package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class TransletOutput extends Instruction { private Expression _filename ; private boolean _append ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "TransletOutput: " + _filename ) ; } public void parseContents ( Parser parser ) { String filename = getAttribute ( "file" ) ; String append = getAttribute ( "append" ) ; if ( ( filename == null ) || ( filename . equals ( EMPTYSTRING ) ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "file" ) ; } _filename = AttributeValue . create ( this , filename , parser ) ; if ( append != null && ( append . toLowerCase ( ) . equals ( "yes" ) || append . toLowerCase ( ) . equals ( "true" ) ) ) { _append = true ; } else _append = false ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type type = _filename . typeCheck ( stable ) ; if ( type instanceof StringType == false ) { _filename = new CastExpr ( _filename , Type . String ) ; } typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; final int open = cpg . addMethodref ( TRANSLET_CLASS , "openOutputHandler" , "(" + STRING_SIG + "Z)" + TRANSLET_OUTPUT_SIG ) ; final int close = cpg . addMethodref ( TRANSLET_CLASS , "closeOutputHandler" , "(" + TRANSLET_OUTPUT_SIG + ")V" ) ; il . append ( classGen . loadTranslet ( ) ) ; _filename . translate ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , _append ) ) ; il . append ( new INVOKEVIRTUAL ( open ) ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( close ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	0	['5', '3', '0', '20', '33', '0', '0', '20', '4', '0.5', '176', '1', '1', '0.933333333', '0.333333333', '2', '7', '33.8', '6', '1.8', '0']
package org . apache . xalan . transformer ; public interface TransformSnapshot { } 	0	['0', '1', '0', '2', '0', '0', '2', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xalan . res ; public class XSLTErrorResources_zh_CN extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "错误：表达式中不能出现  '{'" } , { ER_ILLEGAL_ATTRIBUTE , "{0} 存在一个非法属性： {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode 在  xsl:apply-imports 为空！  " } , { ER_CANNOT_ADD , "无法将  {0} 添加到  {1} 中 " } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode 在  handleApplyTemplatesInstruction 为空！ " } , { ER_NO_NAME_ATTRIB , "{0} 必须具有一个名称属性。 " } , { ER_TEMPLATE_NOT_FOUND , "未找到命名的模板： {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "无法在  xsl:call-template 解析名称  AVI。 " } , { ER_REQUIRES_ATTRIB , "{0} 要求属性： {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} 必须具有一个  ''test'' 属性。 " } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "在级别属性中出现错误数值： {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction 名称不能为  'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction 名称必须是一个有效的  NCName： {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} 必须具有一个与模式相匹配的属性。 " } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} 需要一个名称或匹配属性。 " } , { ER_CANT_RESOLVE_NSPREFIX , "无法解析名称空间前缀： {0}" } , { ER_ILLEGAL_VALUE , "xml:space 存在一个非法数值： {0}" } , { ER_NO_OWNERDOC , "子节点没有一个属主文档！ " } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement 错误： {0}" } , { ER_NULL_CHILD , "正在尝试添加一个空的子节点！ " } , { ER_NEED_SELECT_ATTRIB , "{0} 需要一个选择属性。 " } , { ER_NEED_TEST_ATTRIB , "xsl:when 必须具有一个  'test' 属性。 " } , { ER_NEED_NAME_ATTRIB , "xsl:with-param 必须具有一个  'name' 属性。 " } , { ER_NO_CONTEXT_OWNERDOC , "上下文没有一个属主文档！ " } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "无法创建  XML TransformerFactory Liaison： {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: 运行不成功。 " } , { ER_NOT_SUCCESSFUL , "Xalan: 不成功。 " } , { ER_ENCODING_NOT_SUPPORTED , "不受支持的编码： {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "无法创建  TraceListener： {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key 需要一个  'name' 属性！ " } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key 需要一个  'match' 属性！ " } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key 需要一个  'use' 属性！ " } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} 需要一个  ''elements'' 属性！ " } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} 缺少  ''prefix'' 属性 " } , { ER_BAD_STYLESHEET_URL , "式样表单的  URL 错误： {0}" } , { ER_FILE_NOT_FOUND , "未找到式样表单文件： {0}" } , { ER_IOEXCEPTION , "式样表单文件中存在  IO 异常： {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) 无法在  {0} 中找到  href 属性  " } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} 直接或间接包含自身！ " } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude 错误， {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} 缺少  ''lang'' 属性 " } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) 将  {0} 元素放错位置？？ container 缺少  ''component'' 元素  " } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "仅能输出到  Element、 DocumentFragment、 Document 或  PrintWriter。 " } , { ER_PROCESS_ERROR , "StylesheetRoot.process 错误 " } , { ER_UNIMPLNODE_ERROR , "UnImplNode 错误： {0}" } , { ER_NO_SELECT_EXPRESSION , "错误！未找到  xpath 选择表达式  (-select)。 " } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "无法串行化一个  XSLProcessor！ " } , { ER_NO_INPUT_STYLESHEET , "未指定式样表单输入！ " } , { ER_FAILED_PROCESS_STYLESHEET , "运行式样表单错误！ " } , { ER_COULDNT_PARSE_DOC , "无法分析  {0} 文档！ " } , { ER_COULDNT_FIND_FRAGMENT , "未找到段： {0}" } , { ER_NODE_NOT_ELEMENT , "段标识符指向的节点不是一个元素： {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "每个节点必须具有一个匹配或名称属性 " } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "模板必须具有一个匹配或名称属性 " } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "无法复制文档框架！ " } , { ER_CANT_CREATE_ITEM , "无法在结果树中创建项： {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space 在源  XML 中存在一个非法数值： {0}" } , { ER_NO_XSLKEY_DECLARATION , "在  {0} 中未声明  xsl:key！ " } , { ER_CANT_CREATE_URL , "错误！无法在以下的  {0} 中创建  url： " } , { ER_XSLFUNCTIONS_UNSUPPORTED , "不支持  xsl:functions" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory 错误 " } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "不允许  (StylesheetHandler) {0} 在  stylesheet 的内部！ " } , { ER_RESULTNS_NOT_SUPPORTED , "不再支持  result-ns！请使用  xsl:output 替换。 " } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "不再支持  default-space！请使用  xsl:strip-space 或  xsl:preserve-space 替换。 " } , { ER_INDENTRESULT_NOT_SUPPORTED , "不再支持  indent-result！请使用  xsl:output 替换。 " } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} 存在一个非法属性： {1}" } , { ER_UNKNOWN_XSL_ELEM , "未知的  XSL 元素： {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort 仅能与  xsl:apply-templates 或  xsl:for-each 一起使用。 " } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) 将  xsl:when 放错位置！ " } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when 不是  xsl:choose 的父辈！ " } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) 将  xsl:otherwise 放错位置！ " } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise 不是  xsl:choose 的父辈！ " } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "不允许  (StylesheetHandler) {0} 在模板的内部！ " } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} 扩展名称空间前缀  {1} 未知 " } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) 导入仅能在式样表单中作为第一个元素出现！ " } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} 直接或间接输入自身！ " } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space 存在一个非法数值： {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet 不成功！ " } , { ER_SAX_EXCEPTION , "SAX 异常 " } , { ER_XSLT_ERROR , "XSLT 错误 " } , { ER_CURRENCY_SIGN_ILLEGAL , "在格式模式字符串中不允许出现货币符号 " } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "在  Stylesheet DOM 中不支持文档函数！ " } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "无法分析无前缀分析器的前缀！ " } , { ER_REDIRECT_COULDNT_GET_FILENAME , "重定向扩展：无法得到文件  - 文件或选择属性必须返回有效的字符串。 " } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "无法在重定向扩展中构建  FormatterListener！ " } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "在  exclude-result-prefixes 中的前缀不是有效的： {0}" } , { ER_MISSING_NS_URI , "在指定的前缀中缺少  URI 的名称空间 " } , { ER_MISSING_ARG_FOR_OPTION , "在选项  {0} 中缺少参数： " } , { ER_INVALID_OPTION , "无效的选项： {0}" } , { ER_MALFORMED_FORMAT_STRING , "格式不正确的字符串： {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要一个  'version' 属性！ " } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "属性： {0} 存在一个非法数值： {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose 需要  xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "不允许在  xls:for-each 中出现  xsl:apply-imports" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "无法为一个输出  DOM 节点使用  DTMLiaison...传送一个  org.apache.xpath.DOM2Helper！  " } , { ER_CANT_USE_DTM_FOR_INPUT , "无法为输入  DOM 节点使用  DTMLiaison...传送一个  org.apache.xpath.DOM2Helper！ " } , { ER_CALL_TO_EXT_FAILED , "调用扩展元素错误： {0}" } , { ER_PREFIX_MUST_RESOLVE , "必须将前缀解析为名称空间： {0}" } , { ER_INVALID_UTF16_SURROGATE , "检测到无效的  UTF-16 代理： {0}？  " } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} 被自身使用，将导致无限循环。  " } , { ER_CANNOT_MIX_XERCESDOM , "非  Xerces-DOM 输入与  Xerces-DOM 输出不能混合使用！ " } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "在  ElemTemplateElement.readObject 中： {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "找到多个命名的模板： {0}" } , { ER_INVALID_KEY_CALL , "无效的函数调用：不允许调用递归关键词 ()" } , { ER_REFERENCING_ITSELF , "变量  {0} 正在直接或间接地引用自身！ " } , { ER_ILLEGAL_DOMSOURCE_INPUT , "在  newTemplate 的  DOMSource 中，输入节点不能为空！  " } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "在选项中未找到类文件 {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "未找到需要的元素： {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream 不能为空 " } , { ER_URI_CANNOT_BE_NULL , "URI 不能为空 " } , { ER_FILE_CANNOT_BE_NULL , "File 不能为空 " } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource 不能为空 " } , { ER_CANNOT_INIT_BSFMGR , "无法初始化  BSF 管理器 " } , { ER_CANNOT_CMPL_EXTENSN , "无法编译扩展名 " } , { ER_CANNOT_CREATE_EXTENSN , "由于以下原因： {1}，无法创建扩展名： {0}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , " Instance 调用方法  {0} 时需要将对象实例作为第一个参数。 " } , { ER_INVALID_ELEMENT_NAME , "指定了无效的元素名称  {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "元素名称方法必须是静态的  {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "扩展函数  {0}： {1} 未知 " } , { ER_MORE_MATCH_CONSTRUCTOR , "适用于  {0} 的构造器的多个最佳匹配  " } , { ER_MORE_MATCH_METHOD , "适用于方法  {0} 的多个最佳匹配 " } , { ER_MORE_MATCH_ELEMENT , "适用于元素方法  {0} 的多个最佳匹配 " } , { ER_INVALID_CONTEXT_PASSED , "传送无效的上下文来求值  {0}" } , { ER_POOL_EXISTS , "池已存在 " } , { ER_NO_DRIVER_NAME , "未指定驱动器名称 " } , { ER_NO_URL , "未指定  URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "池的数量不足一个！ " } , { ER_INVALID_DRIVER , "指定了无效的驱动程序名称！ " } , { ER_NO_STYLESHEETROOT , "未找到式样表单的源位置！ " } , { ER_ILLEGAL_XMLSPACE_VALUE , "在  xml:space 中出现非法数值 " } , { ER_PROCESSFROMNODE_FAILED , "processFromNode 失败 " } , { ER_RESOURCE_COULD_NOT_LOAD , "[ {0} ] 资源无法装入： {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "缓冲区大小  <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "调用扩展时出现未知错误 " } , { ER_NO_NAMESPACE_DECL , "前缀  {0} 未声明相应的名称空间 " } , { ER_ELEM_CONTENT_NOT_ALLOWED , "在  lang=javaclass {0} 中不允许出现元素内容 " } , { ER_STYLESHEET_DIRECTED_TERMINATION , "指导式样表单终止 " } , { ER_ONE_OR_TWO , "1 或  2" } , { ER_TWO_OR_THREE , "2 或  3" } , { ER_COULD_NOT_LOAD_RESOURCE , "无法装入  {0}（检查  CLASSPATH），正在使用缺省值 " } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "无法初始化缺省模板 " } , { ER_RESULT_NULL , "结果不应为空 " } , { ER_RESULT_COULD_NOT_BE_SET , "无法设置结果 " } , { ER_NO_OUTPUT_SPECIFIED , "未指定输出 " } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "无法变换到一个类型的结果中  {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "无法变换一个类型源  {0}" } , { ER_NULL_CONTENT_HANDLER , "空的内容句柄 " } , { ER_NULL_ERROR_HANDLER , "空的错误句柄 " } , { ER_CANNOT_CALL_PARSE , "如果未设置  ContentHandler，则无法调用解析 " } , { ER_NO_PARENT_FOR_FILTER , "在过滤器中无父辈 " } , { ER_NO_STYLESHEET_IN_MEDIA , "在  {0}， media= {1} 中未找到式样表单  " } , { ER_NO_STYLESHEET_PI , "在  {0} 中未找到  xml-stylesheet PI：  " } , { ER_NOT_SUPPORTED , "不支持： {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "属性值  {0} 应当是一个布尔实例 " } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "无法在  {0} 中到达外部脚本 " } , { ER_RESOURCE_COULD_NOT_FIND , "未找到  [ {0} ] 资源。 \n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "无法识别输出属性： {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "创建  ElemLiteralResult 实例失败 " } , { ER_VALUE_SHOULD_BE_NUMBER , "{0} 的值应该包含可分析的数字 " } , { ER_VALUE_SHOULD_EQUAL , "{0} 的值应当是“是”或“非” " } , { ER_FAILED_CALLING_METHOD , "调用  {0} 方法失败 " } , { ER_FAILED_CREATING_ELEMTMPL , "创建  ElemTemplateElement 实例失败 " } , { ER_CHARS_NOT_ALLOWED , "在文档此处不允许出现字符 " } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" 属性不允许在  {1} 元素中出现！  " } , { ER_BAD_VALUE , "{0} 错误数值  {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "未找到  {0} 属性值 " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "无法识别  {0} 属性值 " } , { ER_NULL_URI_NAMESPACE , "试图用空  URI 生成名称空间前缀 " } , { ER_NUMBER_TOO_BIG , "试图格式化一个超过最大长整型整数的数 " } , { ER_CANNOT_FIND_SAX1_DRIVER , "找不到  SAX1 驱动程序类  {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "找到  SAX1 驱动程序类  {0} 但无法加载 " } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "加载了  SAX1 驱动程序类  {0} 但无法实例化 " } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 驱动程序类  {0} 无法实现  org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "未指定系统特性  org.xml.sax.parser" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Parser 变量必须为非空 " } , { ER_FEATURE , "特征：一个  {0}" } , { ER_PROPERTY , "特性：一个  {0}" } , { ER_NULL_ENTITY_RESOLVER , "空实体解析程序 " } , { ER_NULL_DTD_HANDLER , "空  DTD 处理程序 " } , { ER_NO_DRIVER_NAME_SPECIFIED , "未指定驱动程序名称！ " } , { ER_NO_URL_SPECIFIED , "未指定  URL！ " } , { ER_POOLSIZE_LESS_THAN_ONE , "池的大小小于  1！ " } , { ER_INVALID_DRIVER_NAME , "指定了无效驱动程序名称！ " } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "程序员错误！ expr 没有  ElemTemplateElement 父类！ " } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "RundundentExprEliminator 中的程序员声明： {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "样式表中的这个位置不允许出现  {0}！ " } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "样式表中的这个位置不允许非空格文本！ " } , { INVALID_TCHAR , "使用了非法值： {1}（在  CHAR 属性  {0} 中）。 CHAR 类型的属性必须只包含  1 个字符！ " } , { INVALID_QNAME , "使用了非法值： {1}（在  QNAME 属性  {0} 中） " } , { INVALID_ENUM , "使用了非法值： {1}（在  ENUM 属性  {0} 中）。有效值为： {2}。 " } , { INVALID_NMTOKEN , "使用了非法值： {1}（在  NMTOKEN 属性  {0} 中）  " } , { INVALID_NCNAME , "使用了非法值： {1}（在  NCNAME 属性  {0} 中）  " } , { INVALID_BOOLEAN , "使用了非法值： {1}（在布尔属性  {0} 中）  " } , { INVALID_NUMBER , "使用了非法值： {1}（在数字属性  {0} 中）  " } , { ER_ARG_LITERAL , "匹配模式中的  {0} 变量必须是文字。 " } , { ER_DUPLICATE_GLOBAL_VAR , "重复的全局变量声明。 " } , { ER_DUPLICATE_VAR , "重复的变量声明。 " } , { ER_TEMPLATE_NAME_MATCH , "xsl:template 必须具有名称或匹配的属性（或同时具有两者） " } , { ER_INVALID_PREFIX , "exclude-result-prefixes 中的前缀无效： {0}" } , { ER_NO_ATTRIB_SET , "不存在名为  {0} 的  attribute-set" } , { WG_FOUND_CURLYBRACE , "已找到  '}'，但未打开属性模板！ " } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "警告： ''count'' 属性与  xsl:number! Target = {0} 中的祖先不匹配 " } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "旧语法： 'expr' 属性的名称已经变为  'select'。 " } , { WG_NO_LOCALE_IN_FORMATNUMBER , " Xalan 仍然无法处理  format-number 函数中的语言环境名称。 " } , { WG_LOCALE_NOT_FOUND , "警告：无法找到  xml:lang={0} 中的语言环境  " } , { WG_CANNOT_MAKE_URL_FROM , "从  {0} 中无法产生  URL：  " } , { WG_CANNOT_LOAD_REQUESTED_DOC , "无法装入请求文档： {0}" } , { WG_CANNOT_FIND_COLLATOR , "在  <sort xml:lang={0} 中无法找到整理机  " } , { WG_FUNCTIONS_SHOULD_USE_URL , "旧语法：函数指令应当使用  {0} 的一个  URL " } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "不受支持的编码： {0}，正在使用  UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "不受支持的编码： {0}，正在  Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "发现专一性冲突： {0} 将使用上次在式样表单中找到的编码。 " } , { WG_PARSING_AND_PREPARING , "========= 分析和准备  {0} ==========" } , { WG_ATTR_TEMPLATE , "属性模板， {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "在  xsl:strip-space 和  xsl:preserve-space 之间出现匹配冲突  " } , { WG_ATTRIB_NOT_HANDLED , "Xalan 仍不处理  {0} 属性！ " } , { WG_NO_DECIMALFORMAT_DECLARATION , "未找到十进制格式的声明： {0}" } , { WG_OLD_XSLT_NS , "缺少或不正确的  XSLT Namespace。  " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "仅允许声明一个缺省  xsl:decimal-format。  " } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format 的名称必须是唯一的。名称  \"{0}\" 已复制。 " } , { WG_ILLEGAL_ATTRIBUTE , "{0} 存在一个非法属性： {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "无法解析名称空间前缀： {0}。忽略节点。 " } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要  'version' 属性！ " } , { WG_ILLEGAL_ATTRIBUTE_NAME , "非法属性名称： {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "在属性中使用非法数值  {0}： {1}" } , { WG_EMPTY_SECOND_ARG , "来自文档属性第二个参数的结果节点集为空。将使用第一个参数。 " } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "xsl:processing-instruction 名称的  'name' 属性值不能为  'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "xsl:processing-instruction 的  ''name'' 属性值必须是一个有效的  NCName:a {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "无法在已经生成子节点之后或在尚未生成元素之前添加属性  {0}。属性将被忽略。 " } , { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "BAD_CODE" , "createMessage 参数超过范围 " } , { "FORMAT_FAILED" , "调用  messageFormat 时出现意外情况   " } , { "version" , ">>>>>>> Xalan 版本  " } , { "version2" , "<<<<<<<" } , { "yes" , "是 " } , { "line" , "行  #" } , { "column" , "列  #" } , { "xsldone" , "XSLProcessor: done" } , { "xslProc_option" , "Xalan-J 命令行运行类选项： " } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER 完全符合分析联络的类名称 ]" } , { "optionE" , "   [-E（不扩展实体引用） ]" } , { "optionV" , "   [-E（不扩展实体引用） ]" } , { "optionQC" , "   [-QC（静止模式冲突警告） ]" } , { "optionQ" , "   [-Q（静止模式） ]" } , { "optionLF" , "   [-LF（仅在输出时使用换行  {缺省为  CR/LF}） ]" } , { "optionCR" , "   [-CR（仅在输出时使用换行  {缺省为  CR/LF}） ]" } , { "optionESCAPE" , "   [-ESCAPE（避免使用的字符  {缺省是  <>&\"\'\\r\\n}） ]" } , { "optionINDENT" , "   [-INDENT（控制缩进空格的数量  {缺省是  0}） ]" } , { "optionTT" , "   [-TT（跟踪调用的模板。） ]" } , { "optionTG" , "   [-TG（跟踪发生事件。） ]" } , { "optionTS" , "   [-TS（跟踪每个选中事件。） ]" } , { "optionTTC" , "   [-TTC（跟踪运行的子模板。） ]" } , { "optionTCLASS" , "   [-TCLASS（用于跟踪扩展名的  TraceListener 类。） ]" } , { "optionVALIDATE" , "   [-VALIDATE（设置是否“确认”。缺省情况下关闭“确认”。） ]" } , { "optionEDUMP" , "   [-EDUMP {可选文件名 }（出现错误时确保栈转储。） ]" } , { "optionXML" , "   [-XML (使用  XML 格式标识符并添加  XML 头。） ]" } , { "optionTEXT" , "   [-TEXT（使用简单的  Text 格式标识符。） ]" } , { "optionHTML" , "   [-HTML（使用  HTML 格式标识符。） ]" } , { "optionPARAM" , "   [-PARAM 名称扩展（设置一个  stylesheet 参数） ]" } , { "noParsermsg1" , "XSL 运行不成功。  " } , { "noParsermsg2" , "** 未找到分析器  **" } , { "noParsermsg3" , "请检查您的类路径。 " } , { "noParsermsg4" , "如果您没有  IBM 用于  Java 的  XML 分析器，您可从 " } , { "noParsermsg5" , "IBM AlphaWorks： http://www.alphaworks.ibm.com/formula/xml 下载。 " } , { "optionURIRESOLVER" , "   [-URIRESOLVER 全类名（ URIResolver 用于分析  URI） ]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER 全类名（ EntityResolver 用于分析实体） ] " } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER 全类名（ ContentHandler 用于串行化输出） ]" } , { "optionLINENUMBERS" , "   [-L 使用源文档的行号 ]" } , { "optionMEDIA" , " [-MEDIA 媒体类型（使用媒体属性查找与某个文档关联的样式表。） ]" } , { "optionFLAVOR" , " [-FLAVOR 风格名称（明确使用  s2s=SAX 或  d2d=DOM 进行变换。） ] " } , { "optionDIAG" , " [-DIAG（打印变换所花的总毫秒数。） ]" } , { "optionINCREMENTAL" , " [-INCREMENTAL（通过将  http://xml.apache.org/xalan/features/incremental 设置为  true 来请求增量式  DTM 构造。） ]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE（通过将  http://xml.apache.org/xalan/features/optimize 设置为  false 来请求无样式表优化处理。） ]" } , { "optionRL" , " [-RL 递归限制（声明样式表递归深度的数字限制。） ]" } , { "optionXO" , " [-XO [translet 名 ]（指定生成的  translet 的名称） ]" } , { "optionXD" , " [-XD 目标目录（指定  translet 的目标目录） ]" } , { "optionXJ" , " [-XJ jar 文件（将  translet 类封装成名称为  <jarfile> 的  jar 文件） ]" } , { "optionXP" , " [-XP 软件包（为所有生成的  translet 类指定软件包名称前缀） ]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "错误：  " ; public static final String WARNING_HEADER = "警告：  " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.423076923', '3769', '0', '0', '0.976190476', '1', '0', '0', '1251', '1', '0.3333', '0']
package org . apache . xalan . xsltc . compiler ; abstract class AttributeValue extends Expression { public static final AttributeValue create ( SyntaxTreeNode parent , String text , Parser parser ) { AttributeValue result ; if ( text . indexOf ( '{' ) != - 1 ) { result = new AttributeValueTemplate ( text , parser , parent ) ; } else if ( text . indexOf ( '}' ) != - 1 ) { result = new AttributeValueTemplate ( text , parser , parent ) ; } else { result = new SimpleAttributeValue ( text ) ; result . setParser ( parser ) ; result . setParent ( parent ) ; } return result ; } } 	0	['2', '3', '2', '10', '8', '1', '7', '5', '1', '2', '44', '0', '0', '0.986111111', '0.5', '0', '0', '21', '3', '1.5', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xml . dtm . DTMAxisIterator ; public final class FilteredStepIterator extends StepIterator { private Filter _filter ; public FilteredStepIterator ( DTMAxisIterator source , DTMAxisIterator iterator , Filter filter ) { super ( source , iterator ) ; _filter = filter ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != END ) { if ( _filter . test ( node ) ) { return returnNode ( node ) ; } } return node ; } } 	0	['2', '3', '0', '3', '6', '0', '0', '3', '2', '0', '28', '1', '1', '0.952380952', '0.666666667', '1', '2', '12.5', '3', '1.5', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class NamespaceAlias extends TopLevelElement { private String sPrefix ; private String rPrefix ; public void parseContents ( Parser parser ) { sPrefix = getAttribute ( "stylesheet-prefix" ) ; rPrefix = getAttribute ( "result-prefix" ) ; parser . getSymbolTable ( ) . addPrefixAlias ( sPrefix , rPrefix ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	0	['4', '3', '0', '8', '8', '6', '1', '7', '3', '1', '30', '1', '0', '0.952380952', '0.4', '2', '4', '6', '1', '0.75', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class ToTextSAXHandler extends ToSAXHandler { public void endElement ( String elemName ) throws SAXException { super . fireEndElem ( elemName ) ; } public void endElement ( String arg0 , String arg1 , String arg2 ) throws SAXException { super . fireEndElem ( arg2 ) ; } public ToTextSAXHandler ( ContentHandler hdlr , LexicalHandler lex , String encoding ) { super ( hdlr , lex , encoding ) ; } public ToTextSAXHandler ( ContentHandler handler , String encoding ) { super ( handler , encoding ) ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { super . fireCommentEvent ( ch , start , length ) ; } public void comment ( String data ) throws org . xml . sax . SAXException { comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } public Properties getOutputFormat ( ) { return null ; } public OutputStream getOutputStream ( ) { return null ; } public Writer getWriter ( ) { return null ; } public void indent ( int n ) throws SAXException { } public boolean reset ( ) { return false ; } public void serialize ( Node node ) throws IOException { } public boolean setEscaping ( boolean escape ) { return false ; } public void setIndent ( boolean indent ) { } public void setOutputFormat ( Properties format ) { } public void setOutputStream ( OutputStream output ) { } public void setWriter ( Writer writer ) { } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) { } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { } public void endPrefixMapping ( String arg0 ) throws SAXException { } public void ignorableWhitespace ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { } public void processingInstruction ( String arg0 , String arg1 ) throws SAXException { super . fireEscapingEvent ( arg0 , arg1 ) ; } public void setDocumentLocator ( Locator arg0 ) { } public void skippedEntity ( String arg0 ) throws SAXException { } public void startElement ( String arg0 , String arg1 , String arg2 , Attributes arg3 ) throws SAXException { flushPending ( ) ; super . startElement ( arg0 , arg1 , arg2 , arg3 ) ; } public void endCDATA ( ) throws SAXException { } public void endDTD ( ) throws SAXException { } public void startCDATA ( ) throws SAXException { } public void startEntity ( String arg0 ) throws SAXException { } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { super . startElement ( elementNamespaceURI , elementLocalName , elementName ) ; } public void startElement ( String elementName ) throws SAXException { super . startElement ( elementName ) ; } public void endDocument ( ) throws SAXException { flushPending ( ) ; m_saxHandler . endDocument ( ) ; super . fireEndDoc ( ) ; } public void characters ( String characters ) throws SAXException { m_saxHandler . characters ( characters . toCharArray ( ) , 0 , characters . length ( ) ) ; } public void characters ( char [ ] characters , int offset , int length ) throws SAXException { m_saxHandler . characters ( characters , offset , length ) ; super . fireCharEvent ( characters , offset , length ) ; } public void addAttribute ( String name , String value ) { } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { return false ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { } } 	0	['41', '3', '0', '3', '56', '814', '2', '1', '41', '2', '161', '0', '0', '0.74', '0.153846154', '2', '6', '2.926829268', '1', '0.9512', '0']
package org . apache . xml . utils ; import java . io . Serializable ; import javax . xml . transform . SourceLocator ; import org . xml . sax . Locator ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . LocatorImpl ; public class SAXSourceLocator extends LocatorImpl implements SourceLocator , Serializable { Locator m_locator ; public SAXSourceLocator ( ) { } public SAXSourceLocator ( Locator locator ) { m_locator = locator ; this . setColumnNumber ( locator . getColumnNumber ( ) ) ; this . setLineNumber ( locator . getLineNumber ( ) ) ; this . setPublicId ( locator . getPublicId ( ) ) ; this . setSystemId ( locator . getSystemId ( ) ) ; } public SAXSourceLocator ( javax . xml . transform . SourceLocator locator ) { m_locator = null ; this . setColumnNumber ( locator . getColumnNumber ( ) ) ; this . setLineNumber ( locator . getLineNumber ( ) ) ; this . setPublicId ( locator . getPublicId ( ) ) ; this . setSystemId ( locator . getSystemId ( ) ) ; } public SAXSourceLocator ( SAXParseException spe ) { this . setLineNumber ( spe . getLineNumber ( ) ) ; this . setColumnNumber ( spe . getColumnNumber ( ) ) ; this . setPublicId ( spe . getPublicId ( ) ) ; this . setSystemId ( spe . getSystemId ( ) ) ; } public String getPublicId ( ) { return ( null == m_locator ) ? super . getPublicId ( ) : m_locator . getPublicId ( ) ; } public String getSystemId ( ) { return ( null == m_locator ) ? super . getSystemId ( ) : m_locator . getSystemId ( ) ; } public int getLineNumber ( ) { return ( null == m_locator ) ? super . getLineNumber ( ) : m_locator . getLineNumber ( ) ; } public int getColumnNumber ( ) { return ( null == m_locator ) ? super . getColumnNumber ( ) : m_locator . getColumnNumber ( ) ; } } 	0	['8', '2', '0', '17', '29', '0', '17', '0', '8', '0.285714286', '119', '0', '0', '0.666666667', '0.34375', '0', '0', '13.75', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . runtime . TransletLoader ; final class FunctionAvailableCall extends FunctionCall { private Expression _arg ; private String _nameOfFunct = null ; private String _namespaceOfFunct = null ; private boolean _isFunctionAvailable = false ; public FunctionAvailableCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _arg = ( Expression ) arguments . elementAt ( 0 ) ; _type = null ; if ( _arg instanceof LiteralExpr ) { LiteralExpr arg = ( LiteralExpr ) _arg ; _namespaceOfFunct = arg . getNamespace ( ) ; _nameOfFunct = arg . getValue ( ) ; if ( ! isInternalNamespace ( ) ) { _isFunctionAvailable = hasMethods ( ) ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) { return _type ; } if ( _arg instanceof LiteralExpr ) { return _type = Type . Boolean ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . NEED_LITERAL_ERR , "function-available" , this ) ; throw new TypeCheckError ( err ) ; } public Object evaluateAtCompileTime ( ) { return getResult ( ) ? Boolean . TRUE : Boolean . FALSE ; } private boolean hasMethods ( ) { LiteralExpr arg = ( LiteralExpr ) _arg ; String className = getClassNameFromUri ( _namespaceOfFunct ) ; String methodName = null ; int colonIndex = _nameOfFunct . indexOf ( ":" ) ; if ( colonIndex > 0 ) { String functionName = _nameOfFunct . substring ( colonIndex + 1 ) ; int lastDotIndex = functionName . lastIndexOf ( '.' ) ; if ( lastDotIndex > 0 ) { methodName = functionName . substring ( lastDotIndex + 1 ) ; if ( className != null && ! className . equals ( "" ) ) className = className + "." + functionName . substring ( 0 , lastDotIndex ) ; else className = functionName . substring ( 0 , lastDotIndex ) ; } else methodName = functionName ; } else methodName = _nameOfFunct ; if ( className == null || methodName == null ) { return false ; } if ( methodName . indexOf ( '-' ) > 0 ) methodName = replaceDash ( methodName ) ; try { TransletLoader loader = new TransletLoader ( ) ; final Class clazz = loader . loadClass ( className ) ; if ( clazz == null ) { return false ; } else { final Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final int mods = methods [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && Modifier . isStatic ( mods ) && methods [ i ] . getName ( ) . equals ( methodName ) ) { return true ; } } } } catch ( ClassNotFoundException e ) { return false ; } return false ; } public boolean getResult ( ) { if ( _nameOfFunct == null ) { return false ; } if ( isInternalNamespace ( ) ) { final Parser parser = getParser ( ) ; _isFunctionAvailable = parser . functionSupported ( Util . getLocalName ( _nameOfFunct ) ) ; } return _isFunctionAvailable ; } private boolean isInternalNamespace ( ) { return ( _namespaceOfFunct == null || _namespaceOfFunct . equals ( EMPTYSTRING ) || _namespaceOfFunct . equals ( TRANSLET_URI ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; methodGen . getInstructionList ( ) . append ( new PUSH ( cpg , getResult ( ) ) ) ; } } 	0	['7', '4', '0', '19', '38', '7', '0', '19', '5', '0.458333333', '275', '1', '1', '0.941176471', '0.285714286', '3', '13', '37.71428571', '12', '3.2857', '0']
package org . apache . xalan . transformer ; import java . util . Enumeration ; import java . util . Stack ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . NamespaceSupport2 ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . ObjectStack ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . xml . sax . helpers . NamespaceSupport ; import org . apache . xml . serializer . NamespaceMappings ; import org . apache . xml . serializer . SerializationHandler ; class TransformSnapshotImpl implements TransformSnapshot { private VariableStack m_variableStacks ; private IntStack m_currentNodes ; private IntStack m_currentExpressionNodes ; private Stack m_contextNodeLists ; private DTMIterator m_contextNodeList ; private Stack m_axesIteratorStack ; private BoolStack m_currentTemplateRuleIsNull ; private ObjectStack m_currentTemplateElements ; private Stack m_currentMatchTemplates ; private NodeVector m_currentMatchNodes ; private CountersTable m_countersTable ; private Stack m_attrSetStack ; boolean m_nsContextPushed ; private NamespaceMappings m_nsSupport ; TransformSnapshotImpl ( TransformerImpl transformer ) { try { SerializationHandler rtf = transformer . getResultTreeHandler ( ) ; { m_nsSupport = ( NamespaceMappings ) rtf . getNamespaceMappings ( ) . clone ( ) ; } XPathContext xpc = transformer . getXPathContext ( ) ; m_variableStacks = ( VariableStack ) xpc . getVarStack ( ) . clone ( ) ; m_currentNodes = ( IntStack ) xpc . getCurrentNodeStack ( ) . clone ( ) ; m_currentExpressionNodes = ( IntStack ) xpc . getCurrentExpressionNodeStack ( ) . clone ( ) ; m_contextNodeLists = ( Stack ) xpc . getContextNodeListsStack ( ) . clone ( ) ; if ( ! m_contextNodeLists . empty ( ) ) m_contextNodeList = ( DTMIterator ) xpc . getContextNodeList ( ) . clone ( ) ; m_axesIteratorStack = ( Stack ) xpc . getAxesIteratorStackStacks ( ) . clone ( ) ; m_currentTemplateRuleIsNull = ( BoolStack ) transformer . m_currentTemplateRuleIsNull . clone ( ) ; m_currentTemplateElements = ( ObjectStack ) transformer . m_currentTemplateElements . clone ( ) ; m_currentMatchTemplates = ( Stack ) transformer . m_currentMatchTemplates . clone ( ) ; m_currentMatchNodes = ( NodeVector ) transformer . m_currentMatchedNodes . clone ( ) ; m_countersTable = ( CountersTable ) transformer . getCountersTable ( ) . clone ( ) ; if ( transformer . m_attrSetStack != null ) m_attrSetStack = ( Stack ) transformer . m_attrSetStack . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } void apply ( TransformerImpl transformer ) { try { SerializationHandler rtf = transformer . getResultTreeHandler ( ) ; if ( rtf != null ) { rtf . setNamespaceMappings ( ( NamespaceMappings ) m_nsSupport . clone ( ) ) ; } XPathContext xpc = transformer . getXPathContext ( ) ; xpc . setVarStack ( ( VariableStack ) m_variableStacks . clone ( ) ) ; xpc . setCurrentNodeStack ( ( IntStack ) m_currentNodes . clone ( ) ) ; xpc . setCurrentExpressionNodeStack ( ( IntStack ) m_currentExpressionNodes . clone ( ) ) ; xpc . setContextNodeListsStack ( ( Stack ) m_contextNodeLists . clone ( ) ) ; if ( m_contextNodeList != null ) xpc . pushContextNodeList ( ( DTMIterator ) m_contextNodeList . clone ( ) ) ; xpc . setAxesIteratorStackStacks ( ( Stack ) m_axesIteratorStack . clone ( ) ) ; transformer . m_currentTemplateRuleIsNull = ( BoolStack ) m_currentTemplateRuleIsNull . clone ( ) ; transformer . m_currentTemplateElements = ( ObjectStack ) m_currentTemplateElements . clone ( ) ; transformer . m_currentMatchTemplates = ( Stack ) m_currentMatchTemplates . clone ( ) ; transformer . m_currentMatchedNodes = ( NodeVector ) m_currentMatchNodes . clone ( ) ; transformer . m_countersTable = ( CountersTable ) m_countersTable . clone ( ) ; if ( m_attrSetStack != null ) transformer . m_attrSetStack = ( Stack ) m_attrSetStack . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } } 	0	['2', '1', '0', '13', '31', '0', '1', '13', '0', '0.142857143', '217', '0.928571429', '9', '0', '1', '0', '0', '100.5', '3', '1.5', '0']
package org . apache . xml . res ; public class XMLErrorResources_ko extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "기능이 지원되지 않습니다!" } , { ER_CANNOT_OVERWRITE_CAUSE , "겹쳐쓸 수 없습니다" } , { ER_NO_DEFAULT_IMPL , "기본 구현을 찾을 수 없습니다" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0})는 현재 지원되지 않습니다." } , { ER_OFFSET_BIGGER_THAN_SLOT , "오프셋이 슬롯보다 큽니다" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine은 사용할 수 없습니다, ID={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager가 co_exit() 요청을 수신했습니다" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet()이 실패했습니다" } , { ER_COROUTINE_PARAM , "Coroutine 매개변수 오류({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\n예상치 못한 문제: doTerminate 구문 분석기가 {0}에 응답했습니다. " } , { ER_NO_PARSE_CALL_WHILE_PARSING , "구문 분석하는 동안에는 구문 분석을 호출할 수 없습니다" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "오류: {0} 축에 대해 입력된 반복기가 구현되지 않습니다." } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "오류: {0} 축에 대한 반복기가 구현되지 않습니다. " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "반복기 복제가 지원되지 않습니다" } , { ER_UNKNOWN_AXIS_TYPE , "알 수 없는 축 순회 유형: {0}" } , { ER_AXIS_NOT_SUPPORTED , "축 순회기가 지원되지 않습니다: {0}" } , { ER_NO_DTMIDS_AVAIL , "더 이상 DTM ID를 사용할 수 없습니다." } , { ER_NOT_SUPPORTED , "지원되지 않습니다: {0}" } , { ER_NODE_NON_NULL , "노드는 getDTMHandleFromNode에 대해 널이 아니어야 합니다" } , { ER_COULD_NOT_RESOLVE_NODE , "노드를 핸들로 변환할 수 없습니다" } , { ER_STARTPARSE_WHILE_PARSING , "startParse는 구문 분석 중에 호출될 수 없습니다" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse에는 널이 아닌 SAXParser가 필요합니다" } , { ER_COULD_NOT_INIT_PARSER , "다음으로 구문 분석기를 초기화할 수 없습니다: " } , { ER_EXCEPTION_CREATING_POOL , "풀에 대한 새 인스턴스 작성 중 예외가 발생했습니다" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "경로에 잘못된 제어 문자열이 포함되어 있습니다" } , { ER_SCHEME_REQUIRED , "체계가 필요합니다!" } , { ER_NO_SCHEME_IN_URI , "URI에  체계가 없습니다: {0}" } , { ER_NO_SCHEME_INURI , "URI에 체계가 없습니다" } , { ER_PATH_INVALID_CHAR , "경로에 잘못된 문자 {0}이(가) 포함되어 있습니다." } , { ER_SCHEME_FROM_NULL_STRING , "널 문자열에서 체계를 설정할 수 없습니다" } , { ER_SCHEME_NOT_CONFORMANT , "체계가 일치하지 않습니다." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "호스트 주소가 올바른 형식이 아닙니다" } , { ER_PORT_WHEN_HOST_NULL , "호스트가 널이면 포트를 설정할 수 없습니다" } , { ER_INVALID_PORT , "잘못된 포트 번호입니다" } , { ER_FRAG_FOR_GENERIC_URI , "단편은 일반 URI에 대해서만 설정될 수 있습니다" } , { ER_FRAG_WHEN_PATH_NULL , "경로가 널이면 단편을 설정할 수 없습니다" } , { ER_FRAG_INVALID_CHAR , "단편에 잘못된 문자가 포함되어 있습니다" } , { ER_PARSER_IN_USE , "구문 분석기가 이미 사용 중입니다" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "구문 분석 중에는 {0} {1}을(를) 변경할 수 없습니다" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "자체 원인 제공은 허용되지 않습니다" } , { ER_NO_USERINFO_IF_NO_HOST , "호스트가 지정되어 있지 않으면 Userinfo를 지정할 수 없습니다" } , { ER_NO_PORT_IF_NO_HOST , "호스트가 지정되어 있지 않으면 포트를 지정할 수 없습니다" } , { ER_NO_QUERY_STRING_IN_PATH , "질의 문자열을 경로 또는 질의 문자열 내에 지정할 수 없습니다" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "단편을 경로와 단편 모두에 지정할 수는 없습니다" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "빈 매개변수로는 URI를 초기화할 수 없습니다" } , { ER_METHOD_NOT_SUPPORTED , "지원되지 않는 메소드입니다 " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter를 다시 시작할 수 없습니다" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "startParse 요청 전에 XMLReader를 수행할 수 없습니다" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "축 트래버서가 지원되지 않음: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler가 널 PrintWriter로 작성됨!" } , { ER_SYSTEMID_UNKNOWN , "시스템 ID를 알 수 없음" } , { ER_LOCATION_UNKNOWN , "오류 위치를 알 수 없음" } , { ER_PREFIX_MUST_RESOLVE , "접두어가 이름 공간 {0}으로(로) 결정되어야 합니다." } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument()는 XPathContext에서 지원되지 않습니다!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "자식 속성에 소유자 문서가 없습니다!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "자식 속성에 소유자 문서 요소가 없습니다!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "경고: 문서 요소 전에 텍스트를 출력할 수 없습니다! 무시됩니다..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "DOM에 두 개 이상의 루트를 가질 수 없습니다!" } , { ER_ARG_LOCALNAME_NULL , "'localName' 인자가 널입니다" } , { ER_ARG_LOCALNAME_INVALID , "QNAME의 로컬 이름은 유효한 NCName이어야 합니다." } , { ER_ARG_PREFIX_INVALID , "QNAME의 접두어는 유효한 NCName이어야 합니다." } , { "BAD_CODE" , "createMessage의 매개변수가 바운드를 벗어났습니다." } , { "FORMAT_FAILED" , "messageFormat 호출 시 예외 발생" } , { "line" , "행 #" } , { "column" , "열 #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '0']
package org . apache . xml . dtm . ref ; public final class ExtendedType { private int nodetype ; private String namespace ; private String localName ; private int hash ; public ExtendedType ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; } public ExtendedType ( int nodetype , String namespace , String localName , int hash ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = hash ; } protected void redefine ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; } protected void redefine ( int nodetype , String namespace , String localName , int hash ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = hash ; } public int hashCode ( ) { return hash ; } public boolean equals ( ExtendedType other ) { try { return other . nodetype == this . nodetype && other . localName . equals ( this . localName ) && other . namespace . equals ( this . namespace ) ; } catch ( NullPointerException e ) { return false ; } } public int getNodeType ( ) { return nodetype ; } public String getLocalName ( ) { return localName ; } public String getNamespace ( ) { return namespace ; } } 	0	['9', '1', '0', '8', '12', '0', '8', '0', '7', '0.40625', '117', '1', '0', '0', '0.5', '1', '2', '11.55555556', '4', '1.1111', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DUP_X1 ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . DOM ; import org . xml . sax . Attributes ; public abstract class SyntaxTreeNode implements Constants { private Parser _parser ; protected SyntaxTreeNode _parent ; private Stylesheet _stylesheet ; private Template _template ; private final Vector _contents = new Vector ( 2 ) ; protected QName _qname ; private int _line ; protected Attributes _attributes = null ; private Hashtable _prefixMapping = null ; protected static final SyntaxTreeNode Dummy = new AbsolutePathPattern ( null ) ; protected static final int IndentIncrement = 4 ; private static final char [ ] _spaces = "                                                       " . toCharArray ( ) ; public SyntaxTreeNode ( ) { _line = 0 ; _qname = null ; } public SyntaxTreeNode ( int line ) { _line = line ; _qname = null ; } public SyntaxTreeNode ( String uri , String prefix , String local ) { _line = 0 ; setQName ( uri , prefix , local ) ; } protected final void setLineNumber ( int line ) { _line = line ; } public final int getLineNumber ( ) { return _line ; } protected void setQName ( QName qname ) { _qname = qname ; } protected void setQName ( String uri , String prefix , String localname ) { _qname = new QName ( uri , prefix , localname ) ; } protected QName getQName ( ) { return ( _qname ) ; } protected void setAttributes ( Attributes attributes ) { _attributes = attributes ; } protected String getAttribute ( String qname ) { if ( _attributes == null ) { return EMPTYSTRING ; } final String value = _attributes . getValue ( qname ) ; return ( value == null || value . equals ( EMPTYSTRING ) ) ? EMPTYSTRING : value ; } protected boolean hasAttribute ( String qname ) { return ( _attributes != null && _attributes . getValue ( qname ) != null ) ; } protected Attributes getAttributes ( ) { return ( _attributes ) ; } protected void setPrefixMapping ( Hashtable mapping ) { _prefixMapping = mapping ; } protected Hashtable getPrefixMapping ( ) { return _prefixMapping ; } protected void addPrefixMapping ( String prefix , String uri ) { if ( _prefixMapping == null ) _prefixMapping = new Hashtable ( ) ; _prefixMapping . put ( prefix , uri ) ; } protected String lookupNamespace ( String prefix ) { String uri = null ; if ( _prefixMapping != null ) uri = ( String ) _prefixMapping . get ( prefix ) ; if ( ( uri == null ) && ( _parent != null ) ) { uri = _parent . lookupNamespace ( prefix ) ; if ( ( prefix == Constants . EMPTYSTRING ) && ( uri == null ) ) uri = Constants . EMPTYSTRING ; } return ( uri ) ; } protected String lookupPrefix ( String uri ) { String prefix = null ; if ( ( _prefixMapping != null ) && ( _prefixMapping . contains ( uri ) ) ) { Enumeration prefixes = _prefixMapping . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { prefix = ( String ) prefixes . nextElement ( ) ; String mapsTo = ( String ) _prefixMapping . get ( prefix ) ; if ( mapsTo . equals ( uri ) ) return ( prefix ) ; } } else if ( _parent != null ) { prefix = _parent . lookupPrefix ( uri ) ; if ( ( uri == Constants . EMPTYSTRING ) && ( prefix == null ) ) prefix = Constants . EMPTYSTRING ; } return ( prefix ) ; } protected void setParser ( Parser parser ) { _parser = parser ; } public final Parser getParser ( ) { return _parser ; } protected void setParent ( SyntaxTreeNode parent ) { if ( _parent == null ) _parent = parent ; } protected final SyntaxTreeNode getParent ( ) { return _parent ; } protected final boolean isDummy ( ) { return this == Dummy ; } protected int getImportPrecedence ( ) { Stylesheet stylesheet = getStylesheet ( ) ; if ( stylesheet == null ) return Integer . MIN_VALUE ; return stylesheet . getImportPrecedence ( ) ; } public Stylesheet getStylesheet ( ) { if ( _stylesheet == null ) { SyntaxTreeNode parent = this ; while ( parent != null ) { if ( parent instanceof Stylesheet ) return ( ( Stylesheet ) parent ) ; parent = parent . getParent ( ) ; } _stylesheet = ( Stylesheet ) parent ; } return ( _stylesheet ) ; } protected Template getTemplate ( ) { if ( _template == null ) { SyntaxTreeNode parent = this ; while ( ( parent != null ) && ( ! ( parent instanceof Template ) ) ) parent = parent . getParent ( ) ; _template = ( Template ) parent ; } return ( _template ) ; } protected final XSLTC getXSLTC ( ) { return _parser . getXSLTC ( ) ; } protected final SymbolTable getSymbolTable ( ) { return ( _parser == null ) ? null : _parser . getSymbolTable ( ) ; } public void parseContents ( Parser parser ) { parseChildren ( parser ) ; } protected final void parseChildren ( Parser parser ) { Vector locals = null ; final int count = _contents . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; final QName varOrParamName = updateScope ( parser , child ) ; if ( varOrParamName != null ) { if ( locals == null ) { locals = new Vector ( 2 ) ; } locals . addElement ( varOrParamName ) ; } } parser . getSymbolTable ( ) . setCurrentNode ( this ) ; if ( locals != null ) { final int nLocals = locals . size ( ) ; for ( int i = 0 ; i < nLocals ; i ++ ) { parser . removeVariable ( ( QName ) locals . elementAt ( i ) ) ; } } } protected QName updateScope ( Parser parser , SyntaxTreeNode node ) { if ( node instanceof Variable ) { final Variable var = ( Variable ) node ; parser . addVariable ( var ) ; return var . getName ( ) ; } else if ( node instanceof Param ) { final Param param = ( Param ) node ; parser . addParameter ( param ) ; return param . getName ( ) ; } else { return null ; } } public abstract Type typeCheck ( SymbolTable stable ) throws TypeCheckError ; protected Type typeCheckContents ( SymbolTable stable ) throws TypeCheckError { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; item . typeCheck ( stable ) ; } return Type . Void ; } public abstract void translate ( ClassGenerator classGen , MethodGenerator methodGen ) ; protected void translateContents ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; item . translate ( classGen , methodGen ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( _contents . elementAt ( i ) instanceof VariableBase ) { final VariableBase var = ( VariableBase ) _contents . elementAt ( i ) ; var . unmapRegister ( methodGen ) ; } } } private boolean isSimpleRTF ( SyntaxTreeNode node ) { Vector contents = node . getContents ( ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! isTextElement ( item , false ) ) return false ; } return true ; } private boolean isAdaptiveRTF ( SyntaxTreeNode node ) { Vector contents = node . getContents ( ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! isTextElement ( item , true ) ) return false ; } return true ; } private boolean isTextElement ( SyntaxTreeNode node , boolean doExtendedCheck ) { if ( node instanceof ValueOf || node instanceof Number || node instanceof Text ) { return true ; } else if ( node instanceof If ) { return doExtendedCheck ? isAdaptiveRTF ( node ) : isSimpleRTF ( node ) ; } else if ( node instanceof Choose ) { Vector contents = node . getContents ( ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( item instanceof Text || ( ( item instanceof When || item instanceof Otherwise ) && ( ( doExtendedCheck && isAdaptiveRTF ( item ) ) || ( ! doExtendedCheck && isSimpleRTF ( item ) ) ) ) ) continue ; else return false ; } return true ; } else if ( doExtendedCheck && ( node instanceof CallTemplate || node instanceof ApplyTemplates ) ) return true ; else return false ; } protected void compileResultTree ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final Stylesheet stylesheet = classGen . getStylesheet ( ) ; boolean isSimple = isSimpleRTF ( this ) ; boolean isAdaptive = false ; if ( ! isSimple ) { isAdaptive = isAdaptiveRTF ( this ) ; } int rtfType = isSimple ? DOM . SIMPLE_RTF : ( isAdaptive ? DOM . ADAPTIVE_RTF : DOM . TREE_RTF ) ; il . append ( methodGen . loadHandler ( ) ) ; final String DOM_CLASS = classGen . getDOMClass ( ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , "getResultTreeFrag" , "(II)" + DOM_INTF_SIG ) ; il . append ( new PUSH ( cpg , RTF_INITIAL_SIZE ) ) ; il . append ( new PUSH ( cpg , rtfType ) ) ; il . append ( new INVOKEINTERFACE ( index , 3 ) ) ; il . append ( DUP ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , "getOutputDomBuilder" , "()" + TRANSLET_OUTPUT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; il . append ( methodGen . startDocument ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . endDocument ( ) ) ; if ( ( ! isSimple || stylesheet . callsNodeset ( ) ) && ! DOM_CLASS . equals ( DOM_IMPL_CLASS ) ) { index = cpg . addMethodref ( DOM_ADAPTER_CLASS , "<init>" , "(" + DOM_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( DOM_ADAPTER_CLASS ) ) ) ; il . append ( new DUP_X1 ( ) ) ; il . append ( SWAP ) ; if ( ! stylesheet . callsNodeset ( ) ) { il . append ( new ICONST ( 0 ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( index ) ) ; } else { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new CHECKCAST ( cpg . addClass ( classGen . getDOMClass ( ) ) ) ) ; il . append ( SWAP ) ; index = cpg . addMethodref ( MULTI_DOM_CLASS , "addDOMAdapter" , "(" + DOM_ADAPTER_SIG + ")I" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( POP ) ; } } il . append ( SWAP ) ; il . append ( methodGen . storeHandler ( ) ) ; } protected boolean contextDependent ( ) { return true ; } protected boolean dependentContents ( ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; if ( item . contextDependent ( ) ) { return true ; } } return false ; } protected final void addElement ( SyntaxTreeNode element ) { _contents . addElement ( element ) ; element . setParent ( this ) ; } protected final void setFirstElement ( SyntaxTreeNode element ) { _contents . insertElementAt ( element , 0 ) ; element . setParent ( this ) ; } protected final void removeElement ( SyntaxTreeNode element ) { _contents . remove ( element ) ; element . setParent ( null ) ; } protected final Vector getContents ( ) { return _contents ; } protected final boolean hasContents ( ) { return elementCount ( ) > 0 ; } protected final int elementCount ( ) { return _contents . size ( ) ; } protected final Enumeration elements ( ) { return _contents . elements ( ) ; } protected final Object elementAt ( int pos ) { return _contents . elementAt ( pos ) ; } protected final SyntaxTreeNode lastChild ( ) { if ( _contents . size ( ) == 0 ) return null ; return ( SyntaxTreeNode ) _contents . lastElement ( ) ; } public void display ( int indent ) { displayContents ( indent ) ; } protected void displayContents ( int indent ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; item . display ( indent ) ; } } protected final void indent ( int indent ) { System . out . print ( new String ( _spaces , 0 , indent ) ) ; } protected void reportError ( SyntaxTreeNode element , Parser parser , String errorCode , String message ) { final ErrorMsg error = new ErrorMsg ( errorCode , message , element ) ; parser . reportError ( Constants . ERROR , error ) ; } protected void reportWarning ( SyntaxTreeNode element , Parser parser , String errorCode , String message ) { final ErrorMsg error = new ErrorMsg ( errorCode , message , element ) ; parser . reportError ( Constants . WARNING , error ) ; } } 	0	['55', '1', '5', '97', '116', '1101', '74', '43', '10', '0.912037037', '1105', '1', '6', '0', '0.149691358', '0', '0', '18.87272727', '18', '2.1818', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DLOAD ; import org . apache . bcel . generic . DSTORE ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionConstants ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public final class RealType extends NumberType { protected RealType ( ) { } public String toString ( ) { return "real" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "D" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . DOUBLE ; } public int distanceTo ( Type type ) { if ( type == this ) { return 0 ; } else if ( type == Type . Int ) { return 1 ; } else { return Integer . MAX_VALUE ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Int ) { translateTo ( classGen , methodGen , ( IntType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "realToString" , "(D)" + STRING_SIG ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , IntType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "realToInt" , "(D)I" ) ) ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { LocalVariableGen local ; final FlowList flowlist = new FlowList ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP2 ) ; local = methodGen . addLocalVariable ( "real_to_boolean_tmp" , org . apache . bcel . generic . Type . DOUBLE , il . getEnd ( ) , null ) ; il . append ( new DSTORE ( local . getIndex ( ) ) ) ; il . append ( DCONST_0 ) ; il . append ( DCMPG ) ; flowlist . add ( il . append ( new IFEQ ( null ) ) ) ; il . append ( new DLOAD ( local . getIndex ( ) ) ) ; il . append ( new DLOAD ( local . getIndex ( ) ) ) ; il . append ( DCMPG ) ; flowlist . add ( il . append ( new IFNE ( null ) ) ) ; return flowlist ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( DOUBLE_CLASS ) ) ) ; il . append ( DUP_X2 ) ; il . append ( DUP_X2 ) ; il . append ( POP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( DOUBLE_CLASS , "<init>" , "(D)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , final Class clazz ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz == Character . TYPE ) { il . append ( D2I ) ; il . append ( I2C ) ; } else if ( clazz == Byte . TYPE ) { il . append ( D2I ) ; il . append ( I2B ) ; } else if ( clazz == Short . TYPE ) { il . append ( D2I ) ; il . append ( I2S ) ; } else if ( clazz == Integer . TYPE ) { il . append ( D2I ) ; } else if ( clazz == Long . TYPE ) { il . append ( D2L ) ; } else if ( clazz == Float . TYPE ) { il . append ( D2F ) ; } else if ( clazz == Double . TYPE ) { il . append ( NOP ) ; } else if ( clazz . isAssignableFrom ( java . lang . Double . class ) ) { translateTo ( classGen , methodGen , Type . Reference ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz == Character . TYPE || clazz == Byte . TYPE || clazz == Short . TYPE || clazz == Integer . TYPE ) { il . append ( I2D ) ; } else if ( clazz == Long . TYPE ) { il . append ( L2D ) ; } else if ( clazz == Float . TYPE ) { il . append ( F2D ) ; } else if ( clazz == Double . TYPE ) { il . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( DOUBLE_CLASS ) ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( DOUBLE_CLASS , DOUBLE_VALUE , DOUBLE_VALUE_SIG ) ) ) ; } public Instruction ADD ( ) { return InstructionConstants . DADD ; } public Instruction SUB ( ) { return InstructionConstants . DSUB ; } public Instruction MUL ( ) { return InstructionConstants . DMUL ; } public Instruction DIV ( ) { return InstructionConstants . DDIV ; } public Instruction REM ( ) { return InstructionConstants . DREM ; } public Instruction NEG ( ) { return InstructionConstants . DNEG ; } public Instruction LOAD ( int slot ) { return new DLOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new DSTORE ( slot ) ; } public Instruction POP ( ) { return POP2 ; } public Instruction CMP ( boolean less ) { return less ? InstructionConstants . DCMPG : InstructionConstants . DCMPL ; } public Instruction DUP ( ) { return DUP2 ; } } 	0	['28', '3', '0', '42', '61', '370', '13', '34', '26', '1', '533', '0', '0', '0.564516129', '0.181547619', '1', '3', '18', '10', '1.8214', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Or extends Operation { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject expr1 = m_left . execute ( xctxt ) ; if ( ! expr1 . bool ( ) ) { XObject expr2 = m_right . execute ( xctxt ) ; return expr2 . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } else return XBoolean . S_TRUE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . bool ( xctxt ) || m_right . bool ( xctxt ) ) ; } } 	0	['3', '3', '0', '6', '7', '1', '1', '5', '3', '2', '42', '0', '0', '0.953488372', '0.833333333', '1', '6', '13', '1', '0.6667', '0']
package org . apache . xalan . xsltc ; import org . xml . sax . SAXException ; public final class TransletException extends SAXException { public TransletException ( ) { super ( "Translet error" ) ; } public TransletException ( Exception e ) { super ( e . toString ( ) ) ; } public TransletException ( String message ) { super ( message ) ; } } 	0	['3', '4', '0', '13', '5', '3', '13', '0', '3', '2', '16', '0', '0', '1', '0.555555556', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . xalan . xsltc . runtime ; import java . util . Enumeration ; class HashtableEntry { int hash ; Object key ; Object value ; HashtableEntry next ; protected Object clone ( ) { HashtableEntry entry = new HashtableEntry ( ) ; entry . hash = hash ; entry . key = key ; entry . value = value ; entry . next = ( next != null ) ? ( HashtableEntry ) next . clone ( ) : null ; return entry ; } } public class Hashtable { private transient HashtableEntry table [ ] ; private transient int count ; private int threshold ; private float loadFactor ; public Hashtable ( int initialCapacity , float loadFactor ) { if ( initialCapacity <= 0 ) initialCapacity = 11 ; if ( loadFactor <= 0.0 ) loadFactor = 0.75f ; this . loadFactor = loadFactor ; table = new HashtableEntry [ initialCapacity ] ; threshold = ( int ) ( initialCapacity * loadFactor ) ; } public Hashtable ( int initialCapacity ) { this ( initialCapacity , 0.75f ) ; } public Hashtable ( ) { this ( 101 , 0.75f ) ; } public int size ( ) { return count ; } public boolean isEmpty ( ) { return count == 0 ; } public Enumeration keys ( ) { return new HashtableEnumerator ( table , true ) ; } public Enumeration elements ( ) { return new HashtableEnumerator ( table , false ) ; } public boolean contains ( Object value ) { if ( value == null ) throw new NullPointerException ( ) ; int i ; HashtableEntry e ; HashtableEntry tab [ ] = table ; for ( i = tab . length ; i -- > 0 ; ) { for ( e = tab [ i ] ; e != null ; e = e . next ) { if ( e . value . equals ( value ) ) { return true ; } } } return false ; } public boolean containsKey ( Object key ) { HashtableEntry e ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] ; e != null ; e = e . next ) if ( ( e . hash == hash ) && e . key . equals ( key ) ) return true ; return false ; } public Object get ( Object key ) { HashtableEntry e ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] ; e != null ; e = e . next ) if ( ( e . hash == hash ) && e . key . equals ( key ) ) return e . value ; return null ; } protected void rehash ( ) { HashtableEntry e , old ; int i , index ; int oldCapacity = table . length ; HashtableEntry oldTable [ ] = table ; int newCapacity = oldCapacity * 2 + 1 ; HashtableEntry newTable [ ] = new HashtableEntry [ newCapacity ] ; threshold = ( int ) ( newCapacity * loadFactor ) ; table = newTable ; for ( i = oldCapacity ; i -- > 0 ; ) { for ( old = oldTable [ i ] ; old != null ; ) { e = old ; old = old . next ; index = ( e . hash & 0x7FFFFFFF ) % newCapacity ; e . next = newTable [ index ] ; newTable [ index ] = e ; } } } public Object put ( Object key , Object value ) { if ( value == null ) throw new NullPointerException ( ) ; HashtableEntry e ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] ; e != null ; e = e . next ) { if ( ( e . hash == hash ) && e . key . equals ( key ) ) { Object old = e . value ; e . value = value ; return old ; } } if ( count >= threshold ) { rehash ( ) ; return put ( key , value ) ; } e = new HashtableEntry ( ) ; e . hash = hash ; e . key = key ; e . value = value ; e . next = tab [ index ] ; tab [ index ] = e ; count ++ ; return null ; } public Object remove ( Object key ) { HashtableEntry e , prev ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( ( e . hash == hash ) && e . key . equals ( key ) ) { if ( prev != null ) prev . next = e . next ; else tab [ index ] = e . next ; count -- ; return e . value ; } } return null ; } public void clear ( ) { HashtableEntry tab [ ] = table ; for ( int index = tab . length ; -- index >= 0 ; ) tab [ index ] = null ; count = 0 ; } public String toString ( ) { int i ; int max = size ( ) - 1 ; StringBuffer buf = new StringBuffer ( ) ; Enumeration k = keys ( ) ; Enumeration e = elements ( ) ; buf . append ( "{" ) ; for ( i = 0 ; i <= max ; i ++ ) { String s1 = k . nextElement ( ) . toString ( ) ; String s2 = e . nextElement ( ) . toString ( ) ; buf . append ( s1 + "=" + s2 ) ; if ( i < max ) buf . append ( ", " ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } class HashtableEnumerator implements Enumeration { boolean keys ; int index ; HashtableEntry table [ ] ; HashtableEntry entry ; HashtableEnumerator ( HashtableEntry table [ ] , boolean keys ) { this . table = table ; this . keys = keys ; this . index = table . length ; } public boolean hasMoreElements ( ) { if ( entry != null ) { return true ; } while ( index -- > 0 ) { if ( ( entry = table [ index ] ) != null ) { return true ; } } return false ; } public Object nextElement ( ) { if ( entry == null ) { while ( ( index -- > 0 ) && ( ( entry = table [ index ] ) == null ) ) ; } if ( entry != null ) { HashtableEntry e = entry ; entry = e . next ; return keys ? e . key : e . value ; } return null ; } } } 	0	['15', '1', '0', '13', '26', '1', '12', '2', '14', '0.553571429', '477', '1', '1', '0', '0.383333333', '0', '0', '30.53333333', '6', '2.4667', '0']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . xml . sax . Attributes ; class ProcessorKey extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { KeyDeclaration kd = new KeyDeclaration ( handler . getStylesheet ( ) , handler . nextUid ( ) ) ; kd . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; kd . setLocaterInfo ( handler . getLocator ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , kd ) ; handler . getStylesheet ( ) . setKey ( kd ) ; } void setPropertiesFromAttributes ( StylesheetHandler handler , String rawName , Attributes attributes , org . apache . xalan . templates . ElemTemplateElement target ) throws org . xml . sax . SAXException { XSLTElementDef def = getElemDef ( ) ; Vector processedDefs = new Vector ( ) ; int nAttrs = attributes . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrLocalName = attributes . getLocalName ( i ) ; XSLTAttributeDef attrDef = def . getAttributeDef ( attrUri , attrLocalName ) ; if ( null == attrDef ) { handler . error ( attributes . getQName ( i ) + "attribute is not allowed on the " + rawName + " element!" , null ) ; } else { String valueString = attributes . getValue ( i ) ; if ( valueString . indexOf ( org . apache . xpath . compiler . Keywords . FUNC_KEY_STRING + "(" ) >= 0 ) handler . error ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_KEY_CALL , null ) , null ) ; processedDefs . addElement ( attrDef ) ; attrDef . setAttrValue ( handler , attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getValue ( i ) , target ) ; } } XSLTAttributeDef [ ] attrDefs = def . getAttributes ( ) ; int nAttrDefs = attrDefs . length ; for ( int i = 0 ; i < nAttrDefs ; i ++ ) { XSLTAttributeDef attrDef = attrDefs [ i ] ; String defVal = attrDef . getDefault ( ) ; if ( null != defVal ) { if ( ! processedDefs . contains ( attrDef ) ) { attrDef . setDefAttrValue ( handler , target ) ; } } if ( attrDef . getRequired ( ) ) { if ( ! processedDefs . contains ( attrDef ) ) handler . error ( XSLMessages . createMessage ( XSLTErrorResources . ER_REQUIRES_ATTRIB , new Object [ ] { rawName , attrDef . getName ( ) } ) , null ) ; } } } } 	0	['3', '4', '0', '10', '34', '3', '1', '9', '1', '2', '169', '0', '0', '0.990566038', '0.666666667', '1', '1', '55.33333333', '1', '0.6667', '0']
package org . apache . xpath . objects ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . res . XPATHErrorResources ; public class XRTreeFragSelectWrapper extends XRTreeFrag implements Cloneable { XObject m_selected ; public XRTreeFragSelectWrapper ( Expression expr ) { super ( expr ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { ( ( Expression ) m_obj ) . fixupVariables ( vars , globalsSize ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { m_selected = ( ( Expression ) m_obj ) . execute ( xctxt ) ; m_selected . allowDetachToRelease ( m_allowRelease ) ; if ( m_selected . getType ( ) == CLASS_STRING ) return m_selected ; else return new XString ( m_selected . str ( ) ) ; } public void detach ( ) { if ( m_allowRelease ) { m_selected . detach ( ) ; m_selected = null ; } super . detach ( ) ; } public double num ( ) throws javax . xml . transform . TransformerException { return m_selected . num ( ) ; } public XMLString xstr ( ) { return m_selected . xstr ( ) ; } public String str ( ) { return m_selected . str ( ) ; } public int getType ( ) { return CLASS_STRING ; } public int rtf ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , null ) ) ; } public DTMIterator asNodeIterator ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , null ) ) ; } } 	0	['10', '4', '0', '9', '23', '23', '1', '8', '10', '0.555555556', '89', '0', '1', '0.905263158', '0.28', '3', '22', '7.8', '2', '1', '0']
package org . apache . xml . res ; public class XMLErrorResources_es extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Función no admitida" } , { ER_CANNOT_OVERWRITE_CAUSE , "No se puede sobrescribir la causa" } , { ER_NO_DEFAULT_IMPL , "No se ha encontrado ninguna implementación predeterminada " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) no se utiliza actualmente" } , { ER_OFFSET_BIGGER_THAN_SLOT , "La desviación es mayor que el intervalo" } , { ER_COROUTINE_NOT_AVAIL , "Corrutina no disponible, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager ha recibido una solicitud co_exit()" } , { ER_COJOINROUTINESET_FAILED , "Fallo co_joinCoroutineSet()" } , { ER_COROUTINE_PARAM , "Error de parámetro de corrutina({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: el analizador sintáctico doTerminate responde {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "no puede invocarse el analizador sintáctico con un análisis sintáctico en curso" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: El iterador introducido para el eje  {0} no está implementado" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: el iterador para el eje {0} no está implementado " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "no se admite clon del iterador" } , { ER_UNKNOWN_AXIS_TYPE , "El tipo de eje transversal es desconocido: {0}" } , { ER_AXIS_NOT_SUPPORTED , "No se admite traverser de eje: {0}" } , { ER_NO_DTMIDS_AVAIL , "No hay más Id de DTM disponibles" } , { ER_NOT_SUPPORTED , "No se admite: {0}" } , { ER_NODE_NON_NULL , "El nodo no puede ser nulo para getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "No se ha podido convertir el nodo en un manejador" } , { ER_STARTPARSE_WHILE_PARSING , "no se puede invocar startParse con un análisis sintáctico en curso" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse no admite SAXParser nulo" } , { ER_COULD_NOT_INIT_PARSER , "No se ha podido inicializar el analizador sintáctico con" } , { ER_EXCEPTION_CREATING_POOL , "se ha producido una excepción al crear una nueva instancia para pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "El trayecto contiene una secuencia de escape no válida" } , { ER_SCHEME_REQUIRED , "Se necesita un esquema." } , { ER_NO_SCHEME_IN_URI , "No se ha encontrado ningún esquema en el URI: {0}" } , { ER_NO_SCHEME_INURI , "No se ha encontrado ningún esquema en el URI" } , { ER_PATH_INVALID_CHAR , "El trayecto contiene un carácter no válido: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "No se puede establecer un esquema a partir de una cadena nula" } , { ER_SCHEME_NOT_CONFORMANT , "El esquema no es aceptable." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "El sistema central no es una dirección bien construida" } , { ER_PORT_WHEN_HOST_NULL , "No puede establecerse el puerto cuando el sistema central es nulo" } , { ER_INVALID_PORT , "Número de puerto no válido" } , { ER_FRAG_FOR_GENERIC_URI , "Sólo puede establecerse el fragmento para un URI genérico" } , { ER_FRAG_WHEN_PATH_NULL , "No puede establecerse el fragmento cuando el trayecto es nulo" } , { ER_FRAG_INVALID_CHAR , "El fragmento contiene un carácter no válido" } , { ER_PARSER_IN_USE , "El analizador sintáctico está en uso" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "No se puede cambiar {0} {1} mientras el análisis sintáctico está en curso" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "No se permite la autocausalidad" } , { ER_NO_USERINFO_IF_NO_HOST , "La información de usuario no puede especificarse si no se especifica el sistema central" } , { ER_NO_PORT_IF_NO_HOST , "El puerto no puede especificarse si no está especificado el sistema central" } , { ER_NO_QUERY_STRING_IN_PATH , "La cadena de consulta no puede especificarse a la vez en el trayecto y en la cadena de consulta" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "El fragmento no puede especificarse a la vez en el trayecto y en el fragmento" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "No se puede inicializar el URI con parámetros vacíos" } , { ER_METHOD_NOT_SUPPORTED , "Método todavía no utilizado" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter no puede reiniciarse actualmente" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader no antes de una solicitud startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "No se admite el eje transversal: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler creado con PrintWriter nulo" } , { ER_SYSTEMID_UNKNOWN , "Id de sistema desconocido" } , { ER_LOCATION_UNKNOWN , "Ubicación del error desconocida" } , { ER_PREFIX_MUST_RESOLVE , "El prefijo debe convertirse en un espacio de nombre: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument no admitido en XPathContext." } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "El atributo hijo no tiene documento propietario!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "El atributo hijo no tiene elemento de documento propietario!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Advertencia: no puede enviar el texto antes del elemento de documento. Se ignora..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "No puede haber más de una raíz en un DOM." } , { ER_ARG_LOCALNAME_NULL , "El argumentoArgument 'localName' es nulo." } , { ER_ARG_LOCALNAME_INVALID , "El nombre local especificado en QNAME debe ser un nombre NCName válido" } , { ER_ARG_PREFIX_INVALID , "El prefijo especificado en QNAME debe ser un nombre NCName válido" } , { "BAD_CODE" , "El parámetro para crear el mensaje estaba fuera de los límites" } , { "FORMAT_FAILED" , "Excepción generada durante la llamada messageFormat" } , { "line" , "Línea #" } , { "column" , "Columna #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '0']
package org . apache . xalan . xsltc ; import java . text . Collator ; import java . util . Locale ; public interface CollatorFactory { public Collator getCollator ( String lang , String country ) ; public Collator getCollator ( Locale locale ) ; } 	0	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class FilterParentPath extends Expression { private Expression _filterExpr ; private Expression _path ; private boolean _hasDescendantAxis = false ; public FilterParentPath ( Expression filterExpr , Expression path ) { ( _path = path ) . setParent ( this ) ; ( _filterExpr = filterExpr ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _filterExpr . setParser ( parser ) ; _path . setParser ( parser ) ; } public String toString ( ) { return "FilterParentPath(" + _filterExpr + ", " + _path + ')' ; } public void setDescendantAxis ( ) { _hasDescendantAxis = true ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type ftype = _filterExpr . typeCheck ( stable ) ; if ( ftype instanceof NodeSetType == false ) { if ( ftype instanceof ReferenceType ) { _filterExpr = new CastExpr ( _filterExpr , Type . NodeSet ) ; } else if ( ftype instanceof NodeType ) { _filterExpr = new CastExpr ( _filterExpr , Type . NodeSet ) ; } else { throw new TypeCheckError ( this ) ; } } final Type ptype = _path . typeCheck ( stable ) ; if ( ! ( ptype instanceof NodeSetType ) ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initSI = cpg . addMethodref ( STEP_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( STEP_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; _filterExpr . translate ( classGen , methodGen ) ; _path . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initSI ) ) ; if ( _hasDescendantAxis ) { final int incl = cpg . addMethodref ( NODE_ITERATOR_BASE , "includeSelf" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEVIRTUAL ( incl ) ) ; } if ( ! ( getParent ( ) instanceof RelativeLocationPath ) && ! ( getParent ( ) instanceof FilterParentPath ) ) { final int order = cpg . addInterfaceMethodref ( DOM_INTF , ORDER_ITERATOR , ORDER_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( order , 3 ) ) ; } } } 	0	['6', '3', '0', '24', '31', '0', '2', '22', '6', '0.333333333', '213', '1', '2', '0.934210526', '0.305555556', '2', '7', '34', '4', '1.3333', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import javax . xml . transform . Result ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class ToHTMLSAXHandler extends ToSAXHandler { protected boolean m_escapeSetting = false ; public Properties getOutputFormat ( ) { return null ; } public OutputStream getOutputStream ( ) { return null ; } public Writer getWriter ( ) { return null ; } public void indent ( int n ) throws SAXException { } public boolean reset ( ) { return false ; } public void serialize ( Node node ) throws IOException { return ; } public boolean setEscaping ( boolean escape ) throws SAXException { boolean oldEscapeSetting = m_escapeSetting ; m_escapeSetting = escape ; if ( escape ) { processingInstruction ( Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { processingInstruction ( Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; } return oldEscapeSetting ; } public void setIndent ( boolean indent ) { } public void setOutputFormat ( Properties format ) { } public void setOutputStream ( OutputStream output ) { } public void setWriter ( Writer writer ) { } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { } public void elementDecl ( String name , String model ) throws SAXException { return ; } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void internalEntityDecl ( String name , String value ) throws SAXException { } public void endElement ( String uri , String localName , String qName ) throws SAXException { flushPending ( ) ; m_saxHandler . endElement ( uri , localName , qName ) ; super . fireEndElem ( qName ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { } public void processingInstruction ( String arg0 , String arg1 ) throws SAXException { flushPending ( ) ; m_saxHandler . processingInstruction ( arg0 , arg1 ) ; super . fireEscapingEvent ( arg0 , arg1 ) ; } public void setDocumentLocator ( Locator arg0 ) { } public void skippedEntity ( String arg0 ) throws SAXException { } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { flushPending ( ) ; super . startElement ( namespaceURI , localName , qName , atts ) ; m_saxHandler . startElement ( namespaceURI , localName , qName , atts ) ; m_startTagOpen = false ; } public void comment ( char [ ] ch , int start , int length ) throws SAXException { flushPending ( ) ; m_lexHandler . comment ( ch , start , length ) ; super . fireCommentEvent ( ch , start , length ) ; return ; } public void endCDATA ( ) throws SAXException { return ; } public void endDTD ( ) throws SAXException { } public void startCDATA ( ) throws SAXException { } public void startEntity ( String arg0 ) throws SAXException { } public void endDocument ( ) throws SAXException { flushPending ( ) ; m_saxHandler . endDocument ( ) ; super . fireEndDoc ( ) ; } protected void closeStartTag ( ) throws SAXException { m_startTagOpen = false ; m_saxHandler . startElement ( EMPTYSTRING , m_elementName , m_elementName , m_attributes ) ; m_attributes . clear ( ) ; } public void close ( ) { return ; } public void characters ( String chars ) throws SAXException { this . characters ( chars . toCharArray ( ) , 0 , chars . length ( ) ) ; return ; } public ToHTMLSAXHandler ( ContentHandler handler , String encoding ) { super ( handler , encoding ) ; } public ToHTMLSAXHandler ( ContentHandler handler , LexicalHandler lex , String encoding ) { super ( handler , lex , encoding ) ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { super . startElement ( elementNamespaceURI , elementLocalName , elementName ) ; flushPending ( ) ; if ( m_lexHandler != null ) { String doctypeSystem = getDoctypeSystem ( ) ; String doctypePublic = getDoctypePublic ( ) ; if ( ( doctypeSystem != null ) || ( doctypePublic != null ) ) m_lexHandler . startDTD ( elementName , doctypePublic , doctypeSystem ) ; m_lexHandler = null ; } m_currentElemDepth ++ ; m_elementName = elementName ; m_elementLocalName = elementLocalName ; m_elementURI = elementNamespaceURI ; m_startTagOpen = true ; } public void startElement ( String elementName ) throws SAXException { this . startElement ( null , null , elementName ) ; } public void endElement ( String elementName ) throws SAXException { flushPending ( ) ; m_saxHandler . endElement ( EMPTYSTRING , elementName , elementName ) ; super . fireEndElem ( elementName ) ; } public void characters ( char [ ] ch , int off , int len ) throws SAXException { flushPending ( ) ; m_saxHandler . characters ( ch , off , len ) ; super . fireCharEvent ( ch , off , len ) ; } public void flushPending ( ) { if ( m_needToCallStartDocument ) { try { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } catch ( SAXException e ) { } } if ( m_startTagOpen ) { try { closeStartTag ( ) ; } catch ( SAXException se ) { } m_startTagOpen = false ; } } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { if ( shouldFlush ) flushPending ( ) ; m_saxHandler . startPrefixMapping ( prefix , uri ) ; return false ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { startPrefixMapping ( prefix , uri , true ) ; } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { if ( m_elementURI == null ) { String prefix1 = getPrefixPart ( m_elementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_elementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; } } 	0	['41', '3', '0', '4', '66', '742', '2', '2', '40', '0.95', '337', '1', '0', '0.74', '0.148217636', '3', '14', '7.195121951', '3', '1', '0']
package org . apache . xml . dtm . ref ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public interface IncrementalSAXSource { public void setContentHandler ( ContentHandler handler ) ; public void setLexicalHandler ( org . xml . sax . ext . LexicalHandler handler ) ; public void setDTDHandler ( org . xml . sax . DTDHandler handler ) ; public Object deliverMoreNodes ( boolean parsemore ) ; public void startParse ( InputSource source ) throws SAXException ; } 	0	['5', '1', '0', '6', '5', '10', '6', '0', '5', '2', '5', '0', '0', '0', '0.333333333', '0', '0', '0', '1', '1', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; public class ToUnknownStream extends SerializerBase { private SerializationHandler m_handler ; private static final String EMPTYSTRING = "" ; private boolean m_wrapped_handler_not_initialized = false ; private String m_firstElementPrefix ; private String m_firstElementName ; private String m_firstElementURI ; private String m_firstElementLocalName = null ; private boolean m_firstTagNotEmitted = true ; private Vector m_namespaceURI = null ; private Vector m_namespacePrefix = null ; private boolean m_needToCallStartDocument = false ; private boolean m_setVersion_called = false ; private boolean m_setDoctypeSystem_called = false ; private boolean m_setDoctypePublic_called = false ; private boolean m_setMediaType_called = false ; public ToUnknownStream ( ) { m_handler = new ToXMLStream ( ) ; } public ContentHandler asContentHandler ( ) throws IOException { return this ; } public void close ( ) { m_handler . close ( ) ; } public Properties getOutputFormat ( ) { return m_handler . getOutputFormat ( ) ; } public OutputStream getOutputStream ( ) { return m_handler . getOutputStream ( ) ; } public Writer getWriter ( ) { return m_handler . getWriter ( ) ; } public boolean reset ( ) { return m_handler . reset ( ) ; } public void serialize ( Node node ) throws IOException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . serialize ( node ) ; } public boolean setEscaping ( boolean escape ) throws SAXException { return m_handler . setEscaping ( escape ) ; } public void setOutputFormat ( Properties format ) { m_handler . setOutputFormat ( format ) ; } public void setOutputStream ( OutputStream output ) { m_handler . setOutputStream ( output ) ; } public void setWriter ( Writer writer ) { m_handler . setWriter ( writer ) ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . addAttribute ( uri , localName , rawName , type , value ) ; } public void addAttribute ( String rawName , String value ) { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . addAttribute ( rawName , value ) ; } public void characters ( String chars ) throws SAXException { final char [ ] arr = chars . toCharArray ( ) ; this . characters ( arr , 0 , arr . length ) ; } public void endElement ( String elementName ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . endElement ( elementName ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { this . startPrefixMapping ( prefix , uri , true ) ; } public void namespaceAfterStartElement ( String prefix , String uri ) throws SAXException { if ( m_firstTagNotEmitted && m_firstElementURI == null && m_firstElementName != null ) { String prefix1 = getPrefixPart ( m_firstElementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_firstElementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { boolean pushed = false ; if ( m_firstTagNotEmitted ) { if ( m_firstElementName != null && shouldFlush ) { flush ( ) ; pushed = m_handler . startPrefixMapping ( prefix , uri , shouldFlush ) ; } else { if ( m_namespacePrefix == null ) { m_namespacePrefix = new Vector ( ) ; m_namespaceURI = new Vector ( ) ; } m_namespacePrefix . addElement ( prefix ) ; m_namespaceURI . addElement ( uri ) ; if ( m_firstElementURI == null ) { if ( prefix . equals ( m_firstElementPrefix ) ) m_firstElementURI = uri ; } } } else { pushed = m_handler . startPrefixMapping ( prefix , uri , shouldFlush ) ; } return pushed ; } public void setVersion ( String version ) { m_handler . setVersion ( version ) ; m_setVersion_called = true ; } public void startDocument ( ) throws SAXException { m_needToCallStartDocument = true ; } public void startElement ( String qName ) throws SAXException { this . startElement ( null , null , qName , null ) ; } public void startElement ( String namespaceURI , String localName , String qName ) throws SAXException { this . startElement ( namespaceURI , localName , qName , null ) ; } public void startElement ( String namespaceURI , String localName , String elementName , Attributes atts ) throws SAXException { if ( m_firstTagNotEmitted ) { if ( m_firstElementName != null ) { flush ( ) ; m_handler . startElement ( namespaceURI , localName , elementName , atts ) ; } else { m_wrapped_handler_not_initialized = true ; m_firstElementName = elementName ; m_firstElementPrefix = getPrefixPartUnknown ( elementName ) ; m_firstElementURI = namespaceURI ; m_firstElementLocalName = localName ; if ( atts != null ) super . addAttributes ( atts ) ; if ( atts != null ) flush ( ) ; } } else { m_handler . startElement ( namespaceURI , localName , elementName , atts ) ; } } public void comment ( String comment ) throws SAXException { if ( m_firstTagNotEmitted && m_firstElementName != null ) { emitFirstTag ( ) ; } else if ( m_needToCallStartDocument ) { m_handler . startDocument ( ) ; m_needToCallStartDocument = false ; } m_handler . comment ( comment ) ; } public String getDoctypePublic ( ) { return m_handler . getDoctypePublic ( ) ; } public String getDoctypeSystem ( ) { return m_handler . getDoctypeSystem ( ) ; } public String getEncoding ( ) { return m_handler . getEncoding ( ) ; } public boolean getIndent ( ) { return m_handler . getIndent ( ) ; } public int getIndentAmount ( ) { return m_handler . getIndentAmount ( ) ; } public String getMediaType ( ) { return m_handler . getMediaType ( ) ; } public boolean getOmitXMLDeclaration ( ) { return m_handler . getOmitXMLDeclaration ( ) ; } public String getStandalone ( ) { return m_handler . getStandalone ( ) ; } public String getVersion ( ) { return m_handler . getVersion ( ) ; } public void setDoctype ( String system , String pub ) { m_handler . setDoctypePublic ( pub ) ; m_handler . setDoctypeSystem ( system ) ; } public void setDoctypePublic ( String doctype ) { m_handler . setDoctypePublic ( doctype ) ; m_setDoctypePublic_called = true ; } public void setDoctypeSystem ( String doctype ) { m_handler . setDoctypeSystem ( doctype ) ; m_setDoctypeSystem_called = true ; } public void setEncoding ( String encoding ) { m_handler . setEncoding ( encoding ) ; } public void setIndent ( boolean indent ) { m_handler . setIndent ( indent ) ; } public void setIndentAmount ( int value ) { m_handler . setIndentAmount ( value ) ; } public void setMediaType ( String mediaType ) { m_handler . setMediaType ( mediaType ) ; m_setMediaType_called = true ; } public void setOmitXMLDeclaration ( boolean b ) { m_handler . setOmitXMLDeclaration ( b ) ; } public void setStandalone ( String standalone ) { m_handler . setStandalone ( standalone ) ; } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { m_handler . attributeDecl ( arg0 , arg1 , arg2 , arg3 , arg4 ) ; } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { if ( m_firstTagNotEmitted ) { emitFirstTag ( ) ; } m_handler . elementDecl ( arg0 , arg1 ) ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . externalEntityDecl ( name , publicId , systemId ) ; } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . internalEntityDecl ( arg0 , arg1 ) ; } public void characters ( char [ ] characters , int offset , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . characters ( characters , offset , length ) ; } public void endDocument ( ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . endDocument ( ) ; } public void endElement ( String namespaceURI , String localName , String qName ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; if ( namespaceURI == null && m_firstElementURI != null ) namespaceURI = m_firstElementURI ; if ( localName == null && m_firstElementLocalName != null ) localName = m_firstElementLocalName ; } m_handler . endElement ( namespaceURI , localName , qName ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { m_handler . endPrefixMapping ( prefix ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . processingInstruction ( target , data ) ; } public void setDocumentLocator ( Locator locator ) { m_handler . setDocumentLocator ( locator ) ; } public void skippedEntity ( String name ) throws SAXException { m_handler . skippedEntity ( name ) ; } public void comment ( char [ ] ch , int start , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . comment ( ch , start , length ) ; } public void endCDATA ( ) throws SAXException { m_handler . endCDATA ( ) ; } public void endDTD ( ) throws SAXException { m_handler . endDTD ( ) ; } public void endEntity ( String name ) throws SAXException { if ( m_firstTagNotEmitted ) { emitFirstTag ( ) ; } m_handler . endEntity ( name ) ; } public void startCDATA ( ) throws SAXException { m_handler . startCDATA ( ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { m_handler . startDTD ( name , publicId , systemId ) ; } public void startEntity ( String name ) throws SAXException { m_handler . startEntity ( name ) ; } private void initStreamOutput ( ) throws SAXException { boolean firstElementIsHTML = isFirstElemHTML ( ) ; if ( firstElementIsHTML ) { SerializationHandler oldHandler = m_handler ; Properties htmlProperties = OutputPropertiesFactory . getDefaultMethodProperties ( Method . HTML ) ; Serializer serializer = SerializerFactory . getSerializer ( htmlProperties ) ; m_handler = ( SerializationHandler ) serializer ; Writer writer = oldHandler . getWriter ( ) ; if ( null != writer ) m_handler . setWriter ( writer ) ; else { OutputStream os = oldHandler . getOutputStream ( ) ; if ( null != os ) m_handler . setOutputStream ( os ) ; } m_handler . setVersion ( oldHandler . getVersion ( ) ) ; m_handler . setDoctypeSystem ( oldHandler . getDoctypeSystem ( ) ) ; m_handler . setDoctypePublic ( oldHandler . getDoctypePublic ( ) ) ; m_handler . setMediaType ( oldHandler . getMediaType ( ) ) ; m_handler . setTransformer ( oldHandler . getTransformer ( ) ) ; } if ( m_needToCallStartDocument ) { m_handler . startDocument ( ) ; m_needToCallStartDocument = false ; } m_wrapped_handler_not_initialized = false ; } private void emitFirstTag ( ) throws SAXException { if ( m_firstElementName != null ) { if ( m_wrapped_handler_not_initialized ) { initStreamOutput ( ) ; m_wrapped_handler_not_initialized = false ; } m_handler . startElement ( m_firstElementURI , null , m_firstElementName , m_attributes ) ; m_attributes = null ; if ( m_namespacePrefix != null ) { final int n = m_namespacePrefix . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final String prefix = ( String ) m_namespacePrefix . elementAt ( i ) ; final String uri = ( String ) m_namespaceURI . elementAt ( i ) ; m_handler . startPrefixMapping ( prefix , uri , false ) ; } m_namespacePrefix = null ; m_namespaceURI = null ; } m_firstTagNotEmitted = false ; } } private String getLocalNameUnknown ( String value ) { int idx = value . lastIndexOf ( ':' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; idx = value . lastIndexOf ( '@' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; return ( value ) ; } private String getPrefixPartUnknown ( String qname ) { final int index = qname . indexOf ( ':' ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : EMPTYSTRING ; } private boolean isFirstElemHTML ( ) { boolean isHTML ; isHTML = getLocalNameUnknown ( m_firstElementName ) . equalsIgnoreCase ( "html" ) ; if ( isHTML && m_firstElementURI != null && ! EMPTYSTRING . equals ( m_firstElementURI ) ) { isHTML = false ; } if ( isHTML && m_namespacePrefix != null ) { final int max = m_namespacePrefix . size ( ) ; for ( int i = 0 ; i < max ; i ++ ) { final String prefix = ( String ) m_namespacePrefix . elementAt ( i ) ; final String uri = ( String ) m_namespaceURI . elementAt ( i ) ; if ( m_firstElementPrefix != null && m_firstElementPrefix . equals ( prefix ) && ! EMPTYSTRING . equals ( uri ) ) { isHTML = false ; break ; } } } return isHTML ; } public DOMSerializer asDOMSerializer ( ) throws IOException { return m_handler . asDOMSerializer ( ) ; } public void setCdataSectionElements ( Vector URI_and_localNames ) { m_handler . setCdataSectionElements ( URI_and_localNames ) ; } public void addAttributes ( Attributes atts ) throws SAXException { m_handler . addAttributes ( atts ) ; } public NamespaceMappings getNamespaceMappings ( ) { NamespaceMappings mappings = null ; if ( m_handler != null ) { mappings = m_handler . getNamespaceMappings ( ) ; } return mappings ; } public void flushPending ( ) { flush ( ) ; m_handler . flushPending ( ) ; } private void flush ( ) { try { if ( m_firstTagNotEmitted ) { emitFirstTag ( ) ; } if ( m_needToCallStartDocument ) { m_handler . startDocument ( ) ; m_needToCallStartDocument = false ; } } catch ( SAXException e ) { throw new RuntimeException ( e . toString ( ) ) ; } } public String getPrefix ( String namespaceURI ) { return m_handler . getPrefix ( namespaceURI ) ; } public void entityReference ( String entityName ) throws SAXException { m_handler . entityReference ( entityName ) ; } public String getNamespaceURI ( String qname , boolean isElement ) { return m_handler . getNamespaceURI ( qname , isElement ) ; } public String getNamespaceURIFromPrefix ( String prefix ) { return m_handler . getNamespaceURIFromPrefix ( prefix ) ; } public void setTransformer ( Transformer t ) { m_handler . setTransformer ( t ) ; } public Transformer getTransformer ( ) { return m_handler . getTransformer ( ) ; } public void setContentHandler ( ContentHandler ch ) { m_handler . setContentHandler ( ch ) ; } public void setSourceLocator ( SourceLocator locator ) { m_handler . setSourceLocator ( locator ) ; } } 	0	['81', '2', '0', '10', '167', '0', '1', '9', '75', '0.841666667', '1040', '1', '1', '0.520958084', '0.114403292', '2', '7', '11.65432099', '10', '1.1728', '0']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . PrefixResolverDefault ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class CachedXPathAPI { protected XPathContext xpathSupport ; public CachedXPathAPI ( ) { xpathSupport = new XPathContext ( ) ; } public CachedXPathAPI ( CachedXPathAPI priorXPathAPI ) { xpathSupport = priorXPathAPI . xpathSupport ; } public XPathContext getXPathContext ( ) { return this . xpathSupport ; } public Node selectSingleNode ( Node contextNode , String str ) throws TransformerException { return selectSingleNode ( contextNode , str , contextNode ) ; } public Node selectSingleNode ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { NodeIterator nl = selectNodeIterator ( contextNode , str , namespaceNode ) ; return nl . nextNode ( ) ; } public NodeIterator selectNodeIterator ( Node contextNode , String str ) throws TransformerException { return selectNodeIterator ( contextNode , str , contextNode ) ; } public NodeIterator selectNodeIterator ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodeset ( ) ; } public NodeList selectNodeList ( Node contextNode , String str ) throws TransformerException { return selectNodeList ( contextNode , str , contextNode ) ; } public NodeList selectNodeList ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodelist ( ) ; } public XObject eval ( Node contextNode , String str ) throws TransformerException { return eval ( contextNode , str , contextNode ) ; } public XObject eval ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { PrefixResolverDefault prefixResolver = new PrefixResolverDefault ( ( namespaceNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( ( Document ) namespaceNode ) . getDocumentElement ( ) : namespaceNode ) ; XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } public XObject eval ( Node contextNode , String str , PrefixResolver prefixResolver ) throws TransformerException { XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; XPathContext xpathSupport = new XPathContext ( ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } } 	0	['12', '1', '0', '5', '23', '54', '0', '5', '12', '0.454545455', '139', '1', '1', '0', '0.533333333', '0', '0', '10.5', '1', '0.8333', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ForEach extends Instruction { private Expression _select ; private Type _type ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ForEach" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { _select = parser . parseExpression ( this , "select" , null ) ; parseChildren ( parser ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; } else { final Expression fpe = new ForwardPositionExpr ( _select ) ; _select . setParent ( fpe ) ; fpe . setParser ( _select . getParser ( ) ) ; _select = fpe ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _type = _select . typeCheck ( stable ) ; if ( _type instanceof ReferenceType || _type instanceof NodeType ) { _select = new CastExpr ( _select , Type . NodeSet ) ; typeCheckContents ( stable ) ; return Type . Void ; } if ( _type instanceof NodeSetType || _type instanceof ResultTreeType ) { typeCheckContents ( stable ) ; return Type . Void ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; final Vector sortObjects = new Vector ( ) ; Enumeration children = elements ( ) ; while ( children . hasMoreElements ( ) ) { final Object child = children . nextElement ( ) ; if ( child instanceof Sort ) { sortObjects . addElement ( child ) ; } } if ( ( _type != null ) && ( _type instanceof ResultTreeType ) ) { il . append ( methodGen . loadDOM ( ) ) ; if ( sortObjects . size ( ) > 0 ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . RESULT_TREE_SORT_ERR , this ) ; getParser ( ) . reportError ( WARNING , msg ) ; } _select . translate ( classGen , methodGen ) ; _type . translateTo ( classGen , methodGen , Type . NodeSet ) ; il . append ( SWAP ) ; il . append ( methodGen . storeDOM ( ) ) ; } else { if ( sortObjects . size ( ) > 0 ) { Sort . translateSortIterator ( classGen , methodGen , _select , sortObjects ) ; } else { _select . translate ( classGen , methodGen ) ; } if ( _type instanceof ReferenceType == false ) { _select . startResetIterator ( classGen , methodGen ) ; } } il . append ( methodGen . storeIterator ( ) ) ; initializeVariables ( classGen , methodGen ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; translateContents ( classGen , methodGen ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGT ( loop ) ) ; if ( ( _type != null ) && ( _type instanceof ResultTreeType ) ) { il . append ( methodGen . storeDOM ( ) ) ; } il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; } public void initializeVariables ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Object child = getContents ( ) . elementAt ( i ) ; if ( child instanceof Variable ) { Variable var = ( Variable ) child ; var . initialize ( classGen , methodGen ) ; } } } } 	0	['6', '3', '0', '28', '58', '3', '1', '28', '5', '0.6', '332', '1', '2', '0.918032787', '0.361111111', '1', '7', '54', '9', '2.6667', '0']
package org . apache . xalan . res ; public class XSLTErrorResources_sv extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "Fel: Kan inte ha '{' inuti uttryck" } , { ER_ILLEGAL_ATTRIBUTE , "{0} har ett otillåtet attribut: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode är null i xsl:apply-imports!" } , { ER_CANNOT_ADD , "Kan inte lägga {0} till {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode är null i handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} måste ha ett namn-attribut." } , { ER_TEMPLATE_NOT_FOUND , "Hittade inte mallen med namn: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Kunde inte lösa namn-AVT i xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} kräver attribut: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} måste ha ett ''test''-attribut." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Dåligt värde på nivå-attribut: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Namn på behandlande instruktion får inte vara 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Namn på behandlande instruktion måste vara ett giltigt NCNamn: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} måste ha ett matchningsattribut om det har ett tillstånd." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} kräver antingen ett namn eller ett matchningsattribut." } , { ER_CANT_RESOLVE_NSPREFIX , "Kan inte lösa namnrymdsprefix: {0}" } , { ER_ILLEGAL_VALUE , "xml:space har ett otillåtet värde: {0}" } , { ER_NO_OWNERDOC , "Barnnod saknar ägardokument!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement-fel: {0}" } , { ER_NULL_CHILD , "Försöker lägga till ett null-barn!" } , { ER_NEED_SELECT_ATTRIB , "{0} kräver ett valattribut." } , { ER_NEED_TEST_ATTRIB , "xsl:when måste ha ett 'test'-attribut." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param måste ha ett 'namn'-attribut." } , { ER_NO_CONTEXT_OWNERDOC , "Kontext saknar ägardokument!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Kunde inte skapa XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Process misslyckades." } , { ER_NOT_SUCCESSFUL , "Xalan: misslyckades." } , { ER_ENCODING_NOT_SUPPORTED , "Kodning inte understödd: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Kunde inte skapa TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key måste ha ett 'namn'-attribut." } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key måste ha ett 'matcha'-attribut." } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key måste ha ett 'använd'-attribut." } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} kräver ett ''element''-attribut!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} ''prefix''-attribut saknas" } , { ER_BAD_STYLESHEET_URL , "Stylesheet URL är dålig: {0}" } , { ER_FILE_NOT_FOUND , "Stylesheet-fil saknas: {0}" } , { ER_IOEXCEPTION , "Fick IO-Undantag med stylesheet-fil: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Hittade inte href-attribute för {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} inkluderar, direkt eller indirekt, sig själv!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude-fel, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} ''lang''-attribut' saknas" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) felplacerade {0} element?? Saknar behållarelement  ''komponent''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Kan endast skicka utdata till ett Element, ett DocumentFragment, ett Document, eller en PrintWriter." } , { ER_PROCESS_ERROR , "StylesheetRoot.process-fel" } , { ER_UNIMPLNODE_ERROR , "UnImplNode-fel: {0}" } , { ER_NO_SELECT_EXPRESSION , "Fel! Hittade inte xpath select-uttryck (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Kan inte serialisera en XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Stylesheet-indata ej angiven!" } , { ER_FAILED_PROCESS_STYLESHEET , "Kunde inte behandla stylesheet!" } , { ER_COULDNT_PARSE_DOC , "Kunde inte tolka {0} dokument!" } , { ER_COULDNT_FIND_FRAGMENT , "Hittade inte fragment: {0}" } , { ER_NODE_NOT_ELEMENT , "Nod som pekades på av fragment-identifierare var inte ett element: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each kräver antingen en matchning eller ett namnattribut." } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "mallar kräver antingen en matchning eller ett namnattribut." } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Ingen klon av ett dokumentfragment!" } , { ER_CANT_CREATE_ITEM , "Kan inte skapa element i resultatträd: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space i käll-XML har ett otillåtet värde: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Det finns ingen xsl:key-deklaration för {0}!" } , { ER_CANT_CREATE_URL , "Fel! Kan inte skapa url för: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions är inte understödd" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory-Fel" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} är inte tillåten inne i ett stylesheet!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns inte längre understödd!  Använd xsl:output istället." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space inte längre understödd!  Använd xsl:strip-space eller xsl:preserve-space istället." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result inte längre understödd!  Använd xsl:output istället." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} har ett otillåtet attribut: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Okänt XSL-element: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort kan endast användas med xsl:apply-templates eller xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) felplacerade xsl:when!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when härstammar inte från xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) felplacerade xsl:otherwise!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise härstammar inte från xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} är inte tillåten inne i en mall!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} utbyggnadsnamnrymdsprefix {1} okänt" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Imports kan endast förekomma som de första elementen i ett stylesheet!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} importerar, direkt eller indirekt, sig själv!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space har ett otillåtet värde: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet misslyckades!" } , { ER_SAX_EXCEPTION , "SAX-Undantag" } , { ER_XSLT_ERROR , "XSLT-fel" } , { ER_CURRENCY_SIGN_ILLEGAL , "valutatecken är inte tillåtet i formatmönstersträng" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Dokumentfunktion inte understödd i Stylesheet DOM!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Kan inte lösa prefix i icke-Prefixlösare!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect extension: Hittade inte filnamn - fil eller valattribut måste returnera vald  sträng." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Kan inte bygga FormatterListener i Redirect extension!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Prefix i exkludera-resultat-prefix är inte giltig: {0}" } , { ER_MISSING_NS_URI , "Namnrymds-URI saknas för angivna prefix" } , { ER_MISSING_ARG_FOR_OPTION , "Argument saknas för alternativ: {0}" } , { ER_INVALID_OPTION , "Ogiltigt alternativ: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Fel format på formatsträng: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet måste ha ett 'version'-attribut!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Attribut: {0} har ett otillåtet värde: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose kräver ett xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports inte tillåtet i ett xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Kan inte använda DTMLiaison till en DOM utdatanod... skicka en org.apache.xpath.DOM2Helper istället!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Kan inte använda DTMLiaison till en DOM indatanod... skicka en org.apache.xpath.DOM2Helper istället!" } , { ER_CALL_TO_EXT_FAILED , "Anrop till anslutningselement misslyckades: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Prefix måste lösa till en mamnrymd: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Ogiltigt UTF-16-surrogat upptäckt: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} använde sig självt, vilket kommer att orsaka en  oändlig loop." } , { ER_CANNOT_MIX_XERCESDOM , "Kan inte blanda icke-Xerces-DOM-indata med Xerces-DOM-utdata!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "I ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Hittade mer än en mall med namnet: {0}" } , { ER_INVALID_KEY_CALL , "Ogiltigt funktionsanrop: rekursiva key()-anrop är inte tillåtna" } , { ER_REFERENCING_ITSELF , "Variabel {0} hänvisar, direkt eller indirekt, till sig själv!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Indatanoden till en DOMSource för newTemplates får inte vara null!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Klassfil för alternativ {0} saknas" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Nödvändigt element saknas: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream får inte vara null" } , { ER_URI_CANNOT_BE_NULL , "URI får inte vara null" } , { ER_FILE_CANNOT_BE_NULL , "Fil får inte vara null" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource får inte vara null" } , { ER_CANNOT_INIT_BSFMGR , "Kan inte initialisera BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "Kunde inte kompilera anslutning" } , { ER_CANNOT_CREATE_EXTENSN , "Kunde inte skapa anslutning: {0} på grund av: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Instansmetodanrop till metod {0} kräver en Objektinstans som första argument" } , { ER_INVALID_ELEMENT_NAME , "Ogiltigt elementnamn angivet {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Elementnamnmetod måste vara static {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Anslutningsfunktion {0} : {1} är okänd" } , { ER_MORE_MATCH_CONSTRUCTOR , "Fler än en bästa matchning för konstruktor för {0}" } , { ER_MORE_MATCH_METHOD , "Fler än en bästa matchning för metod {0}" } , { ER_MORE_MATCH_ELEMENT , "Fler än en bästa matchning för elementmetod {0}" } , { ER_INVALID_CONTEXT_PASSED , "Ogiltig kontext skickad för att utvärdera {0}" } , { ER_POOL_EXISTS , "Pool finns redan" } , { ER_NO_DRIVER_NAME , "Inget driver-namn angivet" } , { ER_NO_URL , "Ingen URL angiven" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Poolstorlek är mindre än ett!" } , { ER_INVALID_DRIVER , "Ogiltigt driver-namn angivet" } , { ER_NO_STYLESHEETROOT , "Hittade inte stylesheet-roten!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Ogiltigt värde för xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode misslyckades" } , { ER_RESOURCE_COULD_NOT_LOAD , "Resursen [ {0} ] kunde inte laddas: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Bufferstorlek <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Okänt fel vid anslutningsanrop" } , { ER_NO_NAMESPACE_DECL , "Prefix{0} har inte en motsvarande namnrymdsdeklaration" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Elementinnehåll är inte tillåtet för lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Stylesheet-ledd avslutning" } , { ER_ONE_OR_TWO , "1 eller 2" } , { ER_TWO_OR_THREE , "2 eller 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Kunde inte ladda {0} (kontrollera CLASSPATH), använder nu enbart standard" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Kan inte initialisera standardmallar" } , { ER_RESULT_NULL , "Result borde inte vara null" } , { ER_RESULT_COULD_NOT_BE_SET , "Result kunde inte sättas" } , { ER_NO_OUTPUT_SPECIFIED , "Ingen utdata angiven" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Kan inte omvandla till en Result av typ {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Kan inte omvandla en Source av typ {0}" } , { ER_NULL_CONTENT_HANDLER , "Innehållshanterare med värde null" } , { ER_NULL_ERROR_HANDLER , "Felhanterare med värde null" } , { ER_CANNOT_CALL_PARSE , "parse kan inte anropas om ContentHandler inte har satts" } , { ER_NO_PARENT_FOR_FILTER , "Ingen förälder till filter" } , { ER_NO_STYLESHEET_IN_MEDIA , "Stylesheet saknas i: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "xml-stylesheet PI saknas i: {0}" } , { ER_NOT_SUPPORTED , "Understöds inte: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Värde på egenskap {0} borde vara en Boolesk instans" } , { "ER_SRC_ATTRIB_NOT_SUPPORTED" , "src-attributet understöds ännu inte för {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "Resursen [ {0} ] saknas. \n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Utdata-egenskap känns inte igen: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Kunde inte skapa instans av ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "Värdet för {0} bör innehålla en siffra som inte kan tolkas" } , { ER_VALUE_SHOULD_EQUAL , "Värde på {0} borde motsvara ja eller nej" } , { ER_FAILED_CALLING_METHOD , " Kunde inte anropa metoden {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Kunde inte skapa instans av ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "Tecken är inte tillåtna i dokumentet vid den här tidpunkten" } , { ER_ATTR_NOT_ALLOWED , "Attributet \"{0}\" är inte tillåten i det {1} elementet!" } , { ER_BAD_VALUE , "{0} dåligt värde {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "Attributet {0} saknas " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Attributvärdet {0} känns inte igen " } , { ER_NULL_URI_NAMESPACE , "Försöker generera ett namnområdesprefix med en null-URI" } , { ER_NUMBER_TOO_BIG , "Försöker formatera en siffra som är större än det största långa heltalet" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Det går inte att hitta SAX1-drivrutinen klass {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1-drivrutinen klass {0} hittades men kan inte laddas" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1-drivrutinen klass {0} hittades men kan inte instansieras" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1-drivrutinen klass {0} implementerar inte org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Systemegenskapen org.xml.sax.parser är inte angiven" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Tolkningsargumentet får inte vara null" } , { ER_FEATURE , "Funktion:a {0}" } , { ER_PROPERTY , "Egenskap:a {0}" } , { ER_NULL_ENTITY_RESOLVER , "Nullenhetslösare" } , { ER_NULL_DTD_HANDLER , "Null-DTD-hanterare" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Inget drivrutinsnamn är angett!" } , { ER_NO_URL_SPECIFIED , "Ingen URL har angetts!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Poolstorleken är mindre än 1!" } , { ER_INVALID_DRIVER_NAME , "Ett ogiltigt drivrutinsnamn har angetts!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programmerarfel! expr har inget överordnat ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Programmerarkontroll i RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} är inte tillåten i denna position i formatmallen!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Text utan blanksteg är inte tillåten i denna position i formatmallen!" } , { INVALID_TCHAR , "Ogiltigt värde: {1} används för CHAR-attributet: {0}.  Ett attribut av CHAR-typ får bara ha 1 tecken!" } , { INVALID_QNAME , "Ogiltigt värde:a {1} används för QNAME-attributet:a {0}" } , { INVALID_ENUM , "Ogiltigt värde:a  {1} används för ENUM-attributet:a {0}.  Giltiga värden är:a {2}." } , { INVALID_NMTOKEN , "Ogiltigt värde:a {1} används för NMTOKEN-attributet:a {0} " } , { INVALID_NCNAME , "Ogiltigt värde:a {1} används för NCNAME-attributet:a {0} " } , { INVALID_BOOLEAN , "Ogiltigt värde:a {1} används som Booleskt attribut:a {0} " } , { INVALID_NUMBER , "Ogiltigt värde:a {1} används som sifferattribut:a {0} " } , { ER_ARG_LITERAL , "Argument för {0} i matchningsmönstret måste vara literalt." } , { ER_DUPLICATE_GLOBAL_VAR , "Dubbel deklaration av global variabel." } , { ER_DUPLICATE_VAR , "Dubbel variabeldeklaration." } , { ER_TEMPLATE_NAME_MATCH , "xsl: en mall måste ha ett namn och ett matchningsattribut (eller både och)" } , { ER_INVALID_PREFIX , "Prefix i exclude-result-prefixes är ogiltigt:a {0}" } , { ER_NO_ATTRIB_SET , "attributserien {0} finns inte" } , { WG_FOUND_CURLYBRACE , "Hittade '}' men ingen attributmall är öppen!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Varning: räknarattribut matchar inte en förfäder in xsl:number! Target = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Gammal syntax: Namnet på  'expr'-attributet har ändrats till 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan hanterar ännu inte locale-namnet i funktionen format-number." } , { WG_LOCALE_NOT_FOUND , "Varning: Hittade inte locale för xml:lang{0}" } , { WG_CANNOT_MAKE_URL_FROM , "Kan inte skapa URL från: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Kan inte ladda begärd doc: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Hittade inte Collator för <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Gammal syntax: Funktionsinstruktionen borde använda en url av {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "kodning understöds inte: {0}, använder UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "kodning understöds inte: {0}, använder Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Hittade specificitetskonflikter: {0} Senast hittade i stylesheet kommer att användas." } , { WG_PARSING_AND_PREPARING , "========= Tolkar och förbereder {0} ==========" } , { WG_ATTR_TEMPLATE , "Attributmall, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Matcha konflikter mellan xsl:strip-space och xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan hanterar ännu inte attributet {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Deklaration saknas för decimalformat: {0}" } , { WG_OLD_XSLT_NS , "XSLT-Namnrymd saknas eller är inkorrekt " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Endast en standarddeklaration av xsl:decimal-format är tillåten." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-formatnamn måste vara unika. Namnet \"{0}\" har blivit duplicerat." } , { WG_ILLEGAL_ATTRIBUTE , "{0} har ett otillåtet attribut: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Kan inte lösa namnrymdsprefix: {0}. Noden kommer att ignoreras." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet måste ha ett 'version'-attribut!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Otillåtet attributnamn: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Ogiltigt värde använt för attribut {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Den resulterande nodmängden från dokumentfunktions andra argument är tomt. Det första argumentet kommer att användas." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Värdet på attributet 'name' i xsl:processing-instruction får inte vara 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Värdet på attributet  ''name'' i xsl:processing-instruction måste vara ett giltigt NCName:a {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Det går inte att lägga till attributet {0} efter undernoder eller innan ett element produceras. Attributet ignoreras." } , { "ui_language" , "sv" } , { "help_language" , "sv" } , { "language" , "sv" } , { "BAD_CODE" , "Parameter till createMessage ligger utanför tillåtet intervall" } , { "FORMAT_FAILED" , "Undantag utlöst vid messageFormat-anrop" } , { "version" , ">>>>>>> Xalan Version" } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Rad #" } , { "column" , "Kolumn #" } , { "xsldone" , "XSLProcessor: färdig" } , { "xslProc_option" , "Xalan-J kommando linje Process klass alternativ:" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT utdataFilnamn]" } , { "optionLXCIN" , "   [-LXCIN kompileratStylesheetFilnameIn]" } , { "optionLXCOUT" , "   [-LXCOUT kompileratStylesheetFilenameUt]" } , { "optionPARSER" , "   [-PARSER fullt kvalificerat klassnamn eller tolkförbindelse]" } , { "optionE" , "   [-E (Utöka inte enhetsreferenser)]" } , { "optionV" , "   [-E (Utöka inte enhetsreferenser)]" } , { "optionQC" , "   [-QC (Tysta Mönsterkonfliktvarningar)]" } , { "optionQ" , "   [-Q  (Tyst Tillstånd)]" } , { "optionLF" , "   [-LF (Använd radframmatning enbart på utdata {standard är CR/LF})]" } , { "optionCR" , "   [-CR (Använd vagnretur enbart på utdata {standard är CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Vilka tecken är skiftningstecken {standard är <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Bestäm antal blanksteg för att tabulera {standard är 0})]" } , { "optionTT" , "   [-TT (Spåra mallarna allt eftersom de blir anropade.)]" } , { "optionTG" , "   [-TG (Spåra varje generationshändelse.)]" } , { "optionTS" , "   [-TS (Spåra varje valhändelse.)]" } , { "optionTTC" , "   [-TTC (Spåra mallbarnen allt eftersom de blir behandlade.)]" } , { "optionTCLASS" , "   [-TCLASS (TraceListener-klass för spårningsanslutningar.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Sätt om validering ska ske.  Standard är att validering är avstängd)]" } , { "optionEDUMP" , "   [-EDUMP {valfritt filnamn) (Gör stackdump vid fel.)]" } , { "optionXML" , "   [-XML (Använd XML-formaterare och lägg till XML-huvud.)]" } , { "optionTEXT" , "   [-XML (Använd enkel Text-formaterare.)]" } , { "optionHTML" , "   [-HTML (Använd HTML-formaterare)]" } , { "optionPARAM" , "   [-PARAM namn uttryck (Sätt en stylesheet-parameter)]" } , { "noParsermsg1" , "XSL-Process misslyckades." } , { "noParsermsg2" , "** Hittade inte tolk **" } , { "noParsermsg3" , "Vänligen kontrollera din classpath" } , { "noParsermsg4" , "Om du inte har IBMs XML-Tolk för Java, kan du ladda ner den från" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER fullständigt klassnamn (URIResolver som ska användas för att lösa URI-er)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER fullständigt klassnamn (EntityResolver som ska användas för att lösa enheter)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTRESOLVER fullständigt klassnamn (ContentHandler som ska användas för att serialisera utdata)]" } , { "optionLINENUMBERS" , "   [-L använd radnummer i källdokument]" } , { "optionMEDIA" , " [-MEDIA mediaType (använd medieattribut för att hitta en formatmall som är associerad med ett dokument.)]" } , { "optionFLAVOR" , " [-FLAVOR flavorName (Använd s2s=SAX eller d2d=DOM för transformationen.)] " } , { "optionDIAG" , " [-DIAG (Skriv ut totala transformationer, millisekunder.)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (begär inkrementell DTM-konstruktion genom att ange http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (begär ingen formatmallsoptimering genom att ange http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , " [-RL recursionlimit (kontrollera numerisk gräns på formatmallens rekursionsdjup.)]" } , { "optionXO" , " [-XO [transletName] (tilldela namnet till genererad translet)]" } , { "optionXD" , " [-XD destinationDirectory (ange målkatalog för translet)]" } , { "optionXJ" , " [-XJ jarfile (paketerar transletklasserna i en jar-fil med namnet <jarfile>)]" } , { "optionXP" , " [-XP-paket (anger ett paketnamnsprefix för alla genererade transletklasser)]" } } ; public static final String BAD_CODE = "DÅLIG_KOD" ; public static final String FORMAT_FAILED = "FORMATERING_MISSLYCKADES" ; public static final String ERROR_STRING = "#fel" ; public static final String ERROR_HEADER = "Fel: " ; public static final String WARNING_HEADER = "Varning: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MÖNSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.423076923', '3769', '0', '0', '0.976190476', '1', '0', '0', '1251', '1', '0.3333', '0']
package org . apache . xalan . xsltc . compiler ; abstract class RelativeLocationPath extends Expression { public abstract int getAxis ( ) ; public abstract void setAxis ( int axis ) ; } 	0	['3', '3', '2', '4', '4', '3', '3', '1', '2', '2', '6', '0', '0', '0.97260274', '0.666666667', '0', '0', '1', '1', '0.6667', '0']
package org . apache . xpath ; import java . util . Vector ; import org . apache . xpath . functions . FuncExtFunction ; public interface ExtensionsProvider { public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException ; public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException ; public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey ) throws javax . xml . transform . TransformerException ; public Object extFunction ( FuncExtFunction extFunction , Vector argVec ) throws javax . xml . transform . TransformerException ; } 	0	['4', '1', '0', '4', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.55', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . templates ; public interface XSLTVisitable { public void callVisitors ( XSLTVisitor visitor ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class VariableRefBase extends Expression { protected final VariableBase _variable ; protected Closure _closure = null ; public VariableRefBase ( VariableBase variable ) { _variable = variable ; variable . addReference ( this ) ; } public VariableRefBase ( ) { _variable = null ; } public VariableBase getVariable ( ) { return _variable ; } public VariableBase findParentVariable ( ) { SyntaxTreeNode node = this ; while ( node != null && ! ( node instanceof VariableBase ) ) { node = node . getParent ( ) ; } return ( VariableBase ) node ; } public boolean equals ( Object obj ) { try { return ( _variable == ( ( VariableRefBase ) obj ) . _variable ) ; } catch ( ClassCastException e ) { return false ; } } public String toString ( ) { return "variable-ref(" + _variable . getName ( ) + '/' + _variable . getType ( ) + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) return _type ; if ( _variable . isLocal ( ) ) { SyntaxTreeNode node = getParent ( ) ; do { if ( node instanceof Closure ) { _closure = ( Closure ) node ; break ; } if ( node instanceof TopLevelElement ) { break ; } node = node . getParent ( ) ; } while ( node != null ) ; if ( _closure != null ) { _closure . addVariable ( this ) ; } } VariableBase parent = findParentVariable ( ) ; if ( parent != null ) parent . addDependency ( _variable ) ; _type = _variable . getType ( ) ; if ( _type == null ) { _variable . typeCheck ( stable ) ; _type = _variable . getType ( ) ; } return _type ; } } 	0	['7', '3', '3', '16', '22', '0', '10', '9', '7', '0.416666667', '146', '1', '2', '0.934210526', '0.357142857', '2', '4', '19.57142857', '3', '1.1429', '0']
package org . apache . xalan . xsltc . dom ; public interface Filter { public boolean test ( int node ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class ForwardPositionIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; public ForwardPositionIterator ( DTMAxisIterator source ) { _source = source ; } public DTMAxisIterator cloneIterator ( ) { try { final ForwardPositionIterator clone = ( ForwardPositionIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public int next ( ) { return returnNode ( _source . next ( ) ) ; } public DTMAxisIterator setStartNode ( int node ) { _source . setStartNode ( node ) ; return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['7', '2', '0', '3', '19', '0', '0', '3', '7', '0', '64', '1', '1', '0.684210526', '0.428571429', '1', '5', '8', '1', '0.8571', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ClassGen ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public class ClassGenerator extends ClassGen { protected static int TRANSLET_INDEX = 0 ; protected static int INVALID_INDEX = - 1 ; private Stylesheet _stylesheet ; private final Parser _parser ; private final Instruction _aloadTranslet ; private final String _domClass ; private final String _domClassSig ; private final String _applyTemplatesSig ; public ClassGenerator ( String class_name , String super_class_name , String file_name , int access_flags , String [ ] interfaces , Stylesheet stylesheet ) { super ( class_name , super_class_name , file_name , access_flags , interfaces ) ; _stylesheet = stylesheet ; _parser = stylesheet . getParser ( ) ; _aloadTranslet = new ALOAD ( TRANSLET_INDEX ) ; if ( stylesheet . isMultiDocument ( ) ) { _domClass = "org.apache.xalan.xsltc.dom.MultiDOM" ; _domClassSig = "Lorg/apache/xalan/xsltc/dom/MultiDOM;" ; } else { _domClass = "org.apache.xalan.xsltc.dom.DOMAdapter" ; _domClassSig = "Lorg/apache/xalan/xsltc/dom/DOMAdapter;" ; } _applyTemplatesSig = "(" + Constants . DOM_INTF_SIG + Constants . NODE_ITERATOR_SIG + Constants . TRANSLET_OUTPUT_SIG + ")V" ; } public final Parser getParser ( ) { return _parser ; } public final Stylesheet getStylesheet ( ) { return _stylesheet ; } public final String getClassName ( ) { return _stylesheet . getClassName ( ) ; } public Instruction loadTranslet ( ) { return _aloadTranslet ; } public final String getDOMClass ( ) { return _domClass ; } public final String getDOMClassSig ( ) { return _domClassSig ; } public final String getApplyTemplatesSig ( ) { return _applyTemplatesSig ; } public boolean isExternal ( ) { return false ; } } 	0	['10', '3', '4', '124', '15', '27', '120', '5', '9', '0.888888889', '87', '1', '2', '0.898734177', '0.288888889', '0', '0', '6.9', '1', '0.8', '0']
package org . apache . xalan . xsltc . util ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; public class JavaCupRedirect { private final static String ERRMSG = "You must supply a filename with the -stdin option." ; public static void main ( String args [ ] ) { boolean systemExitOK = true ; InputStream input = null ; final int argc = args . length ; String [ ] new_args = new String [ argc - 2 ] ; int new_argc = 0 ; for ( int i = 0 ; i < argc ; i ++ ) { if ( args [ i ] . equals ( "-stdin" ) ) { if ( ( ++ i >= argc ) || ( args [ i ] . startsWith ( "-" ) ) ) { System . err . println ( ERRMSG ) ; doSystemExit ( systemExitOK ) ; } try { input = new FileInputStream ( args [ i ] ) ; } catch ( FileNotFoundException e ) { System . err . println ( "Could not open file " + args [ i ] ) ; doSystemExit ( systemExitOK ) ; } catch ( SecurityException e ) { System . err . println ( "No permission to file " + args [ i ] ) ; doSystemExit ( systemExitOK ) ; } } else { if ( new_argc == new_args . length ) { System . err . println ( "Missing -stdin option!" ) ; doSystemExit ( systemExitOK ) ; } new_args [ new_argc ++ ] = args [ i ] ; } } System . setIn ( input ) ; try { java_cup . Main . main ( new_args ) ; } catch ( Exception e ) { System . err . println ( "Error running JavaCUP:" ) ; e . printStackTrace ( ) ; doSystemExit ( systemExitOK ) ; } } public static void doSystemExit ( boolean doExit ) { if ( doExit ) System . exit ( - 1 ) ; } } 	0	['3', '1', '0', '1', '15', '3', '0', '1', '3', '1.5', '124', '1', '0', '0', '0.333333333', '0', '0', '40', '6', '2.6667', '0']
package org . apache . xalan . xsltc . compiler ; final class KeyPattern extends IdKeyPattern { public KeyPattern ( String index , String value ) { super ( index , value ) ; } } 	0	['1', '6', '0', '1', '2', '0', '0', '1', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . xml . dtm . ref . dom2dtm ; import org . apache . xml . dtm . DTMException ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class DOM2DTMdefaultNamespaceDeclarationNode implements Attr { final String NOT_SUPPORTED_ERR = "Unsupported operation on pseudonode" ; Element pseudoparent ; String prefix , uri , nodename ; int handle ; DOM2DTMdefaultNamespaceDeclarationNode ( Element pseudoparent , String prefix , String uri , int handle ) { this . pseudoparent = pseudoparent ; this . prefix = prefix ; this . uri = uri ; this . handle = handle ; this . nodename = "xmlns:" + prefix ; } public String getNodeName ( ) { return nodename ; } public String getName ( ) { return nodename ; } public String getNamespaceURI ( ) { return "http://www.w3.org/2000/xmlns/" ; } public String getPrefix ( ) { return prefix ; } public String getLocalName ( ) { return prefix ; } public String getNodeValue ( ) { return uri ; } public String getValue ( ) { return uri ; } public Element getOwnerElement ( ) { return pseudoparent ; } public boolean isSupported ( String feature , String version ) { return false ; } public boolean hasChildNodes ( ) { return false ; } public boolean hasAttributes ( ) { return false ; } public Node getParentNode ( ) { return null ; } public Node getFirstChild ( ) { return null ; } public Node getLastChild ( ) { return null ; } public Node getPreviousSibling ( ) { return null ; } public Node getNextSibling ( ) { return null ; } public boolean getSpecified ( ) { return false ; } public void normalize ( ) { return ; } public NodeList getChildNodes ( ) { return null ; } public NamedNodeMap getAttributes ( ) { return null ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public void setNodeValue ( String value ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public void setValue ( String value ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public void setPrefix ( String value ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node insertBefore ( Node a , Node b ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node replaceChild ( Node a , Node b ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node appendChild ( Node a ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node removeChild ( Node a ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Document getOwnerDocument ( ) { return pseudoparent . getOwnerDocument ( ) ; } public Node cloneNode ( boolean deep ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public int getHandleOfNode ( ) { return handle ; } } 	0	['46', '1', '0', '3', '53', '1009', '2', '1', '45', '0.966666667', '245', '0', '0', '0', '0.190217391', '0', '0', '4.195652174', '1', '0.9783', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class MultipleNodeCounter extends NodeCounter { private DTMAxisIterator _precSiblings = null ; public MultipleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getExpandedTypeID ( node ) ; _precSiblings = _document . getAxisIterator ( PRECEDINGSIBLING ) ; return this ; } public String getCounter ( ) { if ( _value != Integer . MIN_VALUE ) { return formatNumbers ( _value ) ; } IntegerArray ancestors = new IntegerArray ( ) ; int next = _node ; ancestors . add ( next ) ; while ( ( next = _document . getParent ( next ) ) > END && ! matchesFrom ( next ) ) { ancestors . add ( next ) ; } final int nAncestors = ancestors . cardinality ( ) ; final int [ ] counters = new int [ nAncestors ] ; for ( int i = 0 ; i < nAncestors ; i ++ ) { counters [ i ] = Integer . MIN_VALUE ; } for ( int j = 0 , i = nAncestors - 1 ; i >= 0 ; i -- , j ++ ) { final int counter = counters [ j ] ; final int ancestor = ancestors . at ( i ) ; if ( matchesCount ( ancestor ) ) { _precSiblings . setStartNode ( ancestor ) ; while ( ( next = _precSiblings . next ( ) ) != END ) { if ( matchesCount ( next ) ) { counters [ j ] = ( counters [ j ] == Integer . MIN_VALUE ) ? 1 : counters [ j ] + 1 ; } } counters [ j ] = counters [ j ] == Integer . MIN_VALUE ? 1 : counters [ j ] + 1 ; } } return formatNumbers ( counters ) ; } public static NodeCounter getDefaultNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { return new DefaultMultipleNodeCounter ( translet , document , iterator ) ; } static class DefaultMultipleNodeCounter extends MultipleNodeCounter { public DefaultMultipleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } } } 	0	['4', '2', '1', '6', '19', '0', '1', '6', '4', '0.333333333', '164', '1', '1', '0.823529412', '0.5', '1', '4', '39.75', '11', '3.25', '0']
package org . w3c . dom . xpath ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; public interface XPathResult { public static final short ANY_TYPE = 0 ; public static final short NUMBER_TYPE = 1 ; public static final short STRING_TYPE = 2 ; public static final short BOOLEAN_TYPE = 3 ; public static final short UNORDERED_NODE_ITERATOR_TYPE = 4 ; public static final short ORDERED_NODE_ITERATOR_TYPE = 5 ; public static final short UNORDERED_NODE_SNAPSHOT_TYPE = 6 ; public static final short ORDERED_NODE_SNAPSHOT_TYPE = 7 ; public static final short ANY_UNORDERED_NODE_TYPE = 8 ; public static final short FIRST_ORDERED_NODE_TYPE = 9 ; public short getResultType ( ) ; public double getNumberValue ( ) throws XPathException ; public String getStringValue ( ) throws XPathException ; public boolean getBooleanValue ( ) throws XPathException ; public Node getSingleNodeValue ( ) throws XPathException ; public boolean getInvalidIteratorState ( ) ; public int getSnapshotLength ( ) throws XPathException ; public Node iterateNext ( ) throws XPathException , DOMException ; public Node snapshotItem ( int index ) throws XPathException ; } 	0	['9', '1', '0', '0', '9', '36', '0', '0', '9', '1.125', '19', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . xml . sax . InputSource ; public interface SourceLoader { public InputSource loadSource ( String href , String context , XSLTC xsltc ) ; } 	0	['1', '1', '0', '6', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Lte extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . lessThanOrEqual ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Number extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { if ( XObject . CLASS_NUMBER == right . getType ( ) ) return right ; else return new XNumber ( right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_right . num ( xctxt ) ; } } 	0	['3', '3', '0', '7', '8', '3', '2', '5', '3', '2', '23', '0', '0', '0.952380952', '0.555555556', '1', '1', '6.666666667', '1', '0.6667', '0']
package org . apache . xml . utils ; import java . io . IOException ; import java . io . Serializable ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class URI implements Serializable { public static class MalformedURIException extends IOException { public MalformedURIException ( ) { super ( ) ; } public MalformedURIException ( String p_msg ) { super ( p_msg ) ; } } private static final String RESERVED_CHARACTERS = ";/?:@&=+$," ; private static final String MARK_CHARACTERS = "-_.!~*'() " ; private static final String SCHEME_CHARACTERS = "+-." ; private static final String USERINFO_CHARACTERS = ";:&=+$," ; private String m_scheme = null ; private String m_userinfo = null ; private String m_host = null ; private int m_port = - 1 ; private String m_path = null ; private String m_queryString = null ; private String m_fragment = null ; private static boolean DEBUG = false ; public URI ( ) { } public URI ( URI p_other ) { initialize ( p_other ) ; } public URI ( String p_uriSpec ) throws MalformedURIException { this ( ( URI ) null , p_uriSpec ) ; } public URI ( URI p_base , String p_uriSpec ) throws MalformedURIException { initialize ( p_base , p_uriSpec ) ; } public URI ( String p_scheme , String p_schemeSpecificPart ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme!" ) ; } if ( p_schemeSpecificPart == null || p_schemeSpecificPart . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme-specific part!" ) ; } setScheme ( p_scheme ) ; setPath ( p_schemeSpecificPart ) ; } public URI ( String p_scheme , String p_host , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { this ( p_scheme , null , p_host , - 1 , p_path , p_queryString , p_fragment ) ; } public URI ( String p_scheme , String p_userinfo , String p_host , int p_port , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SCHEME_REQUIRED , null ) ) ; } if ( p_host == null ) { if ( p_userinfo != null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_USERINFO_IF_NO_HOST , null ) ) ; } if ( p_port != - 1 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_PORT_IF_NO_HOST , null ) ) ; } } if ( p_path != null ) { if ( p_path . indexOf ( '?' ) != - 1 && p_queryString != null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_QUERY_STRING_IN_PATH , null ) ) ; } if ( p_path . indexOf ( '#' ) != - 1 && p_fragment != null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_FRAGMENT_STRING_IN_PATH , null ) ) ; } } setScheme ( p_scheme ) ; setHost ( p_host ) ; setPort ( p_port ) ; setUserinfo ( p_userinfo ) ; setPath ( p_path ) ; setQueryString ( p_queryString ) ; setFragment ( p_fragment ) ; } private void initialize ( URI p_other ) { m_scheme = p_other . getScheme ( ) ; m_userinfo = p_other . getUserinfo ( ) ; m_host = p_other . getHost ( ) ; m_port = p_other . getPort ( ) ; m_path = p_other . getPath ( ) ; m_queryString = p_other . getQueryString ( ) ; m_fragment = p_other . getFragment ( ) ; } private void initialize ( URI p_base , String p_uriSpec ) throws MalformedURIException { if ( p_base == null && ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CANNOT_INIT_URI_EMPTY_PARMS , null ) ) ; } if ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) { initialize ( p_base ) ; return ; } String uriSpec = p_uriSpec . trim ( ) ; int uriSpecLen = uriSpec . length ( ) ; int index = 0 ; int colonIndex = uriSpec . indexOf ( ':' ) ; if ( colonIndex < 0 ) { if ( p_base == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_SCHEME_IN_URI , new Object [ ] { uriSpec } ) ) ; } } else { initializeScheme ( uriSpec ) ; uriSpec = uriSpec . substring ( colonIndex + 1 ) ; uriSpecLen = uriSpec . length ( ) ; } if ( ( ( index + 1 ) < uriSpecLen ) && ( uriSpec . substring ( index ) . startsWith ( "//" ) ) ) { index += 2 ; int startPos = index ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = uriSpec . charAt ( index ) ; if ( testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } if ( index > startPos ) { initializeAuthority ( uriSpec . substring ( startPos , index ) ) ; } else { m_host = "" ; } } initializePath ( uriSpec . substring ( index ) ) ; if ( p_base != null ) { if ( m_path . length ( ) == 0 && m_scheme == null && m_host == null ) { m_scheme = p_base . getScheme ( ) ; m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; m_path = p_base . getPath ( ) ; if ( m_queryString == null ) { m_queryString = p_base . getQueryString ( ) ; } return ; } if ( m_scheme == null ) { m_scheme = p_base . getScheme ( ) ; } if ( m_host == null ) { m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; } else { return ; } if ( m_path . length ( ) > 0 && m_path . startsWith ( "/" ) ) { return ; } String path = new String ( ) ; String basePath = p_base . getPath ( ) ; if ( basePath != null ) { int lastSlash = basePath . lastIndexOf ( '/' ) ; if ( lastSlash != - 1 ) { path = basePath . substring ( 0 , lastSlash + 1 ) ; } } path = path . concat ( m_path ) ; index = - 1 ; while ( ( index = path . indexOf ( "/./" ) ) != - 1 ) { path = path . substring ( 0 , index + 1 ) . concat ( path . substring ( index + 3 ) ) ; } if ( path . endsWith ( "/." ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } index = - 1 ; int segIndex = - 1 ; String tempString = null ; while ( ( index = path . indexOf ( "/../" ) ) > 0 ) { tempString = path . substring ( 0 , path . indexOf ( "/../" ) ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { if ( ! tempString . substring ( segIndex ++ ) . equals ( ".." ) ) { path = path . substring ( 0 , segIndex ) . concat ( path . substring ( index + 4 ) ) ; } } } if ( path . endsWith ( "/.." ) ) { tempString = path . substring ( 0 , path . length ( ) - 3 ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { path = path . substring ( 0 , segIndex + 1 ) ; } } m_path = path ; } } private void initializeScheme ( String p_uriSpec ) throws MalformedURIException { int uriSpecLen = p_uriSpec . length ( ) ; int index = 0 ; String scheme = null ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' || testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } scheme = p_uriSpec . substring ( 0 , index ) ; if ( scheme . length ( ) == 0 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_SCHEME_INURI , null ) ) ; } else { setScheme ( scheme ) ; } } private void initializeAuthority ( String p_uriSpec ) throws MalformedURIException { int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; String userinfo = null ; if ( p_uriSpec . indexOf ( '@' , start ) != - 1 ) { while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '@' ) { break ; } index ++ ; } userinfo = p_uriSpec . substring ( start , index ) ; index ++ ; } String host = null ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' ) { break ; } index ++ ; } host = p_uriSpec . substring ( start , index ) ; int port = - 1 ; if ( host . length ( ) > 0 ) { if ( testChar == ':' ) { index ++ ; start = index ; while ( index < end ) { index ++ ; } String portStr = p_uriSpec . substring ( start , index ) ; if ( portStr . length ( ) > 0 ) { for ( int i = 0 ; i < portStr . length ( ) ; i ++ ) { if ( ! isDigit ( portStr . charAt ( i ) ) ) { throw new MalformedURIException ( portStr + " is invalid. Port should only contain digits!" ) ; } } try { port = Integer . parseInt ( portStr ) ; } catch ( NumberFormatException nfe ) { } } } } setHost ( host ) ; setPort ( port ) ; setUserinfo ( userinfo ) ; } private void initializePath ( String p_uriSpec ) throws MalformedURIException { if ( p_uriSpec == null ) { throw new MalformedURIException ( "Cannot initialize path from null string!" ) ; } int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '?' || testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , null ) ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { if ( '\\' != testChar ) throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PATH_INVALID_CHAR , new Object [ ] { String . valueOf ( testChar ) } ) ) ; } index ++ ; } m_path = p_uriSpec . substring ( start , index ) ; if ( testChar == '?' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Query string contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Query string contains invalid character:" + testChar ) ; } index ++ ; } m_queryString = p_uriSpec . substring ( start , index ) ; } if ( testChar == '#' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Fragment contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Fragment contains invalid character:" + testChar ) ; } index ++ ; } m_fragment = p_uriSpec . substring ( start , index ) ; } } public String getScheme ( ) { return m_scheme ; } public String getSchemeSpecificPart ( ) { StringBuffer schemespec = new StringBuffer ( ) ; if ( m_userinfo != null || m_host != null || m_port != - 1 ) { schemespec . append ( "//" ) ; } if ( m_userinfo != null ) { schemespec . append ( m_userinfo ) ; schemespec . append ( '@' ) ; } if ( m_host != null ) { schemespec . append ( m_host ) ; } if ( m_port != - 1 ) { schemespec . append ( ':' ) ; schemespec . append ( m_port ) ; } if ( m_path != null ) { schemespec . append ( ( m_path ) ) ; } if ( m_queryString != null ) { schemespec . append ( '?' ) ; schemespec . append ( m_queryString ) ; } if ( m_fragment != null ) { schemespec . append ( '#' ) ; schemespec . append ( m_fragment ) ; } return schemespec . toString ( ) ; } public String getUserinfo ( ) { return m_userinfo ; } public String getHost ( ) { return m_host ; } public int getPort ( ) { return m_port ; } public String getPath ( boolean p_includeQueryString , boolean p_includeFragment ) { StringBuffer pathString = new StringBuffer ( m_path ) ; if ( p_includeQueryString && m_queryString != null ) { pathString . append ( '?' ) ; pathString . append ( m_queryString ) ; } if ( p_includeFragment && m_fragment != null ) { pathString . append ( '#' ) ; pathString . append ( m_fragment ) ; } return pathString . toString ( ) ; } public String getPath ( ) { return m_path ; } public String getQueryString ( ) { return m_queryString ; } public String getFragment ( ) { return m_fragment ; } public void setScheme ( String p_scheme ) throws MalformedURIException { if ( p_scheme == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SCHEME_FROM_NULL_STRING , null ) ) ; } if ( ! isConformantSchemeName ( p_scheme ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SCHEME_NOT_CONFORMANT , null ) ) ; } m_scheme = p_scheme . toLowerCase ( ) ; } public void setUserinfo ( String p_userinfo ) throws MalformedURIException { if ( p_userinfo == null ) { m_userinfo = null ; } else { if ( m_host == null ) { throw new MalformedURIException ( "Userinfo cannot be set when host is null!" ) ; } int index = 0 ; int end = p_userinfo . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_userinfo . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Userinfo contains invalid escape sequence!" ) ; } } else if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { throw new MalformedURIException ( "Userinfo contains invalid character:" + testChar ) ; } index ++ ; } } m_userinfo = p_userinfo ; } public void setHost ( String p_host ) throws MalformedURIException { if ( p_host == null || p_host . trim ( ) . length ( ) == 0 ) { m_host = p_host ; m_userinfo = null ; m_port = - 1 ; } else if ( ! isWellFormedAddress ( p_host ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_HOST_ADDRESS_NOT_WELLFORMED , null ) ) ; } m_host = p_host ; } public void setPort ( int p_port ) throws MalformedURIException { if ( p_port >= 0 && p_port <= 65535 ) { if ( m_host == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PORT_WHEN_HOST_NULL , null ) ) ; } } else if ( p_port != - 1 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_PORT , null ) ) ; } m_port = p_port ; } public void setPath ( String p_path ) throws MalformedURIException { if ( p_path == null ) { m_path = null ; m_queryString = null ; m_fragment = null ; } else { initializePath ( p_path ) ; } } public void appendPath ( String p_addToPath ) throws MalformedURIException { if ( p_addToPath == null || p_addToPath . trim ( ) . length ( ) == 0 ) { return ; } if ( ! isURIString ( p_addToPath ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PATH_INVALID_CHAR , new Object [ ] { p_addToPath } ) ) ; } if ( m_path == null || m_path . trim ( ) . length ( ) == 0 ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = p_addToPath ; } else { m_path = "/" + p_addToPath ; } } else if ( m_path . endsWith ( "/" ) ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; } else { m_path = m_path . concat ( p_addToPath ) ; } } else { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath ) ; } else { m_path = m_path . concat ( "/" + p_addToPath ) ; } } } public void setQueryString ( String p_queryString ) throws MalformedURIException { if ( p_queryString == null ) { m_queryString = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( "Query string can only be set for a generic URI!" ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( "Query string cannot be set when path is null!" ) ; } else if ( ! isURIString ( p_queryString ) ) { throw new MalformedURIException ( "Query string contains invalid character!" ) ; } else { m_queryString = p_queryString ; } } public void setFragment ( String p_fragment ) throws MalformedURIException { if ( p_fragment == null ) { m_fragment = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_FRAG_FOR_GENERIC_URI , null ) ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_FRAG_WHEN_PATH_NULL , null ) ) ; } else if ( ! isURIString ( p_fragment ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_FRAG_INVALID_CHAR , null ) ) ; } else { m_fragment = p_fragment ; } } public boolean equals ( Object p_test ) { if ( p_test instanceof URI ) { URI testURI = ( URI ) p_test ; if ( ( ( m_scheme == null && testURI . m_scheme == null ) || ( m_scheme != null && testURI . m_scheme != null && m_scheme . equals ( testURI . m_scheme ) ) ) && ( ( m_userinfo == null && testURI . m_userinfo == null ) || ( m_userinfo != null && testURI . m_userinfo != null && m_userinfo . equals ( testURI . m_userinfo ) ) ) && ( ( m_host == null && testURI . m_host == null ) || ( m_host != null && testURI . m_host != null && m_host . equals ( testURI . m_host ) ) ) && m_port == testURI . m_port && ( ( m_path == null && testURI . m_path == null ) || ( m_path != null && testURI . m_path != null && m_path . equals ( testURI . m_path ) ) ) && ( ( m_queryString == null && testURI . m_queryString == null ) || ( m_queryString != null && testURI . m_queryString != null && m_queryString . equals ( testURI . m_queryString ) ) ) && ( ( m_fragment == null && testURI . m_fragment == null ) || ( m_fragment != null && testURI . m_fragment != null && m_fragment . equals ( testURI . m_fragment ) ) ) ) { return true ; } } return false ; } public String toString ( ) { StringBuffer uriSpecString = new StringBuffer ( ) ; if ( m_scheme != null ) { uriSpecString . append ( m_scheme ) ; uriSpecString . append ( ':' ) ; } uriSpecString . append ( getSchemeSpecificPart ( ) ) ; return uriSpecString . toString ( ) ; } public boolean isGenericURI ( ) { return ( m_host != null ) ; } public static boolean isConformantSchemeName ( String p_scheme ) { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { return false ; } if ( ! isAlpha ( p_scheme . charAt ( 0 ) ) ) { return false ; } char testChar ; for ( int i = 1 ; i < p_scheme . length ( ) ; i ++ ) { testChar = p_scheme . charAt ( i ) ; if ( ! isAlphanum ( testChar ) && SCHEME_CHARACTERS . indexOf ( testChar ) == - 1 ) { return false ; } } return true ; } public static boolean isWellFormedAddress ( String p_address ) { if ( p_address == null ) { return false ; } String address = p_address . trim ( ) ; int addrLength = address . length ( ) ; if ( addrLength == 0 || addrLength > 255 ) { return false ; } if ( address . startsWith ( "." ) || address . startsWith ( "-" ) ) { return false ; } int index = address . lastIndexOf ( '.' ) ; if ( address . endsWith ( "." ) ) { index = address . substring ( 0 , index ) . lastIndexOf ( '.' ) ; } if ( index + 1 < addrLength && isDigit ( p_address . charAt ( index + 1 ) ) ) { char testChar ; int numDots = 0 ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isDigit ( address . charAt ( i - 1 ) ) || ( i + 1 < addrLength && ! isDigit ( address . charAt ( i + 1 ) ) ) ) { return false ; } numDots ++ ; } else if ( ! isDigit ( testChar ) ) { return false ; } } if ( numDots != 3 ) { return false ; } } else { char testChar ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isAlphanum ( address . charAt ( i - 1 ) ) ) { return false ; } if ( i + 1 < addrLength && ! isAlphanum ( address . charAt ( i + 1 ) ) ) { return false ; } } else if ( ! isAlphanum ( testChar ) && testChar != '-' ) { return false ; } } } return true ; } private static boolean isDigit ( char p_char ) { return p_char >= '0' && p_char <= '9' ; } private static boolean isHex ( char p_char ) { return ( isDigit ( p_char ) || ( p_char >= 'a' && p_char <= 'f' ) || ( p_char >= 'A' && p_char <= 'F' ) ) ; } private static boolean isAlpha ( char p_char ) { return ( ( p_char >= 'a' && p_char <= 'z' ) || ( p_char >= 'A' && p_char <= 'Z' ) ) ; } private static boolean isAlphanum ( char p_char ) { return ( isAlpha ( p_char ) || isDigit ( p_char ) ) ; } private static boolean isReservedCharacter ( char p_char ) { return RESERVED_CHARACTERS . indexOf ( p_char ) != - 1 ; } private static boolean isUnreservedCharacter ( char p_char ) { return ( isAlphanum ( p_char ) || MARK_CHARACTERS . indexOf ( p_char ) != - 1 ) ; } private static boolean isURIString ( String p_uric ) { if ( p_uric == null ) { return false ; } int end = p_uric . length ( ) ; char testChar = '\0' ; for ( int i = 0 ; i < end ; i ++ ) { testChar = p_uric . charAt ( i ) ; if ( testChar == '%' ) { if ( i + 2 >= end || ! isHex ( p_uric . charAt ( i + 1 ) ) || ! isHex ( p_uric . charAt ( i + 2 ) ) ) { return false ; } else { i += 2 ; continue ; } } if ( isReservedCharacter ( testChar ) || isUnreservedCharacter ( testChar ) ) { continue ; } else { return false ; } } return true ; } } 	0	['42', '1', '0', '3', '68', '375', '1', '2', '29', '0.780487805', '2044', '1', '0', '0', '0.226480836', '0', '0', '47.38095238', '33', '3.1429', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Mult extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) * right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) * m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xalan . res ; import java . util . Locale ; public class XSLTErrorResources_it extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "Errore: Impossibile inserire '{' nell'espressione." } , { ER_ILLEGAL_ATTRIBUTE , "{0} ha un attributo illegale: {1}." } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode nullo in xsl:apply-imports" } , { ER_CANNOT_ADD , "Impossibile aggiungere {0} a {1}." } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode nullo in handleApplyTemplatesInstruction." } , { ER_NO_NAME_ATTRIB , "{0} deve avere un attributo nome." } , { ER_TEMPLATE_NOT_FOUND , "Impossibile trovare il modello denominato: {0}." } , { ER_CANT_RESOLVE_NAME_AVT , "Impossibile risolvere il nome AVT in xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} richiede l'attributo: {1}." } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} deve avere un attributo ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Valore non valido su attributo livello: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Il nome dell'istruzione di elaborazione non può essere 'xml'." } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Il nome dell'istruzione di elaborazione deve essere un NCName valido: {0}." } , { ER_NEED_MATCH_ATTRIB , "{0} deve avere un attributo corrispondenza se ha una modalità." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} richiede un attributo nome o corrispondenza." } , { ER_CANT_RESOLVE_NSPREFIX , "Impossibile risolvere il prefisso namespace: {0}." } , { ER_ILLEGAL_VALUE , "xml:space ha valore non valido: {0}." } , { ER_NO_OWNERDOC , "Il nodo secondario non ha alcun documento di proprietà." } , { ER_ELEMTEMPLATEELEM_ERR , "Errore ElemTemplateElement: {0}." } , { ER_NULL_CHILD , "Tentativo di aggiungere un elemento secondario nullo." } , { ER_NEED_SELECT_ATTRIB , "{0} richiede un attributo selezione." } , { ER_NEED_TEST_ATTRIB , "xsl:when deve avere un attributo 'test'." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param deve avere un attributo 'name'." } , { ER_NO_CONTEXT_OWNERDOC , "Il contesto non ha un documento di proprietà." } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Impossibile creare un XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: il processo non è riuscito." } , { ER_NOT_SUCCESSFUL , "Xalan: non è riuscito." } , { ER_ENCODING_NOT_SUPPORTED , "Codifica non supportata: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Impossibile creare TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key richiede un attributo 'nome'." } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key richiede un attributo 'corrispondenza'." } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key richiede un attributo 'uso'." } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} richiede un attributo ''elementi''." } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} attributo ''prefisso'' mancante" } , { ER_BAD_STYLESHEET_URL , "URL del foglio di stile non valido: {0}" } , { ER_FILE_NOT_FOUND , "File del foglio di stile non trovato: {0}" } , { ER_IOEXCEPTION , "Rilevata eccezione IO con il file del foglio di stile: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Impossibile trovare l'attributo href per {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} include se stesso direttamente o indirettamente." } , { ER_PROCESSINCLUDE_ERROR , "Errore StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} attributo ''lang'' mancante" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) elemento {0} fuori posto? ''Componente'' dell'elemento contenitore mancante" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "È possibile eseguire l'output solo in Element, DocumentFragment, Document o PrintWriter." } , { ER_PROCESS_ERROR , "Errore in StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Errore in UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "Errore. L'espressione di selezione del percorso (-select) non è stata trovata." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Impossibile serializzare un XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Input del foglio di stile non specificato." } , { ER_FAILED_PROCESS_STYLESHEET , "Elaborazione del foglio di stile non riuscita." } , { ER_COULDNT_PARSE_DOC , "Impossibile analizzare il documento {0}." } , { ER_COULDNT_FIND_FRAGMENT , "Impossibile trovare il frammento: {0}" } , { ER_NODE_NOT_ELEMENT , "Il nodo a cui puntava l'identificatore del frammento non era un elemento: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each deve avere un attributo corrispondenza o nome." } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "I modelli devono avere un attributo corrispondenza o nome." } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Nessun duplicato di frammento di un documento." } , { ER_CANT_CREATE_ITEM , "Impossibile creare un elemento nell'albero del risultato: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space nell'XML sorgente ha valore non valido: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Dichiarazione xsl:key mancante per {0}!" } , { ER_CANT_CREATE_URL , "Errore. Impossibile creare URL per: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions non supportato" } , { ER_PROCESSOR_ERROR , "Errore XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} non consentito in un foglio di stile." } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns non è più supportato. Utilizzare xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space non è più supportato. Utilizzare xsl:strip-space o xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result non è più supportato. Utilizzare xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} ha un attributo non valido {1}" } , { ER_UNKNOWN_XSL_ELEM , "Elemento XSL sconosciuto: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort può essere utilizzato solo con xsl:apply-templates o xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when fuori posto." } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when non dipende da xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise fuori posto." } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise non dipende da xsl:choose." } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} non è consentito in un modello." } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} prefisso namespace di estensione {1} sconosciuto" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Le importazioni sono possibili solo come primi elementi di un foglio di stile." } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} sta importando se stesso direttamente o indirettamente." } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space ha valore non valido: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet non è riuscito." } , { ER_SAX_EXCEPTION , "Eccezione SAX" } , { ER_XSLT_ERROR , "Errore XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "Il segno di valuta non è consentito nelle stringhe modello di formato." } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Funzione documento non supportata nel foglio di stile DOM!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Impossibile risolvere il prefisso del risolutore non-Prefix." } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Estensione di reindirizzamento: Impossibile trovare il nome file. Il file o l'attributo di selezione devono generare una stringa valida." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Impossibile generare FormatterListener nell'estensione di reindirizzamento." } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Il prefisso in exclude-result-prefixes non è valido: {0}" } , { ER_MISSING_NS_URI , "URI namespace mancante per il prefisso specificato." } , { ER_MISSING_ARG_FOR_OPTION , "Argomento mancante per l'opzione: {0}" } , { ER_INVALID_OPTION , "Opzione non valida: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Stringa di formato non valida: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet richiede un attributo 'versione'." } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Attributo: {0} ha un valore non valido: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose richiede xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports non consentito in xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Impossibile utilizzare un collegamento DTM per un nodo DOM di output. Utilizzare org.apache.xpath.DOM2Helper." } , { ER_CANT_USE_DTM_FOR_INPUT , "Impossibile utilizzare un collegamento DTM per un nodo DOM di input. Utilizzare org.apache.xpath.DOM2Helper." } , { ER_CALL_TO_EXT_FAILED , "Chiamata all'elemento di estensione non riuscita: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Il prefisso deve risolvere in namespace: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Rilevato surrogato di UTF-16 non valido: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} ha utilizzato se stesso, generando un loop infinito." } , { ER_CANNOT_MIX_XERCESDOM , "Impossibile combinare un input non Xerces-DOM con un input Xerces-DOM." } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "In ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Trovato più di un modello denominato: {0}" } , { ER_INVALID_KEY_CALL , "Chiamata di funzione non valida: le chiamate chiave() ricorsive non sono consentite." } , { ER_REFERENCING_ITSELF , "La variabile {0} fa riferimento a se stessa direttamente o indirettamente." } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Il nodo di input non può essere nullo per DOMSource per newTemplates." } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "File di classe non trovato per l'opzione {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Elemento richiesto non trovato: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream non può essere nullo." } , { ER_URI_CANNOT_BE_NULL , "L'URI non può essere nullo." } , { ER_FILE_CANNOT_BE_NULL , "Il file non può essere nullo." } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource non può essere nullo." } , { ER_CANNOT_INIT_BSFMGR , "Impossibile inizializzare BSF Manager." } , { ER_CANNOT_CMPL_EXTENSN , "Impossibile compilare l'estensione." } , { ER_CANNOT_CREATE_EXTENSN , "Impossibile creare l'estensione: {0} a causa di: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "La chiamata del metodo istanza al metodo {0} richiede un'istanza oggetto come primo argomento." } , { ER_INVALID_ELEMENT_NAME , "È stato specificato un nome elemento non valido {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Il metodo del nome elemento deve essere statico {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Funzione estensione {0} : {1} sconosciuta." } , { ER_MORE_MATCH_CONSTRUCTOR , "Più di una corrispondenza migliore per costruttore per {0}." } , { ER_MORE_MATCH_METHOD , "Più di una corrispondenza migliore per il metodo {0}" } , { ER_MORE_MATCH_ELEMENT , "Più di una corrispondenza migliore per il metodo elemento {0}" } , { ER_INVALID_CONTEXT_PASSED , "Contesto non valido passato da valutare {0}." } , { ER_POOL_EXISTS , "Pool già esistente." } , { ER_NO_DRIVER_NAME , "Non è stato specificato alcun nome di driver." } , { ER_NO_URL , "Non è stato specificato alcun URL." } , { ER_POOL_SIZE_LESSTHAN_ONE , "Le dimensioni del pool sono minori di uno." } , { ER_INVALID_DRIVER , "È stato specificato un nome di driver non valido." } , { ER_NO_STYLESHEETROOT , "Impossibile trovare la root del foglio di stile." } , { ER_ILLEGAL_XMLSPACE_VALUE , "Valore non valido per xml:space." } , { ER_PROCESSFROMNODE_FAILED , "processFromNode non riuscito." } , { ER_RESOURCE_COULD_NOT_LOAD , "Impossibile caricare la risorsa [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Dimensioni del buffer <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Errore sconosciuto nella chiamata dell'estensione." } , { ER_NO_NAMESPACE_DECL , "Il prefisso {0} non ha una corrispondente dichiarazione namespace." } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Contenuto dell'elemento non consentito per lang=javaclass {0}." } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Conclusione richiesta dal foglio di stile." } , { ER_ONE_OR_TWO , "1 o 2" } , { ER_TWO_OR_THREE , "2 o 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Impossibile caricare {0} (verificare CLASSPATH). Attualmente sono in uso i valori predefiniti." } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Impossibile inizializzare i modelli predefiniti." } , { ER_RESULT_NULL , "Il risultato non dovrebbe essere nullo." } , { ER_RESULT_COULD_NOT_BE_SET , "Impossibile stabilire il risultato." } , { ER_NO_OUTPUT_SPECIFIED , "Nessun output specificato." } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Impossibile trasformare in un risultato di tipo {0}." } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Impossibile trasformare un sorgente di tipo {0}." } , { ER_NULL_CONTENT_HANDLER , "Contenuto gestore nullo" } , { ER_NULL_ERROR_HANDLER , "Errore gestore nullo" } , { ER_CANNOT_CALL_PARSE , "Impossibile chiamare l'analisi se non è impostato ContentHandler." } , { ER_NO_PARENT_FOR_FILTER , "Nessun elemento principale per il filtro." } , { ER_NO_STYLESHEET_IN_MEDIA , "Nessun foglio di stile trovato in: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "Nessun xml-stylesheet PI trovato in : {0}" } , { ER_NOT_SUPPORTED , "Non supportato: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Il valore della proprietà {0} deve essere un'istanza booleana" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "L'attributo src non è ancora supportato per {0}." } , { ER_RESOURCE_COULD_NOT_FIND , "Impossibile trovare la risorsa [ {0} ].\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "La proprietà dell'output non è riconosciuta: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Creazione non riuscita dell'istanza ElemLiteralResult." } , { ER_VALUE_SHOULD_BE_NUMBER , "Il valore di {0} deve contenere un numero analizzabile." } , { ER_VALUE_SHOULD_EQUAL , "Il valore di {0} deve essere sì o no." } , { ER_FAILED_CALLING_METHOD , "Chiamata non riuscita del metodo {0}." } , { ER_FAILED_CREATING_ELEMTMPL , "Creazione non riuscita dell'istanza ElemTemplateElement." } , { ER_CHARS_NOT_ALLOWED , "I caratteri non sono consentiti in questo punto del documento." } , { ER_ATTR_NOT_ALLOWED , "\"{0}\": questo attributo non è consentito sull'elemento {1}." } , { ER_BAD_VALUE , "{0} valore non valido {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} valore dell'attributo non trovato." } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} valore dell'attributo non riconosciuto " } , { ER_NULL_URI_NAMESPACE , "Tentativo di generare un prefisso di namespace con URI nullo" } , { ER_NUMBER_TOO_BIG , "Tentativo di formattare un numero maggiore dell'intero lungo più grande" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Impossibile trovare classe driver SAX1 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "La classe di driver SAX1 {0} è stata trovata ma è impossibile caricarla" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "La classe di driver SAX1 {0} è stata caricata ma non è possibile creare istanze" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "La classe di driver SAX1 {0} non implementa org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Proprietà di sistema org.xml.sax.parser non specificata" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "L'argomento del Parser non deve essere nullo" } , { ER_FEATURE , "Caratteristica:a {0}" } , { ER_PROPERTY , "Proprietà:a {0}" } , { ER_NULL_ENTITY_RESOLVER , "Il risolutore dell'entità è nullo" } , { ER_NULL_DTD_HANDLER , "Il gestore DTD è nullo" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Nessun nome di driver specificato." } , { ER_NO_URL_SPECIFIED , "Nessun URL specificato." } , { ER_POOLSIZE_LESS_THAN_ONE , "La dimensione pool è inferiore a 1." } , { ER_INVALID_DRIVER_NAME , "Il nome specificato del driver non è valido." } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Errore del programmatore. L'espressione non presenta ElemTemplateElement superiore." } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Affermazione del programmatore in RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} non è consentito in questa posizione nel foglio di stile." } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Il testo senza spazi non è consentito nel foglio di stile." } , { INVALID_TCHAR , "Valore non consentito: {1} utilizzato per attributo CHAR: {0}. L'attributo di tipo CHAR deve contenere 1 solo carattere." } , { INVALID_QNAME , "Valore non consentito:a {1} utilizzato per attributo QNAME:a {0}" } , { INVALID_ENUM , "Valore non consentito:a {1} utilizzato per attributo ENUM:a {0}. I valori validi sono:a {2}." } , { INVALID_NMTOKEN , "Valore non consentito:a {1} utilizzato per attributo NMTOKEN:a {0} " } , { INVALID_NCNAME , "Valore non consentito:a {1} utilizzato per attributo NCNAME:a {0} " } , { INVALID_BOOLEAN , "Valore non consentito:a {1} utilizzato per attributo boolean:a {0} " } , { INVALID_NUMBER , "Valore non consentito:a {1} utilizzato per attributo number:a {0} " } , { ER_ARG_LITERAL , "L'argomento di {0} nel pattern di corrispondenza deve essere letterale." } , { ER_DUPLICATE_GLOBAL_VAR , "Dichiarazione variabile globale duplicata." } , { ER_DUPLICATE_VAR , "Dichiarazione variabile duplicata." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template deve presentare un name o attributo match (o entrambi)" } , { ER_INVALID_PREFIX , "Il prefisso in exclude-result-prefixes non è valido:a {0}" } , { ER_NO_ATTRIB_SET , "la serie di attributi denominata {0} è inesistente" } , { WG_FOUND_CURLYBRACE , "Trovato '}' ma non vi è alcun modello di attributi aperto." } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Avvertenza: l'attributo di conteggio non corrisponde a un predecessore in xsl:number! Target = {0}." } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Sintassi precedente: il nome dell'attributo 'expr' è stato cambiato in 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan non gestisce ancora il nome locale nella funzione format-number." } , { WG_LOCALE_NOT_FOUND , "Avvertenza: impossibile trovare la versione locale per xml:lang={0}." } , { WG_CANNOT_MAKE_URL_FROM , "Impossibile creare l'URL da: {0}." } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Impossibile caricare il documento richiesto: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Impossibile trovare il collatore per <sort xml:lang={0}." } , { WG_FUNCTIONS_SHOULD_USE_URL , "Sintassi precedente: l'istruzione delle funzioni deve utilizzare l'URL {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "codifica non supportata: {0}, utilizzando UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Codifica non supportata: {0}, utilizzando Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Trovati conflitti di specificità: {0} Sarà utilizzato l'ultimo trovato nel foglio di stile." } , { WG_PARSING_AND_PREPARING , "========= Analisi e preparazione {0} ==========" } , { WG_ATTR_TEMPLATE , "Modello attr., {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Conflitto di corrispondenza tra xsl:strip-space e xsl:preserve-space." } , { WG_ATTRIB_NOT_HANDLED , "Xalan non gestisce ancora l'attributo {0}." } , { WG_NO_DECIMALFORMAT_DECLARATION , "Non è stata trovata alcuna dichiarazione per il formato decimale: {0}" } , { WG_OLD_XSLT_NS , "XSLT Namespace mancante o non valido. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "È consentita solo una dichiarazione xsl:decimal-format predefinita." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "I nomi xsl:decimal-format devono essere univoci. Il nome \"{0}\" è duplicato." } , { WG_ILLEGAL_ATTRIBUTE , "{0} ha un attributo non valido: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Impossibile risolvere il prefisso namespace: {0}. Nodo ignorato." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet richiede un attributo 'versione'." } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Nome attributo non valido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Valore non valido per l'attributo {0}: {1}." } , { WG_EMPTY_SECOND_ARG , "Il nodeset risultante dal secondo argomento della funzione documento è vuoto. Sarà utilizzato il primo argomento." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Il valore dell'attributo 'name' del nome xsl:processing-instruction name non deve essere 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Il valore dell'attributo ''name'' di xsl:processing-instruction deve essere un NCName valido:a {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Impossibile aggiungere l'attributo {0} dopo i nodi secondari o prima della produzione di un elemento.  L'attributo verrà ignorato." } , { "ui_language" , "it" } , { "help_language" , "it" } , { "language" , "it" } , { "BAD_CODE" , "I parametri di createMessage sono esterni ai limiti" } , { "FORMAT_FAILED" , "Eccezione generata durante la chiamata di messageFormat" } , { "version" , ">>>>>>> Xalan Versione " } , { "version2" , "<<<<<<<" } , { "yes" , "sì" } , { "line" , "Linea #" } , { "column" , "Colonna #" } , { "xsldone" , "XSLProcessor: done" } , { "xslProc_option" , "opzioni dalla riga di comando della classe Process di Xalan-J:" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER nome di classe pienamente qualificato del collegamento parser]" } , { "optionE" , "   [-E (Non espandere i rif entità)]" } , { "optionV" , "   [-E (Non espandere i rif entità)]" } , { "optionQC" , "   [-QC (Avvertenze di conflitti Quiet Pattern)]" } , { "optionQ" , "   [-Q  (Modalità Quiet)]" } , { "optionLF" , "   [-LF (Usa nuove righe solo su output {valore predefinito CR/LF})]" } , { "optionCR" , "   [-CR (Usa ritorno a capo solo su output {valore predefinito CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Quali carattere saltare {valore predefinito <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Controlla il numero di spazi del rientro {valore predefinito 0})]" } , { "optionTT" , "   [-TT (Traccia i modelli man mano che sono chiamati)]" } , { "optionTG" , "   [-TG (Traccia ogni evento di generazione)]" } , { "optionTS" , "   [-TS (Traccia ogni evento di selezione)]" } , { "optionTTC" , "   [-TTC (Traccia gli elementi secondari del modello man mano che sono elaborati)]" } , { "optionTCLASS" , "   [-TCLASS (Classe TraceListener per le estensioni di traccia)]" } , { "optionVALIDATE" , "   [-VALIDATE (Imposta se eseguire la validazione. Il valore predefinito è validazione disattivata.)]" } , { "optionEDUMP" , "   [-EDUMP {nome file opzionale} (Esegue il dump dello stack in caso di errore)]" } , { "optionXML" , "   [-XML (Utilizza il formattatore XML e aggiunge l'intestazione XML)]" } , { "optionTEXT" , "   [-TEXT (Utilizza il formattatore di testo semplice)]" } , { "optionHTML" , "   [-HTML (Utilizza il formattatore HTML)]" } , { "optionPARAM" , "   [-PARAM espressione nome (Imposta un parametro di foglio di stile)]" } , { "noParsermsg1" , "Processo XSL non riuscito." } , { "noParsermsg2" , "** Impossibile trovare il parser **" } , { "noParsermsg3" , "Verificare il classpath." } , { "noParsermsg4" , "Se non si dispone del parser XML IBM per Java, scaricarlo da" } , { "noParsermsg5" , "AlphaWorks IBM: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER nome classe completo (URIResolver da utilizzare per risolvere gli URI)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER nome classe completo (EntityResolver da utilizzare per risolvere le entità)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER nome classe completo (ContentHandler da utilizzare per serializzare l'output)]" } , { "optionLINENUMBERS" , "   [-L utilizza i numeri di linea per i documenti sorgente]" } , { "optionMEDIA" , " [-MEDIA mediaType (utilizzare l'attributo media per trovare il foglio di stile associato a un documento.)]" } , { "optionFLAVOR" , " [-FLAVOR flavorName (utilizzare esplicitamente s2s=SAX o d2d=DOM per effettuare la trasformazione.)] " } , { "optionDIAG" , " [-DIAG (stampa i millisecondi globali impiegati dalla trasformazione.)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (richiede la costruzione DTM incrementale impostando a true http://xml.apache.org/xalan/features/incremental.)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (non richiede l'elaborazione dell'ottimizzazione del foglio di stile impostando a false http://xml.apache.org/xalan/features/optimize.)]" } , { "optionRL" , " [-RL recursionlimit (garantisce il limite numerico sulla profondità di ricorsione del foglio di stile.)]" } , { "optionXO" , " [-XO [transletName] (assegna il nome al translet generato)]" } , { "optionXD" , " [-XD destinationDirectory (specifica una directory di destinazione per il translet)]" } , { "optionXJ" , " [-XJ jarfile (compatta la classi del translet in un file jar denominato <filejar>)]" } , { "optionXP" , " [-XP package (specifica un prefisso del nome di pacchetto per tutte le classi translet generate)]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Errore: " ; public static final String WARNING_HEADER = "Avvertenza: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	0	['4', '4', '0', '1', '11', '4', '0', '1', '2', '1.282051282', '3800', '0', '0', '0.953488372', '0.5', '2', '2', '945.75', '2', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ValueOf extends Instruction { private Expression _select ; private boolean _escaping = true ; private boolean _isString = false ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ValueOf" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; } public void parseContents ( Parser parser ) { _select = parser . parseExpression ( this , "select" , null ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; return ; } final String str = getAttribute ( "disable-output-escaping" ) ; if ( ( str != null ) && ( str . equals ( "yes" ) ) ) _escaping = false ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type type = _select . typeCheck ( stable ) ; if ( type != null && ! type . identicalTo ( Type . Node ) ) { if ( type . identicalTo ( Type . NodeSet ) ) { _select = new CastExpr ( _select , Type . Node ) ; } else { _isString = true ; if ( ! type . identicalTo ( Type . String ) ) { _select = new CastExpr ( _select , Type . String ) ; } _isString = true ; } } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int setEscaping = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "setEscaping" , "(Z)Z" ) ; if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEINTERFACE ( setEscaping , 2 ) ) ; } if ( _isString ) { final int characters = cpg . addMethodref ( TRANSLET_CLASS , CHARACTERSW , CHARACTERSW_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( characters ) ) ; } else { final int characters = cpg . addInterfaceMethodref ( DOM_INTF , CHARACTERS , CHARACTERS_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( characters , 3 ) ) ; } if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( setEscaping , 2 ) ) ; il . append ( POP ) ; } } } 	0	['5', '3', '0', '20', '33', '0', '1', '20', '4', '0.416666667', '237', '1', '1', '0.933333333', '0.333333333', '2', '6', '45.8', '4', '2', '0']
package org . apache . xalan . processor ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetComposed ; import org . apache . xalan . templates . StylesheetRoot ; import org . xml . sax . Attributes ; class ProcessorStylesheetElement extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { super . startElement ( handler , uri , localName , rawName , attributes ) ; try { int stylesheetType = handler . getStylesheetType ( ) ; Stylesheet stylesheet ; if ( stylesheetType == StylesheetHandler . STYPE_ROOT ) { try { stylesheet = new StylesheetRoot ( handler . getSchema ( ) , handler . getStylesheetProcessor ( ) . getErrorListener ( ) ) ; } catch ( TransformerConfigurationException tfe ) { throw new TransformerException ( tfe ) ; } } else { Stylesheet parent = handler . getStylesheet ( ) ; if ( stylesheetType == StylesheetHandler . STYPE_IMPORT ) { StylesheetComposed sc = new StylesheetComposed ( parent ) ; parent . setImport ( sc ) ; stylesheet = sc ; } else { stylesheet = new Stylesheet ( parent ) ; parent . setInclude ( stylesheet ) ; } } stylesheet . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; stylesheet . setLocaterInfo ( handler . getLocator ( ) ) ; stylesheet . setPrefixes ( handler . getNamespaceSupport ( ) ) ; handler . pushStylesheet ( stylesheet ) ; setPropertiesFromAttributes ( handler , rawName , attributes , handler . getStylesheet ( ) ) ; handler . pushElemTemplateElement ( handler . getStylesheet ( ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { super . endElement ( handler , uri , localName , rawName ) ; handler . popElemTemplateElement ( ) ; handler . popStylesheet ( ) ; } } 	0	['3', '4', '0', '9', '29', '3', '2', '9', '2', '2', '107', '0', '0', '0.990566038', '0.666666667', '1', '1', '34.66666667', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . Type ; final class SlotAllocator { private int _firstAvailableSlot ; private int _size = 8 ; private int _free = 0 ; private int [ ] _slotsTaken = new int [ _size ] ; public void initialize ( LocalVariableGen [ ] vars ) { final int length = vars . length ; int slot = 0 , size , index ; for ( int i = 0 ; i < length ; i ++ ) { size = vars [ i ] . getType ( ) . getSize ( ) ; index = vars [ i ] . getIndex ( ) ; slot = Math . max ( slot , index + size ) ; } _firstAvailableSlot = slot ; } public int allocateSlot ( Type type ) { final int size = type . getSize ( ) ; final int limit = _free ; int slot = _firstAvailableSlot , where = 0 ; if ( _free + size > _size ) { final int [ ] array = new int [ _size *= 2 ] ; for ( int j = 0 ; j < limit ; j ++ ) array [ j ] = _slotsTaken [ j ] ; _slotsTaken = array ; } while ( where < limit ) { if ( slot + size <= _slotsTaken [ where ] ) { for ( int j = limit - 1 ; j >= where ; j -- ) _slotsTaken [ j + size ] = _slotsTaken [ j ] ; break ; } else { slot = _slotsTaken [ where ++ ] + 1 ; } } for ( int j = 0 ; j < size ; j ++ ) _slotsTaken [ where + j ] = slot + j ; _free += size ; return slot ; } public void releaseSlot ( LocalVariableGen lvg ) { final int size = lvg . getType ( ) . getSize ( ) ; final int slot = lvg . getIndex ( ) ; final int limit = _free ; for ( int i = 0 ; i < limit ; i ++ ) { if ( _slotsTaken [ i ] == slot ) { int j = i + size ; while ( j < limit ) { _slotsTaken [ i ++ ] = _slotsTaken [ j ++ ] ; } _free -= size ; return ; } } String state = "Variable slot allocation error" + "(size=" + size + ", slot=" + slot + ", limit=" + limit + ")" ; ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , state ) ; throw new Error ( err . toString ( ) ) ; } } 	0	['4', '1', '0', '4', '16', '0', '1', '3', '3', '0.5', '242', '1', '0', '0', '0.4375', '0', '0', '58.5', '6', '3', '0']
package org . apache . xalan . trace ; import java . util . TooManyListenersException ; import java . util . Vector ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; public class TraceManager { private TransformerImpl m_transformer ; public TraceManager ( TransformerImpl transformer ) { m_transformer = transformer ; } private Vector m_traceListeners = null ; public void addTraceListener ( TraceListener tl ) throws TooManyListenersException { TransformerImpl . S_DEBUG = true ; if ( null == m_traceListeners ) m_traceListeners = new Vector ( ) ; m_traceListeners . addElement ( tl ) ; } public void removeTraceListener ( TraceListener tl ) { if ( null != m_traceListeners ) { m_traceListeners . removeElement ( tl ) ; if ( 0 == m_traceListeners . size ( ) ) m_traceListeners = null ; } } public void fireGenerateEvent ( GenerateEvent te ) { if ( null != m_traceListeners ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . generated ( te ) ; } } } public boolean hasTraceListeners ( ) { return ( null != m_traceListeners ) ; } public void fireTraceEvent ( ElemTemplateElement styleNode ) { if ( hasTraceListeners ( ) ) { int sourceNode = m_transformer . getXPathContext ( ) . getCurrentNode ( ) ; Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireTraceEvent ( new TracerEvent ( m_transformer , source , m_transformer . getMode ( ) , styleNode ) ) ; } } public void fireTraceEndEvent ( ElemTemplateElement styleNode ) { if ( hasTraceListeners ( ) ) { int sourceNode = m_transformer . getXPathContext ( ) . getCurrentNode ( ) ; Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireTraceEndEvent ( new TracerEvent ( m_transformer , source , m_transformer . getMode ( ) , styleNode ) ) ; } } public void fireTraceEndEvent ( TracerEvent te ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx2 ) { ( ( TraceListenerEx2 ) tl ) . traceEnd ( te ) ; } } } } public void fireTraceEvent ( TracerEvent te ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . trace ( te ) ; } } } public void fireSelectedEvent ( int sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireSelectedEvent ( new SelectionEvent ( m_transformer , source , styleNode , attributeName , xpath , selection ) ) ; } } public void fireSelectedEndEvent ( int sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireSelectedEndEvent ( new EndSelectionEvent ( m_transformer , source , styleNode , attributeName , xpath , selection ) ) ; } } public void fireSelectedEndEvent ( EndSelectionEvent se ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx ) ( ( TraceListenerEx ) tl ) . selectEnd ( se ) ; } } } public void fireSelectedEvent ( SelectionEvent se ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . selected ( se ) ; } } } } 	0	['13', '1', '0', '38', '32', '0', '25', '14', '13', '0.333333333', '301', '1', '1', '0', '0.211538462', '0', '0', '22', '4', '1.8462', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class FilteredAbsoluteLocationPath extends Expression { private Expression _path ; public FilteredAbsoluteLocationPath ( ) { _path = null ; } public FilteredAbsoluteLocationPath ( Expression path ) { _path = path ; if ( path != null ) { _path . setParent ( this ) ; } } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _path != null ) { _path . setParser ( parser ) ; } } public Expression getPath ( ) { return ( _path ) ; } public String toString ( ) { return "FilteredAbsoluteLocationPath(" + ( _path != null ? _path . toString ( ) : "null" ) + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _path != null ) { final Type ptype = _path . typeCheck ( stable ) ; if ( ptype instanceof NodeType ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _path != null ) { final int initDFI = cpg . addMethodref ( DUP_FILTERED_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( DUP_FILTERED_ITERATOR ) ) ) ; il . append ( DUP ) ; _path . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initDFI ) ) ; } else { final int git = cpg . addInterfaceMethodref ( DOM_INTF , "getIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEINTERFACE ( git , 1 ) ) ; } } } 	0	['7', '3', '0', '18', '28', '0', '0', '18', '7', '0', '143', '1', '1', '0.934210526', '0.285714286', '2', '7', '19.28571429', '2', '1.1429', '0']
package org . apache . xml . serializer ; import java . util . Properties ; public class OutputPropertyUtils { public static boolean getBooleanProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null == s || ! s . equals ( "yes" ) ) return false ; else return true ; } public static int getIntProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null == s ) return 0 ; else return Integer . parseInt ( s ) ; } } 	0	['3', '1', '0', '3', '7', '3', '3', '0', '3', '2', '33', '0', '0', '0', '0.555555556', '0', '0', '10', '3', '1.6667', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import javax . xml . transform . Source ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public abstract class DTMDefaultBaseTraversers extends DTMDefaultBase { public DTMDefaultBaseTraversers ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; } public DTMDefaultBaseTraversers ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib ) ; } public DTMAxisTraverser getAxisTraverser ( final int axis ) { DTMAxisTraverser traverser ; if ( null == m_traversers ) { m_traversers = new DTMAxisTraverser [ Axis . names . length ] ; traverser = null ; } else { traverser = m_traversers [ axis ] ; if ( traverser != null ) return traverser ; } switch ( axis ) { case Axis . ANCESTOR : traverser = new AncestorTraverser ( ) ; break ; case Axis . ANCESTORORSELF : traverser = new AncestorOrSelfTraverser ( ) ; break ; case Axis . ATTRIBUTE : traverser = new AttributeTraverser ( ) ; break ; case Axis . CHILD : traverser = new ChildTraverser ( ) ; break ; case Axis . DESCENDANT : traverser = new DescendantTraverser ( ) ; break ; case Axis . DESCENDANTORSELF : traverser = new DescendantOrSelfTraverser ( ) ; break ; case Axis . FOLLOWING : traverser = new FollowingTraverser ( ) ; break ; case Axis . FOLLOWINGSIBLING : traverser = new FollowingSiblingTraverser ( ) ; break ; case Axis . NAMESPACE : traverser = new NamespaceTraverser ( ) ; break ; case Axis . NAMESPACEDECLS : traverser = new NamespaceDeclsTraverser ( ) ; break ; case Axis . PARENT : traverser = new ParentTraverser ( ) ; break ; case Axis . PRECEDING : traverser = new PrecedingTraverser ( ) ; break ; case Axis . PRECEDINGSIBLING : traverser = new PrecedingSiblingTraverser ( ) ; break ; case Axis . SELF : traverser = new SelfTraverser ( ) ; break ; case Axis . ALL : traverser = new AllFromRootTraverser ( ) ; break ; case Axis . ALLFROMNODE : traverser = new AllFromNodeTraverser ( ) ; break ; case Axis . PRECEDINGANDANCESTOR : traverser = new PrecedingAndAncestorTraverser ( ) ; break ; case Axis . DESCENDANTSFROMROOT : traverser = new DescendantFromRootTraverser ( ) ; break ; case Axis . DESCENDANTSORSELFFROMROOT : traverser = new DescendantOrSelfFromRootTraverser ( ) ; break ; case Axis . ROOT : traverser = new RootTraverser ( ) ; break ; case Axis . FILTEREDLIST : return null ; default : throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_UNKNOWN_AXIS_TYPE , new Object [ ] { Integer . toString ( axis ) } ) ) ; } if ( null == traverser ) throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_AXIS_TRAVERSER_NOT_SUPPORTED , new Object [ ] { Axis . names [ axis ] } ) ) ; m_traversers [ axis ] = traverser ; return traverser ; } private class AncestorTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return getParent ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { current = makeNodeIdentity ( current ) ; while ( DTM . NULL != ( current = m_parent . elementAt ( current ) ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } } private class AncestorOrSelfTraverser extends AncestorTraverser { public int first ( int context ) { return context ; } public int first ( int context , int expandedTypeID ) { return ( getExpandedTypeID ( context ) == expandedTypeID ) ? context : next ( context , context , expandedTypeID ) ; } } private class AttributeTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return ( context == current ) ? getFirstAttribute ( context ) : getNextAttribute ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { current = ( context == current ) ? getFirstAttribute ( context ) : getNextAttribute ( current ) ; do { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } while ( DTM . NULL != ( current = getNextAttribute ( current ) ) ) ; return NULL ; } } private class ChildTraverser extends DTMAxisTraverser { protected int getNextIndexed ( int axisRoot , int nextPotential , int expandedTypeID ) { int nsIndex = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; int lnIndex = m_expandedNameTable . getLocalNameID ( expandedTypeID ) ; for ( ; ; ) { int nextID = findElementFromIndex ( nsIndex , lnIndex , nextPotential ) ; if ( NOTPROCESSED != nextID ) { int parentID = m_parent . elementAt ( nextID ) ; if ( parentID == axisRoot ) return nextID ; if ( parentID < axisRoot ) return NULL ; do { parentID = m_parent . elementAt ( parentID ) ; if ( parentID < axisRoot ) return NULL ; } while ( parentID > axisRoot ) ; nextPotential = nextID + 1 ; continue ; } nextNode ( ) ; if ( ! ( m_nextsib . elementAt ( axisRoot ) == NOTPROCESSED ) ) break ; } return DTM . NULL ; } public int first ( int context ) { return getFirstChild ( context ) ; } public int first ( int context , int expandedTypeID ) { if ( true ) { int identity = makeNodeIdentity ( context ) ; int firstMatch = getNextIndexed ( identity , _firstch ( identity ) , expandedTypeID ) ; return makeNodeHandle ( firstMatch ) ; } else { for ( int current = _firstch ( makeNodeIdentity ( context ) ) ; DTM . NULL != current ; current = _nextsib ( current ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } } public int next ( int context , int current ) { return getNextSibling ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { for ( current = _nextsib ( makeNodeIdentity ( current ) ) ; DTM . NULL != current ; current = _nextsib ( current ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } } private abstract class IndexedDTMAxisTraverser extends DTMAxisTraverser { protected final boolean isIndexed ( int expandedTypeID ) { return ( m_indexing && ExpandedNameTable . ELEMENT == m_expandedNameTable . getType ( expandedTypeID ) ) ; } protected abstract boolean isAfterAxis ( int axisRoot , int identity ) ; protected abstract boolean axisHasBeenProcessed ( int axisRoot ) ; protected int getNextIndexed ( int axisRoot , int nextPotential , int expandedTypeID ) { int nsIndex = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; int lnIndex = m_expandedNameTable . getLocalNameID ( expandedTypeID ) ; while ( true ) { int next = findElementFromIndex ( nsIndex , lnIndex , nextPotential ) ; if ( NOTPROCESSED != next ) { if ( isAfterAxis ( axisRoot , next ) ) return NULL ; return next ; } else if ( axisHasBeenProcessed ( axisRoot ) ) break ; nextNode ( ) ; } return DTM . NULL ; } } private class DescendantTraverser extends IndexedDTMAxisTraverser { protected int getFirstPotential ( int identity ) { return identity + 1 ; } protected boolean axisHasBeenProcessed ( int axisRoot ) { return ! ( m_nextsib . elementAt ( axisRoot ) == NOTPROCESSED ) ; } protected int getSubtreeRoot ( int handle ) { return makeNodeIdentity ( handle ) ; } protected boolean isDescendant ( int subtreeRootIdentity , int identity ) { return _parent ( identity ) >= subtreeRootIdentity ; } protected boolean isAfterAxis ( int axisRoot , int identity ) { do { if ( identity == axisRoot ) return false ; identity = m_parent . elementAt ( identity ) ; } while ( identity >= axisRoot ) ; return true ; } public int first ( int context , int expandedTypeID ) { if ( isIndexed ( expandedTypeID ) ) { int identity = getSubtreeRoot ( context ) ; int firstPotential = getFirstPotential ( identity ) ; return makeNodeHandle ( getNextIndexed ( identity , firstPotential , expandedTypeID ) ) ; } return next ( context , context , expandedTypeID ) ; } public int next ( int context , int current ) { int subtreeRootIdent = getSubtreeRoot ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { int type = _type ( current ) ; if ( ! isDescendant ( subtreeRootIdent , current ) ) return NULL ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; return makeNodeHandle ( current ) ; } } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = getSubtreeRoot ( context ) ; current = makeNodeIdentity ( current ) + 1 ; if ( isIndexed ( expandedTypeID ) ) { return makeNodeHandle ( getNextIndexed ( subtreeRootIdent , current , expandedTypeID ) ) ; } for ( ; ; current ++ ) { int exptype = _exptype ( current ) ; if ( ! isDescendant ( subtreeRootIdent , current ) ) return NULL ; if ( exptype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } } } private class DescendantOrSelfTraverser extends DescendantTraverser { protected int getFirstPotential ( int identity ) { return identity ; } public int first ( int context ) { return context ; } } private class AllFromNodeTraverser extends DescendantOrSelfTraverser { public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { _exptype ( current ) ; if ( ! isDescendant ( subtreeRootIdent , current ) ) return NULL ; return makeNodeHandle ( current ) ; } } } private class FollowingTraverser extends DescendantTraverser { public int first ( int context ) { context = makeNodeIdentity ( context ) ; int first ; int type = _type ( context ) ; if ( ( DTM . ATTRIBUTE_NODE == type ) || ( DTM . NAMESPACE_NODE == type ) ) { context = _parent ( context ) ; first = _firstch ( context ) ; if ( NULL != first ) return makeNodeHandle ( first ) ; } do { first = _nextsib ( context ) ; if ( NULL == first ) context = _parent ( context ) ; } while ( NULL == first && NULL != context ) ; return makeNodeHandle ( first ) ; } public int first ( int context , int expandedTypeID ) { int first ; int type = getNodeType ( context ) ; if ( ( DTM . ATTRIBUTE_NODE == type ) || ( DTM . NAMESPACE_NODE == type ) ) { context = getParent ( context ) ; first = getFirstChild ( context ) ; if ( NULL != first ) { if ( getExpandedTypeID ( first ) == expandedTypeID ) return first ; else return next ( context , first , expandedTypeID ) ; } } do { first = getNextSibling ( context ) ; if ( NULL == first ) context = getParent ( context ) ; else { if ( getExpandedTypeID ( first ) == expandedTypeID ) return first ; else return next ( context , first , expandedTypeID ) ; } } while ( NULL == first && NULL != context ) ; return first ; } public int next ( int context , int current ) { current = makeNodeIdentity ( current ) ; while ( true ) { current ++ ; int type = _type ( current ) ; if ( NULL == type ) return NULL ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; return makeNodeHandle ( current ) ; } } public int next ( int context , int current , int expandedTypeID ) { current = makeNodeIdentity ( current ) ; while ( true ) { current ++ ; int etype = _exptype ( current ) ; if ( NULL == etype ) return NULL ; if ( etype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } } } private class FollowingSiblingTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return getNextSibling ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { while ( DTM . NULL != ( current = getNextSibling ( current ) ) ) { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } return NULL ; } } private class NamespaceDeclsTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return ( context == current ) ? getFirstNamespaceNode ( context , false ) : getNextNamespaceNode ( context , current , false ) ; } public int next ( int context , int current , int expandedTypeID ) { current = ( context == current ) ? getFirstNamespaceNode ( context , false ) : getNextNamespaceNode ( context , current , false ) ; do { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } while ( DTM . NULL != ( current = getNextNamespaceNode ( context , current , false ) ) ) ; return NULL ; } } private class NamespaceTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return ( context == current ) ? getFirstNamespaceNode ( context , true ) : getNextNamespaceNode ( context , current , true ) ; } public int next ( int context , int current , int expandedTypeID ) { current = ( context == current ) ? getFirstNamespaceNode ( context , true ) : getNextNamespaceNode ( context , current , true ) ; do { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } while ( DTM . NULL != ( current = getNextNamespaceNode ( context , current , true ) ) ) ; return NULL ; } } private class ParentTraverser extends DTMAxisTraverser { public int first ( int context ) { return getParent ( context ) ; } public int first ( int current , int expandedTypeID ) { current = makeNodeIdentity ( current ) ; while ( NULL != ( current = m_parent . elementAt ( current ) ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } public int next ( int context , int current ) { return NULL ; } public int next ( int context , int current , int expandedTypeID ) { return NULL ; } } private class PrecedingTraverser extends DTMAxisTraverser { protected boolean isAncestor ( int contextIdent , int currentIdent ) { for ( contextIdent = m_parent . elementAt ( contextIdent ) ; DTM . NULL != contextIdent ; contextIdent = m_parent . elementAt ( contextIdent ) ) { if ( contextIdent == currentIdent ) return true ; } return false ; } public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { short type = _type ( current ) ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type || isAncestor ( subtreeRootIdent , current ) ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { int exptype = m_exptype . elementAt ( current ) ; if ( exptype != expandedTypeID || isAncestor ( subtreeRootIdent , current ) ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } } private class PrecedingAndAncestorTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { short type = _type ( current ) ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { int exptype = m_exptype . elementAt ( current ) ; if ( exptype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } } private class PrecedingSiblingTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return getPreviousSibling ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { while ( DTM . NULL != ( current = getPreviousSibling ( current ) ) ) { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } return NULL ; } } private class SelfTraverser extends DTMAxisTraverser { public int first ( int context ) { return context ; } public int first ( int context , int expandedTypeID ) { return ( getExpandedTypeID ( context ) == expandedTypeID ) ? context : NULL ; } public int next ( int context , int current ) { return NULL ; } public int next ( int context , int current , int expandedTypeID ) { return NULL ; } } private class AllFromRootTraverser extends AllFromNodeTraverser { public int first ( int context ) { return getDocumentRoot ( context ) ; } public int first ( int context , int expandedTypeID ) { return ( getExpandedTypeID ( getDocumentRoot ( context ) ) == expandedTypeID ) ? context : next ( context , context , expandedTypeID ) ; } public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { int type = _type ( current ) ; if ( type == NULL ) return NULL ; return makeNodeHandle ( current ) ; } } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { int exptype = _exptype ( current ) ; if ( exptype == NULL ) return NULL ; if ( exptype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } } } private class RootTraverser extends AllFromRootTraverser { public int first ( int context , int expandedTypeID ) { int root = getDocumentRoot ( context ) ; return ( getExpandedTypeID ( root ) == expandedTypeID ) ? root : NULL ; } public int next ( int context , int current ) { return NULL ; } public int next ( int context , int current , int expandedTypeID ) { return NULL ; } } private class DescendantOrSelfFromRootTraverser extends DescendantTraverser { protected int getFirstPotential ( int identity ) { return identity ; } protected int getSubtreeRoot ( int handle ) { return makeNodeIdentity ( getDocument ( ) ) ; } public int first ( int context ) { return getDocumentRoot ( context ) ; } public int first ( int context , int expandedTypeID ) { if ( isIndexed ( expandedTypeID ) ) { int identity = 0 ; int firstPotential = getFirstPotential ( identity ) ; return makeNodeHandle ( getNextIndexed ( identity , firstPotential , expandedTypeID ) ) ; } int root = first ( context ) ; return next ( root , root , expandedTypeID ) ; } } private class DescendantFromRootTraverser extends DescendantTraverser { protected int getFirstPotential ( int identity ) { return _firstch ( 0 ) ; } protected int getSubtreeRoot ( int handle ) { return 0 ; } public int first ( int context ) { return makeNodeHandle ( _firstch ( 0 ) ) ; } public int first ( int context , int expandedTypeID ) { if ( isIndexed ( expandedTypeID ) ) { int identity = 0 ; int firstPotential = getFirstPotential ( identity ) ; return makeNodeHandle ( getNextIndexed ( identity , firstPotential , expandedTypeID ) ) ; } int root = getDocumentRoot ( context ) ; return next ( root , root , expandedTypeID ) ; } } } 	0	['3', '2', '1', '31', '28', '3', '22', '29', '3', '2', '225', '0', '0', '0.989130435', '0.761904762', '0', '0', '74', '5', '1.6667', '0']
package org . apache . xml . dtm ; public interface DTMWSFilter { public static final short NOTSTRIP = 1 ; public static final short STRIP = 2 ; public static final short INHERIT = 3 ; public short getShouldStripSpace ( int elementHandle , DTM dtm ) ; } 	0	['1', '1', '0', '27', '1', '0', '26', '1', '1', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . w3c . dom . xpath ; public class XPathException extends RuntimeException { public XPathException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short INVALID_EXPRESSION_ERR = 1 ; public static final short TYPE_ERR = 2 ; } 	0	['1', '4', '0', '0', '2', '0', '0', '0', '1', '2', '11', '0', '0', '1', '1', '0', '0', '7', '0', '0', '0']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . WhiteSpaceInfo ; import org . apache . xpath . XPath ; import org . xml . sax . Attributes ; class ProcessorStripSpace extends ProcessorPreserveSpace { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { Stylesheet thisSheet = handler . getStylesheet ( ) ; WhitespaceInfoPaths paths = new WhitespaceInfoPaths ( thisSheet ) ; setPropertiesFromAttributes ( handler , rawName , attributes , paths ) ; Vector xpaths = paths . getElements ( ) ; for ( int i = 0 ; i < xpaths . size ( ) ; i ++ ) { WhiteSpaceInfo wsi = new WhiteSpaceInfo ( ( XPath ) xpaths . elementAt ( i ) , true , thisSheet ) ; wsi . setUid ( handler . nextUid ( ) ) ; thisSheet . setStripSpaces ( wsi ) ; } paths . clearElements ( ) ; } } 	0	['2', '5', '0', '8', '14', '1', '1', '7', '1', '2', '50', '0', '0', '0.995283019', '0.625', '2', '2', '24', '1', '0.5', '0']
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; import org . apache . xalan . xsltc . dom . SAXImpl ; public class DOM2SAX implements XMLReader , Locator { private final static String EMPTYSTRING = "" ; private static final String XMLNS_PREFIX = "xmlns" ; private Node _dom = null ; private ContentHandler _sax = null ; private LexicalHandler _lex = null ; private SAXImpl _saxImpl = null ; private Hashtable _nsPrefixes = new Hashtable ( ) ; public DOM2SAX ( Node root ) { _dom = root ; } public ContentHandler getContentHandler ( ) { return _sax ; } public void setContentHandler ( ContentHandler handler ) throws NullPointerException { _sax = handler ; if ( handler instanceof LexicalHandler ) { _lex = ( LexicalHandler ) handler ; } if ( handler instanceof SAXImpl ) { _saxImpl = ( SAXImpl ) handler ; } } private boolean startPrefixMapping ( String prefix , String uri ) throws SAXException { boolean pushed = true ; Stack uriStack = ( Stack ) _nsPrefixes . get ( prefix ) ; if ( uriStack != null ) { if ( uriStack . isEmpty ( ) ) { _sax . startPrefixMapping ( prefix , uri ) ; uriStack . push ( uri ) ; } else { final String lastUri = ( String ) uriStack . peek ( ) ; if ( ! lastUri . equals ( uri ) ) { _sax . startPrefixMapping ( prefix , uri ) ; uriStack . push ( uri ) ; } else { pushed = false ; } } } else { _sax . startPrefixMapping ( prefix , uri ) ; _nsPrefixes . put ( prefix , uriStack = new Stack ( ) ) ; uriStack . push ( uri ) ; } return pushed ; } private void endPrefixMapping ( String prefix ) throws SAXException { final Stack uriStack = ( Stack ) _nsPrefixes . get ( prefix ) ; if ( uriStack != null ) { _sax . endPrefixMapping ( prefix ) ; uriStack . pop ( ) ; } } private static String getLocalName ( Node node ) { final String localName = node . getLocalName ( ) ; if ( localName == null ) { final String qname = node . getNodeName ( ) ; final int col = qname . lastIndexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( col + 1 ) : qname ; } return localName ; } public void parse ( InputSource unused ) throws IOException , SAXException { parse ( _dom ) ; } public void parse ( ) throws IOException , SAXException { if ( _dom != null ) { boolean isIncomplete = ( _dom . getNodeType ( ) != org . w3c . dom . Node . DOCUMENT_NODE ) ; if ( isIncomplete ) { _sax . startDocument ( ) ; parse ( _dom ) ; _sax . endDocument ( ) ; } else { parse ( _dom ) ; } } } private void parse ( Node node ) throws IOException , SAXException { Node first = null ; if ( node == null ) return ; switch ( node . getNodeType ( ) ) { case Node . ATTRIBUTE_NODE : case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . ENTITY_NODE : case Node . ENTITY_REFERENCE_NODE : case Node . NOTATION_NODE : break ; case Node . CDATA_SECTION_NODE : final String cdata = node . getNodeValue ( ) ; if ( _lex != null ) { _lex . startCDATA ( ) ; _sax . characters ( cdata . toCharArray ( ) , 0 , cdata . length ( ) ) ; _lex . endCDATA ( ) ; } else { _sax . characters ( cdata . toCharArray ( ) , 0 , cdata . length ( ) ) ; } break ; case Node . COMMENT_NODE : if ( _lex != null ) { final String value = node . getNodeValue ( ) ; _lex . comment ( value . toCharArray ( ) , 0 , value . length ( ) ) ; } break ; case Node . DOCUMENT_NODE : _sax . setDocumentLocator ( this ) ; _sax . startDocument ( ) ; Node next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _sax . endDocument ( ) ; break ; case Node . ELEMENT_NODE : String prefix ; Vector pushedPrefixes = new Vector ( ) ; final AttributesImpl attrs = new AttributesImpl ( ) ; final NamedNodeMap map = node . getAttributes ( ) ; final int length = map . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNodeValue ( ) ; final int colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( colon + 1 ) : EMPTYSTRING ; if ( startPrefixMapping ( prefix , uriAttr ) ) { pushedPrefixes . addElement ( prefix ) ; } } } for ( int i = 0 ; i < length ; i ++ ) { final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( ! qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNamespaceURI ( ) ; final String localNameAttr = getLocalName ( attr ) ; if ( uriAttr != null ) { final int colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( 0 , colon ) : EMPTYSTRING ; if ( startPrefixMapping ( prefix , uriAttr ) ) { pushedPrefixes . addElement ( prefix ) ; } } attrs . addAttribute ( attr . getNamespaceURI ( ) , getLocalName ( attr ) , qnameAttr , "CDATA" , attr . getNodeValue ( ) ) ; } } final String qname = node . getNodeName ( ) ; final String uri = node . getNamespaceURI ( ) ; final String localName = getLocalName ( node ) ; if ( uri != null ) { final int colon = qname . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qname . substring ( 0 , colon ) : EMPTYSTRING ; if ( startPrefixMapping ( prefix , uri ) ) { pushedPrefixes . addElement ( prefix ) ; } } if ( _saxImpl != null ) { _saxImpl . startElement ( uri , localName , qname , attrs , node ) ; } else { _sax . startElement ( uri , localName , qname , attrs ) ; } next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _sax . endElement ( uri , localName , qname ) ; final int nPushedPrefixes = pushedPrefixes . size ( ) ; for ( int i = 0 ; i < nPushedPrefixes ; i ++ ) { endPrefixMapping ( ( String ) pushedPrefixes . elementAt ( i ) ) ; } break ; case Node . PROCESSING_INSTRUCTION_NODE : _sax . processingInstruction ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; break ; case Node . TEXT_NODE : final String data = node . getNodeValue ( ) ; _sax . characters ( data . toCharArray ( ) , 0 , data . length ( ) ) ; break ; } } public DTDHandler getDTDHandler ( ) { return null ; } public ErrorHandler getErrorHandler ( ) { return null ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return false ; } public void setFeature ( String name , boolean value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public void parse ( String sysId ) throws IOException , SAXException { throw new IOException ( "This method is not yet implemented." ) ; } public void setDTDHandler ( DTDHandler handler ) throws NullPointerException { } public void setEntityResolver ( EntityResolver resolver ) throws NullPointerException { } public EntityResolver getEntityResolver ( ) { return null ; } public void setErrorHandler ( ErrorHandler handler ) throws NullPointerException { } public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return null ; } public int getColumnNumber ( ) { return 0 ; } public int getLineNumber ( ) { return 0 ; } public String getPublicId ( ) { return null ; } public String getSystemId ( ) { return null ; } private String getNodeTypeFromCode ( short code ) { String retval = null ; switch ( code ) { case Node . ATTRIBUTE_NODE : retval = "ATTRIBUTE_NODE" ; break ; case Node . CDATA_SECTION_NODE : retval = "CDATA_SECTION_NODE" ; break ; case Node . COMMENT_NODE : retval = "COMMENT_NODE" ; break ; case Node . DOCUMENT_FRAGMENT_NODE : retval = "DOCUMENT_FRAGMENT_NODE" ; break ; case Node . DOCUMENT_NODE : retval = "DOCUMENT_NODE" ; break ; case Node . DOCUMENT_TYPE_NODE : retval = "DOCUMENT_TYPE_NODE" ; break ; case Node . ELEMENT_NODE : retval = "ELEMENT_NODE" ; break ; case Node . ENTITY_NODE : retval = "ENTITY_NODE" ; break ; case Node . ENTITY_REFERENCE_NODE : retval = "ENTITY_REFERENCE_NODE" ; break ; case Node . NOTATION_NODE : retval = "NOTATION_NODE" ; break ; case Node . PROCESSING_INSTRUCTION_NODE : retval = "PROCESSING_INSTRUCTION_NODE" ; break ; case Node . TEXT_NODE : retval = "TEXT_NODE" ; break ; } return retval ; } } 	0	['25', '1', '0', '3', '71', '254', '2', '1', '20', '0.892857143', '582', '1', '1', '0', '0.152727273', '0', '0', '22', '3', '1.08', '0']
package org . apache . xml . dtm ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } public static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } public ClassLoader getContextClassLoader ( ) { return null ; } public String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } public FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } public InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } 	0	['7', '1', '1', '2', '14', '19', '2', '1', '5', '0.833333333', '76', '1', '0', '0', '0.375', '0', '0', '9.714285714', '2', '0.8571', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public class SingletonIterator extends DTMAxisIteratorBase { private int _node ; private final boolean _isConstant ; public SingletonIterator ( ) { this ( Integer . MIN_VALUE , false ) ; } public SingletonIterator ( int node ) { this ( node , false ) ; } public SingletonIterator ( int node , boolean constant ) { _node = _startNode = node ; _isConstant = constant ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isConstant ) { _node = _startNode ; return resetPosition ( ) ; } else if ( _isRestartable ) { if ( _node <= 0 ) _node = _startNode = node ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { if ( _isConstant ) { _node = _startNode ; return resetPosition ( ) ; } else { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _startNode ) ; _isRestartable = temp ; } return this ; } public int next ( ) { final int result = _node ; _node = DTMAxisIterator . END ; return returnNode ( result ) ; } public void setMark ( ) { _markedNode = _node ; } public void gotoMark ( ) { _node = _markedNode ; } } 	0	['8', '2', '0', '4', '11', '0', '2', '2', '8', '0.214285714', '105', '1', '0', '0.722222222', '0.5', '1', '6', '11.875', '4', '1.125', '0']
package org . apache . xalan . transformer ; import javax . xml . transform . Transformer ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public class XalanTransformState implements TransformState { Node m_node = null ; ElemTemplateElement m_currentElement = null ; ElemTemplate m_currentTemplate = null ; ElemTemplate m_matchedTemplate = null ; int m_currentNodeHandle = DTM . NULL ; Node m_currentNode = null ; int m_matchedNode = DTM . NULL ; DTMIterator m_contextNodeList = null ; boolean m_elemPending = false ; TransformerImpl m_transformer = null ; public void setCurrentNode ( Node n ) { m_node = n ; } public void resetState ( Transformer transformer ) { if ( ( transformer != null ) && ( transformer instanceof TransformerImpl ) ) { m_transformer = ( TransformerImpl ) transformer ; m_currentElement = m_transformer . getCurrentElement ( ) ; m_currentTemplate = m_transformer . getCurrentTemplate ( ) ; m_matchedTemplate = m_transformer . getMatchedTemplate ( ) ; int currentNodeHandle = m_transformer . getCurrentNode ( ) ; DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( currentNodeHandle ) ; m_currentNode = dtm . getNode ( currentNodeHandle ) ; m_matchedNode = m_transformer . getMatchedNode ( ) ; m_contextNodeList = m_transformer . getContextNodeList ( ) ; } } public ElemTemplateElement getCurrentElement ( ) { if ( m_elemPending ) return m_currentElement ; else return m_transformer . getCurrentElement ( ) ; } public Node getCurrentNode ( ) { if ( m_currentNode != null ) { return m_currentNode ; } else { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_transformer . getCurrentNode ( ) ) ; return dtm . getNode ( m_transformer . getCurrentNode ( ) ) ; } } public ElemTemplate getCurrentTemplate ( ) { if ( m_elemPending ) return m_currentTemplate ; else return m_transformer . getCurrentTemplate ( ) ; } public ElemTemplate getMatchedTemplate ( ) { if ( m_elemPending ) return m_matchedTemplate ; else return m_transformer . getMatchedTemplate ( ) ; } public Node getMatchedNode ( ) { if ( m_elemPending ) { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_matchedNode ) ; return dtm . getNode ( m_matchedNode ) ; } else { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_transformer . getMatchedNode ( ) ) ; return dtm . getNode ( m_transformer . getMatchedNode ( ) ) ; } } public NodeIterator getContextNodeList ( ) { if ( m_elemPending ) { return new org . apache . xml . dtm . ref . DTMNodeIterator ( m_contextNodeList ) ; } else { return new org . apache . xml . dtm . ref . DTMNodeIterator ( m_transformer . getContextNodeList ( ) ) ; } } public Transformer getTransformer ( ) { return m_transformer ; } } 	0	['10', '1', '0', '8', '21', '0', '1', '8', '10', '0.711111111', '205', '0', '5', '0', '0.4', '0', '0', '18.5', '3', '1.7', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IF_ICMPNE ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . SIPUSH ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MultiHashtable ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; final class CastExpr extends Expression { private final Expression _left ; static private MultiHashtable InternalTypeMap = new MultiHashtable ( ) ; static { InternalTypeMap . put ( Type . Boolean , Type . Boolean ) ; InternalTypeMap . put ( Type . Boolean , Type . Real ) ; InternalTypeMap . put ( Type . Boolean , Type . String ) ; InternalTypeMap . put ( Type . Boolean , Type . Reference ) ; InternalTypeMap . put ( Type . Boolean , Type . Object ) ; InternalTypeMap . put ( Type . Real , Type . Real ) ; InternalTypeMap . put ( Type . Real , Type . Int ) ; InternalTypeMap . put ( Type . Real , Type . Boolean ) ; InternalTypeMap . put ( Type . Real , Type . String ) ; InternalTypeMap . put ( Type . Real , Type . Reference ) ; InternalTypeMap . put ( Type . Real , Type . Object ) ; InternalTypeMap . put ( Type . Int , Type . Int ) ; InternalTypeMap . put ( Type . Int , Type . Real ) ; InternalTypeMap . put ( Type . Int , Type . Boolean ) ; InternalTypeMap . put ( Type . Int , Type . String ) ; InternalTypeMap . put ( Type . Int , Type . Reference ) ; InternalTypeMap . put ( Type . Int , Type . Object ) ; InternalTypeMap . put ( Type . String , Type . String ) ; InternalTypeMap . put ( Type . String , Type . Boolean ) ; InternalTypeMap . put ( Type . String , Type . Real ) ; InternalTypeMap . put ( Type . String , Type . Reference ) ; InternalTypeMap . put ( Type . String , Type . Object ) ; InternalTypeMap . put ( Type . NodeSet , Type . NodeSet ) ; InternalTypeMap . put ( Type . NodeSet , Type . Boolean ) ; InternalTypeMap . put ( Type . NodeSet , Type . Real ) ; InternalTypeMap . put ( Type . NodeSet , Type . String ) ; InternalTypeMap . put ( Type . NodeSet , Type . Node ) ; InternalTypeMap . put ( Type . NodeSet , Type . Reference ) ; InternalTypeMap . put ( Type . NodeSet , Type . Object ) ; InternalTypeMap . put ( Type . Node , Type . Node ) ; InternalTypeMap . put ( Type . Node , Type . Boolean ) ; InternalTypeMap . put ( Type . Node , Type . Real ) ; InternalTypeMap . put ( Type . Node , Type . String ) ; InternalTypeMap . put ( Type . Node , Type . NodeSet ) ; InternalTypeMap . put ( Type . Node , Type . Reference ) ; InternalTypeMap . put ( Type . Node , Type . Object ) ; InternalTypeMap . put ( Type . ResultTree , Type . ResultTree ) ; InternalTypeMap . put ( Type . ResultTree , Type . Boolean ) ; InternalTypeMap . put ( Type . ResultTree , Type . Real ) ; InternalTypeMap . put ( Type . ResultTree , Type . String ) ; InternalTypeMap . put ( Type . ResultTree , Type . NodeSet ) ; InternalTypeMap . put ( Type . ResultTree , Type . Reference ) ; InternalTypeMap . put ( Type . ResultTree , Type . Object ) ; InternalTypeMap . put ( Type . Reference , Type . Reference ) ; InternalTypeMap . put ( Type . Reference , Type . Boolean ) ; InternalTypeMap . put ( Type . Reference , Type . Int ) ; InternalTypeMap . put ( Type . Reference , Type . Real ) ; InternalTypeMap . put ( Type . Reference , Type . String ) ; InternalTypeMap . put ( Type . Reference , Type . Node ) ; InternalTypeMap . put ( Type . Reference , Type . NodeSet ) ; InternalTypeMap . put ( Type . Reference , Type . ResultTree ) ; InternalTypeMap . put ( Type . Reference , Type . Object ) ; InternalTypeMap . put ( Type . Object , Type . String ) ; InternalTypeMap . put ( Type . Void , Type . String ) ; } private boolean _typeTest = false ; public CastExpr ( Expression left , Type type ) throws TypeCheckError { _left = left ; _type = type ; if ( ( _left instanceof Step ) && ( _type == Type . Boolean ) ) { Step step = ( Step ) _left ; if ( ( step . getAxis ( ) == Axis . SELF ) && ( step . getNodeType ( ) != - 1 ) ) _typeTest = true ; } setParser ( left . getParser ( ) ) ; setParent ( left . getParent ( ) ) ; left . setParent ( this ) ; typeCheck ( left . getParser ( ) . getSymbolTable ( ) ) ; } public Expression getExpr ( ) { return _left ; } public boolean hasPositionCall ( ) { return ( _left . hasPositionCall ( ) ) ; } public boolean hasLastCall ( ) { return ( _left . hasLastCall ( ) ) ; } public String toString ( ) { return "cast(" + _left + ", " + _type + ")" ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type tleft = _left . getType ( ) ; if ( tleft == null ) { tleft = _left . typeCheck ( stable ) ; } if ( tleft instanceof NodeType ) { tleft = Type . Node ; } else if ( tleft instanceof ResultTreeType ) { tleft = Type . ResultTree ; } if ( InternalTypeMap . maps ( tleft , _type ) != null ) { return _type ; } throw new TypeCheckError ( new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , tleft . toString ( ) , _type . toString ( ) ) ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { FlowList fl ; final Type ltype = _left . getType ( ) ; if ( _typeTest ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int idx = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; il . append ( new SIPUSH ( ( short ) ( ( Step ) _left ) . getNodeType ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( idx , 2 ) ) ; _falseList . add ( il . append ( new IF_ICMPNE ( null ) ) ) ; } else { _left . translate ( classGen , methodGen ) ; if ( _type != ltype ) { _left . startResetIterator ( classGen , methodGen ) ; if ( _type instanceof BooleanType ) { fl = ltype . translateToDesynthesized ( classGen , methodGen , _type ) ; if ( fl != null ) { _falseList . append ( fl ) ; } } else { ltype . translateTo ( classGen , methodGen , _type ) ; } } } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Type ltype = _left . getType ( ) ; _left . translate ( classGen , methodGen ) ; if ( _type . identicalTo ( ltype ) == false ) { _left . startResetIterator ( classGen , methodGen ) ; ltype . translateTo ( classGen , methodGen , _type ) ; } } } 	0	['9', '3', '0', '57', '49', '0', '33', '24', '8', '0.583333333', '536', '1', '2', '0.91025641', '0.3125', '2', '7', '58.22222222', '5', '1.3333', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . util . Vector ; public final class MethodType extends Type { private final Type _resultType ; private final Vector _argsType ; public MethodType ( Type resultType ) { _argsType = null ; _resultType = resultType ; } public MethodType ( Type resultType , Type arg1 ) { if ( arg1 != Type . Void ) { _argsType = new Vector ( ) ; _argsType . addElement ( arg1 ) ; } else { _argsType = null ; } _resultType = resultType ; } public MethodType ( Type resultType , Type arg1 , Type arg2 ) { _argsType = new Vector ( 2 ) ; _argsType . addElement ( arg1 ) ; _argsType . addElement ( arg2 ) ; _resultType = resultType ; } public MethodType ( Type resultType , Type arg1 , Type arg2 , Type arg3 ) { _argsType = new Vector ( 3 ) ; _argsType . addElement ( arg1 ) ; _argsType . addElement ( arg2 ) ; _argsType . addElement ( arg3 ) ; _resultType = resultType ; } public MethodType ( Type resultType , Vector argsType ) { _resultType = resultType ; _argsType = argsType . size ( ) > 0 ? argsType : null ; } public String toString ( ) { StringBuffer result = new StringBuffer ( "method{" ) ; if ( _argsType != null ) { final int count = _argsType . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { result . append ( _argsType . elementAt ( i ) ) ; if ( i != ( count - 1 ) ) result . append ( ',' ) ; } } else { result . append ( "void" ) ; } result . append ( '}' ) ; return result . toString ( ) ; } public String toSignature ( ) { return toSignature ( "" ) ; } public String toSignature ( String lastArgSig ) { final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; if ( _argsType != null ) { final int n = _argsType . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { buffer . append ( ( ( Type ) _argsType . elementAt ( i ) ) . toSignature ( ) ) ; } } return buffer . append ( lastArgSig ) . append ( ')' ) . append ( _resultType . toSignature ( ) ) . toString ( ) ; } public org . apache . bcel . generic . Type toJCType ( ) { return null ; } public boolean identicalTo ( Type other ) { boolean result = false ; if ( other instanceof MethodType ) { final MethodType temp = ( MethodType ) other ; if ( _resultType . identicalTo ( temp . _resultType ) ) { final int len = argsCount ( ) ; result = len == temp . argsCount ( ) ; for ( int i = 0 ; i < len && result ; i ++ ) { final Type arg1 = ( Type ) _argsType . elementAt ( i ) ; final Type arg2 = ( Type ) temp . _argsType . elementAt ( i ) ; result = arg1 . identicalTo ( arg2 ) ; } } } return result ; } public int distanceTo ( Type other ) { int result = Integer . MAX_VALUE ; if ( other instanceof MethodType ) { final MethodType mtype = ( MethodType ) other ; if ( _argsType != null ) { final int len = _argsType . size ( ) ; if ( len == mtype . _argsType . size ( ) ) { result = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Type arg1 = ( Type ) _argsType . elementAt ( i ) ; Type arg2 = ( Type ) mtype . _argsType . elementAt ( i ) ; final int temp = arg1 . distanceTo ( arg2 ) ; if ( temp == Integer . MAX_VALUE ) { result = temp ; break ; } else { result += arg1 . distanceTo ( arg2 ) ; } } } } else if ( mtype . _argsType == null ) { result = 0 ; } } return result ; } public Type resultType ( ) { return _resultType ; } public Vector argsType ( ) { return _argsType ; } public int argsCount ( ) { return _argsType == null ? 0 : _argsType . size ( ) ; } } 	0	['14', '2', '0', '10', '29', '0', '8', '2', '14', '0.269230769', '332', '1', '1', '0.785714286', '0.410714286', '1', '1', '22.57142857', '6', '1.6429', '0']
package org . apache . xml . utils ; public class FastStringBuffer { static final int DEBUG_FORCE_INIT_BITS = 0 ; static boolean DEBUG_FORCE_FIXED_CHUNKSIZE = true ; public static final int SUPPRESS_LEADING_WS = 0x01 ; public static final int SUPPRESS_TRAILING_WS = 0x02 ; public static final int SUPPRESS_BOTH = SUPPRESS_LEADING_WS | SUPPRESS_TRAILING_WS ; private static final int CARRY_WS = 0x04 ; int m_chunkBits = 15 ; int m_maxChunkBits = 15 ; int m_rebundleBits = 2 ; int m_chunkSize ; int m_chunkMask ; char [ ] [ ] m_array ; int m_lastChunk = 0 ; int m_firstFree = 0 ; FastStringBuffer m_innerFSB = null ; public FastStringBuffer ( int initChunkBits , int maxChunkBits , int rebundleBits ) { if ( DEBUG_FORCE_INIT_BITS != 0 ) initChunkBits = DEBUG_FORCE_INIT_BITS ; if ( DEBUG_FORCE_FIXED_CHUNKSIZE ) maxChunkBits = initChunkBits ; m_array = new char [ 16 ] [ ] ; if ( initChunkBits > maxChunkBits ) initChunkBits = maxChunkBits ; m_chunkBits = initChunkBits ; m_maxChunkBits = maxChunkBits ; m_rebundleBits = rebundleBits ; m_chunkSize = 1 << ( initChunkBits ) ; m_chunkMask = m_chunkSize - 1 ; m_array [ 0 ] = new char [ m_chunkSize ] ; } public FastStringBuffer ( int initChunkBits , int maxChunkBits ) { this ( initChunkBits , maxChunkBits , 2 ) ; } public FastStringBuffer ( int initChunkBits ) { this ( initChunkBits , 15 , 2 ) ; } public FastStringBuffer ( ) { this ( 10 , 15 , 2 ) ; } public final int size ( ) { return ( m_lastChunk << m_chunkBits ) + m_firstFree ; } public final int length ( ) { return ( m_lastChunk << m_chunkBits ) + m_firstFree ; } public final void reset ( ) { m_lastChunk = 0 ; m_firstFree = 0 ; FastStringBuffer innermost = this ; while ( innermost . m_innerFSB != null ) { innermost = innermost . m_innerFSB ; } m_chunkBits = innermost . m_chunkBits ; m_chunkSize = innermost . m_chunkSize ; m_chunkMask = innermost . m_chunkMask ; m_innerFSB = null ; m_array = new char [ 16 ] [ 0 ] ; m_array [ 0 ] = new char [ m_chunkSize ] ; } public final void setLength ( int l ) { m_lastChunk = l > > > m_chunkBits ; if ( m_lastChunk == 0 && m_innerFSB != null ) { m_innerFSB . setLength ( l , this ) ; } else { m_firstFree = l & m_chunkMask ; if ( m_firstFree == 0 && m_lastChunk > 0 ) { -- m_lastChunk ; m_firstFree = m_chunkSize ; } } } private final void setLength ( int l , FastStringBuffer rootFSB ) { m_lastChunk = l > > > m_chunkBits ; if ( m_lastChunk == 0 && m_innerFSB != null ) { m_innerFSB . setLength ( l , rootFSB ) ; } else { rootFSB . m_chunkBits = m_chunkBits ; rootFSB . m_maxChunkBits = m_maxChunkBits ; rootFSB . m_rebundleBits = m_rebundleBits ; rootFSB . m_chunkSize = m_chunkSize ; rootFSB . m_chunkMask = m_chunkMask ; rootFSB . m_array = m_array ; rootFSB . m_innerFSB = m_innerFSB ; rootFSB . m_lastChunk = m_lastChunk ; rootFSB . m_firstFree = l & m_chunkMask ; } } public final String toString ( ) { int length = ( m_lastChunk << m_chunkBits ) + m_firstFree ; return getString ( new StringBuffer ( length ) , 0 , 0 , length ) . toString ( ) ; } public final void append ( char value ) { char [ ] chunk ; boolean lastchunk = ( m_lastChunk + 1 == m_array . length ) ; if ( m_firstFree < m_chunkSize ) chunk = m_array [ m_lastChunk ] ; else { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } m_firstFree = 0 ; } chunk [ m_firstFree ++ ] = value ; } public final void append ( String value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; value . getChars ( copyfrom , copyfrom + available , m_array [ m_lastChunk ] , m_firstFree ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( StringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; value . getChars ( copyfrom , copyfrom + available , m_array [ m_lastChunk ] , m_firstFree ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( char [ ] chars , int start , int length ) { int strlen = length ; if ( 0 == strlen ) return ; int copyfrom = start ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; System . arraycopy ( chars , copyfrom , m_array [ m_lastChunk ] , m_firstFree , available ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( FastStringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; int sourcechunk = ( copyfrom + value . m_chunkSize - 1 ) > > > value . m_chunkBits ; int sourcecolumn = copyfrom & value . m_chunkMask ; int runlength = value . m_chunkSize - sourcecolumn ; if ( runlength > available ) runlength = available ; System . arraycopy ( value . m_array [ sourcechunk ] , sourcecolumn , m_array [ m_lastChunk ] , m_firstFree , runlength ) ; if ( runlength != available ) System . arraycopy ( value . m_array [ sourcechunk + 1 ] , 0 , m_array [ m_lastChunk ] , m_firstFree + runlength , available - runlength ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public boolean isWhitespace ( int start , int length ) { int sourcechunk = start > > > m_chunkBits ; int sourcecolumn = start & m_chunkMask ; int available = m_chunkSize - sourcecolumn ; boolean chunkOK ; while ( length > 0 ) { int runlength = ( length <= available ) ? length : available ; if ( sourcechunk == 0 && m_innerFSB != null ) chunkOK = m_innerFSB . isWhitespace ( sourcecolumn , runlength ) ; else chunkOK = org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( m_array [ sourcechunk ] , sourcecolumn , runlength ) ; if ( ! chunkOK ) return false ; length -= runlength ; ++ sourcechunk ; sourcecolumn = 0 ; available = m_chunkSize ; } return true ; } public String getString ( int start , int length ) { int startColumn = start & m_chunkMask ; int startChunk = start > > > m_chunkBits ; if ( startColumn + length < m_chunkMask && m_innerFSB == null ) { return getOneChunkString ( startChunk , startColumn , length ) ; } return getString ( new StringBuffer ( length ) , startChunk , startColumn , length ) . toString ( ) ; } protected String getOneChunkString ( int startChunk , int startColumn , int length ) { return new String ( m_array [ startChunk ] , startColumn , length ) ; } StringBuffer getString ( StringBuffer sb , int start , int length ) { return getString ( sb , start > > > m_chunkBits , start & m_chunkMask , length ) ; } StringBuffer getString ( StringBuffer sb , int startChunk , int startColumn , int length ) { int stop = ( startChunk << m_chunkBits ) + startColumn + length ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) m_innerFSB . getString ( sb , startColumn , m_chunkSize - startColumn ) ; else sb . append ( m_array [ i ] , startColumn , m_chunkSize - startColumn ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) m_innerFSB . getString ( sb , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) sb . append ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn ) ; return sb ; } public char charAt ( int pos ) { int startChunk = pos > > > m_chunkBits ; if ( startChunk == 0 && m_innerFSB != null ) return m_innerFSB . charAt ( pos & m_chunkMask ) ; else return m_array [ startChunk ] [ pos & m_chunkMask ] ; } public void sendSAXcharacters ( org . xml . sax . ContentHandler ch , int start , int length ) throws org . xml . sax . SAXException { int startChunk = start > > > m_chunkBits ; int startColumn = start & m_chunkMask ; if ( startColumn + length < m_chunkMask && m_innerFSB == null ) { ch . characters ( m_array [ startChunk ] , startColumn , length ) ; return ; } int stop = start + length ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) m_innerFSB . sendSAXcharacters ( ch , startColumn , m_chunkSize - startColumn ) ; else ch . characters ( m_array [ i ] , startColumn , m_chunkSize - startColumn ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) m_innerFSB . sendSAXcharacters ( ch , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) { ch . characters ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn ) ; } } public int sendNormalizedSAXcharacters ( org . xml . sax . ContentHandler ch , int start , int length ) throws org . xml . sax . SAXException { int stateForNextChunk = SUPPRESS_LEADING_WS ; int stop = start + length ; int startChunk = start > > > m_chunkBits ; int startColumn = start & m_chunkMask ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) stateForNextChunk = m_innerFSB . sendNormalizedSAXcharacters ( ch , startColumn , m_chunkSize - startColumn ) ; else stateForNextChunk = sendNormalizedSAXcharacters ( m_array [ i ] , startColumn , m_chunkSize - startColumn , ch , stateForNextChunk ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) stateForNextChunk = m_innerFSB . sendNormalizedSAXcharacters ( ch , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) { stateForNextChunk = sendNormalizedSAXcharacters ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn , ch , stateForNextChunk | SUPPRESS_TRAILING_WS ) ; } return stateForNextChunk ; } static final char [ ] SINGLE_SPACE = { ' ' } ; static int sendNormalizedSAXcharacters ( char ch [ ] , int start , int length , org . xml . sax . ContentHandler handler , int edgeTreatmentFlags ) throws org . xml . sax . SAXException { boolean processingLeadingWhitespace = ( ( edgeTreatmentFlags & SUPPRESS_LEADING_WS ) != 0 ) ; boolean seenWhitespace = ( ( edgeTreatmentFlags & CARRY_WS ) != 0 ) ; boolean suppressTrailingWhitespace = ( ( edgeTreatmentFlags & SUPPRESS_TRAILING_WS ) != 0 ) ; int currPos = start ; int limit = start + length ; if ( processingLeadingWhitespace ) { for ( ; currPos < limit && XMLCharacterRecognizer . isWhiteSpace ( ch [ currPos ] ) ; currPos ++ ) { } if ( currPos == limit ) { return edgeTreatmentFlags ; } } while ( currPos < limit ) { int startNonWhitespace = currPos ; for ( ; currPos < limit && ! XMLCharacterRecognizer . isWhiteSpace ( ch [ currPos ] ) ; currPos ++ ) { } if ( startNonWhitespace != currPos ) { if ( seenWhitespace ) { handler . characters ( SINGLE_SPACE , 0 , 1 ) ; seenWhitespace = false ; } handler . characters ( ch , startNonWhitespace , currPos - startNonWhitespace ) ; } int startWhitespace = currPos ; for ( ; currPos < limit && XMLCharacterRecognizer . isWhiteSpace ( ch [ currPos ] ) ; currPos ++ ) { } if ( startWhitespace != currPos ) { seenWhitespace = true ; } } return ( seenWhitespace ? CARRY_WS : 0 ) | ( edgeTreatmentFlags & SUPPRESS_TRAILING_WS ) ; } public static void sendNormalizedSAXcharacters ( char ch [ ] , int start , int length , org . xml . sax . ContentHandler handler ) throws org . xml . sax . SAXException { sendNormalizedSAXcharacters ( ch , start , length , handler , SUPPRESS_BOTH ) ; } public void sendSAXComment ( org . xml . sax . ext . LexicalHandler ch , int start , int length ) throws org . xml . sax . SAXException { String comment = getString ( start , length ) ; ch . comment ( comment . toCharArray ( ) , 0 , length ) ; } private void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { } private FastStringBuffer ( FastStringBuffer source ) { m_chunkBits = source . m_chunkBits ; m_maxChunkBits = source . m_maxChunkBits ; m_rebundleBits = source . m_rebundleBits ; m_chunkSize = source . m_chunkSize ; m_chunkMask = source . m_chunkMask ; m_array = source . m_array ; m_innerFSB = source . m_innerFSB ; m_lastChunk = source . m_lastChunk - 1 ; m_firstFree = source . m_chunkSize ; source . m_array = new char [ 16 ] [ ] ; source . m_innerFSB = this ; source . m_lastChunk = 1 ; source . m_firstFree = 0 ; source . m_chunkBits += m_rebundleBits ; source . m_chunkSize = 1 << ( source . m_chunkBits ) ; source . m_chunkMask = source . m_chunkSize - 1 ; } } 	0	['29', '1', '0', '24', '44', '0', '23', '1', '21', '0.640625', '1655', '0.0625', '1', '0', '0.242063492', '0', '0', '55.51724138', '11', '3', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xml . serializer . EmptySerializer ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringDefault ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import javax . xml . transform . SourceLocator ; public class SimpleResultTreeImpl extends EmptySerializer implements DOM , DTM { public final class SimpleIterator extends DTMAxisIteratorBase { static final int DIRECTION_UP = 0 ; static final int DIRECTION_DOWN = 1 ; static final int NO_TYPE = - 1 ; int _direction = DIRECTION_DOWN ; int _type = NO_TYPE ; int _currentNode ; public SimpleIterator ( ) { } public SimpleIterator ( int direction ) { _direction = direction ; } public SimpleIterator ( int direction , int type ) { _direction = direction ; _type = type ; } public int next ( ) { if ( _direction == DIRECTION_DOWN ) { while ( _currentNode < NUMBER_OF_NODES ) { if ( _type != NO_TYPE ) { if ( ( _currentNode == RTF_ROOT && _type == DTM . ROOT_NODE ) || ( _currentNode == RTF_TEXT && _type == DTM . TEXT_NODE ) ) return returnNode ( getNodeHandle ( _currentNode ++ ) ) ; else _currentNode ++ ; } else return returnNode ( getNodeHandle ( _currentNode ++ ) ) ; } return END ; } else { while ( _currentNode >= 0 ) { if ( _type != NO_TYPE ) { if ( ( _currentNode == RTF_ROOT && _type == DTM . ROOT_NODE ) || ( _currentNode == RTF_TEXT && _type == DTM . TEXT_NODE ) ) return returnNode ( getNodeHandle ( _currentNode -- ) ) ; else _currentNode -- ; } else return returnNode ( getNodeHandle ( _currentNode -- ) ) ; } return END ; } } public DTMAxisIterator setStartNode ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; _startNode = nodeID ; if ( ! _includeSelf && nodeID != DTM . NULL ) { if ( _direction == DIRECTION_DOWN ) nodeID ++ ; else if ( _direction == DIRECTION_UP ) nodeID -- ; } _currentNode = nodeID ; return this ; } public void setMark ( ) { _markedNode = _currentNode ; } public void gotoMark ( ) { _currentNode = _markedNode ; } } public final class SingletonIterator extends DTMAxisIteratorBase { static final int NO_TYPE = - 1 ; int _type = NO_TYPE ; int _currentNode ; public SingletonIterator ( ) { } public SingletonIterator ( int type ) { _type = type ; } public void setMark ( ) { _markedNode = _currentNode ; } public void gotoMark ( ) { _currentNode = _markedNode ; } public DTMAxisIterator setStartNode ( int nodeHandle ) { _currentNode = _startNode = getNodeIdent ( nodeHandle ) ; return this ; } public int next ( ) { if ( _currentNode == END ) return END ; _currentNode = END ; if ( _type != NO_TYPE ) { if ( ( _currentNode == RTF_ROOT && _type == DTM . ROOT_NODE ) || ( _currentNode == RTF_TEXT && _type == DTM . TEXT_NODE ) ) return getNodeHandle ( _currentNode ) ; } else return getNodeHandle ( _currentNode ) ; return END ; } } private final static DTMAxisIterator EMPTY_ITERATOR = new DTMAxisIteratorBase ( ) { public DTMAxisIterator reset ( ) { return this ; } public DTMAxisIterator setStartNode ( int node ) { return this ; } public int next ( ) { return DTM . NULL ; } public void setMark ( ) { } public void gotoMark ( ) { } public int getLast ( ) { return 0 ; } public int getPosition ( ) { return 0 ; } public DTMAxisIterator cloneIterator ( ) { return this ; } public void setRestartable ( boolean isRestartable ) { } } ; public static final int RTF_ROOT = 0 ; public static final int RTF_TEXT = 1 ; public static final int NUMBER_OF_NODES = 2 ; private static int _documentURIIndex = 0 ; private static final String EMPTY_STR = "" ; private String _text ; protected String [ ] _textArray ; protected XSLTCDTMManager _dtmManager ; protected int _size = 0 ; private int _documentID ; private BitArray _dontEscape = null ; private boolean _escaping = true ; public SimpleResultTreeImpl ( XSLTCDTMManager dtmManager , int documentID ) { _dtmManager = dtmManager ; _documentID = documentID ; _textArray = new String [ 4 ] ; } public DTMManagerDefault getDTMManager ( ) { return _dtmManager ; } public int getDocument ( ) { return _documentID ; } public String getStringValue ( ) { return _text ; } public DTMAxisIterator getIterator ( ) { return new SingletonIterator ( getDocument ( ) ) ; } public DTMAxisIterator getChildren ( final int node ) { return new SimpleIterator ( ) . setStartNode ( node ) ; } public DTMAxisIterator getTypedChildren ( final int type ) { return new SimpleIterator ( SimpleIterator . DIRECTION_DOWN , type ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { switch ( axis ) { case Axis . CHILD : case Axis . DESCENDANT : return new SimpleIterator ( SimpleIterator . DIRECTION_DOWN ) ; case Axis . PARENT : case Axis . ANCESTOR : return new SimpleIterator ( SimpleIterator . DIRECTION_UP ) ; case Axis . ANCESTORORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_UP ) ) . includeSelf ( ) ; case Axis . DESCENDANTORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_DOWN ) ) . includeSelf ( ) ; case Axis . SELF : return new SingletonIterator ( ) ; default : return EMPTY_ITERATOR ; } } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { switch ( axis ) { case Axis . CHILD : case Axis . DESCENDANT : return new SimpleIterator ( SimpleIterator . DIRECTION_DOWN , type ) ; case Axis . PARENT : case Axis . ANCESTOR : return new SimpleIterator ( SimpleIterator . DIRECTION_UP , type ) ; case Axis . ANCESTORORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_UP , type ) ) . includeSelf ( ) ; case Axis . DESCENDANTORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_DOWN , type ) ) . includeSelf ( ) ; case Axis . SELF : return new SingletonIterator ( type ) ; default : return EMPTY_ITERATOR ; } } public DTMAxisIterator getNthDescendant ( int node , int n , boolean includeself ) { return null ; } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { return null ; } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iter , int returnType , String value , boolean op ) { return null ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return source ; } public String getNodeName ( final int node ) { if ( getNodeIdent ( node ) == RTF_TEXT ) return "#text" ; else return EMPTY_STR ; } public String getNodeNameX ( final int node ) { return EMPTY_STR ; } public String getNamespaceName ( final int node ) { return EMPTY_STR ; } public int getExpandedTypeID ( final int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_TEXT ) return DTM . TEXT_NODE ; else if ( nodeID == RTF_ROOT ) return DTM . ROOT_NODE ; else return DTM . NULL ; } public int getNamespaceType ( final int node ) { return 0 ; } public int getParent ( final int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; return ( nodeID == RTF_TEXT ) ? getNodeHandle ( RTF_ROOT ) : DTM . NULL ; } public int getAttributeNode ( final int gType , final int element ) { return DTM . NULL ; } public String getStringValueX ( final int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_ROOT || nodeID == RTF_TEXT ) return _text ; else return EMPTY_STR ; } public void copy ( final int node , SerializationHandler handler ) throws TransletException { characters ( node , handler ) ; } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { int node ; while ( ( node = nodes . next ( ) ) != DTM . NULL ) { copy ( node , handler ) ; } } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { characters ( node , handler ) ; return null ; } public boolean lessThan ( final int node1 , final int node2 ) { if ( node1 == DTM . NULL ) { return false ; } else if ( node2 == DTM . NULL ) { return true ; } else return ( node1 < node2 ) ; } public void characters ( final int node , SerializationHandler handler ) throws TransletException { int nodeID = getNodeIdent ( node ) ; if ( nodeID == RTF_ROOT || nodeID == RTF_TEXT ) { boolean escapeBit = false ; boolean oldEscapeSetting = false ; try { for ( int i = 0 ; i < _size ; i ++ ) { if ( _dontEscape != null ) { escapeBit = _dontEscape . getBit ( i ) ; if ( escapeBit ) { oldEscapeSetting = handler . setEscaping ( false ) ; } } handler . characters ( _textArray [ i ] ) ; if ( escapeBit ) { handler . setEscaping ( oldEscapeSetting ) ; } } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } } public Node makeNode ( int index ) { return null ; } public Node makeNode ( DTMAxisIterator iter ) { return null ; } public NodeList makeNodeList ( int index ) { return null ; } public NodeList makeNodeList ( DTMAxisIterator iter ) { return null ; } public String getLanguage ( int node ) { return null ; } public int getSize ( ) { return 2 ; } public String getDocumentURI ( int node ) { return "simple_rtf" + _documentURIIndex ++ ; } public void setFilter ( StripFilter filter ) { } public void setupMapping ( String [ ] names , String [ ] namespaces ) { } public boolean isElement ( final int node ) { return false ; } public boolean isAttribute ( final int node ) { return false ; } public String lookupNamespace ( int node , String prefix ) throws TransletException { return null ; } public int getNodeIdent ( final int nodehandle ) { return ( nodehandle != DTM . NULL ) ? ( nodehandle - _documentID ) : DTM . NULL ; } public int getNodeHandle ( final int nodeId ) { return ( nodeId != DTM . NULL ) ? ( nodeId + _documentID ) : DTM . NULL ; } public DOM getResultTreeFrag ( int initialSize , int rtfType ) { return null ; } public SerializationHandler getOutputDomBuilder ( ) { return this ; } public int getNSType ( int node ) { return 0 ; } public String getUnparsedEntityURI ( String name ) { return null ; } public Hashtable getElementsWithIDs ( ) { return null ; } public void startDocument ( ) throws SAXException { } public void endDocument ( ) throws SAXException { if ( _size == 1 ) _text = _textArray [ 0 ] ; else { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < _size ; i ++ ) { buffer . append ( _textArray [ i ] ) ; } _text = buffer . toString ( ) ; } } public void characters ( String str ) throws SAXException { if ( _size >= _textArray . length ) { String [ ] newTextArray = new String [ _textArray . length * 2 ] ; System . arraycopy ( _textArray , 0 , newTextArray , 0 , _textArray . length ) ; _textArray = newTextArray ; } if ( ! _escaping ) { if ( _dontEscape == null ) { _dontEscape = new BitArray ( 8 ) ; } if ( _size >= _dontEscape . size ( ) ) _dontEscape . resize ( _dontEscape . size ( ) * 2 ) ; _dontEscape . setBit ( _size ) ; } _textArray [ _size ++ ] = str ; } public void characters ( char [ ] ch , int offset , int length ) throws SAXException { if ( _size >= _textArray . length ) { String [ ] newTextArray = new String [ _textArray . length * 2 ] ; System . arraycopy ( _textArray , 0 , newTextArray , 0 , _textArray . length ) ; _textArray = newTextArray ; } if ( ! _escaping ) { if ( _dontEscape == null ) { _dontEscape = new BitArray ( 8 ) ; } if ( _size >= _dontEscape . size ( ) ) _dontEscape . resize ( _dontEscape . size ( ) * 2 ) ; _dontEscape . setBit ( _size ) ; } _textArray [ _size ++ ] = new String ( ch , offset , length ) ; } public boolean setEscaping ( boolean escape ) throws SAXException { final boolean temp = _escaping ; _escaping = escape ; return temp ; } public void setFeature ( String featureId , boolean state ) { } public void setProperty ( String property , Object value ) { } public DTMAxisTraverser getAxisTraverser ( final int axis ) { return null ; } public boolean hasChildNodes ( int nodeHandle ) { return ( getNodeIdent ( nodeHandle ) == RTF_ROOT ) ; } public int getFirstChild ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_ROOT ) return getNodeHandle ( RTF_TEXT ) ; else return DTM . NULL ; } public int getLastChild ( int nodeHandle ) { return getFirstChild ( nodeHandle ) ; } public int getAttributeNode ( int elementHandle , String namespaceURI , String name ) { return DTM . NULL ; } public int getFirstAttribute ( int nodeHandle ) { return DTM . NULL ; } public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) { return DTM . NULL ; } public int getNextSibling ( int nodeHandle ) { return DTM . NULL ; } public int getPreviousSibling ( int nodeHandle ) { return DTM . NULL ; } public int getNextAttribute ( int nodeHandle ) { return DTM . NULL ; } public int getNextNamespaceNode ( int baseHandle , int namespaceHandle , boolean inScope ) { return DTM . NULL ; } public int getOwnerDocument ( int nodeHandle ) { return getDocument ( ) ; } public int getDocumentRoot ( int nodeHandle ) { return getDocument ( ) ; } public XMLString getStringValue ( int nodeHandle ) { return new XMLStringDefault ( getStringValueX ( nodeHandle ) ) ; } public int getStringValueChunkCount ( int nodeHandle ) { return 0 ; } public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) { return null ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { return DTM . NULL ; } public String getLocalNameFromExpandedNameID ( int ExpandedNameID ) { return EMPTY_STR ; } public String getNamespaceFromExpandedNameID ( int ExpandedNameID ) { return EMPTY_STR ; } public String getLocalName ( int nodeHandle ) { return EMPTY_STR ; } public String getPrefix ( int nodeHandle ) { return null ; } public String getNamespaceURI ( int nodeHandle ) { return EMPTY_STR ; } public String getNodeValue ( int nodeHandle ) { return ( getNodeIdent ( nodeHandle ) == RTF_TEXT ) ? _text : null ; } public short getNodeType ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_TEXT ) return DTM . TEXT_NODE ; else if ( nodeID == RTF_ROOT ) return DTM . ROOT_NODE ; else return DTM . NULL ; } public short getLevel ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_TEXT ) return 2 ; else if ( nodeID == RTF_ROOT ) return 1 ; else return DTM . NULL ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getDocumentBaseURI ( ) { return EMPTY_STR ; } public void setDocumentBaseURI ( String baseURI ) { } public String getDocumentSystemIdentifier ( int nodeHandle ) { return null ; } public String getDocumentEncoding ( int nodeHandle ) { return null ; } public String getDocumentStandalone ( int nodeHandle ) { return null ; } public String getDocumentVersion ( int documentHandle ) { return null ; } public boolean getDocumentAllDeclarationsProcessed ( ) { return false ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { return null ; } public int getElementById ( String elementId ) { return DTM . NULL ; } public boolean supportsPreStripping ( ) { return false ; } public boolean isNodeAfter ( int firstNodeHandle , int secondNodeHandle ) { return lessThan ( firstNodeHandle , secondNodeHandle ) ; } public boolean isCharacterElementContentWhitespace ( int nodeHandle ) { return false ; } public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) { return false ; } public boolean isAttributeSpecified ( int attributeHandle ) { return false ; } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { } public org . w3c . dom . Node getNode ( int nodeHandle ) { return makeNode ( nodeHandle ) ; } public boolean needsTwoThreads ( ) { return false ; } public org . xml . sax . ContentHandler getContentHandler ( ) { return null ; } public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) { return null ; } public org . xml . sax . EntityResolver getEntityResolver ( ) { return null ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return null ; } public org . xml . sax . ErrorHandler getErrorHandler ( ) { return null ; } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { return null ; } public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) { } public void appendTextChild ( String str ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } public void documentRegistration ( ) { } public void documentRelease ( ) { } } 	0	['109', '2', '1', '20', '134', '5826', '5', '17', '108', '0.967948718', '837', '0.769230769', '3', '0.475490196', '0.153846154', '0', '0', '6.559633028', '4', '1.1651', '0']
package org . apache . xalan . transformer ; import java . util . Vector ; import org . apache . xml . utils . MutableAttrListImpl ; public abstract class QueuedEvents { protected int m_eventCount = 0 ; public boolean m_docPending = false ; protected boolean m_docEnded = false ; public boolean m_elemIsPending = false ; public boolean m_elemIsEnded = false ; protected MutableAttrListImpl m_attributes = new MutableAttrListImpl ( ) ; protected boolean m_nsDeclsHaveBeenAdded = false ; protected String m_name ; protected String m_url ; protected String m_localName ; protected Vector m_namespaces = null ; protected void reInitEvents ( ) { } public void reset ( ) { pushDocumentEvent ( ) ; reInitEvents ( ) ; } void pushDocumentEvent ( ) { m_docPending = true ; m_eventCount ++ ; } void popEvent ( ) { m_elemIsPending = false ; m_attributes . clear ( ) ; m_nsDeclsHaveBeenAdded = false ; m_name = null ; m_url = null ; m_localName = null ; m_namespaces = null ; m_eventCount -- ; } private org . apache . xml . serializer . Serializer m_serializer ; void setSerializer ( org . apache . xml . serializer . Serializer s ) { m_serializer = s ; } org . apache . xml . serializer . Serializer getSerializer ( ) { return m_serializer ; } } 	0	['7', '1', '0', '2', '10', '13', '0', '2', '2', '0.861111111', '99', '0.75', '2', '0', '0.571428571', '0', '0', '11.42857143', '1', '0.8571', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class NthIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private final int _position ; private boolean _ready ; public NthIterator ( DTMAxisIterator source , int n ) { _source = source ; _position = n ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator cloneIterator ( ) { try { final NthIterator clone = ( NthIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public int next ( ) { if ( _ready ) { _ready = false ; return _source . getNodeByPosition ( _position ) ; } return DTMAxisIterator . END ; } public DTMAxisIterator setStartNode ( final int node ) { if ( _isRestartable ) { _source . setStartNode ( node ) ; _ready = true ; } return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; _ready = true ; return this ; } public int getLast ( ) { return 1 ; } public int getPosition ( ) { return 1 ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['10', '2', '0', '3', '21', '0', '0', '3', '10', '0.62962963', '99', '1', '1', '0.590909091', '0.35', '1', '7', '8.6', '2', '1.1', '0']
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; public class StylesheetComposed extends Stylesheet { public StylesheetComposed ( Stylesheet parent ) { super ( parent ) ; } public boolean isAggregatedType ( ) { return true ; } public void recompose ( Vector recomposableElements ) throws TransformerException { int n = getIncludeCountComposed ( ) ; for ( int i = - 1 ; i < n ; i ++ ) { Stylesheet included = getIncludeComposed ( i ) ; int s = included . getOutputCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getOutput ( j ) ) ; } s = included . getAttributeSetCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getAttributeSet ( j ) ) ; } s = included . getDecimalFormatCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getDecimalFormat ( j ) ) ; } s = included . getKeyCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getKey ( j ) ) ; } s = included . getNamespaceAliasCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getNamespaceAlias ( j ) ) ; } s = included . getTemplateCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getTemplate ( j ) ) ; } s = included . getVariableOrParamCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getVariableOrParam ( j ) ) ; } s = included . getStripSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getStripSpace ( j ) ) ; } s = included . getPreserveSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getPreserveSpace ( j ) ) ; } } } private int m_importNumber = - 1 ; private int m_importCountComposed ; private int m_endImportCountComposed ; void recomposeImports ( ) { m_importNumber = getStylesheetRoot ( ) . getImportNumber ( this ) ; StylesheetRoot root = getStylesheetRoot ( ) ; int globalImportCount = root . getGlobalImportCount ( ) ; m_importCountComposed = ( globalImportCount - m_importNumber ) - 1 ; int count = getImportCount ( ) ; if ( count > 0 ) { m_endImportCountComposed += count ; while ( count > 0 ) m_endImportCountComposed += this . getImport ( -- count ) . getEndImportCountComposed ( ) ; } count = getIncludeCountComposed ( ) ; while ( count > 0 ) { int imports = getIncludeComposed ( -- count ) . getImportCount ( ) ; m_endImportCountComposed += imports ; while ( imports > 0 ) m_endImportCountComposed += getIncludeComposed ( count ) . getImport ( -- imports ) . getEndImportCountComposed ( ) ; } } public StylesheetComposed getImportComposed ( int i ) throws ArrayIndexOutOfBoundsException { StylesheetRoot root = getStylesheetRoot ( ) ; return root . getGlobalImport ( 1 + m_importNumber + i ) ; } public int getImportCountComposed ( ) { return m_importCountComposed ; } public int getEndImportCountComposed ( ) { return m_endImportCountComposed ; } private transient Vector m_includesComposed ; void recomposeIncludes ( Stylesheet including ) { int n = including . getIncludeCount ( ) ; if ( n > 0 ) { if ( null == m_includesComposed ) m_includesComposed = new Vector ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Stylesheet included = including . getInclude ( i ) ; m_includesComposed . addElement ( included ) ; recomposeIncludes ( included ) ; } } } public Stylesheet getIncludeComposed ( int i ) throws ArrayIndexOutOfBoundsException { if ( - 1 == i ) return this ; if ( null == m_includesComposed ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( Stylesheet ) m_includesComposed . elementAt ( i ) ; } public int getIncludeCountComposed ( ) { return ( null != m_includesComposed ) ? m_includesComposed . size ( ) : 0 ; } public void recomposeTemplates ( boolean flushFirst ) throws TransformerException { } } 	0	['11', '4', '1', '17', '45', '39', '10', '10', '9', '0.8', '333', '1', '0', '0.964285714', '0.309090909', '1', '2', '28.90909091', '4', '1.5455', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class ForwardPositionExpr extends Expression { private Expression _expr ; public ForwardPositionExpr ( Expression expr ) { _expr = expr ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _expr . setParser ( parser ) ; } public String toString ( ) { return "forward-position-expr(" + _expr + ")" ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return ( _type = _expr . typeCheck ( stable ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { _expr . translate ( classGen , methodGen ) ; if ( _type == Type . NodeSet ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( FORWARD_POSITION_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( FORWARD_POSITION_ITERATOR ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } } } 	0	['5', '3', '0', '16', '20', '0', '2', '14', '5', '0', '86', '1', '1', '0.946666667', '0.333333333', '2', '7', '16', '2', '1', '0']
package org . apache . xalan . xsltc . compiler . util ; public abstract class NumberType extends Type { public boolean isNumber ( ) { return true ; } public boolean isSimple ( ) { return true ; } } 	0	['3', '2', '2', '5', '4', '3', '4', '1', '3', '2', '10', '0', '0', '0.942857143', '1', '0', '0', '2.333333333', '1', '0.6667', '0']
package org . apache . xalan . processor ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemText ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . w3c . dom . Node ; public class ProcessorCharacters extends XSLTElementProcessor { public void startNonText ( StylesheetHandler handler ) throws org . xml . sax . SAXException { if ( this == handler . getCurrentProcessor ( ) ) { handler . popProcessor ( ) ; } int nChars = m_accumulator . length ( ) ; if ( ( nChars > 0 ) && ( ( null != m_xslTextElement ) || ! XMLCharacterRecognizer . isWhiteSpace ( m_accumulator ) ) || handler . isSpacePreserve ( ) ) { ElemTextLiteral elem = new ElemTextLiteral ( ) ; elem . setDOMBackPointer ( m_firstBackPointer ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; try { elem . setPrefixes ( handler . getNamespaceSupport ( ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } boolean doe = ( null != m_xslTextElement ) ? m_xslTextElement . getDisableOutputEscaping ( ) : false ; elem . setDisableOutputEscaping ( doe ) ; elem . setPreserveSpace ( true ) ; char [ ] chars = new char [ nChars ] ; m_accumulator . getChars ( 0 , nChars , chars , 0 ) ; elem . setChars ( chars ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( elem ) ; } m_accumulator . setLength ( 0 ) ; m_firstBackPointer = null ; } protected Node m_firstBackPointer = null ; public void characters ( StylesheetHandler handler , char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { m_accumulator . append ( ch , start , length ) ; if ( null == m_firstBackPointer ) m_firstBackPointer = handler . getOriginatingNode ( ) ; if ( this != handler . getCurrentProcessor ( ) ) handler . pushProcessor ( this ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { startNonText ( handler ) ; handler . getCurrentProcessor ( ) . endElement ( handler , uri , localName , rawName ) ; handler . popProcessor ( ) ; } private StringBuffer m_accumulator = new StringBuffer ( ) ; private ElemText m_xslTextElement ; void setXslTextElement ( ElemText xslTextElement ) { m_xslTextElement = xslTextElement ; } } 	0	['5', '4', '0', '9', '31', '2', '2', '7', '4', '0.333333333', '151', '1', '1', '0.981308411', '0.4', '1', '2', '28.6', '1', '0.8', '0']
package org . apache . xalan . extensions ; import java . lang . reflect . Constructor ; import javax . xml . transform . TransformerException ; public class ExtensionNamespaceSupport { String m_namespace = null ; String m_handlerClass = null ; Class [ ] m_sig = null ; Object [ ] m_args = null ; public ExtensionNamespaceSupport ( String namespace , String handlerClass , Object [ ] constructorArgs ) { m_namespace = namespace ; m_handlerClass = handlerClass ; m_args = constructorArgs ; m_sig = new Class [ m_args . length ] ; for ( int i = 0 ; i < m_args . length ; i ++ ) { if ( m_args [ i ] != null ) m_sig [ i ] = m_args [ i ] . getClass ( ) ; else { m_sig = null ; break ; } } } public String getNamespace ( ) { return m_namespace ; } public ExtensionHandler launch ( ) throws TransformerException { ExtensionHandler handler = null ; try { Class cl = ExtensionHandler . getClassForName ( m_handlerClass ) ; Constructor con = null ; if ( m_sig != null ) con = cl . getConstructor ( m_sig ) ; else { Constructor [ ] cons = cl . getConstructors ( ) ; for ( int i = 0 ; i < cons . length ; i ++ ) { if ( cons [ i ] . getParameterTypes ( ) . length == m_args . length ) { con = cons [ i ] ; break ; } } } if ( con != null ) handler = ( ExtensionHandler ) con . newInstance ( m_args ) ; else throw new TransformerException ( "ExtensionHandler constructor not found" ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } return handler ; } } 	0	['3', '1', '0', '5', '12', '0', '4', '1', '3', '0.5', '133', '0', '0', '0', '0.555555556', '0', '0', '42', '1', '0.6667', '0']
package org . apache . xml . utils ; public class WrappedRuntimeException extends RuntimeException { private Exception m_exception ; public WrappedRuntimeException ( Exception e ) { super ( e . getMessage ( ) ) ; m_exception = e ; } public WrappedRuntimeException ( String msg , Exception e ) { super ( msg ) ; m_exception = e ; } public Exception getException ( ) { return m_exception ; } } 	0	['3', '4', '0', '39', '5', '0', '39', '0', '3', '0', '22', '1', '0', '0.944444444', '0.666666667', '0', '0', '6', '1', '0.3333', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import javax . xml . transform . Source ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public abstract class DTMDefaultBaseIterators extends DTMDefaultBaseTraversers { public DTMDefaultBaseIterators ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; } public DTMDefaultBaseIterators ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib ) ; } public DTMAxisIterator getTypedAxisIterator ( int axis , int type ) { DTMAxisIterator iterator = null ; { switch ( axis ) { case Axis . SELF : iterator = new TypedSingletonIterator ( type ) ; break ; case Axis . CHILD : iterator = new TypedChildrenIterator ( type ) ; break ; case Axis . PARENT : return ( new ParentIterator ( ) . setNodeType ( type ) ) ; case Axis . ANCESTOR : return ( new TypedAncestorIterator ( type ) ) ; case Axis . ANCESTORORSELF : return ( ( new TypedAncestorIterator ( type ) ) . includeSelf ( ) ) ; case Axis . ATTRIBUTE : return ( new TypedAttributeIterator ( type ) ) ; case Axis . DESCENDANT : iterator = new TypedDescendantIterator ( type ) ; break ; case Axis . DESCENDANTORSELF : iterator = ( new TypedDescendantIterator ( type ) ) . includeSelf ( ) ; break ; case Axis . FOLLOWING : iterator = new TypedFollowingIterator ( type ) ; break ; case Axis . PRECEDING : iterator = new TypedPrecedingIterator ( type ) ; break ; case Axis . FOLLOWINGSIBLING : iterator = new TypedFollowingSiblingIterator ( type ) ; break ; case Axis . PRECEDINGSIBLING : iterator = new TypedPrecedingSiblingIterator ( type ) ; break ; case Axis . NAMESPACE : iterator = new TypedNamespaceIterator ( type ) ; break ; case Axis . ROOT : iterator = new TypedRootIterator ( type ) ; break ; default : throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , new Object [ ] { Axis . names [ axis ] } ) ) ; } } return ( iterator ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { DTMAxisIterator iterator = null ; switch ( axis ) { case Axis . SELF : iterator = new SingletonIterator ( ) ; break ; case Axis . CHILD : iterator = new ChildrenIterator ( ) ; break ; case Axis . PARENT : return ( new ParentIterator ( ) ) ; case Axis . ANCESTOR : return ( new AncestorIterator ( ) ) ; case Axis . ANCESTORORSELF : return ( ( new AncestorIterator ( ) ) . includeSelf ( ) ) ; case Axis . ATTRIBUTE : return ( new AttributeIterator ( ) ) ; case Axis . DESCENDANT : iterator = new DescendantIterator ( ) ; break ; case Axis . DESCENDANTORSELF : iterator = ( new DescendantIterator ( ) ) . includeSelf ( ) ; break ; case Axis . FOLLOWING : iterator = new FollowingIterator ( ) ; break ; case Axis . PRECEDING : iterator = new PrecedingIterator ( ) ; break ; case Axis . FOLLOWINGSIBLING : iterator = new FollowingSiblingIterator ( ) ; break ; case Axis . PRECEDINGSIBLING : iterator = new PrecedingSiblingIterator ( ) ; break ; case Axis . NAMESPACE : iterator = new NamespaceIterator ( ) ; break ; case Axis . ROOT : iterator = new RootIterator ( ) ; break ; default : throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_AXIS_NOT_IMPLEMENTED , new Object [ ] { Axis . names [ axis ] } ) ) ; } return ( iterator ) ; } public abstract class InternalAxisIteratorBase extends DTMAxisIteratorBase { protected int _currentNode ; public void setMark ( ) { _markedNode = _currentNode ; } public void gotoMark ( ) { _currentNode = _markedNode ; } } public final class ChildrenIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != NULL ) { int node = _currentNode ; _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return END ; } } public final class ParentIterator extends InternalAxisIteratorBase { private int _nodeType = - 1 ; public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getParent ( node ) ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator setNodeType ( final int type ) { _nodeType = type ; return this ; } public int next ( ) { int result = _currentNode ; if ( _nodeType >= DTM . NTYPES ) { if ( _nodeType != getExpandedTypeID ( _currentNode ) ) { result = END ; } } else if ( _nodeType != NULL ) { if ( _nodeType != getNodeType ( _currentNode ) ) { result = END ; } } _currentNode = END ; return returnNode ( result ) ; } } public final class TypedChildrenIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedChildrenIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch ( makeNodeIdentity ( _startNode ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int eType ; int node = _currentNode ; int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { while ( node != DTM . NULL && _exptype ( node ) != nodeType ) { node = _nextsib ( node ) ; } } else { while ( node != DTM . NULL ) { eType = _exptype ( node ) ; if ( eType < DTM . NTYPES ) { if ( eType == nodeType ) { break ; } } else if ( m_expandedNameTable . getType ( eType ) == nodeType ) { break ; } node = _nextsib ( node ) ; } } if ( node == DTM . NULL ) { _currentNode = DTM . NULL ; return DTM . NULL ; } else { _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public final class NamespaceChildrenIterator extends InternalAxisIteratorBase { private final int _nsType ; public NamespaceChildrenIterator ( final int type ) { _nsType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : NOTPROCESSED ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != DTM . NULL ) { for ( int node = ( NOTPROCESSED == _currentNode ) ? _firstch ( makeNodeIdentity ( _startNode ) ) : _nextsib ( _currentNode ) ; node != END ; node = _nextsib ( node ) ) { if ( m_expandedNameTable . getNamespaceID ( _exptype ( node ) ) == _nsType ) { _currentNode = node ; return returnNode ( node ) ; } } } return END ; } } public class NamespaceIterator extends InternalAxisIteratorBase { public NamespaceIterator ( ) { super ( ) ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstNamespaceNode ( node , true ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; if ( DTM . NULL != node ) _currentNode = getNextNamespaceNode ( _startNode , node , true ) ; return returnNode ( node ) ; } } public class TypedNamespaceIterator extends NamespaceIterator { private final int _nodeType ; public TypedNamespaceIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { int node ; for ( node = _currentNode ; node != END ; node = getNextNamespaceNode ( _startNode , node , true ) ) { if ( getExpandedTypeID ( node ) == _nodeType || getNodeType ( node ) == _nodeType || getNamespaceType ( node ) == _nodeType ) { _currentNode = node ; return returnNode ( node ) ; } } return ( _currentNode = END ) ; } } public class RootIterator extends InternalAxisIteratorBase { public RootIterator ( ) { super ( ) ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = getDocumentRoot ( node ) ; _currentNode = NULL ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _startNode == _currentNode ) return NULL ; _currentNode = _startNode ; return returnNode ( _startNode ) ; } } public class TypedRootIterator extends RootIterator { private final int _nodeType ; public TypedRootIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { if ( _startNode == _currentNode ) return NULL ; int nodeType = _nodeType ; int node = _startNode ; int expType = getExpandedTypeID ( node ) ; _currentNode = node ; if ( nodeType >= DTM . NTYPES ) { if ( nodeType == expType ) { return returnNode ( node ) ; } } else { if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { return returnNode ( node ) ; } } else { if ( m_expandedNameTable . getType ( expType ) == nodeType ) { return returnNode ( node ) ; } } } return END ; } } public final class NamespaceAttributeIterator extends InternalAxisIteratorBase { private final int _nsType ; public NamespaceAttributeIterator ( int nsType ) { super ( ) ; _nsType = nsType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstNamespaceNode ( node , false ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; if ( DTM . NULL != node ) _currentNode = getNextNamespaceNode ( _startNode , node , false ) ; return returnNode ( node ) ; } } public class FollowingSiblingIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = makeNodeIdentity ( node ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { _currentNode = ( _currentNode == DTM . NULL ) ? DTM . NULL : _nextsib ( _currentNode ) ; return returnNode ( makeNodeHandle ( _currentNode ) ) ; } } public final class TypedFollowingSiblingIterator extends FollowingSiblingIterator { private final int _nodeType ; public TypedFollowingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { if ( _currentNode == DTM . NULL ) { return DTM . NULL ; } int node = _currentNode ; int eType ; int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { do { node = _nextsib ( node ) ; } while ( node != DTM . NULL && _exptype ( node ) != nodeType ) ; } else { while ( ( node = _nextsib ( node ) ) != DTM . NULL ) { eType = _exptype ( node ) ; if ( eType < DTM . NTYPES ) { if ( eType == nodeType ) { break ; } } else if ( m_expandedNameTable . getType ( eType ) == nodeType ) { break ; } } } _currentNode = node ; return ( _currentNode == DTM . NULL ) ? DTM . NULL : returnNode ( makeNodeHandle ( _currentNode ) ) ; } } public final class AttributeIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstAttributeIdentity ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; if ( node != NULL ) { _currentNode = getNextAttributeIdentity ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return NULL ; } } public final class TypedAttributeIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedAttributeIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; _currentNode = getTypedAttribute ( node , _nodeType ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; _currentNode = NULL ; return returnNode ( node ) ; } } public class PrecedingSiblingIterator extends InternalAxisIteratorBase { protected int _startNodeID ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; node = _startNodeID = makeNodeIdentity ( node ) ; if ( node == NULL ) { _currentNode = node ; return resetPosition ( ) ; } int type = m_expandedNameTable . getType ( _exptype ( node ) ) ; if ( ExpandedNameTable . ATTRIBUTE == type || ExpandedNameTable . NAMESPACE == type ) { _currentNode = node ; } else { _currentNode = _parent ( node ) ; if ( NULL != _currentNode ) _currentNode = _firstch ( _currentNode ) ; else _currentNode = node ; } return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode == _startNodeID || _currentNode == DTM . NULL ) { return NULL ; } else { final int node = _currentNode ; _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public final class TypedPrecedingSiblingIterator extends PrecedingSiblingIterator { private final int _nodeType ; public TypedPrecedingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; int expType ; int nodeType = _nodeType ; int startID = _startNodeID ; if ( nodeType >= DTM . NTYPES ) { while ( node != NULL && node != startID && _exptype ( node ) != nodeType ) { node = _nextsib ( node ) ; } } else { while ( node != NULL && node != startID ) { expType = _exptype ( node ) ; if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { break ; } } else { if ( m_expandedNameTable . getType ( expType ) == nodeType ) { break ; } } node = _nextsib ( node ) ; } } if ( node == DTM . NULL || node == _startNodeID ) { _currentNode = NULL ; return NULL ; } else { _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public class PrecedingIterator extends InternalAxisIteratorBase { private final int _maxAncestors = 8 ; protected int [ ] _stack = new int [ _maxAncestors ] ; protected int _sp , _oldsp ; protected int _markedsp , _markedNode , _markedDescendant ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; final int [ ] stackCopy = new int [ _stack . length ] ; System . arraycopy ( _stack , 0 , stackCopy , 0 , _stack . length ) ; clone . _stack = stackCopy ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; int parent , index ; if ( _type ( node ) == DTM . ATTRIBUTE_NODE ) node = _parent ( node ) ; _startNode = node ; _stack [ index = 0 ] = node ; parent = node ; while ( ( parent = _parent ( parent ) ) != NULL ) { if ( ++ index == _stack . length ) { final int [ ] stack = new int [ index + 4 ] ; System . arraycopy ( _stack , 0 , stack , 0 , index ) ; _stack = stack ; } _stack [ index ] = parent ; } if ( index > 0 ) -- index ; _currentNode = _stack [ index ] ; _oldsp = _sp = index ; return resetPosition ( ) ; } return this ; } public int next ( ) { for ( ++ _currentNode ; _sp >= 0 ; ++ _currentNode ) { if ( _currentNode < _stack [ _sp ] ) { if ( _type ( _currentNode ) != ATTRIBUTE_NODE && _type ( _currentNode ) != NAMESPACE_NODE ) return returnNode ( makeNodeHandle ( _currentNode ) ) ; } else -- _sp ; } return NULL ; } public DTMAxisIterator reset ( ) { _sp = _oldsp ; return resetPosition ( ) ; } public void setMark ( ) { _markedsp = _sp ; _markedNode = _currentNode ; _markedDescendant = _stack [ 0 ] ; } public void gotoMark ( ) { _sp = _markedsp ; _currentNode = _markedNode ; } } public final class TypedPrecedingIterator extends PrecedingIterator { private final int _nodeType ; public TypedPrecedingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { while ( true ) { node = node + 1 ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else if ( _exptype ( node ) == nodeType ) { break ; } } } else { int expType ; while ( true ) { node = node + 1 ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else { expType = _exptype ( node ) ; if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { break ; } } else { if ( m_expandedNameTable . getType ( expType ) == nodeType ) { break ; } } } } } _currentNode = node ; return ( node == NULL ) ? NULL : returnNode ( makeNodeHandle ( node ) ) ; } } public class FollowingIterator extends InternalAxisIteratorBase { DTMAxisTraverser m_traverser ; public FollowingIterator ( ) { m_traverser = getAxisTraverser ( Axis . FOLLOWING ) ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = m_traverser . first ( node ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; _currentNode = m_traverser . next ( _startNode , _currentNode ) ; return returnNode ( node ) ; } } public final class TypedFollowingIterator extends FollowingIterator { private final int _nodeType ; public TypedFollowingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node ; do { node = _currentNode ; _currentNode = m_traverser . next ( _startNode , _currentNode ) ; } while ( node != DTM . NULL && ( getExpandedTypeID ( node ) != _nodeType && getNodeType ( node ) != _nodeType ) ) ; return ( node == DTM . NULL ? DTM . NULL : returnNode ( node ) ) ; } } public class AncestorIterator extends InternalAxisIteratorBase { org . apache . xml . utils . NodeVector m_ancestors = new org . apache . xml . utils . NodeVector ( ) ; int m_ancestorsPos ; int m_markedPos ; int m_realStartNode ; public int getStartNode ( ) { return m_realStartNode ; } public final boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final AncestorIterator clone = ( AncestorIterator ) super . clone ( ) ; clone . _startNode = _startNode ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; if ( ! _includeSelf && node != DTM . NULL ) { nodeID = _parent ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } _startNode = node ; while ( nodeID != END ) { m_ancestors . addElement ( node ) ; nodeID = _parent ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } m_ancestorsPos = m_ancestors . size ( ) - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { m_ancestorsPos = m_ancestors . size ( ) - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return resetPosition ( ) ; } public int next ( ) { int next = _currentNode ; int pos = -- m_ancestorsPos ; _currentNode = ( pos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return returnNode ( next ) ; } public void setMark ( ) { m_markedPos = m_ancestorsPos ; } public void gotoMark ( ) { m_ancestorsPos = m_markedPos ; _currentNode = m_ancestorsPos >= 0 ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; } } public final class TypedAncestorIterator extends AncestorIterator { private final int _nodeType ; public TypedAncestorIterator ( int type ) { _nodeType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; int nodeType = _nodeType ; if ( ! _includeSelf && node != DTM . NULL ) { nodeID = _parent ( nodeID ) ; } _startNode = node ; if ( nodeType >= DTM . NTYPES ) { while ( nodeID != END ) { int eType = _exptype ( nodeID ) ; if ( eType == nodeType ) { m_ancestors . addElement ( makeNodeHandle ( nodeID ) ) ; } nodeID = _parent ( nodeID ) ; } } else { while ( nodeID != END ) { int eType = _exptype ( nodeID ) ; if ( ( eType >= DTM . NTYPES && m_expandedNameTable . getType ( eType ) == nodeType ) || ( eType < DTM . NTYPES && eType == nodeType ) ) { m_ancestors . addElement ( makeNodeHandle ( nodeID ) ) ; } nodeID = _parent ( nodeID ) ; } } m_ancestorsPos = m_ancestors . size ( ) - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return resetPosition ( ) ; } return this ; } } public class DescendantIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; _startNode = node ; if ( _includeSelf ) node -- ; _currentNode = node ; return resetPosition ( ) ; } return this ; } protected boolean isDescendant ( int identity ) { return ( _parent ( identity ) >= _startNode ) || ( _startNode == identity ) ; } public int next ( ) { if ( _startNode == NULL ) { return NULL ; } if ( _includeSelf && ( _currentNode + 1 ) == _startNode ) return returnNode ( makeNodeHandle ( ++ _currentNode ) ) ; int node = _currentNode ; int type ; do { node ++ ; type = _type ( node ) ; if ( NULL == type || ! isDescendant ( node ) ) { _currentNode = NULL ; return END ; } } while ( ATTRIBUTE_NODE == type || TEXT_NODE == type || NAMESPACE_NODE == type ) ; _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } public DTMAxisIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( makeNodeHandle ( _startNode ) ) ; _isRestartable = temp ; return this ; } } public final class TypedDescendantIterator extends DescendantIterator { private final int _nodeType ; public TypedDescendantIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { int node ; int type ; if ( _startNode == NULL ) { return NULL ; } node = _currentNode ; do { node ++ ; type = _type ( node ) ; if ( NULL == type || ! isDescendant ( node ) ) { _currentNode = NULL ; return END ; } } while ( type != _nodeType && _exptype ( node ) != _nodeType ) ; _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } } public class NthDescendantIterator extends DescendantIterator { int _pos ; public NthDescendantIterator ( int pos ) { _pos = pos ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != END ) { node = makeNodeIdentity ( node ) ; int parent = _parent ( node ) ; int child = _firstch ( parent ) ; int pos = 0 ; do { int type = _type ( child ) ; if ( ELEMENT_NODE == type ) pos ++ ; } while ( ( pos < _pos ) && ( child = _nextsib ( child ) ) != END ) ; if ( node == child ) return node ; } return ( END ) ; } } public class SingletonIterator extends InternalAxisIteratorBase { private boolean _isConstant ; public SingletonIterator ( ) { this ( Integer . MIN_VALUE , false ) ; } public SingletonIterator ( int node ) { this ( node , false ) ; } public SingletonIterator ( int node , boolean constant ) { _currentNode = _startNode = node ; _isConstant = constant ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isConstant ) { _currentNode = _startNode ; return resetPosition ( ) ; } else if ( _isRestartable ) { if ( _currentNode == Integer . MIN_VALUE ) { _currentNode = _startNode = node ; } return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { if ( _isConstant ) { _currentNode = _startNode ; return resetPosition ( ) ; } else { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _startNode ) ; _isRestartable = temp ; } return this ; } public int next ( ) { final int result = _currentNode ; _currentNode = END ; return returnNode ( result ) ; } } public final class TypedSingletonIterator extends SingletonIterator { private final int _nodeType ; public TypedSingletonIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int result = _currentNode ; int nodeType = _nodeType ; _currentNode = END ; if ( nodeType >= DTM . NTYPES ) { if ( getExpandedTypeID ( result ) == nodeType ) { return returnNode ( result ) ; } } else { if ( getNodeType ( result ) == nodeType ) { return returnNode ( result ) ; } } return NULL ; } } } 	0	['4', '3', '3', '54', '36', '6', '46', '31', '4', '2', '243', '0', '0', '0.978723404', '0.642857143', '0', '0', '59.75', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; final class StringLengthCall extends FunctionCall { public StringLengthCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( argumentCount ( ) > 0 ) { argument ( ) . translate ( classGen , methodGen ) ; } else { il . append ( methodGen . loadContextNode ( ) ) ; Type . Node . translateTo ( classGen , methodGen , Type . String ) ; } il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_CLASS , "length" , "()I" ) ) ) ; } } 	0	['2', '4', '0', '11', '13', '1', '0', '11', '2', '2', '44', '0', '0', '0.989690722', '0.6', '2', '4', '21', '2', '1', '0']
package org . apache . xalan . xsltc . runtime ; import java . util . Vector ; public class AttributeList implements org . xml . sax . Attributes { private final static String EMPTYSTRING = "" ; private final static String CDATASTRING = "CDATA" ; private Hashtable _attributes ; private Vector _names ; private Vector _qnames ; private Vector _values ; private Vector _uris ; private int _length ; public AttributeList ( ) { _length = 0 ; } public AttributeList ( org . xml . sax . Attributes attributes ) { this ( ) ; if ( attributes != null ) { final int count = attributes . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { add ( attributes . getQName ( i ) , attributes . getValue ( i ) ) ; } } } private void alloc ( ) { _attributes = new Hashtable ( ) ; _names = new Vector ( ) ; _values = new Vector ( ) ; _qnames = new Vector ( ) ; _uris = new Vector ( ) ; } public int getLength ( ) { return ( _length ) ; } public String getURI ( int index ) { if ( index < _length ) return ( ( String ) _uris . elementAt ( index ) ) ; else return ( null ) ; } public String getLocalName ( int index ) { if ( index < _length ) return ( ( String ) _names . elementAt ( index ) ) ; else return ( null ) ; } public String getQName ( int pos ) { if ( pos < _length ) return ( ( String ) _qnames . elementAt ( pos ) ) ; else return ( null ) ; } public String getType ( int index ) { return ( CDATASTRING ) ; } public int getIndex ( String namespaceURI , String localPart ) { return ( - 1 ) ; } public int getIndex ( String qname ) { return ( - 1 ) ; } public String getType ( String uri , String localName ) { return ( CDATASTRING ) ; } public String getType ( String qname ) { return ( CDATASTRING ) ; } public String getValue ( int pos ) { if ( pos < _length ) return ( ( String ) _values . elementAt ( pos ) ) ; else return ( null ) ; } public String getValue ( String qname ) { if ( _attributes != null ) { final Integer obj = ( Integer ) _attributes . get ( qname ) ; if ( obj == null ) return null ; return ( getValue ( obj . intValue ( ) ) ) ; } else return null ; } public String getValue ( String uri , String localName ) { return ( getValue ( uri + ':' + localName ) ) ; } public void add ( String qname , String value ) { if ( _attributes == null ) alloc ( ) ; Integer obj = ( Integer ) _attributes . get ( qname ) ; if ( obj == null ) { _attributes . put ( qname , obj = new Integer ( _length ++ ) ) ; _qnames . addElement ( qname ) ; _values . addElement ( value ) ; int col = qname . lastIndexOf ( ':' ) ; if ( col > - 1 ) { _uris . addElement ( qname . substring ( 0 , col ) ) ; _names . addElement ( qname . substring ( col + 1 ) ) ; } else { _uris . addElement ( EMPTYSTRING ) ; _names . addElement ( qname ) ; } } else { final int index = obj . intValue ( ) ; _values . set ( index , value ) ; } } public void clear ( ) { _length = 0 ; if ( _attributes != null ) { _attributes . clear ( ) ; _names . removeAllElements ( ) ; _values . removeAllElements ( ) ; _qnames . removeAllElements ( ) ; _uris . removeAllElements ( ) ; } } } 	0	['17', '1', '0', '3', '39', '62', '2', '1', '16', '0.7578125', '276', '1', '1', '0', '0.441176471', '0', '0', '14.76470588', '4', '1.4706', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class LiteralExpr extends Expression { private final String _value ; private final String _namespace ; public LiteralExpr ( String value ) { _value = value ; _namespace = null ; } public LiteralExpr ( String value , String namespace ) { _value = value ; _namespace = namespace . equals ( Constants . EMPTYSTRING ) ? null : namespace ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . String ; } public String toString ( ) { return "literal-expr(" + _value + ')' ; } protected boolean contextDependent ( ) { return false ; } protected String getValue ( ) { return _value ; } protected String getNamespace ( ) { return _namespace ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0	['8', '3', '0', '16', '18', '4', '5', '11', '5', '0.571428571', '75', '1', '0', '0.922077922', '0.325', '2', '8', '8.125', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Text extends Instruction { private String _text ; private boolean _escaping = true ; private boolean _ignore = false ; private boolean _textElement = false ; public Text ( ) { _textElement = true ; } public Text ( String text ) { _text = text ; } protected String getText ( ) { return _text ; } protected void setText ( String text ) { if ( _text == null ) _text = text ; else _text = _text + text ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Text" ) ; indent ( indent + IndentIncrement ) ; Util . println ( _text ) ; } public void parseContents ( Parser parser ) { final String str = getAttribute ( "disable-output-escaping" ) ; if ( ( str != null ) && ( str . equals ( "yes" ) ) ) _escaping = false ; parseChildren ( parser ) ; if ( _text == null ) { if ( _textElement ) { _text = EMPTYSTRING ; } else { _ignore = true ; } } else if ( _textElement ) { if ( _text . length ( ) == 0 ) _ignore = true ; } else if ( getParent ( ) instanceof LiteralElement ) { LiteralElement element = ( LiteralElement ) getParent ( ) ; String space = element . getAttribute ( "xml:space" ) ; if ( ( space == null ) || ( ! space . equals ( "preserve" ) ) ) if ( _text . trim ( ) . length ( ) == 0 ) _ignore = true ; } else { if ( _text . trim ( ) . length ( ) == 0 ) _ignore = true ; } } public void ignore ( ) { _ignore = true ; } public boolean isTextElement ( ) { return _textElement ; } protected boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( ! _ignore ) { final int esc = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "setEscaping" , "(Z)Z" ) ; if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEINTERFACE ( esc , 2 ) ) ; } final int characters = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "characters" , "(" + STRING_SIG + ")V" ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _text ) ) ; il . append ( new INVOKEINTERFACE ( characters , 2 ) ) ; if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( esc , 2 ) ) ; il . append ( POP ) ; } } translateContents ( classGen , methodGen ) ; } } 	0	['10', '3', '0', '19', '33', '0', '6', '15', '7', '0.583333333', '262', '1', '0', '0.875', '0.266666667', '2', '6', '24.8', '10', '2.1', '0']
package org . apache . xalan . processor ; import org . apache . xalan . res . XSLTErrorResources ; class ProcessorImport extends ProcessorInclude { protected int getStylesheetType ( ) { return StylesheetHandler . STYPE_IMPORT ; } protected String getStylesheetInclErr ( ) { return XSLTErrorResources . ER_IMPORTING_ITSELF ; } } 	0	['3', '5', '0', '2', '4', '3', '1', '1', '0', '2', '10', '0', '0', '0.990950226', '1', '1', '1', '2.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . dom ; import java . io . Externalizable ; import java . io . IOException ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import org . apache . xml . dtm . DTMAxisIterator ; public class BitArray implements Externalizable { private int [ ] _bits ; private int _bitSize ; private int _intSize ; private int _mask ; private final static int [ ] _masks = { 0x80000000 , 0x40000000 , 0x20000000 , 0x10000000 , 0x08000000 , 0x04000000 , 0x02000000 , 0x01000000 , 0x00800000 , 0x00400000 , 0x00200000 , 0x00100000 , 0x00080000 , 0x00040000 , 0x00020000 , 0x00010000 , 0x00008000 , 0x00004000 , 0x00002000 , 0x00001000 , 0x00000800 , 0x00000400 , 0x00000200 , 0x00000100 , 0x00000080 , 0x00000040 , 0x00000020 , 0x00000010 , 0x00000008 , 0x00000004 , 0x00000002 , 0x00000001 } ; private final static boolean DEBUG_ASSERTIONS = false ; public BitArray ( ) { this ( 32 ) ; } public BitArray ( int size ) { if ( size < 32 ) size = 32 ; _bitSize = size ; _intSize = ( _bitSize > > > 5 ) + 1 ; _bits = new int [ _intSize + 1 ] ; } public BitArray ( int size , int [ ] bits ) { if ( size < 32 ) size = 32 ; _bitSize = size ; _intSize = ( _bitSize > > > 5 ) + 1 ; _bits = bits ; } public void setMask ( int mask ) { _mask = mask ; } public int getMask ( ) { return ( _mask ) ; } public final int size ( ) { return ( _bitSize ) ; } public final boolean getBit ( int bit ) { if ( DEBUG_ASSERTIONS ) { if ( bit >= _bitSize ) { throw new Error ( "Programmer's assertion in  BitArray.getBit" ) ; } } return ( ( _bits [ bit > > > 5 ] & _masks [ bit % 32 ] ) != 0 ) ; } public final int getNextBit ( int startBit ) { for ( int i = ( startBit > > > 5 ) ; i <= _intSize ; i ++ ) { int bits = _bits [ i ] ; if ( bits != 0 ) { for ( int b = ( startBit % 32 ) ; b < 32 ; b ++ ) { if ( ( bits & _masks [ b ] ) != 0 ) { return ( ( i << 5 ) + b ) ; } } } startBit = 0 ; } return ( DTMAxisIterator . END ) ; } private int _pos = Integer . MAX_VALUE ; private int _node = 0 ; private int _int = 0 ; private int _bit = 0 ; public final int getBitNumber ( int pos ) { if ( pos == _pos ) return ( _node ) ; if ( pos < _pos ) { _int = _bit = _pos = 0 ; } for ( ; _int <= _intSize ; _int ++ ) { int bits = _bits [ _int ] ; if ( bits != 0 ) { for ( ; _bit < 32 ; _bit ++ ) { if ( ( bits & _masks [ _bit ] ) != 0 ) { if ( ++ _pos == pos ) { _node = ( ( _int << 5 ) + _bit ) - 1 ; return ( _node ) ; } } } _bit = 0 ; } } return ( 0 ) ; } public final int [ ] data ( ) { return ( _bits ) ; } int _first = Integer . MAX_VALUE ; int _last = Integer . MIN_VALUE ; public final void setBit ( int bit ) { if ( DEBUG_ASSERTIONS ) { if ( bit >= _bitSize ) { throw new Error ( "Programmer's assertion in  BitArray.getBit" ) ; } } if ( bit >= _bitSize ) return ; final int i = ( bit > > > 5 ) ; if ( i < _first ) _first = i ; if ( i > _last ) _last = i ; _bits [ i ] |= _masks [ bit % 32 ] ; } public final BitArray merge ( BitArray other ) { if ( _last == - 1 ) { _bits = other . _bits ; } else if ( other . _last != - 1 ) { int start = ( _first < other . _first ) ? _first : other . _first ; int stop = ( _last > other . _last ) ? _last : other . _last ; if ( other . _intSize > _intSize ) { if ( stop > _intSize ) stop = _intSize ; for ( int i = start ; i <= stop ; i ++ ) other . _bits [ i ] |= _bits [ i ] ; _bits = other . _bits ; } else { if ( stop > other . _intSize ) stop = other . _intSize ; for ( int i = start ; i <= stop ; i ++ ) _bits [ i ] |= other . _bits [ i ] ; } } return ( this ) ; } public final void resize ( int newSize ) { if ( newSize > _bitSize ) { _intSize = ( newSize > > > 5 ) + 1 ; final int [ ] newBits = new int [ _intSize + 1 ] ; System . arraycopy ( _bits , 0 , newBits , 0 , ( _bitSize > > > 5 ) + 1 ) ; _bits = newBits ; _bitSize = newSize ; } } public BitArray cloneArray ( ) { return ( new BitArray ( _intSize , _bits ) ) ; } public void writeExternal ( ObjectOutput out ) throws IOException { out . writeInt ( _bitSize ) ; out . writeInt ( _mask ) ; out . writeObject ( _bits ) ; out . flush ( ) ; } public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { _bitSize = in . readInt ( ) ; _intSize = ( _bitSize > > > 5 ) + 1 ; _mask = in . readInt ( ) ; _bits = ( int [ ] ) in . readObject ( ) ; } } 	0	['17', '1', '0', '2', '24', '0', '2', '0', '16', '0.6875', '622', '0.833333333', '0', '0', '0.291666667', '0', '0', '34.88235294', '10', '2.2353', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Gte extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . greaterThanOrEqual ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xalan . templates ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class XUnresolvedVariable extends XObject { transient private int m_context ; transient private TransformerImpl m_transformer ; transient private int m_varStackPos = - 1 ; transient private int m_varStackContext ; private boolean m_isGlobal ; transient private boolean m_doneEval = true ; public XUnresolvedVariable ( ElemVariable obj , int sourceNode , TransformerImpl transformer , int varStackPos , int varStackContext , boolean isGlobal ) { super ( obj ) ; m_context = sourceNode ; m_transformer = transformer ; m_varStackPos = varStackPos ; m_varStackContext = varStackContext ; m_isGlobal = isGlobal ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( ! m_doneEval ) { this . m_transformer . getMsgMgr ( ) . error ( xctxt . getSAXLocator ( ) , XSLTErrorResources . ER_REFERENCING_ITSELF , new Object [ ] { ( ( ElemVariable ) this . object ( ) ) . getName ( ) . getLocalName ( ) } ) ; } VariableStack vars = xctxt . getVarStack ( ) ; int currentFrame = vars . getStackFrame ( ) ; ElemVariable velem = ( ElemVariable ) m_obj ; try { m_doneEval = false ; if ( - 1 != velem . m_frameSize ) vars . link ( velem . m_frameSize ) ; XObject var = velem . getValue ( m_transformer , m_context ) ; m_doneEval = true ; return var ; } finally { if ( - 1 != velem . m_frameSize ) vars . unlink ( currentFrame ) ; } } public void setVarStackPos ( int top ) { m_varStackPos = top ; } public void setVarStackContext ( int bottom ) { m_varStackContext = bottom ; } public int getType ( ) { return CLASS_UNRESOLVEDVARIABLE ; } public String getTypeString ( ) { return "XUnresolvedVariable (" + object ( ) . getClass ( ) . getName ( ) + ")" ; } } 	0	['6', '3', '0', '7', '23', '9', '1', '7', '6', '0.833333333', '134', '1', '1', '0.934210526', '0.361111111', '2', '12', '20.33333333', '1', '0.8333', '0']
package org . apache . xml . dtm . ref ; import org . w3c . dom . Node ; public class DTMNodeListBase implements org . w3c . dom . NodeList { public DTMNodeListBase ( ) { } public Node item ( int index ) { return null ; } public int getLength ( ) { return 0 ; } } 	0	['3', '1', '3', '3', '4', '3', '3', '0', '3', '2', '10', '0', '0', '0', '0.666666667', '0', '0', '2.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class NotCall extends FunctionCall { public NotCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; argument ( ) . translate ( classGen , methodGen ) ; il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; final Expression exp = argument ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; final BranchHandle gotoh = il . append ( new GOTO ( null ) ) ; _trueList = exp . _falseList ; _falseList = exp . _trueList ; _falseList . add ( gotoh ) ; } } 	0	['3', '4', '0', '14', '12', '3', '1', '13', '3', '2', '56', '0', '0', '0.979591837', '0.6', '2', '6', '17.66666667', '1', '0.6667', '0']
package org . apache . xpath . objects ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . OneStepIterator ; public class XObjectFactory { static public XObject create ( Object val ) { XObject result ; if ( val instanceof XObject ) { result = ( XObject ) val ; } else if ( val instanceof String ) { result = new XString ( ( String ) val ) ; } else if ( val instanceof Boolean ) { result = new XBoolean ( ( Boolean ) val ) ; } else if ( val instanceof Double ) { result = new XNumber ( ( ( Double ) val ) ) ; } else { result = new XObject ( val ) ; } return result ; } static public XObject create ( Object val , XPathContext xctxt ) { XObject result ; if ( val instanceof XObject ) { result = ( XObject ) val ; } else if ( val instanceof String ) { result = new XString ( ( String ) val ) ; } else if ( val instanceof Boolean ) { result = new XBoolean ( ( Boolean ) val ) ; } else if ( val instanceof Number ) { result = new XNumber ( ( ( Number ) val ) ) ; } else if ( val instanceof DTM ) { DTM dtm = ( DTM ) val ; try { int dtmRoot = dtm . getDocument ( ) ; DTMAxisIterator iter = dtm . getAxisIterator ( Axis . SELF ) ; iter . setStartNode ( dtmRoot ) ; DTMIterator iterator = new OneStepIterator ( iter , Axis . SELF ) ; iterator . setRoot ( dtmRoot , xctxt ) ; result = new XNodeSet ( iterator ) ; } catch ( Exception ex ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ex ) ; } } else if ( val instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) val ; try { DTMIterator iterator = new OneStepIterator ( iter , Axis . SELF ) ; iterator . setRoot ( iter . getStartNode ( ) , xctxt ) ; result = new XNodeSet ( iterator ) ; } catch ( Exception ex ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ex ) ; } } else if ( val instanceof DTMIterator ) { result = new XNodeSet ( ( DTMIterator ) val ) ; } else if ( val instanceof org . w3c . dom . Node ) { result = new XNodeSetForDOM ( ( org . w3c . dom . Node ) val , xctxt ) ; } else if ( val instanceof org . w3c . dom . NodeList ) { result = new XNodeSetForDOM ( ( org . w3c . dom . NodeList ) val , xctxt ) ; } else if ( val instanceof org . w3c . dom . traversal . NodeIterator ) { result = new XNodeSetForDOM ( ( org . w3c . dom . traversal . NodeIterator ) val , xctxt ) ; } else { result = new XObject ( val ) ; } return result ; } } 	0	['3', '1', '0', '13', '19', '3', '1', '13', '3', '2', '207', '0', '0', '0', '0.444444444', '0', '0', '68', '11', '5.3333', '0']
package org . apache . xml . dtm ; import javax . xml . transform . SourceLocator ; public class DTMConfigurationException extends DTMException { public DTMConfigurationException ( ) { super ( "Configuration Error" ) ; } public DTMConfigurationException ( String msg ) { super ( msg ) ; } public DTMConfigurationException ( Throwable e ) { super ( e ) ; } public DTMConfigurationException ( String msg , Throwable e ) { super ( msg , e ) ; } public DTMConfigurationException ( String message , SourceLocator locator ) { super ( message , locator ) ; } public DTMConfigurationException ( String message , SourceLocator locator , Throwable e ) { super ( message , locator , e ) ; } } 	0	['6', '5', '0', '2', '11', '15', '1', '1', '6', '2', '34', '0', '0', '1', '0.625', '0', '0', '4.666666667', '0', '0', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; public class WriterToASCI extends Writer { private final OutputStream m_os ; public WriterToASCI ( OutputStream os ) { m_os = os ; } public void write ( char chars [ ] , int start , int length ) throws java . io . IOException { int n = length + start ; for ( int i = start ; i < n ; i ++ ) { m_os . write ( chars [ i ] ) ; } } public void write ( int c ) throws IOException { m_os . write ( c ) ; } public void write ( String s ) throws IOException { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m_os . write ( s . charAt ( i ) ) ; } } public void flush ( ) throws java . io . IOException { m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } } 	0	['7', '2', '0', '1', '13', '0', '1', '0', '7', '0', '65', '1', '0', '0.684210526', '0.342857143', '1', '2', '8.142857143', '1', '0.8571', '0']
package org . apache . xml . dtm ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . XMLStringFactory ; public abstract class DTMManager { private static final String defaultPropName = "org.apache.xml.dtm.DTMManager" ; private static String defaultClassName = "org.apache.xml.dtm.ref.DTMManagerDefault" ; protected XMLStringFactory m_xsf = null ; protected DTMManager ( ) { } public XMLStringFactory getXMLStringFactory ( ) { return m_xsf ; } public void setXMLStringFactory ( XMLStringFactory xsf ) { m_xsf = xsf ; } public static DTMManager newInstance ( XMLStringFactory xsf ) throws DTMConfigurationException { DTMManager factoryImpl = null ; try { factoryImpl = ( DTMManager ) FactoryFinder . find ( defaultPropName , defaultClassName ) ; } catch ( FactoryFinder . ConfigurationError e ) { throw new DTMConfigurationException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DEFAULT_IMPL , null ) ) ; } if ( factoryImpl == null ) { throw new DTMConfigurationException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DEFAULT_IMPL , null ) ) ; } factoryImpl . setXMLStringFactory ( xsf ) ; return factoryImpl ; } public abstract DTM getDTM ( javax . xml . transform . Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing ) ; public abstract DTM getDTM ( int nodeHandle ) ; public abstract int getDTMHandleFromNode ( org . w3c . dom . Node node ) ; public abstract DTM createDocumentFragment ( ) ; public abstract boolean release ( DTM dtm , boolean shouldHardDelete ) ; public abstract DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) ; public abstract DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) ; public abstract DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) ; public abstract DTMIterator createDTMIterator ( int node ) ; public static boolean m_incremental = false ; public synchronized static boolean getIncremental ( ) { return m_incremental ; } public synchronized static void setIncremental ( boolean incremental ) { m_incremental = incremental ; } private static boolean debug ; static { try { debug = System . getProperty ( "dtm.debug" ) != null ; } catch ( SecurityException ex ) { } } public static final int IDENT_DTM_NODE_BITS = 16 ; public static final int IDENT_NODE_DEFAULT = ( 1 << IDENT_DTM_NODE_BITS ) - 1 ; public static final int IDENT_DTM_DEFAULT = ~ IDENT_NODE_DEFAULT ; public static final int IDENT_MAX_DTMS = ( IDENT_DTM_DEFAULT > > > IDENT_DTM_NODE_BITS ) + 1 ; public abstract int getDTMIdentity ( DTM dtm ) ; public int getDTMIdentityMask ( ) { return IDENT_DTM_DEFAULT ; } public int getNodeIdentityMask ( ) { return IDENT_NODE_DEFAULT ; } } 	0	['19', '1', '2', '53', '24', '157', '44', '10', '17', '0.99382716', '94', '0.444444444', '1', '0', '0.157407407', '0', '0', '3.473684211', '1', '0.8947', '0']
package org . apache . xalan . xsltc ; public class ProcessorVersion { private static int MAJOR = 1 ; private static int MINOR = 0 ; private static int DELTA = 0 ; public static void main ( String [ ] args ) { System . out . println ( "XSLTC version " + MAJOR + "." + MINOR + ( ( DELTA > 0 ) ? ( "." + DELTA ) : ( "" ) ) ) ; } } 	0	['3', '1', '0', '0', '9', '1', '0', '0', '2', '0.5', '44', '1', '0', '0', '0.5', '0', '0', '12.66666667', '2', '0.6667', '0']
package org . apache . xalan . transformer ; public interface TransformerClient { void setTransformState ( TransformState ts ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class String extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { return ( XString ) right . xstr ( ) ; } } 	0	['2', '3', '0', '5', '4', '1', '1', '4', '2', '2', '9', '0', '0', '0.975609756', '0.75', '1', '1', '3.5', '1', '0.5', '0']
package org . apache . xml . dtm ; public interface DTMIterator { public static final short FILTER_ACCEPT = 1 ; public static final short FILTER_REJECT = 2 ; public static final short FILTER_SKIP = 3 ; public DTM getDTM ( int nodeHandle ) ; public DTMManager getDTMManager ( ) ; public int getRoot ( ) ; public void setRoot ( int nodeHandle , Object environment ) ; public void reset ( ) ; public int getWhatToShow ( ) ; public boolean getExpandEntityReferences ( ) ; public int nextNode ( ) ; public int previousNode ( ) ; public void detach ( ) ; public void allowDetachToRelease ( boolean allowRelease ) ; public int getCurrentNode ( ) ; public boolean isFresh ( ) ; public void setShouldCacheNodes ( boolean b ) ; public boolean isMutable ( ) ; public int getCurrentPos ( ) ; public void runTo ( int index ) ; public void setCurrentPos ( int i ) ; public int item ( int index ) ; public void setItem ( int node , int index ) ; public int getLength ( ) ; public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException ; public Object clone ( ) throws CloneNotSupportedException ; public boolean isDocOrdered ( ) ; public int getAxis ( ) ; } 	0	['25', '1', '0', '53', '25', '300', '52', '2', '25', '1.041666667', '28', '0', '0', '0', '0.34', '0', '0', '0', '1', '1', '0']
package org . w3c . dom . xpath ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; public interface XPathExpression { public Object evaluate ( Node contextNode , short type , Object result ) throws XPathException , DOMException ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class ElementAvailableCall extends FunctionCall { public ElementAvailableCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argument ( ) instanceof LiteralExpr ) { return _type = Type . Boolean ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . NEED_LITERAL_ERR , "element-available" , this ) ; throw new TypeCheckError ( err ) ; } public Object evaluateAtCompileTime ( ) { return getResult ( ) ? Boolean . TRUE : Boolean . FALSE ; } public boolean getResult ( ) { try { final LiteralExpr arg = ( LiteralExpr ) argument ( ) ; final String qname = arg . getValue ( ) ; final int index = qname . indexOf ( ':' ) ; final String localName = ( index > 0 ) ? qname . substring ( index + 1 ) : qname ; return getParser ( ) . elementSupported ( arg . getNamespace ( ) , localName ) ; } catch ( ClassCastException e ) { return false ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final boolean result = getResult ( ) ; methodGen . getInstructionList ( ) . append ( new PUSH ( cpg , result ) ) ; } } 	0	['5', '4', '0', '17', '19', '10', '0', '17', '5', '2', '85', '0', '0', '0.96', '0.333333333', '3', '12', '16', '2', '1.2', '0']
package org . apache . xpath ; import javax . xml . transform . SourceLocator ; public interface ExpressionNode extends SourceLocator { public void exprSetParent ( ExpressionNode n ) ; public ExpressionNode exprGetParent ( ) ; public void exprAddChild ( ExpressionNode n , int i ) ; public ExpressionNode exprGetChild ( int i ) ; public int exprGetNumChildren ( ) ; } 	0	['5', '1', '0', '44', '5', '10', '44', '0', '5', '2', '5', '0', '0', '0', '0.6', '0', '0', '0', '1', '1', '0']
package org . apache . xml . utils ; public class SerializableLocatorImpl implements org . xml . sax . Locator , java . io . Serializable { public SerializableLocatorImpl ( ) { } public SerializableLocatorImpl ( org . xml . sax . Locator locator ) { setPublicId ( locator . getPublicId ( ) ) ; setSystemId ( locator . getSystemId ( ) ) ; setLineNumber ( locator . getLineNumber ( ) ) ; setColumnNumber ( locator . getColumnNumber ( ) ) ; } public String getPublicId ( ) { return publicId ; } public String getSystemId ( ) { return systemId ; } public int getLineNumber ( ) { return lineNumber ; } public int getColumnNumber ( ) { return columnNumber ; } public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setSystemId ( String systemId ) { this . systemId = systemId ; } public void setLineNumber ( int lineNumber ) { this . lineNumber = lineNumber ; } public void setColumnNumber ( int columnNumber ) { this . columnNumber = columnNumber ; } private String publicId ; private String systemId ; private int lineNumber ; private int columnNumber ; } 	0	['10', '1', '0', '0', '15', '37', '0', '0', '10', '0.777777778', '64', '1', '0', '0', '0.375', '0', '0', '5', '1', '0.8', '0']
package org . apache . xalan . xsltc . runtime . output ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . Writer ; class WriterOutputBuffer implements OutputBuffer { private static final int KB = 1024 ; private static int BUFFER_SIZE = 4 * KB ; static { final String osName = System . getProperty ( "os.name" ) ; if ( osName . equalsIgnoreCase ( "solaris" ) ) { BUFFER_SIZE = 32 * KB ; } } private Writer _writer ; public WriterOutputBuffer ( Writer writer ) { _writer = new BufferedWriter ( writer , BUFFER_SIZE ) ; } public String close ( ) { try { _writer . flush ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return "" ; } public OutputBuffer append ( String s ) { try { _writer . write ( s ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return this ; } public OutputBuffer append ( char [ ] s , int from , int to ) { try { _writer . write ( s , from , to ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return this ; } public OutputBuffer append ( char ch ) { try { _writer . write ( ch ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return this ; } } 	0	['6', '1', '0', '1', '16', '0', '0', '1', '5', '0.733333333', '88', '1', '0', '0', '0.333333333', '0', '0', '13.16666667', '1', '0.6667', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . utils . IntVector ; import org . w3c . dom . Node ; public class DTMAxisIterNodeList extends DTMNodeListBase { private DTM m_dtm ; private DTMAxisIterator m_iter ; private IntVector m_cachedNodes ; private int m_last = - 1 ; private DTMAxisIterNodeList ( ) { } public DTMAxisIterNodeList ( DTM dtm , DTMAxisIterator dtmAxisIterator ) { if ( dtmAxisIterator == null ) { m_last = 0 ; } else { m_cachedNodes = new IntVector ( ) ; m_dtm = dtm ; } m_iter = dtmAxisIterator ; } public DTMAxisIterator getDTMAxisIterator ( ) { return m_iter ; } public Node item ( int index ) { if ( m_iter != null ) { int node ; int count = m_cachedNodes . size ( ) ; if ( count > index ) { node = m_cachedNodes . elementAt ( index ) ; return m_dtm . getNode ( node ) ; } else if ( m_last == - 1 ) { while ( ( ( node = m_iter . next ( ) ) != DTMAxisIterator . END ) && count <= index ) { m_cachedNodes . addElement ( node ) ; count ++ ; } if ( node == DTMAxisIterator . END ) { m_last = count ; } else { return m_dtm . getNode ( node ) ; } } } return null ; } public int getLength ( ) { if ( m_last == - 1 ) { int node ; while ( ( node = m_iter . next ( ) ) != DTMAxisIterator . END ) { m_cachedNodes . addElement ( node ) ; } m_last = m_cachedNodes . size ( ) ; } return m_last ; } } 	0	['5', '2', '0', '5', '12', '0', '1', '4', '4', '0.4375', '119', '1', '3', '0.4', '0.4', '0', '0', '22', '7', '2.2', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class EmptySerializer implements SerializationHandler { protected static final String ERR = "EmptySerializer method not over-ridden" ; private static void throwUnimplementedException ( ) { return ; } public ContentHandler asContentHandler ( ) throws IOException { throwUnimplementedException ( ) ; return null ; } public void setContentHandler ( ContentHandler ch ) { throwUnimplementedException ( ) ; } public void close ( ) { throwUnimplementedException ( ) ; } public Properties getOutputFormat ( ) { throwUnimplementedException ( ) ; return null ; } public OutputStream getOutputStream ( ) { throwUnimplementedException ( ) ; return null ; } public Writer getWriter ( ) { throwUnimplementedException ( ) ; return null ; } public boolean reset ( ) { throwUnimplementedException ( ) ; return false ; } public void serialize ( Node node ) throws IOException { throwUnimplementedException ( ) ; } public void setCdataSectionElements ( Vector URI_and_localNames ) { throwUnimplementedException ( ) ; } public boolean setEscaping ( boolean escape ) throws SAXException { throwUnimplementedException ( ) ; return false ; } public void setIndent ( boolean indent ) { throwUnimplementedException ( ) ; } public void setIndentAmount ( int spaces ) { throwUnimplementedException ( ) ; } public void setOutputFormat ( Properties format ) { throwUnimplementedException ( ) ; } public void setOutputStream ( OutputStream output ) { throwUnimplementedException ( ) ; } public void setVersion ( String version ) { throwUnimplementedException ( ) ; } public void setWriter ( Writer writer ) { throwUnimplementedException ( ) ; } public void setTransformer ( Transformer transformer ) { throwUnimplementedException ( ) ; } public Transformer getTransformer ( ) { throwUnimplementedException ( ) ; return null ; } public void flushPending ( ) { throwUnimplementedException ( ) ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { throwUnimplementedException ( ) ; } public void addAttributes ( Attributes atts ) throws SAXException { throwUnimplementedException ( ) ; } public void addAttribute ( String name , String value ) { throwUnimplementedException ( ) ; } public void characters ( String chars ) throws SAXException { throwUnimplementedException ( ) ; } public void endElement ( String elemName ) throws SAXException { throwUnimplementedException ( ) ; } public void startDocument ( ) throws SAXException { throwUnimplementedException ( ) ; } public void startElement ( String uri , String localName , String qName ) throws SAXException { throwUnimplementedException ( ) ; } public void startElement ( String qName ) throws SAXException { throwUnimplementedException ( ) ; } public void namespaceAfterStartElement ( String uri , String prefix ) throws SAXException { throwUnimplementedException ( ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { throwUnimplementedException ( ) ; return false ; } public void entityReference ( String entityName ) throws SAXException { throwUnimplementedException ( ) ; } public NamespaceMappings getNamespaceMappings ( ) { throwUnimplementedException ( ) ; return null ; } public String getPrefix ( String uri ) { throwUnimplementedException ( ) ; return null ; } public String getNamespaceURI ( String name , boolean isElement ) { throwUnimplementedException ( ) ; return null ; } public String getNamespaceURIFromPrefix ( String prefix ) { throwUnimplementedException ( ) ; return null ; } public void setDocumentLocator ( Locator arg0 ) { throwUnimplementedException ( ) ; } public void endDocument ( ) throws SAXException { throwUnimplementedException ( ) ; } public void startPrefixMapping ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void endPrefixMapping ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void startElement ( String arg0 , String arg1 , String arg2 , Attributes arg3 ) throws SAXException { throwUnimplementedException ( ) ; } public void endElement ( String arg0 , String arg1 , String arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void characters ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void ignorableWhitespace ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void processingInstruction ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void skippedEntity ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void comment ( String comment ) throws SAXException { throwUnimplementedException ( ) ; } public void startDTD ( String arg0 , String arg1 , String arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void endDTD ( ) throws SAXException { throwUnimplementedException ( ) ; } public void startEntity ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void endEntity ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void startCDATA ( ) throws SAXException { throwUnimplementedException ( ) ; } public void endCDATA ( ) throws SAXException { throwUnimplementedException ( ) ; } public void comment ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public String getDoctypePublic ( ) { throwUnimplementedException ( ) ; return null ; } public String getDoctypeSystem ( ) { throwUnimplementedException ( ) ; return null ; } public String getEncoding ( ) { throwUnimplementedException ( ) ; return null ; } public boolean getIndent ( ) { throwUnimplementedException ( ) ; return false ; } public int getIndentAmount ( ) { throwUnimplementedException ( ) ; return 0 ; } public String getMediaType ( ) { throwUnimplementedException ( ) ; return null ; } public boolean getOmitXMLDeclaration ( ) { throwUnimplementedException ( ) ; return false ; } public String getStandalone ( ) { throwUnimplementedException ( ) ; return null ; } public String getVersion ( ) { throwUnimplementedException ( ) ; return null ; } public void setCdataSectionElements ( Hashtable h ) throws Exception { throwUnimplementedException ( ) ; } public void setDoctype ( String system , String pub ) { throwUnimplementedException ( ) ; } public void setDoctypePublic ( String doctype ) { throwUnimplementedException ( ) ; } public void setDoctypeSystem ( String doctype ) { throwUnimplementedException ( ) ; } public void setEncoding ( String encoding ) { throwUnimplementedException ( ) ; } public void setMediaType ( String mediatype ) { throwUnimplementedException ( ) ; } public void setOmitXMLDeclaration ( boolean b ) { throwUnimplementedException ( ) ; } public void setStandalone ( String standalone ) { throwUnimplementedException ( ) ; } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { throwUnimplementedException ( ) ; } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void warning ( SAXParseException arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void error ( SAXParseException arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void fatalError ( SAXParseException arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public DOMSerializer asDOMSerializer ( ) throws IOException { throwUnimplementedException ( ) ; return null ; } public void setNamespaceMappings ( NamespaceMappings mappings ) { throwUnimplementedException ( ) ; } public void setSourceLocator ( SourceLocator locator ) { throwUnimplementedException ( ) ; } } 	0	['81', '1', '2', '5', '82', '3240', '2', '3', '80', '1.0125', '266', '1', '0', '0', '0.096707819', '0', '0', '2.271604938', '1', '0.9877', '0']
package org . apache . xml . dtm . ref ; import java . util . Hashtable ; public class CustomStringPool extends DTMStringPool { final Hashtable m_stringToInt = new Hashtable ( ) ; public static final int NULL = - 1 ; public CustomStringPool ( ) { super ( ) ; } public void removeAllElements ( ) { m_intToString . removeAllElements ( ) ; if ( m_stringToInt != null ) m_stringToInt . clear ( ) ; } public String indexToString ( int i ) throws java . lang . ArrayIndexOutOfBoundsException { return ( String ) m_intToString . elementAt ( i ) ; } public int stringToIndex ( String s ) { if ( s == null ) return NULL ; Integer iobj = ( Integer ) m_stringToInt . get ( s ) ; if ( iobj == null ) { m_intToString . addElement ( s ) ; iobj = new Integer ( m_intToString . size ( ) ) ; m_stringToInt . put ( s , iobj ) ; } return iobj . intValue ( ) ; } } 	0	['4', '2', '0', '1', '15', '0', '0', '1', '4', '0.833333333', '62', '0', '0', '0.571428571', '0.5', '1', '4', '14', '3', '1.5', '0']
package org . apache . xpath ; import java . io . IOException ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class SourceTreeManager { private Vector m_sourceTree = new Vector ( ) ; public void reset ( ) { m_sourceTree = new Vector ( ) ; } URIResolver m_uriResolver ; public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_uriResolver ; } public String findURIFromDoc ( int owner ) { int n = m_sourceTree . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SourceTree sTree = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( owner == sTree . m_root ) return sTree . m_url ; } return null ; } public Source resolveURI ( String base , String urlString , SourceLocator locator ) throws TransformerException , IOException { Source source = null ; if ( null != m_uriResolver ) { source = m_uriResolver . resolve ( urlString , base ) ; } if ( null == source ) { String uri = SystemIDResolver . getAbsoluteURI ( urlString , base ) ; source = new StreamSource ( uri ) ; } return source ; } public void removeDocumentFromCache ( int n ) { if ( DTM . NULL == n ) return ; for ( int i = m_sourceTree . size ( ) - 1 ; i >= 0 ; -- i ) { SourceTree st = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( st != null && st . m_root == n ) { m_sourceTree . removeElementAt ( i ) ; return ; } } } public void putDocumentInCache ( int n , Source source ) { int cachedNode = getNode ( source ) ; if ( DTM . NULL != cachedNode ) { if ( ! ( cachedNode == n ) ) throw new RuntimeException ( "Programmer's Error!  " + "putDocumentInCache found reparse of doc: " + source . getSystemId ( ) ) ; return ; } if ( null != source . getSystemId ( ) ) { m_sourceTree . addElement ( new SourceTree ( n , source . getSystemId ( ) ) ) ; } } public int getNode ( Source source ) { String url = source . getSystemId ( ) ; if ( null == url ) return DTM . NULL ; int n = m_sourceTree . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SourceTree sTree = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( url . equals ( sTree . m_url ) ) return sTree . m_root ; } return DTM . NULL ; } public int getSourceTree ( String base , String urlString , SourceLocator locator , XPathContext xctxt ) throws TransformerException { try { Source source = this . resolveURI ( base , urlString , locator ) ; return getSourceTree ( source , locator , xctxt ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , locator , ioe ) ; } } public int getSourceTree ( Source source , SourceLocator locator , XPathContext xctxt ) throws TransformerException { int n = getNode ( source ) ; if ( DTM . NULL != n ) return n ; n = parseToNode ( source , locator , xctxt ) ; if ( DTM . NULL != n ) putDocumentInCache ( n , source ) ; return n ; } public int parseToNode ( Source source , SourceLocator locator , XPathContext xctxt ) throws TransformerException { try { Object xowner = xctxt . getOwnerObject ( ) ; DTM dtm ; if ( null != xowner && xowner instanceof org . apache . xml . dtm . DTMWSFilter ) { dtm = xctxt . getDTM ( source , false , ( org . apache . xml . dtm . DTMWSFilter ) xowner , false , true ) ; } else { dtm = xctxt . getDTM ( source , false , null , false , true ) ; } return dtm . getDocument ( ) ; } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , locator , e ) ; } } public static XMLReader getXMLReader ( Source inputSource , SourceLocator locator ) throws TransformerException { try { XMLReader reader = ( inputSource instanceof SAXSource ) ? ( ( SAXSource ) inputSource ) . getXMLReader ( ) : null ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } return reader ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se . getMessage ( ) , locator , se ) ; } } } 	0	['13', '1', '0', '8', '46', '42', '4', '5', '13', '0.625', '339', '0.5', '0', '0', '0.340659341', '0', '0', '24.92307692', '5', '1.8462', '0']
package org . apache . xalan . xsltc . compiler ; class IllegalCharException extends Exception { public IllegalCharException ( String s ) { super ( s ) ; } } 	0	['1', '3', '0', '0', '2', '0', '0', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Mod extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) % right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) % m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xml . serializer ; import java . util . Hashtable ; import org . xml . sax . Attributes ; import org . xml . sax . helpers . AttributesImpl ; public class AttributesImplSerializer extends AttributesImpl { private Hashtable m_indexFromQName = new Hashtable ( ) ; public int getIndex ( String qname ) { int index ; Integer i = ( Integer ) m_indexFromQName . get ( qname ) ; if ( i == null ) index = - 1 ; else index = i . intValue ( ) ; return index ; } public void addAttribute ( String uri , String local , String qname , String type , String val ) { int index = super . getLength ( ) ; super . addAttribute ( uri , local , qname , type , val ) ; Integer i = new Integer ( index ) ; m_indexFromQName . put ( qname , i ) ; } public void clear ( ) { m_indexFromQName . clear ( ) ; super . clear ( ) ; } public void setAttributes ( Attributes atts ) { super . setAttributes ( atts ) ; int numAtts = atts . getLength ( ) ; for ( int i = 0 ; i < numAtts ; i ++ ) { String qName = atts . getQName ( i ) ; int index = super . getIndex ( qName ) ; Integer io = new Integer ( index ) ; m_indexFromQName . put ( qName , io ) ; } } } 	0	['5', '2', '0', '6', '19', '0', '6', '0', '5', '0', '91', '1', '0', '0.857142857', '0.533333333', '1', '3', '17', '2', '1.2', '0']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XNodeSetForDOM extends XNodeSet { Object m_origObj ; public XNodeSetForDOM ( Node node , DTMManager dtmMgr ) { m_dtmMgr = dtmMgr ; m_origObj = node ; int dtmHandle = dtmMgr . getDTMHandleFromNode ( node ) ; m_obj = new NodeSetDTM ( dtmMgr ) ; ( ( NodeSetDTM ) m_obj ) . addNode ( dtmHandle ) ; } public XNodeSetForDOM ( XNodeSet val ) { super ( val ) ; if ( val instanceof XNodeSetForDOM ) m_origObj = ( ( XNodeSetForDOM ) val ) . m_origObj ; } public XNodeSetForDOM ( NodeList nodeList , XPathContext xctxt ) { m_dtmMgr = xctxt . getDTMManager ( ) ; m_origObj = nodeList ; org . apache . xpath . NodeSetDTM nsdtm = new org . apache . xpath . NodeSetDTM ( nodeList , xctxt ) ; m_last = nsdtm . getLength ( ) ; m_obj = nsdtm ; } public XNodeSetForDOM ( NodeIterator nodeIter , XPathContext xctxt ) { m_dtmMgr = xctxt . getDTMManager ( ) ; m_origObj = nodeIter ; org . apache . xpath . NodeSetDTM nsdtm = new org . apache . xpath . NodeSetDTM ( nodeIter , xctxt ) ; m_last = nsdtm . getLength ( ) ; m_obj = nsdtm ; } public Object object ( ) { return m_origObj ; } public NodeIterator nodeset ( ) throws javax . xml . transform . TransformerException { return ( m_origObj instanceof NodeIterator ) ? ( NodeIterator ) m_origObj : super . nodeset ( ) ; } public NodeList nodelist ( ) throws javax . xml . transform . TransformerException { return ( m_origObj instanceof NodeList ) ? ( NodeList ) m_origObj : super . nodelist ( ) ; } } 	0	['7', '5', '0', '5', '18', '0', '1', '4', '7', '0', '115', '0', '0', '0.978417266', '0.285714286', '3', '14', '15.28571429', '1', '0.4286', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; public final class VoidType extends Type { protected VoidType ( ) { } public String toString ( ) { return "void" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "V" ; } public org . apache . bcel . generic . Type toJCType ( ) { return null ; } public Instruction POP ( ) { return NOP ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( classGen . getConstantPool ( ) , "" ) ) ; } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( ! clazz . getName ( ) . equals ( "void" ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } } 	0	['9', '2', '0', '13', '20', '36', '1', '13', '8', '2', '85', '0', '0', '0.804878049', '0.351851852', '2', '3', '8.444444444', '2', '1.2222', '0']
package org . apache . xpath . operations ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public class Operation extends Expression implements ExpressionOwner { protected Expression m_left ; protected Expression m_right ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_left . fixupVariables ( vars , globalsSize ) ; m_right . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_left && m_left . canTraverseOutsideSubtree ( ) ) return true ; if ( null != m_right && m_right . canTraverseOutsideSubtree ( ) ) return true ; return false ; } public void setLeftRight ( Expression l , Expression r ) { m_left = l ; m_right = r ; l . exprSetParent ( this ) ; r . exprSetParent ( this ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject left = m_left . execute ( xctxt , true ) ; XObject right = m_right . execute ( xctxt , true ) ; XObject result = operate ( left , right ) ; left . detach ( ) ; right . detach ( ) ; return result ; } public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return null ; } public Expression getLeftOperand ( ) { return m_left ; } public Expression getRightOperand ( ) { return m_right ; } class LeftExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_left ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( Operation . this ) ; m_left = exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitBinaryOperation ( owner , this ) ) { m_left . callVisitors ( new LeftExprOwner ( ) , visitor ) ; m_right . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_right ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_right = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_left . deepEquals ( ( ( Operation ) expr ) . m_left ) ) return false ; if ( ! m_right . deepEquals ( ( ( Operation ) expr ) . m_right ) ) return false ; return true ; } } 	0	['12', '2', '14', '22', '23', '0', '17', '7', '12', '0.363636364', '149', '1', '2', '0.731707317', '0.21875', '1', '7', '11.25', '5', '1.5833', '0']
package org . apache . xalan . xsltc ; public interface StripFilter { public boolean stripSpace ( DOM dom , int node , int type ) ; } 	0	['1', '1', '0', '9', '1', '0', '9', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . serialize ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import org . xml . sax . ContentHandler ; public interface Serializer { public void setOutputStream ( OutputStream output ) ; public OutputStream getOutputStream ( ) ; public void setWriter ( Writer writer ) ; public Writer getWriter ( ) ; public void setOutputFormat ( Properties format ) ; public Properties getOutputFormat ( ) ; public ContentHandler asContentHandler ( ) throws IOException ; public DOMSerializer asDOMSerializer ( ) throws IOException ; public boolean reset ( ) ; } 	0	['9', '1', '0', '3', '9', '36', '2', '1', '9', '2', '9', '0', '0', '0', '0.333333333', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Templates ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . sax . SAXResult ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLFilterImpl ; import org . xml . sax . helpers . XMLReaderFactory ; public class TrAXFilter extends XMLFilterImpl { private Templates _templates ; private TransformerHandlerImpl _transformer ; public TrAXFilter ( Templates templates ) throws TransformerConfigurationException { _templates = templates ; _transformer = new TransformerHandlerImpl ( ( TransformerImpl ) templates . newTransformer ( ) ) ; } private void createParent ( ) throws SAXException { XMLReader parent = null ; try { SAXParserFactory pfactory = SAXParserFactory . newInstance ( ) ; pfactory . setNamespaceAware ( true ) ; SAXParser saxparser = pfactory . newSAXParser ( ) ; parent = saxparser . getXMLReader ( ) ; } catch ( ParserConfigurationException e ) { throw new SAXException ( e ) ; } catch ( FactoryConfigurationError e ) { throw new SAXException ( e . toString ( ) ) ; } if ( parent == null ) { parent = XMLReaderFactory . createXMLReader ( ) ; } setParent ( parent ) ; } public void parse ( InputSource input ) throws SAXException , IOException { if ( getParent ( ) == null ) { try { createParent ( ) ; } catch ( SAXException e ) { throw new SAXException ( e . toString ( ) ) ; } } getParent ( ) . parse ( input ) ; } public void parse ( String systemId ) throws SAXException , IOException { parse ( new InputSource ( systemId ) ) ; } public void setContentHandler ( ContentHandler handler ) { _transformer . setResult ( new SAXResult ( handler ) ) ; if ( getParent ( ) == null ) { try { createParent ( ) ; } catch ( SAXException e ) { return ; } } getParent ( ) . setContentHandler ( _transformer ) ; } public void setErrorListener ( ErrorListener handler ) { } } 	0	['6', '2', '0', '4', '25', '13', '2', '2', '5', '0.9', '104', '1', '1', '0.871794872', '0.305555556', '1', '1', '16', '2', '1', '0']
package org . apache . xalan . xsltc . runtime ; import org . xml . sax . SAXException ; import org . apache . xml . serializer . EmptySerializer ; public final class StringValueHandler extends EmptySerializer { private StringBuffer _buffer = new StringBuffer ( ) ; private String _str = null ; private static final String EMPTY_STR = "" ; private boolean m_escaping = false ; private int _nestedLevel = 0 ; public void characters ( char [ ] ch , int off , int len ) throws SAXException { if ( _nestedLevel > 0 ) return ; if ( _str != null ) { _buffer . append ( _str ) ; _str = null ; } _buffer . append ( ch , off , len ) ; } public String getValue ( ) { if ( _buffer . length ( ) != 0 ) { String result = _buffer . toString ( ) ; _buffer . setLength ( 0 ) ; return result ; } else { String result = _str ; _str = null ; return ( result != null ) ? result : EMPTY_STR ; } } public void characters ( String characters ) throws SAXException { if ( _nestedLevel > 0 ) return ; if ( _str == null && _buffer . length ( ) == 0 ) { _str = characters ; } else { if ( _str != null ) { _buffer . append ( _str ) ; _str = null ; } _buffer . append ( characters ) ; } } public void startElement ( String qname ) throws SAXException { _nestedLevel ++ ; } public void endElement ( String qname ) throws SAXException { _nestedLevel -- ; } public boolean setEscaping ( boolean bool ) { boolean oldEscaping = m_escaping ; m_escaping = bool ; return bool ; } public String getValueOfPI ( ) { final String value = getValue ( ) ; if ( value . indexOf ( "?>" ) > 0 ) { final int n = value . length ( ) ; final StringBuffer valueOfPI = new StringBuffer ( ) ; for ( int i = 0 ; i < n ; ) { final char ch = value . charAt ( i ++ ) ; if ( ch == '?' && value . charAt ( i ) == '>' ) { valueOfPI . append ( "? >" ) ; i ++ ; } else { valueOfPI . append ( ch ) ; } } return valueOfPI . toString ( ) ; } return value ; } } 	0	['8', '2', '0', '2', '19', '0', '1', '1', '8', '0.657142857', '183', '1', '0', '0.932692308', '0.35', '0', '0', '21.25', '5', '1.625', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNodeSet ; public class FilterExprIteratorSimple extends LocPathIterator { private Expression m_expr ; transient private XNodeSet m_exprObj ; private boolean m_mustHardReset = false ; private boolean m_canDetachNodeset = true ; public FilterExprIteratorSimple ( ) { super ( null ) ; } public FilterExprIteratorSimple ( Expression expr ) { super ( null ) ; m_expr = expr ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_exprObj = executeFilterExpr ( context , m_execContext , getPrefixResolver ( ) , getIsTopLevel ( ) , m_stackFrame , m_expr ) ; } public static XNodeSet executeFilterExpr ( int context , XPathContext xctxt , PrefixResolver prefixResolver , boolean isTopLevel , int stackFrame , Expression expr ) throws org . apache . xml . utils . WrappedRuntimeException { PrefixResolver savedResolver = xctxt . getNamespaceContext ( ) ; XNodeSet result = null ; try { xctxt . pushCurrentNode ( context ) ; xctxt . setNamespaceContext ( prefixResolver ) ; if ( isTopLevel ) { VariableStack vars = xctxt . getVarStack ( ) ; int savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( stackFrame ) ; result = ( org . apache . xpath . objects . XNodeSet ) expr . execute ( xctxt ) ; result . setShouldCacheNodes ( true ) ; vars . setStackFrame ( savedStart ) ; } else result = ( org . apache . xpath . objects . XNodeSet ) expr . execute ( xctxt ) ; } catch ( javax . xml . transform . TransformerException se ) { throw new org . apache . xml . utils . WrappedRuntimeException ( se ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . setNamespaceContext ( savedResolver ) ; } return result ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; if ( null != m_exprObj ) { m_lastFetched = next = m_exprObj . nextNode ( ) ; } else m_lastFetched = next = DTM . NULL ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } public void detach ( ) { if ( m_allowDetach ) { super . detach ( ) ; m_exprObj . detach ( ) ; m_exprObj = null ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_expr . fixupVariables ( vars , globalsSize ) ; } public Expression getInnerExpression ( ) { return m_expr ; } public void setInnerExpression ( Expression expr ) { expr . exprSetParent ( this ) ; m_expr = expr ; } public int getAnalysisBits ( ) { if ( null != m_expr && m_expr instanceof PathComponent ) { return ( ( PathComponent ) m_expr ) . getAnalysisBits ( ) ; } return WalkerFactory . BIT_FILTER ; } public boolean isDocOrdered ( ) { return m_exprObj . isDocOrdered ( ) ; } class filterExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_expr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FilterExprIteratorSimple . this ) ; m_expr = exp ; } } public void callPredicateVisitors ( XPathVisitor visitor ) { m_expr . callVisitors ( new filterExprOwner ( ) , visitor ) ; super . callPredicateVisitors ( visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FilterExprIteratorSimple fet = ( FilterExprIteratorSimple ) expr ; if ( ! m_expr . deepEquals ( fet . m_expr ) ) return false ; return true ; } public int getAxis ( ) { if ( null != m_exprObj ) return m_exprObj . getAxis ( ) ; else return Axis . FILTEREDLIST ; } } 	0	['16', '5', '0', '16', '44', '8', '4', '13', '14', '0.75', '261', '1', '2', '0.899280576', '0.18125', '3', '10', '15.0625', '4', '1.4375', '0']
package org . apache . xml . serializer ; import java . io . Writer ; import java . io . OutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . xml . serializer . DOMSerializer ; import org . xml . sax . ContentHandler ; public interface Serializer { public void setOutputStream ( OutputStream output ) ; public OutputStream getOutputStream ( ) ; public void setWriter ( Writer writer ) ; public Writer getWriter ( ) ; public void setOutputFormat ( Properties format ) ; public Properties getOutputFormat ( ) ; public ContentHandler asContentHandler ( ) throws IOException ; public DOMSerializer asDOMSerializer ( ) throws IOException ; public boolean reset ( ) ; } 	0	['9', '1', '0', '11', '9', '36', '10', '1', '9', '2', '9', '0', '0', '0', '0.333333333', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . objects ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xpath . res . XPATHErrorResources ; public class XStringForFSB extends XString { int m_start ; int m_length ; protected String m_strCache = null ; protected int m_hash = 0 ; public XStringForFSB ( FastStringBuffer val , int start , int length ) { super ( val ) ; m_start = start ; m_length = length ; if ( null == val ) throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , null ) ) ; } private XStringForFSB ( String val ) { super ( val ) ; throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FSB_CANNOT_TAKE_STRING , null ) ) ; } public FastStringBuffer fsb ( ) { return ( ( FastStringBuffer ) m_obj ) ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { fsb . append ( str ( ) ) ; } public boolean hasString ( ) { return ( null != m_strCache ) ; } public Object object ( ) { return str ( ) ; } public String str ( ) { if ( null == m_strCache ) { m_strCache = fsb ( ) . getString ( m_start , m_length ) ; } return m_strCache ; } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { fsb ( ) . sendSAXcharacters ( ch , m_start , m_length ) ; } public void dispatchAsComment ( org . xml . sax . ext . LexicalHandler lh ) throws org . xml . sax . SAXException { fsb ( ) . sendSAXComment ( lh , m_start , m_length ) ; } public int length ( ) { return m_length ; } public char charAt ( int index ) { return fsb ( ) . charAt ( m_start + index ) ; } public void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { int n = srcEnd - srcBegin ; if ( n > m_length ) n = m_length ; if ( n > ( dst . length - dstBegin ) ) n = ( dst . length - dstBegin ) ; int end = srcBegin + m_start + n ; int d = dstBegin ; FastStringBuffer fsb = fsb ( ) ; for ( int i = srcBegin + m_start ; i < end ; i ++ ) { dst [ d ++ ] = fsb . charAt ( i ) ; } } public boolean equals ( XMLString obj2 ) { if ( this == obj2 ) { return true ; } int n = m_length ; if ( n == obj2 . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != obj2 . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( XObject obj2 ) { if ( this == obj2 ) { return true ; } if ( obj2 . getType ( ) == XObject . CLASS_NUMBER ) return obj2 . equals ( this ) ; String str = obj2 . str ( ) ; int n = m_length ; if ( n == str . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != str . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( String anotherString ) { int n = m_length ; if ( n == anotherString . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != anotherString . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( Object obj2 ) { if ( null == obj2 ) return false ; if ( obj2 instanceof XNumber ) return obj2 . equals ( this ) ; else if ( obj2 instanceof XNodeSet ) return obj2 . equals ( this ) ; else if ( obj2 instanceof XStringForFSB ) return equals ( ( XMLString ) this ) ; else return equals ( obj2 . toString ( ) ) ; } public boolean equalsIgnoreCase ( String anotherString ) { return ( m_length == anotherString . length ( ) ) ? str ( ) . equalsIgnoreCase ( anotherString ) : false ; } public int compareTo ( XMLString xstr ) { int len1 = m_length ; int len2 = xstr . length ( ) ; int n = Math . min ( len1 , len2 ) ; FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { char c1 = fsb . charAt ( i ) ; char c2 = xstr . charAt ( j ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len1 - len2 ; } public int compareToIgnoreCase ( XMLString xstr ) { int len1 = m_length ; int len2 = xstr . length ( ) ; int n = Math . min ( len1 , len2 ) ; FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { char c1 = Character . toLowerCase ( fsb . charAt ( i ) ) ; char c2 = Character . toLowerCase ( xstr . charAt ( j ) ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len1 - len2 ; } public int hashCode ( ) { return super . hashCode ( ) ; } public boolean startsWith ( XMLString prefix , int toffset ) { FastStringBuffer fsb = fsb ( ) ; int to = m_start + toffset ; int tlim = m_start + m_length ; int po = 0 ; int pc = prefix . length ( ) ; if ( ( toffset < 0 ) || ( toffset > m_length - pc ) ) { return false ; } while ( -- pc >= 0 ) { if ( fsb . charAt ( to ) != prefix . charAt ( po ) ) { return false ; } to ++ ; po ++ ; } return true ; } public boolean startsWith ( XMLString prefix ) { return startsWith ( prefix , 0 ) ; } public int indexOf ( int ch ) { return indexOf ( ch , 0 ) ; } public int indexOf ( int ch , int fromIndex ) { int max = m_start + m_length ; FastStringBuffer fsb = fsb ( ) ; if ( fromIndex < 0 ) { fromIndex = 0 ; } else if ( fromIndex >= m_length ) { return - 1 ; } for ( int i = m_start + fromIndex ; i < max ; i ++ ) { if ( fsb . charAt ( i ) == ch ) { return i - m_start ; } } return - 1 ; } public XMLString substring ( int beginIndex ) { int len = m_length - beginIndex ; if ( len <= 0 ) return XString . EMPTYSTRING ; else { int start = m_start + beginIndex ; return new XStringForFSB ( fsb ( ) , start , len ) ; } } public XMLString substring ( int beginIndex , int endIndex ) { int len = endIndex - beginIndex ; if ( len > m_length ) len = m_length ; if ( len <= 0 ) return XString . EMPTYSTRING ; else { int start = m_start + beginIndex ; return new XStringForFSB ( fsb ( ) , start , len ) ; } } public XMLString concat ( String str ) { return new XString ( str ( ) . concat ( str ) ) ; } public XMLString trim ( ) { return fixWhiteSpace ( true , true , false ) ; } private static boolean isSpace ( char ch ) { return XMLCharacterRecognizer . isWhiteSpace ( ch ) ; } public XMLString fixWhiteSpace ( boolean trimHead , boolean trimTail , boolean doublePunctuationSpaces ) { int end = m_length + m_start ; char [ ] buf = new char [ m_length ] ; FastStringBuffer fsb = fsb ( ) ; boolean edit = false ; int d = 0 ; boolean pres = false ; for ( int s = m_start ; s < end ; s ++ ) { char c = fsb . charAt ( s ) ; if ( isSpace ( c ) ) { if ( ! pres ) { if ( ' ' != c ) { edit = true ; } buf [ d ++ ] = ' ' ; if ( doublePunctuationSpaces && ( d != 0 ) ) { char prevChar = buf [ d - 1 ] ; if ( ! ( ( prevChar == '.' ) || ( prevChar == '!' ) || ( prevChar == '?' ) ) ) { pres = true ; } } else { pres = true ; } } else { edit = true ; pres = true ; } } else { buf [ d ++ ] = c ; pres = false ; } } if ( trimTail && 1 <= d && ' ' == buf [ d - 1 ] ) { edit = true ; d -- ; } int start = 0 ; if ( trimHead && 0 < d && ' ' == buf [ 0 ] ) { edit = true ; start ++ ; } XMLStringFactory xsf = XMLStringFactoryImpl . getFactory ( ) ; return edit ? xsf . newstr ( buf , start , d - start ) : this ; } public double toDouble ( ) { if ( m_length == 0 ) return Double . NaN ; int i ; char c ; String valueString = fsb ( ) . getString ( m_start , m_length ) ; for ( i = 0 ; i < m_length ; i ++ ) if ( ! XMLCharacterRecognizer . isWhiteSpace ( valueString . charAt ( i ) ) ) break ; if ( valueString . charAt ( i ) == '-' ) i ++ ; for ( ; i < m_length ; i ++ ) { c = valueString . charAt ( i ) ; if ( c != '.' && ( c < '0' || c > '9' ) ) break ; } for ( ; i < m_length ; i ++ ) if ( ! XMLCharacterRecognizer . isWhiteSpace ( valueString . charAt ( i ) ) ) break ; if ( i != m_length ) return Double . NaN ; try { return new Double ( valueString ) . doubleValue ( ) ; } catch ( NumberFormatException nfe ) { return Double . NaN ; } } } 	0	['31', '4', '0', '10', '59', '117', '1', '10', '29', '0.5', '823', '0.5', '0', '0.802721088', '0.150537634', '4', '20', '25.41935484', '14', '2.9032', '0']
package org . apache . xpath . operations ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class VariableSafeAbsRef extends Variable { public XObject execute ( XPathContext xctxt , boolean destructiveOK ) throws javax . xml . transform . TransformerException { XNodeSet xns = ( XNodeSet ) super . execute ( xctxt , destructiveOK ) ; DTMManager dtmMgr = xctxt . getDTMManager ( ) ; int context = xctxt . getContextNode ( ) ; if ( dtmMgr . getDTM ( xns . getRoot ( ) ) . getDocument ( ) != dtmMgr . getDTM ( context ) . getDocument ( ) ) { Expression expr = ( Expression ) xns . getContainedIter ( ) ; xns = ( XNodeSet ) expr . asIterator ( xctxt , context ) ; } return xns ; } } 	0	['2', '3', '0', '9', '11', '1', '1', '8', '2', '2', '39', '0', '0', '0.97826087', '0.666666667', '1', '1', '18.5', '1', '0.5', '0']
package org . apache . xalan . xsltc ; import org . apache . xml . dtm . DTM ; public interface NodeIterator extends Cloneable { public static final int END = DTM . NULL ; public int next ( ) ; public NodeIterator reset ( ) ; public int getLast ( ) ; public int getPosition ( ) ; public void setMark ( ) ; public void gotoMark ( ) ; public NodeIterator setStartNode ( int node ) ; public boolean isReverse ( ) ; public NodeIterator cloneIterator ( ) ; public void setRestartable ( boolean isRestartable ) ; } 	0	['10', '1', '0', '1', '10', '45', '1', '0', '10', '1.111111111', '11', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class NameBase extends FunctionCall { private Expression _param = null ; private Type _paramType = Type . Node ; public NameBase ( QName fname ) { super ( fname ) ; } public NameBase ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _param = argument ( 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { switch ( argumentCount ( ) ) { case 0 : _paramType = Type . Node ; break ; case 1 : _paramType = _param . typeCheck ( stable ) ; break ; default : throw new TypeCheckError ( this ) ; } if ( ( _paramType != Type . NodeSet ) && ( _paramType != Type . Node ) && ( _paramType != Type . Reference ) ) { throw new TypeCheckError ( this ) ; } return ( _type = Type . String ) ; } public Type getType ( ) { return _type ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadDOM ( ) ) ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; } else if ( _paramType == Type . Node ) { _param . translate ( classGen , methodGen ) ; } else if ( _paramType == Type . Reference ) { _param . translate ( classGen , methodGen ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNodeSet" , "(" + OBJECT_SIG + ")" + NODE_ITERATOR_SIG ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; } else { _param . translate ( classGen , methodGen ) ; _param . startResetIterator ( classGen , methodGen ) ; il . append ( methodGen . nextNode ( ) ) ; } } } 	0	['5', '4', '3', '17', '21', '0', '3', '14', '5', '0.25', '149', '1', '2', '0.96969697', '0.366666667', '3', '14', '28.4', '4', '1.2', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFGE ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . IFLE ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . IF_ICMPGE ; import org . apache . bcel . generic . IF_ICMPGT ; import org . apache . bcel . generic . IF_ICMPLE ; import org . apache . bcel . generic . IF_ICMPLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; public final class BooleanType extends Type { protected BooleanType ( ) { } public String toString ( ) { return "boolean" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "Z" ; } public boolean isSimple ( ) { return true ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . BOOLEAN ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final BranchHandle falsec = il . append ( new IFEQ ( null ) ) ; il . append ( new PUSH ( cpg , "true" ) ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( new PUSH ( cpg , "false" ) ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { methodGen . getInstructionList ( ) . append ( I2D ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( BOOLEAN_CLASS ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( BOOLEAN_CLASS , "<init>" , "(Z)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz == java . lang . Boolean . TYPE ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } else if ( clazz . isAssignableFrom ( java . lang . Boolean . class ) ) { translateTo ( classGen , methodGen , Type . Reference ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { translateTo ( classGen , methodGen , clazz ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( BOOLEAN_CLASS ) ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( BOOLEAN_CLASS , BOOLEAN_VALUE , BOOLEAN_VALUE_SIG ) ) ) ; } public Instruction LOAD ( int slot ) { return new ILOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ISTORE ( slot ) ; } public BranchInstruction GT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGT ( null ) : ( BranchInstruction ) new IF_ICMPGT ( null ) ; } public BranchInstruction GE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGE ( null ) : ( BranchInstruction ) new IF_ICMPGE ( null ) ; } public BranchInstruction LT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLT ( null ) : ( BranchInstruction ) new IF_ICMPLT ( null ) ; } public BranchInstruction LE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLE ( null ) : ( BranchInstruction ) new IF_ICMPLE ( null ) ; } } 	0	['21', '2', '0', '49', '56', '208', '17', '36', '19', '0.95', '317', '0', '0', '0.622641509', '0.216450216', '1', '2', '14.04761905', '4', '1.4762', '0']
package org . apache . xalan . xsltc . runtime . output ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xalan . xsltc . trax . SAX2DOM ; import org . apache . xml . serializer . ToHTMLSAXHandler ; import org . apache . xml . serializer . ToHTMLStream ; import org . apache . xml . serializer . ToTextSAXHandler ; import org . apache . xml . serializer . ToTextStream ; import org . apache . xml . serializer . ToUnknownStream ; import org . apache . xml . serializer . ToXMLSAXHandler ; import org . apache . xml . serializer . ToXMLStream ; import org . apache . xml . serializer . SerializationHandler ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; public class TransletOutputHandlerFactory { public static final int STREAM = 0 ; public static final int SAX = 1 ; public static final int DOM = 2 ; private String _encoding = "utf-8" ; private String _method = null ; private int _outputType = STREAM ; private OutputStream _ostream = System . out ; private Writer _writer = null ; private Node _node = null ; private int _indentNumber = - 1 ; private ContentHandler _handler = null ; private LexicalHandler _lexHandler = null ; static public TransletOutputHandlerFactory newInstance ( ) { return new TransletOutputHandlerFactory ( ) ; } public void setOutputType ( int outputType ) { _outputType = outputType ; } public void setEncoding ( String encoding ) { if ( encoding != null ) { _encoding = encoding ; } } public void setOutputMethod ( String method ) { _method = method ; } public void setOutputStream ( OutputStream ostream ) { _ostream = ostream ; } public void setWriter ( Writer writer ) { _writer = writer ; } public void setHandler ( ContentHandler handler ) { _handler = handler ; } public void setLexicalHandler ( LexicalHandler lex ) { _lexHandler = lex ; } public void setNode ( Node node ) { _node = node ; } public Node getNode ( ) { return ( _handler instanceof SAX2DOM ) ? ( ( SAX2DOM ) _handler ) . getDOM ( ) : null ; } public void setIndentNumber ( int value ) { _indentNumber = value ; } public SerializationHandler getSerializationHandler ( ) throws IOException , ParserConfigurationException { SerializationHandler result = null ; switch ( _outputType ) { case STREAM : if ( _method == null ) { result = new ToUnknownStream ( ) ; } else if ( _method . equalsIgnoreCase ( "xml" ) ) { result = new ToXMLStream ( ) ; } else if ( _method . equalsIgnoreCase ( "html" ) ) { result = new ToHTMLStream ( ) ; } else if ( _method . equalsIgnoreCase ( "text" ) ) { result = new ToTextStream ( ) ; } if ( result != null && _indentNumber >= 0 ) { result . setIndentAmount ( _indentNumber ) ; } result . setEncoding ( _encoding ) ; if ( _writer != null ) { result . setWriter ( _writer ) ; } else { result . setOutputStream ( _ostream ) ; } return result ; case DOM : _handler = ( _node != null ) ? new SAX2DOM ( _node ) : new SAX2DOM ( ) ; _lexHandler = ( LexicalHandler ) _handler ; case SAX : if ( _method == null ) { _method = "xml" ; } if ( _method . equalsIgnoreCase ( "xml" ) ) { if ( _lexHandler == null ) { result = new ToXMLSAXHandler ( _handler , _encoding ) ; } else { result = new ToXMLSAXHandler ( _handler , _lexHandler , _encoding ) ; } } else if ( _method . equalsIgnoreCase ( "html" ) ) { if ( _lexHandler == null ) { result = new ToHTMLSAXHandler ( _handler , _encoding ) ; } else { result = new ToHTMLSAXHandler ( _handler , _lexHandler , _encoding ) ; } } else if ( _method . equalsIgnoreCase ( "text" ) ) { if ( _lexHandler == null ) { result = new ToTextSAXHandler ( _handler , _encoding ) ; } else { result = new ToTextSAXHandler ( _handler , _lexHandler , _encoding ) ; } } return result ; } return null ; } } 	0	['13', '1', '0', '12', '32', '34', '3', '9', '13', '0.826388889', '289', '0.75', '0', '0', '0.201923077', '0', '0', '20.30769231', '2', '1.0769', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Equals extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . equals ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject left = m_left . execute ( xctxt , true ) ; XObject right = m_right . execute ( xctxt , true ) ; boolean result = left . equals ( right ) ? true : false ; left . detach ( ) ; right . detach ( ) ; return result ; } } 	0	['3', '3', '0', '6', '7', '3', '1', '5', '3', '2', '40', '0', '0', '0.953488372', '0.555555556', '2', '2', '12.33333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . CompareGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . TestGenerator ; final class LastCall extends FunctionCall { public LastCall ( QName fname ) { super ( fname ) ; } public boolean hasPositionCall ( ) { return true ; } public boolean hasLastCall ( ) { return true ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( methodGen instanceof CompareGenerator ) { il . append ( ( ( CompareGenerator ) methodGen ) . loadLastNode ( ) ) ; } else if ( methodGen instanceof TestGenerator ) { il . append ( new ILOAD ( LAST_INDEX ) ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final int getLast = cpg . addInterfaceMethodref ( NODE_ITERATOR , "getLast" , "()I" ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKEINTERFACE ( getLast , 1 ) ) ; } } } 	0	['4', '4', '0', '13', '13', '6', '1', '12', '4', '2', '59', '0', '0', '0.96969697', '0.4375', '2', '4', '13.75', '3', '1.25', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class KeyCall extends FunctionCall { private Expression _name ; private Expression _value ; private Type _valueType ; private QName _resolvedQName = null ; public KeyCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; switch ( argumentCount ( ) ) { case 1 : _name = null ; _value = argument ( 0 ) ; break ; case 2 : _name = argument ( 0 ) ; _value = argument ( 1 ) ; break ; default : _name = _value = null ; break ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type returnType = super . typeCheck ( stable ) ; if ( _name != null ) { final Type nameType = _name . typeCheck ( stable ) ; if ( _name instanceof LiteralExpr ) { final LiteralExpr literal = ( LiteralExpr ) _name ; _resolvedQName = getParser ( ) . getQNameIgnoreDefaultNs ( literal . getValue ( ) ) ; } else if ( nameType instanceof StringType == false ) { _name = new CastExpr ( _name , Type . String ) ; } } _valueType = _value . typeCheck ( stable ) ; if ( _valueType != Type . NodeSet && _valueType != Type . String ) { _value = new CastExpr ( _value , Type . String ) ; } return returnType ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeHandle = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeHandle" , "(I)" + NODE_SIG ) ; final int dupInit = cpg . addMethodref ( DUP_FILTERED_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( DUP_FILTERED_ITERATOR ) ) ) ; il . append ( DUP ) ; translateCall ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( dupInit ) ) ; } private void translateCall ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeValue = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , "(I)" + STRING_SIG ) ; final int getKeyIndex = cpg . addMethodref ( TRANSLET_CLASS , "getKeyIndex" , "(Ljava/lang/String;)" + KEY_INDEX_SIG ) ; final int lookupId = cpg . addMethodref ( KEY_INDEX_CLASS , "lookupId" , "(Ljava/lang/Object;)V" ) ; final int lookupKey = cpg . addMethodref ( KEY_INDEX_CLASS , "lookupKey" , "(Ljava/lang/Object;)V" ) ; final int merge = cpg . addMethodref ( KEY_INDEX_CLASS , "merge" , "(" + KEY_INDEX_SIG + ")V" ) ; final int indexConstructor = cpg . addMethodref ( TRANSLET_CLASS , "createKeyIndex" , "()" + KEY_INDEX_SIG ) ; final int keyDom = cpg . addMethodref ( XSLT_PACKAGE + ".dom.KeyIndex" , "setDom" , "(" + DOM_INTF_SIG + ")V" ) ; final LocalVariableGen returnIndex = methodGen . addLocalVariable ( "returnIndex" , Util . getJCRefType ( KEY_INDEX_SIG ) , il . getEnd ( ) , null ) ; final LocalVariableGen searchIndex = methodGen . addLocalVariable ( "searchIndex" , Util . getJCRefType ( KEY_INDEX_SIG ) , il . getEnd ( ) , null ) ; if ( _valueType == Type . NodeSet ) { il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; _value . translate ( classGen , methodGen ) ; _value . startResetIterator ( classGen , methodGen ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEVIRTUAL ( indexConstructor ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( keyDom ) ) ; il . append ( new ASTORE ( returnIndex . getIndex ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( _name == null ) { il . append ( new PUSH ( cpg , "##id" ) ) ; } else if ( _resolvedQName != null ) { il . append ( new PUSH ( cpg , _resolvedQName . toString ( ) ) ) ; } else { _name . translate ( classGen , methodGen ) ; } il . append ( new INVOKEVIRTUAL ( getKeyIndex ) ) ; il . append ( new ASTORE ( searchIndex . getIndex ( ) ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( new ALOAD ( returnIndex . getIndex ( ) ) ) ; il . append ( new ALOAD ( searchIndex . getIndex ( ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( getNodeValue , 2 ) ) ; if ( _name == null ) { il . append ( new INVOKEVIRTUAL ( lookupId ) ) ; } else { il . append ( new INVOKEVIRTUAL ( lookupKey ) ) ; } il . append ( new INVOKEVIRTUAL ( merge ) ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGT ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new ALOAD ( returnIndex . getIndex ( ) ) ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; if ( _name == null ) { il . append ( new PUSH ( cpg , "##id" ) ) ; } else if ( _resolvedQName != null ) { il . append ( new PUSH ( cpg , _resolvedQName . toString ( ) ) ) ; } else { _name . translate ( classGen , methodGen ) ; } il . append ( new INVOKEVIRTUAL ( getKeyIndex ) ) ; il . append ( DUP ) ; _value . translate ( classGen , methodGen ) ; if ( _name == null ) { il . append ( new INVOKEVIRTUAL ( lookupId ) ) ; } else { il . append ( new INVOKEVIRTUAL ( lookupKey ) ) ; } } } } 	0	['4', '4', '0', '33', '45', '0', '1', '32', '3', '0.083333333', '524', '1', '4', '0.96969697', '0.458333333', '3', '7', '129', '8', '2.5', '0']
package org . apache . xml . dtm . ref ; import java . util . Vector ; import org . apache . xml . utils . IntVector ; public class DTMStringPool { Vector m_intToString ; static final int HASHPRIME = 101 ; int [ ] m_hashStart = new int [ HASHPRIME ] ; IntVector m_hashChain ; public static final int NULL = - 1 ; public DTMStringPool ( int chainSize ) { m_intToString = new Vector ( ) ; m_hashChain = new IntVector ( chainSize ) ; removeAllElements ( ) ; stringToIndex ( "" ) ; } public DTMStringPool ( ) { this ( 512 ) ; } public void removeAllElements ( ) { m_intToString . removeAllElements ( ) ; for ( int i = 0 ; i < HASHPRIME ; ++ i ) m_hashStart [ i ] = NULL ; m_hashChain . removeAllElements ( ) ; } public String indexToString ( int i ) throws java . lang . ArrayIndexOutOfBoundsException { if ( i == NULL ) return null ; return ( String ) m_intToString . elementAt ( i ) ; } public int stringToIndex ( String s ) { if ( s == null ) return NULL ; int hashslot = s . hashCode ( ) % HASHPRIME ; if ( hashslot < 0 ) hashslot = - hashslot ; int hashlast = m_hashStart [ hashslot ] ; int hashcandidate = hashlast ; while ( hashcandidate != NULL ) { if ( m_intToString . elementAt ( hashcandidate ) . equals ( s ) ) return hashcandidate ; hashlast = hashcandidate ; hashcandidate = m_hashChain . elementAt ( hashcandidate ) ; } int newIndex = m_intToString . size ( ) ; m_intToString . addElement ( s ) ; m_hashChain . addElement ( NULL ) ; if ( hashlast == NULL ) m_hashStart [ hashslot ] = newIndex ; else m_hashChain . setElementAt ( newIndex , hashlast ) ; return newIndex ; } public static void main ( String [ ] args ) { String [ ] word = { "Zero" , "One" , "Two" , "Three" , "Four" , "Five" , "Six" , "Seven" , "Eight" , "Nine" , "Ten" , "Eleven" , "Twelve" , "Thirteen" , "Fourteen" , "Fifteen" , "Sixteen" , "Seventeen" , "Eighteen" , "Nineteen" , "Twenty" , "Twenty-One" , "Twenty-Two" , "Twenty-Three" , "Twenty-Four" , "Twenty-Five" , "Twenty-Six" , "Twenty-Seven" , "Twenty-Eight" , "Twenty-Nine" , "Thirty" , "Thirty-One" , "Thirty-Two" , "Thirty-Three" , "Thirty-Four" , "Thirty-Five" , "Thirty-Six" , "Thirty-Seven" , "Thirty-Eight" , "Thirty-Nine" } ; DTMStringPool pool = new DTMStringPool ( ) ; System . out . println ( "If no complaints are printed below, we passed initial test." ) ; for ( int pass = 0 ; pass <= 1 ; ++ pass ) { int i ; for ( i = 0 ; i < word . length ; ++ i ) { int j = pool . stringToIndex ( word [ i ] ) ; if ( j != i ) System . out . println ( "\tMismatch populating pool: assigned " + j + " for create " + i ) ; } for ( i = 0 ; i < word . length ; ++ i ) { int j = pool . stringToIndex ( word [ i ] ) ; if ( j != i ) System . out . println ( "\tMismatch in stringToIndex: returned " + j + " for lookup " + i ) ; } for ( i = 0 ; i < word . length ; ++ i ) { String w = pool . indexToString ( i ) ; if ( ! word [ i ] . equals ( w ) ) System . out . println ( "\tMismatch in indexToString: returned" + w + " for lookup " + i ) ; } pool . removeAllElements ( ) ; System . out . println ( "\nPass " + pass + " complete\n" ) ; } } } 	0	['6', '1', '2', '6', '25', '3', '5', '1', '6', '0.56', '424', '0', '1', '0', '0.375', '0', '0', '68.83333333', '8', '2.8333', '0']
package org . apache . xalan . templates ; public class XMLNSDecl implements java . io . Serializable { public XMLNSDecl ( String prefix , String uri , boolean isExcluded ) { m_prefix = prefix ; m_uri = uri ; m_isExcluded = isExcluded ; } private String m_prefix ; public String getPrefix ( ) { return m_prefix ; } private String m_uri ; public String getURI ( ) { return m_uri ; } private boolean m_isExcluded ; public boolean getIsExcluded ( ) { return m_isExcluded ; } } 	0	['4', '1', '0', '2', '5', '0', '2', '0', '4', '0.666666667', '28', '1', '0', '0', '0.5', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . xalan . xsltc . cmdline ; import java . io . File ; import java . net . URL ; import java . util . Vector ; import org . apache . xalan . xsltc . cmdline . getopt . GetOpt ; import org . apache . xalan . xsltc . cmdline . getopt . GetOptsException ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; public final class Compile { private static int VERSION_MAJOR = 1 ; private static int VERSION_MINOR = 4 ; private static int VERSION_DELTA = 0 ; private static boolean _allowExit = true ; public static void printUsage ( ) { StringBuffer vers = new StringBuffer ( "XSLTC version " + VERSION_MAJOR + "." + VERSION_MINOR + ( ( VERSION_DELTA > 0 ) ? ( "." + VERSION_DELTA ) : ( "" ) ) ) ; System . err . println ( vers + "\n" + new ErrorMsg ( ErrorMsg . COMPILE_USAGE_STR ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } public static void main ( String [ ] args ) { try { boolean inputIsURL = false ; boolean useStdIn = false ; boolean classNameSet = false ; final GetOpt getopt = new GetOpt ( args , "o:d:j:p:uxhsinv" ) ; if ( args . length < 1 ) printUsage ( ) ; final XSLTC xsltc = new XSLTC ( ) ; xsltc . init ( ) ; int c ; while ( ( c = getopt . getNextOption ( ) ) != - 1 ) { switch ( c ) { case 'i' : useStdIn = true ; break ; case 'o' : xsltc . setClassName ( getopt . getOptionArg ( ) ) ; classNameSet = true ; break ; case 'd' : xsltc . setDestDirectory ( getopt . getOptionArg ( ) ) ; break ; case 'p' : xsltc . setPackageName ( getopt . getOptionArg ( ) ) ; break ; case 'j' : xsltc . setJarFileName ( getopt . getOptionArg ( ) ) ; break ; case 'x' : xsltc . setDebug ( true ) ; break ; case 'u' : inputIsURL = true ; break ; case 's' : _allowExit = false ; break ; case 'n' : xsltc . setTemplateInlining ( true ) ; break ; case 'v' : case 'h' : default : printUsage ( ) ; break ; } } boolean compileOK ; if ( useStdIn ) { if ( ! classNameSet ) { System . err . println ( new ErrorMsg ( ErrorMsg . COMPILE_STDIN_ERR ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } compileOK = xsltc . compile ( System . in , xsltc . getClassName ( ) ) ; } else { final String [ ] stylesheetNames = getopt . getCmdArgs ( ) ; final Vector stylesheetVector = new Vector ( ) ; for ( int i = 0 ; i < stylesheetNames . length ; i ++ ) { final String name = stylesheetNames [ i ] ; URL url ; if ( inputIsURL ) url = new URL ( name ) ; else url = ( new File ( name ) ) . toURL ( ) ; stylesheetVector . addElement ( url ) ; } compileOK = xsltc . compile ( stylesheetVector ) ; } if ( compileOK ) { xsltc . printWarnings ( ) ; if ( xsltc . getJarFileName ( ) != null ) xsltc . outputToJar ( ) ; if ( _allowExit ) System . exit ( 0 ) ; } else { xsltc . printWarnings ( ) ; xsltc . printErrors ( ) ; if ( _allowExit ) System . exit ( - 1 ) ; } } catch ( GetOptsException ex ) { System . err . println ( ex ) ; printUsage ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; if ( _allowExit ) System . exit ( - 1 ) ; } } } 	0	['4', '1', '0', '4', '40', '0', '0', '4', '3', '0.333333333', '240', '1', '0', '0', '0.333333333', '0', '0', '58', '12', '3.75', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xalan . xsltc . compiler . NodeTest ; public abstract class Type implements Constants { public static final Type Int = new IntType ( ) ; public static final Type Real = new RealType ( ) ; public static final Type Boolean = new BooleanType ( ) ; public static final Type NodeSet = new NodeSetType ( ) ; public static final Type String = new StringType ( ) ; public static final Type ResultTree = new ResultTreeType ( ) ; public static final Type Reference = new ReferenceType ( ) ; public static final Type Void = new VoidType ( ) ; public static final Type Object = new ObjectType ( ) ; public static final Type Node = new NodeType ( NodeTest . ANODE ) ; public static final Type Root = new NodeType ( NodeTest . ROOT ) ; public static final Type Element = new NodeType ( NodeTest . ELEMENT ) ; public static final Type Attribute = new NodeType ( NodeTest . ATTRIBUTE ) ; public static final Type Text = new NodeType ( NodeTest . TEXT ) ; public static final Type Comment = new NodeType ( NodeTest . COMMENT ) ; public static final Type Processing_Instruction = new NodeType ( NodeTest . PI ) ; public abstract String toString ( ) ; public abstract boolean identicalTo ( Type other ) ; public boolean isNumber ( ) { return false ; } public boolean implementedAsMethod ( ) { return false ; } public boolean isSimple ( ) { return false ; } public abstract org . apache . bcel . generic . Type toJCType ( ) ; public int distanceTo ( Type type ) { return type == this ? 0 : Integer . MAX_VALUE ; } public abstract String toSignature ( ) ; public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { FlowList fl = null ; if ( type == Type . Boolean ) { fl = translateToDesynthesized ( classGen , methodGen , ( BooleanType ) type ) ; } else { translateTo ( classGen , methodGen , type ) ; } return fl ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; return null ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getClass ( ) . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , clazz . getClass ( ) . toString ( ) , toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , "[" + toString ( ) + "]" ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , "[" + toString ( ) + "]" , toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public String getClassName ( ) { return ( EMPTYSTRING ) ; } public Instruction ADD ( ) { return null ; } public Instruction SUB ( ) { return null ; } public Instruction MUL ( ) { return null ; } public Instruction DIV ( ) { return null ; } public Instruction REM ( ) { return null ; } public Instruction NEG ( ) { return null ; } public Instruction LOAD ( int slot ) { return null ; } public Instruction STORE ( int slot ) { return null ; } public Instruction POP ( ) { return POP ; } public BranchInstruction GT ( boolean tozero ) { return null ; } public BranchInstruction GE ( boolean tozero ) { return null ; } public BranchInstruction LT ( boolean tozero ) { return null ; } public BranchInstruction LE ( boolean tozero ) { return null ; } public Instruction CMP ( boolean less ) { return null ; } public Instruction DUP ( ) { return DUP ; } } 	0	['33', '1', '10', '113', '53', '526', '104', '20', '32', '0.998046875', '300', '0', '16', '0', '0.234375', '0', '0', '7.606060606', '2', '1', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class TestGenerator extends MethodGenerator { private static int CONTEXT_NODE_INDEX = 1 ; private static int CURRENT_NODE_INDEX = 4 ; private static int ITERATOR_INDEX = 6 ; private Instruction _aloadDom ; private final Instruction _iloadCurrent ; private final Instruction _iloadContext ; private final Instruction _istoreCurrent ; private final Instruction _istoreContext ; private final Instruction _astoreIterator ; private final Instruction _aloadIterator ; public TestGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; _iloadCurrent = new ILOAD ( CURRENT_NODE_INDEX ) ; _istoreCurrent = new ISTORE ( CURRENT_NODE_INDEX ) ; _iloadContext = new ILOAD ( CONTEXT_NODE_INDEX ) ; _istoreContext = new ILOAD ( CONTEXT_NODE_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; } public int getHandlerIndex ( ) { return INVALID_INDEX ; } public int getIteratorIndex ( ) { return ITERATOR_INDEX ; } public void setDomIndex ( int domIndex ) { _aloadDom = new ALOAD ( domIndex ) ; } public Instruction loadDOM ( ) { return _aloadDom ; } public Instruction loadCurrentNode ( ) { return _iloadCurrent ; } public Instruction loadContextNode ( ) { return _iloadContext ; } public Instruction storeContextNode ( ) { return _istoreContext ; } public Instruction storeCurrentNode ( ) { return _istoreCurrent ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_NODE_INDEX ; } else { return super . getLocalIndex ( name ) ; } } } 	0	['13', '5', '0', '12', '20', '54', '3', '9', '12', '0.9', '119', '1', '0', '0.926174497', '0.21875', '2', '5', '7.384615385', '2', '0.9231', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . dtm . DTM ; final class AbsolutePathPattern extends LocationPathPattern { private final RelativePathPattern _left ; public AbsolutePathPattern ( RelativePathPattern left ) { _left = left ; if ( left != null ) { left . setParent ( this ) ; } } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _left != null ) _left . setParser ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _left == null ? Type . Root : _left . typeCheck ( stable ) ; } public boolean isWildcard ( ) { return false ; } public StepPattern getKernelPattern ( ) { return _left != null ? _left . getKernelPattern ( ) : null ; } public void reduceKernelPattern ( ) { _left . reduceKernelPattern ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _left != null ) { if ( _left instanceof StepPattern ) { final LocalVariableGen local = methodGen . addLocalVariable2 ( "apptmp" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) ) ; il . append ( DUP ) ; il . append ( new ISTORE ( local . getIndex ( ) ) ) ; _left . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; local . setEnd ( il . append ( new ILOAD ( local . getIndex ( ) ) ) ) ; methodGen . removeLocalVariable ( local ) ; } else { _left . translate ( classGen , methodGen ) ; } } final int getParent = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; InstructionHandle begin = il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getParent , 2 ) ) ; if ( _left instanceof AncestorPattern ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; } il . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; il . append ( new PUSH ( cpg , DTM . DOCUMENT_NODE ) ) ; final BranchHandle skip = il . append ( new IF_ICMPEQ ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; skip . setTarget ( il . append ( NOP ) ) ; if ( _left != null ) { _left . backPatchTrueList ( begin ) ; if ( _left instanceof AncestorPattern ) { final AncestorPattern ancestor = ( AncestorPattern ) _left ; _falseList . backPatch ( ancestor . getLoopHandle ( ) ) ; } _falseList . append ( _left . _falseList ) ; } } public String toString ( ) { return "absolutePathPattern(" + ( _left != null ? _left . toString ( ) : ")" ) ; } } 	0	['8', '5', '0', '29', '45', '0', '1', '29', '8', '0.142857143', '241', '1', '1', '0.933962264', '0.270833333', '4', '5', '29', '6', '1.875', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import org . w3c . dom . Node ; public interface DOMSerializer { public void serialize ( Node node ) throws IOException ; } 	0	['1', '1', '0', '8', '1', '0', '8', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . trax ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TemplatesHandler ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . xml . sax . XMLFilter ; public class SmartTransformerFactoryImpl extends SAXTransformerFactory { private TransformerFactory _xsltcFactory = null ; private TransformerFactory _xalanFactory = null ; private TransformerFactory _currFactory = null ; private ErrorListener _errorlistener = null ; private URIResolver _uriresolver = null ; public SmartTransformerFactoryImpl ( ) { } private void createXSLTCTransformerFactory ( ) { final String xsltcMessage = "org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl " + "could not create an " + "org.apache.xalan.xsltc.trax.TransformerFactoryImpl." ; try { Class xsltcFactClass = Class . forName ( "org.apache.xalan.xsltc.trax.TransformerFactoryImpl" ) ; _xsltcFactory = ( org . apache . xalan . xsltc . trax . TransformerFactoryImpl ) xsltcFactClass . newInstance ( ) ; } catch ( ClassNotFoundException e ) { System . err . println ( xsltcMessage ) ; } catch ( InstantiationException e ) { System . err . println ( xsltcMessage ) ; } catch ( IllegalAccessException e ) { System . err . println ( xsltcMessage ) ; } _currFactory = _xsltcFactory ; } private void createXalanTransformerFactory ( ) { final String xalanMessage = "org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl " + "could not create an " + "org.apache.xalan.processor.TransformerFactoryImpl." ; try { Class xalanFactClass = Class . forName ( "org.apache.xalan.processor.TransformerFactoryImpl" ) ; _xalanFactory = ( SAXTransformerFactory ) xalanFactClass . newInstance ( ) ; } catch ( ClassNotFoundException e ) { System . err . println ( xalanMessage ) ; } catch ( InstantiationException e ) { System . err . println ( xalanMessage ) ; } catch ( IllegalAccessException e ) { System . err . println ( xalanMessage ) ; } _currFactory = _xalanFactory ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { _errorlistener = listener ; } public ErrorListener getErrorListener ( ) { return _errorlistener ; } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( ( name . equals ( "translet-name" ) ) || ( name . equals ( "debug" ) ) ) { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } return _xsltcFactory . getAttribute ( name ) ; } else { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } return _xalanFactory . getAttribute ( name ) ; } } public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( ( name . equals ( "translet-name" ) ) || ( name . equals ( "debug" ) ) ) { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } _xsltcFactory . setAttribute ( name , value ) ; } else { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } _xalanFactory . setAttribute ( name , value ) ; } } public boolean getFeature ( String name ) { String [ ] features = { DOMSource . FEATURE , DOMResult . FEATURE , SAXSource . FEATURE , SAXResult . FEATURE , StreamSource . FEATURE , StreamResult . FEATURE } ; for ( int i = 0 ; i < features . length ; i ++ ) { if ( name . equals ( features [ i ] ) ) return true ; } return false ; } public URIResolver getURIResolver ( ) { return _uriresolver ; } public void setURIResolver ( URIResolver resolver ) { _uriresolver = resolver ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { if ( _currFactory == null ) { createXSLTCTransformerFactory ( ) ; } return _currFactory . getAssociatedStylesheet ( source , media , title , charset ) ; } public Transformer newTransformer ( ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } _currFactory = _xalanFactory ; return _currFactory . newTransformer ( ) ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } _currFactory = _xalanFactory ; return _currFactory . newTransformer ( source ) ; } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } _currFactory = _xsltcFactory ; return _currFactory . newTemplates ( source ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } return ( ( SAXTransformerFactory ) _xsltcFactory ) . newTemplatesHandler ( ) ; } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } return ( ( SAXTransformerFactory ) _xalanFactory ) . newTransformerHandler ( ) ; } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } return ( ( SAXTransformerFactory ) _xalanFactory ) . newTransformerHandler ( src ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } return ( ( SAXTransformerFactory ) _xsltcFactory ) . newTransformerHandler ( templates ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } Templates templates = _xsltcFactory . newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new org . apache . xalan . xsltc . trax . TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException e1 ) { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } ErrorListener errorListener = _xsltcFactory . getErrorListener ( ) ; if ( errorListener != null ) { try { errorListener . fatalError ( e1 ) ; return null ; } catch ( TransformerException e2 ) { new TransformerConfigurationException ( e2 ) ; } } throw e1 ; } } } 	0	['21', '3', '0', '2', '43', '0', '0', '2', '19', '0.5', '498', '1', '0', '0.5', '0.220238095', '1', '2', '22.47619048', '3', '1.0476', '0']
package org . apache . xml . utils ; public class ThreadControllerWrapper { static ThreadController m_tpool = new ThreadController ( ) ; public static void setThreadController ( ThreadController tpool ) { m_tpool = tpool ; } public static Thread runThread ( Runnable runnable , int priority ) { return m_tpool . run ( runnable , priority ) ; } public static void waitThread ( Thread worker , Runnable task ) throws InterruptedException { m_tpool . waitThread ( worker , task ) ; } public static class ThreadController { public Thread run ( Runnable task , int priority ) { Thread t = new Thread ( task ) ; t . start ( ) ; return t ; } public void waitThread ( Thread worker , Runnable task ) throws InterruptedException { worker . join ( ) ; } } } 	0	['5', '1', '0', '3', '9', '0', '2', '1', '4', '0.25', '27', '0', '1', '0', '0.3', '0', '0', '4.2', '1', '0.6', '0']
package org . apache . xml . res ; public class XMLErrorResources_zh_CN extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "函数不受支持！ " } , { ER_CANNOT_OVERWRITE_CAUSE , "无法覆写事由 " } , { ER_NO_DEFAULT_IMPL , "未找到缺省执行  " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "目前不支持  ChunkedIntArray({0}) " } , { ER_OFFSET_BIGGER_THAN_SLOT , "偏移比槽略大 " } , { ER_COROUTINE_NOT_AVAIL , "协同程序不可用， id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager 接收到  co_exit() 请求 " } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() 失败 " } , { ER_COROUTINE_PARAM , "协同程序参数错误  ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: 分析器  doTerminate 回答  {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "当分析时可能不会调用分析函数 " } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "错误：在  axis {0} 中输入的迭代程序无法执行 " } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "错误：在  axis {0} 中的迭代程序无法执行 " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "不支持复制迭代程序 " } , { ER_UNKNOWN_AXIS_TYPE , "未知的  axis 遍历类型： {0}" } , { ER_AXIS_NOT_SUPPORTED , "不支持  axis 遍历器： {0}" } , { ER_NO_DTMIDS_AVAIL , "无法使用多个  DTM ID" } , { ER_NOT_SUPPORTED , "不支持： {0}" } , { ER_NODE_NON_NULL , "节点在  getDTMHandleFromNode 中必须非空 " } , { ER_COULD_NOT_RESOLVE_NODE , "无法将节点解析为句柄 " } , { ER_STARTPARSE_WHILE_PARSING , "在分析时可能会调用  startParse " } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse 需要一个非空的  SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "无法初始化分析器 " } , { ER_EXCEPTION_CREATING_POOL , "创建池的新实例时出现异常 " } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "路径包含无效的换码序列 " } , { ER_SCHEME_REQUIRED , "需要配置！ " } , { ER_NO_SCHEME_IN_URI , "在  URI 中未找到配置： {0}" } , { ER_NO_SCHEME_INURI , "在  URI 中未找到配置 " } , { ER_PATH_INVALID_CHAR , "路径包含无效的字符： {0}" } , { ER_SCHEME_FROM_NULL_STRING , "无法在空的字符串中设置配置 " } , { ER_SCHEME_NOT_CONFORMANT , "配置不一致。 " } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "主机地址的格式不正确 " } , { ER_PORT_WHEN_HOST_NULL , "当主机为空时无法设置端口 " } , { ER_INVALID_PORT , "无效的端口号 " } , { ER_FRAG_FOR_GENERIC_URI , "仅在一般的  URI 中设置段 " } , { ER_FRAG_WHEN_PATH_NULL , "当路径为空时无法设置段 " } , { ER_FRAG_INVALID_CHAR , "段中包含无效字符 " } , { ER_PARSER_IN_USE , "分析器正在使用 " } , { ER_CANNOT_CHANGE_WHILE_PARSING , "在分析时无法改变  {0} {1}" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "不允许自身引起结果 " } , { ER_NO_USERINFO_IF_NO_HOST , "如果未指定主机，可能不会指定用户信息 " } , { ER_NO_PORT_IF_NO_HOST , "如果未指定主机，可能不会指定端口 " } , { ER_NO_QUERY_STRING_IN_PATH , "在路径和查询字符串中，无法指定查询字符串  " } , { ER_NO_FRAGMENT_STRING_IN_PATH , "在路径和段中无法指定段  " } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "无法使用空的参数初始化  URI" } , { ER_METHOD_NOT_SUPPORTED , "方法仍不受支持  " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "当前无法重新启动  IncrementalSAXSource_Filter" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader 未在  startParse 请求之前出现 " } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "轴遍历程序不受支持： {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "用空  PrintWriter 来创建  ListingErrorHandler！ " } , { ER_SYSTEMID_UNKNOWN , "未知的  SystemId" } , { ER_LOCATION_UNKNOWN , "未知的错误位置 " } , { ER_PREFIX_MUST_RESOLVE , "必须解决名称空间的前缀：{0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "XPathContext 中不支持 createDocument()！" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "子属性没有属主文档！" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "子属性没有属主文档元素！" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "警告：不能输出文档元素之前的文字！忽略..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "DOM 上不能有多个根！" } , { ER_ARG_LOCALNAME_NULL , "变量 'localName' 为空" } , { ER_ARG_LOCALNAME_INVALID , "QNAME 中的 Localname 应该是一个有效的 NCName" } , { ER_ARG_PREFIX_INVALID , "QNAME 中的前缀应该是一个有效的 NCName" } , { "BAD_CODE" , "createMessage 参数超过范围 " } , { "FORMAT_FAILED" , "调用  messageFormat 时出现意外情况   " } , { "line" , "行  #" } , { "column" , "列  #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class NodeSortRecordGenerator extends ClassGenerator { private static final int TRANSLET_INDEX = 4 ; private final Instruction _aloadTranslet ; public NodeSortRecordGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; _aloadTranslet = new ALOAD ( TRANSLET_INDEX ) ; } public Instruction loadTranslet ( ) { return _aloadTranslet ; } public boolean isExternal ( ) { return true ; } } 	0	['3', '4', '0', '5', '5', '1', '1', '4', '3', '1', '25', '1', '0', '0.975903614', '0.466666667', '0', '0', '6.666666667', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class CurrentCall extends FunctionCall { public CurrentCall ( QName fname ) { super ( fname ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( methodGen . loadCurrentNode ( ) ) ; } } 	0	['2', '4', '0', '7', '6', '1', '0', '7', '2', '2', '13', '0', '0', '0.989690722', '0.625', '2', '4', '5.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class CeilingCall extends FunctionCall { public CeilingCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; argument ( 0 ) . translate ( classGen , methodGen ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( MATH_CLASS , "ceil" , "(D)D" ) ) ) ; } } 	0	['2', '4', '0', '10', '10', '1', '0', '10', '2', '2', '31', '0', '0', '0.989690722', '0.6', '2', '5', '14.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class When extends Instruction { private Expression _test ; private boolean _ignore = false ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "When" ) ; indent ( indent + IndentIncrement ) ; System . out . print ( "test " ) ; Util . println ( _test . toString ( ) ) ; displayContents ( indent + IndentIncrement ) ; } public Expression getTest ( ) { return _test ; } public boolean ignore ( ) { return ( _ignore ) ; } public void parseContents ( Parser parser ) { _test = parser . parseExpression ( this , "test" , null ) ; Object result = _test . evaluateAtCompileTime ( ) ; if ( result != null && result instanceof Boolean ) { _ignore = ! ( ( Boolean ) result ) . booleanValue ( ) ; } parseChildren ( parser ) ; if ( _test . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "test" ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _test . typeCheck ( stable ) instanceof BooleanType == false ) { _test = new CastExpr ( _test , Type . Boolean ) ; } if ( ! _ignore ) { typeCheckContents ( stable ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . STRAY_WHEN_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } 	0	['7', '3', '0', '14', '25', '0', '2', '13', '6', '0.5', '118', '1', '1', '0.903225806', '0.285714286', '1', '6', '15.57142857', '5', '1.4286', '0']
package org . apache . xalan . xsltc . cmdline . getopt ; class IllegalArgumentException extends GetOptsException { public IllegalArgumentException ( String msg ) { super ( msg ) ; } } 	0	['1', '4', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xalan . xsltc . dom ; import java . util . StringTokenizer ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public class KeyIndex extends DTMAxisIteratorBase { private Hashtable _index = new Hashtable ( ) ; private IntegerArray _nodes = null ; private DOM _dom ; private SAXImpl _saxImpl ; private int _markedPosition = 0 ; public KeyIndex ( int dummy ) { } public void setRestartable ( boolean flag ) { } public void add ( Object value , int node ) { IntegerArray nodes ; if ( ( nodes = ( IntegerArray ) _index . get ( value ) ) == null ) { _index . put ( value , nodes = new IntegerArray ( ) ) ; } nodes . add ( node ) ; } public void merge ( KeyIndex other ) { if ( other == null ) return ; if ( other . _nodes != null ) { if ( _nodes == null ) { _nodes = other . _nodes ; } else { _nodes . merge ( other . _nodes ) ; } } } public void lookupId ( Object value ) { _nodes = null ; final StringTokenizer values = new StringTokenizer ( ( String ) value ) ; while ( values . hasMoreElements ( ) ) { final String token = ( String ) values . nextElement ( ) ; IntegerArray nodes = ( IntegerArray ) _index . get ( token ) ; if ( nodes == null && _saxImpl != null && _saxImpl . hasDOMSource ( ) ) { nodes = getDOMNodeById ( token ) ; } if ( nodes == null ) continue ; if ( _nodes == null ) { _nodes = nodes ; } else { _nodes . merge ( nodes ) ; } } } public IntegerArray getDOMNodeById ( String id ) { IntegerArray nodes = null ; if ( _saxImpl != null ) { int ident = _saxImpl . getElementById ( id ) ; if ( ident != DTM . NULL ) { nodes = new IntegerArray ( ) ; _index . put ( id , nodes ) ; nodes . add ( ident ) ; } } return nodes ; } public void lookupKey ( Object value ) { _nodes = ( IntegerArray ) _index . get ( value ) ; _position = 0 ; } public int next ( ) { if ( _nodes == null ) return DTMAxisIterator . END ; return ( _position < _nodes . cardinality ( ) ) ? _dom . getNodeHandle ( _nodes . at ( _position ++ ) ) : DTMAxisIterator . END ; } public int containsID ( int node , Object value ) { final String string = ( String ) value ; if ( string . indexOf ( ' ' ) > - 1 ) { final StringTokenizer values = new StringTokenizer ( string ) ; while ( values . hasMoreElements ( ) ) { final String token = ( String ) values . nextElement ( ) ; IntegerArray nodes = ( IntegerArray ) _index . get ( token ) ; if ( nodes == null && _saxImpl != null && _saxImpl . hasDOMSource ( ) ) { nodes = getDOMNodeById ( token ) ; } if ( nodes != null && nodes . indexOf ( node ) >= 0 ) { return 1 ; } } return 0 ; } else { IntegerArray nodes = ( IntegerArray ) _index . get ( value ) ; if ( nodes == null && _saxImpl != null && _saxImpl . hasDOMSource ( ) ) { nodes = getDOMNodeById ( string ) ; } return ( nodes != null && nodes . indexOf ( node ) >= 0 ) ? 1 : 0 ; } } public int containsKey ( int node , Object value ) { final IntegerArray nodes = ( IntegerArray ) _index . get ( value ) ; return ( nodes != null && nodes . indexOf ( node ) >= 0 ) ? 1 : 0 ; } public DTMAxisIterator reset ( ) { _position = 0 ; return this ; } public int getLast ( ) { return ( _nodes == null ) ? 0 : _nodes . cardinality ( ) ; } public int getPosition ( ) { return _position ; } public void setMark ( ) { _markedPosition = _position ; } public void gotoMark ( ) { _position = _markedPosition ; } public DTMAxisIterator setStartNode ( int start ) { if ( start == DTMAxisIterator . END ) { _nodes = null ; } else if ( _nodes != null ) { _position = 0 ; } return ( DTMAxisIterator ) this ; } public int getStartNode ( ) { return 0 ; } public boolean isReverse ( ) { return ( false ) ; } public DTMAxisIterator cloneIterator ( ) { KeyIndex other = new KeyIndex ( 0 ) ; other . _index = _index ; other . _nodes = _nodes ; other . _position = _position ; return ( DTMAxisIterator ) other ; } public void setDom ( DOM dom ) { _dom = dom ; if ( dom instanceof SAXImpl ) { _saxImpl = ( SAXImpl ) dom ; } else if ( dom instanceof DOMAdapter ) { DOM idom = ( ( DOMAdapter ) dom ) . getDOMImpl ( ) ; if ( idom instanceof SAXImpl ) { _saxImpl = ( SAXImpl ) idom ; } } } } 	0	['20', '2', '0', '9', '38', '34', '2', '7', '20', '0.778947368', '385', '1', '4', '0.40625', '0.242857143', '1', '7', '18', '11', '2.55', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public class StepIterator extends DTMAxisIteratorBase { protected DTMAxisIterator _source ; protected DTMAxisIterator _iterator ; private int _pos = - 1 ; public StepIterator ( DTMAxisIterator source , DTMAxisIterator iterator ) { _source = source ; _iterator = iterator ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; _iterator . setRestartable ( true ) ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final StepIterator clone = ( StepIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _iterator = _iterator . cloneIterator ( ) ; clone . _iterator . setRestartable ( true ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; _iterator . setStartNode ( _includeSelf ? _startNode : _source . next ( ) ) ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; _iterator . setStartNode ( _includeSelf ? _startNode : _source . next ( ) ) ; return resetPosition ( ) ; } public int next ( ) { for ( int node ; ; ) { if ( ( node = _iterator . next ( ) ) != END ) { return returnNode ( node ) ; } else if ( ( node = _source . next ( ) ) == END ) { return END ; } else { _iterator . setStartNode ( node ) ; } } } public void setMark ( ) { _source . setMark ( ) ; _iterator . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; _iterator . gotoMark ( ) ; } } 	0	['8', '2', '1', '4', '21', '0', '2', '3', '8', '0.333333333', '158', '1', '2', '0.65', '0.34375', '1', '5', '18.375', '3', '1.5', '0']
package org . apache . xpath . axes ; public interface PathComponent { public int getAnalysisBits ( ) ; } 	0	['1', '1', '0', '8', '1', '0', '8', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . trax ; import java . util . Properties ; public final class OutputSettings { private String _cdata_section_elements = null ; private String _doctype_public = null ; private String _encoding = null ; private String _indent = null ; private String _media_type = null ; private String _method = null ; private String _omit_xml_declaration = null ; private String _standalone = null ; private String _version = null ; public Properties getProperties ( ) { Properties properties = new Properties ( ) ; return ( properties ) ; } } 	0	['2', '1', '0', '0', '4', '1', '0', '0', '2', '1', '47', '1', '0', '0', '1', '0', '0', '18', '1', '0.5', '0']
package org . apache . xml . dtm ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import javax . xml . transform . SourceLocator ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class DTMException extends RuntimeException { SourceLocator locator ; public SourceLocator getLocator ( ) { return locator ; } public void setLocator ( SourceLocator location ) { locator = location ; } Throwable containedException ; public Throwable getException ( ) { return containedException ; } public Throwable getCause ( ) { return ( ( containedException == this ) ? null : containedException ) ; } public synchronized Throwable initCause ( Throwable cause ) { if ( ( this . containedException == null ) && ( cause != null ) ) { throw new IllegalStateException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CANNOT_OVERWRITE_CAUSE , null ) ) ; } if ( cause == this ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SELF_CAUSATION_NOT_PERMITTED , null ) ) ; } this . containedException = cause ; return this ; } public DTMException ( String message ) { super ( message ) ; this . containedException = null ; this . locator = null ; } public DTMException ( Throwable e ) { super ( e . getMessage ( ) ) ; this . containedException = e ; this . locator = null ; } public DTMException ( String message , Throwable e ) { super ( ( ( message == null ) || ( message . length ( ) == 0 ) ) ? e . getMessage ( ) : message ) ; this . containedException = e ; this . locator = null ; } public DTMException ( String message , SourceLocator locator ) { super ( message ) ; this . containedException = null ; this . locator = locator ; } public DTMException ( String message , SourceLocator locator , Throwable e ) { super ( message ) ; this . containedException = e ; this . locator = locator ; } public String getMessageAndLocation ( ) { StringBuffer sbuffer = new StringBuffer ( ) ; String message = super . getMessage ( ) ; if ( null != message ) { sbuffer . append ( message ) ; } if ( null != locator ) { String systemID = locator . getSystemId ( ) ; int line = locator . getLineNumber ( ) ; int column = locator . getColumnNumber ( ) ; if ( null != systemID ) { sbuffer . append ( "; SystemID: " ) ; sbuffer . append ( systemID ) ; } if ( 0 != line ) { sbuffer . append ( "; Line#: " ) ; sbuffer . append ( line ) ; } if ( 0 != column ) { sbuffer . append ( "; Column#: " ) ; sbuffer . append ( column ) ; } } return sbuffer . toString ( ) ; } public String getLocationAsString ( ) { if ( null != locator ) { StringBuffer sbuffer = new StringBuffer ( ) ; String systemID = locator . getSystemId ( ) ; int line = locator . getLineNumber ( ) ; int column = locator . getColumnNumber ( ) ; if ( null != systemID ) { sbuffer . append ( "; SystemID: " ) ; sbuffer . append ( systemID ) ; } if ( 0 != line ) { sbuffer . append ( "; Line#: " ) ; sbuffer . append ( line ) ; } if ( 0 != column ) { sbuffer . append ( "; Column#: " ) ; sbuffer . append ( column ) ; } return sbuffer . toString ( ) ; } else { return null ; } } public void printStackTrace ( ) { printStackTrace ( new java . io . PrintWriter ( System . err , true ) ) ; } public void printStackTrace ( java . io . PrintStream s ) { printStackTrace ( new java . io . PrintWriter ( s ) ) ; } public void printStackTrace ( java . io . PrintWriter s ) { if ( s == null ) { s = new java . io . PrintWriter ( System . err , true ) ; } try { String locInfo = getLocationAsString ( ) ; if ( null != locInfo ) { s . println ( locInfo ) ; } super . printStackTrace ( s ) ; } catch ( Throwable e ) { } Throwable exception = getException ( ) ; for ( int i = 0 ; ( i < 10 ) && ( null != exception ) ; i ++ ) { s . println ( "---------" ) ; try { if ( exception instanceof DTMException ) { String locInfo = ( ( DTMException ) exception ) . getLocationAsString ( ) ; if ( null != locInfo ) { s . println ( locInfo ) ; } } exception . printStackTrace ( s ) ; } catch ( Throwable e ) { s . println ( "Could not print stack trace..." ) ; } try { Method meth = ( ( Object ) exception ) . getClass ( ) . getMethod ( "getException" , null ) ; if ( null != meth ) { Throwable prev = exception ; exception = ( Throwable ) meth . invoke ( exception , null ) ; if ( prev == exception ) { break ; } } else { exception = null ; } } catch ( InvocationTargetException ite ) { exception = null ; } catch ( IllegalAccessException iae ) { exception = null ; } catch ( NoSuchMethodException nsme ) { exception = null ; } } } } 	0	['15', '4', '1', '12', '37', '0', '11', '1', '15', '0.392857143', '357', '0', '0', '0.62962963', '0.311111111', '1', '2', '22.66666667', '8', '2', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class UnparsedEntityUriCall extends FunctionCall { private Expression _entity ; public UnparsedEntityUriCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _entity = argument ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type entity = _entity . typeCheck ( stable ) ; if ( entity instanceof StringType == false ) { _entity = new CastExpr ( _entity , Type . String ) ; } return _type = Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadDOM ( ) ) ; _entity . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( cpg . addInterfaceMethodref ( DOM_INTF , GET_UNPARSED_ENTITY_URI , GET_UNPARSED_ENTITY_URI_SIG ) , 2 ) ) ; } } 	0	['3', '4', '0', '15', '14', '0', '0', '15', '3', '0', '63', '1', '1', '0.979591837', '0.444444444', '3', '13', '19.66666667', '1', '0.6667', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class AnyNodeCounter extends NodeCounter { public AnyNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getExpandedTypeID ( node ) ; return this ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next = _node ; final int root = _document . getDocument ( ) ; result = 0 ; while ( next >= root && ! matchesFrom ( next ) ) { if ( matchesCount ( next ) ) { ++ result ; } next -- ; } } return formatNumbers ( result ) ; } public static NodeCounter getDefaultNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { return new DefaultAnyNodeCounter ( translet , document , iterator ) ; } static class DefaultAnyNodeCounter extends AnyNodeCounter { public DefaultAnyNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next = _node ; result = 0 ; final int ntype = _document . getExpandedTypeID ( _node ) ; final int root = _document . getDocument ( ) ; while ( next >= 0 ) { if ( ntype == _document . getExpandedTypeID ( next ) ) { result ++ ; } if ( next == root ) { break ; } else { -- next ; } } } return formatNumbers ( result ) ; } } } 	0	['4', '2', '1', '5', '11', '4', '1', '5', '4', '2', '63', '0', '0', '0.823529412', '0.5', '1', '4', '14.75', '5', '1.75', '0']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Element ; public interface WhitespaceStrippingElementMatcher { public boolean shouldStripWhiteSpace ( XPathContext support , Element targetElement ) throws TransformerException ; public boolean canStripWhiteSpace ( ) ; } 	0	['2', '1', '0', '2', '2', '1', '1', '1', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . processor ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Properties ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TemplatesHandler ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TrAXFilter ; import org . apache . xalan . transformer . TransformerIdentityImpl ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . XalanProperties ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM ; import org . apache . xml . utils . DefaultErrorHandler ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . TreeWalker ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; import org . xml . sax . XMLFilter ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class TransformerFactoryImpl extends SAXTransformerFactory { public static String XSLT_PROPERTIES = "org/apache/xalan/res/XSLTInfo.properties" ; public TransformerFactoryImpl ( ) { } private static final Class [ ] NO_CLASSES = new Class [ 0 ] ; private static final Object [ ] NO_OBJS = new Object [ 0 ] ; public static final String FEATURE_INCREMENTAL = "http://xml.apache.org/xalan/features/incremental" ; public static final String FEATURE_OPTIMIZE = "http://xml.apache.org/xalan/features/optimize" ; public static final String FEATURE_SOURCE_LOCATION = XalanProperties . SOURCE_LOCATION ; static { try { InputStream is = null ; try { Properties props = new Properties ( ) ; try { java . lang . reflect . Method getCCL = Thread . class . getMethod ( "getContextClassLoader" , NO_CLASSES ) ; if ( getCCL != null ) { ClassLoader contextClassLoader = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; is = contextClassLoader . getResourceAsStream ( XSLT_PROPERTIES ) ; } } catch ( Exception e ) { } if ( is == null ) { is = TransformerFactoryImpl . class . getResourceAsStream ( "/" + XSLT_PROPERTIES ) ; } BufferedInputStream bis = new BufferedInputStream ( is ) ; props . load ( bis ) ; bis . close ( ) ; Properties systemProps = System . getProperties ( ) ; Enumeration propEnum = props . propertyNames ( ) ; while ( propEnum . hasMoreElements ( ) ) { String prop = ( String ) propEnum . nextElement ( ) ; if ( ! systemProps . containsKey ( prop ) ) systemProps . put ( prop , props . getProperty ( prop ) ) ; } System . setProperties ( systemProps ) ; } catch ( Exception ex ) { } } catch ( SecurityException se ) { } } public javax . xml . transform . Templates processFromNode ( Node node ) throws TransformerConfigurationException { try { TemplatesHandler builder = newTemplatesHandler ( ) ; TreeWalker walker = new TreeWalker ( builder , new org . apache . xml . utils . DOM2Helper ( ) , builder . getSystemId ( ) ) ; walker . traverse ( node ) ; return builder . getTemplates ( ) ; } catch ( org . xml . sax . SAXException se ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( se ) ) ; } catch ( TransformerException ex ) { throw new TransformerConfigurationException ( ex ) ; } return null ; } else throw new TransformerConfigurationException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PROCESSFROMNODE_FAILED , null ) , se ) ; } catch ( TransformerConfigurationException tce ) { throw tce ; } catch ( Exception e ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( e ) ) ; } catch ( TransformerException ex ) { throw new TransformerConfigurationException ( ex ) ; } return null ; } else throw new TransformerConfigurationException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PROCESSFROMNODE_FAILED , null ) , e ) ; } } private String m_DOMsystemID = null ; String getDOMsystemID ( ) { return m_DOMsystemID ; } javax . xml . transform . Templates processFromNode ( Node node , String systemID ) throws TransformerConfigurationException { m_DOMsystemID = systemID ; return processFromNode ( node ) ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { String baseID ; InputSource isource = null ; Node node = null ; XMLReader reader = null ; if ( source instanceof DOMSource ) { DOMSource dsource = ( DOMSource ) source ; node = dsource . getNode ( ) ; baseID = dsource . getSystemId ( ) ; } else { isource = SAXSource . sourceToInputSource ( source ) ; baseID = isource . getSystemId ( ) ; } StylesheetPIHandler handler = new StylesheetPIHandler ( baseID , media , title , charset ) ; if ( m_uriResolver != null ) { handler . setURIResolver ( m_uriResolver ) ; } try { if ( null != node ) { TreeWalker walker = new TreeWalker ( handler , new org . apache . xml . utils . DOM2Helper ( ) , baseID ) ; walker . traverse ( node ) ; } else { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } reader . setContentHandler ( handler ) ; reader . parse ( isource ) ; } } catch ( StopParseException spe ) { } catch ( org . xml . sax . SAXException se ) { throw new TransformerConfigurationException ( "getAssociatedStylesheets failed" , se ) ; } catch ( IOException ioe ) { throw new TransformerConfigurationException ( "getAssociatedStylesheets failed" , ioe ) ; } return handler . getAssociatedStylesheet ( ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { return new StylesheetHandler ( this ) ; } public boolean getFeature ( String name ) { if ( ( DOMResult . FEATURE == name ) || ( DOMSource . FEATURE == name ) || ( SAXResult . FEATURE == name ) || ( SAXSource . FEATURE == name ) || ( StreamResult . FEATURE == name ) || ( StreamSource . FEATURE == name ) || ( SAXTransformerFactory . FEATURE == name ) || ( SAXTransformerFactory . FEATURE_XMLFILTER == name ) ) return true ; else if ( ( DOMResult . FEATURE . equals ( name ) ) || ( DOMSource . FEATURE . equals ( name ) ) || ( SAXResult . FEATURE . equals ( name ) ) || ( SAXSource . FEATURE . equals ( name ) ) || ( StreamResult . FEATURE . equals ( name ) ) || ( StreamSource . FEATURE . equals ( name ) ) || ( SAXTransformerFactory . FEATURE . equals ( name ) ) || ( SAXTransformerFactory . FEATURE_XMLFILTER . equals ( name ) ) ) return true ; else return false ; } public static boolean m_optimize = true ; public static boolean m_source_location = false ; public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( name . equals ( FEATURE_INCREMENTAL ) ) { if ( value instanceof Boolean ) { org . apache . xml . dtm . DTMManager . setIncremental ( ( ( Boolean ) value ) . booleanValue ( ) ) ; } else if ( value instanceof String ) { org . apache . xml . dtm . DTMManager . setIncremental ( ( new Boolean ( ( String ) value ) ) . booleanValue ( ) ) ; } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BAD_VALUE , new Object [ ] { name , value } ) ) ; } } else if ( name . equals ( FEATURE_OPTIMIZE ) ) { if ( value instanceof Boolean ) { m_optimize = ( ( Boolean ) value ) . booleanValue ( ) ; } else if ( value instanceof String ) { m_optimize = ( new Boolean ( ( String ) value ) ) . booleanValue ( ) ; } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BAD_VALUE , new Object [ ] { name , value } ) ) ; } } else if ( name . equals ( FEATURE_SOURCE_LOCATION ) ) { if ( value instanceof Boolean ) { m_source_location = ( ( Boolean ) value ) . booleanValue ( ) ; SAX2DTM . setUseSourceLocation ( m_source_location ) ; } else if ( value instanceof String ) { m_source_location = ( new Boolean ( ( String ) value ) ) . booleanValue ( ) ; SAX2DTM . setUseSourceLocation ( m_source_location ) ; } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BAD_VALUE , new Object [ ] { name , value } ) ) ; } } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUPPORTED , new Object [ ] { name } ) ) ; } } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( name . equals ( FEATURE_INCREMENTAL ) ) { return new Boolean ( org . apache . xml . dtm . DTMManager . getIncremental ( ) ) ; } else if ( name . equals ( FEATURE_OPTIMIZE ) ) { return new Boolean ( m_optimize ) ; } else if ( name . equals ( FEATURE_SOURCE_LOCATION ) ) { return new Boolean ( m_source_location ) ; } else throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ATTRIB_VALUE_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerException ex1 ) { new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newTransformerHandler ( templates ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { try { TransformerImpl transformer = ( TransformerImpl ) templates . newTransformer ( ) ; transformer . setURIResolver ( m_uriResolver ) ; TransformerHandler th = ( TransformerHandler ) transformer . getInputContentHandler ( true ) ; return th ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerException ex1 ) { ex = new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { return new TransformerIdentityImpl ( ) ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { try { Templates tmpl = newTemplates ( source ) ; if ( tmpl == null ) return null ; Transformer transformer = tmpl . newTransformer ( ) ; transformer . setURIResolver ( m_uriResolver ) ; return transformer ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerException ex1 ) { ex = new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } } public Transformer newTransformer ( ) throws TransformerConfigurationException { return new TransformerIdentityImpl ( ) ; } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { String baseID = source . getSystemId ( ) ; if ( null != baseID ) { baseID = SystemIDResolver . getAbsoluteURI ( baseID ) ; } if ( source instanceof DOMSource ) { DOMSource dsource = ( DOMSource ) source ; Node node = dsource . getNode ( ) ; if ( null != node ) return processFromNode ( node , baseID ) ; else { String messageStr = XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_DOMSOURCE_INPUT , null ) ; throw new IllegalArgumentException ( messageStr ) ; } } TemplatesHandler builder = newTemplatesHandler ( ) ; builder . setSystemId ( baseID ) ; try { InputSource isource = SAXSource . sourceToInputSource ( source ) ; isource . setSystemId ( baseID ) ; XMLReader reader = null ; if ( source instanceof SAXSource ) reader = ( ( SAXSource ) source ) . getXMLReader ( ) ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; reader . setContentHandler ( builder ) ; reader . parse ( isource ) ; } catch ( org . xml . sax . SAXException se ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( se ) ) ; } catch ( TransformerException ex1 ) { throw new TransformerConfigurationException ( ex1 ) ; } } else throw new TransformerConfigurationException ( se . getMessage ( ) , se ) ; } catch ( Exception e ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( e ) ) ; return null ; } catch ( TransformerException ex1 ) { throw new TransformerConfigurationException ( ex1 ) ; } } else throw new TransformerConfigurationException ( e . getMessage ( ) , e ) ; } return builder . getTemplates ( ) ; } URIResolver m_uriResolver ; public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_uriResolver ; } private ErrorListener m_errorListener = new DefaultErrorHandler ( ) ; public ErrorListener getErrorListener ( ) { return m_errorListener ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( null == listener ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ERRORLISTENER , null ) ) ; m_errorListener = listener ; } } 	0	['24', '3', '0', '22', '99', '190', '10', '14', '20', '0.936454849', '912', '0.307692308', '0', '0.476190476', '0.202898551', '1', '2', '36.45833333', '17', '1.5833', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMDefaultBase ; public final class AbsoluteIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; public AbsoluteIterator ( DTMAxisIterator source ) { _source = source ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator setStartNode ( int node ) { _startNode = DTMDefaultBase . ROOTNODE ; if ( _isRestartable ) { _source . setStartNode ( _startNode ) ; resetPosition ( ) ; } return this ; } public int next ( ) { return returnNode ( _source . next ( ) ) ; } public DTMAxisIterator cloneIterator ( ) { try { final AbsoluteIterator clone = ( AbsoluteIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . resetPosition ( ) ; clone . _isRestartable = false ; return clone ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['8', '2', '0', '3', '21', '0', '1', '3', '8', '0', '85', '1', '1', '0.65', '0.34375', '1', '5', '9.5', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class NamespaceUriCall extends NameBase { public NamespaceUriCall ( QName fname ) { super ( fname ) ; } public NamespaceUriCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNamespace = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceName" , "(I)" + STRING_SIG ) ; super . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( getNamespace , 2 ) ) ; } } 	0	['3', '5', '0', '9', '11', '3', '0', '9', '3', '2', '37', '0', '0', '0.99', '0.533333333', '3', '5', '11.33333333', '1', '0.3333', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class ContainsCall extends FunctionCall { private Expression _base = null ; private Expression _token = null ; public ContainsCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public boolean isBoolean ( ) { return true ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argumentCount ( ) != 2 ) { throw new TypeCheckError ( ErrorMsg . ILLEGAL_ARG_ERR , getName ( ) , this ) ; } _base = argument ( 0 ) ; Type baseType = _base . typeCheck ( stable ) ; if ( baseType != Type . String ) _base = new CastExpr ( _base , Type . String ) ; _token = argument ( 1 ) ; Type tokenType = _token . typeCheck ( stable ) ; if ( tokenType != Type . String ) _token = new CastExpr ( _token , Type . String ) ; return _type = Type . Boolean ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { translateDesynthesized ( classGen , methodGen ) ; synthesize ( classGen , methodGen ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _base . translate ( classGen , methodGen ) ; _token . translate ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_CLASS , "indexOf" , "(" + STRING_SIG + ")I" ) ) ) ; _falseList . add ( il . append ( new IFLT ( null ) ) ) ; } } 	0	['5', '4', '0', '18', '22', '4', '0', '18', '5', '0.25', '126', '1', '2', '0.96', '0.4', '3', '14', '23.8', '1', '0.8', '0']
package org . apache . xalan . xsltc . dom ; import java . text . Collator ; import java . util . Locale ; import org . apache . xalan . xsltc . CollatorFactory ; public class CollatorFactoryBase implements CollatorFactory { public static final Locale DEFAULT_LOCALE = Locale . getDefault ( ) ; public static final Collator DEFAULT_COLLATOR = Collator . getInstance ( ) ; public CollatorFactoryBase ( ) { } public Collator getCollator ( String lang , String country ) { return Collator . getInstance ( new Locale ( lang , country ) ) ; } public Collator getCollator ( Locale locale ) { if ( locale == DEFAULT_LOCALE ) return DEFAULT_COLLATOR ; else return Collator . getInstance ( locale ) ; } } 	0	['4', '1', '0', '2', '9', '4', '1', '1', '3', '0.666666667', '29', '0', '0', '0', '0.555555556', '0', '0', '5.75', '2', '0.75', '0']
package org . apache . xml . serializer ; import org . xml . sax . Attributes ; public interface SerializerTrace { public static final int EVENTTYPE_STARTDOCUMENT = 1 ; public static final int EVENTTYPE_ENDDOCUMENT = 2 ; public static final int EVENTTYPE_STARTELEMENT = 3 ; public static final int EVENTTYPE_ENDELEMENT = 4 ; public static final int EVENTTYPE_CHARACTERS = 5 ; public static final int EVENTTYPE_IGNORABLEWHITESPACE = 6 ; public static final int EVENTTYPE_PI = 7 ; public static final int EVENTTYPE_COMMENT = 8 ; public static final int EVENTTYPE_ENTITYREF = 9 ; public static final int EVENTTYPE_CDATA = 10 ; public static final int EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS = 11 ; public static final int EVENTTYPE_OUTPUT_CHARACTERS = 12 ; public boolean hasTraceListeners ( ) ; public void fireGenerateEvent ( int eventType ) ; public void fireGenerateEvent ( int eventType , String name , Attributes atts ) ; public void fireGenerateEvent ( int eventType , char ch [ ] , int start , int length ) ; public void fireGenerateEvent ( int eventType , String name , String data ) ; public void fireGenerateEvent ( int eventType , String data ) ; } 	0	['6', '1', '0', '4', '6', '15', '4', '0', '6', '1.2', '18', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . processor ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . xalan . templates . Constants ; import org . apache . xml . utils . QName ; public class XSLTElementDef { XSLTElementDef ( ) { } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject ) { build ( namespace , name , nameAlias , elements , attributes , contentHandler , classObject ) ; if ( ( null != namespace ) && ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) || namespace . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) || namespace . equals ( Constants . S_BUILTIN_OLD_EXTENSIONS_URL ) ) ) { schema . addAvailableElement ( new QName ( namespace , name ) ) ; if ( null != nameAlias ) schema . addAvailableElement ( new QName ( namespace , nameAlias ) ) ; } } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required ) { this . m_has_required = has_required ; build ( namespace , name , nameAlias , elements , attributes , contentHandler , classObject ) ; if ( ( null != namespace ) && ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) || namespace . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) || namespace . equals ( Constants . S_BUILTIN_OLD_EXTENSIONS_URL ) ) ) { schema . addAvailableElement ( new QName ( namespace , name ) ) ; if ( null != nameAlias ) schema . addAvailableElement ( new QName ( namespace , nameAlias ) ) ; } } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required , boolean required ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , has_required ) ; this . m_required = required ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required , boolean required , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , has_required , required ) ; this . m_order = order ; this . m_multiAllowed = multiAllowed ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required , boolean required , boolean has_order , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , has_required , required ) ; this . m_order = order ; this . m_multiAllowed = multiAllowed ; this . m_isOrdered = has_order ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_order , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , order , multiAllowed ) ; this . m_isOrdered = has_order ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject ) ; this . m_order = order ; this . m_multiAllowed = multiAllowed ; } XSLTElementDef ( Class classObject , XSLTElementProcessor contentHandler , int type ) { this . m_classObject = classObject ; this . m_type = type ; setElementProcessor ( contentHandler ) ; } void build ( String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject ) { this . m_namespace = namespace ; this . m_name = name ; this . m_nameAlias = nameAlias ; this . m_elements = elements ; this . m_attributes = attributes ; setElementProcessor ( contentHandler ) ; this . m_classObject = classObject ; if ( hasRequired ( ) && m_elements != null ) { int n = m_elements . length ; for ( int i = 0 ; i < n ; i ++ ) { XSLTElementDef def = m_elements [ i ] ; if ( def != null && def . getRequired ( ) ) { if ( m_requiredFound == null ) m_requiredFound = new Hashtable ( ) ; m_requiredFound . put ( def . getName ( ) , "xsl:" + def . getName ( ) ) ; } } } } private static boolean equalsMayBeNull ( Object obj1 , Object obj2 ) { return ( obj2 == obj1 ) || ( ( null != obj1 ) && ( null != obj2 ) && obj2 . equals ( obj1 ) ) ; } private static boolean equalsMayBeNullOrZeroLen ( String s1 , String s2 ) { int len1 = ( s1 == null ) ? 0 : s1 . length ( ) ; int len2 = ( s2 == null ) ? 0 : s2 . length ( ) ; return ( len1 != len2 ) ? false : ( len1 == 0 ) ? true : s1 . equals ( s2 ) ; } static final int T_ELEMENT = 1 , T_PCDATA = 2 , T_ANY = 3 ; private int m_type = T_ELEMENT ; int getType ( ) { return m_type ; } void setType ( int t ) { m_type = t ; } private String m_namespace ; String getNamespace ( ) { return m_namespace ; } private String m_name ; String getName ( ) { return m_name ; } private String m_nameAlias ; String getNameAlias ( ) { return m_nameAlias ; } private XSLTElementDef [ ] m_elements ; XSLTElementDef [ ] getElements ( ) { return m_elements ; } void setElements ( XSLTElementDef [ ] defs ) { m_elements = defs ; } private boolean QNameEquals ( String uri , String localName ) { return ( equalsMayBeNullOrZeroLen ( m_namespace , uri ) && ( equalsMayBeNullOrZeroLen ( m_name , localName ) || equalsMayBeNullOrZeroLen ( m_nameAlias , localName ) ) ) ; } XSLTElementProcessor getProcessorFor ( String uri , String localName ) { XSLTElementProcessor elemDef = null ; if ( null == m_elements ) return null ; int n = m_elements . length ; int order = - 1 ; boolean multiAllowed = true ; for ( int i = 0 ; i < n ; i ++ ) { XSLTElementDef def = m_elements [ i ] ; if ( def . m_name . equals ( "*" ) ) { if ( ! equalsMayBeNullOrZeroLen ( uri , Constants . S_XSLNAMESPACEURL ) ) { elemDef = def . m_elementProcessor ; order = def . getOrder ( ) ; multiAllowed = def . getMultiAllowed ( ) ; } } else if ( def . QNameEquals ( uri , localName ) ) { if ( def . getRequired ( ) ) this . setRequiredFound ( def . getName ( ) , true ) ; order = def . getOrder ( ) ; multiAllowed = def . getMultiAllowed ( ) ; elemDef = def . m_elementProcessor ; break ; } } if ( elemDef != null && this . isOrdered ( ) ) { int lastOrder = getLastOrder ( ) ; if ( order > lastOrder ) setLastOrder ( order ) ; else if ( order == lastOrder && ! multiAllowed ) { return null ; } else if ( order < lastOrder && order > 0 ) { return null ; } } return elemDef ; } XSLTElementProcessor getProcessorForUnknown ( String uri , String localName ) { if ( null == m_elements ) return null ; int n = m_elements . length ; for ( int i = 0 ; i < n ; i ++ ) { XSLTElementDef def = m_elements [ i ] ; if ( def . m_name . equals ( "unknown" ) && uri . length ( ) > 0 ) { return def . m_elementProcessor ; } } return null ; } private XSLTAttributeDef [ ] m_attributes ; XSLTAttributeDef [ ] getAttributes ( ) { return m_attributes ; } XSLTAttributeDef getAttributeDef ( String uri , String localName ) { XSLTAttributeDef defaultDef = null ; XSLTAttributeDef [ ] attrDefs = getAttributes ( ) ; int nAttrDefs = attrDefs . length ; for ( int k = 0 ; k < nAttrDefs ; k ++ ) { XSLTAttributeDef attrDef = attrDefs [ k ] ; String uriDef = attrDef . getNamespace ( ) ; String nameDef = attrDef . getName ( ) ; if ( nameDef . equals ( "*" ) && ( equalsMayBeNullOrZeroLen ( uri , uriDef ) || ( uriDef != null && uriDef . equals ( "*" ) && uri != null && uri . length ( ) > 0 ) ) ) { return attrDef ; } else if ( nameDef . equals ( "*" ) && ( uriDef == null ) ) { defaultDef = attrDef ; } else if ( equalsMayBeNullOrZeroLen ( uri , uriDef ) && localName . equals ( nameDef ) ) { return attrDef ; } } if ( null == defaultDef ) { if ( uri . length ( ) > 0 && ! equalsMayBeNullOrZeroLen ( uri , Constants . S_XSLNAMESPACEURL ) ) { return XSLTAttributeDef . m_foreignAttr ; } } return defaultDef ; } private XSLTElementProcessor m_elementProcessor ; XSLTElementProcessor getElementProcessor ( ) { return m_elementProcessor ; } void setElementProcessor ( XSLTElementProcessor handler ) { if ( handler != null ) { m_elementProcessor = handler ; m_elementProcessor . setElemDef ( this ) ; } } private Class m_classObject ; Class getClassObject ( ) { return m_classObject ; } private boolean m_has_required = false ; boolean hasRequired ( ) { return m_has_required ; } private boolean m_required = false ; boolean getRequired ( ) { return m_required ; } Hashtable m_requiredFound ; void setRequiredFound ( String elem , boolean found ) { if ( m_requiredFound . get ( elem ) != null ) m_requiredFound . remove ( elem ) ; } boolean getRequiredFound ( ) { if ( m_requiredFound == null ) return true ; return m_requiredFound . isEmpty ( ) ; } String getRequiredElem ( ) { if ( m_requiredFound == null ) return null ; Enumeration elems = m_requiredFound . elements ( ) ; String s = "" ; boolean first = true ; while ( elems . hasMoreElements ( ) ) { if ( first ) first = false ; else s = s + ", " ; s = s + ( String ) elems . nextElement ( ) ; } return s ; } boolean m_isOrdered = false ; boolean isOrdered ( ) { return m_isOrdered ; } private int m_order = - 1 ; int getOrder ( ) { return m_order ; } private int m_lastOrder = - 1 ; int getLastOrder ( ) { return m_lastOrder ; } void setLastOrder ( int order ) { m_lastOrder = order ; } private boolean m_multiAllowed = true ; boolean getMultiAllowed ( ) { return m_multiAllowed ; } } 	0	['37', '1', '1', '8', '57', '440', '6', '4', '0', '0.793209877', '812', '0.722222222', '3', '0', '0.289189189', '0', '0', '20.45945946', '15', '2.2162', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; public abstract class Pattern extends Expression { public abstract Type typeCheck ( SymbolTable stable ) throws TypeCheckError ; public abstract void translate ( ClassGenerator classGen , MethodGenerator methodGen ) ; public abstract double getPriority ( ) ; } 	0	['4', '3', '2', '17', '5', '6', '11', '6', '4', '2', '7', '0', '0', '0.959459459', '0.4375', '2', '4', '0.75', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; final class ArgumentList { private final Expression _arg ; private final ArgumentList _rest ; public ArgumentList ( Expression arg , ArgumentList rest ) { _arg = arg ; _rest = rest ; } public String toString ( ) { return _rest == null ? _arg . toString ( ) : _arg . toString ( ) + ", " + _rest . toString ( ) ; } } 	0	['2', '1', '0', '1', '7', '0', '0', '1', '2', '0', '35', '1', '2', '0', '0.666666667', '0', '0', '15.5', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class StringCall extends FunctionCall { public StringCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int argc = argumentCount ( ) ; if ( argc > 1 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , this ) ; throw new TypeCheckError ( err ) ; } if ( argc > 0 ) { argument ( ) . typeCheck ( stable ) ; } return _type = Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; Type targ ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; targ = Type . Node ; } else { final Expression arg = argument ( ) ; arg . translate ( classGen , methodGen ) ; arg . startResetIterator ( classGen , methodGen ) ; targ = arg . getType ( ) ; } if ( ! targ . identicalTo ( Type . String ) ) { targ . translateTo ( classGen , methodGen , Type . String ) ; } } } 	0	['3', '4', '0', '13', '17', '3', '0', '13', '3', '2', '75', '0', '0', '0.979591837', '0.444444444', '3', '13', '24', '3', '1.3333', '0']
package org . apache . xalan . extensions ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XString ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class MethodResolver { public static final int STATIC_ONLY = 1 ; public static final int INSTANCE_ONLY = 2 ; public static final int STATIC_AND_INSTANCE = 3 ; public static final int DYNAMIC = 4 ; public static Constructor getConstructor ( Class classObj , Object [ ] argsIn , Object [ ] [ ] argsOut , ExpressionContext exprContext ) throws NoSuchMethodException , SecurityException , TransformerException { Constructor bestConstructor = null ; Class [ ] bestParamTypes = null ; Constructor [ ] constructors = classObj . getConstructors ( ) ; int nMethods = constructors . length ; int bestScore = Integer . MAX_VALUE ; int bestScoreCount = 0 ; for ( int i = 0 ; i < nMethods ; i ++ ) { Constructor ctor = constructors [ i ] ; Class [ ] paramTypes = ctor . getParameterTypes ( ) ; int numberMethodParams = paramTypes . length ; int paramStart = 0 ; boolean isFirstExpressionContext = false ; int scoreStart ; if ( numberMethodParams == ( argsIn . length + 1 ) ) { Class javaClass = paramTypes [ 0 ] ; if ( ExpressionContext . class . isAssignableFrom ( javaClass ) ) { isFirstExpressionContext = true ; scoreStart = 0 ; paramStart ++ ; } else continue ; } else scoreStart = 1000 ; if ( argsIn . length == ( numberMethodParams - paramStart ) ) { int score = scoreMatch ( paramTypes , paramStart , argsIn , scoreStart ) ; if ( - 1 == score ) continue ; if ( score < bestScore ) { bestConstructor = ctor ; bestParamTypes = paramTypes ; bestScore = score ; bestScoreCount = 1 ; } else if ( score == bestScore ) bestScoreCount ++ ; } } if ( null == bestConstructor ) { throw new NoSuchMethodException ( errString ( "function" , "constructor" , classObj , "" , 0 , argsIn ) ) ; } else convertParams ( argsIn , argsOut , bestParamTypes , exprContext ) ; return bestConstructor ; } public static Method getMethod ( Class classObj , String name , Object [ ] argsIn , Object [ ] [ ] argsOut , ExpressionContext exprContext , int searchMethod ) throws NoSuchMethodException , SecurityException , TransformerException { if ( name . indexOf ( "-" ) > 0 ) name = replaceDash ( name ) ; Method bestMethod = null ; Class [ ] bestParamTypes = null ; Method [ ] methods = classObj . getMethods ( ) ; int nMethods = methods . length ; int bestScore = Integer . MAX_VALUE ; int bestScoreCount = 0 ; boolean isStatic ; for ( int i = 0 ; i < nMethods ; i ++ ) { Method method = methods [ i ] ; int xsltParamStart = 0 ; if ( method . getName ( ) . equals ( name ) ) { isStatic = Modifier . isStatic ( method . getModifiers ( ) ) ; switch ( searchMethod ) { case STATIC_ONLY : if ( ! isStatic ) { continue ; } break ; case INSTANCE_ONLY : if ( isStatic ) { continue ; } break ; case STATIC_AND_INSTANCE : break ; case DYNAMIC : if ( ! isStatic ) xsltParamStart = 1 ; } int javaParamStart = 0 ; Class [ ] paramTypes = method . getParameterTypes ( ) ; int numberMethodParams = paramTypes . length ; boolean isFirstExpressionContext = false ; int scoreStart ; int argsLen = ( null != argsIn ) ? argsIn . length : 0 ; if ( numberMethodParams == ( argsLen - xsltParamStart + 1 ) ) { Class javaClass = paramTypes [ 0 ] ; if ( ExpressionContext . class . isAssignableFrom ( javaClass ) ) { isFirstExpressionContext = true ; scoreStart = 0 ; javaParamStart ++ ; } else { continue ; } } else scoreStart = 1000 ; if ( ( argsLen - xsltParamStart ) == ( numberMethodParams - javaParamStart ) ) { int score = scoreMatch ( paramTypes , javaParamStart , argsIn , scoreStart ) ; if ( - 1 == score ) continue ; if ( score < bestScore ) { bestMethod = method ; bestParamTypes = paramTypes ; bestScore = score ; bestScoreCount = 1 ; } else if ( score == bestScore ) bestScoreCount ++ ; } } } if ( null == bestMethod ) { throw new NoSuchMethodException ( errString ( "function" , "method" , classObj , name , searchMethod , argsIn ) ) ; } else convertParams ( argsIn , argsOut , bestParamTypes , exprContext ) ; return bestMethod ; } private static String replaceDash ( String name ) { char dash = '-' ; StringBuffer buff = new StringBuffer ( "" ) ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { if ( name . charAt ( i ) == dash ) { } else if ( i > 0 && name . charAt ( i - 1 ) == dash ) buff . append ( Character . toUpperCase ( name . charAt ( i ) ) ) ; else buff . append ( name . charAt ( i ) ) ; } return buff . toString ( ) ; } public static Method getElementMethod ( Class classObj , String name ) throws NoSuchMethodException , SecurityException , TransformerException { Method bestMethod = null ; Method [ ] methods = classObj . getMethods ( ) ; int nMethods = methods . length ; int bestScoreCount = 0 ; for ( int i = 0 ; i < nMethods ; i ++ ) { Method method = methods [ i ] ; if ( method . getName ( ) . equals ( name ) ) { Class [ ] paramTypes = method . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) ) { if ( ++ bestScoreCount == 1 ) bestMethod = method ; else break ; } } } if ( null == bestMethod ) { throw new NoSuchMethodException ( errString ( "element" , "method" , classObj , name , 0 , null ) ) ; } else if ( bestScoreCount > 1 ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_MORE_MATCH_ELEMENT , new Object [ ] { name } ) ) ; return bestMethod ; } public static void convertParams ( Object [ ] argsIn , Object [ ] [ ] argsOut , Class [ ] paramTypes , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { if ( paramTypes == null ) argsOut [ 0 ] = null ; else { int nParams = paramTypes . length ; argsOut [ 0 ] = new Object [ nParams ] ; int paramIndex = 0 ; if ( ( nParams > 0 ) && ExpressionContext . class . isAssignableFrom ( paramTypes [ 0 ] ) ) { argsOut [ 0 ] [ 0 ] = exprContext ; paramIndex ++ ; } if ( argsIn != null ) { for ( int i = argsIn . length - nParams + paramIndex ; paramIndex < nParams ; i ++ , paramIndex ++ ) { argsOut [ 0 ] [ paramIndex ] = convert ( argsIn [ i ] , paramTypes [ paramIndex ] ) ; } } } } static class ConversionInfo { ConversionInfo ( Class cl , int score ) { m_class = cl ; m_score = score ; } Class m_class ; int m_score ; } private static final int SCOREBASE = 1 ; static ConversionInfo [ ] m_javaObjConversions = { new ConversionInfo ( Double . TYPE , 11 ) , new ConversionInfo ( Float . TYPE , 12 ) , new ConversionInfo ( Long . TYPE , 13 ) , new ConversionInfo ( Integer . TYPE , 14 ) , new ConversionInfo ( Short . TYPE , 15 ) , new ConversionInfo ( Character . TYPE , 16 ) , new ConversionInfo ( Byte . TYPE , 17 ) , new ConversionInfo ( java . lang . String . class , 18 ) } ; static ConversionInfo [ ] m_booleanConversions = { new ConversionInfo ( Boolean . TYPE , 0 ) , new ConversionInfo ( java . lang . Boolean . class , 1 ) , new ConversionInfo ( java . lang . Object . class , 2 ) , new ConversionInfo ( java . lang . String . class , 3 ) } ; static ConversionInfo [ ] m_numberConversions = { new ConversionInfo ( Double . TYPE , 0 ) , new ConversionInfo ( java . lang . Double . class , 1 ) , new ConversionInfo ( Float . TYPE , 3 ) , new ConversionInfo ( Long . TYPE , 4 ) , new ConversionInfo ( Integer . TYPE , 5 ) , new ConversionInfo ( Short . TYPE , 6 ) , new ConversionInfo ( Character . TYPE , 7 ) , new ConversionInfo ( Byte . TYPE , 8 ) , new ConversionInfo ( Boolean . TYPE , 9 ) , new ConversionInfo ( java . lang . String . class , 10 ) , new ConversionInfo ( java . lang . Object . class , 11 ) } ; static ConversionInfo [ ] m_stringConversions = { new ConversionInfo ( java . lang . String . class , 0 ) , new ConversionInfo ( java . lang . Object . class , 1 ) , new ConversionInfo ( Character . TYPE , 2 ) , new ConversionInfo ( Double . TYPE , 3 ) , new ConversionInfo ( Float . TYPE , 3 ) , new ConversionInfo ( Long . TYPE , 3 ) , new ConversionInfo ( Integer . TYPE , 3 ) , new ConversionInfo ( Short . TYPE , 3 ) , new ConversionInfo ( Byte . TYPE , 3 ) , new ConversionInfo ( Boolean . TYPE , 4 ) } ; static ConversionInfo [ ] m_rtfConversions = { new ConversionInfo ( org . w3c . dom . traversal . NodeIterator . class , 0 ) , new ConversionInfo ( org . w3c . dom . NodeList . class , 1 ) , new ConversionInfo ( org . w3c . dom . Node . class , 2 ) , new ConversionInfo ( java . lang . String . class , 3 ) , new ConversionInfo ( java . lang . Object . class , 5 ) , new ConversionInfo ( Character . TYPE , 6 ) , new ConversionInfo ( Double . TYPE , 7 ) , new ConversionInfo ( Float . TYPE , 7 ) , new ConversionInfo ( Long . TYPE , 7 ) , new ConversionInfo ( Integer . TYPE , 7 ) , new ConversionInfo ( Short . TYPE , 7 ) , new ConversionInfo ( Byte . TYPE , 7 ) , new ConversionInfo ( Boolean . TYPE , 8 ) } ; static ConversionInfo [ ] m_nodesetConversions = { new ConversionInfo ( org . w3c . dom . traversal . NodeIterator . class , 0 ) , new ConversionInfo ( org . w3c . dom . NodeList . class , 1 ) , new ConversionInfo ( org . w3c . dom . Node . class , 2 ) , new ConversionInfo ( java . lang . String . class , 3 ) , new ConversionInfo ( java . lang . Object . class , 5 ) , new ConversionInfo ( Character . TYPE , 6 ) , new ConversionInfo ( Double . TYPE , 7 ) , new ConversionInfo ( Float . TYPE , 7 ) , new ConversionInfo ( Long . TYPE , 7 ) , new ConversionInfo ( Integer . TYPE , 7 ) , new ConversionInfo ( Short . TYPE , 7 ) , new ConversionInfo ( Byte . TYPE , 7 ) , new ConversionInfo ( Boolean . TYPE , 8 ) } ; static ConversionInfo [ ] [ ] m_conversions = { m_javaObjConversions , m_booleanConversions , m_numberConversions , m_stringConversions , m_nodesetConversions , m_rtfConversions } ; public static int scoreMatch ( Class [ ] javaParamTypes , int javaParamsStart , Object [ ] xsltArgs , int score ) { if ( ( xsltArgs == null ) || ( javaParamTypes == null ) ) return score ; int nParams = xsltArgs . length ; for ( int i = nParams - javaParamTypes . length + javaParamsStart , javaParamTypesIndex = javaParamsStart ; i < nParams ; i ++ , javaParamTypesIndex ++ ) { Object xsltObj = xsltArgs [ i ] ; int xsltClassType = ( xsltObj instanceof XObject ) ? ( ( XObject ) xsltObj ) . getType ( ) : XObject . CLASS_UNKNOWN ; Class javaClass = javaParamTypes [ javaParamTypesIndex ] ; if ( xsltClassType == XObject . CLASS_NULL ) { if ( ! javaClass . isPrimitive ( ) ) { score += 10 ; continue ; } else return - 1 ; } ConversionInfo [ ] convInfo = m_conversions [ xsltClassType ] ; int nConversions = convInfo . length ; int k ; for ( k = 0 ; k < nConversions ; k ++ ) { ConversionInfo cinfo = convInfo [ k ] ; if ( javaClass . isAssignableFrom ( cinfo . m_class ) ) { score += cinfo . m_score ; break ; } } if ( k == nConversions ) { if ( XObject . CLASS_UNKNOWN == xsltClassType ) { Class realClass = null ; if ( xsltObj instanceof XObject ) { Object realObj = ( ( XObject ) xsltObj ) . object ( ) ; if ( null != realObj ) { realClass = realObj . getClass ( ) ; } else { score += 10 ; continue ; } } else { realClass = xsltObj . getClass ( ) ; } if ( javaClass . isAssignableFrom ( realClass ) ) { score += 0 ; } else return - 1 ; } else return - 1 ; } } return score ; } static Object convert ( Object xsltObj , Class javaClass ) throws javax . xml . transform . TransformerException { if ( xsltObj instanceof XObject ) { XObject xobj = ( ( XObject ) xsltObj ) ; int xsltClassType = xobj . getType ( ) ; switch ( xsltClassType ) { case XObject . CLASS_NULL : return null ; case XObject . CLASS_BOOLEAN : { if ( javaClass == java . lang . String . class ) return xobj . str ( ) ; else return new Boolean ( xobj . bool ( ) ) ; } case XObject . CLASS_NUMBER : { if ( javaClass == java . lang . String . class ) return xobj . str ( ) ; else if ( javaClass == Boolean . TYPE ) return new Boolean ( xobj . bool ( ) ) ; else { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } } case XObject . CLASS_STRING : { if ( ( javaClass == java . lang . String . class ) || ( javaClass == java . lang . Object . class ) ) return xobj . str ( ) ; else if ( javaClass == Character . TYPE ) { String str = xobj . str ( ) ; if ( str . length ( ) > 0 ) return new Character ( str . charAt ( 0 ) ) ; else return null ; } else if ( javaClass == Boolean . TYPE ) return new Boolean ( xobj . bool ( ) ) ; else { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } } case XObject . CLASS_RTREEFRAG : { if ( ( javaClass == NodeIterator . class ) || ( javaClass == java . lang . Object . class ) ) { DTMIterator dtmIter = ( ( XRTreeFrag ) xobj ) . asNodeIterator ( ) ; return new DTMNodeIterator ( dtmIter ) ; } else if ( javaClass == NodeList . class ) { return ( ( XRTreeFrag ) xobj ) . convertToNodeset ( ) ; } else if ( javaClass == Node . class ) { DTMIterator iter = ( ( XRTreeFrag ) xobj ) . asNodeIterator ( ) ; int rootHandle = iter . nextNode ( ) ; DTM dtm = iter . getDTM ( rootHandle ) ; return dtm . getNode ( dtm . getFirstChild ( rootHandle ) ) ; } else if ( javaClass == java . lang . String . class ) { return xobj . str ( ) ; } else if ( javaClass == Boolean . TYPE ) { return new Boolean ( xobj . bool ( ) ) ; } else if ( javaClass . isPrimitive ( ) ) { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } else { DTMIterator iter = ( ( XRTreeFrag ) xobj ) . asNodeIterator ( ) ; int rootHandle = iter . nextNode ( ) ; DTM dtm = iter . getDTM ( rootHandle ) ; Node child = dtm . getNode ( dtm . getFirstChild ( rootHandle ) ) ; if ( javaClass . isAssignableFrom ( child . getClass ( ) ) ) return child ; else return null ; } } case XObject . CLASS_NODESET : { if ( ( javaClass == NodeIterator . class ) || ( javaClass == java . lang . Object . class ) ) { return xobj . nodeset ( ) ; } else if ( javaClass == NodeList . class ) { return xobj . nodelist ( ) ; } else if ( javaClass == Node . class ) { DTMIterator ni = xobj . iter ( ) ; int handle = ni . nextNode ( ) ; if ( handle != DTM . NULL ) return ni . getDTM ( handle ) . getNode ( handle ) ; else return null ; } else if ( javaClass == java . lang . String . class ) { return xobj . str ( ) ; } else if ( javaClass == Boolean . TYPE ) { return new Boolean ( xobj . bool ( ) ) ; } else if ( javaClass . isPrimitive ( ) ) { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } else { DTMIterator iter = xobj . iter ( ) ; int childHandle = iter . nextNode ( ) ; DTM dtm = iter . getDTM ( childHandle ) ; Node child = dtm . getNode ( childHandle ) ; if ( javaClass . isAssignableFrom ( child . getClass ( ) ) ) return child ; else return null ; } } } xsltObj = xobj . object ( ) ; } if ( null != xsltObj ) { if ( javaClass == java . lang . String . class ) { return xsltObj . toString ( ) ; } else if ( javaClass . isPrimitive ( ) ) { XString xstr = new XString ( xsltObj . toString ( ) ) ; double num = xstr . num ( ) ; return convertDoubleToNumber ( num , javaClass ) ; } else if ( javaClass == java . lang . Class . class ) { return xsltObj . getClass ( ) ; } else { return xsltObj ; } } else { return xsltObj ; } } static Object convertDoubleToNumber ( double num , Class javaClass ) { if ( ( javaClass == Double . TYPE ) || ( javaClass == java . lang . Double . class ) ) return new Double ( num ) ; else if ( javaClass == Float . TYPE ) return new Float ( num ) ; else if ( javaClass == Long . TYPE ) { return new Long ( ( long ) num ) ; } else if ( javaClass == Integer . TYPE ) { return new Integer ( ( int ) num ) ; } else if ( javaClass == Short . TYPE ) { return new Short ( ( short ) num ) ; } else if ( javaClass == Character . TYPE ) { return new Character ( ( char ) num ) ; } else if ( javaClass == Byte . TYPE ) { return new Byte ( ( byte ) num ) ; } else { return new Double ( num ) ; } } private static String errString ( String callType , String searchType , Class classObj , String funcName , int searchMethod , Object [ ] xsltArgs ) { String resultString = "For extension " + callType + ", could not find " + searchType + " " ; switch ( searchMethod ) { case STATIC_ONLY : return resultString + "static " + classObj . getName ( ) + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ")." ; case INSTANCE_ONLY : return resultString + classObj . getName ( ) + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ")." ; case STATIC_AND_INSTANCE : return resultString + classObj . getName ( ) + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ").\n" + "Checked both static and instance methods." ; case DYNAMIC : return resultString + "static " + classObj . getName ( ) + "." + funcName + "([ExpressionContext, ]" + errArgs ( xsltArgs , 0 ) + ") nor\n" + classObj + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 1 ) + ")." ; default : if ( callType . equals ( "function" ) ) { return resultString + classObj . getName ( ) + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ")." ; } else { return resultString + classObj . getName ( ) + "." + funcName + "(org.apache.xalan.extensions.XSLProcessorContext, " + "org.apache.xalan.templates.ElemExtensionCall)." ; } } } private static String errArgs ( Object [ ] xsltArgs , int startingArg ) { StringBuffer returnArgs = new StringBuffer ( ) ; for ( int i = startingArg ; i < xsltArgs . length ; i ++ ) { if ( i != startingArg ) returnArgs . append ( ", " ) ; if ( xsltArgs [ i ] instanceof XObject ) returnArgs . append ( ( ( XObject ) xsltArgs [ i ] ) . getTypeString ( ) ) ; else returnArgs . append ( xsltArgs [ i ] . getClass ( ) . getName ( ) ) ; } return returnArgs . toString ( ) ; } } 	0	['13', '1', '0', '11', '70', '66', '2', '9', '6', '0.952898551', '2002', '0.043478261', '7', '0', '0.266666667', '0', '0', '151.2307692', '14', '3.2308', '0']
package org . apache . xalan . xsltc . runtime ; public class Node { public int node ; public int type ; public Node ( int n , int t ) { node = n ; type = t ; } } 	0	['1', '1', '0', '1', '2', '0', '1', '0', '1', '2', '12', '0', '0', '0', '1', '0', '0', '9', '0', '0', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class NodeSortRecordFactGenerator extends ClassGenerator { public NodeSortRecordFactGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; } public boolean isExternal ( ) { return true ; } } 	0	['2', '4', '0', '3', '3', '1', '1', '2', '2', '2', '13', '0', '0', '0.987804878', '0.6', '0', '0', '5.5', '1', '0.5', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . w3c . dom . Node ; public class DTMNodeList extends DTMNodeListBase { private DTMIterator m_iter ; private DTMNodeList ( ) { } public DTMNodeList ( DTMIterator dtmIterator ) { if ( dtmIterator != null ) { int pos = dtmIterator . getCurrentPos ( ) ; try { m_iter = ( DTMIterator ) dtmIterator . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { m_iter = dtmIterator ; } m_iter . setShouldCacheNodes ( true ) ; m_iter . runTo ( - 1 ) ; m_iter . setCurrentPos ( pos ) ; } } public DTMIterator getDTMIterator ( ) { return m_iter ; } public Node item ( int index ) { if ( m_iter != null ) { int handle = m_iter . item ( index ) ; if ( handle == DTM . NULL ) { return null ; } return m_iter . getDTM ( handle ) . getNode ( handle ) ; } else { return null ; } } public int getLength ( ) { return ( m_iter != null ) ? m_iter . getLength ( ) : 0 ; } } 	0	['5', '2', '0', '8', '15', '0', '5', '3', '4', '0.25', '72', '1', '1', '0.4', '0.466666667', '0', '0', '13.2', '3', '1.2', '0']
package org . apache . xml . utils ; import java . util . EmptyStackException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; public class NamespaceSupport2 extends org . xml . sax . helpers . NamespaceSupport { private Context2 currentContext ; public final static String XMLNS = "http://www.w3.org/XML/1998/namespace" ; public NamespaceSupport2 ( ) { reset ( ) ; } public void reset ( ) { currentContext = new Context2 ( null ) ; currentContext . declarePrefix ( "xml" , XMLNS ) ; } public void pushContext ( ) { Context2 parentContext = currentContext ; currentContext = parentContext . getChild ( ) ; if ( currentContext == null ) { currentContext = new Context2 ( parentContext ) ; } else { currentContext . setParent ( parentContext ) ; } } public void popContext ( ) { Context2 parentContext = currentContext . getParent ( ) ; if ( parentContext == null ) throw new EmptyStackException ( ) ; else currentContext = parentContext ; } public boolean declarePrefix ( String prefix , String uri ) { if ( prefix . equals ( "xml" ) || prefix . equals ( "xmlns" ) ) { return false ; } else { currentContext . declarePrefix ( prefix , uri ) ; return true ; } } public String [ ] processName ( String qName , String [ ] parts , boolean isAttribute ) { String [ ] name = currentContext . processName ( qName , isAttribute ) ; if ( name == null ) return null ; System . arraycopy ( name , 0 , parts , 0 , 3 ) ; return parts ; } public String getURI ( String prefix ) { return currentContext . getURI ( prefix ) ; } public Enumeration getPrefixes ( ) { return currentContext . getPrefixes ( ) ; } public String getPrefix ( String uri ) { return currentContext . getPrefix ( uri ) ; } public Enumeration getPrefixes ( String uri ) { return new PrefixForUriEnumerator ( this , uri , getPrefixes ( ) ) ; } public Enumeration getDeclaredPrefixes ( ) { return currentContext . getDeclaredPrefixes ( ) ; } } class PrefixForUriEnumerator implements Enumeration { private Enumeration allPrefixes ; private String uri ; private String lookahead = null ; private NamespaceSupport2 nsup ; PrefixForUriEnumerator ( NamespaceSupport2 nsup , String uri , Enumeration allPrefixes ) { this . nsup = nsup ; this . uri = uri ; this . allPrefixes = allPrefixes ; } public boolean hasMoreElements ( ) { if ( lookahead != null ) return true ; while ( allPrefixes . hasMoreElements ( ) ) { String prefix = ( String ) allPrefixes . nextElement ( ) ; if ( uri . equals ( nsup . getURI ( prefix ) ) ) { lookahead = prefix ; return true ; } } return false ; } public Object nextElement ( ) { if ( hasMoreElements ( ) ) { String tmp = lookahead ; lookahead = null ; return tmp ; } else throw new java . util . NoSuchElementException ( ) ; } } final class Context2 { private final static Enumeration EMPTY_ENUMERATION = new Vector ( ) . elements ( ) ; Hashtable prefixTable ; Hashtable uriTable ; Hashtable elementNameTable ; Hashtable attributeNameTable ; String defaultNS = null ; private Vector declarations = null ; private boolean tablesDirty = false ; private Context2 parent = null ; private Context2 child = null ; Context2 ( Context2 parent ) { if ( parent == null ) { prefixTable = new Hashtable ( ) ; uriTable = new Hashtable ( ) ; elementNameTable = null ; attributeNameTable = null ; } else setParent ( parent ) ; } Context2 getChild ( ) { return child ; } Context2 getParent ( ) { return parent ; } void setParent ( Context2 parent ) { this . parent = parent ; parent . child = this ; declarations = null ; prefixTable = parent . prefixTable ; uriTable = parent . uriTable ; elementNameTable = parent . elementNameTable ; attributeNameTable = parent . attributeNameTable ; defaultNS = parent . defaultNS ; tablesDirty = false ; } void declarePrefix ( String prefix , String uri ) { if ( ! tablesDirty ) { copyTables ( ) ; } if ( declarations == null ) { declarations = new Vector ( ) ; } prefix = prefix . intern ( ) ; uri = uri . intern ( ) ; if ( "" . equals ( prefix ) ) { if ( "" . equals ( uri ) ) { defaultNS = null ; } else { defaultNS = uri ; } } else { prefixTable . put ( prefix , uri ) ; uriTable . put ( uri , prefix ) ; } declarations . addElement ( prefix ) ; } String [ ] processName ( String qName , boolean isAttribute ) { String name [ ] ; Hashtable table ; if ( isAttribute ) { if ( elementNameTable == null ) elementNameTable = new Hashtable ( ) ; table = elementNameTable ; } else { if ( attributeNameTable == null ) attributeNameTable = new Hashtable ( ) ; table = attributeNameTable ; } name = ( String [ ] ) table . get ( qName ) ; if ( name != null ) { return name ; } name = new String [ 3 ] ; int index = qName . indexOf ( ':' ) ; if ( index == - 1 ) { if ( isAttribute || defaultNS == null ) { name [ 0 ] = "" ; } else { name [ 0 ] = defaultNS ; } name [ 1 ] = qName . intern ( ) ; name [ 2 ] = name [ 1 ] ; } else { String prefix = qName . substring ( 0 , index ) ; String local = qName . substring ( index + 1 ) ; String uri ; if ( "" . equals ( prefix ) ) { uri = defaultNS ; } else { uri = ( String ) prefixTable . get ( prefix ) ; } if ( uri == null ) { return null ; } name [ 0 ] = uri ; name [ 1 ] = local . intern ( ) ; name [ 2 ] = qName . intern ( ) ; } table . put ( name [ 2 ] , name ) ; tablesDirty = true ; return name ; } String getURI ( String prefix ) { if ( "" . equals ( prefix ) ) { return defaultNS ; } else if ( prefixTable == null ) { return null ; } else { return ( String ) prefixTable . get ( prefix ) ; } } String getPrefix ( String uri ) { if ( uriTable == null ) { return null ; } else { return ( String ) uriTable . get ( uri ) ; } } Enumeration getDeclaredPrefixes ( ) { if ( declarations == null ) { return EMPTY_ENUMERATION ; } else { return declarations . elements ( ) ; } } Enumeration getPrefixes ( ) { if ( prefixTable == null ) { return EMPTY_ENUMERATION ; } else { return prefixTable . keys ( ) ; } } private void copyTables ( ) { prefixTable = ( Hashtable ) prefixTable . clone ( ) ; uriTable = ( Hashtable ) uriTable . clone ( ) ; if ( elementNameTable != null ) elementNameTable = new Hashtable ( ) ; if ( attributeNameTable != null ) attributeNameTable = new Hashtable ( ) ; tablesDirty = true ; } } 	0	['11', '2', '0', '3', '26', '0', '2', '2', '11', '0.55', '127', '0.5', '1', '0.583333333', '0.409090909', '1', '3', '10.36363636', '3', '1.3636', '0']
package org . apache . xml . serializer ; import java . util . Vector ; public interface XSLOutputAttributes { public String getDoctypePublic ( ) ; public String getDoctypeSystem ( ) ; public String getEncoding ( ) ; public boolean getIndent ( ) ; public int getIndentAmount ( ) ; public String getMediaType ( ) ; public boolean getOmitXMLDeclaration ( ) ; public String getStandalone ( ) ; public String getVersion ( ) ; public void setCdataSectionElements ( Vector URI_and_localNames ) ; public void setDoctype ( String system , String pub ) ; public void setDoctypePublic ( String doctype ) ; public void setDoctypeSystem ( String doctype ) ; public void setEncoding ( String encoding ) ; public void setIndent ( boolean indent ) ; public void setMediaType ( String mediatype ) ; public void setOmitXMLDeclaration ( boolean b ) ; public void setStandalone ( String standalone ) ; public void setVersion ( String version ) ; } 	0	['19', '1', '0', '1', '19', '171', '1', '0', '19', '2', '19', '0', '0', '0', '0.381578947', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . processor ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xml . serializer . OutputPropertiesFactory ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . Attributes ; class ProcessorOutputElem extends XSLTElementProcessor { private OutputProperties m_outputProperties ; public void setCdataSectionElements ( java . util . Vector newValue ) { m_outputProperties . setQNameProperties ( OutputKeys . CDATA_SECTION_ELEMENTS , newValue ) ; } public void setDoctypePublic ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . DOCTYPE_PUBLIC , newValue ) ; } public void setDoctypeSystem ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . DOCTYPE_SYSTEM , newValue ) ; } public void setEncoding ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . ENCODING , newValue ) ; } public void setIndent ( boolean newValue ) { m_outputProperties . setBooleanProperty ( OutputKeys . INDENT , newValue ) ; } public void setMediaType ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . MEDIA_TYPE , newValue ) ; } public void setMethod ( org . apache . xml . utils . QName newValue ) { m_outputProperties . setQNameProperty ( OutputKeys . METHOD , newValue ) ; } public void setOmitXmlDeclaration ( boolean newValue ) { m_outputProperties . setBooleanProperty ( OutputKeys . OMIT_XML_DECLARATION , newValue ) ; } public void setStandalone ( boolean newValue ) { m_outputProperties . setBooleanProperty ( OutputKeys . STANDALONE , newValue ) ; } public void setVersion ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . VERSION , newValue ) ; } public void setForeignAttr ( String attrUri , String attrLocalName , String attrRawName , String attrValue ) { QName key = new QName ( attrUri , attrLocalName ) ; m_outputProperties . setProperty ( key , attrValue ) ; } public void addLiteralResultAttribute ( String attrUri , String attrLocalName , String attrRawName , String attrValue ) { QName key = new QName ( attrUri , attrLocalName ) ; m_outputProperties . setProperty ( key , attrValue ) ; } public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { m_outputProperties = new OutputProperties ( ) ; m_outputProperties . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; m_outputProperties . setLocaterInfo ( handler . getLocator ( ) ) ; m_outputProperties . setUid ( handler . nextUid ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , this ) ; String entitiesFileName = ( String ) m_outputProperties . getProperties ( ) . get ( OutputPropertiesFactory . S_KEY_ENTITIES ) ; if ( null != entitiesFileName ) { try { String absURL = SystemIDResolver . getAbsoluteURI ( entitiesFileName , handler . getBaseIdentifier ( ) ) ; m_outputProperties . getProperties ( ) . put ( OutputPropertiesFactory . S_KEY_ENTITIES , absURL ) ; } catch ( TransformerException te ) { handler . error ( te . getMessage ( ) , te ) ; } } handler . getStylesheet ( ) . setOutput ( m_outputProperties ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( m_outputProperties ) ; m_outputProperties = null ; } } 	0	['14', '4', '0', '9', '40', '0', '1', '8', '13', '0.076923077', '174', '1', '1', '0.941704036', '0.295918367', '2', '3', '11.35714286', '1', '0.9286', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class UnionPathExpr extends Expression { private final Expression _pathExpr ; private final Expression _rest ; private boolean _reverse = false ; private Expression [ ] _components ; public UnionPathExpr ( Expression pathExpr , Expression rest ) { _pathExpr = pathExpr ; _rest = rest ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; final Vector components = new Vector ( ) ; flatten ( components ) ; final int size = components . size ( ) ; _components = ( Expression [ ] ) components . toArray ( new Expression [ size ] ) ; for ( int i = 0 ; i < size ; i ++ ) { _components [ i ] . setParser ( parser ) ; _components [ i ] . setParent ( this ) ; if ( _components [ i ] instanceof Step ) { final Step step = ( Step ) _components [ i ] ; final int axis = step . getAxis ( ) ; final int type = step . getNodeType ( ) ; if ( ( axis == Axis . ATTRIBUTE ) || ( type == DTM . ATTRIBUTE_NODE ) ) { _components [ i ] = _components [ 0 ] ; _components [ 0 ] = step ; } if ( Axis . isReverse [ axis ] ) _reverse = true ; } } if ( getParent ( ) instanceof Expression ) _reverse = false ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int length = _components . length ; for ( int i = 0 ; i < length ; i ++ ) { if ( _components [ i ] . typeCheck ( stable ) != Type . NodeSet ) { _components [ i ] = new CastExpr ( _components [ i ] , Type . NodeSet ) ; } } return _type = Type . NodeSet ; } public String toString ( ) { return "union(" + _pathExpr + ", " + _rest + ')' ; } private void flatten ( Vector components ) { components . addElement ( _pathExpr ) ; if ( _rest != null ) { if ( _rest instanceof UnionPathExpr ) { ( ( UnionPathExpr ) _rest ) . flatten ( components ) ; } else { components . addElement ( _rest ) ; } } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( UNION_ITERATOR_CLASS , "<init>" , "(" + DOM_INTF_SIG + ")V" ) ; final int iter = cpg . addMethodref ( UNION_ITERATOR_CLASS , ADD_ITERATOR , ADD_ITERATOR_SIG ) ; il . append ( new NEW ( cpg . addClass ( UNION_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; final int length = _components . length ; for ( int i = 0 ; i < length ; i ++ ) { _components [ i ] . translate ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( iter ) ) ; } if ( _reverse ) { final int order = cpg . addInterfaceMethodref ( DOM_INTF , ORDER_ITERATOR , ORDER_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( order , 3 ) ) ; } } } 	0	['6', '3', '0', '21', '36', '0', '2', '20', '5', '0.5', '289', '1', '3', '0.934210526', '0.285714286', '2', '8', '46.5', '7', '2.5', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Attribute extends Instruction { private QName _name ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "Attribute " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { _name = parser . getQName ( getAttribute ( "name" ) ) ; parseChildren ( parser ) ; } } 	0	['3', '3', '0', '4', '14', '1', '0', '4', '2', '0.5', '37', '1', '1', '0.965517241', '0.555555556', '1', '4', '11', '1', '0.6667', '0']
package org . apache . xml . serializer ; public interface SerializerConstants { static final String CDATA_CONTINUE = "]]]]><![CDATA[>" ; static final String CDATA_DELIMITER_CLOSE = "]]>" ; static final String CDATA_DELIMITER_OPEN = "<![CDATA[" ; static final char [ ] CNTCDATA = CDATA_CONTINUE . toCharArray ( ) ; static final char [ ] BEGCDATA = CDATA_DELIMITER_OPEN . toCharArray ( ) ; static final char [ ] ENDCDATA = CDATA_DELIMITER_CLOSE . toCharArray ( ) ; static final String EMPTYSTRING = "" ; static final String ENTITY_AMP = "&amp;" ; static final String ENTITY_CRLF = "&#xA;" ; static final String ENTITY_GT = "&gt;" ; static final String ENTITY_LT = "&lt;" ; static final String ENTITY_QUOT = "&quot;" ; static final String XML_PREFIX = "xml" ; static final String XMLNS_PREFIX = "xmlns" ; static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/" ; public static final String DEFAULT_SAX_SERIALIZER = "org.apache.xml.serializer.ToXMLSAXHandler" ; } 	0	['1', '1', '0', '1', '2', '0', '1', '0', '0', '2', '27', '0', '0', '0', '0', '0', '0', '10', '0', '0', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class MatchingIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private final int _match ; public MatchingIterator ( int match , DTMAxisIterator source ) { _source = source ; _match = match ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator cloneIterator ( ) { try { final MatchingIterator clone = ( MatchingIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( node ) ; _position = 1 ; while ( ( node = _source . next ( ) ) != END && node != _match ) { _position ++ ; } } return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { return _source . next ( ) ; } public int getLast ( ) { if ( _last == - 1 ) { _last = _source . getLast ( ) ; } return _last ; } public int getPosition ( ) { return _position ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['10', '2', '0', '3', '23', '0', '0', '3', '10', '0.5', '116', '1', '1', '0.590909091', '0.35', '1', '8', '10.4', '4', '1.3', '0']
package org . apache . xalan . processor ; import java . io . IOException ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . TreeWalker ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; class ProcessorInclude extends XSLTElementProcessor { private String m_href = null ; public String getHref ( ) { return m_href ; } public void setHref ( String baseIdent ) { m_href = baseIdent ; } protected int getStylesheetType ( ) { return StylesheetHandler . STYPE_INCLUDE ; } protected String getStylesheetInclErr ( ) { return XSLTErrorResources . ER_STYLESHEET_INCLUDES_ITSELF ; } public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { setPropertiesFromAttributes ( handler , rawName , attributes , this ) ; try { String hrefUrl = SystemIDResolver . getAbsoluteURI ( getHref ( ) , handler . getBaseIdentifier ( ) ) ; if ( handler . importStackContains ( hrefUrl ) ) { throw new org . xml . sax . SAXException ( XSLMessages . createMessage ( getStylesheetInclErr ( ) , new Object [ ] { hrefUrl } ) ) ; } handler . pushImportURL ( hrefUrl ) ; int savedStylesheetType = handler . getStylesheetType ( ) ; handler . setStylesheetType ( this . getStylesheetType ( ) ) ; handler . pushNewNamespaceSupport ( ) ; try { parse ( handler , uri , localName , rawName , attributes ) ; } finally { handler . setStylesheetType ( savedStylesheetType ) ; handler . popImportURL ( ) ; handler . popNamespaceSupport ( ) ; } } catch ( TransformerException te ) { handler . error ( te . getMessage ( ) , te ) ; } } protected void parse ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { TransformerFactoryImpl processor = handler . getStylesheetProcessor ( ) ; URIResolver uriresolver = processor . getURIResolver ( ) ; try { Source source = null ; if ( null != uriresolver ) { source = uriresolver . resolve ( getHref ( ) , handler . getBaseIdentifier ( ) ) ; if ( null != source && source instanceof DOMSource ) { Node node = ( ( DOMSource ) source ) . getNode ( ) ; String systemId = source . getSystemId ( ) ; if ( systemId == null ) { systemId = SystemIDResolver . getAbsoluteURI ( getHref ( ) , handler . getBaseIdentifier ( ) ) ; } TreeWalker walker = new TreeWalker ( handler , new org . apache . xml . utils . DOM2Helper ( ) , systemId ) ; try { walker . traverse ( node ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } return ; } } if ( null == source ) { String absURL = SystemIDResolver . getAbsoluteURI ( getHref ( ) , handler . getBaseIdentifier ( ) ) ; source = new StreamSource ( absURL ) ; } XMLReader reader = null ; if ( source instanceof SAXSource ) { SAXSource saxSource = ( SAXSource ) source ; reader = saxSource . getXMLReader ( ) ; } InputSource inputSource = SAXSource . sourceToInputSource ( source ) ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; if ( null != reader ) { reader . setContentHandler ( handler ) ; handler . pushBaseIndentifier ( inputSource . getSystemId ( ) ) ; try { reader . parse ( inputSource ) ; } finally { handler . popBaseIndentifier ( ) ; } } } catch ( IOException ioe ) { handler . error ( XSLTErrorResources . ER_IOEXCEPTION , new Object [ ] { getHref ( ) } , ioe ) ; } catch ( TransformerException te ) { handler . error ( te . getMessage ( ) , te ) ; } } } 	0	['7', '4', '1', '11', '47', '15', '2', '9', '3', '0.333333333', '268', '1', '0', '0.972222222', '0.5', '1', '1', '37.14285714', '1', '0.8571', '0']
package org . apache . xalan . res ; public class XSLTErrorResources_de extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "Fehler: '{' in Ausdruck nicht zulässig" } , { ER_ILLEGAL_ATTRIBUTE , "{0} hat ein unzulässiges Attribut: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode ist Null in xsl:apply-imports!" } , { ER_CANNOT_ADD , "{0} kann {1} nicht hinzugefügt werden" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode ist Null in handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} muss ein ''name''-Attribut haben." } , { ER_TEMPLATE_NOT_FOUND , "Vorlage konnte nicht gefunden werden: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "AVT-Name in xsl:call-template konnte nicht aufgelöst werden." } , { ER_REQUIRES_ATTRIB , "{0} erfordert Attribut: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} muss ein ''test''-Attribut haben." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Ungültiger Wert des ''level''-Attributs: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction-Name kann nicht 'xml' sein" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction-Name muss ein gültiger NCName sein: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} muss ein ''match''-Attribut haben, falls ein Modus angegeben ist." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} erfordert entweder ein ''name''- oder ein ''match''-Attribut." } , { ER_CANT_RESOLVE_NSPREFIX , "Namensraum-Präfix kann nicht aufgelöst werden: {0}" } , { ER_ILLEGAL_VALUE , "xml:space hat unzulässigen Wert: {0}" } , { ER_NO_OWNERDOC , "Tochterknoten hat kein Eigentümer-Dokument!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement-Fehler: {0}" } , { ER_NULL_CHILD , "Versuch, einen Null-Tochterknoten hinzuzufügen!" } , { ER_NEED_SELECT_ATTRIB , "{0} erfordert ein ''select''-Attribut." } , { ER_NEED_TEST_ATTRIB , "xsl:when muss ein 'test'-Attribut haben." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param muss ein 'name'-Attribut haben." } , { ER_NO_CONTEXT_OWNERDOC , "Kontext hat kein Eigentümer-Dokument!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "XML TransformerFactory Liaison konnte nicht erstellt werden: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Prozess fehlgeschlagen." } , { ER_NOT_SUCCESSFUL , "Xalan: fehlgeschlagen." } , { ER_ENCODING_NOT_SUPPORTED , "Codierung nicht unterstützt: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "TraceListener konnte nicht erstellt werden: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key erfordert ein 'name'-Attribut!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key erfordert ein 'match'-Attribut!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key erfordert ein 'use'-Attribut!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} erfordert ein ''elements''-Attribut!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} ''prefix''-Attribut fehlt" } , { ER_BAD_STYLESHEET_URL , "Stylesheet-URL ungültig: {0}" } , { ER_FILE_NOT_FOUND , "Stylesheet-Datei nicht gefunden: {0}" } , { ER_IOEXCEPTION , "IO-Ausnahme bei Stylesheet-Datei: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) ''href''-Attribut für {0} nicht gefunden" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} schließt sich selbst direkt oder indirekt ein!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude-Fehler, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} ''lang''-Attribut fehlt" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) Element {0} an falscher Position?? Containerelement ''component'' fehlt" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Ausgabe nur möglich in Element, DocumentFragment, Document oder PrintWriter." } , { ER_PROCESS_ERROR , "StylesheetRoot.process-Fehler" } , { ER_UNIMPLNODE_ERROR , "UnImplNode-Fehler: {0}" } , { ER_NO_SELECT_EXPRESSION , "Fehler! 'select'-Ausdruck bei xpath nicht gefunden (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Ein XSLProcessor kann nicht serialisiert werden!" } , { ER_NO_INPUT_STYLESHEET , "Stylesheet-Eingabe nicht angegeben!" } , { ER_FAILED_PROCESS_STYLESHEET , "Stylesheet konnte nicht verarbeitet werden!" } , { ER_COULDNT_PARSE_DOC , "Dokument {0} konnte nicht geparst werden!" } , { ER_COULDNT_FIND_FRAGMENT , "Fragment nicht gefunden: {0}" } , { ER_NODE_NOT_ELEMENT , "Knoten, auf den von einem Fragmentbezeichner gezeigt wird, war kein Element: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each muss ein 'match'- oder 'name'-Attribut haben" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "Vorlagen müssen ein 'match'- oder 'name'-Attribut haben" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Kein Klone eines Dokument-Fragments!" } , { ER_CANT_CREATE_ITEM , "Element im Ergebnisbaum kann nicht erstellt werden: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space in der Quell-XML hat einen ungültigen Wert: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Keine xsl:key-Vereinbarung für {0} vorhanden!" } , { ER_CANT_CREATE_URL , "Fehler! URL kann nicht erstellt werden für: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions nicht unterstützt" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory-Fehler" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} in einem Stylesheet nicht zulässig!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns nicht mehr unterstützt! Verwenden Sie statt dessen xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space nicht mehr unterstützt! Verwenden Sie statt dessen xsl:strip-space oder xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result nicht mehr unterstützt! Verwenden Sie statt dessen xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} hat ein ungültiges Attribut: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Ungekanntes XSL-Element: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort kann nur mit xsl:apply-templates oder xsl:for-each verwendet werden." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when an falscher Position!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when ohne übergeordnetes xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise an falscher Position!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise ohne übergeordnetes xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} in einer Vorlage nicht zulässig!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) Namensraum-Präfix {1} der Dateierweiterung {0} unbekannt" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Importe nur als erste Elemente im Stylesheet möglich!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} schließt sich selbst direkt oder indirekt ein!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space hat ungültigen Wert: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet fehlgeschlagen!" } , { ER_SAX_EXCEPTION , "SAX-Ausnahme" } , { ER_XSLT_ERROR , "XSLT-Fehler" } , { ER_CURRENCY_SIGN_ILLEGAL , "Währungszeichen in Formatierungsmuster nicht zulässig" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "document-Funktion in Stylesheet-DOM nicht unterstützt!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Präfix von Nicht-Präfix-Resolver kann nicht aufgelöst werden!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect-Erweiterung: Dateiname konnte nicht ermittelt werden - 'file'- oder 'select'-Attribut muss gültige Zeichenkette zurückgeben." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "FormatterListener kann in Redirect-Erweiterung nicht aufgebaut werden!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Präfix in exclude-result-prefixes ist ungültig: {0}" } , { ER_MISSING_NS_URI , "Namensraum-URI für angegebenes Präfix fehlt" } , { ER_MISSING_ARG_FOR_OPTION , "Argument für Option fehlt: {0}" } , { ER_INVALID_OPTION , "Ungültige Option: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Ungültige Formatierungszeichenkette: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet erfordert ein 'version'-Attribut!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Attribut: {0} hat einen ungültigen Wert: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose erfordert xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports nicht zulässig in xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Objekt der Klasse DTMLiaison kann für einen Ausgabe-DOM-Knoten nicht verwendet werden... Übergeben Sie statt dessen ein Objekt der Klasse org.apache.xpath.DOM2Helper!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Objekt der Klasse DTMLiaison kann für einen Eingabe-DOM-Knoten nicht verwendet werden... Übergeben Sie statt dessen ein Objekt der Klasse org.apache.xpath.DOM2Helper!" } , { ER_CALL_TO_EXT_FAILED , "Aufruf des Erweiterungselements fehlgeschlagen: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Präfix muss sich in einen Namensraum auflösen: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Ungültiges UTF-16-Surrogat erkannt: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} verwendet sich selbst, was zu einer Endlosschleife führt." } , { ER_CANNOT_MIX_XERCESDOM , "Eingabe, die nicht Xerces-DOM entspricht, kann nicht mit Xerces-DOM-Ausgabe gemischt werden!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "In ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Mehr als eine Vorlage gefunden, Name: {0}" } , { ER_INVALID_KEY_CALL , "Ungültiger Funktionsaufruf: Aufrufe mit rekursivem Schlüssel () nicht zulässig" } , { ER_REFERENCING_ITSELF , "Variable {0} bezieht sich direkt oder indirekt auf sich selbst!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Der Eingabeknoten darf für ein DOMSource für newTemplates nicht Null sein!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Klassendatei nicht gefunden für Option {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Erforderliches Element nicht gefunden: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream kann nicht Null sein" } , { ER_URI_CANNOT_BE_NULL , "URI kann nicht Null sein" } , { ER_FILE_CANNOT_BE_NULL , "Datei kann nicht Null sein" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource kann nicht Null sein" } , { ER_CANNOT_INIT_BSFMGR , "BSF Manager konnte nicht initialisiert werden" } , { ER_CANNOT_CMPL_EXTENSN , "Erweiterung kann nicht kompiliert werden" } , { ER_CANNOT_CREATE_EXTENSN , "Erweiterung kann nicht erstellt werde: {0} Grund: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Instanzenmethoden-Aufruf von Methode {0} erfordert eine Object-Instanz als erstes Argument" } , { ER_INVALID_ELEMENT_NAME , "Ungültiger Elementname angegeben {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Elementnamen-Methode muss statisch sein {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Erweiterungsfunktion {0} : {1} ist unbekannt" } , { ER_MORE_MATCH_CONSTRUCTOR , "Mehr als ein Best-Match für Konstruktor für {0}" } , { ER_MORE_MATCH_METHOD , "Mehr als ein Best-Match für Methode {0}" } , { ER_MORE_MATCH_ELEMENT , "Mehr als ein Best-Match für Elementmethode {0}" } , { ER_INVALID_CONTEXT_PASSED , "Ungültiger Kontext zur Auswertung von {0} übergeben" } , { ER_POOL_EXISTS , "Pool besteht bereits" } , { ER_NO_DRIVER_NAME , "Kein Treibername angegeben" } , { ER_NO_URL , "Kein URL angegeben" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Pool-Größe kleiner als Eins!" } , { ER_INVALID_DRIVER , "Ungültiger Treibername angegeben!" } , { ER_NO_STYLESHEETROOT , "Stylesheet-Stamm nicht gefunden!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Ungültiger Wert für xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode fehlgeschlagen" } , { ER_RESOURCE_COULD_NOT_LOAD , "Die Ressource [ {0} ] konnte nicht laden: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Puffergröße <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Unbekannter Fehler beim Aufruf der Erweiterung" } , { ER_NO_NAMESPACE_DECL , "Präfix {0} hat keine entsprechende Namensraum-Vereinbarung" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Elementinhalt nicht zulässig für lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Stylesheet führte zu Beendigung" } , { ER_ONE_OR_TWO , "1 oder 2" } , { ER_TWO_OR_THREE , "2 oder 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "{0} konnte nicht geladen werden (überprüfen Sie CLASSPATH); jetzt werden die Standardwerte verwendet" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Standardvorlagen können nicht initialisiert werden" } , { ER_RESULT_NULL , "Ergebnis sollte nicht Null sein" } , { ER_RESULT_COULD_NOT_BE_SET , "Ergebnis konnte nicht festgelegt werden" } , { ER_NO_OUTPUT_SPECIFIED , "Keine Ausgabe festgelegt" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Transformation in ein Ergebnis vom Typ {0} nicht möglich" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Transformation einer Quelle vom Typ {0} nicht möglich" } , { ER_NULL_CONTENT_HANDLER , "Kein Content-Handler" } , { ER_NULL_ERROR_HANDLER , "Kein Error-Handler" } , { ER_CANNOT_CALL_PARSE , "parse kann nicht aufgerufen werden, wenn der ContentHandler nicht festgelegt wurde" } , { ER_NO_PARENT_FOR_FILTER , "Kein übergeordneter Knoten für Filter" } , { ER_NO_STYLESHEET_IN_MEDIA , "Kein Stylesheet gefunden in: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "Kein xml-Stylesheet PI gefunden in: {0}" } , { ER_NOT_SUPPORTED , "Nicht unterstützt: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Wert für Eigenschaft {0} sollte eine Boolesche Instanz sein" } , { "ER_SRC_ATTRIB_NOT_SUPPORTED" , "''src''-Attribut für {0} noch nicht unterstützt" } , { ER_RESOURCE_COULD_NOT_FIND , "Die Ressource [ {0} ] wurde nicht gefunden.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Ausgabe-Eigenschaft nicht erkannt: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Erstellen von ElemLiteralResult-Instanz fehlgeschlagen" } , { ER_VALUE_SHOULD_BE_NUMBER , "Der Wert für {0} muss eine Nummer darstellen, die geparst werden kann." } , { ER_VALUE_SHOULD_EQUAL , " Wert für {0} sollte Ja oder Nein sein" } , { ER_FAILED_CALLING_METHOD , " Aufruf der Methode {0} fehlgeschlagen" } , { ER_FAILED_CREATING_ELEMTMPL , "Erstellen von ElemTemplateElement-Instanz fehlgeschlagen" } , { ER_CHARS_NOT_ALLOWED , "Zeichen an dieser Stelle im Dokument nicht erlaubt" } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" Attribut ist nicht erlaubt für Element {1}!" } , { ER_BAD_VALUE , "{0} ungültiger Wert {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} Attributwert nicht gefunden" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} Attributwert nicht erkannt " } , { ER_NULL_URI_NAMESPACE , "Es wurde versucht, einen Namensraum-Präfix ohne URI zu erzeugen." } , { ER_NUMBER_TOO_BIG , "Es wurde versucht, eine Zahl größer als die größte lange Ganzzahl zu formatieren." } , { ER_CANNOT_FIND_SAX1_DRIVER , "Die SAX1-Treiberklasse {0} kann nicht gefunden werden." } , { ER_SAX1_DRIVER_NOT_LOADED , "Die SAX1-Treiberklasse {0} wurde gefunden, kann aber nicht geladen werden." } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "Die SAX1-Treiberklasse {0} wurde geladen, es kann aber keine Instanz gebildet werden." } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "Die SAX1-Treiberklasse {0} implementiert org.xml.sax.Parser nicht." } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Die Systemeigenschaft org.xml.sax.parser wurde nicht angegeben." } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Das Parserargument darf nicht Null sein." } , { ER_FEATURE , "Merkmal: {0}" } , { ER_PROPERTY , "Eigenschaft: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Entity-Resolver Null" } , { ER_NULL_DTD_HANDLER , "DTD-Handler Null" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Kein Treibername angegeben!" } , { ER_NO_URL_SPECIFIED , "Kein URL angegeben!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Pool-Größe ist kleiner als 1!" } , { ER_INVALID_DRIVER_NAME , "Ungültiger Treibername angegeben!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programmierfehler! Ausdruck weist kein übergeordnetes Element ElemTemplateElement auf!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Programmierannahme in RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} ist an dieser Stelle im Stylesheet nicht zulässig!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "An dieser Stelle im Stylesheet ist nur Leerraum zulässig!" } , { INVALID_TCHAR , "Ungültiger Wert: {1} wurde für das CHAR-Attribut {0} verwendet. Ein Attribut vom Typ CHAR darf nur ein Zeichen aufweisen!" } , { INVALID_QNAME , "Ungültiger Wert: {1} wurde für das QNAME-Attribut {0} verwendet." } , { INVALID_ENUM , "Ungültiger Wert: {1} wurde für das ENUM-Attribut {0} verwendet. Die gültigen Werte lauten: {2}." } , { INVALID_NMTOKEN , "Ungültiger Wert: {1} wurde für das NMTOKEN-Attribut {0} verwendet. " } , { INVALID_NCNAME , "Ungültiger Wert: {1} wurde für das NCNAME-Attribut {0} verwendet. " } , { INVALID_BOOLEAN , "Ungültiger Wert: {1} wurde für das boolean-Attribut {0} verwendet. " } , { INVALID_NUMBER , "Ungültiger Wert: {1} wurde für das number-Attribut {0} verwendet. " } , { ER_ARG_LITERAL , "Das Argument für {0} im Muster muss ein Literal sein." } , { ER_DUPLICATE_GLOBAL_VAR , "Doppelte Deklaration einer globalen Variablen." } , { ER_DUPLICATE_VAR , "Doppelte Deklaration einer Variablen." } , { ER_TEMPLATE_NAME_MATCH , "Das Element xsl:template muss ein name- oder ein match-Attribut (oder beide) aufweisen." } , { ER_INVALID_PREFIX , "Präfix in exclude-result-prefixes ist nicht gültig: {0}" } , { ER_NO_ATTRIB_SET , "Das Attributset mit dem Namen {0} ist nicht vorhanden." } , { WG_FOUND_CURLYBRACE , "'}' gefunden, aber keine Attributvorlage geöffnet!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Warnung: ''count''-Attribute passt zu keinem Vorgängerknoten in xsl:number! Ziel = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Alte Syntax: Der Name des 'expr'-Attributs ist zu 'select' geändert worden." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan bearbeitet den lokalen Namen in der Funktion format-number noch nicht." } , { WG_LOCALE_NOT_FOUND , "Warnung: Locale für xml:lang={0} nicht gefunden" } , { WG_CANNOT_MAKE_URL_FROM , "URL kann nicht erstellt werden aus: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Angefordertes Dokument kann nicht geladen werden: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Collator für <sort xml:lang={0} nicht gefunden" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Alte Syntax: Die Funktionsanweisung sollten einen URL von {0} verwenden" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "Codierung nicht unterstützt: {0}, UTF-8 wird verwendet" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Codierung nicht unterstützt: {0}, Java {1} wird verwendet" } , { WG_SPECIFICITY_CONFLICTS , "Spezifitätskonflikte gefunden: {0} Zuletzt in Stylesheet gefundenes wird verwendet." } , { WG_PARSING_AND_PREPARING , "========= Parsen und Vorbereiten {0} ==========" } , { WG_ATTR_TEMPLATE , "Attributvorlage, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Match-Konflikt zwischen xsl:strip-space und xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan bearbeitet das Attribut {0} noch nicht!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Keine Vereinbarung für Dezimalformat gefunden: {0}" } , { WG_OLD_XSLT_NS , "XSLT-Namensraum fehlt oder ist nicht korrekt. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Nur eine Standardvereinbarung xsl:decimal-format ist erlaubt." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format-Namen müssen eindeutig sein. Name \"{0}\" ist nicht eindeutig." } , { WG_ILLEGAL_ATTRIBUTE , "{0} hat ein ungültiges Attribut: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Namensraum-Präfix konnte nicht aufgelöst werden: {0}. Der Knoten wird ignoriert." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet erfordert ein 'version'-Attribut!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Ungültiger Attributname: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Ungültiger Wert für Attribut {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Resultierendes Knotenset aus zweitem Argument von document-Funktion ist leer. Das erste Argument wird verwendet." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Der Wert des name-Attributs von xsl:processing-instruction darf nicht 'xml' lauten." } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Der Wert des name-Attributs von xsl:processing-instruction muss einem gültigen ''NCName'' entsprechen: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Das Attribut {0} kann nicht nach untergeordneten Elementen oder vor der Erstellung eines Elements hinzugefügt werden. Das Attribut wird ignoriert." } , { "ui_language" , "de" } , { "help_language" , "de" } , { "language" , "de" } , { "BAD_CODE" , "Parameter für createMessage außerhalb der Grenzwerte" } , { "FORMAT_FAILED" , "Ausnahme bei messageFormat-Aufruf" } , { "version" , ">>>>>>> Xalan Version " } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Zeile #" } , { "column" , "Spalte #" } , { "xsldone" , "XSLProcessor: fertig" } , { "xslProc_option" , "Optionen der Klasse Process in Xalan-J-Befehlszeile:" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER voll qualifizierter Klassenname von Parserliaison]" } , { "optionE" , "   [-E (Entity-Referenzen nicht erweitern)]" } , { "optionV" , "   [-E (Entity-Referenzen nicht erweitern)]" } , { "optionQC" , "   [-QC (Geräuscharme Warnungen bei Musterkonflikten)]" } , { "optionQ" , "   [-Q  (Geräuschmer Modus)]" } , { "optionLF" , "   [-LF (bei Ausgabe nur Zeilenvorsprung {Standard ist CR/LF})]" } , { "optionCR" , "   [-CR (bei Ausgabe nur Wagenrücklauf {Standard ist CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Zeichen für Escape {Standard ist <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Anzahl der Leerzeichen zum Einrücken {Standard ist 0})]" } , { "optionTT" , "   [-TT (Vorlagen beim Aufruf verfolgen.)]" } , { "optionTG" , "   [-TG (Jedes Erzeugungsereignis verfolgen.)]" } , { "optionTS" , "   [-TS (Jedes Auswahlereignis verfolgen.)]" } , { "optionTTC" , "   [-TTC (Die Vorlagen-Tochterknoten bei Bearbeitung verfolgen.)]" } , { "optionTCLASS" , "   [-TCLASS (TraceListener-Klasse für Trace-Erweiterungen.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Festlegen, ob Validierung stattfindet. Standard ist keine Validierung.)]" } , { "optionEDUMP" , "   [-EDUMP {optionaler Dateiname} (Speicherauszug bei Fehler.)]" } , { "optionXML" , "   [-XML (XML-Formatierer verwenden und XML-Header hinzufügen.)]" } , { "optionTEXT" , "   [-TEXT (Einfachen Textformatierer verwenden.)]" } , { "optionHTML" , "   [-HTML (HTML-Formatierer verwenden.)]" } , { "optionPARAM" , "   [-PARAM Namensausdruck (Stylesheet-Parameter festlegen)]" } , { "noParsermsg1" , "XSL-Prozess fehlgeschlagen." } , { "noParsermsg2" , "** Parser nicht gefunden **" } , { "noParsermsg3" , "Bitte Classpath überprüfen." } , { "noParsermsg4" , "Wenn Sie IBMs XML Parser for Java nicht haben, können Sie ihn von folgender Adresse herunterladen" } , { "noParsermsg5" , "IBMs AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER vollständiger Klassenname (zum Auflösen von URIs zu verwendender URIResolver)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER vollständiger Klassenname (zum Auflösen von Entities zu verwendender EntityResolver)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER vollständiger Klassenname (zum Serialisieren der Ausgabe zu verwendender ContentHandler)]" } , { "optionLINENUMBERS" , "   [-L Zeilennummern für Quelldokument verwenden]" } , { "optionMEDIA" , " [-MEDIA Medientyp (media-Attribut zum Auffinden des einem Dokument zugeordneten Stylesheets verwenden)]" } , { "optionFLAVOR" , " [-FLAVOR Variantenname(Ausdrücklich s2s=SAX oder d2d=DOM für die Transformation verwenden)] " } , { "optionDIAG" , " [-DIAG (Zeitdauer der Transformation in Millisekunden ausgeben)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (Inkrementellen DTM-Aufbau anfordern, indem http://xml.apache.org/xalan/features/incremental auf 'Wahr' gesetzt wird)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (Keine Optimierung des Stylesheets durchführen, indem http://xml.apache.org/xalan/features/optimize auf 'Falsch' gesetzt wird)]" } , { "optionRL" , " [-RL Rekursionsgrenze (Numerische Begrenzung der Rekursionstiefe für das Stylesheet)]" } , { "optionXO" , " [-XO [Translet-Name] (Zuweisen eines Namens zum erzeugten Translet)]" } , { "optionXD" , " [-XD Zielverzeichnis (Angabe eines Zielverzeichnisses für das Translet)]" } , { "optionXJ" , " [-XJ JAR-Datei (Erstellt ein Paket mit den Translet-Klassen in einer JAR-Datei mit dem Namen <JAR-Datei>)]" } , { "optionXP" , " [-XP Paket (Angabe eines Paketnamen-Präfixes für alle erzeugten Translet-Klassen)]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#Fehler" ; public static final String ERROR_HEADER = "Fehler: " ; public static final String WARNING_HEADER = "Warnung: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MUSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.423076923', '3769', '0', '0', '0.976190476', '1', '0', '0', '1251', '1', '0.3333', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . Writer ; public class SerializerTraceWriter extends Writer { private final java . io . Writer m_writer ; private final SerializerTrace m_tracer ; private int buf_length ; private byte buf [ ] ; private int count ; private void setBufferSize ( int size ) { buf = new byte [ size + 3 ] ; buf_length = size ; count = 0 ; } public SerializerTraceWriter ( Writer out , SerializerTrace tracer ) { m_writer = out ; m_tracer = tracer ; setBufferSize ( 1024 ) ; } private void flushBuffer ( ) throws IOException { if ( count > 0 ) { char [ ] chars = new char [ count ] ; for ( int i = 0 ; i < count ; i ++ ) chars [ i ] = ( char ) buf [ i ] ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_OUTPUT_CHARACTERS , chars , 0 , chars . length ) ; count = 0 ; } } public void flush ( ) throws java . io . IOException { if ( m_writer != null ) m_writer . flush ( ) ; flushBuffer ( ) ; } public void close ( ) throws java . io . IOException { if ( m_writer != null ) m_writer . close ( ) ; flushBuffer ( ) ; } public void write ( final int c ) throws IOException { if ( m_writer != null ) m_writer . write ( c ) ; if ( count >= buf_length ) flushBuffer ( ) ; if ( c < 0x80 ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { if ( m_writer != null ) m_writer . write ( chars , start , length ) ; int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; setBufferSize ( 2 * lengthx3 ) ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } public void write ( final String s ) throws IOException { if ( m_writer != null ) m_writer . write ( s ) ; final int length = s . length ( ) ; int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; setBufferSize ( 2 * lengthx3 ) ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } for ( int i = 0 ; i < length ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } } 	0	['8', '2', '0', '2', '17', '0', '1', '1', '6', '0.171428571', '514', '1', '1', '0.65', '0.3125', '1', '2', '62.625', '1', '0.875', '0']
package org . apache . xalan . serialize ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; public abstract class SerializerFactory { private SerializerFactory ( ) { } public static Serializer getSerializer ( Properties format ) { org . apache . xml . serializer . Serializer ser ; ser = org . apache . xml . serializer . SerializerFactory . getSerializer ( format ) ; SerializerFactory . SerializerWrapper si = new SerializerWrapper ( ser ) ; return si ; } private static class SerializerWrapper implements Serializer { private final org . apache . xml . serializer . Serializer m_serializer ; private DOMSerializer m_old_DOMSerializer ; SerializerWrapper ( org . apache . xml . serializer . Serializer ser ) { m_serializer = ser ; } public void setOutputStream ( OutputStream output ) { m_serializer . setOutputStream ( output ) ; } public OutputStream getOutputStream ( ) { return m_serializer . getOutputStream ( ) ; } public void setWriter ( Writer writer ) { m_serializer . setWriter ( writer ) ; } public Writer getWriter ( ) { return m_serializer . getWriter ( ) ; } public void setOutputFormat ( Properties format ) { m_serializer . setOutputFormat ( format ) ; } public Properties getOutputFormat ( ) { return m_serializer . getOutputFormat ( ) ; } public ContentHandler asContentHandler ( ) throws IOException { return m_serializer . asContentHandler ( ) ; } public DOMSerializer asDOMSerializer ( ) throws IOException { if ( m_old_DOMSerializer == null ) { m_old_DOMSerializer = new DOMSerializerWrapper ( m_serializer . asDOMSerializer ( ) ) ; } return m_old_DOMSerializer ; } public boolean reset ( ) { return m_serializer . reset ( ) ; } } private static class DOMSerializerWrapper implements DOMSerializer { private final org . apache . xml . serializer . DOMSerializer m_dom ; DOMSerializerWrapper ( org . apache . xml . serializer . DOMSerializer domser ) { m_dom = domser ; } public void serialize ( Node node ) throws IOException { m_dom . serialize ( node ) ; } } } 	0	['2', '1', '0', '4', '5', '1', '0', '4', '1', '2', '15', '0', '0', '0', '0.5', '0', '0', '6.5', '1', '0.5', '0']
package org . apache . xml . res ; public class XMLErrorResources_de extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Funktion nicht unterstützt!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Ursache für nicht mögliches Überschreiben" } , { ER_NO_DEFAULT_IMPL , "Keine Standardimplementierung gefunden" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) zurzeit nicht unterstützt" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset größer als Slot" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine nicht verfügbar, ID={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager empfing Anforderung co_exit()" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() fehlgeschlagen" } , { ER_COROUTINE_PARAM , "Parameterfehler in Coroutine ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: Parser doTerminate antwortet {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse darf während des Parsens nicht aufgerufen werden" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fehler: Typisierter Iterator für Achse {0} nicht implementiert" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fehler: Iterator für Achse {0} nicht implementiert" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Iterator-Klone nicht unterstützt" } , { ER_UNKNOWN_AXIS_TYPE , "Unbekannter Achsen-Traversaltyp: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Achsen-Traverser nicht unterstützt: {0}" } , { ER_NO_DTMIDS_AVAIL , "Keine weiteren DTM-IDs verfügbar" } , { ER_NOT_SUPPORTED , "Nicht unterstützt: {0}" } , { ER_NODE_NON_NULL , "Knoten darf für getDTMHandleFromNode nicht Null sein" } , { ER_COULD_NOT_RESOLVE_NODE , "Der Knoten zu einem Handle konnte nicht aufgelöst werden" } , { ER_STARTPARSE_WHILE_PARSING , "startParse darf beim Parsen nicht aufgerufen werden" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse benötigt einen SAXParser, der nicht Null ist" } , { ER_COULD_NOT_INIT_PARSER , "Parser konnte nicht initialisiert werden" } , { ER_EXCEPTION_CREATING_POOL , "Ausnahme, die neue Instanz für Pool erstellt" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Pfad enthält ungültige Escape-Sequenz" } , { ER_SCHEME_REQUIRED , "Schema ist erforderlich!" } , { ER_NO_SCHEME_IN_URI , "Kein Schema gefunden in URI: {0}" } , { ER_NO_SCHEME_INURI , "Kein Schema gefunden in URI" } , { ER_PATH_INVALID_CHAR , "Pfad enthält ungültiges Zeichen: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Schema kann ausgehend von Null-Zeichenkette nicht gesetzt werden" } , { ER_SCHEME_NOT_CONFORMANT , "Schema ist nicht konform." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Hostadresse nicht korrekt gebildet" } , { ER_PORT_WHEN_HOST_NULL , "Port kann nicht gesetzt werden, wenn Host Null ist" } , { ER_INVALID_PORT , "Ungültige Port-Nummer" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment kann nur für einen generischen URI gesetzt werden" } , { ER_FRAG_WHEN_PATH_NULL , "Fragment kann nicht gesetzt werden, wenn der Pfad Null ist" } , { ER_FRAG_INVALID_CHAR , "Fragment enthält ungültiges Zeichen" } , { ER_PARSER_IN_USE , "Parser wird bereits verwendet" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "{0} {1} kann beim Parsen nicht geändert werden" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Selbst-Kausalität nicht erlaubt" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo kann nicht angegeben werden, wenn Host nicht angegeben ist" } , { ER_NO_PORT_IF_NO_HOST , "Port kann nicht angegeben werden, wenn Host nicht angegeben ist" } , { ER_NO_QUERY_STRING_IN_PATH , "Abfragezeichenkette kann nicht sowohl im Pfad als auch in der Abfragezeichenkette angegeben werden" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment kann nicht sowohl im Pfad als auch im Fragment angegeben werden" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "URI kann nicht mit leeren Parametern initialisiert werden" } , { ER_METHOD_NOT_SUPPORTED , "Methode noch nicht unterstützt " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter kann zurzeit nicht neu gestartet werden" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader nicht vor startParse-Anforderung" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Achsen-Traverser nicht unterstützt: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler wurde mit Null-PrintWriter erstellt!" } , { ER_SYSTEMID_UNKNOWN , "Unbekannte SystemId" } , { ER_LOCATION_UNKNOWN , "Fehler befindet sich an unbekannter Stelle" } , { ER_PREFIX_MUST_RESOLVE , "Präfix muss sich in Namensraum auflösen lassen: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() in XpathContext nicht unterstützt!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Attribut-Tochterknoten hat kein Eigentümer-Dokument!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Attribut-Tochterknoten hat kein Element Eigentümer-Dokument!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Warnung: Vor einem Dokumentelement kann kein Text ausgegeben werden! Wird ignoriert..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Ein DOM kann nur einen Stamm haben!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' ist Null" } , { ER_ARG_LOCALNAME_INVALID , "Der lokale Name in QNAME muss einem gültigen 'NCName' entsprechen." } , { ER_ARG_PREFIX_INVALID , "Das Präfix in QNAME muss einem gültigen 'NCName' entsprechen." } , { "BAD_CODE" , "Parameter für createMessage außerhalb der Grenzwerte" } , { "FORMAT_FAILED" , "Ausnahme bei messageFormat-Aufruf" } , { "line" , "Zeile #" } , { "column" , "Spalte #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '0']
package org . apache . xalan . serialize ; public interface DOMSerializer extends org . apache . xml . serializer . DOMSerializer { } 	0	['0', '1', '0', '5', '0', '0', '4', '1', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemText ; public class ProcessorText extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { ProcessorCharacters charProcessor = ( ProcessorCharacters ) handler . getProcessorFor ( null , "text()" , "text" ) ; charProcessor . setXslTextElement ( ( ElemText ) elem ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ProcessorCharacters charProcessor = ( ProcessorCharacters ) handler . getProcessorFor ( null , "text()" , "text" ) ; charProcessor . setXslTextElement ( null ) ; } } 	0	['3', '5', '0', '7', '10', '3', '1', '6', '2', '2', '40', '0', '0', '0.990697674', '0.583333333', '2', '4', '12.33333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Comment extends Instruction { public void parseContents ( Parser parser ) { parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , "stringValueHandler" , STRING_VALUE_HANDLER_SIG ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_VALUE_HANDLER , "getValue" , "()" + STRING_SIG ) ) ) ; final int comment = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "comment" , "(" + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( comment , 2 ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	0	['4', '3', '0', '15', '20', '6', '0', '15', '3', '2', '92', '0', '0', '0.949152542', '0.4', '1', '3', '22', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Fallback extends Instruction { private boolean _active = false ; public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _active ) { return ( typeCheckContents ( stable ) ) ; } else { return Type . Void ; } } public void activate ( ) { _active = true ; } public String toString ( ) { return ( "fallback" ) ; } public void parseContents ( Parser parser ) { if ( _active ) parseChildren ( parser ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _active ) translateContents ( classGen , methodGen ) ; } } 	0	['6', '3', '0', '10', '12', '0', '1', '9', '5', '0.2', '49', '1', '0', '0.918032787', '0.333333333', '1', '3', '7', '2', '1.1667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . CompareGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . TestGenerator ; final class PositionCall extends FunctionCall { public PositionCall ( QName fname ) { super ( fname ) ; } public boolean hasPositionCall ( ) { return true ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( methodGen instanceof CompareGenerator ) { il . append ( ( ( CompareGenerator ) methodGen ) . loadCurrentNode ( ) ) ; } else if ( methodGen instanceof TestGenerator ) { il . append ( new ILOAD ( POSITION_INDEX ) ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "positionF" , "(" + NODE_ITERATOR_SIG + ")I" ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } } } 	0	['3', '4', '0', '13', '12', '3', '1', '12', '3', '2', '55', '0', '0', '0.979591837', '0.5', '2', '4', '17.33333333', '3', '1.3333', '0']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; public class ElemVariablePsuedo extends ElemVariable { XUnresolvedVariableSimple m_lazyVar ; public void setSelect ( XPath v ) { super . setSelect ( v ) ; m_lazyVar = new XUnresolvedVariableSimple ( this ) ; } public void execute ( TransformerImpl transformer ) throws TransformerException { transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , m_lazyVar ) ; } } 	0	['3', '4', '0', '8', '9', '1', '1', '7', '3', '0.5', '26', '0', '1', '0.99086758', '0.555555556', '0', '0', '7.333333333', '1', '0.6667', '0']
package org . apache . xalan . templates ; import org . apache . xpath . XPathVisitor ; public class XSLTVisitor extends XPathVisitor { boolean visitInstruction ( ElemTemplateElement elem ) { return true ; } boolean visitStylesheet ( ElemTemplateElement elem ) { return true ; } boolean visitTopLevelInstruction ( ElemTemplateElement elem ) { return true ; } boolean visitTopLevelVariableOrParamDecl ( ElemTemplateElement elem ) { return true ; } boolean visitVariableOrParamDecl ( ElemVariable elem ) { return true ; } boolean visitLiteralResultElement ( ElemLiteralResult elem ) { return true ; } boolean visitAVT ( AVT elem ) { return true ; } boolean visitExtensionElement ( ElemExtensionCall elem ) { return true ; } } 	0	['9', '2', '1', '20', '10', '36', '19', '6', '1', '2', '28', '0', '0', '0.6', '0.314814815', '0', '0', '2.111111111', '1', '0.8889', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class DocumentCall extends FunctionCall { private Expression _uri = null ; private Expression _base = null ; private Type _uriType ; public DocumentCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int ac = argumentCount ( ) ; if ( ( ac < 1 ) || ( ac > 2 ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } _uri = argument ( 0 ) ; if ( _uri instanceof LiteralExpr ) { LiteralExpr expr = ( LiteralExpr ) _uri ; if ( expr . getValue ( ) . equals ( EMPTYSTRING ) ) { Stylesheet stylesheet = getStylesheet ( ) ; if ( stylesheet == null ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } _uri = new LiteralExpr ( stylesheet . getSystemId ( ) , EMPTYSTRING ) ; } } _uriType = _uri . typeCheck ( stable ) ; if ( ( _uriType != Type . NodeSet ) && ( _uriType != Type . String ) ) { _uri = new CastExpr ( _uri , Type . String ) ; } if ( ac == 2 ) { _base = argument ( 1 ) ; final Type baseType = _base . typeCheck ( stable ) ; if ( baseType . identicalTo ( Type . Node ) ) { _base = new CastExpr ( _base , Type . NodeSet ) ; } else if ( baseType . identicalTo ( Type . NodeSet ) ) { } else { ErrorMsg msg = new ErrorMsg ( ErrorMsg . DOCUMENT_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int domField = cpg . addFieldref ( classGen . getClassName ( ) , DOM_FIELD , DOM_INTF_SIG ) ; final String docParamList = "(" + OBJECT_SIG + STRING_SIG + STRING_SIG + TRANSLET_SIG + DOM_INTF_SIG + ")" + NODE_ITERATOR_SIG ; final int docIdx = cpg . addMethodref ( LOAD_DOCUMENT_CLASS , "document" , docParamList ) ; final int uriIdx = cpg . addInterfaceMethodref ( DOM_INTF , "getDocumentURI" , "(I)" + STRING_SIG ) ; final int nextIdx = cpg . addInterfaceMethodref ( NODE_ITERATOR , NEXT , NEXT_SIG ) ; _uri . translate ( classGen , methodGen ) ; if ( _uriType == Type . NodeSet ) _uri . startResetIterator ( classGen , methodGen ) ; if ( _base != null ) { il . append ( methodGen . loadDOM ( ) ) ; _base . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( nextIdx , 1 ) ) ; il . append ( new INVOKEINTERFACE ( uriIdx , 2 ) ) ; } else { if ( _uriType == Type . NodeSet ) il . append ( new PUSH ( cpg , "" ) ) ; else il . append ( new PUSH ( cpg , getStylesheet ( ) . getSystemId ( ) ) ) ; } il . append ( new PUSH ( cpg , getStylesheet ( ) . getSystemId ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( DUP ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( new INVOKESTATIC ( docIdx ) ) ; } } 	0	['3', '4', '0', '21', '26', '0', '0', '21', '3', '0.166666667', '246', '1', '3', '0.979591837', '0.444444444', '3', '14', '80', '4', '1.6667', '0']
package org . apache . xalan . xsltc . dom ; public interface Axis extends org . apache . xml . dtm . Axis { public static final boolean [ ] isReverse = { true , true , false , false , false , false , false , false , false , false , false , true , true , false } ; } 	0	['1', '1', '0', '7', '1', '0', '6', '1', '0', '2', '62', '0', '0', '0', '0', '0', '0', '60', '0', '0', '0']
package org . apache . xml . dtm . ref ; import java . io . IOException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . ThreadControllerWrapper ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; public class IncrementalSAXSource_Filter implements IncrementalSAXSource , ContentHandler , DTDHandler , LexicalHandler , ErrorHandler , Runnable { boolean DEBUG = false ; private CoroutineManager fCoroutineManager = null ; private int fControllerCoroutineID = - 1 ; private int fSourceCoroutineID = - 1 ; private ContentHandler clientContentHandler = null ; private LexicalHandler clientLexicalHandler = null ; private DTDHandler clientDTDHandler = null ; private ErrorHandler clientErrorHandler = null ; private int eventcounter ; private int frequency = 5 ; private boolean fNoMoreEvents = false ; private XMLReader fXMLReader = null ; private InputSource fXMLReaderInputSource = null ; public IncrementalSAXSource_Filter ( ) { this . init ( new CoroutineManager ( ) , - 1 , - 1 ) ; } public IncrementalSAXSource_Filter ( CoroutineManager co , int controllerCoroutineID ) { this . init ( co , controllerCoroutineID , - 1 ) ; } static public IncrementalSAXSource createIncrementalSAXSource ( CoroutineManager co , int controllerCoroutineID ) { return new IncrementalSAXSource_Filter ( co , controllerCoroutineID ) ; } public void init ( CoroutineManager co , int controllerCoroutineID , int sourceCoroutineID ) { if ( co == null ) co = new CoroutineManager ( ) ; fCoroutineManager = co ; fControllerCoroutineID = co . co_joinCoroutineSet ( controllerCoroutineID ) ; fSourceCoroutineID = co . co_joinCoroutineSet ( sourceCoroutineID ) ; if ( fControllerCoroutineID == - 1 || fSourceCoroutineID == - 1 ) throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COJOINROUTINESET_FAILED , null ) ) ; fNoMoreEvents = false ; eventcounter = frequency ; } public void setXMLReader ( XMLReader eventsource ) { fXMLReader = eventsource ; eventsource . setContentHandler ( this ) ; eventsource . setDTDHandler ( this ) ; eventsource . setErrorHandler ( this ) ; try { eventsource . setProperty ( "http://xml.org/sax/properties/lexical-handler" , this ) ; } catch ( SAXNotRecognizedException e ) { } catch ( SAXNotSupportedException e ) { } } public void setContentHandler ( ContentHandler handler ) { clientContentHandler = handler ; } public void setDTDHandler ( DTDHandler handler ) { clientDTDHandler = handler ; } public void setLexicalHandler ( LexicalHandler handler ) { clientLexicalHandler = handler ; } public void setErrHandler ( ErrorHandler handler ) { clientErrorHandler = handler ; } public void setReturnFrequency ( int events ) { if ( events < 1 ) events = 1 ; frequency = eventcounter = events ; } public void characters ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . characters ( ch , start , length ) ; } public void endDocument ( ) throws org . xml . sax . SAXException { if ( clientContentHandler != null ) clientContentHandler . endDocument ( ) ; eventcounter = 0 ; co_yield ( false ) ; } public void endElement ( java . lang . String namespaceURI , java . lang . String localName , java . lang . String qName ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . endElement ( namespaceURI , localName , qName ) ; } public void endPrefixMapping ( java . lang . String prefix ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . endPrefixMapping ( prefix ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( java . lang . String target , java . lang . String data ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . processingInstruction ( target , data ) ; } public void setDocumentLocator ( Locator locator ) { if ( -- eventcounter <= 0 ) { eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . setDocumentLocator ( locator ) ; } public void skippedEntity ( java . lang . String name ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . skippedEntity ( name ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { co_entry_pause ( ) ; if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . startDocument ( ) ; } public void startElement ( java . lang . String namespaceURI , java . lang . String localName , java . lang . String qName , Attributes atts ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . startElement ( namespaceURI , localName , qName , atts ) ; } public void startPrefixMapping ( java . lang . String prefix , java . lang . String uri ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . startPrefixMapping ( prefix , uri ) ; } public void comment ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . comment ( ch , start , length ) ; } public void endCDATA ( ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . endCDATA ( ) ; } public void endDTD ( ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . endDTD ( ) ; } public void endEntity ( java . lang . String name ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . endEntity ( name ) ; } public void startCDATA ( ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . startCDATA ( ) ; } public void startDTD ( java . lang . String name , java . lang . String publicId , java . lang . String systemId ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . startDTD ( name , publicId , systemId ) ; } public void startEntity ( java . lang . String name ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . startEntity ( name ) ; } public void notationDecl ( String a , String b , String c ) throws SAXException { if ( null != clientDTDHandler ) clientDTDHandler . notationDecl ( a , b , c ) ; } public void unparsedEntityDecl ( String a , String b , String c , String d ) throws SAXException { if ( null != clientDTDHandler ) clientDTDHandler . unparsedEntityDecl ( a , b , c , d ) ; } public void error ( SAXParseException exception ) throws SAXException { if ( null != clientErrorHandler ) clientErrorHandler . error ( exception ) ; } public void fatalError ( SAXParseException exception ) throws SAXException { if ( null != clientErrorHandler ) clientErrorHandler . error ( exception ) ; eventcounter = 0 ; co_yield ( false ) ; } public void warning ( SAXParseException exception ) throws SAXException { if ( null != clientErrorHandler ) clientErrorHandler . error ( exception ) ; } public int getSourceCoroutineID ( ) { return fSourceCoroutineID ; } public int getControllerCoroutineID ( ) { return fControllerCoroutineID ; } public CoroutineManager getCoroutineManager ( ) { return fCoroutineManager ; } protected void count_and_yield ( boolean moreExpected ) throws SAXException { if ( ! moreExpected ) eventcounter = 0 ; if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } } private void co_entry_pause ( ) throws SAXException { if ( fCoroutineManager == null ) { init ( null , - 1 , - 1 ) ; } try { Object arg = fCoroutineManager . co_entry_pause ( fSourceCoroutineID ) ; if ( arg == Boolean . FALSE ) co_yield ( false ) ; } catch ( NoSuchMethodException e ) { if ( DEBUG ) e . printStackTrace ( ) ; throw new SAXException ( e ) ; } } private void co_yield ( boolean moreRemains ) throws SAXException { if ( fNoMoreEvents ) return ; try { Object arg = Boolean . FALSE ; if ( moreRemains ) { arg = fCoroutineManager . co_resume ( Boolean . TRUE , fSourceCoroutineID , fControllerCoroutineID ) ; } if ( arg == Boolean . FALSE ) { fNoMoreEvents = true ; if ( fXMLReader != null ) throw new StopException ( ) ; fCoroutineManager . co_exit_to ( Boolean . FALSE , fSourceCoroutineID , fControllerCoroutineID ) ; } } catch ( NoSuchMethodException e ) { fNoMoreEvents = true ; fCoroutineManager . co_exit ( fSourceCoroutineID ) ; throw new SAXException ( e ) ; } } public void startParse ( InputSource source ) throws SAXException { if ( fNoMoreEvents ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , null ) ) ; if ( fXMLReader == null ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_XMLRDR_NOT_BEFORE_STARTPARSE , null ) ) ; fXMLReaderInputSource = source ; ThreadControllerWrapper . runThread ( this , - 1 ) ; } public void run ( ) { if ( fXMLReader == null ) return ; if ( DEBUG ) System . out . println ( "IncrementalSAXSource_Filter parse thread launched" ) ; Object arg = Boolean . FALSE ; try { fXMLReader . parse ( fXMLReaderInputSource ) ; } catch ( IOException ex ) { arg = ex ; } catch ( StopException ex ) { if ( DEBUG ) System . out . println ( "Active IncrementalSAXSource_Filter normal stop exception" ) ; } catch ( SAXException ex ) { Exception inner = ex . getException ( ) ; if ( inner instanceof StopException ) { if ( DEBUG ) System . out . println ( "Active IncrementalSAXSource_Filter normal stop exception" ) ; } else { if ( DEBUG ) { System . out . println ( "Active IncrementalSAXSource_Filter UNEXPECTED SAX exception: " + inner ) ; inner . printStackTrace ( ) ; } arg = ex ; } } fXMLReader = null ; try { fNoMoreEvents = true ; fCoroutineManager . co_exit_to ( arg , fSourceCoroutineID , fControllerCoroutineID ) ; } catch ( java . lang . NoSuchMethodException e ) { e . printStackTrace ( System . err ) ; fCoroutineManager . co_exit ( fSourceCoroutineID ) ; } } class StopException extends RuntimeException { } public Object deliverMoreNodes ( boolean parsemore ) { if ( fNoMoreEvents ) return Boolean . FALSE ; try { Object result = fCoroutineManager . co_resume ( parsemore ? Boolean . TRUE : Boolean . FALSE , fControllerCoroutineID , fSourceCoroutineID ) ; if ( result == Boolean . FALSE ) fCoroutineManager . co_exit ( fControllerCoroutineID ) ; return result ; } catch ( NoSuchMethodException e ) { return e ; } } } 	0	['42', '1', '0', '10', '90', '335', '6', '5', '39', '0.667917448', '877', '0.923076923', '1', '0', '0.125396825', '0', '0', '19.57142857', '6', '1.2857', '0']
package org . apache . xalan . xsltc . runtime . output ; class StringOutputBuffer implements OutputBuffer { private StringBuffer _buffer ; public StringOutputBuffer ( ) { _buffer = new StringBuffer ( ) ; } public String close ( ) { return _buffer . toString ( ) ; } public OutputBuffer append ( String s ) { _buffer . append ( s ) ; return this ; } public OutputBuffer append ( char [ ] s , int from , int to ) { _buffer . append ( s , from , to ) ; return this ; } public OutputBuffer append ( char ch ) { _buffer . append ( ch ) ; return this ; } } 	0	['5', '1', '0', '1', '11', '0', '0', '1', '5', '0', '41', '1', '0', '0', '0.36', '0', '0', '7', '1', '0.8', '0']
package org . apache . xalan . transformer ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . TransformerException ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; import org . apache . xml . serialize . Method ; import org . apache . xalan . templates . OutputProperties ; import org . xml . sax . ContentHandler ; public class SerializerSwitcher { public static void switchSerializerIfHTML ( TransformerImpl transformer , String ns , String localName ) throws TransformerException { if ( null == transformer ) return ; if ( ( ( null == ns ) || ( ns . length ( ) == 0 ) ) && localName . equalsIgnoreCase ( "html" ) ) { if ( null != transformer . getOutputPropertyNoDefault ( OutputKeys . METHOD ) ) return ; Properties prevProperties = transformer . getOutputFormat ( ) . getProperties ( ) ; OutputProperties htmlOutputProperties = new OutputProperties ( Method . HTML ) ; htmlOutputProperties . copyFrom ( prevProperties , true ) ; Properties htmlProperties = htmlOutputProperties . getProperties ( ) ; try { Serializer oldSerializer = null ; if ( null != oldSerializer ) { Serializer serializer = SerializerFactory . getSerializer ( htmlProperties ) ; Writer writer = oldSerializer . getWriter ( ) ; if ( null != writer ) serializer . setWriter ( writer ) ; else { OutputStream os = oldSerializer . getOutputStream ( ) ; if ( null != os ) serializer . setOutputStream ( os ) ; } ContentHandler ch = serializer . asContentHandler ( ) ; transformer . setContentHandler ( ch ) ; } } catch ( java . io . IOException e ) { throw new TransformerException ( e ) ; } } } private static String getOutputPropertyNoDefault ( String qnameString , Properties props ) throws IllegalArgumentException { String value = ( String ) props . get ( qnameString ) ; return value ; } public static Serializer switchSerializerIfHTML ( String ns , String localName , Properties props , Serializer oldSerializer ) throws TransformerException { Serializer newSerializer = oldSerializer ; if ( ( ( null == ns ) || ( ns . length ( ) == 0 ) ) && localName . equalsIgnoreCase ( "html" ) ) { if ( null != getOutputPropertyNoDefault ( OutputKeys . METHOD , props ) ) return newSerializer ; Properties prevProperties = props ; OutputProperties htmlOutputProperties = new OutputProperties ( Method . HTML ) ; htmlOutputProperties . copyFrom ( prevProperties , true ) ; Properties htmlProperties = htmlOutputProperties . getProperties ( ) ; { if ( null != oldSerializer ) { Serializer serializer = SerializerFactory . getSerializer ( htmlProperties ) ; Writer writer = oldSerializer . getWriter ( ) ; if ( null != writer ) serializer . setWriter ( writer ) ; else { OutputStream os = serializer . getOutputStream ( ) ; if ( null != os ) serializer . setOutputStream ( os ) ; } newSerializer = serializer ; } } } return newSerializer ; } } 	0	['4', '1', '0', '5', '21', '6', '1', '4', '3', '2', '153', '0', '0', '0', '0.4', '0', '0', '37.25', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; class TopLevelElement extends SyntaxTreeNode { public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . NOT_IMPLEMENTED_ERR , getClass ( ) , this ) ; getParser ( ) . reportError ( FATAL , msg ) ; } public InstructionList compile ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList result , save = methodGen . getInstructionList ( ) ; methodGen . setInstructionList ( result = new InstructionList ( ) ) ; translate ( classGen , methodGen ) ; methodGen . setInstructionList ( save ) ; return result ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "TopLevelElement" ) ; displayContents ( indent + IndentIncrement ) ; } } 	0	['5', '2', '10', '24', '17', '10', '14', '10', '4', '2', '56', '0', '0', '0.931034483', '0.44', '1', '4', '10.2', '1', '0.8', '0']
package org . apache . xml . res ; public class XMLErrorResources_zh_TW extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "不支援函式！" } , { ER_CANNOT_OVERWRITE_CAUSE , "無法改寫原因" } , { ER_NO_DEFAULT_IMPL , "找不到預設建置" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "目前不支援 ChunkedIntArray({0})" } , { ER_OFFSET_BIGGER_THAN_SLOT , "偏移大於介面槽" } , { ER_COROUTINE_NOT_AVAIL , "沒有 Coroutine 可用，id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager 收到 co_exit() 要求" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() 失效" } , { ER_COROUTINE_PARAM , "Coroutine 參數錯誤 ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: 剖析器 doTerminate 回答 {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "在進行剖析時未能呼叫剖析" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "錯誤：對軸 {0} 輸入的重覆器沒有執行" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "錯誤：軸 {0} 的重覆器沒有執行 " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "不支援重覆器複製" } , { ER_UNKNOWN_AXIS_TYPE , "未知軸遍歷類型：{0}" } , { ER_AXIS_NOT_SUPPORTED , "不支援軸遍訪器：{0}" } , { ER_NO_DTMIDS_AVAIL , "沒有可用的 DTM ID" } , { ER_NOT_SUPPORTED , "不支援：{0}" } , { ER_NODE_NON_NULL , "對 getDTMHandleFromNode 而言，節點必須為非空值" } , { ER_COULD_NOT_RESOLVE_NODE , "無法解譯節點為控點" } , { ER_STARTPARSE_WHILE_PARSING , "在進行剖析時未呼叫 startParse" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse 需要非空值的 SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "無法起始設定剖析器，以" } , { ER_EXCEPTION_CREATING_POOL , "建立儲存池的新案例時發生異常" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "路徑包含無效逸出序列" } , { ER_SCHEME_REQUIRED , "綱要是必需的！" } , { ER_NO_SCHEME_IN_URI , "在 URI 找不到綱要：{0}" } , { ER_NO_SCHEME_INURI , "在 URI 找不到綱要" } , { ER_PATH_INVALID_CHAR , "路徑包含無效的字元：{0}" } , { ER_SCHEME_FROM_NULL_STRING , "無法從空字串設定綱要" } , { ER_SCHEME_NOT_CONFORMANT , "綱要不一致。" } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "主機沒有完整的位址" } , { ER_PORT_WHEN_HOST_NULL , "主機為空值時，無法設定通訊埠" } , { ER_INVALID_PORT , "無效的通訊埠編號" } , { ER_FRAG_FOR_GENERIC_URI , "只能對同屬的 URI 設定片段" } , { ER_FRAG_WHEN_PATH_NULL , "路徑為空值時，無法設定片段" } , { ER_FRAG_INVALID_CHAR , "片段包含無效字元" } , { ER_PARSER_IN_USE , "剖析器已在使用中" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "剖析時無法變更 {0} {1}" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "不允許自行引起" } , { ER_NO_USERINFO_IF_NO_HOST , "如果沒有指定主機，不可指定 Userinfo" } , { ER_NO_PORT_IF_NO_HOST , "如果沒有指定主機，不可指定通訊埠" } , { ER_NO_QUERY_STRING_IN_PATH , "在路徑及查詢字串中不可指定查詢字串" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "無法在路徑和片段中指定片段" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "無法起始設定空白參數的 URI" } , { ER_METHOD_NOT_SUPPORTED , "不支援方法 " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter 目前無法重新啟動" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader 不在 startParse 要求之前" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "不支援軸遍歷器：{0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "建立的 ListingErrorHandler 具有空 PrintWriter！" } , { ER_SYSTEMID_UNKNOWN , "SystemId 未知" } , { ER_LOCATION_UNKNOWN , "未知的錯誤位置" } , { ER_PREFIX_MUST_RESOLVE , "前置必須解譯為名稱空間：{0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() 在 XPathContext 中不受支援！" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "屬性子項沒有擁有者文件！" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "屬性子項沒有擁有者文件元素！" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "警告：無法輸出文件元素之前的文字！忽略..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "一個 DOM 只能有一個根！" } , { ER_ARG_LOCALNAME_NULL , "引數 'localName' 為空值" } , { ER_ARG_LOCALNAME_INVALID , "QNAME 中的 Localname 應為有效的 NCName" } , { ER_ARG_PREFIX_INVALID , "QNAME 中的前置應為有效的 NCName" } , { "BAD_CODE" , "createMessage 的參數超出界限" } , { "FORMAT_FAILED" , "在 messageFormat 呼叫期間丟出異常" } , { "line" , "行 #" } , { "column" , "直欄 #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '0']
package org . apache . xalan . lib . sql ; import java . sql . Connection ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . sql . Statement ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; public class SQLDocument extends DTMDocument { private boolean DEBUG = false ; private static final String S_NAMESPACE = "http://xml.apache.org/xalan/SQLExtension" ; private static final String S_SQL = "sql" ; private static final String S_ROW_SET = "row-set" ; private static final String S_METADATA = "metadata" ; private static final String S_COLUMN_HEADER = "column-header" ; private static final String S_ROW = "row" ; private static final String S_COL = "col" ; private static final String S_CATALOGUE_NAME = "catalogue-name" ; private static final String S_DISPLAY_SIZE = "column-display-size" ; private static final String S_COLUMN_LABEL = "column-label" ; private static final String S_COLUMN_NAME = "column-name" ; private static final String S_COLUMN_TYPE = "column-type" ; private static final String S_COLUMN_TYPENAME = "column-typename" ; private static final String S_PRECISION = "precision" ; private static final String S_SCALE = "scale" ; private static final String S_SCHEMA_NAME = "schema-name" ; private static final String S_TABLE_NAME = "table-name" ; private static final String S_CASESENSITIVE = "case-sensitive" ; private static final String S_DEFINITELYWRITABLE = "definitely-writable" ; private static final String S_ISNULLABLE = "nullable" ; private static final String S_ISSIGNED = "signed" ; private static final String S_ISWRITEABLE = "writable" ; private static final String S_ISSEARCHABLE = "searchable" ; private int m_SQL_TypeID = 0 ; private int m_MetaData_TypeID = 0 ; private int m_ColumnHeader_TypeID = 0 ; private int m_RowSet_TypeID = 0 ; private int m_Row_TypeID = 0 ; private int m_Col_TypeID = 0 ; private int m_ColAttrib_CATALOGUE_NAME_TypeID = 0 ; private int m_ColAttrib_DISPLAY_SIZE_TypeID = 0 ; private int m_ColAttrib_COLUMN_LABEL_TypeID = 0 ; private int m_ColAttrib_COLUMN_NAME_TypeID = 0 ; private int m_ColAttrib_COLUMN_TYPE_TypeID = 0 ; private int m_ColAttrib_COLUMN_TYPENAME_TypeID = 0 ; private int m_ColAttrib_PRECISION_TypeID = 0 ; private int m_ColAttrib_SCALE_TypeID = 0 ; private int m_ColAttrib_SCHEMA_NAME_TypeID = 0 ; private int m_ColAttrib_TABLE_NAME_TypeID = 0 ; private int m_ColAttrib_CASESENSITIVE_TypeID = 0 ; private int m_ColAttrib_DEFINITELYWRITABLE_TypeID = 0 ; private int m_ColAttrib_ISNULLABLE_TypeID = 0 ; private int m_ColAttrib_ISSIGNED_TypeID = 0 ; private int m_ColAttrib_ISWRITEABLE_TypeID = 0 ; private int m_ColAttrib_ISSEARCHABLE_TypeID = 0 ; private Connection m_Connection = null ; private Statement m_Statement = null ; private ResultSet m_ResultSet = null ; private ConnectionPool m_ConnectionPool = null ; private int [ ] m_ColHeadersIdx ; private int m_ColCount ; private int m_MetaDataIdx = DTM . NULL ; private int m_RowSetIdx = DTM . NULL ; private int m_SQLIdx = DTM . NULL ; private int m_FirstRowIdx = DTM . NULL ; private int m_LastRowIdx = DTM . NULL ; private boolean m_StreamingMode = true ; public SQLDocument ( DTMManager mgr , int ident , ConnectionPool pool , Connection con , Statement stmt , ResultSet data , boolean streamingMode ) throws SQLException { super ( mgr , ident ) ; m_Connection = con ; m_Statement = stmt ; m_ResultSet = data ; m_ConnectionPool = pool ; m_StreamingMode = streamingMode ; createExpandedNameTable ( ) ; extractSQLMetaData ( m_ResultSet . getMetaData ( ) ) ; addRowToDTMFromResultSet ( ) ; } private void extractSQLMetaData ( ResultSetMetaData meta ) { m_DocumentIdx = addElement ( 0 , m_Document_TypeID , DTM . NULL , DTM . NULL ) ; m_SQLIdx = addElement ( 1 , m_SQL_TypeID , m_DocumentIdx , DTM . NULL ) ; m_MetaDataIdx = addElement ( 1 , m_MetaData_TypeID , m_SQLIdx , DTM . NULL ) ; try { m_ColCount = meta . getColumnCount ( ) ; m_ColHeadersIdx = new int [ m_ColCount ] ; } catch ( Exception e ) { error ( "ERROR Extracting Metadata" ) ; } int lastColHeaderIdx = DTM . NULL ; int i = 1 ; for ( i = 1 ; i <= m_ColCount ; i ++ ) { m_ColHeadersIdx [ i - 1 ] = addElement ( 2 , m_ColumnHeader_TypeID , m_MetaDataIdx , lastColHeaderIdx ) ; lastColHeaderIdx = m_ColHeadersIdx [ i - 1 ] ; try { addAttributeToNode ( meta . getColumnName ( i ) , m_ColAttrib_COLUMN_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getColumnLabel ( i ) , m_ColAttrib_COLUMN_LABEL_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_LABEL_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getCatalogName ( i ) , m_ColAttrib_CATALOGUE_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_CATALOGUE_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getColumnDisplaySize ( i ) ) , m_ColAttrib_DISPLAY_SIZE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_DISPLAY_SIZE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getColumnType ( i ) ) , m_ColAttrib_COLUMN_TYPE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_TYPE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getColumnTypeName ( i ) , m_ColAttrib_COLUMN_TYPENAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_TYPENAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getPrecision ( i ) ) , m_ColAttrib_PRECISION_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_PRECISION_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getScale ( i ) ) , m_ColAttrib_SCALE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_SCALE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getSchemaName ( i ) , m_ColAttrib_SCHEMA_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_SCHEMA_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getTableName ( i ) , m_ColAttrib_TABLE_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_TABLE_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isCaseSensitive ( i ) ? S_ISTRUE : S_ISFALSE , m_ColAttrib_CASESENSITIVE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_CASESENSITIVE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isDefinitelyWritable ( i ) ? S_ISTRUE : S_ISFALSE , m_ColAttrib_DEFINITELYWRITABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_DEFINITELYWRITABLE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isNullable ( i ) != 0 ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISNULLABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISNULLABLE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isSigned ( i ) ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISSIGNED_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISSIGNED_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isWritable ( i ) == true ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISWRITEABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISWRITEABLE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isSearchable ( i ) == true ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISSEARCHABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISSEARCHABLE_TypeID , lastColHeaderIdx ) ; } } } protected void createExpandedNameTable ( ) { super . createExpandedNameTable ( ) ; m_SQL_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SQL , DTM . ELEMENT_NODE ) ; m_MetaData_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_METADATA , DTM . ELEMENT_NODE ) ; m_ColumnHeader_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_HEADER , DTM . ELEMENT_NODE ) ; m_RowSet_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ROW_SET , DTM . ELEMENT_NODE ) ; m_Row_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ROW , DTM . ELEMENT_NODE ) ; m_Col_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COL , DTM . ELEMENT_NODE ) ; m_ColAttrib_CATALOGUE_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CATALOGUE_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_DISPLAY_SIZE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DISPLAY_SIZE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_LABEL_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_LABEL , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_TYPE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_TYPE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_TYPENAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_TYPENAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_PRECISION_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_PRECISION , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_SCALE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SCALE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_SCHEMA_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SCHEMA_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_TABLE_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_TABLE_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_CASESENSITIVE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CASESENSITIVE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_DEFINITELYWRITABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DEFINITELYWRITABLE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISNULLABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISNULLABLE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISSIGNED_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISSIGNED , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISWRITEABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISWRITEABLE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISSEARCHABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISSEARCHABLE , DTM . ATTRIBUTE_NODE ) ; } private boolean addRowToDTMFromResultSet ( ) { try { if ( m_RowSetIdx == DTM . NULL ) { m_RowSetIdx = addElement ( 1 , m_RowSet_TypeID , m_SQLIdx , m_MetaDataIdx ) ; } if ( ! m_ResultSet . next ( ) ) { if ( m_StreamingMode && ( m_LastRowIdx != DTM . NULL ) ) { m_nextsib . setElementAt ( DTM . NULL , m_LastRowIdx ) ; } return false ; } if ( m_FirstRowIdx == DTM . NULL ) { m_FirstRowIdx = addElement ( 2 , m_Row_TypeID , m_RowSetIdx , DTM . NULL ) ; m_LastRowIdx = m_FirstRowIdx ; if ( m_StreamingMode ) { m_nextsib . setElementAt ( m_LastRowIdx , m_LastRowIdx ) ; } } else { if ( ! m_StreamingMode ) { m_LastRowIdx = addElement ( 3 , m_Row_TypeID , m_RowSetIdx , m_LastRowIdx ) ; } } int colID = _firstch ( m_LastRowIdx ) ; int pcolID = DTM . NULL ; for ( int i = 1 ; i <= m_ColCount ; i ++ ) { Object o = m_ResultSet . getObject ( i ) ; if ( colID == DTM . NULL ) { pcolID = addElementWithData ( o , 3 , m_Col_TypeID , m_LastRowIdx , pcolID ) ; cloneAttributeFromNode ( pcolID , m_ColHeadersIdx [ i - 1 ] ) ; } else { int dataIdent = _firstch ( colID ) ; if ( dataIdent == DTM . NULL ) { error ( "Streaming Mode, Data Error" ) ; } else { m_ObjectArray . setAt ( dataIdent , o ) ; } } if ( colID != DTM . NULL ) { colID = _nextsib ( colID ) ; } } } catch ( Exception e ) { if ( DEBUG ) { System . out . println ( "SQL Error Fetching next row [" + e . getLocalizedMessage ( ) + "]" ) ; } error ( "SQL Error Fetching next row [" + e . getLocalizedMessage ( ) + "]" ) ; } return true ; } public void close ( ) { if ( DEBUG ) System . out . println ( "close()" ) ; try { if ( null != m_ResultSet ) m_ResultSet . close ( ) ; } catch ( Exception e ) { } try { if ( null != m_Statement ) m_Statement . close ( ) ; } catch ( Exception e ) { } try { if ( null != m_Connection ) m_ConnectionPool . releaseConnection ( m_Connection ) ; } catch ( Exception e ) { } } public void closeOnError ( ) { if ( DEBUG ) System . out . println ( "close()" ) ; try { if ( null != m_ResultSet ) m_ResultSet . close ( ) ; } catch ( Exception e ) { } try { if ( null != m_Statement ) m_Statement . close ( ) ; } catch ( Exception e ) { } try { if ( null != m_Connection ) m_ConnectionPool . releaseConnectionOnError ( m_Connection ) ; } catch ( Exception e ) { } } protected boolean nextNode ( ) { if ( DEBUG ) System . out . println ( "nextNode()" ) ; try { return false ; } catch ( Exception e ) { return false ; } } protected int _nextsib ( int identity ) { int id = _exptype ( identity ) ; if ( ( id == m_Row_TypeID ) && ( identity >= m_LastRowIdx ) ) { if ( DEBUG ) System . out . println ( "reading from the ResultSet" ) ; addRowToDTMFromResultSet ( ) ; } return super . _nextsib ( identity ) ; } public void documentRegistration ( ) { if ( DEBUG ) System . out . println ( "Document Registration" ) ; } public void documentRelease ( ) { if ( DEBUG ) System . out . println ( "Document Release" ) ; } } 	0	['10', '5', '0', '7', '53', '0', '1', '6', '5', '0.883141762', '1077', '1', '1', '0.954545455', '0.211111111', '2', '8', '100.9', '12', '3.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ApplyImports extends Instruction { private QName _modeName ; private String _functionName ; private int _precedence ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ApplyTemplates" ) ; indent ( indent + IndentIncrement ) ; if ( _modeName != null ) { indent ( indent + IndentIncrement ) ; Util . println ( "mode " + _modeName ) ; } } public boolean hasWithParams ( ) { return hasContents ( ) ; } private int getMinPrecedence ( int max ) { Stylesheet stylesheet = getStylesheet ( ) ; Stylesheet root = getParser ( ) . getTopLevelStylesheet ( ) ; int min = max ; Enumeration templates = root . getContents ( ) . elements ( ) ; while ( templates . hasMoreElements ( ) ) { SyntaxTreeNode child = ( SyntaxTreeNode ) templates . nextElement ( ) ; if ( child instanceof Template ) { Stylesheet curr = child . getStylesheet ( ) ; while ( ( curr != null ) && ( curr != stylesheet ) ) { if ( curr . _importedFrom != null ) curr = curr . _importedFrom ; else if ( curr . _includedFrom != null ) curr = curr . _includedFrom ; else curr = null ; } if ( curr == stylesheet ) { int prec = child . getStylesheet ( ) . getImportPrecedence ( ) ; if ( prec < min ) min = prec ; } } } return ( min ) ; } public void parseContents ( Parser parser ) { Stylesheet stylesheet = getStylesheet ( ) ; stylesheet . setTemplateInlining ( false ) ; Template template = getTemplate ( ) ; _modeName = template . getModeName ( ) ; _precedence = template . getImportPrecedence ( ) ; stylesheet = parser . getTopLevelStylesheet ( ) ; final int maxPrecedence = _precedence ; final int minPrecedence = getMinPrecedence ( maxPrecedence ) ; final Mode mode = stylesheet . getMode ( _modeName ) ; _functionName = mode . functionName ( minPrecedence , maxPrecedence ) ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Stylesheet stylesheet = classGen . getStylesheet ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; int init = cpg . addMethodref ( SINGLETON_ITERATOR , "<init>" , "(" + NODE_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( SINGLETON_ITERATOR ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; il . append ( methodGen . loadHandler ( ) ) ; final String className = classGen . getStylesheet ( ) . getClassName ( ) ; final String signature = classGen . getApplyTemplatesSig ( ) ; final int applyTemplates = cpg . addMethodref ( className , _functionName , signature ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; } } 	0	['7', '3', '0', '21', '48', '17', '0', '21', '5', '0.888888889', '237', '1', '1', '0.903225806', '0.30952381', '1', '4', '32.42857143', '6', '1.7143', '0']
package org . apache . xml . dtm ; public interface Axis { public static final int ANCESTOR = 0 ; public static final int ANCESTORORSELF = 1 ; public static final int ATTRIBUTE = 2 ; public static final int CHILD = 3 ; public static final int DESCENDANT = 4 ; public static final int DESCENDANTORSELF = 5 ; public static final int FOLLOWING = 6 ; public static final int FOLLOWINGSIBLING = 7 ; public static final int NAMESPACEDECLS = 8 ; public static final int NAMESPACE = 9 ; public static final int PARENT = 10 ; public static final int PRECEDING = 11 ; public static final int PRECEDINGSIBLING = 12 ; public static final int SELF = 13 ; public static final int ALLFROMNODE = 14 ; public static final int PRECEDINGANDANCESTOR = 15 ; public static final int ALL = 16 ; public static final int DESCENDANTSFROMROOT = 17 ; public static final int DESCENDANTSORSELFFROMROOT = 18 ; public static final int ROOT = 19 ; public static final int FILTEREDLIST = 20 ; public static final String [ ] names = { "ancestor" , "ancestor-or-self" , "attribute" , "child" , "descendant" , "descendant-or-self" , "following" , "following-sibling" , "namespace-decls" , "namespace" , "parent" , "preceding" , "preceding-sibling" , "self" , "all-from-node" , "preceding-and-ancestor" , "all" , "descendants-from-root" , "descendants-or-self-from-root" , "root" , "filtered-list" } ; } 	0	['1', '1', '0', '4', '1', '0', '4', '0', '0', '2', '111', '0', '0', '0', '0', '0', '0', '88', '0', '0', '0']
package org . apache . xalan . processor ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemAttributeSet ; import org . apache . xalan . templates . ElemTemplateElement ; import org . xml . sax . Attributes ; class ProcessorAttributeSet extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { ElemAttributeSet eat = new ElemAttributeSet ( ) ; eat . setLocaterInfo ( handler . getLocator ( ) ) ; try { eat . setPrefixes ( handler . getNamespaceSupport ( ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } eat . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , eat ) ; handler . getStylesheet ( ) . setAttributeSet ( eat ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( eat ) ; handler . pushElemTemplateElement ( eat ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { handler . popElemTemplateElement ( ) ; } } 	0	['3', '4', '0', '7', '19', '3', '1', '6', '2', '2', '54', '0', '0', '0.990566038', '0.666666667', '2', '3', '17', '1', '0.6667', '0']
package org . apache . xalan . templates ; import org . apache . xpath . XPath ; public class WhiteSpaceInfo extends ElemTemplate { private boolean m_shouldStripSpace ; public boolean getShouldStripSpace ( ) { return m_shouldStripSpace ; } public WhiteSpaceInfo ( Stylesheet thisSheet ) { setStylesheet ( thisSheet ) ; } public WhiteSpaceInfo ( XPath matchPattern , boolean shouldStripSpace , Stylesheet thisSheet ) { m_shouldStripSpace = shouldStripSpace ; setMatch ( matchPattern ) ; setStylesheet ( thisSheet ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeWhiteSpaceInfo ( this ) ; } } 	0	['4', '4', '1', '9', '8', '4', '7', '4', '4', '0.666666667', '30', '1', '0', '0.99086758', '0.45', '0', '0', '6.25', '1', '0.5', '0']
package org . apache . xalan . xsltc . cmdline . getopt ; import java . util . ArrayList ; import java . util . List ; import java . util . ListIterator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; public class GetOpt { public GetOpt ( String [ ] args , String optString ) { theOptions = new ArrayList ( ) ; int currOptIndex = 0 ; theCmdArgs = new ArrayList ( ) ; theOptionMatcher = new OptionMatcher ( optString ) ; for ( int i = 0 ; i < args . length ; i ++ ) { String token = args [ i ] ; int tokenLength = token . length ( ) ; if ( token . equals ( "--" ) ) { currOptIndex = i + 1 ; break ; } else if ( token . startsWith ( "-" ) && tokenLength == 2 ) { theOptions . add ( new Option ( token . charAt ( 1 ) ) ) ; } else if ( token . startsWith ( "-" ) && tokenLength > 2 ) { for ( int j = 1 ; j < tokenLength ; j ++ ) { theOptions . add ( new Option ( token . charAt ( j ) ) ) ; } } else if ( ! token . startsWith ( "-" ) ) { if ( theOptions . size ( ) == 0 ) { currOptIndex = i ; break ; } else { int indexoflast = 0 ; indexoflast = theOptions . size ( ) - 1 ; Option op = ( Option ) theOptions . get ( indexoflast ) ; char opLetter = op . getArgLetter ( ) ; if ( ! op . hasArg ( ) && theOptionMatcher . hasArg ( opLetter ) ) { op . setArg ( token ) ; } else { currOptIndex = i ; break ; } } } } theOptionsIterator = theOptions . listIterator ( ) ; for ( int i = currOptIndex ; i < args . length ; i ++ ) { String token = args [ i ] ; theCmdArgs . add ( token ) ; } } public void printOptions ( ) { for ( ListIterator it = theOptions . listIterator ( ) ; it . hasNext ( ) ; ) { Option opt = ( Option ) it . next ( ) ; System . out . print ( "OPT =" + opt . getArgLetter ( ) ) ; String arg = opt . getArgument ( ) ; if ( arg != null ) { System . out . print ( " " + arg ) ; } System . out . println ( ) ; } } public int getNextOption ( ) throws IllegalArgumentException , MissingOptArgException { int retval = - 1 ; if ( theOptionsIterator . hasNext ( ) ) { theCurrentOption = ( Option ) theOptionsIterator . next ( ) ; char c = theCurrentOption . getArgLetter ( ) ; boolean shouldHaveArg = theOptionMatcher . hasArg ( c ) ; String arg = theCurrentOption . getArgument ( ) ; if ( ! theOptionMatcher . match ( c ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , new Character ( c ) ) ; throw ( new IllegalArgumentException ( msg . toString ( ) ) ) ; } else if ( shouldHaveArg && ( arg == null ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , new Character ( c ) ) ; throw ( new MissingOptArgException ( msg . toString ( ) ) ) ; } retval = c ; } return retval ; } public String getOptionArg ( ) { String retval = null ; String tmp = theCurrentOption . getArgument ( ) ; char c = theCurrentOption . getArgLetter ( ) ; if ( theOptionMatcher . hasArg ( c ) ) { retval = tmp ; } return retval ; } public String [ ] getCmdArgs ( ) { String [ ] retval = new String [ theCmdArgs . size ( ) ] ; int i = 0 ; for ( ListIterator it = theCmdArgs . listIterator ( ) ; it . hasNext ( ) ; ) { retval [ i ++ ] = ( String ) it . next ( ) ; } return retval ; } private Option theCurrentOption = null ; private ListIterator theOptionsIterator ; private List theOptions = null ; private List theCmdArgs = null ; private OptionMatcher theOptionMatcher = null ; class Option { private char theArgLetter ; private String theArgument = null ; public Option ( char argLetter ) { theArgLetter = argLetter ; } public void setArg ( String arg ) { theArgument = arg ; } public boolean hasArg ( ) { return ( theArgument != null ) ; } public char getArgLetter ( ) { return theArgLetter ; } public String getArgument ( ) { return theArgument ; } } class OptionMatcher { public OptionMatcher ( String optString ) { theOptString = optString ; } public boolean match ( char c ) { boolean retval = false ; if ( theOptString . indexOf ( c ) != - 1 ) { retval = true ; } return retval ; } public boolean hasArg ( char c ) { boolean retval = false ; int index = theOptString . indexOf ( c ) + 1 ; if ( index == theOptString . length ( ) ) { retval = false ; } else if ( theOptString . charAt ( index ) == ':' ) { retval = true ; } return retval ; } private String theOptString = null ; } } 	0	['5', '1', '0', '6', '36', '0', '3', '5', '5', '0.65', '330', '1', '2', '0', '0.466666667', '0', '0', '64', '3', '1.6', '0']
package org . apache . xml . res ; public class XMLErrorResources_it extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Funzione non supportata" } , { ER_CANNOT_OVERWRITE_CAUSE , "Impossibile sovrascrivere la causa." } , { ER_NO_DEFAULT_IMPL , "Non è stata trovata alcuna implementazione predefinita " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) non è correntemente supportato." } , { ER_OFFSET_BIGGER_THAN_SLOT , "L'offset è maggiore dello slot." } , { ER_COROUTINE_NOT_AVAIL , "Coroutine non disponibile, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager ha ricevuto una richiesta co_exit()." } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() non riuscito." } , { ER_COROUTINE_PARAM , "Errore del parametro di coroutine ({0})." } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: Risposte doTerminate del parser {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "Impossibile chiamare l'analisi mentre è in esecuzione." } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Errore: tipo di iteratore per l'asse {0} non implementato." } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Errore: l'iteratore per l'asse {0} non è implementato. " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Il duplicato dell'iteratore non è supportato." } , { ER_UNKNOWN_AXIS_TYPE , "Tipo di asse trasversale sconosciuto : {0}." } , { ER_AXIS_NOT_SUPPORTED , "Attraversatore dell'asse non supportato: {0}" } , { ER_NO_DTMIDS_AVAIL , "Non sono più disponibili ID DTM." } , { ER_NOT_SUPPORTED , "Non supportato: {0}" } , { ER_NODE_NON_NULL , "Il nodo deve essere non nullo per getDTMHandleFromNode." } , { ER_COULD_NOT_RESOLVE_NODE , "Impossibile risolvere il nodo a un handle" } , { ER_STARTPARSE_WHILE_PARSING , "Impossibile chiamare startParse durante l'analisi." } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse richiede un SAXParser non nullo." } , { ER_COULD_NOT_INIT_PARSER , "Impossibile inizializzare il parser con" } , { ER_EXCEPTION_CREATING_POOL , "l'eccezione crea una nuova istanza del pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Il percorso contiene una sequenza di escape non valida." } , { ER_SCHEME_REQUIRED , "Lo schema è necessario." } , { ER_NO_SCHEME_IN_URI , "Nessuno schema trovato nell'URI: {0}" } , { ER_NO_SCHEME_INURI , "Nessuno schema trovato nell'URI" } , { ER_PATH_INVALID_CHAR , "Il percorso contiene un carattere non valido: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Impossibile impostare lo schema da una stringa nulla." } , { ER_SCHEME_NOT_CONFORMANT , "Lo schema non è conforme." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "L'host non è un indirizzo corretto." } , { ER_PORT_WHEN_HOST_NULL , "Impossibile impostare la porta quando l'host è nullo." } , { ER_INVALID_PORT , "Numero di porta non valido" } , { ER_FRAG_FOR_GENERIC_URI , "È possibile impostare il frammento solo per un URI generico." } , { ER_FRAG_WHEN_PATH_NULL , "Impossibile impostare il frammento quando il percorso è nullo." } , { ER_FRAG_INVALID_CHAR , "Il frammento contiene un carattere non valido." } , { ER_PARSER_IN_USE , "Il parser è già in uso." } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Impossibile cambiare {0} {1} durante l'analisi." } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Non è consentito essere causa ed effetto contemporaneamente." } , { ER_NO_USERINFO_IF_NO_HOST , "Impossibile specificare Userinfo se non è specificato l'host." } , { ER_NO_PORT_IF_NO_HOST , "Impossibile specificare la porta se non è specificato l'host." } , { ER_NO_QUERY_STRING_IN_PATH , "La stringa di query non può essere specificata nella stringa di percorso e di query." } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Il frammento non può essere specificato sia nel percorso sia nel frammento." } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Impossibile inizializzare l'URI con parametri vuoti." } , { ER_METHOD_NOT_SUPPORTED , "Metodo non ancora supportato. " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter non correntemente riavviabile." } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader non prima della richiesta startParse." } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Secante asse non supportata: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler creato con PrintWriter nullo." } , { ER_SYSTEMID_UNKNOWN , "ID sistema sconosciuto" } , { ER_LOCATION_UNKNOWN , "Ubicazione errore sconosciuta" } , { ER_PREFIX_MUST_RESOLVE , "Il prefisso deve risolvere in namespace: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() non supportato in XPathContext." } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "L'elemento secondario dell'attributo non ha un documento di proprietà." } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "L'elemento secondario dell'attributo non ha un elemento del documento di proprietà." } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Avvertenza: impossibile generare un output di testo prima dell'elemento documento. Richiesta ignorata..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Impossibile avere più di una root su un DOM." } , { ER_ARG_LOCALNAME_NULL , "L'argomento 'localName' è nullo" } , { ER_ARG_LOCALNAME_INVALID , "Localname in QNAME deve essere un NCName valido" } , { ER_ARG_PREFIX_INVALID , "Prefisso in QNAME deve essere un NCName valido" } , { "BAD_CODE" , "I parametri di createMessage sono esterni ai limiti" } , { "FORMAT_FAILED" , "Eccezione generata durante la chiamata di messageFormat" } , { "line" , "Linea #" } , { "column" , "Colonna #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '0']
package org . apache . xml . res ; public class XMLErrorResources_ja extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Function はサポートされません。" } , { ER_CANNOT_OVERWRITE_CAUSE , "cause を上書きできません" } , { ER_NO_DEFAULT_IMPL , "デフォルト実装が見つかりません" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) は現在サポートされていません" } , { ER_OFFSET_BIGGER_THAN_SLOT , "スロットよりも大きいオフセット" } , { ER_COROUTINE_NOT_AVAIL , "コルーチンは無効です。id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager は co_exit() 要求を受け取りました" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() は失敗しました" } , { ER_COROUTINE_PARAM , "コルーチンパラメータエラー ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: パーサ doTerminate の答え {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "構文解析中に parse を呼び出すことはできません" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "エラー: 入力された軸の反復子 {0} は実装されていません" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "エラー: 軸の反復子 {0} は実装されていません" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "反復子クローンはサポートされていません" } , { ER_UNKNOWN_AXIS_TYPE , "未知の軸トラバーサルタイプ: {0}" } , { ER_AXIS_NOT_SUPPORTED , "軸トラバーサルはサポートされません: {0}" } , { ER_NO_DTMIDS_AVAIL , "これ以上の DTM ID は無効です" } , { ER_NOT_SUPPORTED , "サポートされません: {0}" } , { ER_NODE_NON_NULL , "getDTMHandleFromNode のノードは null 以外でなくてはなりません" } , { ER_COULD_NOT_RESOLVE_NODE , "ノードをハンドルに変えることができませんでした" } , { ER_STARTPARSE_WHILE_PARSING , "構文解析中に startParse を呼び出すことはできません" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse は null でない SAXParser を必要とします" } , { ER_COULD_NOT_INIT_PARSER , "パーサを初期化できませんでした" } , { ER_EXCEPTION_CREATING_POOL , "例外によりプールに新しいインスタンスを作成しています" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "パスに無効なエスケープシーケンスが含まれています" } , { ER_SCHEME_REQUIRED , "スキーマが必要です。" } , { ER_NO_SCHEME_IN_URI , "URI にスキーマがありません: {0}" } , { ER_NO_SCHEME_INURI , "URI にスキーマがありません" } , { ER_PATH_INVALID_CHAR , "パスに無効な文字列が含まれています: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "null 文字列からスキーマを設定できません" } , { ER_SCHEME_NOT_CONFORMANT , "スキーマが一致しません。" } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "ホストが正しい形式のアドレスではありません" } , { ER_PORT_WHEN_HOST_NULL , "ホストが null のとき、ポートを設定できません" } , { ER_INVALID_PORT , "無効なポート番号" } , { ER_FRAG_FOR_GENERIC_URI , "汎用 URI に対してのみフラグメントを設定できます" } , { ER_FRAG_WHEN_PATH_NULL , "パスが null のとき、フラグメントを設定できません" } , { ER_FRAG_INVALID_CHAR , "フラグメントに無効な文字列が含まれています" } , { ER_PARSER_IN_USE , "パーサはすでに使われています" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "構文解析中、{0} {1} を変更できません" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "自身が原因となってはなりません" } , { ER_NO_USERINFO_IF_NO_HOST , "ホストが指定されていないとき、Userinfo を指定できません" } , { ER_NO_PORT_IF_NO_HOST , "ホストが指定されていないとき、Port を指定できません" } , { ER_NO_QUERY_STRING_IN_PATH , "パスおよび照会文字列で Query 文字列は指定できません" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "パスおよびフラグメントの両方で、Fragment は指定できません" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "空のパラメータを使って URI を初期化できません" } , { ER_METHOD_NOT_SUPPORTED , "メソッドはまだサポートされていません" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter は現在再起動できません" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader は startParse 要求より前に配置できません" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "▼軸トラバーサルはサポートされません: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "▼ListingErrorHandler の作成時に null PrintWriter が指定されました!" } , { ER_SYSTEMID_UNKNOWN , "▼システム ID が不明です" } , { ER_LOCATION_UNKNOWN , "▼エラーの場所が不明です" } , { ER_PREFIX_MUST_RESOLVE , "接頭辞は名前空間に変える必要があります: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() は XPathContext でサポートされていません。" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "属性 child は所有者ドキュメントを保持していません。" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "属性 child は所有者ドキュメント要素を保持していません。" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "警告: ドキュメント要素より前にテキストを出力できません。無視します..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "DOM には複数のルートを保持できません。" } , { ER_ARG_LOCALNAME_NULL , "引数 'localName' が null です" } , { ER_ARG_LOCALNAME_INVALID , "▼QNAME 内のローカル名は有効な NCName でなければなりません" } , { ER_ARG_PREFIX_INVALID , "▼QNAME 内の接頭辞は有効な NCName でなければなりません" } , { "BAD_CODE" , "createMessage のパラメータが範囲外でした" } , { "FORMAT_FAILED" , "messageFormat 呼び出しで例外がスローされました" } , { "line" , "行番号" } , { "column" , "列番号" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '0']
package org . apache . xml . serializer ; import javax . xml . transform . Transformer ; import org . w3c . dom . Node ; public interface TransformStateSetter { void setCurrentNode ( Node n ) ; void resetState ( Transformer transformer ) ; } 	0	['2', '1', '0', '4', '2', '1', '4', '0', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . compiler ; import org . apache . xpath . Expression ; import org . apache . xpath . functions . Function ; public class FunctionTable { public static final int FUNC_CURRENT = 0 ; public static final int FUNC_LAST = 1 ; public static final int FUNC_POSITION = 2 ; public static final int FUNC_COUNT = 3 ; public static final int FUNC_ID = 4 ; public static final int FUNC_KEY = 5 ; public static final int FUNC_LOCAL_PART = 7 ; public static final int FUNC_NAMESPACE = 8 ; public static final int FUNC_QNAME = 9 ; public static final int FUNC_GENERATE_ID = 10 ; public static final int FUNC_NOT = 11 ; public static final int FUNC_TRUE = 12 ; public static final int FUNC_FALSE = 13 ; public static final int FUNC_BOOLEAN = 14 ; public static final int FUNC_NUMBER = 15 ; public static final int FUNC_FLOOR = 16 ; public static final int FUNC_CEILING = 17 ; public static final int FUNC_ROUND = 18 ; public static final int FUNC_SUM = 19 ; public static final int FUNC_STRING = 20 ; public static final int FUNC_STARTS_WITH = 21 ; public static final int FUNC_CONTAINS = 22 ; public static final int FUNC_SUBSTRING_BEFORE = 23 ; public static final int FUNC_SUBSTRING_AFTER = 24 ; public static final int FUNC_NORMALIZE_SPACE = 25 ; public static final int FUNC_TRANSLATE = 26 ; public static final int FUNC_CONCAT = 27 ; public static final int FUNC_SUBSTRING = 29 ; public static final int FUNC_STRING_LENGTH = 30 ; public static final int FUNC_SYSTEM_PROPERTY = 31 ; public static final int FUNC_LANG = 32 ; public static final int FUNC_EXT_FUNCTION_AVAILABLE = 33 ; public static final int FUNC_EXT_ELEM_AVAILABLE = 34 ; public static final int FUNC_UNPARSED_ENTITY_URI = 36 ; public static final int FUNC_DOCLOCATION = 35 ; public static FuncLoader m_functions [ ] ; private static final int NUM_BUILT_IN_FUNCS = 37 ; private static final int NUM_ALLOWABLE_ADDINS = 30 ; static int m_funcNextFreeIndex = NUM_BUILT_IN_FUNCS ; static { m_functions = new FuncLoader [ NUM_BUILT_IN_FUNCS + NUM_ALLOWABLE_ADDINS ] ; m_functions [ FUNC_CURRENT ] = new FuncLoader ( "FuncCurrent" , FUNC_CURRENT ) ; m_functions [ FUNC_LAST ] = new FuncLoader ( "FuncLast" , FUNC_LAST ) ; m_functions [ FUNC_POSITION ] = new FuncLoader ( "FuncPosition" , FUNC_POSITION ) ; m_functions [ FUNC_COUNT ] = new FuncLoader ( "FuncCount" , FUNC_COUNT ) ; m_functions [ FUNC_ID ] = new FuncLoader ( "FuncId" , FUNC_ID ) ; m_functions [ FUNC_KEY ] = new FuncLoader ( "org.apache.xalan.templates.FuncKey" , FUNC_KEY ) ; m_functions [ FUNC_LOCAL_PART ] = new FuncLoader ( "FuncLocalPart" , FUNC_LOCAL_PART ) ; m_functions [ FUNC_NAMESPACE ] = new FuncLoader ( "FuncNamespace" , FUNC_NAMESPACE ) ; m_functions [ FUNC_QNAME ] = new FuncLoader ( "FuncQname" , FUNC_QNAME ) ; m_functions [ FUNC_GENERATE_ID ] = new FuncLoader ( "FuncGenerateId" , FUNC_GENERATE_ID ) ; m_functions [ FUNC_NOT ] = new FuncLoader ( "FuncNot" , FUNC_NOT ) ; m_functions [ FUNC_TRUE ] = new FuncLoader ( "FuncTrue" , FUNC_TRUE ) ; m_functions [ FUNC_FALSE ] = new FuncLoader ( "FuncFalse" , FUNC_FALSE ) ; m_functions [ FUNC_BOOLEAN ] = new FuncLoader ( "FuncBoolean" , FUNC_BOOLEAN ) ; m_functions [ FUNC_LANG ] = new FuncLoader ( "FuncLang" , FUNC_LANG ) ; m_functions [ FUNC_NUMBER ] = new FuncLoader ( "FuncNumber" , FUNC_NUMBER ) ; m_functions [ FUNC_FLOOR ] = new FuncLoader ( "FuncFloor" , FUNC_FLOOR ) ; m_functions [ FUNC_CEILING ] = new FuncLoader ( "FuncCeiling" , FUNC_CEILING ) ; m_functions [ FUNC_ROUND ] = new FuncLoader ( "FuncRound" , FUNC_ROUND ) ; m_functions [ FUNC_SUM ] = new FuncLoader ( "FuncSum" , FUNC_SUM ) ; m_functions [ FUNC_STRING ] = new FuncLoader ( "FuncString" , FUNC_STRING ) ; m_functions [ FUNC_STARTS_WITH ] = new FuncLoader ( "FuncStartsWith" , FUNC_STARTS_WITH ) ; m_functions [ FUNC_CONTAINS ] = new FuncLoader ( "FuncContains" , FUNC_CONTAINS ) ; m_functions [ FUNC_SUBSTRING_BEFORE ] = new FuncLoader ( "FuncSubstringBefore" , FUNC_SUBSTRING_BEFORE ) ; m_functions [ FUNC_SUBSTRING_AFTER ] = new FuncLoader ( "FuncSubstringAfter" , FUNC_SUBSTRING_AFTER ) ; m_functions [ FUNC_NORMALIZE_SPACE ] = new FuncLoader ( "FuncNormalizeSpace" , FUNC_NORMALIZE_SPACE ) ; m_functions [ FUNC_TRANSLATE ] = new FuncLoader ( "FuncTranslate" , FUNC_TRANSLATE ) ; m_functions [ FUNC_CONCAT ] = new FuncLoader ( "FuncConcat" , FUNC_CONCAT ) ; m_functions [ FUNC_SYSTEM_PROPERTY ] = new FuncLoader ( "FuncSystemProperty" , FUNC_SYSTEM_PROPERTY ) ; m_functions [ FUNC_EXT_FUNCTION_AVAILABLE ] = new FuncLoader ( "FuncExtFunctionAvailable" , FUNC_EXT_FUNCTION_AVAILABLE ) ; m_functions [ FUNC_EXT_ELEM_AVAILABLE ] = new FuncLoader ( "FuncExtElementAvailable" , FUNC_EXT_ELEM_AVAILABLE ) ; m_functions [ FUNC_SUBSTRING ] = new FuncLoader ( "FuncSubstring" , FUNC_SUBSTRING ) ; m_functions [ FUNC_STRING_LENGTH ] = new FuncLoader ( "FuncStringLength" , FUNC_STRING_LENGTH ) ; m_functions [ FUNC_DOCLOCATION ] = new FuncLoader ( "FuncDoclocation" , FUNC_DOCLOCATION ) ; m_functions [ FUNC_UNPARSED_ENTITY_URI ] = new FuncLoader ( "FuncUnparsedEntityURI" , FUNC_UNPARSED_ENTITY_URI ) ; } public static Function getFunction ( int which ) throws javax . xml . transform . TransformerException { return m_functions [ which ] . getFunction ( ) ; } public static int installFunction ( String name , Expression func ) { int funcIndex ; Object funcIndexObj = Keywords . m_functions . get ( name ) ; if ( null != funcIndexObj ) { funcIndex = ( ( Integer ) funcIndexObj ) . intValue ( ) ; } else { funcIndex = m_funcNextFreeIndex ; m_funcNextFreeIndex ++ ; Keywords . m_functions . put ( name , new Integer ( funcIndex ) ) ; } FuncLoader loader = new FuncLoader ( func . getClass ( ) . getName ( ) , funcIndex ) ; m_functions [ funcIndex ] = loader ; return funcIndex ; } public static void installFunction ( Expression func , int funcIndex ) { FuncLoader loader = new FuncLoader ( func . getClass ( ) . getName ( ) , funcIndex ) ; m_functions [ funcIndex ] = loader ; } } 	0	['5', '1', '0', '7', '14', '0', '3', '4', '4', '1.211538462', '391', '0.051282051', '1', '0', '0.375', '0', '0', '69.4', '2', '0.8', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemVariable ; class ProcessorGlobalVariableDecl extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { handler . pushElemTemplateElement ( elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ElemVariable v = ( ElemVariable ) handler . getElemTemplateElement ( ) ; handler . getStylesheet ( ) . appendChild ( v ) ; handler . getStylesheet ( ) . setVariable ( v ) ; super . endElement ( handler , uri , localName , rawName ) ; } } 	0	['3', '5', '0', '6', '10', '3', '1', '5', '1', '2', '30', '0', '0', '0.990697674', '0.583333333', '1', '2', '9', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class FilterGenerator extends ClassGenerator { private static int TRANSLET_INDEX = 5 ; private final Instruction _aloadTranslet ; public FilterGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; _aloadTranslet = new ALOAD ( TRANSLET_INDEX ) ; } public final Instruction loadTranslet ( ) { return _aloadTranslet ; } public boolean isExternal ( ) { return true ; } } 	0	['4', '4', '0', '6', '6', '2', '2', '4', '3', '0.666666667', '29', '1', '0', '0.975903614', '0.466666667', '0', '0', '5.75', '1', '0.5', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . w3c . dom . Node ; public class DTMChildIterNodeList extends DTMNodeListBase { private int m_firstChild ; private DTM m_parentDTM ; private DTMChildIterNodeList ( ) { } public DTMChildIterNodeList ( DTM parentDTM , int parentHandle ) { m_parentDTM = parentDTM ; m_firstChild = parentDTM . getFirstChild ( parentHandle ) ; } public Node item ( int index ) { int handle = m_firstChild ; while ( -- index >= 0 && handle != DTM . NULL ) { handle = m_parentDTM . getNextSibling ( handle ) ; } if ( handle == DTM . NULL ) { return null ; } return m_parentDTM . getNode ( handle ) ; } public int getLength ( ) { int count = 0 ; for ( int handle = m_firstChild ; handle != DTM . NULL ; handle = m_parentDTM . getNextSibling ( handle ) ) { ++ count ; } return count ; } } 	0	['4', '2', '0', '3', '8', '0', '1', '2', '3', '0.333333333', '62', '1', '1', '0.5', '0.583333333', '0', '0', '14', '4', '1.5', '0']
package org . apache . xml . dtm . ref ; public class DTMSafeStringPool extends DTMStringPool { public synchronized void removeAllElements ( ) { super . removeAllElements ( ) ; } public synchronized String indexToString ( int i ) throws java . lang . ArrayIndexOutOfBoundsException { return super . indexToString ( i ) ; } public synchronized int stringToIndex ( String s ) { return super . stringToIndex ( s ) ; } public static void main ( String [ ] args ) { String [ ] word = { "Zero" , "One" , "Two" , "Three" , "Four" , "Five" , "Six" , "Seven" , "Eight" , "Nine" , "Ten" , "Eleven" , "Twelve" , "Thirteen" , "Fourteen" , "Fifteen" , "Sixteen" , "Seventeen" , "Eighteen" , "Nineteen" , "Twenty" , "Twenty-One" , "Twenty-Two" , "Twenty-Three" , "Twenty-Four" , "Twenty-Five" , "Twenty-Six" , "Twenty-Seven" , "Twenty-Eight" , "Twenty-Nine" , "Thirty" , "Thirty-One" , "Thirty-Two" , "Thirty-Three" , "Thirty-Four" , "Thirty-Five" , "Thirty-Six" , "Thirty-Seven" , "Thirty-Eight" , "Thirty-Nine" } ; DTMStringPool pool = new DTMSafeStringPool ( ) ; System . out . println ( "If no complaints are printed below, we passed initial test." ) ; for ( int pass = 0 ; pass <= 1 ; ++ pass ) { int i ; for ( i = 0 ; i < word . length ; ++ i ) { int j = pool . stringToIndex ( word [ i ] ) ; if ( j != i ) System . out . println ( "\tMismatch populating pool: assigned " + j + " for create " + i ) ; } for ( i = 0 ; i < word . length ; ++ i ) { int j = pool . stringToIndex ( word [ i ] ) ; if ( j != i ) System . out . println ( "\tMismatch in stringToIndex: returned " + j + " for lookup " + i ) ; } for ( i = 0 ; i < word . length ; ++ i ) { String w = pool . indexToString ( i ) ; if ( ! word [ i ] . equals ( w ) ) System . out . println ( "\tMismatch in indexToString: returned" + w + " for lookup " + i ) ; } pool . removeAllElements ( ) ; System . out . println ( "\nPass " + pass + " complete\n" ) ; } } } 	0	['5', '2', '0', '1', '15', '10', '0', '1', '5', '2', '305', '0', '0', '0.5', '0.35', '2', '5', '60', '8', '2.2', '0']
package org . apache . xml . res ; public class XMLErrorResources_fr extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Fonction non prise en charge !" } , { ER_CANNOT_OVERWRITE_CAUSE , "Impossible d’écraser la cause" } , { ER_NO_DEFAULT_IMPL , "Aucune mise en œuvre par défaut trouvée" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) non pris en charge pour le moment" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Impression plus importante que l’emplacement" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine indisponible, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager a reçu une requête co_exit()" } , { ER_COJOINROUTINESET_FAILED , "Echec de co_joinCoroutineSet()" } , { ER_COROUTINE_PARAM , "Erreur de paramètre Coroutine ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: Réponses de Parser doTerminate {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse ne peut pas être appelé pendant l’opération d’analyse" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Erreur : l’itérateur saisi pour l’axe {0} n’est pas mis en oeuvre" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Erreur : l’itérateur pour l’axe {0} n’est pas mis en oeuvre " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Clone d’itérateur non pris en charge" } , { ER_UNKNOWN_AXIS_TYPE , "Type d’axe transversal inconnu : {0}" } , { ER_AXIS_NOT_SUPPORTED , "Axe transversal non pris en charge : {0}" } , { ER_NO_DTMIDS_AVAIL , "Aucun ID DTM disponible" } , { ER_NOT_SUPPORTED , "Non pris en charge : {0}" } , { ER_NODE_NON_NULL , "Le nœud ne doit pas être vide pour getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Impossible de résoudre le noeud en descripteur" } , { ER_STARTPARSE_WHILE_PARSING , "startParse ne peut pas être appelé pendant l’analyse" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse requiert un SAXParser non vide" } , { ER_COULD_NOT_INIT_PARSER , "Impossible d’initialiser l’analyseur avec" } , { ER_EXCEPTION_CREATING_POOL , "Exception de création d’une nouvelle instance pour le pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Le chemin contient une séquence de remplacement incorrecte" } , { ER_SCHEME_REQUIRED , "Le modèle est requis !" } , { ER_NO_SCHEME_IN_URI , "Aucun modèle trouvé dans l’URI : {0}" } , { ER_NO_SCHEME_INURI , "Aucun modèle trouvé dans l’URI" } , { ER_PATH_INVALID_CHAR , "Le chemin contient des caractères incorrects : {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Impossible de définir le modèle à partir d’une chaîne vide" } , { ER_SCHEME_NOT_CONFORMANT , "Le modèle n’est pas conforme." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "L’hôte n’est pas constitué d’une adresse bien formée" } , { ER_PORT_WHEN_HOST_NULL , "Le port ne peut pas être défini lorsque l’hôte est vide" } , { ER_INVALID_PORT , "Numéro de port incorrect" } , { ER_FRAG_FOR_GENERIC_URI , "Le fragment ne peut être défini que pour un URI générique" } , { ER_FRAG_WHEN_PATH_NULL , "Le fragment ne peut pas être défini lorsque le chemin est vide" } , { ER_FRAG_INVALID_CHAR , "Le fragment contient des caractères incorrects" } , { ER_PARSER_IN_USE , "L’analyseur est déjà en cours d’utilisation" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Impossible de modifier {0} {1} pendant la phase d’analyse" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Lien de causalité vers soi impossible" } , { ER_NO_USERINFO_IF_NO_HOST , "Les informations sur l'utilisateur ne peuvent pas être spécifiées si l’hôte n’est pas spécifié" } , { ER_NO_PORT_IF_NO_HOST , "Le port ne peut pas être spécifié si l’hôte n’est pas spécifié" } , { ER_NO_QUERY_STRING_IN_PATH , "La chaîne de requête ne peut pas être spécifiée dans le chemin et dans la chaîne de requête" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Le fragment ne peut pas être spécifié dans le chemin et dans le fragment" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Impossible d’initialiser l’URI avec des paramètres vides" } , { ER_METHOD_NOT_SUPPORTED , "Méthode non prise en charge pour le moment" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter ne peut pas être relancé pour le moment" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader pas avant la requête startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "La coupure d'axe n'est pas prise en charge : {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler a été créé avec PrintWriter nul !" } , { ER_SYSTEMID_UNKNOWN , "SystemId inconnu" } , { ER_LOCATION_UNKNOWN , "Emplacement de l'erreur inconnu" } , { ER_PREFIX_MUST_RESOLVE , "Le préfixe doit se résoudre en nom d''espace : {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() non pris en charge dans XpathContext !" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "L’attribut child n’a pas de document propriétaire !" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "L’attribute child n’a pas d’élément de document propriétaire !" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Attention : impossible de sortir le texte avant l’élément document !  Opération ignorée ..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Impossible d’avoir plus d’une racine sur un DOM !" } , { ER_ARG_LOCALNAME_NULL , "L’argument 'localName' est égal à null" } , { ER_ARG_LOCALNAME_INVALID , "Le nom local de QNAME doit être un NCName admis" } , { ER_ARG_PREFIX_INVALID , "Le préfixe de QNAME doit être un NCName admis" } , { "BAD_CODE" , "Paramètre pour createMessage hors limites" } , { "FORMAT_FAILED" , "Exception émise pendant l’appel de messageFormat " } , { "line" , "N° de ligne" } , { "column" , "N° de colonne" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class LogicalExpr extends Expression { public static final int OR = 0 ; public static final int AND = 1 ; private final int _op ; private Expression _left ; private Expression _right ; private static final String [ ] Ops = { "or" , "and" } ; public LogicalExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public boolean hasPositionCall ( ) { return ( _left . hasPositionCall ( ) || _right . hasPositionCall ( ) ) ; } public Object evaluateAtCompileTime ( ) { final Object leftb = _left . evaluateAtCompileTime ( ) ; final Object rightb = _right . evaluateAtCompileTime ( ) ; if ( leftb == null || rightb == null ) { return null ; } if ( _op == AND ) { return ( leftb == Boolean . TRUE && rightb == Boolean . TRUE ) ? Boolean . TRUE : Boolean . FALSE ; } else { return ( leftb == Boolean . TRUE || rightb == Boolean . TRUE ) ? Boolean . TRUE : Boolean . FALSE ; } } public int getOp ( ) { return ( _op ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public String toString ( ) { return Ops [ _op ] + '(' + _left + ", " + _right + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type tleft = _left . typeCheck ( stable ) ; Type tright = _right . typeCheck ( stable ) ; MethodType wantType = new MethodType ( Type . Void , tleft , tright ) ; MethodType haveType = lookupPrimop ( stable , Ops [ _op ] , wantType ) ; if ( haveType != null ) { Type arg1 = ( Type ) haveType . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) _left = new CastExpr ( _left , arg1 ) ; Type arg2 = ( Type ) haveType . argsType ( ) . elementAt ( 1 ) ; if ( ! arg2 . identicalTo ( tright ) ) _right = new CastExpr ( _right , arg1 ) ; return _type = haveType . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { translateDesynthesized ( classGen , methodGen ) ; synthesize ( classGen , methodGen ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; final SyntaxTreeNode parent = getParent ( ) ; if ( _op == AND ) { _left . translateDesynthesized ( classGen , methodGen ) ; InstructionHandle middle = il . append ( NOP ) ; _right . translateDesynthesized ( classGen , methodGen ) ; InstructionHandle after = il . append ( NOP ) ; _falseList . append ( _right . _falseList . append ( _left . _falseList ) ) ; if ( ( _left instanceof LogicalExpr ) && ( ( ( LogicalExpr ) _left ) . getOp ( ) == OR ) ) { _left . backPatchTrueList ( middle ) ; } else if ( _left instanceof NotCall ) { _left . backPatchTrueList ( middle ) ; } else { _trueList . append ( _left . _trueList ) ; } if ( ( _right instanceof LogicalExpr ) && ( ( ( LogicalExpr ) _right ) . getOp ( ) == OR ) ) { _right . backPatchTrueList ( after ) ; } else if ( _right instanceof NotCall ) { _right . backPatchTrueList ( after ) ; } else { _trueList . append ( _right . _trueList ) ; } } else { _left . translateDesynthesized ( classGen , methodGen ) ; InstructionHandle ih = il . append ( new GOTO ( null ) ) ; _right . translateDesynthesized ( classGen , methodGen ) ; _left . _trueList . backPatch ( ih ) ; _left . _falseList . backPatch ( ih . getNext ( ) ) ; _falseList . append ( _right . _falseList ) ; _trueList . add ( ih ) . append ( _right . _trueList ) ; } } } 	0	['10', '3', '0', '18', '41', '0', '0', '18', '9', '0.62962963', '362', '0.666666667', '2', '0.898734177', '0.26984127', '2', '9', '34.6', '8', '2.4', '0']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . WhiteSpaceInfo ; import org . apache . xpath . XPath ; import org . xml . sax . Attributes ; class ProcessorPreserveSpace extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { Stylesheet thisSheet = handler . getStylesheet ( ) ; WhitespaceInfoPaths paths = new WhitespaceInfoPaths ( thisSheet ) ; setPropertiesFromAttributes ( handler , rawName , attributes , paths ) ; Vector xpaths = paths . getElements ( ) ; for ( int i = 0 ; i < xpaths . size ( ) ; i ++ ) { WhiteSpaceInfo wsi = new WhiteSpaceInfo ( ( XPath ) xpaths . elementAt ( i ) , false , thisSheet ) ; wsi . setUid ( handler . nextUid ( ) ) ; thisSheet . setPreserveSpaces ( wsi ) ; } paths . clearElements ( ) ; } } 	0	['2', '4', '1', '9', '14', '1', '2', '7', '1', '2', '50', '0', '0', '0.995260664', '0.625', '2', '2', '24', '1', '0.5', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Plus extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) + right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_right . num ( xctxt ) + m_left . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class IntExpr extends Expression { private final int _value ; public IntExpr ( int value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . Int ; } public String toString ( ) { return "int-expr(" + _value + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0	['4', '3', '0', '11', '14', '0', '0', '11', '4', '0.333333333', '44', '1', '0', '0.959459459', '0.4', '2', '7', '9.75', '1', '0.75', '0']
package org . apache . xml . dtm . ref ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . xerces . parsers . SAXParser ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class IncrementalSAXSource_Xerces implements IncrementalSAXSource { Method fParseSomeSetup = null ; Method fParseSome = null ; Object fPullParserConfig = null ; Method fConfigSetInput = null ; Method fConfigParse = null ; Method fSetInputSource = null ; Constructor fConfigInputSourceCtor = null ; Method fConfigSetByteStream = null ; Method fConfigSetCharStream = null ; Method fConfigSetEncoding = null ; Method fReset = null ; SAXParser fIncrementalParser ; private boolean fParseInProgress = false ; public IncrementalSAXSource_Xerces ( ) throws NoSuchMethodException { try { Class me = this . getClass ( ) ; Class xniConfigClass = Class . forName ( "org.apache.xerces.xni.parser.XMLParserConfiguration" ) ; Class [ ] args1 = { xniConfigClass } ; Constructor ctor = SAXParser . class . getConstructor ( args1 ) ; Class xniStdConfigClass = Class . forName ( "org.apache.xerces.parsers.StandardParserConfiguration" ) ; fPullParserConfig = xniStdConfigClass . newInstance ( ) ; Object [ ] args2 = { fPullParserConfig } ; fIncrementalParser = ( SAXParser ) ctor . newInstance ( args2 ) ; Class fXniInputSourceClass = Class . forName ( "org.apache.xerces.xni.parser.XMLInputSource" ) ; Class [ ] args3 = { fXniInputSourceClass } ; fConfigSetInput = xniStdConfigClass . getMethod ( "setInputSource" , args3 ) ; Class [ ] args4 = { String . class , String . class , String . class } ; fConfigInputSourceCtor = fXniInputSourceClass . getConstructor ( args4 ) ; Class [ ] args5 = { java . io . InputStream . class } ; fConfigSetByteStream = fXniInputSourceClass . getMethod ( "setByteStream" , args5 ) ; Class [ ] args6 = { java . io . Reader . class } ; fConfigSetCharStream = fXniInputSourceClass . getMethod ( "setCharacterStream" , args6 ) ; Class [ ] args7 = { String . class } ; fConfigSetEncoding = fXniInputSourceClass . getMethod ( "setEncoding" , args7 ) ; Class [ ] argsb = { Boolean . TYPE } ; fConfigParse = xniStdConfigClass . getMethod ( "parse" , argsb ) ; Class [ ] noargs = new Class [ 0 ] ; fReset = fIncrementalParser . getClass ( ) . getMethod ( "reset" , noargs ) ; } catch ( Exception e ) { IncrementalSAXSource_Xerces dummy = new IncrementalSAXSource_Xerces ( new SAXParser ( ) ) ; this . fParseSomeSetup = dummy . fParseSomeSetup ; this . fParseSome = dummy . fParseSome ; this . fIncrementalParser = dummy . fIncrementalParser ; } } public IncrementalSAXSource_Xerces ( SAXParser parser ) throws NoSuchMethodException { fIncrementalParser = parser ; Class me = parser . getClass ( ) ; Class [ ] parms = { InputSource . class } ; fParseSomeSetup = me . getMethod ( "parseSomeSetup" , parms ) ; parms = new Class [ 0 ] ; fParseSome = me . getMethod ( "parseSome" , parms ) ; } static public IncrementalSAXSource createIncrementalSAXSource ( ) { try { return new IncrementalSAXSource_Xerces ( ) ; } catch ( NoSuchMethodException e ) { IncrementalSAXSource_Filter iss = new IncrementalSAXSource_Filter ( ) ; iss . setXMLReader ( new SAXParser ( ) ) ; return iss ; } } static public IncrementalSAXSource createIncrementalSAXSource ( SAXParser parser ) { try { return new IncrementalSAXSource_Xerces ( parser ) ; } catch ( NoSuchMethodException e ) { IncrementalSAXSource_Filter iss = new IncrementalSAXSource_Filter ( ) ; iss . setXMLReader ( parser ) ; return iss ; } } public void setContentHandler ( org . xml . sax . ContentHandler handler ) { ( ( XMLReader ) fIncrementalParser ) . setContentHandler ( handler ) ; } public void setLexicalHandler ( org . xml . sax . ext . LexicalHandler handler ) { try { ( ( XMLReader ) fIncrementalParser ) . setProperty ( "http://xml.org/sax/properties/lexical-handler" , handler ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { } catch ( org . xml . sax . SAXNotSupportedException e ) { } } public void setDTDHandler ( org . xml . sax . DTDHandler handler ) { ( ( XMLReader ) fIncrementalParser ) . setDTDHandler ( handler ) ; } public void startParse ( InputSource source ) throws SAXException { if ( fIncrementalParser == null ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_STARTPARSE_NEEDS_SAXPARSER , null ) ) ; if ( fParseInProgress ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_STARTPARSE_WHILE_PARSING , null ) ) ; boolean ok = false ; try { ok = parseSomeSetup ( source ) ; } catch ( Exception ex ) { throw new SAXException ( ex ) ; } if ( ! ok ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_INIT_PARSER , null ) ) ; } public Object deliverMoreNodes ( boolean parsemore ) { if ( ! parsemore ) { fParseInProgress = false ; return Boolean . FALSE ; } Object arg ; try { boolean keepgoing = parseSome ( ) ; arg = keepgoing ? Boolean . TRUE : Boolean . FALSE ; } catch ( SAXException ex ) { arg = ex ; } catch ( IOException ex ) { arg = ex ; } catch ( Exception ex ) { arg = new SAXException ( ex ) ; } return arg ; } private boolean parseSomeSetup ( InputSource source ) throws SAXException , IOException , IllegalAccessException , java . lang . reflect . InvocationTargetException , java . lang . InstantiationException { if ( fConfigSetInput != null ) { Object [ ] parms1 = { source . getPublicId ( ) , source . getSystemId ( ) , null } ; Object xmlsource = fConfigInputSourceCtor . newInstance ( parms1 ) ; Object [ ] parmsa = { source . getByteStream ( ) } ; fConfigSetByteStream . invoke ( xmlsource , parmsa ) ; parmsa [ 0 ] = source . getCharacterStream ( ) ; fConfigSetCharStream . invoke ( xmlsource , parmsa ) ; parmsa [ 0 ] = source . getEncoding ( ) ; fConfigSetEncoding . invoke ( xmlsource , parmsa ) ; Object [ ] noparms = new Object [ 0 ] ; fReset . invoke ( fIncrementalParser , noparms ) ; parmsa [ 0 ] = xmlsource ; fConfigSetInput . invoke ( fPullParserConfig , parmsa ) ; return parseSome ( ) ; } else { Object [ ] parm = { source } ; Object ret = fParseSomeSetup . invoke ( fIncrementalParser , parm ) ; return ( ( Boolean ) ret ) . booleanValue ( ) ; } } static final Object [ ] noparms = new Object [ 0 ] ; static final Object [ ] parmsfalse = { Boolean . FALSE } ; private boolean parseSome ( ) throws SAXException , IOException , IllegalAccessException , java . lang . reflect . InvocationTargetException { if ( fConfigSetInput != null ) { Object ret = ( Boolean ) ( fConfigParse . invoke ( fPullParserConfig , parmsfalse ) ) ; return ( ( Boolean ) ret ) . booleanValue ( ) ; } else { Object ret = fParseSome . invoke ( fIncrementalParser , noparms ) ; return ( ( Boolean ) ret ) . booleanValue ( ) ; } } public static void main ( String args [ ] ) { System . out . println ( "Starting..." ) ; CoroutineManager co = new CoroutineManager ( ) ; int appCoroutineID = co . co_joinCoroutineSet ( - 1 ) ; if ( appCoroutineID == - 1 ) { System . out . println ( "ERROR: Couldn't allocate coroutine number.\n" ) ; return ; } IncrementalSAXSource parser = createIncrementalSAXSource ( ) ; org . apache . xml . serialize . XMLSerializer trace ; trace = new org . apache . xml . serialize . XMLSerializer ( System . out , null ) ; parser . setContentHandler ( trace ) ; parser . setLexicalHandler ( trace ) ; for ( int arg = 0 ; arg < args . length ; ++ arg ) { try { InputSource source = new InputSource ( args [ arg ] ) ; Object result = null ; boolean more = true ; parser . startParse ( source ) ; for ( result = parser . deliverMoreNodes ( more ) ; result == Boolean . TRUE ; result = parser . deliverMoreNodes ( more ) ) { System . out . println ( "\nSome parsing successful, trying more.\n" ) ; if ( arg + 1 < args . length && "!" . equals ( args [ arg + 1 ] ) ) { ++ arg ; more = false ; } } if ( result instanceof Boolean && ( ( Boolean ) result ) == Boolean . FALSE ) { System . out . println ( "\nParser ended (EOF or on request).\n" ) ; } else if ( result == null ) { System . out . println ( "\nUNEXPECTED: Parser says shut down prematurely.\n" ) ; } else if ( result instanceof Exception ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ( Exception ) result ) ; } } catch ( SAXException e ) { e . printStackTrace ( ) ; } } } } 	0	['14', '1', '0', '9', '51', '27', '1', '8', '10', '0.596153846', '749', '0.05', '0', '0', '0.162393162', '0', '0', '51.07142857', '9', '1.5', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; public abstract class LocationPathPattern extends Pattern { private Template _template ; private int _importPrecedence ; private double _priority = Double . NaN ; private int _position = 0 ; public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } public void setTemplate ( final Template template ) { _template = template ; _priority = template . getPriority ( ) ; _importPrecedence = template . getImportPrecedence ( ) ; _position = template . getPosition ( ) ; } public Template getTemplate ( ) { return _template ; } public final double getPriority ( ) { return Double . isNaN ( _priority ) ? getDefaultPriority ( ) : _priority ; } public double getDefaultPriority ( ) { return 0.5 ; } public boolean noSmallerThan ( LocationPathPattern other ) { if ( _importPrecedence > other . _importPrecedence ) { return true ; } else if ( _importPrecedence == other . _importPrecedence ) { if ( _priority > other . _priority ) { return true ; } else if ( _priority == other . _priority ) { if ( _position > other . _position ) { return true ; } } } return false ; } public abstract StepPattern getKernelPattern ( ) ; public abstract void reduceKernelPattern ( ) ; public abstract boolean isWildcard ( ) ; public int getAxis ( ) { final StepPattern sp = getKernelPattern ( ) ; return ( sp != null ) ? sp . getAxis ( ) : Axis . CHILD ; } public String toString ( ) { return "root()" ; } } 	0	['13', '4', '3', '13', '19', '64', '5', '8', '13', '0.854166667', '107', '1', '1', '0.878787879', '0.230769231', '2', '3', '6.923076923', '6', '1.4615', '0']
package org . apache . xalan . lib ; import javax . xml . transform . SourceLocator ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class NodeInfo { public static String systemId ( ExpressionContext context ) { Node contextNode = context . getContextNode ( ) ; int nodeHandler = ( ( DTMNodeProxy ) contextNode ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) contextNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getSystemId ( ) ; else return null ; } public static String systemId ( NodeList nodeList ) { if ( nodeList == null || nodeList . getLength ( ) == 0 ) return null ; Node node = nodeList . item ( 0 ) ; int nodeHandler = ( ( DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) node ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getSystemId ( ) ; else return null ; } public static String publicId ( ExpressionContext context ) { Node contextNode = context . getContextNode ( ) ; int nodeHandler = ( ( DTMNodeProxy ) contextNode ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) contextNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getPublicId ( ) ; else return null ; } public static String publicId ( NodeList nodeList ) { if ( nodeList == null || nodeList . getLength ( ) == 0 ) return null ; Node node = nodeList . item ( 0 ) ; int nodeHandler = ( ( DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) node ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getPublicId ( ) ; else return null ; } public static int lineNumber ( ExpressionContext context ) { Node contextNode = context . getContextNode ( ) ; int nodeHandler = ( ( DTMNodeProxy ) contextNode ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) contextNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getLineNumber ( ) ; else return - 1 ; } public static int lineNumber ( NodeList nodeList ) { if ( nodeList == null || nodeList . getLength ( ) == 0 ) return - 1 ; Node node = nodeList . item ( 0 ) ; int nodeHandler = ( ( DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) node ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getLineNumber ( ) ; else return - 1 ; } public static int columnNumber ( ExpressionContext context ) { Node contextNode = context . getContextNode ( ) ; int nodeHandler = ( ( DTMNodeProxy ) contextNode ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) contextNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getColumnNumber ( ) ; else return - 1 ; } public static int columnNumber ( NodeList nodeList ) { if ( nodeList == null || nodeList . getLength ( ) == 0 ) return - 1 ; Node node = nodeList . item ( 0 ) ; int nodeHandler = ( ( DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) node ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getColumnNumber ( ) ; else return - 1 ; } } 	0	['9', '1', '0', '3', '20', '36', '0', '3', '9', '2', '204', '0', '0', '0', '0.333333333', '0', '0', '21.66666667', '4', '2.6667', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public final class ResultTreeType extends Type { private final String _methodName ; protected ResultTreeType ( ) { _methodName = null ; } public ResultTreeType ( String methodName ) { _methodName = methodName ; } public String toString ( ) { return "result-tree" ; } public boolean identicalTo ( Type other ) { return ( other instanceof ResultTreeType ) ; } public String toSignature ( ) { return DOM_INTF_SIG ; } public org . apache . bcel . generic . Type toJCType ( ) { return Util . getJCRefType ( toSignature ( ) ) ; } public String getMethodName ( ) { return _methodName ; } public boolean implementedAsMethod ( ) { return _methodName != null ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . NodeSet ) { translateTo ( classGen , methodGen , ( NodeSetType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( POP ) ; il . append ( ICONST_1 ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _methodName == null ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , "getStringValue" , "()" + STRING_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; } else { final String className = classGen . getClassName ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( DUP ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , "_dom" , DOM_INTF_SIG ) ) ) ; int index = cpg . addMethodref ( STRING_VALUE_HANDLER , "<init>" , "()V" ) ; il . append ( new NEW ( cpg . addClass ( STRING_VALUE_HANDLER ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( index ) ) ; final LocalVariableGen handler = methodGen . addLocalVariable ( "rt_to_string_handler" , Util . getJCRefType ( STRING_VALUE_HANDLER_SIG ) , null , null ) ; il . append ( new ASTORE ( handler . getIndex ( ) ) ) ; index = cpg . addMethodref ( className , _methodName , "(" + DOM_INTF_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( new ALOAD ( handler . getIndex ( ) ) ) ; index = cpg . addMethodref ( STRING_VALUE_HANDLER , "getValue" , "()" + STRING_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { translateTo ( classGen , methodGen , Type . String ) ; Type . String . translateTo ( classGen , methodGen , Type . Real ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _methodName == null ) { il . append ( NOP ) ; } else { LocalVariableGen domBuilder , newDom ; final String className = classGen . getClassName ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , "getResultTreeFrag" , "(IZ)" + DOM_INTF_SIG ) ; il . append ( new PUSH ( cpg , RTF_INITIAL_SIZE ) ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEINTERFACE ( index , 3 ) ) ; il . append ( DUP ) ; newDom = methodGen . addLocalVariable ( "rt_to_reference_dom" , Util . getJCRefType ( DOM_INTF_SIG ) , null , null ) ; il . append ( new CHECKCAST ( cpg . addClass ( DOM_INTF_SIG ) ) ) ; il . append ( new ASTORE ( newDom . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , "getOutputDomBuilder" , "()" + TRANSLET_OUTPUT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; domBuilder = methodGen . addLocalVariable ( "rt_to_reference_handler" , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) , null , null ) ; il . append ( new ASTORE ( domBuilder . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "startDocument" , "()V" ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; index = cpg . addMethodref ( className , _methodName , "(" + DOM_INTF_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( new ALOAD ( domBuilder . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "endDocument" , "()V" ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; il . append ( new ALOAD ( newDom . getIndex ( ) ) ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeSetType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; final int mapping = cpg . addInterfaceMethodref ( DOM_INTF , "setupMapping" , "([" + STRING_SIG + "[" + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( mapping , 3 ) ) ; il . append ( DUP ) ; final int iter = cpg . addInterfaceMethodref ( DOM_INTF , "getIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( iter , 1 ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; translateTo ( classGen , methodGen , Type . Boolean ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final String className = clazz . getName ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( className . equals ( "org.w3c.dom.Node" ) ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE , MAKE_NODE_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "org.w3c.dom.NodeList" ) ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE_LIST , MAKE_NODE_LIST_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "java.lang.Object" ) ) { il . append ( NOP ) ; } else if ( className . equals ( "java.lang.String" ) ) { translateTo ( classGen , methodGen , Type . String ) ; } else if ( clazz == Double . TYPE ) { translateTo ( classGen , methodGen , Type . Real ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , className ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public String getClassName ( ) { return ( DOM_INTF ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['22', '2', '0', '40', '59', '185', '9', '33', '21', '0.523809524', '728', '1', '0', '0.622641509', '0.199300699', '2', '4', '32.04545455', '7', '1.6364', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class SingleNodeCounter extends NodeCounter { static private final int [ ] EmptyArray = new int [ ] { } ; DTMAxisIterator _countSiblings = null ; public SingleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getExpandedTypeID ( node ) ; _countSiblings = _document . getAxisIterator ( PRECEDINGSIBLING ) ; return this ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next = _node ; result = 0 ; if ( ! matchesCount ( next ) ) { while ( ( next = _document . getParent ( next ) ) > END ) { if ( matchesCount ( next ) ) { break ; } if ( matchesFrom ( next ) ) { next = END ; break ; } } } if ( next != END ) { _countSiblings . setStartNode ( next ) ; do { if ( matchesCount ( next ) ) result ++ ; } while ( ( next = _countSiblings . next ( ) ) != END ) ; } else { return formatNumbers ( EmptyArray ) ; } } return formatNumbers ( result ) ; } public static NodeCounter getDefaultNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { return new DefaultSingleNodeCounter ( translet , document , iterator ) ; } static class DefaultSingleNodeCounter extends SingleNodeCounter { public DefaultSingleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getExpandedTypeID ( node ) ; _countSiblings = _document . getTypedAxisIterator ( PRECEDINGSIBLING , _document . getExpandedTypeID ( node ) ) ; return this ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next ; result = 1 ; _countSiblings . setStartNode ( _node ) ; while ( ( next = _countSiblings . next ( ) ) != END ) { result ++ ; } } return formatNumbers ( result ) ; } } } 	0	['5', '2', '1', '5', '16', '2', '1', '5', '4', '0.625', '110', '0.5', '1', '0.823529412', '0.5', '1', '4', '20.6', '9', '2.2', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; abstract class IdKeyPattern extends LocationPathPattern { protected RelativePathPattern _left = null ; ; private String _index = null ; private String _value = null ; ; public IdKeyPattern ( String index , String value ) { _index = index ; _value = value ; } public String getIndexName ( ) { return ( _index ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . NodeSet ; } public boolean isWildcard ( ) { return false ; } public void setLeft ( RelativePathPattern left ) { _left = left ; } public StepPattern getKernelPattern ( ) { return ( null ) ; } public void reduceKernelPattern ( ) { } public String toString ( ) { return "id/keyPattern(" + _index + ", " + _value + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getKeyIndex = cpg . addMethodref ( TRANSLET_CLASS , "getKeyIndex" , "(Ljava/lang/String;)" + KEY_INDEX_SIG ) ; final int lookupId = cpg . addMethodref ( KEY_INDEX_CLASS , "containsID" , "(ILjava/lang/Object;)I" ) ; final int lookupKey = cpg . addMethodref ( KEY_INDEX_CLASS , "containsKey" , "(ILjava/lang/Object;)I" ) ; final int getNodeIdent = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeIdent" , "(I)" + NODE_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _index ) ) ; il . append ( new INVOKEVIRTUAL ( getKeyIndex ) ) ; il . append ( SWAP ) ; il . append ( new PUSH ( cpg , _value ) ) ; if ( this instanceof IdPattern ) { il . append ( SWAP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( lookupId ) ) ; } else { il . append ( SWAP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( lookupKey ) ) ; } _trueList . add ( il . append ( new IFNE ( null ) ) ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; } } 	0	['9', '5', '2', '25', '29', '22', '3', '23', '9', '0.75', '214', '1', '1', '0.925233645', '0.259259259', '3', '4', '22.44444444', '2', '1', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xpath . XPathContext ; public class ReverseAxesWalker extends AxesWalker { ReverseAxesWalker ( LocPathIterator locPathIterator , int axis ) { super ( locPathIterator , axis ) ; } public void setRoot ( int root ) { super . setRoot ( root ) ; m_iterator = getDTM ( root ) . getAxisIterator ( m_axis ) ; m_iterator . setStartNode ( root ) ; } public void detach ( ) { m_iterator = null ; super . detach ( ) ; } protected int getNextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next = m_iterator . next ( ) ; if ( m_isFresh ) m_isFresh = false ; if ( DTM . NULL == next ) this . m_foundLast = true ; return next ; } public boolean isReverseAxes ( ) { return true ; } protected int getProximityPosition ( int predicateIndex ) { if ( predicateIndex < 0 ) return - 1 ; int count = m_proximityPositions [ predicateIndex ] ; if ( count <= 0 ) { AxesWalker savedWalker = wi ( ) . getLastUsedWalker ( ) ; try { ReverseAxesWalker clone = ( ReverseAxesWalker ) this . clone ( ) ; clone . setRoot ( this . getRoot ( ) ) ; clone . setPredicateCount ( predicateIndex ) ; clone . setPrevWalker ( null ) ; clone . setNextWalker ( null ) ; wi ( ) . setLastUsedWalker ( clone ) ; count ++ ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } m_proximityPositions [ predicateIndex ] = count ; } catch ( CloneNotSupportedException cnse ) { } finally { wi ( ) . setLastUsedWalker ( savedWalker ) ; } } return count ; } protected void countProximityPosition ( int i ) { if ( i < m_proximityPositions . length ) m_proximityPositions [ i ] -- ; } public int getLastPos ( XPathContext xctxt ) { int count = 0 ; AxesWalker savedWalker = wi ( ) . getLastUsedWalker ( ) ; try { ReverseAxesWalker clone = ( ReverseAxesWalker ) this . clone ( ) ; clone . setRoot ( this . getRoot ( ) ) ; clone . setPredicateCount ( this . getPredicateCount ( ) - 1 ) ; clone . setPrevWalker ( null ) ; clone . setNextWalker ( null ) ; wi ( ) . setLastUsedWalker ( clone ) ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } } catch ( CloneNotSupportedException cnse ) { } finally { wi ( ) . setLastUsedWalker ( savedWalker ) ; } return count ; } public boolean isDocOrdered ( ) { return false ; } protected DTMAxisIterator m_iterator ; } 	0	['9', '5', '0', '7', '26', '28', '1', '6', '5', '0.5', '207', '1', '1', '0.927927928', '0.416666667', '2', '8', '21.88888889', '4', '1.7778', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class FormatNumberCall extends FunctionCall { private Expression _value ; private Expression _format ; private Expression _name ; private QName _resolvedQName = null ; public FormatNumberCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _value = argument ( 0 ) ; _format = argument ( 1 ) ; _name = argumentCount ( ) == 3 ? argument ( 2 ) : null ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { getStylesheet ( ) . numberFormattingUsed ( ) ; final Type tvalue = _value . typeCheck ( stable ) ; if ( tvalue instanceof RealType == false ) { _value = new CastExpr ( _value , Type . Real ) ; } final Type tformat = _format . typeCheck ( stable ) ; if ( tformat instanceof StringType == false ) { _format = new CastExpr ( _format , Type . String ) ; } if ( argumentCount ( ) == 3 ) { final Type tname = _name . typeCheck ( stable ) ; if ( _name instanceof LiteralExpr ) { final LiteralExpr literal = ( LiteralExpr ) _name ; _resolvedQName = getParser ( ) . getQNameIgnoreDefaultNs ( literal . getValue ( ) ) ; } else if ( tname instanceof StringType == false ) { _name = new CastExpr ( _name , Type . String ) ; } } return _type = Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _value . translate ( classGen , methodGen ) ; _format . translate ( classGen , methodGen ) ; final int fn3arg = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "formatNumber" , "(DLjava/lang/String;" + "Ljava/text/DecimalFormat;)" + "Ljava/lang/String;" ) ; final int get = cpg . addMethodref ( TRANSLET_CLASS , "getDecimalFormat" , "(Ljava/lang/String;)" + "Ljava/text/DecimalFormat;" ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( _name == null ) { il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; } else if ( _resolvedQName != null ) { il . append ( new PUSH ( cpg , _resolvedQName . toString ( ) ) ) ; } else { _name . translate ( classGen , methodGen ) ; } il . append ( new INVOKEVIRTUAL ( get ) ) ; il . append ( new INVOKESTATIC ( fn3arg ) ) ; } } 	0	['3', '4', '0', '22', '24', '0', '0', '22', '3', '0', '191', '1', '4', '0.979591837', '0.444444444', '3', '13', '61.33333333', '3', '1.3333', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . Operators ; final class RelationalExpr extends Expression implements Operators { private int _op ; private Expression _left , _right ; public RelationalExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public boolean hasPositionCall ( ) { if ( _left . hasPositionCall ( ) ) return true ; if ( _right . hasPositionCall ( ) ) return true ; return false ; } public boolean hasReferenceArgs ( ) { return _left . getType ( ) instanceof ReferenceType || _right . getType ( ) instanceof ReferenceType ; } public boolean hasNodeArgs ( ) { return _left . getType ( ) instanceof NodeType || _right . getType ( ) instanceof NodeType ; } public boolean hasNodeSetArgs ( ) { return _left . getType ( ) instanceof NodeSetType || _right . getType ( ) instanceof NodeSetType ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type tleft = _left . typeCheck ( stable ) ; Type tright = _right . typeCheck ( stable ) ; if ( tleft instanceof ResultTreeType && tright instanceof ResultTreeType ) { _right = new CastExpr ( _right , Type . Real ) ; _left = new CastExpr ( _left , Type . Real ) ; return _type = Type . Boolean ; } if ( hasReferenceArgs ( ) ) { Type type = null ; Type typeL = null ; Type typeR = null ; if ( tleft instanceof ReferenceType ) { if ( _left instanceof VariableRefBase ) { VariableRefBase ref = ( VariableRefBase ) _left ; VariableBase var = ref . getVariable ( ) ; typeL = var . getType ( ) ; } } if ( tright instanceof ReferenceType ) { if ( _right instanceof VariableRefBase ) { VariableRefBase ref = ( VariableRefBase ) _right ; VariableBase var = ref . getVariable ( ) ; typeR = var . getType ( ) ; } } if ( typeL == null ) type = typeR ; else if ( typeR == null ) type = typeL ; else { type = Type . Real ; } if ( type == null ) type = Type . Real ; _right = new CastExpr ( _right , type ) ; _left = new CastExpr ( _left , type ) ; return _type = Type . Boolean ; } if ( hasNodeSetArgs ( ) ) { if ( tright instanceof NodeSetType ) { final Expression temp = _right ; _right = _left ; _left = temp ; _op = ( _op == Operators . GT ) ? Operators . LT : ( _op == Operators . LT ) ? Operators . GT : ( _op == Operators . GE ) ? Operators . LE : Operators . GE ; tright = _right . getType ( ) ; } if ( tright instanceof NodeType ) { _right = new CastExpr ( _right , Type . NodeSet ) ; } if ( tright instanceof IntType ) { _right = new CastExpr ( _right , Type . Real ) ; } if ( tright instanceof ResultTreeType ) { _right = new CastExpr ( _right , Type . String ) ; } return _type = Type . Boolean ; } if ( hasNodeArgs ( ) ) { if ( tleft instanceof BooleanType ) { _right = new CastExpr ( _right , Type . Boolean ) ; tright = Type . Boolean ; } if ( tright instanceof BooleanType ) { _left = new CastExpr ( _left , Type . Boolean ) ; tleft = Type . Boolean ; } } MethodType ptype = lookupPrimop ( stable , Operators . names [ _op ] , new MethodType ( Type . Void , tleft , tright ) ) ; if ( ptype != null ) { Type arg1 = ( Type ) ptype . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) { _left = new CastExpr ( _left , arg1 ) ; } Type arg2 = ( Type ) ptype . argsType ( ) . elementAt ( 1 ) ; if ( ! arg2 . identicalTo ( tright ) ) { _right = new CastExpr ( _right , arg1 ) ; } return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( hasNodeSetArgs ( ) || hasReferenceArgs ( ) ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; _left . startResetIterator ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; _right . startResetIterator ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , _op ) ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "compare" , "(" + _left . getType ( ) . toSignature ( ) + _right . getType ( ) . toSignature ( ) + "I" + DOM_INTF_SIG + ")Z" ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else { translateDesynthesized ( classGen , methodGen ) ; synthesize ( classGen , methodGen ) ; } } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( hasNodeSetArgs ( ) || hasReferenceArgs ( ) ) { translate ( classGen , methodGen ) ; desynthesize ( classGen , methodGen ) ; } else { BranchInstruction bi = null ; final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; boolean tozero = false ; Type tleft = _left . getType ( ) ; if ( tleft instanceof RealType ) { il . append ( tleft . CMP ( _op == LT || _op == LE ) ) ; tleft = Type . Int ; tozero = true ; } switch ( _op ) { case LT : bi = tleft . GE ( tozero ) ; break ; case GT : bi = tleft . LE ( tozero ) ; break ; case LE : bi = tleft . GT ( tozero ) ; break ; case GE : bi = tleft . LT ( tozero ) ; break ; default : ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_RELAT_OP_ERR , this ) ; getParser ( ) . reportError ( Constants . FATAL , msg ) ; } _falseList . add ( il . append ( bi ) ) ; } } public String toString ( ) { return Operators . names [ _op ] + '(' + _left + ", " + _right + ')' ; } } 	0	['10', '3', '0', '31', '54', '0', '0', '31', '10', '0.185185185', '600', '1', '2', '0.8875', '0.257142857', '2', '9', '58.7', '7', '2.5', '0']
package org . apache . xalan . xsltc ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTMAxisIterator ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . xml . serializer . SerializationHandler ; public interface DOM { public final static int FIRST_TYPE = 0 ; public final static int NO_TYPE = - 1 ; public final static int NULL = 0 ; public final static int RETURN_CURRENT = 0 ; public final static int RETURN_PARENT = 1 ; public final static int SIMPLE_RTF = 0 ; public final static int ADAPTIVE_RTF = 1 ; public final static int TREE_RTF = 2 ; public DTMAxisIterator getIterator ( ) ; public String getStringValue ( ) ; public DTMAxisIterator getChildren ( final int node ) ; public DTMAxisIterator getTypedChildren ( final int type ) ; public DTMAxisIterator getAxisIterator ( final int axis ) ; public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) ; public DTMAxisIterator getNthDescendant ( int node , int n , boolean includeself ) ; public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) ; public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iter , int returnType , String value , boolean op ) ; public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) ; public String getNodeName ( final int node ) ; public String getNodeNameX ( final int node ) ; public String getNamespaceName ( final int node ) ; public int getExpandedTypeID ( final int node ) ; public int getNamespaceType ( final int node ) ; public int getParent ( final int node ) ; public int getAttributeNode ( final int gType , final int element ) ; public String getStringValueX ( final int node ) ; public void copy ( final int node , SerializationHandler handler ) throws TransletException ; public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException ; public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException ; public boolean lessThan ( final int node1 , final int node2 ) ; public void characters ( final int textNode , SerializationHandler handler ) throws TransletException ; public Node makeNode ( int index ) ; public Node makeNode ( DTMAxisIterator iter ) ; public NodeList makeNodeList ( int index ) ; public NodeList makeNodeList ( DTMAxisIterator iter ) ; public String getLanguage ( int node ) ; public int getSize ( ) ; public String getDocumentURI ( int node ) ; public void setFilter ( StripFilter filter ) ; public void setupMapping ( String [ ] names , String [ ] namespaces ) ; public boolean isElement ( final int node ) ; public boolean isAttribute ( final int node ) ; public String lookupNamespace ( int node , String prefix ) throws TransletException ; public int getNodeIdent ( final int nodehandle ) ; public int getNodeHandle ( final int nodeId ) ; public DOM getResultTreeFrag ( int initialSize , int rtfType ) ; public SerializationHandler getOutputDomBuilder ( ) ; public int getNSType ( int node ) ; public int getDocument ( ) ; public String getUnparsedEntityURI ( String name ) ; public Hashtable getElementsWithIDs ( ) ; } 	0	['43', '1', '0', '36', '43', '903', '32', '5', '43', '1.023809524', '51', '0', '0', '0', '0.261627907', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . axes ; import java . util . Vector ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . NodeVector ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class NodeSequence extends XObject implements DTMIterator , Cloneable , PathComponent { protected int m_last = - 1 ; protected int m_next = 0 ; protected NodeVector getVector ( ) { return ( NodeVector ) m_obj ; } protected void SetVector ( NodeVector v ) { m_obj = v ; } public boolean hasCache ( ) { return ( m_obj != null ) ; } protected DTMIterator m_iter ; public final void setIter ( DTMIterator iter ) { m_iter = iter ; } public final DTMIterator getContainedIter ( ) { return m_iter ; } protected DTMManager m_dtmMgr ; public NodeSequence ( DTMIterator iter , int context , XPathContext xctxt , boolean shouldCacheNodes ) { setIter ( iter ) ; setRoot ( context , xctxt ) ; setShouldCacheNodes ( shouldCacheNodes ) ; } public NodeSequence ( Object nodeVector ) { super ( nodeVector ) ; if ( null != nodeVector ) { assertion ( nodeVector instanceof NodeVector , "Must have a NodeVector as the object for NodeSequence!" ) ; if ( nodeVector instanceof DTMIterator ) { setIter ( ( DTMIterator ) nodeVector ) ; m_last = ( ( DTMIterator ) nodeVector ) . getLength ( ) ; } } } public NodeSequence ( DTMManager dtmMgr ) { super ( new NodeVector ( ) ) ; m_last = 0 ; m_dtmMgr = dtmMgr ; } public NodeSequence ( ) { } public DTM getDTM ( int nodeHandle ) { DTMManager mgr = getDTMManager ( ) ; if ( null != mgr ) return getDTMManager ( ) . getDTM ( nodeHandle ) ; else { assertion ( false , "Can not get a DTM Unless a DTMManager has been set!" ) ; return null ; } } public DTMManager getDTMManager ( ) { return m_dtmMgr ; } public int getRoot ( ) { if ( null != m_iter ) return m_iter . getRoot ( ) ; else { return DTM . NULL ; } } public void setRoot ( int nodeHandle , Object environment ) { if ( null != m_iter ) { XPathContext xctxt = ( XPathContext ) environment ; m_dtmMgr = xctxt . getDTMManager ( ) ; m_iter . setRoot ( nodeHandle , environment ) ; if ( ! m_iter . isDocOrdered ( ) ) { if ( ! hasCache ( ) ) setShouldCacheNodes ( true ) ; runTo ( - 1 ) ; m_next = 0 ; } } else assertion ( false , "Can not setRoot on a non-iterated NodeSequence!" ) ; } public void reset ( ) { m_next = 0 ; } public int getWhatToShow ( ) { return hasCache ( ) ? ( DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ) : m_iter . getWhatToShow ( ) ; } public boolean getExpandEntityReferences ( ) { if ( null != m_iter ) return m_iter . getExpandEntityReferences ( ) ; else return true ; } public int nextNode ( ) { NodeVector vec = getVector ( ) ; if ( null != vec ) { if ( m_next < vec . size ( ) ) { int next = vec . elementAt ( m_next ) ; m_next ++ ; return next ; } else if ( ( - 1 != m_last ) || ( null == m_iter ) ) { m_next ++ ; return DTM . NULL ; } } if ( null == m_iter ) return DTM . NULL ; int next = m_iter . nextNode ( ) ; if ( DTM . NULL != next ) { if ( hasCache ( ) ) { if ( m_iter . isDocOrdered ( ) ) { getVector ( ) . addElement ( next ) ; m_next ++ ; } else { int insertIndex = addNodeInDocOrder ( next ) ; if ( insertIndex >= 0 ) m_next ++ ; } } else m_next ++ ; } else { m_last = m_next ; m_next ++ ; } return next ; } public int previousNode ( ) { if ( hasCache ( ) ) { if ( m_next <= 0 ) return DTM . NULL ; else { m_next -- ; return item ( m_next ) ; } } else { int n = m_iter . previousNode ( ) ; m_next = m_iter . getCurrentPos ( ) ; return m_next ; } } public void detach ( ) { if ( null != m_iter ) m_iter . detach ( ) ; super . detach ( ) ; } public void allowDetachToRelease ( boolean allowRelease ) { if ( ( false == allowRelease ) && ! hasCache ( ) ) { setShouldCacheNodes ( true ) ; } if ( null != m_iter ) m_iter . allowDetachToRelease ( allowRelease ) ; super . allowDetachToRelease ( allowRelease ) ; } public int getCurrentNode ( ) { if ( hasCache ( ) ) { int currentIndex = m_next - 1 ; NodeVector vec = getVector ( ) ; if ( ( currentIndex >= 0 ) && ( currentIndex < vec . size ( ) ) ) return vec . elementAt ( currentIndex ) ; else return DTM . NULL ; } if ( null != m_iter ) { return m_iter . getCurrentNode ( ) ; } else return DTM . NULL ; } public boolean isFresh ( ) { return ( 0 == m_next ) ; } public void setShouldCacheNodes ( boolean b ) { if ( b ) { if ( ! hasCache ( ) ) { SetVector ( new NodeVector ( ) ) ; } } else SetVector ( null ) ; } public boolean isMutable ( ) { return hasCache ( ) ; } public int getCurrentPos ( ) { return m_next ; } public void runTo ( int index ) { int n ; if ( - 1 == index ) { int pos = m_next ; while ( DTM . NULL != ( n = nextNode ( ) ) ) ; m_next = pos ; } else if ( m_next == index ) { return ; } else if ( hasCache ( ) && m_next < getVector ( ) . size ( ) ) { m_next = index ; } else if ( ( null == getVector ( ) ) && ( index < m_next ) ) { while ( ( m_next >= index ) && DTM . NULL != ( n = previousNode ( ) ) ) ; } else { while ( ( m_next < index ) && DTM . NULL != ( n = nextNode ( ) ) ) ; } } public void setCurrentPos ( int i ) { runTo ( i ) ; } public int item ( int index ) { setCurrentPos ( index ) ; int n = nextNode ( ) ; m_next = index ; return n ; } public void setItem ( int node , int index ) { NodeVector vec = getVector ( ) ; if ( null != vec ) { vec . setElementAt ( node , index ) ; m_last = vec . size ( ) ; } else m_iter . setItem ( node , index ) ; } public int getLength ( ) { if ( hasCache ( ) ) { if ( m_iter instanceof NodeSetDTM ) { return m_iter . getLength ( ) ; } if ( - 1 == m_last ) { int pos = m_next ; runTo ( - 1 ) ; m_next = pos ; } return m_last ; } else { return ( - 1 == m_last ) ? ( m_last = m_iter . getLength ( ) ) : m_last ; } } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { NodeSequence seq = ( NodeSequence ) super . clone ( ) ; seq . m_next = 0 ; return seq ; } public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } public boolean isDocOrdered ( ) { if ( null != m_iter ) return m_iter . isDocOrdered ( ) ; else return true ; } public int getAxis ( ) { if ( null != m_iter ) return m_iter . getAxis ( ) ; else { assertion ( false , "Can not getAxis from a non-iterated node sequence!" ) ; return 0 ; } } public int getAnalysisBits ( ) { if ( ( null != m_iter ) && ( m_iter instanceof PathComponent ) ) return ( ( PathComponent ) m_iter ) . getAnalysisBits ( ) ; else return 0 ; } public void fixupVariables ( Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; } protected int addNodeInDocOrder ( int node ) { assertion ( hasCache ( ) , "addNodeInDocOrder must be done on a mutable sequence!" ) ; int insertIndex = - 1 ; NodeVector vec = getVector ( ) ; int size = vec . size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { int child = vec . elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } DTM dtm = m_dtmMgr . getDTM ( node ) ; if ( ! dtm . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; vec . insertElementAt ( node , insertIndex ) ; } return insertIndex ; } } 	0	['37', '3', '1', '9', '68', '212', '1', '8', '34', '0.625', '711', '1', '2', '0.682692308', '0.171171171', '2', '9', '18.10810811', '12', '2.2973', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . util . Stack ; public final class StringStack extends Stack { public String peekString ( ) { return ( String ) super . peek ( ) ; } public String popString ( ) { return ( String ) super . pop ( ) ; } public String pushString ( String val ) { return ( String ) super . push ( val ) ; } } 	0	['4', '5', '0', '0', '8', '6', '0', '0', '4', '2', '20', '0', '0', '0.963855422', '0.625', '0', '0', '4', '1', '0.75', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class SortingIterator extends DTMAxisIteratorBase { private final static int INIT_DATA_SIZE = 16 ; private DTMAxisIterator _source ; private NodeSortRecordFactory _factory ; private NodeSortRecord [ ] _data ; private int _free = 0 ; private int _current ; public SortingIterator ( DTMAxisIterator source , NodeSortRecordFactory factory ) { _source = source ; _factory = factory ; } public int next ( ) { return _current < _free ? _data [ _current ++ ] . getNode ( ) : END ; } public DTMAxisIterator setStartNode ( int node ) { try { _source . setStartNode ( _startNode = node ) ; _data = new NodeSortRecord [ INIT_DATA_SIZE ] ; _free = 0 ; while ( ( node = _source . next ( ) ) != END ) { addRecord ( _factory . makeNodeSortRecord ( node , _free ) ) ; } quicksort ( 0 , _free - 1 ) ; _current = 0 ; return this ; } catch ( Exception e ) { return this ; } } public int getPosition ( ) { return _current == 0 ? 1 : _current ; } public int getLast ( ) { return _free ; } public void setMark ( ) { _source . setMark ( ) ; _markedNode = _current ; } public void gotoMark ( ) { _source . gotoMark ( ) ; _current = _markedNode ; } public DTMAxisIterator cloneIterator ( ) { try { final SortingIterator clone = ( SortingIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _factory = _factory ; clone . _data = _data ; clone . _free = _free ; clone . _current = _current ; clone . setRestartable ( false ) ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } private void addRecord ( NodeSortRecord record ) { if ( _free == _data . length ) { NodeSortRecord [ ] newArray = new NodeSortRecord [ _data . length * 2 ] ; System . arraycopy ( _data , 0 , newArray , 0 , _free ) ; _data = newArray ; } _data [ _free ++ ] = record ; } private void quicksort ( int p , int r ) { while ( p < r ) { final int q = partition ( p , r ) ; quicksort ( p , q ) ; p = q + 1 ; } } private int partition ( int p , int r ) { final NodeSortRecord x = _data [ ( p + r ) > > > 1 ] ; int i = p - 1 ; int j = r + 1 ; while ( true ) { while ( x . compareTo ( _data [ -- j ] ) < 0 ) ; while ( x . compareTo ( _data [ ++ i ] ) > 0 ) ; if ( i < j ) { final NodeSortRecord t = _data [ i ] ; _data [ i ] = _data [ j ] ; _data [ j ] = t ; } else { return ( j ) ; } } } } 	0	['11', '2', '0', '5', '26', '0', '0', '5', '8', '0.666666667', '272', '1', '3', '0.565217391', '0.309090909', '1', '7', '23.18181818', '4', '1.6364', '0']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_no extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Intern programfeil i ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Programfeil under utføing av <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Ugyldig konvertering av ''{0}'' fra ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Ekstern funksjon ''{0}'' er ikke støttet av XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Ugyldig argument i EQUALITY uttrykk." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Ugyldig argument ''{0}'' i kall til ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Forsøk på å formattere nummer ''{0}'' med ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Kan ikke klone iterator ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterator for axis ''{0}'' er ikke stèttet." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterator for typet axis ''{0}'' er ikke stèttet." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Attributt ''{0}'' utenfor element." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Navnedeklarasjon ''{0}''=''{1}'' utenfor element." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Prefix ''{0}'' er ikke deklartert." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "Forsøk på å instansiere DOMAdapter med feil type DOM." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	0	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '195', '1', '0', '0.974358974', '1', '0', '0', '63.66666667', '1', '0.3333', '0']
package org . apache . xalan . res ; public class XSLTErrorResources_es extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "Error: No se puede incluir '{' en una expresión" } , { ER_ILLEGAL_ATTRIBUTE , "{0} tiene un atributo no permitido: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode es nulo en xsl:apply-imports." } , { ER_CANNOT_ADD , "No se puede añadir {0} a {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode es nulo en handleApplyTemplatesInstruction." } , { ER_NO_NAME_ATTRIB , "{0} debe tener un atributo de nombre." } , { ER_TEMPLATE_NOT_FOUND , "No se ha encontrado ninguna plantilla con el nombre: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "No se ha podido convertir el nombre AVT en xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} necesita un atributo: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} debe tener un atributo ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Valor erróneo en un atributo de nivel: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "el nombre de la instrucción de procesamiento no puede ser 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "el nombre de la instrucción de procesamiento debe ser un NCName válido: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} debe tener un atributo de búsqueda si tiene un modo." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} necesita un atributo de nombre o de búsqueda." } , { ER_CANT_RESOLVE_NSPREFIX , "No se puede convertir el prefijo de espacio de nombre: {0}" } , { ER_ILLEGAL_VALUE , "xml:space tiene un valor no permitido: {0}" } , { ER_NO_OWNERDOC , "El nodo hijo no tiene documento propietario." } , { ER_ELEMTEMPLATEELEM_ERR , "Error ElemTemplateElement: {0}" } , { ER_NULL_CHILD , "Intentando agregar un hijo nulo." } , { ER_NEED_SELECT_ATTRIB , "{0} necesita un atributo de selección." } , { ER_NEED_TEST_ATTRIB , "xsl:when debe tener un atributo 'test'." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param debe tener un atributo 'name'." } , { ER_NO_CONTEXT_OWNERDOC , "el contexto no tiene documento propietario." } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "No se ha podido crear un vínculo XML TransformerFactory: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: El proceso ha fallado." } , { ER_NOT_SUCCESSFUL , "Xalan: ha fallado." } , { ER_ENCODING_NOT_SUPPORTED , "Codificación no admitida: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "No se ha podido crear TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key necesita un atributo 'name'." } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key necesita un atributo 'match'." } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key necesita un atributo 'use'." } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} necesita un atributo ''elements''." } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} falta el atributo ''prefix''" } , { ER_BAD_STYLESHEET_URL , "El URL de la hoja de estilo es erróneo: {0}" } , { ER_FILE_NOT_FOUND , "No se ha encontrado el archivo de la hoja de estilo: {0}" } , { ER_IOEXCEPTION , "Tenía una excepción E/S en el archivo de la hoja de estilo: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) No se ha encontrado el atributo href para {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} se incluye a sí mismo directa o indirectamente." } , { ER_PROCESSINCLUDE_ERROR , "Error StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} falta el atributo ''lang''" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) ¿elemento {0} mal colocado? Falta el elemento ''component'' del contenedor" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Sólo puede enviarse a Element, DocumentFragment, Document o PrintWriter." } , { ER_PROCESS_ERROR , "Error StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Error UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "Error. No se ha encontrado la expresión de selección xpath (-seleccionar)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "No se puede serializar un XSLProcessor." } , { ER_NO_INPUT_STYLESHEET , "No se ha especificado la entrada de la hoja de estilo." } , { ER_FAILED_PROCESS_STYLESHEET , "No se ha podido procesar la hoja de estilo." } , { ER_COULDNT_PARSE_DOC , "No se ha podido analizar sintácticamente el documento {0}." } , { ER_COULDNT_FIND_FRAGMENT , "No se ha encontrado el fragmento: {0}" } , { ER_NODE_NOT_ELEMENT , "El nodo señalado por el identificador de fragmento no era un elemento: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each debe tener un atributo de búsqueda o de nombre" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "las plantillas deben tener un atributo de búsqueda o de nombre" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "No existe clon de un fragmento de un documento" } , { ER_CANT_CREATE_ITEM , "No se puede crear el elemento en el árbol de resultados: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space en el XML fuente tiene un valor no permitido: {0}" } , { ER_NO_XSLKEY_DECLARATION , "No existe ninguna declaración xsl:key para {0}." } , { ER_CANT_CREATE_URL , "Error. No se puede crear el url para: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions no se admite" } , { ER_PROCESSOR_ERROR , "Error XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} no se permite en una hoja de estilo." } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns ya no se utiliza.  Utilizar en su lugar xsl:output" } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space ya no se utiliza.  Utilizar en su lugar xsl:strip-space o xsl:preserve-space" } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result ya no se utiliza. Utilizar en su lugar xsl:output" } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} tiene un atributo no permitido: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Elemento XSL desconocido: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort sólo puede utilizarse con xsl:apply-templates o con xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when mal colocado." } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when no es hijo de xsl:choose." } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise mal colocado." } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise no es hijo de xsl:choose." } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} no se permite en una plantilla." } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} prejijo de espacio de nombre de extensión {1} desconocido" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Las importaciones sólo pueden ser los primeros elementos de la hoja de estilo." } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} se importa a sí mismo directa o indirectamente." } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space tiene un valor no permitido: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet ha fallado." } , { ER_SAX_EXCEPTION , "Excepción SAX" } , { ER_XSLT_ERROR , "Error XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "el signo de divisa no se permite en la cadena de patrones de formato" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "La hoja de estilo DOM no admite la función de documento." } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "No se puede convertir el prefijo del convertidor de ausencia de prefijo." } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Reencaminar extensión : No se ha podido obtener el nombre del archivo - el atributo de archivo o de selección debe presentar una cadena válida." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "No se puede crear FormatterListener en extensión Redirect." } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "El prefijo de exclude-result-prefixes no es válido: {0}" } , { ER_MISSING_NS_URI , "Falta el URI de espacio de nombre del prefijo especificado" } , { ER_MISSING_ARG_FOR_OPTION , "Falta el argumento en la opción: {0}" } , { ER_INVALID_OPTION , "Opción no válida: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Cadena de formato mal construida: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet necesita un atributo 'version'." } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "El atributo: {0} tiene un valor no permitido: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose requiere xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports no se permite en xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "No se puede utilizar DTMLiaison con un nodo DOM de salida... utilizar en su lugar org.apache.xpath.DOM2Helper." } , { ER_CANT_USE_DTM_FOR_INPUT , "No se puede utilizar DTMLiaison con un nodo DOM de salida... utilizar en su lugar org.apache.xpath.DOM2Helper." } , { ER_CALL_TO_EXT_FAILED , "Ha fallado el elemento de llamada a la extensión: {0}" } , { ER_PREFIX_MUST_RESOLVE , "El prefijo debe convertir un espacio de nombre: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Se ha detectado un sustituto de UTF-16 no válido: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} se utiliza a sí mismo y provocará un bucle sin fin." } , { ER_CANNOT_MIX_XERCESDOM , "No se puede mezclar una entrada no Xerces-DOM con una salida Xerces-DOM." } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "En ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Se ha encontrado más de una plantilla con el nombre: {0}" } , { ER_INVALID_KEY_CALL , "Llamada a función no válida: no se permiten las llamadas con clave recursiva()" } , { ER_REFERENCING_ITSELF , "La variable {0} se refiere a sí misma directa o indirectamente." } , { ER_ILLEGAL_DOMSOURCE_INPUT , "El nodo de entrada no puede ser nulo para DOMSource en newTemplates." } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "No se ha encontrado el archivo de clase para la opción {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "No se ha encontrado el elemento requerido: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream no puede ser nulo" } , { ER_URI_CANNOT_BE_NULL , "URI no puede ser nulo" } , { ER_FILE_CANNOT_BE_NULL , "El archivo no puede ser nulo" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource no puede ser nulo" } , { ER_CANNOT_INIT_BSFMGR , "No se ha podido inicializar el administrador de BSF" } , { ER_CANNOT_CMPL_EXTENSN , "No se ha podido compilar la extensión" } , { ER_CANNOT_CREATE_EXTENSN , "No se ha podido crear la extensión: {0} debido a: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "El primer argumento de la llamada del método de instancia al método {0} necesita una instancia de objeto" } , { ER_INVALID_ELEMENT_NAME , "Se ha especificado un nombre de elemento no válido {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "El método del nombre de elemento debe ser estático {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "La función de extensión {0} : {1} es desconocida" } , { ER_MORE_MATCH_CONSTRUCTOR , "Hay más de una coincidencia óptima para el creador en {0}" } , { ER_MORE_MATCH_METHOD , "Hay más de una coincidencia óptima para el método {0}" } , { ER_MORE_MATCH_ELEMENT , "Hay más de una coincidencia óptima para el método del elemento {0}" } , { ER_INVALID_CONTEXT_PASSED , "El contexto no válido se ha pasado a evaluación {0}" } , { ER_POOL_EXISTS , "El pool ya existe" } , { ER_NO_DRIVER_NAME , "No se ha especificado ningún nombre para el dispositivo" } , { ER_NO_URL , "No se ha especificado ningún URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "El tamaño del pool es menor que uno." } , { ER_INVALID_DRIVER , "Se ha especificado un nombre de dispositivo no válido." } , { ER_NO_STYLESHEETROOT , "No se ha encontrado la raíz de la hoja de estilo." } , { ER_ILLEGAL_XMLSPACE_VALUE , "Valor no permitido para xml:space" } , { ER_PROCESSFROMNODE_FAILED , "Fallo de processFromNode" } , { ER_RESOURCE_COULD_NOT_LOAD , "El recurso [ {0} ] no ha podido cargar: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Tamaño del búfer <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Error desconocido al llamar a la extensión" } , { ER_NO_NAMESPACE_DECL , "El prefijo {0} no tiene la declaración de espacio de nombre correspondiente" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "El contenido del elemento no está permitido para lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Terminación dirigida a la hoja de estilo" } , { ER_ONE_OR_TWO , "1 ó 2" } , { ER_TWO_OR_THREE , "2 ó 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "No se ha podido cargar {0} (comprobar CLASSPATH), el sistema está utilizando los valores predeterminados" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "No se puede inicializar las plantillas predeterminadas" } , { ER_RESULT_NULL , "El resultado no debe ser nulo" } , { ER_RESULT_COULD_NOT_BE_SET , "No ha podido establecerse el resultado" } , { ER_NO_OUTPUT_SPECIFIED , "No se ha especificado ninguna salida" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "No se puede transformar en un resultado del tipo {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "No se puede transformar una fuente del tipo {0}" } , { ER_NULL_CONTENT_HANDLER , "Manejador de contenido nulo" } , { ER_NULL_ERROR_HANDLER , "Manejador de errores nulo" } , { ER_CANNOT_CALL_PARSE , "no puede invocarse el analizador sintáctico si no se ha establecido el ContentHandler" } , { ER_NO_PARENT_FOR_FILTER , "No existe ningún elemento padre para el filtro" } , { ER_NO_STYLESHEET_IN_MEDIA , "No se ha encontrado ninguna hoja de estilo en: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "No se ha encontrado xml-stylesheet PI en: {0}" } , { ER_NOT_SUPPORTED , "No se admite: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "El valor de propiedad {0} debe ser una instancia booleana" } , { "ER_SRC_ATTRIB_NOT_SUPPORTED" , "el atributo src no se permite todavía para {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "No se ha encontrado el recurso [ {0} ].\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Propiedad de salida no reconocida: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Fallo de creación de instancia ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "El valor de {0} debe contener un número que se pueda analizar" } , { ER_VALUE_SHOULD_EQUAL , " El valor de {0} debe ser igual a sí o no" } , { ER_FAILED_CALLING_METHOD , " Fallo de invocación del método {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Fallo de creación de instancia ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "No se permiten caracteres en esta parte del documento" } , { ER_ATTR_NOT_ALLOWED , "el atributo \"{0}\" no se permite en el elemento {1}." } , { ER_BAD_VALUE , "{0} valor erróneo {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "no se ha encontrado el valor del atributo {0}" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "no se reconoce el valor del atributo {0}" } , { ER_NULL_URI_NAMESPACE , "Se ha intentado generar un prefijo de espacio de nombre con un URI nulo" } , { ER_NUMBER_TOO_BIG , "Se ha intentado dar formato a un número mayor que el entero Long de mayor tamaño" } , { ER_CANNOT_FIND_SAX1_DRIVER , "No se puede hallar la clase {0} del controlador SAX1" } , { ER_SAX1_DRIVER_NOT_LOADED , "Se ha encontrado la clase {0} del controlador SAX1 pero no se puede cargar" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "Se ha cargado la clase {0} del controlador SAX1 pero no se puede crear una instancia" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "La clase {0} del controlador SAX1 no implementa org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "No se ha especificado la propiedad de sistema org.xml.sax.parser" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "El argumento del analizador sintáctico no debe ser nulo" } , { ER_FEATURE , "Característica: {0}" } , { ER_PROPERTY , "Propiedad:{0}" } , { ER_NULL_ENTITY_RESOLVER , "Convertidor de entidad nulo" } , { ER_NULL_DTD_HANDLER , "Manejador DTD nulo" } , { ER_NO_DRIVER_NAME_SPECIFIED , "No se ha especificado un nombre de controlador" } , { ER_NO_URL_SPECIFIED , "No se ha especificado una URL" } , { ER_POOLSIZE_LESS_THAN_ONE , "¡El tamaño de pool es inferior a 1!" } , { ER_INVALID_DRIVER_NAME , "El nombre de controlador especificado no es válido" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Error de programación. expr no tiene ElemTemplateElement padre!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Confirmación del programador en RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} no está permitido en esta posición de la hoja de estilo" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "En esta posición de la hoja de estilo no se admite texto; solo espacios en blanco " } , { INVALID_TCHAR , "Valor no válido: {1} utilizado para el atributo CHAR: {0}.  Un atributo de tipo CHAR debe tener 1 solo carácter" } , { INVALID_QNAME , "Valor no válido: {1} utilizado para atributo QNAME: {0}" } , { INVALID_ENUM , "Valor no válido: {1} utilizado para atributo ENUM: {0}.  Los valores válidos son: {2}." } , { INVALID_NMTOKEN , "Valor no válido: {1} utilizado para atributo NMTOKEN: {0}" } , { INVALID_NCNAME , "Valor no válido: {1} utilizado para atributo NCNAME : {0}" } , { INVALID_BOOLEAN , "Valor no válido: {1} utilizado para atributo booleano: {0}" } , { INVALID_NUMBER , "Valor no válido: {1} utilizado para atributo de número: {0}" } , { ER_ARG_LITERAL , "El argumento de {0} en el patrón coincidente debe ser literal." } , { ER_DUPLICATE_GLOBAL_VAR , "Declaración de variable global duplicada." } , { ER_DUPLICATE_VAR , "Declaración de variable duplicada." } , { ER_TEMPLATE_NAME_MATCH , "xsl: template debe tener un atributo name o match (o ambos)" } , { ER_INVALID_PREFIX , "El prefijo de exclude-result-prefixes no es válido: {0}" } , { ER_NO_ATTRIB_SET , "no existe el conjunto de atributos denominado {0}" } , { WG_FOUND_CURLYBRACE , "Se ha encontrado '}' pero no hay abierta ninguna plantilla de atributos." } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Advertencia: el atributo de cómputo no coincide con ningún antecesor en xsl:number. Objetivo = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Sintaxis antigua: El nombre del atributo 'expr' se ha cambiado por 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan no maneja todavía el nombre locale en la función format-number." } , { WG_LOCALE_NOT_FOUND , "Advertencia: No se ha encontrado locale para xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "No se puede crear URL desde: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "No se puede cargar el doc solicitado: {0}" } , { WG_CANNOT_FIND_COLLATOR , "No se ha encontrado Collator para <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Sintaxis antigua: la instrucción de las funciones debe utilizar un url de {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "codificación no admitida: {0}, se utiliza UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "codificación no admitida: {0}, se utiliza Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Se han encontrado conflictos de especificidad: {0} Se utilizará la última encontrada en la hoja de estilo." } , { WG_PARSING_AND_PREPARING , "========= Análisis sintáctico y preparación {0} ==========" } , { WG_ATTR_TEMPLATE , "Plantilla atri, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Conflicto de coincidencia entre xsl:strip-space y xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan no maneja todavía el atributo {0}." } , { WG_NO_DECIMALFORMAT_DECLARATION , "No se ha encontrado ninguna declaración para el formato decimal: {0}" } , { WG_OLD_XSLT_NS , "Falta el espacio de nombre XSLT o es incorrecto. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Sólo se permite una declaración xsl:decimal-format predeterminada." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "los nombres xsl:decimal-format deben ser únicos. El nombre \"{0}\" está duplicado." } , { WG_ILLEGAL_ATTRIBUTE , "{0} tiene un atributo no permitido: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "No se ha podido convertir el prefijo de espacio de nombre : {0}. El nodo se ignorará." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet necesita un atributo 'version'." } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Nombre de atributo no permitido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Se ha utilizado un valor no permitido para el atributo {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "El conjunto de nodos resultante del segundo argumento de la función de documento está vacío. Se utilizará el primer argumento." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "El valor del atributo 'name' del nombre xsl:processing-instruction no debe ser 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "El valor del atributo ''name'' de xsl:processing-instruction debe ser un nombre NCName válido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "No se puede agregar el atributo {0} después de nodos hijos ni antes de generar un elemento.  El atributo no será considerado" } , { "ui_language" , "es" } , { "help_language" , "es" } , { "language" , "es" } , { "BAD_CODE" , "El parámetro para crear el mensaje estaba fuera de los límites" } , { "FORMAT_FAILED" , "Excepción generada durante la llamada messageFormat" } , { "version" , ">>>>>>> Versión Xalan" } , { "version2" , "<<<<<<<" } , { "yes" , "sí" } , { "line" , "Línea #" } , { "column" , "Columna #" } , { "xsldone" , "XSLProcessor: hecho" } , { "xslProc_option" , "opciones de clase Proceso de la línea de comandos Xalan-J:" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [nombre totalmente cualificado -PARSER de clase de vínculo de analizador sintáctico]" } , { "optionE" , "   [-E (No expandir refs de entidad)]" } , { "optionV" , "   [-E (No expandir refs de entidad)]" } , { "optionQC" , "   [-QC (Advertencias silenciosas de conflictos de patrones)]" } , { "optionQ" , "   [-Q  (Modo silencioso)]" } , { "optionLF" , "   [-LF (Utilizar cambios de línea sólo en la salida {el valor predeterminado es CR/LF})]" } , { "optionCR" , "   [-CR (Utilizar retornos de carro sólo en la salida {el valor predeterminado es CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (¿Cuáles son los caracteres de escape? {el valor por defecto es <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Controlar el número de espacios de indentación {el valor por defecto es 0})]" } , { "optionTT" , "   [-TT (Rastrear las plantillas según se vayan invocando.)]" } , { "optionTG" , "   [-TG (Rastrear cada suceso de generación.)]" } , { "optionTS" , "   [-TS (Rastrear cada suceso de selección.)]" } , { "optionTTC" , "   [-TTC (Rastrear las plantillas hijas según se vayan procesando.)]" } , { "optionTCLASS" , "   [-TCLASS (Clase TraceListener para las extensiones de rastreo.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Establecer si se realiza la validación.  El valor predeterminado de la validación es off.)]" } , { "optionEDUMP" , "   [-EDUMP {nombre de archivo opcional} (Hacer volcado de pila en caso de error.)]" } , { "optionXML" , "   [-XML (Utilizar el formateador XML y agregar la cabecera de XML.)]" } , { "optionTEXT" , "   [-TEXT (Utilizar el formateador de texto sencillo.)]" } , { "optionHTML" , "   [-HTML (Utilizar el formateador HTML.)]" } , { "optionPARAM" , "   [expresión de nombre -PARAM (Establecer un parámetro de hoja de estilo)]" } , { "noParsermsg1" , "Ha fallado el proceso XSL." } , { "noParsermsg2" , "** No se ha encontrado el analizador sintáctico **" } , { "noParsermsg3" , "Comprobar classpath." } , { "noParsermsg4" , "Si no tiene el analizador sintáctico XML para Java de IBM puede cargarlo de " } , { "noParsermsg5" , "AlphaWorks de IBM: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [nombre de clase completo -URIRESOLVER (Utilizar URIResolver para convertir los URIs)]" } , { "optionENTITYRESOLVER" , "   [nombre de clase completo -ENTITYRESOLVER (Utilizar EntityResolver para convertir las entidades)]" } , { "optionCONTENTHANDLER" , "   [nombre de clase completo -CONTENTHANDLER (Utilizar ContentHandler para serializar la salida)]" } , { "optionLINENUMBERS" , "   [-L utilizar números de líneas para el documento fuente]" } , { "optionMEDIA" , " [-MEDIA mediaType (utilice un atributo media para buscar las hojas de estilo asociadas con un documento.)]" } , { "optionFLAVOR" , " [-FLAVOR flavorName (utilice explícitamente s2s=SAX o d2d=DOM para la transformación.)] " } , { "optionDIAG" , " [-DIAG (la impresión tardó milisegundos.)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (solicitar una construcción DTM incremental estableciendo http://xml.apache.org/xalan/features/incremental como Verdadero.)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (solicitar no optimizar la hoja de estilo estableciendo http://xml.apache.org/xalan/features/incremental a Falso.)]" } , { "optionRL" , " [-RL recursionlimit (afirmar límite numérico en la profundidad de recursividad de la hoja de estilo.)]" } , { "optionXO" , " [-XO [transletName] (asignar nombre al translet generado)]" } , { "optionXD" , " [-XD destinationDirectory (especifica un directorio de destino para translet)]" } , { "optionXJ" , " [-XJ jarfile (empaqueta clases translet en un archivo JAR denominado <archivoJAR>)]" } , { "optionXP" , " [-XP package (especifica un prefijo de nombre de paquete para todas las clases translet generadas)]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Advertencia: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATRÓN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.423076923', '3769', '0', '0', '0.976190476', '1', '0', '0', '1251', '1', '0.3333', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Gt extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . greaterThan ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xalan . xsltc . compiler . NodeTest ; public final class NodeType extends Type { private final int _type ; protected NodeType ( ) { this ( NodeTest . ANODE ) ; } protected NodeType ( int type ) { _type = type ; } public int getType ( ) { return _type ; } public String toString ( ) { return "node-type" ; } public boolean identicalTo ( Type other ) { return other instanceof NodeType ; } public int hashCode ( ) { return _type ; } public String toSignature ( ) { return "I" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . INT ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . NodeSet ) { translateTo ( classGen , methodGen , ( NodeSetType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; switch ( _type ) { case NodeTest . ROOT : case NodeTest . ELEMENT : il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , GET_ELEMENT_VALUE , GET_ELEMENT_VALUE_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; break ; case NodeTest . ANODE : case NodeTest . COMMENT : case NodeTest . ATTRIBUTE : case NodeTest . PI : il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , GET_NODE_VALUE_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; break ; default : ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; break ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { translateTo ( classGen , methodGen , Type . String ) ; Type . String . translateTo ( classGen , methodGen , Type . Real ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeSetType type ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( SINGLETON_ITERATOR ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; final int init = cpg . addMethodref ( SINGLETON_ITERATOR , "<init>" , "(" + NODE_SIG + ")V" ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( RUNTIME_NODE_CLASS ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new PUSH ( cpg , _type ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( RUNTIME_NODE_CLASS , "<init>" , "(II)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; String className = clazz . getName ( ) ; if ( className . equals ( "java.lang.String" ) ) { translateTo ( classGen , methodGen , Type . String ) ; return ; } il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; if ( className . equals ( "org.w3c.dom.Node" ) || className . equals ( "java.lang.Object" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE , MAKE_NODE_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "org.w3c.dom.NodeList" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE_LIST , MAKE_NODE_LIST_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , className ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( RUNTIME_NODE_CLASS ) ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( RUNTIME_NODE_CLASS , NODE_FIELD , NODE_FIELD_SIG ) ) ) ; } public String getClassName ( ) { return ( RUNTIME_NODE_CLASS ) ; } public Instruction LOAD ( int slot ) { return new ILOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ISTORE ( slot ) ; } } 	0	['22', '2', '0', '42', '54', '199', '13', '32', '20', '0.571428571', '466', '1', '0', '0.622641509', '0.215909091', '2', '4', '20.13636364', '7', '1.4091', '0']
package org . apache . xpath . objects ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . res . XPATHErrorResources ; public class XStringForChars extends XString { int m_start ; int m_length ; protected String m_strCache = null ; public XStringForChars ( char [ ] val , int start , int length ) { super ( val ) ; m_start = start ; m_length = length ; if ( null == val ) throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , null ) ) ; } private XStringForChars ( String val ) { super ( val ) ; throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , null ) ) ; } public FastStringBuffer fsb ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , null ) ) ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { fsb . append ( ( char [ ] ) m_obj , m_start , m_length ) ; } public boolean hasString ( ) { return ( null != m_strCache ) ; } public String str ( ) { if ( null == m_strCache ) m_strCache = new String ( ( char [ ] ) m_obj , m_start , m_length ) ; return m_strCache ; } public Object object ( ) { return str ( ) ; } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { ch . characters ( ( char [ ] ) m_obj , m_start , m_length ) ; } public void dispatchAsComment ( org . xml . sax . ext . LexicalHandler lh ) throws org . xml . sax . SAXException { lh . comment ( ( char [ ] ) m_obj , m_start , m_length ) ; } public int length ( ) { return m_length ; } public char charAt ( int index ) { return ( ( char [ ] ) m_obj ) [ index + m_start ] ; } public void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { System . arraycopy ( ( char [ ] ) m_obj , m_start + srcBegin , dst , dstBegin , srcEnd ) ; } } 	0	['12', '4', '0', '4', '22', '4', '1', '3', '11', '0.484848485', '148', '0.333333333', '0', '0.921875', '0.25', '3', '15', '11.08333333', '2', '1', '0']
package org . apache . xalan . templates ; public class NamespaceAlias extends ElemTemplateElement { public NamespaceAlias ( int docOrderNumber ) { super ( ) ; m_docOrderNumber = docOrderNumber ; } private String m_StylesheetPrefix ; public void setStylesheetPrefix ( String v ) { m_StylesheetPrefix = v ; } public String getStylesheetPrefix ( ) { return m_StylesheetPrefix ; } private String m_StylesheetNamespace ; public void setStylesheetNamespace ( String v ) { m_StylesheetNamespace = v ; } public String getStylesheetNamespace ( ) { return m_StylesheetNamespace ; } private String m_ResultPrefix ; public void setResultPrefix ( String v ) { m_ResultPrefix = v ; } public String getResultPrefix ( ) { return m_ResultPrefix ; } private String m_ResultNamespace ; public void setResultNamespace ( String v ) { m_ResultNamespace = v ; } public String getResultNamespace ( ) { return m_ResultNamespace ; } public void recompose ( StylesheetRoot root ) { root . recomposeNamespaceAliases ( this ) ; } } 	0	['10', '3', '0', '6', '12', '37', '6', '2', '10', '0.888888889', '52', '1', '0', '0.956097561', '0.4', '1', '1', '3.8', '1', '0.9', '0']
package org . apache . xalan . res ; public class XSLTErrorResources_zh_TW extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "錯誤：在表示式內不能有 '{'" } , { ER_ILLEGAL_ATTRIBUTE , "{0} 含有不正確屬性：{1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "在 xsl:apply-imports 中的 sourceNode 為空值！" } , { ER_CANNOT_ADD , "無法將 {0} 新增至 {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "在 handleApplyTemplatesInstruction 中的 sourceNode 為空值！" } , { ER_NO_NAME_ATTRIB , "{0} 必須有 name 屬性。 " } , { ER_TEMPLATE_NOT_FOUND , "找不到名稱為 {0} 的範本" } , { ER_CANT_RESOLVE_NAME_AVT , "無法解譯 xsl:call-template 中的名稱 AVT。" } , { ER_REQUIRES_ATTRIB , "{0} 需要屬性：{1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} 必須有 ''test'' 屬性。" } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "level 屬性 {0} 上的值錯誤" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction 名稱不得為 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction 名稱必須是有效的 NCName：{0}" } , { ER_NEED_MATCH_ATTRIB , "如果 {0} 有模式的話，則它必須有 match 屬性。" } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} 需要 name 或 match 屬性。" } , { ER_CANT_RESOLVE_NSPREFIX , "無法解譯名稱空間前置：{0}" } , { ER_ILLEGAL_VALUE , "xml:space 含有不合規則的值：{0}" } , { ER_NO_OWNERDOC , "子項節點沒有擁有者文件！" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement 錯誤：{0}" } , { ER_NULL_CHILD , "嘗試新增空的子項！" } , { ER_NEED_SELECT_ATTRIB , "{0} 需要 select 屬性。" } , { ER_NEED_TEST_ATTRIB , "xsl:when 必須有 'test' 屬性。" } , { ER_NEED_NAME_ATTRIB , "xsl:with-param 必須有 'name' 屬性。" } , { ER_NO_CONTEXT_OWNERDOC , "上下文不含擁有者文件！" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "無法建立 XML TransformerFactory Liaison：{0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: 處理不成功。" } , { ER_NOT_SUCCESSFUL , "Xalan: 不成功。" } , { ER_ENCODING_NOT_SUPPORTED , "不支援編碼：{0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "無法建立 TraceListener：{0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key 需要 'name' 屬性！" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key 需要 'match' 屬性！" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key 需要 'use' 屬性！" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} 需要 ''elements'' 屬性！" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} 屬性 ''prefix'' 遺漏" } , { ER_BAD_STYLESHEET_URL , "樣式表 URL 錯誤：{0}" } , { ER_FILE_NOT_FOUND , "找不到樣式表檔案：{0}" } , { ER_IOEXCEPTION , "樣式表檔案 {0} 有輸入/輸出 (I/O) 異常" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) 找不到 {0} 的 href 屬性" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} 直接或間接包含本身！" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude 錯誤：{0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} 屬性 ''lang'' 遺漏" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) 誤置 {0} 元素？？ 遺漏 container 元素 ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "只能輸出至 Element、DocumentFragment、Document 或 PrintWriter。" } , { ER_PROCESS_ERROR , "StylesheetRoot.process 錯誤" } , { ER_UNIMPLNODE_ERROR , "UnImplNode 錯誤：{0}" } , { ER_NO_SELECT_EXPRESSION , "錯誤！未找到 xpath select 表示式 (-select)。" } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "無法串列化 XSLProcessor！" } , { ER_NO_INPUT_STYLESHEET , "未指定樣式表輸入！" } , { ER_FAILED_PROCESS_STYLESHEET , "無法處理樣式表！" } , { ER_COULDNT_PARSE_DOC , "無法剖析 {0} 文件！" } , { ER_COULDNT_FIND_FRAGMENT , "找不到片段：{0}" } , { ER_NODE_NOT_ELEMENT , "片段識別碼所指的節點不是元素：{0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each 必須有 match 或 name 屬性" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates 必須有 match 或 name 屬性" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "文件片段沒有複本！" } , { ER_CANT_CREATE_ITEM , "無法在結果樹 {0} 建立項目" } , { ER_XMLSPACE_ILLEGAL_VALUE , "來源 XML 中的 xml:space 含有不合規則的值：{0}" } , { ER_NO_XSLKEY_DECLARATION , "{0} 沒有 xsl:key 宣告！" } , { ER_CANT_CREATE_URL , "錯誤！無法建立 URL 給：{0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "不支援 xsl:functions" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory 錯誤" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} 不允許在樣式表內！" } , { ER_RESULTNS_NOT_SUPPORTED , "不再支援 result-ns！請使用 xsl:output 來代替。" } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "不再支援 default-space！請使用 xsl:strip-space 或 xsl:preserve-space 來代替。" } , { ER_INDENTRESULT_NOT_SUPPORTED , "不再支援 indent-result！請使用 xsl:output 來代替。" } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} 含有不合規則的屬性：{1}" } , { ER_UNKNOWN_XSL_ELEM , "XSL 元素：{0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort 只能與 xsl:apply-templates 或 xsl:for-each 一起使用。" } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) 誤置 xsl:when！" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when 的上代不是 xsl:choose！" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) 誤置 xsl:otherwise！" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise 的上代不是 xsl:choose！" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} 不允許在範本內！" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} 延伸程式名稱空間前置 {1} 未知" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Imports 只能出現於樣式表中作為第一個元素！" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} 直接或間接匯入本身！" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space 含有不合規則的值：{0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet 不成功！" } , { ER_SAX_EXCEPTION , "SAX 異常" } , { ER_XSLT_ERROR , "XSLT 錯誤" } , { ER_CURRENCY_SIGN_ILLEGAL , "貨幣符號不允許在格式型樣字串中" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "樣式表 DOM 不支援文件函式！" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "無法解譯非前置解析器的前置！" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "重新導向延伸程式：無法取得檔案名稱 - file 或 select 屬性必須傳回有效字串。" } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "無法在重新導向延伸程式中建立 FormatterListener！" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "exclude-result-prefixes 中的前置無效：{0}" } , { ER_MISSING_NS_URI , "遺漏指定的前置的名稱空間 URI" } , { ER_MISSING_ARG_FOR_OPTION , "遺漏選項：{0} 的引數" } , { ER_INVALID_OPTION , "無效的選項：{0}" } , { ER_MALFORMED_FORMAT_STRING , "變形的格式字串：{0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要 'version' 屬性！" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "屬性：{0} 含有不正確值：{1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose 需要 xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports 不允許在 xsl:for-each 中" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "無法對輸出 DOM 節點使用 DTMLiaison... 改為傳送 org.apache.xpath.DOM2Helper！" } , { ER_CANT_USE_DTM_FOR_INPUT , "無法對輸入 DOM 節點使用 DTMLiaison... 改為傳送 org.apache.xpath.DOM2Helper！" } , { ER_CALL_TO_EXT_FAILED , "呼叫延伸程式元素失敗：{0}" } , { ER_PREFIX_MUST_RESOLVE , "前置必須解譯為名稱空間：{0}" } , { ER_INVALID_UTF16_SURROGATE , "偵測到無效的 UTF-16 代用品：{0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} 使用本身，這將造成無窮迴圈。" } , { ER_CANNOT_MIX_XERCESDOM , "無法混合非 Xerces-DOM 輸入與 Xerces-DOM 輸出！" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "在 ElemTemplateElement.readObject：{0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "找到一個以上叫作 {0} 的範本" } , { ER_INVALID_KEY_CALL , "無效的函式呼叫：recursive key() 呼叫不被允許" } , { ER_REFERENCING_ITSELF , "變數 {0} 直接或間接參照本身！" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "對 newTemplates 的 DOMSource 而言，輸入節點不得為空值！" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "找不到選項 {0} 的類別檔案" } , { ER_REQUIRED_ELEM_NOT_FOUND , "找不到必需的元素：{0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream 不得為空值" } , { ER_URI_CANNOT_BE_NULL , "URI 不得為空值" } , { ER_FILE_CANNOT_BE_NULL , "檔案不可為空值" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource 不可為空值" } , { ER_CANNOT_INIT_BSFMGR , "無法起始設定 BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "無法編譯延伸程式" } , { ER_CANNOT_CREATE_EXTENSN , "無法建立延伸程式 {0}，因為：{1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "方法 {0} 的實例方法呼叫需要一個物件實例作為第一個引數" } , { ER_INVALID_ELEMENT_NAME , "指定的元素名稱無效 {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "元素名稱方法必須為靜態 {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "延伸程式函式 {0} : {1} 未知" } , { ER_MORE_MATCH_CONSTRUCTOR , "{0} 的最符合建構元不止一個" } , { ER_MORE_MATCH_METHOD , "最符合方法 {0} 的不止一個" } , { ER_MORE_MATCH_ELEMENT , "最符合元素方法 {0} 的不止一個" } , { ER_INVALID_CONTEXT_PASSED , "傳送來評估 {0} 的上下文無效" } , { ER_POOL_EXISTS , "儲存池已存在" } , { ER_NO_DRIVER_NAME , "未指定驅動程式名稱" } , { ER_NO_URL , "未指定 URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "儲存池大小小於 1！" } , { ER_INVALID_DRIVER , "指定的驅動程式名稱無效！" } , { ER_NO_STYLESHEETROOT , "找不到 stylesheet 根！" } , { ER_ILLEGAL_XMLSPACE_VALUE , "xml:space 的值不正確" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode 失效" } , { ER_RESOURCE_COULD_NOT_LOAD , "無法載入資源 [ {0} ]：{1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "緩衝區大小 <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "呼叫延伸程式時發生未知錯誤" } , { ER_NO_NAMESPACE_DECL , "前置 {0} 沒有對應的名稱空間宣告" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "lang=javaclass {0} 不允許元素內容" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Stylesheet 引導終止" } , { ER_ONE_OR_TWO , "1 或 2" } , { ER_TWO_OR_THREE , "2 或 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "無法載入 {0}（檢查 CLASSPATH），現在只使用預設值" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "無法起始設定預設範本" } , { ER_RESULT_NULL , "結果不應該為空值" } , { ER_RESULT_COULD_NOT_BE_SET , "無法設定結果" } , { ER_NO_OUTPUT_SPECIFIED , "未指定輸出" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "無法轉換成類型 {0} 的結果" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "無法轉換類型 {0} 的來源" } , { ER_NULL_CONTENT_HANDLER , "空的內容處理器" } , { ER_NULL_ERROR_HANDLER , "空的錯誤處理器" } , { ER_CANNOT_CALL_PARSE , "如果未設定 ContentHandler 則無法呼叫剖析" } , { ER_NO_PARENT_FOR_FILTER , "過濾器沒有上代" } , { ER_NO_STYLESHEET_IN_MEDIA , "在 {0} media= {1} 找不到樣式表" } , { ER_NO_STYLESHEET_PI , "在 {0} 中沒有發現 XML 樣式表 PI" } , { ER_NOT_SUPPORTED , "不支援：{0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "內容 {0} 的值應該是一個布林案例" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "無法於 {0} 處取得外部指令集" } , { ER_RESOURCE_COULD_NOT_FIND , "找不到資源 [ {0} ]。\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "未能辨識輸出內容：{0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "建立 ElemLiteralResult 案例失敗" } , { ER_VALUE_SHOULD_BE_NUMBER , "{0} 的值應包含可剖析的數字" } , { ER_VALUE_SHOULD_EQUAL , " {0} 的值應等於 yes 或 no" } , { ER_FAILED_CALLING_METHOD , " 呼叫 {0} 方法失敗" } , { ER_FAILED_CREATING_ELEMTMPL , "建立 ElemTemplateElement 案例失敗" } , { ER_CHARS_NOT_ALLOWED , "文件的這個地方不允許字元" } , { ER_ATTR_NOT_ALLOWED , "{1} 元素上不允許有 \"{0}\" 屬性！" } , { ER_BAD_VALUE , "{0} 錯誤值 {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "找不到 {0} 屬性值 " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "不能辨識 {0} 屬性值 " } , { ER_NULL_URI_NAMESPACE , "正在嘗試使用空 URI 產生名稱空間前置" } , { ER_NUMBER_TOO_BIG , "試圖格式化比最大的 Long 整數還要大的數字" } , { ER_CANNOT_FIND_SAX1_DRIVER , "無法找到 SAX1 驅動程式類別 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "已找到 SAX1 驅動程式類別 {0}，但是無法載入" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "已載入 SAX1 驅動程式類別 {0}，但是無法將其實例化" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 驅動程式類別 {0} 不執行 org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "未指定系統屬性 org.xml.sax.parser" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "剖析器引數不能為空" } , { ER_FEATURE , "功能：a {0}" } , { ER_PROPERTY , "屬性：a {0}" } , { ER_NULL_ENTITY_RESOLVER , "空實體解析器" } , { ER_NULL_DTD_HANDLER , "空 DTD 處理程式" } , { ER_NO_DRIVER_NAME_SPECIFIED , "未指定驅動程式名稱！" } , { ER_NO_URL_SPECIFIED , "未指定 URL！" } , { ER_POOLSIZE_LESS_THAN_ONE , "儲存區小於 1！" } , { ER_INVALID_DRIVER_NAME , "指定的驅動程式名稱無效！" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "程式設計師的錯誤！expr 沒有 ElemTemplateElement 父！" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "程式設計師在 RundundentExprEliminator 中的判斷：{0}" } , { ER_NOT_ALLOWED_IN_POSITION , "在樣式表中，此位置不允許出現 {0}！" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "在樣式表中，此位置只能是空白！" } , { INVALID_TCHAR , "不正確的值：{1} 被用於 CHAR 屬性：{0}。  CHAR 類型的屬性只能是 1 個字元！" } , { INVALID_QNAME , "不正確的值：a {1} 被用於 QNAME 屬性：a {0}" } , { INVALID_ENUM , "不正確的值：a {1} 被用於 ENUM 屬性：a {0}。  有效值為：a {2}。" } , { INVALID_NMTOKEN , "不正確的值：a {1} 被用於 NMTOKEN 屬性：a {0}" } , { INVALID_NCNAME , "不正確的值：a {1} 被用於 NCNAME 屬性：a {0}" } , { INVALID_BOOLEAN , "不正確的值：a {1} 被用於 boolean 屬性：a {0}" } , { INVALID_NUMBER , "不正確的值：a {1} 被用於 number 屬性：a {0}" } , { ER_ARG_LITERAL , "在相符型樣中 {0} 的引數必須是文字。" } , { ER_DUPLICATE_GLOBAL_VAR , "重複的全域變數宣告。" } , { ER_DUPLICATE_VAR , "重複的變數宣告。" } , { ER_TEMPLATE_NAME_MATCH , "xsl:template 必須有一個名稱或相符屬性 (或兩者均有)" } , { ER_INVALID_PREFIX , "exclude-result-prefixes 中的前置無效：a {0}" } , { ER_NO_ATTRIB_SET , "名為 {0} 的 attribute-set 不存在" } , { WG_FOUND_CURLYBRACE , "找到 '}' 但沒有開啟的屬性範本！" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "警告：count 屬性不符合 xsl:number 中的祖先節點！目標 = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "舊語法：'expr' 屬性的名稱已變更為 'select'。" } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan 尚未處理 format-number 函式中的語言環境名稱。" } , { WG_LOCALE_NOT_FOUND , "警告：找不到 xml:lang={0} 的語言環境" } , { WG_CANNOT_MAKE_URL_FROM , "無法從： {0} 產生 URL" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "無法載入所要求的文件：{0}" } , { WG_CANNOT_FIND_COLLATOR , "找不到 <sort xml:lang={0} 的理序器" } , { WG_FUNCTIONS_SHOULD_USE_URL , "舊語法：函式指令應使用 URL {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "不支援編碼：{0}，使用 UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "不支援編碼：{0}，使用 Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "找到具體衝突：{0} 將使用在樣式表中找到的最後一個。" } , { WG_PARSING_AND_PREPARING , "========= 剖析及準備 {0} ==========" } , { WG_ATTR_TEMPLATE , "Attr 範本，{0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "xsl:strip-space 和 xsl:preserve-space 之間發生符合衝突" } , { WG_ATTRIB_NOT_HANDLED , "Xalan 尚未處理 {0} 屬性！" } , { WG_NO_DECIMALFORMAT_DECLARATION , "找不到十進位格式的宣告：{0}" } , { WG_OLD_XSLT_NS , "XSLT 名稱空間遺漏或不正確。" } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "僅允許一個預設 xsl:decimal-format 宣告。" } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format 名稱必須是唯一的。 \"{0}\" 名稱重複。" } , { WG_ILLEGAL_ATTRIBUTE , "{0} 含有不合規則的屬性：{1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "無法解譯名稱空間前置：{0}。節點被忽略。" } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要 'version' 屬性！" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "不合規則的屬性名稱：{0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "屬性 {0} 使用了不合規則的值：{1}" } , { WG_EMPTY_SECOND_ARG , "從文件函式第二個引數產生的節點集是空值。將使用第一個引數。" } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "xsl:processing-instruction 名稱之 'name' 屬性的值不能是 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "xsl:processing-instruction 之 ''name'' 屬性的值必須是一個有效的 NCName：a {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "無法在產生子節點之後或產生元素之前加入屬性 {0}。  屬性將被忽略。" } , { "ui_language" , "zh_TW" } , { "help_language" , "zh_TW" } , { "language" , "zh_TW" } , { "BAD_CODE" , "createMessage 的參數超出界限" } , { "FORMAT_FAILED" , "在 messageFormat 呼叫期間丟出異常" } , { "version" , ">>>>>>> Xalan 版本 " } , { "version2" , "<<<<<<<" } , { "yes" , "是" } , { "line" , "行 #" } , { "column" , "直欄 #" } , { "xsldone" , "XSLProcessor: done" } , { "xslProc_option" , "Xalan-J 指令行 Process 類別選項：" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER 剖析器關聯別名的完整名稱]" } , { "optionE" , "   [-E (不展開實體參照)]" } , { "optionV" , "   [-E (不展開實體參照)]" } , { "optionQC" , "   [-QC (無聲型樣衝突警告)]" } , { "optionQ" , "   [-Q  (無聲模式)]" } , { "optionLF" , "   [-LF (只在輸出上使用換行 {預設是 CR/LF})]" } , { "optionCR" , "   [-CR (只在輸出上使用換行鍵 {預設是 CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (要逸出的字元 {預設是 <>&\"\'\\r\\n})]" } , { "optionINDENT" , "   [-INDENT (控制要內縮的空格數 {預設是 0})]" } , { "optionTT" , "   [-TT (呼叫時追蹤範本。)]" } , { "optionTG" , "   [-TG (追蹤每一個產生事件。)]" } , { "optionTS" , "   [-TS (追蹤每一個選取事件。)]" } , { "optionTTC" , "   [-TTC (追蹤處理中的範本子項。)]" } , { "optionTCLASS" , "   [-TCLASS (追蹤延伸程式的 TraceListener 類別。)]" } , { "optionVALIDATE" , "   [-VALIDATE (設定是否發生驗證。依預設驗證是關閉的。)]" } , { "optionEDUMP" , "   [-EDUMP {可選用的檔案名稱} (發生錯誤時執行 stackdump。)]" } , { "optionXML" , "   [-XML (使用 XML 格式製作器及新增 XML 表頭。)]" } , { "optionTEXT" , "   [-TEXT (使用簡式文字格式化程式。)]" } , { "optionHTML" , "   [-HTML (使用 HTML 格式製作器。)]" } , { "optionPARAM" , "   [-PARAM 名稱表示式 (設定樣式表參數)]" } , { "noParsermsg1" , "XSL 處理不成功。" } , { "noParsermsg2" , "** 找不到剖析器 **" } , { "noParsermsg3" , "請檢查類別路徑。" } , { "noParsermsg4" , "如果您沒有 IBM 的 XML Parser for Java，可下載自 " } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER 完整的類別名稱 (URIResolver 用來解譯 URI)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER 完整的類別名稱 (EntityResolver 用來解譯實體)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER 完整的類別名稱 (ContentHandler 用來串列化輸出)]" } , { "optionLINENUMBERS" , "   [-L 使用原始文件的行號]" } , { "optionMEDIA" , " [-MEDIA mediaType (使用媒體屬性尋找與文件關聯的樣式表。)]" } , { "optionFLAVOR" , " [-FLAVOR flavorName (明確是使用 s2s=SAX 還是 d2d=DOM 來執行轉換。)] " } , { "optionDIAG" , " [-DIAG (列印轉換作業花費的總毫秒數。)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (透過將 http://xml.apache.org/xalan/features/incremental 設定為「真」，要求遞增的 DTM 建構。)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (透過將 http://xml.apache.org/xalan/features/optimize 設定為「假」，要求無樣式表最佳化處理。)]" } , { "optionRL" , " [-RL 循環限制 (假設在樣式表循環深度上數字限制。)]" } , { "optionXO" , " [-XO [transletName] (指定產生的 translet 名稱)]" } , { "optionXD" , " [-XD destinationDirectory (指定 translet 的目標目錄)]" } , { "optionXJ" , " [-XJ jarfile (將 translet 類別封裝成名為 <jarfile> 的 jar 檔)]" } , { "optionXP" , " [-XP package (指定所有 translet 類別的封裝名稱前置)]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "錯誤：" ; public static final String WARNING_HEADER = "警告：" ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.423076923', '3769', '0', '0', '0.976190476', '1', '0', '0', '1251', '1', '0.3333', '0']
package org . w3c . dom . xpath ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; public interface XPathEvaluator { public XPathExpression createExpression ( String expression , XPathNSResolver resolver ) throws XPathException , DOMException ; public XPathNSResolver createNSResolver ( Node nodeResolver ) ; public Object evaluate ( String expression , Node contextNode , XPathNSResolver resolver , short type , Object result ) throws XPathException , DOMException ; } 	0	['3', '1', '0', '0', '3', '3', '0', '0', '3', '2', '3', '0', '0', '0', '0.611111111', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Bool extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { if ( XObject . CLASS_BOOLEAN == right . getType ( ) ) return right ; else return right . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_right . bool ( xctxt ) ; } } 	0	['3', '3', '0', '6', '7', '3', '1', '5', '3', '2', '24', '0', '0', '0.952380952', '0.555555556', '1', '1', '7', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class ConcatCall extends FunctionCall { public ConcatCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { for ( int i = 0 ; i < argumentCount ( ) ; i ++ ) { final Expression exp = argument ( i ) ; if ( ! exp . typeCheck ( stable ) . identicalTo ( Type . String ) ) { setArgument ( i , new CastExpr ( exp , Type . String ) ) ; } } return _type = Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int nArgs = argumentCount ( ) ; switch ( nArgs ) { case 0 : il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; break ; case 1 : argument ( ) . translate ( classGen , methodGen ) ; break ; default : final int initBuffer = cpg . addMethodref ( STRING_BUFFER_CLASS , "<init>" , "()V" ) ; final Instruction append = new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_BUFFER_CLASS , "append" , "(" + STRING_SIG + ")" + STRING_BUFFER_SIG ) ) ; final int toString = cpg . addMethodref ( STRING_BUFFER_CLASS , "toString" , "()" + STRING_SIG ) ; il . append ( new NEW ( cpg . addClass ( STRING_BUFFER_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( initBuffer ) ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { argument ( i ) . translate ( classGen , methodGen ) ; il . append ( append ) ; } il . append ( new INVOKEVIRTUAL ( toString ) ) ; } } } 	0	['3', '4', '0', '19', '22', '3', '0', '19', '3', '2', '131', '0', '0', '0.979591837', '0.444444444', '3', '14', '42.66666667', '5', '2', '0']
package org . apache . xalan . lib ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . util . Hashtable ; import javax . xml . transform . Result ; import javax . xml . transform . TransformerException ; import javax . xml . transform . stream . StreamResult ; import org . apache . xalan . extensions . XSLProcessorContext ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . ContentHandler ; public class Redirect { protected Hashtable m_formatterListeners = new Hashtable ( ) ; protected Hashtable m_outputStreams = new Hashtable ( ) ; public static final boolean DEFAULT_APPEND_OPEN = false ; public static final boolean DEFAULT_APPEND_WRITE = false ; public void open ( XSLProcessorContext context , ElemExtensionCall elem ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { String fileName = getFilename ( context , elem ) ; Object flistener = m_formatterListeners . get ( fileName ) ; if ( null == flistener ) { String mkdirsExpr = elem . getAttribute ( "mkdirs" , context . getContextNode ( ) , context . getTransformer ( ) ) ; boolean mkdirs = ( mkdirsExpr != null ) ? ( mkdirsExpr . equals ( "true" ) || mkdirsExpr . equals ( "yes" ) ) : true ; String appendExpr = elem . getAttribute ( "append" , context . getContextNode ( ) , context . getTransformer ( ) ) ; boolean append = ( appendExpr != null ) ? ( appendExpr . equals ( "true" ) || appendExpr . equals ( "yes" ) ) : DEFAULT_APPEND_OPEN ; Object ignored = makeFormatterListener ( context , elem , fileName , true , mkdirs , append ) ; } } public void write ( XSLProcessorContext context , ElemExtensionCall elem ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { String fileName = getFilename ( context , elem ) ; Object flObject = m_formatterListeners . get ( fileName ) ; ContentHandler formatter ; boolean inTable = false ; if ( null == flObject ) { String mkdirsExpr = ( ( ElemExtensionCall ) elem ) . getAttribute ( "mkdirs" , context . getContextNode ( ) , context . getTransformer ( ) ) ; boolean mkdirs = ( mkdirsExpr != null ) ? ( mkdirsExpr . equals ( "true" ) || mkdirsExpr . equals ( "yes" ) ) : true ; String appendExpr = elem . getAttribute ( "append" , context . getContextNode ( ) , context . getTransformer ( ) ) ; boolean append = ( appendExpr != null ) ? ( appendExpr . equals ( "true" ) || appendExpr . equals ( "yes" ) ) : DEFAULT_APPEND_WRITE ; formatter = makeFormatterListener ( context , elem , fileName , true , mkdirs , append ) ; } else { inTable = true ; formatter = ( ContentHandler ) flObject ; } TransformerImpl transf = context . getTransformer ( ) ; transf . executeChildTemplates ( elem , context . getContextNode ( ) , context . getMode ( ) , formatter ) ; if ( ! inTable ) { OutputStream ostream = ( OutputStream ) m_outputStreams . get ( fileName ) ; if ( null != ostream ) { try { formatter . endDocument ( ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } ostream . close ( ) ; m_outputStreams . remove ( fileName ) ; m_formatterListeners . remove ( fileName ) ; } } } public void close ( XSLProcessorContext context , ElemExtensionCall elem ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { String fileName = getFilename ( context , elem ) ; Object formatterObj = m_formatterListeners . get ( fileName ) ; if ( null != formatterObj ) { ContentHandler fl = ( ContentHandler ) formatterObj ; try { fl . endDocument ( ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } OutputStream ostream = ( OutputStream ) m_outputStreams . get ( fileName ) ; if ( null != ostream ) { ostream . close ( ) ; m_outputStreams . remove ( fileName ) ; } m_formatterListeners . remove ( fileName ) ; } } private String getFilename ( XSLProcessorContext context , ElemExtensionCall elem ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { String fileName ; String fileNameExpr = ( ( ElemExtensionCall ) elem ) . getAttribute ( "select" , context . getContextNode ( ) , context . getTransformer ( ) ) ; if ( null != fileNameExpr ) { org . apache . xpath . XPathContext xctxt = context . getTransformer ( ) . getXPathContext ( ) ; XPath myxpath = new XPath ( fileNameExpr , elem , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; XObject xobj = myxpath . execute ( xctxt , context . getContextNode ( ) , elem ) ; fileName = xobj . str ( ) ; if ( ( null == fileName ) || ( fileName . length ( ) == 0 ) ) { fileName = elem . getAttribute ( "file" , context . getContextNode ( ) , context . getTransformer ( ) ) ; } } else { fileName = elem . getAttribute ( "file" , context . getContextNode ( ) , context . getTransformer ( ) ) ; } if ( null == fileName ) { context . getTransformer ( ) . getMsgMgr ( ) . error ( elem , elem , context . getContextNode ( ) , XSLTErrorResources . ER_REDIRECT_COULDNT_GET_FILENAME ) ; } return fileName ; } private String urlToFileName ( String base ) { if ( null != base ) { if ( base . startsWith ( "file:////" ) ) { base = base . substring ( 7 ) ; } else if ( base . startsWith ( "file:///" ) ) { base = base . substring ( 6 ) ; } else if ( base . startsWith ( "file://" ) ) { base = base . substring ( 5 ) ; } else if ( base . startsWith ( "file:/" ) ) { base = base . substring ( 5 ) ; } else if ( base . startsWith ( "file:" ) ) { base = base . substring ( 4 ) ; } } return base ; } private ContentHandler makeFormatterListener ( XSLProcessorContext context , ElemExtensionCall elem , String fileName , boolean shouldPutInTable , boolean mkdirs , boolean append ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { File file = new File ( fileName ) ; TransformerImpl transformer = context . getTransformer ( ) ; String base ; if ( ! file . isAbsolute ( ) ) { Result outputTarget = transformer . getOutputTarget ( ) ; if ( ( null != outputTarget ) && ( ( base = outputTarget . getSystemId ( ) ) != null ) ) { base = urlToFileName ( base ) ; } else { base = urlToFileName ( transformer . getBaseURLOfSource ( ) ) ; } if ( null != base ) { File baseFile = new File ( base ) ; file = new File ( baseFile . getParent ( ) , fileName ) ; } } if ( mkdirs ) { String dirStr = file . getParent ( ) ; if ( ( null != dirStr ) && ( dirStr . length ( ) > 0 ) ) { File dir = new File ( dirStr ) ; dir . mkdirs ( ) ; } } OutputProperties format = transformer . getOutputFormat ( ) ; FileOutputStream ostream = new FileOutputStream ( file . getPath ( ) , append ) ; try { SerializationHandler flistener = transformer . createSerializationHandler ( new StreamResult ( ostream ) , format ) ; try { flistener . startDocument ( ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } if ( shouldPutInTable ) { m_outputStreams . put ( fileName , ostream ) ; m_formatterListeners . put ( fileName , flistener ) ; } return flistener ; } catch ( TransformerException te ) { throw new javax . xml . transform . TransformerException ( te ) ; } } } 	0	['7', '1', '0', '12', '45', '1', '0', '12', '4', '0.75', '499', '0.5', '0', '0', '0.571428571', '0', '0', '69.71428571', '7', '1.7143', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Whitespace extends TopLevelElement { public static final int USE_PREDICATE = 0 ; public static final int STRIP_SPACE = 1 ; public static final int PRESERVE_SPACE = 2 ; public static final int RULE_NONE = 0 ; public static final int RULE_ELEMENT = 1 ; public static final int RULE_NAMESPACE = 2 ; public static final int RULE_ALL = 3 ; private String _elementList ; private int _action ; private int _importPrecedence ; private final static class WhitespaceRule { private final int _action ; private String _namespace ; private String _element ; private int _type ; private int _priority ; public WhitespaceRule ( int action , String element , int precedence ) { _action = action ; final int colon = element . indexOf ( ':' ) ; if ( colon >= 0 ) { _namespace = element . substring ( 0 , colon ) ; _element = element . substring ( colon + 1 , element . length ( ) ) ; } else { _namespace = Constants . EMPTYSTRING ; _element = element ; } _priority = precedence << 2 ; if ( _element . equals ( "*" ) ) { if ( _namespace == Constants . EMPTYSTRING ) { _type = RULE_ALL ; _priority += 2 ; } else { _type = RULE_NAMESPACE ; _priority += 1 ; } } else { _type = RULE_ELEMENT ; } } public int compareTo ( WhitespaceRule other ) { return _priority < other . _priority ? - 1 : _priority > other . _priority ? 1 : 0 ; } public int getAction ( ) { return _action ; } public int getStrength ( ) { return _type ; } public int getPriority ( ) { return _priority ; } public String getElement ( ) { return _element ; } public String getNamespace ( ) { return _namespace ; } } public void parseContents ( Parser parser ) { _action = _qname . getLocalPart ( ) . endsWith ( "strip-space" ) ? STRIP_SPACE : PRESERVE_SPACE ; _importPrecedence = parser . getCurrentImportPrecedence ( ) ; _elementList = getAttribute ( "elements" ) ; if ( _elementList == null || _elementList . length ( ) == 0 ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "elements" ) ; return ; } final SymbolTable stable = parser . getSymbolTable ( ) ; StringTokenizer list = new StringTokenizer ( _elementList ) ; StringBuffer elements = new StringBuffer ( Constants . EMPTYSTRING ) ; while ( list . hasMoreElements ( ) ) { String token = list . nextToken ( ) ; String prefix ; String namespace ; int col ; if ( ( col = token . indexOf ( ':' ) ) != - 1 ) { prefix = token . substring ( 0 , col ) ; } else { prefix = Constants . EMPTYSTRING ; } namespace = lookupNamespace ( prefix ) ; if ( namespace != null ) elements . append ( namespace + ":" + token . substring ( col + 1 , token . length ( ) ) ) ; else elements . append ( token ) ; if ( list . hasMoreElements ( ) ) elements . append ( " " ) ; } _elementList = elements . toString ( ) ; } public Vector getRules ( ) { final Vector rules = new Vector ( ) ; final StringTokenizer list = new StringTokenizer ( _elementList ) ; while ( list . hasMoreElements ( ) ) { rules . add ( new WhitespaceRule ( _action , list . nextToken ( ) , _importPrecedence ) ) ; } return rules ; } private static WhitespaceRule findContradictingRule ( Vector rules , WhitespaceRule rule ) { for ( int i = 0 ; i < rules . size ( ) ; i ++ ) { WhitespaceRule currentRule = ( WhitespaceRule ) rules . elementAt ( i ) ; if ( currentRule == rule ) { return null ; } switch ( currentRule . getStrength ( ) ) { case RULE_ALL : return currentRule ; case RULE_ELEMENT : if ( ! rule . getElement ( ) . equals ( currentRule . getElement ( ) ) ) { break ; } case RULE_NAMESPACE : if ( rule . getNamespace ( ) . equals ( currentRule . getNamespace ( ) ) ) { return currentRule ; } break ; } } return null ; } private static int prioritizeRules ( Vector rules ) { WhitespaceRule currentRule ; int defaultAction = PRESERVE_SPACE ; quicksort ( rules , 0 , rules . size ( ) - 1 ) ; boolean strip = false ; for ( int i = 0 ; i < rules . size ( ) ; i ++ ) { currentRule = ( WhitespaceRule ) rules . elementAt ( i ) ; if ( currentRule . getAction ( ) == STRIP_SPACE ) { strip = true ; } } if ( ! strip ) { rules . removeAllElements ( ) ; return PRESERVE_SPACE ; } for ( int idx = 0 ; idx < rules . size ( ) ; ) { currentRule = ( WhitespaceRule ) rules . elementAt ( idx ) ; if ( findContradictingRule ( rules , currentRule ) != null ) { rules . remove ( idx ) ; } else { if ( currentRule . getStrength ( ) == RULE_ALL ) { defaultAction = currentRule . getAction ( ) ; for ( int i = idx ; i < rules . size ( ) ; i ++ ) { rules . removeElementAt ( i ) ; } } idx ++ ; } } if ( rules . size ( ) == 0 ) { return defaultAction ; } do { currentRule = ( WhitespaceRule ) rules . lastElement ( ) ; if ( currentRule . getAction ( ) == defaultAction ) { rules . removeElementAt ( rules . size ( ) - 1 ) ; } else { break ; } } while ( rules . size ( ) > 0 ) ; return defaultAction ; } public static void compileStripSpace ( BranchHandle strip [ ] , int sCount , InstructionList il ) { final InstructionHandle target = il . append ( ICONST_1 ) ; il . append ( IRETURN ) ; for ( int i = 0 ; i < sCount ; i ++ ) { strip [ i ] . setTarget ( target ) ; } } public static void compilePreserveSpace ( BranchHandle preserve [ ] , int pCount , InstructionList il ) { final InstructionHandle target = il . append ( ICONST_0 ) ; il . append ( IRETURN ) ; for ( int i = 0 ; i < pCount ; i ++ ) { preserve [ i ] . setTarget ( target ) ; } } private static void compilePredicate ( Vector rules , int defaultAction , ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final MethodGenerator stripSpace = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT } , new String [ ] { "dom" , "node" , "type" } , "stripSpace" , classGen . getClassName ( ) , il , cpg ) ; classGen . addInterface ( "org/apache/xalan/xsltc/StripFilter" ) ; final int paramDom = stripSpace . getLocalIndex ( "dom" ) ; final int paramCurrent = stripSpace . getLocalIndex ( "node" ) ; final int paramType = stripSpace . getLocalIndex ( "type" ) ; BranchHandle strip [ ] = new BranchHandle [ rules . size ( ) ] ; BranchHandle preserve [ ] = new BranchHandle [ rules . size ( ) ] ; int sCount = 0 ; int pCount = 0 ; for ( int i = 0 ; i < rules . size ( ) ; i ++ ) { WhitespaceRule rule = ( WhitespaceRule ) rules . elementAt ( i ) ; final int gns = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceName" , "(I)Ljava/lang/String;" ) ; final int strcmp = cpg . addMethodref ( "java/lang/String" , "compareTo" , "(Ljava/lang/String;)I" ) ; if ( rule . getStrength ( ) == RULE_NAMESPACE ) { il . append ( new ALOAD ( paramDom ) ) ; il . append ( new ILOAD ( paramCurrent ) ) ; il . append ( new INVOKEINTERFACE ( gns , 2 ) ) ; il . append ( new PUSH ( cpg , rule . getNamespace ( ) ) ) ; il . append ( new INVOKEVIRTUAL ( strcmp ) ) ; il . append ( ICONST_0 ) ; if ( rule . getAction ( ) == STRIP_SPACE ) { strip [ sCount ++ ] = il . append ( new IF_ICMPEQ ( null ) ) ; } else { preserve [ pCount ++ ] = il . append ( new IF_ICMPEQ ( null ) ) ; } } else if ( rule . getStrength ( ) == RULE_ELEMENT ) { final Parser parser = classGen . getParser ( ) ; QName qname ; if ( rule . getNamespace ( ) != Constants . EMPTYSTRING ) qname = parser . getQName ( rule . getNamespace ( ) , null , rule . getElement ( ) ) ; else qname = parser . getQName ( rule . getElement ( ) ) ; final int elementType = xsltc . registerElement ( qname ) ; il . append ( new ILOAD ( paramType ) ) ; il . append ( new PUSH ( cpg , elementType ) ) ; if ( rule . getAction ( ) == STRIP_SPACE ) strip [ sCount ++ ] = il . append ( new IF_ICMPEQ ( null ) ) ; else preserve [ pCount ++ ] = il . append ( new IF_ICMPEQ ( null ) ) ; } } if ( defaultAction == STRIP_SPACE ) { compileStripSpace ( strip , sCount , il ) ; compilePreserveSpace ( preserve , pCount , il ) ; } else { compilePreserveSpace ( preserve , pCount , il ) ; compileStripSpace ( strip , sCount , il ) ; } stripSpace . stripAttributes ( true ) ; stripSpace . setMaxLocals ( ) ; stripSpace . setMaxStack ( ) ; stripSpace . removeNOPs ( ) ; classGen . addMethod ( stripSpace . getMethod ( ) ) ; } private static void compileDefault ( int defaultAction , ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final MethodGenerator stripSpace = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT } , new String [ ] { "dom" , "node" , "type" } , "stripSpace" , classGen . getClassName ( ) , il , cpg ) ; classGen . addInterface ( "org/apache/xalan/xsltc/StripFilter" ) ; if ( defaultAction == STRIP_SPACE ) il . append ( ICONST_1 ) ; else il . append ( ICONST_0 ) ; il . append ( IRETURN ) ; stripSpace . stripAttributes ( true ) ; stripSpace . setMaxLocals ( ) ; stripSpace . setMaxStack ( ) ; stripSpace . removeNOPs ( ) ; classGen . addMethod ( stripSpace . getMethod ( ) ) ; } public static int translateRules ( Vector rules , ClassGenerator classGen ) { final int defaultAction = prioritizeRules ( rules ) ; if ( rules . size ( ) == 0 ) { compileDefault ( defaultAction , classGen ) ; return defaultAction ; } compilePredicate ( rules , defaultAction , classGen ) ; return USE_PREDICATE ; } private static void quicksort ( Vector rules , int p , int r ) { while ( p < r ) { final int q = partition ( rules , p , r ) ; quicksort ( rules , p , q ) ; p = q + 1 ; } } private static int partition ( Vector rules , int p , int r ) { final WhitespaceRule x = ( WhitespaceRule ) rules . elementAt ( ( p + r ) > > > 1 ) ; int i = p - 1 , j = r + 1 ; while ( true ) { while ( x . compareTo ( ( WhitespaceRule ) rules . elementAt ( -- j ) ) < 0 ) { } while ( x . compareTo ( ( WhitespaceRule ) rules . elementAt ( ++ i ) ) > 0 ) { } if ( i < j ) { final WhitespaceRule tmp = ( WhitespaceRule ) rules . elementAt ( i ) ; rules . setElementAt ( rules . elementAt ( j ) , i ) ; rules . setElementAt ( tmp , j ) ; } else { return j ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	0	['14', '3', '0', '30', '79', '79', '1', '29', '7', '1.030769231', '805', '0.3', '0', '0.821917808', '0.207142857', '2', '6', '55.78571429', '11', '3.5714', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class UnresolvedRef extends VariableRefBase { private QName _variableName = null ; private VariableRefBase _ref = null ; private VariableBase _var = null ; private Stylesheet _sheet = null ; public UnresolvedRef ( QName name ) { super ( ) ; _variableName = name ; _sheet = getStylesheet ( ) ; } public QName getName ( ) { return ( _variableName ) ; } private ErrorMsg reportError ( ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . VARIABLE_UNDEF_ERR , _variableName , this ) ; getParser ( ) . reportError ( Constants . ERROR , err ) ; return ( err ) ; } private VariableRefBase resolve ( Parser parser , SymbolTable stable ) { VariableBase ref = parser . lookupVariable ( _variableName ) ; if ( ref == null ) ref = ( VariableBase ) stable . lookupName ( _variableName ) ; if ( ref == null ) { reportError ( ) ; return null ; } if ( ( _var = findParentVariable ( ) ) != null ) _var . addDependency ( ref ) ; if ( ref instanceof Variable ) return ( new VariableRef ( ( Variable ) ref ) ) ; else if ( ref instanceof Param ) return ( new ParameterRef ( ( Param ) ref ) ) ; else return null ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _ref != null ) { final String name = _variableName . toString ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . CIRCULAR_VARIABLE_ERR , name , this ) ; } if ( ( _ref = resolve ( getParser ( ) , stable ) ) != null ) { return ( _type = _ref . typeCheck ( stable ) ) ; } throw new TypeCheckError ( reportError ( ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _ref != null ) _ref . translate ( classGen , methodGen ) ; else reportError ( ) ; } public String toString ( ) { return "unresolved-ref()" ; } } 	0	['7', '4', '0', '16', '22', '0', '0', '16', '5', '0.625', '153', '1', '4', '0.926829268', '0.30952381', '2', '4', '20.28571429', '6', '1.7143', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Lt extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . lessThan ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xalan . res ; public class XSLTErrorResources_ja extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "エラー: 式の中で '{' を持つことはできません" } , { ER_ILLEGAL_ATTRIBUTE , "{0} に不当な属性が含まれています: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "xsl:apply-imports で sourceNode が null です" } , { ER_CANNOT_ADD , "{0} を {1} に追加できません" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "handleApplyTemplatesInstruction で sourceNode が null です。" } , { ER_NO_NAME_ATTRIB , "{0} には名前属性が必要です。" } , { ER_TEMPLATE_NOT_FOUND , "{0} という名前のテンプレートが見つかりませんでした。" } , { ER_CANT_RESOLVE_NAME_AVT , "xls:call-template で名前 AVT を解決できませんでした。" } , { ER_REQUIRES_ATTRIB , "{0} には属性 {1} が必要です:" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} には ''test'' 属性が必要です。" } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "レベル属性に不正な値が指定されています: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction 名は 'xml' にできません" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction 名は有効な NCName でなくてはなりません: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} にモードがある場合、一致する属性を持たなくてはなりません。" } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} は name 属性か、または match 属性を必要とします。" } , { ER_CANT_RESOLVE_NSPREFIX , "名前空間の接頭辞 {0} を解決できません" } , { ER_ILLEGAL_VALUE , "xml:space に不当な値があります: {0}" } , { ER_NO_OWNERDOC , "子ノードは所有者ドキュメントを保持しません。" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement エラー: {0}" } , { ER_NULL_CHILD , "null である子を追加しています。" } , { ER_NEED_SELECT_ATTRIB , "{0} は select 属性が必要です。" } , { ER_NEED_TEST_ATTRIB , "xsl:when には 'test' 属性が必要です。" } , { ER_NEED_NAME_ATTRIB , "xsl:with-param には 'name' 属性が必要です。" } , { ER_NO_CONTEXT_OWNERDOC , "コンテキストは所有者ドキュメントを保持しません。" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "XML TransformerFactory Liaison {0} を作成できませんでした。" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: プロセスは成功しませんでした。" } , { ER_NOT_SUCCESSFUL , "Xalan: は成功しませんでした。" } , { ER_ENCODING_NOT_SUPPORTED , "エンコーディングはサポートされていません: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "TraceListener を作成できませんでした: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key には 'name' 属性が必要です。" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key には 'match' 属性が必要です。" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key には 'use' 属性が必要です。" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} には ''elements'' 属性が必要です。" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} 属性に ''prefix'' が足りません" } , { ER_BAD_STYLESHEET_URL , "スタイルシートの URL が不正です: {0}" } , { ER_FILE_NOT_FOUND , "スタイルシートファイルが見つかりませんでした: {0}" } , { ER_IOEXCEPTION , "スタイルシートファイルで入出力例外が発生しました: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) {0} の href 属性が見つかりませんでした" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} は直接的または間接的に自身をインクルードしています。" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude エラー、{0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} 属性 ''lang'' が足りません" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) {0} 要素を配置し忘れていませんか?? コンテナ要素 ''component'' が足りません" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Element、DocumentFragment、Document、または PrintWriter にだけ出力できます。" } , { ER_PROCESS_ERROR , "StylesheetRoot.process エラー" } , { ER_UNIMPLNODE_ERROR , "UnImplNode エラー: {0}" } , { ER_NO_SELECT_EXPRESSION , "エラー。xpath の選択式 (-select) が見つかりませんでした。" } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "XSLProcessor を直列化できません。" } , { ER_NO_INPUT_STYLESHEET , "スタイルシートの入力が指定されませんでした。" } , { ER_FAILED_PROCESS_STYLESHEET , "スタイルシートでの処理に失敗しました。" } , { ER_COULDNT_PARSE_DOC , "{0} ドキュメントを構文解析できませんでした。" } , { ER_COULDNT_FIND_FRAGMENT , "フラグメント {0} が見つかりませんでした" } , { ER_NODE_NOT_ELEMENT , "フラグメント識別子が指すノードが要素ではありませんでした: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each は match 属性または name 属性を持たなくてはなりません" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "テンプレートは match 属性または name 属性を持たなくてはなりません" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "ドキュメントのフラグメントにクローンがありません。" } , { ER_CANT_CREATE_ITEM , "結果ツリーに項目を作成できません: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "ソース XML の xml:space に不当な値があります: {0}" } , { ER_NO_XSLKEY_DECLARATION , "{0} に xsl:key 宣言がありません。" } , { ER_CANT_CREATE_URL , "エラー。{0} の URL を作成できません" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions はサポートされていません" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory エラー" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} はスタイルシート内で許可されません。" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns はもうサポートされていません。代わりに xsl:output を使用してください。" } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space はもうサポートされていません。代わりに xsl:strip-space または xsl:preserve-space を使用してください。" } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result はもうサポートされていません。代わりに xsl:output を使用してください。" } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} に不当な属性があります: {1}" } , { ER_UNKNOWN_XSL_ELEM , "未知の XSL 要素: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort は xsl:apply-templates または xsl:for-each といっしょにのみ使用できます。" } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when の配置が誤っています。" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when の親は xsl:choose ではありません。" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise の配置が誤っています。" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise の親は xsl:choose ではありません。" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} はテンプレートの中に置くことを許可されません。" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} 拡張名前空間の接頭辞 {1} が未知です" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) スタイルシートの最初の要素でのみインポートが実行可能です。" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} は直接的または間接的に自身をインポートしています。" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space に不当な値があります: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet は成功しません。" } , { ER_SAX_EXCEPTION , "SAX 例外" } , { ER_XSLT_ERROR , "XSLT エラー" } , { ER_CURRENCY_SIGN_ILLEGAL , "通貨記号は書式パターン文字列で許可されません。" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Document 関数は Stylesheet DOM でサポートされません。" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "non-Prefix リゾルバの接頭辞は解決できません。" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Rediret 拡張: ファイル名を取得できませんでした - file 属性または select 属性が有効な文字列を戻す必要があります。 " } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Redirect 拡張で FormatterListener を構築できません。" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "exclude-result-prefixes の接頭辞が有効ではありません: {0}" } , { ER_MISSING_NS_URI , "指定された接頭辞の名前空間 URI がありません" } , { ER_MISSING_ARG_FOR_OPTION , "オプションの引数がありません: {0}" } , { ER_INVALID_OPTION , "無効なオプション: {0}" } , { ER_MALFORMED_FORMAT_STRING , "形式の誤った文字列: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet には 'version' 属性が必要です。" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "属性: {0} に不当な値があります: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose には xsl:when が必要です" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports は xsl:for-each で許可されません" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "出力 DOM ノードに DTMLiaison を使用できません... 代わりに org.apache.xpath.DOM2Helper を渡します。" } , { ER_CANT_USE_DTM_FOR_INPUT , "入力 DOM ノードに DTMLiaison を使用できません... 代わりに org.apache.xpath.DOM2Helper を渡します。" } , { ER_CALL_TO_EXT_FAILED , "拡張要素の呼び出しに失敗しました: {0}" } , { ER_PREFIX_MUST_RESOLVE , "接頭辞は名前空間に変わる必要があります: {0}" } , { ER_INVALID_UTF16_SURROGATE , "無効な UTF-16 代理が検出されました: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} は自身を使用したため、無限ループが発生します。" } , { ER_CANNOT_MIX_XERCESDOM , "非 Xerces-DOM 入力と Xerces-DOM 出力を混合できません。" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "ElemTemplateElement.readObject に {0} があります" } , { ER_DUPLICATE_NAMED_TEMPLATE , "以下に示す名前のテンプレートが複数見つかりました: {0}" } , { ER_INVALID_KEY_CALL , "無効な関数呼び出し: recursive key() 呼び出しは許可されません" } , { ER_REFERENCING_ITSELF , "変数 {0} は直接的または間接的に自身を参照しています。" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "newTemplates の DOMSource に対する入力ノードは null にできません。 " } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "オプション {0} に対するクラスファイルが見つかりません" } , { ER_REQUIRED_ELEM_NOT_FOUND , "必要な要素が見つかりません: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream は null にできません" } , { ER_URI_CANNOT_BE_NULL , "URI は null にできません" } , { ER_FILE_CANNOT_BE_NULL , "File は null にできません" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource は null にできません" } , { ER_CANNOT_INIT_BSFMGR , "BSF Manager を初期化できませんでした" } , { ER_CANNOT_CMPL_EXTENSN , "拡張をコンパイルできませんでした" } , { ER_CANNOT_CREATE_EXTENSN , "拡張 {0} を作成できませんでした。原因: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "メソッド {0} のインスタンスメソッド呼び出しは、最初の引数に Objcet インスタンスを必要とします" } , { ER_INVALID_ELEMENT_NAME , "無効な要素名が指定されました {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "要素名メソッドは static でなくてはなりません {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "拡張関数 {0} : {1} は未知です" } , { ER_MORE_MATCH_CONSTRUCTOR , "{0} のコンストラクタに最適な一致が複数個あります {0}" } , { ER_MORE_MATCH_METHOD , "メソッド {0} に最適な一致が複数個あります" } , { ER_MORE_MATCH_ELEMENT , "要素メソッド {0} に最適な一致が複数個あります" } , { ER_INVALID_CONTEXT_PASSED , "{0} を評価するのに無効なコンテキストが渡されました" } , { ER_POOL_EXISTS , "Pool がすでに存在します" } , { ER_NO_DRIVER_NAME , "ドライバの Name が指定されていません" } , { ER_NO_URL , "URL が指定されていません" } , { ER_POOL_SIZE_LESSTHAN_ONE , "1 より小さい Pool のサイズです。" } , { ER_INVALID_DRIVER , "無効なドライバ名が指定されました。" } , { ER_NO_STYLESHEETROOT , "スタイルシートのルートが見つかりませんでした。" } , { ER_ILLEGAL_XMLSPACE_VALUE , "xml:space に不当な値です" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode が失敗しました" } , { ER_RESOURCE_COULD_NOT_LOAD , "リソース [ {0} ] は次のものをロードできませんでした: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "バッファサイズ <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "拡張を呼び出すときに未知のエラーが発生しました" } , { ER_NO_NAMESPACE_DECL , "接頭辞 {0} には対応する名前空間宣言がありません" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "要素の内容は lang=javaclass {0} に許可されません" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "スタイルシートにより終了が指示されました" } , { ER_ONE_OR_TWO , "1 または 2" } , { ER_TWO_OR_THREE , "2 または 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "{0} をロードできませんでした (CLASSPATH をチェックしてください)。デフォルトだけを使用します。" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "デフォルトのテンプレートを初期化できません" } , { ER_RESULT_NULL , "Result は null にはできません" } , { ER_RESULT_COULD_NOT_BE_SET , "Result を設定できませんでした" } , { ER_NO_OUTPUT_SPECIFIED , "出力を指定できませんでした" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "タイプ {0} の Result に変形できません" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "タイプ {0} の Source に変形できません" } , { ER_NULL_CONTENT_HANDLER , "Null コンテンツハンドラ" } , { ER_NULL_ERROR_HANDLER , "Null エラーハンドラ" } , { ER_CANNOT_CALL_PARSE , "ContentHandler が設定されていないと構文解析を呼び出すことができません" } , { ER_NO_PARENT_FOR_FILTER , "フィルタ処理する親がありません" } , { ER_NO_STYLESHEET_IN_MEDIA , "{0} にスタイルシートが見つかりません。メディア= {1}" } , { ER_NO_STYLESHEET_PI , "xml-stylesheet PI が {0} に見つかりませんでした" } , { ER_NOT_SUPPORTED , "サポートされません: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "プロパティ {0} の値は Boolean インスタンスでなくてはなりません" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "{0} にある外部スクリプトを入手できませんでした。" } , { ER_RESOURCE_COULD_NOT_FIND , "リソース [ {0} ] が見つかりませんでした.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "出力プロパティが認められません: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "ElemLiteralResult インスタンスの作成に失敗しました" } , { ER_VALUE_SHOULD_BE_NUMBER , "▼{0} の値に解析可能な数字が含まれている必要があります" } , { ER_VALUE_SHOULD_EQUAL , " {0} の値は yes または no のいずれかでなくてはなりません" } , { ER_FAILED_CALLING_METHOD , " {0} メソッドの呼び出しに失敗しました" } , { ER_FAILED_CREATING_ELEMTMPL , "ElemTemplateElement インスタンスの作成に失敗しました" } , { ER_CHARS_NOT_ALLOWED , "ドキュメントのこの部分で、文字列は許可されません" } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" 属性は {1} 要素で許可されません。" } , { ER_BAD_VALUE , "{0} 誤った値 {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} 属性値が見つかりません" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} 属性値が認められません" } , { ER_NULL_URI_NAMESPACE , "null URI を使って名前空間の接頭辞を生成しようとしています" } , { ER_NUMBER_TOO_BIG , "▼Long 型整数の最大値を超える数字をフォーマットしようとしています" } , { ER_CANNOT_FIND_SAX1_DRIVER , "▼SAX1 ドライバクラス {0} が見つかりません" } , { ER_SAX1_DRIVER_NOT_LOADED , "▼SAX1 ドライバクラス {0} が見つかりましたが、ロードできません" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "▼SAX1 ドライバクラス {0} がロードされましたが、インスタンス化できません" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "▼SAX1 ドライバクラス {0} が org.xml.sax.Parser を実装していません" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "▼システムプロパティ org.xml.sax.parser が指定されていません" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "▼パーサ属性は null にできません" } , { ER_FEATURE , "▼機能: {0}" } , { ER_PROPERTY , "▼プロパティ: {0}" } , { ER_NULL_ENTITY_RESOLVER , "▼null エンティティリゾルバ" } , { ER_NULL_DTD_HANDLER , "▼null DTD ハンドラ" } , { ER_NO_DRIVER_NAME_SPECIFIED , "▼ドライバ名が指定されていません!" } , { ER_NO_URL_SPECIFIED , "▼URL が指定されていません!" } , { ER_POOLSIZE_LESS_THAN_ONE , "▼プールサイズが 1 より小さい値になっています!" } , { ER_INVALID_DRIVER_NAME , "▼無効なドライバ名が指定されています!" } , { ER_ERRORLISTENER , "▼エラーリスナー" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "▼プログラマエラー! 式に ElemTemplateElement の親が含まれていません!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "▼RundundentExprEliminator におけるプログラマの表明: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "▼スタイルシートのこの位置では、{0} は指定できません!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "▼スタイルシートのこの位置では、空白類以外のテキストは指定できません!" } , { INVALID_TCHAR , "▼CHAR 型の属性 {0} に不正な値 {1} が指定されています。CHAR 型の属性に指定できるのは、単一の文字だけです!" } , { INVALID_QNAME , "▼QNAME 型の属性 {0} に不正な値 {1} が指定されています" } , { INVALID_ENUM , "▼ENUM 型の属性 {0} に不正な値 {1} が指定されています。有効な値は {2} です。" } , { INVALID_NMTOKEN , "▼NMTOKEN 型の属性 {0} に不正な値 {1} が指定されています" } , { INVALID_NCNAME , "▼NCNAME 型の属性 {0} に不正な {1} が指定されています" } , { INVALID_BOOLEAN , "▼boolean 型の属性 {0} に不正な {1} が指定されています" } , { INVALID_NUMBER , "▼数字型の属性 {0} に不正な {1} が指定されています" } , { ER_ARG_LITERAL , "▼マッチパターン内に含まれる {0} の引数には、リテラルを指定する必要があります。" } , { ER_DUPLICATE_GLOBAL_VAR , "▼グローバル変数の宣言が重複しています。" } , { ER_DUPLICATE_VAR , "▼変数の宣言が重複しています。" } , { ER_TEMPLATE_NAME_MATCH , "▼xsl:template には、name 属性、match 属性のいずれかまたは両方が含まれている必要があります" } , { ER_INVALID_PREFIX , "▼exclude-result-prefixes の接頭辞が有効ではありません: {0}" } , { ER_NO_ATTRIB_SET , "▼{0} という名前の attribute-set が存在しません" } , { WG_FOUND_CURLYBRACE , "'}' が見つかりましたが、属性テンプレートが開かれていません。" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "警告: count 属性が xsl:number 内の祖先と一致しません。 ターゲット = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "古い構文: 'expr' 属性の名前は 'select' に変更されています。" } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan は format-number 関数内のロケール名をまだ処理していません。" } , { WG_LOCALE_NOT_FOUND , "警告: xml:lang={0} のロケールが見つかりませんでした" } , { WG_CANNOT_MAKE_URL_FROM , "URL を作成できません: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "要求されたドキュメントをロードできません: {0}" } , { WG_CANNOT_FIND_COLLATOR , "<sort xml:lang={0} の Collator が見つかりませんでした" } , { WG_FUNCTIONS_SHOULD_USE_URL , "古い構文: 関数の指令は {0} の URL を使用する必要があります" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "エンコーディングがサポートされていません: {0}、UTF-8 を使用" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "エンコーディングがサポートされていません: {0}、Java {1} を使用" } , { WG_SPECIFICITY_CONFLICTS , "特定であるべきものの競合が見つかりました: {0} スタイルシートで最後に見つかったものが使用されます。" } , { WG_PARSING_AND_PREPARING , "========= {0} の構文解析および準備  ==========" } , { WG_ATTR_TEMPLATE , "属性テンプレート、{0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "xsl:strip-space と xsl:preserve-space の間で match 競合します" } , { WG_ATTRIB_NOT_HANDLED , "Xalan はまだ {0} 属性を処理していません。" } , { WG_NO_DECIMALFORMAT_DECLARATION , "10 進数形式の宣言が見つかりません: {0}" } , { WG_OLD_XSLT_NS , "XSLT 名前空間がない、または不正です。" } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "デフォルトの xsl:decimal-format 宣言は 1 つだけ許可されます。" } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format の名前は一意でなくてはなりません。名前 \"{0}\" は重複しています。" } , { WG_ILLEGAL_ATTRIBUTE , "{0} に不当な属性があります: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "名前空間の接頭辞を解決できません: {0}。 ノードは無視されます。" } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet は 'version' 属性が必要です。" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "不当な属性名: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "属性 {0} に不当な値が使用されています: {1}" } , { WG_EMPTY_SECOND_ARG , "document 関数の 2 番目の引数の結果のノードセットが空です。最初の引数が使用されます。" } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "▼xsl:processing-instruction の 'name' 属性では、'xml' を値として指定することはできません" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "▼xsl:processing-instruction の ''name'' 属性には、有効な NCName 値 {0} を指定する必要があります" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "▼子ノードの生成後や要素の生成前に属性 {0} を要素に追加することはできません。その属性は無視されます。" } , { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "BAD_CODE" , "createMessage のパラメータが範囲外でした" } , { "FORMAT_FAILED" , "messageFormat 呼び出しで例外がスローされました" } , { "version" , ">>>>>>> Xalan バージョン " } , { "version2" , "<<<<<<<" } , { "yes" , "はい" } , { "line" , "行番号" } , { "column" , "列番号" } , { "xsldone" , "XSLProcessor: 終了" } , { "xslProc_option" , "Xalan-J コマンド行プロセスのクラスオプション:" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER は parser liaison のクラス名を完全修飾する]" } , { "optionE" , "   [-E (エンティティ参照を拡張しない)]" } , { "optionV" , "   [-E (エンティティ参照を拡張しない)]" } , { "optionQC" , "   [-QC (Quiet Pattern Conflicts Warnings)]" } , { "optionQ" , "   [-Q  (非出力モード)]" } , { "optionLF" , "   [-LF (出力にのみ改行を使用する {デフォルトは CR/LF})]" } , { "optionCR" , "   [-CR (出力にのみキャリッジリターンを使用する {デフォルトは CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (エスケープする文字列 {デフォルトは <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (インデントに設定する空白文字数を制御する {デフォルトは 0})]" } , { "optionTT" , "   [-TT (テンプレートが呼び出されたときにトレースする)]" } , { "optionTG" , "   [-TG (各生成イベントをトレースする。)]" } , { "optionTS" , "   [-TS (各選択イベントをトレースする。)]" } , { "optionTTC" , "   [-TTC (テンプレートの子が処理されたときにトレースする。)]" } , { "optionTCLASS" , "   [-TCLASS (トレース拡張用の TraceListener クラス。)]" } , { "optionVALIDATE" , "   [-VALIDATE (妥当性検査を有効にするかどうかを設定する。デフォルトでは無効。)]" } , { "optionEDUMP" , "   [-EDUMP {オプションのファイル名} (エラー発生時にスタックダンプを実行する。)]" } , { "optionXML" , "   [-XML (XML フォーマッタを使用して、XML ヘッダを追加する。)]" } , { "optionTEXT" , "   [-TEXT (単純な Text フォーマッタを使用する。)]" } , { "optionHTML" , "   [-HTML (HTML フォーマッタを使用する。)]" } , { "optionPARAM" , "   [-PARAM 名前式 (スタイルシートのパラメータを設定)]" } , { "noParsermsg1" , "XSL プロセスは成功しませんでした。" } , { "noParsermsg2" , "** パーサが見つかりませんでした **" } , { "noParsermsg3" , "クラスパスをチェックしてください。" } , { "noParsermsg4" , "Java 用に IBM の XML パーサがない場合、以下からダウンロードできます" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER フルクラス名 (URI を解決する場合は URIResolver を使用する)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER フルクラス名 (エンティティを解決する場合は EntityResolver を使用する)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER フルクラス名 (出力を直列化する場合は ContentHandler を使用する)]" } , { "optionLINENUMBERS" , "   [-L ソースドキュメントには行番号を使用する]" } , { "optionMEDIA" , " ▼[-MEDIA mediaType (media 属性を使用してドキュメントに関連付けられたスタイルシートを検索する。)]" } , { "optionFLAVOR" , " ▼[-FLAVOR flavorName (s2s=SAX または d2d=DOM を明示的に使用してトランスフォームを実行する。)] " } , { "optionDIAG" , " ▼[-DIAG (トランスフォームにかかった合計時間 (ミリ秒) を出力する。)]" } , { "optionINCREMENTAL" , " ▼[-INCREMENTAL (http://xml.apache.org/xalan/features/incremental を true に設定することで、インクリメンタルな DTM 構築を要求する。)]" } , { "optionNOOPTIMIMIZE" , " ▼[-NOOPTIMIMIZE (http://xml.apache.org/xalan/features/optimize を false に設定することで、スタイルシートの最適化処理を無効にする。)]" } , { "optionRL" , " ▼[-RL recursionlimit (スタイルシートの回帰の深さに上限値を設定する。)]" } , { "optionXO" , " ▼[-XO [transletName] (生成されたトランスレットの名前を指定する)]" } , { "optionXD" , " ▼[-XD destinationDirectory (トランスレットの出力先ディレクトリを指定する)]" } , { "optionXJ" , " ▼[-XJ jarfile (トランスレットのクラスを <jarfile> に指定された名前の JAR ファイルにパッケージ化する)]" } , { "optionXP" , " ▼[-XP package (生成されたすべてのトランスレットクラスに対するパッケージ名の接頭辞を指定する)]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.423076923', '3769', '0', '0', '0.976190476', '1', '0', '0', '1251', '1', '0.3333', '0']
package org . apache . xml . serializer ; import org . apache . xml . utils . StringToIntTable ; class ElemDesc { int m_flags ; StringToIntTable m_attrs = null ; static final int EMPTY = ( 1 << 1 ) ; static final int FLOW = ( 1 << 2 ) ; static final int BLOCK = ( 1 << 3 ) ; static final int BLOCKFORM = ( 1 << 4 ) ; static final int BLOCKFORMFIELDSET = ( 1 << 5 ) ; static final int CDATA = ( 1 << 6 ) ; static final int PCDATA = ( 1 << 7 ) ; static final int RAW = ( 1 << 8 ) ; static final int INLINE = ( 1 << 9 ) ; static final int INLINEA = ( 1 << 10 ) ; static final int INLINELABEL = ( 1 << 11 ) ; static final int FONTSTYLE = ( 1 << 12 ) ; static final int PHRASE = ( 1 << 13 ) ; static final int FORMCTRL = ( 1 << 14 ) ; static final int SPECIAL = ( 1 << 15 ) ; static final int ASPECIAL = ( 1 << 16 ) ; static final int HEADMISC = ( 1 << 17 ) ; static final int HEAD = ( 1 << 18 ) ; static final int LIST = ( 1 << 19 ) ; static final int PREFORMATTED = ( 1 << 20 ) ; static final int WHITESPACESENSITIVE = ( 1 << 21 ) ; static final int HEADELEM = ( 1 << 22 ) ; static final int ATTRURL = ( 1 << 1 ) ; static final int ATTREMPTY = ( 1 << 2 ) ; ElemDesc ( int flags ) { m_flags = flags ; } boolean is ( int flags ) { return ( m_flags & flags ) != 0 ; } void setAttr ( String name , int flags ) { if ( null == m_attrs ) m_attrs = new StringToIntTable ( ) ; m_attrs . put ( name , flags ) ; } boolean isAttrFlagSet ( String name , int flags ) { return ( null != m_attrs ) ? ( ( m_attrs . getIgnoreCase ( name ) & flags ) != 0 ) : false ; } } 	0	['4', '1', '0', '2', '8', '0', '1', '1', '0', '1.269230769', '80', '0', '1', '0', '0.833333333', '0', '0', '12.5', '3', '1.75', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . compiler . Compiler ; public abstract class BasicTestIterator extends LocPathIterator { protected BasicTestIterator ( ) { } protected BasicTestIterator ( PrefixResolver nscontext ) { super ( nscontext ) ; } protected BasicTestIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int whatToShow = compiler . getWhatToShow ( firstStepPos ) ; if ( ( 0 == ( whatToShow & ( DTMFilter . SHOW_ATTRIBUTE | DTMFilter . SHOW_NAMESPACE | DTMFilter . SHOW_ELEMENT | DTMFilter . SHOW_PROCESSING_INSTRUCTION ) ) ) || ( whatToShow == DTMFilter . SHOW_ALL ) ) initNodeTest ( whatToShow ) ; else { initNodeTest ( whatToShow , compiler . getStepNS ( firstStepPos ) , compiler . getStepLocalName ( firstStepPos ) ) ; } initPredicateInfo ( compiler , firstStepPos ) ; } protected BasicTestIterator ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , shouldLoadWalkers ) ; } protected abstract int getNextNode ( ) ; public int nextNode ( ) { if ( m_foundLast ) { m_lastFetched = DTM . NULL ; return DTM . NULL ; } if ( DTM . NULL == m_lastFetched ) { resetProximityPositions ( ) ; } int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { do { next = getNextNode ( ) ; if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { ChildTestIterator clone = ( ChildTestIterator ) super . cloneWithReset ( ) ; clone . resetProximityPositions ( ) ; return clone ; } } 	0	['7', '5', '2', '8', '24', '21', '2', '7', '2', '2', '163', '0', '0', '0.9765625', '0.371428571', '2', '4', '22.28571429', '11', '1.8571', '0']
package org . apache . xalan . xsltc . compiler ; public interface Closure { public boolean inInnerClass ( ) ; public Closure getParentClosure ( ) ; public String getInnerClassName ( ) ; public void addVariable ( VariableRefBase variableRef ) ; } 	0	['4', '1', '0', '6', '4', '6', '6', '1', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class BooleanCall extends FunctionCall { private Expression _arg = null ; public BooleanCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _arg = argument ( 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _arg . typeCheck ( stable ) ; return _type = Type . Boolean ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { _arg . translate ( classGen , methodGen ) ; final Type targ = _arg . getType ( ) ; if ( ! targ . identicalTo ( Type . Boolean ) ) { _arg . startResetIterator ( classGen , methodGen ) ; targ . translateTo ( classGen , methodGen , Type . Boolean ) ; } } } 	0	['3', '4', '0', '8', '11', '0', '0', '8', '3', '0', '51', '1', '1', '0.979591837', '0.444444444', '3', '13', '15.66666667', '2', '1', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . dtm . DTMAxisIterator ; public interface CurrentNodeListFilter { public abstract boolean test ( int node , int position , int last , int current , AbstractTranslet translet , DTMAxisIterator iter ) ; } 	0	['1', '1', '0', '3', '1', '0', '1', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Minus extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) - right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) - m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class MatchGenerator extends MethodGenerator { private static int CURRENT_INDEX = 1 ; private int _iteratorIndex = INVALID_INDEX ; private final Instruction _iloadCurrent ; private final Instruction _istoreCurrent ; private Instruction _aloadDom ; public MatchGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; _iloadCurrent = new ILOAD ( CURRENT_INDEX ) ; _istoreCurrent = new ISTORE ( CURRENT_INDEX ) ; } public Instruction loadCurrentNode ( ) { return _iloadCurrent ; } public Instruction storeCurrentNode ( ) { return _istoreCurrent ; } public int getHandlerIndex ( ) { return INVALID_INDEX ; } public Instruction loadDOM ( ) { return _aloadDom ; } public void setDomIndex ( int domIndex ) { _aloadDom = new ALOAD ( domIndex ) ; } public int getIteratorIndex ( ) { return _iteratorIndex ; } public void setIteratorIndex ( int iteratorIndex ) { _iteratorIndex = iteratorIndex ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_INDEX ; } return super . getLocalIndex ( name ) ; } } 	0	['10', '5', '0', '9', '16', '27', '1', '8', '9', '0.844444444', '79', '1', '0', '0.945205479', '0.263888889', '2', '5', '6.4', '2', '0.9', '0']
package org . apache . xpath . compiler ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . ObjectVector ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . res . XPATHErrorResources ; public class OpMap { protected String m_currentPattern ; public String toString ( ) { return m_currentPattern ; } public String getPatternString ( ) { return m_currentPattern ; } static final int MAXTOKENQUEUESIZE = 500 ; static final int BLOCKTOKENQUEUESIZE = 500 ; ObjectVector m_tokenQueue = new ObjectVector ( MAXTOKENQUEUESIZE , BLOCKTOKENQUEUESIZE ) ; public ObjectVector getTokenQueue ( ) { return m_tokenQueue ; } public Object getToken ( int pos ) { return m_tokenQueue . elementAt ( pos ) ; } public int getTokenQueueSize ( ) { return m_tokenQueue . size ( ) ; } OpMapVector m_opMap = null ; public OpMapVector getOpMap ( ) { return m_opMap ; } public static final int MAPINDEX_LENGTH = 1 ; void shrink ( ) { int n = m_opMap . elementAt ( MAPINDEX_LENGTH ) ; m_opMap . setToSize ( n + 4 ) ; m_opMap . setElementAt ( 0 , n ) ; m_opMap . setElementAt ( 0 , n + 1 ) ; m_opMap . setElementAt ( 0 , n + 2 ) ; n = m_tokenQueue . size ( ) ; m_tokenQueue . setToSize ( n + 4 ) ; m_tokenQueue . setElementAt ( null , n ) ; m_tokenQueue . setElementAt ( null , n + 1 ) ; m_tokenQueue . setElementAt ( null , n + 2 ) ; } public int getOp ( int opPos ) { return m_opMap . elementAt ( opPos ) ; } public void setOp ( int opPos , int value ) { m_opMap . setElementAt ( value , opPos ) ; } public int getNextOpPos ( int opPos ) { return opPos + m_opMap . elementAt ( opPos + 1 ) ; } public int getNextStepPos ( int opPos ) { int stepType = getOp ( opPos ) ; if ( ( stepType >= OpCodes . AXES_START_TYPES ) && ( stepType <= OpCodes . AXES_END_TYPES ) ) { return getNextOpPos ( opPos ) ; } else if ( ( stepType >= OpCodes . FIRST_NODESET_OP ) && ( stepType <= OpCodes . LAST_NODESET_OP ) ) { int newOpPos = getNextOpPos ( opPos ) ; while ( OpCodes . OP_PREDICATE == getOp ( newOpPos ) ) { newOpPos = getNextOpPos ( newOpPos ) ; } stepType = getOp ( newOpPos ) ; if ( ! ( ( stepType >= OpCodes . AXES_START_TYPES ) && ( stepType <= OpCodes . AXES_END_TYPES ) ) ) { return OpCodes . ENDOP ; } return newOpPos ; } else { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_UNKNOWN_STEP , new Object [ ] { new Integer ( stepType ) . toString ( ) } ) ) ; } } public static int getNextOpPos ( int [ ] opMap , int opPos ) { return opPos + opMap [ opPos + 1 ] ; } public int getFirstPredicateOpPos ( int opPos ) throws javax . xml . transform . TransformerException { int stepType = m_opMap . elementAt ( opPos ) ; if ( ( stepType >= OpCodes . AXES_START_TYPES ) && ( stepType <= OpCodes . AXES_END_TYPES ) ) { return opPos + m_opMap . elementAt ( opPos + 2 ) ; } else if ( ( stepType >= OpCodes . FIRST_NODESET_OP ) && ( stepType <= OpCodes . LAST_NODESET_OP ) ) { return opPos + m_opMap . elementAt ( opPos + 1 ) ; } else if ( - 2 == stepType ) { return - 2 ; } else { error ( org . apache . xpath . res . XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { String . valueOf ( stepType ) } ) ; return - 1 ; } } public void error ( String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = org . apache . xalan . res . XSLMessages . createXPATHMessage ( msg , args ) ; throw new javax . xml . transform . TransformerException ( fmsg ) ; } public static int getFirstChildPos ( int opPos ) { return opPos + 2 ; } public int getArgLength ( int opPos ) { return m_opMap . elementAt ( opPos + MAPINDEX_LENGTH ) ; } public int getArgLengthOfStep ( int opPos ) { return m_opMap . elementAt ( opPos + MAPINDEX_LENGTH + 1 ) - 3 ; } public static int getFirstChildPosOfStep ( int opPos ) { return opPos + 3 ; } public int getStepTestType ( int opPosOfStep ) { return m_opMap . elementAt ( opPosOfStep + 3 ) ; } public String getStepNS ( int opPosOfStep ) { int argLenOfStep = getArgLengthOfStep ( opPosOfStep ) ; if ( argLenOfStep == 3 ) { int index = m_opMap . elementAt ( opPosOfStep + 4 ) ; if ( index >= 0 ) return ( String ) m_tokenQueue . elementAt ( index ) ; else if ( OpCodes . ELEMWILDCARD == index ) return NodeTest . WILD ; else return null ; } else return null ; } public String getStepLocalName ( int opPosOfStep ) { int argLenOfStep = getArgLengthOfStep ( opPosOfStep ) ; int index ; switch ( argLenOfStep ) { case 0 : index = OpCodes . EMPTY ; break ; case 1 : index = OpCodes . ELEMWILDCARD ; break ; case 2 : index = m_opMap . elementAt ( opPosOfStep + 4 ) ; break ; case 3 : index = m_opMap . elementAt ( opPosOfStep + 5 ) ; break ; default : index = OpCodes . EMPTY ; break ; } if ( index >= 0 ) return ( String ) m_tokenQueue . elementAt ( index ) . toString ( ) ; else if ( OpCodes . ELEMWILDCARD == index ) return NodeTest . WILD ; else return null ; } } 	0	['22', '1', '1', '5', '38', '67', '2', '3', '21', '0.873015873', '384', '0.166666667', '2', '0', '0.327272727', '0', '0', '16.18181818', '8', '1.5455', '0']
package org . apache . xml . dtm ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; class SecuritySupport12 extends SecuritySupport { public ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } public String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } public FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } public InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } } 	0	['5', '2', '0', '5', '13', '10', '5', '5', '4', '2', '45', '0', '0', '0.692307692', '0.45', '0', '0', '8', '1', '0.8', '0']
package org . apache . xalan . res ; public class XSLTErrorResources_ko extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "오류: 표현식 안에 '{'를 사용할 수 없습니다." } , { ER_ILLEGAL_ATTRIBUTE , "{0}에 잘못된 속성 {1}이(가) 있습니다." } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode는 xsl:apply-imports에서 널입니다!" } , { ER_CANNOT_ADD , "{0}을(를) {1}에 추가할 수 없습니다. " } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode는 handleApplyTemplatesInstruction에서 널입니다!" } , { ER_NO_NAME_ATTRIB , "{0}에 이름 속성이 있어야 합니다." } , { ER_TEMPLATE_NOT_FOUND , "템플리트 {0}을(를) 찾을 수 없습니다." } , { ER_CANT_RESOLVE_NAME_AVT , "xsl:call-template에서 이름 AVT를 결정할 수 없습니다." } , { ER_REQUIRES_ATTRIB , "{0}에 속성 {1}이(가) 필요합니다." } , { ER_MUST_HAVE_TEST_ATTRIB , "{0}에 ''test'' 속성이 있어야 합니다." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "레벨 속성 {0}에 잘못된 값이 있습니다." } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction 이름이 'xml'이어서는 안됩니다." } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction 이름은 올바른 NCName {0}이어야 합니다." } , { ER_NEED_MATCH_ATTRIB , "{0}이(가) 모드를 가지고 있는 경우 일치 속성이 있어야 합니다." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0}에 이름 또는 일치 속성 중 하나가 필요합니다." } , { ER_CANT_RESOLVE_NSPREFIX , "이름 공간 접두어 {0}을(를) 결정할 수 없습니다." } , { ER_ILLEGAL_VALUE , "xml:space에 잘못된 값 {0}이(가) 있습니다." } , { ER_NO_OWNERDOC , "자식 노드에 소유자 문서가 없습니다!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement 오류: {0}" } , { ER_NULL_CHILD , "널 자식을 추가하려고 시도하는 중입니다!" } , { ER_NEED_SELECT_ATTRIB , "{0}에 선택 속성이 필요합니다." } , { ER_NEED_TEST_ATTRIB , "xsl:when에 'test' 속성이 있어야 합니다." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param에 'name' 속성이 있어야 합니다." } , { ER_NO_CONTEXT_OWNERDOC , "컨텍스트에 소유자 문서가 없습니다." } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "XML TransformerFactory Liaison {0}을(를) 작성할 수 없습니다." } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: 프로세스에 성공하지 못했습니다." } , { ER_NOT_SUCCESSFUL , "Xalan:에 성공하지 못했습니다." } , { ER_ENCODING_NOT_SUPPORTED , "코드화가 지원되지 않습니다: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "TraceListener {0}을(를) 작성할 수 없습니다." } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key에 'name' 속성이 필요합니다!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key에 'match' 속성이 필요합니다!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key에 'use' 속성이 필요합니다!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0}에 ''elements'' 속성이 필요합니다!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} 속성 ''prefix''가 빠졌습니다." } , { ER_BAD_STYLESHEET_URL , "Stylesheet URL이 잘못되었습니다: {0}" } , { ER_FILE_NOT_FOUND , "Stylesheet 파일을 찾을 수 없습니다: {0}" } , { ER_IOEXCEPTION , "스타일 시트 파일로 IO 예외가 발생하였습니다: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) {0}에 대한 href 속성을 찾을 수 없습니다." } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0}이(가) 직접 또는 간접적으로 자신을 포함하고 있습니다." } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude 오류, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} 속성 ''lang''이 빠졌습니다." } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) {0} 요소의 위치가 잘못되었습니다?? container 요소 ''component''가 빠졌습니다." } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Element, DocumentFragment, Document 또는 PrintWriter로만 출력할 수 있습니다." } , { ER_PROCESS_ERROR , "StylesheetRoot.process 오류" } , { ER_UNIMPLNODE_ERROR , "UnImplNode 오류: {0}" } , { ER_NO_SELECT_EXPRESSION , "오류! xpath 선택 표현식(-select)을 찾을 수 없습니다" } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "XSLProcessor를 일련화할 수 없습니다!" } , { ER_NO_INPUT_STYLESHEET , "Stylesheet 입력을 지정하지 않았습니다!" } , { ER_FAILED_PROCESS_STYLESHEET , "stylesheet 처리에 실패했습니다!" } , { ER_COULDNT_PARSE_DOC , "{0} 문서를 구문 분석할 수 없습니다!" } , { ER_COULDNT_FIND_FRAGMENT , "단편 {0}을(를) 찾을 수 없습니다." } , { ER_NODE_NOT_ELEMENT , "단편 식별자에 의해 지정된 노드는 요소가 아닙니다: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each에 일치 또는 이름 속성 중 하나가 있어야 합니다." } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "템플리트에 일치 또는 이름 속성 중 하나가 있어야 합니다." } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "문서 단편 복제가 없습니다!" } , { ER_CANT_CREATE_ITEM , "결과 트리 {0}에 항목을 작성할 수 없습니다." } , { ER_XMLSPACE_ILLEGAL_VALUE , "소스 XML의 xml:space에 잘못된 값 {0}이(가) 있습니다." } , { ER_NO_XSLKEY_DECLARATION , "{0}에 대하여 xsl:key 선언이 없습니다!" } , { ER_CANT_CREATE_URL , "오류! {0}에 대하여 url을 작성할 수 없습니다." } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions가 지원되지 않습니다." } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory 오류" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0}은(는) 스타일 시트 내부에 허용되지 않습니다!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns는 더 이상 지원되지 않습니다! 대신 xsl:output을 사용하십시오." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space는 더 이상 지원되지 않습니다! 대신 xsl:preserve-space를 사용하십시오." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result는 더 이상 지원되지 않습니다! 대신 xsl:output을 사용하십시오." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0}에 잘못된 속성 {1}이(가) 있습니다." } , { ER_UNKNOWN_XSL_ELEM , "알 수 없는 XSL 요소 {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort는 xsl:apply-templates 또는 xsl:for-each와만 사용할 수 있습니다." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when의 위치가 잘못되었습니다!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when의 부모는 xsl:choose가 아닙니다!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise의 위치가 잘못되었습니다!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise의 부모는 xsl:choose가 아닙니다!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0}은(는) 템플리트 내부에 허용되지 않습니다!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} 확장 이름 공간 접두어 {1}을(를) 알 수 없습니다." } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) 가져오기는 스타일 시트의 첫 번째 요소로만 발생할 수 있습니다!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0}이(가) 직접 또는 간접적으로 자신을 가져오고 있습니다!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space에 잘못된 값 {0}이(가) 있습니다." } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet가 성공하지 못했습니다!" } , { ER_SAX_EXCEPTION , "SAX 예외" } , { ER_XSLT_ERROR , "XSLT 오류" } , { ER_CURRENCY_SIGN_ILLEGAL , "형식 패턴 문자열에 통화 부호가 허용되지 않습니다." } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Stylesheet DOM에서 문서 기능이 지원되지 않습니다!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "접두어가 없는 결정자의 접두어를 결정할 수 없습니다!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect 확장: 파일 이름을 가져올 수 없습니다 - 파일 또는 선택 속성이 올바른 문자열을 반환해야 합니다." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Redirect 확장에 FormatterListener를 구축할 수 없습니다!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "exclude-result-prefixes의 접두어가 올바르지 않습니다: {0}" } , { ER_MISSING_NS_URI , "지정된 접두어에 대한 이름 공간 URI가 빠졌습니다." } , { ER_MISSING_ARG_FOR_OPTION , "옵션 {0}에 대한 인자가 빠졌습니다." } , { ER_INVALID_OPTION , "잘못된 옵션: {0}" } , { ER_MALFORMED_FORMAT_STRING , "잘못된 형식 문자열: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet에 'version' 속성이 필요합니다!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "속성: {0}에 잘못된 값 {1}이(가) 있습니다." } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose에 xsl:when이 필요합니다.   " } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports는 xsl:for-each에 허용되지 않습니다." } , { ER_CANT_USE_DTM_FOR_OUTPUT , "출력 DOM 노드로 DTMLiaison을 사용할 수 없습니다... 대신 org.apache.xpath.DOM2Helper를 전달하십시오!" } , { ER_CANT_USE_DTM_FOR_INPUT , "입력 DOM 노드로 DTMLiaison을 사용할 수 없습니다... 대신 org.apache.xpath.DOM2Helper를 전달하십시오!" } , { ER_CALL_TO_EXT_FAILED , "확장 요소에 대한 호출이 실패했습니다: {0}" } , { ER_PREFIX_MUST_RESOLVE , "접두어가 이름 공간 {0}으로(로) 결정되어야 합니다." } , { ER_INVALID_UTF16_SURROGATE , "잘못된 UTF-16 대리가 감지되었습니다: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0}이(가) 자신을 사용하였며, 이로 인해 무한 루프가 발생합니다." } , { ER_CANNOT_MIX_XERCESDOM , "Xerces-DOM이 아닌 입력과 Xerces-DOM 출력을 함께 사용할 수 없습니다!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "ElemTemplateElement.readObject에: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "같은 이름 {0}을(를) 가진 둘 이상의 템플리트를 찾았습니다." } , { ER_INVALID_KEY_CALL , "잘못된 함수 호출: 순환적 key() 호출은 허용되지 않습니다." } , { ER_REFERENCING_ITSELF , "{0} 변수가 직접 또는 간접적으로 자신을 참조하고 있습니다!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "newTemplates의 DOMSource에서 입력 노드가 널이 될 수 없습니다!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "옵션 {0}의 클래스 파일을 찾을 수 없습니다.    " } , { ER_REQUIRED_ELEM_NOT_FOUND , "필수 요소를 찾을 수 없습니다: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream은 널이 될 수 없습니다" } , { ER_URI_CANNOT_BE_NULL , "URI는 널이 될 수 없습니다" } , { ER_FILE_CANNOT_BE_NULL , "파일은 널이 될 수 없습니다" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource는 널이 될 수 없습니다" } , { ER_CANNOT_INIT_BSFMGR , "BSF 관리자를 초기화할 수 없습니다" } , { ER_CANNOT_CMPL_EXTENSN , "확장자를 컴파일할 수 없습니다" } , { ER_CANNOT_CREATE_EXTENSN , "{1}로 인해 확장자 {0}을(를) 작성할 수 없습니다." } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "메소드 {0}에 대한 인스턴스 메소드 호출에서 객체 인스턴스가 첫 번째 인자가 되어야 합니다." } , { ER_INVALID_ELEMENT_NAME , "잘못된 이름 요소 {0}이(가) 지정되었습니다.   " } , { ER_ELEMENT_NAME_METHOD_STATIC , "이름 요소 메소드는 정적 {0}이어야 합니다." } , { ER_EXTENSION_FUNC_UNKNOWN , "확장 기능 {0} : {1}을(를) 알 수 없습니다." } , { ER_MORE_MATCH_CONSTRUCTOR , "{0}의 구성자와 일치하는 것이 두 개 이상입니다.   " } , { ER_MORE_MATCH_METHOD , "{0} 메소드와 일치하는 것이 두 개 이상입니다" } , { ER_MORE_MATCH_ELEMENT , "{0} 요소 메소드와 일치하는 것이 두 개 이상입니다" } , { ER_INVALID_CONTEXT_PASSED , "{0} 평가를 위해 전달된 컨텍스트가 잘못되었습니다." } , { ER_POOL_EXISTS , "풀이 이미 있습니다" } , { ER_NO_DRIVER_NAME , "지정된 드라이버 이름이 없습니다" } , { ER_NO_URL , "지정된 URL이 없습니다" } , { ER_POOL_SIZE_LESSTHAN_ONE , "풀 크기가 1보다 작습니다!" } , { ER_INVALID_DRIVER , "지정된 드라이버 이름이 잘못되었습니다!" } , { ER_NO_STYLESHEETROOT , "스타일 시트 루트를 찾을 수 없습니다!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "xml:space에 대한 값이 잘못되었습니다" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode가 실패했습니다" } , { ER_RESOURCE_COULD_NOT_LOAD , "[ {0} ] 자원이 다음을 로드할 수 없습니다: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "버퍼 크기 <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "확장자 호출 중 알 수 없는 오류가 발생했습니다" } , { ER_NO_NAMESPACE_DECL , "{0} 접두어에 관련 이름 공간 선언이 없습니다." } , { ER_ELEM_CONTENT_NOT_ALLOWED , "lang=javaclass {0}에 요소 컨텐트가 허용되지 않습니다." } , { ER_STYLESHEET_DIRECTED_TERMINATION , "스타일 시트가 종료로 지정되었습니다" } , { ER_ONE_OR_TWO , "1 또는 2" } , { ER_TWO_OR_THREE , "2 or 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "기본값만을 사용하여 {0}을(를) 로드할 수 없습니다(CLASSPATH를 확인하십시오)." } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "기본 템플리트를 초기화할 수 없습니다" } , { ER_RESULT_NULL , "결과는 널이 될 수 없습니다" } , { ER_RESULT_COULD_NOT_BE_SET , "결과를 설정할 수 없습니다" } , { ER_NO_OUTPUT_SPECIFIED , "지정된 출력이 없습니다" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "유형이 {0}인 결과로 변환할 수 없습니다." } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "유형이 {0}인 소스로 변환할 수 없습니다. " } , { ER_NULL_CONTENT_HANDLER , "컨텐트 처리기가 널입니다" } , { ER_NULL_ERROR_HANDLER , "오류 처리기가 널입니다" } , { ER_CANNOT_CALL_PARSE , "ContentHandler를 설정하지 않으면 구문 분석이 호출되지 않습니다." } , { ER_NO_PARENT_FOR_FILTER , "필터에 대한 부모가 없습니다" } , { ER_NO_STYLESHEET_IN_MEDIA , "{0}에 스타일 시트가 없습니다. 매체= {1}" } , { ER_NO_STYLESHEET_PI , "{0}에 xml-stylesheet PI가 없습니다. " } , { ER_NOT_SUPPORTED , "지원되지 않습니다: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "{0} 특성에 대한 값이 부울 인스턴스여야 합니다." } , { "ER_SRC_ATTRIB_NOT_SUPPORTED" , "{0}에서 외부 스크립트를 얻을 수 없습니다" } , { ER_RESOURCE_COULD_NOT_FIND , "[ {0} ] 자원을 찾을 수 없습니다.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "출력 특성을 인식할 수 없습니다: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "ElemLiteralResult 인스턴스 작성에 실패했습니다" } , { ER_VALUE_SHOULD_BE_NUMBER , "{0}에 대한 값은 구분 분석할 수 있는 숫자를 포함해야 합니다." } , { ER_VALUE_SHOULD_EQUAL , "{0}에 대한 값은 예 또는 아니오이어야 합니다." } , { ER_FAILED_CALLING_METHOD , "{0} 메소드 호출에 실패했습니다" } , { ER_FAILED_CREATING_ELEMTMPL , "ElemTemplateElement 인스턴스 작성에 실패했습니다" } , { ER_CHARS_NOT_ALLOWED , "이 문서에서 문자가 허용되지 않습니다" } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" 속성이 {1} 요소에 허용되지 않습니다!" } , { ER_BAD_VALUE , "{0} 잘못된 값 {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} 속성 값을 찾을 수 없습니다 " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} 속성 값을 인식할 수 없습니다 " } , { ER_NULL_URI_NAMESPACE , "널 URI로 이름 공간 접두부를 생성하려고 시도 중입니다" } , { ER_NUMBER_TOO_BIG , "가장 큰 Long 정수보다 큰 숫자 서식을 지정하려고 시도 중입니다." } , { ER_CANNOT_FIND_SAX1_DRIVER , "SAX1 드라이버 클래스 {0}을(를) 찾을 수 없습니다." } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1 드라이버 클래스 {0}을(를) 찾았지만 로드할 수 없습니다." } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1 드라이버 클래스 {0}을(를) 로드했지만 인스턴스화할 수 없습니다." } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 드라이버 클래스 {0}은(는) org.xml.sax.Parser를 구현하지 않습니다." } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "org.xml.sax.parser 시스템 특성이 지정되어 있지 않습니다." } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Parser 인자는 널이 아니어야 합니다." } , { ER_FEATURE , "기능: {0}" } , { ER_PROPERTY , "특성: {0}" } , { ER_NULL_ENTITY_RESOLVER , "널 엔티티 결정자" } , { ER_NULL_DTD_HANDLER , "널 DTD 처리기" } , { ER_NO_DRIVER_NAME_SPECIFIED , "드라이버 이름이 지정되지 않음!" } , { ER_NO_URL_SPECIFIED , "URL이 지정되지 않음!" } , { ER_POOLSIZE_LESS_THAN_ONE , "풀 크기가 1보다 작음!" } , { ER_INVALID_DRIVER_NAME , "잘못된 드라이브 이름이 지정됨!" } , { ER_ERRORLISTENER , "오류 수신기" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "프로그래머 오류! 식에 ElemTemplateElement 부모가 없음!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "RundundentExprEliminator의 프로그래머 명제: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "스타일 시트의 이 위치에는 {0}을(를) 사용할 수 없습니다!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "스타일 시트의 이 위치에는 공백이 아닌 텍스트를 사용할 수 없습니다!" } , { INVALID_TCHAR , "잘못된 값:  CHAR 속성 {0}에 사용된 {1}.  CHAR 유형의 속성은 1자여야 합니다!" } , { INVALID_QNAME , "잘못된 값: QNAME 속성 {0}에 사용된 {1}" } , { INVALID_ENUM , "잘못된 값: ENUM 속성 {0}에 사용된 {1}.  유효한 값: {2}." } , { INVALID_NMTOKEN , "잘못된 값: NMTOKEN 속성 {0}에 사용된 {1} " } , { INVALID_NCNAME , "잘못된 값: NCNAME 속성 {0}에 사용된 {1} " } , { INVALID_BOOLEAN , "잘못된 값: boolean 속성 {0}에 사용된 {1} " } , { INVALID_NUMBER , "잘못된 값: number 속성 {0}에 사용된 {1} " } , { ER_ARG_LITERAL , "일치 패턴에서 {0}에 대한 인자는 리터럴이어야 합니다." } , { ER_DUPLICATE_GLOBAL_VAR , "중복되는 전역 변수 선언" } , { ER_DUPLICATE_VAR , "중복되는 변수 선언" } , { ER_TEMPLATE_NAME_MATCH , "xsl:template은 name 또는 match 속성(또는 모두)을 가져야 합니다." } , { ER_INVALID_PREFIX , "exclude-result-prefixes의 접두어가 잘못되었습니다: {0}" } , { ER_NO_ATTRIB_SET , "이름이 {0}인 속성 집합이 없습니다." } , { WG_FOUND_CURLYBRACE , "'}'를 찾았으나 속성 템플리트를 열 수 없습니다!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "경고: 카운트 속성이 xsl:number의 상위와 일치하지 않습니다! 대상 = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "이전 구문: 'expr' 속성의 이름이 'select'로 변경되었습니다." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan이 format-number 기능에서 로켈 이름을 아직 처리하지 않습니다." } , { WG_LOCALE_NOT_FOUND , "경고: xml:lang={0}에 대한 로켈을 찾을 수 없습니다." } , { WG_CANNOT_MAKE_URL_FROM , "{0}에서 URL을 작성할 수 없습니다." } , { WG_CANNOT_LOAD_REQUESTED_DOC , "요청한 문서 {0}을(를) 로드할 수 없습니다." } , { WG_CANNOT_FIND_COLLATOR , "<sort xml:lang={0}에 대한 조합기를 찾을 수 없습니다." } , { WG_FUNCTIONS_SHOULD_USE_URL , "이전 구문: 함수 지시사항은 {0} url을 사용해야 합니다." } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "UTF-8을 사용하여 코드화가 지원되지 않습니다: {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Java {1}을(를) 사용하여 코드화가 지원되지 않습니다: {0} " } , { WG_SPECIFICITY_CONFLICTS , "특이성 충돌이 발견되었습니다: 스타일 시트에서 마지막으로 발견된 {0}이(가) 사용됩니다." } , { WG_PARSING_AND_PREPARING , "========= {0}을(를) 구문 분석 및 준비 중 ==========" } , { WG_ATTR_TEMPLATE , "Attr 템플리트, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "xsl:strip-space 및 xsl:preserve-space 간의 일치 충돌" } , { WG_ATTRIB_NOT_HANDLED , "Xalan이 아직 {0} 속성을 처리하지 않습니다!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "십진수 형식 {0}에 대한 선언을 찾을 수 없습니다." } , { WG_OLD_XSLT_NS , "XSLT 이름 공간이 빠졌거나 잘못되었습니다. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "하나의 기본 xsl:decimal-format 선언만 허용됩니다." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format 이름은 고유해야 합니다. \"{0}\"은(는) 중복됩니다." } , { WG_ILLEGAL_ATTRIBUTE , "{0}에 잘못된 속성 {1}이(가) 있습니다." } , { WG_COULD_NOT_RESOLVE_PREFIX , "이름 공간 접두어 {0}을(를) 결정할 수 없습니다. 이 노드는 무시됩니다." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet에 'version' 속성이 필요합니다!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "잘못된 속성 이름: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "{0} 속성에 잘못된 값 {1}이(가) 사용되었습니다" } , { WG_EMPTY_SECOND_ARG , "문서 기능의 두 번째 인자의 결과로 발생한 노드 세트가 비어 있습니다. 첫 번째 인자가 사용됩니다." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "xsl:processing-instruction 이름의 'name' 속성 값은 'xml'이어서는 안됩니다." } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "xsl:processing-instruction의 'name' 속성 값은 유효한 NCName이어야 합니다: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "하위 노드 다음이나 또는 요소가 만들어지기 전에 속성 {0}을(를) 추가할 수 없습니다.  속성이 무시됩니다." } , { "ui_language" , "ko" } , { "help_language" , "ko" } , { "language" , "ko" } , { "BAD_CODE" , "createMessage의 매개변수가 바운드를 벗어났습니다." } , { "FORMAT_FAILED" , "messageFormat 호출 시 예외 발생" } , { "version" , ">>>>>>> Xalan 버전 " } , { "version2" , "<<<<<<<" } , { "yes" , "예" } , { "line" , "행 #" } , { "column" , "열 #" } , { "xsldone" , "XSLProcessor: 완료" } , { "xslProc_option" , "Xalan-J 명령줄 프로세스 클래스 옵션:" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER 구문 분석기 liaison의 완전한 클래스 이름]" } , { "optionE" , "   [-E (엔티티 refs를 확장하지 마십시오.)]" } , { "optionV" , "   [-E (엔티티 refs를 확장하지 마십시오.)]" } , { "optionQC" , "   [-QC (무음 패턴 충돌 경고)]" } , { "optionQ" , "   [-Q  (무음 모드)]" } , { "optionLF" , "   [-LF (출력에서만 줄 바꿈을 사용하십시오. {기본값은 CR/LF입니다.})]" } , { "optionCR" , "   [-CR (출력에서만 캐리지 리턴을 사용하십시오. {기본값은 CR/LF입니다.})]" } , { "optionESCAPE" , "   [-ESCAPE (제어할 문자 {기본값은 <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (들여쓰기할 공백 수를 제어합니다. {기본값은 0입니다.})]" } , { "optionTT" , "   [-TT (호출될 때 템플리트를 추적합니다.)]" } , { "optionTG" , "   [-TG (각 생성 이벤트를 추적합니다.)]" } , { "optionTS" , "   [-TS (각 선택 이벤트를 추적합니다.)]" } , { "optionTTC" , "   [-TTC (처리될 때 템플리트 자식을 추적합니다.)]" } , { "optionTCLASS" , "   [-TCLASS (추적 확장에 대한 TraceListener 클래스입니다.)]" } , { "optionVALIDATE" , "   [-VALIDATE (검증 여부를 설정합니다. 기본값은 검증이 발생하지 않는 것입니다.)]" } , { "optionEDUMP" , "   [-EDUMP {선택적 파일 이름} (오류가 발생하면 스택덤프 하십시오.)]" } , { "optionXML" , "   [-XML (XML 포매터를 사용하여 XML 헤더를 추가하십시오.)]" } , { "optionTEXT" , "   [-TEXT (단순 텍스트 포매터를 사용하십시오.)]" } , { "optionHTML" , "   [-HTML (HTML 포매터를 사용하십시오.)]" } , { "optionPARAM" , "   [-PARAM 이름 표현식 (스타일 시트 매개변수를 설정하십시오.)]" } , { "noParsermsg1" , "XSL 프로세스가 성공하지 못했습니다." } , { "noParsermsg2" , "** 구문 분석기를 찾을 수 없습니다 **" } , { "noParsermsg3" , "클래스 경로를 확인하십시오." } , { "noParsermsg4" , "Java용 IBM XML 구문 분석기가 없는 경우 다음에서 다운로드할 수 있습니다." } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER 전체 클래스 이름(URI를 결정하는 데 사용되는 URIResolver)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER 전체 클래스 이름(엔티티를 결정하는 데 사용되는 EntityResolver)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER 전체 클래스 이름(출력을 일련화하는 데 사용되는 ContentHandler)]" } , { "optionLINENUMBERS" , "   [-L 소스 문서의 줄 번호 사용]" } , { "optionMEDIA" , " [-MEDIA mediaType(media 속성을 사용하여 문서와 관련된 스타일 시트를 찾습니다.)]" } , { "optionFLAVOR" , " [-FLAVOR flavorName(변환하려면 명시적으로 s2s=SAX 또는 d2d=DOM을 사용하십시오.)] " } , { "optionDIAG" , " [-DIAG(변환에 걸린 전체 시간(밀리초)를 인쇄합니다.)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (http://xml.apache.org/xalan/features/incremental을 true로 설정하여 증분 DTP 생성을 요청합니다.)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (http://xml.apache.org/xalan/features/optimize를 false로 설정하여 스타일 시트 최적화 처리를 요청하지 않습니다.)]" } , { "optionRL" , " [-RL recursionlimit(스타일 시트 재귀 깊이에 대해 숫자 제한을 지정합니다.)]" } , { "optionXO" , " [-XO [transletName] (생성된 translet에 이름을 할당합니다.)]" } , { "optionXD" , " [-XD destinationDirectory(translet에 대한 대상 디렉토리를 지정합니다.)]" } , { "optionXJ" , " [-XJ jarfile(translet 클래스를 이름이 <jarfile>인 jar 파일로 패키지화합니다.)]" } , { "optionXP" , " [-XP package(생성된 모든 translet 클래스에 대해 패키지 이름 접두어를 지정합니다.)]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "오류: " ; public static final String WARNING_HEADER = "경고: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.423076923', '3769', '0', '0', '0.976190476', '1', '0', '0', '1251', '1', '0.3333', '0']
package org . apache . xalan . xsltc . compiler ; final class QName { private final String _localname ; private String _prefix ; private String _namespace ; private String _stringRep ; private int _hashCode ; public QName ( String namespace , String prefix , String localname ) { _namespace = namespace ; _prefix = prefix ; _localname = localname ; _stringRep = ( namespace != null && ! namespace . equals ( Constants . EMPTYSTRING ) ) ? ( namespace + ':' + localname ) : localname ; _hashCode = _stringRep . hashCode ( ) + 19 ; } public void clearNamespace ( ) { _namespace = Constants . EMPTYSTRING ; } public String toString ( ) { return _stringRep ; } public String getStringRep ( ) { return _stringRep ; } public boolean equals ( Object other ) { return ( this == other ) ; } public String getLocalPart ( ) { return _localname ; } public String getNamespace ( ) { return _namespace ; } public String getPrefix ( ) { return _prefix ; } public int hashCode ( ) { return _hashCode ; } public String dump ( ) { return new String ( "QName: " + _namespace + "(" + _prefix + "):" + _localname ) ; } } 	0	['10', '1', '0', '56', '18', '17', '56', '0', '10', '0.777777778', '106', '1', '0', '0', '0.4', '1', '1', '9.1', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Dictionary ; import java . util . Vector ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class TestSeq { private int _kernelType ; private Vector _patterns = null ; private Mode _mode = null ; private Template _default = null ; private InstructionList _instructionList ; private InstructionHandle _start = null ; public TestSeq ( Vector patterns , Mode mode ) { this ( patterns , - 2 , mode ) ; } public TestSeq ( Vector patterns , int kernelType , Mode mode ) { _patterns = patterns ; _kernelType = kernelType ; _mode = mode ; } public String toString ( ) { final int count = _patterns . size ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final LocationPathPattern pattern = ( LocationPathPattern ) _patterns . elementAt ( i ) ; if ( i == 0 ) { result . append ( "Testseq for kernel " + _kernelType ) . append ( '\n' ) ; } result . append ( "   pattern " + i + ": " ) . append ( pattern . toString ( ) ) . append ( '\n' ) ; } return result . toString ( ) ; } public InstructionList getInstructionList ( ) { return _instructionList ; } public double getPriority ( ) { final Template template = ( _patterns . size ( ) == 0 ) ? _default : ( ( Pattern ) _patterns . elementAt ( 0 ) ) . getTemplate ( ) ; return template . getPriority ( ) ; } public int getPosition ( ) { final Template template = ( _patterns . size ( ) == 0 ) ? _default : ( ( Pattern ) _patterns . elementAt ( 0 ) ) . getTemplate ( ) ; return template . getPosition ( ) ; } public void reduce ( ) { final Vector newPatterns = new Vector ( ) ; final int count = _patterns . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final LocationPathPattern pattern = ( LocationPathPattern ) _patterns . elementAt ( i ) ; pattern . reduceKernelPattern ( ) ; if ( pattern . isWildcard ( ) ) { _default = pattern . getTemplate ( ) ; break ; } else { newPatterns . addElement ( pattern ) ; } } _patterns = newPatterns ; } public void findTemplates ( Dictionary templates ) { if ( _default != null ) { templates . put ( _default , this ) ; } for ( int i = 0 ; i < _patterns . size ( ) ; i ++ ) { final LocationPathPattern pattern = ( LocationPathPattern ) _patterns . elementAt ( i ) ; templates . put ( pattern . getTemplate ( ) , this ) ; } } private InstructionHandle getTemplateHandle ( Template template ) { return ( InstructionHandle ) _mode . getTemplateInstructionHandle ( template ) ; } private LocationPathPattern getPattern ( int n ) { return ( LocationPathPattern ) _patterns . elementAt ( n ) ; } public InstructionHandle compile ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle continuation ) { if ( _start != null ) { return _start ; } final int count = _patterns . size ( ) ; if ( count == 0 ) { return ( _start = getTemplateHandle ( _default ) ) ; } InstructionHandle fail = ( _default == null ) ? continuation : getTemplateHandle ( _default ) ; for ( int n = count - 1 ; n >= 0 ; n -- ) { final LocationPathPattern pattern = getPattern ( n ) ; final Template template = pattern . getTemplate ( ) ; final InstructionList il = new InstructionList ( ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; InstructionList ilist = _mode . getInstructionList ( pattern ) ; if ( ilist == null ) { ilist = pattern . compile ( classGen , methodGen ) ; _mode . addInstructionList ( pattern , ilist ) ; } InstructionList copyOfilist = ilist . copy ( ) ; FlowList trueList = pattern . getTrueList ( ) ; if ( trueList != null ) { trueList = trueList . copyAndRedirect ( ilist , copyOfilist ) ; } FlowList falseList = pattern . getFalseList ( ) ; if ( falseList != null ) { falseList = falseList . copyAndRedirect ( ilist , copyOfilist ) ; } il . append ( copyOfilist ) ; final InstructionHandle gtmpl = getTemplateHandle ( template ) ; final InstructionHandle success = il . append ( new GOTO_W ( gtmpl ) ) ; if ( trueList != null ) { trueList . backPatch ( success ) ; } if ( falseList != null ) { falseList . backPatch ( fail ) ; } fail = il . getStart ( ) ; if ( _instructionList != null ) { il . append ( _instructionList ) ; } _instructionList = il ; } return ( _start = fail ) ; } } 	0	['11', '1', '0', '13', '45', '0', '1', '13', '9', '0.633333333', '360', '1', '2', '0', '0.222222222', '0', '0', '31.18181818', '11', '2.4545', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; public class WriterToUTF8 extends Writer { private static final boolean DEBUG_OUT = false ; private final OutputStream m_os ; public WriterToUTF8 ( OutputStream os ) throws UnsupportedEncodingException { m_os = os ; } public void write ( final int c ) throws IOException { if ( c < 0x80 ) m_os . write ( c ) ; else if ( c < 0x800 ) { m_os . write ( 0xc0 + ( c > > 6 ) ) ; m_os . write ( 0x80 + ( c & 0x3f ) ) ; } else { m_os . write ( 0xe0 + ( c > > 12 ) ) ; m_os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; m_os . write ( 0x80 + ( c & 0x3f ) ) ; } if ( DEBUG_OUT ) { if ( c < 0x80 ) { char ch = ( char ) c ; System . out . print ( ch ) ; } else if ( c < 0x800 ) { System . out . print ( 0xc0 + ( c > > 6 ) ) ; System . out . print ( 0x80 + ( c & 0x3f ) ) ; } else { System . out . print ( 0xe0 + ( c > > 12 ) ) ; System . out . print ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; System . out . print ( 0x80 + ( c & 0x3f ) ) ; } System . out . flush ( ) ; } return ; } public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { final OutputStream os = m_os ; int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } if ( DEBUG_OUT ) { for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) System . out . print ( c ) ; else if ( c < 0x800 ) { System . out . print ( 0xc0 + ( c > > 6 ) ) ; System . out . print ( 0x80 + ( c & 0x3f ) ) ; } else { System . out . print ( 0xe0 + ( c > > 12 ) ) ; System . out . print ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; System . out . print ( 0x80 + ( c & 0x3f ) ) ; } } System . out . flush ( ) ; } return ; } public void write ( final String s ) throws IOException { final int n = s . length ( ) ; final OutputStream os = m_os ; for ( int i = 0 ; i < n ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } if ( DEBUG_OUT ) { for ( int i = 0 ; i < n ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) System . out . print ( c ) ; else if ( c < 0x800 ) { System . out . print ( 0xc0 + ( c > > 6 ) ) ; System . out . print ( 0x80 + ( c & 0x3f ) ) ; } else { System . out . print ( 0xe0 + ( c > > 12 ) ) ; System . out . print ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; System . out . print ( 0x80 + ( c & 0x3f ) ) ; } } System . out . flush ( ) ; } return ; } public void flush ( ) throws java . io . IOException { m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } } 	0	['7', '2', '0', '1', '13', '0', '1', '0', '7', '0.583333333', '214', '1', '0', '0.684210526', '0.342857143', '1', '2', '29.28571429', '1', '0.8571', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Quo extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( ( int ) ( left . num ( ) / right . num ( ) ) ) ; } } 	0	['2', '3', '0', '4', '5', '1', '1', '3', '2', '2', '16', '0', '0', '0.976190476', '0.75', '1', '1', '7', '1', '0.5', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . objects . XNodeSet ; public class FilterExprWalker extends AxesWalker { public FilterExprWalker ( WalkingIterator locPathIterator ) { super ( locPathIterator , Axis . FILTEREDLIST ) ; } public void init ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { super . init ( compiler , opPos , stepType ) ; switch ( stepType ) { case OpCodes . OP_FUNCTION : case OpCodes . OP_EXTFUNCTION : m_mustHardReset = true ; case OpCodes . OP_GROUP : case OpCodes . OP_VARIABLE : m_expr = compiler . compile ( opPos ) ; m_expr . exprSetParent ( this ) ; if ( m_expr instanceof org . apache . xpath . operations . Variable ) { m_canDetachNodeset = false ; } break ; default : m_expr = compiler . compile ( opPos + 2 ) ; m_expr . exprSetParent ( this ) ; } } public void detach ( ) { super . detach ( ) ; if ( m_canDetachNodeset ) { m_exprObj . detach ( ) ; } m_exprObj = null ; } public void setRoot ( int root ) { super . setRoot ( root ) ; m_exprObj = FilterExprIteratorSimple . executeFilterExpr ( root , m_lpi . getXPathContext ( ) , m_lpi . getPrefixResolver ( ) , m_lpi . getIsTopLevel ( ) , m_lpi . m_stackFrame , m_expr ) ; } public Object clone ( ) throws CloneNotSupportedException { FilterExprWalker clone = ( FilterExprWalker ) super . clone ( ) ; if ( null != m_exprObj ) clone . m_exprObj = ( XNodeSet ) m_exprObj . clone ( ) ; return clone ; } public short acceptNode ( int n ) { try { if ( getPredicateCount ( ) > 0 ) { countProximityPosition ( 0 ) ; if ( ! executePredicates ( n , m_lpi . getXPathContext ( ) ) ) return DTMIterator . FILTER_SKIP ; } return DTMIterator . FILTER_ACCEPT ; } catch ( javax . xml . transform . TransformerException se ) { throw new RuntimeException ( se . getMessage ( ) ) ; } } public int getNextNode ( ) { if ( null != m_exprObj ) { int next = m_exprObj . nextNode ( ) ; return next ; } else return DTM . NULL ; } public int getLastPos ( XPathContext xctxt ) { return m_exprObj . getLength ( ) ; } private Expression m_expr ; transient private XNodeSet m_exprObj ; private boolean m_mustHardReset = false ; private boolean m_canDetachNodeset = true ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_expr . fixupVariables ( vars , globalsSize ) ; } public Expression getInnerExpression ( ) { return m_expr ; } public void setInnerExpression ( Expression expr ) { expr . exprSetParent ( this ) ; m_expr = expr ; } public int getAnalysisBits ( ) { if ( null != m_expr && m_expr instanceof PathComponent ) { return ( ( PathComponent ) m_expr ) . getAnalysisBits ( ) ; } return WalkerFactory . BIT_FILTER ; } public boolean isDocOrdered ( ) { return m_exprObj . isDocOrdered ( ) ; } public int getAxis ( ) { return m_exprObj . getAxis ( ) ; } class filterExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_expr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FilterExprWalker . this ) ; m_expr = exp ; } } public void callPredicateVisitors ( XPathVisitor visitor ) { m_expr . callVisitors ( new filterExprOwner ( ) , visitor ) ; super . callPredicateVisitors ( visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FilterExprWalker walker = ( FilterExprWalker ) expr ; if ( ! m_expr . deepEquals ( walker . m_expr ) ) return false ; return true ; } } 	0	['18', '5', '0', '19', '48', '13', '5', '15', '16', '0.735294118', '244', '1', '2', '0.858333333', '0.185185185', '4', '14', '12.33333333', '3', '1.3889', '0']
package org . apache . xml . dtm ; public interface DTMAxisIterator extends Cloneable { public static final int END = DTM . NULL ; public int next ( ) ; public DTMAxisIterator reset ( ) ; public int getLast ( ) ; public int getPosition ( ) ; public void setMark ( ) ; public void gotoMark ( ) ; public DTMAxisIterator setStartNode ( int node ) ; public int getStartNode ( ) ; public boolean isReverse ( ) ; public DTMAxisIterator cloneIterator ( ) ; public void setRestartable ( boolean isRestartable ) ; public int getNodeByPosition ( int position ) ; } 	0	['12', '1', '0', '78', '12', '66', '78', '0', '12', '1.090909091', '13', '0', '0', '0', '0.416666667', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class If extends Instruction { private Expression _test ; private boolean _ignore = false ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "If" ) ; indent ( indent + IndentIncrement ) ; System . out . print ( "test " ) ; Util . println ( _test . toString ( ) ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { _test = parser . parseExpression ( this , "test" , null ) ; if ( _test . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "test" ) ; return ; } Object result = _test . evaluateAtCompileTime ( ) ; if ( result != null && result instanceof Boolean ) { _ignore = ! ( ( Boolean ) result ) . booleanValue ( ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _test . typeCheck ( stable ) instanceof BooleanType == false ) { _test = new CastExpr ( _test , Type . Boolean ) ; } if ( ! _ignore ) { typeCheckContents ( stable ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _test . translateDesynthesized ( classGen , methodGen ) ; final InstructionHandle truec = il . getEnd ( ) ; if ( ! _ignore ) { translateContents ( classGen , methodGen ) ; } _test . backPatchFalseList ( il . append ( NOP ) ) ; _test . backPatchTrueList ( truec . getNext ( ) ) ; } } 	0	['5', '3', '0', '16', '28', '0', '2', '15', '4', '0.25', '129', '1', '1', '0.933333333', '0.333333333', '1', '5', '24.4', '5', '1.8', '0']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . WhiteSpaceInfo ; public class WhitespaceInfoPaths extends WhiteSpaceInfo { private Vector m_elements ; public void setElements ( Vector elems ) { m_elements = elems ; } Vector getElements ( ) { return m_elements ; } public void clearElements ( ) { m_elements = null ; } public WhitespaceInfoPaths ( Stylesheet thisSheet ) { super ( thisSheet ) ; setStylesheet ( thisSheet ) ; } } 	0	['4', '5', '0', '4', '6', '0', '2', '2', '3', '0.333333333', '23', '1', '0', '0.986486486', '0.5', '0', '0', '4.5', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFGE ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . IFLE ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . IF_ICMPGE ; import org . apache . bcel . generic . IF_ICMPGT ; import org . apache . bcel . generic . IF_ICMPLE ; import org . apache . bcel . generic . IF_ICMPLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionConstants ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public final class IntType extends NumberType { protected IntType ( ) { } public String toString ( ) { return "int" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "I" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . INT ; } public int distanceTo ( Type type ) { if ( type == this ) { return 0 ; } else if ( type == Type . Real ) { return 1 ; } else return Integer . MAX_VALUE ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , final Type type ) { if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { methodGen . getInstructionList ( ) . append ( I2D ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( INTEGER_CLASS , "toString" , "(I)" + STRING_SIG ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; final BranchHandle falsec = il . append ( new IFEQ ( null ) ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( INTEGER_CLASS ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( INTEGER_CLASS , "<init>" , "(I)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz == Character . TYPE ) { il . append ( I2C ) ; } else if ( clazz == Byte . TYPE ) { il . append ( I2B ) ; } else if ( clazz == Short . TYPE ) { il . append ( I2S ) ; } else if ( clazz == Integer . TYPE ) { il . append ( NOP ) ; } else if ( clazz == Long . TYPE ) { il . append ( I2L ) ; } else if ( clazz == Float . TYPE ) { il . append ( I2F ) ; } else if ( clazz == Double . TYPE ) { il . append ( I2D ) ; } else if ( clazz . isAssignableFrom ( java . lang . Integer . class ) ) { translateTo ( classGen , methodGen , Type . Reference ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( INTEGER_CLASS ) ) ) ; final int index = cpg . addMethodref ( INTEGER_CLASS , INT_VALUE , INT_VALUE_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } public Instruction ADD ( ) { return InstructionConstants . IADD ; } public Instruction SUB ( ) { return InstructionConstants . ISUB ; } public Instruction MUL ( ) { return InstructionConstants . IMUL ; } public Instruction DIV ( ) { return InstructionConstants . IDIV ; } public Instruction REM ( ) { return InstructionConstants . IREM ; } public Instruction NEG ( ) { return InstructionConstants . INEG ; } public Instruction LOAD ( int slot ) { return new ILOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ISTORE ( slot ) ; } public BranchInstruction GT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGT ( null ) : ( BranchInstruction ) new IF_ICMPGT ( null ) ; } public BranchInstruction GE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGE ( null ) : ( BranchInstruction ) new IF_ICMPGE ( null ) ; } public BranchInstruction LT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLT ( null ) : ( BranchInstruction ) new IF_ICMPLT ( null ) ; } public BranchInstruction LE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLE ( null ) : ( BranchInstruction ) new IF_ICMPLE ( null ) ; } } 	0	['28', '3', '0', '46', '63', '374', '8', '40', '26', '1', '422', '0', '0', '0.564516129', '0.181547619', '1', '3', '14.03571429', '10', '1.6786', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public final class NodeSetType extends Type { protected NodeSetType ( ) { } public String toString ( ) { return "node-set" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return NODE_ITERATOR_SIG ; } public org . apache . bcel . generic . Type toJCType ( ) { return new org . apache . bcel . generic . ObjectType ( NODE_ITERATOR ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Node ) { translateTo ( classGen , methodGen , ( NodeType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { InstructionList il = methodGen . getInstructionList ( ) ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; if ( clazz . getName ( ) . equals ( "org.w3c.dom.NodeList" ) ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int convert = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "nodeList2Iterator" , "(" + "Lorg/w3c/dom/NodeList;" + TRANSLET_INTF_SIG + DOM_INTF_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( convert ) ) ; } else if ( clazz . getName ( ) . equals ( "org.w3c.dom.Node" ) ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int convert = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "node2Iterator" , "(" + "Lorg/w3c/dom/Node;" + TRANSLET_INTF_SIG + DOM_INTF_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( convert ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; getFirstNode ( classGen , methodGen ) ; il . append ( DUP ) ; final BranchHandle falsec = il . append ( new IFLT ( null ) ) ; Type . Node . translateTo ( classGen , methodGen , type ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( POP ) ) ; il . append ( new PUSH ( classGen . getConstantPool ( ) , "" ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { translateTo ( classGen , methodGen , Type . String ) ; Type . String . translateTo ( classGen , methodGen , Type . Real ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeType type ) { getFirstNode ( classGen , methodGen ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; getFirstNode ( classGen , methodGen ) ; return new FlowList ( il . append ( new IFLT ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String className = clazz . getName ( ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; if ( className . equals ( "org.w3c.dom.Node" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE , MAKE_NODE_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "org.w3c.dom.NodeList" ) || className . equals ( "java.lang.Object" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE_LIST , MAKE_NODE_LIST_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "java.lang.String" ) ) { int next = cpg . addInterfaceMethodref ( NODE_ITERATOR , "next" , "()I" ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , "(I)" + STRING_SIG ) ; il . append ( new INVOKEINTERFACE ( next , 1 ) ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "int" ) ) { int next = cpg . addInterfaceMethodref ( NODE_ITERATOR , "next" , "()I" ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , "(I)" + STRING_SIG ) ; int str = cpg . addMethodref ( BASIS_LIBRARY_CLASS , STRING_TO_INT , STRING_TO_INT_SIG ) ; il . append ( new INVOKEINTERFACE ( next , 1 ) ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; il . append ( new INVOKESTATIC ( str ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , className ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } private void getFirstNode ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKEINTERFACE ( cpg . addInterfaceMethodref ( NODE_ITERATOR , NEXT , NEXT_SIG ) , 1 ) ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public String getClassName ( ) { return ( NODE_ITERATOR ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['21', '2', '0', '41', '49', '190', '15', '29', '19', '2', '516', '0', '0', '0.622641509', '0.238095238', '2', '4', '23.57142857', '7', '1.619', '0']
package org . apache . xalan . xsltc . runtime ; public class Parameter { public String _name ; public Object _value ; public boolean _isDefault ; public Parameter ( String name , Object value ) { _name = name ; _value = value ; _isDefault = true ; } public Parameter ( String name , Object value , boolean isDefault ) { _name = name ; _value = value ; _isDefault = isDefault ; } } 	0	['2', '1', '0', '2', '3', '0', '2', '0', '2', '0', '29', '0', '0', '0', '0.875', '0', '0', '12', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Iterator ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; public final class FlowList { private Vector _elements ; public FlowList ( ) { _elements = null ; } public FlowList ( InstructionHandle bh ) { _elements = new Vector ( ) ; _elements . addElement ( bh ) ; } public FlowList ( FlowList list ) { _elements = list . _elements ; } public FlowList add ( InstructionHandle bh ) { if ( _elements == null ) { _elements = new Vector ( ) ; } _elements . addElement ( bh ) ; return this ; } public FlowList append ( FlowList right ) { if ( _elements == null ) { _elements = right . _elements ; } else { final Vector temp = right . _elements ; if ( temp != null ) { final int n = temp . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { _elements . addElement ( temp . elementAt ( i ) ) ; } } } return this ; } public void backPatch ( InstructionHandle target ) { if ( _elements != null ) { final int n = _elements . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { BranchHandle bh = ( BranchHandle ) _elements . elementAt ( i ) ; bh . setTarget ( target ) ; } _elements . clear ( ) ; } } public FlowList copyAndRedirect ( InstructionList oldList , InstructionList newList ) { final FlowList result = new FlowList ( ) ; if ( _elements == null ) { return result ; } final int n = _elements . size ( ) ; final Iterator oldIter = oldList . iterator ( ) ; final Iterator newIter = newList . iterator ( ) ; while ( oldIter . hasNext ( ) ) { final InstructionHandle oldIh = ( InstructionHandle ) oldIter . next ( ) ; final InstructionHandle newIh = ( InstructionHandle ) newIter . next ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( _elements . elementAt ( i ) == oldIh ) { result . add ( newIh ) ; } } } return result ; } } 	0	['7', '1', '0', '29', '17', '0', '26', '3', '7', '0', '155', '1', '0', '0', '0.464285714', '0', '0', '21', '4', '1.8571', '0']
package org . apache . xalan . res ; public class XSLTErrorResources_fr extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "Erreur : L’expression ne peut pas contenir '{'" } , { ER_ILLEGAL_ATTRIBUTE , "{0} dispose d’un attribut non autorisé : {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode est vide dans xsl:apply-imports!" } , { ER_CANNOT_ADD , "Impossible d’ajouter {0} à {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode est vide dans handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} doit disposer d’un attribut name." } , { ER_TEMPLATE_NOT_FOUND , "Impossible de trouver le modèle : {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Impossible de résoudre le nom AVT dans xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} requiert l’attribut : {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} doit disposer de l’attribut ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Valeur incorrecte pour l’attribut level : {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Le nom de processing-instruction ne peut pas être 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Le nom de processing-instruction doit être un nom sans deux points correct : {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} doit disposer d’un attribut conforme s’il a un mode." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} requiert soit un nom soit un attribut conforme." } , { ER_CANT_RESOLVE_NSPREFIX , "Impossible de résoudre le préfixe d'espace de noms : {0}" } , { ER_ILLEGAL_VALUE , "xml:space dispose d’une valeur non autorisée : {0}" } , { ER_NO_OWNERDOC , "Le nœud enfant ne dispose pas d’un document propriétaire !" } , { ER_ELEMTEMPLATEELEM_ERR , "Erreur ElemTemplateElement : {0}" } , { ER_NULL_CHILD , "Tentative d’ajout d’un enfant vide !" } , { ER_NEED_SELECT_ATTRIB , "{0} requiert un attribut select." } , { ER_NEED_TEST_ATTRIB , "xsl:when doit disposer d’un attribut 'test'." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param doit disposer d’un attribut 'name'." } , { ER_NO_CONTEXT_OWNERDOC , "Le contexte ne dispose pas d’un document propriétaire !" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Impossible de créer XML TransformerFactory Liaison : {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: échec du traitement." } , { ER_NOT_SUCCESSFUL , "Xalan: échec." } , { ER_ENCODING_NOT_SUPPORTED , "Encodage non pris en charge : {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Impossible de créer TraceListener : {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key requiert un attribut 'name' !" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key requiert un attribut 'match' !" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key requiert un attribut 'use' !" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} requiert un attribut ''elements'' !" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} attribut ''prefix'' manquant" } , { ER_BAD_STYLESHEET_URL , "L’URL de la feuille de style n’est pas correct : {0}" } , { ER_FILE_NOT_FOUND , "Le fichier de feuille de style est introuvable : {0}" } , { ER_IOEXCEPTION , "Exception d’E/S avec le fichier de feuille de style : {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Impossible de trouver l’attribut href pour {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} est directement ou indirectement inclus dans lui-même !" } , { ER_PROCESSINCLUDE_ERROR , "Erreur StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} attribut ''lang'' manquant" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) élément {0} mal placé ?? Elément ''component'' de container manquant" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Sortie possible uniquement vers Element, DocumentFragment, Document ou PrintWriter." } , { ER_PROCESS_ERROR , "Erreur StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Erreur UnImplNode : {0}" } , { ER_NO_SELECT_EXPRESSION , "Erreur ! Impossible de trouver l’expression de sélection xpath (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Impossible de mettre en série un processeur XSL !" } , { ER_NO_INPUT_STYLESHEET , "Entrée de la feuille de style non spécifiée !" } , { ER_FAILED_PROCESS_STYLESHEET , "Echec de traitement de la feuille de style !" } , { ER_COULDNT_PARSE_DOC , "Impossible d’analyser le document {0} !" } , { ER_COULDNT_FIND_FRAGMENT , "Impossible de trouver le fragment : {0}" } , { ER_NODE_NOT_ELEMENT , "Le nœud identifié par l’identificateur de fragments n’est pas un élement : {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each doit disposer d’un attribut match ou name" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates doit disposer d’un attribut match ou name" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Impossible de cloner un fragment de document !" } , { ER_CANT_CREATE_ITEM , "Impossible de créer un objet dans l’arbre de résultats : {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space dispose d’une valeur non autorisée dans la source XML : {0}" } , { ER_NO_XSLKEY_DECLARATION , "Il n’existe pas de déclaration xsl:key pour for {0} !" } , { ER_CANT_CREATE_URL , "Erreur! Impossible de créer une url pour : {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions n’est pas pris en charge" } , { ER_PROCESSOR_ERROR , "Erreur XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} non autorisé dans une feuille de style !" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns n’est plus pris en charge ! Utilisez xsl:output à la place." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space n’est plus pris en charge ! Utilisez xsl:strip-space ou xsl:preserve-space à la place." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result n’est plus pris en charge ! Utilisez xsl:output à la place." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} dispose d’un attribut non autorisé : {1}" } , { ER_UNKNOWN_XSL_ELEM , "Elément XSL inconnu : {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort ne peut être utilisé qu’avec xsl:apply-templates ou xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when mal placé !" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:choose n’est pas parent de xsl:when !" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise mal placé !" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:choose n’est pas parent de xsl:otherwise !" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} n’est pas admis dans un modèle !" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} préfixe de l’espace de noms de l’extension {1} inconnu" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Les importations ne peuvent intervenir qu’en tant que premiers éléments de la feuille de style !" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} est en train de s’importer directement ou indirectement !" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space dispose d’une valeur non autorisée : {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "Echec de processStylesheet !" } , { ER_SAX_EXCEPTION , "Exception SAX" } , { ER_XSLT_ERROR , "Erreur XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "Le symbole d’une devise n’est pas admise dans une chaîne conforme au modèle" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "La fonction Document n’est pas prise en charge dans la feuille de style DOM !" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Impossible de résoudre le préfixe d’un résolveur sans préfixe !" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect extension : impossible de récupérer le nom de fichier – l’attribut file ou select doit retourner une chaîne valide." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Impossible de créer FormatterListener dans Redirect extension !" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Le préfixe dans exclude-result-prefixes n’est pas valide : {0}" } , { ER_MISSING_NS_URI , "URI d’espace de noms manquant pour le préfixe spécifié" } , { ER_MISSING_ARG_FOR_OPTION , "Argument manquant pour l’option : {0}" } , { ER_INVALID_OPTION , "Option incorrecte : {0}" } , { ER_MALFORMED_FORMAT_STRING , "Chaîne de format mal formée : {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requiert un attribut 'version' !" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "L’attribut : {0} dispose d’une valeur non autorisée : {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose requiert un xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports n’est pas admis dans un xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Impossible d'utiliser DTMLiaison pour un noeud de sortie DOM ... Utilisez org.apache.xpath.DOM2Helper à la place !" } , { ER_CANT_USE_DTM_FOR_INPUT , "Impossible d'utiliser DTMLiaison pour un noeud d'entrée DOM... Utilisez org.apache.xpath.DOM2Helper à la place!" } , { ER_CALL_TO_EXT_FAILED , "Echec de l’appel de l’élément d’extension : {0}" } , { ER_PREFIX_MUST_RESOLVE , "Le préfixe doit se résoudre en espace de nom : {0}" } , { ER_INVALID_UTF16_SURROGATE , "Substitut UTF-16 incorrect détecté : {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} s’est utilisé lui-même, ce qui va entraîner une boucle sans fin." } , { ER_CANNOT_MIX_XERCESDOM , "Impossible de mélanger des entrées non Xerces-DOM avec des sorties Xerces-DOM !" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "Dans ElemTemplateElement.readObject : {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Plusieurs modèles trouvés nommés : {0}" } , { ER_INVALID_KEY_CALL , "Appel de fonction incorrect : les appels de recursive key() ne sont pas autorisés" } , { ER_REFERENCING_ITSELF , "La variable {0} est en train de se référencer directement ou indirectement !" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Le nœud d’entrée ne peut pas être vide au niveau d’une source DOM pour newTemplates !" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Fichier de classe introuvable pour l’option {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Elément requis introuvable : {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream ne peut pas être vide" } , { ER_URI_CANNOT_BE_NULL , "URI ne peut pas être vide" } , { ER_FILE_CANNOT_BE_NULL , "File ne peut pas être vide" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource ne peut pas être vide" } , { ER_CANNOT_INIT_BSFMGR , "Impossible d’initialiser BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "Impossible de compiler l’extension" } , { ER_CANNOT_CREATE_EXTENSN , "Impossible de créer l’extension : {0} à cause de : {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "L’appel de la méthode d’instance à la méthode {0} requiert une instance Object comme premier argument" } , { ER_INVALID_ELEMENT_NAME , "Nom d’élément spécifié incorrect {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "La méthode de nom d’élément doit être statique {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Fonction d’extension {0} : {1} inconnue" } , { ER_MORE_MATCH_CONSTRUCTOR , "Plusieurs occurrences exactes pour le constructeur pour {0}" } , { ER_MORE_MATCH_METHOD , "Plusieurs occurrences exactes pour la méthode {0}" } , { ER_MORE_MATCH_ELEMENT , " Plusieurs occurrences exactes pour la méthode d’éléments {0}" } , { ER_INVALID_CONTEXT_PASSED , "Contexte incorrect pour l’évaluation {0}" } , { ER_POOL_EXISTS , "Pool existe déjà" } , { ER_NO_DRIVER_NAME , "Aucun nom de pilote spécifié" } , { ER_NO_URL , "Aucune URL spécifiée" } , { ER_POOL_SIZE_LESSTHAN_ONE , "La taille du Pool est inférieure à un !" } , { ER_INVALID_DRIVER , "Le nom de pilote spécifié n’est pas correct !" } , { ER_NO_STYLESHEETROOT , "Impossible de trouver la feuille de style racine !" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Valeur non autorisée pour xml:space" } , { ER_PROCESSFROMNODE_FAILED , "Echec de processFromNode" } , { ER_RESOURCE_COULD_NOT_LOAD , "La ressource [ {0} ] n’a pas pu être chargée : {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Taille du tampon <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Erreur inconnue lors de l’appel de l’extension" } , { ER_NO_NAMESPACE_DECL , "Le préfixe {0} de dispose pas d’une déclaration d’espaces de noms correspondante" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Contenu d’élément non autorisé pour lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Achèvement dirigé de la feuille de style" } , { ER_ONE_OR_TWO , "1 ou 2" } , { ER_TWO_OR_THREE , "2 ou 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Impossible de charger {0} (vérifier le CHEMIN DE CLASSE). Utilisation des modèles par défaut" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Impossible d’initialiser les modèles par défaut" } , { ER_RESULT_NULL , "Le résultat ne peut pas être vide" } , { ER_RESULT_COULD_NOT_BE_SET , "Le résultat ne peut pas être défini" } , { ER_NO_OUTPUT_SPECIFIED , "Aucune sortie spécifiée" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Transformation impossible en un résultat de type {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Transformation impossible d’une source de type {0}" } , { ER_NULL_CONTENT_HANDLER , "Gestionnaire de contenu vide" } , { ER_NULL_ERROR_HANDLER , "Gestionnaire d’erreurs vide" } , { ER_CANNOT_CALL_PARSE , "L’analyse ne peut être appelée si le gestionnaire de contenu n’a pas été défini" } , { ER_NO_PARENT_FOR_FILTER , "Aucun parent pour le filtre" } , { ER_NO_STYLESHEET_IN_MEDIA , "Aucune feuille de style trouvée dans: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "Aucun xml-stylesheet PI trouvé dans : {0}" } , { ER_NOT_SUPPORTED , "Non pris en charge : {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "La valeur pour la propriété {0} doit être une instance booléenne" } , { "ER_SRC_ATTRIB_NOT_SUPPORTED" , "L’attribut src n’est pas encore pris en charge pour {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "Impossible de trouver la ressource [ {0} ].\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "La propriété de sortie n’a pas été reconnue : {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Echec de création de l’instance ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "La valeur de {0} doit contenir un nombre analysable" } , { ER_VALUE_SHOULD_EQUAL , "La valeur pour {0} doit être équivalente à oui ou non" } , { ER_FAILED_CALLING_METHOD , "Echec d’appel de la méthode {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Echec de création de l’instance ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "Les caractères ne sont pas admis à ce niveau du document" } , { ER_ATTR_NOT_ALLOWED , "L’attribut \"{0}\" n’est pas admis dans l’élément {1} !" } , { ER_BAD_VALUE , "{0} valeur incorrecte {1}" } , { ER_ATTRIB_VALUE_NOT_FOUND , "Valeur de l’attribut {0} introuvable" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Valeur de l’attribut {0} non reconnue" } , { ER_NULL_URI_NAMESPACE , "Tentative de génération d'un préfixe d'expace de nom avec un URI nul" } , { ER_NUMBER_TOO_BIG , "Tentative de formatage d'un nombre supérieur à l'entier le plus long" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Classe de pilotes SAX1 {0} introuvable" } , { ER_SAX1_DRIVER_NOT_LOADED , "La classe de pilotes SAX1 {0} a été trouvée mais n''a pas été chargée" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "La classe de pilotes SAX1 {0} a été chargée mais n''a pas été instanciée" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "La classe de pilotes SAX1 {0} n''implémente pas org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Les propriétés du système org.xml.sax.parser n'ont pas été spécifiées" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "L'argument de l'analyseur ne doit pas être nul" } , { ER_FEATURE , "Fonction : a {0}" } , { ER_PROPERTY , "Propriété : a {0}" } , { ER_NULL_ENTITY_RESOLVER , "Convertisseur d'entité nul" } , { ER_NULL_DTD_HANDLER , "Gestionnaire de DTD nul" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Aucun nom de pilote spécifié !" } , { ER_NO_URL_SPECIFIED , "Aucun URL spécifié !" } , { ER_POOLSIZE_LESS_THAN_ONE , "La taille du pool est inférieure à 1 !" } , { ER_INVALID_DRIVER_NAME , "Nom de pilote spécifié incorrect !" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Erreur du programmeur ! expr n'a pas de parent ElemTemplateElement !" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Assertion du programmeur dans RundundentExprEliminator : {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} n'est pas admis à cet endroit de la feuille de style !" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Le texte sans espace blanc n'est pas admis à cet endroit de la feuille de style !" } , { INVALID_TCHAR , "Valeur incorrecte : {1} est utilisé pour l'attribut CHAR : {0}.  Un attribut de type CHAR doit être composé d'un seul caractère !" } , { INVALID_QNAME , "Valeur incorrecte :a {1} utilisé pour l''attribut QNAME :a {0}" } , { INVALID_ENUM , "Valeur incorrecte :a {1} utilisé pour l''attribut ENUM :a {0}.  Les valeurs correctes sont :a {2}." } , { INVALID_NMTOKEN , "Valeur incorrecte :a {1} utilisé pour l''attribut NMTOKEN :a {0} " } , { INVALID_NCNAME , "Valeur incorrecte :a {1} utilisé pour l''attribut NCNAME :a {0} " } , { INVALID_BOOLEAN , "Valeur incorrecte :a {1} utilisé pour l''attribut boolean :a {0} " } , { INVALID_NUMBER , "Valeur incorrecte :a {1} utilisé pour l''attribut number :a {0} " } , { ER_ARG_LITERAL , "L''argument de {0} de la structure de comparaison doit être un littéral." } , { ER_DUPLICATE_GLOBAL_VAR , "Duplication de la déclaration de variable globale." } , { ER_DUPLICATE_VAR , "Duplication de la déclaration de variable." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template doit avoir un attribut name ou match (ou les deux)" } , { ER_INVALID_PREFIX , "Le préfixe de exclude-result-prefixes est incorrect :a {0}" } , { ER_NO_ATTRIB_SET , "L''ensemble d'attributs {0} n'existe pas" } , { WG_FOUND_CURLYBRACE , "'}' trouvé mais aucun modèle d’attribut ouvert !" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Attention : l’attribut count ne correspond pas à un ancêtre dans xsl:number! Target = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Ancienne syntaxe : le nom de l’attribut 'expr' été changé par 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan ne gère pas encore la partie locale du nom dans la fonction format-number." } , { WG_LOCALE_NOT_FOUND , "Attention : Impossible de trouver la partie locale du nom pour xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossible de créer une URL à partir de : {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Impossible de charger le document demandé : {0}" } , { WG_CANNOT_FIND_COLLATOR , "Impossible de trouver Collator pour <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Ancienne syntaxe : les fonctions doivent utiliser une url de {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "Encodage non pris en charge : {0}, en utilisant UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , " Encodage non pris en charge: {0}, en utilisant Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Conflits de spécificité détectés : {0}, le dernier trouvé dans la feuille de style sera utilisé." } , { WG_PARSING_AND_PREPARING , "========= Analyse et préparation {0} ==========" } , { WG_ATTR_TEMPLATE , "Modèle d’attribut, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Conflit de correspondance entre xsl:strip-space et xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan ne gère pas encore l’attribut {0} !" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Aucune déclaration trouvée pour le format décimal : {0}" } , { WG_OLD_XSLT_NS , "Espace de noms XSLT manquant ou incorrect. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Seule une déclaration xsl:decimal-format par défaut est autorisée." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Les noms xsl:decimal-format doivent être uniques. Le nom \"{0}\" apparaît en double." } , { WG_ILLEGAL_ATTRIBUTE , "{0} dispose d’un attribut non autorisé : {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Impossible de résoudre de préfixe d’espace de noms : {0}. Le nœud sera ignoré." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requiert un attribut 'version' !" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Nom d’attribut non autorisé : {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "La valeur utilisée pour l’attribut {0} n’est pas autorisée : {1}" } , { WG_EMPTY_SECOND_ARG , "L’ensemble de nœuds résultant d’un deuxième argument de la fonction document est vide. Le premier argument sera utilisé." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "La valeur de l'attribut 'name' de xsl:processing-instruction ne doit pas être 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "La valeur de l''attribut ''name'' de xsl:processing-instruction doit être un NCName valide :a {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Impossible d''ajouter l''attribut {0}après les noeuds enfants ou avant qu'un élément ne soit produit.  L'attribut est ignoré." } , { "ui_language" , "fr" } , { "help_language" , "fr" } , { "language" , "fr" } , { "BAD_CODE" , "Paramètre pour createMessage hors limites" } , { "FORMAT_FAILED" , "Exception émise pendant l’appel de messageFormat " } , { "version" , ">>>>>>> Version Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "oui" } , { "line" , "N° de ligne" } , { "column" , "N° de colonne" } , { "xsldone" , "XSLProcessor: terminé" } , { "xslProc_option" , "Options de classe de traitement de la ligne de commande Xalan-J :" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER nom de classe qualifié pour la liaison de l’analyseur]" } , { "optionE" , "   [-E (Ne pas développer les références d’entités)]" } , { "optionV" , "   [-E (Ne pas développer les références d’entités)]" } , { "optionQC" , "   [-QC (Avertissements pour les conflits silencieux de formes)]" } , { "optionQ" , "   [-Q  (Mode silencieux)]" } , { "optionLF" , "   [-LF (Utilisation des sauts de ligne uniquement en sortie {CR/LF par défaut})]" } , { "optionCR" , "   [-CR (Utilisation des retours chariot uniquement en sortie {CR/LF par défaut})]" } , { "optionESCAPE" , "   [-ESCAPE (Caractères à remplacer {<>&\"\'\\r\\n par défaut}]" } , { "optionINDENT" , "   [-INDENT (Contrôle le nombre d’espaces pour le retrait {0 par défaut})]" } , { "optionTT" , "   [-TT (Trace des modèles lors de leur appel.)]" } , { "optionTG" , "   [-TG (Trace de chaque création d’événement.)]" } , { "optionTS" , "   [-TS (Trace de chaque sélection d’événement.)]" } , { "optionTTC" , "   [-TTC (Trace de chaque modèle enfant lorsqu’ils sont traités.)]" } , { "optionTCLASS" , "   [-TCLASS (Classe TraceListener pour les extensions de trace.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Détermine si la validation intervient. La validation est désactivée par défaut.)]" } , { "optionEDUMP" , "   [-EDUMP {optional filename} (Permet d’accéder à l’emplacement de l’erreur.)]" } , { "optionXML" , "   [-XML (Utilisation d’un formateur XML et ajout d’en-tête XML.)]" } , { "optionTEXT" , "   [-TEXT (Utilisation d’un formateur de texte simple.)]" } , { "optionHTML" , "   [-HTML (Utilisation d’un formateur HTML.)]" } , { "optionPARAM" , "   [-PARAM name expression (Définition d’un paramètre de feuille de style)]" } , { "noParsermsg1" , "Echec de XSL Process." } , { "noParsermsg2" , "** Impossible de trouver l’analyseur **" } , { "noParsermsg3" , "Veuillez vérifier votre chemin de classe." } , { "noParsermsg4" , " Si vous ne disposez pas de l’analyseur XML d’IBM pour Java, vous pouvez le télécharger à l’adresse suivante " } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER nom de classe complet (URIResolver à utiliser pour résoudre les URI)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER nom de classe complet (EntityResolver à utiliser pour résoudre les entités)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER nom de classe complet (ContentHandler à utiliser pour mettre en série les sorties)]" } , { "optionLINENUMBERS" , "   [-L Utilisation des nombres de lignes pour le document source]" } , { "optionMEDIA" , " [-MEDIA mediaType (utilisation de l'attribut media pour rechercher la feuille de style associée à un document.)]" } , { "optionFLAVOR" , " [-FLAVOR flavorName (utilisation explicite de s2s=SAX ou d2d=DOM pour procéder aux transformations.)] " } , { "optionDIAG" , " [-DIAG (Impression du nombre global de millisecondes de la transformation.)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (demande de construction DTM incrémentielle en attribuant la valeur true à http://xml.apache.org/xalan/features/incremental.)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (demande d'aucune optimisation de la feuille de style en attribuant la valeur false à http://xml.apache.org/xalan/features/optimize.)]" } , { "optionRL" , " [-RL recursionlimit (assertion d'une limite numérique sur la profondeur de récursion de la feuille de style.)]" } , { "optionXO" , " [-XO [transletName] (affectation du nom au translet généré)]" } , { "optionXD" , " [-XD destinationDirectory (spécification d'un répertoire de destination pour le translet)]" } , { "optionXJ" , " [-XJ jarfile (regroupe les classes de translet dans un fichier jar nommé <jarfile>)]" } , { "optionXP" , " [-XP package (spécifie un préfixe de nom de groupe pour toutes les classes de translet générées)]" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Erreur : " ; public static final String WARNING_HEADER = "Attention : " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "FORME" ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.423076923', '3769', '0', '0', '0.976190476', '1', '0', '0', '1251', '1', '0.3333', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMWSFilter ; public class DOMWSFilter implements DTMWSFilter { private AbstractTranslet m_translet ; private StripFilter m_filter ; private Hashtable m_mappings ; private DTM m_currentDTM ; private short [ ] m_currentMapping ; public DOMWSFilter ( AbstractTranslet translet ) { m_translet = translet ; m_mappings = new Hashtable ( ) ; if ( translet instanceof StripFilter ) { m_filter = ( StripFilter ) translet ; } } public short getShouldStripSpace ( int node , DTM dtm ) { if ( m_filter != null && dtm instanceof DOM ) { DOM dom = ( DOM ) dtm ; int type = 0 ; if ( dtm instanceof SAXImpl ) { SAXImpl saxImpl = ( SAXImpl ) dtm ; short [ ] mapping ; if ( dtm == m_currentDTM ) { mapping = m_currentMapping ; } else { mapping = ( short [ ] ) m_mappings . get ( dtm ) ; if ( mapping == null ) { mapping = saxImpl . getMapping ( m_translet . getNamesArray ( ) ) ; m_mappings . put ( dtm , mapping ) ; m_currentDTM = saxImpl ; m_currentMapping = mapping ; } } int expType = saxImpl . getExpandedTypeID ( node ) ; if ( expType >= 0 && expType < mapping . length ) type = mapping [ expType ] ; else type = - 1 ; } else { return INHERIT ; } if ( m_filter . stripSpace ( dom , node , type ) ) { return STRIP ; } else { return NOTSTRIP ; } } else { return NOTSTRIP ; } } } 	0	['2', '1', '0', '9', '10', '0', '2', '7', '2', '0.4', '110', '1', '4', '0', '0.625', '0', '0', '51.5', '9', '4.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class FloorCall extends FunctionCall { public FloorCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { argument ( ) . translate ( classGen , methodGen ) ; methodGen . getInstructionList ( ) . append ( new INVOKESTATIC ( classGen . getConstantPool ( ) . addMethodref ( MATH_CLASS , "floor" , "(D)D" ) ) ) ; } } 	0	['2', '4', '0', '10', '10', '1', '0', '10', '2', '2', '26', '0', '0', '0.989690722', '0.6', '2', '4', '12', '1', '0.5', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class And extends Operation { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject expr1 = m_left . execute ( xctxt ) ; if ( expr1 . bool ( ) ) { XObject expr2 = m_right . execute ( xctxt ) ; return expr2 . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } else return XBoolean . S_FALSE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . bool ( xctxt ) && m_right . bool ( xctxt ) ) ; } } 	0	['3', '3', '0', '6', '7', '1', '1', '5', '3', '2', '42', '0', '0', '0.953488372', '0.833333333', '1', '6', '13', '1', '0.6667', '0']
package org . apache . xalan . xsltc . dom ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; public interface ExtendedSAX extends ContentHandler , LexicalHandler , DTDHandler , DeclHandler { } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xalan . xsltc . compiler . util ; public final class ErrorMessages_no extends ErrorMessages { private static final String m_errorMessages [ ] [ ] = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "En fil kan bare innehold ett stilark." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "<xsl:template> ''{0}'' er allerede definert i dette stilarket." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "<xsl:template> ''{0}'' er ikke definert i dette stilarket." } , { ErrorMsg . VARIABLE_REDEF_ERR , "Variabel ''{0}'' er allerede definert." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Variabel eller parameter ''{0}'' er ikke definert." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Finner ikke klassen ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Finner ikke ekstern funksjon ''{0}'' (må v\00e6re deklarert både 'static' og 'public')." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Kan ikke konvertere argument/retur type i kall til funksjon ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Finner ikke fil eller URI ''{0}''." } , { ErrorMsg . INVALID_URI_ERR , "Ugyldig URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Kan ikke åpne fil eller URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "Forvented <xsl:stylesheet> eller <xsl:transform> element." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Prefiks ''{0}'' er ikke deklarert." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Kunne ikke resolvere kall til funksjon ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "Argument til ''{0}'' må v\00e6re ordrett tekst." } , { ErrorMsg . XPATH_PARSER_ERR , "Kunne ikke tolke XPath uttrykk ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Nødvendig attributt ''{0}'' er ikke deklarert." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Ugyldig bokstav/tegn ''{0}'' i XPath uttrykk." } , { ErrorMsg . ILLEGAL_PI_ERR , "Ugyldig navn ''{0}'' for prosesserings-instruksjon." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Attributt ''{0}'' utenfor element." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Ugyldig attributt ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Sirkul \00e6 import/include; stilark ''{0}'' er alt lest." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Result-tre fragmenter kan ikke sorteres (<xsl:sort> elementer vil " + "bli ignorert). Du må sortere nodene mens du bygger treet." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Formatterings-symboler ''{0}'' er alt definert." } , { ErrorMsg . XSL_VERSION_ERR , "XSL versjon ''{0}'' er ikke støttet av XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Sirkul\00e6r variabel/parameter referanse i ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Ugyldig operator for bin\00e6rt uttrykk." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Ugyldig parameter i funksjons-kall." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Andre argument til document() må v\00e6re et node-sett." } , { ErrorMsg . MISSING_WHEN_ERR , "Du må deklarere minst ett <xsl:when> element innenfor <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Kun ett <xsl:otherwise> element kan deklareres innenfor <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> kan kun benyttes innenfor <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> kan kun benyttes innenfor <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Kun <xsl:when> og <xsl:otherwise> kan benyttes innenfor <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> element manger 'name' attributt." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Ugyldig element." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "''{0}'' er ikke et gyldig navn for et element." } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "''{0}'' er ikke et gyldig navn for et attributt." } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Du kan ikke plassere tekst utenfor et <xsl:stylesheet> element." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP parser er ikke korrekt konfigurert." } , { ErrorMsg . INTERNAL_ERR , "XSLTC-intern feil: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Støtter ikke XSL element ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "XSLTC støtter ikke utvidet funksjon ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Dette dokumentet er ikke et XSL stilark " + "(xmlns:xsl='http://www.w3.org/1999/XSL/Transform' er ikke deklarert)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Kan ikke finne stilark ved navn ''{0}'' i dette dokumentet." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Ikke implementert/gjenkjent: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Dokumentet inneholder ikke et XSL stilark" } , { ErrorMsg . ELEMENT_PARSE_ERR , "Kan ikke tolke element ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "'use'-attributtet i <xsl:key> må v\00e6re node, node-sett, tekst eller nummer." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Det genererte XML dokumentet må gis versjon 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Ugyldig operator for relasjons-uttrykk." } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Finner ikke <xsl:attribute-set> element med navn ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Kan ikke tolke attributt ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Ukjent data-type i signatur for klassen ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Kan ikke oversette mellom data-type ''{0}'' og ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Dette Templates objected inneholder ingen translet klasse definisjon." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Dette Templates objected inneholder ingen klasse ved navn ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Kan ikke laste translet-klasse ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Translet klassen er lastet man kan instansieres." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "ErrorListener for ''{0}'' forsøkt satt til 'null'." } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Kun StreamSource, SAXSource og DOMSOurce er støttet av XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "Source objekt sendt til ''{0}'' har intet innhold." } , { ErrorMsg . JAXP_COMPILE_ERR , "Kan ikke kompilere stilark." } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory gjenkjenner ikke attributtet ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() må kalles før startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer objektet inneholder ikken noen translet instans." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Ingen 'handler' er satt for å ta imot generert dokument." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Result objektet sendt til ''{0}'' er ikke gyldig." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Forsøker å lese ugyldig attributt ''{0}'' fra Transformer." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Kan ikke instansiere SAX2DOM adapter: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() kalt uten at 'systemId' er definert." } , { ErrorMsg . COMPILE_STDIN_ERR , "Du kan ikke bruke -i uten å også angi klasse-navn med -o." } , { ErrorMsg . COMPILE_USAGE_STR , "Bruk:\n" + "   xsltc [-o <klasse>] [-d <katalog>] [-j <arkiv>]\n" + "         [-p <pakke>] [-x] [-s] [-u] <stilark>|-i\n\n" + "   Der:  <klasse> er navnet du vil gi den kompilerte java klassen.\n" + "         <stilark> er ett eller flere XSL stilark, eller dersom -u\n" + "         er benyttet, en eller flere URL'er til stilark.\n" + "         <katalog> katalog der klasse filer vil plasseres.\n" + "         <arkiv> er en JAR-fil der klassene vil plasseres\n" + "         <pakke> er an Java 'package' klassene vil legges i.\n\n" + "   Annet:\n" + "         -i tvinger kompilatoren til å lese fra stdin.\n" + "         -o ignoreres dersom flere enn ett silark kompileres.\n" + "         -x slår på debug meldinger.\n" + "         -s blokkerer alle kall til System.exit()." } , { ErrorMsg . TRANSFORM_USAGE_STR , "Bruk: \n" + "   xslt  [-j <arkiv>] {-u <url> | <dokument>} <klasse>\n" + "         [<param>=<verdi> ...]\n\n" + "   Der:  <dokument> er XML dokumentet som skal behandles.\n" + "         <url> er en URL til XML dokumentet som skal behandles.\n" + "         <klasse> er Java klassen som skal benyttes.\n" + "         <arkiv> er en JAR-fil som klassen leses fra.\n" + "   Annet:\n" + "         -x slår på debug meldinger.\n" + "         -s blokkerer alle kall til System.exit()." } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> kan bare brukes under <xsl:for-each> eller <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Karaktersett ''{0}'' er ikke støttet av denne JVM." } , { ErrorMsg . SYNTAX_ERR , "Syntax error in ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '1014', '1', '0', '0.975', '1', '0', '0', '336.6666667', '1', '0.3333', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class AncestorPattern extends RelativePathPattern { private final Pattern _left ; private final RelativePathPattern _right ; private InstructionHandle _loop ; public AncestorPattern ( RelativePathPattern right ) { this ( null , right ) ; } public AncestorPattern ( Pattern left , RelativePathPattern right ) { _left = left ; ( _right = right ) . setParent ( this ) ; if ( left != null ) { left . setParent ( this ) ; } } public InstructionHandle getLoopHandle ( ) { return _loop ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _left != null ) { _left . setParser ( parser ) ; } _right . setParser ( parser ) ; } public boolean isWildcard ( ) { return false ; } public StepPattern getKernelPattern ( ) { return _right . getKernelPattern ( ) ; } public void reduceKernelPattern ( ) { _right . reduceKernelPattern ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _left != null ) { _left . typeCheck ( stable ) ; } return _right . typeCheck ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { InstructionHandle parent ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final LocalVariableGen local = methodGen . addLocalVariable2 ( "app" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) ) ; final org . apache . bcel . generic . Instruction loadLocal = new ILOAD ( local . getIndex ( ) ) ; final org . apache . bcel . generic . Instruction storeLocal = new ISTORE ( local . getIndex ( ) ) ; if ( _right instanceof StepPattern ) { il . append ( DUP ) ; il . append ( storeLocal ) ; _right . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( loadLocal ) ; } else { _right . translate ( classGen , methodGen ) ; if ( _right instanceof AncestorPattern ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; } } if ( _left != null ) { final int getParent = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; parent = il . append ( new INVOKEINTERFACE ( getParent , 2 ) ) ; il . append ( DUP ) ; il . append ( storeLocal ) ; _falseList . add ( il . append ( new IFLT ( null ) ) ) ; il . append ( loadLocal ) ; _left . translate ( classGen , methodGen ) ; final SyntaxTreeNode p = getParent ( ) ; if ( p == null || p instanceof Instruction || p instanceof TopLevelElement ) { } else { il . append ( loadLocal ) ; } final BranchHandle exit = il . append ( new GOTO ( null ) ) ; _loop = il . append ( methodGen . loadDOM ( ) ) ; il . append ( loadLocal ) ; local . setEnd ( _loop ) ; il . append ( new GOTO ( parent ) ) ; exit . setTarget ( il . append ( NOP ) ) ; _left . backPatchFalseList ( _loop ) ; _trueList . append ( _left . _trueList ) ; } else { il . append ( POP2 ) ; } if ( _right instanceof AncestorPattern ) { final AncestorPattern ancestor = ( AncestorPattern ) _right ; _falseList . backPatch ( ancestor . getLoopHandle ( ) ) ; } _trueList . append ( _right . _trueList ) ; _falseList . append ( _right . _falseList ) ; } public String toString ( ) { return "AncestorPattern(" + _left + ", " + _right + ')' ; } } 	0	['10', '6', '0', '30', '48', '1', '2', '28', '10', '0.518518519', '302', '1', '2', '0.925233645', '0.242857143', '4', '5', '28.9', '8', '1.6', '0']
package org . apache . xpath . patterns ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . objects . XObject ; public class ContextMatchStepPattern extends StepPattern { public ContextMatchStepPattern ( int axis , int paxis ) { super ( DTMFilter . SHOW_ALL , axis , paxis ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( xctxt . getIteratorRoot ( ) == xctxt . getCurrentNode ( ) ) return getStaticScore ( ) ; else return this . SCORE_NONE ; } public XObject executeRelativePathPattern ( XPathContext xctxt , StepPattern prevStep ) throws javax . xml . transform . TransformerException { XObject score = NodeTest . SCORE_NONE ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; if ( null != dtm ) { int predContext = xctxt . getCurrentNode ( ) ; DTMAxisTraverser traverser ; int axis = m_axis ; boolean needToTraverseAttrs = WalkerFactory . isDownwardAxisOfMany ( axis ) ; boolean iterRootIsAttr = ( dtm . getNodeType ( xctxt . getIteratorRoot ( ) ) == DTM . ATTRIBUTE_NODE ) ; if ( ( Axis . PRECEDING == axis ) && iterRootIsAttr ) { axis = Axis . PRECEDINGANDANCESTOR ; } traverser = dtm . getAxisTraverser ( axis ) ; for ( int relative = traverser . first ( context ) ; DTM . NULL != relative ; relative = traverser . next ( context , relative ) ) { try { xctxt . pushCurrentNode ( relative ) ; score = execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) { if ( executePredicates ( xctxt , dtm , context ) ) return score ; score = NodeTest . SCORE_NONE ; } if ( needToTraverseAttrs && iterRootIsAttr && ( DTM . ELEMENT_NODE == dtm . getNodeType ( relative ) ) ) { int xaxis = Axis . ATTRIBUTE ; for ( int i = 0 ; i < 2 ; i ++ ) { DTMAxisTraverser atraverser = dtm . getAxisTraverser ( xaxis ) ; for ( int arelative = atraverser . first ( relative ) ; DTM . NULL != arelative ; arelative = atraverser . next ( relative , arelative ) ) { try { xctxt . pushCurrentNode ( arelative ) ; score = execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) { if ( score != NodeTest . SCORE_NONE ) return score ; } } finally { xctxt . popCurrentNode ( ) ; } } xaxis = Axis . NAMESPACE ; } } } finally { xctxt . popCurrentNode ( ) ; } } } return score ; } } 	0	['3', '4', '0', '8', '16', '3', '1', '8', '3', '2', '176', '0', '0', '0.975903614', '0.583333333', '2', '12', '57.66666667', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . xalan . xsltc . compiler . SyntaxTreeNode ; public class TypeCheckError extends Exception { ErrorMsg _error = null ; SyntaxTreeNode _node = null ; public TypeCheckError ( SyntaxTreeNode node ) { super ( ) ; _node = node ; } public TypeCheckError ( ErrorMsg error ) { super ( ) ; _error = error ; } public TypeCheckError ( String code , Object param ) { super ( ) ; _error = new ErrorMsg ( code , param ) ; } public TypeCheckError ( String code , Object param1 , Object param2 ) { super ( ) ; _error = new ErrorMsg ( code , param1 , param2 ) ; } public ErrorMsg getErrorMsg ( ) { return _error ; } public String getMessage ( ) { return toString ( ) ; } public String toString ( ) { String result ; if ( _error == null ) { if ( _node != null ) { _error = new ErrorMsg ( ErrorMsg . TYPE_CHECK_ERR , _node . toString ( ) ) ; } else { _error = new ErrorMsg ( ErrorMsg . TYPE_CHECK_UNK_LOC_ERR ) ; } } return _error . toString ( ) ; } } 	0	['7', '3', '0', '89', '13', '0', '88', '2', '7', '0.083333333', '98', '0', '2', '0.85', '0.371428571', '1', '2', '12.71428571', '3', '0.7143', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class NameCall extends NameBase { public NameCall ( QName fname ) { super ( fname ) ; } public NameCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getName = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_NAME , GET_NODE_NAME_SIG ) ; super . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( getName , 2 ) ) ; } } 	0	['3', '5', '0', '9', '11', '3', '0', '9', '3', '2', '37', '0', '0', '0.99', '0.533333333', '3', '5', '11.33333333', '1', '0.3333', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class CurrentNodeListIterator extends DTMAxisIteratorBase { private boolean _docOrder ; private DTMAxisIterator _source ; private final CurrentNodeListFilter _filter ; private IntegerArray _nodes = new IntegerArray ( ) ; private int _currentIndex ; private final int _currentNode ; private AbstractTranslet _translet ; public CurrentNodeListIterator ( DTMAxisIterator source , CurrentNodeListFilter filter , int currentNode , AbstractTranslet translet ) { this ( source , ! source . isReverse ( ) , filter , currentNode , translet ) ; } public CurrentNodeListIterator ( DTMAxisIterator source , boolean docOrder , CurrentNodeListFilter filter , int currentNode , AbstractTranslet translet ) { _source = source ; _filter = filter ; _translet = translet ; _docOrder = docOrder ; _currentNode = currentNode ; } public DTMAxisIterator forceNaturalOrder ( ) { _docOrder = true ; return this ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public boolean isReverse ( ) { return ! _docOrder ; } public DTMAxisIterator cloneIterator ( ) { try { final CurrentNodeListIterator clone = ( CurrentNodeListIterator ) super . clone ( ) ; clone . _nodes = ( IntegerArray ) _nodes . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator reset ( ) { _currentIndex = 0 ; return resetPosition ( ) ; } public int next ( ) { final int last = _nodes . cardinality ( ) ; final int currentNode = _currentNode ; final AbstractTranslet translet = _translet ; for ( int index = _currentIndex ; index < last ; ) { final int position = _docOrder ? index + 1 : last - index ; final int node = _nodes . at ( index ++ ) ; if ( _filter . test ( node , position , last , currentNode , translet , this ) ) { _currentIndex = index ; return returnNode ( node ) ; } } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; _nodes . clear ( ) ; while ( ( node = _source . next ( ) ) != END ) { _nodes . add ( node ) ; } _currentIndex = 0 ; resetPosition ( ) ; } return this ; } public int getLast ( ) { if ( _last == - 1 ) { _last = computePositionOfLast ( ) ; } return _last ; } public void setMark ( ) { _markedNode = _currentIndex ; } public void gotoMark ( ) { _currentIndex = _markedNode ; } private int computePositionOfLast ( ) { final int last = _nodes . cardinality ( ) ; final int currNode = _currentNode ; final AbstractTranslet translet = _translet ; int lastPosition = _position ; for ( int index = _currentIndex ; index < last ; ) { final int position = _docOrder ? index + 1 : last - index ; int nodeIndex = _nodes . at ( index ++ ) ; if ( _filter . test ( nodeIndex , position , last , currNode , translet , this ) ) { lastPosition ++ ; } } return lastPosition ; } } 	0	['13', '2', '0', '6', '31', '14', '0', '6', '12', '0.583333333', '268', '1', '4', '0.541666667', '0.307692308', '1', '8', '19.07692308', '3', '1.4615', '0']
package org . apache . xml . dtm . ref . dom2dtm ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . dom . DOMSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . DTMDefaultBaseIterators ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xml . dtm . ref . ExpandedNameTable ; import org . apache . xml . dtm . ref . IncrementalSAXSource ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . Entity ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; public class DOM2DTM extends DTMDefaultBaseIterators { static final boolean JJK_DEBUG = false ; static final boolean JJK_NEWCODE = true ; static final String NAMESPACE_DECL_NS = "http://www.w3.org/XML/1998/namespace" ; transient private Node m_pos ; private int m_last_parent = 0 ; private int m_last_kid = NULL ; transient private Node m_root ; boolean m_processedFirstElement = false ; transient private boolean m_nodesAreProcessed ; protected Vector m_nodes = new Vector ( ) ; public DOM2DTM ( DTMManager mgr , DOMSource domSource , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , domSource , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; m_pos = m_root = domSource . getNode ( ) ; m_last_parent = m_last_kid = NULL ; m_last_kid = addNode ( m_root , m_last_parent , m_last_kid , NULL ) ; if ( ELEMENT_NODE == m_root . getNodeType ( ) ) { NamedNodeMap attrs = m_root . getAttributes ( ) ; int attrsize = ( attrs == null ) ? 0 : attrs . getLength ( ) ; if ( attrsize > 0 ) { int attrIndex = NULL ; for ( int i = 0 ; i < attrsize ; ++ i ) { attrIndex = addNode ( attrs . item ( i ) , 0 , attrIndex , NULL ) ; m_firstch . setElementAt ( DTM . NULL , attrIndex ) ; } m_nextsib . setElementAt ( DTM . NULL , attrIndex ) ; } } m_nodesAreProcessed = false ; } protected int addNode ( Node node , int parentIndex , int previousSibling , int forceNodeType ) { int nodeIndex = m_nodes . size ( ) ; if ( m_dtmIdent . size ( ) == ( nodeIndex > > > DTMManager . IDENT_DTM_NODE_BITS ) ) { try { if ( m_mgr == null ) throw new ClassCastException ( ) ; DTMManagerDefault mgrD = ( DTMManagerDefault ) m_mgr ; int id = mgrD . getFirstFreeDTMID ( ) ; mgrD . addDTM ( this , id , nodeIndex ) ; m_dtmIdent . addElement ( id << DTMManager . IDENT_DTM_NODE_BITS ) ; } catch ( ClassCastException e ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } } m_size ++ ; int type ; if ( NULL == forceNodeType ) type = node . getNodeType ( ) ; else type = forceNodeType ; if ( Node . ATTRIBUTE_NODE == type ) { String name = node . getNodeName ( ) ; if ( name . startsWith ( "xmlns:" ) || name . equals ( "xmlns" ) ) { type = DTM . NAMESPACE_NODE ; } } m_nodes . addElement ( node ) ; m_firstch . setElementAt ( NOTPROCESSED , nodeIndex ) ; m_nextsib . setElementAt ( NOTPROCESSED , nodeIndex ) ; m_prevsib . setElementAt ( previousSibling , nodeIndex ) ; m_parent . setElementAt ( parentIndex , nodeIndex ) ; if ( DTM . NULL != parentIndex && type != DTM . ATTRIBUTE_NODE && type != DTM . NAMESPACE_NODE ) { if ( NOTPROCESSED == m_firstch . elementAt ( parentIndex ) ) m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } String nsURI = node . getNamespaceURI ( ) ; String localName = ( type == Node . PROCESSING_INSTRUCTION_NODE ) ? node . getNodeName ( ) : node . getLocalName ( ) ; if ( ( ( type == Node . ELEMENT_NODE ) || ( type == Node . ATTRIBUTE_NODE ) ) && null == localName ) localName = node . getNodeName ( ) ; ExpandedNameTable exnt = m_expandedNameTable ; if ( node . getLocalName ( ) == null && ( type == Node . ELEMENT_NODE || type == Node . ATTRIBUTE_NODE ) ) { } int expandedNameID = ( null != localName ) ? exnt . getExpandedTypeID ( nsURI , localName , type ) : exnt . getExpandedTypeID ( type ) ; m_exptype . setElementAt ( expandedNameID , nodeIndex ) ; indexNode ( expandedNameID , nodeIndex ) ; if ( DTM . NULL != previousSibling ) m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; if ( type == DTM . NAMESPACE_NODE ) declareNamespaceInContext ( parentIndex , nodeIndex ) ; return nodeIndex ; } public int getNumberOfNodes ( ) { return m_nodes . size ( ) ; } protected boolean nextNode ( ) { if ( m_nodesAreProcessed ) return false ; Node pos = m_pos ; Node next = null ; int nexttype = NULL ; do { if ( pos . hasChildNodes ( ) ) { next = pos . getFirstChild ( ) ; if ( next != null && DOCUMENT_TYPE_NODE == next . getNodeType ( ) ) next = next . getNextSibling ( ) ; if ( ENTITY_REFERENCE_NODE != pos . getNodeType ( ) ) { m_last_parent = m_last_kid ; m_last_kid = NULL ; if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( m_last_parent ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } } } else { if ( m_last_kid != NULL ) { if ( m_firstch . elementAt ( m_last_kid ) == NOTPROCESSED ) m_firstch . setElementAt ( NULL , m_last_kid ) ; } while ( m_last_parent != NULL ) { next = pos . getNextSibling ( ) ; if ( next != null && DOCUMENT_TYPE_NODE == next . getNodeType ( ) ) next = next . getNextSibling ( ) ; if ( next != null ) break ; pos = pos . getParentNode ( ) ; if ( pos == null ) { if ( JJK_DEBUG ) { System . out . println ( "***** DOM2DTM Pop Control Flow problem" ) ; for ( ; ; ) ; } } if ( pos != null && ENTITY_REFERENCE_NODE == pos . getNodeType ( ) ) { if ( JJK_DEBUG ) System . out . println ( "***** DOM2DTM popping EntRef" ) ; } else { popShouldStripWhitespace ( ) ; if ( m_last_kid == NULL ) m_firstch . setElementAt ( NULL , m_last_parent ) ; else m_nextsib . setElementAt ( NULL , m_last_kid ) ; m_last_parent = m_parent . elementAt ( m_last_kid = m_last_parent ) ; } } if ( m_last_parent == NULL ) next = null ; } if ( next != null ) nexttype = next . getNodeType ( ) ; if ( ENTITY_REFERENCE_NODE == nexttype ) pos = next ; } while ( ENTITY_REFERENCE_NODE == nexttype ) ; if ( next == null ) { m_nextsib . setElementAt ( NULL , 0 ) ; m_nodesAreProcessed = true ; m_pos = null ; if ( JJK_DEBUG ) { System . out . println ( "***** DOM2DTM Crosscheck:" ) ; for ( int i = 0 ; i < m_nodes . size ( ) ; ++ i ) System . out . println ( i + ":\t" + m_firstch . elementAt ( i ) + "\t" + m_nextsib . elementAt ( i ) ) ; } return false ; } boolean suppressNode = false ; Node lastTextNode = null ; nexttype = next . getNodeType ( ) ; if ( TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype ) { suppressNode = ( ( null != m_wsfilter ) && getShouldStripWhitespace ( ) ) ; Node n = next ; while ( n != null ) { lastTextNode = n ; if ( TEXT_NODE == n . getNodeType ( ) ) nexttype = TEXT_NODE ; suppressNode &= XMLCharacterRecognizer . isWhiteSpace ( n . getNodeValue ( ) ) ; n = logicalNextDOMTextNode ( n ) ; } } else if ( PROCESSING_INSTRUCTION_NODE == nexttype ) { suppressNode = ( pos . getNodeName ( ) . toLowerCase ( ) . equals ( "xml" ) ) ; } if ( ! suppressNode ) { int nextindex = addNode ( next , m_last_parent , m_last_kid , nexttype ) ; m_last_kid = nextindex ; if ( ELEMENT_NODE == nexttype ) { int attrIndex = NULL ; NamedNodeMap attrs = next . getAttributes ( ) ; int attrsize = ( attrs == null ) ? 0 : attrs . getLength ( ) ; if ( attrsize > 0 ) { for ( int i = 0 ; i < attrsize ; ++ i ) { attrIndex = addNode ( attrs . item ( i ) , nextindex , attrIndex , NULL ) ; m_firstch . setElementAt ( DTM . NULL , attrIndex ) ; if ( ! m_processedFirstElement && "xmlns:xml" . equals ( attrs . item ( i ) . getNodeName ( ) ) ) m_processedFirstElement = true ; } } if ( ! m_processedFirstElement ) { attrIndex = addNode ( new DOM2DTMdefaultNamespaceDeclarationNode ( ( Element ) next , "xml" , NAMESPACE_DECL_NS , makeNodeHandle ( ( ( attrIndex == NULL ) ? nextindex : attrIndex ) + 1 ) ) , nextindex , attrIndex , NULL ) ; m_firstch . setElementAt ( DTM . NULL , attrIndex ) ; m_processedFirstElement = true ; } if ( attrIndex != NULL ) m_nextsib . setElementAt ( DTM . NULL , attrIndex ) ; } } if ( TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype ) { next = lastTextNode ; } m_pos = next ; return true ; } public Node getNode ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; return ( Node ) m_nodes . elementAt ( identity ) ; } protected Node lookupNode ( int nodeIdentity ) { return ( Node ) m_nodes . elementAt ( nodeIdentity ) ; } protected int getNextNodeIdentity ( int identity ) { identity += 1 ; if ( identity >= m_nodes . size ( ) ) { if ( ! nextNode ( ) ) identity = DTM . NULL ; } return identity ; } private int getHandleFromNode ( Node node ) { if ( null != node ) { int len = m_nodes . size ( ) ; boolean isMore ; int i = 0 ; do { for ( ; i < len ; i ++ ) { if ( m_nodes . elementAt ( i ) == node ) return makeNodeHandle ( i ) ; } isMore = nextNode ( ) ; len = m_nodes . size ( ) ; } while ( isMore || i < len ) ; } return DTM . NULL ; } public int getHandleOfNode ( Node node ) { if ( null != node ) { if ( ( m_root == node ) || ( m_root . getNodeType ( ) == DOCUMENT_NODE && m_root == node . getOwnerDocument ( ) ) || ( m_root . getNodeType ( ) != DOCUMENT_NODE && m_root . getOwnerDocument ( ) == node . getOwnerDocument ( ) ) ) { for ( Node cursor = node ; cursor != null ; cursor = ( cursor . getNodeType ( ) != ATTRIBUTE_NODE ) ? cursor . getParentNode ( ) : ( ( org . w3c . dom . Attr ) cursor ) . getOwnerElement ( ) ) { if ( cursor == m_root ) return getHandleFromNode ( node ) ; } } } return DTM . NULL ; } public int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) { if ( null == namespaceURI ) namespaceURI = "" ; int type = getNodeType ( nodeHandle ) ; if ( DTM . ELEMENT_NODE == type ) { int identity = makeNodeIdentity ( nodeHandle ) ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { type = _type ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE || type == DTM . NAMESPACE_NODE ) { Node node = lookupNode ( identity ) ; String nodeuri = node . getNamespaceURI ( ) ; if ( null == nodeuri ) nodeuri = "" ; String nodelocalname = node . getLocalName ( ) ; if ( nodeuri . equals ( namespaceURI ) && name . equals ( nodelocalname ) ) return makeNodeHandle ( identity ) ; } else { break ; } } } return DTM . NULL ; } public XMLString getStringValue ( int nodeHandle ) { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { getNodeData ( node , buf ) ; s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; } finally { StringBufferPool . free ( buf ) ; } return m_xstrf . newstr ( s ) ; } else if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; while ( node != null ) { buf . append ( node . getNodeValue ( ) ) ; node = logicalNextDOMTextNode ( node ) ; } String s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; StringBufferPool . free ( buf ) ; return m_xstrf . newstr ( s ) ; } else return m_xstrf . newstr ( node . getNodeValue ( ) ) ; } public boolean isWhitespace ( int nodeHandle ) { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; while ( node != null ) { buf . append ( node . getNodeValue ( ) ) ; node = logicalNextDOMTextNode ( node ) ; } boolean b = buf . isWhitespace ( 0 , buf . length ( ) ) ; StringBufferPool . free ( buf ) ; return b ; } return false ; } protected static void getNodeData ( Node node , FastStringBuffer buf ) { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { getNodeData ( child , buf ) ; } } break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : buf . append ( node . getNodeValue ( ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : break ; default : break ; } } public String getNodeName ( int nodeHandle ) { Node node = getNode ( nodeHandle ) ; return node . getNodeName ( ) ; } public String getNodeNameX ( int nodeHandle ) { String name ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . NAMESPACE_NODE : { Node node = getNode ( nodeHandle ) ; name = node . getNodeName ( ) ; if ( name . startsWith ( "xmlns:" ) ) { name = QName . getLocalPart ( name ) ; } else if ( name . equals ( "xmlns" ) ) { name = "" ; } } break ; case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : case DTM . ENTITY_REFERENCE_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : { Node node = getNode ( nodeHandle ) ; name = node . getNodeName ( ) ; } break ; default : name = "" ; } return name ; } public String getLocalName ( int nodeHandle ) { if ( JJK_NEWCODE ) { int id = makeNodeIdentity ( nodeHandle ) ; if ( NULL == id ) return null ; Node newnode = ( Node ) m_nodes . elementAt ( id ) ; String newname = newnode . getLocalName ( ) ; if ( null == newname ) { String qname = newnode . getNodeName ( ) ; if ( '#' == qname . charAt ( 0 ) ) { newname = "" ; } else { int index = qname . indexOf ( ':' ) ; newname = ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } } return newname ; } else { String name ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : case DTM . ENTITY_REFERENCE_NODE : case DTM . NAMESPACE_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : { Node node = getNode ( nodeHandle ) ; name = node . getLocalName ( ) ; if ( null == name ) { String qname = node . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; name = ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } } break ; default : name = "" ; } return name ; } } public String getPrefix ( int nodeHandle ) { String prefix ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . NAMESPACE_NODE : { Node node = getNode ( nodeHandle ) ; String qname = node . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; prefix = ( index < 0 ) ? "" : qname . substring ( index + 1 ) ; } break ; case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : { Node node = getNode ( nodeHandle ) ; String qname = node . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; prefix = ( index < 0 ) ? "" : qname . substring ( 0 , index ) ; } break ; default : prefix = "" ; } return prefix ; } public String getNamespaceURI ( int nodeHandle ) { if ( JJK_NEWCODE ) { int id = makeNodeIdentity ( nodeHandle ) ; if ( id == NULL ) return null ; Node node = ( Node ) m_nodes . elementAt ( id ) ; return node . getNamespaceURI ( ) ; } else { String nsuri ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : case DTM . ENTITY_REFERENCE_NODE : case DTM . NAMESPACE_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : { Node node = getNode ( nodeHandle ) ; nsuri = node . getNamespaceURI ( ) ; } break ; default : nsuri = null ; } return nsuri ; } } private Node logicalNextDOMTextNode ( Node n ) { Node p = n . getNextSibling ( ) ; if ( p == null ) { for ( n = n . getParentNode ( ) ; n != null && ENTITY_REFERENCE_NODE == n . getNodeType ( ) ; n = n . getParentNode ( ) ) { p = n . getNextSibling ( ) ; if ( p != null ) break ; } } n = p ; while ( n != null && ENTITY_REFERENCE_NODE == n . getNodeType ( ) ) { if ( n . hasChildNodes ( ) ) n = n . getFirstChild ( ) ; else n = n . getNextSibling ( ) ; } if ( n != null ) { int ntype = n . getNodeType ( ) ; if ( TEXT_NODE != ntype && CDATA_SECTION_NODE != ntype ) n = null ; } return n ; } public String getNodeValue ( int nodeHandle ) { int type = _exptype ( makeNodeIdentity ( nodeHandle ) ) ; type = ( NULL != type ) ? getNodeType ( nodeHandle ) : NULL ; if ( TEXT_NODE != type && CDATA_SECTION_NODE != type ) return getNode ( nodeHandle ) . getNodeValue ( ) ; Node node = getNode ( nodeHandle ) ; Node n = logicalNextDOMTextNode ( node ) ; if ( n == null ) return node . getNodeValue ( ) ; FastStringBuffer buf = StringBufferPool . get ( ) ; buf . append ( node . getNodeValue ( ) ) ; while ( n != null ) { buf . append ( n . getNodeValue ( ) ) ; n = logicalNextDOMTextNode ( n ) ; } String s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; StringBufferPool . free ( buf ) ; return s ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { Document doc ; if ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) doc = ( Document ) m_root ; else doc = m_root . getOwnerDocument ( ) ; if ( null != doc ) { DocumentType dtd = doc . getDoctype ( ) ; if ( null != dtd ) { return dtd . getSystemId ( ) ; } } return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { Document doc ; if ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) doc = ( Document ) m_root ; else doc = m_root . getOwnerDocument ( ) ; if ( null != doc ) { DocumentType dtd = doc . getDoctype ( ) ; if ( null != dtd ) { return dtd . getPublicId ( ) ; } } return null ; } public int getElementById ( String elementId ) { Document doc = ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( Document ) m_root : m_root . getOwnerDocument ( ) ; if ( null != doc ) { Node elem = doc . getElementById ( elementId ) ; if ( null != elem ) { int elemHandle = getHandleFromNode ( elem ) ; if ( DTM . NULL == elemHandle ) { int identity = m_nodes . size ( ) - 1 ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { Node node = getNode ( identity ) ; if ( node == elem ) { elemHandle = getHandleFromNode ( elem ) ; break ; } } } return elemHandle ; } } return DTM . NULL ; } public String getUnparsedEntityURI ( String name ) { String url = "" ; Document doc = ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( Document ) m_root : m_root . getOwnerDocument ( ) ; if ( null != doc ) { DocumentType doctype = doc . getDoctype ( ) ; if ( null != doctype ) { NamedNodeMap entities = doctype . getEntities ( ) ; if ( null == entities ) return url ; Entity entity = ( Entity ) entities . getNamedItem ( name ) ; if ( null == entity ) return url ; String notationName = entity . getNotationName ( ) ; if ( null != notationName ) { url = entity . getSystemId ( ) ; if ( null == url ) { url = entity . getPublicId ( ) ; } else { } } } } return url ; } public boolean isAttributeSpecified ( int attributeHandle ) { int type = getNodeType ( attributeHandle ) ; if ( DTM . ATTRIBUTE_NODE == type ) { Attr attr = ( Attr ) getNode ( attributeHandle ) ; return attr . getSpecified ( ) ; } return false ; } public void setIncrementalSAXSource ( IncrementalSAXSource source ) { } public org . xml . sax . ContentHandler getContentHandler ( ) { return null ; } public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) { return null ; } public org . xml . sax . EntityResolver getEntityResolver ( ) { return null ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return null ; } public org . xml . sax . ErrorHandler getErrorHandler ( ) { return null ; } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { return null ; } public boolean needsTwoThreads ( ) { return false ; } private static boolean isSpace ( char ch ) { return XMLCharacterRecognizer . isWhiteSpace ( ch ) ; } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { if ( normalize ) { XMLString str = getStringValue ( nodeHandle ) ; str = str . fixWhiteSpace ( true , true , false ) ; str . dispatchCharactersEvents ( ch ) ; } else { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; dispatchNodeData ( node , ch , 0 ) ; if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { while ( null != ( node = logicalNextDOMTextNode ( node ) ) ) { dispatchNodeData ( node , ch , 0 ) ; } } } } protected static void dispatchNodeData ( Node node , org . xml . sax . ContentHandler ch , int depth ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { dispatchNodeData ( child , ch , depth + 1 ) ; } } break ; case Node . PROCESSING_INSTRUCTION_NODE : case Node . COMMENT_NODE : if ( 0 != depth ) break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : String str = node . getNodeValue ( ) ; if ( ch instanceof CharacterNodeHandler ) { ( ( CharacterNodeHandler ) ch ) . characters ( node ) ; } else { ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } break ; default : break ; } } TreeWalker m_walker = new TreeWalker ( null ) ; public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { TreeWalker treeWalker = m_walker ; ContentHandler prevCH = treeWalker . getContentHandler ( ) ; if ( null != prevCH ) { treeWalker = new TreeWalker ( null ) ; } treeWalker . setContentHandler ( ch ) ; try { Node node = getNode ( nodeHandle ) ; treeWalker . traverse ( node ) ; } finally { treeWalker . setContentHandler ( null ) ; } } public interface CharacterNodeHandler { public void characters ( Node node ) throws org . xml . sax . SAXException ; } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } } 	0	['39', '4', '0', '18', '119', '617', '1', '18', '30', '0.870813397', '1667', '0.545454545', '1', '0.712121212', '0.142857143', '2', '17', '41.46153846', '42', '4.6154', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . IF_ICMPNE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . NumberType ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . Operators ; final class EqualityExpr extends Expression implements Operators { private final int _op ; private Expression _left ; private Expression _right ; public EqualityExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public String toString ( ) { return Operators . names [ _op ] + '(' + _left + ", " + _right + ')' ; } public Expression getLeft ( ) { return _left ; } public Expression getRight ( ) { return _right ; } public boolean getOp ( ) { return ( _op != Operators . NE ) ; } public boolean hasPositionCall ( ) { if ( _left . hasPositionCall ( ) ) return true ; if ( _right . hasPositionCall ( ) ) return true ; return false ; } public boolean hasLastCall ( ) { if ( _left . hasLastCall ( ) ) return true ; if ( _right . hasLastCall ( ) ) return true ; return false ; } private void swapArguments ( ) { final Expression temp = _left ; _left = _right ; _right = temp ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tleft = _left . typeCheck ( stable ) ; final Type tright = _right . typeCheck ( stable ) ; if ( tleft . isSimple ( ) && tright . isSimple ( ) ) { if ( tleft != tright ) { if ( tleft instanceof BooleanType ) { _right = new CastExpr ( _right , Type . Boolean ) ; } else if ( tright instanceof BooleanType ) { _left = new CastExpr ( _left , Type . Boolean ) ; } else if ( tleft instanceof NumberType || tright instanceof NumberType ) { _left = new CastExpr ( _left , Type . Real ) ; _right = new CastExpr ( _right , Type . Real ) ; } else { _left = new CastExpr ( _left , Type . String ) ; _right = new CastExpr ( _right , Type . String ) ; } } } else if ( tleft instanceof ReferenceType ) { _right = new CastExpr ( _right , Type . Reference ) ; } else if ( tright instanceof ReferenceType ) { _left = new CastExpr ( _left , Type . Reference ) ; } else if ( tleft instanceof NodeType && tright == Type . String ) { _left = new CastExpr ( _left , Type . String ) ; } else if ( tleft == Type . String && tright instanceof NodeType ) { _right = new CastExpr ( _right , Type . String ) ; } else if ( tleft instanceof NodeType && tright instanceof NodeType ) { _left = new CastExpr ( _left , Type . String ) ; _right = new CastExpr ( _right , Type . String ) ; } else if ( tleft instanceof NodeType && tright instanceof NodeSetType ) { } else if ( tleft instanceof NodeSetType && tright instanceof NodeType ) { swapArguments ( ) ; } else { if ( tleft instanceof NodeType ) { _left = new CastExpr ( _left , Type . NodeSet ) ; } if ( tright instanceof NodeType ) { _right = new CastExpr ( _right , Type . NodeSet ) ; } if ( tleft . isSimple ( ) || tleft instanceof ResultTreeType && tright instanceof NodeSetType ) { swapArguments ( ) ; } if ( _right . getType ( ) instanceof IntType ) { _right = new CastExpr ( _right , Type . Real ) ; } } return _type = Type . Boolean ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final Type tleft = _left . getType ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( tleft instanceof BooleanType ) { _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; _falseList . add ( il . append ( _op == Operators . EQ ? ( BranchInstruction ) new IF_ICMPNE ( null ) : ( BranchInstruction ) new IF_ICMPEQ ( null ) ) ) ; } else if ( tleft instanceof NumberType ) { _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; if ( tleft instanceof RealType ) { il . append ( DCMPG ) ; _falseList . add ( il . append ( _op == Operators . EQ ? ( BranchInstruction ) new IFNE ( null ) : ( BranchInstruction ) new IFEQ ( null ) ) ) ; } else { _falseList . add ( il . append ( _op == Operators . EQ ? ( BranchInstruction ) new IF_ICMPNE ( null ) : ( BranchInstruction ) new IF_ICMPEQ ( null ) ) ) ; } } else { translate ( classGen , methodGen ) ; desynthesize ( classGen , methodGen ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final Type tleft = _left . getType ( ) ; Type tright = _right . getType ( ) ; if ( tleft instanceof BooleanType || tleft instanceof NumberType ) { translateDesynthesized ( classGen , methodGen ) ; synthesize ( classGen , methodGen ) ; return ; } if ( tleft instanceof StringType ) { final int equals = cpg . addMethodref ( STRING_CLASS , "equals" , "(" + OBJECT_SIG + ")Z" ) ; _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( equals ) ) ; if ( _op == Operators . NE ) { il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } return ; } BranchHandle truec , falsec ; if ( tleft instanceof ResultTreeType ) { if ( tright instanceof BooleanType ) { _right . translate ( classGen , methodGen ) ; if ( _op == Operators . NE ) { il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } return ; } if ( tright instanceof RealType ) { _left . translate ( classGen , methodGen ) ; tleft . translateTo ( classGen , methodGen , Type . Real ) ; _right . translate ( classGen , methodGen ) ; il . append ( DCMPG ) ; falsec = il . append ( _op == Operators . EQ ? ( BranchInstruction ) new IFNE ( null ) : ( BranchInstruction ) new IFEQ ( null ) ) ; il . append ( ICONST_1 ) ; truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; return ; } _left . translate ( classGen , methodGen ) ; tleft . translateTo ( classGen , methodGen , Type . String ) ; _right . translate ( classGen , methodGen ) ; if ( tright instanceof ResultTreeType ) { tright . translateTo ( classGen , methodGen , Type . String ) ; } final int equals = cpg . addMethodref ( STRING_CLASS , "equals" , "(" + OBJECT_SIG + ")Z" ) ; il . append ( new INVOKEVIRTUAL ( equals ) ) ; if ( _op == Operators . NE ) { il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } return ; } if ( tleft instanceof NodeSetType && tright instanceof BooleanType ) { _left . translate ( classGen , methodGen ) ; _left . startResetIterator ( classGen , methodGen ) ; Type . NodeSet . translateTo ( classGen , methodGen , Type . Boolean ) ; _right . translate ( classGen , methodGen ) ; il . append ( IXOR ) ; if ( _op == EQ ) { il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } return ; } if ( tleft instanceof NodeSetType && tright instanceof StringType ) { _left . translate ( classGen , methodGen ) ; _left . startResetIterator ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , _op ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int cmp = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "compare" , "(" + tleft . toSignature ( ) + tright . toSignature ( ) + "I" + DOM_INTF_SIG + ")Z" ) ; il . append ( new INVOKESTATIC ( cmp ) ) ; return ; } _left . translate ( classGen , methodGen ) ; _left . startResetIterator ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; _right . startResetIterator ( classGen , methodGen ) ; if ( tright instanceof ResultTreeType ) { tright . translateTo ( classGen , methodGen , Type . String ) ; tright = Type . String ; } il . append ( new PUSH ( cpg , _op ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int compare = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "compare" , "(" + tleft . toSignature ( ) + tright . toSignature ( ) + "I" + DOM_INTF_SIG + ")Z" ) ; il . append ( new INVOKESTATIC ( compare ) ) ; } } 	0	['12', '3', '0', '37', '49', '0', '1', '36', '11', '0.333333333', '836', '1', '2', '0.865853659', '0.238095238', '2', '8', '68.41666667', '18', '3.25', '0']
package org . apache . xalan . xsltc . runtime ; import org . apache . xml . dtm . DTM ; public interface Constants { final static int ANY = - 1 ; final static int ATTRIBUTE = - 2 ; final static int ROOT = DTM . ROOT_NODE ; final static int TEXT = DTM . TEXT_NODE ; final static int ELEMENT = DTM . ELEMENT_NODE ; final static int COMMENT = DTM . COMMENT_NODE ; final static int PROCESSING_INSTRUCTION = DTM . PROCESSING_INSTRUCTION_NODE ; public static String XSLT_URI = "http://www.w3.org/1999/XSL/Transform" ; public static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static final String EMPTYSTRING = "" ; public static final String XML_PREFIX = "xml" ; public static final String XMLNS_PREFIX = "xmlns" ; public static final String XMLNS_STRING = "xmlns:" ; public static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/" ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '14', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ParentPattern extends RelativePathPattern { private final Pattern _left ; private final RelativePathPattern _right ; public ParentPattern ( Pattern left , RelativePathPattern right ) { ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public boolean isWildcard ( ) { return false ; } public StepPattern getKernelPattern ( ) { return _right . getKernelPattern ( ) ; } public void reduceKernelPattern ( ) { _right . reduceKernelPattern ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _left . typeCheck ( stable ) ; return _right . typeCheck ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final LocalVariableGen local = methodGen . addLocalVariable2 ( "ppt" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) ) ; final org . apache . bcel . generic . Instruction loadLocal = new ILOAD ( local . getIndex ( ) ) ; final org . apache . bcel . generic . Instruction storeLocal = new ISTORE ( local . getIndex ( ) ) ; if ( _right . isWildcard ( ) ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; } else if ( _right instanceof StepPattern ) { il . append ( DUP ) ; il . append ( storeLocal ) ; _right . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; local . setEnd ( il . append ( loadLocal ) ) ; } else { _right . translate ( classGen , methodGen ) ; if ( _right instanceof AncestorPattern ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; } } final int getParent = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; il . append ( new INVOKEINTERFACE ( getParent , 2 ) ) ; final SyntaxTreeNode p = getParent ( ) ; if ( p == null || p instanceof Instruction || p instanceof TopLevelElement ) { _left . translate ( classGen , methodGen ) ; } else { il . append ( DUP ) ; il . append ( storeLocal ) ; _left . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; local . setEnd ( il . append ( loadLocal ) ) ; } methodGen . removeLocalVariable ( local ) ; if ( _right instanceof AncestorPattern ) { final AncestorPattern ancestor = ( AncestorPattern ) _right ; _left . backPatchFalseList ( ancestor . getLoopHandle ( ) ) ; } _trueList . append ( _right . _trueList . append ( _left . _trueList ) ) ; _falseList . append ( _right . _falseList . append ( _left . _falseList ) ) ; } public String toString ( ) { return "Parent(" + _left + ", " + _right + ')' ; } } 	0	['8', '6', '0', '26', '43', '0', '1', '25', '8', '0.285714286', '253', '1', '2', '0.933962264', '0.25', '4', '5', '30.375', '8', '1.75', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNONNULL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public class StringType extends Type { protected StringType ( ) { } public String toString ( ) { return "string" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "Ljava/lang/String;" ; } public boolean isSimple ( ) { return true ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . STRING ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , STRING_TO_REAL , STRING_TO_REAL_SIG ) ) ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_CLASS , "length" , "()I" ) ) ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz . isAssignableFrom ( java . lang . String . class ) ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz . getName ( ) . equals ( "java.lang.String" ) ) { il . append ( DUP ) ; final BranchHandle ifNonNull = il . append ( new IFNONNULL ( null ) ) ; il . append ( POP ) ; il . append ( new PUSH ( cpg , "" ) ) ; ifNonNull . setTarget ( il . append ( NOP ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public String getClassName ( ) { return ( STRING_CLASS ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['19', '2', '0', '41', '47', '151', '18', '27', '17', '1', '286', '0', '0', '0.647058824', '0.247368421', '2', '4', '14', '4', '1.3158', '0']
package org . apache . xalan . xsltc . runtime ; public class MessageHandler { public void displayMessage ( String msg ) { System . err . println ( msg ) ; } } 	0	['2', '1', '1', '3', '4', '1', '3', '0', '2', '2', '9', '0', '0', '0', '0.75', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xml . dtm . DTM ; public final class ReferenceType extends Type { protected ReferenceType ( ) { } public String toString ( ) { return "reference" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "Ljava/lang/Object;" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . OBJECT ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . NodeSet ) { translateTo ( classGen , methodGen , ( NodeSetType ) type ) ; } else if ( type == Type . Node ) { translateTo ( classGen , methodGen , ( NodeType ) type ) ; } else if ( type == Type . ResultTree ) { translateTo ( classGen , methodGen , ( ResultTreeType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final int current = methodGen . getLocalIndex ( "current" ) ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; if ( current < 0 ) { il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; } else { il . append ( new ILOAD ( current ) ) ; } il . append ( methodGen . loadDOM ( ) ) ; final int stringF = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "stringF" , "(" + OBJECT_SIG + NODE_SIG + DOM_INTF_SIG + ")" + STRING_SIG ) ; il . append ( new INVOKESTATIC ( stringF ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "numberF" , "(" + OBJECT_SIG + DOM_INTF_SIG + ")D" ) ; il . append ( new INVOKESTATIC ( index ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "booleanF" , "(" + OBJECT_SIG + ")Z" ) ; il . append ( new INVOKESTATIC ( index ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeSetType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNodeSet" , "(" + OBJECT_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( index ) ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , RESET , RESET_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeType type ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; Type . NodeSet . translateTo ( classGen , methodGen , type ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ResultTreeType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToResultTree" , "(" + OBJECT_SIG + ")" + DOM_INTF_SIG ) ; il . append ( new INVOKESTATIC ( index ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz . getName ( ) . equals ( "java.lang.Object" ) ) { il . append ( NOP ) ; } else if ( clazz == Double . TYPE ) { translateTo ( classGen , methodGen , Type . Real ) ; } else if ( clazz . getName ( ) . equals ( "java.lang.String" ) ) { translateTo ( classGen , methodGen , Type . String ) ; } else if ( clazz . getName ( ) . equals ( "org.w3c.dom.Node" ) ) { int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNode" , "(" + OBJECT_SIG + DOM_INTF_SIG + ")" + "Lorg/w3c/dom/Node;" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( clazz . getName ( ) . equals ( "org.w3c.dom.NodeList" ) ) { int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNodeList" , "(" + OBJECT_SIG + DOM_INTF_SIG + ")" + "Lorg/w3c/dom/NodeList;" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( clazz . getName ( ) . equals ( "org.apache.xalan.xsltc.DOM" ) ) { translateTo ( classGen , methodGen , Type . ResultTree ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz . getName ( ) . equals ( "java.lang.Object" ) ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { InstructionList il = methodGen . getInstructionList ( ) ; translateTo ( classGen , methodGen , type ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['20', '2', '0', '41', '46', '184', '19', '29', '19', '2', '448', '0', '0', '0.634615385', '0.230769231', '2', '4', '21.4', '8', '1.75', '0']
package org . apache . xalan . xsltc . cmdline ; import java . io . FileNotFoundException ; import java . net . MalformedURLException ; import java . net . UnknownHostException ; import java . util . Vector ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . sax . SAXSource ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . Constants ; import org . apache . xalan . xsltc . runtime . Parameter ; import org . apache . xalan . xsltc . runtime . TransletLoader ; import org . apache . xalan . xsltc . runtime . output . TransletOutputHandlerFactory ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; final public class Transform { private SerializationHandler _handler ; private String _fileName ; private String _className ; private String _jarFileSrc ; private boolean _isJarFileSpecified = false ; private Vector _params = null ; private boolean _uri , _debug ; private int _iterations ; private static boolean _allowExit = true ; public Transform ( String className , String fileName , boolean uri , boolean debug , int iterations ) { _fileName = fileName ; _className = className ; _uri = uri ; _debug = debug ; _iterations = iterations ; } public String getFileName ( ) { return _fileName ; } public String getClassName ( ) { return _className ; } public void setParameters ( Vector params ) { _params = params ; } private void setJarFileInputSrc ( boolean flag , String jarFile ) { _isJarFileSpecified = flag ; _jarFileSrc = jarFile ; } private Class loadTranslet ( String name ) throws ClassNotFoundException { try { return Class . forName ( name ) ; } catch ( ClassNotFoundException e ) { } TransletLoader loader = new TransletLoader ( ) ; return loader . loadTranslet ( name ) ; } private void doTransform ( ) { try { final Class clazz = loadTranslet ( _className ) ; final AbstractTranslet translet = ( AbstractTranslet ) clazz . newInstance ( ) ; final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { factory . setFeature ( Constants . NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { factory . setNamespaceAware ( true ) ; } final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; final SAXImpl dom = ( SAXImpl ) dtmManager . getDTM ( new SAXSource ( reader , new InputSource ( _fileName ) ) , false , null , true , false , translet . hasIdCall ( ) ) ; dom . setDocumentURI ( _fileName ) ; translet . prepassDocument ( dom ) ; int n = _params . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Parameter param = ( Parameter ) _params . elementAt ( i ) ; translet . addParameter ( param . _name , param . _value ) ; } TransletOutputHandlerFactory tohFactory = TransletOutputHandlerFactory . newInstance ( ) ; tohFactory . setOutputType ( TransletOutputHandlerFactory . STREAM ) ; tohFactory . setEncoding ( translet . _encoding ) ; tohFactory . setOutputMethod ( translet . _method ) ; if ( _iterations == - 1 ) { translet . transform ( dom , tohFactory . getSerializationHandler ( ) ) ; } else if ( _iterations > 0 ) { long mm = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < _iterations ; i ++ ) { translet . transform ( dom , tohFactory . getSerializationHandler ( ) ) ; } mm = System . currentTimeMillis ( ) - mm ; System . err . println ( "\n<!--" ) ; System . err . println ( "  transform  = " + ( ( ( double ) mm ) / ( ( double ) _iterations ) ) + " ms" ) ; System . err . println ( "  throughput = " + ( 1000.0 / ( ( ( double ) mm ) / ( ( double ) _iterations ) ) ) + " tps" ) ; System . err . println ( "-->" ) ; } } catch ( TransletException e ) { if ( _debug ) e . printStackTrace ( ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + e . getMessage ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( RuntimeException e ) { if ( _debug ) e . printStackTrace ( ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + e . getMessage ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( FileNotFoundException e ) { if ( _debug ) e . printStackTrace ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . FILE_NOT_FOUND_ERR , _fileName ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + err . toString ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( MalformedURLException e ) { if ( _debug ) e . printStackTrace ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_URI_ERR , _fileName ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + err . toString ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( ClassNotFoundException e ) { if ( _debug ) e . printStackTrace ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + err . toString ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( UnknownHostException e ) { if ( _debug ) e . printStackTrace ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_URI_ERR , _fileName ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + err . toString ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( SAXException e ) { Exception ex = e . getException ( ) ; if ( _debug ) { if ( ex != null ) ex . printStackTrace ( ) ; e . printStackTrace ( ) ; } System . err . print ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) ) ; if ( ex != null ) System . err . println ( ex . getMessage ( ) ) ; else System . err . println ( e . getMessage ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( Exception e ) { if ( _debug ) e . printStackTrace ( ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + e . getMessage ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } } public static void printUsage ( ) { System . err . println ( new ErrorMsg ( ErrorMsg . TRANSFORM_USAGE_STR ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } public static void main ( String [ ] args ) { try { if ( args . length > 0 ) { int i ; int iterations = - 1 ; boolean uri = false , debug = false ; boolean isJarFileSpecified = false ; String jarFile = null ; for ( i = 0 ; i < args . length && args [ i ] . charAt ( 0 ) == '-' ; i ++ ) { if ( args [ i ] . equals ( "-u" ) ) { uri = true ; } else if ( args [ i ] . equals ( "-x" ) ) { debug = true ; } else if ( args [ i ] . equals ( "-s" ) ) { _allowExit = false ; } else if ( args [ i ] . equals ( "-j" ) ) { isJarFileSpecified = true ; jarFile = args [ ++ i ] ; } else if ( args [ i ] . equals ( "-n" ) ) { try { iterations = Integer . parseInt ( args [ ++ i ] ) ; } catch ( NumberFormatException e ) { } } else { printUsage ( ) ; } } if ( args . length - i < 2 ) printUsage ( ) ; Transform handler = new Transform ( args [ i + 1 ] , args [ i ] , uri , debug , iterations ) ; handler . setJarFileInputSrc ( isJarFileSpecified , jarFile ) ; Vector params = new Vector ( ) ; for ( i += 2 ; i < args . length ; i ++ ) { final int equal = args [ i ] . indexOf ( '=' ) ; if ( equal > 0 ) { final String name = args [ i ] . substring ( 0 , equal ) ; final String value = args [ i ] . substring ( equal + 1 ) ; params . addElement ( new Parameter ( name , value ) ) ; } else { printUsage ( ) ; } } if ( i == args . length ) { handler . setParameters ( params ) ; handler . doTransform ( ) ; if ( _allowExit ) System . exit ( 0 ) ; } } else { printUsage ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } 	0	['10', '1', '0', '12', '71', '17', '0', '12', '6', '0.788888889', '665', '1', '1', '0', '0.277777778', '0', '0', '64.5', '15', '3.4', '0']
package org . apache . xalan . templates ; import java . util . Vector ; import org . apache . xml . utils . QName ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . operations . Variable ; public class VarNameCollector extends XPathVisitor { Vector m_refs = new Vector ( ) ; public void reset ( ) { m_refs . removeAllElements ( ) ; } public int getVarCount ( ) { return m_refs . size ( ) ; } boolean doesOccur ( QName refName ) { return m_refs . contains ( refName ) ; } public boolean visitVariableRef ( ExpressionOwner owner , Variable var ) { m_refs . addElement ( var . getQName ( ) ) ; return true ; } } 	0	['5', '2', '0', '5', '12', '0', '1', '4', '4', '0', '34', '0', '0', '0.75', '0.4', '0', '0', '5.6', '1', '0.8', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class StartsWithCall extends FunctionCall { private Expression _base = null ; private Expression _token = null ; public StartsWithCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argumentCount ( ) != 2 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , getName ( ) , this ) ; throw new TypeCheckError ( err ) ; } _base = argument ( 0 ) ; Type baseType = _base . typeCheck ( stable ) ; if ( baseType != Type . String ) _base = new CastExpr ( _base , Type . String ) ; _token = argument ( 1 ) ; Type tokenType = _token . typeCheck ( stable ) ; if ( tokenType != Type . String ) _token = new CastExpr ( _token , Type . String ) ; return _type = Type . Boolean ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _base . translate ( classGen , methodGen ) ; _token . translate ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_CLASS , "startsWith" , "(" + STRING_SIG + ")Z" ) ) ) ; } } 	0	['3', '4', '0', '16', '17', '0', '0', '16', '3', '0', '108', '1', '2', '0.979591837', '0.444444444', '3', '13', '34.33333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; public final class CompilerException extends Exception { private String _msg ; public CompilerException ( ) { super ( ) ; } public CompilerException ( Exception e ) { super ( e . toString ( ) ) ; _msg = e . toString ( ) ; } public CompilerException ( String message ) { super ( message ) ; _msg = message ; } public String getMessage ( ) { final int col = _msg . indexOf ( ':' ) ; if ( col > - 1 ) return ( _msg . substring ( col ) ) ; else return ( _msg ) ; } } 	0	['4', '3', '0', '2', '9', '0', '2', '0', '4', '0.333333333', '40', '1', '0', '0.944444444', '0.5', '1', '1', '8.75', '2', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Choose extends Instruction { public void display ( int indent ) { indent ( indent ) ; Util . println ( "Choose" ) ; indent ( indent + IndentIncrement ) ; displayContents ( indent + IndentIncrement ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Vector whenElements = new Vector ( ) ; Otherwise otherwise = null ; Enumeration elements = elements ( ) ; ErrorMsg error = null ; final int line = getLineNumber ( ) ; while ( elements . hasMoreElements ( ) ) { Object element = elements . nextElement ( ) ; if ( element instanceof When ) { whenElements . addElement ( element ) ; } else if ( element instanceof Otherwise ) { if ( otherwise == null ) { otherwise = ( Otherwise ) element ; } else { error = new ErrorMsg ( ErrorMsg . MULTIPLE_OTHERWISE_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , error ) ; } } else if ( element instanceof Text ) { ( ( Text ) element ) . ignore ( ) ; } else { error = new ErrorMsg ( ErrorMsg . WHEN_ELEMENT_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , error ) ; } } if ( whenElements . size ( ) == 0 ) { error = new ErrorMsg ( ErrorMsg . MISSING_WHEN_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , error ) ; return ; } InstructionList il = methodGen . getInstructionList ( ) ; BranchHandle nextElement = null ; Vector exitHandles = new Vector ( ) ; InstructionHandle exit = null ; Enumeration whens = whenElements . elements ( ) ; while ( whens . hasMoreElements ( ) ) { final When when = ( When ) whens . nextElement ( ) ; final Expression test = when . getTest ( ) ; InstructionHandle truec = il . getEnd ( ) ; if ( nextElement != null ) nextElement . setTarget ( il . append ( NOP ) ) ; test . translateDesynthesized ( classGen , methodGen ) ; if ( test instanceof FunctionCall ) { FunctionCall call = ( FunctionCall ) test ; try { Type type = call . typeCheck ( getParser ( ) . getSymbolTable ( ) ) ; if ( type != Type . Boolean ) { test . _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; } } catch ( TypeCheckError e ) { } } truec = il . getEnd ( ) ; if ( ! when . ignore ( ) ) when . translateContents ( classGen , methodGen ) ; exitHandles . addElement ( il . append ( new GOTO ( null ) ) ) ; if ( whens . hasMoreElements ( ) || otherwise != null ) { nextElement = il . append ( new GOTO ( null ) ) ; test . backPatchFalseList ( nextElement ) ; } else test . backPatchFalseList ( exit = il . append ( NOP ) ) ; test . backPatchTrueList ( truec . getNext ( ) ) ; } if ( otherwise != null ) { nextElement . setTarget ( il . append ( NOP ) ) ; otherwise . translateContents ( classGen , methodGen ) ; exit = il . append ( NOP ) ; } Enumeration exitGotos = exitHandles . elements ( ) ; while ( exitGotos . hasMoreElements ( ) ) { BranchHandle gotoExit = ( BranchHandle ) exitGotos . nextElement ( ) ; gotoExit . setTarget ( exit ) ; } } } 	0	['3', '3', '0', '24', '37', '3', '2', '23', '2', '2', '245', '0', '0', '0.965517241', '0.5', '2', '4', '80.66666667', '15', '5.3333', '0']
package org . apache . xalan . transformer ; import javax . xml . transform . Transformer ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . serializer . TransformStateSetter ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public interface TransformState extends TransformStateSetter { ElemTemplateElement getCurrentElement ( ) ; Node getCurrentNode ( ) ; ElemTemplate getCurrentTemplate ( ) ; ElemTemplate getMatchedTemplate ( ) ; Node getMatchedNode ( ) ; NodeIterator getContextNodeList ( ) ; Transformer getTransformer ( ) ; } 	0	['7', '1', '0', '6', '7', '21', '3', '3', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class ProcessingInstructionPattern extends StepPattern { private String _name = null ; private boolean _typeChecked = false ; public ProcessingInstructionPattern ( String name ) { super ( Axis . CHILD , DTM . PROCESSING_INSTRUCTION_NODE , null ) ; _name = name ; } public double getDefaultPriority ( ) { return ( _name != null ) ? 0.0 : - 0.5 ; } public String toString ( ) { if ( _predicates == null ) return "processing-instruction(" + _name + ")" ; else return "processing-instruction(" + _name + ")" + _predicates ; } public void reduceKernelPattern ( ) { _typeChecked = true ; } public boolean isWildcard ( ) { return false ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( hasPredicates ( ) ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } } return Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int gname = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeName" , "(I)Ljava/lang/String;" ) ; int cmp = cpg . addMethodref ( STRING_CLASS , "equals" , "(Ljava/lang/Object;)Z" ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; if ( ! _typeChecked ) { il . append ( methodGen . loadCurrentNode ( ) ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; il . append ( new PUSH ( cpg , DTM . PROCESSING_INSTRUCTION_NODE ) ) ; _falseList . add ( il . append ( new IF_ICMPEQ ( null ) ) ) ; } il . append ( new PUSH ( cpg , _name ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( gname , 2 ) ) ; il . append ( new INVOKEVIRTUAL ( cmp ) ) ; _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; if ( hasPredicates ( ) ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; Expression exp = pred . getExpr ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; _trueList . append ( exp . _trueList ) ; _falseList . append ( exp . _falseList ) ; } } InstructionHandle restore ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchTrueList ( restore ) ; BranchHandle skipFalse = il . append ( new GOTO ( null ) ) ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchFalseList ( restore ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; skipFalse . setTarget ( il . append ( NOP ) ) ; } } 	0	['7', '7', '0', '23', '40', '1', '0', '23', '7', '0.583333333', '297', '1', '0', '0.951612903', '0.314285714', '5', '11', '41.14285714', '4', '1.5714', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class NotEquals extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return ( left . notEquals ( right ) ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xpath ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . axes . UnionPathIterator ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XString ; import org . apache . xpath . operations . Operation ; import org . apache . xpath . operations . UnaryOperation ; import org . apache . xpath . operations . Variable ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . patterns . UnionPattern ; public class XPathVisitor { public boolean visitLocationPath ( ExpressionOwner owner , LocPathIterator path ) { return true ; } public boolean visitUnionPath ( ExpressionOwner owner , UnionPathIterator path ) { return true ; } public boolean visitStep ( ExpressionOwner owner , NodeTest step ) { return true ; } public boolean visitPredicate ( ExpressionOwner owner , Expression pred ) { return true ; } public boolean visitBinaryOperation ( ExpressionOwner owner , Operation op ) { return true ; } public boolean visitUnaryOperation ( ExpressionOwner owner , UnaryOperation op ) { return true ; } public boolean visitVariableRef ( ExpressionOwner owner , Variable var ) { return true ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { return true ; } public boolean visitMatchPattern ( ExpressionOwner owner , StepPattern pattern ) { return true ; } public boolean visitUnionPattern ( ExpressionOwner owner , UnionPattern pattern ) { return true ; } public boolean visitStringLiteral ( ExpressionOwner owner , XString str ) { return true ; } public boolean visitNumberLiteral ( ExpressionOwner owner , XNumber num ) { return true ; } } 	0	['13', '1', '5', '43', '14', '78', '40', '13', '13', '2', '40', '0', '0', '0', '0.203296703', '0', '0', '2.076923077', '1', '0.9231', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class LocalNameCall extends NameBase { public LocalNameCall ( QName fname ) { super ( fname ) ; } public LocalNameCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeName = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeName" , "(I)" + STRING_SIG ) ; final int getLocalName = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "getLocalName" , "(Ljava/lang/String;)" + "Ljava/lang/String;" ) ; super . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( getNodeName , 2 ) ) ; il . append ( new INVOKESTATIC ( getLocalName ) ) ; } } 	0	['3', '5', '0', '10', '13', '3', '0', '10', '3', '2', '50', '0', '0', '0.99', '0.533333333', '3', '5', '15.66666667', '1', '0.3333', '0']
package org . apache . xalan . xsltc . cmdline . getopt ; public class GetOptsException extends Exception { public GetOptsException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '2', '3', '2', '0', '3', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xalan . xsltc . dom ; import java . util . Vector ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class NodeCounter implements Axis { public static final int END = DTM . NULL ; protected int _node = END ; protected int _nodeType = DOM . FIRST_TYPE - 1 ; protected int _value = Integer . MIN_VALUE ; public final DOM _document ; public final DTMAxisIterator _iterator ; public final Translet _translet ; protected String _format ; protected String _lang ; protected String _letterValue ; protected String _groupSep ; protected int _groupSize ; private boolean separFirst = true ; private boolean separLast = false ; private Vector separToks = null ; private Vector formatToks = null ; private int nSepars = 0 ; private int nFormats = 0 ; private static String [ ] Thousands = { "" , "m" , "mm" , "mmm" } ; private static String [ ] Hundreds = { "" , "c" , "cc" , "ccc" , "cd" , "d" , "dc" , "dcc" , "dccc" , "cm" } ; private static String [ ] Tens = { "" , "x" , "xx" , "xxx" , "xl" , "l" , "lx" , "lxx" , "lxxx" , "xc" } ; private static String [ ] Ones = { "" , "i" , "ii" , "iii" , "iv" , "v" , "vi" , "vii" , "viii" , "ix" } ; protected NodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { _translet = translet ; _document = document ; _iterator = iterator ; } abstract public NodeCounter setStartNode ( int node ) ; public NodeCounter setValue ( int value ) { _value = value ; return this ; } protected void setFormatting ( String format , String lang , String letterValue , String groupSep , String groupSize ) { _lang = lang ; _format = format ; _groupSep = groupSep ; _letterValue = letterValue ; try { _groupSize = Integer . parseInt ( groupSize ) ; } catch ( NumberFormatException e ) { _groupSize = 0 ; } final int length = _format . length ( ) ; boolean isFirst = true ; separFirst = true ; separLast = false ; separToks = new Vector ( ) ; formatToks = new Vector ( ) ; for ( int j = 0 , i = 0 ; i < length ; ) { char c = _format . charAt ( i ) ; for ( j = i ; Character . isLetterOrDigit ( c ) ; ) { if ( ++ i == length ) break ; c = _format . charAt ( i ) ; } if ( i > j ) { if ( isFirst ) { separToks . addElement ( "." ) ; isFirst = separFirst = false ; } formatToks . addElement ( _format . substring ( j , i ) ) ; } if ( i == length ) break ; c = _format . charAt ( i ) ; for ( j = i ; ! Character . isLetterOrDigit ( c ) ; ) { if ( ++ i == length ) break ; c = _format . charAt ( i ) ; isFirst = false ; } if ( i > j ) { separToks . addElement ( _format . substring ( j , i ) ) ; } } nSepars = separToks . size ( ) ; nFormats = formatToks . size ( ) ; if ( nSepars > nFormats ) separLast = true ; if ( separFirst ) nSepars -- ; if ( separLast ) nSepars -- ; if ( nSepars == 0 ) { separToks . insertElementAt ( "." , 1 ) ; nSepars ++ ; } if ( separFirst ) nSepars ++ ; } public NodeCounter setDefaultFormatting ( ) { setFormatting ( "1" , "en" , "alphabetic" , null , null ) ; return this ; } abstract public String getCounter ( ) ; public String getCounter ( String format , String lang , String letterValue , String groupSep , String groupSize ) { setFormatting ( format , lang , letterValue , groupSep , groupSize ) ; return getCounter ( ) ; } public boolean matchesCount ( int node ) { return _nodeType == _document . getExpandedTypeID ( node ) ; } public boolean matchesFrom ( int node ) { return false ; } protected String formatNumbers ( int value ) { return formatNumbers ( new int [ ] { value } ) ; } protected String formatNumbers ( int [ ] values ) { final int nValues = values . length ; final int length = _format . length ( ) ; boolean isEmpty = true ; for ( int i = 0 ; i < nValues ; i ++ ) if ( values [ i ] != Integer . MIN_VALUE ) isEmpty = false ; if ( isEmpty ) return ( "" ) ; boolean isFirst = true ; int t = 0 , n = 0 , s = 1 ; final StringBuffer buffer = new StringBuffer ( ) ; if ( separFirst ) buffer . append ( ( String ) separToks . elementAt ( 0 ) ) ; while ( n < nValues ) { final int value = values [ n ] ; if ( value != Integer . MIN_VALUE ) { if ( ! isFirst ) buffer . append ( ( String ) separToks . elementAt ( s ++ ) ) ; formatValue ( value , ( String ) formatToks . elementAt ( t ++ ) , buffer ) ; if ( t == nFormats ) t -- ; if ( s >= nSepars ) s -- ; isFirst = false ; } n ++ ; } if ( separLast ) buffer . append ( ( String ) separToks . lastElement ( ) ) ; return buffer . toString ( ) ; } private void formatValue ( int value , String format , StringBuffer buffer ) { char c = format . charAt ( 0 ) ; if ( Character . isDigit ( c ) ) { char zero = ( char ) ( c - Character . getNumericValue ( c ) ) ; StringBuffer temp = buffer ; if ( _groupSize > 0 ) { temp = new StringBuffer ( ) ; } String s = "" ; int n = value ; while ( n > 0 ) { s = ( char ) ( ( int ) zero + ( n % 10 ) ) + s ; n = n / 10 ; } for ( int i = 0 ; i < format . length ( ) - s . length ( ) ; i ++ ) { temp . append ( zero ) ; } temp . append ( s ) ; if ( _groupSize > 0 ) { for ( int i = 0 ; i < temp . length ( ) ; i ++ ) { if ( i != 0 && ( ( temp . length ( ) - i ) % _groupSize ) == 0 ) { buffer . append ( _groupSep ) ; } buffer . append ( temp . charAt ( i ) ) ; } } } else if ( c == 'i' && ! _letterValue . equals ( "alphabetic" ) ) { buffer . append ( romanValue ( value ) ) ; } else if ( c == 'I' && ! _letterValue . equals ( "alphabetic" ) ) { buffer . append ( romanValue ( value ) . toUpperCase ( ) ) ; } else { int min = ( int ) c ; int max = ( int ) c ; if ( c >= 0x3b1 && c <= 0x3c9 ) { max = 0x3c9 ; } else { while ( Character . isLetterOrDigit ( ( char ) ( max + 1 ) ) ) { max ++ ; } } buffer . append ( alphaValue ( value , min , max ) ) ; } } private String alphaValue ( int value , int min , int max ) { if ( value <= 0 ) { return "" + value ; } int range = max - min + 1 ; char last = ( char ) ( ( ( value - 1 ) % range ) + min ) ; if ( value > range ) { return alphaValue ( ( value - 1 ) / range , min , max ) + last ; } else { return "" + last ; } } private String romanValue ( int n ) { if ( n <= 0 || n > 4000 ) { return "" + n ; } return Thousands [ n / 1000 ] + Hundreds [ ( n / 100 ) % 10 ] + Tens [ ( n / 10 ) % 10 ] + Ones [ n % 10 ] ; } } 	0	['15', '1', '3', '8', '39', '91', '4', '4', '7', '0.811688312', '833', '0.818181818', '3', '0', '0.267857143', '0', '0', '53.06666667', '14', '3.6', '0']
package org . apache . xml . dtm ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Properties ; class FactoryFinder { private static boolean debug ; private static String foundFactory = null ; static { try { String val = SecuritySupport . getInstance ( ) . getSystemProperty ( "jaxp.debug" ) ; debug = val != null && ( ! "false" . equals ( val ) ) ; } catch ( SecurityException se ) { debug = false ; } } static Object find ( String factoryId , String fallbackClassName ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader cl = FactoryFinder . class . getClassLoader ( ) ; dPrint ( "find factoryId=" + factoryId ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { dPrint ( "found system property, value=" + systemProp ) ; return newInstance ( systemProp , cl , true ) ; } } catch ( SecurityException se ) { } synchronized ( FactoryFinder . class ) { if ( foundFactory == null ) { Properties xalanProperties = null ; try { String javah = ss . getSystemProperty ( "java.home" ) ; String configFile = javah + File . separator + "lib" + File . separator + "xalan.properties" ; File f = new File ( configFile ) ; FileInputStream fis = ss . getFileInputStream ( f ) ; xalanProperties = new Properties ( ) ; xalanProperties . load ( fis ) ; fis . close ( ) ; } catch ( Exception x ) { } if ( xalanProperties != null ) { foundFactory = xalanProperties . getProperty ( factoryId ) ; if ( foundFactory != null ) { dPrint ( "found in xalan.properties, value=" + foundFactory ) ; } } else { findJarServiceProvider ( factoryId ) ; if ( foundFactory == null ) { if ( fallbackClassName == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } dPrint ( "using fallback, value=" + fallbackClassName ) ; foundFactory = fallbackClassName ; } } } } return newInstance ( foundFactory , cl , true ) ; } private static void dPrint ( String msg ) { if ( debug ) { System . err . println ( "JAXP: " + msg ) ; } } private static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { cl = FactoryFinder . class . getClassLoader ( ) ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } } Object instance = providerClass . newInstance ( ) ; dPrint ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } private static String findJarServiceProvider ( String factoryId ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = "META-INF/services/" + factoryId ; InputStream is = null ; ClassLoader cl = FactoryFinder . class . getClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { return null ; } dPrint ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { dPrint ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['7', '1', '0', '3', '35', '11', '1', '2', '0', '0.611111111', '395', '0.666666667', '0', '0', '0.333333333', '0', '0', '55', '2', '0.8571', '0']
package org . apache . xml . dtm ; public abstract class DTMAxisTraverser { public int first ( int context ) { return next ( context , context ) ; } public int first ( int context , int extendedTypeID ) { return next ( context , context , extendedTypeID ) ; } public abstract int next ( int context , int current ) ; public abstract int next ( int context , int current , int extendedTypeID ) ; } 	0	['5', '1', '12', '31', '6', '10', '31', '0', '5', '2', '19', '0', '0', '0', '0.9', '0', '0', '2.8', '1', '0.8', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class CopyOf extends Instruction { private Expression _select ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "CopyOf" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; } public void parseContents ( Parser parser ) { _select = parser . parseExpression ( this , "select" , null ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; return ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tselect = _select . typeCheck ( stable ) ; if ( tselect instanceof NodeType || tselect instanceof NodeSetType || tselect instanceof ReferenceType || tselect instanceof ResultTreeType ) { } else { _select = new CastExpr ( _select , Type . String ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final Type tselect = _select . getType ( ) ; final String CPY1_SIG = "(" + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + ")V" ; final int cpy1 = cpg . addInterfaceMethodref ( DOM_INTF , "copy" , CPY1_SIG ) ; final String CPY2_SIG = "(" + NODE_SIG + TRANSLET_OUTPUT_SIG + ")V" ; final int cpy2 = cpg . addInterfaceMethodref ( DOM_INTF , "copy" , CPY2_SIG ) ; final String getDoc_SIG = "()" + NODE_SIG ; final int getDoc = cpg . addInterfaceMethodref ( DOM_INTF , "getDocument" , getDoc_SIG ) ; if ( tselect instanceof NodeSetType ) { il . append ( methodGen . loadDOM ( ) ) ; _select . translate ( classGen , methodGen ) ; _select . startResetIterator ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( cpy1 , 3 ) ) ; } else if ( tselect instanceof NodeType ) { il . append ( methodGen . loadDOM ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( cpy2 , 3 ) ) ; } else if ( tselect instanceof ResultTreeType ) { _select . translate ( classGen , methodGen ) ; il . append ( DUP ) ; il . append ( new INVOKEINTERFACE ( getDoc , 1 ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( cpy2 , 3 ) ) ; } else if ( tselect instanceof ReferenceType ) { _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int copy = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "copy" , "(" + OBJECT_SIG + TRANSLET_OUTPUT_SIG + NODE_SIG + DOM_INTF_SIG + ")V" ) ; il . append ( new INVOKESTATIC ( copy ) ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , CHARACTERSW , CHARACTERSW_SIG ) ) ) ; } } } 	0	['5', '3', '0', '24', '32', '0', '1', '23', '4', '0.25', '269', '1', '1', '0.933333333', '0.333333333', '1', '4', '52.6', '5', '1.8', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ACONST_NULL ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . Type ; import org . apache . xalan . xsltc . compiler . Constants ; public final class CompareGenerator extends MethodGenerator { private static int DOM_INDEX = 1 ; private static int CURRENT_INDEX = 2 ; private static int LEVEL_INDEX = 3 ; private static int TRANSLET_INDEX = 4 ; private static int LAST_INDEX = 5 ; private int ITERATOR_INDEX = 6 ; private final Instruction _iloadCurrent ; private final Instruction _istoreCurrent ; private final Instruction _aloadDom ; private final Instruction _iloadLast ; private final Instruction _aloadIterator ; private final Instruction _astoreIterator ; public CompareGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; _iloadCurrent = new ILOAD ( CURRENT_INDEX ) ; _istoreCurrent = new ISTORE ( CURRENT_INDEX ) ; _aloadDom = new ALOAD ( DOM_INDEX ) ; _iloadLast = new ILOAD ( LAST_INDEX ) ; LocalVariableGen iterator = addLocalVariable ( "iterator" , Util . getJCRefType ( Constants . NODE_ITERATOR_SIG ) , null , null ) ; ITERATOR_INDEX = iterator . getIndex ( ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; il . append ( new ACONST_NULL ( ) ) ; il . append ( storeIterator ( ) ) ; } public Instruction loadLastNode ( ) { return _iloadLast ; } public Instruction loadCurrentNode ( ) { return _iloadCurrent ; } public Instruction storeCurrentNode ( ) { return _istoreCurrent ; } public Instruction loadDOM ( ) { return _aloadDom ; } public int getHandlerIndex ( ) { return INVALID_INDEX ; } public int getIteratorIndex ( ) { return INVALID_INDEX ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_INDEX ; } return super . getLocalIndex ( name ) ; } } 	0	['11', '5', '0', '16', '23', '37', '3', '13', '10', '0.916666667', '141', '1', '0', '0.93877551', '0.225', '2', '5', '10.72727273', '2', '0.9091', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class RealExpr extends Expression { private double _value ; public RealExpr ( double value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . Real ; } public String toString ( ) { return "real-expr(" + _value + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0	['4', '3', '0', '11', '14', '0', '0', '11', '4', '0.333333333', '44', '1', '0', '0.959459459', '0.4', '2', '7', '9.75', '1', '0.75', '0']
package org . apache . xalan . xsltc . cmdline . getopt ; class MissingOptArgException extends GetOptsException { public MissingOptArgException ( String msg ) { super ( msg ) ; } } 	0	['1', '4', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xml . serializer ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Properties ; import javax . xml . transform . OutputKeys ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . Constants ; import org . apache . xml . utils . WrappedRuntimeException ; public class OutputPropertiesFactory { public static final String S_BUILTIN_EXTENSIONS_UNIVERSAL = "{" + Constants . S_BUILTIN_EXTENSIONS_URL + "}" ; public static final String S_KEY_INDENT_AMOUNT = S_BUILTIN_EXTENSIONS_UNIVERSAL + "indent-amount" ; public static final String S_KEY_CONTENT_HANDLER = S_BUILTIN_EXTENSIONS_UNIVERSAL + "content-handler" ; public static final String S_KEY_ENTITIES = S_BUILTIN_EXTENSIONS_UNIVERSAL + "entities" ; public static final String S_USE_URL_ESCAPING = S_BUILTIN_EXTENSIONS_UNIVERSAL + "use-url-escaping" ; public static final String S_OMIT_META_TAG = S_BUILTIN_EXTENSIONS_UNIVERSAL + "omit-meta-tag" ; public static final String S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL = "{" + Constants . S_BUILTIN_OLD_EXTENSIONS_URL + "}" ; public static final int S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN = S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL . length ( ) ; private static final String S_XSLT_PREFIX = "xslt.output." ; private static final int S_XSLT_PREFIX_LEN = S_XSLT_PREFIX . length ( ) ; private static final String S_XALAN_PREFIX = "org.apache.xslt." ; private static final int S_XALAN_PREFIX_LEN = S_XALAN_PREFIX . length ( ) ; private static final Class [ ] NO_CLASSES = new Class [ 0 ] ; private static Integer m_synch_object = new Integer ( 1 ) ; private static final Object [ ] NO_OBJS = new Object [ 0 ] ; private static final String PROP_DIR = "org/apache/xml/serializer/" ; private static final String PROP_FILE_XML = "output_xml.properties" ; private static final String PROP_FILE_TEXT = "output_text.properties" ; private static final String PROP_FILE_HTML = "output_html.properties" ; private static final String PROP_FILE_UNKNOWN = "output_unknown.properties" ; private static Properties m_xml_properties = null ; private static Properties m_html_properties = null ; private static Properties m_text_properties = null ; private static Properties m_unknown_properties = null ; static public Properties getDefaultMethodProperties ( String method ) { String fileName = null ; Properties defaultProperties = null ; try { synchronized ( m_synch_object ) { if ( null == m_xml_properties ) { fileName = PROP_FILE_XML ; m_xml_properties = loadPropertiesFile ( fileName , null ) ; } } if ( method . equals ( Method . XML ) ) { defaultProperties = m_xml_properties ; } else if ( method . equals ( Method . HTML ) ) { if ( null == m_html_properties ) { fileName = PROP_FILE_HTML ; m_html_properties = loadPropertiesFile ( fileName , m_xml_properties ) ; } defaultProperties = m_html_properties ; } else if ( method . equals ( Method . TEXT ) ) { if ( null == m_text_properties ) { fileName = PROP_FILE_TEXT ; m_text_properties = loadPropertiesFile ( fileName , m_xml_properties ) ; if ( null == m_text_properties . getProperty ( OutputKeys . ENCODING ) ) { String mimeEncoding = Encodings . getMimeEncoding ( null ) ; m_text_properties . put ( OutputKeys . ENCODING , mimeEncoding ) ; } } defaultProperties = m_text_properties ; } else if ( method . equals ( org . apache . xml . serializer . Method . UNKNOWN ) ) { if ( null == m_unknown_properties ) { fileName = PROP_FILE_UNKNOWN ; m_unknown_properties = loadPropertiesFile ( fileName , m_xml_properties ) ; } defaultProperties = m_unknown_properties ; } else { defaultProperties = m_xml_properties ; } } catch ( IOException ioe ) { throw new WrappedRuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_LOAD_METHOD_PROPERTY , new Object [ ] { fileName , method } ) , ioe ) ; } return defaultProperties ; } static private Properties loadPropertiesFile ( final String resourceName , Properties defaults ) throws IOException { Properties props = new Properties ( defaults ) ; InputStream is = null ; BufferedInputStream bis = null ; Class accessControllerClass = null ; try { try { try { accessControllerClass = Class . forName ( "java.security.AccessController" ) ; is = ( InputStream ) java . security . AccessController . doPrivileged ( new java . security . PrivilegedAction ( ) { public Object run ( ) { try { java . lang . reflect . Method getCCL = Thread . class . getMethod ( "getContextClassLoader" , NO_CLASSES ) ; if ( getCCL != null ) { ClassLoader contextClassLoader = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; return ( contextClassLoader . getResourceAsStream ( PROP_DIR + resourceName ) ) ; } } catch ( Exception e ) { } return null ; } } ) ; } catch ( ClassNotFoundException e ) { try { java . lang . reflect . Method getCCL = Thread . class . getMethod ( "getContextClassLoader" , NO_CLASSES ) ; if ( getCCL != null ) { ClassLoader contextClassLoader = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; is = contextClassLoader . getResourceAsStream ( PROP_DIR + resourceName ) ; } } catch ( Exception exception ) { } } } catch ( Exception e ) { } if ( is == null ) { if ( accessControllerClass != null ) { is = ( InputStream ) java . security . AccessController . doPrivileged ( new java . security . PrivilegedAction ( ) { public Object run ( ) { return OutputPropertiesFactory . class . getResourceAsStream ( resourceName ) ; } } ) ; } else { is = OutputPropertiesFactory . class . getResourceAsStream ( resourceName ) ; } } bis = new BufferedInputStream ( is ) ; props . load ( bis ) ; } catch ( IOException ioe ) { if ( defaults == null ) { throw ioe ; } else { throw new WrappedRuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_LOAD_RESOURCE , new Object [ ] { resourceName } ) , ioe ) ; } } catch ( SecurityException se ) { if ( defaults == null ) { throw se ; } else { throw new WrappedRuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_LOAD_RESOURCE , new Object [ ] { resourceName } ) , se ) ; } } finally { if ( bis != null ) { bis . close ( ) ; } if ( is != null ) { is . close ( ) ; } } Enumeration keys = ( ( Properties ) props . clone ( ) ) . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; String value = null ; try { value = System . getProperty ( key ) ; } catch ( SecurityException se ) { } if ( value == null ) value = ( String ) props . get ( key ) ; String newKey = fixupPropertyString ( key , true ) ; String newValue = null ; try { newValue = System . getProperty ( newKey ) ; } catch ( SecurityException se ) { } if ( newValue == null ) newValue = fixupPropertyString ( value , false ) ; else newValue = fixupPropertyString ( newValue , false ) ; if ( key != newKey || value != newValue ) { props . remove ( key ) ; props . put ( newKey , newValue ) ; } } return props ; } static private String fixupPropertyString ( String s , boolean doClipping ) { int index ; if ( doClipping && s . startsWith ( S_XSLT_PREFIX ) ) { s = s . substring ( S_XSLT_PREFIX_LEN ) ; } if ( s . startsWith ( S_XALAN_PREFIX ) ) { s = S_BUILTIN_EXTENSIONS_UNIVERSAL + s . substring ( S_XALAN_PREFIX_LEN ) ; } if ( ( index = s . indexOf ( "\\u003a" ) ) > 0 ) { String temp = s . substring ( index + 6 ) ; s = s . substring ( 0 , index ) + ":" + temp ; } return s ; } } 	0	['8', '1', '0', '9', '47', '14', '6', '5', '2', '0.983516484', '460', '0.615384615', '0', '0', '0.25', '0', '0', '53.25', '10', '2.375', '0']
package org . apache . xalan . xsltc . dom ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMException ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xalan . xsltc . trax . DOM2SAX ; import org . xml . sax . InputSource ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; public class XSLTCDTMManager extends DTMManagerDefault { private static String defaultClassName = "org.apache.xalan.xsltc.dom.XSLTCDTMManager" ; private static final boolean DUMPTREE = false ; private static final boolean DEBUG = false ; public XSLTCDTMManager ( ) { super ( ) ; } public static XSLTCDTMManager newInstance ( ) { XSLTCDTMManager factoryImpl = new XSLTCDTMManager ( ) ; return factoryImpl ; } public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing ) { return getDTM ( source , unique , whiteSpaceFilter , incremental , doIndexing , false , 0 , true ) ; } public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing , boolean buildIdIndex ) { return getDTM ( source , unique , whiteSpaceFilter , incremental , doIndexing , false , 0 , buildIdIndex ) ; } public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing , boolean hasUserReader , int size , boolean buildIdIndex ) { if ( DEBUG && null != source ) { System . out . println ( "Starting " + ( unique ? "UNIQUE" : "shared" ) + " source: " + source . getSystemId ( ) ) ; } int dtmPos = getFirstFreeDTMID ( ) ; int documentID = dtmPos << IDENT_DTM_NODE_BITS ; if ( ( null != source ) && source instanceof DOMSource ) { final DOMSource domsrc = ( DOMSource ) source ; final org . w3c . dom . Node node = domsrc . getNode ( ) ; final DOM2SAX dom2sax = new DOM2SAX ( node ) ; SAXImpl dtm ; if ( size <= 0 ) { dtm = new SAXImpl ( this , source , documentID , whiteSpaceFilter , null , doIndexing , buildIdIndex ) ; } else { dtm = new SAXImpl ( this , source , documentID , whiteSpaceFilter , null , doIndexing , size , buildIdIndex ) ; } dtm . setDocumentURI ( source . getSystemId ( ) ) ; addDTM ( dtm , dtmPos , 0 ) ; dom2sax . setContentHandler ( dtm ) ; try { dom2sax . parse ( ) ; } catch ( RuntimeException re ) { throw re ; } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } return dtm ; } else { boolean isSAXSource = ( null != source ) ? ( source instanceof SAXSource ) : true ; boolean isStreamSource = ( null != source ) ? ( source instanceof StreamSource ) : false ; if ( isSAXSource || isStreamSource ) { XMLReader reader ; InputSource xmlSource ; if ( null == source ) { xmlSource = null ; reader = null ; hasUserReader = false ; } else { reader = getXMLReader ( source ) ; xmlSource = SAXSource . sourceToInputSource ( source ) ; String urlOfSource = xmlSource . getSystemId ( ) ; if ( null != urlOfSource ) { try { urlOfSource = SystemIDResolver . getAbsoluteURI ( urlOfSource ) ; } catch ( Exception e ) { System . err . println ( "Can not absolutize URL: " + urlOfSource ) ; } xmlSource . setSystemId ( urlOfSource ) ; } } SAXImpl dtm ; if ( size <= 0 ) { dtm = new SAXImpl ( this , source , documentID , whiteSpaceFilter , null , doIndexing , buildIdIndex ) ; } else { dtm = new SAXImpl ( this , source , documentID , whiteSpaceFilter , null , doIndexing , size , buildIdIndex ) ; } addDTM ( dtm , dtmPos , 0 ) ; if ( null == reader ) { return dtm ; } reader . setContentHandler ( dtm . getBuilder ( ) ) ; if ( ! hasUserReader || null == reader . getDTDHandler ( ) ) { reader . setDTDHandler ( dtm ) ; } if ( ! hasUserReader || null == reader . getErrorHandler ( ) ) { reader . setErrorHandler ( dtm ) ; } try { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , dtm ) ; } catch ( SAXNotRecognizedException e ) { } catch ( SAXNotSupportedException e ) { } try { reader . parse ( xmlSource ) ; } catch ( RuntimeException re ) { throw re ; } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } if ( DUMPTREE ) { System . out . println ( "Dumping SAX2DOM" ) ; dtm . dumpDTM ( System . err ) ; } return dtm ; } else { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NOT_SUPPORTED , new Object [ ] { source } ) ) ; } } } } 	0	['6', '3', '0', '20', '37', '15', '10', '11', '5', '1.133333333', '273', '1', '0', '0.897435897', '0.56', '1', '4', '44', '16', '3.1667', '0']
package org . apache . xalan . xsltc . trax ; import java . util . Stack ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xalan . xsltc . runtime . Constants ; import org . w3c . dom . Comment ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . ProcessingInstruction ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class SAX2DOM implements ContentHandler , LexicalHandler , Constants { private Node _root = null ; private Document _document = null ; private Stack _nodeStk = new Stack ( ) ; private Vector _namespaceDecls = null ; public SAX2DOM ( ) throws ParserConfigurationException { final DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; _document = factory . newDocumentBuilder ( ) . newDocument ( ) ; _root = _document ; } public SAX2DOM ( Node root ) throws ParserConfigurationException { _root = root ; if ( root instanceof Document ) { _document = ( Document ) root ; } else if ( root != null ) { _document = root . getOwnerDocument ( ) ; } else { final DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; _document = factory . newDocumentBuilder ( ) . newDocument ( ) ; _root = _document ; } } public Node getDOM ( ) { return _root ; } public void characters ( char [ ] ch , int start , int length ) { final Node last = ( Node ) _nodeStk . peek ( ) ; if ( last != _document ) { final String text = new String ( ch , start , length ) ; last . appendChild ( _document . createTextNode ( text ) ) ; } } public void startDocument ( ) { _nodeStk . push ( _root ) ; } public void endDocument ( ) { _nodeStk . pop ( ) ; } public void startElement ( String namespace , String localName , String qName , Attributes attrs ) { final Element tmp = ( Element ) _document . createElementNS ( namespace , qName ) ; if ( _namespaceDecls != null ) { final int nDecls = _namespaceDecls . size ( ) ; for ( int i = 0 ; i < nDecls ; i ++ ) { final String prefix = ( String ) _namespaceDecls . elementAt ( i ++ ) ; if ( prefix == null || prefix . equals ( EMPTYSTRING ) ) { tmp . setAttributeNS ( XMLNS_URI , XMLNS_PREFIX , ( String ) _namespaceDecls . elementAt ( i ) ) ; } else { tmp . setAttributeNS ( XMLNS_URI , XMLNS_STRING + prefix , ( String ) _namespaceDecls . elementAt ( i ) ) ; } } _namespaceDecls . clear ( ) ; } final int nattrs = attrs . getLength ( ) ; for ( int i = 0 ; i < nattrs ; i ++ ) { if ( attrs . getLocalName ( i ) == null ) { tmp . setAttribute ( attrs . getQName ( i ) , attrs . getValue ( i ) ) ; } else { tmp . setAttributeNS ( attrs . getURI ( i ) , attrs . getQName ( i ) , attrs . getValue ( i ) ) ; } } Node last = ( Node ) _nodeStk . peek ( ) ; last . appendChild ( tmp ) ; _nodeStk . push ( tmp ) ; } public void endElement ( String namespace , String localName , String qName ) { _nodeStk . pop ( ) ; } public void startPrefixMapping ( String prefix , String uri ) { if ( _namespaceDecls == null ) { _namespaceDecls = new Vector ( 2 ) ; } _namespaceDecls . addElement ( prefix ) ; _namespaceDecls . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) { } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { } public void processingInstruction ( String target , String data ) { final Node last = ( Node ) _nodeStk . peek ( ) ; ProcessingInstruction pi = _document . createProcessingInstruction ( target , data ) ; if ( pi != null ) last . appendChild ( pi ) ; } public void setDocumentLocator ( Locator locator ) { } public void skippedEntity ( String name ) { } public void comment ( char [ ] ch , int start , int length ) { final Node last = ( Node ) _nodeStk . peek ( ) ; Comment comment = _document . createComment ( new String ( ch , start , length ) ) ; if ( comment != null ) last . appendChild ( comment ) ; } public void startCDATA ( ) { } public void endCDATA ( ) { } public void startEntity ( java . lang . String name ) { } public void endDTD ( ) { } public void endEntity ( String name ) { } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { } } 	0	['21', '1', '0', '2', '52', '126', '1', '1', '21', '0.7625', '322', '1', '0', '0', '0.265306122', '0', '0', '14.14285714', '7', '1.381', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . Transformer ; import org . apache . xml . serializer . Serializer ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . ext . DeclHandler ; public interface SerializationHandler extends ExtendedContentHandler , ExtendedLexicalHandler , XSLOutputAttributes , DeclHandler , ErrorHandler , DOMSerializer , Serializer { public void setContentHandler ( ContentHandler ch ) ; public void close ( ) ; public void serialize ( Node node ) throws IOException ; public boolean setEscaping ( boolean escape ) throws SAXException ; public void setIndentAmount ( int spaces ) ; public void setTransformer ( Transformer transformer ) ; public Transformer getTransformer ( ) ; public void setNamespaceMappings ( NamespaceMappings mappings ) ; public void flushPending ( ) ; } 	0	['9', '1', '0', '47', '9', '36', '41', '6', '9', '2', '9', '0', '0', '0', '0.238095238', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . patterns ; public interface NodeTestFilter { void setNodeTest ( NodeTest nodeTest ) ; } 	0	['1', '1', '0', '1', '1', '0', '0', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . FilterGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class LangCall extends FunctionCall { private Expression _lang ; private Type _langType ; public LangCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _lang = argument ( 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _langType = _lang . typeCheck ( stable ) ; if ( ! ( _langType instanceof StringType ) ) { _lang = new CastExpr ( _lang , Type . String ) ; } return Type . Boolean ; } public Type getType ( ) { return ( Type . Boolean ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int tst = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "testLanguage" , "(" + STRING_SIG + DOM_INTF_SIG + "I)Z" ) ; _lang . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; if ( classGen instanceof FilterGenerator ) il . append ( new ILOAD ( 1 ) ) ; else il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKESTATIC ( tst ) ) ; } } 	0	['4', '4', '0', '17', '17', '0', '0', '17', '4', '0.666666667', '84', '1', '2', '0.96969697', '0.375', '3', '8', '19.5', '2', '1', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class FilterIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private final DTMFilter _filter ; private final boolean _isReverse ; public FilterIterator ( DTMAxisIterator source , DTMFilter filter ) { _source = source ; _filter = filter ; _isReverse = source . isReverse ( ) ; } public boolean isReverse ( ) { return _isReverse ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator cloneIterator ( ) { try { final FilterIterator clone = ( FilterIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { if ( _filter . acceptNode ( node , DTMFilter . SHOW_ALL ) == DTMIterator . FILTER_ACCEPT ) { return returnNode ( node ) ; } } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; return resetPosition ( ) ; } return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['9', '2', '0', '4', '24', '0', '0', '4', '9', '0.625', '109', '1', '2', '0.619047619', '0.288888889', '1', '6', '10.77777778', '3', '1.2222', '0']
package org . apache . xalan . xsltc . compiler ; abstract class RelativePathPattern extends LocationPathPattern { } 	0	['1', '5', '3', '7', '2', '0', '6', '1', '0', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xpath . axes ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . res . XPATHErrorResources ; public class AxesWalker extends PredicatedNodeTest implements Cloneable , PathComponent , ExpressionOwner { public AxesWalker ( LocPathIterator locPathIterator , int axis ) { super ( locPathIterator ) ; m_axis = axis ; } public final WalkingIterator wi ( ) { return ( WalkingIterator ) m_lpi ; } public void init ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { initPredicateInfo ( compiler , opPos ) ; } public Object clone ( ) throws CloneNotSupportedException { AxesWalker clone = ( AxesWalker ) super . clone ( ) ; return clone ; } AxesWalker cloneDeep ( WalkingIterator cloneOwner , Vector cloneList ) throws CloneNotSupportedException { AxesWalker clone = findClone ( this , cloneList ) ; if ( null != clone ) return clone ; clone = ( AxesWalker ) this . clone ( ) ; clone . setLocPathIterator ( cloneOwner ) ; if ( null != cloneList ) { cloneList . addElement ( this ) ; cloneList . addElement ( clone ) ; } if ( wi ( ) . m_lastUsedWalker == this ) cloneOwner . m_lastUsedWalker = clone ; if ( null != m_nextWalker ) clone . m_nextWalker = m_nextWalker . cloneDeep ( cloneOwner , cloneList ) ; if ( null != cloneList ) { if ( null != m_prevWalker ) clone . m_prevWalker = m_prevWalker . cloneDeep ( cloneOwner , cloneList ) ; } else { if ( null != m_nextWalker ) clone . m_nextWalker . m_prevWalker = clone ; } return clone ; } static AxesWalker findClone ( AxesWalker key , Vector cloneList ) { if ( null != cloneList ) { int n = cloneList . size ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( key == cloneList . elementAt ( i ) ) return ( AxesWalker ) cloneList . elementAt ( i + 1 ) ; } } return null ; } public void detach ( ) { m_currentNode = DTM . NULL ; m_dtm = null ; m_traverser = null ; m_isFresh = true ; m_root = DTM . NULL ; } public int getRoot ( ) { return m_root ; } public int getAnalysisBits ( ) { int axis = getAxis ( ) ; int bit = WalkerFactory . getAnalysisBitFromAxes ( axis ) ; return bit ; } public void setRoot ( int root ) { XPathContext xctxt = wi ( ) . getXPathContext ( ) ; m_dtm = xctxt . getDTM ( root ) ; m_traverser = m_dtm . getAxisTraverser ( m_axis ) ; m_isFresh = true ; m_foundLast = false ; m_root = root ; m_currentNode = root ; if ( DTM . NULL == root ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_SETTING_WALKER_ROOT_TO_NULL , null ) ) ; } resetProximityPositions ( ) ; } public final int getCurrentNode ( ) { return m_currentNode ; } public void setNextWalker ( AxesWalker walker ) { m_nextWalker = walker ; } public AxesWalker getNextWalker ( ) { return m_nextWalker ; } public void setPrevWalker ( AxesWalker walker ) { m_prevWalker = walker ; } public AxesWalker getPrevWalker ( ) { return m_prevWalker ; } private int returnNextNode ( int n ) { return n ; } protected int getNextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( m_isFresh ) { m_currentNode = m_traverser . first ( m_root ) ; m_isFresh = false ; } else if ( DTM . NULL != m_currentNode ) { m_currentNode = m_traverser . next ( m_root , m_currentNode ) ; } if ( DTM . NULL == m_currentNode ) this . m_foundLast = true ; return m_currentNode ; } public int nextNode ( ) { int nextNode = DTM . NULL ; AxesWalker walker = wi ( ) . getLastUsedWalker ( ) ; while ( true ) { if ( null == walker ) break ; nextNode = walker . getNextNode ( ) ; if ( DTM . NULL == nextNode ) { walker = walker . m_prevWalker ; } else { if ( walker . acceptNode ( nextNode ) != DTMIterator . FILTER_ACCEPT ) { continue ; } if ( null == walker . m_nextWalker ) { wi ( ) . setLastUsedWalker ( walker ) ; break ; } else { AxesWalker prev = walker ; walker = walker . m_nextWalker ; walker . setRoot ( nextNode ) ; walker . m_prevWalker = prev ; continue ; } } } return nextNode ; } public int getLastPos ( XPathContext xctxt ) { int pos = getProximityPosition ( ) ; AxesWalker walker ; try { walker = ( AxesWalker ) clone ( ) ; } catch ( CloneNotSupportedException cnse ) { return - 1 ; } walker . setPredicateCount ( walker . getPredicateCount ( ) - 1 ) ; walker . setNextWalker ( null ) ; walker . setPrevWalker ( null ) ; WalkingIterator lpi = wi ( ) ; AxesWalker savedWalker = lpi . getLastUsedWalker ( ) ; try { lpi . setLastUsedWalker ( walker ) ; int next ; while ( DTM . NULL != ( next = walker . nextNode ( ) ) ) { pos ++ ; } } finally { lpi . setLastUsedWalker ( savedWalker ) ; } return pos ; } private DTM m_dtm ; public void setDefaultDTM ( DTM dtm ) { m_dtm = dtm ; } public DTM getDTM ( int node ) { return wi ( ) . getXPathContext ( ) . getDTM ( node ) ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return m_axis ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitStep ( owner , this ) ) { callPredicateVisitors ( visitor ) ; if ( null != m_nextWalker ) { m_nextWalker . callVisitors ( this , visitor ) ; } } } public Expression getExpression ( ) { return m_nextWalker ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_nextWalker = ( AxesWalker ) exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; AxesWalker walker = ( AxesWalker ) expr ; if ( this . m_axis != walker . m_axis ) return false ; return true ; } transient int m_root = DTM . NULL ; private transient int m_currentNode = DTM . NULL ; transient boolean m_isFresh ; protected AxesWalker m_nextWalker ; AxesWalker m_prevWalker ; protected int m_axis = - 1 ; protected DTMAxisTraverser m_traverser ; } 	0	['27', '4', '2', '21', '53', '257', '8', '15', '23', '0.802884615', '454', '0.625', '4', '0.747572816', '0.138888889', '1', '4', '15.51851852', '5', '1.5926', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class SimpleAttributeValue extends AttributeValue { private String _value ; public SimpleAttributeValue ( String value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . String ; } public String toString ( ) { return _value ; } protected boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0	['5', '4', '0', '11', '10', '4', '1', '11', '4', '0.5', '38', '1', '0', '0.947368421', '0.36', '2', '8', '6.4', '1', '0.8', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Message extends Instruction { private boolean _terminate = false ; public void parseContents ( Parser parser ) { String termstr = getAttribute ( "terminate" ) ; if ( termstr != null ) { _terminate = termstr . equals ( "yes" ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( classGen . loadTranslet ( ) ) ; switch ( elementCount ( ) ) { case 0 : il . append ( new PUSH ( cpg , "" ) ) ; break ; case 1 : SyntaxTreeNode child = ( SyntaxTreeNode ) elementAt ( 0 ) ; if ( child instanceof Text ) { il . append ( new PUSH ( cpg , ( ( Text ) child ) . getText ( ) ) ) ; break ; } default : il . append ( methodGen . loadHandler ( ) ) ; il . append ( new NEW ( cpg . addClass ( STREAM_XML_OUTPUT ) ) ) ; il . append ( methodGen . storeHandler ( ) ) ; il . append ( new NEW ( cpg . addClass ( STRING_WRITER ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( STRING_WRITER , "<init>" , "()V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( STREAM_XML_OUTPUT , "<init>" , "()V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "setWriter" , "(" + WRITER_SIG + ")V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , "UTF-8" ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "setEncoding" , "(" + STRING_SIG + ")V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( ICONST_1 ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "setOmitXMLDeclaration" , "(Z)V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "startDocument" , "()V" ) ) ) ; translateContents ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "endDocument" , "()V" ) ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_WRITER , "toString" , "()" + STRING_SIG ) ) ) ; il . append ( SWAP ) ; il . append ( methodGen . storeHandler ( ) ) ; break ; } il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , "displayMessage" , "(" + STRING_SIG + ")V" ) ) ) ; if ( _terminate == true ) { final int einit = cpg . addMethodref ( "java.lang.RuntimeException" , "<init>" , "(Ljava/lang/String;)V" ) ; il . append ( new NEW ( cpg . addClass ( "java.lang.RuntimeException" ) ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "Termination forced by an " + "xsl:message instruction" ) ) ; il . append ( new INVOKESPECIAL ( einit ) ) ; il . append ( ATHROW ) ; } } } 	0	['4', '3', '0', '19', '26', '0', '0', '19', '3', '0.333333333', '311', '1', '0', '0.949152542', '0.4', '2', '6', '76.5', '6', '2.25', '0']
package org . apache . xpath . compiler ; public class PsuedoNames { public static final String PSEUDONAME_ANY = "*" ; public static final String PSEUDONAME_ROOT = "/" ; public static final String PSEUDONAME_TEXT = "#text" ; public static final String PSEUDONAME_COMMENT = "#comment" ; public static final String PSEUDONAME_PI = "#pi" ; public static final String PSEUDONAME_OTHER = "*" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '10', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xalan . transformer ; import java . io . IOException ; import javax . xml . transform . Result ; import javax . xml . transform . Transformer ; import javax . xml . transform . sax . TransformerHandler ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . IncrementalSAXSource_Filter ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM ; import org . apache . xpath . XPathContext ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . apache . xml . serializer . SerializationHandler ; public class TransformerHandlerImpl implements EntityResolver , DTDHandler , ContentHandler , ErrorHandler , LexicalHandler , TransformerHandler , DeclHandler { private boolean m_insideParse = false ; public TransformerHandlerImpl ( TransformerImpl transformer , boolean doFragment , String baseSystemID ) { super ( ) ; m_transformer = transformer ; m_baseSystemID = baseSystemID ; XPathContext xctxt = transformer . getXPathContext ( ) ; DTM dtm = xctxt . getDTM ( null , true , transformer , true , true ) ; m_dtm = dtm ; dtm . setDocumentBaseURI ( baseSystemID ) ; m_contentHandler = dtm . getContentHandler ( ) ; m_dtdHandler = dtm . getDTDHandler ( ) ; m_entityResolver = dtm . getEntityResolver ( ) ; m_errorHandler = dtm . getErrorHandler ( ) ; m_lexicalHandler = dtm . getLexicalHandler ( ) ; } protected void clearCoRoutine ( ) { clearCoRoutine ( null ) ; } protected void clearCoRoutine ( SAXException ex ) { if ( null != ex ) m_transformer . setExceptionThrown ( ex ) ; if ( m_dtm instanceof SAX2DTM ) { if ( DEBUG ) System . err . println ( "In clearCoRoutine..." ) ; try { SAX2DTM sax2dtm = ( ( SAX2DTM ) m_dtm ) ; if ( null != m_contentHandler && m_contentHandler instanceof IncrementalSAXSource_Filter ) { IncrementalSAXSource_Filter sp = ( IncrementalSAXSource_Filter ) m_contentHandler ; sp . deliverMoreNodes ( false ) ; } sax2dtm . clearCoRoutine ( true ) ; m_contentHandler = null ; m_dtdHandler = null ; m_entityResolver = null ; m_errorHandler = null ; m_lexicalHandler = null ; } catch ( Throwable throwable ) { throwable . printStackTrace ( ) ; } if ( DEBUG ) System . err . println ( "...exiting clearCoRoutine" ) ; } } public void setResult ( Result result ) throws IllegalArgumentException { if ( null == result ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_RESULT_NULL , null ) ) ; try { SerializationHandler xoh = m_transformer . createSerializationHandler ( result ) ; m_transformer . setSerializationHandler ( xoh ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_RESULT_COULD_NOT_BE_SET , null ) ) ; } m_result = result ; } public void setSystemId ( String systemID ) { m_baseSystemID = systemID ; m_dtm . setDocumentBaseURI ( systemID ) ; } public String getSystemId ( ) { return m_baseSystemID ; } public Transformer getTransformer ( ) { return m_transformer ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( m_entityResolver != null ) { return m_entityResolver . resolveEntity ( publicId , systemId ) ; } else { return null ; } } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( m_dtdHandler != null ) { m_dtdHandler . notationDecl ( name , publicId , systemId ) ; } } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( m_dtdHandler != null ) { m_dtdHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } } public void setDocumentLocator ( Locator locator ) { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#setDocumentLocator: " + locator . getSystemId ( ) ) ; this . m_locator = locator ; if ( null == m_baseSystemID ) { setSystemId ( locator . getSystemId ( ) ) ; } if ( m_contentHandler != null ) { m_contentHandler . setDocumentLocator ( locator ) ; } } public void startDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startDocument" ) ; m_insideParse = true ; if ( m_contentHandler != null ) { if ( DTMManager . getIncremental ( ) ) { m_transformer . setSourceTreeDocForThread ( m_dtm . getDocument ( ) ) ; int cpriority = Thread . currentThread ( ) . getPriority ( ) ; m_transformer . runTransformThread ( cpriority ) ; } m_contentHandler . startDocument ( ) ; } } public void endDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endDocument" ) ; m_insideParse = false ; if ( m_contentHandler != null ) { m_contentHandler . endDocument ( ) ; } if ( DTMManager . getIncremental ( ) ) { m_transformer . waitTransformThread ( ) ; } else { m_transformer . setSourceTreeDocForThread ( m_dtm . getDocument ( ) ) ; m_transformer . run ( ) ; } } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startPrefixMapping: " + prefix + ", " + uri ) ; if ( m_contentHandler != null ) { m_contentHandler . startPrefixMapping ( prefix , uri ) ; } } public void endPrefixMapping ( String prefix ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endPrefixMapping: " + prefix ) ; if ( m_contentHandler != null ) { m_contentHandler . endPrefixMapping ( prefix ) ; } } public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startElement: " + qName ) ; if ( m_contentHandler != null ) { m_contentHandler . startElement ( uri , localName , qName , atts ) ; } } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endElement: " + qName ) ; if ( m_contentHandler != null ) { m_contentHandler . endElement ( uri , localName , qName ) ; } } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#characters: " + start + ", " + length ) ; if ( m_contentHandler != null ) { m_contentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#ignorableWhitespace: " + start + ", " + length ) ; if ( m_contentHandler != null ) { m_contentHandler . ignorableWhitespace ( ch , start , length ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#processingInstruction: " + target + ", " + data ) ; if ( m_contentHandler != null ) { m_contentHandler . processingInstruction ( target , data ) ; } } public void skippedEntity ( String name ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#skippedEntity: " + name ) ; if ( m_contentHandler != null ) { m_contentHandler . skippedEntity ( name ) ; } } public void warning ( SAXParseException e ) throws SAXException { javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . warning ( e ) ; } else { try { errorListener . warning ( new javax . xml . transform . TransformerException ( e ) ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } public void error ( SAXParseException e ) throws SAXException { javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . error ( e ) ; if ( null != m_errorHandler ) m_errorHandler . error ( e ) ; } else { try { errorListener . error ( new javax . xml . transform . TransformerException ( e ) ) ; if ( null != m_errorHandler ) m_errorHandler . error ( e ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } public void fatalError ( SAXParseException e ) throws SAXException { if ( null != m_errorHandler ) { try { m_errorHandler . fatalError ( e ) ; } catch ( SAXParseException se ) { } } javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . fatalError ( e ) ; if ( null != m_errorHandler ) m_errorHandler . fatalError ( e ) ; } else { try { errorListener . fatalError ( new javax . xml . transform . TransformerException ( e ) ) ; if ( null != m_errorHandler ) m_errorHandler . fatalError ( e ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startDTD: " + name + ", " + publicId + ", " + systemId ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startDTD ( name , publicId , systemId ) ; } } public void endDTD ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endDTD" ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endDTD ( ) ; } } public void startEntity ( String name ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startEntity: " + name ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startEntity ( name ) ; } } public void endEntity ( String name ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endEntity: " + name ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endEntity ( name ) ; } } public void startCDATA ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startCDATA" ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endCDATA" ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endCDATA ( ) ; } } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#comment: " + start + ", " + length ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . comment ( ch , start , length ) ; } } public void elementDecl ( String name , String model ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#elementDecl: " + name + ", " + model ) ; if ( null != m_declHandler ) { m_declHandler . elementDecl ( name , model ) ; } } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#attributeDecl: " + eName + ", " + aName + ", etc..." ) ; if ( null != m_declHandler ) { m_declHandler . attributeDecl ( eName , aName , type , valueDefault , value ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#internalEntityDecl: " + name + ", " + value ) ; if ( null != m_declHandler ) { m_declHandler . internalEntityDecl ( name , value ) ; } } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#externalEntityDecl: " + name + ", " + publicId + ", " + systemId ) ; if ( null != m_declHandler ) { m_declHandler . externalEntityDecl ( name , publicId , systemId ) ; } } private static boolean DEBUG = false ; private TransformerImpl m_transformer ; private String m_baseSystemID ; private Result m_result = null ; private Locator m_locator = null ; private EntityResolver m_entityResolver = null ; private DTDHandler m_dtdHandler = null ; private ContentHandler m_contentHandler = null ; private ErrorHandler m_errorHandler = null ; private LexicalHandler m_lexicalHandler = null ; private DeclHandler m_declHandler = null ; DTM m_dtm ; } 	0	['36', '1', '0', '10', '100', '0', '2', '9', '33', '0.817582418', '914', '0.923076923', '2', '0', '0.176623377', '0', '0', '24.02777778', '7', '1.1944', '0']
package org . apache . xpath . compiler ; import java . util . Vector ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . res . XPATHErrorResources ; class Lexer { private Compiler m_compiler ; PrefixResolver m_namespaceContext ; XPathParser m_processor ; static final int TARGETEXTRA = 10000 ; private int m_patternMap [ ] = new int [ 100 ] ; private int m_patternMapSize ; Lexer ( Compiler compiler , PrefixResolver resolver , XPathParser xpathProcessor ) { m_compiler = compiler ; m_namespaceContext = resolver ; m_processor = xpathProcessor ; } void tokenize ( String pat ) throws javax . xml . transform . TransformerException { tokenize ( pat , null ) ; } void tokenize ( String pat , Vector targetStrings ) throws javax . xml . transform . TransformerException { m_compiler . m_currentPattern = pat ; m_patternMapSize = 0 ; m_compiler . m_opMap = new OpMapVector ( OpMap . MAXTOKENQUEUESIZE * 5 , OpMap . BLOCKTOKENQUEUESIZE * 5 , OpMap . MAPINDEX_LENGTH ) ; int nChars = pat . length ( ) ; int startSubstring = - 1 ; int posOfNSSep = - 1 ; boolean isStartOfPat = true ; boolean isAttrName = false ; boolean isNum = false ; int nesting = 0 ; for ( int i = 0 ; i < nChars ; i ++ ) { char c = pat . charAt ( i ) ; switch ( c ) { case '\"' : { if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } } startSubstring = i ; for ( i ++ ; ( i < nChars ) && ( ( c = pat . charAt ( i ) ) != '\"' ) ; i ++ ) ; if ( c == '\"' && i < nChars ) { addToTokenQueue ( pat . substring ( startSubstring , i + 1 ) ) ; startSubstring = - 1 ; } else { m_processor . error ( XPATHErrorResources . ER_EXPECTED_DOUBLE_QUOTE , null ) ; } } break ; case '\'' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } } startSubstring = i ; for ( i ++ ; ( i < nChars ) && ( ( c = pat . charAt ( i ) ) != '\'' ) ; i ++ ) ; if ( c == '\'' && i < nChars ) { addToTokenQueue ( pat . substring ( startSubstring , i + 1 ) ) ; startSubstring = - 1 ; } else { m_processor . error ( XPATHErrorResources . ER_EXPECTED_SINGLE_QUOTE , null ) ; } break ; case 0x0A : case 0x0D : case ' ' : case '\t' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } startSubstring = - 1 ; } break ; case '@' : isAttrName = true ; case '-' : if ( '-' == c ) { if ( ! ( isNum || ( startSubstring == - 1 ) ) ) { break ; } isNum = false ; } case '(' : case '[' : case ')' : case ']' : case '|' : case '/' : case '*' : case '+' : case '=' : case ',' : case '\\' : case '^' : case '!' : case '$' : case '<' : case '>' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } startSubstring = - 1 ; } else if ( ( '/' == c ) && isStartOfPat ) { isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; } else if ( '*' == c ) { isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; } if ( 0 == nesting ) { if ( '|' == c ) { if ( null != targetStrings ) { recordTokenString ( targetStrings ) ; } isStartOfPat = true ; } } if ( ( ')' == c ) || ( ']' == c ) ) { nesting -- ; } else if ( ( '(' == c ) || ( '[' == c ) ) { nesting ++ ; } addToTokenQueue ( pat . substring ( i , i + 1 ) ) ; break ; case ':' : if ( i > 0 ) { if ( posOfNSSep == ( i - 1 ) ) { if ( startSubstring != - 1 ) { if ( startSubstring < ( i - 1 ) ) addToTokenQueue ( pat . substring ( startSubstring , i - 1 ) ) ; } isNum = false ; isAttrName = false ; startSubstring = - 1 ; posOfNSSep = - 1 ; addToTokenQueue ( pat . substring ( i - 1 , i + 1 ) ) ; break ; } else { posOfNSSep = i ; } } default : if ( - 1 == startSubstring ) { startSubstring = i ; isNum = Character . isDigit ( c ) ; } else if ( isNum ) { isNum = Character . isDigit ( c ) ; } } } if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; if ( ( - 1 != posOfNSSep ) || ( ( m_namespaceContext != null ) && ( m_namespaceContext . handlesNullPrefixes ( ) ) ) ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , nChars ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , nChars ) ) ; } } if ( 0 == m_compiler . getTokenQueueSize ( ) ) { m_processor . error ( XPATHErrorResources . ER_EMPTY_EXPRESSION , null ) ; } else if ( null != targetStrings ) { recordTokenString ( targetStrings ) ; } m_processor . m_queueMark = 0 ; } private boolean mapPatternElemPos ( int nesting , boolean isStart , boolean isAttrName ) { if ( 0 == nesting ) { if ( m_patternMapSize >= m_patternMap . length ) { int patternMap [ ] = m_patternMap ; int len = m_patternMap . length ; m_patternMap = new int [ m_patternMapSize + 100 ] ; System . arraycopy ( patternMap , 0 , m_patternMap , 0 , len ) ; } if ( ! isStart ) { m_patternMap [ m_patternMapSize - 1 ] -= TARGETEXTRA ; } m_patternMap [ m_patternMapSize ] = ( m_compiler . getTokenQueueSize ( ) - ( isAttrName ? 1 : 0 ) ) + TARGETEXTRA ; m_patternMapSize ++ ; isStart = false ; } return isStart ; } private int getTokenQueuePosFromMap ( int i ) { int pos = m_patternMap [ i ] ; return ( pos >= TARGETEXTRA ) ? ( pos - TARGETEXTRA ) : pos ; } private final void resetTokenMark ( int mark ) { int qsz = m_compiler . getTokenQueueSize ( ) ; m_processor . m_queueMark = ( mark > 0 ) ? ( ( mark <= qsz ) ? mark - 1 : mark ) : 0 ; if ( m_processor . m_queueMark < qsz ) { m_processor . m_token = ( String ) m_compiler . getTokenQueue ( ) . elementAt ( m_processor . m_queueMark ++ ) ; m_processor . m_tokenChar = m_processor . m_token . charAt ( 0 ) ; } else { m_processor . m_token = null ; m_processor . m_tokenChar = 0 ; } } final int getKeywordToken ( String key ) { int tok ; try { Integer itok = ( Integer ) Keywords . m_keywords . get ( key ) ; tok = ( null != itok ) ? itok . intValue ( ) : 0 ; } catch ( NullPointerException npe ) { tok = 0 ; } catch ( ClassCastException cce ) { tok = 0 ; } return tok ; } private void recordTokenString ( Vector targetStrings ) { int tokPos = getTokenQueuePosFromMap ( m_patternMapSize - 1 ) ; resetTokenMark ( tokPos + 1 ) ; if ( m_processor . lookahead ( '(' , 1 ) ) { int tok = getKeywordToken ( m_processor . m_token ) ; switch ( tok ) { case OpCodes . NODETYPE_COMMENT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_COMMENT ) ; break ; case OpCodes . NODETYPE_TEXT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_TEXT ) ; break ; case OpCodes . NODETYPE_NODE : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; case OpCodes . NODETYPE_ROOT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ROOT ) ; break ; case OpCodes . NODETYPE_ANYELEMENT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; case OpCodes . NODETYPE_PI : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; default : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; } } else { if ( m_processor . tokenIs ( '@' ) ) { tokPos ++ ; resetTokenMark ( tokPos + 1 ) ; } if ( m_processor . lookahead ( ':' , 1 ) ) { tokPos += 2 ; } targetStrings . addElement ( m_compiler . getTokenQueue ( ) . elementAt ( tokPos ) ) ; } } private final void addToTokenQueue ( String s ) { m_compiler . getTokenQueue ( ) . addElement ( s ) ; } private int mapNSTokens ( String pat , int startSubstring , int posOfNSSep , int posOfScan ) throws javax . xml . transform . TransformerException { String prefix = "" ; if ( ( startSubstring >= 0 ) && ( posOfNSSep >= 0 ) ) { prefix = pat . substring ( startSubstring , posOfNSSep ) ; } String uName ; if ( ( null != m_namespaceContext ) && ! prefix . equals ( "*" ) && ! prefix . equals ( "xmlns" ) ) { try { if ( prefix . length ( ) > 0 ) uName = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; else { if ( false ) { addToTokenQueue ( ":" ) ; String s = pat . substring ( posOfNSSep + 1 , posOfScan ) ; if ( s . length ( ) > 0 ) addToTokenQueue ( s ) ; return - 1 ; } else { uName = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; } } } catch ( ClassCastException cce ) { uName = m_namespaceContext . getNamespaceForPrefix ( prefix ) ; } } else { uName = prefix ; } if ( ( null != uName ) && ( uName . length ( ) > 0 ) ) { addToTokenQueue ( uName ) ; addToTokenQueue ( ":" ) ; String s = pat . substring ( posOfNSSep + 1 , posOfScan ) ; if ( s . length ( ) > 0 ) addToTokenQueue ( s ) ; } else { m_processor . error ( XPATHErrorResources . ER_PREFIX_MUST_RESOLVE , new String [ ] { prefix } ) ; } return - 1 ; } } 	0	['10', '1', '0', '6', '30', '3', '1', '6', '0', '0.611111111', '807', '0.5', '3', '0', '0.3125', '0', '0', '79.1', '11', '2.8', '0']
package org . apache . xml . utils ; public class XMLStringFactoryDefault extends XMLStringFactory { private static final XMLStringDefault EMPTY_STR = new XMLStringDefault ( "" ) ; public XMLString newstr ( String string ) { return new XMLStringDefault ( string ) ; } public XMLString newstr ( FastStringBuffer fsb , int start , int length ) { return new XMLStringDefault ( fsb . getString ( start , length ) ) ; } public XMLString newstr ( char [ ] string , int start , int length ) { return new XMLStringDefault ( new String ( string , start , length ) ) ; } public XMLString emptystr ( ) { return EMPTY_STR ; } } 	0	['6', '2', '0', '4', '10', '13', '0', '4', '5', '0.8', '41', '1', '1', '0.5', '0.4', '0', '0', '5.666666667', '1', '0.6667', '0']
package org . apache . xml . dtm . ref ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; public interface CoroutineParser { public int getParserCoroutineID ( ) ; public CoroutineManager getCoroutineManager ( ) ; public void setContentHandler ( ContentHandler handler ) ; public void setLexHandler ( org . xml . sax . ext . LexicalHandler handler ) ; public Object doParse ( InputSource source , int appCoroutine ) ; public Object doMore ( boolean parsemore , int appCoroutine ) ; public void doTerminate ( int appCoroutine ) ; public void init ( CoroutineManager co , int appCoroutineID , XMLReader parser ) ; } 	0	['8', '1', '0', '1', '8', '28', '0', '1', '8', '2', '8', '0', '0', '0', '0.28125', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . compiler ; public class XPathDumper { } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '4', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xml . dtm . ref ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMException ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . dom2dtm . DOM2DTM ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM ; import org . apache . xml . dtm . ref . sax2dtm . SAX2RTFDTM ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . XMLStringFactory ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class DTMManagerDefault extends DTMManager { private static final boolean DUMPTREE = false ; private static final boolean DEBUG = false ; protected DTM m_dtms [ ] = new DTM [ 256 ] ; int m_dtm_offsets [ ] = new int [ 256 ] ; synchronized public void addDTM ( DTM dtm , int id ) { addDTM ( dtm , id , 0 ) ; } synchronized public void addDTM ( DTM dtm , int id , int offset ) { if ( id >= IDENT_MAX_DTMS ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } int oldlen = m_dtms . length ; if ( oldlen <= id ) { int newlen = Math . min ( ( id + 256 ) , IDENT_MAX_DTMS ) ; DTM new_m_dtms [ ] = new DTM [ newlen ] ; System . arraycopy ( m_dtms , 0 , new_m_dtms , 0 , oldlen ) ; m_dtms = new_m_dtms ; int new_m_dtm_offsets [ ] = new int [ newlen ] ; System . arraycopy ( m_dtm_offsets , 0 , new_m_dtm_offsets , 0 , oldlen ) ; m_dtm_offsets = new_m_dtm_offsets ; } m_dtms [ id ] = dtm ; m_dtm_offsets [ id ] = offset ; dtm . documentRegistration ( ) ; } synchronized public int getFirstFreeDTMID ( ) { int n = m_dtms . length ; for ( int i = 1 ; i < n ; i ++ ) { if ( null == m_dtms [ i ] ) { return i ; } } return n ; } private ExpandedNameTable m_expandedNameTable = new ExpandedNameTable ( ) ; public DTMManagerDefault ( ) { } synchronized public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing ) { if ( DEBUG && null != source ) System . out . println ( "Starting " + ( unique ? "UNIQUE" : "shared" ) + " source: " + source . getSystemId ( ) ) ; XMLStringFactory xstringFactory = m_xsf ; int dtmPos = getFirstFreeDTMID ( ) ; int documentID = dtmPos << IDENT_DTM_NODE_BITS ; if ( ( null != source ) && source instanceof DOMSource ) { DOM2DTM dtm = new DOM2DTM ( this , ( DOMSource ) source , documentID , whiteSpaceFilter , xstringFactory , doIndexing ) ; addDTM ( dtm , dtmPos , 0 ) ; return dtm ; } else { boolean isSAXSource = ( null != source ) ? ( source instanceof SAXSource ) : true ; boolean isStreamSource = ( null != source ) ? ( source instanceof StreamSource ) : false ; if ( isSAXSource || isStreamSource ) { XMLReader reader ; InputSource xmlSource ; if ( null == source ) { xmlSource = null ; reader = null ; } else { reader = getXMLReader ( source ) ; xmlSource = SAXSource . sourceToInputSource ( source ) ; String urlOfSource = xmlSource . getSystemId ( ) ; if ( null != urlOfSource ) { try { urlOfSource = SystemIDResolver . getAbsoluteURI ( urlOfSource ) ; } catch ( Exception e ) { System . err . println ( "Can not absolutize URL: " + urlOfSource ) ; } xmlSource . setSystemId ( urlOfSource ) ; } } SAX2DTM dtm ; if ( source == null && unique && ! incremental && ! doIndexing ) { dtm = new SAX2RTFDTM ( this , source , documentID , whiteSpaceFilter , xstringFactory , doIndexing ) ; } else { dtm = new SAX2DTM ( this , source , documentID , whiteSpaceFilter , xstringFactory , doIndexing ) ; } addDTM ( dtm , dtmPos , 0 ) ; boolean haveXercesParser = ( null != reader ) && ( reader . getClass ( ) . getName ( ) . equals ( "org.apache.xerces.parsers.SAXParser" ) ) ; if ( haveXercesParser ) incremental = true ; if ( m_incremental && incremental ) { IncrementalSAXSource coParser = null ; if ( haveXercesParser ) { try { coParser = org . apache . xml . dtm . ref . IncrementalSAXSource_Xerces . createIncrementalSAXSource ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; coParser = null ; } } if ( coParser == null ) { if ( null == reader ) coParser = new IncrementalSAXSource_Filter ( ) ; else { IncrementalSAXSource_Filter filter = new IncrementalSAXSource_Filter ( ) ; filter . setXMLReader ( reader ) ; coParser = filter ; } } dtm . setIncrementalSAXSource ( coParser ) ; if ( null == xmlSource ) { return dtm ; } if ( null == reader . getErrorHandler ( ) ) reader . setErrorHandler ( dtm ) ; reader . setDTDHandler ( dtm ) ; try { coParser . startParse ( xmlSource ) ; } catch ( RuntimeException re ) { dtm . clearCoRoutine ( ) ; throw re ; } catch ( Exception e ) { dtm . clearCoRoutine ( ) ; throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } else { if ( null == reader ) { return dtm ; } reader . setContentHandler ( dtm ) ; reader . setDTDHandler ( dtm ) ; if ( null == reader . getErrorHandler ( ) ) reader . setErrorHandler ( dtm ) ; try { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , dtm ) ; } catch ( SAXNotRecognizedException e ) { } catch ( SAXNotSupportedException e ) { } try { reader . parse ( xmlSource ) ; } catch ( RuntimeException re ) { dtm . clearCoRoutine ( ) ; throw re ; } catch ( Exception e ) { dtm . clearCoRoutine ( ) ; throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } if ( DUMPTREE ) { System . out . println ( "Dumping SAX2DOM" ) ; dtm . dumpDTM ( System . err ) ; } return dtm ; } else { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NOT_SUPPORTED , new Object [ ] { source } ) ) ; } } } synchronized public int getDTMHandleFromNode ( org . w3c . dom . Node node ) { if ( null == node ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NODE_NON_NULL , null ) ) ; if ( node instanceof org . apache . xml . dtm . ref . DTMNodeProxy ) return ( ( org . apache . xml . dtm . ref . DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; else { int max = m_dtms . length ; for ( int i = 0 ; i < max ; i ++ ) { DTM thisDTM = m_dtms [ i ] ; if ( ( null != thisDTM ) && thisDTM instanceof DOM2DTM ) { int handle = ( ( DOM2DTM ) thisDTM ) . getHandleOfNode ( node ) ; if ( handle != DTM . NULL ) return handle ; } } Node root = node ; Node p = ( root . getNodeType ( ) == Node . ATTRIBUTE_NODE ) ? ( ( org . w3c . dom . Attr ) root ) . getOwnerElement ( ) : root . getParentNode ( ) ; for ( ; p != null ; p = p . getParentNode ( ) ) { root = p ; } DOM2DTM dtm = ( DOM2DTM ) getDTM ( new javax . xml . transform . dom . DOMSource ( root ) , false , null , true , true ) ; int handle ; if ( node instanceof org . apache . xml . dtm . ref . dom2dtm . DOM2DTMdefaultNamespaceDeclarationNode ) { handle = dtm . getHandleOfNode ( ( ( org . w3c . dom . Attr ) node ) . getOwnerElement ( ) ) ; handle = dtm . getAttributeNode ( handle , node . getNamespaceURI ( ) , node . getLocalName ( ) ) ; } else handle = ( ( DOM2DTM ) dtm ) . getHandleOfNode ( node ) ; if ( DTM . NULL == handle ) throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_RESOLVE_NODE , null ) ) ; return handle ; } } synchronized public XMLReader getXMLReader ( Source inputSource ) { try { XMLReader reader = ( inputSource instanceof SAXSource ) ? ( ( SAXSource ) inputSource ) . getXMLReader ( ) : null ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } return reader ; } catch ( org . xml . sax . SAXException se ) { throw new DTMException ( se . getMessage ( ) , se ) ; } } synchronized public DTM getDTM ( int nodeHandle ) { try { return m_dtms [ nodeHandle > > > IDENT_DTM_NODE_BITS ] ; } catch ( java . lang . ArrayIndexOutOfBoundsException e ) { if ( nodeHandle == DTM . NULL ) return null ; else throw e ; } } synchronized public int getDTMIdentity ( DTM dtm ) { if ( dtm instanceof DTMDefaultBase ) { DTMDefaultBase dtmdb = ( DTMDefaultBase ) dtm ; if ( dtmdb . getManager ( ) == this ) return dtmdb . getDTMIDs ( ) . elementAt ( 0 ) ; else return - 1 ; } int n = m_dtms . length ; for ( int i = 0 ; i < n ; i ++ ) { DTM tdtm = m_dtms [ i ] ; if ( tdtm == dtm && m_dtm_offsets [ i ] == 0 ) return i << IDENT_DTM_NODE_BITS ; } return - 1 ; } synchronized public boolean release ( DTM dtm , boolean shouldHardDelete ) { if ( DEBUG ) { System . out . println ( "Releasing " + ( shouldHardDelete ? "HARD" : "soft" ) + " dtm=" + dtm . getDocumentBaseURI ( ) ) ; } if ( dtm instanceof SAX2DTM ) { ( ( SAX2DTM ) dtm ) . clearCoRoutine ( ) ; } if ( dtm instanceof DTMDefaultBase ) { org . apache . xml . utils . SuballocatedIntVector ids = ( ( DTMDefaultBase ) dtm ) . getDTMIDs ( ) ; for ( int i = ids . size ( ) - 1 ; i >= 0 ; -- i ) m_dtms [ ids . elementAt ( i ) > > > DTMManager . IDENT_DTM_NODE_BITS ] = null ; } else { int i = getDTMIdentity ( dtm ) ; if ( i >= 0 ) { m_dtms [ i > > > DTMManager . IDENT_DTM_NODE_BITS ] = null ; } } dtm . documentRelease ( ) ; return true ; } synchronized public DTM createDocumentFragment ( ) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document doc = db . newDocument ( ) ; Node df = doc . createDocumentFragment ( ) ; return getDTM ( new DOMSource ( df ) , true , null , false , false ) ; } catch ( Exception e ) { throw new DTMException ( e ) ; } } synchronized public DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) { return null ; } synchronized public DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) { return null ; } synchronized public DTMIterator createDTMIterator ( int node ) { return null ; } synchronized public DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) { return null ; } public ExpandedNameTable getExpandedNameTable ( DTM dtm ) { return m_expandedNameTable ; } } 	0	['16', '2', '1', '27', '85', '76', '8', '22', '16', '0.8', '728', '0.8', '2', '0.558823529', '0.215909091', '1', '1', '44.1875', '25', '4.0625', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; final class ChunkedIntArray { final int slotsize = 4 ; static final int lowbits = 10 ; static final int chunkalloc = 1 << lowbits ; static final int lowmask = chunkalloc - 1 ; ChunksVector chunks = new ChunksVector ( ) ; final int fastArray [ ] = new int [ chunkalloc ] ; int lastUsed = 0 ; ChunkedIntArray ( int slotsize ) { if ( this . slotsize < slotsize ) throw new ArrayIndexOutOfBoundsException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CHUNKEDINTARRAY_NOT_SUPPORTED , new Object [ ] { Integer . toString ( slotsize ) } ) ) ; else if ( this . slotsize > slotsize ) System . out . println ( "*****WARNING: ChunkedIntArray(" + slotsize + ") wasting " + ( this . slotsize - slotsize ) + " words per slot" ) ; chunks . addElement ( fastArray ) ; } int appendSlot ( int w0 , int w1 , int w2 , int w3 ) { { final int slotsize = 4 ; int newoffset = ( lastUsed + 1 ) * slotsize ; int chunkpos = newoffset > > lowbits ; int slotpos = ( newoffset & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + 1 ] = w1 ; chunk [ slotpos + 2 ] = w2 ; chunk [ slotpos + 3 ] = w3 ; return ++ lastUsed ; } } int readEntry ( int position , int offset ) throws ArrayIndexOutOfBoundsException { { if ( offset >= slotsize ) throw new ArrayIndexOutOfBoundsException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OFFSET_BIGGER_THAN_SLOT , null ) ) ; position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = position & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; return chunk [ slotpos + offset ] ; } } int specialFind ( int startPos , int position ) { int ancestor = startPos ; while ( ancestor > 0 ) { ancestor *= slotsize ; int chunkpos = ancestor > > lowbits ; int slotpos = ancestor & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; ancestor = chunk [ slotpos + 1 ] ; if ( ancestor == position ) break ; } if ( ancestor <= 0 ) { return position ; } return - 1 ; } int slotsUsed ( ) { return lastUsed ; } void discardLast ( ) { -- lastUsed ; } void writeEntry ( int position , int offset , int value ) throws ArrayIndexOutOfBoundsException { { if ( offset >= slotsize ) throw new ArrayIndexOutOfBoundsException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OFFSET_BIGGER_THAN_SLOT , null ) ) ; position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = position & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos + offset ] = value ; } } void writeSlot ( int position , int w0 , int w1 , int w2 , int w3 ) { position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = ( position & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + 1 ] = w1 ; chunk [ slotpos + 2 ] = w2 ; chunk [ slotpos + 3 ] = w3 ; } void readSlot ( int position , int [ ] buffer ) { { position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = ( position & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; System . arraycopy ( chunk , slotpos , buffer , 0 , slotsize ) ; } } class ChunksVector { final int BLOCKSIZE = 64 ; int [ ] m_map [ ] = new int [ BLOCKSIZE ] [ ] ; int m_mapSize = BLOCKSIZE ; int pos = 0 ; ChunksVector ( ) { } final int size ( ) { return pos ; } void addElement ( int [ ] value ) { if ( pos >= m_mapSize ) { int orgMapSize = m_mapSize ; while ( pos >= m_mapSize ) m_mapSize += BLOCKSIZE ; int [ ] newMap [ ] = new int [ m_mapSize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , orgMapSize ) ; m_map = newMap ; } m_map [ pos ] = value ; pos ++ ; } final int [ ] elementAt ( int pos ) { return m_map [ pos ] ; } } } 	0	['9', '1', '0', '3', '24', '0', '2', '2', '0', '0.892857143', '353', '0', '1', '0', '0.62962963', '0', '0', '37.44444444', '3', '1.4444', '0']
package org . apache . xalan . xsltc ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . serializer . SerializationHandler ; public interface Translet { public void transform ( DOM document , SerializationHandler handler ) throws TransletException ; public void transform ( DOM document , SerializationHandler [ ] handlers ) throws TransletException ; public void transform ( DOM document , DTMAxisIterator iterator , SerializationHandler handler ) throws TransletException ; public Object addParameter ( String name , Object value ) ; public void buildKeys ( DOM document , DTMAxisIterator iterator , SerializationHandler handler , int root ) throws TransletException ; public void addAuxiliaryClass ( Class auxClass ) ; public Class getAuxiliaryClass ( String className ) ; public String [ ] getNamesArray ( ) ; public String [ ] getNamespaceArray ( ) ; } 	0	['9', '1', '0', '20', '9', '36', '16', '4', '9', '2', '9', '0', '0', '0', '0.296296296', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFNULL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . runtime . TransletLoader ; public final class ObjectType extends Type { private String _javaClassName = "java.lang.Object" ; private Class _clazz = java . lang . Object . class ; protected ObjectType ( ) { } public ObjectType ( String javaClassName ) { _javaClassName = javaClassName ; try { TransletLoader loader = new TransletLoader ( ) ; _clazz = loader . loadClass ( javaClassName ) ; } catch ( ClassNotFoundException e ) { _clazz = null ; } } public ObjectType ( Class clazz ) { _clazz = clazz ; _javaClassName = clazz . getName ( ) ; } public int hashCode ( ) { return toString ( ) . hashCode ( ) ; } public boolean equals ( Object obj ) { return ( obj instanceof ObjectType ) ; } public String getJavaClassName ( ) { return _javaClassName ; } public Class getJavaClass ( ) { return _clazz ; } public String toString ( ) { return _javaClassName ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { final StringBuffer result = new StringBuffer ( "L" ) ; result . append ( _javaClassName . replace ( '.' , '/' ) ) . append ( ';' ) ; return result . toString ( ) ; } public org . apache . bcel . generic . Type toJCType ( ) { return Util . getJCRefType ( toSignature ( ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP ) ; final BranchHandle ifNull = il . append ( new IFNULL ( null ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( _javaClassName , "toString" , "()" + STRING_SIG ) ) ) ; final BranchHandle gotobh = il . append ( new GOTO ( null ) ) ; ifNull . setTarget ( il . append ( POP ) ) ; il . append ( new PUSH ( cpg , "" ) ) ; gotobh . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz . isAssignableFrom ( _clazz ) ) methodGen . getInstructionList ( ) . append ( NOP ) ; else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getClass ( ) . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['18', '2', '0', '28', '52', '91', '6', '23', '16', '0.68627451', '271', '0.666666667', '0', '0.6875', '0.222222222', '2', '3', '13.88888889', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class BinOpExpr extends Expression { public static final int PLUS = 0 ; public static final int MINUS = 1 ; public static final int TIMES = 2 ; public static final int DIV = 3 ; public static final int MOD = 4 ; private static final String [ ] Ops = { "+" , "-" , "*" , "/" , "%" } ; private int _op ; private Expression _left , _right ; public BinOpExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public boolean hasPositionCall ( ) { if ( _left . hasPositionCall ( ) ) return true ; if ( _right . hasPositionCall ( ) ) return true ; return false ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tleft = _left . typeCheck ( stable ) ; final Type tright = _right . typeCheck ( stable ) ; final MethodType ptype = lookupPrimop ( stable , Ops [ _op ] , new MethodType ( Type . Void , tleft , tright ) ) ; if ( ptype != null ) { final Type arg1 = ( Type ) ptype . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) { _left = new CastExpr ( _left , arg1 ) ; } final Type arg2 = ( Type ) ptype . argsType ( ) . elementAt ( 1 ) ; if ( ! arg2 . identicalTo ( tright ) ) { _right = new CastExpr ( _right , arg1 ) ; } return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; switch ( _op ) { case PLUS : il . append ( _type . ADD ( ) ) ; break ; case MINUS : il . append ( _type . SUB ( ) ) ; break ; case TIMES : il . append ( _type . MUL ( ) ) ; break ; case DIV : il . append ( _type . DIV ( ) ) ; break ; case MOD : il . append ( _type . REM ( ) ) ; break ; default : ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_BINARY_OP_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } public String toString ( ) { return Ops [ _op ] + '(' + _left + ", " + _right + ')' ; } } 	0	['7', '3', '0', '14', '36', '0', '0', '14', '6', '0.814814815', '242', '0.444444444', '2', '0.934210526', '0.285714286', '2', '8', '32.28571429', '3', '1.1429', '0']
package org . apache . xml . utils ; public abstract class XMLStringFactory { public abstract XMLString newstr ( String string ) ; public abstract XMLString newstr ( FastStringBuffer string , int start , int length ) ; public abstract XMLString newstr ( char [ ] string , int start , int length ) ; public abstract XMLString emptystr ( ) ; } 	0	['5', '1', '2', '22', '6', '10', '20', '2', '5', '2', '8', '0', '0', '0', '0.4', '0', '0', '0.6', '1', '0.8', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; public class MatchPatternIterator extends LocPathIterator { protected StepPattern m_pattern ; protected int m_superAxis = - 1 ; protected DTMAxisTraverser m_traverser ; private static final boolean DEBUG = false ; MatchPatternIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_pattern = WalkerFactory . loadSteps ( this , compiler , firstStepPos , 0 ) ; boolean fromRoot = false ; boolean walkBack = false ; boolean walkDescendants = false ; boolean walkAttributes = false ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ROOT | WalkerFactory . BIT_ANY_DESCENDANT_FROM_ROOT ) ) ) fromRoot = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ANCESTOR | WalkerFactory . BIT_ANCESTOR_OR_SELF | WalkerFactory . BIT_PRECEDING | WalkerFactory . BIT_PRECEDING_SIBLING | WalkerFactory . BIT_FOLLOWING | WalkerFactory . BIT_FOLLOWING_SIBLING | WalkerFactory . BIT_PARENT | WalkerFactory . BIT_FILTER ) ) ) walkBack = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_DESCENDANT_OR_SELF | WalkerFactory . BIT_DESCENDANT | WalkerFactory . BIT_CHILD ) ) ) walkDescendants = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ATTRIBUTE | WalkerFactory . BIT_NAMESPACE ) ) ) walkAttributes = true ; if ( false || DEBUG ) { System . out . print ( "analysis: " + Integer . toBinaryString ( analysis ) ) ; System . out . println ( ", " + WalkerFactory . getAnalysisString ( analysis ) ) ; } if ( fromRoot || walkBack ) { if ( walkAttributes ) { m_superAxis = Axis . ALL ; } else { m_superAxis = Axis . DESCENDANTSFROMROOT ; } } else if ( walkDescendants ) { if ( walkAttributes ) { m_superAxis = Axis . ALLFROMNODE ; } else { m_superAxis = Axis . DESCENDANTORSELF ; } } else { m_superAxis = Axis . ALL ; } if ( false || DEBUG ) { System . out . println ( "axis: " + Axis . names [ m_superAxis ] ) ; } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_superAxis ) ; } public void detach ( ) { if ( m_allowDetach ) { m_traverser = null ; super . detach ( ) ; } } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; return m_lastFetched ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { if ( DEBUG ) System . out . println ( "m_pattern" + m_pattern . toString ( ) ) ; do { next = getNextNode ( ) ; if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next , m_execContext ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { if ( DEBUG ) { System . out . println ( "next: " + next ) ; System . out . println ( "name: " + m_cdtm . getNodeName ( next ) ) ; } incrementCurrentPos ( ) ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public short acceptNode ( int n , XPathContext xctxt ) { try { xctxt . pushCurrentNode ( n ) ; xctxt . pushIteratorRoot ( m_context ) ; if ( DEBUG ) { System . out . println ( "traverser: " + m_traverser ) ; System . out . print ( "node: " + n ) ; System . out . println ( ", " + m_cdtm . getNodeName ( n ) ) ; System . out . println ( "pattern: " + m_pattern . toString ( ) ) ; m_pattern . debugWhatToShow ( m_pattern . getWhatToShow ( ) ) ; } XObject score = m_pattern . execute ( xctxt ) ; if ( DEBUG ) { System . out . println ( "score: " + score ) ; System . out . println ( "skip: " + ( score == NodeTest . SCORE_NONE ) ) ; } return ( score == NodeTest . SCORE_NONE ) ? DTMIterator . FILTER_SKIP : DTMIterator . FILTER_ACCEPT ; } catch ( javax . xml . transform . TransformerException se ) { throw new RuntimeException ( se . getMessage ( ) ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popIteratorRoot ( ) ; } } } 	0	['6', '5', '0', '11', '25', '3', '1', '11', '4', '0.75', '261', '1', '2', '0.961538462', '0.4', '1', '6', '41.83333333', '10', '2.8333', '0']
package org . apache . xalan . templates ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPath ; import org . apache . xpath . axes . AxesWalker ; import org . apache . xpath . axes . FilterExprIteratorSimple ; import org . apache . xpath . axes . FilterExprWalker ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . axes . SelfIteratorNoPredicate ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . axes . WalkingIterator ; import org . apache . xpath . operations . Variable ; import org . apache . xpath . operations . VariableSafeAbsRef ; public class RedundentExprEliminator extends XSLTVisitor { Vector m_paths ; Vector m_absPaths ; boolean m_isSameContext ; AbsPathChecker m_absPathChecker = new AbsPathChecker ( ) ; static int m_uniquePsuedoVarID = 1 ; static final String PSUEDOVARNAMESPACE = Constants . S_VENDORURL + "/xalan/psuedovar" ; public static boolean DEBUG = false ; public static boolean DIAGNOSE_NUM_PATHS_REDUCED = false ; public static boolean DIAGNOSE_MULTISTEPLIST = false ; VarNameCollector m_varNameCollector = new VarNameCollector ( ) ; public RedundentExprEliminator ( ) { m_isSameContext = true ; m_absPaths = new Vector ( ) ; m_paths = null ; } public void eleminateRedundentLocals ( ElemTemplateElement psuedoVarRecipient ) { eleminateRedundent ( psuedoVarRecipient , m_paths ) ; } public void eleminateRedundentGlobals ( StylesheetRoot stylesheet ) { eleminateRedundent ( stylesheet , m_absPaths ) ; } protected void eleminateRedundent ( ElemTemplateElement psuedoVarRecipient , Vector paths ) { int n = paths . size ( ) ; int numPathsEliminated = 0 ; int numUniquePathsEliminated = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner owner = ( ExpressionOwner ) paths . elementAt ( i ) ; if ( null != owner ) { int found = findAndEliminateRedundant ( i + 1 , i , owner , psuedoVarRecipient , paths ) ; if ( found > 0 ) numUniquePathsEliminated ++ ; numPathsEliminated += found ; } } eleminateSharedPartialPaths ( psuedoVarRecipient , paths ) ; if ( DIAGNOSE_NUM_PATHS_REDUCED ) diagnoseNumPaths ( paths , numPathsEliminated , numUniquePathsEliminated ) ; } protected void eleminateSharedPartialPaths ( ElemTemplateElement psuedoVarRecipient , Vector paths ) { MultistepExprHolder list = createMultistepExprList ( paths ) ; if ( null != list ) { if ( DIAGNOSE_MULTISTEPLIST ) list . diagnose ( ) ; boolean isGlobal = ( paths == m_absPaths ) ; int longestStepsCount = list . m_stepCount ; for ( int i = longestStepsCount - 1 ; i >= 1 ; i -- ) { MultistepExprHolder next = list ; while ( null != next ) { if ( next . m_stepCount < i ) break ; list = matchAndEliminatePartialPaths ( next , list , isGlobal , i , psuedoVarRecipient ) ; next = next . m_next ; } } } } protected MultistepExprHolder matchAndEliminatePartialPaths ( MultistepExprHolder testee , MultistepExprHolder head , boolean isGlobal , int lengthToTest , ElemTemplateElement varScope ) { if ( null == testee . m_exprOwner ) return head ; WalkingIterator iter1 = ( WalkingIterator ) testee . m_exprOwner . getExpression ( ) ; if ( partialIsVariable ( testee , lengthToTest ) ) return head ; MultistepExprHolder matchedPaths = null ; MultistepExprHolder matchedPathsTail = null ; MultistepExprHolder meh = head ; while ( null != meh ) { if ( ( meh != testee ) && ( null != meh . m_exprOwner ) ) { WalkingIterator iter2 = ( WalkingIterator ) meh . m_exprOwner . getExpression ( ) ; if ( stepsEqual ( iter1 , iter2 , lengthToTest ) ) { if ( null == matchedPaths ) { try { matchedPaths = ( MultistepExprHolder ) testee . clone ( ) ; testee . m_exprOwner = null ; } catch ( CloneNotSupportedException cnse ) { } matchedPathsTail = matchedPaths ; matchedPathsTail . m_next = null ; } try { matchedPathsTail . m_next = ( MultistepExprHolder ) meh . clone ( ) ; meh . m_exprOwner = null ; } catch ( CloneNotSupportedException cnse ) { } matchedPathsTail = matchedPathsTail . m_next ; matchedPathsTail . m_next = null ; } } meh = meh . m_next ; } int matchCount = 0 ; if ( null != matchedPaths ) { ElemTemplateElement root = isGlobal ? varScope : findCommonAncestor ( matchedPaths ) ; WalkingIterator sharedIter = ( WalkingIterator ) matchedPaths . m_exprOwner . getExpression ( ) ; WalkingIterator newIter = createIteratorFromSteps ( sharedIter , lengthToTest ) ; ElemVariable var = createPsuedoVarDecl ( root , newIter , isGlobal ) ; if ( DIAGNOSE_MULTISTEPLIST ) System . err . println ( "Created var: " + var . getName ( ) + ( isGlobal ? "(Global)" : "" ) ) ; while ( null != matchedPaths ) { ExpressionOwner owner = matchedPaths . m_exprOwner ; WalkingIterator iter = ( WalkingIterator ) owner . getExpression ( ) ; if ( DIAGNOSE_MULTISTEPLIST ) diagnoseLineNumber ( iter ) ; LocPathIterator newIter2 = changePartToRef ( var . getName ( ) , iter , lengthToTest , isGlobal ) ; owner . setExpression ( newIter2 ) ; matchedPaths = matchedPaths . m_next ; } } if ( DIAGNOSE_MULTISTEPLIST ) diagnoseMultistepList ( matchCount , lengthToTest , isGlobal ) ; return head ; } boolean partialIsVariable ( MultistepExprHolder testee , int lengthToTest ) { if ( 1 == lengthToTest ) { WalkingIterator wi = ( WalkingIterator ) testee . m_exprOwner . getExpression ( ) ; if ( wi . getFirstWalker ( ) instanceof FilterExprWalker ) return true ; } return false ; } protected void diagnoseLineNumber ( Expression expr ) { ElemTemplateElement e = getElemFromExpression ( expr ) ; System . err . println ( "   " + e . getSystemId ( ) + " Line " + e . getLineNumber ( ) ) ; } protected ElemTemplateElement findCommonAncestor ( MultistepExprHolder head ) { int numExprs = head . getLength ( ) ; ElemTemplateElement [ ] elems = new ElemTemplateElement [ numExprs ] ; int [ ] ancestorCounts = new int [ numExprs ] ; MultistepExprHolder next = head ; int shortestAncestorCount = 10000 ; for ( int i = 0 ; i < numExprs ; i ++ ) { ElemTemplateElement elem = getElemFromExpression ( next . m_exprOwner . getExpression ( ) ) ; elems [ i ] = elem ; int numAncestors = countAncestors ( elem ) ; ancestorCounts [ i ] = numAncestors ; if ( numAncestors < shortestAncestorCount ) { shortestAncestorCount = numAncestors ; } next = next . m_next ; } for ( int i = 0 ; i < numExprs ; i ++ ) { if ( ancestorCounts [ i ] > shortestAncestorCount ) { int numStepCorrection = ancestorCounts [ i ] - shortestAncestorCount ; for ( int j = 0 ; j < numStepCorrection ; j ++ ) { elems [ i ] = elems [ i ] . getParentElem ( ) ; } } } ElemTemplateElement first = null ; while ( shortestAncestorCount -- >= 0 ) { boolean areEqual = true ; first = elems [ 0 ] ; for ( int i = 1 ; i < numExprs ; i ++ ) { if ( first != elems [ i ] ) { areEqual = false ; break ; } } if ( areEqual && isNotSameAsOwner ( head , first ) && first . canAcceptVariables ( ) ) { if ( DIAGNOSE_MULTISTEPLIST ) { System . err . print ( first . getClass ( ) . getName ( ) ) ; System . err . println ( " at   " + first . getSystemId ( ) + " Line " + first . getLineNumber ( ) ) ; } return first ; } for ( int i = 0 ; i < numExprs ; i ++ ) { elems [ i ] = elems [ i ] . getParentElem ( ) ; } } assertion ( false , "Could not find common ancestor!!!" ) ; return null ; } protected boolean isNotSameAsOwner ( MultistepExprHolder head , ElemTemplateElement ete ) { MultistepExprHolder next = head ; while ( null != next ) { ElemTemplateElement elemOwner = getElemFromExpression ( next . m_exprOwner . getExpression ( ) ) ; if ( elemOwner == ete ) return false ; next = next . m_next ; } return true ; } protected int countAncestors ( ElemTemplateElement elem ) { int count = 0 ; while ( null != elem ) { count ++ ; elem = elem . getParentElem ( ) ; } return count ; } protected void diagnoseMultistepList ( int matchCount , int lengthToTest , boolean isGlobal ) { if ( matchCount > 0 ) { System . err . print ( "Found multistep matches: " + matchCount + ", " + lengthToTest + " length" ) ; if ( isGlobal ) System . err . println ( " (global)" ) ; else System . err . println ( ) ; } } protected LocPathIterator changePartToRef ( final QName uniquePsuedoVarName , WalkingIterator wi , final int numSteps , final boolean isGlobal ) { Variable var = new Variable ( ) ; var . setQName ( uniquePsuedoVarName ) ; var . setIsGlobal ( isGlobal ) ; if ( isGlobal ) { ElemTemplateElement elem = getElemFromExpression ( wi ) ; StylesheetRoot root = elem . getStylesheetRoot ( ) ; Vector vars = root . getVariablesAndParamsComposed ( ) ; var . setIndex ( vars . size ( ) - 1 ) ; } AxesWalker walker = wi . getFirstWalker ( ) ; for ( int i = 0 ; i < numSteps ; i ++ ) { assertion ( null != walker , "Walker should not be null!" ) ; walker = walker . getNextWalker ( ) ; } if ( null != walker ) { FilterExprWalker few = new FilterExprWalker ( wi ) ; few . setInnerExpression ( var ) ; few . exprSetParent ( wi ) ; few . setNextWalker ( walker ) ; walker . setPrevWalker ( few ) ; wi . setFirstWalker ( few ) ; return wi ; } else { FilterExprIteratorSimple feis = new FilterExprIteratorSimple ( var ) ; feis . exprSetParent ( wi . exprGetParent ( ) ) ; return feis ; } } protected WalkingIterator createIteratorFromSteps ( final WalkingIterator wi , int numSteps ) { WalkingIterator newIter = new WalkingIterator ( wi . getPrefixResolver ( ) ) ; try { AxesWalker walker = ( AxesWalker ) wi . getFirstWalker ( ) . clone ( ) ; newIter . setFirstWalker ( walker ) ; walker . setLocPathIterator ( newIter ) ; for ( int i = 1 ; i < numSteps ; i ++ ) { AxesWalker next = ( AxesWalker ) walker . getNextWalker ( ) . clone ( ) ; walker . setNextWalker ( next ) ; next . setLocPathIterator ( newIter ) ; walker = next ; } walker . setNextWalker ( null ) ; } catch ( CloneNotSupportedException cnse ) { throw new WrappedRuntimeException ( cnse ) ; } return newIter ; } protected boolean stepsEqual ( WalkingIterator iter1 , WalkingIterator iter2 , int numSteps ) { AxesWalker aw1 = iter1 . getFirstWalker ( ) ; AxesWalker aw2 = iter2 . getFirstWalker ( ) ; for ( int i = 0 ; ( i < numSteps ) ; i ++ ) { if ( ( null == aw1 ) || ( null == aw2 ) ) return false ; if ( ! aw1 . deepEquals ( aw2 ) ) return false ; aw1 = aw1 . getNextWalker ( ) ; aw2 = aw2 . getNextWalker ( ) ; } assertion ( ( null != aw1 ) || ( null != aw2 ) , "Total match is incorrect!" ) ; return true ; } protected MultistepExprHolder createMultistepExprList ( Vector paths ) { MultistepExprHolder first = null ; int n = paths . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner eo = ( ExpressionOwner ) paths . elementAt ( i ) ; if ( null == eo ) continue ; LocPathIterator lpi = ( LocPathIterator ) eo . getExpression ( ) ; int numPaths = countSteps ( lpi ) ; if ( numPaths > 1 ) { if ( null == first ) first = new MultistepExprHolder ( eo , numPaths , null ) ; else first = first . addInSortedOrder ( eo , numPaths ) ; } } if ( ( null == first ) || ( first . getLength ( ) <= 1 ) ) return null ; else return first ; } protected int findAndEliminateRedundant ( int start , int firstOccuranceIndex , ExpressionOwner firstOccuranceOwner , ElemTemplateElement psuedoVarRecipient , Vector paths ) throws org . w3c . dom . DOMException { MultistepExprHolder head = null ; MultistepExprHolder tail = null ; int numPathsFound = 0 ; int n = paths . size ( ) ; Expression expr1 = firstOccuranceOwner . getExpression ( ) ; if ( DEBUG ) assertIsLocPathIterator ( expr1 , firstOccuranceOwner ) ; boolean isGlobal = ( paths == m_absPaths ) ; LocPathIterator lpi = ( LocPathIterator ) expr1 ; int stepCount = countSteps ( lpi ) ; for ( int j = start ; j < n ; j ++ ) { ExpressionOwner owner2 = ( ExpressionOwner ) paths . elementAt ( j ) ; if ( null != owner2 ) { Expression expr2 = owner2 . getExpression ( ) ; boolean isEqual = expr2 . deepEquals ( lpi ) ; if ( isEqual ) { LocPathIterator lpi2 = ( LocPathIterator ) expr2 ; if ( null == head ) { head = new MultistepExprHolder ( firstOccuranceOwner , stepCount , null ) ; tail = head ; numPathsFound ++ ; } tail . m_next = new MultistepExprHolder ( owner2 , stepCount , null ) ; tail = tail . m_next ; paths . setElementAt ( null , j ) ; numPathsFound ++ ; } } } if ( ( 0 == numPathsFound ) && isGlobal ) { head = new MultistepExprHolder ( firstOccuranceOwner , stepCount , null ) ; numPathsFound ++ ; } if ( null != head ) { ElemTemplateElement root = isGlobal ? psuedoVarRecipient : findCommonAncestor ( head ) ; LocPathIterator sharedIter = ( LocPathIterator ) head . m_exprOwner . getExpression ( ) ; ElemVariable var = createPsuedoVarDecl ( root , sharedIter , isGlobal ) ; if ( DIAGNOSE_MULTISTEPLIST ) System . err . println ( "Created var: " + var . getName ( ) + ( isGlobal ? "(Global)" : "" ) ) ; QName uniquePsuedoVarName = var . getName ( ) ; while ( null != head ) { ExpressionOwner owner = head . m_exprOwner ; if ( DIAGNOSE_MULTISTEPLIST ) diagnoseLineNumber ( owner . getExpression ( ) ) ; changeToVarRef ( uniquePsuedoVarName , owner , paths , root ) ; head = head . m_next ; } paths . setElementAt ( var . getSelect ( ) , firstOccuranceIndex ) ; } return numPathsFound ; } protected int oldFindAndEliminateRedundant ( int start , int firstOccuranceIndex , ExpressionOwner firstOccuranceOwner , ElemTemplateElement psuedoVarRecipient , Vector paths ) throws org . w3c . dom . DOMException { QName uniquePsuedoVarName = null ; boolean foundFirst = false ; int numPathsFound = 0 ; int n = paths . size ( ) ; Expression expr1 = firstOccuranceOwner . getExpression ( ) ; if ( DEBUG ) assertIsLocPathIterator ( expr1 , firstOccuranceOwner ) ; boolean isGlobal = ( paths == m_absPaths ) ; LocPathIterator lpi = ( LocPathIterator ) expr1 ; for ( int j = start ; j < n ; j ++ ) { ExpressionOwner owner2 = ( ExpressionOwner ) paths . elementAt ( j ) ; if ( null != owner2 ) { Expression expr2 = owner2 . getExpression ( ) ; boolean isEqual = expr2 . deepEquals ( lpi ) ; if ( isEqual ) { LocPathIterator lpi2 = ( LocPathIterator ) expr2 ; if ( ! foundFirst ) { foundFirst = true ; ElemVariable var = createPsuedoVarDecl ( psuedoVarRecipient , lpi , isGlobal ) ; if ( null == var ) return 0 ; uniquePsuedoVarName = var . getName ( ) ; changeToVarRef ( uniquePsuedoVarName , firstOccuranceOwner , paths , psuedoVarRecipient ) ; paths . setElementAt ( var . getSelect ( ) , firstOccuranceIndex ) ; numPathsFound ++ ; } changeToVarRef ( uniquePsuedoVarName , owner2 , paths , psuedoVarRecipient ) ; paths . setElementAt ( null , j ) ; numPathsFound ++ ; } } } if ( ( 0 == numPathsFound ) && ( paths == m_absPaths ) ) { ElemVariable var = createPsuedoVarDecl ( psuedoVarRecipient , lpi , true ) ; if ( null == var ) return 0 ; uniquePsuedoVarName = var . getName ( ) ; changeToVarRef ( uniquePsuedoVarName , firstOccuranceOwner , paths , psuedoVarRecipient ) ; paths . setElementAt ( var . getSelect ( ) , firstOccuranceIndex ) ; numPathsFound ++ ; } return numPathsFound ; } protected int countSteps ( LocPathIterator lpi ) { if ( lpi instanceof WalkingIterator ) { WalkingIterator wi = ( WalkingIterator ) lpi ; AxesWalker aw = wi . getFirstWalker ( ) ; int count = 0 ; while ( null != aw ) { count ++ ; aw = aw . getNextWalker ( ) ; } return count ; } else return 1 ; } protected void changeToVarRef ( QName varName , ExpressionOwner owner , Vector paths , ElemTemplateElement psuedoVarRecipient ) { Variable varRef = ( paths == m_absPaths ) ? new VariableSafeAbsRef ( ) : new Variable ( ) ; varRef . setQName ( varName ) ; if ( paths == m_absPaths ) { StylesheetRoot root = ( StylesheetRoot ) psuedoVarRecipient ; Vector globalVars = root . getVariablesAndParamsComposed ( ) ; varRef . setIndex ( globalVars . size ( ) - 1 ) ; varRef . setIsGlobal ( true ) ; } owner . setExpression ( varRef ) ; } protected ElemVariable createPsuedoVarDecl ( ElemTemplateElement psuedoVarRecipient , LocPathIterator lpi , boolean isGlobal ) throws org . w3c . dom . DOMException { QName uniquePsuedoVarName = new QName ( PSUEDOVARNAMESPACE , "#" + m_uniquePsuedoVarID ) ; m_uniquePsuedoVarID ++ ; if ( isGlobal ) { return createGlobalPsuedoVarDecl ( uniquePsuedoVarName , ( StylesheetRoot ) psuedoVarRecipient , lpi ) ; } else return createLocalPsuedoVarDecl ( uniquePsuedoVarName , psuedoVarRecipient , lpi ) ; } protected ElemVariable createGlobalPsuedoVarDecl ( QName uniquePsuedoVarName , StylesheetRoot stylesheetRoot , LocPathIterator lpi ) throws org . w3c . dom . DOMException { ElemVariable psuedoVar = new ElemVariable ( ) ; psuedoVar . setIsTopLevel ( true ) ; XPath xpath = new XPath ( lpi ) ; psuedoVar . setSelect ( xpath ) ; psuedoVar . setName ( uniquePsuedoVarName ) ; Vector globalVars = stylesheetRoot . getVariablesAndParamsComposed ( ) ; psuedoVar . setIndex ( globalVars . size ( ) ) ; globalVars . addElement ( psuedoVar ) ; return psuedoVar ; } protected ElemVariable createLocalPsuedoVarDecl ( QName uniquePsuedoVarName , ElemTemplateElement psuedoVarRecipient , LocPathIterator lpi ) throws org . w3c . dom . DOMException { ElemVariable psuedoVar = new ElemVariablePsuedo ( ) ; XPath xpath = new XPath ( lpi ) ; psuedoVar . setSelect ( xpath ) ; psuedoVar . setName ( uniquePsuedoVarName ) ; ElemVariable var = addVarDeclToElem ( psuedoVarRecipient , lpi , psuedoVar ) ; lpi . exprSetParent ( var ) ; return var ; } protected ElemVariable addVarDeclToElem ( ElemTemplateElement psuedoVarRecipient , LocPathIterator lpi , ElemVariable psuedoVar ) throws org . w3c . dom . DOMException { ElemTemplateElement ete = psuedoVarRecipient . getFirstChildElem ( ) ; lpi . callVisitors ( null , m_varNameCollector ) ; if ( m_varNameCollector . getVarCount ( ) > 0 ) { ElemTemplateElement baseElem = getElemFromExpression ( lpi ) ; ElemVariable varElem = getPrevVariableElem ( baseElem ) ; while ( null != varElem ) { if ( m_varNameCollector . doesOccur ( varElem . getName ( ) ) ) { psuedoVarRecipient = varElem . getParentElem ( ) ; ete = varElem . getNextSiblingElem ( ) ; break ; } varElem = getPrevVariableElem ( varElem ) ; } } if ( ( null != ete ) && ( Constants . ELEMNAME_PARAMVARIABLE == ete . getXSLToken ( ) ) ) { if ( isParam ( lpi ) ) return null ; while ( null != ete ) { ete = ete . getNextSiblingElem ( ) ; if ( ( null != ete ) && Constants . ELEMNAME_PARAMVARIABLE != ete . getXSLToken ( ) ) break ; } } psuedoVarRecipient . insertBefore ( psuedoVar , ete ) ; m_varNameCollector . reset ( ) ; return psuedoVar ; } protected boolean isParam ( ExpressionNode expr ) { while ( null != expr ) { if ( expr instanceof ElemTemplateElement ) break ; expr = expr . exprGetParent ( ) ; } if ( null != expr ) { ElemTemplateElement ete = ( ElemTemplateElement ) expr ; while ( null != ete ) { int type = ete . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_PARAMVARIABLE : return true ; case Constants . ELEMNAME_TEMPLATE : case Constants . ELEMNAME_STYLESHEET : return false ; } ete = ete . getParentElem ( ) ; } } return false ; } protected ElemVariable getPrevVariableElem ( ElemTemplateElement elem ) { while ( null != ( elem = getPrevElementWithinContext ( elem ) ) ) { int type = elem . getXSLToken ( ) ; if ( ( Constants . ELEMNAME_VARIABLE == type ) || ( Constants . ELEMNAME_PARAMVARIABLE == type ) ) { return ( ElemVariable ) elem ; } } return null ; } protected ElemTemplateElement getPrevElementWithinContext ( ElemTemplateElement elem ) { ElemTemplateElement prev = elem . getPreviousSiblingElem ( ) ; if ( null == prev ) prev = elem . getParentElem ( ) ; if ( null != prev ) { int type = prev . getXSLToken ( ) ; if ( ( Constants . ELEMNAME_FOREACH == type ) || ( Constants . ELEMNAME_TEMPLATE == type ) || ( Constants . ELEMNAME_STYLESHEET == type ) ) { prev = null ; } } return prev ; } protected ElemTemplateElement getElemFromExpression ( Expression expr ) { ExpressionNode parent = expr . exprGetParent ( ) ; while ( null != parent ) { if ( parent instanceof ElemTemplateElement ) return ( ElemTemplateElement ) parent ; parent = parent . exprGetParent ( ) ; } throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ASSERT_NO_TEMPLATE_PARENT , null ) ) ; } public boolean isAbsolute ( LocPathIterator path ) { int analysis = path . getAnalysisBits ( ) ; boolean isAbs = ( WalkerFactory . isSet ( analysis , WalkerFactory . BIT_ROOT ) || WalkerFactory . isSet ( analysis , WalkerFactory . BIT_ANY_DESCENDANT_FROM_ROOT ) ) ; if ( isAbs ) { isAbs = m_absPathChecker . checkAbsolute ( path ) ; } return isAbs ; } public boolean visitLocationPath ( ExpressionOwner owner , LocPathIterator path ) { if ( path instanceof SelfIteratorNoPredicate ) { return true ; } else if ( path instanceof WalkingIterator ) { WalkingIterator wi = ( WalkingIterator ) path ; AxesWalker aw = wi . getFirstWalker ( ) ; if ( ( aw instanceof FilterExprWalker ) && ( null == aw . getNextWalker ( ) ) ) { FilterExprWalker few = ( FilterExprWalker ) aw ; Expression exp = few . getInnerExpression ( ) ; if ( exp instanceof Variable ) return true ; } } if ( isAbsolute ( path ) && ( null != m_absPaths ) ) { if ( DEBUG ) validateNewAddition ( m_absPaths , owner , path ) ; m_absPaths . addElement ( owner ) ; } else if ( m_isSameContext && ( null != m_paths ) ) { if ( DEBUG ) validateNewAddition ( m_paths , owner , path ) ; m_paths . addElement ( owner ) ; } return true ; } public boolean visitPredicate ( ExpressionOwner owner , Expression pred ) { boolean savedIsSame = m_isSameContext ; m_isSameContext = false ; pred . callVisitors ( owner , this ) ; m_isSameContext = savedIsSame ; return false ; } boolean visitTopLevelInstruction ( ElemTemplateElement elem ) { int type = elem . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEMPLATE : return visitInstruction ( elem ) ; default : return true ; } } boolean visitInstruction ( ElemTemplateElement elem ) { int type = elem . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_TEMPLATE : case Constants . ELEMNAME_FOREACH : { if ( type == Constants . ELEMNAME_FOREACH ) { ElemForEach efe = ( ElemForEach ) elem ; Expression select = efe . getSelect ( ) ; select . callVisitors ( efe , this ) ; } Vector savedPaths = m_paths ; m_paths = new Vector ( ) ; elem . callChildVisitors ( this , false ) ; eleminateRedundentLocals ( elem ) ; m_paths = savedPaths ; return false ; } case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_SORT : boolean savedIsSame = m_isSameContext ; m_isSameContext = false ; elem . callChildVisitors ( this ) ; m_isSameContext = savedIsSame ; return false ; default : return true ; } } protected void diagnoseNumPaths ( Vector paths , int numPathsEliminated , int numUniquePathsEliminated ) { if ( numPathsEliminated > 0 ) { if ( paths == m_paths ) { System . err . println ( "Eliminated " + numPathsEliminated + " total paths!" ) ; System . err . println ( "Consolodated " + numUniquePathsEliminated + " redundent paths!" ) ; } else { System . err . println ( "Eliminated " + numPathsEliminated + " total global paths!" ) ; System . err . println ( "Consolodated " + numUniquePathsEliminated + " redundent global paths!" ) ; } } } private final void assertIsLocPathIterator ( Expression expr1 , ExpressionOwner eo ) throws RuntimeException { if ( ! ( expr1 instanceof LocPathIterator ) ) { String errMsg ; if ( expr1 instanceof Variable ) { errMsg = "Programmer's assertion: expr1 not an iterator: " + ( ( Variable ) expr1 ) . getQName ( ) ; } else { errMsg = "Programmer's assertion: expr1 not an iterator: " + expr1 . getClass ( ) . getName ( ) ; } throw new RuntimeException ( errMsg + ", " + eo . getClass ( ) . getName ( ) + " " + expr1 . exprGetParent ( ) ) ; } } private static void validateNewAddition ( Vector paths , ExpressionOwner owner , LocPathIterator path ) throws RuntimeException { assertion ( owner . getExpression ( ) == path , "owner.getExpression() != path!!!" ) ; int n = paths . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner ew = ( ExpressionOwner ) paths . elementAt ( i ) ; assertion ( ew != owner , "duplicate owner on the list!!!" ) ; assertion ( ew . getExpression ( ) != path , "duplicate expression on the list!!!" ) ; } } protected static void assertion ( boolean b , String msg ) { if ( ! b ) { throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , new Object [ ] { msg } ) ) ; } } class MultistepExprHolder implements Cloneable { ExpressionOwner m_exprOwner ; final int m_stepCount ; MultistepExprHolder m_next ; public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } MultistepExprHolder ( ExpressionOwner exprOwner , int stepCount , MultistepExprHolder next ) { m_exprOwner = exprOwner ; assertion ( null != m_exprOwner , "exprOwner can not be null!" ) ; m_stepCount = stepCount ; m_next = next ; } MultistepExprHolder addInSortedOrder ( ExpressionOwner exprOwner , int stepCount ) { MultistepExprHolder first = this ; MultistepExprHolder next = this ; MultistepExprHolder prev = null ; while ( null != next ) { if ( stepCount >= next . m_stepCount ) { MultistepExprHolder newholder = new MultistepExprHolder ( exprOwner , stepCount , next ) ; if ( null == prev ) first = newholder ; else prev . m_next = newholder ; return first ; } prev = next ; next = next . m_next ; } prev . m_next = new MultistepExprHolder ( exprOwner , stepCount , null ) ; return first ; } MultistepExprHolder unlink ( MultistepExprHolder itemToRemove ) { MultistepExprHolder first = this ; MultistepExprHolder next = this ; MultistepExprHolder prev = null ; while ( null != next ) { if ( next == itemToRemove ) { if ( null == prev ) first = next . m_next ; else prev . m_next = next . m_next ; next . m_next = null ; return first ; } prev = next ; next = next . m_next ; } assertion ( false , "unlink failed!!!" ) ; return null ; } int getLength ( ) { int count = 0 ; MultistepExprHolder next = this ; while ( null != next ) { count ++ ; next = next . m_next ; } return count ; } protected void diagnose ( ) { System . err . print ( "Found multistep iterators: " + this . getLength ( ) + "  " ) ; MultistepExprHolder next = this ; while ( null != next ) { System . err . print ( "" + next . m_stepCount ) ; next = next . m_next ; if ( null != next ) System . err . print ( ", " ) ; } System . err . println ( ) ; } } } 	0	['38', '3', '0', '27', '128', '607', '1', '27', '6', '0.9', '1849', '0', '2', '0.357142857', '0.194594595', '0', '0', '47.39473684', '15', '3.7632', '0']
package org . apache . xalan . lib . sql ; import java . sql . SQLException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; public class SQLErrorDocument extends DTMDocument { private static final String S_EXT_ERROR = "ext-error" ; private static final String S_SQL_ERROR = "sql-error" ; private static final String S_MESSAGE = "message" ; private static final String S_CODE = "code" ; private int m_ErrorExt_TypeID = DTM . NULL ; private int m_Message_TypeID = DTM . NULL ; private int m_Code_TypeID = DTM . NULL ; private int m_SQLError_TypeID = DTM . NULL ; private int m_rootID = DTM . NULL ; private int m_extErrorID = DTM . NULL ; private int m_MainMessageID = DTM . NULL ; public SQLErrorDocument ( DTMManager mgr , int ident , SQLException error ) { super ( mgr , ident ) ; createExpandedNameTable ( ) ; buildBasicStructure ( error ) ; int sqlError = addElement ( 2 , m_SQLError_TypeID , m_extErrorID , m_MainMessageID ) ; int element = DTM . NULL ; element = addElementWithData ( new Integer ( error . getErrorCode ( ) ) , 3 , m_Code_TypeID , sqlError , element ) ; element = addElementWithData ( error . getLocalizedMessage ( ) , 3 , m_Message_TypeID , sqlError , element ) ; } public SQLErrorDocument ( DTMManager mgr , int ident , Exception error ) { super ( mgr , ident ) ; createExpandedNameTable ( ) ; buildBasicStructure ( error ) ; } private void buildBasicStructure ( Exception e ) { m_rootID = addElement ( 0 , m_Document_TypeID , DTM . NULL , DTM . NULL ) ; m_extErrorID = addElement ( 1 , m_ErrorExt_TypeID , m_rootID , DTM . NULL ) ; m_MainMessageID = addElementWithData ( e . getLocalizedMessage ( ) , 2 , m_Message_TypeID , m_extErrorID , DTM . NULL ) ; } protected void createExpandedNameTable ( ) { super . createExpandedNameTable ( ) ; m_ErrorExt_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_EXT_ERROR , DTM . ELEMENT_NODE ) ; m_SQLError_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SQL_ERROR , DTM . ELEMENT_NODE ) ; m_Message_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_MESSAGE , DTM . ELEMENT_NODE ) ; m_Code_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CODE , DTM . ELEMENT_NODE ) ; } } 	0	['4', '5', '0', '4', '13', '0', '1', '3', '2', '0.636363636', '179', '1', '0', '0.989528796', '0.55', '1', '1', '41', '1', '0.5', '0']
package org . apache . xml . res ; public class XMLErrorResources_sv extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Funktion inte understödd:" } , { ER_CANNOT_OVERWRITE_CAUSE , "Kan inte skriva över orsak" } , { ER_NO_DEFAULT_IMPL , "Standardimplementering saknas i:" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) understöds för närvarande inte" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset större än fack" } , { ER_COROUTINE_NOT_AVAIL , "Sidorutin inte tillgänglig, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager mottog co_exit()-förfrågan" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() misslyckades" } , { ER_COROUTINE_PARAM , "Sidorutin fick parameterfel ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nOVÄNTAT: Parser doTerminate-svar {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse får inte anropas medan tolkning sker" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fel: typad upprepare för axel {0} inte implementerad" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fel: upprepare för axel {0} inte implementerad" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Uppreparklon understöds inte" } , { ER_UNKNOWN_AXIS_TYPE , "Okänd axeltraverstyp: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Axeltravers understöds inte: {0}" } , { ER_NO_DTMIDS_AVAIL , "Inga fler DTM-IDs är tillgängliga" } , { ER_NOT_SUPPORTED , "Understöds inte: {0}" } , { ER_NODE_NON_NULL , "Nod måste vara icke-null för getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Kunde inte lösa nod till ett handtag" } , { ER_STARTPARSE_WHILE_PARSING , "startParse får inte anropas medan tolkning sker" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse behöver en SAXParser som är icke-null" } , { ER_COULD_NOT_INIT_PARSER , "kunde inte initialisera tolk med" } , { ER_EXCEPTION_CREATING_POOL , "undantag skapar ny instans för pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Väg innehåller ogiltig flyktsekvens" } , { ER_SCHEME_REQUIRED , "Schema krävs!" } , { ER_NO_SCHEME_IN_URI , "Schema saknas i URI: {0}" } , { ER_NO_SCHEME_INURI , "Schema saknas i URI" } , { ER_PATH_INVALID_CHAR , "Väg innehåller ogiltigt tecken: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Kan inte sätta schema från null-sträng" } , { ER_SCHEME_NOT_CONFORMANT , "Schemat är inte likformigt." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Värd är inte en välformulerad adress" } , { ER_PORT_WHEN_HOST_NULL , "Port kan inte sättas när värd är null" } , { ER_INVALID_PORT , "Ogiltigt portnummer" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment kan bara sättas för en allmän URI" } , { ER_FRAG_WHEN_PATH_NULL , "Fragment kan inte sättas när väg är null" } , { ER_FRAG_INVALID_CHAR , "Fragment innehåller ogiltigt tecken" } , { ER_PARSER_IN_USE , "Tolk används redan" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Kan inte ändra {0} {1} medan tolkning sker" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Självorsakande inte tillåten" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo får inte anges om värden inte är angiven" } , { ER_NO_PORT_IF_NO_HOST , "Port får inte anges om värden inte är angiven" } , { ER_NO_QUERY_STRING_IN_PATH , "Förfrågan-sträng kan inte anges i väg och förfrågan-sträng" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment kan inte anges i både vägen och fragmentet" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Kan inte initialisera URI med tomma parametrar" } , { ER_METHOD_NOT_SUPPORTED , "Metod ännu inte understödd " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter kan för närvarande inte startas om" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader inte innan startParse-begäran" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Det går inte att vända axeln: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler skapad med null PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "SystemId okänt" } , { ER_LOCATION_UNKNOWN , "Platsen för felet är okänd" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() understöds inte av XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Attributbarn saknar ägardokument!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Attributbarn saknar ägardokumentelement!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Varning: kan inte skriva ut text innan dokumentelement!  Ignorerar..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Kan inte ha mer än en rot på en DOM!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' är null" } , { ER_ARG_LOCALNAME_INVALID , "Localname i QNAME bör vara ett giltigt NCName" } , { ER_ARG_PREFIX_INVALID , "Prefixet i QNAME bör vara ett giltigt NCName" } , { "BAD_CODE" , "Parameter till createMessage ligger utanför tillåtet intervall" } , { "FORMAT_FAILED" , "Undantag utlöst vid messageFormat-anrop" } , { "line" , "Rad #" } , { "column" , "Kolumn #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DUP ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . SWITCH ; import org . apache . bcel . generic . TargetLostException ; import org . apache . bcel . util . InstructionFinder ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NamedMethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class Mode implements Constants { private final QName _name ; private final Stylesheet _stylesheet ; private final String _methodName ; private Vector _templates ; private Vector _childNodeGroup = null ; private TestSeq _childNodeTestSeq = null ; private Vector _attribNodeGroup = null ; private TestSeq _attribNodeTestSeq = null ; private Vector _idxGroup = null ; private TestSeq _idxTestSeq = null ; private Vector [ ] _patternGroups ; private TestSeq [ ] _testSeq ; private Hashtable _preCompiled = new Hashtable ( ) ; private Hashtable _neededTemplates = new Hashtable ( ) ; private Hashtable _namedTemplates = new Hashtable ( ) ; private Hashtable _templateIHs = new Hashtable ( ) ; private Hashtable _templateILs = new Hashtable ( ) ; private LocationPathPattern _rootPattern = null ; private Hashtable _importLevels = null ; private Hashtable _keys = null ; private int _currentIndex ; public Mode ( QName name , Stylesheet stylesheet , String suffix ) { _name = name ; _stylesheet = stylesheet ; _methodName = APPLY_TEMPLATES + suffix ; _templates = new Vector ( ) ; _patternGroups = new Vector [ 32 ] ; } public String functionName ( ) { return _methodName ; } public String functionName ( int min , int max ) { if ( _importLevels == null ) { _importLevels = new Hashtable ( ) ; } _importLevels . put ( new Integer ( max ) , new Integer ( min ) ) ; return _methodName + '_' + max ; } public void addInstructionList ( Pattern pattern , InstructionList ilist ) { _preCompiled . put ( pattern , ilist ) ; } public InstructionList getInstructionList ( Pattern pattern ) { return ( InstructionList ) _preCompiled . get ( pattern ) ; } private String getClassName ( ) { return _stylesheet . getClassName ( ) ; } public Stylesheet getStylesheet ( ) { return _stylesheet ; } public void addTemplate ( Template template ) { _templates . addElement ( template ) ; } private Vector quicksort ( Vector templates , int p , int r ) { if ( p < r ) { final int q = partition ( templates , p , r ) ; quicksort ( templates , p , q ) ; quicksort ( templates , q + 1 , r ) ; } return templates ; } private int partition ( Vector templates , int p , int r ) { final Template x = ( Template ) templates . elementAt ( p ) ; int i = p - 1 ; int j = r + 1 ; while ( true ) { while ( x . compareTo ( ( Template ) templates . elementAt ( -- j ) ) > 0 ) ; while ( x . compareTo ( ( Template ) templates . elementAt ( ++ i ) ) < 0 ) ; if ( i < j ) { templates . set ( j , templates . set ( i , templates . elementAt ( j ) ) ) ; } else { return j ; } } } public void processPatterns ( Hashtable keys ) { _keys = keys ; _templates = quicksort ( _templates , 0 , _templates . size ( ) - 1 ) ; final Enumeration templates = _templates . elements ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; if ( template . isNamed ( ) && ! template . disabled ( ) ) { _namedTemplates . put ( template , this ) ; } final Pattern pattern = template . getPattern ( ) ; if ( pattern != null ) { flattenAlternative ( pattern , template , keys ) ; } } prepareTestSequences ( ) ; } private void flattenAlternative ( Pattern pattern , Template template , Hashtable keys ) { if ( pattern instanceof IdKeyPattern ) { final IdKeyPattern idkey = ( IdKeyPattern ) pattern ; idkey . setTemplate ( template ) ; if ( _idxGroup == null ) _idxGroup = new Vector ( ) ; _idxGroup . add ( pattern ) ; } else if ( pattern instanceof AlternativePattern ) { final AlternativePattern alt = ( AlternativePattern ) pattern ; flattenAlternative ( alt . getLeft ( ) , template , keys ) ; flattenAlternative ( alt . getRight ( ) , template , keys ) ; } else if ( pattern instanceof LocationPathPattern ) { final LocationPathPattern lpp = ( LocationPathPattern ) pattern ; lpp . setTemplate ( template ) ; addPatternToGroup ( lpp ) ; } } private void addPatternToGroup ( final LocationPathPattern lpp ) { if ( lpp instanceof IdKeyPattern ) { addPattern ( - 1 , lpp ) ; } else { final StepPattern kernel = lpp . getKernelPattern ( ) ; if ( kernel != null ) { addPattern ( kernel . getNodeType ( ) , lpp ) ; } else if ( _rootPattern == null || lpp . noSmallerThan ( _rootPattern ) ) { _rootPattern = lpp ; } } } private void addPattern ( int kernelType , LocationPathPattern pattern ) { final int oldLength = _patternGroups . length ; if ( kernelType >= oldLength ) { Vector [ ] newGroups = new Vector [ kernelType * 2 ] ; System . arraycopy ( _patternGroups , 0 , newGroups , 0 , oldLength ) ; _patternGroups = newGroups ; } Vector patterns ; if ( kernelType == DOM . NO_TYPE ) { if ( pattern . getAxis ( ) == Axis . ATTRIBUTE ) { patterns = ( _attribNodeGroup == null ) ? ( _attribNodeGroup = new Vector ( 2 ) ) : _attribNodeGroup ; } else { patterns = ( _childNodeGroup == null ) ? ( _childNodeGroup = new Vector ( 2 ) ) : _childNodeGroup ; } } else { patterns = ( _patternGroups [ kernelType ] == null ) ? ( _patternGroups [ kernelType ] = new Vector ( 2 ) ) : _patternGroups [ kernelType ] ; } if ( patterns . size ( ) == 0 ) { patterns . addElement ( pattern ) ; } else { boolean inserted = false ; for ( int i = 0 ; i < patterns . size ( ) ; i ++ ) { final LocationPathPattern lppToCompare = ( LocationPathPattern ) patterns . elementAt ( i ) ; if ( pattern . noSmallerThan ( lppToCompare ) ) { inserted = true ; patterns . insertElementAt ( pattern , i ) ; break ; } } if ( inserted == false ) { patterns . addElement ( pattern ) ; } } } private void completeTestSequences ( int nodeType , Vector patterns ) { if ( patterns != null ) { if ( _patternGroups [ nodeType ] == null ) { _patternGroups [ nodeType ] = patterns ; } else { final int m = patterns . size ( ) ; for ( int j = 0 ; j < m ; j ++ ) { addPattern ( nodeType , ( LocationPathPattern ) patterns . elementAt ( j ) ) ; } } } } private void prepareTestSequences ( ) { final Vector starGroup = _patternGroups [ DTM . ELEMENT_NODE ] ; final Vector atStarGroup = _patternGroups [ DTM . ATTRIBUTE_NODE ] ; completeTestSequences ( DTM . TEXT_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . ELEMENT_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . PROCESSING_INSTRUCTION_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . COMMENT_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . ATTRIBUTE_NODE , _attribNodeGroup ) ; final Vector names = _stylesheet . getXSLTC ( ) . getNamesIndex ( ) ; if ( starGroup != null || atStarGroup != null || _childNodeGroup != null || _attribNodeGroup != null ) { final int n = _patternGroups . length ; for ( int i = DTM . NTYPES ; i < n ; i ++ ) { if ( _patternGroups [ i ] == null ) continue ; final String name = ( String ) names . elementAt ( i - DTM . NTYPES ) ; if ( isAttributeName ( name ) ) { completeTestSequences ( i , atStarGroup ) ; completeTestSequences ( i , _attribNodeGroup ) ; } else { completeTestSequences ( i , starGroup ) ; completeTestSequences ( i , _childNodeGroup ) ; } } } _testSeq = new TestSeq [ DTM . NTYPES + names . size ( ) ] ; final int n = _patternGroups . length ; for ( int i = 0 ; i < n ; i ++ ) { final Vector patterns = _patternGroups [ i ] ; if ( patterns != null ) { final TestSeq testSeq = new TestSeq ( patterns , i , this ) ; testSeq . reduce ( ) ; _testSeq [ i ] = testSeq ; testSeq . findTemplates ( _neededTemplates ) ; } } if ( _childNodeGroup != null && _childNodeGroup . size ( ) > 0 ) { _childNodeTestSeq = new TestSeq ( _childNodeGroup , - 1 , this ) ; _childNodeTestSeq . reduce ( ) ; _childNodeTestSeq . findTemplates ( _neededTemplates ) ; } if ( _idxGroup != null && _idxGroup . size ( ) > 0 ) { _idxTestSeq = new TestSeq ( _idxGroup , this ) ; _idxTestSeq . reduce ( ) ; _idxTestSeq . findTemplates ( _neededTemplates ) ; } if ( _rootPattern != null ) { _neededTemplates . put ( _rootPattern . getTemplate ( ) , this ) ; } } private void compileNamedTemplate ( Template template , ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; String methodName = Util . escape ( template . getName ( ) . toString ( ) ) ; final NamedMethodGenerator methodGen = new NamedMethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) , org . apache . bcel . generic . Type . INT } , new String [ ] { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME , NODE_PNAME } , methodName , getClassName ( ) , il , cpg ) ; il . append ( template . compile ( classGen , methodGen ) ) ; il . append ( RETURN ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; } private void compileTemplates ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next ) { Enumeration templates = _namedTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; compileNamedTemplate ( template , classGen ) ; } templates = _neededTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; if ( template . hasContents ( ) ) { InstructionList til = template . compile ( classGen , methodGen ) ; til . append ( new GOTO_W ( next ) ) ; _templateILs . put ( template , til ) ; _templateIHs . put ( template , til . getStart ( ) ) ; } else { _templateIHs . put ( template , next ) ; } } } private void appendTemplateCode ( InstructionList body ) { final Enumeration templates = _neededTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Object iList = _templateILs . get ( templates . nextElement ( ) ) ; if ( iList != null ) { body . append ( ( InstructionList ) iList ) ; } } } private void appendTestSequences ( InstructionList body ) { final int n = _testSeq . length ; for ( int i = 0 ; i < n ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( testSeq != null ) { InstructionList il = testSeq . getInstructionList ( ) ; if ( il != null ) body . append ( il ) ; } } } public static void compileGetChildren ( ClassGenerator classGen , MethodGenerator methodGen , int node ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , GET_CHILDREN , GET_CHILDREN_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( node ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; } private InstructionList compileDefaultRecursion ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final String applyTemplatesSig = classGen . getApplyTemplatesSig ( ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , GET_CHILDREN , GET_CHILDREN_SIG ) ; final int applyTemplates = cpg . addMethodref ( getClassName ( ) , functionName ( ) , applyTemplatesSig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( _currentIndex ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; il . append ( new GOTO_W ( next ) ) ; return il ; } private InstructionList compileDefaultText ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final int chars = cpg . addInterfaceMethodref ( DOM_INTF , CHARACTERS , CHARACTERS_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( _currentIndex ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( chars , 3 ) ) ; il . append ( new GOTO_W ( next ) ) ; return il ; } private InstructionList compileNamespaces ( ClassGenerator classGen , MethodGenerator methodGen , boolean [ ] isNamespace , boolean [ ] isAttribute , boolean attrFlag , InstructionHandle defaultTarget ) { final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final Vector namespaces = xsltc . getNamespaceIndex ( ) ; final Vector names = xsltc . getNamesIndex ( ) ; final int namespaceCount = namespaces . size ( ) + 1 ; final int namesCount = names . size ( ) ; final InstructionList il = new InstructionList ( ) ; final int [ ] types = new int [ namespaceCount ] ; final InstructionHandle [ ] targets = new InstructionHandle [ types . length ] ; if ( namespaceCount > 0 ) { boolean compiled = false ; for ( int i = 0 ; i < namespaceCount ; i ++ ) { targets [ i ] = defaultTarget ; types [ i ] = i ; } for ( int i = DTM . NTYPES ; i < ( DTM . NTYPES + namesCount ) ; i ++ ) { if ( ( isNamespace [ i ] ) && ( isAttribute [ i ] == attrFlag ) ) { String name = ( String ) names . elementAt ( i - DTM . NTYPES ) ; String namespace = name . substring ( 0 , name . lastIndexOf ( ':' ) ) ; final int type = xsltc . registerNamespace ( namespace ) ; if ( ( i < _testSeq . length ) && ( _testSeq [ i ] != null ) ) { targets [ type ] = ( _testSeq [ i ] ) . compile ( classGen , methodGen , defaultTarget ) ; compiled = true ; } } } if ( ! compiled ) return ( null ) ; final int getNS = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceType" , "(I)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( _currentIndex ) ) ; il . append ( new INVOKEINTERFACE ( getNS , 2 ) ) ; il . append ( new SWITCH ( types , targets , defaultTarget ) ) ; return ( il ) ; } else { return ( null ) ; } } public void compileApplyTemplates ( ClassGenerator classGen ) { final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final Vector names = xsltc . getNamesIndex ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList mainIL = new InstructionList ( ) ; final MethodGenerator methodGen = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . VOID , argTypes , argNames , functionName ( ) , getClassName ( ) , mainIL , classGen . getConstantPool ( ) ) ; methodGen . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current ; current = methodGen . addLocalVariable2 ( "current" , org . apache . bcel . generic . Type . INT , mainIL . getEnd ( ) ) ; _currentIndex = current . getIndex ( ) ; final InstructionList body = new InstructionList ( ) ; body . append ( NOP ) ; final InstructionList ilLoop = new InstructionList ( ) ; ilLoop . append ( methodGen . loadIterator ( ) ) ; ilLoop . append ( methodGen . nextNode ( ) ) ; ilLoop . append ( DUP ) ; ilLoop . append ( new ISTORE ( _currentIndex ) ) ; final BranchHandle ifeq = ilLoop . append ( new IFLT ( null ) ) ; final BranchHandle loop = ilLoop . append ( new GOTO_W ( null ) ) ; ifeq . setTarget ( ilLoop . append ( RETURN ) ) ; final InstructionHandle ihLoop = ilLoop . getStart ( ) ; InstructionList ilRecurse = compileDefaultRecursion ( classGen , methodGen , ihLoop ) ; InstructionHandle ihRecurse = ilRecurse . getStart ( ) ; InstructionList ilText = compileDefaultText ( classGen , methodGen , ihLoop ) ; InstructionHandle ihText = ilText . getStart ( ) ; final int [ ] types = new int [ DTM . NTYPES + names . size ( ) ] ; for ( int i = 0 ; i < types . length ; i ++ ) { types [ i ] = i ; } final boolean [ ] isAttribute = new boolean [ types . length ] ; final boolean [ ] isNamespace = new boolean [ types . length ] ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { final String name = ( String ) names . elementAt ( i ) ; isAttribute [ i + DTM . NTYPES ] = isAttributeName ( name ) ; isNamespace [ i + DTM . NTYPES ] = isNamespaceName ( name ) ; } compileTemplates ( classGen , methodGen , ihLoop ) ; final TestSeq elemTest = _testSeq [ DTM . ELEMENT_NODE ] ; InstructionHandle ihElem = ihRecurse ; if ( elemTest != null ) ihElem = elemTest . compile ( classGen , methodGen , ihRecurse ) ; final TestSeq attrTest = _testSeq [ DTM . ATTRIBUTE_NODE ] ; InstructionHandle ihAttr = ihText ; if ( attrTest != null ) ihAttr = attrTest . compile ( classGen , methodGen , ihAttr ) ; InstructionList ilKey = null ; if ( _idxTestSeq != null ) { loop . setTarget ( _idxTestSeq . compile ( classGen , methodGen , body . getStart ( ) ) ) ; ilKey = _idxTestSeq . getInstructionList ( ) ; } else { loop . setTarget ( body . getStart ( ) ) ; } if ( _childNodeTestSeq != null ) { double nodePrio = _childNodeTestSeq . getPriority ( ) ; int nodePos = _childNodeTestSeq . getPosition ( ) ; double elemPrio = ( 0 - Double . MAX_VALUE ) ; int elemPos = Integer . MIN_VALUE ; if ( elemTest != null ) { elemPrio = elemTest . getPriority ( ) ; elemPos = elemTest . getPosition ( ) ; } if ( elemPrio == Double . NaN || elemPrio < nodePrio || ( elemPrio == nodePrio && elemPos < nodePos ) ) { ihElem = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; } final TestSeq textTest = _testSeq [ DTM . TEXT_NODE ] ; double textPrio = ( 0 - Double . MAX_VALUE ) ; int textPos = Integer . MIN_VALUE ; if ( textTest != null ) { textPrio = textTest . getPriority ( ) ; textPos = textTest . getPosition ( ) ; } if ( textPrio == Double . NaN || textPrio < nodePrio || ( textPrio == nodePrio && textPos < nodePos ) ) { ihText = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; _testSeq [ DTM . TEXT_NODE ] = _childNodeTestSeq ; } } InstructionHandle elemNamespaceHandle = ihElem ; InstructionList nsElem = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , false , ihElem ) ; if ( nsElem != null ) elemNamespaceHandle = nsElem . getStart ( ) ; InstructionHandle attrNamespaceHandle = ihAttr ; InstructionList nsAttr = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , true , ihAttr ) ; if ( nsAttr != null ) attrNamespaceHandle = nsAttr . getStart ( ) ; final InstructionHandle [ ] targets = new InstructionHandle [ types . length ] ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( isNamespace [ i ] ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else if ( testSeq != null ) { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } else { targets [ i ] = ihLoop ; } } targets [ DTM . ROOT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . DOCUMENT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . TEXT_NODE ] = _testSeq [ DTM . TEXT_NODE ] != null ? _testSeq [ DTM . TEXT_NODE ] . compile ( classGen , methodGen , ihText ) : ihText ; targets [ DTM . NAMESPACE_NODE ] = ihLoop ; targets [ DTM . ELEMENT_NODE ] = elemNamespaceHandle ; targets [ DTM . ATTRIBUTE_NODE ] = attrNamespaceHandle ; InstructionHandle ihPI = ihLoop ; if ( _childNodeTestSeq != null ) ihPI = ihElem ; if ( _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] != null ) targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] . compile ( classGen , methodGen , ihPI ) ; else targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = ihPI ; InstructionHandle ihComment = ihLoop ; if ( _childNodeTestSeq != null ) ihComment = ihElem ; targets [ DTM . COMMENT_NODE ] = _testSeq [ DTM . COMMENT_NODE ] != null ? _testSeq [ DTM . COMMENT_NODE ] . compile ( classGen , methodGen , ihComment ) : ihComment ; targets [ DTM . CDATA_SECTION_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_FRAGMENT_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_TYPE_NODE ] = ihLoop ; targets [ DTM . ENTITY_NODE ] = ihLoop ; targets [ DTM . ENTITY_REFERENCE_NODE ] = ihLoop ; targets [ DTM . NOTATION_NODE ] = ihLoop ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( ( testSeq == null ) || ( isNamespace [ i ] ) ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } } if ( ilKey != null ) body . insert ( ilKey ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; body . append ( methodGen . loadDOM ( ) ) ; body . append ( new ILOAD ( _currentIndex ) ) ; body . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; InstructionHandle disp = body . append ( new SWITCH ( types , targets , ihLoop ) ) ; appendTestSequences ( body ) ; appendTemplateCode ( body ) ; if ( nsElem != null ) body . append ( nsElem ) ; if ( nsAttr != null ) body . append ( nsAttr ) ; body . append ( ilRecurse ) ; body . append ( ilText ) ; mainIL . append ( new GOTO_W ( ihLoop ) ) ; mainIL . append ( body ) ; mainIL . append ( ilLoop ) ; peepHoleOptimization ( methodGen ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; if ( _importLevels != null ) { Enumeration levels = _importLevels . keys ( ) ; while ( levels . hasMoreElements ( ) ) { Integer max = ( Integer ) levels . nextElement ( ) ; Integer min = ( Integer ) _importLevels . get ( max ) ; compileApplyImports ( classGen , min . intValue ( ) , max . intValue ( ) ) ; } } } private void compileTemplateCalls ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next , int min , int max ) { Enumeration templates = _neededTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; final int prec = template . getImportPrecedence ( ) ; if ( ( prec >= min ) && ( prec < max ) ) { if ( template . hasContents ( ) ) { InstructionList til = template . compile ( classGen , methodGen ) ; til . append ( new GOTO_W ( next ) ) ; _templateILs . put ( template , til ) ; _templateIHs . put ( template , til . getStart ( ) ) ; } else { _templateIHs . put ( template , next ) ; } } } } public void compileApplyImports ( ClassGenerator classGen , int min , int max ) { final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final Vector names = xsltc . getNamesIndex ( ) ; _namedTemplates = new Hashtable ( ) ; _neededTemplates = new Hashtable ( ) ; _templateIHs = new Hashtable ( ) ; _templateILs = new Hashtable ( ) ; _patternGroups = new Vector [ 32 ] ; _rootPattern = null ; Vector oldTemplates = _templates ; _templates = new Vector ( ) ; final Enumeration templates = oldTemplates . elements ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; final int prec = template . getImportPrecedence ( ) ; if ( ( prec >= min ) && ( prec < max ) ) addTemplate ( template ) ; } processPatterns ( _keys ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList mainIL = new InstructionList ( ) ; final MethodGenerator methodGen = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . VOID , argTypes , argNames , functionName ( ) + '_' + max , getClassName ( ) , mainIL , classGen . getConstantPool ( ) ) ; methodGen . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current ; current = methodGen . addLocalVariable2 ( "current" , org . apache . bcel . generic . Type . INT , mainIL . getEnd ( ) ) ; _currentIndex = current . getIndex ( ) ; final InstructionList body = new InstructionList ( ) ; body . append ( NOP ) ; final InstructionList ilLoop = new InstructionList ( ) ; ilLoop . append ( methodGen . loadIterator ( ) ) ; ilLoop . append ( methodGen . nextNode ( ) ) ; ilLoop . append ( DUP ) ; ilLoop . append ( new ISTORE ( _currentIndex ) ) ; final BranchHandle ifeq = ilLoop . append ( new IFLT ( null ) ) ; final BranchHandle loop = ilLoop . append ( new GOTO_W ( null ) ) ; ifeq . setTarget ( ilLoop . append ( RETURN ) ) ; final InstructionHandle ihLoop = ilLoop . getStart ( ) ; InstructionList ilRecurse = compileDefaultRecursion ( classGen , methodGen , ihLoop ) ; InstructionHandle ihRecurse = ilRecurse . getStart ( ) ; InstructionList ilText = compileDefaultText ( classGen , methodGen , ihLoop ) ; InstructionHandle ihText = ilText . getStart ( ) ; final int [ ] types = new int [ DTM . NTYPES + names . size ( ) ] ; for ( int i = 0 ; i < types . length ; i ++ ) { types [ i ] = i ; } final boolean [ ] isAttribute = new boolean [ types . length ] ; final boolean [ ] isNamespace = new boolean [ types . length ] ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { final String name = ( String ) names . elementAt ( i ) ; isAttribute [ i + DTM . NTYPES ] = isAttributeName ( name ) ; isNamespace [ i + DTM . NTYPES ] = isNamespaceName ( name ) ; } compileTemplateCalls ( classGen , methodGen , ihLoop , min , max ) ; final TestSeq elemTest = _testSeq [ DTM . ELEMENT_NODE ] ; InstructionHandle ihElem = ihRecurse ; if ( elemTest != null ) { ihElem = elemTest . compile ( classGen , methodGen , ihLoop ) ; } final TestSeq attrTest = _testSeq [ DTM . ATTRIBUTE_NODE ] ; InstructionHandle ihAttr = ihLoop ; if ( attrTest != null ) { ihAttr = attrTest . compile ( classGen , methodGen , ihAttr ) ; } InstructionList ilKey = null ; if ( _idxTestSeq != null ) { loop . setTarget ( _idxTestSeq . compile ( classGen , methodGen , body . getStart ( ) ) ) ; ilKey = _idxTestSeq . getInstructionList ( ) ; } else { loop . setTarget ( body . getStart ( ) ) ; } if ( _childNodeTestSeq != null ) { double nodePrio = _childNodeTestSeq . getPriority ( ) ; int nodePos = _childNodeTestSeq . getPosition ( ) ; double elemPrio = ( 0 - Double . MAX_VALUE ) ; int elemPos = Integer . MIN_VALUE ; if ( elemTest != null ) { elemPrio = elemTest . getPriority ( ) ; elemPos = elemTest . getPosition ( ) ; } if ( elemPrio == Double . NaN || elemPrio < nodePrio || ( elemPrio == nodePrio && elemPos < nodePos ) ) { ihElem = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; } final TestSeq textTest = _testSeq [ DTM . TEXT_NODE ] ; double textPrio = ( 0 - Double . MAX_VALUE ) ; int textPos = Integer . MIN_VALUE ; if ( textTest != null ) { textPrio = textTest . getPriority ( ) ; textPos = textTest . getPosition ( ) ; } if ( textPrio == Double . NaN || textPrio < nodePrio || ( textPrio == nodePrio && textPos < nodePos ) ) { ihText = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; _testSeq [ DTM . TEXT_NODE ] = _childNodeTestSeq ; } } InstructionHandle elemNamespaceHandle = ihElem ; InstructionList nsElem = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , false , ihElem ) ; if ( nsElem != null ) elemNamespaceHandle = nsElem . getStart ( ) ; InstructionList nsAttr = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , true , ihAttr ) ; InstructionHandle attrNamespaceHandle = ihAttr ; if ( nsAttr != null ) attrNamespaceHandle = nsAttr . getStart ( ) ; final InstructionHandle [ ] targets = new InstructionHandle [ types . length ] ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( isNamespace [ i ] ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else if ( testSeq != null ) { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } else { targets [ i ] = ihLoop ; } } targets [ DTM . ROOT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . DOCUMENT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . TEXT_NODE ] = _testSeq [ DTM . TEXT_NODE ] != null ? _testSeq [ DTM . TEXT_NODE ] . compile ( classGen , methodGen , ihText ) : ihText ; targets [ DTM . NAMESPACE_NODE ] = ihLoop ; targets [ DTM . ELEMENT_NODE ] = elemNamespaceHandle ; targets [ DTM . ATTRIBUTE_NODE ] = attrNamespaceHandle ; InstructionHandle ihPI = ihLoop ; if ( _childNodeTestSeq != null ) ihPI = ihElem ; if ( _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] != null ) { targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] . compile ( classGen , methodGen , ihPI ) ; } else { targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = ihPI ; } InstructionHandle ihComment = ihLoop ; if ( _childNodeTestSeq != null ) ihComment = ihElem ; targets [ DTM . COMMENT_NODE ] = _testSeq [ DTM . COMMENT_NODE ] != null ? _testSeq [ DTM . COMMENT_NODE ] . compile ( classGen , methodGen , ihComment ) : ihComment ; targets [ DTM . CDATA_SECTION_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_FRAGMENT_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_TYPE_NODE ] = ihLoop ; targets [ DTM . ENTITY_NODE ] = ihLoop ; targets [ DTM . ENTITY_REFERENCE_NODE ] = ihLoop ; targets [ DTM . NOTATION_NODE ] = ihLoop ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( ( testSeq == null ) || ( isNamespace [ i ] ) ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } } if ( ilKey != null ) body . insert ( ilKey ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; body . append ( methodGen . loadDOM ( ) ) ; body . append ( new ILOAD ( _currentIndex ) ) ; body . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; InstructionHandle disp = body . append ( new SWITCH ( types , targets , ihLoop ) ) ; appendTestSequences ( body ) ; appendTemplateCode ( body ) ; if ( nsElem != null ) body . append ( nsElem ) ; if ( nsAttr != null ) body . append ( nsAttr ) ; body . append ( ilRecurse ) ; body . append ( ilText ) ; mainIL . append ( new GOTO_W ( ihLoop ) ) ; mainIL . append ( body ) ; mainIL . append ( ilLoop ) ; peepHoleOptimization ( methodGen ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; _templates = oldTemplates ; } private void peepHoleOptimization ( MethodGenerator methodGen ) { InstructionList il = methodGen . getInstructionList ( ) ; InstructionFinder find = new InstructionFinder ( il ) ; InstructionHandle ih ; String pattern ; pattern = "`ALOAD'`POP'`Instruction'" ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { if ( ( ! match [ 0 ] . hasTargeters ( ) ) && ( ! match [ 1 ] . hasTargeters ( ) ) ) { il . delete ( match [ 0 ] , match [ 1 ] ) ; } } catch ( TargetLostException e ) { } } pattern = "`ILOAD'`ALOAD'`SWAP'`Instruction'" ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { org . apache . bcel . generic . Instruction iload ; org . apache . bcel . generic . Instruction aload ; if ( ( ! match [ 0 ] . hasTargeters ( ) ) && ( ! match [ 1 ] . hasTargeters ( ) ) && ( ! match [ 2 ] . hasTargeters ( ) ) ) { iload = match [ 0 ] . getInstruction ( ) ; aload = match [ 1 ] . getInstruction ( ) ; il . insert ( match [ 0 ] , aload ) ; il . insert ( match [ 0 ] , iload ) ; il . delete ( match [ 0 ] , match [ 2 ] ) ; } } catch ( TargetLostException e ) { } } pattern = "`ALOAD_1'`ALOAD_1'`Instruction'" ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { org . apache . bcel . generic . Instruction iload ; org . apache . bcel . generic . Instruction aload ; if ( ( ! match [ 0 ] . hasTargeters ( ) ) && ( ! match [ 1 ] . hasTargeters ( ) ) ) { il . insert ( match [ 1 ] , new DUP ( ) ) ; il . delete ( match [ 1 ] ) ; } } catch ( TargetLostException e ) { } } } public InstructionHandle getTemplateInstructionHandle ( Template template ) { return ( InstructionHandle ) _templateIHs . get ( template ) ; } private static boolean isAttributeName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) + 1 ; return ( qname . charAt ( col ) == '@' ) ; } private static boolean isNamespaceName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) ; return ( col > - 1 && qname . charAt ( qname . length ( ) - 1 ) == '*' ) ; } } 	0	['31', '1', '0', '41', '146', '327', '4', '39', '12', '0.853968254', '3077', '1', '7', '0', '0.163306452', '0', '0', '97.58064516', '41', '5.6452', '0']
package org . apache . xalan . templates ; import java . io . Serializable ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . patterns . StepPattern ; class TemplateSubPatternAssociation implements Serializable , Cloneable { StepPattern m_stepPattern ; private String m_pattern ; private ElemTemplate m_template ; private TemplateSubPatternAssociation m_next = null ; private boolean m_wild ; private String m_targetString ; TemplateSubPatternAssociation ( ElemTemplate template , StepPattern pattern , String pat ) { m_pattern = pat ; m_template = template ; m_stepPattern = pattern ; m_targetString = m_stepPattern . getTargetString ( ) ; m_wild = m_targetString . equals ( "*" ) ; } public Object clone ( ) throws CloneNotSupportedException { TemplateSubPatternAssociation tspa = ( TemplateSubPatternAssociation ) super . clone ( ) ; tspa . m_next = null ; return tspa ; } public final String getTargetString ( ) { return m_targetString ; } public void setTargetString ( String key ) { m_targetString = key ; } boolean matchMode ( QName m1 ) { return matchModes ( m1 , m_template . getMode ( ) ) ; } private boolean matchModes ( QName m1 , QName m2 ) { return ( ( ( null == m1 ) && ( null == m2 ) ) || ( ( null != m1 ) && ( null != m2 ) && m1 . equals ( m2 ) ) ) ; } public boolean matches ( XPathContext xctxt , int targetNode , QName mode ) throws TransformerException { double score = m_stepPattern . getMatchScore ( xctxt , targetNode ) ; return ( XPath . MATCH_SCORE_NONE != score ) && matchModes ( mode , m_template . getMode ( ) ) ; } public final boolean isWild ( ) { return m_wild ; } public final StepPattern getStepPattern ( ) { return m_stepPattern ; } public final String getPattern ( ) { return m_pattern ; } public int getDocOrderPos ( ) { return m_template . getUid ( ) ; } public final int getImportLevel ( ) { return m_template . getStylesheetComposed ( ) . getImportCountComposed ( ) ; } public final ElemTemplate getTemplate ( ) { return m_template ; } public final TemplateSubPatternAssociation getNext ( ) { return m_next ; } public void setNext ( TemplateSubPatternAssociation mp ) { m_next = mp ; } } 	0	['15', '1', '0', '7', '25', '49', '2', '5', '12', '0.833333333', '139', '0.833333333', '3', '0', '0.208333333', '0', '0', '7.866666667', '6', '1.2667', '0']
package org . apache . xpath . operations ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public abstract class UnaryOperation extends Expression implements ExpressionOwner { protected Expression m_right ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_right . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_right && m_right . canTraverseOutsideSubtree ( ) ) return true ; return false ; } public void setRight ( Expression r ) { m_right = r ; r . exprSetParent ( this ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return operate ( m_right . execute ( xctxt ) ) ; } public abstract XObject operate ( XObject right ) throws javax . xml . transform . TransformerException ; public Expression getOperand ( ) { return m_right ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitUnaryOperation ( owner , this ) ) { m_right . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_right ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_right = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_right . deepEquals ( ( ( UnaryOperation ) expr ) . m_right ) ) return false ; return true ; } } 	0	['11', '2', '4', '11', '20', '0', '6', '6', '11', '0.2', '88', '1', '1', '0.75', '0.227272727', '1', '7', '6.909090909', '3', '1.3636', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemTemplateElement ; class ProcessorGlobalParamDecl extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { handler . pushElemTemplateElement ( elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ElemParam v = ( ElemParam ) handler . getElemTemplateElement ( ) ; handler . getStylesheet ( ) . appendChild ( v ) ; handler . getStylesheet ( ) . setParam ( v ) ; super . endElement ( handler , uri , localName , rawName ) ; } } 	0	['3', '5', '0', '6', '10', '3', '1', '5', '1', '2', '30', '0', '0', '0.990697674', '0.583333333', '1', '2', '9', '1', '0.6667', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; class ProcessorTemplate extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { super . appendAndPush ( handler , elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; handler . getStylesheet ( ) . setTemplate ( ( ElemTemplate ) elem ) ; } } 	0	['2', '5', '0', '6', '8', '1', '1', '5', '0', '2', '19', '0', '0', '0.995327103', '0.666666667', '1', '1', '8.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; final class IdPattern extends IdKeyPattern { public IdPattern ( String id ) { super ( "##id" , id ) ; } } 	0	['1', '6', '0', '1', '2', '0', '1', '1', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class AbsoluteLocationPath extends Expression { private Expression _path ; public AbsoluteLocationPath ( ) { _path = null ; } public AbsoluteLocationPath ( Expression path ) { _path = path ; if ( path != null ) { _path . setParent ( this ) ; } } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _path != null ) { _path . setParser ( parser ) ; } } public Expression getPath ( ) { return ( _path ) ; } public String toString ( ) { return "AbsoluteLocationPath(" + ( _path != null ? _path . toString ( ) : "null" ) + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _path != null ) { final Type ptype = _path . typeCheck ( stable ) ; if ( ptype instanceof NodeType ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _path != null ) { final int initAI = cpg . addMethodref ( ABSOLUTE_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( ABSOLUTE_ITERATOR ) ) ) ; il . append ( DUP ) ; _path . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initAI ) ) ; } else { final int gitr = cpg . addInterfaceMethodref ( DOM_INTF , "getIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEINTERFACE ( gitr , 1 ) ) ; } } } 	0	['7', '3', '0', '19', '28', '0', '1', '18', '7', '0', '143', '1', '1', '0.934210526', '0.285714286', '2', '7', '19.28571429', '2', '1.1429', '0']
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . ObjectStack ; public class StackGuard { public static int m_recursionLimit = - 1 ; TransformerImpl m_transformer ; public int getRecursionLimit ( ) { return m_recursionLimit ; } public void setRecursionLimit ( int limit ) { m_recursionLimit = limit ; } public StackGuard ( TransformerImpl transformerImpl ) { m_transformer = transformerImpl ; } public int countLikeTemplates ( ElemTemplate templ , int pos ) { ObjectStack elems = m_transformer . getCurrentTemplateElements ( ) ; int count = 1 ; for ( int i = pos - 1 ; i >= 0 ; i -- ) { if ( ( ElemTemplateElement ) elems . elementAt ( i ) == templ ) count ++ ; } return count ; } private ElemTemplate getNextMatchOrNamedTemplate ( int pos ) { ObjectStack elems = m_transformer . getCurrentTemplateElements ( ) ; for ( int i = pos ; i >= 0 ; i -- ) { ElemTemplateElement elem = ( ElemTemplateElement ) elems . elementAt ( i ) ; if ( null != elem ) { if ( elem . getXSLToken ( ) == Constants . ELEMNAME_TEMPLATE ) { return ( ElemTemplate ) elem ; } } } return null ; } public void checkForInfinateLoop ( ) throws TransformerException { int nTemplates = m_transformer . getCurrentTemplateElementsCount ( ) ; if ( nTemplates < m_recursionLimit ) return ; if ( m_recursionLimit <= 0 ) return ; for ( int i = ( nTemplates - 1 ) ; i >= m_recursionLimit ; i -- ) { ElemTemplate template = getNextMatchOrNamedTemplate ( i ) ; if ( null == template ) break ; int loopCount = countLikeTemplates ( template , i ) ; if ( loopCount >= m_recursionLimit ) { String idIs = XSLMessages . createMessage ( ( ( null != template . getName ( ) ) ? "nameIs" : "matchPatternIs" ) , null ) ; Object [ ] msgArgs = new Object [ ] { new Integer ( loopCount ) , idIs , ( ( null != template . getName ( ) ) ? template . getName ( ) . toString ( ) : template . getMatch ( ) . getPatternString ( ) ) } ; String msg = XSLMessages . createMessage ( "recursionTooDeep" , msgArgs ) ; throw new TransformerException ( msg ) ; } } } } 	0	['7', '1', '0', '8', '19', '0', '3', '7', '5', '0.5', '157', '0', '1', '0', '0.458333333', '0', '0', '21.14285714', '4', '1.4286', '0']
package org . apache . xml . utils ; public interface DOMOrder { public int getUid ( ) ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xml . serializer ; public class EncodingInfo extends Object { final String name ; final String javaName ; final int lastPrintable ; public EncodingInfo ( String name , String javaName , int lastPrintable ) { this . name = name ; this . javaName = javaName ; this . lastPrintable = lastPrintable ; } } 	0	['1', '1', '0', '1', '2', '0', '1', '0', '1', '2', '16', '0', '0', '0', '1', '0', '0', '12', '0', '0', '0']
package org . apache . xalan . xsltc . dom ; public final class EmptyFilter implements Filter { public boolean test ( int node ) { return true ; } } 	0	['2', '1', '0', '1', '3', '1', '0', '1', '2', '2', '7', '0', '0', '0', '0.75', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . runtime ; import org . apache . xalan . xsltc . DOM ; import org . xml . sax . AttributeList ; public final class Attributes implements AttributeList { private int _element ; private DOM _document ; public Attributes ( DOM document , int element ) { _element = element ; _document = document ; } public int getLength ( ) { return 0 ; } public String getName ( int i ) { return null ; } public String getType ( int i ) { return null ; } public String getType ( String name ) { return null ; } public String getValue ( int i ) { return null ; } public String getValue ( String name ) { return null ; } } 	0	['7', '1', '0', '1', '8', '21', '0', '1', '7', '1', '30', '1', '1', '0', '0.5', '0', '0', '3', '1', '0.8571', '0']
package org . apache . xalan . templates ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class XUnresolvedVariableSimple extends XObject { public XUnresolvedVariableSimple ( ElemVariable obj ) { super ( obj ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { Expression expr = ( ( ElemVariable ) m_obj ) . getSelect ( ) . getExpression ( ) ; XObject xobj = expr . execute ( xctxt ) ; xobj . allowDetachToRelease ( false ) ; return xobj ; } public int getType ( ) { return CLASS_UNRESOLVEDVARIABLE ; } public String getTypeString ( ) { return "XUnresolvedVariableSimple (" + object ( ) . getClass ( ) . getName ( ) + ")" ; } } 	0	['4', '3', '0', '6', '15', '6', '1', '5', '4', '2', '39', '0', '0', '0.959459459', '0.5', '2', '12', '8.75', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class BooleanExpr extends Expression { private boolean _value ; public BooleanExpr ( boolean value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _type = Type . Boolean ; return _type ; } public String toString ( ) { return _value ? "true()" : "false()" ; } public boolean getValue ( ) { return _value ; } public boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( _value ) { il . append ( NOP ) ; } else { _falseList . add ( il . append ( new GOTO ( null ) ) ) ; } } } 	0	['7', '3', '0', '17', '16', '1', '1', '16', '7', '0.333333333', '70', '1', '0', '0.922077922', '0.371428571', '2', '8', '8.857142857', '2', '1.1429', '0']
package org . apache . xalan . templates ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . functions . FuncCurrent ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . functions . Function ; import org . apache . xpath . operations . Variable ; public class AbsPathChecker extends XPathVisitor { private boolean m_isAbs = true ; public boolean checkAbsolute ( LocPathIterator path ) { m_isAbs = true ; path . callVisitors ( null , this ) ; return m_isAbs ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { if ( ( func instanceof FuncCurrent ) || ( func instanceof FuncExtFunction ) ) m_isAbs = false ; return true ; } public boolean visitVariableRef ( ExpressionOwner owner , Variable var ) { m_isAbs = false ; return true ; } } 	0	['4', '2', '0', '8', '6', '0', '1', '7', '4', '0', '37', '1', '0', '0.8', '0.45', '0', '0', '8', '3', '1.25', '0']
package org . apache . xalan . xsltc . runtime . output ; interface OutputBuffer { public String close ( ) ; public OutputBuffer append ( char ch ) ; public OutputBuffer append ( String s ) ; public OutputBuffer append ( char [ ] s , int from , int to ) ; } 	0	['4', '1', '0', '2', '4', '6', '2', '0', '4', '2', '4', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . xml . dtm . ref ; import javax . xml . transform . SourceLocator ; public class NodeLocator implements SourceLocator { protected String m_publicId ; protected String m_systemId ; protected int m_lineNumber ; protected int m_columnNumber ; public NodeLocator ( String publicId , String systemId , int lineNumber , int columnNumber ) { this . m_publicId = publicId ; this . m_systemId = systemId ; this . m_lineNumber = lineNumber ; this . m_columnNumber = columnNumber ; } public String getPublicId ( ) { return m_publicId ; } public String getSystemId ( ) { return m_systemId ; } public int getLineNumber ( ) { return m_lineNumber ; } public int getColumnNumber ( ) { return m_columnNumber ; } public String toString ( ) { return "file '" + m_systemId + "', line #" + m_lineNumber + ", column #" + m_columnNumber ; } } 	0	['6', '1', '0', '1', '11', '0', '1', '0', '6', '0.65', '57', '1', '0', '0', '0.444444444', '0', '0', '7.833333333', '1', '0.8333', '0']
package org . apache . xml . dtm ; public interface DTMFilter { public static final int SHOW_ALL = 0xFFFFFFFF ; public static final int SHOW_ELEMENT = 0x00000001 ; public static final int SHOW_ATTRIBUTE = 0x00000002 ; public static final int SHOW_TEXT = 0x00000004 ; public static final int SHOW_CDATA_SECTION = 0x00000008 ; public static final int SHOW_ENTITY_REFERENCE = 0x00000010 ; public static final int SHOW_ENTITY = 0x00000020 ; public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040 ; public static final int SHOW_COMMENT = 0x00000080 ; public static final int SHOW_DOCUMENT = 0x00000100 ; public static final int SHOW_DOCUMENT_TYPE = 0x00000200 ; public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400 ; public static final int SHOW_NOTATION = 0x00000800 ; public static final int SHOW_NAMESPACE = 0x00001000 ; public static final int SHOW_BYFUNCTION = 0x00010000 ; public short acceptNode ( int nodeHandle , int whatToShow ) ; public short acceptNode ( int nodeHandle , int whatToShow , int expandedName ) ; } 	0	['2', '1', '0', '6', '2', '1', '6', '0', '2', '2', '17', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class NumberCall extends FunctionCall { public NumberCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argumentCount ( ) > 0 ) { argument ( ) . typeCheck ( stable ) ; } return _type = Type . Real ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; Type targ ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; targ = Type . Node ; } else { final Expression arg = argument ( ) ; arg . translate ( classGen , methodGen ) ; arg . startResetIterator ( classGen , methodGen ) ; targ = arg . getType ( ) ; } if ( ! targ . identicalTo ( Type . Real ) ) { targ . translateTo ( classGen , methodGen , Type . Real ) ; } } } 	0	['3', '4', '0', '11', '15', '3', '0', '11', '3', '2', '59', '0', '0', '0.979591837', '0.444444444', '3', '13', '18.66666667', '3', '1.3333', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . NamespaceAlias ; import org . xml . sax . Attributes ; class ProcessorNamespaceAlias extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { NamespaceAlias na = new NamespaceAlias ( handler . nextUid ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , na ) ; String prefix = na . getStylesheetPrefix ( ) ; if ( prefix . equals ( "#default" ) ) { prefix = "" ; na . setStylesheetPrefix ( prefix ) ; } String stylesheetNS = handler . getNamespaceForPrefix ( prefix ) ; na . setStylesheetNamespace ( stylesheetNS ) ; prefix = na . getResultPrefix ( ) ; if ( prefix . equals ( "#default" ) ) { prefix = "" ; na . setResultPrefix ( prefix ) ; } String resultNS = handler . getNamespaceForPrefix ( prefix ) ; na . setResultNamespace ( resultNS ) ; handler . getStylesheet ( ) . setNamespaceAlias ( na ) ; handler . getStylesheet ( ) . appendChild ( na ) ; } } 	0	['2', '4', '0', '6', '17', '1', '1', '5', '1', '2', '65', '0', '0', '0.995260664', '0.625', '3', '4', '31.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . util . Hashtable ; import java . util . Vector ; public final class MultiHashtable extends Hashtable { public Object put ( Object key , Object value ) { Vector vector = ( Vector ) get ( key ) ; if ( vector == null ) super . put ( key , vector = new Vector ( ) ) ; vector . add ( value ) ; return vector ; } public Object maps ( Object from , Object to ) { if ( from == null ) return null ; final Vector vector = ( Vector ) get ( from ) ; if ( vector != null ) { final int n = vector . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Object item = vector . elementAt ( i ) ; if ( item . equals ( to ) ) { return item ; } } } return null ; } } 	0	['3', '3', '0', '2', '11', '3', '2', '0', '3', '2', '61', '0', '0', '0.95', '0.833333333', '1', '2', '19.33333333', '5', '2.3333', '0']
package org . apache . xalan . transformer ; public class XalanProperties { public final static String SOURCE_LOCATION = "http://xml.apache.org/xalan/properties/source-location" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '5', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xalan . xsltc . runtime ; public interface Operators { public static final int EQ = 0 ; public static final int NE = 1 ; public static final int GT = 2 ; public static final int LT = 3 ; public static final int GE = 4 ; public static final int LE = 5 ; public static final String [ ] names = { "=" , "!=" , ">" , "<" , ">=" , "<=" } ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '0', '2', '36', '0', '0', '0', '0', '0', '0', '28', '0', '0', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class RtMethodGenerator extends MethodGenerator { private static final int HANDLER_INDEX = 2 ; private final Instruction _astoreHandler ; private final Instruction _aloadHandler ; public RtMethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; _astoreHandler = new ASTORE ( HANDLER_INDEX ) ; _aloadHandler = new ALOAD ( HANDLER_INDEX ) ; } public int getIteratorIndex ( ) { return INVALID_INDEX ; } public final Instruction storeHandler ( ) { return _astoreHandler ; } public final Instruction loadHandler ( ) { return _aloadHandler ; } public int getLocalIndex ( String name ) { return INVALID_INDEX ; } } 	0	['5', '5', '0', '7', '8', '6', '0', '7', '5', '0.916666667', '41', '1', '0', '0.971830986', '0.325', '1', '2', '6.6', '1', '0.8', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; public interface StripWhitespaceFilter { public boolean stripSpace ( DOM dom , int node , int type ) ; } 	0	['1', '1', '0', '1', '1', '0', '0', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class UnaryOpExpr extends Expression { private Expression _left ; public UnaryOpExpr ( Expression left ) { ( _left = left ) . setParent ( this ) ; } public boolean hasPositionCall ( ) { return ( _left . hasPositionCall ( ) ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tleft = _left . typeCheck ( stable ) ; final MethodType ptype = lookupPrimop ( stable , "u-" , new MethodType ( Type . Void , tleft ) ) ; if ( ptype != null ) { final Type arg1 = ( Type ) ptype . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) { _left = new CastExpr ( _left , arg1 ) ; } return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public String toString ( ) { return "u-" + '(' + _left + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; il . append ( _type . NEG ( ) ) ; } } 	0	['6', '3', '0', '13', '28', '0', '0', '13', '6', '0', '101', '1', '1', '0.934210526', '0.305555556', '2', '8', '15.66666667', '1', '0.8333', '0']
package org . apache . xalan . xsltc . runtime ; final public class TransletLoader { ClassLoader _loader = null ; public TransletLoader ( ) { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final String loaderName = loader . getClass ( ) . getName ( ) ; if ( loaderName . equals ( "sun.misc.Launcher$ExtClassLoader" ) ) { loader = ClassLoader . getSystemClassLoader ( ) ; } _loader = loader ; } public Class loadClass ( String name ) throws ClassNotFoundException { return ( Class . forName ( name , false , _loader ) ) ; } public Class loadTranslet ( String name ) throws ClassNotFoundException { return ( Class . forName ( name , true , _loader ) ) ; } } 	0	['3', '1', '0', '6', '11', '0', '6', '0', '3', '0', '38', '0', '0', '0', '0.833333333', '0', '0', '11.33333333', '1', '0.6667', '0']
package org . apache . xpath ; public interface ExpressionOwner { public Expression getExpression ( ) ; public void setExpression ( Expression exp ) ; } 	0	['2', '1', '0', '55', '2', '1', '54', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . xml . dtm . ref . sax2dtm ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import org . apache . xml . dtm . * ; import org . apache . xml . dtm . ref . * ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . IntVector ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . * ; import org . xml . sax . ext . * ; public class SAX2DTM extends DTMDefaultBaseIterators implements EntityResolver , DTDHandler , ContentHandler , ErrorHandler , DeclHandler , LexicalHandler { private static final boolean DEBUG = false ; private IncrementalSAXSource m_incrementalSAXSource = null ; protected FastStringBuffer m_chars ; protected SuballocatedIntVector m_data ; transient protected IntStack m_parents ; transient protected int m_previous = 0 ; transient protected java . util . Vector m_prefixMappings = new java . util . Vector ( ) ; transient protected IntStack m_contextIndexes ; transient protected int m_textType = DTM . TEXT_NODE ; transient protected int m_coalescedTextType = DTM . TEXT_NODE ; transient protected Locator m_locator = null ; transient private String m_systemId = null ; transient protected boolean m_insideDTD = false ; protected DTMTreeWalker m_walker = new DTMTreeWalker ( ) ; protected DTMStringPool m_valuesOrPrefixes ; protected boolean m_endDocumentOccured = false ; protected SuballocatedIntVector m_dataOrQName ; protected Hashtable m_idAttributes = new Hashtable ( ) ; static final String [ ] m_fixednames = { null , null , null , "#text" , "#cdata_section" , null , null , null , "#comment" , "#document" , null , "#document-fragment" , null } ; private Vector m_entities = null ; private static final int ENTITY_FIELD_PUBLICID = 0 ; private static final int ENTITY_FIELD_SYSTEMID = 1 ; private static final int ENTITY_FIELD_NOTATIONNAME = 2 ; private static final int ENTITY_FIELD_NAME = 3 ; private static final int ENTITY_FIELDS_PER = 4 ; protected int m_textPendingStart = - 1 ; protected boolean m_useSourceLocationProperty = false ; protected static boolean m_source_location = false ; protected StringVector m_sourceSystemId ; protected IntVector m_sourceLine ; protected IntVector m_sourceColumn ; public SAX2DTM ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , true ) ; } public SAX2DTM ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib ) ; if ( blocksize <= 64 ) { m_data = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS_SMALL ) ; m_dataOrQName = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS_SMALL ) ; m_valuesOrPrefixes = new DTMStringPool ( 16 ) ; m_chars = new FastStringBuffer ( 7 , 10 ) ; m_contextIndexes = new IntStack ( 4 ) ; m_parents = new IntStack ( 4 ) ; } else { m_data = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS ) ; m_dataOrQName = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS ) ; m_valuesOrPrefixes = new DTMStringPool ( ) ; m_chars = new FastStringBuffer ( 10 , 13 ) ; m_contextIndexes = new IntStack ( ) ; m_parents = new IntStack ( ) ; } m_data . addElement ( 0 ) ; m_useSourceLocationProperty = m_source_location ; m_sourceSystemId = ( m_useSourceLocationProperty ) ? new StringVector ( ) : null ; m_sourceLine = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; m_sourceColumn = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; } public static void setUseSourceLocation ( boolean useSourceLocation ) { m_source_location = useSourceLocation ; } protected int _dataOrQName ( int identity ) { if ( identity < m_size ) return m_dataOrQName . elementAt ( identity ) ; while ( true ) { boolean isMore = nextNode ( ) ; if ( ! isMore ) return NULL ; else if ( identity < m_size ) return m_dataOrQName . elementAt ( identity ) ; } } public void clearCoRoutine ( ) { clearCoRoutine ( true ) ; } public void clearCoRoutine ( boolean callDoTerminate ) { if ( null != m_incrementalSAXSource ) { if ( callDoTerminate ) m_incrementalSAXSource . deliverMoreNodes ( false ) ; m_incrementalSAXSource = null ; } } public void setIncrementalSAXSource ( IncrementalSAXSource incrementalSAXSource ) { m_incrementalSAXSource = incrementalSAXSource ; incrementalSAXSource . setContentHandler ( this ) ; incrementalSAXSource . setLexicalHandler ( this ) ; incrementalSAXSource . setDTDHandler ( this ) ; } public ContentHandler getContentHandler ( ) { if ( m_incrementalSAXSource instanceof IncrementalSAXSource_Filter ) return ( ContentHandler ) m_incrementalSAXSource ; else return this ; } public LexicalHandler getLexicalHandler ( ) { if ( m_incrementalSAXSource instanceof IncrementalSAXSource_Filter ) return ( LexicalHandler ) m_incrementalSAXSource ; else return this ; } public EntityResolver getEntityResolver ( ) { return this ; } public DTDHandler getDTDHandler ( ) { return this ; } public ErrorHandler getErrorHandler ( ) { return this ; } public DeclHandler getDeclHandler ( ) { return this ; } public boolean needsTwoThreads ( ) { return null != m_incrementalSAXSource ; } public void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws SAXException { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return ; int type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } else { int firstChild = _firstch ( identity ) ; if ( DTM . NULL != firstChild ) { int offset = - 1 ; int length = 0 ; int startNode = identity ; identity = firstChild ; do { type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; if ( - 1 == offset ) { offset = m_data . elementAt ( dataIndex ) ; } length += m_data . elementAt ( dataIndex + 1 ) ; } identity = getNextNodeIdentity ( identity ) ; } while ( DTM . NULL != identity && ( _parent ( identity ) >= startNode ) ) ; if ( length > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } } else if ( type != DTM . ELEMENT_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } String str = m_valuesOrPrefixes . indexToString ( dataIndex ) ; if ( normalize ) FastStringBuffer . sendNormalizedSAXcharacters ( str . toCharArray ( ) , 0 , str . length ( ) , ch ) ; else ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } } } public String getNodeName ( int nodeHandle ) { int expandedTypeID = getExpandedTypeID ( nodeHandle ) ; int namespaceID = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; if ( 0 == namespaceID ) { int type = getNodeType ( nodeHandle ) ; if ( type == DTM . NAMESPACE_NODE ) { if ( null == m_expandedNameTable . getLocalName ( expandedTypeID ) ) return "xmlns" ; else return "xmlns:" + m_expandedNameTable . getLocalName ( expandedTypeID ) ; } else if ( 0 == m_expandedNameTable . getLocalNameID ( expandedTypeID ) ) { return m_fixednames [ type ] ; } else return m_expandedNameTable . getLocalName ( expandedTypeID ) ; } else { int qnameIndex = m_dataOrQName . elementAt ( makeNodeIdentity ( nodeHandle ) ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public String getNodeNameX ( int nodeHandle ) { int expandedTypeID = getExpandedTypeID ( nodeHandle ) ; int namespaceID = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; if ( 0 == namespaceID ) { String name = m_expandedNameTable . getLocalName ( expandedTypeID ) ; if ( name == null ) return "" ; else return name ; } else { int qnameIndex = m_dataOrQName . elementAt ( makeNodeIdentity ( nodeHandle ) ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public boolean isAttributeSpecified ( int attributeHandle ) { return true ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } protected int getNextNodeIdentity ( int identity ) { identity += 1 ; while ( identity >= m_size ) { if ( null == m_incrementalSAXSource ) return DTM . NULL ; nextNode ( ) ; } return identity ; } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { DTMTreeWalker treeWalker = m_walker ; ContentHandler prevCH = treeWalker . getcontentHandler ( ) ; if ( null != prevCH ) { treeWalker = new DTMTreeWalker ( ) ; } treeWalker . setcontentHandler ( ch ) ; treeWalker . setDTM ( this ) ; try { treeWalker . traverse ( nodeHandle ) ; } finally { treeWalker . setcontentHandler ( null ) ; } } public int getNumberOfNodes ( ) { return m_size ; } protected boolean nextNode ( ) { if ( null == m_incrementalSAXSource ) return false ; if ( m_endDocumentOccured ) { clearCoRoutine ( ) ; return false ; } Object gotMore = m_incrementalSAXSource . deliverMoreNodes ( true ) ; if ( ! ( gotMore instanceof Boolean ) ) { if ( gotMore instanceof RuntimeException ) { throw ( RuntimeException ) gotMore ; } else if ( gotMore instanceof Exception ) { throw new WrappedRuntimeException ( ( Exception ) gotMore ) ; } clearCoRoutine ( ) ; return false ; } if ( gotMore != Boolean . TRUE ) { clearCoRoutine ( ) ; } return true ; } private final boolean isTextType ( int type ) { return ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) ; } protected int addNode ( int type , int expandedTypeID , int parentIndex , int previousSibling , int dataOrPrefix , boolean canHaveFirstChild ) { int nodeIndex = m_size ++ ; if ( m_dtmIdent . size ( ) == ( nodeIndex > > > DTMManager . IDENT_DTM_NODE_BITS ) ) { addNewDTMID ( nodeIndex ) ; } m_firstch . addElement ( canHaveFirstChild ? NOTPROCESSED : DTM . NULL ) ; m_nextsib . addElement ( NOTPROCESSED ) ; m_parent . addElement ( parentIndex ) ; m_exptype . addElement ( expandedTypeID ) ; m_dataOrQName . addElement ( dataOrPrefix ) ; if ( m_prevsib != null ) { m_prevsib . addElement ( previousSibling ) ; } if ( DTM . NULL != previousSibling ) { m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; } if ( m_locator != null && m_useSourceLocationProperty ) { setSourceLocation ( ) ; } switch ( type ) { case DTM . NAMESPACE_NODE : declareNamespaceInContext ( parentIndex , nodeIndex ) ; break ; case DTM . ATTRIBUTE_NODE : break ; default : if ( DTM . NULL == previousSibling && DTM . NULL != parentIndex ) { m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } break ; } return nodeIndex ; } protected void addNewDTMID ( int nodeIndex ) { try { if ( m_mgr == null ) throw new ClassCastException ( ) ; DTMManagerDefault mgrD = ( DTMManagerDefault ) m_mgr ; int id = mgrD . getFirstFreeDTMID ( ) ; mgrD . addDTM ( this , id , nodeIndex ) ; m_dtmIdent . addElement ( id << DTMManager . IDENT_DTM_NODE_BITS ) ; } catch ( ClassCastException e ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } } protected void setSourceLocation ( ) { m_sourceSystemId . addElement ( m_locator . getSystemId ( ) ) ; m_sourceLine . addElement ( m_locator . getLineNumber ( ) ) ; m_sourceColumn . addElement ( m_locator . getColumnNumber ( ) ) ; if ( m_sourceSystemId . size ( ) != m_size ) { System . err . println ( "CODING ERROR in Source Location: " + m_size + " != " + m_sourceSystemId . size ( ) ) ; System . exit ( 1 ) ; } } public String getNodeValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_chars . getString ( offset , length ) ; } else if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type || DTM . DOCUMENT_NODE == type ) { return null ; } else { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } } public String getLocalName ( int nodeHandle ) { return m_expandedNameTable . getLocalName ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public String getUnparsedEntityURI ( String name ) { String url = "" ; if ( null == m_entities ) return url ; int n = m_entities . size ( ) ; for ( int i = 0 ; i < n ; i += ENTITY_FIELDS_PER ) { String ename = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_NAME ) ; if ( null != ename && ename . equals ( name ) ) { String nname = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_NOTATIONNAME ) ; if ( null != nname ) { url = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_SYSTEMID ) ; if ( null == url ) { url = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_PUBLICID ) ; } } break ; } } return url ; } public String getPrefix ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type ( identity ) ; if ( DTM . ELEMENT_NODE == type ) { int prefixIndex = _dataOrQName ( identity ) ; if ( 0 == prefixIndex ) return "" ; else { String qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; return getPrefix ( qname , null ) ; } } else if ( DTM . ATTRIBUTE_NODE == type ) { int prefixIndex = _dataOrQName ( identity ) ; if ( prefixIndex < 0 ) { prefixIndex = m_data . elementAt ( - prefixIndex ) ; String qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; return getPrefix ( qname , null ) ; } } return "" ; } public int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) { for ( int attrH = getFirstAttribute ( nodeHandle ) ; DTM . NULL != attrH ; attrH = getNextAttribute ( attrH ) ) { String attrNS = getNamespaceURI ( attrH ) ; String attrName = getLocalName ( attrH ) ; boolean nsMatch = namespaceURI == attrNS || ( namespaceURI != null && namespaceURI . equals ( attrNS ) ) ; if ( nsMatch && name . equals ( attrName ) ) return attrH ; } return DTM . NULL ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } public String getNamespaceURI ( int nodeHandle ) { return m_expandedNameTable . getNamespace ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public XMLString getStringValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type ; if ( identity == DTM . NULL ) type = DTM . NULL ; else type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_xstrf . newstr ( m_chars , offset , length ) ; } else { int firstChild = _firstch ( identity ) ; if ( DTM . NULL != firstChild ) { int offset = - 1 ; int length = 0 ; int startNode = identity ; identity = firstChild ; do { type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; if ( - 1 == offset ) { offset = m_data . elementAt ( dataIndex ) ; } length += m_data . elementAt ( dataIndex + 1 ) ; } identity = getNextNodeIdentity ( identity ) ; } while ( DTM . NULL != identity && ( _parent ( identity ) >= startNode ) ) ; if ( length > 0 ) { return m_xstrf . newstr ( m_chars , offset , length ) ; } } else if ( type != DTM . ELEMENT_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return m_xstrf . newstr ( m_valuesOrPrefixes . indexToString ( dataIndex ) ) ; } } return m_xstrf . emptystr ( ) ; } public boolean isWhitespace ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type ; if ( identity == DTM . NULL ) type = DTM . NULL ; else type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_chars . isWhitespace ( offset , length ) ; } return false ; } public int getElementById ( String elementId ) { Integer intObj ; boolean isMore = true ; do { intObj = ( Integer ) m_idAttributes . get ( elementId ) ; if ( null != intObj ) return makeNodeHandle ( intObj . intValue ( ) ) ; if ( ! isMore || m_endDocumentOccured ) break ; isMore = nextNode ( ) ; } while ( null == intObj ) ; return DTM . NULL ; } public String getPrefix ( String qname , String uri ) { String prefix ; int uriIndex = - 1 ; if ( null != uri && uri . length ( ) > 0 ) { do { uriIndex = m_prefixMappings . indexOf ( uri , ++ uriIndex ) ; } while ( ( uriIndex & 0x01 ) == 0 ) ; if ( uriIndex >= 0 ) { prefix = ( String ) m_prefixMappings . elementAt ( uriIndex - 1 ) ; } else if ( null != qname ) { int indexOfNSSep = qname . indexOf ( ':' ) ; if ( qname . equals ( "xmlns" ) ) prefix = "" ; else if ( qname . startsWith ( "xmlns:" ) ) prefix = qname . substring ( indexOfNSSep + 1 ) ; else prefix = ( indexOfNSSep > 0 ) ? qname . substring ( 0 , indexOfNSSep ) : null ; } else { prefix = null ; } } else if ( null != qname ) { int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { if ( qname . startsWith ( "xmlns:" ) ) prefix = qname . substring ( indexOfNSSep + 1 ) ; else prefix = qname . substring ( 0 , indexOfNSSep ) ; } else { if ( qname . equals ( "xmlns" ) ) prefix = "" ; else prefix = null ; } } else { prefix = null ; } return prefix ; } public int getIdForNamespace ( String uri ) { return m_valuesOrPrefixes . stringToIndex ( uri ) ; } public String getNamespaceURI ( String prefix ) { String uri = "" ; int prefixIndex = m_contextIndexes . peek ( ) - 1 ; if ( null == prefix ) prefix = "" ; do { prefixIndex = m_prefixMappings . indexOf ( prefix , ++ prefixIndex ) ; } while ( ( prefixIndex >= 0 ) && ( prefixIndex & 0x01 ) == 0x01 ) ; if ( prefixIndex > - 1 ) { uri = ( String ) m_prefixMappings . elementAt ( prefixIndex + 1 ) ; } return uri ; } public void setIDAttribute ( String id , int elem ) { m_idAttributes . put ( id , new Integer ( elem ) ) ; } protected void charactersFlush ( ) { if ( m_textPendingStart >= 0 ) { int length = m_chars . size ( ) - m_textPendingStart ; boolean doStrip = false ; if ( getShouldStripWhitespace ( ) ) { doStrip = m_chars . isWhitespace ( m_textPendingStart , length ) ; } if ( doStrip ) m_chars . setLength ( m_textPendingStart ) ; else { int exName = m_expandedNameTable . getExpandedTypeID ( DTM . TEXT_NODE ) ; int dataIndex = m_data . size ( ) ; m_previous = addNode ( m_coalescedTextType , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; m_data . addElement ( m_textPendingStart ) ; m_data . addElement ( length ) ; } m_textPendingStart = - 1 ; m_textType = m_coalescedTextType = DTM . TEXT_NODE ; } } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { return null ; } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( null == m_entities ) { m_entities = new Vector ( ) ; } try { systemId = SystemIDResolver . getAbsoluteURI ( systemId , getDocumentBaseURI ( ) ) ; } catch ( Exception e ) { throw new org . xml . sax . SAXException ( e ) ; } m_entities . addElement ( publicId ) ; m_entities . addElement ( systemId ) ; m_entities . addElement ( notationName ) ; m_entities . addElement ( name ) ; } public void setDocumentLocator ( Locator locator ) { m_locator = locator ; m_systemId = locator . getSystemId ( ) ; } public void startDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "startDocument" ) ; int doc = addNode ( DTM . DOCUMENT_NODE , m_expandedNameTable . getExpandedTypeID ( DTM . DOCUMENT_NODE ) , DTM . NULL , DTM . NULL , 0 , true ) ; m_parents . push ( doc ) ; m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "endDocument" ) ; charactersFlush ( ) ; m_nextsib . setElementAt ( NULL , 0 ) ; if ( m_firstch . elementAt ( 0 ) == NOTPROCESSED ) m_firstch . setElementAt ( NULL , 0 ) ; if ( DTM . NULL != m_previous ) m_nextsib . setElementAt ( DTM . NULL , m_previous ) ; m_parents = null ; m_prefixMappings = null ; m_contextIndexes = null ; m_endDocumentOccured = true ; m_locator = null ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( DEBUG ) System . out . println ( "startPrefixMapping: prefix: " + prefix + ", uri: " + uri ) ; if ( null == prefix ) prefix = "" ; m_prefixMappings . addElement ( prefix ) ; m_prefixMappings . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { if ( DEBUG ) System . out . println ( "endPrefixMapping: prefix: " + prefix ) ; if ( null == prefix ) prefix = "" ; int index = m_contextIndexes . peek ( ) - 1 ; do { index = m_prefixMappings . indexOf ( prefix , ++ index ) ; } while ( ( index >= 0 ) && ( ( index & 0x01 ) == 0x01 ) ) ; if ( index > - 1 ) { m_prefixMappings . setElementAt ( "%@$#^@#" , index ) ; m_prefixMappings . setElementAt ( "%@$#^@#" , index + 1 ) ; } } protected boolean declAlreadyDeclared ( String prefix ) { int startDecls = m_contextIndexes . peek ( ) ; java . util . Vector prefixMappings = m_prefixMappings ; int nDecls = prefixMappings . size ( ) ; for ( int i = startDecls ; i < nDecls ; i += 2 ) { String prefixDecl = ( String ) prefixMappings . elementAt ( i ) ; if ( prefixDecl == null ) continue ; if ( prefixDecl . equals ( prefix ) ) return true ; } return false ; } boolean m_pastFirstElement = false ; public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( DEBUG ) { System . out . println ( "startElement: uri: " + uri + ", localname: " + localName + ", qname: " + qName + ", atts: " + attributes ) ; boolean DEBUG_ATTRS = true ; if ( DEBUG_ATTRS & attributes != null ) { int n = attributes . getLength ( ) ; if ( n == 0 ) System . out . println ( "\tempty attribute list" ) ; else for ( int i = 0 ; i < n ; i ++ ) System . out . println ( "\t attr: uri: " + attributes . getURI ( i ) + ", localname: " + attributes . getLocalName ( i ) + ", qname: " + attributes . getQName ( i ) + ", type: " + attributes . getType ( i ) + ", value: " + attributes . getValue ( i ) ) ; } } charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( uri , localName , DTM . ELEMENT_NODE ) ; String prefix = getPrefix ( qName , uri ) ; int prefixIndex = ( null != prefix ) ? m_valuesOrPrefixes . stringToIndex ( qName ) : 0 ; int elemNode = addNode ( DTM . ELEMENT_NODE , exName , m_parents . peek ( ) , m_previous , prefixIndex , true ) ; if ( m_indexing ) indexNode ( exName , elemNode ) ; m_parents . push ( elemNode ) ; int startDecls = m_contextIndexes . peek ( ) ; int nDecls = m_prefixMappings . size ( ) ; int prev = DTM . NULL ; if ( ! m_pastFirstElement ) { prefix = "xml" ; String declURL = "http://www.w3.org/XML/1998/namespace" ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; int val = m_valuesOrPrefixes . stringToIndex ( declURL ) ; prev = addNode ( DTM . NAMESPACE_NODE , exName , elemNode , prev , val , false ) ; m_pastFirstElement = true ; } for ( int i = startDecls ; i < nDecls ; i += 2 ) { prefix = ( String ) m_prefixMappings . elementAt ( i ) ; if ( prefix == null ) continue ; String declURL = ( String ) m_prefixMappings . elementAt ( i + 1 ) ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; int val = m_valuesOrPrefixes . stringToIndex ( declURL ) ; prev = addNode ( DTM . NAMESPACE_NODE , exName , elemNode , prev , val , false ) ; } int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrQName = attributes . getQName ( i ) ; String valString = attributes . getValue ( i ) ; prefix = getPrefix ( attrQName , attrUri ) ; int nodeType ; String attrLocalName = attributes . getLocalName ( i ) ; if ( ( null != attrQName ) && ( attrQName . equals ( "xmlns" ) || attrQName . startsWith ( "xmlns:" ) ) ) { if ( declAlreadyDeclared ( prefix ) ) continue ; nodeType = DTM . NAMESPACE_NODE ; } else { nodeType = DTM . ATTRIBUTE_NODE ; if ( attributes . getType ( i ) . equalsIgnoreCase ( "ID" ) ) setIDAttribute ( valString , elemNode ) ; } if ( null == valString ) valString = "" ; int val = m_valuesOrPrefixes . stringToIndex ( valString ) ; if ( null != prefix ) { prefixIndex = m_valuesOrPrefixes . stringToIndex ( attrQName ) ; int dataIndex = m_data . size ( ) ; m_data . addElement ( prefixIndex ) ; m_data . addElement ( val ) ; val = - dataIndex ; } exName = m_expandedNameTable . getExpandedTypeID ( attrUri , attrLocalName , nodeType ) ; prev = addNode ( nodeType , exName , elemNode , prev , val , false ) ; } if ( DTM . NULL != prev ) m_nextsib . setElementAt ( DTM . NULL , prev ) ; if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( elemNode ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( DEBUG ) System . out . println ( "endElement: uri: " + uri + ", localname: " + localName + ", qname: " + qName ) ; charactersFlush ( ) ; m_contextIndexes . quickPop ( 1 ) ; int topContextIndex = m_contextIndexes . peek ( ) ; if ( topContextIndex != m_prefixMappings . size ( ) ) { m_prefixMappings . setSize ( topContextIndex ) ; } int lastNode = m_previous ; m_previous = m_parents . pop ( ) ; if ( DTM . NULL == lastNode ) m_firstch . setElementAt ( DTM . NULL , m_previous ) ; else m_nextsib . setElementAt ( DTM . NULL , lastNode ) ; popShouldStripWhitespace ( ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( m_textPendingStart == - 1 ) { m_textPendingStart = m_chars . size ( ) ; m_coalescedTextType = m_textType ; } else if ( m_textType == DTM . TEXT_NODE ) { m_coalescedTextType = DTM . TEXT_NODE ; } m_chars . append ( ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { characters ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { if ( DEBUG ) System . out . println ( "processingInstruction: target: " + target + ", data: " + data ) ; charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( null , target , DTM . PROCESSING_INSTRUCTION_NODE ) ; int dataIndex = m_valuesOrPrefixes . stringToIndex ( data ) ; m_previous = addNode ( DTM . PROCESSING_INSTRUCTION_NODE , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void skippedEntity ( String name ) throws SAXException { } public void warning ( SAXParseException e ) throws SAXException { System . err . println ( e . getMessage ( ) ) ; } public void error ( SAXParseException e ) throws SAXException { throw e ; } public void fatalError ( SAXParseException e ) throws SAXException { throw e ; } public void elementDecl ( String name , String model ) throws SAXException { } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { } public void internalEntityDecl ( String name , String value ) throws SAXException { } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { m_insideDTD = true ; } public void endDTD ( ) throws SAXException { m_insideDTD = false ; } public void startEntity ( String name ) throws SAXException { } public void endEntity ( String name ) throws SAXException { } public void startCDATA ( ) throws SAXException { m_textType = DTM . CDATA_SECTION_NODE ; } public void endCDATA ( ) throws SAXException { m_textType = DTM . TEXT_NODE ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( m_insideDTD ) return ; charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( DTM . COMMENT_NODE ) ; int dataIndex = m_valuesOrPrefixes . stringToIndex ( new String ( ch , start , length ) ) ; m_previous = addNode ( DTM . COMMENT_NODE , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { if ( m_useSourceLocationProperty ) { node = makeNodeIdentity ( node ) ; return new NodeLocator ( null , m_sourceSystemId . elementAt ( node ) , m_sourceLine . elementAt ( node ) , m_sourceColumn . elementAt ( node ) ) ; } else if ( m_locator != null ) { return new NodeLocator ( null , m_locator . getSystemId ( ) , - 1 , - 1 ) ; } else if ( m_systemId != null ) { return new NodeLocator ( null , m_systemId , - 1 , - 1 ) ; } return null ; } } 	0	['74', '4', '2', '25', '188', '2227', '5', '21', '64', '0.907106164', '2452', '0.9375', '11', '0.56969697', '0.134246575', '2', '20', '31.7027027', '13', '2.2973', '0']
package org . apache . xalan . extensions ; import javax . xml . transform . ErrorListener ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public interface ExpressionContext { public Node getContextNode ( ) ; public NodeIterator getContextNodes ( ) ; public ErrorListener getErrorListener ( ) ; public double toNumber ( Node n ) ; public String toString ( Node n ) ; public XObject getVariableOrParam ( org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException ; public org . apache . xpath . XPathContext getXPathContext ( ) throws javax . xml . transform . TransformerException ; } 	0	['7', '1', '0', '17', '7', '21', '15', '3', '7', '2', '7', '0', '0', '0', '0.476190476', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . NodeIterator ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; public abstract class NodeIteratorBase implements NodeIterator { protected int _last = - 1 ; protected int _position = 0 ; protected int _markedNode ; protected int _startNode = NodeIterator . END ; protected boolean _includeSelf = false ; protected boolean _isRestartable = true ; public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; } abstract public NodeIterator setStartNode ( int node ) ; public NodeIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _includeSelf ? _startNode + 1 : _startNode ) ; _isRestartable = temp ; return this ; } public NodeIterator includeSelf ( ) { _includeSelf = true ; return this ; } public int getLast ( ) { if ( _last == - 1 ) { final int temp = _position ; setMark ( ) ; reset ( ) ; do { _last ++ ; } while ( next ( ) != END ) ; gotoMark ( ) ; _position = temp ; } return _last ; } public int getPosition ( ) { return _position == 0 ? 1 : _position ; } public boolean isReverse ( ) { return false ; } public NodeIterator cloneIterator ( ) { try { final NodeIteratorBase clone = ( NodeIteratorBase ) super . clone ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } protected final int returnNode ( final int node ) { _position ++ ; return node ; } protected final NodeIterator resetPosition ( ) { _position = 0 ; return this ; } } 	0	['11', '1', '0', '2', '18', '19', '0', '2', '9', '0.75', '138', '1', '0', '0', '0.424242424', '0', '0', '11', '3', '1.2727', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; abstract class Instruction extends SyntaxTreeNode { public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . NOT_IMPLEMENTED_ERR , getClass ( ) , this ) ; getParser ( ) . reportError ( FATAL , msg ) ; } } 	0	['3', '2', '26', '36', '9', '3', '28', '8', '2', '2', '24', '0', '0', '0.964285714', '0.5', '1', '2', '7', '1', '0.6667', '0']
package org . w3c . dom . xpath ; public interface XPathNSResolver { public String lookupNamespaceURI ( String prefix ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xml . serializer ; import org . xml . sax . SAXException ; public interface ExtendedLexicalHandler extends org . xml . sax . ext . LexicalHandler { public void comment ( String comment ) throws SAXException ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . w3c . dom . xpath ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; public interface XPathNamespace extends Node { public static final short XPATH_NAMESPACE_NODE = 13 ; public Element getOwnerElement ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class LiteralAttribute extends Instruction { private final String _name ; private final AttributeValue _value ; public LiteralAttribute ( String name , String value , Parser parser ) { _name = name ; _value = AttributeValue . create ( this , value , parser ) ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "LiteralAttribute name=" + _name + " value=" + _value ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _value . typeCheck ( stable ) ; typeCheckContents ( stable ) ; return Type . Void ; } protected boolean contextDependent ( ) { return _value . contextDependent ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _name ) ) ; _value . translate ( classGen , methodGen ) ; il . append ( methodGen . attribute ( ) ) ; } } 	0	['5', '3', '0', '18', '24', '0', '2', '16', '4', '0.25', '84', '1', '1', '0.933333333', '0.314285714', '1', '4', '15.4', '1', '0.8', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class AlternativePattern extends Pattern { private final Pattern _left ; private final Pattern _right ; public AlternativePattern ( Pattern left , Pattern right ) { _left = left ; _right = right ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public Pattern getLeft ( ) { return _left ; } public Pattern getRight ( ) { return _right ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _left . typeCheck ( stable ) ; _right . typeCheck ( stable ) ; return null ; } public double getPriority ( ) { double left = _left . getPriority ( ) ; double right = _right . getPriority ( ) ; if ( left < right ) return ( left ) ; else return ( right ) ; } public String toString ( ) { return "alternative(" + _left + ", " + _right + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; final InstructionHandle gotot = il . append ( new GOTO ( null ) ) ; il . append ( methodGen . loadContextNode ( ) ) ; _right . translate ( classGen , methodGen ) ; _left . _trueList . backPatch ( gotot ) ; _left . _falseList . backPatch ( gotot . getNext ( ) ) ; _trueList . append ( _right . _trueList . add ( gotot ) ) ; _falseList . append ( _right . _falseList ) ; } } 	0	['8', '4', '0', '15', '27', '0', '1', '14', '8', '0.142857143', '135', '1', '2', '0.925531915', '0.270833333', '2', '3', '15.625', '2', '1', '0']
package org . apache . xalan . lib ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public abstract class ExsltBase { protected static String toString ( Node n ) { if ( n instanceof DTMNodeProxy ) return ( ( DTMNodeProxy ) n ) . getStringValue ( ) ; else { String value = n . getNodeValue ( ) ; if ( value == null ) { NodeList nodelist = n . getChildNodes ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Node childNode = nodelist . item ( i ) ; buf . append ( toString ( childNode ) ) ; } return buf . toString ( ) ; } else return value ; } } protected static double toNumber ( Node n ) { double d = 0.0 ; String str = toString ( n ) ; try { d = Double . valueOf ( str ) . doubleValue ( ) ; } catch ( NumberFormatException e ) { d = Double . NaN ; } return d ; } } 	0	['3', '1', '4', '5', '14', '3', '4', '1', '1', '2', '62', '0', '0', '0', '0.5', '0', '0', '19.66666667', '4', '1.6667', '0']
package org . apache . xalan . transformer ; import java . util . Vector ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; public class KeyManager { private transient Vector m_key_tables = null ; public XNodeSet getNodeSetDTMByKey ( XPathContext xctxt , int doc , QName name , XMLString ref , PrefixResolver nscontext ) throws javax . xml . transform . TransformerException { XNodeSet nl = null ; ElemTemplateElement template = ( ElemTemplateElement ) nscontext ; if ( ( null != template ) && null != template . getStylesheetRoot ( ) . getKeysComposed ( ) ) { boolean foundDoc = false ; if ( null == m_key_tables ) { m_key_tables = new Vector ( 4 ) ; } else { int nKeyTables = m_key_tables . size ( ) ; for ( int i = 0 ; i < nKeyTables ; i ++ ) { KeyTable kt = ( KeyTable ) m_key_tables . elementAt ( i ) ; if ( kt . getKeyTableName ( ) . equals ( name ) && doc == kt . getDocKey ( ) ) { nl = kt . getNodeSetDTMByKey ( name , ref ) ; if ( nl != null ) { foundDoc = true ; break ; } } } } if ( ( null == nl ) && ! foundDoc ) { KeyTable kt = new KeyTable ( doc , nscontext , name , template . getStylesheetRoot ( ) . getKeysComposed ( ) , xctxt ) ; m_key_tables . addElement ( kt ) ; if ( doc == kt . getDocKey ( ) ) { foundDoc = true ; nl = kt . getNodeSetDTMByKey ( name , ref ) ; } } } return nl ; } } 	0	['2', '1', '0', '10', '14', '0', '2', '8', '2', '0', '104', '1', '0', '0', '0.583333333', '0', '0', '50.5', '1', '0.5', '0']
package org . apache . xml . utils ; import org . w3c . dom . Node ; public interface NodeConsumer { public void setOriginatingNode ( Node n ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Otherwise extends Instruction { public void display ( int indent ) { indent ( indent ) ; Util . println ( "Otherwise" ) ; indent ( indent + IndentIncrement ) ; displayContents ( indent + IndentIncrement ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Parser parser = getParser ( ) ; final ErrorMsg err = new ErrorMsg ( ErrorMsg . STRAY_OTHERWISE_ERR , this ) ; parser . reportError ( Constants . ERROR , err ) ; } } 	0	['4', '3', '0', '11', '12', '6', '2', '10', '3', '2', '43', '0', '0', '0.949152542', '0.4', '1', '4', '9.75', '1', '0.75', '0']
package org . apache . xpath ; public interface XPathVisitable { public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) ; } 	0	['1', '1', '0', '3', '1', '0', '1', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Neg extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( - right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return - ( m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '6', '7', '3', '1', '5', '3', '2', '19', '0', '0', '0.952380952', '0.555555556', '1', '1', '5.333333333', '1', '0.6667', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMDOMException ; import org . apache . xml . dtm . DTMIterator ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeFilter ; public class DTMNodeIterator implements org . w3c . dom . traversal . NodeIterator { private DTMIterator dtm_iter ; private boolean valid = true ; public DTMNodeIterator ( DTMIterator dtmIterator ) { try { dtm_iter = ( DTMIterator ) dtmIterator . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } public DTMIterator getDTMIterator ( ) { return dtm_iter ; } public void detach ( ) { valid = false ; } public boolean getExpandEntityReferences ( ) { return false ; } public NodeFilter getFilter ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public Node getRoot ( ) { int handle = dtm_iter . getRoot ( ) ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } public int getWhatToShow ( ) { return dtm_iter . getWhatToShow ( ) ; } public Node nextNode ( ) throws DOMException { if ( ! valid ) throw new DTMDOMException ( DOMException . INVALID_STATE_ERR ) ; int handle = dtm_iter . nextNode ( ) ; if ( handle == DTM . NULL ) return null ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } public Node previousNode ( ) { if ( ! valid ) throw new DTMDOMException ( DOMException . INVALID_STATE_ERR ) ; int handle = dtm_iter . previousNode ( ) ; if ( handle == DTM . NULL ) return null ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } } 	0	['9', '1', '0', '11', '19', '0', '7', '4', '9', '0.5', '106', '1', '1', '0', '0.555555556', '0', '0', '10.55555556', '3', '1.1111', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class ParentLocationPath extends RelativeLocationPath { private Expression _step ; private final RelativeLocationPath _path ; private Type stype ; private boolean _orderNodes = false ; private boolean _axisMismatch = false ; public ParentLocationPath ( RelativeLocationPath path , Expression step ) { _path = path ; _step = step ; _path . setParent ( this ) ; _step . setParent ( this ) ; if ( _step instanceof Step ) { _axisMismatch = checkAxisMismatch ( ) ; } } public void setAxis ( int axis ) { _path . setAxis ( axis ) ; } public int getAxis ( ) { return _path . getAxis ( ) ; } public RelativeLocationPath getPath ( ) { return ( _path ) ; } public Expression getStep ( ) { return ( _step ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _step . setParser ( parser ) ; _path . setParser ( parser ) ; } public String toString ( ) { return "ParentLocationPath(" + _path + ", " + _step + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { stype = _step . typeCheck ( stable ) ; _path . typeCheck ( stable ) ; if ( _axisMismatch ) enableNodeOrdering ( ) ; return _type = Type . NodeSet ; } public void enableNodeOrdering ( ) { SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof ParentLocationPath ) ( ( ParentLocationPath ) parent ) . enableNodeOrdering ( ) ; else { _orderNodes = true ; } } public boolean checkAxisMismatch ( ) { int left = _path . getAxis ( ) ; int right = ( ( Step ) _step ) . getAxis ( ) ; if ( ( ( left == Axis . ANCESTOR ) || ( left == Axis . ANCESTORORSELF ) ) && ( ( right == Axis . CHILD ) || ( right == Axis . DESCENDANT ) || ( right == Axis . DESCENDANTORSELF ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) || ( right == Axis . PRECEDINGSIBLING ) ) ) return true ; if ( ( left == Axis . CHILD ) && ( right == Axis . ANCESTOR ) || ( right == Axis . ANCESTORORSELF ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) ) return true ; if ( ( left == Axis . DESCENDANT ) || ( left == Axis . DESCENDANTORSELF ) ) return true ; if ( ( ( left == Axis . FOLLOWING ) || ( left == Axis . FOLLOWINGSIBLING ) ) && ( ( right == Axis . FOLLOWING ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) || ( right == Axis . PRECEDINGSIBLING ) ) ) return true ; if ( ( ( left == Axis . PRECEDING ) || ( left == Axis . PRECEDINGSIBLING ) ) && ( ( right == Axis . DESCENDANT ) || ( right == Axis . DESCENDANTORSELF ) || ( right == Axis . FOLLOWING ) || ( right == Axis . FOLLOWINGSIBLING ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) || ( right == Axis . PRECEDINGSIBLING ) ) ) return true ; if ( ( right == Axis . FOLLOWING ) && ( left == Axis . CHILD ) ) { if ( _path instanceof Step ) { int type = ( ( Step ) _path ) . getNodeType ( ) ; if ( type == DTM . ATTRIBUTE_NODE ) return true ; } } return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initSI = cpg . addMethodref ( STEP_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( STEP_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; _path . translate ( classGen , methodGen ) ; _step . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initSI ) ) ; Expression stp = _step ; if ( stp instanceof ParentLocationPath ) stp = ( ( ParentLocationPath ) stp ) . getStep ( ) ; if ( ( _path instanceof Step ) && ( stp instanceof Step ) ) { final int path = ( ( Step ) _path ) . getAxis ( ) ; final int step = ( ( Step ) stp ) . getAxis ( ) ; if ( ( path == Axis . DESCENDANTORSELF && step == Axis . CHILD ) || ( path == Axis . PRECEDING && step == Axis . PARENT ) ) { final int incl = cpg . addMethodref ( NODE_ITERATOR_BASE , "includeSelf" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEVIRTUAL ( incl ) ) ; } } if ( _orderNodes ) { final int order = cpg . addInterfaceMethodref ( DOM_INTF , ORDER_ITERATOR , ORDER_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( order , 3 ) ) ; } } } 	0	['11', '4', '0', '20', '42', '0', '2', '19', '11', '0.64', '380', '1', '3', '0.879518072', '0.204545455', '2', '7', '33.09090909', '35', '4.8182', '0']
package org . apache . xml . serializer ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . StringTokenizer ; public class Encodings extends Object { static final int m_defaultLastPrintable = 0x7F ; static final String ENCODINGS_FILE = "org/apache/xml/serializer/Encodings.properties" ; static final String ENCODINGS_PROP = "org.apache.xalan.serialize.encodings" ; private static final Class [ ] NO_CLASSES = new Class [ 0 ] ; private static final Object [ ] NO_OBJS = new Object [ 0 ] ; public static Writer getWriter ( OutputStream output , String encoding ) throws UnsupportedEncodingException { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { try { return new OutputStreamWriter ( output , _encodings [ i ] . javaName ) ; } catch ( java . lang . IllegalArgumentException iae ) { } catch ( UnsupportedEncodingException usee ) { } } } try { return new OutputStreamWriter ( output , encoding ) ; } catch ( java . lang . IllegalArgumentException iae ) { throw new UnsupportedEncodingException ( encoding ) ; } } public static Object getCharToByteConverter ( String encoding ) { Class charToByteConverterClass = null ; java . lang . reflect . Method getConverterMethod = null ; try { charToByteConverterClass = Class . forName ( "sun.io.CharToByteConverter" ) ; Class argTypes [ ] = new Class [ 1 ] ; argTypes [ 0 ] = String . class ; getConverterMethod = charToByteConverterClass . getMethod ( "getConverter" , argTypes ) ; } catch ( Exception e ) { System . err . println ( "Warning: Could not get charToByteConverterClass!" ) ; return null ; } Object args [ ] = new Object [ 1 ] ; for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { try { args [ 0 ] = _encodings [ i ] . javaName ; Object converter = getConverterMethod . invoke ( null , args ) ; if ( null != converter ) return converter ; } catch ( Exception iae ) { } } } return null ; } public static int getLastPrintable ( String encoding ) { EncodingInfo ei ; String normalizedEncoding = encoding . toUpperCase ( ) ; ei = ( EncodingInfo ) _encodingTableKeyJava . get ( normalizedEncoding ) ; if ( ei == null ) ei = ( EncodingInfo ) _encodingTableKeyMime . get ( normalizedEncoding ) ; if ( ei != null ) return ei . lastPrintable ; return m_defaultLastPrintable ; } public static int getLastPrintable ( ) { return m_defaultLastPrintable ; } public static final String DEFAULT_MIME_ENCODING = "UTF-8" ; public static String getMimeEncoding ( String encoding ) { if ( null == encoding ) { try { encoding = System . getProperty ( "file.encoding" , "UTF8" ) ; if ( null != encoding ) { String jencoding = ( encoding . equalsIgnoreCase ( "Cp1252" ) || encoding . equalsIgnoreCase ( "ISO8859_1" ) || encoding . equalsIgnoreCase ( "8859_1" ) || encoding . equalsIgnoreCase ( "UTF8" ) ) ? DEFAULT_MIME_ENCODING : convertJava2MimeEncoding ( encoding ) ; encoding = ( null != jencoding ) ? jencoding : DEFAULT_MIME_ENCODING ; } else { encoding = DEFAULT_MIME_ENCODING ; } } catch ( SecurityException se ) { encoding = DEFAULT_MIME_ENCODING ; } } else { encoding = convertJava2MimeEncoding ( encoding ) ; } return encoding ; } public static String convertJava2MimeEncoding ( String encoding ) { EncodingInfo enc = ( EncodingInfo ) _encodingTableKeyJava . get ( encoding . toUpperCase ( ) ) ; if ( null != enc ) return enc . name ; return encoding ; } public static String convertMime2JavaEncoding ( String encoding ) { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { return _encodings [ i ] . javaName ; } } return encoding ; } private static EncodingInfo [ ] loadEncodingInfo ( ) { URL url = null ; try { String urlString = null ; try { urlString = System . getProperty ( ENCODINGS_PROP , "" ) ; } catch ( SecurityException e ) { } if ( urlString != null && urlString . length ( ) > 0 ) url = new URL ( urlString ) ; if ( url == null ) { ClassLoader cl = null ; try { java . lang . reflect . Method getCCL = Thread . class . getMethod ( "getContextClassLoader" , NO_CLASSES ) ; if ( getCCL != null ) { cl = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; } } catch ( Exception e ) { } if ( cl != null ) { url = cl . getResource ( ENCODINGS_FILE ) ; } } if ( url == null ) url = ClassLoader . getSystemResource ( ENCODINGS_FILE ) ; Properties props = new Properties ( ) ; if ( url != null ) { InputStream is = url . openStream ( ) ; props . load ( is ) ; is . close ( ) ; } else { } int totalEntries = props . size ( ) ; int totalMimeNames = 0 ; Enumeration keys = props . keys ( ) ; for ( int i = 0 ; i < totalEntries ; ++ i ) { String javaName = ( String ) keys . nextElement ( ) ; String val = props . getProperty ( javaName ) ; totalMimeNames ++ ; int pos = val . indexOf ( ' ' ) ; for ( int j = 0 ; j < pos ; ++ j ) if ( val . charAt ( j ) == ',' ) totalMimeNames ++ ; } EncodingInfo [ ] ret = new EncodingInfo [ totalMimeNames ] ; int j = 0 ; keys = props . keys ( ) ; for ( int i = 0 ; i < totalEntries ; ++ i ) { String javaName = ( String ) keys . nextElement ( ) ; String val = props . getProperty ( javaName ) ; int pos = val . indexOf ( ' ' ) ; String mimeName ; int lastPrintable ; if ( pos < 0 ) { mimeName = val ; lastPrintable = 0x00FF ; } else { lastPrintable = Integer . decode ( val . substring ( pos ) . trim ( ) ) . intValue ( ) ; StringTokenizer st = new StringTokenizer ( val . substring ( 0 , pos ) , "," ) ; for ( boolean first = true ; st . hasMoreTokens ( ) ; first = false ) { mimeName = st . nextToken ( ) ; ret [ j ] = new EncodingInfo ( mimeName , javaName , lastPrintable ) ; _encodingTableKeyMime . put ( mimeName . toUpperCase ( ) , ret [ j ] ) ; if ( first ) _encodingTableKeyJava . put ( javaName . toUpperCase ( ) , ret [ j ] ) ; j ++ ; } } } return ret ; } catch ( java . net . MalformedURLException mue ) { throw new org . apache . xml . utils . WrappedRuntimeException ( mue ) ; } catch ( java . io . IOException ioe ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ioe ) ; } } private static final Hashtable _encodingTableKeyJava = new Hashtable ( ) ; private static final Hashtable _encodingTableKeyMime = new Hashtable ( ) ; private static final EncodingInfo [ ] _encodings = loadEncodingInfo ( ) ; } 	0	['11', '1', '0', '7', '51', '31', '5', '2', '8', '0.927272727', '489', '0.454545455', '1', '0', '0.3', '0', '0', '42.45454545', '15', '3.4545', '0']
package org . apache . xalan . xsltc . trax ; import javax . xml . transform . Result ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . sax . TransformerHandler ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . DOMWSFilter ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . DefaultHandler ; public class TransformerHandlerImpl implements TransformerHandler , DeclHandler { private TransformerImpl _transformer ; private AbstractTranslet _translet = null ; private String _systemId ; private SAXImpl _dom = null ; private ContentHandler _handler = null ; private LexicalHandler _lexHandler = null ; private DTDHandler _dtdHandler = null ; private DeclHandler _declHandler = null ; private Result _result = null ; private Locator _locator = null ; private boolean _done = false ; private boolean _isIdentity = false ; public TransformerHandlerImpl ( TransformerImpl transformer ) { _transformer = transformer ; if ( transformer . isIdentity ( ) ) { _handler = new DefaultHandler ( ) ; _isIdentity = true ; } else { _translet = _transformer . getTranslet ( ) ; } } public String getSystemId ( ) { return _systemId ; } public void setSystemId ( String id ) { _systemId = id ; } public Transformer getTransformer ( ) { return _transformer ; } public void setResult ( Result result ) throws IllegalArgumentException { _result = result ; if ( _isIdentity ) { try { SerializationHandler outputHandler = _transformer . getOutputHandler ( result ) ; _transformer . transferOutputProperties ( outputHandler ) ; _handler = outputHandler ; _lexHandler = outputHandler ; } catch ( TransformerException e ) { _result = null ; } } else if ( _done ) { try { _transformer . setDOM ( _dom ) ; _transformer . transform ( null , _result ) ; } catch ( TransformerException e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } } } public void characters ( char [ ] ch , int start , int length ) throws SAXException { _handler . characters ( ch , start , length ) ; } public void startDocument ( ) throws SAXException { if ( _result == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_SET_RESULT_ERR ) ; throw new SAXException ( err . toString ( ) ) ; } if ( ! _isIdentity ) { boolean hasIdCall = ( _translet != null ) ? _translet . hasIdCall ( ) : false ; XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; DTMWSFilter wsFilter ; if ( _translet != null && _translet instanceof StripFilter ) { wsFilter = new DOMWSFilter ( _translet ) ; } else { wsFilter = null ; } _dom = ( SAXImpl ) dtmManager . getDTM ( null , false , wsFilter , true , false , hasIdCall ) ; _handler = _dom . getBuilder ( ) ; _lexHandler = ( LexicalHandler ) _handler ; _dtdHandler = ( DTDHandler ) _handler ; _declHandler = ( DeclHandler ) _handler ; _dom . setDocumentURI ( _systemId ) ; if ( _locator != null ) { _handler . setDocumentLocator ( _locator ) ; } } _handler . startDocument ( ) ; } public void endDocument ( ) throws SAXException { _handler . endDocument ( ) ; if ( ! _isIdentity ) { if ( _result != null ) { try { _transformer . setDOM ( _dom ) ; _transformer . transform ( null , _result ) ; } catch ( TransformerException e ) { throw new SAXException ( e ) ; } } _done = true ; _transformer . setDOM ( _dom ) ; } } public void startElement ( String uri , String localName , String qname , Attributes attributes ) throws SAXException { _handler . startElement ( uri , localName , qname , attributes ) ; } public void endElement ( String namespaceURI , String localName , String qname ) throws SAXException { _handler . endElement ( namespaceURI , localName , qname ) ; } public void processingInstruction ( String target , String data ) throws SAXException { _handler . processingInstruction ( target , data ) ; } public void startCDATA ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endCDATA ( ) ; } } public void comment ( char [ ] ch , int start , int length ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . comment ( ch , start , length ) ; } } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { _handler . ignorableWhitespace ( ch , start , length ) ; } public void setDocumentLocator ( Locator locator ) { _locator = locator ; if ( _handler != null ) { _handler . setDocumentLocator ( locator ) ; } } public void skippedEntity ( String name ) throws SAXException { _handler . skippedEntity ( name ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { _handler . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { _handler . endPrefixMapping ( prefix ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startDTD ( name , publicId , systemId ) ; } } public void endDTD ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endDTD ( ) ; } } public void startEntity ( String name ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startEntity ( name ) ; } } public void endEntity ( String name ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endEntity ( name ) ; } } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( _dtdHandler != null ) { _dtdHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( _dtdHandler != null ) { _dtdHandler . notationDecl ( name , publicId , systemId ) ; } } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( _declHandler != null ) { _declHandler . attributeDecl ( eName , aName , type , valueDefault , value ) ; } } public void elementDecl ( String name , String model ) throws SAXException { if ( _declHandler != null ) { _declHandler . elementDecl ( name , model ) ; } } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( _declHandler != null ) { _declHandler . externalEntityDecl ( name , publicId , systemId ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( _declHandler != null ) { _declHandler . internalEntityDecl ( name , value ) ; } } } 	0	['29', '1', '0', '14', '73', '116', '2', '12', '29', '0.857142857', '462', '1', '3', '0', '0.237068966', '0', '0', '14.51724138', '2', '1', '0']
package org . apache . xml . serializer ; public final class Method { public static final String XML = "xml" ; public static final String HTML = "html" ; public static final String XHTML = "xhtml" ; public static final String TEXT = "text" ; public static final String UNKNOWN = "" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '9', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xml . serializer ; import javax . xml . transform . SourceLocator ; import org . xml . sax . SAXException ; public interface ExtendedContentHandler extends org . xml . sax . ContentHandler { public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException ; public void addAttributes ( org . xml . sax . Attributes atts ) throws org . xml . sax . SAXException ; public void addAttribute ( String qName , String value ) ; public void characters ( String chars ) throws SAXException ; public void endElement ( String elemName ) throws SAXException ; public void startElement ( String uri , String localName , String qName ) throws org . xml . sax . SAXException ; public void startElement ( String qName ) throws SAXException ; public void namespaceAfterStartElement ( String uri , String prefix ) throws SAXException ; public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException ; public void entityReference ( String entityName ) throws SAXException ; public NamespaceMappings getNamespaceMappings ( ) ; public String getPrefix ( String uri ) ; public String getNamespaceURI ( String name , boolean isElement ) ; public String getNamespaceURIFromPrefix ( String prefix ) ; public void setSourceLocator ( SourceLocator locator ) ; } 	0	['15', '1', '0', '2', '15', '105', '1', '1', '15', '2', '15', '0', '0', '0', '0.413333333', '0', '0', '0', '1', '1', '0']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . PrefixResolverDefault ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XPathAPI { public static Node selectSingleNode ( Node contextNode , String str ) throws TransformerException { return selectSingleNode ( contextNode , str , contextNode ) ; } public static Node selectSingleNode ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { NodeIterator nl = selectNodeIterator ( contextNode , str , namespaceNode ) ; return nl . nextNode ( ) ; } public static NodeIterator selectNodeIterator ( Node contextNode , String str ) throws TransformerException { return selectNodeIterator ( contextNode , str , contextNode ) ; } public static NodeIterator selectNodeIterator ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodeset ( ) ; } public static NodeList selectNodeList ( Node contextNode , String str ) throws TransformerException { return selectNodeList ( contextNode , str , contextNode ) ; } public static NodeList selectNodeList ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodelist ( ) ; } public static XObject eval ( Node contextNode , String str ) throws TransformerException { return eval ( contextNode , str , contextNode ) ; } public static XObject eval ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XPathContext xpathSupport = new XPathContext ( ) ; PrefixResolverDefault prefixResolver = new PrefixResolverDefault ( ( namespaceNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( ( Document ) namespaceNode ) . getDocumentElement ( ) : namespaceNode ) ; XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } public static XObject eval ( Node contextNode , String str , PrefixResolver prefixResolver ) throws TransformerException { XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; XPathContext xpathSupport = new XPathContext ( ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } } 	0	['10', '1', '0', '6', '21', '45', '1', '5', '10', '2', '116', '0', '0', '0', '0.5', '0', '0', '10.6', '1', '0.9', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . MethodType ; final class SymbolTable { private final Hashtable _stylesheets = new Hashtable ( ) ; private final Hashtable _primops = new Hashtable ( ) ; private Hashtable _variables = null ; private Hashtable _templates = null ; private Hashtable _attributeSets = null ; private Hashtable _aliases = null ; private Hashtable _excludedURI = null ; private Hashtable _decimalFormats = null ; public DecimalFormatting getDecimalFormatting ( QName name ) { if ( _decimalFormats == null ) return null ; return ( ( DecimalFormatting ) _decimalFormats . get ( name ) ) ; } public void addDecimalFormatting ( QName name , DecimalFormatting symbols ) { if ( _decimalFormats == null ) _decimalFormats = new Hashtable ( ) ; _decimalFormats . put ( name , symbols ) ; } public Stylesheet addStylesheet ( QName name , Stylesheet node ) { return ( Stylesheet ) _stylesheets . put ( name , node ) ; } public Stylesheet lookupStylesheet ( QName name ) { return ( Stylesheet ) _stylesheets . get ( name ) ; } public Template addTemplate ( Template template ) { final QName name = template . getName ( ) ; if ( _templates == null ) _templates = new Hashtable ( ) ; return ( Template ) _templates . put ( name , template ) ; } public Template lookupTemplate ( QName name ) { if ( _templates == null ) return null ; return ( Template ) _templates . get ( name ) ; } public Variable addVariable ( Variable variable ) { if ( _variables == null ) _variables = new Hashtable ( ) ; final String name = variable . getName ( ) . getStringRep ( ) ; return ( Variable ) _variables . put ( name , variable ) ; } public Param addParam ( Param parameter ) { if ( _variables == null ) _variables = new Hashtable ( ) ; final String name = parameter . getName ( ) . getStringRep ( ) ; return ( Param ) _variables . put ( name , parameter ) ; } public Variable lookupVariable ( QName qname ) { if ( _variables == null ) return null ; final String name = qname . getStringRep ( ) ; final Object obj = _variables . get ( name ) ; return obj instanceof Variable ? ( Variable ) obj : null ; } public Param lookupParam ( QName qname ) { if ( _variables == null ) return null ; final String name = qname . getStringRep ( ) ; final Object obj = _variables . get ( name ) ; return obj instanceof Param ? ( Param ) obj : null ; } public SyntaxTreeNode lookupName ( QName qname ) { if ( _variables == null ) return null ; final String name = qname . getStringRep ( ) ; return ( SyntaxTreeNode ) _variables . get ( name ) ; } public AttributeSet addAttributeSet ( AttributeSet atts ) { if ( _attributeSets == null ) _attributeSets = new Hashtable ( ) ; return ( AttributeSet ) _attributeSets . put ( atts . getName ( ) , atts ) ; } public AttributeSet lookupAttributeSet ( QName name ) { if ( _attributeSets == null ) return null ; return ( AttributeSet ) _attributeSets . get ( name ) ; } public void addPrimop ( String name , MethodType mtype ) { Vector methods = ( Vector ) _primops . get ( name ) ; if ( methods == null ) { _primops . put ( name , methods = new Vector ( ) ) ; } methods . addElement ( mtype ) ; } public Vector lookupPrimop ( String name ) { return ( Vector ) _primops . get ( name ) ; } private int _nsCounter = 0 ; public String generateNamespacePrefix ( ) { return ( new String ( "ns" + ( _nsCounter ++ ) ) ) ; } private SyntaxTreeNode _current = null ; public void setCurrentNode ( SyntaxTreeNode node ) { _current = node ; } public String lookupNamespace ( String prefix ) { if ( _current == null ) return ( Constants . EMPTYSTRING ) ; return ( _current . lookupNamespace ( prefix ) ) ; } public void addPrefixAlias ( String prefix , String alias ) { if ( _aliases == null ) _aliases = new Hashtable ( ) ; _aliases . put ( prefix , alias ) ; } public String lookupPrefixAlias ( String prefix ) { if ( _aliases == null ) return null ; return ( String ) _aliases . get ( prefix ) ; } public void excludeURI ( String uri ) { if ( uri == null ) return ; if ( _excludedURI == null ) _excludedURI = new Hashtable ( ) ; Integer refcnt = ( Integer ) _excludedURI . get ( uri ) ; if ( refcnt == null ) refcnt = new Integer ( 1 ) ; else refcnt = new Integer ( refcnt . intValue ( ) + 1 ) ; _excludedURI . put ( uri , refcnt ) ; } public void excludeNamespaces ( String prefixes ) { if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri ; if ( prefix . equals ( "#default" ) ) uri = lookupNamespace ( Constants . EMPTYSTRING ) ; else uri = lookupNamespace ( prefix ) ; if ( uri != null ) excludeURI ( uri ) ; } } } public boolean isExcludedNamespace ( String uri ) { if ( uri != null && _excludedURI != null ) { final Integer refcnt = ( Integer ) _excludedURI . get ( uri ) ; return ( refcnt != null && refcnt . intValue ( ) > 0 ) ; } return false ; } public void unExcludeNamespaces ( String prefixes ) { if ( _excludedURI == null ) return ; if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri ; if ( prefix . equals ( "#default" ) ) uri = lookupNamespace ( Constants . EMPTYSTRING ) ; else uri = lookupNamespace ( prefix ) ; Integer refcnt = ( Integer ) _excludedURI . get ( uri ) ; if ( refcnt != null ) _excludedURI . put ( uri , new Integer ( refcnt . intValue ( ) - 1 ) ) ; } } } } 	0	['25', '1', '0', '91', '48', '214', '89', '9', '24', '0.891666667', '494', '1', '1', '0', '0.185454545', '0', '0', '18.36', '5', '2.2', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class GenerateIdCall extends FunctionCall { public GenerateIdCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; } else { argument ( ) . translate ( classGen , methodGen ) ; } final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "generate_idF" , GET_NODE_NAME_SIG ) ) ) ; } } 	0	['2', '4', '0', '10', '12', '1', '0', '10', '2', '2', '39', '0', '0', '0.989690722', '0.6', '2', '4', '18.5', '2', '1', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Div extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) / right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) / m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xpath . axes ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . functions . FuncLast ; import org . apache . xpath . functions . FuncPosition ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . operations . Div ; import org . apache . xpath . operations . Minus ; import org . apache . xpath . operations . Mod ; import org . apache . xpath . operations . Mult ; import org . apache . xpath . operations . Plus ; import org . apache . xpath . operations . Quo ; import org . apache . xpath . operations . Variable ; public class HasPositionalPredChecker extends XPathVisitor { private boolean m_hasPositionalPred = false ; private int m_predDepth = 0 ; public static boolean check ( LocPathIterator path ) { HasPositionalPredChecker hppc = new HasPositionalPredChecker ( ) ; path . callVisitors ( null , hppc ) ; return hppc . m_hasPositionalPred ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { if ( ( func instanceof FuncPosition ) || ( func instanceof FuncLast ) ) m_hasPositionalPred = true ; return true ; } public boolean visitPredicate ( ExpressionOwner owner , Expression pred ) { m_predDepth ++ ; if ( m_predDepth == 1 ) { if ( ( pred instanceof Variable ) || ( pred instanceof XNumber ) || ( pred instanceof Div ) || ( pred instanceof Plus ) || ( pred instanceof Minus ) || ( pred instanceof Mod ) || ( pred instanceof Quo ) || ( pred instanceof Mult ) || ( pred instanceof org . apache . xpath . operations . Number ) || ( pred instanceof Function ) ) m_hasPositionalPred = true ; else pred . callVisitors ( owner , this ) ; } m_predDepth -- ; return false ; } } 	0	['4', '2', '0', '17', '7', '0', '1', '16', '4', '0.166666667', '93', '1', '0', '0.8', '0.4', '0', '0', '21.75', '12', '4', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class NodeCounterGenerator extends ClassGenerator { private Instruction _aloadTranslet ; public NodeCounterGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; } public void setTransletIndex ( int index ) { _aloadTranslet = new ALOAD ( index ) ; } public Instruction loadTranslet ( ) { return _aloadTranslet ; } public boolean isExternal ( ) { return true ; } } 	0	['4', '4', '0', '5', '6', '4', '1', '4', '4', '0.666666667', '26', '1', '0', '0.964285714', '0.45', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . xalan . xsltc . dom ; public interface DOMBuilder extends ExtendedSAX { } 	0	['0', '1', '0', '5', '0', '0', '4', '1', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNodeSet ; public class FilterExprIterator extends BasicTestIterator { private Expression m_expr ; transient private XNodeSet m_exprObj ; private boolean m_mustHardReset = false ; private boolean m_canDetachNodeset = true ; public FilterExprIterator ( ) { super ( null ) ; } public FilterExprIterator ( Expression expr ) { super ( null ) ; m_expr = expr ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_exprObj = FilterExprIteratorSimple . executeFilterExpr ( context , m_execContext , getPrefixResolver ( ) , getIsTopLevel ( ) , m_stackFrame , m_expr ) ; } protected int getNextNode ( ) { if ( null != m_exprObj ) { m_lastFetched = m_exprObj . nextNode ( ) ; } else m_lastFetched = DTM . NULL ; return m_lastFetched ; } public void detach ( ) { super . detach ( ) ; m_exprObj . detach ( ) ; m_exprObj = null ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_expr . fixupVariables ( vars , globalsSize ) ; } public Expression getInnerExpression ( ) { return m_expr ; } public void setInnerExpression ( Expression expr ) { expr . exprSetParent ( this ) ; m_expr = expr ; } public int getAnalysisBits ( ) { if ( null != m_expr && m_expr instanceof PathComponent ) { return ( ( PathComponent ) m_expr ) . getAnalysisBits ( ) ; } return WalkerFactory . BIT_FILTER ; } public boolean isDocOrdered ( ) { return m_exprObj . isDocOrdered ( ) ; } class filterExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_expr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FilterExprIterator . this ) ; m_expr = exp ; } } public void callPredicateVisitors ( XPathVisitor visitor ) { m_expr . callVisitors ( new filterExprOwner ( ) , visitor ) ; super . callPredicateVisitors ( visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FilterExprIterator fet = ( FilterExprIterator ) expr ; if ( ! m_expr . deepEquals ( fet . m_expr ) ) return false ; return true ; } } 	0	['14', '6', '0', '11', '32', '0', '1', '11', '11', '0.730769231', '163', '1', '2', '0.914285714', '0.234693878', '4', '8', '10.35714286', '3', '1.2143', '0']
