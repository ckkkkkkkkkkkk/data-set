package org . gjt . sp . jedit ; import javax . swing . text . * ; import java . lang . reflect . * ; import java . awt . datatransfer . * ; import java . awt . Toolkit ; import java . io . * ; import java . util . Vector ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . util . Log ; public class Registers { public static void copy ( JEditTextArea textArea , char register ) { String selection = textArea . getSelectedText ( ) ; if ( selection == null ) return ; setRegister ( register , selection ) ; HistoryModel . getModel ( "clipboard" ) . addItem ( selection ) ; } public static void append ( JEditTextArea textArea , char register ) { append ( textArea , register , "\n" , false ) ; } public static void append ( JEditTextArea textArea , char register , String separator ) { append ( textArea , register , separator , false ) ; } public static void append ( JEditTextArea textArea , char register , String separator , boolean cut ) { if ( cut && ! textArea . isEditable ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } String selection = textArea . getSelectedText ( ) ; if ( selection == null ) return ; Register reg = getRegister ( register ) ; String registerContents = reg . toString ( ) ; if ( reg != null && registerContents != null ) { if ( registerContents . endsWith ( separator ) ) selection = registerContents + selection ; else selection = registerContents + separator + selection ; } setRegister ( register , selection ) ; HistoryModel . getModel ( "clipboard" ) . addItem ( selection ) ; if ( cut ) textArea . setSelectedText ( "" ) ; } public static void cut ( JEditTextArea textArea , char register ) { if ( textArea . isEditable ( ) ) { String selection = textArea . getSelectedText ( ) ; if ( selection == null ) return ; setRegister ( register , selection ) ; HistoryModel . getModel ( "clipboard" ) . addItem ( selection ) ; textArea . setSelectedText ( "" ) ; } else textArea . getToolkit ( ) . beep ( ) ; } public static void paste ( JEditTextArea textArea , char register ) { if ( ! textArea . isEditable ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } Register reg = getRegister ( register ) ; if ( reg == null ) { textArea . getToolkit ( ) . beep ( ) ; return ; } else { String selection = reg . toString ( ) ; if ( selection == null ) { textArea . getToolkit ( ) . beep ( ) ; return ; } int magic = textArea . getMagicCaretPosition ( ) ; textArea . setSelectedText ( selection ) ; if ( textArea . getCaretPosition ( ) != textArea . getLineEndOffset ( textArea . getCaretLine ( ) ) - 1 ) { textArea . setMagicCaretPosition ( magic ) ; } else { } HistoryModel . getModel ( "clipboard" ) . addItem ( selection ) ; } } public static Register getRegister ( char name ) { if ( registers == null || name >= registers . length ) return null ; else return registers [ name ] ; } public static void setRegister ( char name , Register newRegister ) { if ( name >= registers . length ) { Register [ ] newRegisters = new Register [ Math . min ( 1 << 16 , name * 2 ) ] ; System . arraycopy ( registers , 0 , newRegisters , 0 , registers . length ) ; registers = newRegisters ; } registers [ name ] = newRegister ; } public static void setRegister ( char name , String value ) { if ( name >= registers . length ) { Register [ ] newRegisters = new Register [ Math . min ( 1 << 16 , name * 2 ) ] ; System . arraycopy ( registers , 0 , newRegisters , 0 , registers . length ) ; registers = newRegisters ; registers [ name ] = new StringRegister ( value ) ; } else { Register register = registers [ name ] ; if ( register != null ) register . setValue ( value ) ; else registers [ name ] = new StringRegister ( value ) ; } } public static void clearRegister ( char name ) { if ( name >= registers . length ) return ; Register register = registers [ name ] ; if ( name == '$' || name == '%' ) register . setValue ( "" ) ; else registers [ name ] = null ; } public static Register [ ] getRegisters ( ) { return registers ; } public interface Register { String toString ( ) ; void setValue ( String value ) ; } public static class ClipboardRegister implements Register { Clipboard clipboard ; public ClipboardRegister ( Clipboard clipboard ) { this . clipboard = clipboard ; } public void setValue ( String value ) { StringSelection selection = new StringSelection ( value ) ; clipboard . setContents ( selection , null ) ; } public String toString ( ) { try { String selection = ( String ) ( clipboard . getContents ( this ) . getTransferData ( DataFlavor . stringFlavor ) ) ; boolean trailingEOL = ( selection . endsWith ( "\n" ) || selection . endsWith ( System . getProperty ( "line.separator" ) ) ) ; BufferedReader in = new BufferedReader ( new StringReader ( selection ) ) ; StringBuffer buf = new StringBuffer ( ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { buf . append ( line ) ; buf . append ( '\n' ) ; } if ( ! trailingEOL ) buf . setLength ( buf . length ( ) - 1 ) ; return buf . toString ( ) ; } catch ( Exception e ) { Log . log ( Log . NOTICE , this , e ) ; return null ; } } } public static class StringRegister implements Register { private String value ; public StringRegister ( String value ) { this . value = value ; } public void setValue ( String value ) { this . value = value ; } public String toString ( ) { return value ; } public void dispose ( ) { } } private static Register [ ] registers ; private Registers ( ) { } static { registers = new Register [ 256 ] ; registers [ '$' ] = new ClipboardRegister ( Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ) ; try { Method method = Toolkit . class . getMethod ( "getSystemSelection" , new Class [ 0 ] ) ; Clipboard selection = ( Clipboard ) method . invoke ( Toolkit . getDefaultToolkit ( ) , new Object [ 0 ] ) ; if ( selection != null ) { Log . log ( Log . DEBUG , Registers . class , "Toolkit.getSystemSelection() detected" ) ; Log . log ( Log . DEBUG , Registers . class , "% register is system selection" ) ; registers [ '%' ] = new ClipboardRegister ( selection ) ; } else { Log . log ( Log . DEBUG , Registers . class , "Toolkit.getSystemSelection() " + "detected, but returns null" ) ; Log . log ( Log . DEBUG , Registers . class , "% register is jEdit-specific" ) ; registers [ '%' ] = new StringRegister ( "" ) ; } } catch ( Exception e ) { Log . log ( Log . DEBUG , Registers . class , "Toolkit.getSystemSelection() not detected" ) ; Log . log ( Log . DEBUG , Registers . class , "% register is jEdit-specific" ) ; registers [ '%' ] = new StringRegister ( "" ) ; } } } 	0	['14', '1', '0', '9', '45', '61', '3', '6', '11', '0.769230769', '425', '1', '1', '0', '0.294871795', '0', '0', '29.14285714', '8', '2.4286', '0']
package gnu . regexp ; import java . util . Vector ; final class RETokenRepeated extends REToken { private REToken token ; private int min , max ; private boolean stingy ; RETokenRepeated ( int subIndex , REToken token , int min , int max ) { super ( subIndex ) ; this . token = token ; this . min = min ; this . max = max ; } void makeStingy ( ) { stingy = true ; } boolean isStingy ( ) { return stingy ; } int getMinimumLength ( ) { return ( min * token . getMinimumLength ( ) ) ; } boolean match ( CharIndexed input , REMatch mymatch ) { int numRepeats = 0 ; REMatch newMatch = mymatch ; REMatch last = null ; REMatch current ; Vector positions = new Vector ( ) ; positions . addElement ( newMatch ) ; REMatch doables ; REMatch doablesLast ; REMatch recurrent ; do { if ( stingy && ( numRepeats >= min ) ) { REMatch result = matchRest ( input , newMatch ) ; if ( result != null ) { mymatch . assignFrom ( result ) ; return true ; } } doables = null ; doablesLast = null ; for ( current = newMatch ; current != null ; current = current . next ) { recurrent = ( REMatch ) current . clone ( ) ; if ( token . match ( input , recurrent ) ) { if ( doables == null ) { doables = recurrent ; doablesLast = recurrent ; } else { doablesLast . next = recurrent ; } while ( doablesLast . next != null ) { doablesLast = doablesLast . next ; } } } if ( doables == null ) break ; newMatch = doables ; ++ numRepeats ; positions . addElement ( newMatch ) ; } while ( numRepeats < max ) ; if ( numRepeats < min ) return false ; int posIndex = positions . size ( ) ; REMatch allResults = null ; REMatch allResultsLast = null ; REMatch results = null ; while ( -- posIndex >= min ) { newMatch = ( REMatch ) positions . elementAt ( posIndex ) ; results = matchRest ( input , newMatch ) ; if ( results != null ) { if ( allResults == null ) { allResults = results ; allResultsLast = results ; } else { allResultsLast . next = results ; } while ( allResultsLast . next != null ) { allResultsLast = allResultsLast . next ; } } } if ( allResults != null ) { mymatch . assignFrom ( allResults ) ; return true ; } return false ; } private REMatch matchRest ( CharIndexed input , final REMatch newMatch ) { REMatch current , single ; REMatch doneIndex = null ; REMatch doneIndexLast = null ; for ( current = newMatch ; current != null ; current = current . next ) { single = ( REMatch ) current . clone ( ) ; if ( next ( input , single ) ) { if ( doneIndex == null ) { doneIndex = single ; doneIndexLast = single ; } else { doneIndexLast . next = single ; } while ( doneIndexLast . next != null ) { doneIndexLast = doneIndexLast . next ; } } } return doneIndex ; } void dump ( StringBuffer os ) { os . append ( "(?:" ) ; token . dumpAll ( os ) ; os . append ( ')' ) ; if ( ( max == Integer . MAX_VALUE ) && ( min <= 1 ) ) os . append ( ( min == 0 ) ? '*' : '+' ) ; else if ( ( min == 0 ) && ( max == 1 ) ) os . append ( '?' ) ; else { os . append ( '{' ) . append ( min ) ; if ( max > min ) { os . append ( ',' ) ; if ( max != Integer . MAX_VALUE ) os . append ( max ) ; } os . append ( '}' ) ; } if ( stingy ) os . append ( '?' ) ; } } 	0	['7', '2', '0', '4', '21', '0', '1', '3', '0', '0.541666667', '300', '1', '1', '0.538461538', '0.333333333', '1', '3', '41.28571429', '16', '4.7143', '0']
package gnu . regexp ; import java . io . Serializable ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class REMatchEnumeration implements Enumeration , Serializable { private static final int YES = 1 ; private static final int MAYBE = 0 ; private static final int NO = - 1 ; private int more ; private REMatch match ; private RE expr ; private CharIndexed input ; private int eflags ; private StringBuffer buffer ; REMatchEnumeration ( RE expr , CharIndexed input , int index , int eflags ) { more = MAYBE ; this . expr = expr ; this . input = input ; input . move ( index ) ; this . eflags = eflags ; } public boolean hasMoreElements ( ) { return hasMoreMatches ( null ) ; } public boolean hasMoreMatches ( ) { return hasMoreMatches ( null ) ; } public boolean hasMoreMatches ( StringBuffer buffer ) { if ( more == MAYBE ) { match = expr . getMatchImpl ( input , 0 , eflags , buffer ) ; if ( match != null ) { input . move ( ( match . end [ 0 ] > 0 ) ? match . end [ 0 ] : 1 ) ; more = YES ; } else more = NO ; } return ( more == YES ) ; } public Object nextElement ( ) throws NoSuchElementException { return nextMatch ( ) ; } public REMatch nextMatch ( ) throws NoSuchElementException { if ( hasMoreElements ( ) ) { more = ( input . isValid ( ) ) ? MAYBE : NO ; return match ; } throw new NoSuchElementException ( ) ; } } 	0	['6', '1', '0', '3', '11', '9', '1', '3', '5', '0.6', '113', '1', '3', '0', '0.333333333', '0', '0', '16.33333333', '5', '1.5', '0']
package bsh ; import java . lang . reflect . Array ; class BSHType extends SimpleNode implements BshClassManager . Listener { private Class baseType ; private int arrayDims ; private Class type ; BSHType ( int id ) { super ( id ) ; BshClassManager . addCMListener ( this ) ; } public void addArrayDimension ( ) { arrayDims ++ ; } public Class getType ( NameSpace namespace ) throws EvalError { if ( type != null ) return type ; SimpleNode node = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( node instanceof BSHPrimitiveType ) baseType = ( ( BSHPrimitiveType ) node ) . getType ( ) ; else baseType = ( ( BSHAmbiguousName ) node ) . toClass ( namespace ) ; if ( arrayDims > 0 ) { try { int [ ] dims = new int [ arrayDims ] ; Object obj = Array . newInstance ( baseType , dims ) ; type = obj . getClass ( ) ; } catch ( Exception e ) { throw new EvalError ( "Couldn't construct array type" , this ) ; } } else type = baseType ; return type ; } public Class getBaseType ( ) { return baseType ; } public int getArrayDims ( ) { return arrayDims ; } public void classLoaderChanged ( ) { type = null ; baseType = null ; } } 	0	['6', '2', '0', '16', '14', '3', '8', '8', '5', '0.666666667', '92', '1', '0', '0.782608696', '0.444444444', '0', '0', '13.83333333', '1', '0.8333', '0']
package gnu . regexp ; import java . util . Vector ; final class RETokenOneOf extends REToken { private Vector options ; private boolean negative ; RETokenOneOf ( int subIndex , String optionsStr , boolean negative , boolean insens ) { super ( subIndex ) ; options = new Vector ( ) ; this . negative = negative ; for ( int i = 0 ; i < optionsStr . length ( ) ; i ++ ) options . addElement ( new RETokenChar ( subIndex , optionsStr . charAt ( i ) , insens ) ) ; } RETokenOneOf ( int subIndex , Vector options , boolean negative ) { super ( subIndex ) ; this . options = options ; this . negative = negative ; } int getMinimumLength ( ) { int min = Integer . MAX_VALUE ; int x ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { if ( ( x = ( ( REToken ) options . elementAt ( i ) ) . getMinimumLength ( ) ) < min ) min = x ; } return min ; } boolean match ( CharIndexed input , REMatch mymatch ) { if ( negative && ( input . charAt ( mymatch . index ) == CharIndexed . OUT_OF_BOUNDS ) ) return false ; REMatch newMatch = null ; REMatch last = null ; REToken tk ; boolean isMatch ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { tk = ( REToken ) options . elementAt ( i ) ; REMatch tryMatch = ( REMatch ) mymatch . clone ( ) ; if ( tk . match ( input , tryMatch ) ) { if ( negative ) return false ; if ( next ( input , tryMatch ) ) { if ( last == null ) { newMatch = tryMatch ; last = tryMatch ; } else { last . next = tryMatch ; last = tryMatch ; } } } } if ( newMatch != null ) { if ( negative ) { return false ; } else { mymatch . assignFrom ( newMatch ) ; return true ; } } else { if ( negative ) { ++ mymatch . index ; return next ( input , mymatch ) ; } else { return false ; } } } void dump ( StringBuffer os ) { os . append ( negative ? "[^" : "(?:" ) ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { if ( ! negative && ( i > 0 ) ) os . append ( '|' ) ; ( ( REToken ) options . elementAt ( i ) ) . dumpAll ( os ) ; } os . append ( negative ? ']' : ')' ) ; } } 	0	['5', '2', '0', '5', '22', '0', '1', '4', '0', '0.125', '206', '1', '0', '0.7', '0.35', '1', '3', '39.8', '11', '4', '0']
package bsh ; import java . lang . reflect . Array ; class BSHArrayDimensions extends SimpleNode { public Class baseType ; private int arrayDims ; public int [ ] dimensions ; BSHArrayDimensions ( int id ) { super ( id ) ; } public void addArrayDimension ( ) { arrayDims ++ ; } public Object eval ( Class type , CallStack callstack , Interpreter interpreter ) throws EvalError { Interpreter . debug ( "array base type = " + type ) ; baseType = type ; return eval ( callstack , interpreter ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode child = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( child instanceof BSHArrayInitializer ) { if ( baseType == null ) throw new EvalError ( "Internal Array Eval err:  unknown base type" , this ) ; Object initValue = ( ( BSHArrayInitializer ) child ) . eval ( baseType , arrayDims , callstack , interpreter ) ; Class arrayClass = initValue . getClass ( ) ; dimensions = new int [ Reflect . getArrayDimensions ( arrayClass ) ] ; if ( dimensions . length != arrayDims ) throw new EvalError ( "Incompatible initializer. Allocation calls for a " + arrayDims + " dimensional array, but initializer is a " + dimensions . length + " dimensional array" , this ) ; Object arraySlice = initValue ; for ( int i = 0 ; i < dimensions . length ; i ++ ) { dimensions [ i ] = Array . getLength ( arraySlice ) ; if ( dimensions [ i ] > 0 ) arraySlice = Array . get ( arraySlice , 0 ) ; } return initValue ; } else { dimensions = new int [ jjtGetNumChildren ( ) ] ; for ( int i = 0 ; i < dimensions . length ; i ++ ) { try { Object length = ( ( SimpleNode ) jjtGetChild ( i ) ) . eval ( callstack , interpreter ) ; dimensions [ i ] = ( ( Primitive ) length ) . intValue ( ) ; } catch ( Exception e ) { throw new EvalError ( "Array index: " + i + " does not evaluate to an integer" , this ) ; } } } return Primitive . VOID ; } } 	0	['4', '2', '0', '10', '21', '2', '2', '8', '3', '0.555555556', '174', '0.333333333', '0', '0.857142857', '0.5', '1', '1', '41.75', '1', '0.75', '0']
package gnu . regexp ; import java . io . Serializable ; class CharIndexedString implements CharIndexed , Serializable { private String s ; private int anchor ; private int len ; CharIndexedString ( String str , int index ) { s = str ; len = s . length ( ) ; anchor = index ; } public char charAt ( int index ) { int pos = anchor + index ; return ( ( pos < len ) && ( pos >= 0 ) ) ? s . charAt ( pos ) : OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( anchor < len ) ; } public boolean move ( int index ) { return ( ( anchor += index ) < len ) ; } } 	0	['4', '1', '0', '2', '7', '0', '1', '1', '3', '0.222222222', '62', '1', '0', '0', '0.666666667', '0', '0', '13.75', '3', '1.75', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . plaf . metal . MetalLookAndFeel ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public interface DockableWindowContainer { void addDockableWindow ( DockableWindow win ) ; void saveDockableWindow ( DockableWindow win ) ; void removeDockableWindow ( DockableWindow win ) ; void showDockableWindow ( DockableWindow win ) ; boolean isDockableWindowVisible ( DockableWindow win ) ; public class TabbedPane extends JTabbedPane implements DockableWindowContainer { public static final int SPLITTER_WIDTH = 10 ; String position ; int dimension ; boolean collapsed ; public TabbedPane ( String position ) { this . position = position ; try { dimension = Integer . parseInt ( jEdit . getProperty ( "view.dock." + position + ".dimension" ) ) ; } catch ( NumberFormatException nf ) { dimension = - 1 ; } if ( dimension <= SPLITTER_WIDTH ) collapsed = true ; collapsed = jEdit . getBooleanProperty ( "view.dock." + position + ".collapsed" ) ; MouseHandler mouseHandler = new MouseHandler ( ) ; addMouseListener ( mouseHandler ) ; addMouseMotionListener ( mouseHandler ) ; propertiesChanged ( ) ; } public boolean isCollapsed ( ) { return getComponentCount ( ) == 0 || collapsed ; } public void setCollapsed ( boolean collapsed ) { if ( getComponentCount ( ) == 0 ) return ; if ( dimension <= SPLITTER_WIDTH ) dimension = - 1 ; this . collapsed = collapsed ; revalidate ( ) ; } public void toggleCollapsed ( ) { setCollapsed ( ! collapsed ) ; } public void saveDimension ( ) { jEdit . setProperty ( "view.dock." + position + ".dimension" , String . valueOf ( dimension ) ) ; jEdit . setBooleanProperty ( "view.dock." + position + ".collapsed" , collapsed ) ; } public void propertiesChanged ( ) { setBorder ( new DockBorder ( position ) ) ; int tabsPos = Integer . parseInt ( jEdit . getProperty ( "view.docking.tabsPos" ) ) ; if ( tabsPos == 0 ) setTabPlacement ( JTabbedPane . TOP ) ; else if ( tabsPos == 1 ) setTabPlacement ( JTabbedPane . BOTTOM ) ; } public Dimension getMinimumSize ( ) { return new Dimension ( 0 , 0 ) ; } public Dimension getPreferredSize ( ) { if ( getComponentCount ( ) == 0 ) return new Dimension ( 0 , 0 ) ; Dimension prefSize = super . getPreferredSize ( ) ; if ( collapsed ) { if ( position . equals ( DockableWindowManager . LEFT ) || position . equals ( DockableWindowManager . RIGHT ) ) prefSize . width = SPLITTER_WIDTH ; else if ( position . equals ( DockableWindowManager . TOP ) || position . equals ( DockableWindowManager . BOTTOM ) ) prefSize . height = SPLITTER_WIDTH ; } else if ( dimension <= SPLITTER_WIDTH ) { if ( position . equals ( DockableWindowManager . LEFT ) || position . equals ( DockableWindowManager . RIGHT ) ) dimension = prefSize . width ; else if ( position . equals ( DockableWindowManager . TOP ) || position . equals ( DockableWindowManager . BOTTOM ) ) dimension = prefSize . height ; } else { if ( position . equals ( DockableWindowManager . LEFT ) || position . equals ( DockableWindowManager . RIGHT ) ) prefSize . width = dimension ; else if ( position . equals ( DockableWindowManager . TOP ) || position . equals ( DockableWindowManager . BOTTOM ) ) prefSize . height = dimension ; } return prefSize ; } public void addDockableWindow ( DockableWindow win ) { addTab ( jEdit . getProperty ( win . getName ( ) + ".title" ) , win . getComponent ( ) ) ; setSelectedComponent ( win . getComponent ( ) ) ; collapsed = false ; revalidate ( ) ; } public void saveDockableWindow ( DockableWindow win ) { } public void removeDockableWindow ( DockableWindow win ) { remove ( win . getComponent ( ) ) ; revalidate ( ) ; } public void showDockableWindow ( DockableWindow win ) { setSelectedComponent ( win . getComponent ( ) ) ; if ( collapsed ) { collapsed = false ; revalidate ( ) ; } win . getComponent ( ) . requestFocus ( ) ; } public boolean isDockableWindowVisible ( DockableWindow win ) { return ! collapsed ; } class MouseHandler extends MouseAdapter implements MouseMotionListener { boolean canDrag ; int dragStartDimension ; Point dragStart ; public void mousePressed ( MouseEvent evt ) { dragStartDimension = dimension ; dragStart = evt . getPoint ( ) ; dragStart . x = ( getWidth ( ) - dragStart . x ) ; dragStart . y = ( getHeight ( ) - dragStart . y ) ; } public void mouseClicked ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) setCollapsed ( ! isCollapsed ( ) ) ; } public void mouseMoved ( MouseEvent evt ) { Border border = getBorder ( ) ; Insets insets = border . getBorderInsets ( TabbedPane . this ) ; int cursor = Cursor . DEFAULT_CURSOR ; canDrag = false ; if ( position . equals ( DockableWindowManager . TOP ) ) { if ( evt . getY ( ) >= getHeight ( ) - insets . bottom ) { cursor = Cursor . N_RESIZE_CURSOR ; canDrag = true ; } } else if ( position . equals ( DockableWindowManager . LEFT ) ) { if ( evt . getX ( ) >= getWidth ( ) - insets . right ) { cursor = Cursor . W_RESIZE_CURSOR ; canDrag = true ; } } else if ( position . equals ( DockableWindowManager . BOTTOM ) ) { if ( evt . getY ( ) <= insets . top ) { cursor = Cursor . S_RESIZE_CURSOR ; canDrag = true ; } } else if ( position . equals ( DockableWindowManager . RIGHT ) ) { if ( evt . getX ( ) <= insets . left ) { cursor = Cursor . E_RESIZE_CURSOR ; canDrag = true ; } } setCursor ( Cursor . getPredefinedCursor ( cursor ) ) ; } public void mouseDragged ( MouseEvent evt ) { if ( ! canDrag ) return ; if ( dragStart == null ) return ; if ( position . equals ( DockableWindowManager . TOP ) ) dimension = evt . getY ( ) + dragStart . y ; else if ( position . equals ( DockableWindowManager . LEFT ) ) dimension = evt . getX ( ) + dragStart . x ; else if ( position . equals ( DockableWindowManager . BOTTOM ) ) { dimension = getHeight ( ) - ( evt . getY ( ) ) ; } else if ( position . equals ( DockableWindowManager . RIGHT ) ) { dimension = getWidth ( ) - ( evt . getX ( ) ) ; } dimension = Math . max ( SPLITTER_WIDTH , dimension ) ; if ( dimension == SPLITTER_WIDTH ) { dimension = dragStartDimension ; collapsed = true ; } else collapsed = false ; revalidate ( ) ; } public void mouseExited ( MouseEvent evt ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } static class DockBorder implements Border { String position ; Insets insets ; Color color1 ; Color color2 ; Color color3 ; DockBorder ( String position ) { if ( UIManager . getLookAndFeel ( ) instanceof MetalLookAndFeel ) { color1 = MetalLookAndFeel . getControlHighlight ( ) ; color2 = MetalLookAndFeel . getControlDarkShadow ( ) ; color3 = MetalLookAndFeel . getControl ( ) ; } else { color1 = color2 = null ; color3 = GUIUtilities . parseColor ( jEdit . getProperty ( "view.docking.borderColor" ) ) ; } this . position = position ; insets = new Insets ( position . equals ( DockableWindowManager . BOTTOM ) ? SPLITTER_WIDTH : 0 , position . equals ( DockableWindowManager . RIGHT ) ? SPLITTER_WIDTH : 0 , position . equals ( DockableWindowManager . TOP ) ? SPLITTER_WIDTH : 0 , position . equals ( DockableWindowManager . LEFT ) ? SPLITTER_WIDTH : 0 ) ; } public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { if ( position . equals ( DockableWindowManager . BOTTOM ) ) paintHorizBorder ( g , x , y , width ) ; else if ( position . equals ( DockableWindowManager . RIGHT ) ) paintVertBorder ( g , x , y , height ) ; else if ( position . equals ( DockableWindowManager . TOP ) ) { paintHorizBorder ( g , x , y + height - SPLITTER_WIDTH , width ) ; } else if ( position . equals ( DockableWindowManager . LEFT ) ) { paintVertBorder ( g , x + width - SPLITTER_WIDTH , y , height ) ; } } public Insets getBorderInsets ( Component c ) { return insets ; } public boolean isBorderOpaque ( ) { return false ; } private void paintHorizBorder ( Graphics g , int x , int y , int width ) { g . setColor ( color3 ) ; g . fillRect ( x , y , width , SPLITTER_WIDTH ) ; if ( color1 == null || color2 == null ) return ; for ( int i = 0 ; i < width / 4 - 1 ; i ++ ) { g . setColor ( color1 ) ; g . drawLine ( x + i * 4 + 2 , y + 3 , x + i * 4 + 2 , y + 3 ) ; g . setColor ( color2 ) ; g . drawLine ( x + i * 4 + 3 , y + 4 , x + i * 4 + 3 , y + 4 ) ; g . setColor ( color1 ) ; g . drawLine ( x + i * 4 + 4 , y + 5 , x + i * 4 + 4 , y + 5 ) ; g . setColor ( color2 ) ; g . drawLine ( x + i * 4 + 5 , y + 6 , x + i * 4 + 5 , y + 6 ) ; } } private void paintVertBorder ( Graphics g , int x , int y , int height ) { g . setColor ( color3 ) ; g . fillRect ( x , y , SPLITTER_WIDTH , height ) ; if ( color1 == null || color2 == null ) return ; for ( int i = 0 ; i < height / 4 - 1 ; i ++ ) { g . setColor ( color1 ) ; g . drawLine ( x + 3 , y + i * 4 + 2 , x + 3 , y + i * 4 + 2 ) ; g . setColor ( color2 ) ; g . drawLine ( x + 4 , y + i * 4 + 3 , x + 4 , y + i * 4 + 3 ) ; g . setColor ( color1 ) ; g . drawLine ( x + 5 , y + i * 4 + 4 , x + 5 , y + i * 4 + 4 ) ; g . setColor ( color2 ) ; g . drawLine ( x + 6 , y + i * 4 + 5 , x + 6 , y + i * 4 + 5 ) ; } } } } public class Floating extends JFrame implements DockableWindowContainer { public Floating ( DockableWindowManager dockableWindowManager ) { this . dockableWindowManager = dockableWindowManager ; setIconImage ( GUIUtilities . getPluginIcon ( ) ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; } public void addDockableWindow ( DockableWindow window ) { this . window = window ; name = window . getName ( ) ; setTitle ( jEdit . getProperty ( name + ".title" ) ) ; getContentPane ( ) . add ( BorderLayout . CENTER , window . getComponent ( ) ) ; pack ( ) ; GUIUtilities . loadGeometry ( this , name ) ; show ( ) ; } public void saveDockableWindow ( DockableWindow window ) { GUIUtilities . saveGeometry ( this , name ) ; } public void removeDockableWindow ( DockableWindow window ) { super . dispose ( ) ; } public void showDockableWindow ( DockableWindow window ) { toFront ( ) ; requestFocus ( ) ; } public boolean isDockableWindowVisible ( DockableWindow win ) { return true ; } public void dispose ( ) { dockableWindowManager . removeDockableWindow ( name ) ; } private DockableWindowManager dockableWindowManager ; private DockableWindow window ; private String name ; } } 	0	['5', '1', '0', '5', '5', '10', '4', '1', '5', '2', '5', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . textarea ; import java . awt . * ; class TextRendererAWT extends TextRenderer { float _drawChars ( char [ ] text , int start , int len , Graphics g , float x , float y ) { g . drawChars ( text , start , len , ( int ) x , ( int ) y ) ; return ( float ) g . getFontMetrics ( ) . charsWidth ( text , start , len ) ; } float _getWidth ( char [ ] text , int start , int len , Font font ) { return ( float ) Toolkit . getDefaultToolkit ( ) . getFontMetrics ( font ) . charsWidth ( text , start , len ) ; } int _xToOffset ( char [ ] text , int start , int len , Font font , float x , boolean round ) { int end = start + len ; FontMetrics fm = Toolkit . getDefaultToolkit ( ) . getFontMetrics ( font ) ; int width = 0 ; for ( int i = start ; i < end ; i ++ ) { int newWidth = fm . charWidth ( text [ i ] ) ; if ( x <= width + newWidth ) { if ( round && ( x - width ) < ( width + newWidth - x ) ) return i - start ; else return i + 1 - start ; } else width += newWidth ; } return - 1 ; } } 	0	['4', '2', '0', '1', '11', '6', '1', '1', '0', '2', '93', '0', '0', '0.785714286', '0.571428571', '1', '2', '22.25', '5', '1.75', '0']
package bsh ; import java . util . Hashtable ; import java . lang . reflect . InvocationTargetException ; class BSHLHSPrimarySuffix extends SimpleNode { public static final int INDEX = 1 , NAME = 2 , PROPERTY = 3 ; public int operation ; Object index ; public String field ; public String method ; BSHLHSPrimarySuffix ( int id ) { super ( id ) ; } public LHS doLHSSuffix ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError { try { switch ( operation ) { case INDEX : return doIndex ( obj , callstack , interpreter ) ; case NAME : return doName ( obj , callstack , interpreter ) ; case PROPERTY : return doProperty ( obj , callstack , interpreter ) ; default : throw new InterpreterError ( "LHS suffix" ) ; } } catch ( ReflectError e ) { throw new EvalError ( "reflection error: " + e , this ) ; } catch ( InvocationTargetException e ) { throw new TargetError ( e . getTargetException ( ) , this ) ; } } private LHS doName ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError , InvocationTargetException { if ( jjtGetNumChildren ( ) == 0 ) return Reflect . getLHSObjectField ( obj , field ) ; else { Object [ ] oa = ( ( BSHArguments ) jjtGetChild ( 0 ) ) . getArguments ( callstack , interpreter ) ; try { obj = Reflect . invokeObjectMethod ( interpreter , obj , method , oa , this ) ; } catch ( EvalError ee ) { throw new EvalError ( ee . getMessage ( ) , this ) ; } return Reflect . getLHSObjectField ( obj , field ) ; } } private LHS doIndex ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError { if ( ! obj . getClass ( ) . isArray ( ) ) throw new EvalError ( "Not an array" , this ) ; int index ; try { Primitive val = ( Primitive ) ( ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ) ; index = val . intValue ( ) ; } catch ( Exception e ) { throw new EvalError ( "You can only index arrays by integer types" , this ) ; } return new LHS ( obj , index ) ; } private LHS doProperty ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError { if ( obj == Primitive . VOID ) throw new EvalError ( "Attempt to access property on a void type" , this ) ; else if ( obj instanceof Primitive ) throw new EvalError ( "Attempt to access property on a primitive" , this ) ; Object value = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( ! ( value instanceof String ) ) throw new EvalError ( "Property expression must be a String or identifier." , this ) ; Interpreter . debug ( "LHS property access: " ) ; return new LHS ( obj , ( String ) value ) ; } } 	0	['5', '2', '0', '14', '27', '10', '2', '12', '1', '1.071428571', '182', '0', '0', '0.818181818', '0.72', '0', '0', '34', '1', '0.8', '0']
package bsh ; import java . util . Vector ; import java . io . * ; public class Interpreter implements Runnable , ConsoleInterface { public static final String VERSION = "1.2b1" ; public static boolean DEBUG , TRACE ; static PrintStream debug ; static { staticInit ( ) ; } static This systemObject ; public static boolean strictJava = false ; Parser parser ; NameSpace globalNameSpace ; Reader in ; PrintStream out ; PrintStream err ; ConsoleInterface console ; Interpreter parent ; String sourceFileInfo ; public boolean noExitOnEOF ; private boolean evalOnly , interactive ; public Interpreter ( Reader in , PrintStream out , PrintStream err , boolean interactive , NameSpace namespace , Interpreter parent , String sourceFileInfo ) { parser = new Parser ( in ) ; long t1 = System . currentTimeMillis ( ) ; this . in = in ; this . out = out ; this . err = err ; this . interactive = interactive ; debug = err ; this . parent = parent ; this . sourceFileInfo = sourceFileInfo ; if ( namespace == null ) this . globalNameSpace = new NameSpace ( "global" ) ; else this . globalNameSpace = namespace ; globalNameSpace . loadDefaultImports ( ) ; if ( ! ( getu ( "bsh" ) instanceof bsh . This ) ) initRootSystemObject ( ) ; if ( interactive ) loadRCFiles ( ) ; long t2 = System . currentTimeMillis ( ) ; Interpreter . debug ( "Time to initialize interpreter: " + ( t2 - t1 ) ) ; } public Interpreter ( Reader in , PrintStream out , PrintStream err , boolean interactive , NameSpace namespace ) { this ( in , out , err , interactive , namespace , null , null ) ; } public Interpreter ( Reader in , PrintStream out , PrintStream err , boolean interactive ) { this ( in , out , err , interactive , null ) ; } public Interpreter ( ConsoleInterface console , NameSpace globalNameSpace ) { this ( console . getIn ( ) , console . getOut ( ) , console . getErr ( ) , true , globalNameSpace ) ; setConsole ( console ) ; } public Interpreter ( ConsoleInterface console ) { this ( console , null ) ; } public Interpreter ( ) { this ( new StringReader ( "" ) , System . out , System . err , false , null ) ; evalOnly = true ; setu ( "bsh.evalOnly" , new Primitive ( true ) ) ; } public void setConsole ( ConsoleInterface console ) { this . console = console ; setu ( "bsh.console" , console ) ; } private void initRootSystemObject ( ) { setu ( "bsh" , new NameSpace ( "Bsh Object" ) . getThis ( this ) ) ; if ( systemObject == null ) systemObject = new NameSpace ( "Bsh System Object" ) . getThis ( this ) ; setu ( "bsh.system" , systemObject ) ; This helpText = new NameSpace ( "Bsh Command Help Text" ) . getThis ( this ) ; setu ( "bsh.help" , helpText ) ; try { setu ( "bsh.cwd" , System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException e ) { setu ( "bsh.cwd" , "." ) ; } setu ( "bsh.interactive" , new Primitive ( interactive ) ) ; setu ( "bsh.evalOnly" , new Primitive ( evalOnly ) ) ; } public void setNameSpace ( NameSpace globalNameSpace ) { this . globalNameSpace = globalNameSpace ; } public NameSpace getNameSpace ( ) { return globalNameSpace ; } public static void main ( String [ ] args ) { if ( args . length > 0 ) { String filename = args [ 0 ] ; String [ ] bshArgs ; if ( args . length > 1 ) { bshArgs = new String [ args . length - 1 ] ; System . arraycopy ( args , 1 , bshArgs , 0 , args . length - 1 ) ; } else bshArgs = new String [ 0 ] ; Interpreter interpreter = new Interpreter ( ) ; interpreter . setu ( "bsh.args" , bshArgs ) ; try { interpreter . source ( filename , interpreter . globalNameSpace ) ; } catch ( FileNotFoundException e ) { System . out . println ( "File not found: " + e ) ; } catch ( EvalError e ) { System . out . println ( "Evaluation Error: " + e ) ; } catch ( IOException e ) { System . out . println ( "I/O Error: " + e ) ; } } else { InputStream src ; if ( System . getProperty ( "os.name" ) . startsWith ( "Windows" ) && System . getProperty ( "java.version" ) . startsWith ( "1.1." ) ) { src = new FilterInputStream ( System . in ) { public int available ( ) throws IOException { return 0 ; } } ; } else src = System . in ; Reader in = new CommandLineReader ( new InputStreamReader ( src ) ) ; Interpreter interpreter = new Interpreter ( in , System . out , System . err , true ) ; interpreter . run ( ) ; } } public void run ( ) { if ( evalOnly ) throw new RuntimeException ( "bsh Interpreter: No stream" ) ; if ( interactive ) try { eval ( "printBanner();" ) ; } catch ( EvalError e ) { println ( "BeanShell " + VERSION + " - by Pat Niemeyer (pat@pat.net)" ) ; } boolean eof = false ; CallStack callstack = new CallStack ( ) ; callstack . push ( globalNameSpace ) ; while ( ! eof ) { try { System . out . flush ( ) ; System . err . flush ( ) ; Thread . yield ( ) ; if ( interactive ) print ( "bsh % " ) ; eof = Line ( ) ; if ( get_jjtree ( ) . nodeArity ( ) > 0 ) { SimpleNode node = ( SimpleNode ) ( get_jjtree ( ) . rootNode ( ) ) ; if ( DEBUG ) node . dump ( ">" ) ; Object ret = node . eval ( callstack , this ) ; if ( callstack . depth ( ) > 1 ) throw new InterpreterError ( "Callstack growing: " + callstack ) ; if ( ret instanceof ReturnControl ) ret = ( ( ReturnControl ) ret ) . value ; if ( ret != Primitive . VOID ) { setVariable ( "$_" , ret ) ; Object show = getu ( "bsh.show" ) ; if ( show instanceof Boolean && ( ( Boolean ) show ) . booleanValue ( ) == true ) println ( "<" + ret + ">" ) ; } } } catch ( ParseException e ) { error ( "Parser Error: " + e . getMessage ( DEBUG ) ) ; if ( DEBUG ) e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; parser . reInitInput ( in ) ; } catch ( InterpreterError e ) { error ( "Internal Error: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; } catch ( TargetError e ) { error ( "// Uncaught Exception: " + e ) ; if ( DEBUG ) e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; } catch ( EvalError e ) { if ( interactive ) error ( e . toString ( ) ) ; else error ( e . getMessage ( ) ) ; if ( DEBUG ) e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; } catch ( Exception e ) { error ( "Unknown error: " + e ) ; e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; } catch ( TokenMgrError e ) { error ( "Error parsing input: " + e ) ; parser . reInitTokenInput ( in ) ; if ( ! interactive ) eof = true ; } finally { get_jjtree ( ) . reset ( ) ; if ( callstack . depth ( ) > 1 ) { callstack . clear ( ) ; callstack . push ( globalNameSpace ) ; } } } if ( interactive && ! noExitOnEOF ) System . exit ( 0 ) ; } public Object source ( String filename , NameSpace nameSpace ) throws FileNotFoundException , IOException , EvalError { File file = pathToFile ( filename ) ; debug ( "Sourcing file: " + file ) ; Reader in = new BufferedReader ( new FileReader ( file ) ) ; return eval ( in , nameSpace , filename ) ; } public Object source ( String filename ) throws FileNotFoundException , IOException , EvalError { return source ( filename , globalNameSpace ) ; } public Object eval ( Reader in , NameSpace nameSpace , String sourceFileInfo ) throws EvalError { Object retVal = null ; debug ( "eval: nameSpace = " + nameSpace ) ; Interpreter localInterpreter = new Interpreter ( in , out , err , false , nameSpace , this , sourceFileInfo ) ; CallStack callstack = new CallStack ( ) ; callstack . push ( nameSpace ) ; boolean eof = false ; while ( ! eof ) { SimpleNode node = null ; try { eof = localInterpreter . Line ( ) ; if ( localInterpreter . get_jjtree ( ) . nodeArity ( ) > 0 ) { node = ( SimpleNode ) localInterpreter . get_jjtree ( ) . rootNode ( ) ; node . setSourceFile ( sourceFileInfo ) ; if ( TRACE ) println ( "// " + node . getText ( ) ) ; retVal = node . eval ( callstack , localInterpreter ) ; if ( callstack . depth ( ) > 1 ) throw new InterpreterError ( "Callstack growing: " + callstack ) ; if ( retVal instanceof ReturnControl ) { retVal = ( ( ReturnControl ) retVal ) . value ; break ; } } } catch ( ParseException e ) { throw new EvalError ( "Sourced file: " + sourceFileInfo + " parser Error: " + e . getMessage ( DEBUG ) , node ) ; } catch ( InterpreterError e ) { e . printStackTrace ( ) ; throw new EvalError ( "Sourced file: " + sourceFileInfo + " internal Error: " + e . getMessage ( ) , node ) ; } catch ( TargetError e ) { if ( DEBUG ) e . printStackTrace ( ) ; if ( e . getNode ( ) == null ) e . setNode ( node ) ; e . reThrow ( "Sourced file: " + sourceFileInfo ) ; } catch ( EvalError e ) { if ( DEBUG ) e . printStackTrace ( ) ; if ( e . getNode ( ) == null ) e . setNode ( node ) ; e . reThrow ( "Sourced file: " + sourceFileInfo ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new EvalError ( "Sourced file: " + sourceFileInfo + " unknown error: " + e . getMessage ( ) , node ) ; } catch ( TokenMgrError e ) { throw new EvalError ( "Sourced file: " + sourceFileInfo + " Token Parsing Error: " + e . getMessage ( ) , node ) ; } finally { localInterpreter . get_jjtree ( ) . reset ( ) ; if ( callstack . depth ( ) > 1 ) { callstack . clear ( ) ; callstack . push ( nameSpace ) ; } } } return Primitive . unwrap ( retVal ) ; } public Object eval ( Reader in ) throws EvalError { return eval ( in , globalNameSpace , "eval stream" ) ; } public Object eval ( String statement ) throws EvalError { return eval ( statement , globalNameSpace ) ; } public Object eval ( String statement , NameSpace nameSpace ) throws EvalError { String s = ( statement . endsWith ( ";" ) ? statement : statement + ";" ) ; return eval ( new StringReader ( s ) , nameSpace , "<Inline eval of: " + s + " >" ) ; } public final void error ( String s ) { if ( console != null ) console . error ( "// Error: " + s + "\n" ) ; else { err . println ( "// Error: " + s ) ; err . flush ( ) ; } } public Reader getIn ( ) { return in ; } public PrintStream getOut ( ) { return out ; } public PrintStream getErr ( ) { return err ; } public final void println ( String s ) { print ( s + "\n" ) ; } public final void print ( String s ) { if ( console != null ) { console . print ( s ) ; } else { out . print ( s ) ; out . flush ( ) ; } } public final static void debug ( String s ) { if ( DEBUG ) debug . println ( "// Debug: " + s ) ; } public Object get ( String name ) throws EvalError { Object ret = globalNameSpace . get ( name , this ) ; return Primitive . unwrap ( ret ) ; } Object getu ( String name ) { try { return get ( name ) ; } catch ( EvalError e ) { throw new InterpreterError ( "set: " + e ) ; } } public void set ( String name , Object value ) throws EvalError { if ( value == null ) value = Primitive . NULL ; CallStack callstack = new CallStack ( ) ; LHS lhs = globalNameSpace . getNameResolver ( name ) . toLHS ( callstack , this ) ; lhs . assign ( value ) ; } void setu ( String name , Object value ) { try { set ( name , value ) ; } catch ( EvalError e ) { throw new InterpreterError ( "set: " + e ) ; } } public void set ( String name , long value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void set ( String name , int value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void set ( String name , double value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void set ( String name , float value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void set ( String name , boolean value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void unset ( String name ) throws EvalError { CallStack callstack = new CallStack ( ) ; LHS lhs = globalNameSpace . getNameResolver ( name ) . toLHS ( callstack , this ) ; if ( lhs . type != LHS . VARIABLE ) throw new EvalError ( "Can't unset, not a variable: " + name ) ; lhs . assign ( null ) ; } public Object getVariable ( String name ) { Object obj = globalNameSpace . getVariable ( name ) ; return Primitive . unwrap ( obj ) ; } public void setVariable ( String name , Object value ) { try { globalNameSpace . setVariable ( name , value ) ; } catch ( EvalError e ) { error ( e . toString ( ) ) ; } } public void setVariable ( String name , int value ) { try { globalNameSpace . setVariable ( name , new Primitive ( value ) ) ; } catch ( EvalError e ) { error ( e . toString ( ) ) ; } } public void setVariable ( String name , float value ) { try { globalNameSpace . setVariable ( name , new Primitive ( value ) ) ; } catch ( EvalError e ) { error ( e . toString ( ) ) ; } } public void setVariable ( String name , boolean value ) { try { globalNameSpace . setVariable ( name , new Primitive ( value ) ) ; } catch ( EvalError e ) { error ( e . toString ( ) ) ; } } private JJTParserState get_jjtree ( ) { return parser . jjtree ; } private ASCII_UCodeESC_CharStream get_jj_input_stream ( ) { return parser . jj_input_stream ; } private boolean Line ( ) throws ParseException { return parser . Line ( ) ; } void loadRCFiles ( ) { try { String rcfile = System . getProperty ( "user.home" ) + File . separator + ".bshrc" ; source ( rcfile , globalNameSpace ) ; } catch ( Exception e ) { debug ( "Could not find rc file: " + e ) ; } } public File pathToFile ( String fileName ) throws IOException { File file = new File ( fileName ) ; if ( ! file . isAbsolute ( ) ) { String cwd = ( String ) getu ( "bsh.cwd" ) ; file = new File ( cwd + File . separator + fileName ) ; } return new File ( file . getCanonicalPath ( ) ) ; } public static void redirectOutputToFile ( String filename ) { try { PrintStream pout = new PrintStream ( new FileOutputStream ( filename ) ) ; System . setOut ( pout ) ; System . setErr ( pout ) ; } catch ( IOException e ) { System . err . println ( "Can't redirect output to file: " + filename ) ; } } public void setClassLoader ( ClassLoader externalCL ) { BshClassManager . setClassLoader ( externalCL ) ; } static void staticInit ( ) { try { debug = System . err ; DEBUG = Boolean . getBoolean ( "debug" ) ; TRACE = Boolean . getBoolean ( "trace" ) ; String outfilename = System . getProperty ( "outfile" ) ; if ( outfilename != null ) redirectOutputToFile ( outfilename ) ; } catch ( SecurityException e ) { System . err . println ( "Could not init static:" + e ) ; } catch ( Exception e ) { System . err . println ( "Could not init static(2):" + e ) ; } catch ( Throwable e ) { System . err . println ( "Could not init static(3):" + e ) ; } } public String getSourceFileInfo ( ) { if ( sourceFileInfo != null ) return sourceFileInfo ; else return "<unknown source>" ; } public Interpreter getParent ( ) { return parent ; } } 	0	['51', '1', '0', '58', '132', '925', '44', '21', '42', '0.776470588', '1458', '0.117647059', '5', '0', '0.144', '0', '0', '27.25490196', '33', '1.6667', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . gui . DockableWindow ; import org . gjt . sp . jedit . * ; public class CreateDockableWindow extends EBMessage { public CreateDockableWindow ( View view , String name , String position ) { super ( view ) ; if ( name == null ) throw new NullPointerException ( "Name must be non-null" ) ; this . name = name ; this . position = position ; } public View getView ( ) { return ( View ) getSource ( ) ; } public String getDockableWindowName ( ) { return name ; } public void setDockableWindow ( DockableWindow win ) { this . win = win ; veto ( ) ; } public DockableWindow getDockableWindow ( ) { return win ; } public String getPosition ( ) { return position ; } public String paramString ( ) { return super . paramString ( ) + ",name=" + name + ",position=" + position ; } private String name ; private String position ; private DockableWindow win ; } 	0	['7', '2', '0', '6', '15', '9', '2', '4', '7', '0.722222222', '64', '1', '1', '0.454545455', '0.357142857', '1', '1', '7.714285714', '1', '0.8571', '0']
package org . gjt . sp . jedit ; public interface EBComponent { void handleMessage ( EBMessage message ) ; } 	0	['1', '1', '0', '31', '1', '0', '31', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit ; import java . util . Enumeration ; import java . util . Vector ; public abstract class EBMessage { public EBMessage ( EBComponent source ) { this . source = source ; } public EBComponent getSource ( ) { return source ; } public void veto ( ) { vetoed = true ; } public boolean isVetoed ( ) { return vetoed ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + paramString ( ) + "]" ; } public String paramString ( ) { return "source=" + source ; } private EBComponent source ; private boolean vetoed ; public static abstract class NonVetoable extends EBMessage { public NonVetoable ( EBComponent source ) { super ( source ) ; } public void veto ( ) { throw new InternalError ( "Can't veto this message" ) ; } } } 	0	['6', '1', '3', '29', '14', '7', '29', '1', '6', '0.6', '49', '1', '1', '0', '0.583333333', '0', '0', '6.833333333', '1', '0.8333', '0']
package gnu . regexp ; final class RETokenLookAhead extends REToken { RE re ; boolean negative ; RETokenLookAhead ( Object pattern , int cflags , RESyntax syntax , boolean negative ) throws REException { super ( 0 ) ; re = new RE ( pattern , cflags , syntax ) ; this . negative = negative ; } boolean match ( CharIndexed input , REMatch mymatch ) { REMatch trymatch = ( REMatch ) mymatch . clone ( ) ; REMatch trymatch1 = ( REMatch ) mymatch . clone ( ) ; REMatch newMatch = null ; if ( re . match ( input , trymatch ) ) { if ( negative ) return false ; if ( next ( input , trymatch1 ) ) newMatch = trymatch1 ; } if ( newMatch != null ) { if ( negative ) return false ; mymatch . assignFrom ( newMatch ) ; return true ; } else { if ( negative ) return next ( input , mymatch ) ; return false ; } } } 	0	['2', '2', '0', '6', '8', '0', '1', '6', '0', '0', '69', '0', '1', '0.875', '0.571428571', '1', '1', '32.5', '7', '3.5', '0']
package gnu . regexp ; import java . io . Serializable ; import java . util . BitSet ; public final class RESyntax implements Serializable { static final String DEFAULT_LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; private static final String SYNTAX_IS_FINAL = RE . getLocalizedMessage ( "syntax.final" ) ; private BitSet bits ; private boolean isFinal = false ; private String lineSeparator = DEFAULT_LINE_SEPARATOR ; public static final int RE_BACKSLASH_ESCAPE_IN_LISTS = 0 ; public static final int RE_BK_PLUS_QM = 1 ; public static final int RE_CHAR_CLASSES = 2 ; public static final int RE_CONTEXT_INDEP_ANCHORS = 3 ; public static final int RE_CONTEXT_INDEP_OPS = 4 ; public static final int RE_CONTEXT_INVALID_OPS = 5 ; public static final int RE_DOT_NEWLINE = 6 ; public static final int RE_DOT_NOT_NULL = 7 ; public static final int RE_INTERVALS = 8 ; public static final int RE_LIMITED_OPS = 9 ; public static final int RE_NEWLINE_ALT = 10 ; public static final int RE_NO_BK_BRACES = 11 ; public static final int RE_NO_BK_PARENS = 12 ; public static final int RE_NO_BK_REFS = 13 ; public static final int RE_NO_BK_VBAR = 14 ; public static final int RE_NO_EMPTY_RANGES = 15 ; public static final int RE_UNMATCHED_RIGHT_PAREN_ORD = 16 ; public static final int RE_HAT_LISTS_NOT_NEWLINE = 17 ; public static final int RE_STINGY_OPS = 18 ; public static final int RE_CHAR_CLASS_ESCAPES = 19 ; public static final int RE_PURE_GROUPING = 20 ; public static final int RE_LOOKAHEAD = 21 ; public static final int RE_STRING_ANCHORS = 22 ; public static final int RE_COMMENTS = 23 ; public static final int RE_CHAR_CLASS_ESC_IN_LISTS = 24 ; private static final int BIT_TOTAL = 25 ; public static final RESyntax RE_SYNTAX_AWK ; public static final RESyntax RE_SYNTAX_ED ; public static final RESyntax RE_SYNTAX_EGREP ; public static final RESyntax RE_SYNTAX_EMACS ; public static final RESyntax RE_SYNTAX_GREP ; public static final RESyntax RE_SYNTAX_POSIX_AWK ; public static final RESyntax RE_SYNTAX_POSIX_BASIC ; public static final RESyntax RE_SYNTAX_POSIX_EGREP ; public static final RESyntax RE_SYNTAX_POSIX_EXTENDED ; public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_BASIC ; public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_EXTENDED ; public static final RESyntax RE_SYNTAX_SED ; public static final RESyntax RE_SYNTAX_PERL4 ; public static final RESyntax RE_SYNTAX_PERL4_S ; public static final RESyntax RE_SYNTAX_PERL5 ; public static final RESyntax RE_SYNTAX_PERL5_S ; static { RE_SYNTAX_EMACS = new RESyntax ( ) . makeFinal ( ) ; RESyntax RE_SYNTAX_POSIX_COMMON = new RESyntax ( ) . set ( RE_CHAR_CLASSES ) . set ( RE_DOT_NEWLINE ) . set ( RE_DOT_NOT_NULL ) . set ( RE_INTERVALS ) . set ( RE_NO_EMPTY_RANGES ) . makeFinal ( ) ; RE_SYNTAX_POSIX_BASIC = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_BK_PLUS_QM ) . makeFinal ( ) ; RE_SYNTAX_POSIX_EXTENDED = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INDEP_OPS ) . set ( RE_NO_BK_BRACES ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_VBAR ) . set ( RE_UNMATCHED_RIGHT_PAREN_ORD ) . makeFinal ( ) ; RE_SYNTAX_AWK = new RESyntax ( ) . set ( RE_BACKSLASH_ESCAPE_IN_LISTS ) . set ( RE_DOT_NOT_NULL ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_REFS ) . set ( RE_NO_BK_VBAR ) . set ( RE_NO_EMPTY_RANGES ) . set ( RE_UNMATCHED_RIGHT_PAREN_ORD ) . makeFinal ( ) ; RE_SYNTAX_POSIX_AWK = new RESyntax ( RE_SYNTAX_POSIX_EXTENDED ) . set ( RE_BACKSLASH_ESCAPE_IN_LISTS ) . makeFinal ( ) ; RE_SYNTAX_GREP = new RESyntax ( ) . set ( RE_BK_PLUS_QM ) . set ( RE_CHAR_CLASSES ) . set ( RE_HAT_LISTS_NOT_NEWLINE ) . set ( RE_INTERVALS ) . set ( RE_NEWLINE_ALT ) . makeFinal ( ) ; RE_SYNTAX_EGREP = new RESyntax ( ) . set ( RE_CHAR_CLASSES ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INDEP_OPS ) . set ( RE_HAT_LISTS_NOT_NEWLINE ) . set ( RE_NEWLINE_ALT ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_VBAR ) . makeFinal ( ) ; RE_SYNTAX_POSIX_EGREP = new RESyntax ( RE_SYNTAX_EGREP ) . set ( RE_INTERVALS ) . set ( RE_NO_BK_BRACES ) . makeFinal ( ) ; RE_SYNTAX_ED = new RESyntax ( RE_SYNTAX_POSIX_BASIC ) . makeFinal ( ) ; RE_SYNTAX_SED = new RESyntax ( RE_SYNTAX_POSIX_BASIC ) . makeFinal ( ) ; RE_SYNTAX_POSIX_MINIMAL_BASIC = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_LIMITED_OPS ) . makeFinal ( ) ; RE_SYNTAX_POSIX_MINIMAL_EXTENDED = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INVALID_OPS ) . set ( RE_NO_BK_BRACES ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_REFS ) . set ( RE_NO_BK_VBAR ) . set ( RE_UNMATCHED_RIGHT_PAREN_ORD ) . makeFinal ( ) ; RE_SYNTAX_PERL4 = new RESyntax ( ) . set ( RE_BACKSLASH_ESCAPE_IN_LISTS ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INDEP_OPS ) . set ( RE_INTERVALS ) . set ( RE_NO_BK_BRACES ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_VBAR ) . set ( RE_NO_EMPTY_RANGES ) . set ( RE_CHAR_CLASS_ESCAPES ) . makeFinal ( ) ; RE_SYNTAX_PERL4_S = new RESyntax ( RE_SYNTAX_PERL4 ) . set ( RE_DOT_NEWLINE ) . makeFinal ( ) ; RE_SYNTAX_PERL5 = new RESyntax ( RE_SYNTAX_PERL4 ) . set ( RE_PURE_GROUPING ) . set ( RE_STINGY_OPS ) . set ( RE_LOOKAHEAD ) . set ( RE_STRING_ANCHORS ) . set ( RE_CHAR_CLASS_ESC_IN_LISTS ) . set ( RE_COMMENTS ) . makeFinal ( ) ; RE_SYNTAX_PERL5_S = new RESyntax ( RE_SYNTAX_PERL5 ) . set ( RE_DOT_NEWLINE ) . makeFinal ( ) ; } public RESyntax ( ) { bits = new BitSet ( BIT_TOTAL ) ; } public RESyntax makeFinal ( ) { isFinal = true ; return this ; } public RESyntax ( RESyntax other ) { bits = ( BitSet ) other . bits . clone ( ) ; } public boolean get ( int index ) { return bits . get ( index ) ; } public RESyntax set ( int index ) { if ( isFinal ) throw new IllegalAccessError ( SYNTAX_IS_FINAL ) ; bits . set ( index ) ; return this ; } public RESyntax clear ( int index ) { if ( isFinal ) throw new IllegalAccessError ( SYNTAX_IS_FINAL ) ; bits . clear ( index ) ; return this ; } public RESyntax setLineSeparator ( String aSeparator ) { if ( isFinal ) throw new IllegalAccessError ( SYNTAX_IS_FINAL ) ; lineSeparator = aSeparator ; return this ; } public String getLineSeparator ( ) { return lineSeparator ; } } 	0	['9', '1', '0', '4', '18', '0', '4', '1', '8', '1.015957447', '361', '0.106382979', '16', '0', '0.40625', '0', '0', '33.88888889', '2', '1', '0']
package org . gjt . sp . jedit . search ; import gnu . regexp . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class AllBufferSet extends BufferListSet { public AllBufferSet ( String glob ) { super ( listFiles ( glob ) ) ; this . glob = glob ; } public String getFileFilter ( ) { return glob ; } public String getCode ( ) { return "new AllBufferSet(\"" + MiscUtilities . charsToEscapes ( glob ) + "\")" ; } private String glob ; private static Vector listFiles ( String glob ) { Buffer [ ] buffers = jEdit . getBuffers ( ) ; Vector vector = new Vector ( buffers . length ) ; RE filter ; try { filter = new RE ( MiscUtilities . globToRE ( glob ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , DirectoryListSet . class , e ) ; return vector ; } for ( int i = 0 ; i < buffers . length ; i ++ ) { Buffer buffer = buffers [ i ] ; if ( filter . isMatch ( buffer . getName ( ) ) ) vector . addElement ( buffer . getPath ( ) ) ; } return vector ; } } 	0	['5', '2', '0', '7', '22', '4', '1', '6', '3', '0.625', '93', '1', '0', '0.636363636', '0.6', '0', '0', '17.2', '4', '1.4', '0']
package bsh ; class ReturnControl implements ParserConstants { public int kind ; public Object value ; public ReturnControl ( int kind , Object value ) { this . kind = kind ; this . value = value ; } } 	0	['1', '1', '0', '10', '2', '0', '9', '1', '1', '2', '12', '0', '0', '0', '1', '0', '0', '9', '0', '0', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class EditAbbrevDialog extends JDialog { public EditAbbrevDialog ( Component comp , String abbrev , String expansion ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "edit-abbrev.title" ) , true ) ; this . comp = comp ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; content . add ( BorderLayout . NORTH , new JLabel ( jEdit . getProperty ( "edit-abbrev.caption" , new String [ ] { abbrev } ) ) ) ; editor = new AbbrevEditor ( ) ; editor . setExpansion ( expansion ) ; editor . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; content . add ( BorderLayout . CENTER , editor ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; box . add ( ok ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; box . add ( cancel ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; KeyListener listener = new KeyHandler ( ) ; addKeyListener ( listener ) ; editor . getBeforeCaretTextArea ( ) . addKeyListener ( listener ) ; editor . getAfterCaretTextArea ( ) . addKeyListener ( listener ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; GUIUtilities . requestFocus ( this , editor . getBeforeCaretTextArea ( ) ) ; pack ( ) ; setLocationRelativeTo ( comp ) ; show ( ) ; } public String getExpansion ( ) { if ( ! isOK ) return null ; return editor . getExpansion ( ) ; } private Component comp ; private AbbrevEditor editor ; private JButton ok ; private JButton cancel ; private boolean isOK ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) isOK = true ; dispose ( ) ; } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) dispose ( ) ; } } } 	0	['5', '6', '0', '6', '39', '0', '3', '5', '2', '0.8', '210', '1', '1', '0.99389313', '0.32', '0', '0', '40', '2', '1', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . text . Element ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . jedit . * ; public class SelectLineRange extends EnhancedDialog implements ActionListener { public SelectLineRange ( View view ) { super ( view , jEdit . getProperty ( "selectlinerange.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 0 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "selectlinerange.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 12 ) ) ; content . add ( BorderLayout . NORTH , label ) ; JPanel panel = createFieldPanel ( ) ; content . add ( BorderLayout . CENTER , panel ) ; panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 6 , 0 , 0 , 12 ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( this ) ; getRootPane ( ) . setDefaultButton ( ok ) ; panel . add ( ok ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( this ) ; panel . add ( cancel ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( panel , BorderLayout . SOUTH ) ; GUIUtilities . requestFocus ( this , startField ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { int startLine ; int endLine ; try { startLine = Integer . parseInt ( startField . getText ( ) ) - 1 ; endLine = Integer . parseInt ( endField . getText ( ) ) - 1 ; } catch ( NumberFormatException nf ) { getToolkit ( ) . beep ( ) ; return ; } Buffer buffer = view . getBuffer ( ) ; Element map = buffer . getDefaultRootElement ( ) ; if ( startLine < 0 || endLine >= map . getElementCount ( ) ) { getToolkit ( ) . beep ( ) ; return ; } int startOffset = map . getElement ( startLine ) . getStartOffset ( ) ; int endOffset = map . getElement ( endLine ) . getEndOffset ( ) - 1 ; JEditTextArea textArea = view . getTextArea ( ) ; textArea . setSelection ( new Selection . Range ( startOffset , endOffset ) ) ; textArea . moveCaretPosition ( endOffset ) ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; } private View view ; private JTextField startField ; private JTextField endField ; private JButton ok ; private JButton cancel ; private JPanel createFieldPanel ( ) { GridBagLayout layout = new GridBagLayout ( ) ; JPanel panel = new JPanel ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . insets = new Insets ( 0 , 0 , 6 , 12 ) ; cons . gridwidth = cons . gridheight = 1 ; cons . gridx = cons . gridy = 0 ; cons . fill = GridBagConstraints . BOTH ; JLabel label = new JLabel ( jEdit . getProperty ( "selectlinerange.start" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; startField = new JTextField ( 10 ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( startField , cons ) ; panel . add ( startField ) ; label = new JLabel ( jEdit . getProperty ( "selectlinerange.end" ) , SwingConstants . RIGHT ) ; cons . gridx = 0 ; cons . weightx = 0.0f ; cons . gridy = 1 ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; endField = new JTextField ( 10 ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( endField , cons ) ; panel . add ( endField ) ; return panel ; } } 	0	['5', '7', '0', '8', '52', '2', '1', '8', '4', '0.5', '364', '1', '1', '0.99391172', '0.466666667', '0', '0', '70.8', '3', '1.6', '0']
package bsh ; class BSHSwitchStatement extends SimpleNode implements ParserConstants { public BSHSwitchStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int numchild = jjtGetNumChildren ( ) ; int child = 0 ; SimpleNode switchExp = ( ( SimpleNode ) jjtGetChild ( child ++ ) ) ; Object switchVal = switchExp . eval ( callstack , interpreter ) ; BSHSwitchLabel label ; Object node ; ReturnControl returnControl = null ; if ( child >= numchild ) throw new EvalError ( "Empty switch statement..." ) ; label = ( ( BSHSwitchLabel ) jjtGetChild ( child ++ ) ) ; while ( child < numchild && returnControl == null ) { if ( label . isDefault || label . eval ( callstack , interpreter ) . equals ( switchVal ) ) { while ( child < numchild ) { node = jjtGetChild ( child ++ ) ; if ( node instanceof BSHSwitchLabel ) continue ; Object value = ( ( SimpleNode ) node ) . eval ( callstack , interpreter ) ; if ( value instanceof ReturnControl ) { returnControl = ( ReturnControl ) value ; break ; } } } else { while ( child < numchild ) { node = jjtGetChild ( child ++ ) ; if ( node instanceof BSHSwitchLabel ) { label = ( BSHSwitchLabel ) node ; break ; } } } } if ( returnControl != null && returnControl . kind == RETURN ) return returnControl ; else return Primitive . VOID ; } } 	0	['2', '2', '0', '10', '9', '1', '1', '9', '2', '2', '106', '0', '0', '0.947368421', '0.625', '2', '2', '52', '1', '0.5', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import java . io . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class GeneralOptionPane extends AbstractOptionPane { public GeneralOptionPane ( ) { super ( "general" ) ; } protected void _init ( ) { addComponent ( new JLabel ( jEdit . getProperty ( "options.general.lf.note" ) ) ) ; lfs = UIManager . getInstalledLookAndFeels ( ) ; String [ ] names = new String [ lfs . length ] ; String lf = UIManager . getLookAndFeel ( ) . getClass ( ) . getName ( ) ; int index = 0 ; for ( int i = 0 ; i < names . length ; i ++ ) { names [ i ] = lfs [ i ] . getName ( ) ; if ( lf . equals ( lfs [ i ] . getClassName ( ) ) ) index = i ; } lookAndFeel = new JComboBox ( names ) ; lookAndFeel . setSelectedIndex ( index ) ; addComponent ( jEdit . getProperty ( "options.general.lf" ) , lookAndFeel ) ; history = new JTextField ( jEdit . getProperty ( "history" ) ) ; addComponent ( jEdit . getProperty ( "options.general.history" ) , history ) ; saveCaret = new JCheckBox ( jEdit . getProperty ( "options.general.saveCaret" ) ) ; saveCaret . setSelected ( jEdit . getBooleanProperty ( "saveCaret" ) ) ; addComponent ( saveCaret ) ; sortBuffers = new JCheckBox ( jEdit . getProperty ( "options.general.sortBuffers" ) ) ; sortBuffers . setSelected ( jEdit . getBooleanProperty ( "sortBuffers" ) ) ; addComponent ( sortBuffers ) ; sortByName = new JCheckBox ( jEdit . getProperty ( "options.general.sortByName" ) ) ; sortByName . setSelected ( jEdit . getBooleanProperty ( "sortByName" ) ) ; addComponent ( sortByName ) ; checkModStatus = new JCheckBox ( jEdit . getProperty ( "options.general.checkModStatus" ) ) ; checkModStatus . setSelected ( jEdit . getBooleanProperty ( "view.checkModStatus" ) ) ; addComponent ( checkModStatus ) ; showFullPath = new JCheckBox ( jEdit . getProperty ( "options.general.showFullPath" ) ) ; showFullPath . setSelected ( jEdit . getBooleanProperty ( "view.showFullPath" ) ) ; addComponent ( showFullPath ) ; showSearchbar = new JCheckBox ( jEdit . getProperty ( "options.general.showSearchbar" ) ) ; showSearchbar . setSelected ( jEdit . getBooleanProperty ( "view.showSearchbar" ) ) ; addComponent ( showSearchbar ) ; showBufferSwitcher = new JCheckBox ( jEdit . getProperty ( "options.general.showBufferSwitcher" ) ) ; showBufferSwitcher . setSelected ( jEdit . getBooleanProperty ( "view.showBufferSwitcher" ) ) ; addComponent ( showBufferSwitcher ) ; showTips = new JCheckBox ( jEdit . getProperty ( "options.general.showTips" ) ) ; showTips . setSelected ( jEdit . getBooleanProperty ( "tip.show" ) ) ; addComponent ( showTips ) ; showSplash = new JCheckBox ( jEdit . getProperty ( "options.general.showSplash" ) ) ; String settingsDirectory = jEdit . getSettingsDirectory ( ) ; if ( settingsDirectory == null ) showSplash . setSelected ( true ) ; else showSplash . setSelected ( ! new File ( settingsDirectory , "nosplash" ) . exists ( ) ) ; addComponent ( showSplash ) ; globalColors = new JCheckBox ( jEdit . getProperty ( "options.general.globalColors" ) ) ; globalColors . setSelected ( jEdit . getBooleanProperty ( "globalColors" ) ) ; addComponent ( globalColors ) ; } protected void _save ( ) { String lf = lfs [ lookAndFeel . getSelectedIndex ( ) ] . getClassName ( ) ; jEdit . setProperty ( "lookAndFeel" , lf ) ; jEdit . setProperty ( "history" , history . getText ( ) ) ; jEdit . setBooleanProperty ( "saveCaret" , saveCaret . isSelected ( ) ) ; jEdit . setBooleanProperty ( "sortBuffers" , sortBuffers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "sortByName" , sortByName . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.checkModStatus" , checkModStatus . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.showFullPath" , showFullPath . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.showSearchbar" , showSearchbar . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.showBufferSwitcher" , showBufferSwitcher . isSelected ( ) ) ; jEdit . setBooleanProperty ( "tip.show" , showTips . isSelected ( ) ) ; String settingsDirectory = jEdit . getSettingsDirectory ( ) ; if ( settingsDirectory != null ) { File file = new File ( settingsDirectory , "nosplash" ) ; if ( showSplash . isSelected ( ) ) file . delete ( ) ; else { try { FileOutputStream out = new FileOutputStream ( file ) ; out . write ( '\n' ) ; out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; } } } jEdit . setBooleanProperty ( "globalColors" , globalColors . isSelected ( ) ) ; } private UIManager . LookAndFeelInfo [ ] lfs ; private JComboBox lookAndFeel ; private JTextField history ; private JCheckBox saveCaret ; private JCheckBox sortBuffers ; private JCheckBox sortByName ; private JCheckBox checkModStatus ; private JCheckBox showFullPath ; private JCheckBox showSearchbar ; private JCheckBox showBufferSwitcher ; private JCheckBox showTips ; private JCheckBox showSplash ; private JCheckBox globalColors ; } 	0	['3', '6', '0', '4', '34', '1', '1', '3', '1', '0.5', '370', '1', '0', '0.996987952', '1', '2', '4', '118', '5', '2.6667', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . table . * ; import javax . swing . * ; import java . util . Vector ; public class JCheckBoxList extends JTable { public JCheckBoxList ( Object [ ] items ) { setModel ( items ) ; } public JCheckBoxList ( Vector items ) { setModel ( items ) ; } public void setModel ( Object [ ] items ) { setModel ( new CheckBoxListModel ( items ) ) ; init ( ) ; } public void setModel ( Vector items ) { setModel ( new CheckBoxListModel ( items ) ) ; init ( ) ; } public Object [ ] getCheckedValues ( ) { Vector values = new Vector ( ) ; CheckBoxListModel model = ( CheckBoxListModel ) getModel ( ) ; for ( int i = 0 ; i < model . items . size ( ) ; i ++ ) { Entry entry = ( Entry ) model . items . elementAt ( i ) ; if ( entry . checked ) values . addElement ( entry . value ) ; } Object [ ] retVal = new Object [ values . size ( ) ] ; values . copyInto ( retVal ) ; return retVal ; } public Entry [ ] getValues ( ) { CheckBoxListModel model = ( CheckBoxListModel ) getModel ( ) ; Entry [ ] retVal = new Entry [ model . items . size ( ) ] ; model . items . copyInto ( retVal ) ; return retVal ; } public Object getSelectedValue ( ) { int row = getSelectedRow ( ) ; if ( row == - 1 ) return null ; else return getModel ( ) . getValueAt ( row , 1 ) ; } private void init ( ) { getSelectionModel ( ) . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; setShowGrid ( false ) ; setAutoResizeMode ( JTable . AUTO_RESIZE_LAST_COLUMN ) ; TableColumn column = getColumnModel ( ) . getColumn ( 0 ) ; int checkBoxWidth = new JCheckBox ( ) . getPreferredSize ( ) . width ; column . setPreferredWidth ( checkBoxWidth ) ; column . setMinWidth ( checkBoxWidth ) ; column . setWidth ( checkBoxWidth ) ; column . setMaxWidth ( checkBoxWidth ) ; column . setResizable ( false ) ; } public static class Entry { boolean checked ; Object value ; public Entry ( boolean checked , Object value ) { this . checked = checked ; this . value = value ; } public boolean isChecked ( ) { return checked ; } public Object getValue ( ) { return value ; } } } class CheckBoxListModel extends AbstractTableModel { Vector items ; CheckBoxListModel ( Vector _items ) { items = new Vector ( _items . size ( ) ) ; for ( int i = 0 ; i < _items . size ( ) ; i ++ ) { items . addElement ( createEntry ( _items . elementAt ( i ) ) ) ; } } CheckBoxListModel ( Object [ ] _items ) { items = new Vector ( _items . length ) ; for ( int i = 0 ; i < _items . length ; i ++ ) { items . addElement ( createEntry ( _items [ i ] ) ) ; } } private JCheckBoxList . Entry createEntry ( Object obj ) { if ( obj instanceof JCheckBoxList . Entry ) return ( JCheckBoxList . Entry ) obj ; else return new JCheckBoxList . Entry ( false , obj ) ; } public int getRowCount ( ) { return items . size ( ) ; } public int getColumnCount ( ) { return 2 ; } public String getColumnName ( int col ) { return null ; } public Object getValueAt ( int row , int col ) { JCheckBoxList . Entry entry = ( JCheckBoxList . Entry ) items . elementAt ( row ) ; switch ( col ) { case 0 : return new Boolean ( entry . checked ) ; case 1 : return entry . value ; default : throw new InternalError ( ) ; } } public Class getColumnClass ( int col ) { switch ( col ) { case 0 : return Boolean . class ; case 1 : return String . class ; default : throw new InternalError ( ) ; } } public boolean isCellEditable ( int row , int col ) { return ( col == 0 && ! ( ( ( JCheckBoxList . Entry ) items . elementAt ( row ) ) . value instanceof String ) ) ; } public void setValueAt ( Object value , int row , int col ) { if ( col == 0 ) { ( ( JCheckBoxList . Entry ) items . elementAt ( row ) ) . checked = ( value . equals ( Boolean . TRUE ) ) ; } } } 	0	['8', '5', '0', '4', '33', '28', '2', '2', '7', '2', '143', '0', '0', '0.992974239', '0.5', '1', '1', '16.875', '3', '1.125', '0']
package bsh ; interface Node extends java . io . Serializable { public void jjtOpen ( ) ; public void jjtClose ( ) ; public void jjtSetParent ( Node n ) ; public Node jjtGetParent ( ) ; public void jjtAddChild ( Node n , int i ) ; public Node jjtGetChild ( int i ) ; public int jjtGetNumChildren ( ) ; } 	0	['7', '1', '0', '36', '7', '21', '36', '0', '7', '2', '7', '0', '0', '0', '0.523809524', '0', '0', '0', '1', '1', '0']
package bsh ; class BSHBinaryExpression extends SimpleNode implements ParserConstants { public int kind ; BSHBinaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object lhs = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( kind == INSTANCEOF ) { if ( lhs == Primitive . NULL ) return new Primitive ( false ) ; if ( lhs instanceof Primitive ) return new Primitive ( false ) ; NameSpace namespace = callstack . top ( ) ; Class rhs = ( ( BSHType ) jjtGetChild ( 1 ) ) . getType ( namespace ) ; boolean ret = ( Reflect . isAssignableFrom ( rhs , lhs . getClass ( ) ) ) ; return new Primitive ( ret ) ; } if ( kind == BOOL_AND || kind == BOOL_ANDX ) { Object obj = lhs ; if ( isPrimitiveValue ( lhs ) ) obj = ( ( Primitive ) lhs ) . getValue ( ) ; if ( obj instanceof Boolean && ( ( ( Boolean ) obj ) . booleanValue ( ) == false ) ) return new Primitive ( false ) ; } if ( kind == BOOL_OR || kind == BOOL_ORX ) { Object obj = lhs ; if ( isPrimitiveValue ( lhs ) ) obj = ( ( Primitive ) lhs ) . getValue ( ) ; if ( obj instanceof Boolean && ( ( ( Boolean ) obj ) . booleanValue ( ) == true ) ) return new Primitive ( true ) ; } boolean isLhsWrapper = isWrapper ( lhs ) ; Object rhs = ( ( SimpleNode ) jjtGetChild ( 1 ) ) . eval ( callstack , interpreter ) ; boolean isRhsWrapper = isWrapper ( rhs ) ; if ( ( isLhsWrapper || isPrimitiveValue ( lhs ) ) && ( isRhsWrapper || isPrimitiveValue ( rhs ) ) ) { if ( ( isLhsWrapper && isRhsWrapper && kind == EQ ) ) { } else try { return Primitive . binaryOperation ( lhs , rhs , kind ) ; } catch ( TargetError e ) { e . reThrow ( this ) ; } } switch ( kind ) { case EQ : return new Primitive ( ( lhs == rhs ) ) ; case NE : return new Primitive ( ( lhs != rhs ) ) ; case PLUS : if ( lhs instanceof String || rhs instanceof String ) return lhs . toString ( ) + rhs . toString ( ) ; default : if ( lhs instanceof Primitive || rhs instanceof Primitive ) if ( lhs == Primitive . VOID || rhs == Primitive . VOID ) throw new EvalError ( "illegal use of undefined variable, class, or 'void' literal" , this ) ; else if ( lhs == Primitive . NULL || rhs == Primitive . NULL ) throw new EvalError ( "illegal use of null value or 'null' literal" , this ) ; throw new EvalError ( "Operator: '" + tokenImage [ kind ] + "' inappropriate for objects" , this ) ; } } private boolean isPrimitiveValue ( Object obj ) { return ( ( obj instanceof Primitive ) && ( obj != Primitive . VOID ) && ( obj != Primitive . NULL ) ) ; } private boolean isWrapper ( Object obj ) { return ( obj instanceof Boolean || obj instanceof Character || obj instanceof Number ) ; } } 	0	['4', '2', '0', '12', '21', '6', '1', '11', '1', '1', '279', '0', '0', '0.857142857', '0.45', '1', '1', '68.5', '4', '2.25', '0']
package bsh ; import java . io . IOException ; public class This implements java . io . Serializable , Runnable { NameSpace namespace ; transient Interpreter declaringInterpreter ; transient CallStack callstack ; static This getThis ( NameSpace namespace , Interpreter declaringInterpreter ) { try { if ( Capabilities . canGenerateInterfaces ( ) ) return ( This ) Reflect . constructObject ( "bsh.XThis" , new Object [ ] { namespace , declaringInterpreter } ) ; else if ( Capabilities . haveSwing ( ) ) return ( This ) Reflect . constructObject ( "bsh.JThis" , new Object [ ] { namespace , declaringInterpreter } ) ; else return new This ( namespace , declaringInterpreter ) ; } catch ( Exception e ) { throw new InterpreterError ( "internal error 1 in This: " + e ) ; } } public Object getInterface ( Class clas ) throws EvalError { if ( clas . isInstance ( this ) ) return this ; else throw new EvalError ( "Dynamic proxy mechanism not available. " + "Cannot construct interface type: " + clas ) ; } protected This ( NameSpace namespace , Interpreter declaringInterpreter ) { this . namespace = namespace ; this . declaringInterpreter = declaringInterpreter ; initCallStack ( namespace ) ; } public NameSpace getNameSpace ( ) { return namespace ; } public String toString ( ) { return "'this' reference to Bsh object: " + namespace . name ; } public void run ( ) { try { invokeMethod ( "run" , new Object [ 0 ] ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "Exception in runnable:" + e ) ; } } public Object invokeMethod ( String name , Object [ ] args ) throws EvalError { return invokeMethod ( name , args , declaringInterpreter , null , null ) ; } public Object invokeMethod ( String name , Object [ ] args , Interpreter interpreter , CallStack callstack , SimpleNode callerInfo ) throws EvalError { return namespace . invokeMethod ( name , args , interpreter , callstack , callerInfo ) ; } public static void bind ( This ths , NameSpace namespace , Interpreter declaringInterpreter ) { ths . namespace . setParent ( namespace ) ; ths . declaringInterpreter = declaringInterpreter ; ths . initCallStack ( namespace ) ; } private synchronized void writeObject ( java . io . ObjectOutputStream s ) throws IOException { NameSpace parent = namespace . getParent ( ) ; namespace . prune ( ) ; s . defaultWriteObject ( ) ; namespace . setParent ( parent ) ; } private final void initCallStack ( NameSpace namespace ) { callstack = new CallStack ( ) ; callstack . push ( namespace ) ; } } 	0	['11', '1', '2', '14', '30', '15', '9', '8', '7', '0.566666667', '182', '0', '3', '0', '0.236363636', '0', '0', '15.27272727', '3', '1.0909', '0']
package bsh ; import java . util . Vector ; class BSHTryStatement extends SimpleNode { BSHTryStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { BSHBlock tryBlock = ( ( BSHBlock ) jjtGetChild ( 0 ) ) ; Vector catchParams = new Vector ( ) ; Vector catchBlocks = new Vector ( ) ; int nchild = jjtGetNumChildren ( ) ; Node node = null ; int i = 1 ; while ( ( i < nchild ) && ( ( node = jjtGetChild ( i ++ ) ) instanceof BSHFormalParameter ) ) { catchParams . addElement ( node ) ; catchBlocks . addElement ( jjtGetChild ( i ++ ) ) ; node = null ; } BSHBlock finallyBlock = null ; if ( node != null ) finallyBlock = ( BSHBlock ) node ; TargetError target = null ; Throwable thrown = null ; Object ret = null ; int callstackDepth = callstack . depth ( ) ; try { ret = tryBlock . eval ( callstack , interpreter ) ; } catch ( TargetError e ) { target = e ; String stackInfo = "Bsh Stack: " ; while ( callstack . depth ( ) > callstackDepth ) stackInfo += "\t" + callstack . pop ( ) + "\n" ; } if ( target != null ) thrown = target . getTarget ( ) ; if ( thrown != null ) { int n = catchParams . size ( ) ; for ( i = 0 ; i < n ; i ++ ) { NameSpace namespace = callstack . top ( ) ; BSHFormalParameter fp = ( BSHFormalParameter ) catchParams . elementAt ( i ) ; fp . eval ( namespace ) ; if ( fp . type != null ) try { thrown = ( Throwable ) NameSpace . getAssignableForm ( thrown , fp . type ) ; } catch ( EvalError e ) { continue ; } BSHBlock cb = ( BSHBlock ) ( catchBlocks . elementAt ( i ) ) ; if ( fp . type == BSHFormalParameter . UNTYPED ) namespace . setVariable ( fp . name , thrown ) ; else namespace . setTypedVariable ( fp . name , fp . type , thrown , false ) ; ret = cb . eval ( callstack , interpreter ) ; target = null ; break ; } } if ( finallyBlock != null ) ret = finallyBlock . eval ( callstack , interpreter ) ; if ( target != null ) throw target ; if ( ret instanceof ReturnControl ) return ret ; else return Primitive . VOID ; } } 	0	['2', '2', '0', '12', '22', '1', '1', '11', '1', '2', '185', '0', '0', '0.947368421', '0.625', '1', '2', '91.5', '1', '0.5', '0']
package bsh ; class BSHWhileStatement extends SimpleNode implements ParserConstants { public boolean isDoStatement ; BSHWhileStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int numChild = jjtGetNumChildren ( ) ; SimpleNode condExp , body = null ; if ( isDoStatement ) { condExp = ( SimpleNode ) jjtGetChild ( 1 ) ; body = ( SimpleNode ) jjtGetChild ( 0 ) ; } else { condExp = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( numChild > 1 ) body = ( SimpleNode ) jjtGetChild ( 1 ) ; } boolean doOnceFlag = isDoStatement ; while ( doOnceFlag || BSHIfStatement . evaluateCondition ( condExp , callstack , interpreter ) ) { if ( body == null ) continue ; Object ret = body . eval ( callstack , interpreter ) ; boolean breakout = false ; if ( ret instanceof ReturnControl ) { switch ( ( ( ReturnControl ) ret ) . kind ) { case RETURN : return ret ; case CONTINUE : continue ; case BREAK : breakout = true ; break ; } } if ( breakout ) break ; doOnceFlag = false ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '10', '7', '1', '1', '9', '1', '1', '79', '0', '0', '0.947368421', '0.625', '1', '1', '38', '1', '0.5', '0']
package org . gjt . sp . jedit . proto . jeditresource ; import java . io . IOException ; import java . net . * ; public class Handler extends URLStreamHandler { public URLConnection openConnection ( URL url ) throws IOException { PluginResURLConnection c = new PluginResURLConnection ( url ) ; c . connect ( ) ; return c ; } } 	0	['2', '2', '0', '1', '5', '1', '0', '1', '2', '2', '14', '0', '0', '0.923076923', '0.75', '0', '0', '6', '1', '0.5', '0']
package org . gjt . sp . jedit . textarea ; import javax . swing . text . TabExpander ; import java . awt . * ; import org . gjt . sp . util . Log ; public abstract class TextRenderer { static final String JAVA2D_RENDER_CLASS = "org.gjt.sp.jedit.textarea.TextRenderer2D" ; public static TextRenderer createTextRenderer ( ) { if ( java2d ) { try { ClassLoader loader = TextRenderer . class . getClassLoader ( ) ; Class clazz ; if ( loader == null ) clazz = Class . forName ( JAVA2D_RENDER_CLASS ) ; else clazz = loader . loadClass ( JAVA2D_RENDER_CLASS ) ; return ( TextRenderer ) clazz . newInstance ( ) ; } catch ( Exception e ) { throw new NoClassDefFoundError ( JAVA2D_RENDER_CLASS ) ; } } else return new TextRendererAWT ( ) ; } public static TextRenderer createPrintTextRenderer ( ) { return new TextRendererAWT ( ) ; } public void setupGraphics ( Graphics g ) { } public void configure ( boolean antiAlias , boolean fracFontMetrics ) { } public float drawChars ( char [ ] text , int off , int len , Graphics g , float x , float y , TabExpander e , Color foreground , Color tokenBackground , Color componentBackground ) { if ( tokenBackground != null ) { float width = charsWidth ( text , off , len , g . getFont ( ) , x , e ) ; FontMetrics fm = g . getFontMetrics ( ) ; float height = fm . getHeight ( ) ; float descent = fm . getDescent ( ) ; float leading = fm . getLeading ( ) ; g . setXORMode ( componentBackground ) ; g . setColor ( tokenBackground ) ; g . fillRect ( ( int ) x , ( int ) ( y - height + descent + leading ) , ( int ) width , ( int ) height ) ; g . setPaintMode ( ) ; } g . setColor ( foreground ) ; int flushLen = 0 ; int flushIndex = off ; int end = off + len ; for ( int i = off ; i < end ; i ++ ) { if ( text [ i ] == '\t' ) { if ( flushLen > 0 ) { x += _drawChars ( text , flushIndex , flushLen , g , x , y ) ; flushLen = 0 ; } flushIndex = i + 1 ; x = e . nextTabStop ( x , i - off ) ; } else flushLen ++ ; } if ( flushLen > 0 ) x += _drawChars ( text , flushIndex , flushLen , g , x , y ) ; return x ; } public float charsWidth ( char [ ] text , int off , int len , Font font , float x , TabExpander e ) { float newX = x ; int flushLen = 0 ; int flushIndex = off ; int end = off + len ; for ( int i = off ; i < end ; i ++ ) { if ( text [ i ] == '\t' ) { if ( flushLen > 0 ) { newX += _getWidth ( text , flushIndex , flushLen , font ) ; flushLen = 0 ; } flushIndex = i + 1 ; newX = e . nextTabStop ( newX , i - off ) ; } else flushLen ++ ; } if ( flushLen > 0 ) newX += _getWidth ( text , flushIndex , flushLen , font ) ; return newX - x ; } public int xToOffset ( char [ ] text , int off , int len , Font font , float x , TabExpander e , boolean round , float [ ] widthArray ) { int flushLen = 0 ; int flushIndex = off ; int end = off + len ; float width = widthArray [ 0 ] ; for ( int i = off ; i < end ; i ++ ) { if ( text [ i ] == '\t' ) { if ( flushLen > 0 ) { float newWidth = _getWidth ( text , flushIndex , flushLen , font ) ; if ( x <= width + newWidth ) { return _xToOffset ( text , flushIndex , flushLen , font , x - width , round ) + flushIndex ; } else width += newWidth ; flushLen = 0 ; } flushIndex = i + 1 ; float newWidth = e . nextTabStop ( width , i - off ) - width ; if ( x <= width + newWidth ) { if ( round && ( x - width ) < ( width + newWidth - x ) ) return i ; else return i + 1 ; } else width += newWidth ; } else flushLen ++ ; } if ( flushLen > 0 ) { float newWidth = _getWidth ( text , flushIndex , flushLen , font ) ; if ( x <= width + newWidth ) { return _xToOffset ( text , flushIndex , flushLen , font , x - width , round ) + flushIndex ; } else width += newWidth ; } widthArray [ 0 ] = width ; return - 1 ; } abstract float _drawChars ( char [ ] text , int start , int len , Graphics g , float x , float y ) ; abstract float _getWidth ( char [ ] text , int start , int len , Font font ) ; abstract int _xToOffset ( char [ ] text , int start , int len , Font font , float x , boolean round ) ; static boolean java2d ; static { try { ClassLoader loader = TextRenderer . class . getClassLoader ( ) ; if ( loader == null ) Class . forName ( "java.awt.Graphics2D" ) ; else loader . loadClass ( "java.awt.Graphics2D" ) ; Log . log ( Log . DEBUG , TextRenderer . class , "Java2D detected; will use new text rendering code" ) ; java2d = true ; } catch ( ClassNotFoundException cnf ) { Log . log ( Log . DEBUG , TextRenderer . class , "Java2D not detected; will use old text rendering code" ) ; java2d = false ; } } } 	0	['13', '1', '2', '6', '32', '76', '5', '2', '8', '0.972222222', '439', '0.333333333', '0', '0', '0.318181818', '0', '0', '32.53846154', '10', '2.4615', '0']
package org . gjt . sp . jedit . browser ; import java . util . EventListener ; import org . gjt . sp . jedit . io . VFS ; public interface BrowserListener extends EventListener { void filesSelected ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) ; void filesActivated ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package bsh ; public class Primitive implements ParserConstants , java . io . Serializable { private Object value ; private static class Special implements java . io . Serializable { private Special ( ) { } public static final Special NULL_VALUE = new Special ( ) ; public static final Special VOID_TYPE = new Special ( ) ; } public static final Primitive NULL = new Primitive ( Special . NULL_VALUE ) ; public static final Primitive VOID = new Primitive ( Special . VOID_TYPE ) ; private Primitive ( Object value ) { if ( value == null ) throw new InterpreterError ( "Use Primitve.NULL instead of Primitive(null)" ) ; this . value = value ; } public Primitive ( Number number ) { this ( ( Object ) number ) ; } public Primitive ( Boolean value ) { this ( ( Object ) value ) ; } public Primitive ( Byte value ) { this ( ( Object ) value ) ; } public Primitive ( Short value ) { this ( ( Object ) value ) ; } public Primitive ( Character value ) { this ( ( Object ) value ) ; } public Primitive ( Integer value ) { this ( ( Object ) value ) ; } public Primitive ( Long value ) { this ( ( Object ) value ) ; } public Primitive ( Float value ) { this ( ( Object ) value ) ; } public Primitive ( Double value ) { this ( ( Object ) value ) ; } public Primitive ( boolean value ) { this ( new Boolean ( value ) ) ; } public Primitive ( byte value ) { this ( new Byte ( value ) ) ; } public Primitive ( short value ) { this ( new Short ( value ) ) ; } public Primitive ( char value ) { this ( new Character ( value ) ) ; } public Primitive ( int value ) { this ( new Integer ( value ) ) ; } public Primitive ( long value ) { this ( new Long ( value ) ) ; } public Primitive ( float value ) { this ( new Float ( value ) ) ; } public Primitive ( double value ) { this ( new Double ( value ) ) ; } public Object getValue ( ) { if ( value == Special . NULL_VALUE ) return null ; else if ( value == Special . VOID_TYPE ) throw new InterpreterError ( "attempt to unwrap void type" ) ; else return value ; } public String toString ( ) { if ( value == Special . NULL_VALUE ) return "null" ; else if ( value == Special . VOID_TYPE ) return "void" ; else return value . toString ( ) ; } public Class getType ( ) { return getType ( value ) ; } private Class getType ( Object o ) { if ( o instanceof Boolean ) return Boolean . TYPE ; else if ( o instanceof Byte ) return Byte . TYPE ; else if ( o instanceof Short ) return Short . TYPE ; else if ( o instanceof Character ) return Character . TYPE ; else if ( o instanceof Integer ) return Integer . TYPE ; else if ( o instanceof Long ) return Long . TYPE ; else if ( o instanceof Float ) return Float . TYPE ; else if ( o instanceof Double ) return Double . TYPE ; return null ; } public static Object binaryOperation ( Object obj1 , Object obj2 , int kind ) throws EvalError { if ( obj1 == NULL || obj2 == NULL ) throw new EvalError ( "Null value or 'null' literal in binary operation" ) ; if ( obj1 == VOID || obj2 == VOID ) throw new EvalError ( "Undefined variable, class, or 'void' literal in binary operation" ) ; Class lhsOrgType = obj1 . getClass ( ) ; Class rhsOrgType = obj2 . getClass ( ) ; if ( obj1 instanceof Primitive ) obj1 = ( ( Primitive ) obj1 ) . getValue ( ) ; if ( obj2 instanceof Primitive ) obj2 = ( ( Primitive ) obj2 ) . getValue ( ) ; Object [ ] operands = promotePrimitives ( obj1 , obj2 ) ; Object lhs = operands [ 0 ] ; Object rhs = operands [ 1 ] ; if ( lhs . getClass ( ) != rhs . getClass ( ) ) throw new EvalError ( "type mismatch in operator.  " + lhs . getClass ( ) + " cannot be used with " + rhs . getClass ( ) ) ; Object result ; try { result = binaryOperationImpl ( lhs , rhs , kind ) ; } catch ( ArithmeticException e ) { throw new TargetError ( "Arithemetic Exception in binary op" , e ) ; } if ( lhsOrgType == Primitive . class && rhsOrgType == Primitive . class ) return new Primitive ( result ) ; else return result ; } static Object binaryOperationImpl ( Object lhs , Object rhs , int kind ) throws EvalError { if ( lhs instanceof Boolean ) return booleanBinaryOperation ( ( Boolean ) lhs , ( Boolean ) rhs , kind ) ; else if ( lhs instanceof Integer ) return intBinaryOperation ( ( Integer ) lhs , ( Integer ) rhs , kind ) ; else if ( lhs instanceof Long ) return longBinaryOperation ( ( Long ) lhs , ( Long ) rhs , kind ) ; else if ( lhs instanceof Float ) return floatBinaryOperation ( ( Float ) lhs , ( Float ) rhs , kind ) ; else if ( lhs instanceof Double ) return doubleBinaryOperation ( ( Double ) lhs , ( Double ) rhs , kind ) ; else throw new EvalError ( "Invalid types in binary operator" ) ; } static Boolean booleanBinaryOperation ( Boolean B1 , Boolean B2 , int kind ) throws EvalError { boolean lhs = B1 . booleanValue ( ) ; boolean rhs = B2 . booleanValue ( ) ; switch ( kind ) { case EQ : return new Boolean ( lhs == rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case BOOL_OR : case BOOL_ORX : return new Boolean ( lhs || rhs ) ; case BOOL_AND : case BOOL_ANDX : return new Boolean ( lhs && rhs ) ; default : throw new InterpreterError ( "unimplemented binary operator" ) ; } } static Object longBinaryOperation ( Long L1 , Long L2 , int kind ) { long lhs = L1 . longValue ( ) ; long rhs = L2 . longValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Long ( lhs + rhs ) ; case MINUS : return new Long ( lhs - rhs ) ; case STAR : return new Long ( lhs * rhs ) ; case SLASH : return new Long ( lhs / rhs ) ; case MOD : return new Long ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : return new Long ( lhs << rhs ) ; case RSIGNEDSHIFT : case RSIGNEDSHIFTX : return new Long ( lhs > > rhs ) ; case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : return new Long ( lhs > > > rhs ) ; case BIT_AND : case BIT_ANDX : return new Long ( lhs & rhs ) ; case BIT_OR : case BIT_ORX : return new Long ( lhs | rhs ) ; case XOR : return new Long ( lhs ^ rhs ) ; default : throw new InterpreterError ( "Unimplemented binary long operator" ) ; } } static Object intBinaryOperation ( Integer I1 , Integer I2 , int kind ) { int lhs = I1 . intValue ( ) ; int rhs = I2 . intValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Integer ( lhs + rhs ) ; case MINUS : return new Integer ( lhs - rhs ) ; case STAR : return new Integer ( lhs * rhs ) ; case SLASH : return new Integer ( lhs / rhs ) ; case MOD : return new Integer ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : return new Integer ( lhs << rhs ) ; case RSIGNEDSHIFT : case RSIGNEDSHIFTX : return new Integer ( lhs > > rhs ) ; case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : return new Integer ( lhs > > > rhs ) ; case BIT_AND : case BIT_ANDX : return new Integer ( lhs & rhs ) ; case BIT_OR : case BIT_ORX : return new Integer ( lhs | rhs ) ; case XOR : return new Integer ( lhs ^ rhs ) ; default : throw new InterpreterError ( "Unimplemented binary integer operator" ) ; } } static Object doubleBinaryOperation ( Double D1 , Double D2 , int kind ) throws EvalError { double lhs = D1 . doubleValue ( ) ; double rhs = D2 . doubleValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Double ( lhs + rhs ) ; case MINUS : return new Double ( lhs - rhs ) ; case STAR : return new Double ( lhs * rhs ) ; case SLASH : return new Double ( lhs / rhs ) ; case MOD : return new Double ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : case RSIGNEDSHIFT : case RSIGNEDSHIFTX : case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : throw new EvalError ( "Can't shift doubles" ) ; default : throw new InterpreterError ( "Unimplemented binary double operator" ) ; } } static Object floatBinaryOperation ( Float F1 , Float F2 , int kind ) throws EvalError { float lhs = F1 . floatValue ( ) ; float rhs = F2 . floatValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Float ( lhs + rhs ) ; case MINUS : return new Float ( lhs - rhs ) ; case STAR : return new Float ( lhs * rhs ) ; case SLASH : return new Float ( lhs / rhs ) ; case MOD : return new Float ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : case RSIGNEDSHIFT : case RSIGNEDSHIFTX : case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : throw new EvalError ( "Can't shift floats " ) ; default : throw new InterpreterError ( "Unimplemented binary float operator" ) ; } } static Object promoteToInteger ( Object primitive ) { if ( primitive instanceof Character ) return new Integer ( ( ( Character ) primitive ) . charValue ( ) ) ; else if ( ( primitive instanceof Byte ) || ( primitive instanceof Short ) ) return new Integer ( ( ( Number ) primitive ) . intValue ( ) ) ; return primitive ; } static Object [ ] promotePrimitives ( Object lhs , Object rhs ) { lhs = promoteToInteger ( lhs ) ; rhs = promoteToInteger ( rhs ) ; if ( ( lhs instanceof Number ) && ( rhs instanceof Number ) ) { Number lnum = ( Number ) lhs ; Number rnum = ( Number ) rhs ; boolean b ; if ( ( b = ( lnum instanceof Double ) ) || ( rnum instanceof Double ) ) { if ( b ) rhs = new Double ( rnum . doubleValue ( ) ) ; else lhs = new Double ( lnum . doubleValue ( ) ) ; } else if ( ( b = ( lnum instanceof Float ) ) || ( rnum instanceof Float ) ) { if ( b ) rhs = new Float ( rnum . floatValue ( ) ) ; else lhs = new Float ( lnum . floatValue ( ) ) ; } else if ( ( b = ( lnum instanceof Long ) ) || ( rnum instanceof Long ) ) { if ( b ) rhs = new Long ( rnum . longValue ( ) ) ; else lhs = new Long ( lnum . longValue ( ) ) ; } } return new Object [ ] { lhs , rhs } ; } public static Primitive unaryOperation ( Primitive val , int kind ) throws EvalError { if ( val == NULL ) throw new EvalError ( "illegal use of null object or 'null' literal" ) ; if ( val == VOID ) throw new EvalError ( "illegal use of undefined object or 'void' literal" ) ; Class operandType = val . getType ( ) ; Object operand = promoteToInteger ( val . getValue ( ) ) ; if ( operand instanceof Boolean ) return new Primitive ( booleanUnaryOperation ( ( Boolean ) operand , kind ) ) ; else if ( operand instanceof Integer ) { int result = intUnaryOperation ( ( Integer ) operand , kind ) ; if ( kind == INCR || kind == DECR ) { if ( operandType == Byte . TYPE ) return new Primitive ( ( byte ) result ) ; if ( operandType == Short . TYPE ) return new Primitive ( ( short ) result ) ; if ( operandType == Character . TYPE ) return new Primitive ( ( char ) result ) ; } return new Primitive ( result ) ; } else if ( operand instanceof Long ) return new Primitive ( longUnaryOperation ( ( Long ) operand , kind ) ) ; else if ( operand instanceof Float ) return new Primitive ( floatUnaryOperation ( ( Float ) operand , kind ) ) ; else if ( operand instanceof Double ) return new Primitive ( doubleUnaryOperation ( ( Double ) operand , kind ) ) ; else throw new InterpreterError ( "An error occurred.  Please call technical support." ) ; } static boolean booleanUnaryOperation ( Boolean B , int kind ) throws EvalError { boolean operand = B . booleanValue ( ) ; switch ( kind ) { case BANG : return ! operand ; default : throw new EvalError ( "Operator inappropriate for boolean" ) ; } } static int intUnaryOperation ( Integer I , int kind ) { int operand = I . intValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; case TILDE : return ~ operand ; case INCR : return operand + 1 ; case DECR : return operand - 1 ; default : throw new InterpreterError ( "bad integer unaryOperation" ) ; } } static long longUnaryOperation ( Long L , int kind ) { long operand = L . longValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; case TILDE : return ~ operand ; case INCR : return operand + 1 ; case DECR : return operand - 1 ; default : throw new InterpreterError ( "bad long unaryOperation" ) ; } } static float floatUnaryOperation ( Float F , int kind ) { float operand = F . floatValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; default : throw new InterpreterError ( "bad float unaryOperation" ) ; } } static double doubleUnaryOperation ( Double D , int kind ) { double operand = D . doubleValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; default : throw new InterpreterError ( "bad double unaryOperation" ) ; } } public int intValue ( ) throws EvalError { if ( value instanceof Number ) return ( ( Number ) value ) . intValue ( ) ; else throw new EvalError ( "Primitive not a number" ) ; } public boolean booleanValue ( ) throws EvalError { if ( value instanceof Boolean ) return ( ( Boolean ) value ) . booleanValue ( ) ; else throw new EvalError ( "Primitive not a boolean" ) ; } public boolean isNumber ( ) { return ( ! ( value instanceof Boolean ) && ! ( this == NULL ) && ! ( this == VOID ) ) ; } public Number numberValue ( ) throws EvalError { Object value = this . value ; if ( value instanceof Character ) value = new Integer ( ( ( Character ) value ) . charValue ( ) ) ; if ( value instanceof Number ) return ( Number ) value ; else throw new EvalError ( "Primitive not a number" ) ; } public boolean equals ( Object obj ) { if ( obj instanceof Primitive ) return ( ( Primitive ) obj ) . value . equals ( this . value ) ; else return obj . equals ( this . value ) ; } public static Object unwrap ( Object obj ) { if ( obj == null ) return null ; if ( obj == Primitive . VOID ) return null ; if ( obj instanceof Primitive ) return ( ( Primitive ) obj ) . getValue ( ) ; else return obj ; } } 	0	['45', '1', '0', '41', '77', '898', '36', '5', '28', '0.795454545', '1472', '0.25', '2', '0', '0.083333333', '0', '0', '31.62222222', '12', '2.0222', '0']
package bsh ; import java . lang . reflect . * ; import java . io . * ; import java . util . Vector ; class Reflect { public static Object invokeObjectMethod ( Interpreter interpreter , Object object , String methodName , Object [ ] args , SimpleNode callerInfo ) throws ReflectError , InvocationTargetException , EvalError { if ( object instanceof This ) return ( ( This ) object ) . invokeMethod ( methodName , args , interpreter , null , callerInfo ) ; else return invokeMethod ( object . getClass ( ) , object , methodName , args , false ) ; } public static Object invokeStaticMethod ( Class clas , String methodName , Object [ ] args ) throws ReflectError , InvocationTargetException , EvalError { Interpreter . debug ( "invoke static Method" ) ; return invokeMethod ( clas , null , methodName , args , true ) ; } public static Object getIndex ( Object array , int index ) throws ReflectError , TargetError { try { Object val = Array . get ( array , index ) ; return wrapPrimitive ( val , array . getClass ( ) . getComponentType ( ) ) ; } catch ( ArrayIndexOutOfBoundsException e1 ) { throw new TargetError ( "Array Index" , e1 ) ; } catch ( Exception e ) { throw new ReflectError ( "Array access:" + e ) ; } } public static void setIndex ( Object array , int index , Object val ) throws ReflectError , TargetError { try { val = unwrapPrimitive ( val ) ; Array . set ( array , index , val ) ; } catch ( ArrayStoreException e2 ) { throw new TargetError ( "Array store exception" , e2 ) ; } catch ( IllegalArgumentException e1 ) { throw new TargetError ( "Illegal Argument" , new ArrayStoreException ( e1 . toString ( ) ) ) ; } catch ( Exception e ) { throw new ReflectError ( "Array access:" + e ) ; } } public static Object getStaticField ( Class clas , String fieldName ) throws ReflectError { return getFieldValue ( clas , null , fieldName ) ; } public static Object getObjectField ( Object object , String fieldName ) throws ReflectError { if ( object instanceof This ) return ( ( This ) object ) . namespace . getVariable ( fieldName ) ; else { try { return getFieldValue ( object . getClass ( ) , object , fieldName ) ; } catch ( ReflectError e ) { if ( hasObjectPropertyGetter ( object . getClass ( ) , fieldName ) ) return getObjectProperty ( object , fieldName ) ; else throw e ; } } } static LHS getLHSStaticField ( Class clas , String fieldName ) throws ReflectError { Field f = getField ( clas , fieldName ) ; return new LHS ( f ) ; } static LHS getLHSObjectField ( Object object , String fieldName ) throws ReflectError { if ( object instanceof This ) return new LHS ( ( ( This ) object ) . namespace , fieldName ) ; try { Field f = getField ( object . getClass ( ) , fieldName ) ; return new LHS ( object , f ) ; } catch ( ReflectError e ) { if ( hasObjectPropertySetter ( object . getClass ( ) , fieldName ) ) return new LHS ( object , fieldName ) ; else throw e ; } } private static Object getFieldValue ( Class clas , Object object , String fieldName ) throws ReflectError { try { Field f = getField ( clas , fieldName ) ; if ( f == null ) throw new ReflectError ( "internal: field not found:" + fieldName ) ; Object value = f . get ( object ) ; Class returnType = f . getType ( ) ; return wrapPrimitive ( value , returnType ) ; } catch ( NullPointerException e ) { throw new ReflectError ( "???" + fieldName + " is not a static field." ) ; } catch ( IllegalAccessException e ) { throw new ReflectError ( "Can't access field: " + fieldName ) ; } } private static Field getField ( Class clas , String fieldName ) throws ReflectError { try { if ( Capabilities . haveAccessibility ( ) ) return findAccessibleField ( clas , fieldName ) ; else return clas . getField ( fieldName ) ; } catch ( NoSuchFieldException e ) { throw new ReflectError ( "No such field: " + fieldName ) ; } } private static Field findAccessibleField ( Class clas , String fieldName ) throws NoSuchFieldException { while ( clas != null ) { try { Field field = clas . getDeclaredField ( fieldName ) ; if ( ReflectManager . RMSetAccessible ( field ) ) return field ; } catch ( NoSuchFieldException e ) { } clas = clas . getSuperclass ( ) ; } throw new NoSuchFieldException ( fieldName ) ; } private static Object invokeMethod ( Class clas , Object object , String name , Object [ ] args , boolean onlyStatic ) throws ReflectError , InvocationTargetException , EvalError { if ( object == Primitive . NULL ) throw new TargetError ( "Attempt to invoke method " + name + " on null value" , new NullPointerException ( ) ) ; if ( object == Primitive . VOID ) throw new EvalError ( "Attempt to invoke method " + name + " on undefined variable or class name" ) ; if ( args == null ) args = new Object [ ] { } ; for ( int i = 0 ; i < args . length ; i ++ ) if ( args [ i ] == Primitive . VOID ) throw new ReflectError ( "Attempt to pass void argument " + "(position " + i + ") to method: " + name ) ; Class returnType = null ; Object returnValue = null ; Class [ ] types = getTypes ( args ) ; unwrapPrimitives ( args ) ; try { Method m = null ; try { m = findAccessibleMethod ( clas , name , types , onlyStatic ) ; } catch ( SecurityException e ) { } if ( m == null ) Interpreter . debug ( "Exact method " + StringUtil . methodString ( name , types ) + " not found in '" + clas . getName ( ) + "'" ) ; if ( m == null ) { if ( types . length == 0 ) throw new ReflectError ( "No args " + ( onlyStatic ? "static " : "" ) + "method " + StringUtil . methodString ( name , types ) + " not found in class'" + clas . getName ( ) + "'" ) ; Method [ ] methods = clas . getMethods ( ) ; if ( onlyStatic ) methods = retainStaticMethods ( methods ) ; m = findMostSpecificMethod ( name , types , methods ) ; methods = clas . getMethods ( ) ; if ( m == null ) m = findExtendedMethod ( name , args , methods ) ; if ( m != null ) { try { m = findAccessibleMethod ( clas , m . getName ( ) , m . getParameterTypes ( ) , onlyStatic ) ; } catch ( SecurityException e ) { } } } if ( m == null ) throw new ReflectError ( ( onlyStatic ? "Static method " : "Method " ) + StringUtil . methodString ( name , types ) + " not found in class'" + clas . getName ( ) + "'" ) ; returnValue = m . invoke ( object , args ) ; if ( returnValue == null ) returnValue = Primitive . NULL ; returnType = m . getReturnType ( ) ; } catch ( IllegalAccessException e ) { throw new ReflectError ( "Cannot access method " + StringUtil . methodString ( name , types ) + " in '" + clas . getName ( ) + "' :" + e ) ; } return wrapPrimitive ( returnValue , returnType ) ; } private static Method [ ] retainStaticMethods ( Method [ ] methods ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) if ( Modifier . isStatic ( methods [ i ] . getModifiers ( ) ) ) v . addElement ( methods [ i ] ) ; Method [ ] ma = new Method [ v . size ( ) ] ; v . copyInto ( ma ) ; return ma ; } static Method findAccessibleMethod ( Class clas , String name , Class [ ] types , boolean onlyStatic ) { Method meth = null ; Vector classQ = new Vector ( ) ; classQ . addElement ( clas ) ; Method found = null ; while ( classQ . size ( ) > 0 ) { Class c = ( Class ) classQ . firstElement ( ) ; classQ . removeElementAt ( 0 ) ; if ( Modifier . isPublic ( c . getModifiers ( ) ) || ( Capabilities . haveAccessibility ( ) && ReflectManager . RMSetAccessible ( c ) ) ) { try { meth = c . getDeclaredMethod ( name , types ) ; if ( Modifier . isPublic ( meth . getModifiers ( ) ) || ( Capabilities . haveAccessibility ( ) && ReflectManager . RMSetAccessible ( meth ) ) ) { found = meth ; break ; } } catch ( NoSuchMethodException e ) { } } if ( ! c . isInterface ( ) ) { Class superclass = c . getSuperclass ( ) ; if ( superclass != null ) classQ . addElement ( ( Object ) superclass ) ; } Class [ ] intfs = c . getInterfaces ( ) ; for ( int i = 0 ; i < intfs . length ; i ++ ) classQ . addElement ( ( Object ) intfs [ i ] ) ; } if ( found != null && ( ! onlyStatic || Modifier . isStatic ( found . getModifiers ( ) ) ) ) return found ; return null ; } private static Object wrapPrimitive ( Object value , Class returnType ) throws ReflectError { if ( value == null ) return Primitive . NULL ; if ( returnType == Void . TYPE ) return Primitive . VOID ; else if ( returnType . isPrimitive ( ) ) { if ( value instanceof Number ) return new Primitive ( ( Number ) value ) ; if ( value instanceof Boolean ) return new Primitive ( ( Boolean ) value ) ; if ( value instanceof Character ) return new Primitive ( ( Character ) value ) ; throw new ReflectError ( "Something bad happened" ) ; } else return value ; } public static Class [ ] getTypes ( Object [ ] args ) { if ( args == null ) return new Class [ 0 ] ; Class [ ] types = new Class [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] instanceof Primitive ) types [ i ] = ( ( Primitive ) args [ i ] ) . getType ( ) ; else types [ i ] = args [ i ] . getClass ( ) ; } return types ; } private static void unwrapPrimitives ( Object [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) args [ i ] = unwrapPrimitive ( args [ i ] ) ; } private static Object unwrapPrimitive ( Object arg ) { if ( arg instanceof Primitive ) return ( ( Primitive ) arg ) . getValue ( ) ; else return arg ; } static Object constructObject ( String clas , Object [ ] args ) throws ReflectError , InvocationTargetException { Class c = BshClassManager . classForName ( clas ) ; if ( c == null ) throw new ReflectError ( "Class not found: " + clas ) ; return constructObject ( c , args ) ; } static Object constructObject ( Class clas , Object [ ] args ) throws ReflectError , InvocationTargetException { for ( int i = 0 ; i < args . length ; i ++ ) if ( args [ i ] == Primitive . VOID ) throw new ReflectError ( "Attempt to pass void argument " + "(position " + i + ") to constructor for: " + clas ) ; if ( clas . isInterface ( ) ) throw new ReflectError ( "Can't create instance of an interface: " + clas ) ; Object obj = null ; Class [ ] types = getTypes ( args ) ; unwrapPrimitives ( args ) ; Constructor con = null ; Constructor [ ] constructors = clas . getDeclaredConstructors ( ) ; Interpreter . debug ( "Looking for most specific constructor: " + clas ) ; con = findMostSpecificConstructor ( types , constructors ) ; if ( con == null ) if ( types . length == 0 ) throw new ReflectError ( "Can't find default constructor for: " + clas ) ; else con = findExtendedConstructor ( args , constructors ) ; if ( con == null ) throw new ReflectError ( "Can't find constructor: " + clas ) ; try { obj = con . newInstance ( args ) ; } catch ( InstantiationException e ) { throw new ReflectError ( "the class is abstract " ) ; } catch ( IllegalAccessException e ) { throw new ReflectError ( "we don't have permission to create an instance" ) ; } catch ( IllegalArgumentException e ) { throw new ReflectError ( "the number of arguments was wrong" ) ; } if ( obj == null ) throw new ReflectError ( "couldn't construct the object" ) ; return obj ; } static Method findMostSpecificMethod ( String name , Class [ ] idealMatch , Method [ ] methods ) { Vector sigs = new Vector ( ) ; Vector meths = new Vector ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) if ( methods [ i ] . getName ( ) . equals ( name ) ) { meths . addElement ( methods [ i ] ) ; sigs . addElement ( methods [ i ] . getParameterTypes ( ) ) ; } Class [ ] [ ] candidates = new Class [ sigs . size ( ) ] [ ] ; sigs . copyInto ( candidates ) ; Interpreter . debug ( "Looking for most specific method: " + name ) ; int match = findMostSpecificSignature ( idealMatch , candidates ) ; if ( match == - 1 ) return null ; else return ( Method ) meths . elementAt ( match ) ; } static Method findExtendedMethod ( String name , Object [ ] args , Method [ ] methods ) { Method bestMatch = null ; Object [ ] tempArgs = new Object [ args . length ] ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method currentMethod = methods [ i ] ; if ( name . equals ( currentMethod . getName ( ) ) ) { Class [ ] parameters = currentMethod . getParameterTypes ( ) ; if ( parameters . length != args . length ) continue ; try { for ( int j = 0 ; j < parameters . length ; j ++ ) tempArgs [ j ] = NameSpace . getAssignableForm ( args [ j ] , parameters [ j ] ) ; System . arraycopy ( tempArgs , 0 , args , 0 , args . length ) ; return currentMethod ; } catch ( EvalError e ) { } } } return null ; } static Constructor findMostSpecificConstructor ( Class [ ] idealMatch , Constructor [ ] constructors ) { Class [ ] [ ] candidates = new Class [ constructors . length ] [ ] ; for ( int i = 0 ; i < candidates . length ; i ++ ) candidates [ i ] = constructors [ i ] . getParameterTypes ( ) ; int match = findMostSpecificSignature ( idealMatch , candidates ) ; if ( match == - 1 ) return null ; else return constructors [ match ] ; } static Constructor findExtendedConstructor ( Object [ ] args , Constructor [ ] constructors ) { Constructor bestMatch = null ; Object [ ] tempArgs = new Object [ args . length ] ; for ( int i = 0 ; i < constructors . length ; i ++ ) { Constructor currentConstructor = constructors [ i ] ; Class [ ] parameters = currentConstructor . getParameterTypes ( ) ; if ( parameters . length != args . length ) continue ; try { for ( int j = 0 ; j < parameters . length ; j ++ ) tempArgs [ j ] = NameSpace . getAssignableForm ( args [ j ] , parameters [ j ] ) ; System . arraycopy ( tempArgs , 0 , args , 0 , args . length ) ; return currentConstructor ; } catch ( EvalError e ) { } } return null ; } static int findMostSpecificSignature ( Class [ ] idealMatch , Class [ ] [ ] candidates ) { Class [ ] bestMatch = null ; int bestMatchIndex = - 1 ; for ( int i = 0 ; i < candidates . length ; i ++ ) { Class [ ] targetMatch = candidates [ i ] ; if ( isAssignable ( idealMatch , targetMatch ) && ( ( bestMatch == null ) || isAssignable ( targetMatch , bestMatch ) ) ) { bestMatch = targetMatch ; bestMatchIndex = i ; } } if ( bestMatch != null ) { return bestMatchIndex ; } else { Interpreter . debug ( "no match found" ) ; return - 1 ; } } static boolean isAssignable ( Class [ ] from , Class [ ] to ) { if ( from == null ) from = new Class [ 0 ] ; if ( to == null ) to = new Class [ 0 ] ; if ( from . length != to . length ) return false ; for ( int i = 0 ; i < from . length ; i ++ ) { if ( to [ i ] == null ) continue ; if ( from [ i ] == null ) { if ( ! ( to [ i ] . isPrimitive ( ) ) ) continue ; else return false ; } if ( ! isAssignableFrom ( to [ i ] , from [ i ] ) ) return false ; } return true ; } static boolean isAssignableFrom ( Class lhs , Class rhs ) { if ( lhs . isPrimitive ( ) && rhs . isPrimitive ( ) ) { if ( lhs == rhs ) return true ; if ( ( rhs == Byte . TYPE ) && ( lhs == Short . TYPE || lhs == Integer . TYPE || lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Short . TYPE ) && ( lhs == Integer . TYPE || lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Character . TYPE ) && ( lhs == Integer . TYPE || lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Integer . TYPE ) && ( lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Long . TYPE ) && ( lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Float . TYPE ) && ( lhs == Double . TYPE ) ) return true ; } else if ( lhs . isAssignableFrom ( rhs ) ) return true ; return false ; } private static String accessorName ( String getorset , String propName ) { return getorset + String . valueOf ( Character . toUpperCase ( propName . charAt ( 0 ) ) ) + propName . substring ( 1 ) ; } public static boolean hasObjectPropertyGetter ( Class clas , String propName ) { String getterName = accessorName ( "get" , propName ) ; try { clas . getMethod ( getterName , new Class [ 0 ] ) ; return true ; } catch ( NoSuchMethodException e ) { return false ; } } public static boolean hasObjectPropertySetter ( Class clas , String propName ) { String setterName = accessorName ( "set" , propName ) ; Class [ ] sig = new Class [ ] { clas } ; Method [ ] methods = clas . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) if ( methods [ i ] . getName ( ) . equals ( setterName ) ) return true ; return false ; } public static Object getObjectProperty ( Object obj , String propName ) throws ReflectError { String accessorName = accessorName ( "get" , propName ) ; Object [ ] args = new Object [ ] { } ; Interpreter . debug ( "property access: " ) ; try { try { return invokeObjectMethod ( null , obj , accessorName , args , null ) ; } catch ( EvalError e ) { throw new ReflectError ( "getter: " + e ) ; } } catch ( InvocationTargetException e ) { throw new ReflectError ( "Property accessor threw exception:" + e ) ; } } public static void setObjectProperty ( Object obj , String propName , Object value ) throws ReflectError , EvalError { String accessorName = accessorName ( "set" , propName ) ; Object [ ] args = new Object [ ] { value } ; Interpreter . debug ( "property access: " ) ; try { invokeObjectMethod ( null , obj , accessorName , args , null ) ; } catch ( InvocationTargetException e ) { throw new EvalError ( "Property accessor threw exception!" ) ; } } public static String normalizeClassName ( Class type ) { if ( ! type . isArray ( ) ) return type . getName ( ) ; StringBuffer className = new StringBuffer ( ) ; try { className . append ( getArrayBaseType ( type ) . getName ( ) ) ; for ( int i = 0 ; i < getArrayDimensions ( type ) ; i ++ ) className . append ( "[]" ) ; } catch ( Exception e ) { } return className . toString ( ) ; } public static int getArrayDimensions ( Class arrayClass ) { if ( ! arrayClass . isArray ( ) ) return 0 ; return arrayClass . getName ( ) . lastIndexOf ( '[' ) + 1 ; } public static Class getArrayBaseType ( Class arrayClass ) throws ReflectError { if ( ! arrayClass . isArray ( ) ) throw new ReflectError ( "The class is not an array." ) ; return arrayClass . getComponentType ( ) ; } } 	0	['36', '1', '0', '23', '109', '630', '12', '14', '14', '2', '1557', '0', '0', '0', '0.155982906', '0', '0', '42.25', '30', '3.1111', '0']
package bsh ; import java . util . Hashtable ; public class Capabilities { private static boolean accessibility = false ; public static boolean haveSwing ( ) { return classExists ( "javax.swing.JButton" ) ; } public static boolean canGenerateInterfaces ( ) { return classExists ( "java.lang.reflect.Proxy" ) ; } public static boolean haveAccessibility ( ) { return ( accessibility && classExists ( "java.lang.reflect.AccessibleObject" ) && classExists ( "bsh.reflect.ReflectManagerImpl" ) ) ; } public static void setAccessibility ( boolean b ) { accessibility = b ; } private static Hashtable classes = new Hashtable ( ) ; public static boolean classExists ( String name ) { Object c = classes . get ( name ) ; if ( c == null ) { try { c = Class . forName ( name ) ; } catch ( ClassNotFoundException e ) { } if ( c != null ) classes . put ( c , "unused" ) ; } return c != null ; } public static class Unavailable extends RuntimeException { public Unavailable ( String s ) { super ( s ) ; } } } 	0	['7', '1', '0', '5', '12', '13', '5', '0', '6', '0.5', '64', '1', '0', '0', '0.166666667', '0', '0', '7.857142857', '4', '1.5714', '0']
package bsh ; public class ClassPathException extends EvalError { public ClassPathException ( String msg ) { super ( msg ) ; } } 	0	['1', '4', '0', '3', '2', '0', '2', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; public abstract class EnhancedDialog extends JDialog { public EnhancedDialog ( Frame parent , String title , boolean modal ) { super ( parent , title , modal ) ; ( ( Container ) getLayeredPane ( ) ) . addContainerListener ( new ContainerHandler ( ) ) ; getContentPane ( ) . addContainerListener ( new ContainerHandler ( ) ) ; keyHandler = new KeyHandler ( ) ; addKeyListener ( keyHandler ) ; addWindowListener ( new WindowHandler ( ) ) ; setDefaultCloseOperation ( DO_NOTHING_ON_CLOSE ) ; } public abstract void ok ( ) ; public abstract void cancel ( ) ; protected KeyHandler keyHandler ; class ContainerHandler extends ContainerAdapter { public void componentAdded ( ContainerEvent evt ) { componentAdded ( evt . getChild ( ) ) ; } public void componentRemoved ( ContainerEvent evt ) { componentRemoved ( evt . getChild ( ) ) ; } private void componentAdded ( Component comp ) { comp . addKeyListener ( keyHandler ) ; if ( comp instanceof Container ) { Container cont = ( Container ) comp ; cont . addContainerListener ( this ) ; Component [ ] comps = cont . getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { componentAdded ( comps [ i ] ) ; } } } private void componentRemoved ( Component comp ) { comp . removeKeyListener ( keyHandler ) ; if ( comp instanceof Container ) { Container cont = ( Container ) comp ; cont . removeContainerListener ( this ) ; Component [ ] comps = cont . getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { componentRemoved ( comps [ i ] ) ; } } } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { if ( evt . isConsumed ( ) ) return ; if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { Component comp = getFocusOwner ( ) ; while ( comp != null ) { if ( comp instanceof JComboBox ) { JComboBox combo = ( JComboBox ) comp ; if ( combo . isEditable ( ) ) { Object selected = combo . getEditor ( ) . getItem ( ) ; if ( selected != null ) combo . setSelectedItem ( selected ) ; } break ; } comp = comp . getParent ( ) ; } ok ( ) ; evt . consume ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { cancel ( ) ; evt . consume ( ) ; } } } class WindowHandler extends WindowAdapter { public void windowClosing ( WindowEvent evt ) { cancel ( ) ; } } } 	0	['3', '6', '16', '19', '13', '3', '19', '3', '3', '1', '59', '1', '1', '0.996937213', '0.5', '0', '0', '18.33333333', '1', '0.6667', '0']
package com . microstar . xml ; public class XmlException extends Exception { private String message ; private String systemId ; private int line ; private int column ; public XmlException ( String message , String systemId , int line , int column ) { this . message = message ; this . systemId = systemId ; this . line = line ; this . column = column ; } public String getMessage ( ) { return message ; } public String getSystemId ( ) { return systemId ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return column ; } } 	0	['5', '3', '0', '5', '6', '2', '5', '0', '5', '0.75', '36', '1', '0', '0.80952381', '0.466666667', '1', '1', '5.4', '1', '0.8', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class PropertiesChanged extends EBMessage . NonVetoable { public PropertiesChanged ( EBComponent source ) { super ( source ) ; } } 	0	['1', '3', '0', '8', '2', '0', '6', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package gnu . regexp ; import java . io . Serializable ; abstract class REToken implements Serializable { protected REToken next = null ; protected REToken uncle = null ; protected int subIndex ; protected REToken ( int aSubIndex ) { subIndex = aSubIndex ; } int getMinimumLength ( ) { return 0 ; } void setUncle ( REToken anUncle ) { uncle = anUncle ; } abstract boolean match ( CharIndexed input , REMatch mymatch ) ; protected boolean next ( CharIndexed input , REMatch mymatch ) { if ( next == null ) { if ( uncle == null ) { return true ; } else { return uncle . match ( input , mymatch ) ; } } else { return next . match ( input , mymatch ) ; } } boolean chain ( REToken token ) { next = token ; return true ; } void dump ( StringBuffer os ) { } void dumpAll ( StringBuffer os ) { dump ( os ) ; if ( next != null ) next . dumpAll ( os ) ; } } 	0	['8', '1', '13', '15', '9', '12', '13', '2', '0', '0.761904762', '66', '1', '2', '0', '0.354166667', '0', '0', '6.875', '3', '1.25', '0']
package bsh ; public interface ParserTreeConstants { public int JJTVOID = 0 ; public int JJTMETHODDECLARATION = 1 ; public int JJTIMPORTDECLARATION = 2 ; public int JJTVARIABLEDECLARATOR = 3 ; public int JJTARRAYINITIALIZER = 4 ; public int JJTFORMALPARAMETERS = 5 ; public int JJTFORMALPARAMETER = 6 ; public int JJTTYPE = 7 ; public int JJTRETURNTYPE = 8 ; public int JJTPRIMITIVETYPE = 9 ; public int JJTAMBIGUOUSNAME = 10 ; public int JJTASSIGNMENT = 11 ; public int JJTTERNARYEXPRESSION = 12 ; public int JJTBINARYEXPRESSION = 13 ; public int JJTUNARYEXPRESSION = 14 ; public int JJTCASTEXPRESSION = 15 ; public int JJTPRIMARYEXPRESSION = 16 ; public int JJTMETHODINVOCATION = 17 ; public int JJTPRIMARYSUFFIX = 18 ; public int JJTLHSPRIMARYEXPRESSION = 19 ; public int JJTLHSPRIMARYSUFFIX = 20 ; public int JJTLITERAL = 21 ; public int JJTARGUMENTS = 22 ; public int JJTALLOCATIONEXPRESSION = 23 ; public int JJTARRAYDIMENSIONS = 24 ; public int JJTBLOCK = 25 ; public int JJTSWITCHSTATEMENT = 26 ; public int JJTSWITCHLABEL = 27 ; public int JJTIFSTATEMENT = 28 ; public int JJTWHILESTATEMENT = 29 ; public int JJTFORSTATEMENT = 30 ; public int JJTTYPEDVARIABLEDECLARATION = 31 ; public int JJTSTATEMENTEXPRESSIONLIST = 32 ; public int JJTRETURNSTATEMENT = 33 ; public int JJTTHROWSTATEMENT = 34 ; public int JJTTRYSTATEMENT = 35 ; public String [ ] jjtNodeName = { "void" , "MethodDeclaration" , "ImportDeclaration" , "VariableDeclarator" , "ArrayInitializer" , "FormalParameters" , "FormalParameter" , "Type" , "ReturnType" , "PrimitiveType" , "AmbiguousName" , "Assignment" , "TernaryExpression" , "BinaryExpression" , "UnaryExpression" , "CastExpression" , "PrimaryExpression" , "MethodInvocation" , "PrimarySuffix" , "LHSPrimaryExpression" , "LHSPrimarySuffix" , "Literal" , "Arguments" , "AllocationExpression" , "ArrayDimensions" , "Block" , "SwitchStatement" , "SwitchLabel" , "IfStatement" , "WhileStatement" , "ForStatement" , "TypedVariableDeclaration" , "StatementExpressionList" , "ReturnStatement" , "ThrowStatement" , "TryStatement" , } ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '186', '0', '0', '0', '0', '0', '0', '148', '0', '0', '0']
package bsh ; import java . io . Reader ; class ParserTokenManager implements ParserConstants { private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x3eL ) != 0L ) return 0 ; if ( ( active1 & 0x400040000000L ) != 0L ) return 56 ; if ( ( active1 & 0x20L ) != 0L ) return 11 ; if ( ( active0 & 0x3fffffffff800L ) != 0L ) { jjmatchedKind = 58 ; return 35 ; } return - 1 ; case 1 : if ( ( active0 & 0x3ffffbf9ff800L ) != 0L ) { if ( jjmatchedPos != 1 ) { jjmatchedKind = 58 ; jjmatchedPos = 1 ; } return 35 ; } if ( ( active0 & 0x40600000L ) != 0L ) return 35 ; return - 1 ; case 2 : if ( ( active0 & 0x37fe9afdff800L ) != 0L ) { if ( jjmatchedPos != 2 ) { jjmatchedKind = 58 ; jjmatchedPos = 2 ; } return 35 ; } if ( ( active0 & 0x801610000000L ) != 0L ) return 35 ; return - 1 ; case 3 : if ( ( active0 & 0x140282082c000L ) != 0L ) return 35 ; if ( ( active0 & 0x23fc58f5d3800L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 58 ; jjmatchedPos = 3 ; } return 35 ; } return - 1 ; case 4 : if ( ( active0 & 0x1bc580580800L ) != 0L ) { if ( jjmatchedPos != 4 ) { jjmatchedKind = 58 ; jjmatchedPos = 4 ; } return 35 ; } if ( ( active0 & 0x224000f053000L ) != 0L ) return 35 ; return - 1 ; case 5 : if ( ( active0 & 0xc504180800L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 5 ; return 35 ; } if ( ( active0 & 0x1b0080400000L ) != 0L ) return 35 ; return - 1 ; case 6 : if ( ( active0 & 0x4004100800L ) != 0L ) return 35 ; if ( ( active0 & 0x8500080000L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 6 ; return 35 ; } return - 1 ; case 7 : if ( ( active0 & 0x8500000000L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 7 ; return 35 ; } if ( ( active0 & 0x80000L ) != 0L ) return 35 ; return - 1 ; case 8 : if ( ( active0 & 0x100000000L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 8 ; return 35 ; } if ( ( active0 & 0x8400000000L ) != 0L ) return 35 ; return - 1 ; case 9 : if ( ( active0 & 0x100000000L ) != 0L ) return 35 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_0 ( int pos , long active0 , long active1 ) { return jjMoveNfa_0 ( jjStopStringLiteralDfa_0 ( pos , active0 , active1 ) , pos + 1 ) ; } private final int jjStopAtPos ( int pos , int kind ) { jjmatchedKind = kind ; jjmatchedPos = pos ; return pos + 1 ; } private final int jjStartNfaWithStates_0 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_0 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_0 ( ) { switch ( curChar ) { case 9 : return jjStartNfaWithStates_0 ( 0 , 2 , 0 ) ; case 10 : return jjStartNfaWithStates_0 ( 0 , 5 , 0 ) ; case 12 : return jjStartNfaWithStates_0 ( 0 , 4 , 0 ) ; case 13 : return jjStartNfaWithStates_0 ( 0 , 3 , 0 ) ; case 32 : return jjStartNfaWithStates_0 ( 0 , 1 , 0 ) ; case 33 : jjmatchedKind = 75 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x100000L ) ; case 37 : jjmatchedKind = 100 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x10000000000000L ) ; case 38 : jjmatchedKind = 95 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x800000800000L ) ; case 40 : return jjStopAtPos ( 0 , 61 ) ; case 41 : return jjStopAtPos ( 0 , 62 ) ; case 42 : jjmatchedKind = 93 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x200000000000L ) ; case 43 : jjmatchedKind = 91 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x80002000000L ) ; case 44 : return jjStopAtPos ( 0 , 68 ) ; case 45 : jjmatchedKind = 92 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x100004000000L ) ; case 46 : return jjStartNfaWithStates_0 ( 0 , 69 , 11 ) ; case 47 : jjmatchedKind = 94 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x400000000000L ) ; case 58 : return jjStopAtPos ( 0 , 78 ) ; case 59 : return jjStopAtPos ( 0 , 67 ) ; case 60 : jjmatchedKind = 73 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x20002000010000L ) ; case 61 : jjmatchedKind = 70 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x8000L ) ; case 62 : jjmatchedKind = 71 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x280028000040000L ) ; case 63 : return jjStopAtPos ( 0 , 77 ) ; case 64 : return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x5450545014a0500L ) ; case 91 : return jjStopAtPos ( 0 , 65 ) ; case 93 : return jjStopAtPos ( 0 , 66 ) ; case 94 : jjmatchedKind = 99 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x8000000000000L ) ; case 98 : return jjMoveStringLiteralDfa1_0 ( 0x5800L , 0x0L ) ; case 99 : return jjMoveStringLiteralDfa1_0 ( 0xfa000L , 0x0L ) ; case 100 : return jjMoveStringLiteralDfa1_0 ( 0x700000L , 0x0L ) ; case 101 : return jjMoveStringLiteralDfa1_0 ( 0x800000L , 0x0L ) ; case 102 : return jjMoveStringLiteralDfa1_0 ( 0x1f000000L , 0x0L ) ; case 103 : return jjMoveStringLiteralDfa1_0 ( 0x20000000L , 0x0L ) ; case 105 : return jjMoveStringLiteralDfa1_0 ( 0x7c0000000L , 0x0L ) ; case 108 : return jjMoveStringLiteralDfa1_0 ( 0x800000000L , 0x0L ) ; case 110 : return jjMoveStringLiteralDfa1_0 ( 0x3000000000L , 0x0L ) ; case 112 : return jjMoveStringLiteralDfa1_0 ( 0x1c000000000L , 0x0L ) ; case 114 : return jjMoveStringLiteralDfa1_0 ( 0x20000000000L , 0x0L ) ; case 115 : return jjMoveStringLiteralDfa1_0 ( 0x1c0000000000L , 0x0L ) ; case 116 : return jjMoveStringLiteralDfa1_0 ( 0xe00000000000L , 0x0L ) ; case 118 : return jjMoveStringLiteralDfa1_0 ( 0x1000000000000L , 0x0L ) ; case 119 : return jjMoveStringLiteralDfa1_0 ( 0x2000000000000L , 0x0L ) ; case 123 : return jjStopAtPos ( 0 , 63 ) ; case 124 : jjmatchedKind = 97 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x2000000200000L ) ; case 125 : return jjStopAtPos ( 0 , 64 ) ; case 126 : return jjStopAtPos ( 0 , 76 ) ; default : return jjMoveNfa_0 ( 6 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_0 ( long active0 , long active1 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 0 , active0 , active1 ) ; return 1 ; } switch ( curChar ) { case 38 : if ( ( active1 & 0x800000L ) != 0L ) return jjStopAtPos ( 1 , 87 ) ; break ; case 43 : if ( ( active1 & 0x2000000L ) != 0L ) return jjStopAtPos ( 1 , 89 ) ; break ; case 45 : if ( ( active1 & 0x4000000L ) != 0L ) return jjStopAtPos ( 1 , 90 ) ; break ; case 60 : if ( ( active1 & 0x2000000000L ) != 0L ) { jjmatchedKind = 101 ; jjmatchedPos = 1 ; } return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x20000000000000L ) ; case 61 : if ( ( active1 & 0x8000L ) != 0L ) return jjStopAtPos ( 1 , 79 ) ; else if ( ( active1 & 0x10000L ) != 0L ) return jjStopAtPos ( 1 , 80 ) ; else if ( ( active1 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 82 ) ; else if ( ( active1 & 0x100000L ) != 0L ) return jjStopAtPos ( 1 , 84 ) ; else if ( ( active1 & 0x80000000000L ) != 0L ) return jjStopAtPos ( 1 , 107 ) ; else if ( ( active1 & 0x100000000000L ) != 0L ) return jjStopAtPos ( 1 , 108 ) ; else if ( ( active1 & 0x200000000000L ) != 0L ) return jjStopAtPos ( 1 , 109 ) ; else if ( ( active1 & 0x400000000000L ) != 0L ) return jjStopAtPos ( 1 , 110 ) ; else if ( ( active1 & 0x800000000000L ) != 0L ) return jjStopAtPos ( 1 , 111 ) ; else if ( ( active1 & 0x2000000000000L ) != 0L ) return jjStopAtPos ( 1 , 113 ) ; else if ( ( active1 & 0x8000000000000L ) != 0L ) return jjStopAtPos ( 1 , 115 ) ; else if ( ( active1 & 0x10000000000000L ) != 0L ) return jjStopAtPos ( 1 , 116 ) ; break ; case 62 : if ( ( active1 & 0x8000000000L ) != 0L ) { jjmatchedKind = 103 ; jjmatchedPos = 1 ; } return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x280020000000000L ) ; case 97 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x1018000L , active1 , 0x1000001000000L ) ; case 98 : return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x500000000L ) ; case 101 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x21000100000L , active1 , 0L ) ; case 102 : if ( ( active0 & 0x40000000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 30 , 35 ) ; break ; case 103 : return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x80100L ) ; case 104 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x2240000020000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x6000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x8802000L , active1 , 0x40004000020400L ) ; case 109 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x80000000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x700000000L , active1 , 0L ) ; case 111 : if ( ( active0 & 0x200000L ) != 0L ) { jjmatchedKind = 21 ; jjmatchedPos = 1 ; } return jjMoveStringLiteralDfa2_0 ( active0 , 0x10008304c0800L , active1 , 0x4000000400000L ) ; case 114 : return jjMoveStringLiteralDfa2_0 ( active0 , 0xc0c000001000L , active1 , 0x500050000000000L ) ; case 116 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x80000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x12000000000L , active1 , 0L ) ; case 119 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 121 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x4000L , active1 , 0L ) ; case 124 : if ( ( active1 & 0x200000L ) != 0L ) return jjStopAtPos ( 1 , 85 ) ; break ; default : break ; } return jjStartNfa_0 ( 0 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa2_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 0 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 1 , active0 , active1 ) ; return 2 ; } switch ( curChar ) { case 61 : if ( ( active1 & 0x20000000000000L ) != 0L ) return jjStopAtPos ( 2 , 117 ) ; else if ( ( active1 & 0x80000000000000L ) != 0L ) return jjStopAtPos ( 2 , 119 ) ; break ; case 62 : if ( ( active1 & 0x20000000000L ) != 0L ) { jjmatchedKind = 105 ; jjmatchedPos = 2 ; } return jjMoveStringLiteralDfa3_0 ( active0 , 0L , active1 , 0x200000000000000L ) ; case 97 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x80000022000L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x10000000000L , active1 , 0L ) ; case 101 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x1000L , active1 , 0x40004000000000L ) ; case 102 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x100000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x3104000000000L , active1 , 0x500050500000000L ) ; case 108 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x2001000000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x8060c0000L , active1 , 0x1000001000000L ) ; case 111 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x48008000800L , active1 , 0L ) ; case 112 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x80000000L , active1 , 0L ) ; case 114 : if ( ( active0 & 0x10000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 28 , 35 ) ; else if ( ( active1 & 0x400000L ) != 0L ) { jjmatchedKind = 86 ; jjmatchedPos = 2 ; } return jjMoveStringLiteralDfa3_0 ( active0 , 0x200000000000L , active1 , 0x4000000000000L ) ; case 115 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x100808000L , active1 , 0L ) ; case 116 : if ( ( active0 & 0x200000000L ) != 0L ) { jjmatchedKind = 33 ; jjmatchedPos = 2 ; } else if ( ( active1 & 0x100L ) != 0L ) { jjmatchedKind = 72 ; jjmatchedPos = 2 ; } else if ( ( active1 & 0x400L ) != 0L ) { jjmatchedKind = 74 ; jjmatchedPos = 2 ; } return jjMoveStringLiteralDfa3_0 ( active0 , 0x20420014000L , active1 , 0xa0000L ) ; case 117 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x400000400000L , active1 , 0L ) ; case 119 : if ( ( active0 & 0x1000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 36 , 35 ) ; break ; case 121 : if ( ( active0 & 0x800000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 47 , 35 ) ; break ; default : break ; } return jjStartNfa_0 ( 1 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa3_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 1 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 2 , active0 , active1 ) ; return 3 ; } switch ( curChar ) { case 61 : if ( ( active1 & 0x200000000000000L ) != 0L ) return jjStopAtPos ( 3 , 121 ) ; break ; case 95 : return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 97 : return jjMoveStringLiteralDfa4_0 ( active0 , 0xe101000L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x400000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x10000L , active1 , 0L ) ; case 100 : if ( ( active0 & 0x1000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 48 , 35 ) ; else if ( ( active1 & 0x1000000L ) != 0L ) { jjmatchedKind = 88 ; jjmatchedPos = 3 ; } return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x1000000000000L ) ; case 101 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 14 , 35 ) ; else if ( ( active0 & 0x8000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 15 , 35 ) ; else if ( ( active0 & 0x800000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 23 , 35 ) ; else if ( ( active0 & 0x400000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 46 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x400000000L , active1 , 0xa0000L ) ; case 102 : return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 103 : if ( ( active0 & 0x800000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 35 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x500050000000000L ) ; case 108 : if ( ( active0 & 0x2000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 37 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x2010000000800L , active1 , 0L ) ; case 111 : if ( ( active0 & 0x20000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 29 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x200080000000L , active1 , 0L ) ; case 114 : if ( ( active0 & 0x20000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 17 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x40000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x1042000L , active1 , 0L ) ; case 116 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x188100080000L , active1 , 0x500000000L ) ; case 117 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x20000000000L , active1 , 0L ) ; case 118 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x4000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 2 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa4_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 2 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 3 , active0 , active1 ) ; return 4 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x1000000000000L ) ; case 97 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x4100000000L , active1 , 0x4000000000000L ) ; case 99 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x1000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 24 , 35 ) ; else if ( ( active0 & 0x2000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 49 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0x8000000800L , active1 , 0L ) ; case 104 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 16 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x500050000000000L ) ; case 105 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x90000080000L , active1 , 0L ) ; case 107 : if ( ( active0 & 0x1000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 12 , 35 ) ; break ; case 108 : if ( ( active0 & 0x2000000L ) != 0L ) { jjmatchedKind = 25 ; jjmatchedPos = 4 ; } return jjMoveStringLiteralDfa5_0 ( active0 , 0x4400000L , active1 , 0L ) ; case 113 : if ( ( active1 & 0x20000L ) != 0L ) return jjStopAtPos ( 4 , 81 ) ; else if ( ( active1 & 0x80000L ) != 0L ) return jjStopAtPos ( 4 , 83 ) ; break ; case 114 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x20480000000L , active1 , 0L ) ; case 115 : if ( ( active0 & 0x2000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 13 , 35 ) ; break ; case 116 : if ( ( active0 & 0x40000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 18 , 35 ) ; else if ( ( active0 & 0x8000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 27 , 35 ) ; else if ( ( active0 & 0x40000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 42 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 117 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x100000L , active1 , 0L ) ; case 119 : if ( ( active0 & 0x200000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 45 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x500000000L ) ; default : break ; } return jjStartNfa_0 ( 3 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa5_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 3 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 4 , active0 , active1 ) ; return 5 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa6_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 97 : return jjMoveStringLiteralDfa6_0 ( active0 , 0x800L , active1 , 0x1000000000000L ) ; case 99 : if ( ( active0 & 0x10000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 40 , 35 ) ; else if ( ( active0 & 0x80000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 43 , 35 ) ; return jjMoveStringLiteralDfa6_0 ( active0 , 0x8000000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x400000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 22 , 35 ) ; break ; case 102 : return jjMoveStringLiteralDfa6_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 104 : if ( ( active0 & 0x100000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 44 , 35 ) ; break ; case 105 : return jjMoveStringLiteralDfa6_0 ( active0 , 0L , active1 , 0x500000000L ) ; case 108 : return jjMoveStringLiteralDfa6_0 ( active0 , 0x4100000L , active1 , 0L ) ; case 110 : if ( ( active0 & 0x20000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 41 , 35 ) ; return jjMoveStringLiteralDfa6_0 ( active0 , 0x100080000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa6_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 116 : if ( ( active0 & 0x80000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 31 , 35 ) ; return jjMoveStringLiteralDfa6_0 ( active0 , 0x4000000000L , active1 , 0x500050000000000L ) ; default : break ; } return jjStartNfa_0 ( 4 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa6_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 4 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 5 , active0 , active1 ) ; return 6 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa7_0 ( active0 , 0L , active1 , 0x500050000000000L ) ; case 97 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x100000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x4000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 38 , 35 ) ; break ; case 110 : if ( ( active0 & 0x800L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 11 , 35 ) ; break ; case 115 : return jjMoveStringLiteralDfa7_0 ( active0 , 0L , active1 , 0x45004500000000L ) ; case 116 : if ( ( active0 & 0x100000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 20 , 35 ) ; return jjMoveStringLiteralDfa7_0 ( active0 , 0x8000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x80000L , active1 , 0L ) ; case 121 : if ( ( active0 & 0x4000000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 26 , 35 ) ; break ; default : break ; } return jjStartNfa_0 ( 5 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa7_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 5 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 6 , active0 , active1 ) ; return 7 ; } switch ( curChar ) { case 99 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x80000L ) != 0L ) return jjStartNfaWithStates_0 ( 7 , 19 , 35 ) ; return jjMoveStringLiteralDfa8_0 ( active0 , 0x8100000000L , active1 , 0x500000000L ) ; case 104 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 105 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 115 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x101010000000000L ) ; case 117 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 6 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa8_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 6 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 7 , active0 , active1 ) ; return 8 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x500000000L ) ; case 100 : if ( ( active0 & 0x8000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 8 , 39 , 35 ) ; break ; case 101 : if ( ( active0 & 0x400000000L ) != 0L ) return jjStartNfaWithStates_0 ( 8 , 34 , 35 ) ; break ; case 103 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 104 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x100010000000000L ) ; case 105 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x41004000000000L ) ; case 110 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x400040000000000L ) ; case 111 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x100000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 7 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 7 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 8 , active0 , active1 ) ; return 9 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x100000000L ) ; case 102 : if ( ( active0 & 0x100000000L ) != 0L ) return jjStartNfaWithStates_0 ( 9 , 32 , 35 ) ; return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 103 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x1000000000000L ) ; case 105 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x100010000000000L ) ; case 110 : if ( ( active1 & 0x4000000000000L ) != 0L ) return jjStopAtPos ( 9 , 114 ) ; break ; case 111 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x400000000L ) ; case 115 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 8 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa10_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 8 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 9 , 0L , active1 ) ; return 10 ; } switch ( curChar ) { case 102 : return jjMoveStringLiteralDfa11_0 ( active1 , 0x100010000000000L ) ; case 105 : return jjMoveStringLiteralDfa11_0 ( active1 , 0x400040000000000L ) ; case 110 : if ( ( active1 & 0x1000000000000L ) != 0L ) return jjStopAtPos ( 10 , 112 ) ; return jjMoveStringLiteralDfa11_0 ( active1 , 0x100000000L ) ; case 114 : if ( ( active1 & 0x400000000L ) != 0L ) return jjStopAtPos ( 10 , 98 ) ; break ; case 116 : if ( ( active1 & 0x4000000000L ) != 0L ) { jjmatchedKind = 102 ; jjmatchedPos = 10 ; } return jjMoveStringLiteralDfa11_0 ( active1 , 0x40000000000000L ) ; default : break ; } return jjStartNfa_0 ( 9 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa11_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 9 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 10 , 0L , active1 ) ; return 11 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa12_0 ( active1 , 0x40000000000000L ) ; case 100 : if ( ( active1 & 0x100000000L ) != 0L ) return jjStopAtPos ( 11 , 96 ) ; break ; case 103 : return jjMoveStringLiteralDfa12_0 ( active1 , 0x400040000000000L ) ; case 116 : if ( ( active1 & 0x10000000000L ) != 0L ) { jjmatchedKind = 104 ; jjmatchedPos = 11 ; } return jjMoveStringLiteralDfa12_0 ( active1 , 0x100000000000000L ) ; default : break ; } return jjStartNfa_0 ( 10 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa12_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 10 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 11 , 0L , active1 ) ; return 12 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa13_0 ( active1 , 0x100000000000000L ) ; case 97 : return jjMoveStringLiteralDfa13_0 ( active1 , 0x40000000000000L ) ; case 110 : return jjMoveStringLiteralDfa13_0 ( active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 11 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa13_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 11 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 12 , 0L , active1 ) ; return 13 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa14_0 ( active1 , 0x100000000000000L ) ; case 101 : return jjMoveStringLiteralDfa14_0 ( active1 , 0x400040000000000L ) ; case 115 : return jjMoveStringLiteralDfa14_0 ( active1 , 0x40000000000000L ) ; default : break ; } return jjStartNfa_0 ( 12 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa14_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 12 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 13 , 0L , active1 ) ; return 14 ; } switch ( curChar ) { case 100 : return jjMoveStringLiteralDfa15_0 ( active1 , 0x400040000000000L ) ; case 115 : return jjMoveStringLiteralDfa15_0 ( active1 , 0x140000000000000L ) ; default : break ; } return jjStartNfa_0 ( 13 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa15_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 13 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 14 , 0L , active1 ) ; return 15 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa16_0 ( active1 , 0x400040000000000L ) ; case 105 : return jjMoveStringLiteralDfa16_0 ( active1 , 0x40000000000000L ) ; case 115 : return jjMoveStringLiteralDfa16_0 ( active1 , 0x100000000000000L ) ; default : break ; } return jjStartNfa_0 ( 14 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa16_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 14 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 15 , 0L , active1 ) ; return 16 ; } switch ( curChar ) { case 103 : return jjMoveStringLiteralDfa17_0 ( active1 , 0x40000000000000L ) ; case 105 : return jjMoveStringLiteralDfa17_0 ( active1 , 0x100000000000000L ) ; case 115 : return jjMoveStringLiteralDfa17_0 ( active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 15 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa17_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 15 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 16 , 0L , active1 ) ; return 17 ; } switch ( curChar ) { case 103 : return jjMoveStringLiteralDfa18_0 ( active1 , 0x100000000000000L ) ; case 104 : return jjMoveStringLiteralDfa18_0 ( active1 , 0x400040000000000L ) ; case 110 : if ( ( active1 & 0x40000000000000L ) != 0L ) return jjStopAtPos ( 17 , 118 ) ; break ; default : break ; } return jjStartNfa_0 ( 16 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa18_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 16 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 17 , 0L , active1 ) ; return 18 ; } switch ( curChar ) { case 105 : return jjMoveStringLiteralDfa19_0 ( active1 , 0x400040000000000L ) ; case 110 : if ( ( active1 & 0x100000000000000L ) != 0L ) return jjStopAtPos ( 18 , 120 ) ; break ; default : break ; } return jjStartNfa_0 ( 17 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa19_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 17 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 18 , 0L , active1 ) ; return 19 ; } switch ( curChar ) { case 102 : return jjMoveStringLiteralDfa20_0 ( active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 18 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa20_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 18 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 19 , 0L , active1 ) ; return 20 ; } switch ( curChar ) { case 116 : if ( ( active1 & 0x40000000000L ) != 0L ) { jjmatchedKind = 106 ; jjmatchedPos = 20 ; } return jjMoveStringLiteralDfa21_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 19 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa21_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 19 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 20 , 0L , active1 ) ; return 21 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa22_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 20 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa22_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 20 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 21 , 0L , active1 ) ; return 22 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa23_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 21 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa23_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 21 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 22 , 0L , active1 ) ; return 23 ; } switch ( curChar ) { case 115 : return jjMoveStringLiteralDfa24_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 22 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa24_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 22 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 23 , 0L , active1 ) ; return 24 ; } switch ( curChar ) { case 115 : return jjMoveStringLiteralDfa25_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 23 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa25_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 23 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 24 , 0L , active1 ) ; return 25 ; } switch ( curChar ) { case 105 : return jjMoveStringLiteralDfa26_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 24 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa26_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 24 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 25 , 0L , active1 ) ; return 26 ; } switch ( curChar ) { case 103 : return jjMoveStringLiteralDfa27_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 25 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa27_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 25 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 26 , 0L , active1 ) ; return 27 ; } switch ( curChar ) { case 110 : if ( ( active1 & 0x400000000000000L ) != 0L ) return jjStopAtPos ( 27 , 122 ) ; break ; default : break ; } return jjStartNfa_0 ( 26 , 0L , active1 ) ; } private final void jjCheckNAdd ( int state ) { if ( jjrounds [ state ] != jjround ) { jjstateSet [ jjnewStateCnt ++ ] = state ; jjrounds [ state ] = jjround ; } } private final void jjAddStates ( int start , int end ) { do { jjstateSet [ jjnewStateCnt ++ ] = jjnextStates [ start ] ; } while ( start ++ != end ) ; } private final void jjCheckNAddTwoStates ( int state1 , int state2 ) { jjCheckNAdd ( state1 ) ; jjCheckNAdd ( state2 ) ; } private final void jjCheckNAddStates ( int start , int end ) { do { jjCheckNAdd ( jjnextStates [ start ] ) ; } while ( start ++ != end ) ; } private final void jjCheckNAddStates ( int start ) { jjCheckNAdd ( jjnextStates [ start ] ) ; jjCheckNAdd ( jjnextStates [ start + 1 ] ) ; } static final long [ ] jjbitVec0 = { 0x0L , 0x0L , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec1 = { 0xfffffffffffffffeL , 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec3 = { 0x1ff00000fffffffeL , 0xffffffffffffc000L , 0xffffffffL , 0x600000000000000L } ; static final long [ ] jjbitVec4 = { 0x0L , 0x0L , 0x0L , 0xff7fffffff7fffffL } ; static final long [ ] jjbitVec5 = { 0x0L , 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec6 = { 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffL , 0x0L } ; static final long [ ] jjbitVec7 = { 0xffffffffffffffffL , 0xffffffffffffffffL , 0x0L , 0x0L } ; static final long [ ] jjbitVec8 = { 0x3fffffffffffL , 0x0L , 0x0L , 0x0L } ; private final int jjMoveNfa_0 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 74 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : if ( ( 0x1ffffffffL & l ) != 0L ) { if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; } else if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 0 , 6 ) ; else if ( curChar == 47 ) jjAddStates ( 7 , 9 ) ; else if ( curChar == 36 ) { if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; } else if ( curChar == 34 ) jjCheckNAddStates ( 10 , 12 ) ; else if ( curChar == 39 ) jjAddStates ( 13 , 14 ) ; else if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; if ( ( 0x3fe000000000000L & l ) != 0L ) { if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 8 , 9 ) ; } else if ( curChar == 48 ) { if ( kind > 50 ) kind = 50 ; jjCheckNAddStates ( 15 , 17 ) ; } break ; case 56 : if ( curChar == 42 ) jjCheckNAddTwoStates ( 69 , 70 ) ; else if ( curChar == 47 ) jjCheckNAddStates ( 18 , 20 ) ; if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 61 ; break ; case 0 : if ( ( 0x1ffffffffL & l ) == 0L ) break ; if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; break ; case 1 : if ( curChar == 33 ) jjCheckNAddStates ( 21 , 23 ) ; break ; case 2 : if ( ( 0xffffffffffffdbffL & l ) != 0L ) jjCheckNAddStates ( 21 , 23 ) ; break ; case 3 : if ( ( 0x2400L & l ) != 0L && kind > 8 ) kind = 8 ; break ; case 4 : if ( curChar == 10 && kind > 8 ) kind = 8 ; break ; case 5 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 4 ; break ; case 7 : if ( ( 0x3fe000000000000L & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 8 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 10 : if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; break ; case 11 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddStates ( 24 , 26 ) ; break ; case 13 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 14 ) ; break ; case 14 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddTwoStates ( 14 , 15 ) ; break ; case 16 : if ( curChar == 39 ) jjAddStates ( 13 , 14 ) ; break ; case 17 : if ( ( 0xffffff7fffffdbffL & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 18 : if ( curChar == 39 && kind > 56 ) kind = 56 ; break ; case 20 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 21 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 22 , 18 ) ; break ; case 22 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 23 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 24 ; break ; case 24 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 22 ) ; break ; case 25 : if ( curChar == 34 ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 26 : if ( ( 0xfffffffbffffdbffL & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 28 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 29 : if ( curChar == 34 && kind > 57 ) kind = 57 ; break ; case 30 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 27 , 30 ) ; break ; case 31 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 32 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 33 ; break ; case 33 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 31 ) ; break ; case 34 : if ( curChar != 36 ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 35 : if ( ( 0x3ff001000000000L & l ) == 0L ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 36 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 0 , 6 ) ; break ; case 37 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 37 , 38 ) ; break ; case 38 : if ( curChar != 46 ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddStates ( 31 , 33 ) ; break ; case 39 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddStates ( 31 , 33 ) ; break ; case 41 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 42 ) ; break ; case 42 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddTwoStates ( 42 , 15 ) ; break ; case 43 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 43 , 44 ) ; break ; case 45 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 46 ) ; break ; case 46 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddTwoStates ( 46 , 15 ) ; break ; case 47 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 34 , 36 ) ; break ; case 49 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 50 ) ; break ; case 50 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 50 , 15 ) ; break ; case 51 : if ( curChar != 48 ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddStates ( 15 , 17 ) ; break ; case 53 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 53 , 9 ) ; break ; case 54 : if ( ( 0xff000000000000L & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 54 , 9 ) ; break ; case 55 : if ( curChar == 47 ) jjAddStates ( 7 , 9 ) ; break ; case 57 : if ( ( 0xffffffffffffdbffL & l ) != 0L ) jjCheckNAddStates ( 18 , 20 ) ; break ; case 58 : if ( ( 0x2400L & l ) != 0L && kind > 7 ) kind = 7 ; break ; case 59 : if ( curChar == 10 && kind > 7 ) kind = 7 ; break ; case 60 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 59 ; break ; case 61 : if ( curChar == 42 ) jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 62 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 63 : if ( curChar == 42 ) jjCheckNAddStates ( 37 , 39 ) ; break ; case 64 : if ( ( 0xffff7bffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 65 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 66 : if ( curChar == 47 && kind > 9 ) kind = 9 ; break ; case 67 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 61 ; break ; case 68 : if ( curChar == 42 ) jjCheckNAddTwoStates ( 69 , 70 ) ; break ; case 69 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 69 , 70 ) ; break ; case 70 : if ( curChar == 42 ) jjCheckNAddStates ( 40 , 42 ) ; break ; case 71 : if ( ( 0xffff7bffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 72 , 70 ) ; break ; case 72 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 72 , 70 ) ; break ; case 73 : if ( curChar == 47 && kind > 10 ) kind = 10 ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : case 35 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 2 : jjAddStates ( 21 , 23 ) ; break ; case 9 : if ( ( 0x100000001000L & l ) != 0L && kind > 50 ) kind = 50 ; break ; case 12 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 43 , 44 ) ; break ; case 15 : if ( ( 0x5000000050L & l ) != 0L && kind > 54 ) kind = 54 ; break ; case 17 : if ( ( 0xffffffffefffffffL & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 19 : if ( curChar == 92 ) jjAddStates ( 45 , 47 ) ; break ; case 20 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 26 : if ( ( 0xffffffffefffffffL & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 27 : if ( curChar == 92 ) jjAddStates ( 48 , 50 ) ; break ; case 28 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 40 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 51 , 52 ) ; break ; case 44 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 53 , 54 ) ; break ; case 48 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 55 , 56 ) ; break ; case 52 : if ( ( 0x100000001000000L & l ) != 0L ) jjCheckNAdd ( 53 ) ; break ; case 53 : if ( ( 0x7e0000007eL & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 53 , 9 ) ; break ; case 57 : jjAddStates ( 18 , 20 ) ; break ; case 62 : jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 64 : case 65 : jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 69 : jjCheckNAddTwoStates ( 69 , 70 ) ; break ; case 71 : case 72 : jjCheckNAddTwoStates ( 72 , 70 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) { if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; } if ( jjCanMove_2 ( hiByte , i1 , i2 , l1 , l2 ) ) { if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; } break ; case 0 : if ( ! jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; break ; case 2 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 21 , 23 ) ; break ; case 17 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjstateSet [ jjnewStateCnt ++ ] = 18 ; break ; case 26 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 10 , 12 ) ; break ; case 34 : case 35 : if ( ! jjCanMove_2 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 57 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 18 , 20 ) ; break ; case 62 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 64 : case 65 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 69 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 69 , 70 ) ; break ; case 71 : case 72 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 72 , 70 ) ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 74 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } static final int [ ] jjnextStates = { 37 , 38 , 43 , 44 , 47 , 48 , 15 , 56 , 67 , 68 , 26 , 27 , 29 , 17 , 19 , 52 , 54 , 9 , 57 , 58 , 60 , 2 , 3 , 5 , 11 , 12 , 15 , 26 , 27 , 31 , 29 , 39 , 40 , 15 , 47 , 48 , 15 , 63 , 64 , 66 , 70 , 71 , 73 , 13 , 14 , 20 , 21 , 23 , 28 , 30 , 32 , 41 , 42 , 45 , 46 , 49 , 50 , } ; private static final boolean jjCanMove_0 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec0 [ i2 ] & l2 ) != 0L ) ; default : return false ; } } private static final boolean jjCanMove_1 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec0 [ i2 ] & l2 ) != 0L ) ; default : if ( ( jjbitVec1 [ i1 ] & l1 ) != 0L ) return true ; return false ; } } private static final boolean jjCanMove_2 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec4 [ i2 ] & l2 ) != 0L ) ; case 48 : return ( ( jjbitVec5 [ i2 ] & l2 ) != 0L ) ; case 49 : return ( ( jjbitVec6 [ i2 ] & l2 ) != 0L ) ; case 51 : return ( ( jjbitVec7 [ i2 ] & l2 ) != 0L ) ; case 61 : return ( ( jjbitVec8 [ i2 ] & l2 ) != 0L ) ; default : if ( ( jjbitVec3 [ i1 ] & l1 ) != 0L ) return true ; return false ; } } public static final String [ ] jjstrLiteralImages = { "" , null , null , null , null , null , null , null , null , null , null , "\142\157\157\154\145\141\156" , "\142\162\145\141\153" , "\143\154\141\163\163" , "\142\171\164\145" , "\143\141\163\145" , "\143\141\164\143\150" , "\143\150\141\162" , "\143\157\156\163\164" , "\143\157\156\164\151\156\165\145" , "\144\145\146\141\165\154\164" , "\144\157" , "\144\157\165\142\154\145" , "\145\154\163\145" , "\146\141\154\163\145" , "\146\151\156\141\154" , "\146\151\156\141\154\154\171" , "\146\154\157\141\164" , "\146\157\162" , "\147\157\164\157" , "\151\146" , "\151\155\160\157\162\164" , "\151\156\163\164\141\156\143\145\157\146" , "\151\156\164" , "\151\156\164\145\162\146\141\143\145" , "\154\157\156\147" , "\156\145\167" , "\156\165\154\154" , "\160\162\151\166\141\164\145" , "\160\162\157\164\145\143\164\145\144" , "\160\165\142\154\151\143" , "\162\145\164\165\162\156" , "\163\150\157\162\164" , "\163\164\141\164\151\143" , "\163\167\151\164\143\150" , "\164\150\162\157\167" , "\164\162\165\145" , "\164\162\171" , "\166\157\151\144" , "\167\150\151\154\145" , null , null , null , null , null , null , null , null , null , null , null , "\50" , "\51" , "\173" , "\175" , "\133" , "\135" , "\73" , "\54" , "\56" , "\75" , "\76" , "\100\147\164" , "\74" , "\100\154\164" , "\41" , "\176" , "\77" , "\72" , "\75\75" , "\74\75" , "\100\154\164\145\161" , "\76\75" , "\100\147\164\145\161" , "\41\75" , "\174\174" , "\100\157\162" , "\46\46" , "\100\141\156\144" , "\53\53" , "\55\55" , "\53" , "\55" , "\52" , "\57" , "\46" , "\100\142\151\164\167\151\163\145\137\141\156\144" , "\174" , "\100\142\151\164\167\151\163\145\137\157\162" , "\136" , "\45" , "\74\74" , "\100\154\145\146\164\137\163\150\151\146\164" , "\76\76" , "\100\162\151\147\150\164\137\163\150\151\146\164" , "\76\76\76" , "\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164" , "\53\75" , "\55\75" , "\52\75" , "\57\75" , "\46\75" , "\100\141\156\144\137\141\163\163\151\147\156" , "\174\75" , "\100\157\162\137\141\163\163\151\147\156" , "\136\75" , "\45\75" , "\74\74\75" , "\100\154\145\146\164\137\163\150\151\146\164\137\141\163\163\151\147\156" , "\76\76\75" , "\100\162\151\147\150\164\137\163\150\151\146\164\137\141\163\163\151\147\156" , "\76\76\76\75" , "\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164\137\141\163\163\151\147\156" , } ; public static final String [ ] lexStateNames = { "DEFAULT" , } ; static final long [ ] jjtoToken = { 0xe747fffffffff801L , 0x7ffffffffffffffL , } ; static final long [ ] jjtoSkip = { 0x7feL , 0x0L , } ; static final long [ ] jjtoSpecial = { 0x780L , 0x0L , } ; private ASCII_UCodeESC_CharStream input_stream ; private final int [ ] jjrounds = new int [ 74 ] ; private final int [ ] jjstateSet = new int [ 148 ] ; protected char curChar ; public ParserTokenManager ( ASCII_UCodeESC_CharStream stream ) { if ( ASCII_UCodeESC_CharStream . staticFlag ) throw new Error ( "ERROR: Cannot use a static CharStream class with a non-static lexical analyzer." ) ; input_stream = stream ; } public ParserTokenManager ( ASCII_UCodeESC_CharStream stream , int lexState ) { this ( stream ) ; SwitchTo ( lexState ) ; } public void ReInit ( ASCII_UCodeESC_CharStream stream ) { jjmatchedPos = jjnewStateCnt = 0 ; curLexState = defaultLexState ; input_stream = stream ; ReInitRounds ( ) ; } private final void ReInitRounds ( ) { int i ; jjround = 0x80000001 ; for ( i = 74 ; i -- > 0 ; ) jjrounds [ i ] = 0x80000000 ; } public void ReInit ( ASCII_UCodeESC_CharStream stream , int lexState ) { ReInit ( stream ) ; SwitchTo ( lexState ) ; } public void SwitchTo ( int lexState ) { if ( lexState >= 1 || lexState < 0 ) throw new TokenMgrError ( "Error: Ignoring invalid lexical state : " + lexState + ". State unchanged." , TokenMgrError . INVALID_LEXICAL_STATE ) ; else curLexState = lexState ; } private final Token jjFillToken ( ) { Token t = Token . newToken ( jjmatchedKind ) ; t . kind = jjmatchedKind ; String im = jjstrLiteralImages [ jjmatchedKind ] ; t . image = ( im == null ) ? input_stream . GetImage ( ) : im ; t . beginLine = input_stream . getBeginLine ( ) ; t . beginColumn = input_stream . getBeginColumn ( ) ; t . endLine = input_stream . getEndLine ( ) ; t . endColumn = input_stream . getEndColumn ( ) ; return t ; } int curLexState = 0 ; int defaultLexState = 0 ; int jjnewStateCnt ; int jjround ; int jjmatchedPos ; int jjmatchedKind ; public final Token getNextToken ( ) { int kind ; Token specialToken = null ; Token matchedToken ; int curPos = 0 ; EOFLoop : for ( ; ; ) { try { curChar = input_stream . BeginToken ( ) ; } catch ( java . io . IOException e ) { jjmatchedKind = 0 ; matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_0 ( ) ; if ( jjmatchedKind != 0x7fffffff ) { if ( jjmatchedPos + 1 < curPos ) input_stream . backup ( curPos - jjmatchedPos - 1 ) ; if ( ( jjtoToken [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } else { if ( ( jjtoSpecial [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; if ( specialToken == null ) specialToken = matchedToken ; else { matchedToken . specialToken = specialToken ; specialToken = ( specialToken . next = matchedToken ) ; } } continue EOFLoop ; } } int error_line = input_stream . getEndLine ( ) ; int error_column = input_stream . getEndColumn ( ) ; String error_after = null ; boolean EOFSeen = false ; try { input_stream . readChar ( ) ; input_stream . backup ( 1 ) ; } catch ( java . io . IOException e1 ) { EOFSeen = true ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; if ( curChar == '\n' || curChar == '\r' ) { error_line ++ ; error_column = 0 ; } else error_column ++ ; } if ( ! EOFSeen ) { input_stream . backup ( 1 ) ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; } throw new TokenMgrError ( EOFSeen , curLexState , error_line , error_column , error_after , curChar , TokenMgrError . LEXICAL_ERROR ) ; } } } 	0	['50', '1', '0', '5', '66', '3', '1', '4', '6', '0.75170068', '6259', '0.166666667', '1', '0', '0.5', '0', '0', '123.7', '163', '8.68', '0']
package gnu . regexp ; import java . io . Serializable ; class CharIndexedStringBuffer implements CharIndexed , Serializable { private StringBuffer s ; private int anchor ; CharIndexedStringBuffer ( StringBuffer str , int index ) { s = str ; anchor = index ; } public char charAt ( int index ) { int pos = anchor + index ; return ( ( pos < s . length ( ) ) && ( pos >= 0 ) ) ? s . charAt ( pos ) : OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( anchor < s . length ( ) ) ; } public boolean move ( int index ) { return ( ( anchor += index ) < s . length ( ) ) ; } } 	0	['4', '1', '0', '2', '7', '0', '1', '1', '3', '0', '59', '1', '0', '0', '0.666666667', '0', '0', '13.25', '3', '1.75', '0']
package org . gjt . sp . jedit ; import java . util . * ; import org . gjt . sp . util . Log ; public class EditBus { public static void addToBus ( EBComponent comp ) { synchronized ( components ) { components . addElement ( comp ) ; copyComponents = null ; } } public static void removeFromBus ( EBComponent comp ) { synchronized ( components ) { components . removeElement ( comp ) ; copyComponents = null ; } } public static EBComponent [ ] getComponents ( ) { synchronized ( components ) { if ( copyComponents == null ) { copyComponents = new EBComponent [ components . size ( ) ] ; components . copyInto ( copyComponents ) ; } return copyComponents ; } } public static void send ( EBMessage message ) { Log . log ( Log . DEBUG , EditBus . class , message . toString ( ) ) ; EBComponent [ ] comps = getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { try { comps [ i ] . handleMessage ( message ) ; if ( message . isVetoed ( ) ) break ; } catch ( Throwable t ) { Log . log ( Log . ERROR , EditBus . class , "Exception" + " while sending message on EditBus:" ) ; Log . log ( Log . ERROR , EditBus . class , t ) ; } } } public static Object [ ] getNamedList ( Object tag ) { Object [ ] list = ( Object [ ] ) listArrays . get ( tag ) ; if ( list != null ) return list ; Vector listVector = ( Vector ) listVectors . get ( tag ) ; if ( listVector != null ) { list = new Object [ listVector . size ( ) ] ; listVector . copyInto ( list ) ; listArrays . put ( tag , list ) ; return list ; } return null ; } public static Enumeration getNamedLists ( ) { return listVectors . keys ( ) ; } public static void addToNamedList ( Object tag , Object entry ) { Vector listVector = ( Vector ) listVectors . get ( tag ) ; if ( listVector == null ) { listVector = new Vector ( ) ; listVectors . put ( tag , listVector ) ; } listVector . addElement ( entry ) ; listArrays . remove ( tag ) ; } public static void removeFromNamedList ( Object tag , Object entry ) { Vector listVector = ( Vector ) listVectors . get ( tag ) ; if ( listVector == null ) return ; listVector . removeElement ( entry ) ; listArrays . remove ( tag ) ; } private static Vector components = new Vector ( ) ; private static EBComponent [ ] copyComponents ; private static Hashtable listVectors = new Hashtable ( ) ; private static Hashtable listArrays = new Hashtable ( ) ; private EditBus ( ) { } } 	0	['11', '1', '0', '22', '29', '23', '19', '3', '8', '0.72', '244', '1', '1', '0', '0.16', '0', '0', '20.72727273', '5', '1.7273', '0']
package org . gjt . sp . jedit . gui ; import java . awt . * ; public class VariableGridLayout implements LayoutManager2 , java . io . Serializable { public static final int FIXED_NUM_ROWS = 1 ; public static final int FIXED_NUM_COLUMNS = 2 ; public VariableGridLayout ( int mode , int size , int hgap , int vgap ) { if ( mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS ) { throw new IllegalArgumentException ( "illegal mode; value is " + mode ) ; } if ( size <= 0 ) { throw new IllegalArgumentException ( "size cannot be zero or less; value is " + size ) ; } if ( hgap < 0 ) { throw new IllegalArgumentException ( "hgap cannot be negative; value is " + hgap ) ; } if ( vgap < 0 ) { throw new IllegalArgumentException ( "vgap cannot be negative; value is " + vgap ) ; } this . mode = mode ; this . size = size ; this . hgap = hgap ; this . vgap = vgap ; } public VariableGridLayout ( int mode , int size ) { this ( mode , size , 0 , 0 ) ; } public VariableGridLayout ( ) { this ( FIXED_NUM_ROWS , 1 , 0 , 0 ) ; } public void addLayoutComponent ( String name , Component component ) { } public void addLayoutComponent ( Component component , Object constraints ) { } public void removeLayoutComponent ( Component component ) { } public float getLayoutAlignmentX ( Container container ) { return 0.5f ; } public float getLayoutAlignmentY ( Container container ) { return 0.5f ; } public Dimension preferredLayoutSize ( Container parent ) { return getLayoutSize ( parent , 2 ) ; } public Dimension minimumLayoutSize ( Container parent ) { return getLayoutSize ( parent , 0 ) ; } public Dimension maximumLayoutSize ( Container parent ) { return getLayoutSize ( parent , 1 ) ; } public void layoutContainer ( Container parent ) { synchronized ( parent . getTreeLock ( ) ) { int ncomponents = parent . getComponentCount ( ) ; if ( ncomponents == 0 ) { return ; } int total_height = 0 ; for ( int r = 0 , i = 0 ; r < nrows ; r ++ ) { for ( int c = 0 ; c < ncols ; c ++ , i ++ ) { if ( i < ncomponents ) { Dimension d = parent . getComponent ( i ) . getPreferredSize ( ) ; row_heights [ r ] = Math . max ( row_heights [ r ] , d . height ) ; col_widths [ c ] = Math . max ( col_widths [ c ] , d . width ) ; } else { break ; } } total_height += row_heights [ r ] ; } int total_width = 0 ; for ( int c = 0 ; c < ncols ; c ++ ) { total_width += col_widths [ c ] ; } Dimension parent_size = parent . getSize ( ) ; Insets insets = parent . getInsets ( ) ; int free_height = parent_size . height - insets . top - insets . bottom - ( nrows - 1 ) * vgap ; int free_width = parent_size . width - insets . left - insets . right - ( ncols - 1 ) * hgap ; if ( total_height != free_height ) { double dy = ( double ) free_height / ( double ) total_height ; for ( int r = 0 ; r < nrows ; r ++ ) { row_heights [ r ] = ( int ) ( ( double ) row_heights [ r ] * dy ) ; } } if ( total_width != free_width ) { double dx = ( ( double ) free_width ) / ( ( double ) total_width ) ; for ( int c = 0 ; c < ncols ; c ++ ) { col_widths [ c ] = ( int ) ( ( double ) col_widths [ c ] * dx ) ; } } for ( int r = 0 , y = insets . top , i = 0 ; r < nrows ; y += row_heights [ r ] + vgap , r ++ ) { for ( int c = 0 , x = insets . left ; c < ncols ; x += col_widths [ c ] + hgap , c ++ , i ++ ) { if ( i < ncomponents ) { parent . getComponent ( i ) . setBounds ( x , y , col_widths [ c ] , row_heights [ r ] ) ; } } } } } public void invalidateLayout ( Container container ) { int ncomponents = container . getComponentCount ( ) ; int old_nrows = nrows ; int old_ncols = ncols ; if ( this . mode == FIXED_NUM_ROWS ) { nrows = this . size ; ncols = ( ncomponents + nrows - 1 ) / nrows ; } else { ncols = this . size ; nrows = ( ncomponents + ncols - 1 ) / ncols ; } if ( old_nrows != nrows ) { row_heights = new int [ nrows ] ; } if ( old_ncols != ncols ) { col_widths = new int [ ncols ] ; } } public int getRows ( ) { return nrows ; } public int getColumns ( ) { return ncols ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[mode=" + mode + ",size=" + size + ",hgap=" + hgap + ",vgap=" + vgap + "]" ; } private Dimension getLayoutSize ( Container parent , int which ) { synchronized ( parent . getTreeLock ( ) ) { int ncomponents = parent . getComponentCount ( ) ; int h = 0 ; int w = 0 ; for ( int r = 0 , i = 0 ; r < nrows ; r ++ ) { int row_height = 0 ; for ( int c = 0 ; c < ncols ; c ++ , i ++ ) { if ( i < ncomponents ) { switch ( which ) { case 0 : row_height = Math . max ( row_height , parent . getComponent ( i ) . getMinimumSize ( ) . height ) ; break ; case 1 : row_height = Math . max ( row_height , parent . getComponent ( i ) . getMaximumSize ( ) . height ) ; break ; default : row_height = Math . max ( row_height , parent . getComponent ( i ) . getPreferredSize ( ) . height ) ; break ; } } else { break ; } } h += row_height ; } for ( int c = 0 ; c < ncols ; c ++ ) { int col_width = 0 ; for ( int r = 0 ; r < nrows ; r ++ ) { int i = r * ncols + c ; if ( i < ncomponents ) { switch ( which ) { case 0 : col_width = Math . max ( col_width , parent . getComponent ( i ) . getMinimumSize ( ) . width ) ; break ; case 1 : col_width = Math . max ( col_width , parent . getComponent ( i ) . getMaximumSize ( ) . width ) ; break ; default : col_width = Math . max ( col_width , parent . getComponent ( i ) . getPreferredSize ( ) . width ) ; break ; } } else { break ; } } w += col_width ; } Insets insets = parent . getInsets ( ) ; return new Dimension ( w + insets . left + insets . right + ( ( ncols - 1 ) * hgap ) , h + insets . top + insets . bottom + ( ( nrows - 1 ) * vgap ) ) ; } } private int mode ; private int size ; private int hgap ; private int vgap ; private transient int nrows = - 1 ; private transient int ncols = - 1 ; private transient int [ ] row_heights = null ; private transient int [ ] col_widths = null ; } 	0	['17', '1', '0', '1', '37', '100', '1', '0', '16', '0.7', '691', '0.8', '0', '0', '0.323529412', '0', '0', '39.05882353', '13', '2.1176', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . FontSelector ; import org . gjt . sp . jedit . * ; public class GutterOptionPane extends AbstractOptionPane { public GutterOptionPane ( ) { super ( "gutter" ) ; } public void _init ( ) { lineNumbersEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.lineNumbers" ) ) ; lineNumbersEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.lineNumbers" ) ) ; addComponent ( lineNumbersEnabled ) ; String _fontFamily = jEdit . getProperty ( "view.gutter.font" ) ; int _fontStyle ; try { _fontStyle = Integer . parseInt ( jEdit . getProperty ( "view.gutter.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { _fontStyle = Font . PLAIN ; } int _fontSize ; try { _fontSize = Integer . parseInt ( jEdit . getProperty ( "view.gutter.fontsize" ) ) ; } catch ( NumberFormatException nf ) { _fontSize = 14 ; } gutterFont = new FontSelector ( new Font ( _fontFamily , _fontStyle , _fontSize ) ) ; addComponent ( jEdit . getProperty ( "options.gutter.font" ) , gutterFont ) ; gutterBorderWidth = new JTextField ( jEdit . getProperty ( "view.gutter.borderWidth" ) ) ; addComponent ( jEdit . getProperty ( "options.gutter.borderWidth" ) , gutterBorderWidth ) ; gutterHighlightInterval = new JTextField ( jEdit . getProperty ( "view.gutter.highlightInterval" ) ) ; addComponent ( jEdit . getProperty ( "options.gutter.interval" ) , gutterHighlightInterval ) ; String [ ] alignments = new String [ ] { "Left" , "Center" , "Right" } ; gutterNumberAlignment = new JComboBox ( alignments ) ; String alignment = jEdit . getProperty ( "view.gutter.numberAlignment" ) ; if ( "right" . equals ( alignment ) ) gutterNumberAlignment . setSelectedIndex ( 2 ) ; else if ( "center" . equals ( alignment ) ) gutterNumberAlignment . setSelectedIndex ( 1 ) ; else gutterNumberAlignment . setSelectedIndex ( 0 ) ; addComponent ( jEdit . getProperty ( "options.gutter.numberAlignment" ) , gutterNumberAlignment ) ; gutterCurrentLineHighlightEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.currentLineHighlight" ) ) ; gutterCurrentLineHighlightEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.highlightCurrentLine" ) ) ; addComponent ( gutterCurrentLineHighlightEnabled ) ; gutterMarkerHighlightEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.markerHighlight" ) ) ; gutterMarkerHighlightEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.markerHighlight" ) ) ; addComponent ( gutterMarkerHighlightEnabled ) ; } public void _save ( ) { Font _font = gutterFont . getFont ( ) ; jEdit . setProperty ( "view.gutter.font" , _font . getFamily ( ) ) ; jEdit . setProperty ( "view.gutter.fontsize" , String . valueOf ( _font . getSize ( ) ) ) ; jEdit . setProperty ( "view.gutter.fontstyle" , String . valueOf ( _font . getStyle ( ) ) ) ; jEdit . setProperty ( "view.gutter.borderWidth" , gutterBorderWidth . getText ( ) ) ; jEdit . setProperty ( "view.gutter.highlightInterval" , gutterHighlightInterval . getText ( ) ) ; String alignment = null ; switch ( gutterNumberAlignment . getSelectedIndex ( ) ) { case 2 : alignment = "right" ; break ; case 1 : alignment = "center" ; break ; case 0 : default : alignment = "left" ; } jEdit . setProperty ( "view.gutter.numberAlignment" , alignment ) ; jEdit . setBooleanProperty ( "view.gutter.lineNumbers" , lineNumbersEnabled . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.gutter.highlightCurrentLine" , gutterCurrentLineHighlightEnabled . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.gutter.markerHighlight" , gutterMarkerHighlightEnabled . isSelected ( ) ) ; } private FontSelector gutterFont ; private JTextField gutterBorderWidth ; private JTextField gutterHighlightInterval ; private JComboBox gutterNumberAlignment ; private JCheckBox lineNumbersEnabled ; private JCheckBox gutterCurrentLineHighlightEnabled ; private JCheckBox gutterMarkerHighlightEnabled ; } 	0	['3', '6', '0', '4', '27', '1', '1', '3', '3', '0.5', '238', '1', '1', '0.996987952', '1', '2', '4', '76', '3', '1.6667', '0']
package bsh ; import java . lang . reflect . Array ; class BSHArrayInitializer extends SimpleNode { BSHArrayInitializer ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { throw new EvalError ( "Array initializer has no base type." ) ; } public Object eval ( Class baseType , int dimensions , CallStack callstack , Interpreter interpreter ) throws EvalError { int numInitializers = jjtGetNumChildren ( ) ; int [ ] dima = new int [ dimensions ] ; dima [ 0 ] = numInitializers ; Object initializers = Array . newInstance ( baseType , dima ) ; for ( int i = 0 ; i < numInitializers ; i ++ ) { SimpleNode node = ( SimpleNode ) jjtGetChild ( i ) ; Object currentInitializer ; if ( node instanceof BSHArrayInitializer ) { if ( dimensions < 2 ) throw new EvalError ( "Invalid Location for Intializer, position: " + i , this ) ; currentInitializer = ( ( BSHArrayInitializer ) node ) . eval ( baseType , dimensions - 1 , callstack , interpreter ) ; } else currentInitializer = node . eval ( callstack , interpreter ) ; if ( currentInitializer == Primitive . VOID ) throw new EvalError ( "Void in array initializer, position" + i , this ) ; Object value ; if ( currentInitializer instanceof Primitive ) value = ( ( Primitive ) currentInitializer ) . getValue ( ) ; else value = currentInitializer ; try { Array . set ( initializers , i , value ) ; } catch ( IllegalArgumentException e ) { Interpreter . debug ( "illegal arg" + e ) ; throwTypeError ( baseType , currentInitializer , i ) ; } catch ( ArrayStoreException e ) { Interpreter . debug ( "arraystore" + e ) ; throwTypeError ( baseType , currentInitializer , i ) ; } } return initializers ; } private void throwTypeError ( Class baseType , Object initializer , int argNum ) throws EvalError { String lhsType = Reflect . normalizeClassName ( baseType ) ; String rhsType ; if ( initializer instanceof Primitive ) rhsType = ( ( Primitive ) initializer ) . getType ( ) . getName ( ) ; else rhsType = Reflect . normalizeClassName ( initializer . getClass ( ) ) ; throw new EvalError ( "Incompatible type: " + rhsType + " in initializer of array type: " + baseType + " at position: " + argNum , this ) ; } } 	0	['4', '2', '0', '10', '23', '6', '3', '7', '2', '2', '175', '0', '0', '0.857142857', '0.583333333', '1', '1', '42.75', '1', '0.75', '0']
package bsh ; final class ASCII_UCodeESC_CharStream { public static final boolean staticFlag = false ; static final int hexval ( char c ) throws java . io . IOException { switch ( c ) { case '0' : return 0 ; case '1' : return 1 ; case '2' : return 2 ; case '3' : return 3 ; case '4' : return 4 ; case '5' : return 5 ; case '6' : return 6 ; case '7' : return 7 ; case '8' : return 8 ; case '9' : return 9 ; case 'a' : case 'A' : return 10 ; case 'b' : case 'B' : return 11 ; case 'c' : case 'C' : return 12 ; case 'd' : case 'D' : return 13 ; case 'e' : case 'E' : return 14 ; case 'f' : case 'F' : return 15 ; } throw new java . io . IOException ( ) ; } public int bufpos = - 1 ; int bufsize ; int available ; int tokenBegin ; private int bufline [ ] ; private int bufcolumn [ ] ; private int column = 0 ; private int line = 1 ; private java . io . Reader inputStream ; private boolean prevCharIsCR = false ; private boolean prevCharIsLF = false ; private char [ ] nextCharBuf ; private char [ ] buffer ; private int maxNextCharInd = 0 ; private int nextCharInd = - 1 ; private int inBuf = 0 ; private final void ExpandBuff ( boolean wrapAround ) { char [ ] newbuffer = new char [ bufsize + 2048 ] ; int newbufline [ ] = new int [ bufsize + 2048 ] ; int newbufcolumn [ ] = new int [ bufsize + 2048 ] ; try { if ( wrapAround ) { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; System . arraycopy ( buffer , 0 , newbuffer , bufsize - tokenBegin , bufpos ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufline , 0 , newbufline , bufsize - tokenBegin , bufpos ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufcolumn , 0 , newbufcolumn , bufsize - tokenBegin , bufpos ) ; bufcolumn = newbufcolumn ; bufpos += ( bufsize - tokenBegin ) ; } else { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; bufcolumn = newbufcolumn ; bufpos -= tokenBegin ; } } catch ( Throwable t ) { throw new Error ( t . getMessage ( ) ) ; } available = ( bufsize += 2048 ) ; tokenBegin = 0 ; } private final void FillBuff ( ) throws java . io . IOException { int i ; if ( maxNextCharInd == 4096 ) maxNextCharInd = nextCharInd = 0 ; try { if ( ( i = inputStream . read ( nextCharBuf , maxNextCharInd , 4096 - maxNextCharInd ) ) == - 1 ) { inputStream . close ( ) ; throw new java . io . IOException ( ) ; } else maxNextCharInd += i ; return ; } catch ( java . io . IOException e ) { if ( bufpos != 0 ) { -- bufpos ; backup ( 0 ) ; } else { bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; } throw e ; } } private final char ReadByte ( ) throws java . io . IOException { if ( ++ nextCharInd >= maxNextCharInd ) FillBuff ( ) ; return nextCharBuf [ nextCharInd ] ; } public final char BeginToken ( ) throws java . io . IOException { if ( inBuf > 0 ) { -- inBuf ; return buffer [ tokenBegin = ( bufpos == bufsize - 1 ) ? ( bufpos = 0 ) : ++ bufpos ] ; } tokenBegin = 0 ; bufpos = - 1 ; return readChar ( ) ; } private final void AdjustBuffSize ( ) { if ( available == bufsize ) { if ( tokenBegin > 2048 ) { bufpos = 0 ; available = tokenBegin ; } else ExpandBuff ( false ) ; } else if ( available > tokenBegin ) available = bufsize ; else if ( ( tokenBegin - available ) < 2048 ) ExpandBuff ( true ) ; else available = tokenBegin ; } private final void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c == '\n' ) { prevCharIsLF = true ; } else line += ( column = 1 ) ; } switch ( c ) { case '\r' : prevCharIsCR = true ; break ; case '\n' : prevCharIsLF = true ; break ; case '\t' : column -- ; column += ( 8 - ( column & 07 ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; } public final char readChar ( ) throws java . io . IOException { if ( inBuf > 0 ) { -- inBuf ; return buffer [ ( bufpos == bufsize - 1 ) ? ( bufpos = 0 ) : ++ bufpos ] ; } char c ; if ( ++ bufpos == available ) AdjustBuffSize ( ) ; if ( ( ( buffer [ bufpos ] = c = ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) == '\\' ) ) { UpdateLineColumn ( c ) ; int backSlashCnt = 1 ; for ( ; ; ) { if ( ++ bufpos == available ) AdjustBuffSize ( ) ; try { if ( ( buffer [ bufpos ] = c = ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) != '\\' ) { UpdateLineColumn ( c ) ; if ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { if ( -- bufpos < 0 ) bufpos = bufsize - 1 ; break ; } backup ( backSlashCnt ) ; return '\\' ; } } catch ( java . io . IOException e ) { if ( backSlashCnt > 1 ) backup ( backSlashCnt ) ; return '\\' ; } UpdateLineColumn ( c ) ; backSlashCnt ++ ; } try { while ( ( c = ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) == 'u' ) ++ column ; buffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) << 8 | hexval ( ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) << 4 | hexval ( ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) ) ; column += 4 ; } catch ( java . io . IOException e ) { throw new Error ( "Invalid escape character at line " + line + " column " + column + "." ) ; } if ( backSlashCnt == 1 ) return c ; else { backup ( backSlashCnt - 1 ) ; return '\\' ; } } else { UpdateLineColumn ( c ) ; return ( c ) ; } } public final int getColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getLine ( ) { return bufline [ bufpos ] ; } public final int getEndColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getEndLine ( ) { return bufline [ bufpos ] ; } public final int getBeginColumn ( ) { return bufcolumn [ tokenBegin ] ; } public final int getBeginLine ( ) { return bufline [ tokenBegin ] ; } public final void backup ( int amount ) { inBuf += amount ; if ( ( bufpos -= amount ) < 0 ) bufpos += bufsize ; } public ASCII_UCodeESC_CharStream ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; nextCharBuf = new char [ 4096 ] ; } public ASCII_UCodeESC_CharStream ( java . io . Reader dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; if ( buffer == null || buffersize != buffer . length ) { available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; nextCharBuf = new char [ 4096 ] ; } prevCharIsLF = prevCharIsCR = false ; tokenBegin = inBuf = maxNextCharInd = 0 ; nextCharInd = bufpos = - 1 ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public ASCII_UCodeESC_CharStream ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { this ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , 4096 ) ; } public ASCII_UCodeESC_CharStream ( java . io . InputStream dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { ReInit ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public final String GetImage ( ) { if ( bufpos >= tokenBegin ) return new String ( buffer , tokenBegin , bufpos - tokenBegin + 1 ) ; else return new String ( buffer , tokenBegin , bufsize - tokenBegin ) + new String ( buffer , 0 , bufpos + 1 ) ; } public final char [ ] GetSuffix ( int len ) { char [ ] ret = new char [ len ] ; if ( ( bufpos + 1 ) >= len ) System . arraycopy ( buffer , bufpos - len + 1 , ret , 0 , len ) ; else { System . arraycopy ( buffer , bufsize - ( len - bufpos - 1 ) , ret , 0 , len - bufpos - 1 ) ; System . arraycopy ( buffer , 0 , ret , len - bufpos - 1 , bufpos + 1 ) ; } return ret ; } public void Done ( ) { nextCharBuf = null ; buffer = null ; bufline = null ; bufcolumn = null ; } public void adjustBeginLineColumn ( int newLine , int newCol ) { int start = tokenBegin ; int len ; if ( bufpos >= tokenBegin ) { len = bufpos - tokenBegin + inBuf + 1 ; } else { len = bufsize - tokenBegin + bufpos + 1 + inBuf ; } int i = 0 , j = 0 , k = 0 ; int nextColDiff = 0 , columnDiff = 0 ; while ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { bufline [ j ] = newLine ; nextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; bufcolumn [ j ] = newCol + columnDiff ; columnDiff = nextColDiff ; i ++ ; } if ( i < len ) { bufline [ j ] = newLine ++ ; bufcolumn [ j ] = newCol + columnDiff ; while ( i ++ < len ) { if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; else bufline [ j ] = newLine ; } } line = bufline [ j ] ; column = bufcolumn [ j ] ; } } 	0	['27', '1', '0', '3', '40', '25', '3', '0', '21', '0.529411765', '1277', '0.705882353', '0', '0', '0.296296296', '0', '0', '45.66666667', '7', '1.5926', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . * ; public class BufferSwitcher extends JComboBox { public BufferSwitcher ( EditPane editPane ) { this . editPane = editPane ; setRenderer ( new BufferCellRenderer ( ) ) ; setMaximumRowCount ( 10 ) ; addActionListener ( new ActionHandler ( ) ) ; } public void updateBufferList ( ) { if ( jEdit . getBufferCount ( ) == 0 ) return ; updating = true ; setModel ( new DefaultComboBoxModel ( jEdit . getBuffers ( ) ) ) ; setSelectedItem ( editPane . getBuffer ( ) ) ; updating = false ; } private EditPane editPane ; private boolean updating ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( ! updating ) { Buffer buffer = ( Buffer ) getSelectedItem ( ) ; if ( buffer != null ) editPane . setBuffer ( buffer ) ; } } } class BufferCellRenderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; Buffer buffer = ( Buffer ) value ; if ( buffer == null ) setIcon ( null ) ; else setIcon ( buffer . getIcon ( ) ) ; return this ; } } } 	0	['4', '5', '0', '6', '16', '0', '4', '5', '2', '0.5', '62', '1', '1', '0.995856354', '0.416666667', '0', '0', '14', '2', '1', '0']
package gnu . regexp ; final class RETokenEnd extends REToken { private String newline ; RETokenEnd ( int subIndex , String newline ) { super ( subIndex ) ; this . newline = newline ; } boolean match ( CharIndexed input , REMatch mymatch ) { char ch = input . charAt ( mymatch . index ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return ( ( mymatch . eflags & RE . REG_NOTEOL ) > 0 ) ? false : next ( input , mymatch ) ; if ( newline != null ) { char z ; int i = 0 ; do { z = newline . charAt ( i ) ; if ( ch != z ) return false ; ++ i ; ch = input . charAt ( mymatch . index + i ) ; } while ( i < newline . length ( ) ) ; return next ( input , mymatch ) ; } return false ; } void dump ( StringBuffer os ) { os . append ( '$' ) ; } } 	0	['3', '2', '0', '4', '9', '1', '1', '3', '0', '0.5', '71', '1', '0', '0.777777778', '0.444444444', '1', '2', '22.33333333', '6', '2.3333', '0']
package bsh ; import java . lang . reflect . Field ; import java . util . Hashtable ; class LHS implements ParserConstants , java . io . Serializable { NameSpace nameSpace ; static final int VARIABLE = 0 , FIELD = 1 , PROPERTY = 2 , INDEX = 3 ; int type ; String varName ; String propName ; Field field ; Object object ; int index ; LHS ( NameSpace nameSpace , String varName ) { type = VARIABLE ; this . varName = varName ; this . nameSpace = nameSpace ; } LHS ( Field field ) { type = FIELD ; this . object = null ; this . field = field ; } LHS ( Object object , Field field ) { if ( object == null ) throw new NullPointerException ( "constructed empty LHS" ) ; type = FIELD ; this . object = object ; this . field = field ; } LHS ( Object object , String propName ) { if ( object == null ) throw new NullPointerException ( "constructed empty LHS" ) ; type = PROPERTY ; this . object = object ; this . propName = propName ; } LHS ( Object array , int index ) { if ( array == null ) throw new NullPointerException ( "constructed empty LHS" ) ; type = INDEX ; this . object = array ; this . index = index ; } public Object getValue ( ) throws EvalError { if ( type == VARIABLE ) return nameSpace . getVariable ( varName ) ; else if ( type == FIELD ) try { return field . get ( object ) ; } catch ( IllegalAccessException e2 ) { throw new EvalError ( "Can't read field: " + field ) ; } else if ( type == PROPERTY ) try { return Reflect . getObjectProperty ( object , propName ) ; } catch ( ReflectError e ) { Interpreter . debug ( e . getMessage ( ) ) ; throw new EvalError ( "No such property: " + propName ) ; } else if ( type == INDEX ) try { return Reflect . getIndex ( object , index ) ; } catch ( Exception e ) { throw new EvalError ( "Array access: " + e ) ; } throw new InterpreterError ( "LHS type" ) ; } public Object assign ( Object val ) throws EvalError { if ( type == VARIABLE ) nameSpace . setVariable ( varName , val ) ; else if ( type == FIELD ) try { if ( val instanceof Primitive ) val = ( ( Primitive ) val ) . getValue ( ) ; field . set ( object , val ) ; return val ; } catch ( NullPointerException e ) { throw new EvalError ( "LHS (" + field . getName ( ) + ") not a static field." ) ; } catch ( IllegalAccessException e2 ) { throw new EvalError ( "LHS (" + field . getName ( ) + ") can't access field." ) ; } catch ( IllegalArgumentException e3 ) { throw new EvalError ( "Argument type mismatch. " + ( val == null ? "null" : val . getClass ( ) . getName ( ) ) + " not assignable to field " + field . getName ( ) ) ; } else if ( type == PROPERTY ) if ( object instanceof Hashtable ) ( ( Hashtable ) object ) . put ( propName , val ) ; else try { Reflect . setObjectProperty ( object , propName , val ) ; } catch ( ReflectError e ) { Interpreter . debug ( "Assignment: " + e . getMessage ( ) ) ; throw new EvalError ( "No such property: " + propName ) ; } else if ( type == INDEX ) try { Reflect . setIndex ( object , index , val ) ; } catch ( TargetError e1 ) { throw e1 ; } catch ( Exception e ) { throw new EvalError ( "Assignment: " + e . getMessage ( ) ) ; } return val ; } public String toString ( ) { return "LHS" ; } } 	0	['8', '1', '0', '15', '31', '0', '8', '9', '3', '0.766233766', '356', '0', '1', '0', '0.375', '0', '0', '42.125', '1', '0.375', '0']
package gnu . regexp ; final class RETokenEndSub extends REToken { RETokenEndSub ( int subIndex ) { super ( subIndex ) ; } boolean match ( CharIndexed input , REMatch mymatch ) { mymatch . end [ subIndex ] = mymatch . index ; return next ( input , mymatch ) ; } void dump ( StringBuffer os ) { } } 	0	['3', '2', '0', '4', '5', '3', '1', '3', '0', '2', '20', '0', '0', '0.777777778', '0.466666667', '1', '2', '5.666666667', '1', '0.6667', '0']
package gnu . regexp ; final class RETokenRange extends REToken { private char lo , hi ; private boolean insens ; RETokenRange ( int subIndex , char lo , char hi , boolean ins ) { super ( subIndex ) ; this . lo = ( insens = ins ) ? Character . toLowerCase ( lo ) : lo ; this . hi = ins ? Character . toLowerCase ( hi ) : hi ; } int getMinimumLength ( ) { return 1 ; } boolean match ( CharIndexed input , REMatch mymatch ) { char c = input . charAt ( mymatch . index ) ; if ( c == CharIndexed . OUT_OF_BOUNDS ) return false ; if ( insens ) c = Character . toLowerCase ( c ) ; if ( ( c >= lo ) && ( c <= hi ) ) { ++ mymatch . index ; return next ( input , mymatch ) ; } return false ; } void dump ( StringBuffer os ) { os . append ( lo ) . append ( '-' ) . append ( hi ) ; } } 	0	['4', '2', '0', '4', '9', '0', '1', '3', '0', '0.444444444', '80', '1', '0', '0.7', '0.357142857', '1', '2', '18.25', '5', '1.75', '0']
package bsh . commands ; import java . io . * ; import bsh . * ; import java . util . Date ; import java . util . Vector ; import java . util . GregorianCalendar ; import java . util . Calendar ; public class dir { static final String [ ] months = { "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" , "Jul" , "Aug" , "Sep" , "Oct" , "Nov" , "Dec" } ; public static String usage ( ) { return "usage: dir( String dir )\n       dir()" ; } public static void invoke ( Interpreter env , NameSpace namespace ) { String dir = "." ; invoke ( env , namespace , dir ) ; } public static void invoke ( Interpreter env , NameSpace namespace , String dir ) { File file ; try { file = env . pathToFile ( dir ) ; } catch ( IOException e ) { env . println ( "error reading path: " + e ) ; return ; } if ( ! file . exists ( ) || ! file . canRead ( ) ) { env . println ( "Can't read " + file ) ; return ; } if ( ! file . isDirectory ( ) ) { env . println ( "'" + dir + "' is not a directory" ) ; } String [ ] files = file . list ( ) ; files = bubbleSort ( files ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( dir + File . separator + files [ i ] ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( f . canRead ( ) ? "r" : "-" ) ; sb . append ( f . canWrite ( ) ? "w" : "-" ) ; sb . append ( "_" ) ; sb . append ( " " ) ; Date d = new Date ( f . lastModified ( ) ) ; GregorianCalendar c = new GregorianCalendar ( ) ; c . setTime ( d ) ; int day = c . get ( Calendar . DAY_OF_MONTH ) ; sb . append ( months [ c . get ( Calendar . MONTH ) ] + " " + day ) ; if ( day < 10 ) sb . append ( " " ) ; sb . append ( " " ) ; int fieldlen = 8 ; StringBuffer len = new StringBuffer ( ) ; for ( int j = 0 ; j < fieldlen ; j ++ ) len . append ( " " ) ; len . insert ( 0 , f . length ( ) ) ; len . setLength ( fieldlen ) ; int si = len . toString ( ) . indexOf ( " " ) ; if ( si != - 1 ) { String pad = len . toString ( ) . substring ( si ) ; len . setLength ( si ) ; len . insert ( 0 , pad ) ; } sb . append ( len ) ; sb . append ( " " + f . getName ( ) ) ; if ( f . isDirectory ( ) ) sb . append ( "/" ) ; env . println ( sb . toString ( ) ) ; } } public static String [ ] bubbleSort ( String [ ] in ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < in . length ; i ++ ) v . addElement ( in [ i ] ) ; int n = v . size ( ) ; boolean swap = true ; while ( swap ) { swap = false ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) if ( ( ( String ) v . elementAt ( i ) ) . compareTo ( ( ( String ) v . elementAt ( i + 1 ) ) ) > 0 ) { String tmp = ( String ) v . elementAt ( i + 1 ) ; v . removeElementAt ( i + 1 ) ; v . insertElementAt ( tmp , i ) ; swap = true ; } } String [ ] out = new String [ n ] ; v . copyInto ( out ) ; return out ; } } 	0	['6', '1', '0', '2', '40', '13', '0', '2', '5', '0.6', '374', '0', '0', '0', '0.28', '0', '0', '61.16666667', '11', '3', '0']
package gnu . regexp ; import java . text . MessageFormat ; public class REException extends Exception { private int type ; private int pos ; public static final int REG_BADRPT = 1 ; public static final int REG_BADBR = 2 ; public static final int REG_EBRACE = 3 ; public static final int REG_EBRACK = 4 ; public static final int REG_ERANGE = 5 ; public static final int REG_ECTYPE = 6 ; public static final int REG_EPAREN = 7 ; public static final int REG_ESUBREG = 8 ; public static final int REG_EEND = 9 ; public static final int REG_ESCAPE = 10 ; public static final int REG_BADPAT = 11 ; public static final int REG_ESIZE = 12 ; public static final int REG_ESPACE = 13 ; REException ( String msg , int type , int position ) { super ( msg ) ; this . type = type ; this . pos = position ; } public int getType ( ) { return type ; } public int getPosition ( ) { return pos ; } public String getMessage ( ) { Object [ ] args = { new Integer ( pos ) } ; StringBuffer sb = new StringBuffer ( ) ; String prefix = RE . getLocalizedMessage ( "error.prefix" ) ; sb . append ( MessageFormat . format ( prefix , args ) ) ; sb . append ( '\n' ) ; sb . append ( super . getMessage ( ) ) ; return sb . toString ( ) ; } } 	0	['4', '3', '0', '4', '13', '0', '4', '1', '3', '1.222222222', '71', '0.133333333', '0', '0.85', '0.5', '1', '1', '13', '1', '0.75', '0']
package bsh ; class BSHLHSPrimaryExpression extends SimpleNode { BSHLHSPrimaryExpression ( int id ) { super ( id ) ; } public LHS toLHS ( CallStack callstack , Interpreter interpreter ) throws EvalError { int childNum = 0 ; SimpleNode prefixNode = ( SimpleNode ) jjtGetChild ( childNum ++ ) ; Object prefixValue = null ; LHS lhs = null ; if ( prefixNode instanceof BSHAmbiguousName ) { lhs = ( ( BSHAmbiguousName ) prefixNode ) . toLHS ( callstack , interpreter ) ; } else prefixValue = ( ( SimpleNode ) prefixNode ) . eval ( callstack , interpreter ) ; if ( prefixValue != null ) lhs = ( ( BSHLHSPrimarySuffix ) jjtGetChild ( childNum ++ ) ) . doLHSSuffix ( prefixValue , callstack , interpreter ) ; int numChildren = jjtGetNumChildren ( ) ; while ( childNum < numChildren ) lhs = ( ( BSHLHSPrimarySuffix ) jjtGetChild ( childNum ++ ) ) . doLHSSuffix ( lhs . getValue ( ) , callstack , interpreter ) ; return lhs ; } } 	0	['2', '2', '0', '11', '9', '1', '3', '8', '1', '2', '65', '0', '0', '0.947368421', '0.625', '0', '0', '31.5', '1', '0.5', '0']
package bsh ; import java . net . * ; import java . util . * ; import java . io . IOException ; import java . io . * ; public abstract class BshClassManager { private static BshClassManager manager ; private static boolean checkedForManager ; private static Object NOVALUE = new Object ( ) ; private static ClassLoader externalClassLoader ; protected transient static Hashtable absoluteClassCache = new Hashtable ( ) ; protected transient static Hashtable absoluteNonClasses = new Hashtable ( ) ; public static BshClassManager getClassManager ( ) { if ( ! checkedForManager && manager == null ) try { if ( plainClassForName ( "java.lang.ref.WeakReference" ) != null && plainClassForName ( "java.util.HashMap" ) != null ) { Class bcm = plainClassForName ( "bsh.classpath.ClassManagerImpl" ) ; manager = ( BshClassManager ) bcm . newInstance ( ) ; } } catch ( ClassNotFoundException e ) { } catch ( Exception e ) { System . err . println ( "Error loading classmanager: " + e ) ; } checkedForManager = true ; return manager ; } public static boolean classExists ( String name ) { return ( classForName ( name ) != null ) ; } public static Class classForName ( String name ) { BshClassManager manager = getClassManager ( ) ; if ( manager != null ) return manager . getClassForName ( name ) ; else try { return plainClassForName ( name ) ; } catch ( ClassNotFoundException e ) { return null ; } } public static Class plainClassForName ( String name ) throws ClassNotFoundException { try { Class c ; if ( externalClassLoader != null ) { c = externalClassLoader . loadClass ( name ) ; } else c = Class . forName ( name ) ; cacheClassInfo ( name , c ) ; return c ; } catch ( NoClassDefFoundError e ) { cacheClassInfo ( name , null ) ; throw new ClassNotFoundException ( e . toString ( ) ) ; } } public static void cacheClassInfo ( String name , Class value ) { if ( value != null ) absoluteClassCache . put ( name , value ) ; else absoluteNonClasses . put ( name , NOVALUE ) ; } protected void clearCaches ( ) { absoluteNonClasses = new Hashtable ( ) ; absoluteClassCache = new Hashtable ( ) ; } public static void addCMListener ( Listener l ) { getClassManager ( ) ; if ( manager != null ) manager . addListener ( l ) ; } public static void setClassLoader ( ClassLoader externalCL ) { externalClassLoader = externalCL ; } public static interface Listener { public void classLoaderChanged ( ) ; } public abstract Class getClassForName ( String name ) ; public abstract ClassLoader getBaseLoader ( ) ; public abstract ClassLoader getLoaderForClass ( String name ) ; public abstract void addClassPath ( URL path ) throws IOException ; public abstract void reset ( ) ; public abstract void setClassPath ( URL [ ] cp ) ; public abstract void reloadAllClasses ( ) throws ClassPathException ; public abstract void reloadClasses ( String [ ] classNames ) throws ClassPathException ; public abstract void reloadPackage ( String pack ) throws ClassPathException ; public abstract void doSuperImport ( ) throws EvalError ; public abstract String getClassNameByUnqName ( String name ) throws ClassPathException ; public abstract void addListener ( Listener l ) ; public abstract void removeListener ( Listener l ) ; public abstract void dump ( PrintWriter pw ) ; protected abstract void classLoaderChanged ( ) ; } 	0	['25', '1', '0', '10', '37', '290', '7', '3', '22', '0.888888889', '161', '1', '1', '0', '0.157407407', '0', '0', '5.2', '3', '1.16', '0']
package bsh ; import java . lang . reflect . Array ; import java . util . Hashtable ; import java . io . * ; import java . lang . reflect . InvocationTargetException ; class Name implements java . io . Serializable { public NameSpace namespace ; String value = null ; private String evalName ; private Object evalBaseObject ; private int callstackDepth ; private boolean literalThisReference ; private boolean literalCallerReference ; private void reset ( ) { evalName = value ; evalBaseObject = null ; callstackDepth = 0 ; literalThisReference = false ; literalCallerReference = false ; } public Name ( NameSpace namespace , String s ) { this . namespace = namespace ; value = s ; } public Object toObject ( CallStack callstack , Interpreter interpreter ) throws EvalError { return toObject ( callstack , interpreter , false ) ; } synchronized public Object toObject ( CallStack callstack , Interpreter interpreter , boolean forceClass ) throws EvalError { reset ( ) ; Object obj = null ; while ( evalName != null ) obj = consumeNextObjectField ( callstack , interpreter , forceClass ) ; if ( obj == null ) throw new InterpreterError ( "null value in toObject()" ) ; return obj ; } private Object consumeNextObjectField ( CallStack callstack , Interpreter interpreter , boolean forceClass ) throws EvalError { if ( ( evalBaseObject == null && ! isCompound ( evalName ) ) && ! forceClass ) { Object obj = resolveThisFieldReference ( callstack , namespace , interpreter , evalName , false ) ; if ( obj != Primitive . VOID ) { evalName = null ; return evalBaseObject = obj ; } } if ( ( evalBaseObject == null || evalBaseObject instanceof This ) && ! forceClass ) { String varName = prefix ( evalName , 1 ) ; Interpreter . debug ( "trying to resolve variable: " + varName ) ; Object obj ; if ( evalBaseObject == null ) { obj = resolveThisFieldReference ( callstack , namespace , interpreter , varName , false ) ; } else { obj = resolveThisFieldReference ( callstack , ( ( This ) evalBaseObject ) . namespace , interpreter , varName , true ) ; } if ( obj != Primitive . VOID ) { Interpreter . debug ( "resolved variable: " + varName + " in namespace: " + namespace ) ; evalName = suffix ( evalName ) ; return evalBaseObject = obj ; } } if ( evalBaseObject == null ) { Interpreter . debug ( "trying class: " + evalName ) ; Class clas = null ; int i = 1 ; for ( ; i <= countParts ( evalName ) ; i ++ ) if ( ( clas = namespace . getClass ( prefix ( evalName , i ) ) ) != null ) break ; if ( clas != null ) { evalName = suffix ( evalName , countParts ( evalName ) - i ) ; return ( evalBaseObject = new ClassIdentifier ( clas ) ) ; } Interpreter . debug ( "not a class, trying var prefix " + evalName ) ; } if ( evalBaseObject == null ) { if ( ! isCompound ( evalName ) ) { evalName = null ; return evalBaseObject = Primitive . VOID ; } else throw new EvalError ( "Class or variable not found:" + evalName ) ; } if ( evalBaseObject == Primitive . NULL ) throw new TargetError ( "Null Pointer while evaluating: " + value , new NullPointerException ( ) ) ; if ( evalBaseObject == Primitive . VOID ) throw new EvalError ( "Undefined variable or class name while evaluating: " + value ) ; if ( evalBaseObject instanceof Primitive ) throw new EvalError ( "Can't treat primitive like an object. " + "Error while evaluating: " + value ) ; if ( evalBaseObject instanceof ClassIdentifier ) { Class clas = ( ( ClassIdentifier ) evalBaseObject ) . getTargetClass ( ) ; String field = prefix ( evalName , 1 ) ; Object obj = null ; try { obj = Reflect . getStaticField ( clas , field ) ; } catch ( ReflectError e ) { } if ( obj == null ) { String iclass = clas . getName ( ) + "$" + field ; Class c = namespace . getClass ( iclass ) ; if ( c != null ) obj = new ClassIdentifier ( c ) ; } if ( obj == null ) throw new EvalError ( "No static field or inner class: " + field + " of " + clas ) ; evalName = suffix ( evalName ) ; return ( evalBaseObject = obj ) ; } if ( forceClass ) throw new EvalError ( value + " does not resolve to a class name." ) ; String field = prefix ( evalName , 1 ) ; if ( field . equals ( "length" ) && evalBaseObject . getClass ( ) . isArray ( ) ) { Object obj = new Primitive ( Array . getLength ( evalBaseObject ) ) ; evalName = suffix ( evalName ) ; return ( evalBaseObject = obj ) ; } try { Object obj = Reflect . getObjectField ( evalBaseObject , field ) ; evalName = suffix ( evalName ) ; return ( evalBaseObject = obj ) ; } catch ( ReflectError e ) { } throw new EvalError ( "Cannot access field: " + field + ", on object: " + evalBaseObject ) ; } Object resolveThisFieldReference ( CallStack callstack , NameSpace thisNamespace , Interpreter interpreter , String varName , boolean specialFieldsVisible ) throws EvalError { Object obj = null ; boolean wasThis = false , wasCaller = false ; if ( varName . equals ( "this" ) ) { if ( specialFieldsVisible ) throw new EvalError ( "Redundant to call .this on This type" ) ; obj = thisNamespace . getThis ( interpreter ) ; wasThis = true ; } if ( obj == null ) { if ( varName . equals ( "super" ) ) obj = thisNamespace . getSuper ( ) . getThis ( interpreter ) ; else if ( varName . equals ( "global" ) ) obj = thisNamespace . getGlobal ( ) . getThis ( interpreter ) ; } if ( obj == null && specialFieldsVisible ) { if ( varName . equals ( "namespace" ) ) obj = thisNamespace ; else if ( varName . equals ( "variables" ) ) obj = thisNamespace . getVariableNames ( ) ; else if ( varName . equals ( "methods" ) ) obj = thisNamespace . getMethodNames ( ) ; else if ( varName . equals ( "interpreter" ) ) if ( literalThisReference ) obj = interpreter ; else throw new EvalError ( "Can only call .interpreter on literal 'this'" ) ; } if ( obj == null && specialFieldsVisible && varName . equals ( "caller" ) ) { if ( literalThisReference || literalCallerReference ) { if ( callstack == null ) throw new InterpreterError ( "no callstack" ) ; obj = callstack . get ( ++ callstackDepth ) . getThis ( interpreter ) ; } else throw new EvalError ( "Can only call .caller on literal 'this' or literal '.caller'" ) ; wasCaller = true ; } if ( obj == null && specialFieldsVisible && varName . equals ( "callstack" ) ) { if ( literalThisReference ) { if ( callstack == null ) throw new InterpreterError ( "no callstack" ) ; obj = callstack ; } else throw new EvalError ( "Can only call .callstack on literal 'this'" ) ; } if ( obj == null ) obj = thisNamespace . getVariable ( varName ) ; literalThisReference = wasThis ; literalCallerReference = wasCaller ; return obj ; } synchronized public Class toClass ( ) throws EvalError { reset ( ) ; Class clas = namespace . getClass ( evalName ) ; if ( clas == null ) { Object obj = null ; try { obj = toObject ( null , null , true ) ; } catch ( EvalError e ) { } ; if ( obj instanceof ClassIdentifier ) clas = ( ( ClassIdentifier ) obj ) . getTargetClass ( ) ; } if ( clas == null ) throw new EvalError ( "Class: " + value + " not found in namespace" ) ; return clas ; } synchronized public LHS toLHS ( CallStack callstack , Interpreter interpreter ) throws EvalError { reset ( ) ; if ( ! isCompound ( evalName ) ) { return new LHS ( namespace , evalName ) ; } Object obj = null ; try { while ( isCompound ( evalName ) ) obj = consumeNextObjectField ( callstack , interpreter , false ) ; } catch ( EvalError e ) { throw new EvalError ( "LHS evaluation: " + e ) ; } if ( obj == null ) throw new InterpreterError ( "internal error 2893749283" ) ; if ( obj instanceof This ) { Interpreter . debug ( "found This reference evaluating LHS" ) ; return new LHS ( ( ( This ) obj ) . namespace , evalName ) ; } if ( evalName != null ) { try { if ( obj instanceof ClassIdentifier ) { Class clas = ( ( ClassIdentifier ) obj ) . getTargetClass ( ) ; return Reflect . getLHSStaticField ( clas , evalName ) ; } else return Reflect . getLHSObjectField ( obj , evalName ) ; } catch ( ReflectError e ) { throw new EvalError ( "Field access: " + e ) ; } } throw new InterpreterError ( "Internal error in lhs..." ) ; } private BshMethod toLocalMethod ( Object [ ] args ) { Class [ ] sig = Reflect . getTypes ( args ) ; return namespace . getMethod ( value , sig ) ; } public Object invokeMethod ( Interpreter interpreter , Object [ ] args , CallStack callstack , SimpleNode callerInfo ) throws EvalError , ReflectError , InvocationTargetException { if ( ! Name . isCompound ( value ) ) return invokeLocalMethod ( interpreter , args , callstack , callerInfo ) ; Name targetName = namespace . getNameResolver ( Name . prefix ( value ) ) ; String methodName = Name . suffix ( value , 1 ) ; Object obj = targetName . toObject ( callstack , interpreter ) ; if ( obj == Primitive . VOID ) throw new EvalError ( "Attempt to invoke method: " + methodName + "() on undefined variable or class name: " + targetName ) ; if ( ! ( obj instanceof Name . ClassIdentifier ) ) { if ( obj instanceof Primitive ) { if ( obj == Primitive . NULL ) throw new TargetError ( "Null Pointer in Method Invocation" , new NullPointerException ( ) ) ; interpreter . error ( "Attempt to access method on primitive..." + " allowing bsh.Primitive to peek through for debugging" ) ; } return Reflect . invokeObjectMethod ( interpreter , obj , methodName , args , callerInfo ) ; } Interpreter . debug ( "invokeMethod: trying static - " + targetName ) ; Class clas = ( ( Name . ClassIdentifier ) obj ) . getTargetClass ( ) ; if ( clas != null ) return Reflect . invokeStaticMethod ( clas , methodName , args ) ; throw new EvalError ( "unknown target: " + targetName ) ; } public Object invokeLocalMethod ( Interpreter interpreter , Object [ ] args , CallStack callstack , SimpleNode callerInfo ) throws EvalError , ReflectError , InvocationTargetException { Interpreter . debug ( "invoke local method: " + value ) ; BshMethod meth = toLocalMethod ( args ) ; if ( meth != null ) return meth . invokeDeclaredMethod ( args , interpreter , callstack , callerInfo ) ; else Interpreter . debug ( "no locally declared method: " + value ) ; String commandName = "commands/" + value + ".bsh" ; InputStream in = Interpreter . class . getResourceAsStream ( commandName ) ; if ( in != null ) { Interpreter . debug ( "loading resource: " + commandName ) ; if ( interpreter == null ) throw new InterpreterError ( "2234432 interpreter = null" ) ; interpreter . eval ( new InputStreamReader ( in ) , namespace , commandName ) ; meth = toLocalMethod ( args ) ; if ( meth != null ) return meth . invokeDeclaredMethod ( args , interpreter , callstack , callerInfo ) ; else throw new EvalError ( "Loaded resource: " + commandName + "had an error or did not contain the correct method" ) ; } commandName = "bsh.commands." + value ; Class c = BshClassManager . classForName ( commandName ) ; if ( c == null ) throw new EvalError ( "Command not found: " + value ) ; Object [ ] invokeArgs = new Object [ args . length + 2 ] ; invokeArgs [ 0 ] = interpreter ; invokeArgs [ 1 ] = namespace ; System . arraycopy ( args , 0 , invokeArgs , 2 , args . length ) ; try { return Reflect . invokeStaticMethod ( c , "invoke" , invokeArgs ) ; } catch ( ReflectError e ) { Interpreter . debug ( "invoke command args error:" + e ) ; } try { String s = ( String ) Reflect . invokeStaticMethod ( c , "usage" , null ) ; interpreter . println ( s ) ; return Primitive . VOID ; } catch ( ReflectError e ) { Interpreter . debug ( "usage threw: " + e ) ; throw new EvalError ( "Wrong number or type of args for command" ) ; } } static boolean isCompound ( String value ) { return countParts ( value ) > 1 ; } static int countParts ( String value ) { if ( value == null ) return 0 ; int count = 0 ; int index = - 1 ; while ( ( index = value . indexOf ( '.' , index + 1 ) ) != - 1 ) count ++ ; return count + 1 ; } static String prefix ( String value ) { if ( ! isCompound ( value ) ) return null ; return prefix ( value , countParts ( value ) - 1 ) ; } static String prefix ( String value , int parts ) { if ( parts < 1 ) return null ; int count = 0 ; int index = - 1 ; while ( ( ( index = value . indexOf ( '.' , index + 1 ) ) != - 1 ) && ( ++ count < parts ) ) { ; } return ( index == - 1 ) ? value : value . substring ( 0 , index ) ; } static String suffix ( String name ) { if ( ! isCompound ( name ) ) return null ; return suffix ( name , countParts ( name ) - 1 ) ; } public static String suffix ( String value , int parts ) { if ( parts < 1 ) return null ; int count = 0 ; int index = value . length ( ) + 1 ; while ( ( ( index = value . lastIndexOf ( '.' , index - 1 ) ) != - 1 ) && ( ++ count < parts ) ) { ; } return ( index == - 1 ) ? value : value . substring ( index + 1 ) ; } public String toString ( ) { return value ; } static class ClassIdentifier { Class clas ; public ClassIdentifier ( Class clas ) { this . clas = clas ; } public Class getTargetClass ( ) { return clas ; } public String toString ( ) { return "Class Identifier: " + clas . getName ( ) ; } } } 	0	['19', '1', '0', '19', '71', '91', '6', '15', '9', '0.708333333', '1263', '0.625', '1', '0', '0.274853801', '0', '0', '65.05263158', '5', '1.6316', '0']
package gnu . regexp ; import java . io . Serializable ; public final class REMatch implements Serializable , Cloneable { private String matchedText ; int eflags ; int offset ; int anchor ; int [ ] start ; int [ ] end ; int index ; REMatch next ; public Object clone ( ) { try { REMatch copy = ( REMatch ) super . clone ( ) ; copy . next = null ; copy . start = ( int [ ] ) start . clone ( ) ; copy . end = ( int [ ] ) end . clone ( ) ; return copy ; } catch ( CloneNotSupportedException e ) { throw new Error ( ) ; } } void assignFrom ( REMatch other ) { start = other . start ; end = other . end ; index = other . index ; next = other . next ; } REMatch ( int subs , int index , int eflags ) { start = new int [ subs + 1 ] ; end = new int [ subs + 1 ] ; anchor = index ; this . eflags = eflags ; clear ( index ) ; } void finish ( CharIndexed text ) { start [ 0 ] = 0 ; StringBuffer sb = new StringBuffer ( ) ; int i ; for ( i = 0 ; i < end [ 0 ] ; i ++ ) sb . append ( text . charAt ( i ) ) ; matchedText = sb . toString ( ) ; for ( i = 0 ; i < start . length ; i ++ ) { if ( ( start [ i ] == - 1 ) ^ ( end [ i ] == - 1 ) ) { start [ i ] = - 1 ; end [ i ] = - 1 ; } } next = null ; } void clear ( int index ) { offset = index ; this . index = 0 ; for ( int i = 0 ; i < start . length ; i ++ ) { start [ i ] = end [ i ] = - 1 ; } next = null ; } public String toString ( ) { return matchedText ; } public int getStartIndex ( ) { return offset + start [ 0 ] ; } public int getEndIndex ( ) { return offset + end [ 0 ] ; } public String toString ( int sub ) { if ( ( sub >= start . length ) || ( start [ sub ] == - 1 ) ) return "" ; return ( matchedText . substring ( start [ sub ] , end [ sub ] ) ) ; } public int getSubStartIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = start [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getStartIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = start [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getSubEndIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = end [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getEndIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = end [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getSubCount ( ) { return start . length ; } public String substituteInto ( String input ) { StringBuffer output = new StringBuffer ( ) ; int pos ; for ( pos = 0 ; pos < input . length ( ) - 1 ; pos ++ ) { if ( ( input . charAt ( pos ) == '$' ) && ( Character . isDigit ( input . charAt ( pos + 1 ) ) ) ) { int val = Character . digit ( input . charAt ( ++ pos ) , 10 ) ; if ( val < start . length ) { output . append ( toString ( val ) ) ; } } else output . append ( input . charAt ( pos ) ) ; } if ( pos < input . length ( ) ) output . append ( input . charAt ( pos ) ) ; return output . toString ( ) ; } } 	0	['15', '1', '0', '19', '28', '0', '18', '1', '11', '0.669642857', '391', '0.125', '1', '0', '0.333333333', '0', '0', '24.53333333', '6', '2.2667', '0']
package gnu . regexp ; import java . io . FilterReader ; import java . io . Reader ; public class REFilterReader extends FilterReader { private RE expr ; private String replace ; private String buffer ; private int bufpos ; private int offset ; private CharIndexedReader stream ; public REFilterReader ( Reader stream , RE expr , String replace ) { super ( stream ) ; this . stream = new CharIndexedReader ( stream , 0 ) ; this . expr = expr ; this . replace = replace ; } public int read ( ) { if ( ( buffer != null ) && ( bufpos < buffer . length ( ) ) ) { return ( int ) buffer . charAt ( bufpos ++ ) ; } if ( ! stream . isValid ( ) ) return - 1 ; REMatch mymatch = new REMatch ( expr . getNumSubs ( ) , offset , 0 ) ; if ( expr . match ( stream , mymatch ) ) { mymatch . end [ 0 ] = mymatch . index ; mymatch . finish ( stream ) ; stream . move ( mymatch . toString ( ) . length ( ) ) ; offset += mymatch . toString ( ) . length ( ) ; buffer = mymatch . substituteInto ( replace ) ; bufpos = 1 ; if ( buffer . length ( ) > 0 ) { return buffer . charAt ( 0 ) ; } } char ch = stream . charAt ( 0 ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return - 1 ; stream . move ( 1 ) ; offset ++ ; return ch ; } public boolean markSupported ( ) { return false ; } public int read ( char [ ] b , int off , int len ) { int i ; int ok = 0 ; while ( len -- > 0 ) { i = read ( ) ; if ( i == - 1 ) return ( ok == 0 ) ? - 1 : ok ; b [ off ++ ] = ( char ) i ; ok ++ ; } return ok ; } public int read ( char [ ] b ) { return read ( b , 0 , b . length ) ; } } 	0	['5', '3', '0', '4', '18', '8', '0', '4', '5', '0.375', '173', '1', '2', '0.818181818', '0.366666667', '2', '3', '32.4', '7', '2.6', '0']
package bsh ; class ParseException extends Exception { public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( "" ) ; specialConstructor = true ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; } public ParseException ( ) { super ( ) ; specialConstructor = false ; } public ParseException ( String message ) { super ( message ) ; specialConstructor = false ; } protected boolean specialConstructor ; public Token currentToken ; public int [ ] [ ] expectedTokenSequences ; public String [ ] tokenImage ; public String getMessage ( ) { return getMessage ( true ) ; } public String getMessage ( boolean debug ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } String expected = "" ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected += tokenImage [ expectedTokenSequences [ i ] [ j ] ] + " " ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected += "..." ; } expected += eol + "    " ; } String retval = "Encountered \"" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += " " ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += "\" at line " + currentToken . next . beginLine + ", column " + currentToken . next . beginColumn + "." + eol ; if ( debug ) { if ( expectedTokenSequences . length == 1 ) { retval += "Was expecting:" + eol + "    " ; } else { retval += "Was expecting one of:" + eol + "    " ; } retval += expected ; } return retval ; } protected String eol = System . getProperty ( "line.separator" , "\n" ) ; protected String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } } 	0	['6', '3', '0', '3', '19', '3', '2', '1', '5', '0.44', '387', '0.4', '1', '0.85', '0.333333333', '1', '1', '62.66666667', '14', '4.3333', '0']
package bsh ; class Token implements java . io . Serializable { public int kind ; public int beginLine , beginColumn , endLine , endColumn ; public String image ; public Token next ; public Token specialToken ; public final String toString ( ) { return image ; } public static final Token newToken ( int ofKind ) { switch ( ofKind ) { default : return new Token ( ) ; } } } 	0	['3', '1', '0', '5', '4', '3', '5', '0', '2', '1.4375', '23', '0', '2', '0', '0.5', '0', '0', '4', '2', '1', '0']
package bsh ; import java . awt . event . * ; import javax . swing . * ; import javax . swing . event . * ; import java . io . * ; import java . beans . * ; class JThis extends This implements ActionListener , AdjustmentListener , ComponentListener , ContainerListener , FocusListener , ItemListener , KeyListener , MouseListener , MouseMotionListener , TextListener , WindowListener , PropertyChangeListener , AncestorListener , CaretListener , CellEditorListener , ChangeListener , DocumentListener , HyperlinkListener , InternalFrameListener , ListDataListener , ListSelectionListener , MenuDragMouseListener , MenuKeyListener , MenuListener , MouseInputListener , PopupMenuListener , TableColumnModelListener , TableModelListener , TreeExpansionListener , TreeModelListener , TreeSelectionListener , TreeWillExpandListener , UndoableEditListener { JThis ( NameSpace namespace , Interpreter declaringInterp ) { super ( namespace , declaringInterp ) ; } public String toString ( ) { return "'this' reference (JThis) to Bsh object: " + namespace . name ; } void event ( String name , Object event ) { BshMethod method ; method = namespace . getMethod ( "handleEvent" , new Class [ ] { null } ) ; if ( method != null ) try { method . invokeDeclaredMethod ( new Object [ ] { event } , declaringInterpreter , callstack , null ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "local event hander method invocation error:" + e ) ; } method = namespace . getMethod ( name , new Class [ ] { null } ) ; if ( method != null ) try { method . invokeDeclaredMethod ( new Object [ ] { event } , declaringInterpreter , callstack , null ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "local event hander method invocation error:" + e ) ; } } public void ancestorAdded ( AncestorEvent e ) { event ( "ancestorAdded" , e ) ; } public void ancestorRemoved ( AncestorEvent e ) { event ( "ancestorRemoved" , e ) ; } public void ancestorMoved ( AncestorEvent e ) { event ( "ancestorMoved" , e ) ; } public void caretUpdate ( CaretEvent e ) { event ( "caretUpdate" , e ) ; } public void editingStopped ( ChangeEvent e ) { event ( "editingStopped" , e ) ; } public void editingCanceled ( ChangeEvent e ) { event ( "editingCanceled" , e ) ; } public void stateChanged ( ChangeEvent e ) { event ( "stateChanged" , e ) ; } public void insertUpdate ( DocumentEvent e ) { event ( "insertUpdate" , e ) ; } public void removeUpdate ( DocumentEvent e ) { event ( "removeUpdate" , e ) ; } public void changedUpdate ( DocumentEvent e ) { event ( "changedUpdate" , e ) ; } public void hyperlinkUpdate ( HyperlinkEvent e ) { event ( "internalFrameOpened" , e ) ; } public void internalFrameOpened ( InternalFrameEvent e ) { event ( "internalFrameOpened" , e ) ; } public void internalFrameClosing ( InternalFrameEvent e ) { event ( "internalFrameClosing" , e ) ; } public void internalFrameClosed ( InternalFrameEvent e ) { event ( "internalFrameClosed" , e ) ; } public void internalFrameIconified ( InternalFrameEvent e ) { event ( "internalFrameIconified" , e ) ; } public void internalFrameDeiconified ( InternalFrameEvent e ) { event ( "internalFrameDeiconified" , e ) ; } public void internalFrameActivated ( InternalFrameEvent e ) { event ( "internalFrameActivated" , e ) ; } public void internalFrameDeactivated ( InternalFrameEvent e ) { event ( "internalFrameDeactivated" , e ) ; } public void intervalAdded ( ListDataEvent e ) { event ( "intervalAdded" , e ) ; } public void intervalRemoved ( ListDataEvent e ) { event ( "intervalRemoved" , e ) ; } public void contentsChanged ( ListDataEvent e ) { event ( "contentsChanged" , e ) ; } public void valueChanged ( ListSelectionEvent e ) { event ( "valueChanged" , e ) ; } public void menuDragMouseEntered ( MenuDragMouseEvent e ) { event ( "menuDragMouseEntered" , e ) ; } public void menuDragMouseExited ( MenuDragMouseEvent e ) { event ( "menuDragMouseExited" , e ) ; } public void menuDragMouseDragged ( MenuDragMouseEvent e ) { event ( "menuDragMouseDragged" , e ) ; } public void menuDragMouseReleased ( MenuDragMouseEvent e ) { event ( "menuDragMouseReleased" , e ) ; } public void menuKeyTyped ( MenuKeyEvent e ) { event ( "menuKeyTyped" , e ) ; } public void menuKeyPressed ( MenuKeyEvent e ) { event ( "menuKeyPressed" , e ) ; } public void menuKeyReleased ( MenuKeyEvent e ) { event ( "menuKeyReleased" , e ) ; } public void menuSelected ( MenuEvent e ) { event ( "menuSelected" , e ) ; } public void menuDeselected ( MenuEvent e ) { event ( "menuDeselected" , e ) ; } public void menuCanceled ( MenuEvent e ) { event ( "menuCanceled" , e ) ; } public void popupMenuWillBecomeVisible ( PopupMenuEvent e ) { event ( "popupMenuWillBecomeVisible" , e ) ; } public void popupMenuWillBecomeInvisible ( PopupMenuEvent e ) { event ( "popupMenuWillBecomeInvisible" , e ) ; } public void popupMenuCanceled ( PopupMenuEvent e ) { event ( "popupMenuCanceled" , e ) ; } public void columnAdded ( TableColumnModelEvent e ) { event ( "columnAdded" , e ) ; } public void columnRemoved ( TableColumnModelEvent e ) { event ( "columnRemoved" , e ) ; } public void columnMoved ( TableColumnModelEvent e ) { event ( "columnMoved" , e ) ; } public void columnMarginChanged ( ChangeEvent e ) { event ( "columnMarginChanged" , e ) ; } public void columnSelectionChanged ( ListSelectionEvent e ) { event ( "columnSelectionChanged" , e ) ; } public void tableChanged ( TableModelEvent e ) { event ( "tableChanged" , e ) ; } public void treeExpanded ( TreeExpansionEvent e ) { event ( "treeExpanded" , e ) ; } public void treeCollapsed ( TreeExpansionEvent e ) { event ( "treeCollapsed" , e ) ; } public void treeNodesChanged ( TreeModelEvent e ) { event ( "treeNodesChanged" , e ) ; } public void treeNodesInserted ( TreeModelEvent e ) { event ( "treeNodesInserted" , e ) ; } public void treeNodesRemoved ( TreeModelEvent e ) { event ( "treeNodesRemoved" , e ) ; } public void treeStructureChanged ( TreeModelEvent e ) { event ( "treeStructureChanged" , e ) ; } public void valueChanged ( TreeSelectionEvent e ) { event ( "valueChanged" , e ) ; } public void treeWillExpand ( TreeExpansionEvent e ) { event ( "treeWillExpand" , e ) ; } public void treeWillCollapse ( TreeExpansionEvent e ) { event ( "treeWillCollapse" , e ) ; } public void undoableEditHappened ( UndoableEditEvent e ) { event ( "undoableEditHappened" , e ) ; } public void actionPerformed ( ActionEvent e ) { event ( "actionPerformed" , e ) ; } public void adjustmentValueChanged ( AdjustmentEvent e ) { event ( "adjustmentValueChanged" , e ) ; } public void componentResized ( ComponentEvent e ) { event ( "componentResized" , e ) ; } public void componentMoved ( ComponentEvent e ) { event ( "componentMoved" , e ) ; } public void componentShown ( ComponentEvent e ) { event ( "componentShown" , e ) ; } public void componentHidden ( ComponentEvent e ) { event ( "componentHidden" , e ) ; } public void componentAdded ( ContainerEvent e ) { event ( "componentAdded" , e ) ; } public void componentRemoved ( ContainerEvent e ) { event ( "componentRemoved" , e ) ; } public void focusGained ( FocusEvent e ) { event ( "focusGained" , e ) ; } public void focusLost ( FocusEvent e ) { event ( "focusLost" , e ) ; } public void itemStateChanged ( ItemEvent e ) { event ( "itemStateChanged" , e ) ; } public void keyTyped ( KeyEvent e ) { event ( "keyTyped" , e ) ; } public void keyPressed ( KeyEvent e ) { event ( "keyPressed" , e ) ; } public void keyReleased ( KeyEvent e ) { event ( "keyReleased" , e ) ; } public void mouseClicked ( MouseEvent e ) { event ( "mouseClicked" , e ) ; } public void mousePressed ( MouseEvent e ) { event ( "mousePressed" , e ) ; } public void mouseReleased ( MouseEvent e ) { event ( "mouseReleased" , e ) ; } public void mouseEntered ( MouseEvent e ) { event ( "mouseEntered" , e ) ; } public void mouseExited ( MouseEvent e ) { event ( "mouseExited" , e ) ; } public void mouseDragged ( MouseEvent e ) { event ( "mouseDragged" , e ) ; } public void mouseMoved ( MouseEvent e ) { event ( "mouseMoved" , e ) ; } public void textValueChanged ( TextEvent e ) { event ( "textValueChanged" , e ) ; } public void windowOpened ( WindowEvent e ) { event ( "windowOpened" , e ) ; } public void windowClosing ( WindowEvent e ) { event ( "windowClosing" , e ) ; } public void windowClosed ( WindowEvent e ) { event ( "windowClosed" , e ) ; } public void windowIconified ( WindowEvent e ) { event ( "windowIconified" , e ) ; } public void windowDeiconified ( WindowEvent e ) { event ( "windowDeiconified" , e ) ; } public void windowActivated ( WindowEvent e ) { event ( "windowActivated" , e ) ; } public void windowDeactivated ( WindowEvent e ) { event ( "windowDeactivated" , e ) ; } public void propertyChange ( PropertyChangeEvent e ) { event ( "propertyChange" , e ) ; } public void vetoableChange ( PropertyChangeEvent e ) { event ( "vetoableChange" , e ) ; } public boolean imageUpdate ( java . awt . Image img , int infoflags , int x , int y , int width , int height ) { BshMethod method = namespace . getMethod ( "imageUpdate" , new Class [ ] { null , null , null , null , null , null } ) ; if ( method != null ) try { method . invokeDeclaredMethod ( new Object [ ] { img , new Primitive ( infoflags ) , new Primitive ( x ) , new Primitive ( y ) , new Primitive ( width ) , new Primitive ( height ) } , declaringInterpreter , callstack , null ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "local event handler imageUpdate: method invocation error:" + e ) ; } return true ; } private synchronized void writeObject ( java . io . ObjectOutputStream s ) throws IOException { NameSpace parent = namespace . getParent ( ) ; Interpreter interpreter = declaringInterpreter ; namespace . prune ( ) ; s . defaultWriteObject ( ) ; namespace . setParent ( parent ) ; declaringInterpreter = interpreter ; } } 	0	['87', '2', '0', '8', '100', '3741', '0', '8', '84', '2', '711', '0', '0', '0.104166667', '0.054675365', '1', '2', '7.172413793', '3', '1.023', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBMessage ; import org . gjt . sp . jedit . View ; public class EditorExitRequested extends EBMessage . NonVetoable { public EditorExitRequested ( View view ) { super ( view ) ; } public View getView ( ) { return ( View ) getSource ( ) ; } } 	0	['2', '3', '0', '5', '4', '1', '1', '4', '2', '2', '10', '0', '0', '0.857142857', '0.75', '0', '0', '4', '1', '0.5', '0']
package bsh ; class BSHArguments extends SimpleNode { BSHArguments ( int id ) { super ( id ) ; } public Object [ ] getArguments ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object [ ] args = new Object [ jjtGetNumChildren ( ) ] ; for ( int i = 0 ; i < args . length ; i ++ ) args [ i ] = ( ( SimpleNode ) jjtGetChild ( i ) ) . eval ( callstack , interpreter ) ; return args ; } } 	0	['2', '2', '0', '10', '6', '1', '5', '5', '1', '2', '30', '0', '0', '0.947368421', '0.625', '0', '0', '14', '1', '0.5', '0']
package org . gjt . sp . jedit . textarea ; public interface ScrollListener extends java . util . EventListener { void scrolledVertically ( JEditTextArea textArea ) ; void scrolledHorizontally ( JEditTextArea textArea ) ; } 	0	['2', '1', '0', '3', '2', '1', '3', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class AbbrevEditor extends JPanel { public AbbrevEditor ( ) { GridBagLayout layout = new GridBagLayout ( ) ; setLayout ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . anchor = cons . WEST ; cons . fill = cons . BOTH ; cons . weightx = 1.0f ; cons . gridx = 1 ; cons . gridy = 1 ; JLabel label = new JLabel ( jEdit . getProperty ( "abbrev-editor.before" ) ) ; label . setBorder ( new EmptyBorder ( 6 , 0 , 3 , 0 ) ) ; layout . setConstraints ( label , cons ) ; add ( label ) ; cons . gridy ++ ; cons . weighty = 1.0f ; beforeCaret = new JTextArea ( 4 , 40 ) ; JScrollPane scroller = new JScrollPane ( beforeCaret ) ; layout . setConstraints ( scroller , cons ) ; add ( scroller ) ; cons . gridy ++ ; cons . weighty = 0.0f ; label = new JLabel ( jEdit . getProperty ( "abbrev-editor.after" ) ) ; label . setBorder ( new EmptyBorder ( 6 , 0 , 3 , 0 ) ) ; layout . setConstraints ( label , cons ) ; add ( label ) ; cons . gridy ++ ; cons . weighty = 1.0f ; afterCaret = new JTextArea ( 4 , 40 ) ; scroller = new JScrollPane ( afterCaret ) ; layout . setConstraints ( scroller , cons ) ; add ( scroller ) ; } public String getExpansion ( ) { StringBuffer buf = new StringBuffer ( ) ; String beforeCaretText = beforeCaret . getText ( ) ; String afterCaretText = afterCaret . getText ( ) ; for ( int i = 0 ; i < beforeCaretText . length ( ) ; i ++ ) { char ch = beforeCaretText . charAt ( i ) ; switch ( ch ) { case '\n' : buf . append ( "\\n" ) ; break ; case '\t' : buf . append ( "\\t" ) ; break ; case '\\' : buf . append ( "\\\\" ) ; break ; default : buf . append ( ch ) ; break ; } } if ( afterCaretText . length ( ) != 0 ) { buf . append ( "\\|" ) ; for ( int i = 0 ; i < afterCaretText . length ( ) ; i ++ ) { char ch = afterCaretText . charAt ( i ) ; switch ( ch ) { case '\n' : buf . append ( "\\n" ) ; break ; case '\t' : buf . append ( "\\t" ) ; break ; case '\\' : buf . append ( "\\\\" ) ; break ; default : buf . append ( ch ) ; break ; } } } return buf . toString ( ) ; } public void setExpansion ( String expansion ) { if ( expansion == null ) { beforeCaret . setText ( null ) ; afterCaret . setText ( null ) ; return ; } String beforeCaretText = null ; String afterCaretText = null ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < expansion . length ( ) ; i ++ ) { char ch = expansion . charAt ( i ) ; if ( ch == '\\' && i != expansion . length ( ) - 1 ) { ch = expansion . charAt ( ++ i ) ; switch ( ch ) { case 't' : buf . append ( '\t' ) ; break ; case 'n' : buf . append ( '\n' ) ; break ; case '|' : beforeCaretText = buf . toString ( ) ; buf . setLength ( 0 ) ; break ; default : buf . append ( ch ) ; break ; } } else buf . append ( ch ) ; } if ( beforeCaretText == null ) beforeCaretText = buf . toString ( ) ; else afterCaretText = buf . toString ( ) ; beforeCaret . setText ( beforeCaretText ) ; afterCaret . setText ( afterCaretText ) ; } public JTextArea getBeforeCaretTextArea ( ) { return beforeCaret ; } public JTextArea getAfterCaretTextArea ( ) { return afterCaret ; } private JTextArea beforeCaret , afterCaret ; } 	0	['5', '5', '0', '4', '26', '0', '3', '1', '5', '0.25', '339', '1', '0', '0.99391172', '0.6', '0', '0', '66.4', '12', '4.2', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . EditAction ; import org . gjt . sp . jedit . GUIUtilities ; public class EnhancedButton extends JButton { public EnhancedButton ( Icon icon , String toolTip , EditAction action ) { super ( icon ) ; if ( action != null ) { setEnabled ( true ) ; addActionListener ( new EditAction . Wrapper ( action ) ) ; } else setEnabled ( false ) ; setToolTipText ( toolTip ) ; Insets zeroInsets = new Insets ( 0 , 0 , 0 , 0 ) ; setMargin ( zeroInsets ) ; setRequestFocusEnabled ( false ) ; } public boolean isFocusTraversable ( ) { return false ; } public String getActionCommand ( ) { return getModel ( ) . getActionCommand ( ) ; } } 	0	['3', '6', '0', '3', '13', '3', '1', '2', '3', '2', '45', '0', '0', '0.997382199', '0.5', '2', '2', '14', '1', '0.6667', '0']
package bsh ; class ReflectError extends Exception { public ReflectError ( ) { super ( ) ; } public ReflectError ( String s ) { super ( s ) ; } } 	0	['2', '3', '0', '7', '4', '1', '7', '0', '2', '2', '9', '0', '0', '1', '0.75', '0', '0', '3.5', '0', '0', '0']
package bsh ; class BSHImportDeclaration extends SimpleNode { public boolean importPackage ; public boolean superImport ; BSHImportDeclaration ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { if ( superImport ) NameSpace . doSuperImport ( ) ; else { NameSpace namespace = callstack . top ( ) ; String name = ( ( BSHAmbiguousName ) jjtGetChild ( 0 ) ) . getName ( namespace ) . value ; if ( importPackage ) namespace . importPackage ( name ) ; else namespace . importClass ( name ) ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '10', '9', '1', '1', '9', '1', '1', '36', '0', '0', '0.947368421', '0.625', '1', '1', '16', '1', '0.5', '0']
package bsh ; class BSHAssignment extends SimpleNode implements ParserConstants { public int operator ; BSHAssignment ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { BSHLHSPrimaryExpression lhsNode = ( BSHLHSPrimaryExpression ) jjtGetChild ( 0 ) ; if ( lhsNode == null ) throw new InterpreterError ( "Error, null LHSnode" ) ; LHS lhs = lhsNode . toLHS ( callstack , interpreter ) ; if ( lhs == null ) throw new InterpreterError ( "Error, null LHS" ) ; Object rhs = ( ( SimpleNode ) jjtGetChild ( 1 ) ) . eval ( callstack , interpreter ) ; if ( rhs == Primitive . VOID ) throw new EvalError ( "Void assignment." , this ) ; switch ( operator ) { case ASSIGN : try { return lhs . assign ( rhs ) ; } catch ( EvalError e ) { e . reThrow ( this ) ; } case PLUSASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , PLUS ) ) ; case MINUSASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , MINUS ) ) ; case STARASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , STAR ) ) ; case SLASHASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , SLASH ) ) ; case ANDASSIGN : case ANDASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , BIT_AND ) ) ; case ORASSIGN : case ORASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , BIT_OR ) ) ; case XORASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , XOR ) ) ; case MODASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , MOD ) ) ; case LSHIFTASSIGN : case LSHIFTASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , LSHIFT ) ) ; case RSIGNEDSHIFTASSIGN : case RSIGNEDSHIFTASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , RSIGNEDSHIFT ) ) ; case RUNSIGNEDSHIFTASSIGN : case RUNSIGNEDSHIFTASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , RUNSIGNEDSHIFT ) ) ; default : throw new InterpreterError ( "unimplemented operator in assignment BSH" ) ; } } private Object operation ( Object lhs , Object rhs , int kind ) throws EvalError { if ( lhs instanceof String && rhs != Primitive . VOID ) { if ( kind != PLUS ) throw new EvalError ( "Use of non + operator with String LHS" , this ) ; return ( String ) lhs + rhs ; } if ( lhs instanceof Primitive || rhs instanceof Primitive ) if ( lhs == Primitive . VOID || rhs == Primitive . VOID ) throw new EvalError ( "Illegal use of undefined object or 'void' literal" , this ) ; else if ( lhs == Primitive . NULL || rhs == Primitive . NULL ) throw new EvalError ( "Illegal use of null object or 'null' literal" , this ) ; if ( ( lhs instanceof Boolean || lhs instanceof Character || lhs instanceof Number || lhs instanceof Primitive ) && ( rhs instanceof Boolean || rhs instanceof Character || rhs instanceof Number || rhs instanceof Primitive ) ) { return Primitive . binaryOperation ( lhs , rhs , kind ) ; } throw new EvalError ( "Non primitive value in operator: " + lhs . getClass ( ) + " " + tokenImage [ kind ] + " " + rhs . getClass ( ) , this ) ; } } 	0	['3', '2', '0', '11', '18', '3', '1', '10', '1', '1', '273', '0', '0', '0.9', '0.533333333', '1', '1', '89.66666667', '1', '0.6667', '0']
package bsh ; class SimpleNode implements Node { protected Node parent ; protected Node [ ] children ; protected int id ; Token firstToken , lastToken ; String sourceFile ; public SimpleNode ( int i ) { id = i ; } public void jjtOpen ( ) { } public void jjtClose ( ) { } public void jjtSetParent ( Node n ) { parent = n ; } public Node jjtGetParent ( ) { return parent ; } public void jjtAddChild ( Node n , int i ) { if ( children == null ) children = new Node [ i + 1 ] ; else if ( i >= children . length ) { Node c [ ] = new Node [ i + 1 ] ; System . arraycopy ( children , 0 , c , 0 , children . length ) ; children = c ; } children [ i ] = n ; } public Node jjtGetChild ( int i ) { return children [ i ] ; } public SimpleNode getChild ( int i ) { return ( SimpleNode ) jjtGetChild ( i ) ; } public int jjtGetNumChildren ( ) { return ( children == null ) ? 0 : children . length ; } public String toString ( ) { return ParserTreeConstants . jjtNodeName [ id ] ; } public String toString ( String prefix ) { return prefix + toString ( ) ; } public void dump ( String prefix ) { System . out . println ( toString ( prefix ) ) ; if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { SimpleNode n = ( SimpleNode ) children [ i ] ; if ( n != null ) { n . dump ( prefix + " " ) ; } } } } public void prune ( ) { jjtSetParent ( null ) ; } public Object eval ( NameSpace namespace ) throws EvalError { throw new EvalError ( "Unimplemented or inappropriate for " + getClass ( ) . getName ( ) ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { return eval ( callstack . top ( ) ) ; } public void setSourceFile ( String sourceFile ) { this . sourceFile = sourceFile ; } public String getSourceFile ( ) { if ( sourceFile == null ) if ( parent != null ) return ( ( SimpleNode ) parent ) . getSourceFile ( ) ; else return "<unknown file>" ; else return sourceFile ; } public int getLineNumber ( ) { return firstToken . beginLine ; } public String getText ( ) { StringBuffer text = new StringBuffer ( ) ; Token t = firstToken ; while ( t != null ) { text . append ( t . image ) ; if ( ! t . image . equals ( "." ) ) text . append ( " " ) ; if ( t == lastToken || t . image . equals ( "{" ) || t . image . equals ( ";" ) ) break ; t = t . next ; } return text . toString ( ) ; } } 	0	['19', '1', '35', '50', '30', '147', '46', '7', '19', '0.888888889', '240', '0.5', '4', '0', '0.233082707', '0', '0', '11.31578947', '6', '1.6316', '0']
package bsh ; class BSHForStatement extends SimpleNode implements ParserConstants { public boolean hasForInit ; public boolean hasExpression ; public boolean hasForUpdate ; private SimpleNode forInit ; private SimpleNode expression ; private SimpleNode forUpdate ; private SimpleNode statement ; private boolean parsed ; BSHForStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int i = 0 ; if ( hasForInit ) forInit = ( ( SimpleNode ) jjtGetChild ( i ++ ) ) ; if ( hasExpression ) expression = ( ( SimpleNode ) jjtGetChild ( i ++ ) ) ; if ( hasForUpdate ) forUpdate = ( ( SimpleNode ) jjtGetChild ( i ++ ) ) ; if ( i < jjtGetNumChildren ( ) ) statement = ( ( SimpleNode ) jjtGetChild ( i ) ) ; NameSpace enclosingNameSpace = callstack . top ( ) ; BlockNameSpace forNameSpace = new BlockNameSpace ( enclosingNameSpace ) ; callstack . swap ( forNameSpace ) ; if ( hasForInit ) forInit . eval ( callstack , interpreter ) ; Object returnControl = Primitive . VOID ; while ( true ) { if ( hasExpression ) { boolean cond = BSHIfStatement . evaluateCondition ( expression , callstack , interpreter ) ; if ( ! cond ) break ; } boolean breakout = false ; if ( statement != null ) { Object ret = statement . eval ( callstack , interpreter ) ; if ( ret instanceof ReturnControl ) { switch ( ( ( ReturnControl ) ret ) . kind ) { case RETURN : returnControl = ret ; breakout = true ; break ; case CONTINUE : break ; case BREAK : breakout = true ; break ; } } } if ( breakout ) break ; if ( hasForUpdate ) forUpdate . eval ( callstack , interpreter ) ; } callstack . swap ( enclosingNameSpace ) ; return returnControl ; } } 	0	['2', '2', '0', '12', '10', '1', '1', '11', '1', '1.125', '137', '0.625', '4', '0.947368421', '0.625', '1', '1', '63.5', '1', '0.5', '0']
package bsh ; class BSHVariableDeclarator extends SimpleNode { public String name ; BSHVariableDeclarator ( int id ) { super ( id ) ; } public Object eval ( BSHType typeNode , CallStack callstack , Interpreter interpreter ) throws EvalError { Object value = Primitive . VOID ; if ( jjtGetNumChildren ( ) > 0 ) { SimpleNode initializer = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( ( typeNode != null ) && initializer instanceof BSHArrayInitializer ) value = ( ( BSHArrayInitializer ) initializer ) . eval ( typeNode . getBaseType ( ) , typeNode . getArrayDims ( ) , callstack , interpreter ) ; else value = initializer . eval ( callstack , interpreter ) ; } return value ; } } 	0	['2', '2', '0', '10', '9', '1', '2', '8', '1', '2', '40', '0', '0', '0.947368421', '0.6', '1', '2', '18.5', '1', '0.5', '0']
package org . gjt . sp . util ; import java . util . EventListener ; public interface WorkThreadProgressListener extends EventListener { void progressUpdate ( WorkThreadPool threadPool , int threadIndex ) ; } 	0	['1', '1', '0', '5', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . * ; public class BufferUpdate extends EBMessage . NonVetoable { public static final Object CREATED = "CREATED" ; public static final Object LOAD_STARTED = "LOAD_STARTED" ; public static final Object LOADED = "LOADED" ; public static final Object CLOSED = "CLOSED" ; public static final Object DIRTY_CHANGED = "DIRTY_CHANGED" ; public static final Object MARKERS_CHANGED = "MARKERS_CHANGED" ; public static final Object MODE_CHANGED = "MODE_CHANGED" ; public static final Object ENCODING_CHANGED = "ENCODING_CHANGED" ; public static final Object SAVING = "SAVING" ; public BufferUpdate ( Buffer buffer , View view , Object what ) { super ( buffer ) ; this . view = view ; if ( what == null ) throw new NullPointerException ( "What must be non-null" ) ; this . what = what ; } public Object getWhat ( ) { return what ; } public Buffer getBuffer ( ) { return ( Buffer ) getSource ( ) ; } public View getView ( ) { return view ; } public String paramString ( ) { return super . paramString ( ) + ",what=" + what + ",view=" + view ; } private Object what ; private View view ; } 	0	['6', '3', '0', '14', '14', '5', '11', '5', '5', '0.927272727', '81', '0.181818182', '1', '0.6', '0.4', '1', '1', '10.66666667', '1', '0.6667', '0']
package org . gjt . sp . jedit . search ; import org . gjt . sp . jedit . * ; public interface SearchFileSet { Buffer getFirstBuffer ( View view ) ; Buffer getNextBuffer ( View view , Buffer buffer ) ; void matchFound ( Buffer buffer ) ; int getBufferCount ( ) ; String getCode ( ) ; } 	0	['5', '1', '0', '9', '5', '10', '7', '2', '5', '2', '5', '0', '0', '0', '0.6', '0', '0', '0', '1', '1', '0']
package bsh ; import java . io . Reader ; class Parser implements ParserTreeConstants , ParserConstants { protected JJTParserState jjtree = new JJTParserState ( ) ; void jjtreeOpenNodeScope ( Node n ) { ( ( SimpleNode ) n ) . firstToken = getToken ( 1 ) ; } void jjtreeCloseNodeScope ( Node n ) { ( ( SimpleNode ) n ) . lastToken = getToken ( 0 ) ; } void reInitInput ( Reader in ) { ReInit ( in ) ; } void reInitTokenInput ( Reader in ) { jj_input_stream . ReInit ( in , jj_input_stream . getEndLine ( ) , jj_input_stream . getEndColumn ( ) ) ; } final public boolean Line ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 0 : jj_consume_token ( 0 ) ; Interpreter . debug ( "End of File!" ) ; { if ( true ) return true ; } break ; case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : if ( jj_2_1 ( 2147483647 ) ) { Expression ( ) ; jj_consume_token ( SEMICOLON ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : BlockStatement ( ) ; break ; default : jj_la1 [ 0 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } { if ( true ) return false ; } break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } throw new Error ( "Missing return statement in function" ) ; } final public void MethodDeclaration ( ) throws ParseException { BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration ( JJTMETHODDECLARATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { if ( jj_2_2 ( 2147483647 ) ) { ReturnType ( ) ; t = jj_consume_token ( IDENTIFIER ) ; jjtn000 . name = t . image ; FormalParameters ( ) ; Block ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : t = jj_consume_token ( IDENTIFIER ) ; jjtn000 . name = t . image ; FormalParameters ( ) ; Block ( ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void MethodDeclarationLookahead ( ) throws ParseException { if ( jj_2_3 ( 2147483647 ) ) { ReturnType ( ) ; jj_consume_token ( IDENTIFIER ) ; FormalParameters ( ) ; jj_consume_token ( LBRACE ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; FormalParameters ( ) ; jj_consume_token ( LBRACE ) ; break ; default : jj_la1 [ 3 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void MethodDeclarationTypeLookahead ( ) throws ParseException { ReturnType ( ) ; jj_consume_token ( IDENTIFIER ) ; jj_consume_token ( LPAREN ) ; } final public void ImportDeclaration ( ) throws ParseException { BSHImportDeclaration jjtn000 = new BSHImportDeclaration ( JJTIMPORTDECLARATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { if ( jj_2_4 ( 2 ) ) { jj_consume_token ( IMPORT ) ; AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case DOT : t = jj_consume_token ( DOT ) ; jj_consume_token ( STAR ) ; break ; default : jj_la1 [ 4 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; if ( t != null ) jjtn000 . importPackage = true ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IMPORT : jj_consume_token ( IMPORT ) ; jj_consume_token ( STAR ) ; jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . superImport = true ; break ; default : jj_la1 [ 5 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void VariableDeclarator ( ) throws ParseException { BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator ( JJTVARIABLEDECLARATOR ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; try { t = jj_consume_token ( IDENTIFIER ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ASSIGN : jj_consume_token ( ASSIGN ) ; VariableInitializer ( ) ; break ; default : jj_la1 [ 6 ] = jj_gen ; ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . name = t . image ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void VariableInitializer ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : ArrayInitializer ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : Expression ( ) ; break ; default : jj_la1 [ 7 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } final public void ArrayInitializer ( ) throws ParseException { BSHArrayInitializer jjtn000 = new BSHArrayInitializer ( JJTARRAYINITIALIZER ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : VariableInitializer ( ) ; label_1 : while ( true ) { if ( jj_2_5 ( 2 ) ) { ; } else { break label_1 ; } jj_consume_token ( COMMA ) ; VariableInitializer ( ) ; } break ; default : jj_la1 [ 8 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : jj_consume_token ( COMMA ) ; break ; default : jj_la1 [ 9 ] = jj_gen ; ; } jj_consume_token ( RBRACE ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void FormalParameters ( ) throws ParseException { BSHFormalParameters jjtn000 = new BSHFormalParameters ( JJTFORMALPARAMETERS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : case IDENTIFIER : FormalParameter ( ) ; label_2 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 10 ] = jj_gen ; break label_2 ; } jj_consume_token ( COMMA ) ; FormalParameter ( ) ; } break ; default : jj_la1 [ 11 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void FormalParameter ( ) throws ParseException { BSHFormalParameter jjtn000 = new BSHFormalParameter ( JJTFORMALPARAMETER ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; try { if ( jj_2_6 ( 2 ) ) { Type ( ) ; t = jj_consume_token ( IDENTIFIER ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . name = t . image ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : t = jj_consume_token ( IDENTIFIER ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . name = t . image ; break ; default : jj_la1 [ 12 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Type ( ) throws ParseException { BSHType jjtn000 = new BSHType ( JJTTYPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : PrimitiveType ( ) ; break ; case IDENTIFIER : AmbiguousName ( ) ; break ; default : jj_la1 [ 13 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } label_3 : while ( true ) { if ( jj_2_7 ( 2 ) ) { ; } else { break label_3 ; } jj_consume_token ( LBRACKET ) ; jj_consume_token ( RBRACKET ) ; jjtn000 . addArrayDimension ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ReturnType ( ) throws ParseException { BSHReturnType jjtn000 = new BSHReturnType ( JJTRETURNTYPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case VOID : jj_consume_token ( VOID ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isVoid = true ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : case IDENTIFIER : Type ( ) ; break ; default : jj_la1 [ 14 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void PrimitiveType ( ) throws ParseException { BSHPrimitiveType jjtn000 = new BSHPrimitiveType ( JJTPRIMITIVETYPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : jj_consume_token ( BOOLEAN ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Boolean . TYPE ; break ; case CHAR : jj_consume_token ( CHAR ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Character . TYPE ; break ; case BYTE : jj_consume_token ( BYTE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Byte . TYPE ; break ; case SHORT : jj_consume_token ( SHORT ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Short . TYPE ; break ; case INT : jj_consume_token ( INT ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Integer . TYPE ; break ; case LONG : jj_consume_token ( LONG ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Long . TYPE ; break ; case FLOAT : jj_consume_token ( FLOAT ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Float . TYPE ; break ; case DOUBLE : jj_consume_token ( DOUBLE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Double . TYPE ; break ; default : jj_la1 [ 15 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void AmbiguousName ( ) throws ParseException { BSHAmbiguousName jjtn000 = new BSHAmbiguousName ( JJTAMBIGUOUSNAME ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; StringBuffer s ; try { t = jj_consume_token ( IDENTIFIER ) ; s = new StringBuffer ( t . image ) ; label_4 : while ( true ) { if ( jj_2_8 ( 2 ) ) { ; } else { break label_4 ; } jj_consume_token ( DOT ) ; t = jj_consume_token ( IDENTIFIER ) ; s . append ( "." + t . image ) ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . text = s . toString ( ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Expression ( ) throws ParseException { if ( jj_2_9 ( 2147483647 ) ) { Assignment ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : ConditionalExpression ( ) ; break ; default : jj_la1 [ 16 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void Assignment ( ) throws ParseException { BSHAssignment jjtn000 = new BSHAssignment ( JJTASSIGNMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; int op ; try { LHSPrimaryExpression ( ) ; op = AssignmentOperator ( ) ; jjtn000 . operator = op ; Expression ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public int AssignmentOperator ( ) throws ParseException { Token t ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ASSIGN : jj_consume_token ( ASSIGN ) ; break ; case STARASSIGN : jj_consume_token ( STARASSIGN ) ; break ; case SLASHASSIGN : jj_consume_token ( SLASHASSIGN ) ; break ; case MODASSIGN : jj_consume_token ( MODASSIGN ) ; break ; case PLUSASSIGN : jj_consume_token ( PLUSASSIGN ) ; break ; case MINUSASSIGN : jj_consume_token ( MINUSASSIGN ) ; break ; case ANDASSIGN : jj_consume_token ( ANDASSIGN ) ; break ; case XORASSIGN : jj_consume_token ( XORASSIGN ) ; break ; case ORASSIGN : jj_consume_token ( ORASSIGN ) ; break ; case LSHIFTASSIGN : jj_consume_token ( LSHIFTASSIGN ) ; break ; case LSHIFTASSIGNX : jj_consume_token ( LSHIFTASSIGNX ) ; break ; case RSIGNEDSHIFTASSIGN : jj_consume_token ( RSIGNEDSHIFTASSIGN ) ; break ; case RSIGNEDSHIFTASSIGNX : jj_consume_token ( RSIGNEDSHIFTASSIGNX ) ; break ; case RUNSIGNEDSHIFTASSIGN : jj_consume_token ( RUNSIGNEDSHIFTASSIGN ) ; break ; case RUNSIGNEDSHIFTASSIGNX : jj_consume_token ( RUNSIGNEDSHIFTASSIGNX ) ; break ; default : jj_la1 [ 17 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } t = getToken ( 0 ) ; { if ( true ) return t . kind ; } throw new Error ( "Missing return statement in function" ) ; } final public void ConditionalExpression ( ) throws ParseException { ConditionalOrExpression ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case HOOK : jj_consume_token ( HOOK ) ; Expression ( ) ; jj_consume_token ( COLON ) ; BSHTernaryExpression jjtn001 = new BSHTernaryExpression ( JJTTERNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { ConditionalExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 3 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 18 ] = jj_gen ; ; } } final public void ConditionalOrExpression ( ) throws ParseException { Token t = null ; ConditionalAndExpression ( ) ; label_5 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_OR : case BOOL_ORX : ; break ; default : jj_la1 [ 19 ] = jj_gen ; break label_5 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_OR : t = jj_consume_token ( BOOL_OR ) ; break ; case BOOL_ORX : t = jj_consume_token ( BOOL_ORX ) ; break ; default : jj_la1 [ 20 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } ConditionalAndExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void ConditionalAndExpression ( ) throws ParseException { Token t = null ; InclusiveOrExpression ( ) ; label_6 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_AND : case BOOL_ANDX : ; break ; default : jj_la1 [ 21 ] = jj_gen ; break label_6 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_AND : t = jj_consume_token ( BOOL_AND ) ; break ; case BOOL_ANDX : t = jj_consume_token ( BOOL_ANDX ) ; break ; default : jj_la1 [ 22 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } InclusiveOrExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void InclusiveOrExpression ( ) throws ParseException { Token t = null ; ExclusiveOrExpression ( ) ; label_7 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_OR : case BIT_ORX : ; break ; default : jj_la1 [ 23 ] = jj_gen ; break label_7 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_OR : t = jj_consume_token ( BIT_OR ) ; break ; case BIT_ORX : t = jj_consume_token ( BIT_ORX ) ; break ; default : jj_la1 [ 24 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } ExclusiveOrExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void ExclusiveOrExpression ( ) throws ParseException { Token t = null ; AndExpression ( ) ; label_8 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case XOR : ; break ; default : jj_la1 [ 25 ] = jj_gen ; break label_8 ; } t = jj_consume_token ( XOR ) ; AndExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void AndExpression ( ) throws ParseException { Token t = null ; EqualityExpression ( ) ; label_9 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_AND : case BIT_ANDX : ; break ; default : jj_la1 [ 26 ] = jj_gen ; break label_9 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_AND : t = jj_consume_token ( BIT_AND ) ; break ; case BIT_ANDX : t = jj_consume_token ( BIT_ANDX ) ; break ; default : jj_la1 [ 27 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } EqualityExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void EqualityExpression ( ) throws ParseException { Token t = null ; InstanceOfExpression ( ) ; label_10 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EQ : case NE : ; break ; default : jj_la1 [ 28 ] = jj_gen ; break label_10 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EQ : t = jj_consume_token ( EQ ) ; break ; case NE : t = jj_consume_token ( NE ) ; break ; default : jj_la1 [ 29 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } InstanceOfExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void InstanceOfExpression ( ) throws ParseException { Token t = null ; RelationalExpression ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INSTANCEOF : t = jj_consume_token ( INSTANCEOF ) ; Type ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 30 ] = jj_gen ; ; } } final public void RelationalExpression ( ) throws ParseException { Token t = null ; ShiftExpression ( ) ; label_11 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case GT : case GTX : case LT : case LTX : case LE : case LEX : case GE : case GEX : ; break ; default : jj_la1 [ 31 ] = jj_gen ; break label_11 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LT : t = jj_consume_token ( LT ) ; break ; case LTX : t = jj_consume_token ( LTX ) ; break ; case GT : t = jj_consume_token ( GT ) ; break ; case GTX : t = jj_consume_token ( GTX ) ; break ; case LE : t = jj_consume_token ( LE ) ; break ; case LEX : t = jj_consume_token ( LEX ) ; break ; case GE : t = jj_consume_token ( GE ) ; break ; case GEX : t = jj_consume_token ( GEX ) ; break ; default : jj_la1 [ 32 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } ShiftExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void ShiftExpression ( ) throws ParseException { Token t = null ; AdditiveExpression ( ) ; label_12 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LSHIFT : case LSHIFTX : case RSIGNEDSHIFT : case RSIGNEDSHIFTX : case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : ; break ; default : jj_la1 [ 33 ] = jj_gen ; break label_12 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LSHIFT : t = jj_consume_token ( LSHIFT ) ; break ; case LSHIFTX : t = jj_consume_token ( LSHIFTX ) ; break ; case RSIGNEDSHIFT : t = jj_consume_token ( RSIGNEDSHIFT ) ; break ; case RSIGNEDSHIFTX : t = jj_consume_token ( RSIGNEDSHIFTX ) ; break ; case RUNSIGNEDSHIFT : t = jj_consume_token ( RUNSIGNEDSHIFT ) ; break ; case RUNSIGNEDSHIFTX : t = jj_consume_token ( RUNSIGNEDSHIFTX ) ; break ; default : jj_la1 [ 34 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } AdditiveExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void AdditiveExpression ( ) throws ParseException { Token t = null ; MultiplicativeExpression ( ) ; label_13 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : case MINUS : ; break ; default : jj_la1 [ 35 ] = jj_gen ; break label_13 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : t = jj_consume_token ( PLUS ) ; break ; case MINUS : t = jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 36 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } MultiplicativeExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void MultiplicativeExpression ( ) throws ParseException { Token t = null ; UnaryExpression ( ) ; label_14 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STAR : case SLASH : case MOD : ; break ; default : jj_la1 [ 37 ] = jj_gen ; break label_14 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STAR : t = jj_consume_token ( STAR ) ; break ; case SLASH : t = jj_consume_token ( SLASH ) ; break ; case MOD : t = jj_consume_token ( MOD ) ; break ; default : jj_la1 [ 38 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } UnaryExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void UnaryExpression ( ) throws ParseException { Token t = null ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : case MINUS : switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : t = jj_consume_token ( PLUS ) ; break ; case MINUS : t = jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 39 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } UnaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; case INCR : PreIncrementExpression ( ) ; break ; case DECR : PreDecrementExpression ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : UnaryExpressionNotPlusMinus ( ) ; break ; default : jj_la1 [ 40 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } final public void PreIncrementExpression ( ) throws ParseException { Token t = null ; t = jj_consume_token ( INCR ) ; LHSPrimaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } final public void PreDecrementExpression ( ) throws ParseException { Token t = null ; t = jj_consume_token ( DECR ) ; LHSPrimaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } final public void UnaryExpressionNotPlusMinus ( ) throws ParseException { Token t = null ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BANG : case TILDE : switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TILDE : t = jj_consume_token ( TILDE ) ; break ; case BANG : t = jj_consume_token ( BANG ) ; break ; default : jj_la1 [ 41 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } UnaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 42 ] = jj_gen ; if ( jj_2_10 ( 2147483647 ) ) { CastExpression ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : PostfixExpression ( ) ; break ; default : jj_la1 [ 43 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void CastLookahead ( ) throws ParseException { if ( jj_2_11 ( 2 ) ) { jj_consume_token ( LPAREN ) ; PrimitiveType ( ) ; } else if ( jj_2_12 ( 2147483647 ) ) { jj_consume_token ( LPAREN ) ; AmbiguousName ( ) ; jj_consume_token ( LBRACKET ) ; jj_consume_token ( RBRACKET ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : jj_consume_token ( LPAREN ) ; AmbiguousName ( ) ; jj_consume_token ( RPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TILDE : jj_consume_token ( TILDE ) ; break ; case BANG : jj_consume_token ( BANG ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; break ; case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; break ; case NEW : jj_consume_token ( NEW ) ; break ; case FALSE : case NULL : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : Literal ( ) ; break ; default : jj_la1 [ 44 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } break ; default : jj_la1 [ 45 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void PostfixExpression ( ) throws ParseException { Token t = null ; if ( jj_2_13 ( 2147483647 ) ) { LHSPrimaryExpression ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INCR : case DECR : switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INCR : t = jj_consume_token ( INCR ) ; break ; case DECR : t = jj_consume_token ( DECR ) ; break ; default : jj_la1 [ 46 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; jjtn001 . postfix = true ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 47 ] = jj_gen ; ; } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : PrimaryExpression ( ) ; break ; default : jj_la1 [ 48 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void CastExpression ( ) throws ParseException { BSHCastExpression jjtn000 = new BSHCastExpression ( JJTCASTEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { if ( jj_2_14 ( 2147483647 ) ) { jj_consume_token ( LPAREN ) ; Type ( ) ; jj_consume_token ( RPAREN ) ; UnaryExpression ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : jj_consume_token ( LPAREN ) ; Type ( ) ; jj_consume_token ( RPAREN ) ; UnaryExpressionNotPlusMinus ( ) ; break ; default : jj_la1 [ 49 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void PrimaryExpression ( ) throws ParseException { BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression ( JJTPRIMARYEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { PrimaryPrefix ( ) ; label_15 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : case LBRACKET : case DOT : ; break ; default : jj_la1 [ 50 ] = jj_gen ; break label_15 ; } PrimarySuffix ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void PrimaryPrefix ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FALSE : case NULL : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : Literal ( ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; break ; case NEW : AllocationExpression ( ) ; break ; default : jj_la1 [ 52 ] = jj_gen ; if ( jj_2_15 ( 2147483647 ) ) { Type ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : BSHMethodInvocation jjtn001 = new BSHMethodInvocation ( JJTMETHODINVOCATION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; break ; default : jj_la1 [ 51 ] = jj_gen ; ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , jjtree . nodeArity ( ) > 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 53 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void PrimarySuffix ( ) throws ParseException { BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix ( JJTPRIMARYSUFFIX ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { if ( jj_2_16 ( 2 ) ) { jj_consume_token ( DOT ) ; jj_consume_token ( CLASS ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . CLASS ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : jj_consume_token ( LBRACKET ) ; Expression ( ) ; jj_consume_token ( RBRACKET ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . INDEX ; break ; case DOT : jj_consume_token ( DOT ) ; t = jj_consume_token ( IDENTIFIER ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; break ; default : jj_la1 [ 54 ] = jj_gen ; ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . NAME ; jjtn000 . field = t . image ; break ; case LBRACE : jj_consume_token ( LBRACE ) ; Expression ( ) ; jj_consume_token ( RBRACE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . PROPERTY ; break ; default : jj_la1 [ 55 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void LHSPrimaryPrefix ( ) throws ParseException { BSHMethodInvocation jjtn001 = new BSHMethodInvocation ( JJTMETHODINVOCATION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; break ; default : jj_la1 [ 56 ] = jj_gen ; ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , jjtree . nodeArity ( ) > 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } final public void LHSPrimaryExpression ( ) throws ParseException { BSHLHSPrimaryExpression jjtn000 = new BSHLHSPrimaryExpression ( JJTLHSPRIMARYEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { LHSPrimaryPrefix ( ) ; label_16 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : case LBRACKET : case DOT : ; break ; default : jj_la1 [ 57 ] = jj_gen ; break label_16 ; } LHSPrimarySuffix ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void LHSPrimarySuffix ( ) throws ParseException { BSHLHSPrimarySuffix jjtn000 = new BSHLHSPrimarySuffix ( JJTLHSPRIMARYSUFFIX ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null , t1 , t2 = null ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : jj_consume_token ( LBRACKET ) ; Expression ( ) ; jj_consume_token ( RBRACKET ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHLHSPrimarySuffix . INDEX ; break ; case DOT : jj_consume_token ( DOT ) ; t1 = jj_consume_token ( IDENTIFIER ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; jj_consume_token ( DOT ) ; t2 = jj_consume_token ( IDENTIFIER ) ; break ; default : jj_la1 [ 58 ] = jj_gen ; ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHLHSPrimarySuffix . NAME ; if ( t2 == null ) jjtn000 . field = t1 . image ; else { jjtn000 . method = t1 . image ; jjtn000 . field = t2 . image ; } break ; case LBRACE : jj_consume_token ( LBRACE ) ; Expression ( ) ; jj_consume_token ( RBRACE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHLHSPrimarySuffix . PROPERTY ; break ; default : jj_la1 [ 59 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Literal ( ) throws ParseException { BSHLiteral jjtn000 = new BSHLiteral ( JJTLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token x ; boolean b ; String literal ; char ch ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INTEGER_LITERAL : x = jj_consume_token ( INTEGER_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; literal = x . image ; ch = literal . charAt ( literal . length ( ) - 1 ) ; if ( ch == 'l' || ch == 'L' ) { literal = literal . substring ( 0 , literal . length ( ) - 1 ) ; jjtn000 . value = new Primitive ( new Long ( literal ) ) ; } else jjtn000 . value = new Primitive ( Integer . decode ( literal ) ) ; break ; case FLOATING_POINT_LITERAL : x = jj_consume_token ( FLOATING_POINT_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; literal = x . image ; ch = literal . charAt ( literal . length ( ) - 1 ) ; if ( ch == 'f' || ch == 'F' ) { literal = literal . substring ( 0 , literal . length ( ) - 1 ) ; jjtn000 . value = new Primitive ( new Float ( literal ) ) ; } else { if ( ch == 'd' || ch == 'D' ) literal = literal . substring ( 0 , literal . length ( ) - 1 ) ; jjtn000 . value = new Primitive ( new Double ( literal ) ) ; } break ; case CHARACTER_LITERAL : x = jj_consume_token ( CHARACTER_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; try { jjtn000 . charSetup ( x . image . substring ( 1 , x . image . length ( ) - 1 ) ) ; } catch ( Exception e ) { { if ( true ) throw new ParseException ( "Error parsing character: " + x . image ) ; } } break ; case STRING_LITERAL : x = jj_consume_token ( STRING_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; try { jjtn000 . stringSetup ( x . image . substring ( 1 , x . image . length ( ) - 1 ) ) ; } catch ( Exception e ) { { if ( true ) throw new ParseException ( "Error parsing string: " + x . image ) ; } } break ; case FALSE : case TRUE : b = BooleanLiteral ( ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . value = new Primitive ( new Boolean ( b ) ) ; break ; case NULL : NullLiteral ( ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . value = Primitive . NULL ; break ; case VOID : VoidLiteral ( ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . value = Primitive . VOID ; break ; default : jj_la1 [ 60 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public boolean BooleanLiteral ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TRUE : jj_consume_token ( TRUE ) ; { if ( true ) return true ; } break ; case FALSE : jj_consume_token ( FALSE ) ; { if ( true ) return false ; } break ; default : jj_la1 [ 61 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } throw new Error ( "Missing return statement in function" ) ; } final public void NullLiteral ( ) throws ParseException { jj_consume_token ( NULL ) ; } final public void VoidLiteral ( ) throws ParseException { jj_consume_token ( VOID ) ; } final public void Arguments ( ) throws ParseException { BSHArguments jjtn000 = new BSHArguments ( JJTARGUMENTS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : ArgumentList ( ) ; break ; default : jj_la1 [ 62 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ArgumentList ( ) throws ParseException { Expression ( ) ; label_17 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 63 ] = jj_gen ; break label_17 ; } jj_consume_token ( COMMA ) ; Expression ( ) ; } } final public void AllocationExpression ( ) throws ParseException { BSHAllocationExpression jjtn000 = new BSHAllocationExpression ( JJTALLOCATIONEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { if ( jj_2_18 ( 2 ) ) { jj_consume_token ( NEW ) ; PrimitiveType ( ) ; ArrayDimensions ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case NEW : jj_consume_token ( NEW ) ; AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : ArrayDimensions ( ) ; break ; case LPAREN : Arguments ( ) ; if ( jj_2_17 ( 2 ) ) { Block ( ) ; } else { ; } break ; default : jj_la1 [ 64 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } break ; default : jj_la1 [ 65 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ArrayDimensions ( ) throws ParseException { BSHArrayDimensions jjtn000 = new BSHArrayDimensions ( JJTARRAYDIMENSIONS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { if ( jj_2_20 ( 2 ) ) { label_18 : while ( true ) { jj_consume_token ( LBRACKET ) ; Expression ( ) ; jj_consume_token ( RBRACKET ) ; jjtn000 . addArrayDimension ( ) ; if ( jj_2_19 ( 2 ) ) { ; } else { break label_18 ; } } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : label_19 : while ( true ) { jj_consume_token ( LBRACKET ) ; jj_consume_token ( RBRACKET ) ; jjtn000 . addArrayDimension ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : ; break ; default : jj_la1 [ 66 ] = jj_gen ; break label_19 ; } } ArrayInitializer ( ) ; break ; default : jj_la1 [ 67 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Statement ( ) throws ParseException { if ( jj_2_21 ( 2 ) ) { LabeledStatement ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : Block ( ) ; break ; case SEMICOLON : EmptyStatement ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : StatementExpression ( ) ; jj_consume_token ( SEMICOLON ) ; break ; case SWITCH : SwitchStatement ( ) ; break ; case IF : IfStatement ( ) ; break ; case WHILE : WhileStatement ( ) ; break ; case DO : DoStatement ( ) ; break ; case FOR : ForStatement ( ) ; break ; case BREAK : BreakStatement ( ) ; break ; case CONTINUE : ContinueStatement ( ) ; break ; case RETURN : ReturnStatement ( ) ; break ; case THROW : ThrowStatement ( ) ; break ; case TRY : TryStatement ( ) ; break ; default : jj_la1 [ 68 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void LabeledStatement ( ) throws ParseException { jj_consume_token ( IDENTIFIER ) ; jj_consume_token ( COLON ) ; Statement ( ) ; } final public void Block ( ) throws ParseException { BSHBlock jjtn000 = new BSHBlock ( JJTBLOCK ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACE ) ; label_20 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : ; break ; default : jj_la1 [ 69 ] = jj_gen ; break label_20 ; } BlockStatement ( ) ; } jj_consume_token ( RBRACE ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void BlockStatement ( ) throws ParseException { if ( jj_2_22 ( 2147483647 ) ) { MethodDeclaration ( ) ; } else if ( jj_2_23 ( 2147483647 ) ) { TypedVariableDeclaration ( ) ; jj_consume_token ( SEMICOLON ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FLOAT : case FOR : case IF : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : Statement ( ) ; break ; case IMPORT : ImportDeclaration ( ) ; break ; default : jj_la1 [ 70 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void EmptyStatement ( ) throws ParseException { jj_consume_token ( SEMICOLON ) ; } final public void StatementExpression ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INCR : PreIncrementExpression ( ) ; break ; case DECR : PreDecrementExpression ( ) ; break ; default : jj_la1 [ 71 ] = jj_gen ; if ( jj_2_24 ( 2147483647 ) ) { Assignment ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : PostfixExpression ( ) ; break ; default : jj_la1 [ 72 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void SwitchStatement ( ) throws ParseException { BSHSwitchStatement jjtn000 = new BSHSwitchStatement ( JJTSWITCHSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( SWITCH ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; jj_consume_token ( LBRACE ) ; label_21 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case CASE : case _DEFAULT : ; break ; default : jj_la1 [ 73 ] = jj_gen ; break label_21 ; } SwitchLabel ( ) ; label_22 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : ; break ; default : jj_la1 [ 74 ] = jj_gen ; break label_22 ; } BlockStatement ( ) ; } } jj_consume_token ( RBRACE ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void SwitchLabel ( ) throws ParseException { BSHSwitchLabel jjtn000 = new BSHSwitchLabel ( JJTSWITCHLABEL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case CASE : jj_consume_token ( CASE ) ; Expression ( ) ; jj_consume_token ( COLON ) ; break ; case _DEFAULT : jj_consume_token ( _DEFAULT ) ; jj_consume_token ( COLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isDefault = true ; break ; default : jj_la1 [ 75 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void IfStatement ( ) throws ParseException { BSHIfStatement jjtn000 = new BSHIfStatement ( JJTIFSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( IF ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; Statement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSE : jj_consume_token ( ELSE ) ; Statement ( ) ; break ; default : jj_la1 [ 76 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void WhileStatement ( ) throws ParseException { BSHWhileStatement jjtn000 = new BSHWhileStatement ( JJTWHILESTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( WHILE ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; Statement ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void DoStatement ( ) throws ParseException { BSHWhileStatement jjtn000 = new BSHWhileStatement ( JJTWHILESTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( DO ) ; Statement ( ) ; jj_consume_token ( WHILE ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isDoStatement = true ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ForStatement ( ) throws ParseException { BSHForStatement jjtn000 = new BSHForStatement ( JJTFORSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( FOR ) ; jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FINAL : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : ForInit ( ) ; jjtn000 . hasForInit = true ; break ; default : jj_la1 [ 77 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : Expression ( ) ; jjtn000 . hasExpression = true ; break ; default : jj_la1 [ 78 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : ForUpdate ( ) ; jjtn000 . hasForUpdate = true ; break ; default : jj_la1 [ 79 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; Statement ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ForInit ( ) throws ParseException { Token t = null ; if ( jj_2_25 ( 2147483647 ) ) { TypedVariableDeclaration ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : StatementExpressionList ( ) ; break ; default : jj_la1 [ 80 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void TypedVariableDeclaration ( ) throws ParseException { BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration ( JJTTYPEDVARIABLEDECLARATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FINAL : t = jj_consume_token ( FINAL ) ; break ; default : jj_la1 [ 81 ] = jj_gen ; ; } Type ( ) ; VariableDeclarator ( ) ; label_23 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 82 ] = jj_gen ; break label_23 ; } jj_consume_token ( COMMA ) ; VariableDeclarator ( ) ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isFinal = ( t != null ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void StatementExpressionList ( ) throws ParseException { BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList ( JJTSTATEMENTEXPRESSIONLIST ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { StatementExpression ( ) ; label_24 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 83 ] = jj_gen ; break label_24 ; } jj_consume_token ( COMMA ) ; StatementExpression ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ForUpdate ( ) throws ParseException { StatementExpressionList ( ) ; } final public void BreakStatement ( ) throws ParseException { BSHReturnStatement jjtn000 = new BSHReturnStatement ( JJTRETURNSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( BREAK ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; break ; default : jj_la1 [ 84 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . kind = BREAK ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ContinueStatement ( ) throws ParseException { BSHReturnStatement jjtn000 = new BSHReturnStatement ( JJTRETURNSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( CONTINUE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; break ; default : jj_la1 [ 85 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . kind = CONTINUE ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ReturnStatement ( ) throws ParseException { BSHReturnStatement jjtn000 = new BSHReturnStatement ( JJTRETURNSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( RETURN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : Expression ( ) ; break ; default : jj_la1 [ 86 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . kind = RETURN ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ThrowStatement ( ) throws ParseException { BSHThrowStatement jjtn000 = new BSHThrowStatement ( JJTTHROWSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( THROW ) ; Expression ( ) ; jj_consume_token ( SEMICOLON ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void TryStatement ( ) throws ParseException { BSHTryStatement jjtn000 = new BSHTryStatement ( JJTTRYSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( TRY ) ; Block ( ) ; label_25 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case CATCH : ; break ; default : jj_la1 [ 87 ] = jj_gen ; break label_25 ; } jj_consume_token ( CATCH ) ; jj_consume_token ( LPAREN ) ; FormalParameter ( ) ; jj_consume_token ( RPAREN ) ; Block ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FINALLY : jj_consume_token ( FINALLY ) ; Block ( ) ; break ; default : jj_la1 [ 88 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final private boolean jj_2_1 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_1 ( ) ; jj_save ( 0 , xla ) ; return retval ; } final private boolean jj_2_2 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_2 ( ) ; jj_save ( 1 , xla ) ; return retval ; } final private boolean jj_2_3 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_3 ( ) ; jj_save ( 2 , xla ) ; return retval ; } final private boolean jj_2_4 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_4 ( ) ; jj_save ( 3 , xla ) ; return retval ; } final private boolean jj_2_5 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_5 ( ) ; jj_save ( 4 , xla ) ; return retval ; } final private boolean jj_2_6 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_6 ( ) ; jj_save ( 5 , xla ) ; return retval ; } final private boolean jj_2_7 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_7 ( ) ; jj_save ( 6 , xla ) ; return retval ; } final private boolean jj_2_8 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_8 ( ) ; jj_save ( 7 , xla ) ; return retval ; } final private boolean jj_2_9 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_9 ( ) ; jj_save ( 8 , xla ) ; return retval ; } final private boolean jj_2_10 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_10 ( ) ; jj_save ( 9 , xla ) ; return retval ; } final private boolean jj_2_11 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_11 ( ) ; jj_save ( 10 , xla ) ; return retval ; } final private boolean jj_2_12 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_12 ( ) ; jj_save ( 11 , xla ) ; return retval ; } final private boolean jj_2_13 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_13 ( ) ; jj_save ( 12 , xla ) ; return retval ; } final private boolean jj_2_14 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_14 ( ) ; jj_save ( 13 , xla ) ; return retval ; } final private boolean jj_2_15 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_15 ( ) ; jj_save ( 14 , xla ) ; return retval ; } final private boolean jj_2_16 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_16 ( ) ; jj_save ( 15 , xla ) ; return retval ; } final private boolean jj_2_17 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_17 ( ) ; jj_save ( 16 , xla ) ; return retval ; } final private boolean jj_2_18 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_18 ( ) ; jj_save ( 17 , xla ) ; return retval ; } final private boolean jj_2_19 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_19 ( ) ; jj_save ( 18 , xla ) ; return retval ; } final private boolean jj_2_20 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_20 ( ) ; jj_save ( 19 , xla ) ; return retval ; } final private boolean jj_2_21 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_21 ( ) ; jj_save ( 20 , xla ) ; return retval ; } final private boolean jj_2_22 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_22 ( ) ; jj_save ( 21 , xla ) ; return retval ; } final private boolean jj_2_23 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_23 ( ) ; jj_save ( 22 , xla ) ; return retval ; } final private boolean jj_2_24 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_24 ( ) ; jj_save ( 23 , xla ) ; return retval ; } final private boolean jj_2_25 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_25 ( ) ; jj_save ( 24 , xla ) ; return retval ; } final private boolean jj_3R_27 ( ) { if ( jj_3R_45 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_16 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( CLASS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_102 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_16 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_117 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_118 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_119 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_79 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_96 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_149 ( ) { if ( jj_scan_token ( FINAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_39 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_78 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_79 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_78 ( ) { if ( jj_3R_45 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_96 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_2 ( ) { if ( jj_3R_27 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_132 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_149 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_226 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_227 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3_15 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( CLASS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_42 ( ) { if ( jj_scan_token ( FINAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_25 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_42 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_148 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_96 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_36 ( ) { if ( jj_scan_token ( DECR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_243 ( ) { if ( jj_scan_token ( ELSE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_81 ( ) { if ( jj_3R_102 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_101 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_116 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_147 ( ) { if ( jj_3R_45 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_96 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_92 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_35 ( ) { if ( jj_scan_token ( INCR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_269 ( ) { if ( jj_3R_270 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_131 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_147 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_148 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_100 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_244 ( ) { if ( jj_3R_261 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_268 ( ) { if ( jj_3R_132 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_261 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_268 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_269 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_246 ( ) { if ( jj_3R_262 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_99 ( ) { if ( jj_3R_115 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_245 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_91 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_98 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_1 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_80 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_97 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_98 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_99 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_100 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_101 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_97 ( ) { if ( jj_3R_109 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_14 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_90 ( ) { if ( jj_scan_token ( BANG ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_280 ( ) { if ( jj_scan_token ( DECR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_181 ( ) { if ( jj_scan_token ( FOR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_244 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_245 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_246 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_41 ( ) { if ( jj_3R_80 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_81 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_89 ( ) { if ( jj_scan_token ( TILDE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_282 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_265 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_279 ( ) { if ( jj_scan_token ( INCR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_180 ( ) { if ( jj_scan_token ( DO ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( WHILE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_281 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_278 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_281 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_282 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_274 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_279 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_280 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_13 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_35 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_36 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_209 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_179 ( ) { if ( jj_scan_token ( WHILE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_12 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_208 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_274 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_260 ( ) { if ( jj_3R_95 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_178 ( ) { if ( jj_scan_token ( IF ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_243 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_201 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_208 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_209 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_68 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_89 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_90 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_91 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_92 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_93 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_94 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_67 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_10 ( ) { if ( jj_3R_33 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_267 ( ) { if ( jj_scan_token ( _DEFAULT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_11 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_33 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_11 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_67 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_68 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_277 ( ) { if ( jj_scan_token ( BANG ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_266 ( ) { if ( jj_scan_token ( CASE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_259 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_266 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_267 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_242 ( ) { if ( jj_3R_259 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_260 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_273 ( ) { if ( jj_3R_201 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_258 ( ) { if ( jj_scan_token ( MOD ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_272 ( ) { if ( jj_3R_278 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_24 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_276 ( ) { if ( jj_scan_token ( TILDE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_177 ( ) { if ( jj_scan_token ( SWITCH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_242 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_271 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_276 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_277 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_265 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_271 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_272 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_273 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_257 ( ) { if ( jj_scan_token ( SLASH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_195 ( ) { if ( jj_3R_201 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_233 ( ) { if ( jj_scan_token ( RSIGNEDSHIFTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_200 ( ) { if ( jj_scan_token ( DECR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_194 ( ) { if ( jj_3R_82 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_193 ( ) { if ( jj_3R_200 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_256 ( ) { if ( jj_scan_token ( STAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_192 ( ) { if ( jj_3R_199 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_176 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_192 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_193 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_194 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_195 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_239 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_256 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_257 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_258 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_199 ( ) { if ( jj_scan_token ( INCR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_232 ( ) { if ( jj_scan_token ( RSIGNEDSHIFT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_264 ( ) { if ( jj_scan_token ( MINUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_255 ( ) { if ( jj_3R_265 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_225 ( ) { if ( jj_scan_token ( GEX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_254 ( ) { if ( jj_3R_200 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_175 ( ) { if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_253 ( ) { if ( jj_3R_199 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_263 ( ) { if ( jj_scan_token ( PLUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_221 ( ) { if ( jj_scan_token ( GTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_40 ( ) { if ( jj_scan_token ( FINAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_252 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_263 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_264 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_238 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_252 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_253 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_254 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_255 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_23 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_40 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_241 ( ) { if ( jj_scan_token ( MINUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_113 ( ) { if ( jj_3R_134 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_22 ( ) { if ( jj_3R_39 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_224 ( ) { if ( jj_scan_token ( GE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_235 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_228 ( ) { if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_239 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_112 ( ) { if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_220 ( ) { if ( jj_scan_token ( GT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_231 ( ) { if ( jj_scan_token ( LSHIFTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_240 ( ) { if ( jj_scan_token ( PLUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_111 ( ) { if ( jj_3R_132 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_229 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_240 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_241 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_228 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_213 ( ) { if ( jj_scan_token ( NE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_95 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_110 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_111 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_112 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_113 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_110 ( ) { if ( jj_3R_131 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_77 ( ) { if ( jj_3R_95 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_216 ( ) { if ( jj_3R_228 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_229 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_223 ( ) { if ( jj_scan_token ( LEX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_234 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_230 ( ) { if ( jj_scan_token ( LSHIFT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_219 ( ) { if ( jj_scan_token ( LTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_37 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_77 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_217 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_230 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_231 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_232 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_233 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_234 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_235 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_216 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_212 ( ) { if ( jj_scan_token ( EQ ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_214 ( ) { if ( jj_3R_216 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_217 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_205 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_212 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_213 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_204 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_38 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_222 ( ) { if ( jj_scan_token ( LE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_218 ( ) { if ( jj_scan_token ( LT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_215 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_218 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_219 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_220 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_221 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_222 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_223 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_224 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_225 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_214 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_162 ( ) { if ( jj_3R_186 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_161 ( ) { if ( jj_3R_185 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_210 ( ) { if ( jj_3R_214 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_215 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_160 ( ) { if ( jj_3R_184 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_159 ( ) { if ( jj_3R_183 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_211 ( ) { if ( jj_scan_token ( INSTANCEOF ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_158 ( ) { if ( jj_3R_182 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_204 ( ) { if ( jj_3R_210 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_211 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_157 ( ) { if ( jj_3R_181 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_207 ( ) { if ( jj_scan_token ( BIT_ANDX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_156 ( ) { if ( jj_3R_180 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_155 ( ) { if ( jj_3R_179 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_189 ( ) { if ( jj_scan_token ( XOR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_188 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_154 ( ) { if ( jj_3R_178 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_197 ( ) { if ( jj_3R_204 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_205 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_153 ( ) { if ( jj_3R_177 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_152 ( ) { if ( jj_3R_176 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_60 ( ) { if ( jj_scan_token ( ORASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_17 ( ) { if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_206 ( ) { if ( jj_scan_token ( BIT_AND ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_151 ( ) { if ( jj_3R_175 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_198 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_206 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_207 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_197 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_150 ( ) { if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_188 ( ) { if ( jj_3R_197 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_198 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_59 ( ) { if ( jj_scan_token ( XORASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_21 ( ) { if ( jj_3R_38 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_133 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_21 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_150 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_151 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_152 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_153 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_154 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_155 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_156 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_157 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_158 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_159 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_160 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_161 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_162 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_191 ( ) { if ( jj_scan_token ( BIT_ORX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_168 ( ) { if ( jj_3R_188 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_189 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_167 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_17 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_58 ( ) { if ( jj_scan_token ( ANDASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_196 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_64 ( ) { if ( jj_scan_token ( RSIGNEDSHIFTASSIGNX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_171 ( ) { if ( jj_scan_token ( BOOL_ANDX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_187 ( ) { Token xsp ; if ( jj_3R_196 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_196 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_3R_86 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_166 ( ) { if ( jj_3R_165 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_190 ( ) { if ( jj_scan_token ( BIT_OR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_19 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_104 ( ) { if ( jj_scan_token ( HOOK ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_83 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_169 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_190 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_191 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_168 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_165 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_20 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_187 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_57 ( ) { if ( jj_scan_token ( MINUSASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_20 ( ) { Token xsp ; if ( jj_3_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_19 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_63 ( ) { if ( jj_scan_token ( RSIGNEDSHIFTASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_139 ( ) { if ( jj_3R_168 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_169 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_142 ( ) { if ( jj_scan_token ( BOOL_ORX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_170 ( ) { if ( jj_scan_token ( BOOL_AND ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_56 ( ) { if ( jj_scan_token ( PLUSASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_140 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_170 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_171 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_139 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_120 ( ) { if ( jj_3R_139 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_140 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_137 ( ) { if ( jj_scan_token ( NEW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_166 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_167 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_55 ( ) { if ( jj_scan_token ( MODASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_141 ( ) { if ( jj_scan_token ( BOOL_OR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_18 ( ) { if ( jj_scan_token ( NEW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_165 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_115 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_18 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_137 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_121 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_141 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_142 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_120 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_172 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_103 ( ) { if ( jj_3R_120 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_121 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_54 ( ) { if ( jj_scan_token ( SLASHASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_143 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_172 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_66 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFTASSIGNX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_122 ( ) { if ( jj_3R_143 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_62 ( ) { if ( jj_scan_token ( LSHIFTASSIGNX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_83 ( ) { if ( jj_3R_103 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_104 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_53 ( ) { if ( jj_scan_token ( STARASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_105 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_122 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_65 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFTASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_61 ( ) { if ( jj_scan_token ( LSHIFTASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_52 ( ) { if ( jj_scan_token ( ASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_146 ( ) { if ( jj_scan_token ( VOID ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_32 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_52 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_53 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_54 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_55 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_56 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_57 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_58 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_59 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_60 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_61 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_62 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_63 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_64 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_65 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_66 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_145 ( ) { if ( jj_scan_token ( NULL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_9 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_174 ( ) { if ( jj_scan_token ( FALSE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_82 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_173 ( ) { if ( jj_scan_token ( TRUE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_144 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_173 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_174 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_44 ( ) { if ( jj_3R_83 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_43 ( ) { if ( jj_3R_82 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_26 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_43 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_44 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_130 ( ) { if ( jj_3R_146 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_129 ( ) { if ( jj_3R_145 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_128 ( ) { if ( jj_3R_144 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_127 ( ) { if ( jj_scan_token ( STRING_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_8 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_28 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_8 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_126 ( ) { if ( jj_scan_token ( CHARACTER_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_203 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_76 ( ) { if ( jj_scan_token ( DOUBLE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_75 ( ) { if ( jj_scan_token ( FLOAT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_74 ( ) { if ( jj_scan_token ( LONG ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_73 ( ) { if ( jj_scan_token ( INT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_49 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_72 ( ) { if ( jj_scan_token ( SHORT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_71 ( ) { if ( jj_scan_token ( BYTE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_70 ( ) { if ( jj_scan_token ( CHAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_125 ( ) { if ( jj_scan_token ( FLOATING_POINT_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_69 ( ) { if ( jj_scan_token ( BOOLEAN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_34 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_69 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_70 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_71 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_72 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_73 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_74 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_75 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_76 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_85 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_45 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_84 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_85 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_84 ( ) { if ( jj_scan_token ( VOID ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_7 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_48 ( ) { if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_109 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_124 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_125 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_126 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_127 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_128 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_129 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_130 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_124 ( ) { if ( jj_scan_token ( INTEGER_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_123 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_30 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_48 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_49 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_7 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_136 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_135 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_164 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_108 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_6 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_135 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_6 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_164 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_51 ( ) { if ( jj_3R_88 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_5 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_29 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_87 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_107 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_123 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_114 ( ) { if ( jj_3R_135 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_136 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_106 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_88 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_106 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_107 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_108 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_96 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_114 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_202 ( ) { if ( jj_3R_29 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_5 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_86 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_202 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_203 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_31 ( ) { if ( jj_3R_50 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_51 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_251 ( ) { if ( jj_scan_token ( FINALLY ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_250 ( ) { if ( jj_scan_token ( CATCH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_135 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_47 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_186 ( ) { if ( jj_scan_token ( TRY ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_250 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } xsp = jj_scanpos ; if ( jj_3R_251 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_46 ( ) { if ( jj_3R_86 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_29 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_46 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_47 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_236 ( ) { if ( jj_scan_token ( ASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_29 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_50 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_87 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_249 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_237 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( STAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_248 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_185 ( ) { if ( jj_scan_token ( THROW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_138 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_227 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_226 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_94 ( ) { if ( jj_3R_109 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_275 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_176 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_184 ( ) { if ( jj_scan_token ( RETURN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_249 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_247 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_226 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_236 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_93 ( ) { if ( jj_scan_token ( NEW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_183 ( ) { if ( jj_scan_token ( CONTINUE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_248 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_163 ( ) { if ( jj_scan_token ( IMPORT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( STAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_182 ( ) { if ( jj_scan_token ( BREAK ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_247 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_119 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_118 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_138 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_262 ( ) { if ( jj_3R_270 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_4 ( ) { if ( jj_scan_token ( IMPORT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_237 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_134 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_4 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_163 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_116 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_3 ( ) { if ( jj_3R_27 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_117 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_270 ( ) { if ( jj_3R_176 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_275 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } public ParserTokenManager token_source ; ASCII_UCodeESC_CharStream jj_input_stream ; public Token token , jj_nt ; private int jj_ntk ; private Token jj_scanpos , jj_lastpos ; private int jj_la ; public boolean lookingAhead = false ; private boolean jj_semLA ; private int jj_gen ; final private int [ ] jj_la1 = new int [ 89 ] ; final private int [ ] jj_la1_0 = { 0xdb6a5800 , 0xdb6a5801 , 0x0 , 0x0 , 0x0 , 0x80000000 , 0x0 , 0x9424800 , 0x9424800 , 0x0 , 0x0 , 0x8424800 , 0x0 , 0x8424800 , 0x8424800 , 0x8424800 , 0x9424800 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x9424800 , 0x0 , 0x0 , 0x9424800 , 0x1000000 , 0x0 , 0x0 , 0x0 , 0x9424800 , 0x0 , 0x0 , 0x0 , 0x1000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x1000000 , 0x1000000 , 0x9424800 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x596a5800 , 0xdb6a5800 , 0xd96a5800 , 0x0 , 0x9424800 , 0x108000 , 0xdb6a5800 , 0x108000 , 0x800000 , 0xb424800 , 0x9424800 , 0x9424800 , 0x9424800 , 0x2000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x9424800 , 0x10000 , 0x4000000 , } ; final private int [ ] jj_la1_1 = { 0xa747f63a , 0xa747f63a , 0x4000000 , 0x4000000 , 0x0 , 0x0 , 0x0 , 0xa745443a , 0xa745443a , 0x0 , 0x0 , 0x400040a , 0x4000000 , 0x400040a , 0x401040a , 0x40a , 0x2745443a , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x2745443a , 0x0 , 0x0 , 0x2745443a , 0x27454030 , 0x20000000 , 0x0 , 0x0 , 0x2745443a , 0x20000000 , 0x80000000 , 0x20000000 , 0x23454030 , 0x4000000 , 0x20000000 , 0x80000000 , 0x20000000 , 0x80000000 , 0x20000000 , 0x80000000 , 0x3454020 , 0x4000 , 0x2745443a , 0x0 , 0x20000000 , 0x10 , 0x0 , 0x0 , 0xa747f63a , 0xa747f63a , 0xa747f63a , 0x0 , 0x2745443a , 0x0 , 0xa747f63a , 0x0 , 0x0 , 0x2745443a , 0x2745443a , 0x2745443a , 0x2745443a , 0x0 , 0x0 , 0x0 , 0x4000000 , 0x4000000 , 0x2745443a , 0x0 , 0x0 , } ; final private int [ ] jj_la1_2 = { 0x6000008 , 0x1e001808 , 0x0 , 0x0 , 0x20 , 0x0 , 0x40 , 0x1e001800 , 0x1e001800 , 0x10 , 0x10 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x1e001800 , 0x40 , 0x2000 , 0x600000 , 0x600000 , 0x1800000 , 0x1800000 , 0x0 , 0x0 , 0x0 , 0x80000000 , 0x80000000 , 0x108000 , 0x108000 , 0x0 , 0xf0780 , 0xf0780 , 0x0 , 0x0 , 0x18000000 , 0x18000000 , 0x60000000 , 0x60000000 , 0x18000000 , 0x1e001800 , 0x1800 , 0x1800 , 0x0 , 0x1800 , 0x0 , 0x6000000 , 0x6000000 , 0x0 , 0x0 , 0x22 , 0x0 , 0x0 , 0x0 , 0x0 , 0x22 , 0x0 , 0x22 , 0x0 , 0x22 , 0x0 , 0x0 , 0x1e001800 , 0x10 , 0x2 , 0x0 , 0x2 , 0x2 , 0x6000008 , 0x6000008 , 0x6000008 , 0x6000000 , 0x0 , 0x0 , 0x6000008 , 0x0 , 0x0 , 0x6000000 , 0x1e001800 , 0x6000000 , 0x6000000 , 0x0 , 0x10 , 0x10 , 0x0 , 0x0 , 0x1e001800 , 0x0 , 0x0 , } ; final private int [ ] jj_la1_3 = { 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x7faf800 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x6 , 0x6 , 0x8 , 0x1 , 0x1 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x7e0 , 0x7e0 , 0x0 , 0x0 , 0x10 , 0x10 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , } ; final private JJCalls [ ] jj_2_rtns = new JJCalls [ 25 ] ; private boolean jj_rescan = false ; private int jj_gc = 0 ; public Parser ( java . io . InputStream stream ) { jj_input_stream = new ASCII_UCodeESC_CharStream ( stream , 1 , 1 ) ; token_source = new ParserTokenManager ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( java . io . InputStream stream ) { jj_input_stream . ReInit ( stream , 1 , 1 ) ; token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public Parser ( java . io . Reader stream ) { jj_input_stream = new ASCII_UCodeESC_CharStream ( stream , 1 , 1 ) ; token_source = new ParserTokenManager ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( java . io . Reader stream ) { jj_input_stream . ReInit ( stream , 1 , 1 ) ; token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public Parser ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } final private Token jj_consume_token ( int kind ) throws ParseException { Token oldToken ; if ( ( oldToken = token ) . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; if ( token . kind == kind ) { jj_gen ++ ; if ( ++ jj_gc > 100 ) { jj_gc = 0 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) { JJCalls c = jj_2_rtns [ i ] ; while ( c != null ) { if ( c . gen < jj_gen ) c . first = null ; c = c . next ; } } } return token ; } token = oldToken ; jj_kind = kind ; throw generateParseException ( ) ; } final private boolean jj_scan_token ( int kind ) { if ( jj_scanpos == jj_lastpos ) { jj_la -- ; if ( jj_scanpos . next == null ) { jj_lastpos = jj_scanpos = jj_scanpos . next = token_source . getNextToken ( ) ; } else { jj_lastpos = jj_scanpos = jj_scanpos . next ; } } else { jj_scanpos = jj_scanpos . next ; } if ( jj_rescan ) { int i = 0 ; Token tok = token ; while ( tok != null && tok != jj_scanpos ) { i ++ ; tok = tok . next ; } if ( tok != null ) jj_add_error_token ( kind , i ) ; } return ( jj_scanpos . kind != kind ) ; } final public Token getNextToken ( ) { if ( token . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen ++ ; return token ; } final public Token getToken ( int index ) { Token t = lookingAhead ? jj_scanpos : token ; for ( int i = 0 ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token_source . getNextToken ( ) ; } return t ; } final private int jj_ntk ( ) { if ( ( jj_nt = token . next ) == null ) return ( jj_ntk = ( token . next = token_source . getNextToken ( ) ) . kind ) ; else return ( jj_ntk = jj_nt . kind ) ; } private java . util . Vector jj_expentries = new java . util . Vector ( ) ; private int [ ] jj_expentry ; private int jj_kind = - 1 ; private int [ ] jj_lasttokens = new int [ 100 ] ; private int jj_endpos ; private void jj_add_error_token ( int kind , int pos ) { if ( pos >= 100 ) return ; if ( pos == jj_endpos + 1 ) { jj_lasttokens [ jj_endpos ++ ] = kind ; } else if ( jj_endpos != 0 ) { jj_expentry = new int [ jj_endpos ] ; for ( int i = 0 ; i < jj_endpos ; i ++ ) { jj_expentry [ i ] = jj_lasttokens [ i ] ; } boolean exists = false ; for ( java . util . Enumeration enum = jj_expentries . elements ( ) ; enum . hasMoreElements ( ) ; ) { int [ ] oldentry = ( int [ ] ) ( enum . nextElement ( ) ) ; if ( oldentry . length == jj_expentry . length ) { exists = true ; for ( int i = 0 ; i < jj_expentry . length ; i ++ ) { if ( oldentry [ i ] != jj_expentry [ i ] ) { exists = false ; break ; } } if ( exists ) break ; } } if ( ! exists ) jj_expentries . addElement ( jj_expentry ) ; if ( pos != 0 ) jj_lasttokens [ ( jj_endpos = pos ) - 1 ] = kind ; } } final public ParseException generateParseException ( ) { jj_expentries . removeAllElements ( ) ; boolean [ ] la1tokens = new boolean [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { la1tokens [ i ] = false ; } if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 89 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } if ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 64 + j ] = true ; } if ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 96 + j ] = true ; } } } } for ( int i = 0 ; i < 123 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . addElement ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = ( int [ ] ) jj_expentries . elementAt ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; } final public void enable_tracing ( ) { } final public void disable_tracing ( ) { } final private void jj_rescan_token ( ) { jj_rescan = true ; for ( int i = 0 ; i < 25 ; i ++ ) { JJCalls p = jj_2_rtns [ i ] ; do { if ( p . gen > jj_gen ) { jj_la = p . arg ; jj_lastpos = jj_scanpos = p . first ; switch ( i ) { case 0 : jj_3_1 ( ) ; break ; case 1 : jj_3_2 ( ) ; break ; case 2 : jj_3_3 ( ) ; break ; case 3 : jj_3_4 ( ) ; break ; case 4 : jj_3_5 ( ) ; break ; case 5 : jj_3_6 ( ) ; break ; case 6 : jj_3_7 ( ) ; break ; case 7 : jj_3_8 ( ) ; break ; case 8 : jj_3_9 ( ) ; break ; case 9 : jj_3_10 ( ) ; break ; case 10 : jj_3_11 ( ) ; break ; case 11 : jj_3_12 ( ) ; break ; case 12 : jj_3_13 ( ) ; break ; case 13 : jj_3_14 ( ) ; break ; case 14 : jj_3_15 ( ) ; break ; case 15 : jj_3_16 ( ) ; break ; case 16 : jj_3_17 ( ) ; break ; case 17 : jj_3_18 ( ) ; break ; case 18 : jj_3_19 ( ) ; break ; case 19 : jj_3_20 ( ) ; break ; case 20 : jj_3_21 ( ) ; break ; case 21 : jj_3_22 ( ) ; break ; case 22 : jj_3_23 ( ) ; break ; case 23 : jj_3_24 ( ) ; break ; case 24 : jj_3_25 ( ) ; break ; } } p = p . next ; } while ( p != null ) ; } jj_rescan = false ; } final private void jj_save ( int index , int xla ) { JJCalls p = jj_2_rtns [ index ] ; while ( p . gen > jj_gen ) { if ( p . next == null ) { p = p . next = new JJCalls ( ) ; break ; } p = p . next ; } p . gen = jj_gen + xla - jj_la ; p . first = token ; p . arg = xla ; } static final class JJCalls { int gen ; Token first ; int arg ; JJCalls next ; } } 	0	['399', '1', '0', '47', '487', '0', '1', '47', '82', '0.71839196', '23350', '0.8', '8', '0', '0.183375104', '0', '0', '57.45864662', '46', '5.5439', '0']
package org . gjt . sp . jedit . syntax ; public class ParserRuleFactory { public static final ParserRule createSpanRule ( String begin , String end , byte id , boolean noLineBreak , boolean atLineStart , boolean excludeMatch , boolean noWordBreak ) { int ruleAction = TokenMarker . SPAN | ( ( noLineBreak ) ? TokenMarker . NO_LINE_BREAK : 0 ) | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? TokenMarker . NO_WORD_BREAK : 0 ) ; String [ ] strings = new String [ 2 ] ; strings [ 0 ] = begin ; strings [ 1 ] = end ; int [ ] ruleSeqLengths = getStringLengthArray ( strings ) ; char [ ] ruleChars = getCharArray ( strings , ruleSeqLengths ) ; return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createDelegateSpanRule ( String begin , String end , String delegateSet , byte id , boolean noLineBreak , boolean atLineStart , boolean excludeMatch , boolean noWordBreak ) { int ruleAction = TokenMarker . SPAN | TokenMarker . DELEGATE | ( ( noLineBreak ) ? TokenMarker . NO_LINE_BREAK : 0 ) | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? TokenMarker . NO_WORD_BREAK : 0 ) ; String [ ] strings = new String [ 3 ] ; strings [ 0 ] = begin ; strings [ 1 ] = end ; strings [ 2 ] = delegateSet ; int [ ] ruleSeqLengths = getStringLengthArray ( strings ) ; char [ ] ruleChars = getCharArray ( strings , ruleSeqLengths ) ; return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createEOLSpanRule ( String seq , byte id , boolean atLineStart , boolean excludeMatch ) { int ruleAction = TokenMarker . EOL_SPAN | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createMarkPreviousRule ( String seq , byte id , boolean atLineStart , boolean excludeMatch ) { int ruleAction = TokenMarker . MARK_PREVIOUS | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createMarkFollowingRule ( String seq , byte id , boolean atLineStart , boolean excludeMatch ) { int ruleAction = TokenMarker . MARK_FOLLOWING | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createSequenceRule ( String seq , byte id , boolean atLineStart ) { int ruleAction = ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createEscapeRule ( String seq ) { int ruleAction = TokenMarker . IS_ESCAPE ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , Token . NULL ) ; } public static final ParserRule createWhitespaceRule ( String seq ) { int ruleAction = TokenMarker . WHITESPACE ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , Token . NULL ) ; } private static char [ ] getCharArray ( String [ ] strings , int [ ] lengthArray ) { if ( lengthArray == null || lengthArray . length == 0 ) return new char [ 0 ] ; char [ ] chars ; int charArrayLength = 0 ; for ( int i = 0 ; i < lengthArray . length ; i ++ ) { charArrayLength += lengthArray [ i ] ; } chars = new char [ charArrayLength ] ; int copyOffset = 0 ; for ( int i = 0 ; i < strings . length ; i ++ ) { if ( strings [ i ] != null ) { System . arraycopy ( strings [ i ] . toCharArray ( ) , 0 , chars , copyOffset , lengthArray [ i ] ) ; copyOffset += lengthArray [ i ] ; } } return chars ; } private static int [ ] getStringLengthArray ( String [ ] strings ) { int [ ] stringLengthArray ; if ( strings == null ) return new int [ 0 ] ; stringLengthArray = new int [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { if ( strings [ i ] != null ) { stringLengthArray [ i ] = strings [ i ] . length ( ) ; } } return stringLengthArray ; } } 	0	['11', '1', '0', '3', '16', '55', '2', '1', '9', '2', '456', '0', '0', '0', '0.363636364', '0', '0', '40.45454545', '6', '3.5455', '0']
package bsh ; class TokenMgrError extends Error { static final int LEXICAL_ERROR = 0 ; static final int STATIC_LEXER_ERROR = 1 ; static final int INVALID_LEXICAL_STATE = 2 ; static final int LOOP_DETECTED = 3 ; int errorCode ; protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } private static final String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + ", column " + errorColumn + ".  Encountered: " + ( EOFSeen ? "<EOF> " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " (" + ( int ) curChar + "), " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; } public String getMessage ( ) { return super . getMessage ( ) ; } public TokenMgrError ( ) { } public TokenMgrError ( String message , int reason ) { super ( message ) ; errorCode = reason ; } public TokenMgrError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar , int reason ) { this ( LexicalError ( EOFSeen , lexState , errorLine , errorColumn , errorAfter , curChar ) , reason ) ; } } 	0	['6', '3', '0', '2', '19', '15', '2', '0', '4', '1.12', '184', '0', '0', '0.85', '0.5', '1', '1', '28.83333333', '14', '2.8333', '0']
package bsh ; class BSHThrowStatement extends SimpleNode { BSHThrowStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object obj = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( ! ( obj instanceof Exception ) ) throw new EvalError ( "Expression in 'throw' must be Exception type" , this ) ; throw new TargetError ( ( Exception ) obj , this ) ; } } 	0	['2', '2', '0', '7', '7', '1', '1', '6', '1', '2', '30', '0', '0', '0.947368421', '0.625', '1', '1', '14', '1', '0.5', '0']
package bsh ; class BSHTernaryExpression extends SimpleNode { BSHTernaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode cond = ( SimpleNode ) jjtGetChild ( 0 ) , evalTrue = ( SimpleNode ) jjtGetChild ( 1 ) , evalFalse = ( SimpleNode ) jjtGetChild ( 2 ) ; if ( BSHIfStatement . evaluateCondition ( cond , callstack , interpreter ) ) return evalTrue . eval ( callstack , interpreter ) ; else return evalFalse . eval ( callstack , interpreter ) ; } } 	0	['2', '2', '0', '7', '6', '1', '1', '6', '1', '2', '36', '0', '0', '0.947368421', '0.625', '1', '1', '17', '1', '0.5', '0']
package org . gjt . sp . jedit . search ; import gnu . regexp . RE ; import java . io . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class DirectoryListSet extends BufferListSet { public DirectoryListSet ( String directory , String glob , boolean recurse ) { super ( listFiles ( directory , glob , recurse ) ) ; this . directory = directory ; this . glob = glob ; this . recurse = recurse ; } public String getDirectory ( ) { return directory ; } public String getFileFilter ( ) { return glob ; } public boolean isRecursive ( ) { return recurse ; } public String getCode ( ) { return "new DirectoryListSet(\"" + MiscUtilities . charsToEscapes ( directory ) + "\",\"" + MiscUtilities . charsToEscapes ( glob ) + "\"," + recurse + ")" ; } private String directory ; private String glob ; private boolean recurse ; private static Vector listFiles ( String directory , String glob , boolean recurse ) { Log . log ( Log . DEBUG , DirectoryListSet . class , "Searching in " + directory ) ; Vector files = new Vector ( 50 ) ; RE filter ; try { filter = new RE ( MiscUtilities . globToRE ( glob ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , DirectoryListSet . class , e ) ; return files ; } listFiles ( new Vector ( ) , files , new File ( directory ) , filter , recurse ) ; return files ; } private static void listFiles ( Vector stack , Vector files , File directory , RE filter , boolean recurse ) { if ( stack . contains ( directory ) ) { Log . log ( Log . ERROR , DirectoryListSet . class , "Recursion in DirectoryListSet: " + directory . getPath ( ) ) ; return ; } else stack . addElement ( directory ) ; String [ ] _files = directory . list ( ) ; if ( _files == null ) return ; MiscUtilities . quicksort ( _files , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < _files . length ; i ++ ) { String name = _files [ i ] ; File file = new File ( directory , name ) ; if ( file . isDirectory ( ) ) { if ( recurse ) listFiles ( stack , files , file , filter , recurse ) ; } else { if ( ! filter . isMatch ( name ) ) continue ; Log . log ( Log . DEBUG , DirectoryListSet . class , file . getPath ( ) ) ; String canonPath ; try { canonPath = file . getCanonicalPath ( ) ; } catch ( IOException io ) { canonPath = file . getPath ( ) ; } files . addElement ( canonPath ) ; } } } } 	0	['8', '2', '0', '8', '34', '12', '2', '6', '5', '0.714285714', '223', '1', '0', '0.5', '0.291666667', '0', '0', '26.375', '8', '2', '0']
package bsh ; import java . lang . reflect . * ; import java . lang . reflect . InvocationHandler ; import java . io . * ; class XThis extends This { InvocationHandler invocationHandler = new Handler ( ) ; XThis ( NameSpace namespace , Interpreter declaringInterp ) { super ( namespace , declaringInterp ) ; } public String toString ( ) { return "'this' reference (XThis) to Bsh object: " + namespace . name ; } String toStringShowInts ( Class [ ] ints ) { StringBuffer sb = new StringBuffer ( toString ( ) + "\nimplements:" ) ; for ( int i = 0 ; i < ints . length ; i ++ ) sb . append ( " " + ints [ i ] . getName ( ) + ( ( ints . length > 1 ) ? "," : "" ) ) ; return sb . toString ( ) ; } public Object getInterface ( Class clas ) { return Proxy . newProxyInstance ( clas . getClassLoader ( ) , new Class [ ] { clas } , invocationHandler ) ; } class Handler implements InvocationHandler , java . io . Serializable { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws EvalError { Class [ ] sig = Reflect . getTypes ( args ) ; BshMethod bmethod = namespace . getMethod ( method . getName ( ) , sig ) ; if ( bmethod != null ) return Primitive . unwrap ( bmethod . invokeDeclaredMethod ( args , declaringInterpreter , callstack , null ) ) ; bmethod = namespace . getMethod ( "invoke" , new Class [ ] { null , null } ) ; if ( bmethod != null ) return Primitive . unwrap ( bmethod . invokeDeclaredMethod ( new Object [ ] { method . getName ( ) , args } , declaringInterpreter , callstack , null ) ) ; if ( method . getName ( ) . equals ( "toString" ) ) return toStringShowInts ( proxy . getClass ( ) . getInterfaces ( ) ) ; if ( method . getName ( ) . equals ( "hashCode" ) ) return new Integer ( this . hashCode ( ) ) ; if ( method . getName ( ) . equals ( "equals" ) ) { Object obj = args [ 0 ] ; return new Boolean ( proxy == obj ) ; } throw new EvalError ( "Bsh script method: " + method . getName ( ) + " not found in namespace: " + namespace . name ) ; } } ; private synchronized void writeObject ( ObjectOutputStream s ) throws IOException { NameSpace parent = namespace . getParent ( ) ; Interpreter interpreter = declaringInterpreter ; namespace . prune ( ) ; s . defaultWriteObject ( ) ; namespace . setParent ( parent ) ; declaringInterpreter = interpreter ; } } 	0	['5', '2', '0', '4', '18', '8', '1', '4', '2', '0.75', '106', '0', '0', '0.714285714', '0.333333333', '1', '2', '20', '3', '1.2', '0']
package bsh ; class BSHLiteral extends SimpleNode { public Object value ; BSHLiteral ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { if ( value == null ) throw new InterpreterError ( "Null in bsh literal: " + value ) ; return value ; } private char getEscapeChar ( char ch ) { switch ( ch ) { case 'b' : ch = '\b' ; break ; case 't' : ch = '\t' ; break ; case 'n' : ch = '\n' ; break ; case 'f' : ch = '\f' ; break ; case 'r' : ch = '\r' ; break ; case '"' : case '\'' : case '\\' : break ; } return ch ; } public void charSetup ( String str ) { char ch = str . charAt ( 0 ) ; if ( ch == '\\' ) { ch = str . charAt ( 1 ) ; if ( Character . isDigit ( ch ) ) ch = ( char ) Integer . parseInt ( str . substring ( 1 ) , 8 ) ; else ch = getEscapeChar ( ch ) ; } value = new Primitive ( new Character ( ch ) ) ; } void stringSetup ( String str ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == '\\' ) { ch = str . charAt ( ++ i ) ; if ( Character . isDigit ( ch ) ) { int endPos = i ; while ( endPos < i + 2 ) { if ( Character . isDigit ( str . charAt ( endPos + 1 ) ) ) endPos ++ ; else break ; } ch = ( char ) Integer . parseInt ( str . substring ( i , endPos + 1 ) , 8 ) ; i = endPos ; } else ch = getEscapeChar ( ch ) ; } buffer . append ( ch ) ; } value = buffer . toString ( ) ; } } 	0	['5', '2', '0', '7', '20', '4', '1', '6', '2', '0.5', '153', '0', '0', '0.818181818', '0.366666667', '0', '0', '29.4', '10', '4', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . FontSelector ; import org . gjt . sp . jedit . * ; public class TextAreaOptionPane extends AbstractOptionPane { public TextAreaOptionPane ( ) { super ( "textarea" ) ; } public void _init ( ) { String _fontFamily = jEdit . getProperty ( "view.font" ) ; int _fontStyle ; try { _fontStyle = Integer . parseInt ( jEdit . getProperty ( "view.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { _fontStyle = Font . PLAIN ; } int _fontSize ; try { _fontSize = Integer . parseInt ( jEdit . getProperty ( "view.fontsize" ) ) ; } catch ( NumberFormatException nf ) { _fontSize = 14 ; } font = new FontSelector ( new Font ( _fontFamily , _fontStyle , _fontSize ) ) ; addComponent ( jEdit . getProperty ( "options.textarea.font" ) , font ) ; lineHighlight = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".lineHighlight" ) ) ; lineHighlight . setSelected ( jEdit . getBooleanProperty ( "view.lineHighlight" ) ) ; addComponent ( lineHighlight ) ; bracketHighlight = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".bracketHighlight" ) ) ; bracketHighlight . setSelected ( jEdit . getBooleanProperty ( "view.bracketHighlight" ) ) ; addComponent ( bracketHighlight ) ; eolMarkers = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".eolMarkers" ) ) ; eolMarkers . setSelected ( jEdit . getBooleanProperty ( "view.eolMarkers" ) ) ; addComponent ( eolMarkers ) ; wrapGuide = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".wrapGuide" ) ) ; wrapGuide . setSelected ( jEdit . getBooleanProperty ( "view.wrapGuide" ) ) ; addComponent ( wrapGuide ) ; blinkCaret = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".blinkCaret" ) ) ; blinkCaret . setSelected ( jEdit . getBooleanProperty ( "view.caretBlink" ) ) ; addComponent ( blinkCaret ) ; blockCaret = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".blockCaret" ) ) ; blockCaret . setSelected ( jEdit . getBooleanProperty ( "view.blockCaret" ) ) ; addComponent ( blockCaret ) ; electricBorders = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".electricBorders" ) ) ; electricBorders . setSelected ( ! "0" . equals ( jEdit . getProperty ( "view.electricBorders" ) ) ) ; addComponent ( electricBorders ) ; homeEnd = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".homeEnd" ) ) ; homeEnd . setSelected ( jEdit . getBooleanProperty ( "view.homeEnd" ) ) ; addComponent ( homeEnd ) ; middleMousePaste = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".middleMousePaste" ) ) ; middleMousePaste . setSelected ( jEdit . getBooleanProperty ( "view.middleMousePaste" ) ) ; addComponent ( middleMousePaste ) ; antiAlias = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".antiAlias" ) ) ; antiAlias . setSelected ( jEdit . getBooleanProperty ( "view.antiAlias" ) ) ; fracFontMetrics = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".fracFontMetrics" ) ) ; fracFontMetrics . setSelected ( jEdit . getBooleanProperty ( "view.fracFontMetrics" ) ) ; if ( System . getProperty ( "java.version" ) . compareTo ( "1.2" ) >= 0 ) { addComponent ( antiAlias ) ; addComponent ( fracFontMetrics ) ; } } public void _save ( ) { Font _font = font . getFont ( ) ; jEdit . setProperty ( "view.font" , _font . getFamily ( ) ) ; jEdit . setProperty ( "view.fontsize" , String . valueOf ( _font . getSize ( ) ) ) ; jEdit . setProperty ( "view.fontstyle" , String . valueOf ( _font . getStyle ( ) ) ) ; jEdit . setBooleanProperty ( "view.lineHighlight" , lineHighlight . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.bracketHighlight" , bracketHighlight . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.eolMarkers" , eolMarkers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.wrapGuide" , wrapGuide . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.caretBlink" , blinkCaret . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.blockCaret" , blockCaret . isSelected ( ) ) ; jEdit . setProperty ( "view.electricBorders" , electricBorders . isSelected ( ) ? "3" : "0" ) ; jEdit . setBooleanProperty ( "view.homeEnd" , homeEnd . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.middleMousePaste" , middleMousePaste . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.antiAlias" , antiAlias . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.fracFontMetrics" , fracFontMetrics . isSelected ( ) ) ; } private FontSelector font ; private JCheckBox lineHighlight ; private JCheckBox bracketHighlight ; private JCheckBox eolMarkers ; private JCheckBox wrapGuide ; private JCheckBox blinkCaret ; private JCheckBox blockCaret ; private JCheckBox electricBorders ; private JCheckBox homeEnd ; private JCheckBox middleMousePaste ; private JCheckBox antiAlias ; private JCheckBox fracFontMetrics ; } 	0	['3', '6', '0', '4', '24', '1', '1', '3', '3', '0.5', '321', '1', '1', '0.996987952', '1', '2', '4', '102', '3', '1.6667', '0']
package gnu . regexp ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . IOException ; class CharIndexedReader implements CharIndexed { private static final int BUFFER_INCREMENT = 1024 ; private static final int UNKNOWN = Integer . MAX_VALUE ; private final BufferedReader br ; private int index = - 1 ; private int bufsize = BUFFER_INCREMENT ; private int end = UNKNOWN ; private char cached = OUT_OF_BOUNDS ; private char [ ] lookBehind = new char [ ] { OUT_OF_BOUNDS , OUT_OF_BOUNDS } ; CharIndexedReader ( Reader reader , int index ) { if ( reader instanceof BufferedReader ) { br = ( BufferedReader ) reader ; } else { br = new BufferedReader ( reader , BUFFER_INCREMENT ) ; } next ( ) ; if ( index > 0 ) move ( index ) ; } private boolean next ( ) { lookBehind [ 1 ] = lookBehind [ 0 ] ; lookBehind [ 0 ] = cached ; if ( end == 1 ) { cached = OUT_OF_BOUNDS ; return false ; } end -- ; try { if ( index != - 1 ) { br . reset ( ) ; } int i = br . read ( ) ; br . mark ( bufsize ) ; if ( i == - 1 ) { end = 1 ; cached = OUT_OF_BOUNDS ; return false ; } cached = ( char ) i ; index = 1 ; } catch ( IOException e ) { e . printStackTrace ( ) ; cached = OUT_OF_BOUNDS ; return false ; } return true ; } public char charAt ( int index ) { if ( index == 0 ) { return cached ; } else if ( index >= end ) { return OUT_OF_BOUNDS ; } else if ( index >= bufsize ) { try { while ( bufsize <= index ) bufsize += BUFFER_INCREMENT ; br . reset ( ) ; br . mark ( bufsize ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } else if ( this . index != index ) { try { br . reset ( ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } else if ( index == - 1 ) { return lookBehind [ 0 ] ; } else if ( index == - 2 ) { return lookBehind [ 1 ] ; } else if ( index < - 2 ) { return OUT_OF_BOUNDS ; } char ch = OUT_OF_BOUNDS ; try { int i = br . read ( ) ; this . index = index + 1 ; if ( i == - 1 ) { end = index ; return ch ; } ch = ( char ) i ; } catch ( IOException ie ) { } return ch ; } public boolean move ( int index ) { boolean retval = true ; while ( retval && ( index -- > 0 ) ) retval = next ( ) ; return retval ; } public boolean isValid ( ) { return ( cached != OUT_OF_BOUNDS ) ; } } 	0	['5', '1', '0', '3', '12', '0', '2', '1', '3', '0.46875', '269', '1', '0', '0', '0.6', '0', '0', '51.2', '10', '3.8', '0']
package org . gjt . sp . util ; import javax . swing . text . * ; import java . io . * ; import java . util . StringTokenizer ; public class Log { public static final int MAXLINES = 500 ; public static final int DEBUG = 1 ; public static final int MESSAGE = 3 ; public static final int NOTICE = 5 ; public static final int WARNING = 7 ; public static final int ERROR = 9 ; public static void init ( boolean stdio , int level ) { if ( stdio ) { if ( System . out == realOut && System . err == realErr ) { System . setOut ( createPrintStream ( NOTICE , null ) ) ; System . setErr ( createPrintStream ( ERROR , null ) ) ; } } Log . level = level ; Log . stream = stream ; log ( MESSAGE , Log . class , "When reporting bugs, please" + " include the following information:" ) ; String [ ] props = { "java.version" , "java.vendor" , "java.compiler" , "os.name" , "os.version" , "os.arch" , "user.home" , "java.class.path" , } ; for ( int i = 0 ; i < props . length ; i ++ ) { log ( MESSAGE , Log . class , props [ i ] + "=" + System . getProperty ( props [ i ] ) ) ; } } public static void setLogWriter ( Writer stream ) { if ( Log . stream == null && stream != null ) { try { stream . write ( logDocument . getText ( 0 , logDocument . getLength ( ) ) ) ; stream . flush ( ) ; } catch ( Exception e ) { } } Log . stream = stream ; } public static Document getLogDocument ( ) { return logDocument ; } public static void flushStream ( ) { if ( stream != null ) { try { stream . flush ( ) ; } catch ( IOException io ) { io . printStackTrace ( realErr ) ; } } } public static void closeStream ( ) { if ( stream != null ) { try { stream . close ( ) ; stream = null ; } catch ( IOException io ) { io . printStackTrace ( realErr ) ; } } } public static void log ( int urgency , Object source , Object message ) { String _source ; if ( source == null ) { _source = Thread . currentThread ( ) . getName ( ) ; if ( _source == null ) { _source = Thread . currentThread ( ) . getClass ( ) . getName ( ) ; } } else if ( source instanceof Class ) _source = ( ( Class ) source ) . getName ( ) ; else _source = source . getClass ( ) . getName ( ) ; int index = _source . lastIndexOf ( '.' ) ; if ( index != - 1 ) _source = _source . substring ( index + 1 ) ; if ( message instanceof Throwable ) { _logException ( urgency , source , ( Throwable ) message ) ; } else { String _message = String . valueOf ( message ) ; synchronized ( LOCK ) { StringTokenizer st = new StringTokenizer ( _message , "\r\n" ) ; while ( st . hasMoreTokens ( ) ) { _log ( urgency , _source , st . nextToken ( ) ) ; } } } } private static Object LOCK = new Object ( ) ; private static Document logDocument ; private static int level ; private static Writer stream ; private static String lineSep ; private static PrintStream realOut ; private static PrintStream realErr ; static { level = WARNING ; realOut = System . out ; realErr = System . err ; logDocument = new PlainDocument ( ) ; lineSep = System . getProperty ( "line.separator" ) ; } private static PrintStream createPrintStream ( final int urgency , final Object source ) { return new PrintStream ( new OutputStream ( ) { public void write ( int b ) { byte [ ] barray = { ( byte ) b } ; write ( barray , 0 , 1 ) ; } public void write ( byte [ ] b , int off , int len ) { String str = new String ( b , off , len ) ; log ( urgency , source , str ) ; } } ) ; } private static void _logException ( final int urgency , final Object source , final Throwable message ) { PrintStream out = createPrintStream ( urgency , source ) ; synchronized ( LOCK ) { message . printStackTrace ( out ) ; } } private static void _log ( int urgency , String source , String message ) { String urgencyString = "[" + urgencyToString ( urgency ) + "] " ; String fullMessage = urgencyString + source + ": " + message ; try { logDocument . insertString ( logDocument . getLength ( ) , fullMessage , null ) ; logDocument . insertString ( logDocument . getLength ( ) , "\n" , null ) ; Element map = logDocument . getDefaultRootElement ( ) ; int lines = map . getElementCount ( ) ; if ( lines > MAXLINES ) { Element first = map . getElement ( 0 ) ; Element last = map . getElement ( lines - MAXLINES ) ; logDocument . remove ( first . getStartOffset ( ) , last . getEndOffset ( ) ) ; } if ( stream != null ) { stream . write ( fullMessage ) ; stream . write ( lineSep ) ; } } catch ( Exception e ) { e . printStackTrace ( realErr ) ; } message = urgencyString + message + '\n' ; if ( urgency >= level ) { if ( urgency == ERROR ) realErr . print ( message ) ; else realOut . print ( message ) ; } } private static String urgencyToString ( int urgency ) { switch ( urgency ) { case DEBUG : return "debug" ; case MESSAGE : return "message" ; case NOTICE : return "notice" ; case WARNING : return "warning" ; case ERROR : return "error" ; } throw new IllegalArgumentException ( "Invalid urgency: " + urgency ) ; } } 	0	['13', '1', '0', '64', '55', '36', '64', '1', '7', '0.886904762', '433', '0.571428571', '0', '0', '0.178571429', '0', '0', '31.23076923', '7', '2.3077', '0']
package bsh ; public class EvalError extends Exception { SimpleNode node ; public EvalError ( String s ) { super ( s ) ; } public EvalError ( String s , SimpleNode node ) { super ( s ) ; this . node = node ; } public String toString ( ) { String trace ; if ( node != null ) trace = " : at Line: " + node . getLineNumber ( ) + " : in file: " + node . getSourceFile ( ) + " : " + node . getText ( ) ; else trace = ": <at unknown location>" ; return getMessage ( ) + trace ; } public void reThrow ( String msg ) throws EvalError { reThrow ( msg , null ) ; } public void reThrow ( SimpleNode node ) throws EvalError { reThrow ( null , node ) ; } public void reThrow ( String addMsg , SimpleNode addNode ) throws EvalError { String msg = getMessage ( ) ; if ( addMsg != null ) msg = addMsg + " : " + msg ; SimpleNode node = this . node ; if ( node == null && addNode != null ) node = addNode ; throw new EvalError ( msg , node ) ; } void setNode ( SimpleNode node ) { this . node = node ; } SimpleNode getNode ( ) { return node ; } public String getErrorText ( ) { if ( node != null ) return node . getText ( ) ; else return "<unknown error>" ; } public int getErrorLineNumber ( ) { if ( node != null ) return node . getLineNumber ( ) ; else return - 1 ; } public String getErrorSourceFile ( ) { if ( node != null ) return node . getSourceFile ( ) ; else return "<unknown file>" ; } } 	0	['11', '3', '2', '51', '20', '0', '51', '1', '9', '0.1', '137', '0', '1', '0.653846154', '0.575757576', '1', '1', '11.36363636', '2', '1.1818', '0']
package org . gjt . sp . jedit . syntax ; import javax . swing . text . Segment ; import org . gjt . sp . jedit . TextUtilities ; public class KeywordMap { public KeywordMap ( boolean ignoreCase ) { this ( ignoreCase , 52 ) ; this . ignoreCase = ignoreCase ; } public KeywordMap ( boolean ignoreCase , int mapLength ) { this . mapLength = mapLength ; this . ignoreCase = ignoreCase ; map = new Keyword [ mapLength ] ; } public byte lookup ( Segment text , int offset , int length ) { if ( length == 0 ) return Token . NULL ; Keyword k = map [ getSegmentMapKey ( text , offset , length ) ] ; while ( k != null ) { if ( length != k . keyword . length ) { k = k . next ; continue ; } if ( TextUtilities . regionMatches ( ignoreCase , text , offset , k . keyword ) ) return k . id ; k = k . next ; } return Token . NULL ; } public void add ( String keyword , byte id ) { int key = getStringMapKey ( keyword ) ; map [ key ] = new Keyword ( keyword . toCharArray ( ) , id , map [ key ] ) ; } public boolean getIgnoreCase ( ) { return ignoreCase ; } public void setIgnoreCase ( boolean ignoreCase ) { this . ignoreCase = ignoreCase ; } protected int mapLength ; protected int getStringMapKey ( String s ) { return ( Character . toUpperCase ( s . charAt ( 0 ) ) + Character . toUpperCase ( s . charAt ( s . length ( ) - 1 ) ) ) % mapLength ; } protected int getSegmentMapKey ( Segment s , int off , int len ) { return ( Character . toUpperCase ( s . array [ off ] ) + Character . toUpperCase ( s . array [ off + len - 1 ] ) ) % mapLength ; } class Keyword { public Keyword ( char [ ] keyword , byte id , Keyword next ) { this . keyword = keyword ; this . id = id ; this . next = next ; } public char [ ] keyword ; public byte id ; public Keyword next ; } private Keyword [ ] map ; private boolean ignoreCase ; } 	0	['8', '1', '0', '5', '15', '0', '4', '2', '6', '0.428571429', '139', '1', '1', '0', '0.395833333', '0', '0', '16', '5', '1.375', '0']
package org . gjt . sp . jedit . browser ; import java . awt . * ; import java . awt . event . * ; import java . util . * ; import javax . swing . * ; import javax . swing . event . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . search . * ; import org . gjt . sp . jedit . * ; public class BrowserPopupMenu extends JPopupMenu { public BrowserPopupMenu ( VFSBrowser browser , VFS . DirectoryEntry file ) { this . browser = browser ; if ( file != null ) { this . file = file ; this . vfs = VFSManager . getVFSForPath ( file . path ) ; boolean delete = ( vfs . getCapabilities ( ) & VFS . DELETE_CAP ) != 0 ; boolean rename = ( vfs . getCapabilities ( ) & VFS . RENAME_CAP ) != 0 ; if ( jEdit . getBuffer ( file . path ) != null ) { if ( browser . getMode ( ) == VFSBrowser . BROWSER ) { add ( createMenuItem ( "open" ) ) ; add ( createMenuItem ( "insert" ) ) ; add ( createMenuItem ( "close" ) ) ; } else add ( createMenuItem ( "choose" ) ) ; } else { if ( file . type == VFS . DirectoryEntry . DIRECTORY || file . type == VFS . DirectoryEntry . FILESYSTEM ) { add ( createMenuItem ( "browse" ) ) ; } else if ( browser . getMode ( ) != VFSBrowser . BROWSER ) { add ( createMenuItem ( "choose" ) ) ; } else { add ( createMenuItem ( "open" ) ) ; add ( createOpenEncodingMenu ( ) ) ; add ( createMenuItem ( "insert" ) ) ; } if ( rename ) add ( createMenuItem ( "rename" ) ) ; if ( delete ) add ( createMenuItem ( "delete" ) ) ; } addSeparator ( ) ; } else vfs = VFSManager . getVFSForPath ( browser . getDirectory ( ) ) ; JCheckBoxMenuItem showHiddenFiles = new JCheckBoxMenuItem ( jEdit . getProperty ( "vfs.browser.menu.show-hidden-files.label" ) ) ; showHiddenFiles . setActionCommand ( "show-hidden-files" ) ; showHiddenFiles . setSelected ( browser . getShowHiddenFiles ( ) ) ; showHiddenFiles . addActionListener ( new ActionHandler ( ) ) ; add ( showHiddenFiles ) ; addSeparator ( ) ; add ( createMenuItem ( "new-file" ) ) ; add ( createMenuItem ( "new-directory" ) ) ; addSeparator ( ) ; if ( browser . getMode ( ) == VFSBrowser . BROWSER && vfs instanceof FileVFS ) { add ( createMenuItem ( "search-in-directory" ) ) ; addSeparator ( ) ; } add ( createMenuItem ( "add-to-favorites" ) ) ; add ( createMenuItem ( "go-to-favorites" ) ) ; Vector vec = new Vector ( ) ; Enumeration enum = VFSManager . getFilesystems ( ) ; while ( enum . hasMoreElements ( ) ) { VFS vfs = ( VFS ) enum . nextElement ( ) ; if ( ( vfs . getCapabilities ( ) & VFS . BROWSE_CAP ) == 0 ) continue ; JMenuItem menuItem = new JMenuItem ( jEdit . getProperty ( "vfs." + vfs . getName ( ) + ".label" ) ) ; menuItem . setActionCommand ( "vfs." + vfs . getName ( ) ) ; menuItem . addActionListener ( new ActionHandler ( ) ) ; vec . addElement ( menuItem ) ; } if ( vec . size ( ) != 0 ) { addSeparator ( ) ; MiscUtilities . quicksort ( vec , new MiscUtilities . MenuItemCompare ( ) ) ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) add ( ( JMenuItem ) vec . elementAt ( i ) ) ; } } private VFSBrowser browser ; private VFS . DirectoryEntry file ; private VFS vfs ; private JMenuItem createMenuItem ( String name ) { String label = jEdit . getProperty ( "vfs.browser.menu." + name + ".label" ) ; JMenuItem mi = new JMenuItem ( label ) ; mi . setActionCommand ( name ) ; mi . addActionListener ( new ActionHandler ( ) ) ; return mi ; } private JMenu createOpenEncodingMenu ( ) { ActionListener listener = new ActionHandler ( ) ; JMenu openEncoding = new JMenu ( jEdit . getProperty ( "open-encoding.label" ) ) ; String systemEncoding = System . getProperty ( "file.encoding" ) ; JMenuItem mi = new JMenuItem ( jEdit . getProperty ( "os-encoding" ) ) ; mi . setActionCommand ( "open@" + systemEncoding ) ; mi . addActionListener ( listener ) ; openEncoding . add ( mi ) ; mi = new JMenuItem ( jEdit . getProperty ( "jedit-encoding" ) ) ; mi . setActionCommand ( "open@" + jEdit . getProperty ( "buffer.encoding" , systemEncoding ) ) ; mi . addActionListener ( listener ) ; openEncoding . add ( mi ) ; openEncoding . addSeparator ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { String encoding = st . nextToken ( ) ; mi = new JMenuItem ( encoding ) ; mi . setActionCommand ( "open@" + encoding ) ; mi . addActionListener ( listener ) ; openEncoding . add ( mi ) ; } openEncoding . addSeparator ( ) ; mi = new JMenuItem ( jEdit . getProperty ( "other-encoding.label" ) ) ; mi . setActionCommand ( "other-encoding" ) ; mi . addActionListener ( listener ) ; openEncoding . add ( mi ) ; return openEncoding ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { View view = browser . getView ( ) ; String actionCommand = evt . getActionCommand ( ) ; if ( actionCommand . startsWith ( "open@" ) ) { Hashtable props = new Hashtable ( ) ; props . put ( Buffer . ENCODING , actionCommand . substring ( 5 ) ) ; jEdit . openFile ( view , null , file . path , false , props ) ; } else if ( actionCommand . equals ( "other-encoding" ) ) { String encoding = GUIUtilities . input ( browser , "encoding-prompt" , null , jEdit . getProperty ( "buffer.encoding" , System . getProperty ( "file.encoding" ) ) ) ; if ( encoding == null ) return ; Hashtable props = new Hashtable ( ) ; props . put ( Buffer . ENCODING , encoding ) ; jEdit . openFile ( view , null , file . path , false , props ) ; } else if ( actionCommand . equals ( "open" ) ) jEdit . openFile ( view , file . path ) ; else if ( actionCommand . equals ( "insert" ) ) view . getBuffer ( ) . insert ( view , file . path ) ; else if ( actionCommand . equals ( "choose" ) ) browser . filesActivated ( ) ; else if ( actionCommand . equals ( "close" ) ) { Buffer buffer = jEdit . getBuffer ( file . path ) ; if ( buffer != null ) jEdit . closeBuffer ( view , buffer ) ; } else if ( actionCommand . equals ( "browse" ) ) browser . setDirectory ( file . path ) ; else if ( evt . getActionCommand ( ) . equals ( "rename" ) ) browser . rename ( file . path ) ; else if ( evt . getActionCommand ( ) . equals ( "delete" ) ) browser . delete ( file . deletePath ) ; else if ( actionCommand . equals ( "show-hidden-files" ) ) { browser . setShowHiddenFiles ( ! browser . getShowHiddenFiles ( ) ) ; browser . reloadDirectory ( ) ; } else if ( actionCommand . equals ( "new-file" ) ) { VFS . DirectoryEntry [ ] selected = browser . getSelectedFiles ( ) ; if ( selected . length >= 1 ) { VFS . DirectoryEntry file = selected [ 0 ] ; if ( file . type == VFS . DirectoryEntry . DIRECTORY ) jEdit . newFile ( view , file . path ) ; else { VFS vfs = VFSManager . getVFSForPath ( file . path ) ; jEdit . newFile ( view , vfs . getParentOfPath ( file . path ) ) ; } } else jEdit . newFile ( view , browser . getDirectory ( ) ) ; } else if ( actionCommand . equals ( "new-directory" ) ) browser . mkdir ( ) ; else if ( actionCommand . equals ( "search-in-directory" ) ) { String path ; VFS . DirectoryEntry [ ] selected = browser . getSelectedFiles ( ) ; if ( selected . length >= 1 ) { VFS . DirectoryEntry file = selected [ 0 ] ; if ( file . type == VFS . DirectoryEntry . DIRECTORY ) path = file . path ; else { VFS vfs = VFSManager . getVFSForPath ( file . path ) ; path = vfs . getParentOfPath ( file . path ) ; } } else path = browser . getDirectory ( ) ; SearchAndReplace . setSearchFileSet ( new DirectoryListSet ( path , browser . getFilenameFilter ( ) , true ) ) ; new SearchDialog ( browser . getView ( ) , null , SearchDialog . DIRECTORY ) ; } else if ( actionCommand . equals ( "add-to-favorites" ) ) { Vector toAdd = new Vector ( ) ; VFS . DirectoryEntry [ ] selected = browser . getSelectedFiles ( ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { VFS . DirectoryEntry file = selected [ i ] ; if ( file . type == VFS . DirectoryEntry . FILE ) { GUIUtilities . error ( browser , "vfs.browser.files-favorites" , null ) ; return ; } else toAdd . addElement ( file . path ) ; } if ( toAdd . size ( ) != 0 ) { for ( int i = 0 ; i < toAdd . size ( ) ; i ++ ) { FavoritesVFS . addToFavorites ( ( String ) toAdd . elementAt ( i ) ) ; } } else { String directory = browser . getDirectory ( ) ; if ( directory . equals ( FavoritesVFS . PROTOCOL + ":" ) ) { GUIUtilities . error ( browser , "vfs.browser.recurse-favorites" , null ) ; } else { FavoritesVFS . addToFavorites ( directory ) ; } } } else if ( actionCommand . equals ( "go-to-favorites" ) ) browser . setDirectory ( FavoritesVFS . PROTOCOL + ":" ) ; else if ( actionCommand . startsWith ( "vfs." ) ) { String vfsName = actionCommand . substring ( 4 ) ; VFS vfs = VFSManager . getVFSByName ( vfsName ) ; String directory = vfs . showBrowseDialog ( null , browser ) ; if ( directory != null ) browser . setDirectory ( directory ) ; } } } } 	0	['5', '5', '0', '14', '45', '6', '4', '11', '1', '0.833333333', '458', '1', '3', '0.994436718', '0.32', '0', '0', '90', '3', '1.4', '0']
package bsh ; import java . io . * ; public interface ConsoleInterface { public Reader getIn ( ) ; public PrintStream getOut ( ) ; public PrintStream getErr ( ) ; public void println ( String s ) ; public void print ( String s ) ; public void error ( String s ) ; } 	0	['6', '1', '0', '1', '6', '15', '1', '0', '6', '2', '6', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package bsh ; class BSHBlock extends SimpleNode { BSHBlock ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { return eval ( callstack , interpreter , false ) ; } public Object eval ( CallStack callstack , Interpreter interpreter , boolean overrideNamespace ) throws EvalError { Object ret = Primitive . VOID ; int statements = jjtGetNumChildren ( ) ; NameSpace enclosingNameSpace = null ; if ( ! overrideNamespace ) { enclosingNameSpace = callstack . top ( ) ; BlockNameSpace bodyNameSpace = new BlockNameSpace ( enclosingNameSpace ) ; callstack . swap ( bodyNameSpace ) ; } for ( int i = 0 ; i < statements ; i ++ ) { SimpleNode node = ( ( SimpleNode ) jjtGetChild ( i ) ) ; ret = node . eval ( callstack , interpreter ) ; if ( ret instanceof ReturnControl ) break ; } if ( ! overrideNamespace ) callstack . swap ( enclosingNameSpace ) ; return ret ; } } 	0	['3', '2', '0', '14', '10', '3', '5', '9', '2', '2', '63', '0', '0', '0.9', '0.6', '1', '1', '20', '1', '0.6667', '0']
package bsh ; class BSHFormalParameters extends SimpleNode { int numArgs ; String [ ] argNames ; Class [ ] argTypes ; BSHFormalParameters ( int id ) { super ( id ) ; } public Object eval ( NameSpace namespace ) throws EvalError { numArgs = jjtGetNumChildren ( ) ; argNames = new String [ numArgs ] ; argTypes = new Class [ numArgs ] ; for ( int i = 0 ; i < numArgs ; i ++ ) { BSHFormalParameter param = ( BSHFormalParameter ) jjtGetChild ( i ) ; param . eval ( namespace ) ; argNames [ i ] = param . name ; argTypes [ i ] = param . type ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '9', '6', '1', '3', '6', '1', '1', '54', '0', '0', '0.947368421', '0.666666667', '1', '2', '24.5', '1', '0.5', '0']
package bsh ; import bsh . Capabilities . Unavailable ; public abstract class ReflectManager { private static ReflectManager rfm ; public static ReflectManager getReflectManager ( ) { if ( rfm == null ) { Class clas ; try { clas = BshClassManager . plainClassForName ( "bsh.reflect.ReflectManagerImpl" ) ; rfm = ( ReflectManager ) clas . newInstance ( ) ; } catch ( Exception e ) { throw new Unavailable ( "Reflect Manager unavailable: " + e ) ; } } return rfm ; } public static boolean RMSetAccessible ( Object obj ) throws Unavailable { return getReflectManager ( ) . setAccessible ( obj ) ; } public abstract boolean setAccessible ( Object o ) ; } 	0	['4', '1', '0', '3', '12', '6', '1', '2', '4', '0.666666667', '37', '1', '1', '0', '0.5', '0', '0', '8', '2', '1', '0']
package bsh ; class BSHPrimaryExpression extends SimpleNode { BSHPrimaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object obj = jjtGetChild ( 0 ) ; int n = jjtGetNumChildren ( ) ; for ( int i = 1 ; i < n ; i ++ ) obj = ( ( BSHPrimarySuffix ) jjtGetChild ( i ) ) . doSuffix ( obj , callstack , interpreter ) ; if ( obj instanceof SimpleNode ) if ( obj instanceof BSHAmbiguousName ) obj = ( ( BSHAmbiguousName ) obj ) . toObject ( callstack , interpreter ) ; else obj = ( ( SimpleNode ) obj ) . eval ( callstack , interpreter ) ; return obj ; } } 	0	['2', '2', '0', '8', '8', '1', '1', '7', '1', '2', '50', '0', '0', '0.947368421', '0.625', '1', '1', '24', '1', '0.5', '0']
package org . gjt . sp . jedit . search ; import org . gjt . sp . jedit . * ; public class CurrentBufferSet implements SearchFileSet { public Buffer getFirstBuffer ( View view ) { return view . getBuffer ( ) ; } public Buffer getNextBuffer ( View view , Buffer buffer ) { if ( buffer == null ) return view . getBuffer ( ) ; else return null ; } public void matchFound ( Buffer buffer ) { } public int getBufferCount ( ) { return 1 ; } public String getCode ( ) { return "new CurrentBufferSet()" ; } } 	0	['6', '1', '0', '6', '8', '15', '3', '3', '6', '2', '24', '0', '0', '0', '0.555555556', '0', '0', '3', '2', '1', '0']
package org . gjt . sp . jedit . textarea ; import java . awt . * ; import java . awt . event . MouseEvent ; import java . util . Vector ; import org . gjt . sp . jedit . * ; public class MarkerHighlight implements TextAreaHighlight { public void init ( JEditTextArea textArea , TextAreaHighlight next ) { this . textArea = textArea ; this . next = next ; } public void paintHighlight ( Graphics gfx , int line , int y ) { if ( textArea . getBuffer ( ) . isLoaded ( ) && highlightEnabled ) { Buffer buffer = textArea . getBuffer ( ) ; if ( buffer . getMarkerAtLine ( buffer . virtualToPhysical ( line ) ) != null ) { int firstLine = textArea . getFirstLine ( ) ; line -= firstLine ; FontMetrics fm = textArea . getPainter ( ) . getFontMetrics ( ) ; gfx . setColor ( markerHighlightColor ) ; gfx . fillRect ( 0 , line * fm . getHeight ( ) , textArea . getGutter ( ) . getWidth ( ) , fm . getHeight ( ) ) ; } } if ( next != null ) next . paintHighlight ( gfx , line , y ) ; } public String getToolTipText ( MouseEvent evt ) { if ( textArea . getBuffer ( ) . isLoaded ( ) && highlightEnabled ) { FontMetrics fm = textArea . getPainter ( ) . getFontMetrics ( ) ; int line = textArea . getFirstLine ( ) + evt . getY ( ) / fm . getHeight ( ) ; Buffer buffer = textArea . getBuffer ( ) ; Marker marker = buffer . getMarkerAtLine ( buffer . virtualToPhysical ( line ) ) ; if ( marker != null ) { char shortcut = marker . getShortcut ( ) ; if ( shortcut == '\0' ) return jEdit . getProperty ( "view.gutter.marker.no-name" ) ; else { String [ ] args = { String . valueOf ( shortcut ) } ; return jEdit . getProperty ( "view.gutter.marker" , args ) ; } } } if ( next != null ) return next . getToolTipText ( evt ) ; else return null ; } public Color getMarkerHighlightColor ( ) { return markerHighlightColor ; } public void setMarkerHighlightColor ( Color markerHighlightColor ) { this . markerHighlightColor = markerHighlightColor ; } public boolean isHighlightEnabled ( ) { return highlightEnabled ; } public void setHighlightEnabled ( boolean highlightEnabled ) { this . highlightEnabled = highlightEnabled ; } private JEditTextArea textArea ; private TextAreaHighlight next ; private boolean highlightEnabled ; private Color markerHighlightColor ; } 	0	['8', '1', '0', '8', '28', '6', '1', '7', '8', '0.678571429', '160', '1', '2', '0', '0.234375', '0', '0', '18.5', '6', '2', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; public class EditPaneUpdate extends EBMessage . NonVetoable { public static final Object CREATED = "CREATED" ; public static final Object DESTROYED = "DESTROYED" ; public static final Object BUFFER_CHANGED = "BUFFER_CHANGED" ; public EditPaneUpdate ( EditPane editPane , Object what ) { super ( editPane ) ; if ( what == null ) throw new NullPointerException ( "What must be non-null" ) ; this . what = what ; } public Object getWhat ( ) { return what ; } public EditPane getEditPane ( ) { return ( EditPane ) getSource ( ) ; } public String paramString ( ) { return super . paramString ( ) + ",what=" + what ; } private Object what ; } 	0	['5', '3', '0', '5', '13', '4', '2', '4', '4', '0.875', '50', '0.25', '0', '0.666666667', '0.5', '1', '1', '8.2', '1', '0.6', '0']
package bsh ; class BSHTypedVariableDeclaration extends SimpleNode { public boolean isFinal ; BSHTypedVariableDeclaration ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { try { NameSpace namespace = callstack . top ( ) ; BSHType typeNode = ( ( BSHType ) jjtGetChild ( 0 ) ) ; Class type = typeNode . getType ( namespace ) ; int n = jjtGetNumChildren ( ) ; for ( int i = 1 ; i < n ; i ++ ) { BSHVariableDeclarator dec = ( BSHVariableDeclarator ) jjtGetChild ( i ) ; Object value = dec . eval ( typeNode , callstack , interpreter ) ; if ( value == Primitive . VOID ) value = null ; else if ( value == Primitive . NULL ) { } else if ( canCastToDeclaredType ( value , type ) ) value = BSHCastExpression . castObject ( value , type ) ; else { } namespace . setTypedVariable ( dec . name , type , value , isFinal ) ; } } catch ( EvalError e ) { e . reThrow ( "Typed variable declaration" , this ) ; } return Primitive . VOID ; } boolean canCastToDeclaredType ( Object value , Class toType ) { if ( ! ( value instanceof Primitive ) ) return false ; Class fromType = ( ( Primitive ) value ) . getType ( ) ; if ( ( toType == Byte . TYPE || toType == Short . TYPE || toType == Character . TYPE ) && fromType == Integer . TYPE ) return true ; else return false ; } } 	0	['3', '2', '0', '11', '13', '3', '1', '10', '1', '1', '101', '0', '0', '0.9', '0.444444444', '1', '1', '32.33333333', '6', '2.3333', '0']
package org . gjt . sp . jedit ; import javax . swing . JPopupMenu ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . Component ; import java . util . EventObject ; import org . gjt . sp . util . Log ; public abstract class EditAction { public EditAction ( String name ) { this ( name , true ) ; } EditAction ( String name , boolean plugin ) { this . name = name ; this . plugin = plugin ; } public final String getName ( ) { return name ; } public boolean isPluginAction ( ) { return plugin ; } public void invoke ( View view ) { ActionEvent evt = new ActionEvent ( view , ActionEvent . ACTION_PERFORMED , null ) ; actionPerformed ( evt ) ; } public void actionPerformed ( ActionEvent evt ) { } public static View getView ( EventObject evt ) { if ( evt != null ) { Object o = evt . getSource ( ) ; if ( o instanceof Component ) return getView ( ( Component ) o ) ; } return null ; } public static Buffer getBuffer ( EventObject evt ) { View view = getView ( evt ) ; if ( view != null ) return view . getBuffer ( ) ; return null ; } public static View getView ( Component comp ) { for ( ; ; ) { if ( comp instanceof View ) return ( View ) comp ; else if ( comp instanceof JPopupMenu ) comp = ( ( JPopupMenu ) comp ) . getInvoker ( ) ; else if ( comp != null ) comp = comp . getParent ( ) ; else break ; } return null ; } public boolean isToggle ( ) { return false ; } public boolean isSelected ( View view ) { return isSelected ( ( Component ) view ) ; } public boolean isSelected ( Component comp ) { return false ; } public boolean noRepeat ( ) { return false ; } public boolean noRecord ( ) { return false ; } public String getCode ( ) { return "view.getInputHandler().invokeAction(" + "jEdit.getAction(\"" + name + "\"))" ; } public String toString ( ) { return name ; } private String name ; private boolean plugin ; public static class Wrapper implements ActionListener { public Wrapper ( EditAction action ) { this . action = action ; } public void actionPerformed ( ActionEvent evt ) { EditAction . getView ( evt ) . getInputHandler ( ) . invokeAction ( action ) ; } private EditAction action ; } } 	0	['16', '1', '2', '23', '25', '106', '21', '2', '15', '0.8', '128', '1', '0', '0', '0.205357143', '0', '0', '6.875', '3', '1.1875', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . msg . MacrosChanged ; import org . gjt . sp . jedit . * ; public class MacrosMenu extends EnhancedMenu implements EBComponent { public MacrosMenu ( ) { super ( "macros" ) ; updateMacrosMenu ( ) ; } public void addNotify ( ) { super . addNotify ( ) ; EditBus . addToBus ( this ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; EditBus . removeFromBus ( this ) ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof MacrosChanged ) updateMacrosMenu ( ) ; } private void updateMacrosMenu ( ) { for ( int i = getMenuComponentCount ( ) - 1 ; i >= 0 ; i -- ) { if ( getMenuComponent ( i ) instanceof JSeparator ) break ; else remove ( i ) ; } int count = getMenuComponentCount ( ) ; Vector macroVector = Macros . getMacroHierarchy ( ) ; createMacrosMenu ( this , macroVector , 0 ) ; if ( count == getMenuComponentCount ( ) ) add ( GUIUtilities . loadMenuItem ( "no-macros" ) ) ; } private void createMacrosMenu ( JMenu menu , Vector vector , int start ) { for ( int i = start ; i < vector . size ( ) ; i ++ ) { Object obj = vector . elementAt ( i ) ; if ( obj instanceof Macros . Macro ) { Macros . Macro macro = ( Macros . Macro ) obj ; String label = macro . name ; int index = label . lastIndexOf ( '/' ) ; label = label . substring ( index + 1 ) . replace ( '_' , ' ' ) ; menu . add ( new EnhancedMenuItem ( label , macro . action ) ) ; } else if ( obj instanceof Vector ) { Vector subvector = ( Vector ) obj ; String name = ( String ) subvector . elementAt ( 0 ) ; JMenu submenu = new JMenu ( name ) ; createMacrosMenu ( submenu , subvector , 1 ) ; if ( submenu . getMenuComponentCount ( ) == 0 ) { submenu . add ( GUIUtilities . loadMenuItem ( "no-macros" ) ) ; } menu . add ( submenu ) ; } } } } 	0	['6', '8', '0', '10', '24', '15', '1', '10', '4', '2', '144', '0', '0', '0.994206257', '0.333333333', '1', '7', '23', '5', '2.1667', '0']
package org . gjt . sp . jedit . textarea ; import java . awt . Graphics ; import java . awt . event . MouseEvent ; public interface TextAreaHighlight { void init ( JEditTextArea textArea , TextAreaHighlight next ) ; void paintHighlight ( Graphics gfx , int line , int y ) ; String getToolTipText ( MouseEvent evt ) ; } 	0	['3', '1', '0', '5', '3', '3', '4', '1', '3', '2', '3', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit ; import java . util . Vector ; import org . gjt . sp . jedit . gui . OptionsDialog ; public abstract class EBPlugin extends EditPlugin implements EBComponent { public void handleMessage ( EBMessage message ) { } protected EBPlugin ( ) { EditBus . addToBus ( this ) ; } } 	0	['2', '2', '0', '4', '3', '1', '1', '3', '1', '2', '6', '0', '0', '0.9', '0.75', '0', '0', '2', '1', '0.5', '0']
package gnu . regexp ; class RETokenStart extends REToken { private String newline ; RETokenStart ( int subIndex , String newline ) { super ( subIndex ) ; this . newline = newline ; } boolean match ( CharIndexed input , REMatch mymatch ) { if ( newline != null ) { int len = newline . length ( ) ; if ( mymatch . offset >= len ) { boolean found = true ; char z ; int i = 0 ; char ch = input . charAt ( mymatch . index - len ) ; do { z = newline . charAt ( i ) ; if ( ch != z ) { found = false ; break ; } ++ i ; ch = input . charAt ( mymatch . index - len + i ) ; } while ( i < len ) ; if ( found ) return next ( input , mymatch ) ; } } if ( ( mymatch . eflags & RE . REG_NOTBOL ) > 0 ) return false ; if ( ( mymatch . eflags & RE . REG_ANCHORINDEX ) > 0 ) return ( mymatch . anchor == mymatch . offset ) ? next ( input , mymatch ) : false ; else return ( ( mymatch . index == 0 ) && ( mymatch . offset == 0 ) ) ? next ( input , mymatch ) : false ; } void dump ( StringBuffer os ) { os . append ( '^' ) ; } } 	0	['3', '2', '0', '4', '9', '1', '1', '3', '0', '0.5', '106', '1', '0', '0.777777778', '0.444444444', '1', '2', '34', '11', '4', '0']
package org . gjt . sp . jedit . textarea ; import java . awt . font . * ; import java . awt . * ; import java . util . Hashtable ; class TextRenderer2D extends TextRenderer { public void setupGraphics ( Graphics g ) { ( ( Graphics2D ) g ) . setRenderingHints ( renderingHints ) ; } public void configure ( boolean antiAlias , boolean fracFontMetrics ) { Hashtable hints = new Hashtable ( ) ; if ( antiAlias ) { hints . put ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; hints . put ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; hints . put ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; hints . put ( RenderingHints . KEY_FRACTIONALMETRICS , fracFontMetrics ? RenderingHints . VALUE_FRACTIONALMETRICS_ON : RenderingHints . VALUE_FRACTIONALMETRICS_OFF ) ; } else hints . put ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_OFF ) ; renderingHints = new RenderingHints ( hints ) ; fontRenderContext = new FontRenderContext ( null , antiAlias , fracFontMetrics ) ; } float _drawChars ( char [ ] text , int start , int len , Graphics _g , float x , float y ) { Graphics2D g = ( Graphics2D ) _g ; Font font = g . getFont ( ) ; fontRenderContext = g . getFontRenderContext ( ) ; GlyphVector glyphs = font . createGlyphVector ( fontRenderContext , new String ( text , start , len ) ) ; ( ( Graphics2D ) g ) . drawGlyphVector ( glyphs , x , y ) ; return ( float ) glyphs . getLogicalBounds ( ) . getWidth ( ) ; } float _getWidth ( char [ ] text , int start , int len , Font font ) { GlyphVector glyphs = font . createGlyphVector ( fontRenderContext , new String ( text , start , len ) ) ; return ( float ) glyphs . getLogicalBounds ( ) . getWidth ( ) ; } int _xToOffset ( char [ ] text , int start , int len , Font font , float x , boolean round ) { TextLayout layout = new TextLayout ( new String ( text , start , len ) , font , fontRenderContext ) ; TextHitInfo info = layout . hitTestChar ( x , 0 ) ; return ( round ? info . getInsertionIndex ( ) : info . getCharIndex ( ) ) ; } private RenderingHints renderingHints ; private FontRenderContext fontRenderContext ; } 	0	['6', '2', '0', '1', '23', '1', '0', '1', '2', '0.6', '141', '1', '0', '0.6875', '0.476190476', '1', '2', '22.16666667', '3', '1.3333', '0']
package gnu . regexp ; public interface CharIndexed { public static final char OUT_OF_BOUNDS = '￿' ; public char charAt ( int index ) ; public boolean move ( int index ) ; public boolean isValid ( ) ; } 	0	['3', '1', '0', '24', '3', '3', '24', '0', '3', '1.5', '4', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '0']
package bsh ; public class InterpreterError extends RuntimeException { public InterpreterError ( String s ) { super ( s ) ; } } 	0	['1', '4', '0', '16', '2', '0', '16', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . io . * ; import java . util . * ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . MiscUtilities ; import org . gjt . sp . util . Log ; public class HistoryModel { public HistoryModel ( String name ) { this . name = name ; try { max = Integer . parseInt ( jEdit . getProperty ( "history" ) ) ; } catch ( NumberFormatException nf ) { max = 25 ; } data = new Vector ( max ) ; } public void addItem ( String text ) { if ( text == null || text . length ( ) == 0 ) return ; int index = data . indexOf ( text ) ; if ( index != - 1 ) data . removeElementAt ( index ) ; data . insertElementAt ( text , 0 ) ; if ( getSize ( ) > max ) data . removeElementAt ( getSize ( ) - 1 ) ; } public String getItem ( int index ) { return ( String ) data . elementAt ( index ) ; } public int getSize ( ) { return data . size ( ) ; } public String getName ( ) { return name ; } public static HistoryModel getModel ( String name ) { if ( models == null ) models = new Hashtable ( ) ; HistoryModel model = ( HistoryModel ) models . get ( name ) ; if ( model == null ) { model = new HistoryModel ( name ) ; models . put ( name , model ) ; } return model ; } public static void loadHistory ( File file ) { if ( models == null ) models = new Hashtable ( ) ; try { BufferedReader in = new BufferedReader ( new FileReader ( file ) ) ; HistoryModel currentModel = null ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "[" ) && line . endsWith ( "]" ) ) { if ( currentModel != null ) { models . put ( currentModel . getName ( ) , currentModel ) ; } currentModel = new HistoryModel ( line . substring ( 1 , line . length ( ) - 1 ) ) ; } else if ( currentModel == null ) { throw new IOException ( "History data starts" + " before model name" ) ; } else { currentModel . addItemToEnd ( MiscUtilities . escapesToChars ( line ) ) ; } } if ( currentModel != null ) { models . put ( currentModel . getName ( ) , currentModel ) ; } in . close ( ) ; } catch ( FileNotFoundException fnf ) { Log . log ( Log . DEBUG , HistoryModel . class , fnf ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , HistoryModel . class , io ) ; } } public static void saveHistory ( File file ) { String lineSep = System . getProperty ( "line.separator" ) ; try { BufferedWriter out = new BufferedWriter ( new FileWriter ( file ) ) ; if ( models == null ) { out . close ( ) ; return ; } Enumeration modelEnum = models . elements ( ) ; while ( modelEnum . hasMoreElements ( ) ) { HistoryModel model = ( HistoryModel ) modelEnum . nextElement ( ) ; out . write ( '[' ) ; out . write ( model . getName ( ) ) ; out . write ( ']' ) ; out . write ( lineSep ) ; for ( int i = 0 ; i < model . getSize ( ) ; i ++ ) { out . write ( MiscUtilities . charsToEscapes ( model . getItem ( i ) , true ) ) ; out . write ( lineSep ) ; } } out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , HistoryModel . class , io ) ; } } private String name ; private int max ; private Vector data ; private static Hashtable models ; private void addItemToEnd ( String item ) { data . addElement ( item ) ; } } 	0	['10', '1', '0', '10', '47', '17', '8', '3', '8', '0.622222222', '299', '1', '0', '0', '0.35', '0', '0', '28.4', '10', '2.8', '0']
package com . microstar . xml ; public interface XmlHandler { public void startDocument ( ) throws java . lang . Exception ; public void endDocument ( ) throws java . lang . Exception ; public Object resolveEntity ( String publicId , String systemId ) throws java . lang . Exception ; public void startExternalEntity ( String systemId ) throws java . lang . Exception ; public void endExternalEntity ( String systemId ) throws java . lang . Exception ; public void doctypeDecl ( String name , String publicId , String systemId ) throws java . lang . Exception ; public void attribute ( String aname , String value , boolean isSpecified ) throws java . lang . Exception ; public void startElement ( String elname ) throws java . lang . Exception ; public void endElement ( String elname ) throws java . lang . Exception ; public void charData ( char ch [ ] , int start , int length ) throws java . lang . Exception ; public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws java . lang . Exception ; public void processingInstruction ( String target , String data ) throws java . lang . Exception ; public void error ( String message , String systemId , int line , int column ) throws java . lang . Exception ; } 	0	['13', '1', '0', '6', '13', '78', '6', '0', '13', '2', '13', '0', '0', '0', '0.430769231', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . syntax ; public class ParserRule { public final char [ ] searchChars ; public final int [ ] sequenceLengths ; public final int action ; public final byte token ; public ParserRule next ; ParserRule ( char [ ] searchChars , int [ ] sequenceLengths , int action , byte token ) { this . searchChars = searchChars ; this . sequenceLengths = sequenceLengths ; this . action = action ; this . token = token ; } } 	0	['1', '1', '0', '6', '2', '0', '6', '0', '0', '2', '21', '0', '1', '0', '1', '0', '0', '15', '0', '0', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . * ; import java . net . URL ; import java . util . Random ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . util . Log ; public class SplashScreen extends JWindow { public SplashScreen ( ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; JPanel splash = new JPanel ( new BorderLayout ( 12 , 12 ) ) ; splash . setBorder ( new CompoundBorder ( new MatteBorder ( 1 , 1 , 1 , 1 , Color . black ) , new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ) ; splash . setBackground ( Color . white ) ; URL url = getClass ( ) . getResource ( "/org/gjt/sp/jedit/jedit_logo.gif" ) ; if ( url != null ) { JLabel label = new JLabel ( new ImageIcon ( url ) ) ; splash . add ( label , BorderLayout . CENTER ) ; } progress = new JProgressBar ( 0 , 6 ) ; progress . setStringPainted ( true ) ; progress . setString ( "jEdit version: " + jEdit . getVersion ( ) ) ; splash . add ( BorderLayout . SOUTH , progress ) ; setContentPane ( splash ) ; Dimension screen = getToolkit ( ) . getScreenSize ( ) ; pack ( ) ; setLocation ( ( screen . width - getSize ( ) . width ) / 2 , ( screen . height - getSize ( ) . height ) / 2 ) ; show ( ) ; } public void advance ( ) { try { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { progress . setValue ( progress . getValue ( ) + 1 ) ; } } ) ; Thread . yield ( ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } } private JProgressBar progress ; } 	0	['3', '5', '0', '4', '37', '1', '2', '3', '2', '0.5', '138', '1', '0', '0.996710526', '0.5', '0', '0', '44.66666667', '2', '1', '0']
package org . gjt . sp . jedit . options ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . gui . GrabKeyDialog ; import org . gjt . sp . jedit . * ; public class ShortcutsOptionPane extends AbstractOptionPane { public ShortcutsOptionPane ( ) { super ( "shortcuts" ) ; } protected void _init ( ) { allBindings = new Vector ( ) ; setLayout ( new BorderLayout ( 12 , 12 ) ) ; initModels ( ) ; selectModel = new JComboBox ( models ) ; selectModel . addActionListener ( new ActionHandler ( ) ) ; Box north = Box . createHorizontalBox ( ) ; north . add ( new JLabel ( jEdit . getProperty ( "options.shortcuts.select.label" ) ) ) ; north . add ( Box . createHorizontalStrut ( 12 ) ) ; north . add ( selectModel ) ; keyTable = new JTable ( currentModel ) ; keyTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; keyTable . getTableHeader ( ) . addMouseListener ( new HeaderMouseHandler ( ) ) ; keyTable . addMouseListener ( new TableMouseHandler ( ) ) ; Dimension d = keyTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 200 ) ; JScrollPane scroller = new JScrollPane ( keyTable ) ; scroller . setPreferredSize ( d ) ; add ( BorderLayout . NORTH , north ) ; add ( BorderLayout . CENTER , scroller ) ; } protected void _save ( ) { if ( keyTable . getCellEditor ( ) != null ) keyTable . getCellEditor ( ) . stopCellEditing ( ) ; Enumeration e = models . elements ( ) ; while ( e . hasMoreElements ( ) ) ( ( ShortcutsModel ) e . nextElement ( ) ) . save ( ) ; Macros . loadMacros ( ) ; } private void initModels ( ) { models = new Vector ( ) ; models . addElement ( currentModel = createModel ( "commands" , false ) ) ; models . addElement ( createModel ( "plugins" , true ) ) ; models . addElement ( createMacrosModel ( ) ) ; } private ShortcutsModel createModel ( String id , boolean pluginActions ) { EditAction [ ] actions = jEdit . getActions ( ) ; Vector bindings = new Vector ( actions . length ) ; for ( int i = 0 ; i < actions . length ; i ++ ) { EditAction action = actions [ i ] ; if ( action . isPluginAction ( ) != pluginActions ) continue ; String name = action . getName ( ) ; String label = jEdit . getProperty ( name + ".label" ) ; if ( label == null ) continue ; label = GUIUtilities . prettifyMenuLabel ( label ) ; addBindings ( name , label , bindings ) ; } return new ShortcutsModel ( id , bindings ) ; } private ShortcutsModel createMacrosModel ( ) { Vector bindings = new Vector ( ) ; Vector macroList = Macros . getMacroList ( ) ; for ( int i = 0 ; i < macroList . size ( ) ; i ++ ) { String name = macroList . elementAt ( i ) . toString ( ) ; addBindings ( name , name , bindings ) ; } return new ShortcutsModel ( "macros" , bindings ) ; } private void addBindings ( String name , String label , Vector bindings ) { GrabKeyDialog . KeyBinding b [ ] = new GrabKeyDialog . KeyBinding [ 2 ] ; b [ 0 ] = createBinding ( name , label , jEdit . getProperty ( name + ".shortcut" ) ) ; b [ 1 ] = createBinding ( name , label , jEdit . getProperty ( name + ".shortcut2" ) ) ; bindings . addElement ( b ) ; } private GrabKeyDialog . KeyBinding createBinding ( String name , String label , String shortcut ) { if ( shortcut != null && shortcut . length ( ) == 0 ) shortcut = null ; GrabKeyDialog . KeyBinding binding = new GrabKeyDialog . KeyBinding ( name , label , shortcut , false ) ; allBindings . addElement ( binding ) ; return binding ; } private JTable keyTable ; private Vector models ; private ShortcutsModel currentModel ; private JComboBox selectModel ; private Vector allBindings ; class HeaderMouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { switch ( keyTable . getTableHeader ( ) . columnAtPoint ( evt . getPoint ( ) ) ) { case 0 : currentModel . sort ( 0 ) ; break ; case 1 : currentModel . sort ( 1 ) ; break ; case 2 : currentModel . sort ( 2 ) ; break ; } } } class TableMouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { int row = keyTable . getSelectedRow ( ) ; int col = keyTable . getSelectedColumn ( ) ; if ( col != 0 && row != - 1 ) { GrabKeyDialog gkd = new GrabKeyDialog ( ShortcutsOptionPane . this , currentModel . getBindingAt ( row , col - 1 ) , allBindings ) ; if ( gkd . isOK ( ) ) currentModel . setValueAt ( gkd . getShortcut ( ) , row , col ) ; } } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { ShortcutsModel newModel = ( ShortcutsModel ) selectModel . getSelectedItem ( ) ; if ( currentModel != newModel ) { currentModel = newModel ; keyTable . setModel ( currentModel ) ; } } } class ShortcutsModel extends AbstractTableModel { private Vector bindings ; private String name ; ShortcutsModel ( String name , Vector bindings ) { this . name = name ; this . bindings = bindings ; sort ( 0 ) ; } public void sort ( int col ) { MiscUtilities . quicksort ( bindings , new KeyCompare ( col ) ) ; fireTableDataChanged ( ) ; } public int getColumnCount ( ) { return 3 ; } public int getRowCount ( ) { return bindings . size ( ) ; } public Object getValueAt ( int row , int col ) { switch ( col ) { case 0 : return getBindingAt ( row , 0 ) . label ; case 1 : return getBindingAt ( row , 0 ) . shortcut ; case 2 : return getBindingAt ( row , 1 ) . shortcut ; default : return null ; } } public void setValueAt ( Object value , int row , int col ) { if ( col == 0 ) return ; getBindingAt ( row , col - 1 ) . shortcut = ( String ) value ; fireTableDataChanged ( ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.shortcuts.name" ) ; case 1 : return jEdit . getProperty ( "options.shortcuts.shortcut1" ) ; case 2 : return jEdit . getProperty ( "options.shortcuts.shortcut2" ) ; default : return null ; } } public void save ( ) { Enumeration enum = bindings . elements ( ) ; while ( enum . hasMoreElements ( ) ) { GrabKeyDialog . KeyBinding binding [ ] = ( GrabKeyDialog . KeyBinding [ ] ) enum . nextElement ( ) ; jEdit . setProperty ( binding [ 0 ] . name + ".shortcut" , binding [ 0 ] . shortcut ) ; jEdit . setProperty ( binding [ 1 ] . name + ".shortcut2" , binding [ 1 ] . shortcut ) ; } } public GrabKeyDialog . KeyBinding getBindingAt ( int row , int nr ) { GrabKeyDialog . KeyBinding binding [ ] = ( GrabKeyDialog . KeyBinding [ ] ) bindings . elementAt ( row ) ; return binding [ nr ] ; } public String toString ( ) { return jEdit . getProperty ( "options.shortcuts.select." + name ) ; } class KeyCompare implements MiscUtilities . Compare { int col ; KeyCompare ( int col ) { this . col = col ; } public int compare ( Object obj1 , Object obj2 ) { GrabKeyDialog . KeyBinding [ ] k1 = ( GrabKeyDialog . KeyBinding [ ] ) obj1 ; GrabKeyDialog . KeyBinding [ ] k2 = ( GrabKeyDialog . KeyBinding [ ] ) obj2 ; String label1 = k1 [ 0 ] . label . toLowerCase ( ) ; String label2 = k2 [ 0 ] . label . toLowerCase ( ) ; if ( col == 0 ) return label1 . compareTo ( label2 ) ; else { String shortcut1 , shortcut2 ; if ( col == 1 ) { shortcut1 = k1 [ 0 ] . shortcut ; shortcut2 = k2 [ 0 ] . shortcut ; } else { shortcut1 = k1 [ 1 ] . shortcut ; shortcut2 = k2 [ 1 ] . shortcut ; } if ( shortcut1 == null && shortcut2 != null ) return 1 ; else if ( shortcut2 == null && shortcut1 != null ) return - 1 ; else if ( shortcut1 == null && shortcut2 == null ) return label1 . compareTo ( label2 ) ; else return shortcut1 . compareTo ( shortcut2 ) ; } } } } } 	0	['13', '6', '0', '11', '60', '50', '5', '10', '1', '0.816666667', '361', '1', '1', '0.982195846', '0.243589744', '4', '12', '26.38461538', '5', '1.9231', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import java . awt . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; public class ViewRegisters extends EnhancedDialog { public ViewRegisters ( View view ) { super ( view , jEdit . getProperty ( "view-registers.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBorder ( new EmptyBorder ( 0 , 12 , 0 , 0 ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "view-registers.register" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 0 ) ) ; panel . add ( BorderLayout . NORTH , label ) ; DefaultListModel registerModel = new DefaultListModel ( ) ; registerList = new JList ( registerModel ) ; registerList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; registerList . setCellRenderer ( new Renderer ( ) ) ; Registers . Register [ ] registers = Registers . getRegisters ( ) ; int index = 0 ; for ( int i = 0 ; i < registers . length ; i ++ ) { Registers . Register reg = registers [ i ] ; if ( reg == null ) continue ; String value = reg . toString ( ) ; if ( value == null || value . length ( ) == 0 ) continue ; registerModel . addElement ( new Character ( ( char ) i ) ) ; } if ( registerModel . getSize ( ) == 0 ) registerModel . addElement ( jEdit . getProperty ( "view-registers.none" ) ) ; panel . add ( BorderLayout . CENTER , new JScrollPane ( registerList ) ) ; content . add ( BorderLayout . WEST , panel ) ; panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBorder ( new EmptyBorder ( 0 , 12 , 0 , 0 ) ) ; label = new JLabel ( jEdit . getProperty ( "view-registers.contents" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 0 ) ) ; panel . add ( BorderLayout . NORTH , label ) ; contentTextArea = new JTextArea ( 10 , 80 ) ; contentTextArea . setEditable ( false ) ; panel . add ( BorderLayout . CENTER , new JScrollPane ( contentTextArea ) ) ; content . add ( BorderLayout . CENTER , panel ) ; panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( new ActionHandler ( ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( close ) ; panel . add ( Box . createGlue ( ) ) ; getRootPane ( ) . setDefaultButton ( close ) ; content . add ( BorderLayout . SOUTH , panel ) ; registerList . addListSelectionListener ( new ListHandler ( ) ) ; registerList . setSelectedIndex ( index ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } private JList registerList ; private JTextArea contentTextArea ; private JButton close ; class Renderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; if ( value instanceof Character ) { char name = ( ( Character ) value ) . charValue ( ) ; String label ; if ( name == '\n' ) label = "\n" ; else if ( name == '\t' ) label = "\t" ; else if ( name == '$' ) label = jEdit . getProperty ( "view-registers.clipboard" ) ; else if ( name == '%' ) label = jEdit . getProperty ( "view-registers.selection" ) ; else label = String . valueOf ( ( char ) name ) ; setText ( label ) ; } return this ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == close ) cancel ( ) ; } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { Object value = registerList . getSelectedValue ( ) ; if ( ! ( value instanceof Character ) ) return ; char name = ( ( Character ) value ) . charValue ( ) ; Registers . Register reg = Registers . getRegister ( name ) ; if ( reg == null ) return ; contentTextArea . setText ( reg . toString ( ) ) ; contentTextArea . setCaretPosition ( 0 ) ; } } } 	0	['6', '7', '0', '8', '47', '9', '3', '8', '3', '0.8', '311', '1', '0', '0.992401216', '0.388888889', '0', '0', '50.33333333', '1', '0.8333', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . * ; public class EnhancedMenu extends JMenu { public EnhancedMenu ( String name ) { String label = jEdit . getProperty ( name . concat ( ".label" ) ) ; if ( label == null ) label = name ; char mnemonic ; int index = label . indexOf ( '$' ) ; if ( index != - 1 && label . length ( ) - index > 1 ) { mnemonic = Character . toLowerCase ( label . charAt ( index + 1 ) ) ; label = label . substring ( 0 , index ) . concat ( label . substring ( ++ index ) ) ; } else mnemonic = '\0' ; setText ( label ) ; setMnemonic ( mnemonic ) ; String menuItems = jEdit . getProperty ( name ) ; if ( menuItems != null ) { StringTokenizer st = new StringTokenizer ( menuItems ) ; while ( st . hasMoreTokens ( ) ) { String menuItemName = st . nextToken ( ) ; if ( menuItemName . equals ( "-" ) ) addSeparator ( ) ; else { if ( menuItemName . startsWith ( "%" ) ) add ( GUIUtilities . loadMenu ( menuItemName . substring ( 1 ) ) ) ; else add ( GUIUtilities . loadMenuItem ( menuItemName ) ) ; } } } } } 	0	['1', '7', '6', '8', '21', '0', '7', '2', '1', '2', '93', '0', '0', '1', '1', '0', '0', '92', '0', '0', '0']
package org . gjt . sp . jedit . gui ; import java . awt . Component ; public interface DockableWindow { String DOCKABLE_WINDOW_LIST = "DOCKABLE_WINDOWS" ; String getName ( ) ; Component getComponent ( ) ; } 	0	['2', '1', '0', '12', '2', '1', '12', '0', '2', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit ; import javax . swing . Timer ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; class Autosave implements ActionListener { public static void setInterval ( int interval ) { if ( interval == 0 ) { if ( timer != null ) { timer . stop ( ) ; timer = null ; } return ; } interval *= 1000 ; if ( timer == null ) { timer = new Timer ( interval , new Autosave ( ) ) ; timer . start ( ) ; } else timer . setDelay ( interval ) ; } public static void stop ( ) { if ( timer != null ) timer . stop ( ) ; } public void actionPerformed ( ActionEvent evt ) { Buffer [ ] bufferArray = jEdit . getBuffers ( ) ; for ( int i = 0 ; i < bufferArray . length ; i ++ ) bufferArray [ i ] . autosave ( ) ; } private static Timer timer ; private Autosave ( ) { } } 	0	['4', '1', '0', '2', '11', '4', '1', '2', '3', '0.666666667', '58', '1', '0', '0', '0.333333333', '0', '0', '13.25', '4', '2', '0']
package bsh ; import java . util . Vector ; class BSHMethodDeclaration extends SimpleNode { String name ; BSHFormalParameters params ; BSHBlock block ; Object returnType ; BSHMethodDeclaration ( int id ) { super ( id ) ; } public Object eval ( NameSpace namespace ) throws EvalError { if ( block == null ) { if ( jjtGetNumChildren ( ) == 3 ) { returnType = ( ( BSHReturnType ) jjtGetChild ( 0 ) ) . getReturnType ( namespace ) ; params = ( BSHFormalParameters ) jjtGetChild ( 1 ) ; block = ( BSHBlock ) jjtGetChild ( 2 ) ; } else { params = ( BSHFormalParameters ) jjtGetChild ( 0 ) ; block = ( BSHBlock ) jjtGetChild ( 1 ) ; } params . eval ( namespace ) ; if ( Interpreter . strictJava ) { for ( int i = 0 ; i < params . argTypes . length ; i ++ ) if ( params . argTypes [ i ] == null ) throw new EvalError ( "(Strict Java Mode) Undeclared argument type, parameter: " + params . argNames [ i ] + " in method: " + name , this ) ; if ( returnType == null ) throw new EvalError ( "(Strict Java Mode) Undeclared return type for method: " + name , this ) ; } } namespace . setMethod ( name , new BshMethod ( this , namespace ) ) ; return Primitive . VOID ; } public String toString ( ) { return "MethodDeclaration: " + name ; } } 	0	['3', '2', '0', '11', '14', '1', '2', '10', '2', '0.875', '134', '0', '2', '0.9', '0.555555556', '1', '3', '42.33333333', '1', '0.6667', '0']
package bsh ; class BSHSwitchLabel extends SimpleNode { boolean isDefault ; public BSHSwitchLabel ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { if ( isDefault ) return null ; SimpleNode label = ( ( SimpleNode ) jjtGetChild ( 0 ) ) ; return label . eval ( callstack , interpreter ) ; } } 	0	['2', '2', '0', '7', '5', '1', '2', '5', '2', '1', '22', '0', '0', '0.947368421', '0.625', '1', '1', '9.5', '1', '0.5', '0']
package bsh ; import java . util . Hashtable ; import java . lang . reflect . Array ; import java . lang . reflect . InvocationTargetException ; class BSHPrimarySuffix extends SimpleNode { public static final int CLASS = 0 , INDEX = 1 , NAME = 2 , PROPERTY = 3 ; public int operation ; Object index ; public String field ; BSHPrimarySuffix ( int id ) { super ( id ) ; } public Object doSuffix ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError { if ( operation == CLASS ) if ( obj instanceof BSHType ) { NameSpace namespace = callstack . top ( ) ; return ( ( BSHType ) obj ) . getType ( namespace ) ; } else throw new EvalError ( "Attemp to invoke .class on non class." , this ) ; if ( obj instanceof SimpleNode ) if ( obj instanceof BSHAmbiguousName ) obj = ( ( BSHAmbiguousName ) obj ) . toObject ( callstack , interpreter ) ; else obj = ( ( SimpleNode ) obj ) . eval ( callstack , interpreter ) ; try { switch ( operation ) { case INDEX : return doIndex ( obj , callstack , interpreter ) ; case NAME : return doName ( obj , callstack , interpreter ) ; case PROPERTY : return doProperty ( obj , callstack , interpreter ) ; default : throw new InterpreterError ( "LHS suffix" ) ; } } catch ( ReflectError e ) { throw new EvalError ( "reflection error: " + e , this ) ; } catch ( InvocationTargetException e ) { throw new TargetError ( e . getTargetException ( ) , this ) ; } } private Object doName ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError , InvocationTargetException { if ( field . equals ( "length" ) && obj . getClass ( ) . isArray ( ) ) return new Primitive ( Array . getLength ( obj ) ) ; if ( jjtGetNumChildren ( ) == 0 ) return Reflect . getObjectField ( obj , field ) ; else { Object [ ] oa = ( ( BSHArguments ) jjtGetChild ( 0 ) ) . getArguments ( callstack , interpreter ) ; try { return Reflect . invokeObjectMethod ( interpreter , obj , field , oa , this ) ; } catch ( EvalError ee ) { throw new EvalError ( ee . getMessage ( ) , this ) ; } } } private Object doIndex ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError { if ( ! obj . getClass ( ) . isArray ( ) ) throw new EvalError ( "Not an array" , this ) ; int index ; try { Primitive val = ( Primitive ) ( ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ) ; index = val . intValue ( ) ; } catch ( Exception e ) { throw new EvalError ( "You can only index arrays by integer types" , this ) ; } return Reflect . getIndex ( obj , index ) ; } private Object doProperty ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError { if ( obj == Primitive . VOID ) throw new EvalError ( "Attempt to access property on undefined variable or class name" , this ) ; if ( obj instanceof Primitive ) throw new EvalError ( "Attempt to access property on a primitive" , this ) ; Object value = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( ! ( value instanceof String ) ) throw new EvalError ( "Property expression must be a String or identifier." , this ) ; if ( obj instanceof Hashtable ) { Object val = ( ( Hashtable ) obj ) . get ( ( String ) value ) ; if ( val == null ) val = Primitive . NULL ; return val ; } try { return Reflect . getObjectProperty ( obj , ( String ) value ) ; } catch ( ReflectError e ) { Interpreter . debug ( e . toString ( ) ) ; throw new EvalError ( "No such property: " + value , this ) ; } } } 	0	['5', '2', '0', '16', '35', '10', '2', '14', '1', '1.142857143', '256', '0', '0', '0.818181818', '0.72', '0', '0', '48.8', '1', '0.8', '0']
package org . gjt . sp . jedit ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . * ; import java . io . * ; import java . util . * ; import org . gjt . sp . jedit . gui . AddAbbrevDialog ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class Abbrevs { public static boolean getExpandOnInput ( ) { return expandOnInput ; } public static void setExpandOnInput ( boolean expandOnInput ) { Abbrevs . expandOnInput = expandOnInput ; } public static boolean expandAbbrev ( View view , boolean add ) { JEditTextArea textArea = view . getTextArea ( ) ; if ( ! textArea . isEditable ( ) ) { view . getToolkit ( ) . beep ( ) ; return false ; } Buffer buffer = view . getBuffer ( ) ; int line = textArea . getCaretLine ( ) ; int lineStart = textArea . getLineStartOffset ( line ) ; int caret = textArea . getCaretPosition ( ) ; String lineText = textArea . getLineText ( line ) ; if ( lineText . length ( ) == 0 ) { if ( add ) view . getToolkit ( ) . beep ( ) ; return false ; } int pos = caret - lineStart ; if ( pos == 0 ) { if ( add ) view . getToolkit ( ) . beep ( ) ; return false ; } pp . removeAllElements ( ) ; int wordStart ; String abbrev ; if ( lineText . charAt ( pos - 1 ) == '#' ) { wordStart = lineText . indexOf ( '#' ) ; wordStart = TextUtilities . findWordStart ( lineText , wordStart , ( String ) buffer . getProperty ( "noWordSep" ) + '#' ) ; abbrev = lineText . substring ( wordStart , pos - 1 ) ; int lastIndex = 0 ; for ( int i = 0 ; i < abbrev . length ( ) ; i ++ ) { if ( abbrev . charAt ( i ) == '#' ) { pp . addElement ( abbrev . substring ( lastIndex , i ) ) ; lastIndex = i + 1 ; } } pp . addElement ( abbrev . substring ( lastIndex ) ) ; abbrev = ( String ) pp . elementAt ( 0 ) ; } else { wordStart = TextUtilities . findWordStart ( lineText , pos - 1 , ( String ) buffer . getProperty ( "noWordSep" ) ) ; abbrev = lineText . substring ( wordStart , pos ) ; } Expansion expand = expandAbbrev ( buffer . getMode ( ) . getName ( ) , abbrev , ( buffer . getBooleanProperty ( "noTabs" ) ? buffer . getTabSize ( ) : 0 ) , pp ) ; if ( expand == null ) { if ( add ) new AddAbbrevDialog ( view , abbrev ) ; return false ; } else { buffer . beginCompoundEdit ( ) ; try { lineText = buffer . getText ( lineStart , wordStart ) ; int leadingIndent = MiscUtilities . getLeadingWhiteSpaceWidth ( lineText , buffer . getTabSize ( ) ) ; buffer . remove ( lineStart + wordStart , pos - wordStart ) ; buffer . insertString ( lineStart + wordStart , expand . text , null ) ; if ( expand . caretPosition != - 1 ) { textArea . setCaretPosition ( lineStart + wordStart + expand . caretPosition ) ; } String whiteSpace = MiscUtilities . createWhiteSpace ( leadingIndent , buffer . getBooleanProperty ( "noTabs" ) ? 0 : buffer . getTabSize ( ) ) ; Element map = buffer . getDefaultRootElement ( ) ; for ( int i = line + 1 ; i <= line + expand . lineCount ; i ++ ) { Element elem = map . getElement ( i ) ; buffer . insertString ( elem . getStartOffset ( ) , whiteSpace , null ) ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , Abbrevs . class , bl ) ; } buffer . endCompoundEdit ( ) ; return true ; } } public static Hashtable getGlobalAbbrevs ( ) { return globalAbbrevs ; } public static void setGlobalAbbrevs ( Hashtable globalAbbrevs ) { abbrevsChanged = true ; Abbrevs . globalAbbrevs = globalAbbrevs ; } public static Hashtable getModeAbbrevs ( ) { return modes ; } public static void setModeAbbrevs ( Hashtable modes ) { abbrevsChanged = true ; Abbrevs . modes = modes ; } public static void addGlobalAbbrev ( String abbrev , String expansion ) { globalAbbrevs . put ( abbrev , expansion ) ; abbrevsChanged = true ; } public static void addModeAbbrev ( String mode , String abbrev , String expansion ) { Hashtable modeAbbrevs = ( Hashtable ) modes . get ( mode ) ; if ( modeAbbrevs == null ) { modeAbbrevs = new Hashtable ( ) ; modes . put ( mode , modeAbbrevs ) ; } modeAbbrevs . put ( abbrev , expansion ) ; abbrevsChanged = true ; } static void load ( ) { expandOnInput = jEdit . getBooleanProperty ( "view.expandOnInput" ) ; globalAbbrevs = new Hashtable ( ) ; modes = new Hashtable ( ) ; boolean loaded = false ; String settings = jEdit . getSettingsDirectory ( ) ; if ( settings != null ) { File file = new File ( MiscUtilities . constructPath ( settings , "abbrevs" ) ) ; abbrevsModTime = file . lastModified ( ) ; try { loadAbbrevs ( new FileReader ( file ) ) ; loaded = true ; } catch ( FileNotFoundException fnf ) { } catch ( Exception e ) { Log . log ( Log . ERROR , Abbrevs . class , "Error while loading " + file ) ; Log . log ( Log . ERROR , Abbrevs . class , e ) ; } } if ( ! loaded ) { try { loadAbbrevs ( new InputStreamReader ( Abbrevs . class . getResourceAsStream ( "default.abbrevs" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , Abbrevs . class , "Error while loading default.abbrevs" ) ; Log . log ( Log . ERROR , Abbrevs . class , e ) ; } } } static void save ( ) { jEdit . setBooleanProperty ( "view.expandOnInput" , expandOnInput ) ; String settings = jEdit . getSettingsDirectory ( ) ; if ( abbrevsChanged && settings != null ) { File file = new File ( MiscUtilities . constructPath ( settings , "abbrevs" ) ) ; if ( file . exists ( ) && file . lastModified ( ) != abbrevsModTime ) { Log . log ( Log . WARNING , Abbrevs . class , file + " changed on disk;" + " will not save abbrevs" ) ; } else { try { saveAbbrevs ( new FileWriter ( file ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , Abbrevs . class , "Error while saving " + file ) ; Log . log ( Log . ERROR , Abbrevs . class , e ) ; } abbrevsModTime = file . lastModified ( ) ; } } } private static boolean abbrevsChanged ; private static long abbrevsModTime ; private static boolean expandOnInput ; private static Hashtable globalAbbrevs ; private static Hashtable modes ; private static Vector pp = new Vector ( ) ; private Abbrevs ( ) { } private static Expansion expandAbbrev ( String mode , String abbrev , int softTabSize , Vector pp ) { String expand = null ; Hashtable modeAbbrevs = ( Hashtable ) modes . get ( mode ) ; if ( modeAbbrevs != null ) expand = ( String ) modeAbbrevs . get ( abbrev ) ; if ( expand == null ) expand = ( String ) globalAbbrevs . get ( abbrev ) ; if ( expand == null ) return null ; else return new Expansion ( expand , softTabSize , pp ) ; } private static void loadAbbrevs ( Reader _in ) throws Exception { BufferedReader in = new BufferedReader ( _in ) ; Hashtable currentAbbrevs = null ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . length ( ) == 0 ) continue ; else if ( line . startsWith ( "[" ) && line . indexOf ( '|' ) == - 1 ) { if ( line . equals ( "[global]" ) ) currentAbbrevs = globalAbbrevs ; else { String mode = line . substring ( 1 , line . length ( ) - 1 ) ; currentAbbrevs = ( Hashtable ) modes . get ( mode ) ; if ( currentAbbrevs == null ) { currentAbbrevs = new Hashtable ( ) ; modes . put ( mode , currentAbbrevs ) ; } } } else { int index = line . indexOf ( '|' ) ; currentAbbrevs . put ( line . substring ( 0 , index ) , line . substring ( index + 1 ) ) ; } } in . close ( ) ; } private static void saveAbbrevs ( Writer _out ) throws Exception { BufferedWriter out = new BufferedWriter ( _out ) ; String lineSep = System . getProperty ( "line.separator" ) ; out . write ( "[global]" ) ; out . write ( lineSep ) ; saveAbbrevs ( out , globalAbbrevs ) ; Enumeration keys = modes . keys ( ) ; Enumeration values = modes . elements ( ) ; while ( keys . hasMoreElements ( ) ) { out . write ( '[' ) ; out . write ( ( String ) keys . nextElement ( ) ) ; out . write ( ']' ) ; out . write ( lineSep ) ; saveAbbrevs ( out , ( Hashtable ) values . nextElement ( ) ) ; } out . close ( ) ; } private static void saveAbbrevs ( Writer out , Hashtable abbrevs ) throws Exception { String lineSep = System . getProperty ( "line.separator" ) ; Enumeration keys = abbrevs . keys ( ) ; Enumeration values = abbrevs . elements ( ) ; while ( keys . hasMoreElements ( ) ) { String abbrev = ( String ) keys . nextElement ( ) ; out . write ( abbrev ) ; out . write ( '|' ) ; out . write ( values . nextElement ( ) . toString ( ) ) ; out . write ( lineSep ) ; } } static class Expansion { String text ; int caretPosition = - 1 ; int lineCount ; Expansion ( String text , int softTabSize , Vector pp ) { StringBuffer buf = new StringBuffer ( ) ; boolean backslash = false ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char ch = text . charAt ( i ) ; if ( backslash ) { backslash = false ; if ( ch == '|' ) caretPosition = buf . length ( ) ; else if ( ch == 'n' ) { buf . append ( '\n' ) ; lineCount ++ ; } else if ( ch == 't' ) { if ( softTabSize == 0 ) buf . append ( '\t' ) ; else { for ( int j = 0 ; j < softTabSize ; j ++ ) buf . append ( ' ' ) ; } } else buf . append ( ch ) ; } else if ( ch == '\\' ) backslash = true ; else if ( ch == '$' ) { if ( i != text . length ( ) - 1 ) { ch = text . charAt ( i + 1 ) ; if ( Character . isDigit ( ch ) && ch != '0' ) { i ++ ; int pos = ch - '0' ; if ( pos < pp . size ( ) ) buf . append ( pp . elementAt ( pos ) ) ; else { buf . append ( '$' ) ; buf . append ( ch ) ; } } else { buf . append ( '$' ) ; } } } else buf . append ( ch ) ; } this . text = buf . toString ( ) ; } } } 	0	['18', '1', '0', '12', '96', '47', '4', '10', '9', '0.773109244', '730', '1', '0', '0', '0.104575163', '0', '0', '39.16666667', '16', '2.7222', '0']
package bsh ; class BSHPrimitiveType extends SimpleNode { public Class type ; BSHPrimitiveType ( int id ) { super ( id ) ; } public Class getType ( ) { return type ; } } 	0	['2', '2', '0', '4', '3', '1', '3', '1', '1', '1', '10', '0', '0', '0.947368421', '0.75', '0', '0', '3.5', '1', '0.5', '0']
package org . gjt . sp . jedit . search ; import javax . swing . SwingUtilities ; import java . util . Vector ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class BufferListSet implements SearchFileSet { public BufferListSet ( Object [ ] files ) { this . files = new Vector ( files . length ) ; for ( int i = 0 ; i < files . length ; i ++ ) { this . files . addElement ( ( ( Buffer ) files [ i ] ) . getPath ( ) ) ; } } public BufferListSet ( Vector files ) { this . files = files ; } public Buffer getFirstBuffer ( View view ) { return getBuffer ( ( String ) files . elementAt ( 0 ) ) ; } public Buffer getNextBuffer ( View view , Buffer buffer ) { if ( buffer == null ) { buffer = view . getBuffer ( ) ; for ( int i = 0 ; i < files . size ( ) ; i ++ ) { if ( files . elementAt ( i ) . equals ( buffer . getPath ( ) ) ) return buffer ; } return getFirstBuffer ( view ) ; } else { for ( int i = 0 ; i < files . size ( ) - 1 ; i ++ ) { if ( files . elementAt ( i ) . equals ( buffer . getPath ( ) ) ) return getBuffer ( ( String ) files . elementAt ( i + 1 ) ) ; } return null ; } } public void matchFound ( final Buffer buffer ) { if ( ! SwingUtilities . isEventDispatchThread ( ) ) { try { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { jEdit . commitTemporary ( buffer ) ; } } ) ; } catch ( Exception e ) { } } else jEdit . commitTemporary ( buffer ) ; } public int getBufferCount ( ) { return files . size ( ) ; } public boolean isValid ( ) { return files . size ( ) != 0 ; } public String getCode ( ) { return null ; } private Vector files ; private Buffer getBuffer ( final String path ) { if ( ! SwingUtilities . isEventDispatchThread ( ) ) { final Buffer [ ] retVal = new Buffer [ 1 ] ; try { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { retVal [ 0 ] = jEdit . openTemporary ( null , null , path , false ) ; } } ) ; return retVal [ 0 ] ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; return null ; } } else return jEdit . openTemporary ( null , null , path , false ) ; } } 	0	['9', '1', '2', '9', '24', '6', '4', '7', '8', '0.375', '174', '1', '0', '0', '0.296296296', '0', '0', '18.22222222', '6', '1.8889', '0']
package org . gjt . sp . jedit . gui ; import java . awt . event . * ; import java . awt . * ; import java . util . Vector ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import org . gjt . sp . jedit . jEdit ; public class FontSelector extends JButton { public FontSelector ( Font font ) { setFont ( font ) ; updateText ( ) ; setRequestFocusEnabled ( false ) ; addActionListener ( new ActionHandler ( ) ) ; } private void updateText ( ) { Font font = getFont ( ) ; String styleString ; switch ( font . getStyle ( ) ) { case Font . PLAIN : styleString = jEdit . getProperty ( "font-selector.plain" ) ; break ; case Font . BOLD : styleString = jEdit . getProperty ( "font-selector.bold" ) ; break ; case Font . ITALIC : styleString = jEdit . getProperty ( "font-selector.italic" ) ; break ; case Font . BOLD | Font . ITALIC : styleString = jEdit . getProperty ( "font-selector.bolditalic" ) ; break ; default : styleString = "UNKNOWN!!!???" ; break ; } setText ( font . getFamily ( ) + " " + font . getSize ( ) + " " + styleString ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Font font = new FontSelectorDialog ( FontSelector . this , getFont ( ) ) . getSelectedFont ( ) ; if ( font != null ) { setFont ( font ) ; updateText ( ) ; } } } } class FontSelectorDialog extends EnhancedDialog { public FontSelectorDialog ( Component comp , Font font ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "font-selector.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel listPanel = new JPanel ( new GridLayout ( 1 , 3 , 6 , 6 ) ) ; JPanel familyPanel = createTextFieldAndListPanel ( "font-selector.family" , familyField = new JTextField ( ) , familyList = new JList ( getFontList ( ) ) ) ; listPanel . add ( familyPanel ) ; String [ ] sizes = { "9" , "10" , "12" , "14" , "16" , "18" , "24" } ; JPanel sizePanel = createTextFieldAndListPanel ( "font-selector.size" , sizeField = new JTextField ( ) , sizeList = new JList ( sizes ) ) ; listPanel . add ( sizePanel ) ; String [ ] styles = { jEdit . getProperty ( "font-selector.plain" ) , jEdit . getProperty ( "font-selector.bold" ) , jEdit . getProperty ( "font-selector.italic" ) , jEdit . getProperty ( "font-selector.bolditalic" ) } ; JPanel stylePanel = createTextFieldAndListPanel ( "font-selector.style" , styleField = new JTextField ( ) , styleList = new JList ( styles ) ) ; styleField . setEditable ( false ) ; listPanel . add ( stylePanel ) ; familyList . setSelectedValue ( font . getFamily ( ) , true ) ; familyField . setText ( font . getFamily ( ) ) ; sizeList . setSelectedValue ( String . valueOf ( font . getSize ( ) ) , true ) ; sizeField . setText ( String . valueOf ( font . getSize ( ) ) ) ; styleList . setSelectedIndex ( font . getStyle ( ) ) ; styleField . setText ( ( String ) styleList . getSelectedValue ( ) ) ; ListHandler listHandler = new ListHandler ( ) ; familyList . addListSelectionListener ( listHandler ) ; sizeList . addListSelectionListener ( listHandler ) ; styleList . addListSelectionListener ( listHandler ) ; content . add ( BorderLayout . NORTH , listPanel ) ; preview = new JLabel ( jEdit . getProperty ( "font-selector.long-text" ) ) ; preview . setBorder ( new TitledBorder ( jEdit . getProperty ( "font-selector.preview" ) ) ) ; updatePreview ( ) ; Dimension prefSize = preview . getPreferredSize ( ) ; prefSize . height = 50 ; preview . setPreferredSize ( prefSize ) ; content . add ( BorderLayout . CENTER , preview ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; buttons . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; buttons . add ( ok ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( cancel ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , buttons ) ; pack ( ) ; setLocationRelativeTo ( JOptionPane . getFrameForComponent ( comp ) ) ; show ( ) ; } public void ok ( ) { isOK = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public Font getSelectedFont ( ) { if ( ! isOK ) return null ; int size ; try { size = Integer . parseInt ( sizeField . getText ( ) ) ; } catch ( Exception e ) { size = 14 ; } return new Font ( familyField . getText ( ) , styleList . getSelectedIndex ( ) , size ) ; } private boolean isOK ; private JTextField familyField ; private JList familyList ; private JTextField sizeField ; private JList sizeList ; private JTextField styleField ; private JList styleList ; private JLabel preview ; private JButton ok ; private JButton cancel ; private static final String [ ] HIDEFONTS = { ".bold" , ".italic" } ; private String [ ] getFontList ( ) { try { Class GEClass = Class . forName ( "java.awt.GraphicsEnvironment" ) ; Object GEInstance = GEClass . getMethod ( "getLocalGraphicsEnvironment" , null ) . invoke ( null , null ) ; String [ ] nameArray = ( String [ ] ) GEClass . getMethod ( "getAvailableFontFamilyNames" , null ) . invoke ( GEInstance , null ) ; Vector nameVector = new Vector ( nameArray . length ) ; for ( int i = 0 , j ; i < nameArray . length ; i ++ ) { for ( j = 0 ; j < HIDEFONTS . length ; j ++ ) { if ( nameArray [ i ] . indexOf ( HIDEFONTS [ j ] ) >= 0 ) break ; } if ( j == HIDEFONTS . length ) nameVector . addElement ( nameArray [ i ] ) ; } String [ ] _array = new String [ nameVector . size ( ) ] ; nameVector . copyInto ( _array ) ; return _array ; } catch ( Exception ex ) { return Toolkit . getDefaultToolkit ( ) . getFontList ( ) ; } } private JPanel createTextFieldAndListPanel ( String label , JTextField textField , JList list ) { GridBagLayout layout = new GridBagLayout ( ) ; JPanel panel = new JPanel ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridx = cons . gridy = 0 ; cons . gridwidth = cons . gridheight = 1 ; cons . fill = GridBagConstraints . BOTH ; cons . weightx = 1.0f ; JLabel _label = new JLabel ( jEdit . getProperty ( label ) ) ; layout . setConstraints ( _label , cons ) ; panel . add ( _label ) ; cons . gridy = 1 ; Component vs = Box . createVerticalStrut ( 6 ) ; layout . setConstraints ( vs , cons ) ; panel . add ( vs ) ; cons . gridy = 2 ; layout . setConstraints ( textField , cons ) ; panel . add ( textField ) ; cons . gridy = 3 ; vs = Box . createVerticalStrut ( 6 ) ; layout . setConstraints ( vs , cons ) ; panel . add ( vs ) ; cons . gridy = 4 ; cons . gridheight = GridBagConstraints . REMAINDER ; cons . weighty = 1.0f ; JScrollPane scroller = new JScrollPane ( list ) ; layout . setConstraints ( scroller , cons ) ; panel . add ( scroller ) ; return panel ; } private void updatePreview ( ) { String family = familyField . getText ( ) ; int size ; try { size = Integer . parseInt ( sizeField . getText ( ) ) ; } catch ( Exception e ) { size = 14 ; } int style = styleList . getSelectedIndex ( ) ; preview . setFont ( new Font ( family , style , size ) ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) ok ( ) ; else if ( evt . getSource ( ) == cancel ) cancel ( ) ; } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == familyList ) { String family = ( String ) familyList . getSelectedValue ( ) ; if ( family != null ) familyField . setText ( family ) ; } else if ( source == sizeList ) { String size = ( String ) sizeList . getSelectedValue ( ) ; if ( size != null ) sizeField . setText ( size ) ; } else if ( source == styleList ) { String style = ( String ) styleList . getSelectedValue ( ) ; if ( style != null ) styleField . setText ( style ) ; } updatePreview ( ) ; } } } 	0	['3', '6', '0', '5', '18', '3', '4', '2', '1', '2', '71', '0', '0', '0.997382199', '0.444444444', '0', '0', '22.66666667', '2', '1', '0']
package bsh ; class BSHIfStatement extends SimpleNode { BSHIfStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object ret = null ; if ( evaluateCondition ( ( SimpleNode ) jjtGetChild ( 0 ) , callstack , interpreter ) ) ret = ( ( SimpleNode ) jjtGetChild ( 1 ) ) . eval ( callstack , interpreter ) ; else if ( jjtGetNumChildren ( ) > 2 ) ret = ( ( SimpleNode ) jjtGetChild ( 2 ) ) . eval ( callstack , interpreter ) ; if ( ret instanceof ReturnControl ) return ret ; else return Primitive . VOID ; } public static boolean evaluateCondition ( SimpleNode condExp , CallStack callstack , Interpreter interpreter ) throws EvalError { Object obj = condExp . eval ( callstack , interpreter ) ; if ( obj instanceof Primitive ) { if ( obj == Primitive . VOID ) throw new EvalError ( "Condition evaluates to void type" , condExp ) ; obj = ( ( Primitive ) obj ) . getValue ( ) ; } if ( obj instanceof Boolean ) return ( ( Boolean ) obj ) . booleanValue ( ) ; else throw new EvalError ( "Condition must evaluate to a Boolean or boolean." , condExp ) ; } } 	0	['3', '2', '0', '11', '10', '3', '4', '7', '2', '2', '79', '0', '0', '0.9', '0.533333333', '1', '1', '25.33333333', '1', '0.6667', '0']
package org . gjt . sp . jedit . syntax ; import java . awt . Font ; import java . awt . Color ; public class SyntaxStyle { public SyntaxStyle ( Color fgColor , Color bgColor , Font font ) { this . fgColor = fgColor ; this . bgColor = bgColor ; this . font = font ; } public Color getForegroundColor ( ) { return fgColor ; } public Color getBackgroundColor ( ) { return bgColor ; } public Font getFont ( ) { return font ; } private Color fgColor ; private Color bgColor ; private Font font ; } 	0	['4', '1', '0', '10', '5', '0', '10', '0', '4', '0.666666667', '28', '1', '0', '0', '0.5', '0', '0', '5.25', '1', '0.75', '0']
package gnu . regexp ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . util . Locale ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; import java . util . Vector ; class IntPair implements Serializable { public int first , second ; } class CharUnit implements Serializable { public char ch ; public boolean bk ; } public final class RE extends REToken { private static final String s_version = "1.1.3" ; private static ResourceBundle messages = PropertyResourceBundle . getBundle ( "gnu/regexp/MessagesBundle" , Locale . getDefault ( ) ) ; private REToken firstToken , lastToken ; private int numSubs ; private int minimumLength ; public static final int REG_ICASE = 2 ; public static final int REG_DOT_NEWLINE = 4 ; public static final int REG_MULTILINE = 8 ; public static final int REG_NOTBOL = 16 ; public static final int REG_NOTEOL = 32 ; public static final int REG_ANCHORINDEX = 64 ; public static final int REG_NO_INTERPOLATE = 128 ; public static final String version ( ) { return s_version ; } static final String getLocalizedMessage ( String key ) { return messages . getString ( key ) ; } public RE ( Object pattern ) throws REException { this ( pattern , 0 , RESyntax . RE_SYNTAX_PERL5 , 0 , 0 ) ; } public RE ( Object pattern , int cflags ) throws REException { this ( pattern , cflags , RESyntax . RE_SYNTAX_PERL5 , 0 , 0 ) ; } public RE ( Object pattern , int cflags , RESyntax syntax ) throws REException { this ( pattern , cflags , syntax , 0 , 0 ) ; } private RE ( REToken first , REToken last , int subs , int subIndex , int minLength ) { super ( subIndex ) ; firstToken = first ; lastToken = last ; numSubs = subs ; minimumLength = minLength ; addToken ( new RETokenEndSub ( subIndex ) ) ; } private RE ( Object patternObj , int cflags , RESyntax syntax , int myIndex , int nextSub ) throws REException { super ( myIndex ) ; char [ ] pattern ; if ( patternObj instanceof String ) { pattern = ( ( String ) patternObj ) . toCharArray ( ) ; } else if ( patternObj instanceof char [ ] ) { pattern = ( char [ ] ) patternObj ; } else if ( patternObj instanceof StringBuffer ) { pattern = new char [ ( ( StringBuffer ) patternObj ) . length ( ) ] ; ( ( StringBuffer ) patternObj ) . getChars ( 0 , pattern . length , pattern , 0 ) ; } else { pattern = patternObj . toString ( ) . toCharArray ( ) ; } int pLength = pattern . length ; numSubs = 0 ; Vector branches = null ; firstToken = lastToken = null ; boolean insens = ( ( cflags & REG_ICASE ) > 0 ) ; int index = 0 ; CharUnit unit = new CharUnit ( ) ; IntPair minMax = new IntPair ( ) ; REToken currentToken = null ; char ch ; while ( index < pLength ) { index = getCharUnit ( pattern , index , unit ) ; if ( ( ( unit . ch == '|' && ( syntax . get ( RESyntax . RE_NO_BK_VBAR ) ^ unit . bk ) ) || ( syntax . get ( RESyntax . RE_NEWLINE_ALT ) && ( unit . ch == '\n' ) && ! unit . bk ) ) && ! syntax . get ( RESyntax . RE_LIMITED_OPS ) ) { addToken ( currentToken ) ; RE theBranch = new RE ( firstToken , lastToken , numSubs , subIndex , minimumLength ) ; if ( branches == null ) { branches = new Vector ( ) ; minimumLength = 0 ; } branches . addElement ( theBranch ) ; firstToken = lastToken = currentToken = null ; } else if ( ( unit . ch == '{' ) && syntax . get ( RESyntax . RE_INTERVALS ) && ( syntax . get ( RESyntax . RE_NO_BK_BRACES ) ^ unit . bk ) ) { int newIndex = getMinMax ( pattern , index , minMax , syntax ) ; if ( newIndex > index ) { if ( minMax . first > minMax . second ) throw new REException ( getLocalizedMessage ( "interval.order" ) , REException . REG_BADRPT , newIndex ) ; if ( currentToken == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , newIndex ) ; if ( currentToken instanceof RETokenRepeated ) throw new REException ( getLocalizedMessage ( "repeat.chained" ) , REException . REG_BADRPT , newIndex ) ; if ( currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary ) throw new REException ( getLocalizedMessage ( "repeat.assertion" ) , REException . REG_BADRPT , newIndex ) ; if ( ( currentToken . getMinimumLength ( ) == 0 ) && ( minMax . second == Integer . MAX_VALUE ) ) throw new REException ( getLocalizedMessage ( "repeat.empty.token" ) , REException . REG_BADRPT , newIndex ) ; index = newIndex ; currentToken = setRepeated ( currentToken , minMax . first , minMax . second , index ) ; } else { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , unit . ch , insens ) ; } } else if ( ( unit . ch == '[' ) && ! unit . bk ) { Vector options = new Vector ( ) ; boolean negative = false ; char lastChar = 0 ; if ( index == pLength ) throw new REException ( getLocalizedMessage ( "unmatched.bracket" ) , REException . REG_EBRACK , index ) ; if ( ( ch = pattern [ index ] ) == '^' ) { negative = true ; if ( ++ index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; ch = pattern [ index ] ; } if ( ch == ']' ) { lastChar = ch ; if ( ++ index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; } while ( ( ch = pattern [ index ++ ] ) != ']' ) { if ( ( ch == '-' ) && ( lastChar != 0 ) ) { if ( index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; if ( ( ch = pattern [ index ] ) == ']' ) { options . addElement ( new RETokenChar ( subIndex , lastChar , insens ) ) ; lastChar = '-' ; } else { options . addElement ( new RETokenRange ( subIndex , lastChar , ch , insens ) ) ; lastChar = 0 ; index ++ ; } } else if ( ( ch == '\\' ) && syntax . get ( RESyntax . RE_BACKSLASH_ESCAPE_IN_LISTS ) ) { if ( index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; int posixID = - 1 ; boolean negate = false ; char asciiEsc = 0 ; if ( ( "dswDSW" . indexOf ( pattern [ index ] ) != - 1 ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESC_IN_LISTS ) ) { switch ( pattern [ index ] ) { case 'D' : negate = true ; case 'd' : posixID = RETokenPOSIX . DIGIT ; break ; case 'S' : negate = true ; case 's' : posixID = RETokenPOSIX . SPACE ; break ; case 'W' : negate = true ; case 'w' : posixID = RETokenPOSIX . ALNUM ; break ; } } else if ( "nrt" . indexOf ( pattern [ index ] ) != - 1 ) { switch ( pattern [ index ] ) { case 'n' : asciiEsc = '\n' ; break ; case 't' : asciiEsc = '\t' ; break ; case 'r' : asciiEsc = '\r' ; break ; } } if ( lastChar != 0 ) options . addElement ( new RETokenChar ( subIndex , lastChar , insens ) ) ; if ( posixID != - 1 ) { options . addElement ( new RETokenPOSIX ( subIndex , posixID , insens , negate ) ) ; } else if ( asciiEsc != 0 ) { lastChar = asciiEsc ; } else { lastChar = pattern [ index ] ; } ++ index ; } else if ( ( ch == '[' ) && ( syntax . get ( RESyntax . RE_CHAR_CLASSES ) ) && ( index < pLength ) && ( pattern [ index ] == ':' ) ) { StringBuffer posixSet = new StringBuffer ( ) ; index = getPosixSet ( pattern , index + 1 , posixSet ) ; int posixId = RETokenPOSIX . intValue ( posixSet . toString ( ) ) ; if ( posixId != - 1 ) options . addElement ( new RETokenPOSIX ( subIndex , posixId , insens , false ) ) ; } else { if ( lastChar != 0 ) options . addElement ( new RETokenChar ( subIndex , lastChar , insens ) ) ; lastChar = ch ; } if ( index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; } if ( lastChar != 0 ) options . addElement ( new RETokenChar ( subIndex , lastChar , insens ) ) ; addToken ( currentToken ) ; options . trimToSize ( ) ; currentToken = new RETokenOneOf ( subIndex , options , negative ) ; } else if ( ( unit . ch == '(' ) && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) { boolean pure = false ; boolean comment = false ; boolean lookAhead = false ; boolean negativelh = false ; if ( ( index + 1 < pLength ) && ( pattern [ index ] == '?' ) ) { switch ( pattern [ index + 1 ] ) { case '!' : if ( syntax . get ( RESyntax . RE_LOOKAHEAD ) ) { pure = true ; negativelh = true ; lookAhead = true ; index += 2 ; } break ; case '=' : if ( syntax . get ( RESyntax . RE_LOOKAHEAD ) ) { pure = true ; lookAhead = true ; index += 2 ; } break ; case ':' : if ( syntax . get ( RESyntax . RE_PURE_GROUPING ) ) { pure = true ; index += 2 ; } break ; case '#' : if ( syntax . get ( RESyntax . RE_COMMENTS ) ) { comment = true ; } break ; default : throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; } } if ( index >= pLength ) { throw new REException ( getLocalizedMessage ( "unmatched.paren" ) , REException . REG_ESUBREG , index ) ; } int endIndex = index ; int nextIndex = index ; int nested = 0 ; while ( ( ( nextIndex = getCharUnit ( pattern , endIndex , unit ) ) > 0 ) && ! ( nested == 0 && ( unit . ch == ')' ) && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) ) if ( ( endIndex = nextIndex ) >= pLength ) throw new REException ( getLocalizedMessage ( "subexpr.no.end" ) , REException . REG_ESUBREG , nextIndex ) ; else if ( unit . ch == '(' && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) nested ++ ; else if ( unit . ch == ')' && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) nested -- ; if ( comment ) index = nextIndex ; else { addToken ( currentToken ) ; if ( ! pure ) { numSubs ++ ; } if ( lookAhead ) currentToken = new RETokenLookAhead ( String . valueOf ( pattern , index , endIndex - index ) . toCharArray ( ) , cflags , syntax , negativelh ) ; else { int useIndex = pure ? 0 : nextSub + numSubs ; currentToken = new RE ( String . valueOf ( pattern , index , endIndex - index ) . toCharArray ( ) , cflags , syntax , useIndex , nextSub + numSubs ) ; numSubs += ( ( RE ) currentToken ) . getNumSubs ( ) ; } index = nextIndex ; } } else if ( ! syntax . get ( RESyntax . RE_UNMATCHED_RIGHT_PAREN_ORD ) && ( ( unit . ch == ')' ) && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) ) { throw new REException ( getLocalizedMessage ( "unmatched.paren" ) , REException . REG_EPAREN , index ) ; } else if ( ( unit . ch == '^' ) && ! unit . bk ) { addToken ( currentToken ) ; currentToken = null ; addToken ( new RETokenStart ( subIndex , ( ( cflags & REG_MULTILINE ) > 0 ) ? syntax . getLineSeparator ( ) : null ) ) ; } else if ( ( unit . ch == '$' ) && ! unit . bk ) { addToken ( currentToken ) ; currentToken = null ; addToken ( new RETokenEnd ( subIndex , ( ( cflags & REG_MULTILINE ) > 0 ) ? syntax . getLineSeparator ( ) : null ) ) ; } else if ( ( unit . ch == '.' ) && ! unit . bk ) { addToken ( currentToken ) ; currentToken = new RETokenAny ( subIndex , syntax . get ( RESyntax . RE_DOT_NEWLINE ) || ( ( cflags & REG_DOT_NEWLINE ) > 0 ) , syntax . get ( RESyntax . RE_DOT_NOT_NULL ) ) ; } else if ( ( unit . ch == '*' ) && ! unit . bk ) { if ( currentToken == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenRepeated ) throw new REException ( getLocalizedMessage ( "repeat.chained" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary ) throw new REException ( getLocalizedMessage ( "repeat.assertion" ) , REException . REG_BADRPT , index ) ; if ( currentToken . getMinimumLength ( ) == 0 ) throw new REException ( getLocalizedMessage ( "repeat.empty.token" ) , REException . REG_BADRPT , index ) ; currentToken = setRepeated ( currentToken , 0 , Integer . MAX_VALUE , index ) ; } else if ( ( unit . ch == '+' ) && ! syntax . get ( RESyntax . RE_LIMITED_OPS ) && ( ! syntax . get ( RESyntax . RE_BK_PLUS_QM ) ^ unit . bk ) ) { if ( currentToken == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenRepeated ) throw new REException ( getLocalizedMessage ( "repeat.chained" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary ) throw new REException ( getLocalizedMessage ( "repeat.assertion" ) , REException . REG_BADRPT , index ) ; if ( currentToken . getMinimumLength ( ) == 0 ) throw new REException ( getLocalizedMessage ( "repeat.empty.token" ) , REException . REG_BADRPT , index ) ; currentToken = setRepeated ( currentToken , 1 , Integer . MAX_VALUE , index ) ; } else if ( ( unit . ch == '?' ) && ! syntax . get ( RESyntax . RE_LIMITED_OPS ) && ( ! syntax . get ( RESyntax . RE_BK_PLUS_QM ) ^ unit . bk ) ) { if ( currentToken == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenRepeated ) { if ( syntax . get ( RESyntax . RE_STINGY_OPS ) && ! ( ( RETokenRepeated ) currentToken ) . isStingy ( ) ) ( ( RETokenRepeated ) currentToken ) . makeStingy ( ) ; else throw new REException ( getLocalizedMessage ( "repeat.chained" ) , REException . REG_BADRPT , index ) ; } else if ( currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary ) throw new REException ( getLocalizedMessage ( "repeat.assertion" ) , REException . REG_BADRPT , index ) ; else currentToken = setRepeated ( currentToken , 0 , 1 , index ) ; } else if ( unit . bk && Character . isDigit ( unit . ch ) && ! syntax . get ( RESyntax . RE_NO_BK_REFS ) ) { addToken ( currentToken ) ; currentToken = new RETokenBackRef ( subIndex , Character . digit ( unit . ch , 10 ) , insens ) ; } else if ( unit . bk && ( unit . ch == 'A' ) && syntax . get ( RESyntax . RE_STRING_ANCHORS ) ) { addToken ( currentToken ) ; currentToken = new RETokenStart ( subIndex , null ) ; } else if ( unit . bk && ( unit . ch == 'b' ) && syntax . get ( RESyntax . RE_STRING_ANCHORS ) ) { addToken ( currentToken ) ; currentToken = new RETokenWordBoundary ( subIndex , RETokenWordBoundary . BEGIN | RETokenWordBoundary . END , false ) ; } else if ( unit . bk && ( unit . ch == '<' ) ) { addToken ( currentToken ) ; currentToken = new RETokenWordBoundary ( subIndex , RETokenWordBoundary . BEGIN , false ) ; } else if ( unit . bk && ( unit . ch == '>' ) ) { addToken ( currentToken ) ; currentToken = new RETokenWordBoundary ( subIndex , RETokenWordBoundary . END , false ) ; } else if ( unit . bk && ( unit . ch == 'B' ) && syntax . get ( RESyntax . RE_STRING_ANCHORS ) ) { addToken ( currentToken ) ; currentToken = new RETokenWordBoundary ( subIndex , RETokenWordBoundary . BEGIN | RETokenWordBoundary . END , true ) ; } else if ( unit . bk && ( unit . ch == 'd' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . DIGIT , insens , false ) ; } else if ( unit . bk && ( unit . ch == 'D' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . DIGIT , insens , true ) ; } else if ( unit . bk && ( unit . ch == 'n' ) ) { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , '\n' , false ) ; } else if ( unit . bk && ( unit . ch == 'r' ) ) { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , '\r' , false ) ; } else if ( unit . bk && ( unit . ch == 's' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . SPACE , insens , false ) ; } else if ( unit . bk && ( unit . ch == 'S' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . SPACE , insens , true ) ; } else if ( unit . bk && ( unit . ch == 't' ) ) { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , '\t' , false ) ; } else if ( unit . bk && ( unit . ch == 'w' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . ALNUM , insens , false ) ; } else if ( unit . bk && ( unit . ch == 'W' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . ALNUM , insens , true ) ; } else if ( unit . bk && ( unit . ch == 'Z' ) && syntax . get ( RESyntax . RE_STRING_ANCHORS ) ) { addToken ( currentToken ) ; currentToken = new RETokenEnd ( subIndex , null ) ; } else { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , unit . ch , insens ) ; } } addToken ( currentToken ) ; if ( branches != null ) { branches . addElement ( new RE ( firstToken , lastToken , numSubs , subIndex , minimumLength ) ) ; branches . trimToSize ( ) ; minimumLength = 0 ; firstToken = lastToken = null ; addToken ( new RETokenOneOf ( subIndex , branches , false ) ) ; } else addToken ( new RETokenEndSub ( subIndex ) ) ; } private static int getCharUnit ( char [ ] input , int index , CharUnit unit ) throws REException { unit . ch = input [ index ++ ] ; if ( unit . bk = ( unit . ch == '\\' ) ) if ( index < input . length ) unit . ch = input [ index ++ ] ; else throw new REException ( getLocalizedMessage ( "ends.with.backslash" ) , REException . REG_ESCAPE , index ) ; return index ; } public boolean isMatch ( Object input ) { return isMatch ( input , 0 , 0 ) ; } public boolean isMatch ( Object input , int index ) { return isMatch ( input , index , 0 ) ; } public boolean isMatch ( Object input , int index , int eflags ) { return isMatchImpl ( makeCharIndexed ( input , index ) , index , eflags ) ; } private boolean isMatchImpl ( CharIndexed input , int index , int eflags ) { if ( firstToken == null ) return ( input . charAt ( 0 ) == CharIndexed . OUT_OF_BOUNDS ) ; REMatch m = new REMatch ( numSubs , index , eflags ) ; if ( firstToken . match ( input , m ) ) { while ( m != null ) { if ( input . charAt ( m . index ) == CharIndexed . OUT_OF_BOUNDS ) { return true ; } m = m . next ; } } return false ; } public int getNumSubs ( ) { return numSubs ; } void setUncle ( REToken uncle ) { if ( lastToken != null ) { lastToken . setUncle ( uncle ) ; } else super . setUncle ( uncle ) ; } boolean chain ( REToken next ) { super . chain ( next ) ; setUncle ( next ) ; return true ; } public int getMinimumLength ( ) { return minimumLength ; } public REMatch [ ] getAllMatches ( Object input ) { return getAllMatches ( input , 0 , 0 ) ; } public REMatch [ ] getAllMatches ( Object input , int index ) { return getAllMatches ( input , index , 0 ) ; } public REMatch [ ] getAllMatches ( Object input , int index , int eflags ) { return getAllMatchesImpl ( makeCharIndexed ( input , index ) , index , eflags ) ; } private REMatch [ ] getAllMatchesImpl ( CharIndexed input , int index , int eflags ) { Vector all = new Vector ( ) ; REMatch m = null ; while ( ( m = getMatchImpl ( input , index , eflags , null ) ) != null ) { all . addElement ( m ) ; index = m . getEndIndex ( ) ; if ( m . end [ 0 ] == 0 ) { index ++ ; input . move ( 1 ) ; } else { input . move ( m . end [ 0 ] ) ; } if ( ! input . isValid ( ) ) break ; } REMatch [ ] mset = new REMatch [ all . size ( ) ] ; all . copyInto ( mset ) ; return mset ; } boolean match ( CharIndexed input , REMatch mymatch ) { if ( firstToken == null ) return next ( input , mymatch ) ; mymatch . start [ subIndex ] = mymatch . index ; return firstToken . match ( input , mymatch ) ; } public REMatch getMatch ( Object input ) { return getMatch ( input , 0 , 0 ) ; } public REMatch getMatch ( Object input , int index ) { return getMatch ( input , index , 0 ) ; } public REMatch getMatch ( Object input , int index , int eflags ) { return getMatch ( input , index , eflags , null ) ; } public REMatch getMatch ( Object input , int index , int eflags , StringBuffer buffer ) { return getMatchImpl ( makeCharIndexed ( input , index ) , index , eflags , buffer ) ; } REMatch getMatchImpl ( CharIndexed input , int index , int eflags , StringBuffer buffer ) { REMatch mymatch = new REMatch ( numSubs , index , eflags ) ; do { if ( minimumLength == 0 || input . charAt ( minimumLength - 1 ) != CharIndexed . OUT_OF_BOUNDS ) { if ( match ( input , mymatch ) ) { REMatch longest = mymatch ; while ( ( mymatch = mymatch . next ) != null ) { if ( mymatch . index > longest . index ) { longest = mymatch ; } } longest . end [ 0 ] = longest . index ; longest . finish ( input ) ; return longest ; } } mymatch . clear ( ++ index ) ; if ( buffer != null && input . charAt ( 0 ) != CharIndexed . OUT_OF_BOUNDS ) { buffer . append ( input . charAt ( 0 ) ) ; } } while ( input . move ( 1 ) ) ; return null ; } public REMatchEnumeration getMatchEnumeration ( Object input ) { return getMatchEnumeration ( input , 0 , 0 ) ; } public REMatchEnumeration getMatchEnumeration ( Object input , int index ) { return getMatchEnumeration ( input , index , 0 ) ; } public REMatchEnumeration getMatchEnumeration ( Object input , int index , int eflags ) { return new REMatchEnumeration ( this , makeCharIndexed ( input , index ) , index , eflags ) ; } public String substitute ( Object input , String replace ) { return substitute ( input , replace , 0 , 0 ) ; } public String substitute ( Object input , String replace , int index ) { return substitute ( input , replace , index , 0 ) ; } public String substitute ( Object input , String replace , int index , int eflags ) { return substituteImpl ( makeCharIndexed ( input , index ) , replace , index , eflags ) ; } private String substituteImpl ( CharIndexed input , String replace , int index , int eflags ) { StringBuffer buffer = new StringBuffer ( ) ; REMatch m = getMatchImpl ( input , index , eflags , buffer ) ; if ( m == null ) return buffer . toString ( ) ; buffer . append ( ( ( eflags & REG_NO_INTERPOLATE ) > 0 ) ? replace : m . substituteInto ( replace ) ) ; if ( input . move ( m . end [ 0 ] ) ) { do { buffer . append ( input . charAt ( 0 ) ) ; } while ( input . move ( 1 ) ) ; } return buffer . toString ( ) ; } public String substituteAll ( Object input , String replace ) { return substituteAll ( input , replace , 0 , 0 ) ; } public String substituteAll ( Object input , String replace , int index ) { return substituteAll ( input , replace , index , 0 ) ; } public String substituteAll ( Object input , String replace , int index , int eflags ) { return substituteAllImpl ( makeCharIndexed ( input , index ) , replace , index , eflags ) ; } private String substituteAllImpl ( CharIndexed input , String replace , int index , int eflags ) { StringBuffer buffer = new StringBuffer ( ) ; REMatch m ; while ( ( m = getMatchImpl ( input , index , eflags , buffer ) ) != null ) { buffer . append ( ( ( eflags & REG_NO_INTERPOLATE ) > 0 ) ? replace : m . substituteInto ( replace ) ) ; index = m . getEndIndex ( ) ; if ( m . end [ 0 ] == 0 ) { char ch = input . charAt ( 0 ) ; if ( ch != CharIndexed . OUT_OF_BOUNDS ) buffer . append ( ch ) ; input . move ( 1 ) ; } else { input . move ( m . end [ 0 ] ) ; } if ( ! input . isValid ( ) ) break ; } return buffer . toString ( ) ; } private void addToken ( REToken next ) { if ( next == null ) return ; minimumLength += next . getMinimumLength ( ) ; if ( firstToken == null ) { lastToken = firstToken = next ; } else { if ( lastToken . chain ( next ) ) { lastToken = next ; } } } private static REToken setRepeated ( REToken current , int min , int max , int index ) throws REException { if ( current == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; return new RETokenRepeated ( current . subIndex , current , min , max ) ; } private static int getPosixSet ( char [ ] pattern , int index , StringBuffer buf ) { int i ; for ( i = index ; i < ( pattern . length - 1 ) ; i ++ ) { if ( ( pattern [ i ] == ':' ) && ( pattern [ i + 1 ] == ']' ) ) return i + 2 ; buf . append ( pattern [ i ] ) ; } return index ; } private int getMinMax ( char [ ] input , int index , IntPair minMax , RESyntax syntax ) throws REException { boolean mustMatch = ! syntax . get ( RESyntax . RE_NO_BK_BRACES ) ; int startIndex = index ; if ( index == input . length ) { if ( mustMatch ) throw new REException ( getLocalizedMessage ( "unmatched.brace" ) , REException . REG_EBRACE , index ) ; else return startIndex ; } int min , max = 0 ; CharUnit unit = new CharUnit ( ) ; StringBuffer buf = new StringBuffer ( ) ; do { index = getCharUnit ( input , index , unit ) ; if ( Character . isDigit ( unit . ch ) ) buf . append ( unit . ch ) ; } while ( ( index != input . length ) && Character . isDigit ( unit . ch ) ) ; if ( buf . length ( ) == 0 ) { if ( mustMatch ) throw new REException ( getLocalizedMessage ( "interval.error" ) , REException . REG_EBRACE , index ) ; else return startIndex ; } min = Integer . parseInt ( buf . toString ( ) ) ; if ( ( unit . ch == '}' ) && ( syntax . get ( RESyntax . RE_NO_BK_BRACES ) ^ unit . bk ) ) max = min ; else if ( index == input . length ) if ( mustMatch ) throw new REException ( getLocalizedMessage ( "interval.no.end" ) , REException . REG_EBRACE , index ) ; else return startIndex ; else if ( ( unit . ch == ',' ) && ! unit . bk ) { buf = new StringBuffer ( ) ; while ( ( ( index = getCharUnit ( input , index , unit ) ) != input . length ) && Character . isDigit ( unit . ch ) ) buf . append ( unit . ch ) ; if ( ! ( ( unit . ch == '}' ) && ( syntax . get ( RESyntax . RE_NO_BK_BRACES ) ^ unit . bk ) ) ) if ( mustMatch ) throw new REException ( getLocalizedMessage ( "interval.error" ) , REException . REG_EBRACE , index ) ; else return startIndex ; if ( buf . length ( ) == 0 ) max = Integer . MAX_VALUE ; else max = Integer . parseInt ( buf . toString ( ) ) ; } else if ( mustMatch ) throw new REException ( getLocalizedMessage ( "interval.error" ) , REException . REG_EBRACE , index ) ; else return startIndex ; minMax . first = min ; minMax . second = max ; return index ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; dump ( sb ) ; return sb . toString ( ) ; } void dump ( StringBuffer os ) { os . append ( '(' ) ; if ( subIndex == 0 ) os . append ( "?:" ) ; if ( firstToken != null ) firstToken . dumpAll ( os ) ; os . append ( ')' ) ; } private static CharIndexed makeCharIndexed ( Object input , int index ) { if ( input instanceof String ) return new CharIndexedString ( ( String ) input , index ) ; else if ( input instanceof char [ ] ) return new CharIndexedCharArray ( ( char [ ] ) input , index ) ; else if ( input instanceof StringBuffer ) return new CharIndexedStringBuffer ( ( StringBuffer ) input , index ) ; else if ( input instanceof InputStream ) return new CharIndexedInputStream ( ( InputStream ) input , index ) ; else if ( input instanceof Reader ) return new CharIndexedReader ( ( Reader ) input , index ) ; else if ( input instanceof CharIndexed ) return ( CharIndexed ) input ; else return new CharIndexedString ( input . toString ( ) , index ) ; } } 	0	['45', '2', '0', '34', '107', '928', '13', '25', '26', '0.93006993', '2533', '0.461538462', '2', '0.152173913', '0.231060606', '1', '2', '55', '9', '1.7778', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class EditorExiting extends EBMessage . NonVetoable { public EditorExiting ( EBComponent source ) { super ( source ) ; } } 	0	['1', '3', '0', '3', '2', '0', '1', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package gnu . regexp ; final class RETokenPOSIX extends REToken { int type ; boolean insens ; boolean negated ; static final int ALNUM = 0 ; static final int ALPHA = 1 ; static final int BLANK = 2 ; static final int CNTRL = 3 ; static final int DIGIT = 4 ; static final int GRAPH = 5 ; static final int LOWER = 6 ; static final int PRINT = 7 ; static final int PUNCT = 8 ; static final int SPACE = 9 ; static final int UPPER = 10 ; static final int XDIGIT = 11 ; static final String [ ] s_nameTable = { "alnum" , "alpha" , "blank" , "cntrl" , "digit" , "graph" , "lower" , "print" , "punct" , "space" , "upper" , "xdigit" } ; static int intValue ( String key ) { for ( int i = 0 ; i < s_nameTable . length ; i ++ ) { if ( s_nameTable [ i ] . equals ( key ) ) return i ; } return - 1 ; } RETokenPOSIX ( int subIndex , int type , boolean insens , boolean negated ) { super ( subIndex ) ; this . type = type ; this . insens = insens ; this . negated = negated ; } int getMinimumLength ( ) { return 1 ; } boolean match ( CharIndexed input , REMatch mymatch ) { char ch = input . charAt ( mymatch . index ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return false ; boolean retval = false ; switch ( type ) { case ALNUM : retval = Character . isLetterOrDigit ( ch ) || ( ch == '_' ) ; break ; case ALPHA : retval = Character . isLetter ( ch ) ; break ; case BLANK : retval = ( ( ch == ' ' ) || ( ch == '\t' ) ) ; break ; case CNTRL : retval = Character . isISOControl ( ch ) ; break ; case DIGIT : retval = Character . isDigit ( ch ) ; break ; case GRAPH : retval = ( ! ( Character . isWhitespace ( ch ) || Character . isISOControl ( ch ) ) ) ; break ; case LOWER : retval = ( ( insens && Character . isLetter ( ch ) ) || Character . isLowerCase ( ch ) ) ; break ; case PRINT : retval = ( ! ( Character . isWhitespace ( ch ) || Character . isISOControl ( ch ) ) ) || ( ch == ' ' ) ; break ; case PUNCT : retval = ( "`~!@#$%^&*()-_=+[]{}\\|;:'\"/?,.<>" . indexOf ( ch ) != - 1 ) ; break ; case SPACE : retval = Character . isWhitespace ( ch ) ; break ; case UPPER : retval = ( ( insens && Character . isLetter ( ch ) ) || Character . isUpperCase ( ch ) ) ; break ; case XDIGIT : retval = ( Character . isDigit ( ch ) || ( "abcdefABCDEF" . indexOf ( ch ) != - 1 ) ) ; break ; } if ( negated ) retval = ! retval ; if ( retval ) { ++ mymatch . index ; return next ( input , mymatch ) ; } else return false ; } void dump ( StringBuffer os ) { if ( negated ) os . append ( '^' ) ; os . append ( "[:" + s_nameTable [ type ] + ":]" ) ; } } 	0	['6', '2', '0', '4', '22', '3', '1', '3', '0', '1.0625', '288', '0', '0', '0.636363636', '0.285714286', '1', '2', '44.33333333', '25', '5.1667', '0']
package gnu . regexp ; import java . io . FilterInputStream ; import java . io . InputStream ; public class REFilterInputStream extends FilterInputStream { private RE expr ; private String replace ; private String buffer ; private int bufpos ; private int offset ; private CharIndexedInputStream stream ; public REFilterInputStream ( InputStream stream , RE expr , String replace ) { super ( stream ) ; this . stream = new CharIndexedInputStream ( stream , 0 ) ; this . expr = expr ; this . replace = replace ; } public int read ( ) { if ( ( buffer != null ) && ( bufpos < buffer . length ( ) ) ) { return ( int ) buffer . charAt ( bufpos ++ ) ; } if ( ! stream . isValid ( ) ) return - 1 ; REMatch mymatch = new REMatch ( expr . getNumSubs ( ) , offset , 0 ) ; if ( expr . match ( stream , mymatch ) ) { mymatch . end [ 0 ] = mymatch . index ; mymatch . finish ( stream ) ; stream . move ( mymatch . toString ( ) . length ( ) ) ; offset += mymatch . toString ( ) . length ( ) ; buffer = mymatch . substituteInto ( replace ) ; bufpos = 1 ; if ( buffer . length ( ) > 0 ) { return buffer . charAt ( 0 ) ; } } char ch = stream . charAt ( 0 ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return - 1 ; stream . move ( 1 ) ; offset ++ ; return ch ; } public boolean markSupported ( ) { return false ; } public int read ( byte [ ] b , int off , int len ) { int i ; int ok = 0 ; while ( len -- > 0 ) { i = read ( ) ; if ( i == - 1 ) return ( ok == 0 ) ? - 1 : ok ; b [ off ++ ] = ( byte ) i ; ok ++ ; } return ok ; } public int read ( byte [ ] b ) { return read ( b , 0 , b . length ) ; } } 	0	['5', '3', '0', '4', '18', '8', '0', '4', '5', '0.375', '173', '1', '2', '0.818181818', '0.366666667', '2', '3', '32.4', '7', '2.6', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class SearchSettingsChanged extends EBMessage . NonVetoable { public SearchSettingsChanged ( EBComponent source ) { super ( source ) ; } } 	0	['1', '3', '0', '4', '2', '0', '2', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package gnu . regexp ; final class RETokenAny extends REToken { private boolean newline ; private boolean matchNull ; RETokenAny ( int subIndex , boolean newline , boolean matchNull ) { super ( subIndex ) ; this . newline = newline ; this . matchNull = matchNull ; } int getMinimumLength ( ) { return 1 ; } boolean match ( CharIndexed input , REMatch mymatch ) { char ch = input . charAt ( mymatch . index ) ; if ( ( ch == CharIndexed . OUT_OF_BOUNDS ) || ( ! newline && ( ch == '\n' ) ) || ( matchNull && ( ch == 0 ) ) ) { return false ; } ++ mymatch . index ; return next ( input , mymatch ) ; } void dump ( StringBuffer os ) { os . append ( '.' ) ; } } 	0	['4', '2', '0', '4', '8', '4', '1', '3', '0', '0.666666667', '55', '1', '0', '0.7', '0.375', '1', '2', '12.25', '6', '2', '0']
package bsh ; import java . util . * ; import java . io . InputStream ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . IOException ; public class NameSpace implements java . io . Serializable , BshClassManager . Listener , NameSource { public static final NameSpace JAVACODE = new NameSpace ( "Called from compiled Java code" ) ; public String name ; private NameSpace parent ; private Hashtable variables ; private Hashtable methods ; private Hashtable importedClasses ; private This thisReference ; private Vector importedPackages ; transient private static boolean superImport ; transient private Hashtable classCache ; public NameSpace ( String name ) { this ( null , name ) ; } public NameSpace ( NameSpace parent , String name ) { setName ( name ) ; setParent ( parent ) ; BshClassManager . addCMListener ( this ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return this . name ; } SimpleNode callerInfoNode ; void setNode ( SimpleNode node ) { this . callerInfoNode = node ; } SimpleNode getNode ( ) { return this . callerInfoNode ; } public Object get ( String name , Interpreter interpreter ) throws EvalError { CallStack callstack = new CallStack ( ) ; return getNameResolver ( name ) . toObject ( callstack , interpreter ) ; } public void setVariable ( String name , Object value ) throws EvalError { if ( variables == null ) variables = new Hashtable ( ) ; if ( value == null ) { variables . remove ( name ) ; return ; } boolean recurse = Interpreter . strictJava ; Object current = getVariableImpl ( name , recurse ) ; if ( ( current != null ) && ( current instanceof TypedVariable ) ) { try { ( ( TypedVariable ) current ) . setValue ( value ) ; } catch ( EvalError e ) { throw new EvalError ( "Typed variable: " + name + ": " + e . getMessage ( ) ) ; } } else if ( Interpreter . strictJava ) throw new EvalError ( "(Strict Java mode) Assignment to undeclared variable: " + name ) ; else { variables . put ( name , value ) ; } } public String [ ] getVariableNames ( ) { if ( variables == null ) return new String [ 0 ] ; else return enumerationToStringArray ( variables . keys ( ) ) ; } public String [ ] getMethodNames ( ) { if ( methods == null ) return new String [ 0 ] ; else return enumerationToStringArray ( methods . keys ( ) ) ; } private String [ ] enumerationToStringArray ( Enumeration e ) { Vector v = new Vector ( ) ; while ( e . hasMoreElements ( ) ) v . addElement ( e . nextElement ( ) ) ; String [ ] sa = new String [ v . size ( ) ] ; v . copyInto ( sa ) ; return sa ; } public NameSpace getParent ( ) { return parent ; } public NameSpace getSuper ( ) { if ( parent != null ) return parent ; else return this ; } public NameSpace getGlobal ( ) { if ( parent != null ) return parent . getGlobal ( ) ; else return this ; } This getThis ( Interpreter declaringInterpreter ) { if ( thisReference == null ) thisReference = This . getThis ( this , declaringInterpreter ) ; return thisReference ; } public void prune ( ) { parent = null ; } public void setParent ( NameSpace parent ) { this . parent = parent ; } public Object getVariable ( String name ) { return getVariable ( name , true ) ; } public Object getVariable ( String name , boolean recurse ) { Object val = getVariableImpl ( name , recurse ) ; return unwrapVariable ( val ) ; } protected Object unwrapVariable ( Object val ) { if ( val instanceof TypedVariable ) val = ( ( TypedVariable ) val ) . getValue ( ) ; return ( val == null ) ? Primitive . VOID : val ; } protected Object getVariableImpl ( String name , boolean recurse ) { Object val = null ; if ( variables != null ) val = variables . get ( name ) ; if ( recurse && ( val == null ) && ( parent != null ) ) val = parent . getVariableImpl ( name , recurse ) ; return val ; } public void setTypedVariable ( String name , Class type , Object value , boolean isFinal ) throws EvalError { if ( variables == null ) variables = new Hashtable ( ) ; if ( value == null ) { if ( type . isPrimitive ( ) ) { if ( type == Boolean . TYPE ) value = new Primitive ( Boolean . FALSE ) ; else if ( type == Byte . TYPE ) value = new Primitive ( ( byte ) 0 ) ; else if ( type == Short . TYPE ) value = new Primitive ( ( short ) 0 ) ; else if ( type == Character . TYPE ) value = new Primitive ( ( char ) 0 ) ; else if ( type == Integer . TYPE ) value = new Primitive ( ( int ) 0 ) ; else if ( type == Long . TYPE ) value = new Primitive ( 0L ) ; else if ( type == Float . TYPE ) value = new Primitive ( 0.0f ) ; else if ( type == Double . TYPE ) value = new Primitive ( 0.0d ) ; } else value = Primitive . NULL ; } if ( variables . containsKey ( name ) ) { Object existing = getVariableImpl ( name , false ) ; if ( existing instanceof TypedVariable ) { if ( ( ( TypedVariable ) existing ) . getType ( ) != type ) throw new EvalError ( "Typed variable: " + name + " was previously declared with type: " + ( ( TypedVariable ) existing ) . getType ( ) ) ; else { ( ( TypedVariable ) existing ) . setValue ( value ) ; return ; } } } variables . put ( name , new TypedVariable ( type , value , isFinal ) ) ; } public void setMethod ( String name , BshMethod method ) { if ( methods == null ) methods = new Hashtable ( ) ; Object m = methods . get ( name ) ; if ( m == null ) methods . put ( name , method ) ; else if ( m instanceof BshMethod ) { Vector v = new Vector ( ) ; v . addElement ( m ) ; v . addElement ( method ) ; methods . put ( name , v ) ; } else ( ( Vector ) m ) . addElement ( method ) ; } public BshMethod getMethod ( String name , Class [ ] sig ) { BshMethod method = null ; Object m = null ; if ( methods != null ) m = methods . get ( name ) ; if ( m instanceof Vector ) { Vector vm = ( Vector ) m ; BshMethod [ ] ma = new BshMethod [ vm . size ( ) ] ; vm . copyInto ( ma ) ; Class [ ] [ ] candidates = new Class [ ma . length ] [ ] ; for ( int i = 0 ; i < ma . length ; i ++ ) candidates [ i ] = ma [ i ] . getArgTypes ( ) ; int match = Reflect . findMostSpecificSignature ( sig , candidates ) ; if ( match != - 1 ) method = ma [ match ] ; } else method = ( BshMethod ) m ; if ( ( method == null ) && ( parent != null ) ) return parent . getMethod ( name , sig ) ; return method ; } public void importClass ( String name ) { if ( importedClasses == null ) importedClasses = new Hashtable ( ) ; importedClasses . put ( Name . suffix ( name , 1 ) , name ) ; nameSpaceChanged ( ) ; } private String getImportedClass ( String name ) throws ClassPathException { String s = null ; if ( importedClasses != null ) s = ( String ) importedClasses . get ( name ) ; if ( ( s == null ) && ( parent != null ) ) return ( String ) parent . getImportedClass ( name ) ; return s ; } public void importPackage ( String name ) { if ( importedPackages == null ) importedPackages = new Vector ( ) ; importedPackages . addElement ( name ) ; nameSpaceChanged ( ) ; } public String [ ] getImportedPackages ( ) { Vector v = new Vector ( ) ; if ( parent != null ) { String [ ] psa = parent . getImportedPackages ( ) ; for ( int i = 0 ; i < psa . length ; i ++ ) v . addElement ( psa [ i ] ) ; } if ( importedPackages != null ) for ( int i = 0 ; i < importedPackages . size ( ) ; i ++ ) v . addElement ( importedPackages . elementAt ( i ) ) ; String [ ] packages = new String [ v . size ( ) ] ; v . copyInto ( packages ) ; return packages ; } public Class getClass ( String name ) throws ClassPathException { Class c = null ; if ( classCache != null ) c = ( Class ) classCache . get ( name ) ; if ( c == null ) { c = getClassImpl ( name ) ; if ( c != null ) { if ( classCache == null ) classCache = new Hashtable ( ) ; classCache . put ( name , c ) ; } } return c ; } private Class getClassImpl ( String name ) throws ClassPathException { if ( ! Name . isCompound ( name ) ) { String fullname = getImportedClass ( name ) ; if ( fullname != null ) { Class clas = classForName ( fullname ) ; if ( clas == null ) { if ( Name . isCompound ( fullname ) ) try { clas = getNameResolver ( fullname ) . toClass ( ) ; } catch ( EvalError e ) { } else Interpreter . debug ( "imported unpackaged name not found:" + fullname ) ; } if ( clas != null ) { BshClassManager . cacheClassInfo ( fullname , clas ) ; return clas ; } return null ; } String [ ] packages = getImportedPackages ( ) ; for ( int i = packages . length - 1 ; i >= 0 ; i -- ) { String s = packages [ i ] + "." + name ; Class c = classForName ( s ) ; if ( c != null ) return c ; } if ( superImport ) { BshClassManager bcm = BshClassManager . getClassManager ( ) ; if ( bcm != null ) { String s = bcm . getClassNameByUnqName ( name ) ; if ( s != null ) return classForName ( s ) ; } } } Class c = classForName ( name ) ; if ( c != null ) return c ; Interpreter . debug ( "getClass(): " + name + " not	found in " + this ) ; return null ; } private Class classForName ( String name ) { return BshClassManager . classForName ( name ) ; } public String [ ] getAllNames ( ) { Vector vec = new Vector ( ) ; getAllNamesAux ( vec ) ; String [ ] names = new String [ vec . size ( ) ] ; vec . copyInto ( names ) ; return names ; } protected void getAllNamesAux ( Vector vec ) { Enumeration varNames = variables . keys ( ) ; while ( varNames . hasMoreElements ( ) ) vec . addElement ( varNames . nextElement ( ) ) ; Enumeration methodNames = methods . keys ( ) ; while ( methodNames . hasMoreElements ( ) ) vec . addElement ( methodNames . nextElement ( ) ) ; if ( parent != null ) parent . getAllNamesAux ( vec ) ; } Vector nameSourceListeners ; public void addNameSourceListener ( NameSource . Listener listener ) { if ( nameSourceListeners == null ) nameSourceListeners = new Vector ( ) ; nameSourceListeners . addElement ( listener ) ; } public static void doSuperImport ( ) throws EvalError { BshClassManager bcm = BshClassManager . getClassManager ( ) ; if ( bcm != null ) bcm . doSuperImport ( ) ; superImport = true ; } static class TypedVariable implements java . io . Serializable { Class type ; Object value = null ; boolean isFinal ; TypedVariable ( Class type , Object value , boolean isFinal ) throws EvalError { this . type = type ; if ( type == null ) throw new InterpreterError ( "null type in typed var: " + value ) ; this . isFinal = isFinal ; setValue ( value ) ; } void setValue ( Object val ) throws EvalError { if ( isFinal && value != null ) throw new EvalError ( "Final variable, can't assign" ) ; val = getAssignableForm ( val , type ) ; if ( val instanceof Primitive && ( ( Primitive ) val ) . isNumber ( ) ) try { val = BSHCastExpression . castPrimitive ( ( Primitive ) val , type ) ; } catch ( EvalError e ) { throw new InterpreterError ( "auto assignment cast failed" ) ; } this . value = val ; } Object getValue ( ) { return value ; } Class getType ( ) { return type ; } public String toString ( ) { return "TypedVariable: " + type + ", value:" + value ; } } public static Object checkAssignableFrom ( Object rhs , Class lhsType ) throws EvalError { return getAssignableForm ( rhs , lhsType ) ; } static Object getAssignableForm ( Object rhs , Class lhsType ) throws EvalError { Class originalType ; if ( lhsType == null ) throw new InterpreterError ( "Null value for type in getAssignableForm" ) ; if ( rhs == null ) throw new InterpreterError ( "Null value in getAssignableForm." ) ; if ( rhs == Primitive . VOID ) throw new EvalError ( "Undefined variable or class name" ) ; if ( rhs == Primitive . NULL ) if ( ! lhsType . isPrimitive ( ) ) return rhs ; else throw new EvalError ( "Can't assign null to primitive type " + lhsType . getName ( ) ) ; Class rhsType ; if ( rhs instanceof Primitive ) { rhsType = originalType = ( ( Primitive ) rhs ) . getType ( ) ; if ( lhsType . isPrimitive ( ) ) { } else { if ( Boolean . class . isAssignableFrom ( lhsType ) || Character . class . isAssignableFrom ( lhsType ) || Number . class . isAssignableFrom ( lhsType ) ) { rhs = ( ( Primitive ) rhs ) . getValue ( ) ; rhsType = rhs . getClass ( ) ; } else assignmentError ( lhsType , originalType ) ; } } else { rhsType = originalType = rhs . getClass ( ) ; if ( lhsType . isPrimitive ( ) ) { if ( rhsType == Boolean . class ) { rhs = new Primitive ( ( Boolean ) rhs ) ; rhsType = Boolean . TYPE ; } else if ( rhsType == Character . class ) { rhs = new Primitive ( ( Character ) rhs ) ; rhsType = Character . TYPE ; } else if ( Number . class . isAssignableFrom ( rhsType ) ) { rhs = new Primitive ( ( Number ) rhs ) ; rhsType = ( ( Primitive ) rhs ) . getType ( ) ; } else assignmentError ( lhsType , originalType ) ; } } if ( Reflect . isAssignableFrom ( lhsType , rhsType ) ) return rhs ; if ( lhsType == Short . class ) if ( rhsType == Byte . class ) return new Short ( ( ( Number ) rhs ) . shortValue ( ) ) ; if ( lhsType == Integer . class ) { if ( rhsType == Byte . class || rhsType == Short . class ) return new Integer ( ( ( Number ) rhs ) . intValue ( ) ) ; if ( rhsType == Character . class ) return new Integer ( ( ( Number ) rhs ) . intValue ( ) ) ; } if ( lhsType == Long . class ) { if ( rhsType == Byte . class || rhsType == Short . class || rhsType == Integer . class ) return new Long ( ( ( Number ) rhs ) . longValue ( ) ) ; if ( rhsType == Character . class ) return new Long ( ( ( Number ) rhs ) . longValue ( ) ) ; } if ( lhsType == Float . class ) { if ( rhsType == Byte . class || rhsType == Short . class || rhsType == Integer . class || rhsType == Long . class ) return new Float ( ( ( Number ) rhs ) . floatValue ( ) ) ; if ( rhsType == Character . class ) return new Float ( ( ( Number ) rhs ) . floatValue ( ) ) ; } if ( lhsType == Double . class ) { if ( rhsType == Byte . class || rhsType == Short . class || rhsType == Integer . class || rhsType == Long . class || rhsType == Float . class ) return new Double ( ( ( Number ) rhs ) . doubleValue ( ) ) ; if ( rhsType == Character . class ) return new Double ( ( ( Number ) rhs ) . doubleValue ( ) ) ; } if ( Capabilities . canGenerateInterfaces ( ) && lhsType . isInterface ( ) && ( rhs instanceof bsh . This ) ) { return ( ( bsh . This ) rhs ) . getInterface ( lhsType ) ; } assignmentError ( lhsType , originalType ) ; return rhs ; } private static void assignmentError ( Class lhs , Class rhs ) throws EvalError { String lhsType = Reflect . normalizeClassName ( lhs ) ; String rhsType = Reflect . normalizeClassName ( rhs ) ; throw new EvalError ( "Can't assign " + rhsType + " to " + lhsType ) ; } public String toString ( ) { return "NameSpace: " + ( name == null ? super . toString ( ) : name + " (" + super . toString ( ) + ")" ) ; } private synchronized void writeObject ( java . io . ObjectOutputStream s ) throws IOException { s . defaultWriteObject ( ) ; } public Object invokeMethod ( String methodName , Object [ ] args , Interpreter interpreter ) throws EvalError { return invokeMethod ( methodName , args , interpreter , null , null ) ; } public Object invokeMethod ( String methodName , Object [ ] args , Interpreter interpreter , CallStack callstack , SimpleNode callerInfo ) throws EvalError { if ( callstack == null ) { callstack = new CallStack ( ) ; callstack . push ( this ) ; } BshMethod meth = getMethod ( methodName , Reflect . getTypes ( args ) ) ; if ( meth != null ) return meth . invokeDeclaredMethod ( args , interpreter , callstack , callerInfo ) ; meth = getMethod ( "invoke" , new Class [ ] { null , null } ) ; if ( meth != null ) return meth . invokeDeclaredMethod ( new Object [ ] { methodName , args } , interpreter , callstack , callerInfo ) ; throw new EvalError ( "No locally declared method: " + methodName + " in namespace: " + this ) ; } public void classLoaderChanged ( ) { nameSpaceChanged ( ) ; } public void nameSpaceChanged ( ) { classCache = null ; } public void loadDefaultImports ( ) { importClass ( "bsh.EvalError" ) ; importPackage ( "javax.swing.event" ) ; importPackage ( "javax.swing" ) ; importPackage ( "java.awt.event" ) ; importPackage ( "java.awt" ) ; importPackage ( "java.net" ) ; importPackage ( "java.util" ) ; importPackage ( "java.io" ) ; importPackage ( "java.lang" ) ; } Name getNameResolver ( String name ) { return new Name ( this , name ) ; } public int getInvocationLine ( ) { SimpleNode node = getNode ( ) ; if ( node != null ) return node . getLineNumber ( ) ; else return - 1 ; } public String getInvocationText ( ) { SimpleNode node = getNode ( ) ; if ( node != null ) return node . getText ( ) ; else return "<invoked from Java code>" ; } public static Class identifierToClass ( Name . ClassIdentifier ci ) { return ci . getTargetClass ( ) ; } } 	0	['51', '1', '1', '44', '135', '1139', '34', '18', '35', '0.949090909', '1644', '0.818181818', '4', '0', '0.111764706', '0', '0', '30.80392157', '6', '1.5882', '0']
package bsh ; public interface ParserConstants { int EOF = 0 ; int NONPRINTABLE = 6 ; int SINGLE_LINE_COMMENT = 7 ; int HASH_BANG_COMMENT = 8 ; int FORMAL_COMMENT = 9 ; int MULTI_LINE_COMMENT = 10 ; int BOOLEAN = 11 ; int BREAK = 12 ; int CLASS = 13 ; int BYTE = 14 ; int CASE = 15 ; int CATCH = 16 ; int CHAR = 17 ; int CONST = 18 ; int CONTINUE = 19 ; int _DEFAULT = 20 ; int DO = 21 ; int DOUBLE = 22 ; int ELSE = 23 ; int FALSE = 24 ; int FINAL = 25 ; int FINALLY = 26 ; int FLOAT = 27 ; int FOR = 28 ; int GOTO = 29 ; int IF = 30 ; int IMPORT = 31 ; int INSTANCEOF = 32 ; int INT = 33 ; int INTERFACE = 34 ; int LONG = 35 ; int NEW = 36 ; int NULL = 37 ; int PRIVATE = 38 ; int PROTECTED = 39 ; int PUBLIC = 40 ; int RETURN = 41 ; int SHORT = 42 ; int STATIC = 43 ; int SWITCH = 44 ; int THROW = 45 ; int TRUE = 46 ; int TRY = 47 ; int VOID = 48 ; int WHILE = 49 ; int INTEGER_LITERAL = 50 ; int DECIMAL_LITERAL = 51 ; int HEX_LITERAL = 52 ; int OCTAL_LITERAL = 53 ; int FLOATING_POINT_LITERAL = 54 ; int EXPONENT = 55 ; int CHARACTER_LITERAL = 56 ; int STRING_LITERAL = 57 ; int IDENTIFIER = 58 ; int LETTER = 59 ; int DIGIT = 60 ; int LPAREN = 61 ; int RPAREN = 62 ; int LBRACE = 63 ; int RBRACE = 64 ; int LBRACKET = 65 ; int RBRACKET = 66 ; int SEMICOLON = 67 ; int COMMA = 68 ; int DOT = 69 ; int ASSIGN = 70 ; int GT = 71 ; int GTX = 72 ; int LT = 73 ; int LTX = 74 ; int BANG = 75 ; int TILDE = 76 ; int HOOK = 77 ; int COLON = 78 ; int EQ = 79 ; int LE = 80 ; int LEX = 81 ; int GE = 82 ; int GEX = 83 ; int NE = 84 ; int BOOL_OR = 85 ; int BOOL_ORX = 86 ; int BOOL_AND = 87 ; int BOOL_ANDX = 88 ; int INCR = 89 ; int DECR = 90 ; int PLUS = 91 ; int MINUS = 92 ; int STAR = 93 ; int SLASH = 94 ; int BIT_AND = 95 ; int BIT_ANDX = 96 ; int BIT_OR = 97 ; int BIT_ORX = 98 ; int XOR = 99 ; int MOD = 100 ; int LSHIFT = 101 ; int LSHIFTX = 102 ; int RSIGNEDSHIFT = 103 ; int RSIGNEDSHIFTX = 104 ; int RUNSIGNEDSHIFT = 105 ; int RUNSIGNEDSHIFTX = 106 ; int PLUSASSIGN = 107 ; int MINUSASSIGN = 108 ; int STARASSIGN = 109 ; int SLASHASSIGN = 110 ; int ANDASSIGN = 111 ; int ANDASSIGNX = 112 ; int ORASSIGN = 113 ; int ORASSIGNX = 114 ; int XORASSIGN = 115 ; int MODASSIGN = 116 ; int LSHIFTASSIGN = 117 ; int LSHIFTASSIGNX = 118 ; int RSIGNEDSHIFTASSIGN = 119 ; int RSIGNEDSHIFTASSIGNX = 120 ; int RUNSIGNEDSHIFTASSIGN = 121 ; int RUNSIGNEDSHIFTASSIGNX = 122 ; int DEFAULT = 0 ; String [ ] tokenImage = { "<EOF>" , "\" \"" , "\"\\t\"" , "\"\\r\"" , "\"\\f\"" , "\"\\n\"" , "<NONPRINTABLE>" , "<SINGLE_LINE_COMMENT>" , "<HASH_BANG_COMMENT>" , "<FORMAL_COMMENT>" , "<MULTI_LINE_COMMENT>" , "\"boolean\"" , "\"break\"" , "\"class\"" , "\"byte\"" , "\"case\"" , "\"catch\"" , "\"char\"" , "\"const\"" , "\"continue\"" , "\"default\"" , "\"do\"" , "\"double\"" , "\"else\"" , "\"false\"" , "\"final\"" , "\"finally\"" , "\"float\"" , "\"for\"" , "\"goto\"" , "\"if\"" , "\"import\"" , "\"instanceof\"" , "\"int\"" , "\"interface\"" , "\"long\"" , "\"new\"" , "\"null\"" , "\"private\"" , "\"protected\"" , "\"public\"" , "\"return\"" , "\"short\"" , "\"static\"" , "\"switch\"" , "\"throw\"" , "\"true\"" , "\"try\"" , "\"void\"" , "\"while\"" , "<INTEGER_LITERAL>" , "<DECIMAL_LITERAL>" , "<HEX_LITERAL>" , "<OCTAL_LITERAL>" , "<FLOATING_POINT_LITERAL>" , "<EXPONENT>" , "<CHARACTER_LITERAL>" , "<STRING_LITERAL>" , "<IDENTIFIER>" , "<LETTER>" , "<DIGIT>" , "\"(\"" , "\")\"" , "\"{\"" , "\"}\"" , "\"[\"" , "\"]\"" , "\";\"" , "\",\"" , "\".\"" , "\"=\"" , "\">\"" , "\"@gt\"" , "\"<\"" , "\"@lt\"" , "\"!\"" , "\"~\"" , "\"?\"" , "\":\"" , "\"==\"" , "\"<=\"" , "\"@lteq\"" , "\">=\"" , "\"@gteq\"" , "\"!=\"" , "\"||\"" , "\"@or\"" , "\"&&\"" , "\"@and\"" , "\"++\"" , "\"--\"" , "\"+\"" , "\"-\"" , "\"*\"" , "\"/\"" , "\"&\"" , "\"@bitwise_and\"" , "\"|\"" , "\"@bitwise_or\"" , "\"^\"" , "\"%\"" , "\"<<\"" , "\"@left_shift\"" , "\">>\"" , "\"@right_shift\"" , "\">>>\"" , "\"@right_unsigned_shift\"" , "\"+=\"" , "\"-=\"" , "\"*=\"" , "\"/=\"" , "\"&=\"" , "\"@and_assign\"" , "\"|=\"" , "\"@or_assign\"" , "\"^=\"" , "\"%=\"" , "\"<<=\"" , "\"@left_shift_assign\"" , "\">>=\"" , "\"@right_shift_assign\"" , "\">>>=\"" , "\"@right_unsigned_shift_assign\"" , } ; } 	0	['1', '1', '0', '12', '1', '0', '12', '0', '0', '2', '617', '0', '0', '0', '0', '0', '0', '496', '0', '0', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class MacrosChanged extends EBMessage . NonVetoable { public MacrosChanged ( EBComponent source ) { super ( source ) ; } } 	0	['1', '3', '0', '4', '2', '0', '2', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . gjt . sp . jedit . search ; import java . io . Serializable ; import javax . swing . text . Segment ; import gnu . regexp . * ; public class CharIndexedSegment implements CharIndexed , Serializable { private Segment seg ; private int m_index ; CharIndexedSegment ( Segment seg , int index ) { this . seg = seg ; m_index = index ; } public char charAt ( int index ) { return ( ( m_index + index ) < seg . count ) ? seg . array [ seg . offset + m_index + index ] : CharIndexed . OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( m_index < seg . count ) ; } public boolean move ( int index ) { return ( ( m_index += index ) < seg . count ) ; } } 	0	['4', '1', '0', '2', '5', '0', '1', '1', '3', '0', '63', '1', '0', '0', '0.666666667', '0', '0', '14.25', '2', '1.5', '0']
package gnu . regexp ; final class RETokenWordBoundary extends REToken { private boolean negated ; private int where ; static final int BEGIN = 1 ; static final int END = 2 ; RETokenWordBoundary ( int subIndex , int where , boolean negated ) { super ( subIndex ) ; this . where = where ; this . negated = negated ; } boolean match ( CharIndexed input , REMatch mymatch ) { boolean after = false ; boolean before = false ; char ch ; if ( ( ( mymatch . eflags & RE . REG_ANCHORINDEX ) != RE . REG_ANCHORINDEX ) || ( mymatch . offset + mymatch . index > mymatch . anchor ) ) { if ( ( ch = input . charAt ( mymatch . index - 1 ) ) != CharIndexed . OUT_OF_BOUNDS ) { before = Character . isLetterOrDigit ( ch ) || ( ch == '_' ) ; } } if ( ( ch = input . charAt ( mymatch . index ) ) != CharIndexed . OUT_OF_BOUNDS ) { after = Character . isLetterOrDigit ( ch ) || ( ch == '_' ) ; } boolean doNext = false ; if ( ( where & BEGIN ) == BEGIN ) { doNext = after && ! before ; } if ( ( where & END ) == END ) { doNext ^= before && ! after ; } if ( negated ) doNext = ! doNext ; return ( doNext ? next ( input , mymatch ) : false ) ; } void dump ( StringBuffer os ) { if ( where == ( BEGIN | END ) ) { os . append ( negated ? "\\B" : "\\b" ) ; } else if ( where == BEGIN ) { os . append ( "\\<" ) ; } else { os . append ( "\\>" ) ; } } } 	0	['3', '2', '0', '4', '8', '0', '1', '3', '0', '0.75', '151', '0.5', '0', '0.777777778', '0.444444444', '1', '2', '48', '18', '7.3333', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class AddAbbrevDialog extends JDialog { public AddAbbrevDialog ( View view , String abbrev ) { super ( view , jEdit . getProperty ( "add-abbrev.title" ) , true ) ; this . view = view ; this . abbrev = abbrev ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; content . add ( BorderLayout . NORTH , new JLabel ( jEdit . getProperty ( "add-abbrev.caption" , new String [ ] { abbrev } ) ) ) ; editor = new AbbrevEditor ( ) ; editor . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; content . add ( BorderLayout . CENTER , editor ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; global = new JButton ( jEdit . getProperty ( "add-abbrev.global" ) ) ; global . addActionListener ( new ActionHandler ( ) ) ; box . add ( global ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; modeSpecific = new JButton ( jEdit . getProperty ( "add-abbrev.mode" ) ) ; modeSpecific . addActionListener ( new ActionHandler ( ) ) ; box . add ( modeSpecific ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; box . add ( cancel ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; KeyListener listener = new KeyHandler ( ) ; addKeyListener ( listener ) ; editor . getBeforeCaretTextArea ( ) . addKeyListener ( listener ) ; editor . getAfterCaretTextArea ( ) . addKeyListener ( listener ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; GUIUtilities . requestFocus ( this , editor . getBeforeCaretTextArea ( ) ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } private View view ; private String abbrev ; private AbbrevEditor editor ; private JButton global ; private JButton modeSpecific ; private JButton cancel ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == global ) { Abbrevs . addGlobalAbbrev ( abbrev , editor . getExpansion ( ) ) ; Abbrevs . expandAbbrev ( view , false ) ; } else if ( source == modeSpecific ) { Abbrevs . addModeAbbrev ( view . getBuffer ( ) . getMode ( ) . getName ( ) , abbrev , editor . getExpansion ( ) ) ; Abbrevs . expandAbbrev ( view , false ) ; } dispose ( ) ; } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) dispose ( ) ; } } } 	0	['6', '6', '0', '7', '35', '5', '3', '6', '1', '0.833333333', '229', '1', '2', '0.992378049', '0.333333333', '0', '0', '36.16666667', '1', '0.8333', '0']
package bsh ; class BSHFormalParameter extends SimpleNode { public static final Class UNTYPED = null ; public String name ; public Class type ; BSHFormalParameter ( int id ) { super ( id ) ; } public Object eval ( NameSpace namespace ) throws EvalError { if ( jjtGetNumChildren ( ) > 0 ) type = ( ( BSHType ) jjtGetChild ( 0 ) ) . getType ( namespace ) ; else type = UNTYPED ; return Primitive . VOID ; } } 	0	['3', '2', '0', '9', '7', '1', '3', '6', '1', '1', '30', '0', '0', '0.947368421', '0.666666667', '1', '2', '8', '1', '0.3333', '0']
package com . microstar . xml ; import java . io . BufferedInputStream ; import java . io . EOFException ; import java . io . InputStream ; import java . io . Reader ; import java . net . URL ; import java . net . URLConnection ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; public class XmlParser { private final static boolean USE_CHEATS = true ; public XmlParser ( ) { } public void setHandler ( XmlHandler handler ) { this . handler = handler ; } public void parse ( String systemId , String publicId , String encoding ) throws java . lang . Exception { doParse ( systemId , publicId , null , null , encoding ) ; } public void parse ( String systemId , String publicId , InputStream stream , String encoding ) throws java . lang . Exception { doParse ( systemId , publicId , null , stream , encoding ) ; } public void parse ( String systemId , String publicId , Reader reader ) throws java . lang . Exception { doParse ( systemId , publicId , reader , null , null ) ; } private synchronized void doParse ( String systemId , String publicId , Reader reader , InputStream stream , String encoding ) throws java . lang . Exception { basePublicId = publicId ; baseURI = systemId ; baseReader = reader ; baseInputStream = stream ; initializeVariables ( ) ; setInternalEntity ( intern ( "amp" ) , "&#38;" ) ; setInternalEntity ( intern ( "lt" ) , "&#60;" ) ; setInternalEntity ( intern ( "gt" ) , "&#62;" ) ; setInternalEntity ( intern ( "apos" ) , "&#39;" ) ; setInternalEntity ( intern ( "quot" ) , "&#34;" ) ; if ( handler != null ) { handler . startDocument ( ) ; } pushURL ( "[document]" , basePublicId , baseURI , baseReader , baseInputStream , encoding ) ; parseDocument ( ) ; if ( handler != null ) { handler . endDocument ( ) ; } cleanupVariables ( ) ; } public final static int CONTENT_UNDECLARED = 0 ; public final static int CONTENT_ANY = 1 ; public final static int CONTENT_EMPTY = 2 ; public final static int CONTENT_MIXED = 3 ; public final static int CONTENT_ELEMENTS = 4 ; public final static int ENTITY_UNDECLARED = 0 ; public final static int ENTITY_INTERNAL = 1 ; public final static int ENTITY_NDATA = 2 ; public final static int ENTITY_TEXT = 3 ; public final static int ATTRIBUTE_UNDECLARED = 0 ; public final static int ATTRIBUTE_CDATA = 1 ; public final static int ATTRIBUTE_ID = 2 ; public final static int ATTRIBUTE_IDREF = 3 ; public final static int ATTRIBUTE_IDREFS = 4 ; public final static int ATTRIBUTE_ENTITY = 5 ; public final static int ATTRIBUTE_ENTITIES = 6 ; public final static int ATTRIBUTE_NMTOKEN = 7 ; public final static int ATTRIBUTE_NMTOKENS = 8 ; public final static int ATTRIBUTE_ENUMERATED = 9 ; public final static int ATTRIBUTE_NOTATION = 10 ; private static Hashtable attributeTypeHash ; static { attributeTypeHash = new Hashtable ( ) ; attributeTypeHash . put ( "CDATA" , new Integer ( ATTRIBUTE_CDATA ) ) ; attributeTypeHash . put ( "ID" , new Integer ( ATTRIBUTE_ID ) ) ; attributeTypeHash . put ( "IDREF" , new Integer ( ATTRIBUTE_IDREF ) ) ; attributeTypeHash . put ( "IDREFS" , new Integer ( ATTRIBUTE_IDREFS ) ) ; attributeTypeHash . put ( "ENTITY" , new Integer ( ATTRIBUTE_ENTITY ) ) ; attributeTypeHash . put ( "ENTITIES" , new Integer ( ATTRIBUTE_ENTITIES ) ) ; attributeTypeHash . put ( "NMTOKEN" , new Integer ( ATTRIBUTE_NMTOKEN ) ) ; attributeTypeHash . put ( "NMTOKENS" , new Integer ( ATTRIBUTE_NMTOKENS ) ) ; attributeTypeHash . put ( "NOTATION" , new Integer ( ATTRIBUTE_NOTATION ) ) ; } private final static int ENCODING_UTF_8 = 1 ; private final static int ENCODING_ISO_8859_1 = 2 ; private final static int ENCODING_UCS_2_12 = 3 ; private final static int ENCODING_UCS_2_21 = 4 ; private final static int ENCODING_UCS_4_1234 = 5 ; private final static int ENCODING_UCS_4_4321 = 6 ; private final static int ENCODING_UCS_4_2143 = 7 ; private final static int ENCODING_UCS_4_3412 = 8 ; public final static int ATTRIBUTE_DEFAULT_UNDECLARED = 0 ; public final static int ATTRIBUTE_DEFAULT_SPECIFIED = 1 ; public final static int ATTRIBUTE_DEFAULT_IMPLIED = 2 ; public final static int ATTRIBUTE_DEFAULT_REQUIRED = 3 ; public final static int ATTRIBUTE_DEFAULT_FIXED = 4 ; private final static int INPUT_NONE = 0 ; private final static int INPUT_INTERNAL = 1 ; private final static int INPUT_EXTERNAL = 2 ; private final static int INPUT_STREAM = 3 ; private final static int INPUT_BUFFER = 4 ; private final static int INPUT_READER = 5 ; private final static int LIT_CHAR_REF = 1 ; private final static int LIT_ENTITY_REF = 2 ; private final static int LIT_PE_REF = 4 ; private final static int LIT_NORMALIZE = 8 ; private final static int CONTEXT_NONE = 0 ; private final static int CONTEXT_DTD = 1 ; private final static int CONTEXT_ENTITYVALUE = 2 ; private final static int CONTEXT_ATTRIBUTEVALUE = 3 ; void error ( String message , String textFound , String textExpected ) throws java . lang . Exception { errorCount ++ ; if ( textFound != null ) { message = message + " (found \"" + textFound + "\")" ; } if ( textExpected != null ) { message = message + " (expected \"" + textExpected + "\")" ; } if ( handler != null ) { String uri = null ; if ( externalEntity != null ) { uri = externalEntity . getURL ( ) . toString ( ) ; } handler . error ( message , uri , line , column ) ; } } void error ( String message , char textFound , String textExpected ) throws java . lang . Exception { error ( message , new Character ( textFound ) . toString ( ) , textExpected ) ; } void parseDocument ( ) throws java . lang . Exception { char c ; parseProlog ( ) ; require ( '<' ) ; parseElement ( ) ; try { parseMisc ( ) ; c = readCh ( ) ; error ( "unexpected characters after document end" , c , null ) ; } catch ( EOFException e ) { return ; } } void parseComment ( ) throws java . lang . Exception { skipUntil ( "-->" ) ; } void parsePI ( ) throws java . lang . Exception { String name ; name = readNmtoken ( true ) ; if ( ! tryRead ( "?>" ) ) { requireWhitespace ( ) ; parseUntil ( "?>" ) ; } if ( handler != null ) { handler . processingInstruction ( name , dataBufferToString ( ) ) ; } } void parseCDSect ( ) throws java . lang . Exception { parseUntil ( "]]>" ) ; } void parseProlog ( ) throws java . lang . Exception { parseMisc ( ) ; if ( tryRead ( "<!DOCTYPE" ) ) { parseDoctypedecl ( ) ; parseMisc ( ) ; } } void parseXMLDecl ( boolean ignoreEncoding ) throws java . lang . Exception { String version ; String encodingName = null ; String standalone = null ; require ( "version" ) ; parseEq ( ) ; version = readLiteral ( 0 ) ; if ( ! version . equals ( "1.0" ) ) { error ( "unsupported XML version" , version , "1.0" ) ; } skipWhitespace ( ) ; if ( tryRead ( "encoding" ) ) { parseEq ( ) ; encodingName = readLiteral ( 0 ) ; checkEncoding ( encodingName , ignoreEncoding ) ; } skipWhitespace ( ) ; if ( tryRead ( "standalone" ) ) { parseEq ( ) ; standalone = readLiteral ( 0 ) ; } skipWhitespace ( ) ; require ( "?>" ) ; } void parseTextDecl ( boolean ignoreEncoding ) throws java . lang . Exception { String encodingName = null ; if ( tryRead ( "version" ) ) { String version ; parseEq ( ) ; version = readLiteral ( 0 ) ; if ( ! version . equals ( "1.0" ) ) { error ( "unsupported XML version" , version , "1.0" ) ; } requireWhitespace ( ) ; } require ( "encoding" ) ; parseEq ( ) ; encodingName = readLiteral ( 0 ) ; checkEncoding ( encodingName , ignoreEncoding ) ; skipWhitespace ( ) ; require ( "?>" ) ; } void checkEncoding ( String encodingName , boolean ignoreEncoding ) throws java . lang . Exception { encodingName = encodingName . toUpperCase ( ) ; if ( ignoreEncoding ) { return ; } switch ( encoding ) { case ENCODING_UTF_8 : if ( encodingName . equals ( "ISO-8859-1" ) ) { encoding = ENCODING_ISO_8859_1 ; } else if ( ! encodingName . equals ( "UTF-8" ) ) { error ( "unsupported 8-bit encoding" , encodingName , "UTF-8 or ISO-8859-1" ) ; } break ; case ENCODING_UCS_2_12 : case ENCODING_UCS_2_21 : if ( ! encodingName . equals ( "ISO-10646-UCS-2" ) && ! encodingName . equals ( "UTF-16" ) ) { error ( "unsupported 16-bit encoding" , encodingName , "ISO-10646-UCS-2" ) ; } break ; case ENCODING_UCS_4_1234 : case ENCODING_UCS_4_4321 : case ENCODING_UCS_4_2143 : case ENCODING_UCS_4_3412 : if ( ! encodingName . equals ( "ISO-10646-UCS-4" ) ) { error ( "unsupported 32-bit encoding" , encodingName , "ISO-10646-UCS-4" ) ; } } } void parseMisc ( ) throws java . lang . Exception { while ( true ) { skipWhitespace ( ) ; if ( tryRead ( "<?" ) ) { parsePI ( ) ; } else if ( tryRead ( "<!--" ) ) { parseComment ( ) ; } else { return ; } } } void parseDoctypedecl ( ) throws java . lang . Exception { char c ; String doctypeName , ids [ ] ; requireWhitespace ( ) ; doctypeName = readNmtoken ( true ) ; skipWhitespace ( ) ; ids = readExternalIds ( false ) ; skipWhitespace ( ) ; if ( tryRead ( '[' ) ) { while ( true ) { context = CONTEXT_DTD ; skipWhitespace ( ) ; context = CONTEXT_NONE ; if ( tryRead ( ']' ) ) { break ; } else { context = CONTEXT_DTD ; parseMarkupdecl ( ) ; context = CONTEXT_NONE ; } } } if ( ids [ 1 ] != null ) { pushURL ( "[external subset]" , ids [ 0 ] , ids [ 1 ] , null , null , null ) ; while ( true ) { context = CONTEXT_DTD ; skipWhitespace ( ) ; context = CONTEXT_NONE ; if ( tryRead ( '>' ) ) { break ; } else { context = CONTEXT_DTD ; parseMarkupdecl ( ) ; context = CONTEXT_NONE ; } } } else { skipWhitespace ( ) ; require ( '>' ) ; } if ( handler != null ) { handler . doctypeDecl ( doctypeName , ids [ 0 ] , ids [ 1 ] ) ; } } void parseMarkupdecl ( ) throws java . lang . Exception { if ( tryRead ( "<!ELEMENT" ) ) { parseElementdecl ( ) ; } else if ( tryRead ( "<!ATTLIST" ) ) { parseAttlistDecl ( ) ; } else if ( tryRead ( "<!ENTITY" ) ) { parseEntityDecl ( ) ; } else if ( tryRead ( "<!NOTATION" ) ) { parseNotationDecl ( ) ; } else if ( tryRead ( "<?" ) ) { parsePI ( ) ; } else if ( tryRead ( "<!--" ) ) { parseComment ( ) ; } else if ( tryRead ( "<![" ) ) { parseConditionalSect ( ) ; } else { error ( "expected markup declaration" , null , null ) ; } } void parseElement ( ) throws java . lang . Exception { String gi ; char c ; int oldElementContent = currentElementContent ; String oldElement = currentElement ; tagAttributePos = 0 ; gi = readNmtoken ( true ) ; currentElement = gi ; currentElementContent = getElementContentType ( gi ) ; if ( currentElementContent == CONTENT_UNDECLARED ) { currentElementContent = CONTENT_ANY ; } skipWhitespace ( ) ; c = readCh ( ) ; while ( c != '/' && c != '>' ) { unread ( c ) ; parseAttribute ( gi ) ; skipWhitespace ( ) ; c = readCh ( ) ; } unread ( c ) ; Enumeration atts = declaredAttributes ( gi ) ; if ( atts != null ) { String aname ; loop : while ( atts . hasMoreElements ( ) ) { aname = ( String ) atts . nextElement ( ) ; for ( int i = 0 ; i < tagAttributePos ; i ++ ) { if ( tagAttributes [ i ] == aname ) { continue loop ; } } if ( handler != null ) { handler . attribute ( aname , getAttributeExpandedValue ( gi , aname ) , false ) ; } } } c = readCh ( ) ; switch ( c ) { case '>' : if ( handler != null ) { handler . startElement ( gi ) ; } parseContent ( ) ; break ; case '/' : require ( '>' ) ; if ( handler != null ) { handler . startElement ( gi ) ; handler . endElement ( gi ) ; } break ; } currentElement = oldElement ; currentElementContent = oldElementContent ; } void parseAttribute ( String name ) throws java . lang . Exception { String aname ; int type ; String value ; aname = readNmtoken ( true ) . intern ( ) ; type = getAttributeDefaultValueType ( name , aname ) ; parseEq ( ) ; if ( type == ATTRIBUTE_CDATA || type == ATTRIBUTE_UNDECLARED ) { value = readLiteral ( LIT_CHAR_REF | LIT_ENTITY_REF ) ; } else { value = readLiteral ( LIT_CHAR_REF | LIT_ENTITY_REF | LIT_NORMALIZE ) ; } if ( handler != null ) { handler . attribute ( aname , value , true ) ; } dataBufferPos = 0 ; if ( tagAttributePos == tagAttributes . length ) { String newAttrib [ ] = new String [ tagAttributes . length * 2 ] ; System . arraycopy ( tagAttributes , 0 , newAttrib , 0 , tagAttributePos ) ; tagAttributes = newAttrib ; } tagAttributes [ tagAttributePos ++ ] = aname ; } void parseEq ( ) throws java . lang . Exception { skipWhitespace ( ) ; require ( '=' ) ; skipWhitespace ( ) ; } void parseETag ( ) throws java . lang . Exception { String name ; name = readNmtoken ( true ) ; if ( name != currentElement ) { error ( "mismatched end tag" , name , currentElement ) ; } skipWhitespace ( ) ; require ( '>' ) ; if ( handler != null ) { handler . endElement ( name ) ; } } void parseContent ( ) throws java . lang . Exception { String data ; char c ; while ( true ) { switch ( currentElementContent ) { case CONTENT_ANY : case CONTENT_MIXED : parsePCData ( ) ; break ; case CONTENT_ELEMENTS : parseWhitespace ( ) ; break ; } c = readCh ( ) ; switch ( c ) { case '&' : c = readCh ( ) ; if ( c == '#' ) { parseCharRef ( ) ; } else { unread ( c ) ; parseEntityRef ( true ) ; } break ; case '<' : c = readCh ( ) ; switch ( c ) { case '!' : c = readCh ( ) ; switch ( c ) { case '-' : require ( '-' ) ; parseComment ( ) ; break ; case '[' : require ( "CDATA[" ) ; parseCDSect ( ) ; break ; default : error ( "expected comment or CDATA section" , c , null ) ; break ; } break ; case '?' : dataBufferFlush ( ) ; parsePI ( ) ; break ; case '/' : dataBufferFlush ( ) ; parseETag ( ) ; return ; default : dataBufferFlush ( ) ; unread ( c ) ; parseElement ( ) ; break ; } } } } void parseElementdecl ( ) throws java . lang . Exception { String name ; requireWhitespace ( ) ; name = readNmtoken ( true ) ; requireWhitespace ( ) ; parseContentspec ( name ) ; skipWhitespace ( ) ; require ( '>' ) ; } void parseContentspec ( String name ) throws java . lang . Exception { if ( tryRead ( "EMPTY" ) ) { setElement ( name , CONTENT_EMPTY , null , null ) ; return ; } else if ( tryRead ( "ANY" ) ) { setElement ( name , CONTENT_ANY , null , null ) ; return ; } else { require ( '(' ) ; dataBufferAppend ( '(' ) ; skipWhitespace ( ) ; if ( tryRead ( "#PCDATA" ) ) { dataBufferAppend ( "#PCDATA" ) ; parseMixed ( ) ; setElement ( name , CONTENT_MIXED , dataBufferToString ( ) , null ) ; } else { parseElements ( ) ; setElement ( name , CONTENT_ELEMENTS , dataBufferToString ( ) , null ) ; } } } void parseElements ( ) throws java . lang . Exception { char c ; char sep ; skipWhitespace ( ) ; parseCp ( ) ; skipWhitespace ( ) ; c = readCh ( ) ; switch ( c ) { case ')' : dataBufferAppend ( ')' ) ; c = readCh ( ) ; switch ( c ) { case '*' : case '+' : case '?' : dataBufferAppend ( c ) ; break ; default : unread ( c ) ; } return ; case ',' : case '|' : sep = c ; dataBufferAppend ( c ) ; break ; default : error ( "bad separator in content model" , c , null ) ; return ; } while ( true ) { skipWhitespace ( ) ; parseCp ( ) ; skipWhitespace ( ) ; c = readCh ( ) ; if ( c == ')' ) { dataBufferAppend ( ')' ) ; break ; } else if ( c != sep ) { error ( "bad separator in content model" , c , null ) ; return ; } else { dataBufferAppend ( c ) ; } } c = readCh ( ) ; switch ( c ) { case '?' : case '*' : case '+' : dataBufferAppend ( c ) ; return ; default : unread ( c ) ; return ; } } void parseCp ( ) throws java . lang . Exception { char c ; if ( tryRead ( '(' ) ) { dataBufferAppend ( '(' ) ; parseElements ( ) ; } else { dataBufferAppend ( readNmtoken ( true ) ) ; c = readCh ( ) ; switch ( c ) { case '?' : case '*' : case '+' : dataBufferAppend ( c ) ; break ; default : unread ( c ) ; break ; } } } void parseMixed ( ) throws java . lang . Exception { char c ; skipWhitespace ( ) ; if ( tryRead ( ')' ) ) { dataBufferAppend ( ")*" ) ; tryRead ( '*' ) ; return ; } skipWhitespace ( ) ; while ( ! tryRead ( ")*" ) ) { require ( '|' ) ; dataBufferAppend ( '|' ) ; skipWhitespace ( ) ; dataBufferAppend ( readNmtoken ( true ) ) ; skipWhitespace ( ) ; } dataBufferAppend ( ")*" ) ; } void parseAttlistDecl ( ) throws java . lang . Exception { String elementName ; requireWhitespace ( ) ; elementName = readNmtoken ( true ) ; requireWhitespace ( ) ; while ( ! tryRead ( '>' ) ) { parseAttDef ( elementName ) ; skipWhitespace ( ) ; } } void parseAttDef ( String elementName ) throws java . lang . Exception { String name ; int type ; String enum = null ; name = readNmtoken ( true ) ; requireWhitespace ( ) ; type = readAttType ( ) ; if ( type == ATTRIBUTE_ENUMERATED || type == ATTRIBUTE_NOTATION ) { enum = dataBufferToString ( ) ; } requireWhitespace ( ) ; parseDefault ( elementName , name , type , enum ) ; } int readAttType ( ) throws java . lang . Exception { String typeString ; Integer type ; if ( tryRead ( '(' ) ) { parseEnumeration ( ) ; return ATTRIBUTE_ENUMERATED ; } else { typeString = readNmtoken ( true ) ; if ( typeString . equals ( "NOTATION" ) ) { parseNotationType ( ) ; } type = ( Integer ) attributeTypeHash . get ( typeString ) ; if ( type == null ) { error ( "illegal attribute type" , typeString , null ) ; return ATTRIBUTE_UNDECLARED ; } else { return type . intValue ( ) ; } } } void parseEnumeration ( ) throws java . lang . Exception { char c ; dataBufferAppend ( '(' ) ; skipWhitespace ( ) ; dataBufferAppend ( readNmtoken ( true ) ) ; skipWhitespace ( ) ; while ( ! tryRead ( ')' ) ) { require ( '|' ) ; dataBufferAppend ( '|' ) ; skipWhitespace ( ) ; dataBufferAppend ( readNmtoken ( true ) ) ; skipWhitespace ( ) ; } dataBufferAppend ( ')' ) ; } void parseNotationType ( ) throws java . lang . Exception { requireWhitespace ( ) ; require ( '(' ) ; parseEnumeration ( ) ; } void parseDefault ( String elementName , String name , int type , String enum ) throws java . lang . Exception { int valueType = ATTRIBUTE_DEFAULT_SPECIFIED ; String value = null ; boolean normalizeWSFlag ; if ( tryRead ( '#' ) ) { if ( tryRead ( "FIXED" ) ) { valueType = ATTRIBUTE_DEFAULT_FIXED ; requireWhitespace ( ) ; context = CONTEXT_ATTRIBUTEVALUE ; value = readLiteral ( LIT_CHAR_REF ) ; context = CONTEXT_DTD ; } else if ( tryRead ( "REQUIRED" ) ) { valueType = ATTRIBUTE_DEFAULT_REQUIRED ; } else if ( tryRead ( "IMPLIED" ) ) { valueType = ATTRIBUTE_DEFAULT_IMPLIED ; } else { error ( "illegal keyword for attribute default value" , null , null ) ; } } else { context = CONTEXT_ATTRIBUTEVALUE ; value = readLiteral ( LIT_CHAR_REF ) ; context = CONTEXT_DTD ; } setAttribute ( elementName , name , type , enum , value , valueType ) ; } void parseConditionalSect ( ) throws java . lang . Exception { skipWhitespace ( ) ; if ( tryRead ( "INCLUDE" ) ) { skipWhitespace ( ) ; require ( '[' ) ; skipWhitespace ( ) ; while ( ! tryRead ( "]]>" ) ) { parseMarkupdecl ( ) ; skipWhitespace ( ) ; } } else if ( tryRead ( "IGNORE" ) ) { skipWhitespace ( ) ; require ( '[' ) ; int nesting = 1 ; char c ; for ( int nest = 1 ; nest > 0 ; ) { c = readCh ( ) ; switch ( c ) { case '<' : if ( tryRead ( "![" ) ) { nest ++ ; } case ']' : if ( tryRead ( "]>" ) ) { nest -- ; } } } } else { error ( "conditional section must begin with INCLUDE or IGNORE" , null , null ) ; } } void parseCharRef ( ) throws java . lang . Exception { int value = 0 ; char c ; if ( tryRead ( 'x' ) ) { loop1 : while ( true ) { c = readCh ( ) ; switch ( c ) { case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case 'a' : case 'A' : case 'b' : case 'B' : case 'c' : case 'C' : case 'd' : case 'D' : case 'e' : case 'E' : case 'f' : case 'F' : value *= 16 ; value += Integer . parseInt ( new Character ( c ) . toString ( ) , 16 ) ; break ; case ';' : break loop1 ; default : error ( "illegal character in character reference" , c , null ) ; break loop1 ; } } } else { loop2 : while ( true ) { c = readCh ( ) ; switch ( c ) { case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : value *= 10 ; value += Integer . parseInt ( new Character ( c ) . toString ( ) , 10 ) ; break ; case ';' : break loop2 ; default : error ( "illegal character in character reference" , c , null ) ; break loop2 ; } } } if ( value <= 0x0000ffff ) { dataBufferAppend ( ( char ) value ) ; } else if ( value <= 0x000fffff ) { dataBufferAppend ( ( char ) ( 0xd8 | ( ( value & 0x000ffc00 ) > > 10 ) ) ) ; dataBufferAppend ( ( char ) ( 0xdc | ( value & 0x0003ff ) ) ) ; } else { error ( "character reference " + value + " is too large for UTF-16" , new Integer ( value ) . toString ( ) , null ) ; } } void parseEntityRef ( boolean externalAllowed ) throws java . lang . Exception { String name ; name = readNmtoken ( true ) ; require ( ';' ) ; switch ( getEntityType ( name ) ) { case ENTITY_UNDECLARED : error ( "reference to undeclared entity" , name , null ) ; break ; case ENTITY_INTERNAL : pushString ( name , getEntityValue ( name ) ) ; break ; case ENTITY_TEXT : if ( externalAllowed ) { pushURL ( name , getEntityPublicId ( name ) , getEntitySystemId ( name ) , null , null , null ) ; } else { error ( "reference to external entity in attribute value." , name , null ) ; } break ; case ENTITY_NDATA : if ( externalAllowed ) { error ( "data entity reference in content" , name , null ) ; } else { error ( "reference to external entity in attribute value." , name , null ) ; } break ; } } void parsePEReference ( boolean isEntityValue ) throws java . lang . Exception { String name ; name = "%" + readNmtoken ( true ) ; require ( ';' ) ; switch ( getEntityType ( name ) ) { case ENTITY_UNDECLARED : error ( "reference to undeclared parameter entity" , name , null ) ; break ; case ENTITY_INTERNAL : if ( isEntityValue ) { pushString ( name , getEntityValue ( name ) ) ; } else { pushString ( name , " " + getEntityValue ( name ) + ' ' ) ; } break ; case ENTITY_TEXT : if ( isEntityValue ) { pushString ( null , " " ) ; } pushURL ( name , getEntityPublicId ( name ) , getEntitySystemId ( name ) , null , null , null ) ; if ( isEntityValue ) { pushString ( null , " " ) ; } break ; } } void parseEntityDecl ( ) throws java . lang . Exception { char c ; boolean peFlag = false ; String name , value , notationName , ids [ ] ; requireWhitespace ( ) ; if ( tryRead ( '%' ) ) { peFlag = true ; requireWhitespace ( ) ; } name = readNmtoken ( true ) ; if ( peFlag ) { name = "%" + name ; } requireWhitespace ( ) ; c = readCh ( ) ; unread ( c ) ; if ( c == '"' || c == '\'' ) { context = CONTEXT_ENTITYVALUE ; value = readLiteral ( LIT_CHAR_REF | LIT_PE_REF ) ; context = CONTEXT_DTD ; setInternalEntity ( name , value ) ; } else { ids = readExternalIds ( false ) ; if ( ids [ 1 ] == null ) { error ( "system identifer missing" , name , null ) ; } skipWhitespace ( ) ; if ( tryRead ( "NDATA" ) ) { requireWhitespace ( ) ; notationName = readNmtoken ( true ) ; setExternalDataEntity ( name , ids [ 0 ] , ids [ 1 ] , notationName ) ; } else { setExternalTextEntity ( name , ids [ 0 ] , ids [ 1 ] ) ; } } skipWhitespace ( ) ; require ( '>' ) ; } void parseNotationDecl ( ) throws java . lang . Exception { String nname , ids [ ] ; requireWhitespace ( ) ; nname = readNmtoken ( true ) ; requireWhitespace ( ) ; ids = readExternalIds ( true ) ; if ( ids [ 0 ] == null && ids [ 1 ] == null ) { error ( "external identifer missing" , nname , null ) ; } setNotation ( nname , ids [ 0 ] , ids [ 1 ] ) ; skipWhitespace ( ) ; require ( '>' ) ; } void parsePCData ( ) throws java . lang . Exception { char c ; if ( USE_CHEATS ) { int lineAugment = 0 ; int columnAugment = 0 ; loop : for ( int i = readBufferPos ; i < readBufferLength ; i ++ ) { switch ( readBuffer [ i ] ) { case '\n' : lineAugment ++ ; columnAugment = 0 ; break ; case '&' : case '<' : int start = readBufferPos ; columnAugment ++ ; readBufferPos = i ; if ( lineAugment > 0 ) { line += lineAugment ; column = columnAugment ; } else { column += columnAugment ; } dataBufferAppend ( readBuffer , start , i - start ) ; return ; default : columnAugment ++ ; } } } while ( true ) { c = readCh ( ) ; switch ( c ) { case '<' : case '&' : unread ( c ) ; return ; default : dataBufferAppend ( c ) ; break ; } } } void requireWhitespace ( ) throws java . lang . Exception { char c = readCh ( ) ; if ( isWhitespace ( c ) ) { skipWhitespace ( ) ; } else { error ( "whitespace expected" , c , null ) ; } } void parseWhitespace ( ) throws java . lang . Exception { char c = readCh ( ) ; while ( isWhitespace ( c ) ) { dataBufferAppend ( c ) ; c = readCh ( ) ; } unread ( c ) ; } void skipWhitespace ( ) throws java . lang . Exception { if ( USE_CHEATS ) { int lineAugment = 0 ; int columnAugment = 0 ; loop : for ( int i = readBufferPos ; i < readBufferLength ; i ++ ) { switch ( readBuffer [ i ] ) { case ' ' : case '\t' : case '\r' : columnAugment ++ ; break ; case '\n' : lineAugment ++ ; columnAugment = 0 ; break ; case '%' : if ( context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE ) { break loop ; } default : readBufferPos = i ; if ( lineAugment > 0 ) { line += lineAugment ; column = columnAugment ; } else { column += columnAugment ; } return ; } } } char c = readCh ( ) ; while ( isWhitespace ( c ) ) { c = readCh ( ) ; } unread ( c ) ; } String readNmtoken ( boolean isName ) throws java . lang . Exception { char c ; if ( USE_CHEATS ) { loop : for ( int i = readBufferPos ; i < readBufferLength ; i ++ ) { switch ( readBuffer [ i ] ) { case '%' : if ( context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE ) { break loop ; } case '<' : case '>' : case '&' : case ',' : case '|' : case '*' : case '+' : case '?' : case ')' : case '=' : case '\'' : case '"' : case '[' : case ' ' : case '\t' : case '\r' : case '\n' : case ';' : case '/' : case '#' : int start = readBufferPos ; if ( i == start ) { error ( "name expected" , readBuffer [ i ] , null ) ; } readBufferPos = i ; return intern ( readBuffer , start , i - start ) ; } } } nameBufferPos = 0 ; loop : while ( true ) { c = readCh ( ) ; switch ( c ) { case '%' : case '<' : case '>' : case '&' : case ',' : case '|' : case '*' : case '+' : case '?' : case ')' : case '=' : case '\'' : case '"' : case '[' : case ' ' : case '\t' : case '\n' : case '\r' : case ';' : case '/' : unread ( c ) ; if ( nameBufferPos == 0 ) { error ( "name expected" , null , null ) ; } String s = intern ( nameBuffer , 0 , nameBufferPos ) ; nameBufferPos = 0 ; return s ; default : nameBuffer = ( char [ ] ) extendArray ( nameBuffer , nameBuffer . length , nameBufferPos ) ; nameBuffer [ nameBufferPos ++ ] = c ; } } } String readLiteral ( int flags ) throws java . lang . Exception { char delim , c ; int startLine = line ; delim = readCh ( ) ; if ( delim != '"' && delim != '\'' && delim != ( char ) 0 ) { error ( "expected '\"' or \"'\"" , delim , null ) ; return null ; } try { c = readCh ( ) ; loop : while ( c != delim ) { switch ( c ) { case '\n' : case '\r' : c = ' ' ; break ; case '&' : if ( ( flags & LIT_CHAR_REF ) > 0 ) { c = readCh ( ) ; if ( c == '#' ) { parseCharRef ( ) ; c = readCh ( ) ; continue loop ; } else if ( ( flags & LIT_ENTITY_REF ) > 0 ) { unread ( c ) ; parseEntityRef ( false ) ; c = readCh ( ) ; continue loop ; } else { dataBufferAppend ( '&' ) ; } } break ; default : break ; } dataBufferAppend ( c ) ; c = readCh ( ) ; } } catch ( EOFException e ) { error ( "end of input while looking for delimiter (started on line " + startLine + ')' , null , new Character ( delim ) . toString ( ) ) ; } if ( ( flags & LIT_NORMALIZE ) > 0 ) { dataBufferNormalize ( ) ; } return dataBufferToString ( ) ; } String [ ] readExternalIds ( boolean inNotation ) throws java . lang . Exception { char c ; String ids [ ] = new String [ 2 ] ; if ( tryRead ( "PUBLIC" ) ) { requireWhitespace ( ) ; ids [ 0 ] = readLiteral ( LIT_NORMALIZE ) ; if ( inNotation ) { skipWhitespace ( ) ; if ( tryRead ( '"' ) || tryRead ( '\'' ) ) { ids [ 1 ] = readLiteral ( 0 ) ; } } else { requireWhitespace ( ) ; ids [ 1 ] = readLiteral ( 0 ) ; } } else if ( tryRead ( "SYSTEM" ) ) { requireWhitespace ( ) ; ids [ 1 ] = readLiteral ( 0 ) ; } return ids ; } final boolean isWhitespace ( char c ) { switch ( ( int ) c ) { case 0x20 : case 0x09 : case 0x0d : case 0x0a : return true ; default : return false ; } } void dataBufferAppend ( char c ) { dataBuffer = ( char [ ] ) extendArray ( dataBuffer , dataBuffer . length , dataBufferPos ) ; dataBuffer [ dataBufferPos ++ ] = c ; } void dataBufferAppend ( String s ) { dataBufferAppend ( s . toCharArray ( ) , 0 , s . length ( ) ) ; } void dataBufferAppend ( char ch [ ] , int start , int length ) { dataBuffer = ( char [ ] ) extendArray ( dataBuffer , dataBuffer . length , dataBufferPos + length ) ; System . arraycopy ( ( Object ) ch , start , ( Object ) dataBuffer , dataBufferPos , length ) ; dataBufferPos += length ; } void dataBufferNormalize ( ) { int i = 0 ; int j = 0 ; int end = dataBufferPos ; while ( j < end && isWhitespace ( dataBuffer [ j ] ) ) { j ++ ; } while ( end > j && isWhitespace ( dataBuffer [ end - 1 ] ) ) { end -- ; } while ( j < end ) { char c = dataBuffer [ j ++ ] ; if ( isWhitespace ( c ) ) { while ( j < end && isWhitespace ( dataBuffer [ j ++ ] ) ) { } dataBuffer [ i ++ ] = ' ' ; dataBuffer [ i ++ ] = dataBuffer [ j - 1 ] ; } else { dataBuffer [ i ++ ] = c ; } } dataBufferPos = i ; } String dataBufferToString ( ) { String s = new String ( dataBuffer , 0 , dataBufferPos ) ; dataBufferPos = 0 ; return s ; } void dataBufferFlush ( ) throws java . lang . Exception { if ( dataBufferPos > 0 ) { switch ( currentElementContent ) { case CONTENT_UNDECLARED : case CONTENT_EMPTY : break ; case CONTENT_MIXED : case CONTENT_ANY : if ( handler != null ) { handler . charData ( dataBuffer , 0 , dataBufferPos ) ; } break ; case CONTENT_ELEMENTS : if ( handler != null ) { handler . ignorableWhitespace ( dataBuffer , 0 , dataBufferPos ) ; } break ; } dataBufferPos = 0 ; } } void require ( String delim ) throws java . lang . Exception { char ch [ ] = delim . toCharArray ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) { require ( ch [ i ] ) ; } } void require ( char delim ) throws java . lang . Exception { char c = readCh ( ) ; if ( c != delim ) { error ( "expected character" , c , new Character ( delim ) . toString ( ) ) ; } } public String intern ( String s ) { char ch [ ] = s . toCharArray ( ) ; return intern ( ch , 0 , ch . length ) ; } public String intern ( char ch [ ] , int start , int length ) { int index ; int hash = 0 ; for ( int i = start ; i < start + length ; i ++ ) { hash = ( ( hash << 1 ) & 0xffffff ) + ( int ) ch [ i ] ; } hash = hash % SYMBOL_TABLE_LENGTH ; Object bucket [ ] = ( Object [ ] ) symbolTable [ hash ] ; if ( bucket == null ) { symbolTable [ hash ] = bucket = new Object [ 8 ] ; } for ( index = 0 ; index < bucket . length ; index += 2 ) { char chFound [ ] = ( char [ ] ) bucket [ index ] ; if ( chFound == null ) { break ; } if ( chFound . length == length ) { for ( int i = 0 ; i < chFound . length ; i ++ ) { if ( ch [ start + i ] != chFound [ i ] ) { break ; } else if ( i == length - 1 ) { return ( String ) bucket [ index + 1 ] ; } } } } bucket = ( Object [ ] ) extendArray ( bucket , bucket . length , index ) ; String s = new String ( ch , start , length ) ; bucket [ index ] = s . toCharArray ( ) ; bucket [ index + 1 ] = s ; symbolTable [ hash ] = bucket ; return s ; } Object extendArray ( Object array , int currentSize , int requiredSize ) { if ( requiredSize < currentSize ) { return array ; } else { Object newArray = null ; int newSize = currentSize * 2 ; if ( newSize <= requiredSize ) { newSize = requiredSize + 1 ; } if ( array instanceof char [ ] ) { newArray = new char [ currentSize * 2 ] ; } else if ( array instanceof Object [ ] ) { newArray = new Object [ currentSize * 2 ] ; } System . arraycopy ( array , 0 , newArray , 0 , currentSize ) ; return newArray ; } } public Enumeration declaredElements ( ) { return elementInfo . keys ( ) ; } public int getElementContentType ( String name ) { Object element [ ] = ( Object [ ] ) elementInfo . get ( name ) ; if ( element == null ) { return CONTENT_UNDECLARED ; } else { return ( ( Integer ) element [ 0 ] ) . intValue ( ) ; } } public String getElementContentModel ( String name ) { Object element [ ] = ( Object [ ] ) elementInfo . get ( name ) ; if ( element == null ) { return null ; } else { return ( String ) element [ 1 ] ; } } void setElement ( String name , int contentType , String contentModel , Hashtable attributes ) throws java . lang . Exception { Object element [ ] ; element = ( Object [ ] ) elementInfo . get ( name ) ; if ( element == null ) { element = new Object [ 3 ] ; element [ 0 ] = new Integer ( CONTENT_UNDECLARED ) ; element [ 1 ] = null ; element [ 2 ] = null ; } else if ( contentType != CONTENT_UNDECLARED && ( ( Integer ) element [ 0 ] ) . intValue ( ) != CONTENT_UNDECLARED ) { error ( "multiple declarations for element type" , name , null ) ; return ; } if ( contentType != CONTENT_UNDECLARED ) { element [ 0 ] = new Integer ( contentType ) ; } if ( contentModel != null ) { element [ 1 ] = contentModel ; } if ( attributes != null ) { element [ 2 ] = attributes ; } elementInfo . put ( name , element ) ; } Hashtable getElementAttributes ( String name ) { Object element [ ] = ( Object [ ] ) elementInfo . get ( name ) ; if ( element == null ) { return null ; } else { return ( Hashtable ) element [ 2 ] ; } } public Enumeration declaredAttributes ( String elname ) { Hashtable attlist = getElementAttributes ( elname ) ; if ( attlist == null ) { return null ; } else { return attlist . keys ( ) ; } } public int getAttributeType ( String name , String aname ) { Object attribute [ ] = getAttribute ( name , aname ) ; if ( attribute == null ) { return ATTRIBUTE_UNDECLARED ; } else { return ( ( Integer ) attribute [ 0 ] ) . intValue ( ) ; } } public String getAttributeEnumeration ( String name , String aname ) { Object attribute [ ] = getAttribute ( name , aname ) ; if ( attribute == null ) { return null ; } else { return ( String ) attribute [ 3 ] ; } } public String getAttributeDefaultValue ( String name , String aname ) { Object attribute [ ] = getAttribute ( name , aname ) ; if ( attribute == null ) { return null ; } else { return ( String ) attribute [ 1 ] ; } } public String getAttributeExpandedValue ( String name , String aname ) { Object attribute [ ] = getAttribute ( name , aname ) ; if ( attribute == null ) { return null ; } else if ( attribute [ 4 ] == null && attribute [ 1 ] != null ) { try { pushString ( null , ( char ) 0 + ( String ) attribute [ 1 ] + ( char ) 0 ) ; attribute [ 4 ] = readLiteral ( LIT_NORMALIZE | LIT_CHAR_REF | LIT_ENTITY_REF ) ; } catch ( Exception e ) { } } return ( String ) attribute [ 4 ] ; } public int getAttributeDefaultValueType ( String name , String aname ) { Object attribute [ ] = getAttribute ( name , aname ) ; if ( attribute == null ) { return ATTRIBUTE_DEFAULT_UNDECLARED ; } else { return ( ( Integer ) attribute [ 2 ] ) . intValue ( ) ; } } void setAttribute ( String elName , String name , int type , String enumeration , String value , int valueType ) throws java . lang . Exception { Hashtable attlist ; Object attribute [ ] ; attlist = getElementAttributes ( elName ) ; if ( attlist == null ) { attlist = new Hashtable ( ) ; } if ( attlist . get ( name ) != null ) { return ; } else { attribute = new Object [ 5 ] ; attribute [ 0 ] = new Integer ( type ) ; attribute [ 1 ] = value ; attribute [ 2 ] = new Integer ( valueType ) ; attribute [ 3 ] = enumeration ; attribute [ 4 ] = null ; attlist . put ( name . intern ( ) , attribute ) ; setElement ( elName , CONTENT_UNDECLARED , null , attlist ) ; } } Object [ ] getAttribute ( String elName , String name ) { Hashtable attlist ; Object attribute [ ] ; attlist = getElementAttributes ( elName ) ; if ( attlist == null ) { return null ; } attribute = ( Object [ ] ) attlist . get ( name ) ; return attribute ; } public Enumeration declaredEntities ( ) { return entityInfo . keys ( ) ; } public int getEntityType ( String ename ) { Object entity [ ] = ( Object [ ] ) entityInfo . get ( ename ) ; if ( entity == null ) { return ENTITY_UNDECLARED ; } else { return ( ( Integer ) entity [ 0 ] ) . intValue ( ) ; } } public String getEntityPublicId ( String ename ) { Object entity [ ] = ( Object [ ] ) entityInfo . get ( ename ) ; if ( entity == null ) { return null ; } else { return ( String ) entity [ 1 ] ; } } public String getEntitySystemId ( String ename ) { Object entity [ ] = ( Object [ ] ) entityInfo . get ( ename ) ; if ( entity == null ) { return null ; } else { return ( String ) entity [ 2 ] ; } } public String getEntityValue ( String ename ) { Object entity [ ] = ( Object [ ] ) entityInfo . get ( ename ) ; if ( entity == null ) { return null ; } else { return ( String ) entity [ 3 ] ; } } public String getEntityNotationName ( String eName ) { Object entity [ ] = ( Object [ ] ) entityInfo . get ( eName ) ; if ( entity == null ) { return null ; } else { return ( String ) entity [ 4 ] ; } } void setInternalEntity ( String eName , String value ) { setEntity ( eName , ENTITY_INTERNAL , null , null , value , null ) ; } void setExternalDataEntity ( String eName , String pubid , String sysid , String nName ) { setEntity ( eName , ENTITY_NDATA , pubid , sysid , null , nName ) ; } void setExternalTextEntity ( String eName , String pubid , String sysid ) { setEntity ( eName , ENTITY_TEXT , pubid , sysid , null , null ) ; } void setEntity ( String eName , int eClass , String pubid , String sysid , String value , String nName ) { Object entity [ ] ; if ( entityInfo . get ( eName ) == null ) { entity = new Object [ 5 ] ; entity [ 0 ] = new Integer ( eClass ) ; entity [ 1 ] = pubid ; entity [ 2 ] = sysid ; entity [ 3 ] = value ; entity [ 4 ] = nName ; entityInfo . put ( eName , entity ) ; } } public Enumeration declaredNotations ( ) { return notationInfo . keys ( ) ; } public String getNotationPublicId ( String nname ) { Object notation [ ] = ( Object [ ] ) notationInfo . get ( nname ) ; if ( notation == null ) { return null ; } else { return ( String ) notation [ 0 ] ; } } public String getNotationSystemId ( String nname ) { Object notation [ ] = ( Object [ ] ) notationInfo . get ( nname ) ; if ( notation == null ) { return null ; } else { return ( String ) notation [ 1 ] ; } } void setNotation ( String nname , String pubid , String sysid ) throws java . lang . Exception { Object notation [ ] ; if ( notationInfo . get ( nname ) == null ) { notation = new Object [ 2 ] ; notation [ 0 ] = pubid ; notation [ 1 ] = sysid ; notationInfo . put ( nname , notation ) ; } else { error ( "multiple declarations of notation" , nname , null ) ; } } public int getLineNumber ( ) { return line ; } public int getColumnNumber ( ) { return column ; } char readCh ( ) throws java . lang . Exception { char c ; while ( readBufferPos >= readBufferLength ) { switch ( sourceType ) { case INPUT_READER : case INPUT_EXTERNAL : case INPUT_STREAM : readDataChunk ( ) ; while ( readBufferLength < 1 ) { popInput ( ) ; if ( readBufferLength < 1 ) { readDataChunk ( ) ; } } break ; default : popInput ( ) ; break ; } } c = readBuffer [ readBufferPos ++ ] ; if ( c == '%' && ( context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE ) ) { char c2 = readCh ( ) ; unread ( c2 ) ; if ( ! isWhitespace ( c2 ) ) { parsePEReference ( context == CONTEXT_ENTITYVALUE ) ; return readCh ( ) ; } } if ( c == '\n' ) { line ++ ; column = 0 ; } else { column ++ ; } return c ; } void unread ( char c ) throws java . lang . Exception { if ( c == '\n' ) { line -- ; column = - 1 ; } if ( readBufferPos > 0 ) { readBuffer [ -- readBufferPos ] = c ; } else { pushString ( null , new Character ( c ) . toString ( ) ) ; } } void unread ( char ch [ ] , int length ) throws java . lang . Exception { for ( int i = 0 ; i < length ; i ++ ) { if ( ch [ i ] == '\n' ) { line -- ; column = - 1 ; } } if ( length < readBufferPos ) { readBufferPos -= length ; } else { pushCharArray ( null , ch , 0 , length ) ; sourceType = INPUT_BUFFER ; } } void pushURL ( String ename , String publicId , String systemId , Reader reader , InputStream stream , String encoding ) throws java . lang . Exception { URL url ; boolean ignoreEncoding = false ; pushInput ( ename ) ; readBuffer = new char [ READ_BUFFER_MAX + 4 ] ; readBufferPos = 0 ; readBufferLength = 0 ; readBufferOverflow = - 1 ; is = null ; line = 1 ; currentByteCount = 0 ; dataBufferFlush ( ) ; if ( systemId != null && externalEntity != null ) { systemId = new URL ( externalEntity . getURL ( ) , systemId ) . toString ( ) ; } else if ( baseURI != null ) { try { systemId = new URL ( new URL ( baseURI ) , systemId ) . toString ( ) ; } catch ( Exception e ) { } } if ( systemId != null && handler != null ) { Object input = handler . resolveEntity ( publicId , systemId ) ; if ( input != null ) { if ( input instanceof String ) { systemId = ( String ) input ; } else if ( input instanceof InputStream ) { stream = ( InputStream ) input ; } else if ( input instanceof Reader ) { reader = ( Reader ) input ; } } } if ( handler != null ) { if ( systemId != null ) { handler . startExternalEntity ( systemId ) ; } else { handler . startExternalEntity ( "[external stream]" ) ; } } if ( reader != null ) { sourceType = INPUT_READER ; this . reader = reader ; tryEncodingDecl ( true ) ; return ; } else if ( stream != null ) { sourceType = INPUT_STREAM ; is = stream ; } else { sourceType = INPUT_EXTERNAL ; url = new URL ( systemId ) ; externalEntity = url . openConnection ( ) ; externalEntity . connect ( ) ; is = externalEntity . getInputStream ( ) ; } if ( ! is . markSupported ( ) ) { is = new BufferedInputStream ( is ) ; } if ( encoding == null && externalEntity != null ) { encoding = externalEntity . getContentEncoding ( ) ; } if ( encoding != null ) { checkEncoding ( encoding , false ) ; ignoreEncoding = true ; } else { detectEncoding ( ) ; ignoreEncoding = false ; } tryEncodingDecl ( ignoreEncoding ) ; } void tryEncodingDecl ( boolean ignoreEncoding ) throws java . lang . Exception { if ( tryRead ( "<?xml" ) ) { if ( tryWhitespace ( ) ) { if ( inputStack . size ( ) > 0 ) { parseTextDecl ( ignoreEncoding ) ; } else { parseXMLDecl ( ignoreEncoding ) ; } } else { unread ( "xml" . toCharArray ( ) , 3 ) ; parsePI ( ) ; } } } void detectEncoding ( ) throws java . lang . Exception { byte signature [ ] = new byte [ 4 ] ; is . mark ( 4 ) ; is . read ( signature ) ; is . reset ( ) ; if ( tryEncoding ( signature , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x3c ) ) { encoding = ENCODING_UCS_4_1234 ; } else if ( tryEncoding ( signature , ( byte ) 0x3c , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 ) ) { encoding = ENCODING_UCS_4_4321 ; } else if ( tryEncoding ( signature , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x3c , ( byte ) 0x00 ) ) { encoding = ENCODING_UCS_4_2143 ; } else if ( tryEncoding ( signature , ( byte ) 0x00 , ( byte ) 0x3c , ( byte ) 0x00 , ( byte ) 0x00 ) ) { encoding = ENCODING_UCS_4_3412 ; } else if ( tryEncoding ( signature , ( byte ) 0xfe , ( byte ) 0xff ) ) { encoding = ENCODING_UCS_2_12 ; is . read ( ) ; is . read ( ) ; } else if ( tryEncoding ( signature , ( byte ) 0xff , ( byte ) 0xfe ) ) { encoding = ENCODING_UCS_2_21 ; is . read ( ) ; is . read ( ) ; } else if ( tryEncoding ( signature , ( byte ) 0x00 , ( byte ) 0x3c , ( byte ) 0x00 , ( byte ) 0x3f ) ) { encoding = ENCODING_UCS_2_12 ; error ( "no byte-order mark for UCS-2 entity" , null , null ) ; } else if ( tryEncoding ( signature , ( byte ) 0x3c , ( byte ) 0x00 , ( byte ) 0x3f , ( byte ) 0x00 ) ) { encoding = ENCODING_UCS_2_21 ; error ( "no byte-order mark for UCS-2 entity" , null , null ) ; } else if ( tryEncoding ( signature , ( byte ) 0x3c , ( byte ) 0x3f , ( byte ) 0x78 , ( byte ) 0x6d ) ) { encoding = ENCODING_UTF_8 ; read8bitEncodingDeclaration ( ) ; } else { encoding = ENCODING_UTF_8 ; } } boolean tryEncoding ( byte sig [ ] , byte b1 , byte b2 , byte b3 , byte b4 ) { return ( sig [ 0 ] == b1 && sig [ 1 ] == b2 && sig [ 2 ] == b3 && sig [ 3 ] == b4 ) ; } boolean tryEncoding ( byte sig [ ] , byte b1 , byte b2 ) { return ( ( sig [ 0 ] == b1 ) && ( sig [ 1 ] == b2 ) ) ; } void pushString ( String ename , String s ) throws java . lang . Exception { char ch [ ] = s . toCharArray ( ) ; pushCharArray ( ename , ch , 0 , ch . length ) ; } void pushCharArray ( String ename , char ch [ ] , int start , int length ) throws java . lang . Exception { pushInput ( ename ) ; sourceType = INPUT_INTERNAL ; readBuffer = ch ; readBufferPos = start ; readBufferLength = length ; readBufferOverflow = - 1 ; } void pushInput ( String ename ) throws java . lang . Exception { Object input [ ] = new Object [ 12 ] ; if ( ename != null ) { Enumeration entities = entityStack . elements ( ) ; while ( entities . hasMoreElements ( ) ) { String e = ( String ) entities . nextElement ( ) ; if ( e == ename ) { error ( "recursive reference to entity" , ename , null ) ; } } } entityStack . push ( ename ) ; if ( sourceType == INPUT_NONE ) { return ; } input [ 0 ] = new Integer ( sourceType ) ; input [ 1 ] = externalEntity ; input [ 2 ] = readBuffer ; input [ 3 ] = new Integer ( readBufferPos ) ; input [ 4 ] = new Integer ( readBufferLength ) ; input [ 5 ] = new Integer ( line ) ; input [ 6 ] = new Integer ( encoding ) ; input [ 7 ] = new Integer ( readBufferOverflow ) ; input [ 8 ] = is ; input [ 9 ] = new Integer ( currentByteCount ) ; input [ 10 ] = new Integer ( column ) ; input [ 11 ] = reader ; inputStack . push ( input ) ; } void popInput ( ) throws java . lang . Exception { Object input [ ] ; switch ( sourceType ) { case INPUT_EXTERNAL : dataBufferFlush ( ) ; if ( handler != null && externalEntity != null ) { handler . endExternalEntity ( externalEntity . getURL ( ) . toString ( ) ) ; } break ; case INPUT_STREAM : dataBufferFlush ( ) ; if ( baseURI != null ) { if ( handler != null ) { handler . endExternalEntity ( baseURI ) ; } } break ; case INPUT_READER : dataBufferFlush ( ) ; if ( baseURI != null ) { if ( handler != null ) { handler . endExternalEntity ( baseURI ) ; } } break ; } if ( inputStack . isEmpty ( ) ) { throw new EOFException ( ) ; } else { String s ; input = ( Object [ ] ) inputStack . pop ( ) ; s = ( String ) entityStack . pop ( ) ; } sourceType = ( ( Integer ) input [ 0 ] ) . intValue ( ) ; externalEntity = ( URLConnection ) input [ 1 ] ; readBuffer = ( char [ ] ) input [ 2 ] ; readBufferPos = ( ( Integer ) input [ 3 ] ) . intValue ( ) ; readBufferLength = ( ( Integer ) input [ 4 ] ) . intValue ( ) ; line = ( ( Integer ) input [ 5 ] ) . intValue ( ) ; encoding = ( ( Integer ) input [ 6 ] ) . intValue ( ) ; readBufferOverflow = ( ( Integer ) input [ 7 ] ) . intValue ( ) ; is = ( InputStream ) input [ 8 ] ; currentByteCount = ( ( Integer ) input [ 9 ] ) . intValue ( ) ; column = ( ( Integer ) input [ 10 ] ) . intValue ( ) ; reader = ( Reader ) input [ 11 ] ; } boolean tryRead ( char delim ) throws java . lang . Exception { char c ; c = readCh ( ) ; if ( c == delim ) { return true ; } else { unread ( c ) ; return false ; } } boolean tryRead ( String delim ) throws java . lang . Exception { char ch [ ] = delim . toCharArray ( ) ; char c ; for ( int i = 0 ; i < ch . length ; i ++ ) { c = readCh ( ) ; if ( c != ch [ i ] ) { unread ( c ) ; if ( i != 0 ) { unread ( ch , i ) ; } return false ; } } return true ; } boolean tryWhitespace ( ) throws java . lang . Exception { char c ; c = readCh ( ) ; if ( isWhitespace ( c ) ) { skipWhitespace ( ) ; return true ; } else { unread ( c ) ; return false ; } } void parseUntil ( String delim ) throws java . lang . Exception { char c ; int startLine = line ; try { while ( ! tryRead ( delim ) ) { c = readCh ( ) ; dataBufferAppend ( c ) ; } } catch ( EOFException e ) { error ( "end of input while looking for delimiter (started on line " + startLine + ')' , null , delim ) ; } } void skipUntil ( String delim ) throws java . lang . Exception { while ( ! tryRead ( delim ) ) { readCh ( ) ; } } void read8bitEncodingDeclaration ( ) throws java . lang . Exception { int ch ; readBufferPos = readBufferLength = 0 ; while ( true ) { ch = is . read ( ) ; readBuffer [ readBufferLength ++ ] = ( char ) ch ; switch ( ch ) { case ( int ) '>' : return ; case - 1 : error ( "end of file before end of XML or encoding declaration." , null , "?>" ) ; return ; } if ( readBuffer . length == readBufferLength ) { error ( "unfinished XML or encoding declaration" , null , null ) ; } } } void readDataChunk ( ) throws java . lang . Exception { int count , i , j ; if ( readBufferOverflow > - 1 ) { readBuffer [ 0 ] = ( char ) readBufferOverflow ; readBufferOverflow = - 1 ; readBufferPos = 1 ; sawCR = true ; } else { readBufferPos = 0 ; sawCR = false ; } if ( sourceType == INPUT_READER ) { count = reader . read ( readBuffer , readBufferPos , READ_BUFFER_MAX - 1 ) ; if ( count < 0 ) { readBufferLength = - 1 ; } else { readBufferLength = readBufferPos + count ; filterCR ( ) ; sawCR = false ; } return ; } count = is . read ( rawReadBuffer , 0 , READ_BUFFER_MAX ) ; switch ( encoding ) { case ENCODING_UTF_8 : copyUtf8ReadBuffer ( count ) ; break ; case ENCODING_ISO_8859_1 : copyIso8859_1ReadBuffer ( count ) ; break ; case ENCODING_UCS_2_12 : copyUcs2ReadBuffer ( count , 8 , 0 ) ; break ; case ENCODING_UCS_2_21 : copyUcs2ReadBuffer ( count , 0 , 8 ) ; break ; case ENCODING_UCS_4_1234 : copyUcs4ReadBuffer ( count , 24 , 16 , 8 , 0 ) ; break ; case ENCODING_UCS_4_4321 : copyUcs4ReadBuffer ( count , 0 , 8 , 16 , 24 ) ; break ; case ENCODING_UCS_4_2143 : copyUcs4ReadBuffer ( count , 16 , 24 , 0 , 8 ) ; break ; case ENCODING_UCS_4_3412 : copyUcs4ReadBuffer ( count , 8 , 0 , 24 , 16 ) ; break ; } if ( sawCR ) { filterCR ( ) ; sawCR = false ; } readBufferPos = 0 ; currentByteCount += count ; } void filterCR ( ) { int i , j ; readBufferOverflow = - 1 ; loop : for ( i = 0 , j = 0 ; j < readBufferLength ; i ++ , j ++ ) { switch ( readBuffer [ j ] ) { case '\r' : if ( j == readBufferLength - 1 ) { readBufferOverflow = '\r' ; readBufferLength -- ; break loop ; } else if ( readBuffer [ j + 1 ] == '\n' ) { j ++ ; } readBuffer [ i ] = '\n' ; break ; case '\n' : default : readBuffer [ i ] = readBuffer [ j ] ; break ; } } readBufferLength = i ; } void copyUtf8ReadBuffer ( int count ) throws java . lang . Exception { int i = 0 ; int j = readBufferPos ; int b1 ; boolean isSurrogate = false ; while ( i < count ) { b1 = rawReadBuffer [ i ++ ] ; isSurrogate = false ; if ( ( b1 & 0x80 ) == 0 ) { readBuffer [ j ++ ] = ( char ) b1 ; } else if ( ( b1 & 0xe0 ) == 0xc0 ) { readBuffer [ j ++ ] = ( char ) ( ( ( b1 & 0x1f ) << 6 ) | getNextUtf8Byte ( i ++ , count ) ) ; } else if ( ( b1 & 0xf0 ) == 0xe0 ) { readBuffer [ j ++ ] = ( char ) ( ( ( b1 & 0x0f ) << 12 ) | ( getNextUtf8Byte ( i ++ , count ) << 6 ) | getNextUtf8Byte ( i ++ , count ) ) ; } else if ( ( b1 & 0xf8 ) == 0xf0 ) { isSurrogate = true ; int b2 = getNextUtf8Byte ( i ++ , count ) ; int b3 = getNextUtf8Byte ( i ++ , count ) ; int b4 = getNextUtf8Byte ( i ++ , count ) ; readBuffer [ j ++ ] = ( char ) ( 0xd800 | ( ( ( ( b1 & 0x07 ) << 2 ) | ( ( b2 & 0x30 ) > > 4 ) - 1 ) << 6 ) | ( ( b2 & 0x0f ) << 2 ) | ( ( b3 & 0x30 ) > > 4 ) ) ; readBuffer [ j ++ ] = ( char ) ( 0xdc | ( ( b3 & 0x0f ) << 6 ) | b4 ) ; } else { encodingError ( "bad start for UTF-8 multi-byte sequence" , b1 , i ) ; } if ( readBuffer [ j - 1 ] == '\r' ) { sawCR = true ; } } readBufferLength = j ; } int getNextUtf8Byte ( int pos , int count ) throws java . lang . Exception { int val ; if ( pos < count ) { val = rawReadBuffer [ pos ] ; } else { val = is . read ( ) ; if ( val == - 1 ) { encodingError ( "unfinished multi-byte UTF-8 sequence at EOF" , - 1 , pos ) ; } } if ( ( val & 0xc0 ) != 0x80 ) { encodingError ( "bad continuation of multi-byte UTF-8 sequence" , val , pos + 1 ) ; } return ( val & 0x3f ) ; } void copyIso8859_1ReadBuffer ( int count ) { int i , j ; for ( i = 0 , j = readBufferPos ; i < count ; i ++ , j ++ ) { readBuffer [ j ] = ( char ) ( rawReadBuffer [ i ] & 0xff ) ; if ( readBuffer [ j ] == '\r' ) { sawCR = true ; } } readBufferLength = j ; } void copyUcs2ReadBuffer ( int count , int shift1 , int shift2 ) throws java . lang . Exception { int j = readBufferPos ; if ( count > 0 && ( count % 2 ) != 0 ) { encodingError ( "odd number of bytes in UCS-2 encoding" , - 1 , count ) ; } for ( int i = 0 ; i < count ; i += 2 ) { readBuffer [ j ++ ] = ( char ) ( ( ( rawReadBuffer [ i ] & 0xff ) << shift1 ) | ( ( rawReadBuffer [ i + 1 ] & 0xff ) << shift2 ) ) ; if ( readBuffer [ j - 1 ] == '\r' ) { sawCR = true ; } } readBufferLength = j ; } void copyUcs4ReadBuffer ( int count , int shift1 , int shift2 , int shift3 , int shift4 ) throws java . lang . Exception { int j = readBufferPos ; int value ; if ( count > 0 && ( count % 4 ) != 0 ) { encodingError ( "number of bytes in UCS-4 encoding not divisible by 4" , - 1 , count ) ; } for ( int i = 0 ; i < count ; i += 4 ) { value = ( ( ( rawReadBuffer [ i ] & 0xff ) << shift1 ) | ( ( rawReadBuffer [ i + 1 ] & 0xff ) << shift2 ) | ( ( rawReadBuffer [ i + 2 ] & 0xff ) << shift3 ) | ( ( rawReadBuffer [ i + 3 ] & 0xff ) << shift4 ) ) ; if ( value < 0x0000ffff ) { readBuffer [ j ++ ] = ( char ) value ; if ( value == ( int ) '\r' ) { sawCR = true ; } } else if ( value < 0x000fffff ) { readBuffer [ j ++ ] = ( char ) ( 0xd8 | ( ( value & 0x000ffc00 ) > > 10 ) ) ; readBuffer [ j ++ ] = ( char ) ( 0xdc | ( value & 0x0003ff ) ) ; } else { encodingError ( "value cannot be represented in UTF-16" , value , i ) ; } } readBufferLength = j ; } void encodingError ( String message , int value , int offset ) throws java . lang . Exception { String uri ; if ( value >= 0 ) { message = message + " (byte value: 0x" + Integer . toHexString ( value ) + ')' ; } if ( externalEntity != null ) { uri = externalEntity . getURL ( ) . toString ( ) ; } else { uri = baseURI ; } handler . error ( message , uri , - 1 , offset + currentByteCount ) ; } void initializeVariables ( ) { errorCount = 0 ; line = 1 ; column = 0 ; dataBufferPos = 0 ; dataBuffer = new char [ DATA_BUFFER_INITIAL ] ; nameBufferPos = 0 ; nameBuffer = new char [ NAME_BUFFER_INITIAL ] ; elementInfo = new Hashtable ( ) ; entityInfo = new Hashtable ( ) ; notationInfo = new Hashtable ( ) ; currentElement = null ; currentElementContent = CONTENT_UNDECLARED ; sourceType = INPUT_NONE ; inputStack = new Stack ( ) ; entityStack = new Stack ( ) ; externalEntity = null ; tagAttributePos = 0 ; tagAttributes = new String [ 100 ] ; rawReadBuffer = new byte [ READ_BUFFER_MAX ] ; readBufferOverflow = - 1 ; context = CONTEXT_NONE ; symbolTable = new Object [ SYMBOL_TABLE_LENGTH ] ; } void cleanupVariables ( ) { errorCount = - 1 ; line = - 1 ; column = - 1 ; dataBuffer = null ; nameBuffer = null ; currentElement = null ; currentElementContent = CONTENT_UNDECLARED ; sourceType = INPUT_NONE ; inputStack = null ; externalEntity = null ; entityStack = null ; } XmlHandler handler ; private Reader reader ; private InputStream is ; private int line ; private int column ; private int sourceType ; private Stack inputStack ; private URLConnection externalEntity ; private int encoding ; private int currentByteCount ; private int errorCount ; private final static int READ_BUFFER_MAX = 16384 ; private char readBuffer [ ] ; private int readBufferPos ; private int readBufferLength ; private int readBufferOverflow ; private byte rawReadBuffer [ ] ; private static int DATA_BUFFER_INITIAL = 4096 ; private char dataBuffer [ ] ; private int dataBufferPos ; private static int NAME_BUFFER_INITIAL = 1024 ; private char nameBuffer [ ] ; private int nameBufferPos ; private Hashtable elementInfo ; private Hashtable entityInfo ; private Hashtable notationInfo ; private String currentElement ; private int currentElementContent ; private String basePublicId ; private String baseURI ; private int baseEncoding ; private Reader baseReader ; private InputStream baseInputStream ; private char baseInputBuffer [ ] ; private int baseInputBufferStart ; private int baseInputBufferLength ; private Stack entityStack ; private int context ; private Object symbolTable [ ] ; private final static int SYMBOL_TABLE_LENGTH = 1087 ; private String tagAttributes [ ] ; private int tagAttributePos ; private boolean sawCR ; } 	0	['118', '1', '0', '6', '180', '6075', '5', '1', '27', '0.921125975', '5223', '0.717391304', '1', '0', '0.138067061', '0', '0', '42.48305085', '9', '1.4492', '0']
package org . gjt . sp . jedit ; import java . util . Enumeration ; import java . util . Vector ; import org . gjt . sp . util . Log ; public class OptionGroup { public OptionGroup ( String name ) { this . name = name ; members = new Vector ( ) ; } public String getName ( ) { return name ; } public void addOptionGroup ( OptionGroup group ) { if ( members . indexOf ( group ) != - 1 ) return ; members . addElement ( group ) ; } public void addOptionPane ( OptionPane pane ) { if ( members . indexOf ( pane ) != - 1 ) return ; members . addElement ( pane ) ; } public Enumeration getMembers ( ) { return members . elements ( ) ; } public Object getMember ( int index ) { return ( index >= 0 && index < members . size ( ) ) ? members . elementAt ( index ) : null ; } public int getMemberIndex ( Object member ) { return members . indexOf ( member ) ; } public int getMemberCount ( ) { return members . size ( ) ; } public void save ( ) { Enumeration enum = members . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object elem = enum . nextElement ( ) ; try { if ( elem instanceof OptionPane ) { ( ( OptionPane ) elem ) . save ( ) ; } else if ( elem instanceof OptionGroup ) { ( ( OptionGroup ) elem ) . save ( ) ; } } catch ( Throwable t ) { Log . log ( Log . ERROR , elem , "Error saving option pane" ) ; Log . log ( Log . ERROR , elem , t ) ; } } } private String name ; private Vector members ; } 	0	['9', '1', '0', '5', '20', '0', '3', '2', '9', '0.5', '111', '1', '0', '0', '0.259259259', '0', '0', '11.11111111', '3', '1.5556', '0']
package bsh ; class JJTParserState { private java . util . Stack nodes ; private java . util . Stack marks ; private int sp ; private int mk ; private boolean node_created ; JJTParserState ( ) { nodes = new java . util . Stack ( ) ; marks = new java . util . Stack ( ) ; sp = 0 ; mk = 0 ; } boolean nodeCreated ( ) { return node_created ; } void reset ( ) { nodes . removeAllElements ( ) ; marks . removeAllElements ( ) ; sp = 0 ; mk = 0 ; } Node rootNode ( ) { return ( Node ) nodes . elementAt ( 0 ) ; } void pushNode ( Node n ) { nodes . push ( n ) ; ++ sp ; } Node popNode ( ) { if ( -- sp < mk ) { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; } return ( Node ) nodes . pop ( ) ; } Node peekNode ( ) { return ( Node ) nodes . peek ( ) ; } int nodeArity ( ) { return sp - mk ; } void clearNodeScope ( Node n ) { while ( sp > mk ) { popNode ( ) ; } mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; } void openNodeScope ( Node n ) { marks . push ( new Integer ( mk ) ) ; mk = sp ; n . jjtOpen ( ) ; } void closeNodeScope ( Node n , int num ) { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; while ( num -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , num ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } void closeNodeScope ( Node n , boolean condition ) { if ( condition ) { int a = nodeArity ( ) ; mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; while ( a -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , a ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } else { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; node_created = false ; } } } 	0	['12', '1', '0', '3', '25', '0', '2', '1', '0', '0.436363636', '218', '1', '0', '0', '0.395833333', '0', '0', '16.75', '3', '1.3333', '0']
package bsh ; import java . util . * ; public class StringUtil { public static String [ ] split ( String s , String delim ) { Vector v = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( s , delim ) ; while ( st . hasMoreTokens ( ) ) v . addElement ( st . nextToken ( ) ) ; String [ ] sa = new String [ v . size ( ) ] ; v . copyInto ( sa ) ; return sa ; } public static String [ ] bubbleSort ( String [ ] in ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < in . length ; i ++ ) v . addElement ( in [ i ] ) ; int n = v . size ( ) ; boolean swap = true ; while ( swap ) { swap = false ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) if ( ( ( String ) v . elementAt ( i ) ) . compareTo ( ( ( String ) v . elementAt ( i + 1 ) ) ) > 0 ) { String tmp = ( String ) v . elementAt ( i + 1 ) ; v . removeElementAt ( i + 1 ) ; v . insertElementAt ( tmp , i ) ; swap = true ; } } String [ ] out = new String [ n ] ; v . copyInto ( out ) ; return out ; } public static String maxCommonPrefix ( String one , String two ) { int i = 0 ; while ( one . regionMatches ( 0 , two , 0 , i ) ) i ++ ; return one . substring ( 0 , i - 1 ) ; } public static String methodString ( String name , Class [ ] types ) { StringBuffer sb = new StringBuffer ( name + "(" ) ; if ( types . length > 0 ) sb . append ( " " ) ; for ( int i = 0 ; i < ( types . length - 1 ) ; i ++ ) { Class c = types [ i ] ; sb . append ( ( ( c == null ) ? "null" : c . getName ( ) ) + ", " ) ; } if ( types . length > 0 ) { Class c = types [ types . length - 1 ] ; sb . append ( ( ( c == null ) ? "null" : c . getName ( ) ) ) ; sb . append ( " " ) ; } sb . append ( ")" ) ; return sb . toString ( ) ; } } 	0	['5', '1', '0', '1', '24', '10', '1', '0', '5', '2', '206', '0', '0', '0', '0.3', '0', '0', '40.2', '6', '3', '0']
package org . gjt . sp . jedit ; import java . awt . Component ; public interface OptionPane { String getName ( ) ; Component getComponent ( ) ; void init ( ) ; void save ( ) ; } 	0	['4', '1', '0', '5', '4', '6', '5', '0', '4', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package gnu . regexp ; final class RETokenChar extends REToken { private char [ ] ch ; private boolean insens ; RETokenChar ( int subIndex , char c , boolean ins ) { super ( subIndex ) ; ch = new char [ 1 ] ; ch [ 0 ] = ( insens = ins ) ? Character . toLowerCase ( c ) : c ; } int getMinimumLength ( ) { return ch . length ; } boolean match ( CharIndexed input , REMatch mymatch ) { int z = ch . length ; char c ; for ( int i = 0 ; i < z ; i ++ ) { c = input . charAt ( mymatch . index + i ) ; if ( ( ( insens ) ? Character . toLowerCase ( c ) : c ) != ch [ i ] ) { return false ; } } mymatch . index += z ; return next ( input , mymatch ) ; } boolean chain ( REToken next ) { if ( next instanceof RETokenChar ) { RETokenChar cnext = ( RETokenChar ) next ; int newsize = ch . length + cnext . ch . length ; char [ ] chTemp = new char [ newsize ] ; System . arraycopy ( ch , 0 , chTemp , 0 , ch . length ) ; System . arraycopy ( cnext . ch , 0 , chTemp , ch . length , cnext . ch . length ) ; ch = chTemp ; return false ; } else return super . chain ( next ) ; } void dump ( StringBuffer os ) { os . append ( ch ) ; } } 	0	['5', '2', '0', '5', '12', '0', '2', '3', '0', '0.375', '127', '1', '0', '0.636363636', '0.3', '1', '2', '24', '4', '1.6', '0']
package org . gjt . sp . util ; public abstract class WorkRequest implements Runnable { public void setAbortable ( boolean abortable ) { Thread thread = Thread . currentThread ( ) ; if ( thread instanceof WorkThread ) ( ( WorkThread ) thread ) . setAbortable ( abortable ) ; } public void setStatus ( String status ) { Thread thread = Thread . currentThread ( ) ; if ( thread instanceof WorkThread ) ( ( WorkThread ) thread ) . setStatus ( status ) ; } public void setProgressValue ( int value ) { Thread thread = Thread . currentThread ( ) ; if ( thread instanceof WorkThread ) ( ( WorkThread ) thread ) . setProgressValue ( value ) ; } public void setProgressMaximum ( int value ) { Thread thread = Thread . currentThread ( ) ; if ( thread instanceof WorkThread ) ( ( WorkThread ) thread ) . setProgressMaximum ( value ) ; } } 	0	['6', '1', '3', '4', '12', '15', '3', '1', '6', '2', '49', '0', '0', '0', '0.416666667', '0', '0', '7.166666667', '2', '1.5', '0']
package bsh ; class BSHCastExpression extends SimpleNode { public BSHCastExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { NameSpace namespace = callstack . top ( ) ; Class toType = ( ( BSHType ) jjtGetChild ( 0 ) ) . getType ( namespace ) ; SimpleNode expression = ( SimpleNode ) jjtGetChild ( 1 ) ; Object fromValue = expression . eval ( callstack , interpreter ) ; Class fromType = fromValue . getClass ( ) ; try { return castObject ( fromValue , toType ) ; } catch ( EvalError e ) { e . reThrow ( this ) ; throw new InterpreterError ( "can't happen" ) ; } } public static Object castObject ( Object fromValue , Class toType ) throws EvalError { Class fromType = fromValue . getClass ( ) ; Object result = null ; if ( toType . isPrimitive ( ) ) if ( fromValue instanceof Primitive ) result = castPrimitive ( ( Primitive ) fromValue , toType ) ; else castError ( fromValue . getClass ( ) , toType ) ; else if ( fromValue instanceof Primitive ) result = castPrimitive ( ( Primitive ) fromValue , toType ) ; else if ( Capabilities . canGenerateInterfaces ( ) && ( fromValue instanceof bsh . This ) && toType . isInterface ( ) ) result = ( ( bsh . This ) fromValue ) . getInterface ( toType ) ; else if ( toType . isInstance ( fromValue ) ) result = fromValue ; else castError ( fromType , toType ) ; if ( result == null ) throw new InternalError ( "bad construct somewhere..." ) ; return result ; } public static void castError ( Class from , Class to ) throws EvalError { castError ( Reflect . normalizeClassName ( from ) , Reflect . normalizeClassName ( to ) ) ; } public static void castError ( String from , String to ) throws EvalError { Exception cce = new ClassCastException ( "Illegal cast. Cannot cast " + from + " to " + to ) ; throw new TargetError ( "Cast" , cce ) ; } public static Primitive castPrimitive ( Primitive primValue , Class toType ) throws EvalError { if ( primValue == Primitive . VOID ) castError ( "void value" , Reflect . normalizeClassName ( toType ) ) ; Object value = primValue . getValue ( ) ; Class fromType = primValue . getType ( ) ; if ( ! toType . isPrimitive ( ) ) if ( primValue != Primitive . NULL ) castError ( "primitive value" , "object type:" + toType ) ; else return primValue ; if ( fromType == Boolean . TYPE ) { if ( toType != Boolean . TYPE ) castError ( fromType , toType ) ; else return primValue ; } if ( value instanceof Character ) value = new Integer ( ( ( Character ) value ) . charValue ( ) ) ; if ( value instanceof Number ) { Number number = ( Number ) value ; if ( toType == Byte . TYPE ) value = new Primitive ( number . byteValue ( ) ) ; else if ( toType == Short . TYPE ) value = new Primitive ( number . shortValue ( ) ) ; else if ( toType == Character . TYPE ) value = new Primitive ( ( char ) number . intValue ( ) ) ; else if ( toType == Integer . TYPE ) value = new Primitive ( number . intValue ( ) ) ; else if ( toType == Long . TYPE ) value = new Primitive ( number . longValue ( ) ) ; else if ( toType == Float . TYPE ) value = new Primitive ( number . floatValue ( ) ) ; else if ( toType == Double . TYPE ) value = new Primitive ( number . doubleValue ( ) ) ; else castError ( fromType , toType ) ; return ( Primitive ) value ; } throw new EvalError ( "unknown type in cast" ) ; } } 	0	['6', '2', '0', '16', '45', '15', '3', '13', '6', '2', '280', '0', '0', '0.782608696', '0.229166667', '1', '1', '45.66666667', '1', '0.8333', '0']
package com . microstar . xml ; import com . microstar . xml . XmlHandler ; import com . microstar . xml . XmlException ; import java . io . Reader ; public class HandlerBase implements XmlHandler { public void startDocument ( ) throws java . lang . Exception { } public void endDocument ( ) throws java . lang . Exception { } public Object resolveEntity ( String publicId , String systemId ) throws java . lang . Exception { return null ; } public void startExternalEntity ( String systemId ) throws java . lang . Exception { } public void endExternalEntity ( String systemId ) throws java . lang . Exception { } public void doctypeDecl ( String name , String publicId , String systemId ) throws java . lang . Exception { } public void attribute ( String aname , String value , boolean isSpecified ) throws java . lang . Exception { } public void startElement ( String elname ) throws java . lang . Exception { } public void endElement ( String elname ) throws java . lang . Exception { } public void charData ( char ch [ ] , int start , int length ) throws java . lang . Exception { } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws java . lang . Exception { } public void processingInstruction ( String target , String data ) throws java . lang . Exception { } public void error ( String message , String systemId , int line , int column ) throws XmlException , java . lang . Exception { throw new XmlException ( message , systemId , line , column ) ; } } 	0	['14', '1', '6', '8', '16', '91', '6', '2', '14', '2', '38', '0', '0', '0', '0.414285714', '0', '0', '1.714285714', '1', '0.9286', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; public class ViewUpdate extends EBMessage . NonVetoable { public static final Object CREATED = "CREATED" ; public static final Object CLOSED = "CLOSED" ; public ViewUpdate ( View view , Object what ) { super ( view ) ; if ( what == null ) throw new NullPointerException ( "What must be non-null" ) ; this . what = what ; } public Object getWhat ( ) { return what ; } public View getView ( ) { return ( View ) getSource ( ) ; } public String paramString ( ) { return super . paramString ( ) + ",what=" + what ; } private Object what ; } 	0	['5', '3', '0', '6', '13', '4', '2', '4', '4', '0.833333333', '47', '0.333333333', '0', '0.666666667', '0.5', '1', '1', '7.8', '1', '0.6', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class PluginsMenu extends EnhancedMenu { public PluginsMenu ( ) { super ( "plugins" ) ; Vector pluginMenuItems = new Vector ( ) ; EditPlugin [ ] pluginArray = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < pluginArray . length ; i ++ ) { try { EditPlugin plugin = pluginArray [ i ] ; int count = pluginMenuItems . size ( ) ; plugin . createMenuItems ( null , pluginMenuItems , pluginMenuItems ) ; if ( count != pluginMenuItems . size ( ) ) { Log . log ( Log . WARNING , this , plugin . getClassName ( ) + " is using the obsolete" + " createMenuItems() API." ) ; } plugin . createMenuItems ( pluginMenuItems ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , this , "Error creating menu items" + " for plugin" ) ; Log . log ( Log . ERROR , this , t ) ; } } if ( pluginMenuItems . isEmpty ( ) ) { add ( GUIUtilities . loadMenuItem ( "no-plugins" ) ) ; return ; } MiscUtilities . quicksort ( pluginMenuItems , new MiscUtilities . MenuItemCompare ( ) ) ; JMenu menu = this ; for ( int i = 0 ; i < pluginMenuItems . size ( ) ; i ++ ) { if ( menu . getItemCount ( ) >= 20 ) { menu . addSeparator ( ) ; JMenu newMenu = new JMenu ( jEdit . getProperty ( "common.more" ) ) ; menu . add ( newMenu ) ; menu = newMenu ; } menu . add ( ( JMenuItem ) pluginMenuItems . elementAt ( i ) ) ; } } } 	0	['1', '8', '0', '9', '22', '0', '1', '9', '1', '2', '111', '0', '0', '1', '1', '0', '0', '110', '0', '0', '0']
package bsh ; class BSHUnaryExpression extends SimpleNode implements ParserConstants { public int kind ; public boolean postfix = false ; BSHUnaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode node = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( node instanceof BSHLHSPrimaryExpression ) return lhsUnaryOperation ( ( ( BSHLHSPrimaryExpression ) node ) . toLHS ( callstack , interpreter ) ) ; else return unaryOperation ( node . eval ( callstack , interpreter ) , kind ) ; } private Object lhsUnaryOperation ( LHS lhs ) throws EvalError { Interpreter . debug ( "lhsUnaryOperation" ) ; Object prevalue , postvalue ; prevalue = lhs . getValue ( ) ; postvalue = unaryOperation ( prevalue , kind ) ; Object retVal ; if ( postfix ) retVal = prevalue ; else retVal = postvalue ; lhs . assign ( postvalue ) ; return retVal ; } private Object unaryOperation ( Object op , int kind ) throws EvalError { if ( op instanceof Boolean || op instanceof Character || op instanceof Number ) return primitiveWrapperUnaryOperation ( op , kind ) ; if ( ! ( op instanceof Primitive ) ) throw new EvalError ( "Unary operation " + tokenImage [ kind ] + " inappropriate for object" , this ) ; return Primitive . unaryOperation ( ( Primitive ) op , kind ) ; } private Object primitiveWrapperUnaryOperation ( Object val , int kind ) throws EvalError { Class operandType = val . getClass ( ) ; Object operand = Primitive . promoteToInteger ( val ) ; if ( operand instanceof Boolean ) return new Boolean ( Primitive . booleanUnaryOperation ( ( Boolean ) operand , kind ) ) ; else if ( operand instanceof Integer ) { int result = Primitive . intUnaryOperation ( ( Integer ) operand , kind ) ; if ( kind == INCR || kind == DECR ) { if ( operandType == Byte . TYPE ) return new Byte ( ( byte ) result ) ; if ( operandType == Short . TYPE ) return new Short ( ( short ) result ) ; if ( operandType == Character . TYPE ) return new Character ( ( char ) result ) ; } return new Integer ( result ) ; } else if ( operand instanceof Long ) return new Long ( Primitive . longUnaryOperation ( ( Long ) operand , kind ) ) ; else if ( operand instanceof Float ) return new Float ( Primitive . floatUnaryOperation ( ( Float ) operand , kind ) ) ; else if ( operand instanceof Double ) return new Double ( Primitive . doubleUnaryOperation ( ( Double ) operand , kind ) ) ; else throw new InterpreterError ( "An error occurred.  Please call technical support." ) ; } } 	0	['5', '2', '0', '11', '33', '6', '1', '10', '1', '0.625', '204', '0', '0', '0.818181818', '0.433333333', '1', '1', '39.4', '1', '0.8', '0']
package bsh ; class BSHReturnStatement extends SimpleNode implements ParserConstants { public int kind ; BSHReturnStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object value ; if ( jjtGetNumChildren ( ) > 0 ) value = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; else value = Primitive . VOID ; return new ReturnControl ( kind , value ) ; } } 	0	['2', '2', '0', '9', '7', '1', '1', '8', '1', '1', '28', '0', '0', '0.947368421', '0.625', '1', '1', '12.5', '1', '0.5', '0']
package gnu . regexp ; final class RETokenBackRef extends REToken { private int num ; private boolean insens ; RETokenBackRef ( int subIndex , int num , boolean insens ) { super ( subIndex ) ; this . num = num ; this . insens = insens ; } boolean match ( CharIndexed input , REMatch mymatch ) { int b , e ; b = mymatch . start [ num ] ; e = mymatch . end [ num ] ; if ( ( b == - 1 ) || ( e == - 1 ) ) return false ; for ( int i = b ; i < e ; i ++ ) { if ( input . charAt ( mymatch . index + i - b ) != input . charAt ( i ) ) { return false ; } } mymatch . index += e - b ; return next ( input , mymatch ) ; } void dump ( StringBuffer os ) { os . append ( '\\' ) . append ( num ) ; } } 	0	['3', '2', '0', '4', '8', '0', '1', '3', '0', '0.5', '77', '1', '0', '0.777777778', '0.444444444', '1', '2', '24', '5', '2', '0']
package gnu . regexp ; import java . io . Serializable ; class CharIndexedCharArray implements CharIndexed , Serializable { private char [ ] s ; private int anchor ; CharIndexedCharArray ( char [ ] str , int index ) { s = str ; anchor = index ; } public char charAt ( int index ) { int pos = anchor + index ; return ( ( pos < s . length ) && ( pos >= 0 ) ) ? s [ pos ] : OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( anchor < s . length ) ; } public boolean move ( int index ) { return ( ( anchor += index ) < s . length ) ; } } 	0	['4', '1', '0', '2', '5', '0', '1', '1', '3', '0', '59', '1', '0', '0', '0.666666667', '0', '0', '13.25', '3', '1.75', '0']
package bsh ; import java . lang . reflect . InvocationTargetException ; public class TargetError extends EvalError { Throwable target ; public TargetError ( String msg , Throwable t , SimpleNode node ) { super ( msg , node ) ; target = t ; } public TargetError ( Throwable t , SimpleNode node ) { this ( "TargetError" , t , node ) ; } public TargetError ( String s , Throwable t ) { this ( s , t , null ) ; } public Throwable getTarget ( ) { if ( target instanceof InvocationTargetException ) return ( ( InvocationTargetException ) target ) . getTargetException ( ) ; else return target ; } public String toString ( ) { return super . toString ( ) + "\nTarget exception: " + printTargetError ( target ) ; } public void printStackTrace ( ) { super . printStackTrace ( ) ; System . out . println ( "--- Target Stack Trace ---" ) ; target . printStackTrace ( ) ; } public void reThrow ( String msg ) throws TargetError { throw new TargetError ( msg + ":" + getMessage ( ) , target , node ) ; } public void reThrow ( String msg , SimpleNode node ) throws TargetError { String m = ( msg == null ) ? "" : ( msg + " : " ) ; throw new TargetError ( m + getMessage ( ) , target , node ) ; } public void reThrow ( SimpleNode node ) throws TargetError { reThrow ( null , node ) ; } public String printTargetError ( Throwable t ) { String s = target . toString ( ) ; if ( Capabilities . canGenerateInterfaces ( ) ) s += "\n" + xPrintTargetError ( t ) ; return s ; } public String xPrintTargetError ( Throwable t ) { String getTarget = "import java.lang.reflect.UndeclaredThrowableException;" + "if ( target instanceof UndeclaredThrowableException )" + "	return target.getUndeclaredThrowable().toString();" + "else return \"\"" ; Interpreter i = new Interpreter ( ) ; try { i . set ( "target" , t ) ; return ( String ) i . eval ( getTarget ) ; } catch ( EvalError e ) { throw new InterpreterError ( "xprintarget: " + e . toString ( ) ) ; } } } 	0	['11', '4', '0', '18', '26', '13', '14', '5', '11', '0.1', '171', '0', '0', '0.764705882', '0.545454545', '2', '2', '14.45454545', '2', '0.9091', '0']
package gnu . regexp ; import java . io . InputStream ; import java . io . BufferedInputStream ; import java . io . IOException ; class CharIndexedInputStream implements CharIndexed { private static final int BUFFER_INCREMENT = 1024 ; private static final int UNKNOWN = Integer . MAX_VALUE ; private BufferedInputStream br ; private int index = - 1 ; private int bufsize = BUFFER_INCREMENT ; private int end = UNKNOWN ; private char cached = OUT_OF_BOUNDS ; private char [ ] lookBehind = new char [ ] { OUT_OF_BOUNDS , OUT_OF_BOUNDS } ; CharIndexedInputStream ( InputStream str , int index ) { if ( str instanceof BufferedInputStream ) br = ( BufferedInputStream ) str ; else br = new BufferedInputStream ( str , BUFFER_INCREMENT ) ; next ( ) ; if ( index > 0 ) move ( index ) ; } private boolean next ( ) { if ( end == 1 ) return false ; end -- ; try { if ( index != - 1 ) { br . reset ( ) ; } int i = br . read ( ) ; br . mark ( bufsize ) ; if ( i == - 1 ) { end = 1 ; cached = OUT_OF_BOUNDS ; return false ; } cached = ( char ) i ; index = 1 ; } catch ( IOException e ) { e . printStackTrace ( ) ; cached = OUT_OF_BOUNDS ; return false ; } return true ; } public char charAt ( int index ) { if ( index == 0 ) { return cached ; } else if ( index >= end ) { return OUT_OF_BOUNDS ; } else if ( index == - 1 ) { return lookBehind [ 0 ] ; } else if ( index == - 2 ) { return lookBehind [ 1 ] ; } else if ( index < - 2 ) { return OUT_OF_BOUNDS ; } else if ( index >= bufsize ) { try { while ( bufsize <= index ) bufsize += BUFFER_INCREMENT ; br . reset ( ) ; br . mark ( bufsize ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } else if ( this . index != index ) { try { br . reset ( ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } char ch = OUT_OF_BOUNDS ; try { int i = br . read ( ) ; this . index = index + 1 ; if ( i == - 1 ) { end = index ; return ch ; } ch = ( char ) i ; } catch ( IOException ie ) { } return ch ; } public boolean move ( int index ) { boolean retval = true ; while ( retval && ( index -- > 0 ) ) retval = next ( ) ; return retval ; } public boolean isValid ( ) { return ( cached != OUT_OF_BOUNDS ) ; } } 	0	['5', '1', '0', '3', '12', '0', '2', '1', '3', '0.53125', '251', '1', '0', '0', '0.6', '0', '0', '47.6', '10', '3.8', '0']
package bsh ; import java . lang . reflect . Array ; import java . lang . reflect . InvocationTargetException ; class BSHAllocationExpression extends SimpleNode { BSHAllocationExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode type = ( SimpleNode ) jjtGetChild ( 0 ) ; SimpleNode args = ( SimpleNode ) jjtGetChild ( 1 ) ; if ( type instanceof BSHAmbiguousName ) { BSHAmbiguousName name = ( BSHAmbiguousName ) type ; if ( args instanceof BSHArguments ) return objectAllocation ( name , ( BSHArguments ) args , callstack , interpreter ) ; else return objectArrayAllocation ( name , ( BSHArrayDimensions ) args , callstack , interpreter ) ; } else return primitiveArrayAllocation ( ( BSHPrimitiveType ) type , ( BSHArrayDimensions ) args , callstack , interpreter ) ; } private Object objectAllocation ( BSHAmbiguousName nameNode , BSHArguments argumentsNode , CallStack callstack , Interpreter interpreter ) throws EvalError { NameSpace namespace = callstack . top ( ) ; Class type = nameNode . toClass ( namespace ) ; Object [ ] args = argumentsNode . getArguments ( callstack , interpreter ) ; if ( args == null ) throw new EvalError ( "Trying to new a class...?" , this ) ; boolean hasBody = jjtGetNumChildren ( ) > 2 ; if ( hasBody ) { BSHBlock body = ( BSHBlock ) jjtGetChild ( 2 ) ; return constructWithBody ( type , args , body , callstack , interpreter ) ; } else return constructObject ( type , args ) ; } private Object constructObject ( Class type , Object [ ] args ) throws EvalError { try { return Reflect . constructObject ( type , args ) ; } catch ( ReflectError e ) { throw new EvalError ( "Constructor error: " + e . getMessage ( ) , this ) ; } catch ( InvocationTargetException e ) { Interpreter . debug ( "The constructor threw an exception:\n\t" + e . getTargetException ( ) ) ; throw new TargetError ( e . getTargetException ( ) , this ) ; } } private Object constructWithBody ( Class type , Object [ ] args , BSHBlock body , CallStack callstack , Interpreter interpreter ) throws EvalError { if ( ! type . isInterface ( ) ) throw new EvalError ( "BeanShell cannot extend class types: " + type ) ; NameSpace namespace = callstack . top ( ) ; NameSpace local = new NameSpace ( namespace , "anonymous block object" ) ; callstack . push ( local ) ; body . eval ( callstack , interpreter , true ) ; callstack . pop ( ) ; return local . getThis ( interpreter ) . getInterface ( type ) ; } private Object objectArrayAllocation ( BSHAmbiguousName nameNode , BSHArrayDimensions dimensionsNode , CallStack callstack , Interpreter interpreter ) throws EvalError { NameSpace namespace = callstack . top ( ) ; Class type = nameNode . toClass ( namespace ) ; if ( type == null ) throw new EvalError ( "Class " + nameNode . getName ( namespace ) + " not found." , this ) ; Object result = dimensionsNode . eval ( type , callstack , interpreter ) ; if ( result != Primitive . VOID ) return result ; else return arrayNewInstance ( type , dimensionsNode ) ; } private Object primitiveArrayAllocation ( BSHPrimitiveType typeNode , BSHArrayDimensions dimensionsNode , CallStack callstack , Interpreter interpreter ) throws EvalError { Class type = typeNode . getType ( ) ; Object result = dimensionsNode . eval ( type , callstack , interpreter ) ; if ( result != Primitive . VOID ) return result ; return arrayNewInstance ( type , dimensionsNode ) ; } private Object arrayNewInstance ( Class type , BSHArrayDimensions dimensionsNode ) throws EvalError { try { return Array . newInstance ( type , dimensionsNode . dimensions ) ; } catch ( NegativeArraySizeException e1 ) { throw new TargetError ( "Negative Array Size" , e1 ) ; } catch ( Exception e ) { throw new EvalError ( "Can't construct primitive array: " + e . getMessage ( ) , this ) ; } } } 	0	['8', '2', '0', '18', '37', '28', '1', '17', '1', '2', '271', '0', '0', '0.72', '0.363636364', '1', '1', '32.875', '1', '0.875', '0']
package bsh ; class BSHMethodInvocation extends SimpleNode { BSHMethodInvocation ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { NameSpace namespace = callstack . top ( ) ; Name name = ( ( BSHAmbiguousName ) jjtGetChild ( 0 ) ) . getName ( namespace ) ; Object [ ] args = ( ( BSHArguments ) jjtGetChild ( 1 ) ) . getArguments ( callstack , interpreter ) ; try { return name . invokeMethod ( interpreter , args , callstack , this ) ; } catch ( ReflectError e ) { throw new EvalError ( "Error in method invocation: " + e . getMessage ( ) , this ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { throw new TargetError ( e . getTargetException ( ) , this ) ; } catch ( EvalError ee ) { ee . reThrow ( this ) ; throw new Error ( "should be unreachable..." ) ; } } } 	0	['2', '2', '0', '12', '17', '1', '1', '11', '1', '2', '63', '0', '0', '0.947368421', '0.625', '1', '1', '30.5', '1', '0.5', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . * ; public class VFSUpdate extends EBMessage { public VFSUpdate ( String path ) { super ( null ) ; if ( path == null ) throw new NullPointerException ( "Path must be non-null" ) ; this . path = path ; } public String getPath ( ) { return path ; } public String paramString ( ) { return super . paramString ( ) + ",path=" + path ; } private String path ; } 	0	['3', '2', '0', '6', '9', '0', '4', '2', '3', '0', '34', '1', '0', '0.714285714', '0.666666667', '1', '1', '10', '1', '0.6667', '0']
package bsh ; class BSHReturnType extends SimpleNode { public boolean isVoid ; BSHReturnType ( int id ) { super ( id ) ; } public Object getReturnType ( NameSpace namespace ) throws EvalError { if ( isVoid ) return Primitive . VOID ; else return ( ( BSHType ) jjtGetChild ( 0 ) ) . getType ( namespace ) ; } } 	0	['2', '2', '0', '8', '5', '1', '2', '6', '1', '1', '19', '0', '0', '0.947368421', '0.666666667', '0', '0', '8', '1', '0.5', '0']
package bsh ; class BSHStatementExpressionList extends SimpleNode { BSHStatementExpressionList ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int n = jjtGetNumChildren ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SimpleNode node = ( ( SimpleNode ) jjtGetChild ( i ) ) ; node . eval ( callstack , interpreter ) ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '7', '6', '1', '1', '6', '1', '2', '28', '0', '0', '0.947368421', '0.625', '1', '1', '13', '1', '0.5', '0']
package bsh ; class BshMethod implements java . io . Serializable { public BSHMethodDeclaration method ; NameSpace declaringNameSpace ; private Class [ ] argTypes ; public BshMethod ( BSHMethodDeclaration method , NameSpace declaringNameSpace ) { this . method = method ; this . declaringNameSpace = declaringNameSpace ; } public Class [ ] getArgTypes ( ) { if ( argTypes == null ) argTypes = method . params . argTypes ; return argTypes ; } public Object invokeDeclaredMethod ( Object [ ] argValues , Interpreter interpreter , CallStack callstack , SimpleNode callerInfo ) throws EvalError { if ( argValues == null ) argValues = new Object [ ] { } ; if ( argValues . length != method . params . numArgs ) { try { String help = ( String ) declaringNameSpace . get ( "bsh.help." + method . name , interpreter ) ; interpreter . println ( help ) ; return Primitive . VOID ; } catch ( Exception e ) { throw new EvalError ( "Wrong number of arguments for local method: " + method . name , callerInfo ) ; } } NameSpace localNameSpace = new NameSpace ( declaringNameSpace , method . name ) ; localNameSpace . setNode ( callerInfo ) ; for ( int i = 0 ; i < method . params . numArgs ; i ++ ) { if ( method . params . argTypes [ i ] != null ) { try { argValues [ i ] = NameSpace . getAssignableForm ( argValues [ i ] , method . params . argTypes [ i ] ) ; } catch ( EvalError e ) { throw new EvalError ( "Invalid argument: " + "`" + method . params . argNames [ i ] + "'" + " for method: " + method . name + " : " + e . getMessage ( ) , callerInfo ) ; } localNameSpace . setTypedVariable ( method . params . argNames [ i ] , method . params . argTypes [ i ] , argValues [ i ] , false ) ; } else { if ( argValues [ i ] == Primitive . VOID ) throw new EvalError ( "Undefined variable or class name, parameter: " + method . params . argNames [ i ] + " to method: " + method . name , callerInfo ) ; else localNameSpace . setVariable ( method . params . argNames [ i ] , argValues [ i ] ) ; } } callstack . push ( localNameSpace ) ; Object ret = method . block . eval ( callstack , interpreter , true ) ; callstack . pop ( ) ; if ( ret instanceof ReturnControl ) { ReturnControl rs = ( ReturnControl ) ret ; if ( rs . kind == rs . RETURN ) ret = ( ( ReturnControl ) ret ) . value ; else throw new EvalError ( "continue or break in method body" , method ) ; } if ( method . returnType != null ) { if ( method . returnType == Primitive . VOID ) return method . returnType ; try { ret = NameSpace . getAssignableForm ( ret , ( Class ) method . returnType ) ; } catch ( EvalError e ) { throw new EvalError ( "Incorrect type returned from method: " + method . name + e . getMessage ( ) , method ) ; } } return ret ; } public String toString ( ) { return "Bsh Method: " + method . name ; } } 	0	['4', '1', '0', '13', '20', '0', '5', '10', '4', '0.555555556', '301', '0.333333333', '2', '0', '0.357142857', '0', '0', '73.5', '2', '1', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . EmptyBorder ; import java . awt . * ; import java . awt . event . * ; import java . io . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class LogViewer extends JPanel implements DockableWindow { public LogViewer ( ) { super ( new BorderLayout ( ) ) ; String settingsDirectory = jEdit . getSettingsDirectory ( ) ; if ( settingsDirectory != null ) { String [ ] args = { MiscUtilities . constructPath ( settingsDirectory , "activity.log" ) } ; JLabel label = new JLabel ( jEdit . getProperty ( "log-viewer.caption" , args ) ) ; add ( BorderLayout . NORTH , label ) ; } JTextArea textArea = new JTextArea ( 24 , 80 ) ; textArea . setDocument ( Log . getLogDocument ( ) ) ; add ( BorderLayout . CENTER , new JScrollPane ( textArea ) ) ; } public String getName ( ) { return "log-viewer" ; } public Component getComponent ( ) { return this ; } } 	0	['3', '5', '0', '5', '14', '3', '1', '4', '3', '2', '55', '0', '0', '0.996946565', '1', '0', '0', '17.33333333', '1', '0.6667', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class EditorStarted extends EBMessage . NonVetoable { public EditorStarted ( EBComponent source ) { super ( source ) ; } } 	0	['1', '3', '0', '3', '2', '0', '1', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package bsh ; class BSHAmbiguousName extends SimpleNode { public String text ; BSHAmbiguousName ( int id ) { super ( id ) ; } public Name getName ( NameSpace namespace ) { return namespace . getNameResolver ( text ) ; } public Object toObject ( CallStack callstack , Interpreter interpreter ) throws EvalError { return getName ( callstack . top ( ) ) . toObject ( callstack , interpreter ) ; } public Class toClass ( NameSpace namespace ) throws EvalError { return getName ( namespace ) . toClass ( ) ; } public LHS toLHS ( CallStack callstack , Interpreter interpreter ) throws EvalError { return getName ( callstack . top ( ) ) . toLHS ( callstack , interpreter ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { throw new InterpreterError ( "Don't know how to eval an ambiguous name!" + "  Use toObject() if you want an object." ) ; } public String toString ( ) { return "AmbigousName: " + text ; } } 	0	['7', '2', '0', '16', '17', '19', '8', '8', '6', '0.333333333', '53', '0', '0', '0.75', '0.457142857', '1', '1', '6.428571429', '1', '0.8571', '0']
package org . gjt . sp . jedit . io ; import javax . swing . filechooser . FileSystemView ; import java . awt . Component ; import java . lang . reflect . * ; import java . io . File ; import org . gjt . sp . util . Log ; public class FileRootsVFS extends VFS { public static final String PROTOCOL = "roots" ; public FileRootsVFS ( ) { super ( "roots" ) ; try { method = File . class . getMethod ( "listRoots" , new Class [ 0 ] ) ; Log . log ( Log . DEBUG , this , "File.listRoots() detected" ) ; } catch ( Exception e ) { fsView = FileSystemView . getFileSystemView ( ) ; Log . log ( Log . DEBUG , this , "File.listRoots() not detected" ) ; } } public int getCapabilities ( ) { return 0 ; } public String getParentOfPath ( String path ) { return PROTOCOL + ":" ; } public VFS . DirectoryEntry [ ] _listDirectory ( Object session , String url , Component comp ) { File [ ] roots ; if ( method == null ) roots = fsView . getRoots ( ) ; else { try { roots = ( File [ ] ) method . invoke ( null , new Object [ 0 ] ) ; } catch ( Exception e ) { roots = null ; Log . log ( Log . ERROR , this , e ) ; } } if ( roots == null ) return null ; VFS . DirectoryEntry [ ] rootDE = new VFS . DirectoryEntry [ roots . length ] ; for ( int i = 0 ; i < roots . length ; i ++ ) { String name = roots [ i ] . getPath ( ) ; rootDE [ i ] = _getDirectoryEntry ( session , name , comp ) ; } return rootDE ; } public DirectoryEntry _getDirectoryEntry ( Object session , String path , Component comp ) { return new VFS . DirectoryEntry ( path , path , path , VFS . DirectoryEntry . FILESYSTEM , 0L , false ) ; } private FileSystemView fsView ; private Method method ; } 	0	['6', '2', '0', '4', '20', '13', '1', '3', '5', '0.95', '126', '0.75', '0', '0.807692308', '0.541666667', '1', '3', '19.33333333', '4', '1.3333', '0']
package bsh ; class BlockNameSpace extends NameSpace { public BlockNameSpace ( NameSpace parent ) throws EvalError { super ( parent , parent . name + "/BlockNameSpace" ) ; } public void setVariable ( String name , Object o ) throws EvalError { if ( weHaveVar ( name ) ) super . setVariable ( name , o ) ; else getParent ( ) . setVariable ( name , o ) ; } boolean weHaveVar ( String name ) { return super . getVariableImpl ( name , false ) != null ; } } 	0	['3', '2', '0', '4', '10', '3', '2', '2', '2', '2', '40', '0', '0', '0.96', '0.583333333', '0', '0', '12.33333333', '2', '1', '0']
package bsh ; import java . util . * ; public interface NameSource { public String [ ] getAllNames ( ) ; public void addNameSourceListener ( NameSource . Listener listener ) ; public static interface Listener { public void nameSourceChanged ( NameSource src ) ; } } 	0	['2', '1', '0', '2', '2', '1', '2', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . JOptionPane ; import java . awt . Component ; import java . io . * ; import java . net . * ; import java . util . zip . * ; import java . util . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; class Roster { Roster ( ) { operations = new Vector ( ) ; } void addOperation ( Operation op ) { for ( int i = 0 ; i < operations . size ( ) ; i ++ ) { if ( operations . elementAt ( i ) . equals ( op ) ) return ; } operations . addElement ( op ) ; } int getOperationCount ( ) { return operations . size ( ) ; } boolean isEmpty ( ) { return operations . size ( ) == 0 ; } boolean performOperations ( PluginManagerProgress progress ) { for ( int i = 0 ; i < operations . size ( ) ; i ++ ) { Operation op = ( Operation ) operations . elementAt ( i ) ; if ( op . perform ( progress ) ) progress . done ( true ) ; else { progress . done ( false ) ; return false ; } if ( Thread . interrupted ( ) ) return false ; } return true ; } private Vector operations ; static interface Operation { boolean perform ( PluginManagerProgress progress ) ; boolean equals ( Object o ) ; } static class Remove implements Operation { Remove ( String plugin ) { this . plugin = plugin ; } public boolean perform ( PluginManagerProgress progress ) { progress . removing ( MiscUtilities . getFileName ( plugin ) ) ; EditPlugin . JAR jar = jEdit . getPluginJAR ( plugin ) ; if ( jar != null ) jar . getClassLoader ( ) . closeZipFile ( ) ; File jarFile = new File ( plugin ) ; File srcFile = new File ( plugin . substring ( 0 , plugin . length ( ) - 4 ) ) ; boolean ok = true ; ok &= deleteRecursively ( jarFile ) ; if ( srcFile . exists ( ) ) ok &= deleteRecursively ( srcFile ) ; String [ ] args = { plugin } ; if ( ! ok ) GUIUtilities . error ( progress , "plugin-manager.remove-failed" , args ) ; return ok ; } public boolean equals ( Object o ) { if ( o instanceof Remove && ( ( Remove ) o ) . plugin . equals ( plugin ) ) return true ; else return false ; } private String plugin ; private boolean deleteRecursively ( File file ) { Log . log ( Log . NOTICE , this , "Deleting " + file + " recursively" ) ; boolean ok = true ; if ( file . isDirectory ( ) ) { String path = file . getPath ( ) ; String [ ] children = file . list ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { ok &= deleteRecursively ( new File ( path , children [ i ] ) ) ; } } ok &= file . delete ( ) ; return ok ; } } static class Install implements Operation { Install ( String url , String installDirectory ) { if ( url == null ) throw new NullPointerException ( ) ; this . url = url ; this . installDirectory = installDirectory ; } public boolean perform ( PluginManagerProgress progress ) { try { String fileName = MiscUtilities . getFileName ( url ) ; progress . downloading ( fileName ) ; String path = download ( progress , fileName , url ) ; if ( path == null ) { return false ; } progress . installing ( fileName ) ; install ( progress , path , installDirectory ) ; return true ; } catch ( InterruptedIOException iio ) { return false ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] args = { io . getMessage ( ) } ; VFSManager . error ( progress , "ioerror" , args ) ; return false ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; return false ; } } public boolean equals ( Object o ) { if ( o instanceof Install && ( ( Install ) o ) . url . equals ( url ) ) { return true ; } else return false ; } private String url ; private String installDirectory ; private String download ( PluginManagerProgress progress , String fileName , String url ) throws Exception { URLConnection conn = new URL ( url ) . openConnection ( ) ; progress . setMaximum ( Math . max ( 0 , conn . getContentLength ( ) ) ) ; String path = MiscUtilities . constructPath ( getDownloadDir ( ) , fileName ) ; if ( ! copy ( progress , conn . getInputStream ( ) , new FileOutputStream ( path ) , true , true ) ) return null ; return path ; } private boolean install ( PluginManagerProgress progress , String path , String dir ) throws Exception { progress . setMaximum ( 1 ) ; ZipFile zipFile = new ZipFile ( path ) ; Enumeration enum = zipFile . entries ( ) ; while ( enum . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) enum . nextElement ( ) ; String name = entry . getName ( ) . replace ( '/' , File . separatorChar ) ; File file = new File ( dir , name ) ; if ( entry . isDirectory ( ) ) file . mkdirs ( ) ; else { new File ( file . getParent ( ) ) . mkdirs ( ) ; copy ( progress , zipFile . getInputStream ( entry ) , new FileOutputStream ( file ) , false , false ) ; } } new File ( path ) . delete ( ) ; progress . setValue ( 1 ) ; return true ; } private boolean copy ( PluginManagerProgress progress , InputStream in , OutputStream out , boolean canStop , boolean doProgress ) throws Exception { in = new BufferedInputStream ( in ) ; out = new BufferedOutputStream ( out ) ; byte [ ] buf = new byte [ 4096 ] ; int copied = 0 ; loop : for ( ; ; ) { int count = in . read ( buf , 0 , buf . length ) ; if ( count == - 1 ) break loop ; if ( doProgress ) { copied += count ; progress . setValue ( copied ) ; } out . write ( buf , 0 , count ) ; if ( canStop && Thread . interrupted ( ) ) { in . close ( ) ; out . close ( ) ; return false ; } } in . close ( ) ; out . close ( ) ; return true ; } static File downloadDir ; static String getDownloadDir ( ) { if ( downloadDir == null ) { String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) settings = System . getProperty ( "user.home" ) ; downloadDir = new File ( MiscUtilities . constructPath ( settings , "PluginManager.download" ) ) ; downloadDir . mkdirs ( ) ; } return downloadDir . getPath ( ) ; } } } 	0	['5', '1', '0', '9', '14', '0', '8', '2', '0', '0', '82', '1', '0', '0', '0.466666667', '0', '0', '15.2', '4', '2', '0']
package bsh ; import java . io . * ; class CommandLineReader extends FilterReader { public CommandLineReader ( Reader in ) { super ( in ) ; } static final int normal = 0 , lastCharNL = 1 , sentSemi = 2 ; int state = lastCharNL ; public int read ( ) throws IOException { int b ; if ( state == sentSemi ) { state = lastCharNL ; return '\n' ; } while ( ( b = in . read ( ) ) == '\r' ) ; if ( b == '\n' ) if ( state == lastCharNL ) { b = ';' ; state = sentSemi ; } else state = lastCharNL ; else state = normal ; return b ; } public int read ( char buff [ ] , int off , int len ) throws IOException { int b = read ( ) ; if ( b == - 1 ) return - 1 ; else { buff [ off ] = ( char ) b ; return 1 ; } } public static void main ( String [ ] args ) throws Exception { Reader in = new CommandLineReader ( new InputStreamReader ( System . in ) ) ; while ( true ) System . out . println ( in . read ( ) ) ; } } 	0	['4', '3', '0', '1', '8', '4', '1', '0', '4', '1', '82', '0', '0', '0.857142857', '0.35', '2', '2', '18.5', '1', '0.75', '0']
package bsh ; import java . util . Vector ; public class CallStack { private Vector stack = new Vector ( 2 ) ; public void clear ( ) { stack . removeAllElements ( ) ; } public void push ( NameSpace ns ) { stack . insertElementAt ( ns , 0 ) ; } public NameSpace top ( ) { return get ( 0 ) ; } public NameSpace get ( int depth ) { if ( depth >= depth ( ) ) return NameSpace . JAVACODE ; else return ( NameSpace ) ( stack . elementAt ( depth ) ) ; } public void set ( int depth , NameSpace ns ) { stack . setElementAt ( ns , depth ) ; } public NameSpace pop ( ) { if ( depth ( ) < 1 ) throw new InterpreterError ( "pop on empty CallStack" ) ; NameSpace top = top ( ) ; stack . removeElementAt ( 0 ) ; return top ; } public NameSpace swap ( NameSpace newTop ) { NameSpace oldTop = ( NameSpace ) ( stack . elementAt ( 0 ) ) ; stack . setElementAt ( newTop , 0 ) ; return oldTop ; } public int depth ( ) { return stack . size ( ) ; } public NameSpace [ ] toArray ( ) { NameSpace [ ] nsa = new NameSpace [ depth ( ) ] ; stack . copyInto ( nsa ) ; return nsa ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "CallStack:\n" ) ; NameSpace [ ] nsa = toArray ( ) ; for ( int i = 0 ; i < nsa . length ; i ++ ) sb . append ( "\t" + nsa [ i ] + "\n" ) ; return sb . toString ( ) ; } } 	0	['11', '1', '0', '39', '25', '0', '38', '2', '11', '0', '135', '1', '0', '0', '0.484848485', '0', '0', '11.18181818', '2', '1.1818', '0']
