package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; public class ValueReferencePtg extends Ptg { private final static int SIZE = 5 ; public final static byte sid = 0x44 ; private short field_1_row ; private short field_2_col ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public ValueReferencePtg ( ) { } public ValueReferencePtg ( byte [ ] data , int offset ) { offset ++ ; field_1_row = LittleEndian . getShort ( data , offset + 0 ) ; field_2_col = LittleEndian . getShort ( data , offset + 2 ) ; System . out . println ( toString ( ) ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( "[ValueReferencePtg]\n" ) ; buffer . append ( "row = " ) . append ( getRow ( ) ) . append ( "\n" ) ; buffer . append ( "col = " ) . append ( getColumnRaw ( ) ) . append ( "\n" ) ; buffer . append ( "rowrelative = " ) . append ( isRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "colrelative = " ) . append ( isColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { } public void setRow ( short row ) { field_1_row = row ; } public short getRow ( ) { return field_1_row ; } public boolean isRowRelative ( ) { return rowRelative . isSet ( field_2_col ) ; } public boolean isColRelative ( ) { return rowRelative . isSet ( field_2_col ) ; } public void setColumnRaw ( short col ) { field_2_col = col ; } public short getColumnRaw ( ) { return field_2_col ; } public void setColumn ( short col ) { field_2_col = col ; } public short getColumn ( ) { return field_2_col ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( ) { return "NO IDEA YET VALUE REF" ; } } 	0	['14', '2', '0', '4', '24', '37', '2', '3', '14', '0.833333333', '151', '0.833333333', '2', '0.368421053', '0.375', '1', '2', '9.357142857', '1', '0.8571', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class InterfaceHdrRecord extends Record { public final static short sid = 0xe1 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public InterfaceHdrRecord ( ) { } public InterfaceHdrRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public InterfaceHdrRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A INTERFACEHDR RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[INTERFACEHDR]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/INTERFACEHDR]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '49', '2', '3', '9', '0.933333333', '107', '0.333333333', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class WindowProtectRecord extends Record { public final static short sid = 0x19 ; private short field_1_protect ; public WindowProtectRecord ( ) { } public WindowProtectRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WindowProtectRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A WINDOWPROTECT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_protect = LittleEndian . getShort ( data , 0 + offset ) ; } public void setProtect ( boolean protect ) { if ( protect == true ) { field_1_protect = 1 ; } else { field_1_protect = 0 ; } } public boolean getProtect ( ) { return ( field_1_protect == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WINDOWPROTECT]\n" ) ; buffer . append ( "    .protect         = " ) . append ( getProtect ( ) ) . append ( "\n" ) ; buffer . append ( "[/WINDOWPROTECT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_protect ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '43', '2', '3', '9', '0.85', '117', '0.5', '0', '0.578947368', '0.418181818', '1', '6', '9.454545455', '2', '1', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class FnGroupCountRecord extends Record { public final static short sid = 0x9c ; public final static short COUNT = 14 ; private short field_1_count ; public FnGroupCountRecord ( ) { } public FnGroupCountRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public FnGroupCountRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A FNGROUPCOUNT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_count = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCount ( short count ) { field_1_count = count ; } public short getCount ( ) { return field_1_count ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[FNGROUPCOUNT]\n" ) ; buffer . append ( "    .count            = " ) . append ( getCount ( ) ) . append ( "\n" ) ; buffer . append ( "[/FNGROUPCOUNT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCount ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '49', '2', '3', '9', '0.933333333', '106', '0.333333333', '0', '0.578947368', '0.522727273', '1', '6', '8.363636364', '2', '0.8182', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; public class SmallDocumentBlock implements BlockWritable , ListManagedBlock { private byte [ ] _data ; private static final byte _default_fill = ( byte ) 0xff ; private static final int _block_size = 64 ; private static final int _blocks_per_big_block = POIFSConstants . BIG_BLOCK_SIZE / _block_size ; private SmallDocumentBlock ( final byte [ ] data , final int index ) { this ( ) ; System . arraycopy ( data , index * _block_size , _data , 0 , _block_size ) ; } private SmallDocumentBlock ( ) { _data = new byte [ _block_size ] ; } public static SmallDocumentBlock [ ] convert ( final byte [ ] array , final int size ) { SmallDocumentBlock [ ] rval = new SmallDocumentBlock [ ( size + _block_size - 1 ) / _block_size ] ; int offset = 0 ; for ( int k = 0 ; k < rval . length ; k ++ ) { rval [ k ] = new SmallDocumentBlock ( ) ; if ( offset < array . length ) { int length = Math . min ( _block_size , array . length - offset ) ; System . arraycopy ( array , offset , rval [ k ] . _data , 0 , length ) ; if ( length != _block_size ) { Arrays . fill ( rval [ k ] . _data , length , _block_size , _default_fill ) ; } } else { Arrays . fill ( rval [ k ] . _data , _default_fill ) ; } offset += _block_size ; } return rval ; } public static int fill ( final List blocks ) { int count = blocks . size ( ) ; int big_block_count = ( count + _blocks_per_big_block - 1 ) / _blocks_per_big_block ; int full_count = big_block_count * _blocks_per_big_block ; for ( ; count < full_count ; count ++ ) { blocks . add ( makeEmptySmallDocumentBlock ( ) ) ; } return big_block_count ; } public static SmallDocumentBlock [ ] convert ( final BlockWritable [ ] store , final int size ) throws IOException , ArrayIndexOutOfBoundsException { ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; for ( int j = 0 ; j < store . length ; j ++ ) { store [ j ] . writeBlocks ( stream ) ; } byte [ ] data = stream . toByteArray ( ) ; SmallDocumentBlock [ ] rval = new SmallDocumentBlock [ convertToBlockCount ( size ) ] ; for ( int index = 0 ; index < rval . length ; index ++ ) { rval [ index ] = new SmallDocumentBlock ( data , index ) ; } return rval ; } public static List extract ( ListManagedBlock [ ] blocks ) throws IOException { List sdbs = new ArrayList ( ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { byte [ ] data = blocks [ j ] . getData ( ) ; for ( int k = 0 ; k < _blocks_per_big_block ; k ++ ) { sdbs . add ( new SmallDocumentBlock ( data , k ) ) ; } } return sdbs ; } public static void read ( final BlockWritable [ ] blocks , final byte [ ] buffer , final int offset ) { int firstBlockIndex = offset / _block_size ; int firstBlockOffset = offset % _block_size ; int lastBlockIndex = ( offset + buffer . length - 1 ) / _block_size ; if ( firstBlockIndex == lastBlockIndex ) { System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ firstBlockIndex ] ) . _data , firstBlockOffset , buffer , 0 , buffer . length ) ; } else { int buffer_offset = 0 ; System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ firstBlockIndex ] ) . _data , firstBlockOffset , buffer , buffer_offset , _block_size - firstBlockOffset ) ; buffer_offset += _block_size - firstBlockOffset ; for ( int j = firstBlockIndex + 1 ; j < lastBlockIndex ; j ++ ) { System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ j ] ) . _data , 0 , buffer , buffer_offset , _block_size ) ; buffer_offset += _block_size ; } System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ lastBlockIndex ] ) . _data , 0 , buffer , buffer_offset , buffer . length - buffer_offset ) ; } } public static int calcSize ( int size ) { return size * _block_size ; } private static SmallDocumentBlock makeEmptySmallDocumentBlock ( ) { SmallDocumentBlock block = new SmallDocumentBlock ( ) ; Arrays . fill ( block . _data , _default_fill ) ; return block ; } private static int convertToBlockCount ( final int size ) { return ( size + _block_size - 1 ) / _block_size ; } public void writeBlocks ( final OutputStream stream ) throws IOException { stream . write ( _data ) ; } public byte [ ] getData ( ) throws IOException { return _data ; } } 	0	['12', '1', '0', '8', '25', '24', '6', '2', '8', '0.863636364', '319', '1', '0', '0', '0.214285714', '0', '0', '25.25', '3', '1.25', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; public class RawDataBlockList extends BlockListImpl { public RawDataBlockList ( final InputStream stream ) throws IOException { List blocks = new ArrayList ( ) ; while ( true ) { RawDataBlock block = new RawDataBlock ( stream ) ; if ( block . eof ( ) ) { break ; } blocks . add ( block ) ; } setBlocks ( ( RawDataBlock [ ] ) blocks . toArray ( new RawDataBlock [ 0 ] ) ) ; } } 	0	['5', '2', '0', '8', '16', '10', '4', '4', '5', '2', '50', '0', '0', '0.555555556', '0.5', '0', '0', '9', '1', '0.8', '0']
package org . apache . poi . hssf . eventmodel ; import org . apache . poi . hssf . record . Record ; public interface HSSFListener { public void processRecord ( Record record ) ; } 	0	['1', '1', '0', '6', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	0	['8', '1', '0', '7', '17', '0', '2', '5', '7', '0.571428571', '134', '1', '2', '0', '0.458333333', '0', '0', '15.375', '3', '1.375', '0']
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; public class POIFSViewer { public static void main ( final String args [ ] ) { if ( args . length < 0 ) { System . err . println ( "Must specify at least one file to view" ) ; System . exit ( 1 ) ; } boolean printNames = ( args . length > 1 ) ; for ( int j = 0 ; j < args . length ; j ++ ) { viewFile ( args [ j ] , printNames ) ; } } private static void viewFile ( final String filename , final boolean printName ) { if ( printName ) { StringBuffer flowerbox = new StringBuffer ( ) ; flowerbox . append ( "." ) ; for ( int j = 0 ; j < filename . length ( ) ; j ++ ) { flowerbox . append ( "-" ) ; } flowerbox . append ( "." ) ; System . out . println ( flowerbox ) ; System . out . println ( "|" + filename + "|" ) ; System . out . println ( flowerbox ) ; } try { POIFSViewable fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; List strings = POIFSViewEngine . inspectViewable ( fs , true , 0 , "  " ) ; Iterator iter = strings . iterator ( ) ; while ( iter . hasNext ( ) ) { System . out . print ( iter . next ( ) ) ; } } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } } } 	0	['3', '1', '0', '2', '21', '3', '0', '2', '2', '2', '112', '0', '0', '0', '0.333333333', '0', '0', '36.33333333', '4', '2.3333', '0']
package org . apache . poi . poifs . dev ; import java . util . Iterator ; public interface POIFSViewable { public Object [ ] getViewableArray ( ) ; public Iterator getViewableIterator ( ) ; public boolean preferArray ( ) ; public String getShortDescription ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '6', '0', '4', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . filesystem ; public interface POIFSWriterListener { public void processPOIFSWriterEvent ( POIFSWriterEvent event ) ; } 	0	['1', '1', '0', '7', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . filesystem ; public class DocumentDescriptor { private POIFSDocumentPath path ; private String name ; private int hashcode = 0 ; public DocumentDescriptor ( final POIFSDocumentPath path , final String name ) { if ( path == null ) { throw new NullPointerException ( "path must not be null" ) ; } if ( name == null ) { throw new NullPointerException ( "name must not be null" ) ; } if ( name . length ( ) == 0 ) { throw new IllegalArgumentException ( "name cannot be empty" ) ; } this . path = path ; this . name = name ; } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { DocumentDescriptor descriptor = ( DocumentDescriptor ) o ; rval = this . path . equals ( descriptor . path ) && this . name . equals ( descriptor . name ) ; } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { hashcode = path . hashCode ( ) ^ name . hashCode ( ) ; } return hashcode ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( 40 * ( path . length ( ) + 1 ) ) ; for ( int j = 0 ; j < path . length ( ) ; j ++ ) { buffer . append ( path . getComponent ( j ) ) . append ( "/" ) ; } buffer . append ( name ) ; return buffer . toString ( ) ; } } 	0	['4', '1', '0', '2', '18', '0', '1', '1', '4', '0.222222222', '129', '1', '1', '0', '0.4375', '1', '1', '30.5', '6', '2.5', '0']
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	0	['4', '1', '0', '6', '16', '4', '1', '6', '4', '0.333333333', '82', '0', '0', '0', '0.416666667', '0', '0', '19.25', '3', '1.25', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PrecisionRecord extends Record { public final static short sid = 0xE ; public short field_1_precision ; public PrecisionRecord ( ) { } public PrecisionRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PrecisionRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PRECISION RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_precision = LittleEndian . getShort ( data , 0 + offset ) ; } public void setFullPrecision ( boolean fullprecision ) { if ( fullprecision == true ) { field_1_precision = 1 ; } else { field_1_precision = 0 ; } } public boolean getFullPrecision ( ) { return ( field_1_precision == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PRECISION]\n" ) ; buffer . append ( "    .precision       = " ) . append ( getFullPrecision ( ) ) . append ( "\n" ) ; buffer . append ( "[/PRECISION]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_precision ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '43', '2', '3', '9', '0.85', '117', '0', '0', '0.578947368', '0.418181818', '1', '6', '9.454545455', '2', '1', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '49', '2', '3', '9', '0.933333333', '107', '0.333333333', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '0']
package org . apache . poi . hssf . usermodel ; public interface HSSFErrorConstants { public static final byte ERROR_NULL = 0x00 ; public static final byte ERROR_DIV_0 = 0x07 ; public static final byte ERROR_VALUE = 0x0f ; public static final byte ERROR_REF = 0x17 ; public static final byte ERROR_NAME = 0x1d ; public static final byte ERROR_NUM = 0x24 ; public static final byte ERROR_NA = 0x2a ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . StringUtil ; import org . apache . poi . util . HexDump ; public class ValueRangeRecord extends Record { public final static short sid = 0x101f ; private double field_1_minimumAxisValue ; private double field_2_maximumAxisValue ; private double field_3_majorIncrement ; private double field_4_minorIncrement ; private double field_5_categoryAxisCross ; private short field_6_options ; private BitField automaticMinimum = new BitField ( 0x1 ) ; private BitField automaticMaximum = new BitField ( 0x2 ) ; private BitField automaticMajor = new BitField ( 0x4 ) ; private BitField automaticMinor = new BitField ( 0x8 ) ; private BitField automaticCategoryCrossing = new BitField ( 0x10 ) ; private BitField logarithmicScale = new BitField ( 0x20 ) ; private BitField valuesInReverse = new BitField ( 0x40 ) ; private BitField crossCategoryAxisAtMaximum = new BitField ( 0x80 ) ; private BitField reserved = new BitField ( 0x100 ) ; public ValueRangeRecord ( ) { } public ValueRangeRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ValueRangeRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a ValueRange record" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_minimumAxisValue = LittleEndian . getDouble ( data , 0x0 + offset ) ; field_2_maximumAxisValue = LittleEndian . getDouble ( data , 0x8 + offset ) ; field_3_majorIncrement = LittleEndian . getDouble ( data , 0x10 + offset ) ; field_4_minorIncrement = LittleEndian . getDouble ( data , 0x18 + offset ) ; field_5_categoryAxisCross = LittleEndian . getDouble ( data , 0x20 + offset ) ; field_6_options = LittleEndian . getShort ( data , 0x28 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[ValueRange]\n" ) ; buffer . append ( "    .minimumAxisValue     = " ) . append ( " (" ) . append ( getMinimumAxisValue ( ) ) . append ( " )\n" ) ; buffer . append ( "    .maximumAxisValue     = " ) . append ( " (" ) . append ( getMaximumAxisValue ( ) ) . append ( " )\n" ) ; buffer . append ( "    .majorIncrement       = " ) . append ( " (" ) . append ( getMajorIncrement ( ) ) . append ( " )\n" ) ; buffer . append ( "    .minorIncrement       = " ) . append ( " (" ) . append ( getMinorIncrement ( ) ) . append ( " )\n" ) ; buffer . append ( "    .categoryAxisCross    = " ) . append ( " (" ) . append ( getCategoryAxisCross ( ) ) . append ( " )\n" ) ; buffer . append ( "    .options              = " ) . append ( "0x" ) . append ( HexDump . toHex ( ( short ) getOptions ( ) ) ) . append ( " (" ) . append ( getOptions ( ) ) . append ( " )\n" ) ; buffer . append ( "         .automaticMinimum         = " ) . append ( isAutomaticMinimum ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticMaximum         = " ) . append ( isAutomaticMaximum ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticMajor           = " ) . append ( isAutomaticMajor ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticMinor           = " ) . append ( isAutomaticMinor ( ) ) . append ( '\n' ) ; buffer . append ( "         .automaticCategoryCrossing     = " ) . append ( isAutomaticCategoryCrossing ( ) ) . append ( '\n' ) ; buffer . append ( "         .logarithmicScale         = " ) . append ( isLogarithmicScale ( ) ) . append ( '\n' ) ; buffer . append ( "         .valuesInReverse          = " ) . append ( isValuesInReverse ( ) ) . append ( '\n' ) ; buffer . append ( "         .crossCategoryAxisAtMaximum     = " ) . append ( isCrossCategoryAxisAtMaximum ( ) ) . append ( '\n' ) ; buffer . append ( "         .reserved                 = " ) . append ( isReserved ( ) ) . append ( '\n' ) ; buffer . append ( "[/ValueRange]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putDouble ( data , 4 + offset , field_1_minimumAxisValue ) ; LittleEndian . putDouble ( data , 12 + offset , field_2_maximumAxisValue ) ; LittleEndian . putDouble ( data , 20 + offset , field_3_majorIncrement ) ; LittleEndian . putDouble ( data , 28 + offset , field_4_minorIncrement ) ; LittleEndian . putDouble ( data , 36 + offset , field_5_categoryAxisCross ) ; LittleEndian . putShort ( data , 44 + offset , field_6_options ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 8 + 8 + 8 + 8 + 8 + 2 ; } public short getSid ( ) { return this . sid ; } public double getMinimumAxisValue ( ) { return field_1_minimumAxisValue ; } public void setMinimumAxisValue ( double field_1_minimumAxisValue ) { this . field_1_minimumAxisValue = field_1_minimumAxisValue ; } public double getMaximumAxisValue ( ) { return field_2_maximumAxisValue ; } public void setMaximumAxisValue ( double field_2_maximumAxisValue ) { this . field_2_maximumAxisValue = field_2_maximumAxisValue ; } public double getMajorIncrement ( ) { return field_3_majorIncrement ; } public void setMajorIncrement ( double field_3_majorIncrement ) { this . field_3_majorIncrement = field_3_majorIncrement ; } public double getMinorIncrement ( ) { return field_4_minorIncrement ; } public void setMinorIncrement ( double field_4_minorIncrement ) { this . field_4_minorIncrement = field_4_minorIncrement ; } public double getCategoryAxisCross ( ) { return field_5_categoryAxisCross ; } public void setCategoryAxisCross ( double field_5_categoryAxisCross ) { this . field_5_categoryAxisCross = field_5_categoryAxisCross ; } public short getOptions ( ) { return field_6_options ; } public void setOptions ( short field_6_options ) { this . field_6_options = field_6_options ; } public void setAutomaticMinimum ( boolean value ) { field_6_options = automaticMinimum . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMinimum ( ) { return automaticMinimum . isSet ( field_6_options ) ; } public void setAutomaticMaximum ( boolean value ) { field_6_options = automaticMaximum . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMaximum ( ) { return automaticMaximum . isSet ( field_6_options ) ; } public void setAutomaticMajor ( boolean value ) { field_6_options = automaticMajor . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMajor ( ) { return automaticMajor . isSet ( field_6_options ) ; } public void setAutomaticMinor ( boolean value ) { field_6_options = automaticMinor . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticMinor ( ) { return automaticMinor . isSet ( field_6_options ) ; } public void setAutomaticCategoryCrossing ( boolean value ) { field_6_options = automaticCategoryCrossing . setShortBoolean ( field_6_options , value ) ; } public boolean isAutomaticCategoryCrossing ( ) { return automaticCategoryCrossing . isSet ( field_6_options ) ; } public void setLogarithmicScale ( boolean value ) { field_6_options = logarithmicScale . setShortBoolean ( field_6_options , value ) ; } public boolean isLogarithmicScale ( ) { return logarithmicScale . isSet ( field_6_options ) ; } public void setValuesInReverse ( boolean value ) { field_6_options = valuesInReverse . setShortBoolean ( field_6_options , value ) ; } public boolean isValuesInReverse ( ) { return valuesInReverse . isSet ( field_6_options ) ; } public void setCrossCategoryAxisAtMaximum ( boolean value ) { field_6_options = crossCategoryAxisAtMaximum . setShortBoolean ( field_6_options , value ) ; } public boolean isCrossCategoryAxisAtMaximum ( ) { return crossCategoryAxisAtMaximum . isSet ( field_6_options ) ; } public void setReserved ( boolean value ) { field_6_options = reserved . setShortBoolean ( field_6_options , value ) ; } public boolean isReserved ( ) { return reserved . isSet ( field_6_options ) ; } } 	0	['39', '2', '0', '6', '58', '115', '1', '5', '37', '0.858552632', '697', '0.9375', '9', '0.234042553', '0.277777778', '1', '6', '16.46153846', '2', '0.9487', '0']
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	0	['9', '1', '0', '10', '20', '0', '10', '0', '9', '0.25', '294', '1', '0', '0', '0.311111111', '1', '1', '31.44444444', '7', '1.8889', '0']
package org . apache . poi . poifs . filesystem ; public class POIFSWriterEvent { private DocumentOutputStream stream ; private POIFSDocumentPath path ; private String documentName ; private int limit ; POIFSWriterEvent ( final DocumentOutputStream stream , final POIFSDocumentPath path , final String documentName , final int limit ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; this . limit = limit ; } public DocumentOutputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } public int getLimit ( ) { return limit ; } } 	0	['5', '1', '0', '5', '6', '2', '3', '2', '4', '0.75', '36', '1', '2', '0', '0.36', '0', '0', '5.4', '1', '0.8', '0']
package org . apache . poi . util ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . * ; import org . apache . commons . logging . * ; public class POILogFactory { private static LogFactory _creator = LogFactory . getFactory ( ) ; private static Map _loggers = new HashMap ( ) ; ; private POILogFactory ( ) { } public static POILogger getLogger ( final Class theclass ) { return getLogger ( theclass . getName ( ) ) ; } public static POILogger getLogger ( final String cat ) { POILogger logger = null ; if ( _loggers . containsKey ( cat ) ) { logger = ( POILogger ) _loggers . get ( cat ) ; } else { logger = new POILogger ( _creator . getInstance ( cat ) ) ; _loggers . put ( cat , logger ) ; } return logger ; } } 	0	['4', '1', '0', '7', '13', '4', '4', '3', '2', '0.333333333', '46', '1', '0', '0', '0.333333333', '0', '0', '10', '2', '0.75', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class PropertyBlock extends BigBlock { private static final int _properties_per_block = POIFSConstants . BIG_BLOCK_SIZE / POIFSConstants . PROPERTY_SIZE ; private Property [ ] _properties ; private PropertyBlock ( final Property [ ] properties , final int offset ) { _properties = new Property [ _properties_per_block ] ; for ( int j = 0 ; j < _properties_per_block ; j ++ ) { _properties [ j ] = properties [ j + offset ] ; } } public static BlockWritable [ ] createPropertyBlockArray ( final List properties ) { int block_count = ( properties . size ( ) + _properties_per_block - 1 ) / _properties_per_block ; Property [ ] to_be_written = new Property [ block_count * _properties_per_block ] ; System . arraycopy ( properties . toArray ( new Property [ 0 ] ) , 0 , to_be_written , 0 , properties . size ( ) ) ; for ( int j = properties . size ( ) ; j < to_be_written . length ; j ++ ) { to_be_written [ j ] = new Property ( ) { protected void preWrite ( ) { } public boolean isDirectory ( ) { return false ; } } ; } BlockWritable [ ] rvalue = new BlockWritable [ block_count ] ; for ( int j = 0 ; j < block_count ; j ++ ) { rvalue [ j ] = new PropertyBlock ( to_be_written , j * _properties_per_block ) ; } return rvalue ; } void writeData ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _properties_per_block ; j ++ ) { _properties [ j ] . writeData ( stream ) ; } } } 	0	['4', '2', '0', '5', '11', '4', '1', '4', '2', '0.833333333', '108', '1', '1', '0.5', '0.4', '1', '1', '25.5', '3', '1.25', '0']
package org . apache . poi . poifs . filesystem ; public interface DocumentEntry extends Entry { public int getSize ( ) ; } 	0	['1', '1', '0', '7', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hpsf . littleendian ; public class Byte extends LittleEndian { public Byte ( final byte [ ] src , final int offset ) { super ( src , offset ) ; } public final static int LENGTH = 1 ; public int length ( ) { return LENGTH ; } } 	0	['2', '2', '0', '2', '3', '1', '1', '1', '2', '2', '10', '0', '0', '0.75', '0.666666667', '1', '1', '3.5', '1', '0.5', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class WindowOneRecord extends Record { public final static short sid = 0x3d ; private short field_1_h_hold ; private short field_2_v_hold ; private short field_3_width ; private short field_4_height ; private short field_5_options ; static final private BitField hidden = new BitField ( 0x01 ) ; static final private BitField iconic = new BitField ( 0x02 ) ; static final private BitField reserved = new BitField ( 0x04 ) ; static final private BitField hscroll = new BitField ( 0x08 ) ; static final private BitField vscroll = new BitField ( 0x10 ) ; static final private BitField tabs = new BitField ( 0x20 ) ; private short field_6_selected_tab ; private short field_7_displayed_tab ; private short field_8_num_selected_tabs ; private short field_9_tab_width_ratio ; public WindowOneRecord ( ) { } public WindowOneRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public WindowOneRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A WINDOW1 RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_h_hold = LittleEndian . getShort ( data , 0 + offset ) ; field_2_v_hold = LittleEndian . getShort ( data , 2 + offset ) ; field_3_width = LittleEndian . getShort ( data , 4 + offset ) ; field_4_height = LittleEndian . getShort ( data , 6 + offset ) ; field_5_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_selected_tab = LittleEndian . getShort ( data , 10 + offset ) ; field_7_displayed_tab = LittleEndian . getShort ( data , 12 + offset ) ; field_8_num_selected_tabs = LittleEndian . getShort ( data , 14 + offset ) ; field_9_tab_width_ratio = LittleEndian . getShort ( data , 16 + offset ) ; } public void setHorizontalHold ( short h ) { field_1_h_hold = h ; } public void setVerticalHold ( short v ) { field_2_v_hold = v ; } public void setWidth ( short w ) { field_3_width = w ; } public void setHeight ( short h ) { field_4_height = h ; } public void setOptions ( short o ) { field_5_options = o ; } public void setHidden ( boolean ishidden ) { field_5_options = hidden . setShortBoolean ( field_5_options , ishidden ) ; } public void setIconic ( boolean isiconic ) { field_5_options = iconic . setShortBoolean ( field_5_options , isiconic ) ; } public void setDisplayHorizonalScrollbar ( boolean scroll ) { field_5_options = hscroll . setShortBoolean ( field_5_options , scroll ) ; } public void setDisplayVerticalScrollbar ( boolean scroll ) { field_5_options = vscroll . setShortBoolean ( field_5_options , scroll ) ; } public void setDisplayTabs ( boolean disptabs ) { field_5_options = tabs . setShortBoolean ( field_5_options , disptabs ) ; } public void setSelectedTab ( short s ) { field_6_selected_tab = s ; } public void setDisplayedTab ( short t ) { field_7_displayed_tab = t ; } public void setNumSelectedTabs ( short n ) { field_8_num_selected_tabs = n ; } public void setTabWidthRatio ( short r ) { field_9_tab_width_ratio = r ; } public short getHorizontalHold ( ) { return field_1_h_hold ; } public short getVerticalHold ( ) { return field_2_v_hold ; } public short getWidth ( ) { return field_3_width ; } public short getHeight ( ) { return field_4_height ; } public short getOptions ( ) { return field_5_options ; } public boolean getHidden ( ) { return hidden . isSet ( field_5_options ) ; } public boolean getIconic ( ) { return iconic . isSet ( field_5_options ) ; } public boolean getDisplayHorizontalScrollbar ( ) { return hscroll . isSet ( field_5_options ) ; } public boolean getDisplayVerticalScrollbar ( ) { return vscroll . isSet ( field_5_options ) ; } public boolean getDisplayTabs ( ) { return tabs . isSet ( field_5_options ) ; } public short getSelectedTab ( ) { return field_6_selected_tab ; } public short getDisplayedTab ( ) { return field_7_displayed_tab ; } public short getNumSelectedTabs ( ) { return field_8_num_selected_tabs ; } public short getTabWidthRatio ( ) { return field_9_tab_width_ratio ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[WINDOW1]\n" ) ; buffer . append ( "    .h_hold          = " ) . append ( Integer . toHexString ( getHorizontalHold ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .v_hold          = " ) . append ( Integer . toHexString ( getVerticalHold ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .width           = " ) . append ( Integer . toHexString ( getWidth ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .height          = " ) . append ( Integer . toHexString ( getHeight ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .options         = " ) . append ( Integer . toHexString ( getOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "        .hidden      = " ) . append ( getHidden ( ) ) . append ( "\n" ) ; buffer . append ( "        .iconic      = " ) . append ( getIconic ( ) ) . append ( "\n" ) ; buffer . append ( "        .hscroll     = " ) . append ( getDisplayHorizontalScrollbar ( ) ) . append ( "\n" ) ; buffer . append ( "        .vscroll     = " ) . append ( getDisplayVerticalScrollbar ( ) ) . append ( "\n" ) ; buffer . append ( "        .tabs        = " ) . append ( getDisplayTabs ( ) ) . append ( "\n" ) ; buffer . append ( "    .selectedtab     = " ) . append ( Integer . toHexString ( getSelectedTab ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .displayedtab    = " ) . append ( Integer . toHexString ( getDisplayedTab ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .numselectedtabs = " ) . append ( Integer . toHexString ( getNumSelectedTabs ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .tabwidthratio   = " ) . append ( Integer . toHexString ( getTabWidthRatio ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/WINDOW1]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x12 ) ) ; LittleEndian . putShort ( data , 4 + offset , getHorizontalHold ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getVerticalHold ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getWidth ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getHeight ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getSelectedTab ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getDisplayedTab ( ) ) ; LittleEndian . putShort ( data , 18 + offset , getNumSelectedTabs ( ) ) ; LittleEndian . putShort ( data , 20 + offset , getTabWidthRatio ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 22 ; } public short getSid ( ) { return this . sid ; } } 	0	['38', '2', '0', '6', '52', '479', '2', '4', '35', '0.898648649', '536', '0.9375', '6', '0.244444444', '0.335135135', '1', '6', '12.68421053', '2', '0.9211', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . property . Property ; public abstract class EntryNode implements Entry { private Property _property ; private DirectoryNode _parent ; protected EntryNode ( final Property property , final DirectoryNode parent ) { _property = property ; _parent = parent ; } protected Property getProperty ( ) { return _property ; } protected boolean isRoot ( ) { return ( _parent == null ) ; } protected abstract boolean isDeleteOK ( ) ; public String getName ( ) { return _property . getName ( ) ; } public boolean isDirectoryEntry ( ) { return false ; } public boolean isDocumentEntry ( ) { return false ; } public DirectoryEntry getParent ( ) { return _parent ; } public boolean delete ( ) { boolean rval = false ; if ( ( ! isRoot ( ) ) && isDeleteOK ( ) ) { rval = _parent . deleteEntry ( this ) ; } return rval ; } public boolean renameTo ( final String newName ) { boolean rval = false ; if ( ! isRoot ( ) ) { rval = _parent . changeName ( getName ( ) , newName ) ; } return rval ; } } 	0	['10', '1', '2', '6', '14', '19', '3', '4', '6', '0.611111111', '71', '1', '2', '0', '0.325', '0', '0', '5.9', '3', '1.3', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class LongField implements FixedField { private long _value ; private final int _offset ; public LongField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public LongField ( final int offset , final long value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public LongField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public LongField ( final int offset , final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public long get ( ) { return _value ; } public void set ( final long value ) { _value = value ; } public void set ( final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getLong ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readLong ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putLong ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '5', '21', '9', '2', '3', '11', '0.25', '92', '1', '0', '0', '0.454545455', '0', '0', '7.181818182', '1', '0.6364', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public interface FixedField { public void readFromBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public void readFromStream ( InputStream stream ) throws IOException , BufferUnderrunException ; public void writeToBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public String toString ( ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ByteField implements FixedField { private static final byte _default_value = 0 ; private byte _value ; private final int _offset ; public ByteField ( final int offset ) throws ArrayIndexOutOfBoundsException { this ( offset , _default_value ) ; } public ByteField ( final int offset , final byte value ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "offset cannot be negative" ) ; } _offset = offset ; set ( value ) ; } public ByteField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ByteField ( final int offset , final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset , value ) ; writeToBytes ( data ) ; } public byte get ( ) { return _value ; } public void set ( final byte value ) { _value = value ; } public void set ( final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { set ( value ) ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = data [ _offset ] ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = ( LittleEndian . readFromStream ( stream , LittleEndianConsts . BYTE_SIZE ) ) [ 0 ] ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { data [ _offset ] = _value ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '4', '15', '21', '1', '3', '11', '0.533333333', '90', '1', '0', '0', '0.454545455', '0', '0', '6.909090909', '1', '0.6364', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class ProtectionRev4Record extends Record { public final static short sid = 0x1af ; private short field_1_protect ; public ProtectionRev4Record ( ) { } public ProtectionRev4Record ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ProtectionRev4Record ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PROTECTION REV 4 RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_protect = LittleEndian . getShort ( data , 0 + offset ) ; } public void setProtect ( boolean protect ) { if ( protect ) { field_1_protect = 1 ; } else { field_1_protect = 0 ; } } public short getProtect ( ) { return field_1_protect ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PROT4REV]\n" ) ; buffer . append ( "    .rowheight      = " ) . append ( Integer . toHexString ( getProtect ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/PROT4REV]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getProtect ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '49', '2', '3', '9', '0.85', '112', '0.5', '0', '0.578947368', '0.418181818', '1', '6', '9', '2', '0.9091', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; abstract class BigBlock implements BlockWritable { protected void doWriteData ( final OutputStream stream , final byte [ ] data ) throws IOException { stream . write ( data ) ; } abstract void writeData ( final OutputStream stream ) throws IOException ; public void writeBlocks ( final OutputStream stream ) throws IOException { writeData ( stream ) ; } } 	0	['4', '1', '4', '5', '6', '6', '4', '1', '1', '2', '15', '0', '0', '0', '0.666666667', '0', '0', '2.75', '1', '0.75', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class TabIdRecord extends Record { public final static short sid = 0x13d ; public short [ ] field_1_tabids ; public TabIdRecord ( ) { } public TabIdRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public TabIdRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A TABID RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_tabids = new short [ size / 2 ] ; for ( int k = 0 ; k < field_1_tabids . length ; k ++ ) { field_1_tabids [ k ] = LittleEndian . getShort ( data , ( k * 2 ) + offset ) ; } } public void setTabIdArray ( short [ ] array ) { field_1_tabids = array ; } public short [ ] getTabIdArray ( ) { return field_1_tabids ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[TABID]\n" ) ; buffer . append ( "    .elements        = " ) . append ( field_1_tabids . length ) . append ( "\n" ) ; for ( int k = 0 ; k < field_1_tabids . length ; k ++ ) { buffer . append ( "    .element_" + k + "       = " ) . append ( field_1_tabids [ k ] ) . append ( "\n" ) ; } buffer . append ( "[/TABID]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { short [ ] tabids = getTabIdArray ( ) ; short length = ( short ) ( tabids . length * 2 ) ; int byteoffset = 4 ; LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) length ) ) ; for ( int k = 0 ; k < ( length / 2 ) ; k ++ ) { LittleEndian . putShort ( data , byteoffset + offset , tabids [ k ] ) ; byteoffset += 2 ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + ( getTabIdArray ( ) . length * 2 ) ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '25', '43', '2', '3', '9', '0.8', '182', '0', '0', '0.578947368', '0.418181818', '1', '6', '15.36363636', '2', '1.0909', '0']
package org . apache . poi . hpsf . littleendian ; public class Word extends LittleEndian { public Word ( final byte [ ] src , final int offset ) { super ( src , offset ) ; } public final static int LENGTH = 2 ; public int length ( ) { return LENGTH ; } } 	0	['2', '2', '0', '4', '3', '1', '3', '1', '2', '2', '10', '0', '0', '0.75', '0.666666667', '1', '1', '3.5', '1', '0.5', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; public interface BlockWritable { public void writeBlocks ( final OutputStream stream ) throws IOException ; } 	0	['1', '1', '0', '9', '1', '0', '9', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . property ; import java . io . IOException ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . storage . ListManagedBlock ; class PropertyFactory { private PropertyFactory ( ) { } static List convertToProperties ( ListManagedBlock [ ] blocks ) throws IOException { List properties = new ArrayList ( ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { byte [ ] data = blocks [ j ] . getData ( ) ; int property_count = data . length / POIFSConstants . PROPERTY_SIZE ; int offset = 0 ; for ( int k = 0 ; k < property_count ; k ++ ) { switch ( data [ offset + PropertyConstants . PROPERTY_TYPE_OFFSET ] ) { case PropertyConstants . DIRECTORY_TYPE : properties . add ( new DirectoryProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . DOCUMENT_TYPE : properties . add ( new DocumentProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . ROOT_TYPE : properties . add ( new RootProperty ( properties . size ( ) , data , offset ) ) ; break ; default : properties . add ( null ) ; break ; } offset += POIFSConstants . PROPERTY_SIZE ; } } return properties ; } } 	0	['2', '1', '0', '5', '10', '1', '1', '4', '0', '2', '82', '0', '0', '0', '0.5', '0', '0', '40', '1', '0.5', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class IntegerField implements FixedField { private int _value ; private final int _offset ; public IntegerField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "negative offset" ) ; } _offset = offset ; } public IntegerField ( final int offset , final int value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public IntegerField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public IntegerField ( final int offset , final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public int get ( ) { return _value ; } public void set ( final int value ) { _value = value ; } public void set ( final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getInt ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readInt ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putInt ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '7', '17', '9', '4', '3', '11', '0.25', '85', '1', '0', '0', '0.522727273', '0', '0', '6.545454545', '1', '0.6364', '0']
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RKUtil ; public class MulRKRecord extends Record { public final static short sid = 0xbd ; private short field_1_row ; private short field_2_first_col ; private ArrayList field_3_rks ; private short field_4_last_col ; public MulRKRecord ( ) { } public MulRKRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public MulRKRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } public short getRow ( ) { return field_1_row ; } public short getFirstColumn ( ) { return field_2_first_col ; } public short getLastColumn ( ) { return field_4_last_col ; } public int getNumColumns ( ) { return field_4_last_col - field_2_first_col + 1 ; } public short getXFAt ( int coffset ) { return ( ( RkRec ) field_3_rks . get ( coffset ) ) . xf ; } public double getRKNumberAt ( int coffset ) { return RKUtil . decodeNumber ( ( ( RkRec ) field_3_rks . get ( coffset ) ) . rk ) ; } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_col = LittleEndian . getShort ( data , 2 + offset ) ; field_3_rks = parseRKs ( data , 4 , offset , size ) ; field_4_last_col = LittleEndian . getShort ( data , ( field_3_rks . size ( ) * 6 ) + 4 + offset ) ; } private ArrayList parseRKs ( byte [ ] data , int offset , int recoffset , short size ) { ArrayList retval = new ArrayList ( ) ; for ( ; offset < size - 2 ; ) { RkRec rec = new RkRec ( ) ; rec . xf = LittleEndian . getShort ( data , offset + recoffset ) ; offset += 2 ; rec . rk = LittleEndian . getInt ( data , offset + recoffset ) ; offset += 4 ; retval . add ( rec ) ; } return retval ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[MULRK]\n" ) ; buffer . append ( "firstcol  = " ) . append ( Integer . toHexString ( getFirstColumn ( ) ) ) . append ( "\n" ) ; buffer . append ( " lastcol  = " ) . append ( Integer . toHexString ( getLastColumn ( ) ) ) . append ( "\n" ) ; for ( int k = 0 ; k < getNumColumns ( ) ; k ++ ) { buffer . append ( "xf" ) . append ( k ) . append ( "        = " ) . append ( Integer . toHexString ( getXFAt ( k ) ) ) . append ( "\n" ) ; buffer . append ( "rk" ) . append ( k ) . append ( "        = " ) . append ( getRKNumberAt ( k ) ) . append ( "\n" ) ; } buffer . append ( "[/MULRK]\n" ) ; return buffer . toString ( ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a MulRKRecord!" ) ; } } public short getSid ( ) { return this . sid ; } public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( "Sorry, you can't serialize a MulRK in this release" ) ; } } class RkRec { public short xf ; public int rk ; } 	0	['15', '2', '0', '7', '33', '87', '2', '5', '12', '0.871428571', '230', '0.8', '0', '0.47826087', '0.516666667', '1', '5', '14', '2', '1', '0']
package org . apache . poi . poifs . eventfilesystem ; public interface POIFSReaderListener { public void processPOIFSReaderEvent ( POIFSReaderEvent event ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . property ; import java . util . * ; import java . io . IOException ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; public class DirectoryProperty extends Property implements Parent { private List _children ; private Set _children_names ; public DirectoryProperty ( String name ) { super ( ) ; _children = new ArrayList ( ) ; _children_names = new HashSet ( ) ; setName ( name ) ; setSize ( 0 ) ; setPropertyType ( PropertyConstants . DIRECTORY_TYPE ) ; setStartBlock ( 0 ) ; setNodeColor ( _NODE_BLACK ) ; } protected DirectoryProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; _children = new ArrayList ( ) ; _children_names = new HashSet ( ) ; } public boolean changeName ( final Property property , final String newName ) { boolean result ; String oldName = property . getName ( ) ; property . setName ( newName ) ; String cleanNewName = property . getName ( ) ; if ( _children_names . contains ( cleanNewName ) ) { property . setName ( oldName ) ; result = false ; } else { _children_names . add ( cleanNewName ) ; _children_names . remove ( oldName ) ; result = true ; } return result ; } public boolean deleteChild ( final Property property ) { boolean result = _children . remove ( property ) ; if ( result ) { _children_names . remove ( property . getName ( ) ) ; } return result ; } private class PropertyComparator implements Comparator { public boolean equals ( Object o ) { return this == o ; } public int compare ( Object o1 , Object o2 ) { String name1 = ( ( Property ) o1 ) . getName ( ) ; String name2 = ( ( Property ) o2 ) . getName ( ) ; int result = name1 . length ( ) - name2 . length ( ) ; if ( result == 0 ) { result = name1 . compareTo ( name2 ) ; } return result ; } } public boolean isDirectory ( ) { return true ; } protected void preWrite ( ) { if ( _children . size ( ) > 0 ) { Property [ ] children = ( Property [ ] ) _children . toArray ( new Property [ 0 ] ) ; Arrays . sort ( children , new PropertyComparator ( ) ) ; int midpoint = children . length / 2 ; setChildProperty ( children [ midpoint ] . getIndex ( ) ) ; children [ 0 ] . setPreviousChild ( null ) ; children [ 0 ] . setNextChild ( null ) ; for ( int j = 1 ; j < midpoint ; j ++ ) { children [ j ] . setPreviousChild ( children [ j - 1 ] ) ; children [ j ] . setNextChild ( null ) ; } if ( midpoint != 0 ) { children [ midpoint ] . setPreviousChild ( children [ midpoint - 1 ] ) ; } if ( midpoint != ( children . length - 1 ) ) { children [ midpoint ] . setNextChild ( children [ midpoint + 1 ] ) ; for ( int j = midpoint + 1 ; j < children . length - 1 ; j ++ ) { children [ j ] . setPreviousChild ( null ) ; children [ j ] . setNextChild ( children [ j + 1 ] ) ; } children [ children . length - 1 ] . setPreviousChild ( null ) ; children [ children . length - 1 ] . setNextChild ( null ) ; } else { children [ midpoint ] . setNextChild ( null ) ; } } } public Iterator getChildren ( ) { return _children . iterator ( ) ; } public void addChild ( final Property property ) throws IOException { String name = property . getName ( ) ; if ( _children_names . contains ( name ) ) { throw new IOException ( "Duplicate name \"" + name + "\"" ) ; } _children_names . add ( name ) ; _children . add ( property ) ; } } 	0	['8', '2', '1', '11', '37', '0', '7', '5', '6', '0.357142857', '278', '1', '0', '0.823529412', '0.375', '1', '1', '33.5', '6', '1.625', '0']
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; public class POIFSViewEngine { private static final String _EOL = System . getProperty ( "line.separator" ) ; public static List inspectViewable ( final Object viewable , final boolean drilldown , final int indentLevel , final String indentString ) { List objects = new ArrayList ( ) ; if ( viewable instanceof POIFSViewable ) { POIFSViewable inspected = ( POIFSViewable ) viewable ; objects . add ( indent ( indentLevel , indentString , inspected . getShortDescription ( ) ) ) ; if ( drilldown ) { if ( inspected . preferArray ( ) ) { Object [ ] data = inspected . getViewableArray ( ) ; for ( int j = 0 ; j < data . length ; j ++ ) { objects . addAll ( inspectViewable ( data [ j ] , drilldown , indentLevel + 1 , indentString ) ) ; } } else { Iterator iter = inspected . getViewableIterator ( ) ; while ( iter . hasNext ( ) ) { objects . addAll ( inspectViewable ( iter . next ( ) , drilldown , indentLevel + 1 , indentString ) ) ; } } } } else { objects . add ( indent ( indentLevel , indentString , viewable . toString ( ) ) ) ; } return objects ; } private static String indent ( final int indentLevel , final String indentString , final String data ) { StringBuffer finalBuffer = new StringBuffer ( ) ; StringBuffer indentPrefix = new StringBuffer ( ) ; for ( int j = 0 ; j < indentLevel ; j ++ ) { indentPrefix . append ( indentString ) ; } LineNumberReader reader = new LineNumberReader ( new StringReader ( data ) ) ; try { String line = reader . readLine ( ) ; while ( line != null ) { finalBuffer . append ( indentPrefix ) . append ( line ) . append ( _EOL ) ; line = reader . readLine ( ) ; } } catch ( IOException e ) { finalBuffer . append ( indentPrefix ) . append ( e . getMessage ( ) ) . append ( _EOL ) ; } return finalBuffer . toString ( ) ; } } 	0	['4', '1', '0', '2', '24', '4', '1', '1', '2', '0.333333333', '146', '1', '0', '0', '0.466666667', '0', '0', '35.25', '3', '1.25', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class UseSelFSRecord extends Record { public final static short sid = 0x160 ; public final static short TRUE = 1 ; public final static short FALSE = 0 ; private short field_1_flag ; public UseSelFSRecord ( ) { } public UseSelFSRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public UseSelFSRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A UseSelFS RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_flag = LittleEndian . getShort ( data , 0 + offset ) ; } public void setFlag ( short flag ) { field_1_flag = flag ; } public short getFlag ( ) { return field_1_flag ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[USESELFS]\n" ) ; buffer . append ( "    .flag            = " ) . append ( Integer . toHexString ( getFlag ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/USESELFS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFlag ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '49', '2', '3', '9', '0.975', '108', '0.25', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '0']
package org . apache . poi . poifs . property ; import org . apache . poi . poifs . filesystem . POIFSDocument ; public class DocumentProperty extends Property { private POIFSDocument _document ; public DocumentProperty ( final String name , final int size ) { super ( ) ; _document = null ; setName ( name ) ; setSize ( size ) ; setNodeColor ( _NODE_BLACK ) ; setPropertyType ( PropertyConstants . DOCUMENT_TYPE ) ; } protected DocumentProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; _document = null ; } public void setDocument ( POIFSDocument doc ) { _document = doc ; } public POIFSDocument getDocument ( ) { return _document ; } public boolean shouldUseSmallBlocks ( ) { return super . shouldUseSmallBlocks ( ) ; } public boolean isDirectory ( ) { return false ; } protected void preWrite ( ) { } } 	0	['7', '2', '0', '6', '14', '9', '5', '2', '5', '0.5', '48', '1', '1', '0.848484848', '0.342857143', '0', '0', '5.714285714', '1', '0.7143', '0']
package org . apache . poi . hpsf . littleendian ; public class DWord extends LittleEndian { public DWord ( final byte [ ] src , final int offset ) { super ( src , offset ) ; } public final static int LENGTH = 4 ; public int length ( ) { return LENGTH ; } public int intValue ( ) { int value = 0 ; final int length = length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final int b = 0xFF & bytes [ i ] ; value = value << 8 | b ; } return value ; } } 	0	['3', '2', '0', '6', '4', '3', '5', '1', '3', '1.5', '38', '0', '0', '0.6', '0.555555556', '1', '1', '11.33333333', '2', '1', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Arrays ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BATBlock extends BigBlock { private static final int _entries_per_block = POIFSConstants . BIG_BLOCK_SIZE / LittleEndianConsts . INT_SIZE ; private static final int _entries_per_xbat_block = _entries_per_block - 1 ; private static final int _xbat_chain_offset = _entries_per_xbat_block * LittleEndianConsts . INT_SIZE ; private static final byte _default_value = ( byte ) 0xFF ; private IntegerField [ ] _fields ; private byte [ ] _data ; private BATBlock ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; _fields = new IntegerField [ _entries_per_block ] ; int offset = 0 ; for ( int j = 0 ; j < _entries_per_block ; j ++ ) { _fields [ j ] = new IntegerField ( offset ) ; offset += LittleEndianConsts . INT_SIZE ; } } public static BATBlock [ ] createBATBlocks ( final int [ ] entries ) { int block_count = calculateStorageRequirements ( entries . length ) ; BATBlock [ ] blocks = new BATBlock [ block_count ] ; int index = 0 ; int remaining = entries . length ; for ( int j = 0 ; j < entries . length ; j += _entries_per_block ) { blocks [ index ++ ] = new BATBlock ( entries , j , ( remaining > _entries_per_block ) ? j + _entries_per_block : entries . length ) ; remaining -= _entries_per_block ; } return blocks ; } public static BATBlock [ ] createXBATBlocks ( final int [ ] entries , final int startBlock ) { int block_count = calculateXBATStorageRequirements ( entries . length ) ; BATBlock [ ] blocks = new BATBlock [ block_count ] ; int index = 0 ; int remaining = entries . length ; if ( block_count != 0 ) { for ( int j = 0 ; j < entries . length ; j += _entries_per_xbat_block ) { blocks [ index ++ ] = new BATBlock ( entries , j , ( remaining > _entries_per_xbat_block ) ? j + _entries_per_xbat_block : entries . length ) ; remaining -= _entries_per_xbat_block ; } for ( index = 0 ; index < blocks . length - 1 ; index ++ ) { blocks [ index ] . setXBATChain ( startBlock + index + 1 ) ; } blocks [ index ] . setXBATChain ( POIFSConstants . END_OF_CHAIN ) ; } return blocks ; } public static int calculateStorageRequirements ( final int entryCount ) { return ( entryCount + _entries_per_block - 1 ) / _entries_per_block ; } public static int calculateXBATStorageRequirements ( final int entryCount ) { return ( entryCount + _entries_per_xbat_block - 1 ) / _entries_per_xbat_block ; } public static final int entriesPerBlock ( ) { return _entries_per_block ; } public static final int entriesPerXBATBlock ( ) { return _entries_per_xbat_block ; } public static final int getXBATChainOffset ( ) { return _xbat_chain_offset ; } private void setXBATChain ( int chainIndex ) { _fields [ _entries_per_xbat_block ] . set ( chainIndex , _data ) ; } private BATBlock ( final int [ ] entries , final int start_index , final int end_index ) { this ( ) ; for ( int k = start_index ; k < end_index ; k ++ ) { _fields [ k - start_index ] . set ( entries [ k ] , _data ) ; } } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0	['12', '2', '0', '6', '18', '54', '4', '2', '8', '0.924242424', '222', '1', '1', '0.230769231', '0.3125', '1', '2', '17', '5', '1.3333', '0']
package org . apache . poi . util ; public interface LittleEndianConsts { public static final int BYTE_SIZE = 1 ; public static final int SHORT_SIZE = 2 ; public static final int INT_SIZE = 4 ; public static final int LONG_SIZE = 8 ; public static final int DOUBLE_SIZE = 8 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '5', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . util ; import java . util . * ; public class ShortList { private short [ ] _array ; private int _limit ; private static final int _default_size = 128 ; public ShortList ( ) { this ( _default_size ) ; } public ShortList ( final ShortList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; } public ShortList ( final int initialCapacity ) { _array = new short [ initialCapacity ] ; _limit = 0 ; } public void add ( final int index , final short value ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } else if ( index == _limit ) { add ( value ) ; } else { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } System . arraycopy ( _array , index , _array , index + 1 , _limit - index ) ; _array [ index ] = value ; _limit ++ ; } } public boolean add ( final short value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; } public boolean addAll ( final ShortList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; } public boolean addAll ( final int index , final ShortList c ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( _array , index , _array , index + c . _limit , _limit - index ) ; System . arraycopy ( c . _array , 0 , _array , index , c . _limit ) ; _limit += c . _limit ; } return true ; } public void clear ( ) { _limit = 0 ; } public boolean contains ( final short o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; } public boolean containsAll ( final ShortList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; } public boolean equals ( final Object o ) { boolean rval = this == o ; if ( ! rval && ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { ShortList other = ( ShortList ) o ; if ( other . _limit == _limit ) { rval = true ; for ( int j = 0 ; rval && ( j < _limit ) ; j ++ ) { rval = _array [ j ] == other . _array [ j ] ; } } } return rval ; } public short get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } return _array [ index ] ; } public int hashCode ( ) { int hash = 0 ; for ( int j = 0 ; j < _limit ; j ++ ) { hash = ( 31 * hash ) + _array [ j ] ; } return hash ; } public int indexOf ( final short o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; } public boolean isEmpty ( ) { return _limit == 0 ; } public int lastIndexOf ( final short o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; } public short remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } short rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; } public boolean removeValue ( final short o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; _limit -- ; rval = true ; } } return rval ; } public boolean removeAll ( final ShortList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; } public boolean retainAll ( final ShortList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; } public short set ( final int index , final short element ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } short rval = _array [ index ] ; _array [ index ] = element ; return rval ; } public int size ( ) { return _limit ; } public short [ ] toArray ( ) { short [ ] rval = new short [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; } public short [ ] toArray ( final short [ ] a ) { short [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; } private void growArray ( final int new_size ) { int size = ( new_size == _array . length ) ? new_size + 1 : new_size ; short [ ] new_array = new short [ size ] ; System . arraycopy ( _array , 0 , new_array , 0 , _limit ) ; _array = new_array ; } } 	0	['25', '1', '0', '0', '29', '0', '0', '0', '24', '0.388888889', '629', '1', '0', '0', '0.313333333', '1', '1', '24.04', '9', '2.6', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DateWindow1904Record extends Record { public final static short sid = 0x22 ; private short field_1_window ; public DateWindow1904Record ( ) { } public DateWindow1904Record ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DateWindow1904Record ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A 1904 RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_window = LittleEndian . getShort ( data , 0 + offset ) ; } public void setWindowing ( short window ) { field_1_window = window ; } public short getWindowing ( ) { return field_1_window ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[1904]\n" ) ; buffer . append ( "    .is1904          = " ) . append ( Integer . toHexString ( getWindowing ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/1904]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getWindowing ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '49', '2', '3', '9', '0.85', '106', '0.5', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class RefreshAllRecord extends Record { public final static short sid = 0x1B7 ; private short field_1_refreshall ; public RefreshAllRecord ( ) { } public RefreshAllRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public RefreshAllRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A REFRESHALL RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_refreshall = LittleEndian . getShort ( data , 0 + offset ) ; } public void setRefreshAll ( boolean refreshall ) { if ( refreshall ) { field_1_refreshall = 1 ; } else { field_1_refreshall = 0 ; } } public boolean getRefreshAll ( ) { return ( field_1_refreshall == 1 ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[REFRESHALL]\n" ) ; buffer . append ( "    .refreshall      = " ) . append ( getRefreshAll ( ) ) . append ( "\n" ) ; buffer . append ( "[/REFRESHALL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_refreshall ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '43', '2', '3', '9', '0.85', '116', '0.5', '0', '0.578947368', '0.418181818', '1', '6', '9.363636364', '2', '1', '0']
package org . apache . poi . util ; import java . util . * ; public class IntList { private int [ ] _array ; private int _limit ; private static final int _default_size = 128 ; public IntList ( ) { this ( _default_size ) ; } public IntList ( final IntList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; } public IntList ( final int initialCapacity ) { _array = new int [ initialCapacity ] ; _limit = 0 ; } public void add ( final int index , final int value ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } else if ( index == _limit ) { add ( value ) ; } else { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } System . arraycopy ( _array , index , _array , index + 1 , _limit - index ) ; _array [ index ] = value ; _limit ++ ; } } public boolean add ( final int value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; } public boolean addAll ( final IntList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; } public boolean addAll ( final int index , final IntList c ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( _array , index , _array , index + c . _limit , _limit - index ) ; System . arraycopy ( c . _array , 0 , _array , index , c . _limit ) ; _limit += c . _limit ; } return true ; } public void clear ( ) { _limit = 0 ; } public boolean contains ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; } public boolean containsAll ( final IntList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; } public boolean equals ( final Object o ) { boolean rval = this == o ; if ( ! rval && ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { IntList other = ( IntList ) o ; if ( other . _limit == _limit ) { rval = true ; for ( int j = 0 ; rval && ( j < _limit ) ; j ++ ) { rval = _array [ j ] == other . _array [ j ] ; } } } return rval ; } public int get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } return _array [ index ] ; } public int hashCode ( ) { int hash = 0 ; for ( int j = 0 ; j < _limit ; j ++ ) { hash = ( 31 * hash ) + _array [ j ] ; } return hash ; } public int indexOf ( final int o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; } public boolean isEmpty ( ) { return _limit == 0 ; } public int lastIndexOf ( final int o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; } public int remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } int rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; } public boolean removeValue ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; _limit -- ; rval = true ; } } return rval ; } public boolean removeAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; } public boolean retainAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; } public int set ( final int index , final int element ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } int rval = _array [ index ] ; _array [ index ] = element ; return rval ; } public int size ( ) { return _limit ; } public int [ ] toArray ( ) { int [ ] rval = new int [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; } public int [ ] toArray ( final int [ ] a ) { int [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; } private void growArray ( final int new_size ) { int size = ( new_size == _array . length ) ? new_size + 1 : new_size ; int [ ] new_array = new int [ size ] ; System . arraycopy ( _array , 0 , new_array , 0 , _limit ) ; _array = new_array ; } } 	0	['25', '1', '0', '4', '29', '0', '4', '0', '24', '0.388888889', '629', '1', '0', '0', '0.36', '1', '1', '24.04', '9', '2.6', '0']
package org . apache . poi . hssf . util ; import org . apache . poi . hssf . record . MergeCellsRecord . MergedRegion ; public class Region implements Comparable { private int rowFrom ; private short colFrom ; private int rowTo ; private short colTo ; public Region ( ) { } public Region ( int rowFrom , short colFrom , int rowTo , short colTo ) { this . rowFrom = rowFrom ; this . rowTo = rowTo ; this . colFrom = colFrom ; this . colTo = colTo ; } public Region ( MergedRegion region ) { this ( region . row_from , region . col_from , region . row_to , region . col_to ) ; } public short getColumnFrom ( ) { return colFrom ; } public int getRowFrom ( ) { return rowFrom ; } public short getColumnTo ( ) { return colTo ; } public int getRowTo ( ) { return rowTo ; } public void setColumnFrom ( short colFrom ) { this . colFrom = colFrom ; } public void setRowFrom ( int rowFrom ) { this . rowFrom = rowFrom ; } public void setColumnTo ( short colTo ) { this . colTo = colTo ; } public void setRowTo ( int rowTo ) { this . rowTo = rowTo ; } public boolean contains ( int row , short col ) { if ( ( this . rowFrom <= row ) && ( this . rowTo >= row ) && ( this . colFrom <= col ) && ( this . colTo >= col ) ) { return true ; } return false ; } public boolean equals ( Region r ) { return ( compareTo ( r ) == 0 ) ; } public int compareTo ( Region r ) { if ( ( this . getRowFrom ( ) == r . getRowFrom ( ) ) && ( this . getColumnFrom ( ) == r . getColumnFrom ( ) ) && ( this . getRowTo ( ) == r . getRowTo ( ) ) && ( this . getColumnTo ( ) == r . getColumnTo ( ) ) ) { return 0 ; } if ( ( this . getRowFrom ( ) < r . getRowFrom ( ) ) || ( this . getColumnFrom ( ) < r . getColumnFrom ( ) ) || ( this . getRowTo ( ) < r . getRowTo ( ) ) || ( this . getColumnTo ( ) < r . getColumnTo ( ) ) ) { return 1 ; } return - 1 ; } public int compareTo ( Object o ) { return compareTo ( ( Region ) o ) ; } public int getArea ( ) { return ( ( 1 + ( getRowTo ( ) - getRowFrom ( ) ) ) * ( 1 + ( getColumnTo ( ) - getColumnFrom ( ) ) ) ) ; } } 	0	['16', '1', '0', '3', '17', '78', '2', '1', '16', '0.533333333', '172', '1', '0', '0', '0.291666667', '0', '0', '9.5', '9', '1.625', '0']
package org . apache . poi . hssf . record . formula ; public class FormulaUtil { public FormulaUtil ( ) { } public static Ptg [ ] parseFormula ( String formula ) { Ptg [ ] ptg = null ; StringBuffer f = new StringBuffer ( formula ) ; if ( isIntAddition ( formula ) ) { int loc = getLoc ( formula , '+' ) ; System . out . println ( formula . substring ( 0 , loc ) . trim ( ) + "," + formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ; ptg = formulaAddTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } else if ( isIntSubtraction ( formula ) ) { int loc = getLoc ( formula , '-' ) ; ptg = formulaSubtractTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } else if ( isIntMultiplication ( formula ) ) { int loc = getLoc ( formula , '*' ) ; ptg = formulaMultiplyTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } else if ( isIntDivision ( formula ) ) { int loc = getLoc ( formula , '/' ) ; ptg = formulaDivideTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } else if ( isIntPower ( formula ) ) { int loc = getLoc ( formula , '^' ) ; ptg = formulaPowerTwoInts ( Short . parseShort ( formula . substring ( 0 , loc ) . trim ( ) ) , Short . parseShort ( formula . substring ( loc + 1 , formula . length ( ) ) . trim ( ) ) ) ; } return ptg ; } public static Ptg [ ] formulaAddTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( first ) ; ptg [ 1 ] = createInteger ( second ) ; ptg [ 2 ] = createAdd ( ) ; return ptg ; } public static Ptg [ ] formulaSubtractTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( first ) ; ptg [ 1 ] = createInteger ( second ) ; ptg [ 2 ] = createSubtract ( ) ; return ptg ; } public static Ptg [ ] formulaMultiplyTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( first ) ; ptg [ 1 ] = createInteger ( second ) ; ptg [ 2 ] = createMultiply ( ) ; return ptg ; } public static Ptg [ ] formulaPowerTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( second ) ; ptg [ 1 ] = createInteger ( first ) ; ptg [ 2 ] = createPower ( ) ; return ptg ; } public static Ptg [ ] formulaDivideTwoInts ( short first , short second ) { Ptg [ ] ptg = new Ptg [ 3 ] ; ptg [ 0 ] = createInteger ( first ) ; ptg [ 1 ] = createInteger ( second ) ; ptg [ 2 ] = createDivide ( ) ; return ptg ; } public static Ptg createInteger ( short value ) { IntPtg ptg = new IntPtg ( ) ; ptg . setValue ( value ) ; return ptg ; } public static Ptg createAdd ( ) { AddPtg ptg = new AddPtg ( ) ; return ptg ; } public static Ptg createSubtract ( ) { SubtractPtg ptg = new SubtractPtg ( ) ; return ptg ; } public static Ptg createMultiply ( ) { MultiplyPtg ptg = new MultiplyPtg ( ) ; return ptg ; } public static Ptg createDivide ( ) { DividePtg ptg = new DividePtg ( ) ; return ptg ; } public static Ptg createPower ( ) { PowerPtg ptg = new PowerPtg ( ) ; return ptg ; } private static boolean isIntAddition ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "+" ) ) { return true ; } return false ; } private static boolean isIntSubtraction ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "-" ) ) { return true ; } return false ; } private static boolean isIntMultiplication ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "*" ) ) { return true ; } return false ; } private static boolean isIntDivision ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "/" ) ) { return true ; } return false ; } private static boolean isIntPower ( String formula ) { StringBuffer buffer = new StringBuffer ( formula ) ; if ( instr ( formula , "^" ) ) { return true ; } return false ; } private static boolean instr ( String matchin , String matchon ) { int lenmatchin = matchin . length ( ) ; int lenmatchon = matchon . length ( ) ; int pos = 0 ; if ( lenmatchon > lenmatchin ) { return false ; } while ( pos + lenmatchon < lenmatchin ) { String sub = matchin . substring ( pos , pos + lenmatchon ) ; if ( sub . equals ( matchon ) ) { return true ; } pos ++ ; } return false ; } private static int getLoc ( String matchin , char matchon ) { int retval = - 1 ; for ( int pos = 0 ; pos < matchin . length ( ) ; pos ++ ) { if ( matchin . charAt ( pos ) == matchon ) { retval = pos ; break ; } } return retval ; } } 	0	['20', '1', '0', '8', '39', '190', '1', '7', '13', '2', '433', '0', '0', '0', '0.2', '0', '0', '20.65', '6', '1.7', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ShortField implements FixedField { private short _value ; private final int _offset ; public ShortField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public ShortField ( final int offset , final short value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public ShortField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ShortField ( final int offset , final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public short get ( ) { return _value ; } public void set ( final short value ) { _value = value ; } public void set ( final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getShort ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readShort ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putShort ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '5', '21', '9', '2', '3', '11', '0.25', '92', '1', '0', '0', '0.454545455', '0', '0', '7.181818182', '1', '0.6364', '0']
package org . apache . poi . poifs . common ; public interface POIFSConstants { public static final int BIG_BLOCK_SIZE = 0x0200 ; public static final int END_OF_CHAIN = - 2 ; public static final int PROPERTY_SIZE = 0x0080 ; public static final int UNUSED_BLOCK = - 1 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . poifs . property ; public interface Child { public Child getNextChild ( ) ; public Child getPreviousChild ( ) ; public void setNextChild ( final Child child ) ; public void setPreviousChild ( final Child child ) ; } 	0	['4', '1', '0', '3', '4', '6', '3', '0', '4', '2', '4', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . record ; public class RecordFormatException extends RuntimeException { public RecordFormatException ( String exception ) { super ( exception ) ; } } 	0	['1', '4', '0', '99', '2', '0', '99', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . poi . poifs . property ; import java . util . * ; import java . io . IOException ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; public class RootProperty extends DirectoryProperty { RootProperty ( ) { super ( "Root Entry" ) ; setNodeColor ( _NODE_BLACK ) ; setPropertyType ( PropertyConstants . ROOT_TYPE ) ; setStartBlock ( POIFSConstants . END_OF_CHAIN ) ; } protected RootProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; } public void setSize ( int size ) { super . setSize ( SmallDocumentBlock . calcSize ( size ) ) ; } } 	0	['3', '3', '0', '8', '10', '3', '6', '2', '1', '2', '27', '0', '0', '0.971428571', '0.666666667', '1', '1', '8', '1', '0.3333', '0']
package org . apache . poi . poifs . storage ; import java . util . * ; public class SmallDocumentBlockList extends BlockListImpl { public SmallDocumentBlockList ( final List blocks ) { setBlocks ( ( SmallDocumentBlock [ ] ) blocks . toArray ( new SmallDocumentBlock [ 0 ] ) ) ; } } 	0	['5', '2', '0', '5', '12', '10', '1', '4', '5', '2', '32', '0', '0', '0.555555556', '0.5', '0', '0', '5.4', '1', '0.8', '0']
package org . apache . poi . hpsf . littleendian ; public abstract class LittleEndian { protected byte [ ] bytes ; public LittleEndian ( final byte [ ] src , final int offset ) { read ( src , offset ) ; } public byte [ ] getBytes ( ) { return bytes ; } public byte [ ] read ( final byte [ ] src , final int offset ) { final int length = length ( ) ; bytes = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) bytes [ i ] = src [ offset + length - 1 - i ] ; return bytes ; } public abstract int length ( ) ; } 	0	['4', '1', '4', '4', '5', '4', '4', '0', '4', '0.333333333', '46', '1', '0', '0', '0.666666667', '0', '0', '10.25', '2', '1', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; public class DocumentInputStream extends InputStream { private int _current_offset ; private int _marked_offset ; private int _document_size ; private boolean _closed ; private POIFSDocument _document ; private byte [ ] _tiny_buffer ; static private final int EOD = - 1 ; public DocumentInputStream ( final DocumentEntry document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; if ( document instanceof DocumentNode ) { _document = ( ( DocumentNode ) document ) . getDocument ( ) ; } else { throw new IOException ( "Cannot open internal document storage" ) ; } } public DocumentInputStream ( final POIFSDocument document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; _document = document ; } public int available ( ) throws IOException { dieIfClosed ( ) ; return _document_size - _current_offset ; } public void close ( ) throws IOException { _closed = true ; } public void mark ( int ignoredReadlimit ) { _marked_offset = _current_offset ; } public boolean markSupported ( ) { return true ; } public int read ( ) throws IOException { dieIfClosed ( ) ; if ( atEOD ( ) ) { return EOD ; } if ( _tiny_buffer == null ) { _tiny_buffer = new byte [ 1 ] ; } _document . read ( _tiny_buffer , _current_offset ++ ) ; return ( ( int ) _tiny_buffer [ 0 ] ) & 0x000000FF ; } public int read ( final byte [ ] b ) throws IOException , NullPointerException { return read ( b , 0 , b . length ) ; } public int read ( final byte [ ] b , final int off , final int len ) throws IOException , NullPointerException , IndexOutOfBoundsException { dieIfClosed ( ) ; if ( b == null ) { throw new NullPointerException ( "buffer is null" ) ; } if ( ( off < 0 ) || ( len < 0 ) || ( b . length < ( off + len ) ) ) { throw new IndexOutOfBoundsException ( "can't read past buffer boundaries" ) ; } if ( len == 0 ) { return 0 ; } if ( atEOD ( ) ) { return EOD ; } int limit = Math . min ( available ( ) , len ) ; if ( ( off == 0 ) && ( limit == b . length ) ) { _document . read ( b , _current_offset ) ; } else { byte [ ] buffer = new byte [ limit ] ; _document . read ( buffer , _current_offset ) ; System . arraycopy ( buffer , 0 , b , off , limit ) ; } _current_offset += limit ; return limit ; } public void reset ( ) { _current_offset = _marked_offset ; } public long skip ( final long n ) throws IOException { dieIfClosed ( ) ; if ( n < 0 ) { return 0 ; } int new_offset = _current_offset + ( int ) n ; if ( new_offset < _current_offset ) { new_offset = _document_size ; } else if ( new_offset > _document_size ) { new_offset = _document_size ; } long rval = new_offset - _current_offset ; _current_offset = new_offset ; return rval ; } private void dieIfClosed ( ) throws IOException { if ( _closed ) { throw new IOException ( "cannot perform requested operation on a closed stream" ) ; } } private boolean atEOD ( ) { return _current_offset == _document_size ; } } 	0	['13', '2', '0', '13', '23', '0', '10', '3', '11', '0.642857143', '271', '1', '1', '0.45', '0.256410256', '1', '2', '19.30769231', '2', '0.9231', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BackupRecord extends Record { public final static short sid = 0x40 ; private short field_1_backup ; public BackupRecord ( ) { } public BackupRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BackupRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BACKUP RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_backup = LittleEndian . getShort ( data , 0 + offset ) ; } public void setBackup ( short backup ) { field_1_backup = backup ; } public short getBackup ( ) { return field_1_backup ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BACKUP]\n" ) ; buffer . append ( "    .backup          = " ) . append ( Integer . toHexString ( getBackup ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BACKUP]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getBackup ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '6', '21', '49', '3', '3', '9', '0.85', '106', '0.5', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BeginRecord extends Record { public static final short sid = 0x1033 ; public BeginRecord ( ) { } public BeginRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BeginRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BEGIN RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BEGIN]\n" ) ; buffer . append ( "[/BEGIN]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	0	['9', '2', '0', '4', '17', '36', '1', '3', '7', '1.125', '72', '0', '0', '0.647058824', '0.555555556', '1', '6', '6.888888889', '2', '0.7778', '0']
package org . apache . poi . poifs . property ; import java . util . Iterator ; import java . io . IOException ; public interface Parent extends Child { public Iterator getChildren ( ) ; public void addChild ( final Property property ) throws IOException ; public void setPreviousChild ( final Child child ) ; public void setNextChild ( final Child child ) ; } 	0	['4', '1', '0', '3', '4', '6', '1', '2', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . eventfilesystem ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; public class POIFSReaderEvent { private DocumentInputStream stream ; private POIFSDocumentPath path ; private String documentName ; POIFSReaderEvent ( final DocumentInputStream stream , final POIFSDocumentPath path , final String documentName ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; } public DocumentInputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } } 	0	['4', '1', '0', '5', '5', '0', '3', '2', '3', '0.666666667', '28', '1', '2', '0', '0.4375', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . poi . poifs . property ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . PropertyBlock ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . RawDataBlockList ; public class PropertyTable implements BATManaged , BlockWritable { private int _start_block ; private List _properties ; private BlockWritable [ ] _blocks ; public PropertyTable ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _properties = new ArrayList ( ) ; addProperty ( new RootProperty ( ) ) ; _blocks = null ; } public PropertyTable ( final int startBlock , final RawDataBlockList blockList ) throws IOException { _start_block = POIFSConstants . END_OF_CHAIN ; _blocks = null ; _properties = PropertyFactory . convertToProperties ( blockList . fetchBlocks ( startBlock ) ) ; populatePropertyTree ( ( DirectoryProperty ) _properties . get ( 0 ) ) ; } public void addProperty ( final Property property ) { _properties . add ( property ) ; } public void removeProperty ( final Property property ) { _properties . remove ( property ) ; } public RootProperty getRoot ( ) { return ( RootProperty ) _properties . get ( 0 ) ; } public void preWrite ( ) { Property [ ] properties = ( Property [ ] ) _properties . toArray ( new Property [ 0 ] ) ; for ( int k = 0 ; k < properties . length ; k ++ ) { properties [ k ] . setIndex ( k ) ; } _blocks = PropertyBlock . createPropertyBlockArray ( _properties ) ; for ( int k = 0 ; k < properties . length ; k ++ ) { properties [ k ] . preWrite ( ) ; } } public int getStartBlock ( ) { return _start_block ; } private void populatePropertyTree ( DirectoryProperty root ) throws IOException { int index = root . getChildIndex ( ) ; if ( ! Property . isValidIndex ( index ) ) { return ; } Stack children = new Stack ( ) ; children . push ( _properties . get ( index ) ) ; while ( ! children . empty ( ) ) { Property property = ( Property ) children . pop ( ) ; root . addChild ( property ) ; if ( property . isDirectory ( ) ) { populatePropertyTree ( ( DirectoryProperty ) property ) ; } index = property . getPreviousChildIndex ( ) ; if ( Property . isValidIndex ( index ) ) { children . push ( _properties . get ( index ) ) ; } index = property . getNextChildIndex ( ) ; if ( Property . isValidIndex ( index ) ) { children . push ( _properties . get ( index ) ) ; } } } public int countBlocks ( ) { return ( _blocks == null ) ? 0 : _blocks . length ; } public void setStartBlock ( final int index ) { _start_block = index ; } public void writeBlocks ( final OutputStream stream ) throws IOException { if ( _blocks != null ) { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } } } 	0	['11', '1', '0', '11', '34', '0', '2', '9', '10', '0.566666667', '210', '1', '1', '0', '0.272727273', '0', '0', '17.81818182', '3', '1.0909', '0']
package org . apache . poi . hssf . usermodel ; public interface HSSFColorConstants { public final static short AUTOMATIC = 0x40 ; public final static short BLACK = 0x8 ; public final static short BROWN = 0x3c ; public final static short OLIVE_GREEN = 0x3b ; public final static short DARK_GREEN = 0x3a ; public final static short DARK_TEAL = 0x38 ; public final static short DARK_BLUE = 0x12 ; public final static short INDIGO = 0x3e ; public final static short GREY_80_PERCENT = 0x3f ; public final static short DARK_RED = 0x10 ; public final static short ORANGE = 0x35 ; public final static short DARK_YELLOW = 0x13 ; public final static short GREEN = 0x11 ; public final static short TEAL = 0x15 ; public final static short BLUE = 0xc ; public final static short BLUE_GREY = 0x36 ; public final static short GREY_50_PERCENT = 0x17 ; public final static short RED = 0xa ; public final static short LIGHT_ORANGE = 0x34 ; public final static short LIME = 0x32 ; public final static short SEA_GREEN = 0x39 ; public final static short AQUA = 0x31 ; public final static short LIGHT_BLUE = 0x30 ; public final static short VIOLET = 0x14 ; public final static short GREY_40_PERCENT = 0x37 ; public final static short PINK = 0xe ; public final static short GOLD = 0x33 ; public final static short YELLOW = 0xd ; public final static short BRIGHT_GREEN = 0xb ; public final static short TURQUOISE = 0xf ; public final static short SKY_BLUE = 0x28 ; public final static short PLUM = 0x3d ; public final static short GREY_25_PERCENT = 0x16 ; public final static short ROSE = 0x2d ; public final static short TAN = 0x2f ; public final static short LIGHT_YELLOW = 0x2b ; public final static short LIGHT_GREEN = 0x2a ; public final static short LIGHT_TURQUOISE = 0x29 ; public final static short PALE_BLUE = 0x2c ; public final static short LAVENDER = 0x2e ; public final static short WHITE = 0x9 ; } 	0	['0', '1', '0', '2', '0', '0', '2', '0', '0', '2', '41', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BookBoolRecord extends Record { public final static short sid = 0xDA ; private short field_1_save_link_values ; public BookBoolRecord ( ) { } public BookBoolRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BookBoolRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOOKBOOL RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_save_link_values = LittleEndian . getShort ( data , 0 + offset ) ; } public void setSaveLinkValues ( short flag ) { field_1_save_link_values = flag ; } public short getSaveLinkValues ( ) { return field_1_save_link_values ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOOKBOOL]\n" ) ; buffer . append ( "    .savelinkvalues  = " ) . append ( Integer . toHexString ( getSaveLinkValues ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOOKBOOL]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_save_link_values ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '43', '2', '3', '9', '0.85', '106', '0.5', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; public interface ListManagedBlock { public byte [ ] getData ( ) throws IOException ; } 	0	['1', '1', '0', '13', '1', '0', '13', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private short rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , short rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { this . rowNum = rowNum ; cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( short rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public short getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	0	['24', '1', '0', '8', '51', '84', '3', '5', '16', '0.673913043', '451', '0.833333333', '3', '0', '0.183333333', '0', '0', '17.54166667', '5', '1.7083', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DocumentProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . ListManagedBlock ; import org . apache . poi . poifs . storage . DocumentBlock ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; import org . apache . poi . util . HexDump ; public class POIFSDocument implements BATManaged , BlockWritable , POIFSViewable { private DocumentProperty _property ; private int _size ; private SmallBlockStore _small_store ; private BigBlockStore _big_store ; public POIFSDocument ( final String name , final RawDataBlock [ ] blocks , final int length ) throws IOException { _size = length ; _big_store = new BigBlockStore ( blocks ) ; _property = new DocumentProperty ( name , _size ) ; _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; _property . setDocument ( this ) ; } public POIFSDocument ( final String name , final SmallDocumentBlock [ ] blocks , final int length ) { _size = length ; try { _big_store = new BigBlockStore ( new RawDataBlock [ 0 ] ) ; } catch ( IOException ignored ) { } _property = new DocumentProperty ( name , _size ) ; _small_store = new SmallBlockStore ( blocks ) ; _property . setDocument ( this ) ; } public POIFSDocument ( final String name , final ListManagedBlock [ ] blocks , final int length ) throws IOException { _size = length ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( Property . isSmall ( _size ) ) { _big_store = new BigBlockStore ( new RawDataBlock [ 0 ] ) ; _small_store = new SmallBlockStore ( blocks ) ; } else { _big_store = new BigBlockStore ( blocks ) ; _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; } } public POIFSDocument ( final String name , final InputStream stream ) throws IOException { List blocks = new ArrayList ( ) ; _size = 0 ; while ( true ) { DocumentBlock block = new DocumentBlock ( stream ) ; int blockSize = block . size ( ) ; if ( blockSize > 0 ) { blocks . add ( block ) ; _size += blockSize ; } if ( block . partiallyRead ( ) ) { break ; } } DocumentBlock [ ] bigBlocks = ( DocumentBlock [ ] ) blocks . toArray ( new DocumentBlock [ 0 ] ) ; _big_store = new BigBlockStore ( bigBlocks ) ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( _property . shouldUseSmallBlocks ( ) ) { _small_store = new SmallBlockStore ( SmallDocumentBlock . convert ( bigBlocks , _size ) ) ; _big_store = new BigBlockStore ( new DocumentBlock [ 0 ] ) ; } else { _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; } } public POIFSDocument ( final String name , final int size , final POIFSDocumentPath path , final POIFSWriterListener writer ) throws IOException { _size = size ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( _property . shouldUseSmallBlocks ( ) ) { _small_store = new SmallBlockStore ( path , name , size , writer ) ; _big_store = new BigBlockStore ( new Object [ 0 ] ) ; } else { _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; _big_store = new BigBlockStore ( path , name , size , writer ) ; } } public BlockWritable [ ] getSmallBlocks ( ) { return _small_store . getBlocks ( ) ; } public int getSize ( ) { return _size ; } void read ( final byte [ ] buffer , final int offset ) { if ( _property . shouldUseSmallBlocks ( ) ) { SmallDocumentBlock . read ( _small_store . getBlocks ( ) , buffer , offset ) ; } else { DocumentBlock . read ( _big_store . getBlocks ( ) , buffer , offset ) ; } } DocumentProperty getDocumentProperty ( ) { return _property ; } public void writeBlocks ( final OutputStream stream ) throws IOException { _big_store . writeBlocks ( stream ) ; } public int countBlocks ( ) { return _big_store . countBlocks ( ) ; } public void setStartBlock ( final int index ) { _property . setStartBlock ( index ) ; } public Object [ ] getViewableArray ( ) { Object [ ] results = new Object [ 1 ] ; String result ; try { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; BlockWritable [ ] blocks = null ; if ( _big_store . isValid ( ) ) { blocks = _big_store . getBlocks ( ) ; } else if ( _small_store . isValid ( ) ) { blocks = _small_store . getBlocks ( ) ; } if ( blocks != null ) { for ( int k = 0 ; k < blocks . length ; k ++ ) { blocks [ k ] . writeBlocks ( output ) ; } byte [ ] data = output . toByteArray ( ) ; if ( data . length > _property . getSize ( ) ) { byte [ ] tmp = new byte [ _property . getSize ( ) ] ; System . arraycopy ( data , 0 , tmp , 0 , tmp . length ) ; data = tmp ; } output = new ByteArrayOutputStream ( ) ; HexDump . dump ( data , 0 , output , 0 ) ; result = output . toString ( ) ; } else { result = "<NO DATA>" ; } } catch ( IOException e ) { result = e . getMessage ( ) ; } results [ 0 ] = result ; return results ; } public Iterator getViewableIterator ( ) { return Collections . EMPTY_LIST . iterator ( ) ; } public boolean preferArray ( ) { return true ; } public String getShortDescription ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Document: \"" ) . append ( _property . getName ( ) ) . append ( "\"" ) ; buffer . append ( " size = " ) . append ( getSize ( ) ) ; return buffer . toString ( ) ; } private class SmallBlockStore { private SmallDocumentBlock [ ] smallBlocks ; private POIFSDocumentPath path ; private String name ; private int size ; private POIFSWriterListener writer ; SmallBlockStore ( final Object [ ] blocks ) { smallBlocks = new SmallDocumentBlock [ blocks . length ] ; for ( int j = 0 ; j < blocks . length ; j ++ ) { smallBlocks [ j ] = ( SmallDocumentBlock ) blocks [ j ] ; } this . path = null ; this . name = null ; this . size = - 1 ; this . writer = null ; } SmallBlockStore ( final POIFSDocumentPath path , final String name , final int size , final POIFSWriterListener writer ) { smallBlocks = new SmallDocumentBlock [ 0 ] ; this . path = path ; this . name = name ; this . size = size ; this . writer = writer ; } boolean isValid ( ) { return ( ( smallBlocks . length > 0 ) || ( writer != null ) ) ; } BlockWritable [ ] getBlocks ( ) { if ( isValid ( ) && ( writer != null ) ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( size ) ; DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; smallBlocks = SmallDocumentBlock . convert ( stream . toByteArray ( ) , size ) ; } return smallBlocks ; } } private class BigBlockStore { private DocumentBlock [ ] bigBlocks ; private POIFSDocumentPath path ; private String name ; private int size ; private POIFSWriterListener writer ; BigBlockStore ( final Object [ ] blocks ) throws IOException { bigBlocks = new DocumentBlock [ blocks . length ] ; for ( int j = 0 ; j < blocks . length ; j ++ ) { if ( blocks [ j ] instanceof DocumentBlock ) { bigBlocks [ j ] = ( DocumentBlock ) blocks [ j ] ; } else { bigBlocks [ j ] = new DocumentBlock ( ( RawDataBlock ) blocks [ j ] ) ; } } this . path = null ; this . name = null ; this . size = - 1 ; this . writer = null ; } BigBlockStore ( final POIFSDocumentPath path , final String name , final int size , final POIFSWriterListener writer ) { bigBlocks = new DocumentBlock [ 0 ] ; this . path = path ; this . name = name ; this . size = size ; this . writer = writer ; } boolean isValid ( ) { return ( ( bigBlocks . length > 0 ) || ( writer != null ) ) ; } DocumentBlock [ ] getBlocks ( ) { if ( isValid ( ) && ( writer != null ) ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( size ) ; DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; bigBlocks = DocumentBlock . convert ( stream . toByteArray ( ) , size ) ; } return bigBlocks ; } void writeBlocks ( OutputStream stream ) throws IOException { if ( isValid ( ) ) { if ( writer != null ) { DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; dstream . writeFiller ( countBlocks ( ) * POIFSConstants . BIG_BLOCK_SIZE , DocumentBlock . getFillByte ( ) ) ; } else { for ( int k = 0 ; k < bigBlocks . length ; k ++ ) { bigBlocks [ k ] . writeBlocks ( stream ) ; } } } } int countBlocks ( ) { int rval = 0 ; if ( isValid ( ) ) { if ( writer != null ) { rval = ( size + POIFSConstants . BIG_BLOCK_SIZE - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ; } else { rval = bigBlocks . length ; } } return rval ; } } } 	0	['16', '1', '0', '20', '55', '0', '9', '14', '14', '0.5', '453', '1', '3', '0', '0.198863636', '0', '0', '27.0625', '6', '1.0625', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class InterfaceEndRecord extends Record { public final static short sid = 0xe2 ; public InterfaceEndRecord ( ) { } public InterfaceEndRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public InterfaceEndRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A INTERFACEEND RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[INTERFACEEND]\n" ) ; buffer . append ( "[/INTERFACEEND]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x00 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	0	['9', '2', '0', '5', '17', '36', '2', '3', '7', '1.125', '72', '0', '0', '0.647058824', '0.555555556', '1', '6', '6.888888889', '2', '0.7778', '0']
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import java . util . * ; public class POILogger { private Log log = null ; public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( final Log log ) { this . log = log ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final Log log , final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( log , level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( log , level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	0	['25', '1', '0', '7', '53', '28', '5', '2', '21', '0.895833333', '840', '0.166666667', '0', '0', '0.485714286', '0', '0', '32.36', '12', '2.84', '0']
package org . apache . poi . poifs . filesystem ; public interface Entry { public String getName ( ) ; public boolean isDirectoryEntry ( ) ; public boolean isDocumentEntry ( ) ; public DirectoryEntry getParent ( ) ; public boolean delete ( ) ; public boolean renameTo ( final String newName ) ; } 	0	['6', '1', '0', '5', '6', '15', '5', '1', '6', '2', '6', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . filesystem ; public interface BATManaged { public int countBlocks ( ) ; public void setStartBlock ( final int index ) ; } 	0	['2', '1', '0', '5', '2', '1', '5', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hpsf . littleendian ; import java . io . * ; public class ClassID extends LittleEndian { public ClassID ( final byte [ ] src , final int offset ) { super ( src , offset ) ; } public final static int LENGTH = 16 ; public int length ( ) { return LENGTH ; } public byte [ ] read ( byte [ ] src , int offset ) { LittleEndian [ ] b = new LittleEndian [ 11 ] ; b [ 0 ] = new DWord ( src , offset ) ; b [ 1 ] = new Word ( src , offset += DWord . LENGTH ) ; b [ 2 ] = new Word ( src , offset += Word . LENGTH ) ; b [ 3 ] = new Byte ( src , offset += Word . LENGTH ) ; b [ 4 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 5 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 6 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 7 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 8 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 9 ] = new Byte ( src , offset += Byte . LENGTH ) ; b [ 10 ] = new Byte ( src , offset += Byte . LENGTH ) ; int capacity = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) capacity += b [ i ] . getBytes ( ) . length ; bytes = new byte [ capacity ] ; int pos = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) { byte [ ] s = b [ i ] . getBytes ( ) ; for ( int j = 0 ; j < s . length ; j ++ ) bytes [ pos ++ ] = s [ j ] ; } return bytes ; } } 	0	['3', '2', '0', '7', '8', '3', '3', '4', '3', '1.5', '168', '0', '0', '0.6', '0.777777778', '1', '4', '54.66666667', '4', '1.6667', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class MMSRecord extends Record { public final static short sid = 0xC1 ; private byte field_1_addMenuCount ; private byte field_2_delMenuCount ; public MMSRecord ( ) { } public MMSRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public MMSRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A MMS RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_addMenuCount = data [ 0 + offset ] ; field_2_delMenuCount = data [ 1 + offset ] ; } public void setAddMenuCount ( byte am ) { field_1_addMenuCount = am ; } public void setDelMenuCount ( byte dm ) { field_2_delMenuCount = dm ; } public byte getAddMenuCount ( ) { return field_1_addMenuCount ; } public byte getDelMenuCount ( ) { return field_2_delMenuCount ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[MMS]\n" ) ; buffer . append ( "    .addMenu        = " ) . append ( Integer . toHexString ( getAddMenuCount ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .delMenu        = " ) . append ( Integer . toHexString ( getDelMenuCount ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/MMS]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; data [ 4 + offset ] = getAddMenuCount ( ) ; data [ 5 + offset ] = getDelMenuCount ( ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['13', '2', '0', '5', '22', '66', '2', '3', '11', '0.805555556', '140', '0.666666667', '0', '0.523809524', '0.4', '1', '6', '9.538461538', '2', '0.8462', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableReader { private IntList _entries ; public BlockAllocationTableReader ( final int block_count , final int [ ] block_array , final int xbat_count , final int xbat_index , final BlockList raw_block_list ) throws IOException { this ( ) ; if ( block_count <= 0 ) { throw new IOException ( "Illegal block count; minimum count is 1, got " + block_count + " instead" ) ; } RawDataBlock blocks [ ] = new RawDataBlock [ block_count ] ; int limit = Math . min ( block_count , block_array . length ) ; int block_index ; for ( block_index = 0 ; block_index < limit ; block_index ++ ) { blocks [ block_index ] = ( RawDataBlock ) raw_block_list . remove ( block_array [ block_index ] ) ; } if ( block_index < block_count ) { if ( xbat_index < 0 ) { throw new IOException ( "BAT count exceeds limit, yet XBAT index indicates no valid entries" ) ; } int chain_index = xbat_index ; int max_entries_per_block = BATBlock . entriesPerXBATBlock ( ) ; int chain_index_offset = BATBlock . getXBATChainOffset ( ) ; for ( int j = 0 ; j < xbat_count ; j ++ ) { limit = Math . min ( block_count - block_index , max_entries_per_block ) ; byte [ ] data = raw_block_list . remove ( chain_index ) . getData ( ) ; int offset = 0 ; for ( int k = 0 ; k < limit ; k ++ ) { blocks [ block_index ++ ] = ( RawDataBlock ) raw_block_list . remove ( LittleEndian . getInt ( data , offset ) ) ; offset += LittleEndianConsts . INT_SIZE ; } chain_index = LittleEndian . getInt ( data , chain_index_offset ) ; if ( chain_index == POIFSConstants . END_OF_CHAIN ) { break ; } } } if ( block_index != block_count ) { throw new IOException ( "Could not find all blocks" ) ; } setEntries ( blocks , raw_block_list ) ; } BlockAllocationTableReader ( final ListManagedBlock [ ] blocks , final BlockList raw_block_list ) throws IOException { this ( ) ; setEntries ( blocks , raw_block_list ) ; } BlockAllocationTableReader ( ) { _entries = new IntList ( ) ; } ListManagedBlock [ ] fetchBlocks ( final int startBlock , final BlockList blockList ) throws IOException { List blocks = new ArrayList ( ) ; int currentBlock = startBlock ; while ( currentBlock != POIFSConstants . END_OF_CHAIN ) { blocks . add ( blockList . remove ( currentBlock ) ) ; currentBlock = _entries . get ( currentBlock ) ; } return ( ListManagedBlock [ ] ) blocks . toArray ( new ListManagedBlock [ 0 ] ) ; } boolean isUsed ( final int index ) { boolean rval = false ; try { rval = _entries . get ( index ) != - 1 ; } catch ( IndexOutOfBoundsException ignored ) { } return rval ; } int getNextBlockIndex ( final int index ) throws IOException { if ( isUsed ( index ) ) { return _entries . get ( index ) ; } else { throw new IOException ( "index " + index + " is unused" ) ; } } private void setEntries ( final ListManagedBlock [ ] blocks , final BlockList raw_blocks ) throws IOException { int limit = BATBlock . entriesPerBlock ( ) ; for ( int block_index = 0 ; block_index < blocks . length ; block_index ++ ) { byte [ ] data = blocks [ block_index ] . getData ( ) ; int offset = 0 ; for ( int k = 0 ; k < limit ; k ++ ) { int entry = LittleEndian . getInt ( data , offset ) ; if ( entry == POIFSConstants . UNUSED_BLOCK ) { raw_blocks . zap ( _entries . size ( ) ) ; } _entries . add ( entry ) ; offset += LittleEndianConsts . INT_SIZE ; } blocks [ block_index ] = null ; } raw_blocks . setBAT ( this ) ; } } 	0	['7', '1', '0', '12', '29', '1', '7', '6', '1', '0', '257', '1', '1', '0', '0.514285714', '0', '0', '35.57142857', '2', '0.7143', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class HideObjRecord extends Record { public final static short sid = 0x8d ; public final static short HIDE_ALL = 2 ; public final static short SHOW_PLACEHOLDERS = 1 ; public final static short SHOW_ALL = 0 ; private short field_1_hide_obj ; public HideObjRecord ( ) { } public HideObjRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public HideObjRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A HIDEOBJ RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_hide_obj = LittleEndian . getShort ( data , 0 + offset ) ; } public void setHideObj ( short hide ) { field_1_hide_obj = hide ; } public short getHideObj ( ) { return field_1_hide_obj ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[HIDEOBJ]\n" ) ; buffer . append ( "    .hideobj         = " ) . append ( Integer . toHexString ( getHideObj ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/HIDEOBJ]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getHideObj ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '49', '2', '3', '9', '1', '109', '0.2', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '0']
package org . apache . poi . util ; import java . util . * ; public final class BinaryTree extends AbstractMap { private Node [ ] _root = new Node [ ] { null , null } ; private int _size = 0 ; private int _modifications = 0 ; private Set [ ] _key_set = new Set [ ] { null , null } ; private Set [ ] _entry_set = new Set [ ] { null , null } ; private Collection [ ] _value_collection = new Collection [ ] { null , null } ; private static final int _KEY = 0 ; private static final int _VALUE = 1 ; private static final int _INDEX_SUM = _KEY + _VALUE ; private static final int _MINIMUM_INDEX = 0 ; private static final int _INDEX_COUNT = 2 ; private static final String [ ] _data_name = new String [ ] { "key" , "value" } ; public BinaryTree ( ) { } public BinaryTree ( final Map map ) throws ClassCastException , NullPointerException , IllegalArgumentException { putAll ( map ) ; } public Object getKeyForValue ( final Object value ) throws ClassCastException , NullPointerException { return doGet ( ( Comparable ) value , _VALUE ) ; } public Object removeValue ( final Object value ) { return doRemove ( ( Comparable ) value , _VALUE ) ; } public Set entrySetByValue ( ) { if ( _entry_set [ _VALUE ] == null ) { _entry_set [ _VALUE ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node ; } } ; } public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object key = entry . getKey ( ) ; Node node = lookup ( ( Comparable ) entry . getValue ( ) , _VALUE ) ; return ( node != null ) && node . getData ( _KEY ) . equals ( key ) ; } public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object key = entry . getKey ( ) ; Node node = lookup ( ( Comparable ) entry . getValue ( ) , _VALUE ) ; if ( ( node != null ) && node . getData ( _KEY ) . equals ( key ) ) { doRedBlackDelete ( node ) ; return true ; } return false ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _entry_set [ _VALUE ] ; } public Set keySetByValue ( ) { if ( _key_set [ _VALUE ] == null ) { _key_set [ _VALUE ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _KEY ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsKey ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; BinaryTree . this . remove ( o ) ; return _size != old_size ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _key_set [ _VALUE ] ; } public Collection valuesByValue ( ) { if ( _value_collection [ _VALUE ] == null ) { _value_collection [ _VALUE ] = new AbstractCollection ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _VALUE ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsValue ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; removeValue ( o ) ; return _size != old_size ; } public boolean removeAll ( Collection c ) { boolean modified = false ; Iterator iter = c . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( removeValue ( iter . next ( ) ) != null ) { modified = true ; } } return modified ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _value_collection [ _VALUE ] ; } private Object doRemove ( final Comparable o , final int index ) { Node node = lookup ( o , index ) ; Object rval = null ; if ( node != null ) { rval = node . getData ( oppositeIndex ( index ) ) ; doRedBlackDelete ( node ) ; } return rval ; } private Object doGet ( final Comparable o , final int index ) { checkNonNullComparable ( o , index ) ; Node node = lookup ( o , index ) ; return ( ( node == null ) ? null : node . getData ( oppositeIndex ( index ) ) ) ; } private int oppositeIndex ( final int index ) { return _INDEX_SUM - index ; } private Node lookup ( final Comparable data , final int index ) { Node rval = null ; Node node = _root [ index ] ; while ( node != null ) { int cmp = compare ( data , node . getData ( index ) ) ; if ( cmp == 0 ) { rval = node ; break ; } else { node = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; } } return rval ; } private static int compare ( final Comparable o1 , final Comparable o2 ) { return ( ( Comparable ) o1 ) . compareTo ( o2 ) ; } private static Node leastNode ( final Node node , final int index ) { Node rval = node ; if ( rval != null ) { while ( rval . getLeft ( index ) != null ) { rval = rval . getLeft ( index ) ; } } return rval ; } private Node nextGreater ( final Node node , final int index ) { Node rval = null ; if ( node == null ) { rval = null ; } else if ( node . getRight ( index ) != null ) { rval = leastNode ( node . getRight ( index ) , index ) ; } else { Node parent = node . getParent ( index ) ; Node child = node ; while ( ( parent != null ) && ( child == parent . getRight ( index ) ) ) { child = parent ; parent = parent . getParent ( index ) ; } rval = parent ; } return rval ; } private static void copyColor ( final Node from , final Node to , final int index ) { if ( to != null ) { if ( from == null ) { to . setBlack ( index ) ; } else { to . copyColor ( from , index ) ; } } } private static boolean isRed ( final Node node , final int index ) { return ( ( node == null ) ? false : node . isRed ( index ) ) ; } private static boolean isBlack ( final Node node , final int index ) { return ( ( node == null ) ? true : node . isBlack ( index ) ) ; } private static void makeRed ( final Node node , final int index ) { if ( node != null ) { node . setRed ( index ) ; } } private static void makeBlack ( final Node node , final int index ) { if ( node != null ) { node . setBlack ( index ) ; } } private static Node getGrandParent ( final Node node , final int index ) { return getParent ( getParent ( node , index ) , index ) ; } private static Node getParent ( final Node node , final int index ) { return ( ( node == null ) ? null : node . getParent ( index ) ) ; } private static Node getRightChild ( final Node node , final int index ) { return ( node == null ) ? null : node . getRight ( index ) ; } private static Node getLeftChild ( final Node node , final int index ) { return ( node == null ) ? null : node . getLeft ( index ) ; } private static boolean isLeftChild ( final Node node , final int index ) { return ( node == null ) ? true : ( ( node . getParent ( index ) == null ) ? false : ( node == node . getParent ( index ) . getLeft ( index ) ) ) ; } private static boolean isRightChild ( final Node node , final int index ) { return ( node == null ) ? true : ( ( node . getParent ( index ) == null ) ? false : ( node == node . getParent ( index ) . getRight ( index ) ) ) ; } private void rotateLeft ( final Node node , final int index ) { Node right_child = node . getRight ( index ) ; node . setRight ( right_child . getLeft ( index ) , index ) ; if ( right_child . getLeft ( index ) != null ) { right_child . getLeft ( index ) . setParent ( node , index ) ; } right_child . setParent ( node . getParent ( index ) , index ) ; if ( node . getParent ( index ) == null ) { _root [ index ] = right_child ; } else if ( node . getParent ( index ) . getLeft ( index ) == node ) { node . getParent ( index ) . setLeft ( right_child , index ) ; } else { node . getParent ( index ) . setRight ( right_child , index ) ; } right_child . setLeft ( node , index ) ; node . setParent ( right_child , index ) ; } private void rotateRight ( final Node node , final int index ) { Node left_child = node . getLeft ( index ) ; node . setLeft ( left_child . getRight ( index ) , index ) ; if ( left_child . getRight ( index ) != null ) { left_child . getRight ( index ) . setParent ( node , index ) ; } left_child . setParent ( node . getParent ( index ) , index ) ; if ( node . getParent ( index ) == null ) { _root [ index ] = left_child ; } else if ( node . getParent ( index ) . getRight ( index ) == node ) { node . getParent ( index ) . setRight ( left_child , index ) ; } else { node . getParent ( index ) . setLeft ( left_child , index ) ; } left_child . setRight ( node , index ) ; node . setParent ( left_child , index ) ; } private void doRedBlackInsert ( final Node inserted_node , final int index ) { Node current_node = inserted_node ; makeRed ( current_node , index ) ; while ( ( current_node != null ) && ( current_node != _root [ index ] ) && ( isRed ( current_node . getParent ( index ) , index ) ) ) { if ( isLeftChild ( getParent ( current_node , index ) , index ) ) { Node y = getRightChild ( getGrandParent ( current_node , index ) , index ) ; if ( isRed ( y , index ) ) { makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( y , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; current_node = getGrandParent ( current_node , index ) ; } else { if ( isRightChild ( current_node , index ) ) { current_node = getParent ( current_node , index ) ; rotateLeft ( current_node , index ) ; } makeBlack ( getParent ( current_node , index ) , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; if ( getGrandParent ( current_node , index ) != null ) { rotateRight ( getGrandParent ( current_node , index ) , index ) ; } } } else { Node y = getLeftChild ( getGrandParent ( current_node , index ) , index ) ; if ( isRed ( y , index ) ) { makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( y , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; current_node = getGrandParent ( current_node , index ) ; } else { if ( isLeftChild ( current_node , index ) ) { current_node = getParent ( current_node , index ) ; rotateRight ( current_node , index ) ; } makeBlack ( getParent ( current_node , index ) , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; if ( getGrandParent ( current_node , index ) != null ) { rotateLeft ( getGrandParent ( current_node , index ) , index ) ; } } } } makeBlack ( _root [ index ] , index ) ; } private void doRedBlackDelete ( final Node deleted_node ) { for ( int index = _MINIMUM_INDEX ; index < _INDEX_COUNT ; index ++ ) { if ( ( deleted_node . getLeft ( index ) != null ) && ( deleted_node . getRight ( index ) != null ) ) { swapPosition ( nextGreater ( deleted_node , index ) , deleted_node , index ) ; } Node replacement = ( ( deleted_node . getLeft ( index ) != null ) ? deleted_node . getLeft ( index ) : deleted_node . getRight ( index ) ) ; if ( replacement != null ) { replacement . setParent ( deleted_node . getParent ( index ) , index ) ; if ( deleted_node . getParent ( index ) == null ) { _root [ index ] = replacement ; } else if ( deleted_node == deleted_node . getParent ( index ) . getLeft ( index ) ) { deleted_node . getParent ( index ) . setLeft ( replacement , index ) ; } else { deleted_node . getParent ( index ) . setRight ( replacement , index ) ; } deleted_node . setLeft ( null , index ) ; deleted_node . setRight ( null , index ) ; deleted_node . setParent ( null , index ) ; if ( isBlack ( deleted_node , index ) ) { doRedBlackDeleteFixup ( replacement , index ) ; } } else { if ( deleted_node . getParent ( index ) == null ) { _root [ index ] = null ; } else { if ( isBlack ( deleted_node , index ) ) { doRedBlackDeleteFixup ( deleted_node , index ) ; } if ( deleted_node . getParent ( index ) != null ) { if ( deleted_node == deleted_node . getParent ( index ) . getLeft ( index ) ) { deleted_node . getParent ( index ) . setLeft ( null , index ) ; } else { deleted_node . getParent ( index ) . setRight ( null , index ) ; } deleted_node . setParent ( null , index ) ; } } } } shrink ( ) ; } private void doRedBlackDeleteFixup ( final Node replacement_node , final int index ) { Node current_node = replacement_node ; while ( ( current_node != _root [ index ] ) && ( isBlack ( current_node , index ) ) ) { if ( isLeftChild ( current_node , index ) ) { Node sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; if ( isRed ( sibling_node , index ) ) { makeBlack ( sibling_node , index ) ; makeRed ( getParent ( current_node , index ) , index ) ; rotateLeft ( getParent ( current_node , index ) , index ) ; sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; } if ( isBlack ( getLeftChild ( sibling_node , index ) , index ) && isBlack ( getRightChild ( sibling_node , index ) , index ) ) { makeRed ( sibling_node , index ) ; current_node = getParent ( current_node , index ) ; } else { if ( isBlack ( getRightChild ( sibling_node , index ) , index ) ) { makeBlack ( getLeftChild ( sibling_node , index ) , index ) ; makeRed ( sibling_node , index ) ; rotateRight ( sibling_node , index ) ; sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; } copyColor ( getParent ( current_node , index ) , sibling_node , index ) ; makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( getRightChild ( sibling_node , index ) , index ) ; rotateLeft ( getParent ( current_node , index ) , index ) ; current_node = _root [ index ] ; } } else { Node sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; if ( isRed ( sibling_node , index ) ) { makeBlack ( sibling_node , index ) ; makeRed ( getParent ( current_node , index ) , index ) ; rotateRight ( getParent ( current_node , index ) , index ) ; sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; } if ( isBlack ( getRightChild ( sibling_node , index ) , index ) && isBlack ( getLeftChild ( sibling_node , index ) , index ) ) { makeRed ( sibling_node , index ) ; current_node = getParent ( current_node , index ) ; } else { if ( isBlack ( getLeftChild ( sibling_node , index ) , index ) ) { makeBlack ( getRightChild ( sibling_node , index ) , index ) ; makeRed ( sibling_node , index ) ; rotateLeft ( sibling_node , index ) ; sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; } copyColor ( getParent ( current_node , index ) , sibling_node , index ) ; makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( getLeftChild ( sibling_node , index ) , index ) ; rotateRight ( getParent ( current_node , index ) , index ) ; current_node = _root [ index ] ; } } } makeBlack ( current_node , index ) ; } private void swapPosition ( final Node x , final Node y , final int index ) { Node x_old_parent = x . getParent ( index ) ; Node x_old_left_child = x . getLeft ( index ) ; Node x_old_right_child = x . getRight ( index ) ; Node y_old_parent = y . getParent ( index ) ; Node y_old_left_child = y . getLeft ( index ) ; Node y_old_right_child = y . getRight ( index ) ; boolean x_was_left_child = ( x . getParent ( index ) != null ) && ( x == x . getParent ( index ) . getLeft ( index ) ) ; boolean y_was_left_child = ( y . getParent ( index ) != null ) && ( y == y . getParent ( index ) . getLeft ( index ) ) ; if ( x == y_old_parent ) { x . setParent ( y , index ) ; if ( y_was_left_child ) { y . setLeft ( x , index ) ; y . setRight ( x_old_right_child , index ) ; } else { y . setRight ( x , index ) ; y . setLeft ( x_old_left_child , index ) ; } } else { x . setParent ( y_old_parent , index ) ; if ( y_old_parent != null ) { if ( y_was_left_child ) { y_old_parent . setLeft ( x , index ) ; } else { y_old_parent . setRight ( x , index ) ; } } y . setLeft ( x_old_left_child , index ) ; y . setRight ( x_old_right_child , index ) ; } if ( y == x_old_parent ) { y . setParent ( x , index ) ; if ( x_was_left_child ) { x . setLeft ( y , index ) ; x . setRight ( y_old_right_child , index ) ; } else { x . setRight ( y , index ) ; x . setLeft ( y_old_left_child , index ) ; } } else { y . setParent ( x_old_parent , index ) ; if ( x_old_parent != null ) { if ( x_was_left_child ) { x_old_parent . setLeft ( y , index ) ; } else { x_old_parent . setRight ( y , index ) ; } } x . setLeft ( y_old_left_child , index ) ; x . setRight ( y_old_right_child , index ) ; } if ( x . getLeft ( index ) != null ) { x . getLeft ( index ) . setParent ( x , index ) ; } if ( x . getRight ( index ) != null ) { x . getRight ( index ) . setParent ( x , index ) ; } if ( y . getLeft ( index ) != null ) { y . getLeft ( index ) . setParent ( y , index ) ; } if ( y . getRight ( index ) != null ) { y . getRight ( index ) . setParent ( y , index ) ; } x . swapColors ( y , index ) ; if ( _root [ index ] == x ) { _root [ index ] = y ; } else if ( _root [ index ] == y ) { _root [ index ] = x ; } } private static void checkNonNullComparable ( final Object o , final int index ) { if ( o == null ) { throw new NullPointerException ( _data_name [ index ] + " cannot be null" ) ; } if ( ! ( o instanceof Comparable ) ) { throw new ClassCastException ( _data_name [ index ] + " must be Comparable" ) ; } } private static void checkKey ( final Object key ) { checkNonNullComparable ( key , _KEY ) ; } private static void checkValue ( final Object value ) { checkNonNullComparable ( value , _VALUE ) ; } private static void checkKeyAndValue ( final Object key , final Object value ) { checkKey ( key ) ; checkValue ( value ) ; } private void modify ( ) { _modifications ++ ; } private void grow ( ) { modify ( ) ; _size ++ ; } private void shrink ( ) { modify ( ) ; _size -- ; } private void insertValue ( final Node newNode ) throws IllegalArgumentException { Node node = _root [ _VALUE ] ; while ( true ) { int cmp = compare ( newNode . getData ( _VALUE ) , node . getData ( _VALUE ) ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( "Cannot store a duplicate value (\"" + newNode . getData ( _VALUE ) + "\") in this Map" ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( _VALUE ) != null ) { node = node . getLeft ( _VALUE ) ; } else { node . setLeft ( newNode , _VALUE ) ; newNode . setParent ( node , _VALUE ) ; doRedBlackInsert ( newNode , _VALUE ) ; break ; } } else { if ( node . getRight ( _VALUE ) != null ) { node = node . getRight ( _VALUE ) ; } else { node . setRight ( newNode , _VALUE ) ; newNode . setParent ( node , _VALUE ) ; doRedBlackInsert ( newNode , _VALUE ) ; break ; } } } } public int size ( ) { return _size ; } public boolean containsKey ( final Object key ) throws ClassCastException , NullPointerException { checkKey ( key ) ; return lookup ( ( Comparable ) key , _KEY ) != null ; } public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookup ( ( Comparable ) value , _VALUE ) != null ; } public Object get ( final Object key ) throws ClassCastException , NullPointerException { return doGet ( ( Comparable ) key , _KEY ) ; } public Object put ( final Object key , final Object value ) throws ClassCastException , NullPointerException , IllegalArgumentException { checkKeyAndValue ( key , value ) ; Node node = _root [ _KEY ] ; if ( node == null ) { Node root = new Node ( ( Comparable ) key , ( Comparable ) value ) ; _root [ _KEY ] = root ; _root [ _VALUE ] = root ; grow ( ) ; } else { while ( true ) { int cmp = compare ( ( Comparable ) key , node . getData ( _KEY ) ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( "Cannot store a duplicate key (\"" + key + "\") in this Map" ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( _KEY ) != null ) { node = node . getLeft ( _KEY ) ; } else { Node newNode = new Node ( ( Comparable ) key , ( Comparable ) value ) ; insertValue ( newNode ) ; node . setLeft ( newNode , _KEY ) ; newNode . setParent ( node , _KEY ) ; doRedBlackInsert ( newNode , _KEY ) ; grow ( ) ; break ; } } else { if ( node . getRight ( _KEY ) != null ) { node = node . getRight ( _KEY ) ; } else { Node newNode = new Node ( ( Comparable ) key , ( Comparable ) value ) ; insertValue ( newNode ) ; node . setRight ( newNode , _KEY ) ; newNode . setParent ( node , _KEY ) ; doRedBlackInsert ( newNode , _KEY ) ; grow ( ) ; break ; } } } } return null ; } public Object remove ( final Object key ) { return doRemove ( ( Comparable ) key , _KEY ) ; } public void clear ( ) { modify ( ) ; _size = 0 ; _root [ _KEY ] = null ; _root [ _VALUE ] = null ; } public Set keySet ( ) { if ( _key_set [ _KEY ] == null ) { _key_set [ _KEY ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _KEY ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsKey ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; BinaryTree . this . remove ( o ) ; return _size != old_size ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _key_set [ _KEY ] ; } public Collection values ( ) { if ( _value_collection [ _KEY ] == null ) { _value_collection [ _KEY ] = new AbstractCollection ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _VALUE ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsValue ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; removeValue ( o ) ; return _size != old_size ; } public boolean removeAll ( Collection c ) { boolean modified = false ; Iterator iter = c . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( removeValue ( iter . next ( ) ) != null ) { modified = true ; } } return modified ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _value_collection [ _KEY ] ; } public Set entrySet ( ) { if ( _entry_set [ _KEY ] == null ) { _entry_set [ _KEY ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node ; } } ; } public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object value = entry . getValue ( ) ; Node node = lookup ( ( Comparable ) entry . getKey ( ) , _KEY ) ; return ( node != null ) && node . getData ( _VALUE ) . equals ( value ) ; } public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object value = entry . getValue ( ) ; Node node = lookup ( ( Comparable ) entry . getKey ( ) , _KEY ) ; if ( ( node != null ) && node . getData ( _VALUE ) . equals ( value ) ) { doRedBlackDelete ( node ) ; return true ; } return false ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _entry_set [ _KEY ] ; } private abstract class BinaryTreeIterator implements Iterator { private int _expected_modifications ; protected Node _last_returned_node ; private Node _next_node ; private int _type ; BinaryTreeIterator ( final int type ) { _type = type ; _expected_modifications = BinaryTree . this . _modifications ; _last_returned_node = null ; _next_node = leastNode ( _root [ _type ] , _type ) ; } protected abstract Object doGetNext ( ) ; public final boolean hasNext ( ) { return _next_node != null ; } public final Object next ( ) throws NoSuchElementException , ConcurrentModificationException { if ( _next_node == null ) { throw new NoSuchElementException ( ) ; } if ( _modifications != _expected_modifications ) { throw new ConcurrentModificationException ( ) ; } _last_returned_node = _next_node ; _next_node = nextGreater ( _next_node , _type ) ; return doGetNext ( ) ; } public final void remove ( ) throws IllegalStateException , ConcurrentModificationException { if ( _last_returned_node == null ) { throw new IllegalStateException ( ) ; } if ( _modifications != _expected_modifications ) { throw new ConcurrentModificationException ( ) ; } doRedBlackDelete ( _last_returned_node ) ; _expected_modifications ++ ; _last_returned_node = null ; } } private static final class Node implements Map . Entry { private Comparable [ ] _data ; private Node [ ] _left ; private Node [ ] _right ; private Node [ ] _parent ; private boolean [ ] _black ; private int _hashcode ; private boolean _calculated_hashcode ; Node ( final Comparable key , final Comparable value ) { _data = new Comparable [ ] { key , value } ; _left = new Node [ ] { null , null } ; _right = new Node [ ] { null , null } ; _parent = new Node [ ] { null , null } ; _black = new boolean [ ] { true , true } ; _calculated_hashcode = false ; } private Comparable getData ( final int index ) { return _data [ index ] ; } private void setLeft ( final Node node , final int index ) { _left [ index ] = node ; } private Node getLeft ( final int index ) { return _left [ index ] ; } private void setRight ( final Node node , final int index ) { _right [ index ] = node ; } private Node getRight ( final int index ) { return _right [ index ] ; } private void setParent ( final Node node , final int index ) { _parent [ index ] = node ; } private Node getParent ( final int index ) { return _parent [ index ] ; } private void swapColors ( final Node node , final int index ) { _black [ index ] ^= node . _black [ index ] ; node . _black [ index ] ^= _black [ index ] ; _black [ index ] ^= node . _black [ index ] ; } private boolean isBlack ( final int index ) { return _black [ index ] ; } private boolean isRed ( final int index ) { return ! _black [ index ] ; } private void setBlack ( final int index ) { _black [ index ] = true ; } private void setRed ( final int index ) { _black [ index ] = false ; } private void copyColor ( final Node node , final int index ) { _black [ index ] = node . _black [ index ] ; } public Object getKey ( ) { return _data [ _KEY ] ; } public Object getValue ( ) { return _data [ _VALUE ] ; } public Object setValue ( Object ignored ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( "Map.Entry.setValue is not supported" ) ; } public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry e = ( Map . Entry ) o ; return _data [ _KEY ] . equals ( e . getKey ( ) ) && _data [ _VALUE ] . equals ( e . getValue ( ) ) ; } public int hashCode ( ) { if ( ! _calculated_hashcode ) { _hashcode = _data [ _KEY ] . hashCode ( ) ^ _data [ _VALUE ] . hashCode ( ) ; _calculated_hashcode = true ; } return _hashcode ; } } } 	0	['57', '2', '0', '15', '87', '1362', '14', '7', '17', '0.927083333', '1806', '1', '1', '0.25', '0.265306122', '1', '7', '30.47368421', '19', '2.5263', '0']
package org . apache . poi . poifs . eventfilesystem ; import java . util . * ; import org . apache . poi . poifs . filesystem . DocumentDescriptor ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; class POIFSReaderRegistry { private Set omnivorousListeners ; private Map selectiveListeners ; private Map chosenDocumentDescriptors ; POIFSReaderRegistry ( ) { omnivorousListeners = new HashSet ( ) ; selectiveListeners = new HashMap ( ) ; chosenDocumentDescriptors = new HashMap ( ) ; } void registerListener ( final POIFSReaderListener listener , final POIFSDocumentPath path , final String documentName ) { if ( ! omnivorousListeners . contains ( listener ) ) { Set descriptors = ( Set ) selectiveListeners . get ( listener ) ; if ( descriptors == null ) { descriptors = new HashSet ( ) ; selectiveListeners . put ( listener , descriptors ) ; } DocumentDescriptor descriptor = new DocumentDescriptor ( path , documentName ) ; if ( descriptors . add ( descriptor ) ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; if ( listeners == null ) { listeners = new HashSet ( ) ; chosenDocumentDescriptors . put ( descriptor , listeners ) ; } listeners . add ( listener ) ; } } } void registerListener ( final POIFSReaderListener listener ) { if ( ! omnivorousListeners . contains ( listener ) ) { removeSelectiveListener ( listener ) ; omnivorousListeners . add ( listener ) ; } } Iterator getListeners ( final POIFSDocumentPath path , final String name ) { Set rval = new HashSet ( omnivorousListeners ) ; Set selectiveListeners = ( Set ) chosenDocumentDescriptors . get ( new DocumentDescriptor ( path , name ) ) ; if ( selectiveListeners != null ) { rval . addAll ( selectiveListeners ) ; } return rval . iterator ( ) ; } private void removeSelectiveListener ( final POIFSReaderListener listener ) { Set selectedDescriptors = ( Set ) selectiveListeners . remove ( listener ) ; if ( selectedDescriptors != null ) { Iterator iter = selectedDescriptors . iterator ( ) ; while ( iter . hasNext ( ) ) { dropDocument ( listener , ( DocumentDescriptor ) iter . next ( ) ) ; } } } private void dropDocument ( final POIFSReaderListener listener , final DocumentDescriptor descriptor ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; listeners . remove ( listener ) ; if ( listeners . size ( ) == 0 ) { chosenDocumentDescriptors . remove ( descriptor ) ; } } } 	0	['6', '1', '0', '4', '22', '0', '1', '3', '0', '0.333333333', '163', '1', '0', '0', '0.5', '0', '0', '25.66666667', '5', '2.3333', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class EndRecord extends Record { public static final short sid = 0x1034 ; public EndRecord ( ) { } public EndRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public EndRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An END RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[END]\n" ) ; buffer . append ( "[/END]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0 ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 ; } public short getSid ( ) { return this . sid ; } } 	0	['9', '2', '0', '4', '17', '36', '1', '3', '7', '1.125', '72', '0', '0', '0.647058824', '0.555555556', '1', '6', '6.888888889', '2', '0.7778', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; class BlockListImpl implements BlockList { private ListManagedBlock [ ] _blocks ; private BlockAllocationTableReader _bat ; protected BlockListImpl ( ) { _blocks = new ListManagedBlock [ 0 ] ; _bat = null ; } protected void setBlocks ( final ListManagedBlock [ ] blocks ) { _blocks = blocks ; } public void zap ( final int index ) { if ( ( index >= 0 ) && ( index < _blocks . length ) ) { _blocks [ index ] = null ; } } public ListManagedBlock remove ( final int index ) throws IOException { ListManagedBlock result = null ; try { result = _blocks [ index ] ; if ( result == null ) { throw new IOException ( "block[ " + index + " ] already removed" ) ; } _blocks [ index ] = null ; } catch ( ArrayIndexOutOfBoundsException ignored ) { throw new IOException ( "Cannot remove block[ " + index + " ]; out of range" ) ; } return result ; } public ListManagedBlock [ ] fetchBlocks ( final int startBlock ) throws IOException { if ( _bat == null ) { throw new IOException ( "Improperly initialized list: no block allocation table provided" ) ; } return _bat . fetchBlocks ( startBlock , this ) ; } public void setBAT ( final BlockAllocationTableReader bat ) throws IOException { if ( _bat != null ) { throw new IOException ( "Attempt to replace existing BlockAllocationTable" ) ; } _bat = bat ; } } 	0	['6', '1', '2', '5', '13', '0', '2', '3', '4', '0.5', '107', '1', '2', '0', '0.458333333', '0', '0', '16.5', '3', '1.1667', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; public interface BlockList { public void zap ( final int index ) ; public ListManagedBlock remove ( final int index ) throws IOException ; public ListManagedBlock [ ] fetchBlocks ( final int startBlock ) throws IOException ; public void setBAT ( final BlockAllocationTableReader bat ) throws IOException ; } 	0	['4', '1', '0', '6', '4', '6', '5', '2', '4', '2', '4', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . eventmodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected void processRecord ( Record rec ) { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { HSSFListener listener = ( HSSFListener ) listeners . get ( k ) ; listener . processRecord ( rec ) ; } } } } 	0	['4', '1', '0', '6', '16', '0', '3', '3', '3', '0', '97', '1', '0', '0', '0.5', '0', '0', '23', '3', '1.75', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CountryRecord extends Record { public final static short sid = 0x8c ; private short field_1_default_country ; private short field_2_current_country ; public CountryRecord ( ) { } public CountryRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CountryRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A Country RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_default_country = LittleEndian . getShort ( data , 0 + offset ) ; field_2_current_country = LittleEndian . getShort ( data , 2 + offset ) ; } public void setDefaultCountry ( short country ) { field_1_default_country = country ; } public void setCurrentCountry ( short country ) { field_2_current_country = country ; } public short getDefaultCountry ( ) { return field_1_default_country ; } public short getCurrentCountry ( ) { return field_2_current_country ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[COUNTRY]\n" ) ; buffer . append ( "    .defaultcountry  = " ) . append ( Integer . toHexString ( getDefaultCountry ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .currentcountry  = " ) . append ( Integer . toHexString ( getCurrentCountry ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/COUNTRY]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x04 ) ) ; LittleEndian . putShort ( data , 4 + offset , getDefaultCountry ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getCurrentCountry ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 ; } public short getSid ( ) { return this . sid ; } } 	0	['13', '2', '0', '5', '23', '66', '2', '3', '11', '0.805555556', '140', '0.666666667', '0', '0.523809524', '0.5', '1', '6', '9.538461538', '2', '0.8462', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class DSFRecord extends Record { public final static short sid = 0x161 ; private short field_1_dsf ; public DSFRecord ( ) { } public DSFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public DSFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A DSF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_dsf = LittleEndian . getShort ( data , 0 + offset ) ; } public void setDsf ( short dsfflag ) { field_1_dsf = dsfflag ; } public short getDsf ( ) { return field_1_dsf ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[DSF]\n" ) ; buffer . append ( "    .isDSF           = " ) . append ( Integer . toHexString ( getDsf ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/DSF]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getDsf ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '49', '2', '3', '9', '0.85', '106', '0.5', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class PasswordRev4Record extends Record { public final static short sid = 0x1BC ; private short field_1_password ; public PasswordRev4Record ( ) { } public PasswordRev4Record ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PasswordRev4Record ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A PROT4REVPASSWORD RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_password = LittleEndian . getShort ( data , 0 + offset ) ; } public void setPassword ( short pw ) { field_1_password = pw ; } public short getPassword ( ) { return field_1_password ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PROT4REVPASSWORD]\n" ) ; buffer . append ( "    .password       = " ) . append ( Integer . toHexString ( getPassword ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/PROT4REVPASSWORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getPassword ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	0	['11', '2', '0', '5', '21', '49', '2', '3', '9', '0.85', '106', '0.5', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '0']
package org . apache . poi . poifs . eventfilesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; import org . apache . poi . poifs . property . DirectoryProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . property . PropertyTable ; import org . apache . poi . poifs . storage . BlockAllocationTableReader ; import org . apache . poi . poifs . storage . BlockList ; import org . apache . poi . poifs . storage . HeaderBlockReader ; import org . apache . poi . poifs . storage . RawDataBlockList ; import org . apache . poi . poifs . storage . SmallBlockTableReader ; public class POIFSReader { private POIFSReaderRegistry registry ; private boolean registryClosed ; public POIFSReader ( ) { registry = new POIFSReaderRegistry ( ) ; registryClosed = false ; } public void read ( final InputStream stream ) throws IOException { registryClosed = true ; HeaderBlockReader header_block_reader = new HeaderBlockReader ( stream ) ; RawDataBlockList data_blocks = new RawDataBlockList ( stream ) ; new BlockAllocationTableReader ( header_block_reader . getBATCount ( ) , header_block_reader . getBATArray ( ) , header_block_reader . getXBATCount ( ) , header_block_reader . getXBATIndex ( ) , data_blocks ) ; PropertyTable properties = new PropertyTable ( header_block_reader . getPropertyStart ( ) , data_blocks ) ; processProperties ( SmallBlockTableReader . getSmallDocumentBlocks ( data_blocks , properties . getRoot ( ) , header_block_reader . getSBATStart ( ) ) , data_blocks , properties . getRoot ( ) . getChildren ( ) , new POIFSDocumentPath ( ) ) ; } public void registerListener ( final POIFSReaderListener listener ) { if ( listener == null ) { throw new NullPointerException ( ) ; } if ( registryClosed ) { throw new IllegalStateException ( ) ; } registry . registerListener ( listener ) ; } public void registerListener ( final POIFSReaderListener listener , final String name ) { registerListener ( listener , null , name ) ; } public void registerListener ( final POIFSReaderListener listener , final POIFSDocumentPath path , final String name ) { if ( ( listener == null ) || ( name == null ) || ( name . length ( ) == 0 ) ) { throw new NullPointerException ( ) ; } if ( registryClosed ) { throw new IllegalStateException ( ) ; } registry . registerListener ( listener , ( path == null ) ? new POIFSDocumentPath ( ) : path , name ) ; } public static void main ( String args [ ] ) throws IOException { if ( args . length == 0 ) { System . err . println ( "at least one argument required: input filename(s)" ) ; System . exit ( 1 ) ; } for ( int j = 0 ; j < args . length ; j ++ ) { POIFSReader reader = new POIFSReader ( ) ; POIFSReaderListener listener = new SampleListener ( ) ; reader . registerListener ( listener ) ; System . out . println ( "reading " + args [ j ] ) ; FileInputStream istream = new FileInputStream ( args [ j ] ) ; reader . read ( istream ) ; istream . close ( ) ; } } private void processProperties ( final BlockList small_blocks , final BlockList big_blocks , final Iterator properties , final POIFSDocumentPath path ) throws IOException { while ( properties . hasNext ( ) ) { Property property = ( Property ) properties . next ( ) ; String name = property . getName ( ) ; if ( property . isDirectory ( ) ) { POIFSDocumentPath new_path = new POIFSDocumentPath ( path , new String [ ] { name } ) ; processProperties ( small_blocks , big_blocks , ( ( DirectoryProperty ) property ) . getChildren ( ) , new_path ) ; } else { int startBlock = property . getStartBlock ( ) ; Iterator listeners = registry . getListeners ( path , name ) ; if ( listeners . hasNext ( ) ) { int size = property . getSize ( ) ; POIFSDocument document = null ; if ( property . shouldUseSmallBlocks ( ) ) { document = new POIFSDocument ( name , small_blocks . fetchBlocks ( startBlock ) , size ) ; } else { document = new POIFSDocument ( name , big_blocks . fetchBlocks ( startBlock ) , size ) ; } while ( listeners . hasNext ( ) ) { POIFSReaderListener listener = ( POIFSReaderListener ) listeners . next ( ) ; listener . processPOIFSReaderEvent ( new POIFSReaderEvent ( new DocumentInputStream ( document ) , path , name ) ) ; } } else { if ( property . shouldUseSmallBlocks ( ) ) { small_blocks . fetchBlocks ( startBlock ) ; } else { big_blocks . fetchBlocks ( startBlock ) ; } } } } } private static class SampleListener implements POIFSReaderListener { SampleListener ( ) { } public void processPOIFSReaderEvent ( final POIFSReaderEvent event ) { DocumentInputStream istream = event . getStream ( ) ; POIFSDocumentPath path = event . getPath ( ) ; String name = event . getName ( ) ; try { byte [ ] data = new byte [ istream . available ( ) ] ; istream . read ( data ) ; int pathLength = path . length ( ) ; for ( int k = 0 ; k < pathLength ; k ++ ) { System . out . print ( "/" + path . getComponent ( k ) ) ; } System . out . println ( "/" + name + ": " + data . length + " bytes read" ) ; } catch ( IOException ignored ) { } } } } 	0	['7', '1', '0', '17', '51', '3', '0', '17', '6', '0.083333333', '282', '1', '1', '0', '0.303571429', '0', '0', '39', '6', '1.8571', '0']
package org . apache . poi . util ; public class BitField { private final int _mask ; private final int _shift_count ; public BitField ( final int mask ) { _mask = mask ; int count = 0 ; int bit_pattern = mask ; if ( bit_pattern != 0 ) { while ( ( bit_pattern & 1 ) == 0 ) { count ++ ; bit_pattern >>= 1 ; } } _shift_count = count ; } public int getValue ( final int holder ) { return getRawValue ( holder ) > > _shift_count ; } public short getShortValue ( final short holder ) { return ( short ) getValue ( holder ) ; } public int getRawValue ( final int holder ) { return ( holder & _mask ) ; } public short getShortRawValue ( final short holder ) { return ( short ) getRawValue ( holder ) ; } public boolean isSet ( final int holder ) { return ( holder & _mask ) != 0 ; } public boolean isAllSet ( final int holder ) { return ( holder & _mask ) == _mask ; } public int setValue ( final int holder , final int value ) { return ( holder & ~ _mask ) | ( ( value << _shift_count ) & _mask ) ; } public short setShortValue ( final short holder , final short value ) { return ( short ) setValue ( holder , value ) ; } public int clear ( final int holder ) { return holder & ~ _mask ; } public short clearShort ( final short holder ) { return ( short ) clear ( holder ) ; } public byte clearByte ( final byte holder ) { return ( byte ) clear ( holder ) ; } public int set ( final int holder ) { return holder | _mask ; } public short setShort ( final short holder ) { return ( short ) set ( holder ) ; } public byte setByte ( final byte holder ) { return ( byte ) set ( holder ) ; } public int setBoolean ( final int holder , final boolean flag ) { return flag ? set ( holder ) : clear ( holder ) ; } public short setShortBoolean ( final short holder , final boolean flag ) { return flag ? setShort ( holder ) : clearShort ( holder ) ; } public byte setByteBoolean ( final byte holder , final boolean flag ) { return flag ? setByte ( holder ) : clearByte ( holder ) ; } } 	0	['18', '1', '0', '25', '19', '107', '25', '0', '18', '0.382352941', '170', '1', '0', '0', '0.433333333', '0', '0', '8.333333333', '2', '1.2222', '0']
package org . apache . poi . poifs . property ; public interface PropertyConstants { public static final int PROPERTY_TYPE_OFFSET = 0x42 ; public static final byte DIRECTORY_TYPE = 1 ; public static final byte DOCUMENT_TYPE = 2 ; public static final byte ROOT_TYPE = 5 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	0	['6', '1', '0', '17', '45', '5', '1', '17', '6', '0.55', '247', '0', '2', '0', '0.375', '0', '0', '39.5', '10', '2.6667', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; public class DocumentOutputStream extends OutputStream { private OutputStream stream ; private int limit ; private int written ; DocumentOutputStream ( final OutputStream stream , final int limit ) { this . stream = stream ; this . limit = limit ; this . written = 0 ; } public void write ( final int b ) throws IOException { limitCheck ( 1 ) ; stream . write ( b ) ; } public void write ( final byte b [ ] ) throws IOException { write ( b , 0 , b . length ) ; } public void write ( final byte b [ ] , final int off , final int len ) throws IOException { limitCheck ( len ) ; stream . write ( b , off , len ) ; } public void flush ( ) throws IOException { stream . flush ( ) ; } public void close ( ) throws IOException { } void writeFiller ( final int totalLimit , final byte fill ) throws IOException { if ( totalLimit > written ) { byte [ ] filler = new byte [ totalLimit - written ] ; Arrays . fill ( filler , fill ) ; stream . write ( filler ) ; } } private void limitCheck ( final int toBeWritten ) throws IOException { if ( ( written + toBeWritten ) > limit ) { throw new IOException ( "tried to write too much data" ) ; } written += toBeWritten ; } } 	0	['8', '2', '0', '3', '15', '4', '3', '0', '5', '0.428571429', '90', '1', '0', '0.416666667', '0.425', '1', '1', '9.875', '1', '0.875', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; public class ChartFormatRecord extends Record { public static final short sid = 0x1014 ; private int field1_x_position ; private int field2_y_position ; private int field3_width ; private int field4_height ; private short field5_grbit ; private BitField varyDisplayPattern = new BitField ( 0x01 ) ; public ChartFormatRecord ( ) { } public ChartFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ChartFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CHARTFORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field1_x_position = LittleEndian . getInt ( data , 0 + offset ) ; field2_y_position = LittleEndian . getInt ( data , 4 + offset ) ; field3_width = LittleEndian . getInt ( data , 8 + offset ) ; field4_height = LittleEndian . getInt ( data , 12 + offset ) ; field5_grbit = LittleEndian . getShort ( data , 16 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CHARTFORMAT]\n" ) ; buffer . append ( "    .xPosition       = " ) . append ( getXPosition ( ) ) . append ( "\n" ) ; buffer . append ( "    .yPosition       = " ) . append ( getYPosition ( ) ) . append ( "\n" ) ; buffer . append ( "    .width           = " ) . append ( getWidth ( ) ) . append ( "\n" ) ; buffer . append ( "    .height          = " ) . append ( getHeight ( ) ) . append ( "\n" ) ; buffer . append ( "    .grBit           = " ) . append ( Integer . toHexString ( field5_grbit ) ) . append ( "\n" ) ; buffer . append ( "[/CHARTFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 22 ) ) ; LittleEndian . putInt ( data , 4 + offset , getXPosition ( ) ) ; LittleEndian . putInt ( data , 8 + offset , getYPosition ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getWidth ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getHeight ( ) ) ; LittleEndian . putShort ( data , 20 + offset , field5_grbit ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 22 ; } public short getSid ( ) { return this . sid ; } public int getXPosition ( ) { return field1_x_position ; } public void setXPosition ( int xPosition ) { this . field1_x_position = xPosition ; } public int getYPosition ( ) { return field2_y_position ; } public void setYPosition ( int yPosition ) { this . field2_y_position = yPosition ; } public int getWidth ( ) { return field3_width ; } public void setWidth ( int width ) { this . field3_width = width ; } public int getHeight ( ) { return field4_height ; } public void setHeight ( int height ) { this . field4_height = height ; } public boolean getVaryDisplayPattern ( ) { return varyDisplayPattern . isSet ( field5_grbit ) ; } public void setVaryDisplayPattern ( boolean value ) { field5_grbit = varyDisplayPattern . setShortBoolean ( field5_grbit , value ) ; } } 	0	['19', '2', '0', '5', '35', '109', '1', '4', '17', '0.817460317', '265', '0.857142857', '1', '0.407407407', '0.368421053', '1', '6', '12.57894737', '2', '0.8947', '0']
package org . apache . poi . poifs . filesystem ; import java . util . * ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DocumentProperty ; public class DocumentNode extends EntryNode implements DocumentEntry , POIFSViewable { private POIFSDocument _document ; DocumentNode ( final DocumentProperty property , final DirectoryNode parent ) { super ( property , parent ) ; _document = property . getDocument ( ) ; } POIFSDocument getDocument ( ) { return _document ; } public int getSize ( ) { return getProperty ( ) . getSize ( ) ; } public boolean isDocumentEntry ( ) { return true ; } protected boolean isDeleteOK ( ) { return true ; } public Object [ ] getViewableArray ( ) { return new Object [ 0 ] ; } public Iterator getViewableIterator ( ) { List components = new ArrayList ( ) ; components . add ( getProperty ( ) ) ; components . add ( _document ) ; return components . iterator ( ) ; } public boolean preferArray ( ) { return false ; } public String getShortDescription ( ) { return getName ( ) ; } } 	0	['9', '2', '0', '9', '17', '30', '3', '7', '6', '0.75', '55', '1', '1', '0.529411765', '0.407407407', '1', '1', '5', '1', '0.8889', '0']
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableReader { public static BlockList getSmallDocumentBlocks ( final RawDataBlockList blockList , final RootProperty root , final int sbatStart ) throws IOException { BlockList list = new SmallDocumentBlockList ( SmallDocumentBlock . extract ( blockList . fetchBlocks ( root . getStartBlock ( ) ) ) ) ; new BlockAllocationTableReader ( blockList . fetchBlocks ( sbatStart ) , list ) ; return list ; } } 	0	['2', '1', '0', '9', '8', '1', '2', '7', '2', '2', '24', '0', '0', '0', '0.5', '0', '0', '11', '1', '0.5', '0']
