package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class RefVPtg extends ReferencePtg { public final static byte sid = 0x44 ; protected RefVPtg ( ) { super ( ) ; } public RefVPtg ( short row , short column , boolean isRowRelative , boolean isColumnRelative ) { super ( row , column , isRowRelative , isColumnRelative ) ; } public RefVPtg ( RecordInputStream in ) { super ( in ) ; } public String getRefPtgName ( ) { return "RefVPtg" ; } public Object clone ( ) { RefVPtg ptg = new RefVPtg ( ) ; ptg . setRow ( getRow ( ) ) ; ptg . setColumnRaw ( getColumnRaw ( ) ) ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0	['5', '3', '0', '4', '13', '10', '2', '2', '4', '1.25', '40', '0', '0', '0.92', '0.4', '1', '1', '6.8', '1', '0.4', '0']
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class SubtractPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x04 ; public SubtractPtg ( ) { } public SubtractPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "-" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( "-" ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new SubtractPtg ( ) ; } } 	0	['9', '2', '0', '5', '13', '36', '2', '3', '9', '1.125', '59', '0', '0', '0.3', '0.259259259', '0', '0', '5.333333333', '1', '0.7778', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class RefNPtg extends ReferencePtg { public final static byte sid = 0x2C ; protected RefNPtg ( ) { } public RefNPtg ( RecordInputStream in ) { super ( in ) ; } public void writeBytes ( byte [ ] array , int offset ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public String getRefPtgName ( ) { return "RefNPtg" ; } public String toFormulaString ( Workbook book ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public Object clone ( ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } } 	0	['6', '3', '0', '5', '9', '15', '2', '3', '5', '1.2', '31', '0', '0', '0.851851852', '0.333333333', '0', '0', '4', '1', '0.6667', '0']
package org . apache . poi . hssf . util ; import java . util . * ; public class HSSFColor { private final static int PALETTE_SIZE = 56 ; private final static int DISTINCT_COLOR_COUNT = 46 ; public HSSFColor ( ) { } public final static Hashtable getIndexHash ( ) { Hashtable hash = new Hashtable ( PALETTE_SIZE ) ; hash . put ( new Integer ( HSSFColor . BLACK . index ) , new HSSFColor . BLACK ( ) ) ; hash . put ( new Integer ( HSSFColor . BROWN . index ) , new HSSFColor . BROWN ( ) ) ; hash . put ( new Integer ( HSSFColor . OLIVE_GREEN . index ) , new HSSFColor . OLIVE_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_GREEN . index ) , new HSSFColor . DARK_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_TEAL . index ) , new HSSFColor . DARK_TEAL ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_BLUE . index ) , new HSSFColor . DARK_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_BLUE . index2 ) , new HSSFColor . DARK_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . INDIGO . index ) , new HSSFColor . INDIGO ( ) ) ; hash . put ( new Integer ( HSSFColor . GREY_80_PERCENT . index ) , new HSSFColor . GREY_80_PERCENT ( ) ) ; hash . put ( new Integer ( HSSFColor . ORANGE . index ) , new HSSFColor . ORANGE ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_YELLOW . index ) , new HSSFColor . DARK_YELLOW ( ) ) ; hash . put ( new Integer ( HSSFColor . GREEN . index ) , new HSSFColor . GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . TEAL . index ) , new HSSFColor . TEAL ( ) ) ; hash . put ( new Integer ( HSSFColor . TEAL . index2 ) , new HSSFColor . TEAL ( ) ) ; hash . put ( new Integer ( HSSFColor . BLUE . index ) , new HSSFColor . BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . BLUE . index2 ) , new HSSFColor . BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . BLUE_GREY . index ) , new HSSFColor . BLUE_GREY ( ) ) ; hash . put ( new Integer ( HSSFColor . GREY_50_PERCENT . index ) , new HSSFColor . GREY_50_PERCENT ( ) ) ; hash . put ( new Integer ( HSSFColor . RED . index ) , new HSSFColor . RED ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_ORANGE . index ) , new HSSFColor . LIGHT_ORANGE ( ) ) ; hash . put ( new Integer ( HSSFColor . LIME . index ) , new HSSFColor . LIME ( ) ) ; hash . put ( new Integer ( HSSFColor . SEA_GREEN . index ) , new HSSFColor . SEA_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . AQUA . index ) , new HSSFColor . AQUA ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_BLUE . index ) , new HSSFColor . LIGHT_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . VIOLET . index ) , new HSSFColor . VIOLET ( ) ) ; hash . put ( new Integer ( HSSFColor . VIOLET . index2 ) , new HSSFColor . VIOLET ( ) ) ; hash . put ( new Integer ( HSSFColor . GREY_40_PERCENT . index ) , new HSSFColor . GREY_40_PERCENT ( ) ) ; hash . put ( new Integer ( HSSFColor . PINK . index ) , new HSSFColor . PINK ( ) ) ; hash . put ( new Integer ( HSSFColor . PINK . index2 ) , new HSSFColor . PINK ( ) ) ; hash . put ( new Integer ( HSSFColor . GOLD . index ) , new HSSFColor . GOLD ( ) ) ; hash . put ( new Integer ( HSSFColor . YELLOW . index ) , new HSSFColor . YELLOW ( ) ) ; hash . put ( new Integer ( HSSFColor . YELLOW . index2 ) , new HSSFColor . YELLOW ( ) ) ; hash . put ( new Integer ( HSSFColor . BRIGHT_GREEN . index ) , new HSSFColor . BRIGHT_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . BRIGHT_GREEN . index2 ) , new HSSFColor . BRIGHT_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . TURQUOISE . index ) , new HSSFColor . TURQUOISE ( ) ) ; hash . put ( new Integer ( HSSFColor . TURQUOISE . index2 ) , new HSSFColor . TURQUOISE ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_RED . index ) , new HSSFColor . DARK_RED ( ) ) ; hash . put ( new Integer ( HSSFColor . DARK_RED . index2 ) , new HSSFColor . DARK_RED ( ) ) ; hash . put ( new Integer ( HSSFColor . SKY_BLUE . index ) , new HSSFColor . SKY_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . PLUM . index ) , new HSSFColor . PLUM ( ) ) ; hash . put ( new Integer ( HSSFColor . PLUM . index2 ) , new HSSFColor . PLUM ( ) ) ; hash . put ( new Integer ( HSSFColor . GREY_25_PERCENT . index ) , new HSSFColor . GREY_25_PERCENT ( ) ) ; hash . put ( new Integer ( HSSFColor . ROSE . index ) , new HSSFColor . ROSE ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_YELLOW . index ) , new HSSFColor . LIGHT_YELLOW ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_GREEN . index ) , new HSSFColor . LIGHT_GREEN ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_TURQUOISE . index ) , new HSSFColor . LIGHT_TURQUOISE ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_TURQUOISE . index2 ) , new HSSFColor . LIGHT_TURQUOISE ( ) ) ; hash . put ( new Integer ( HSSFColor . PALE_BLUE . index ) , new HSSFColor . PALE_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . LAVENDER . index ) , new HSSFColor . LAVENDER ( ) ) ; hash . put ( new Integer ( HSSFColor . WHITE . index ) , new HSSFColor . WHITE ( ) ) ; hash . put ( new Integer ( HSSFColor . CORNFLOWER_BLUE . index ) , new HSSFColor . CORNFLOWER_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . LEMON_CHIFFON . index ) , new HSSFColor . LEMON_CHIFFON ( ) ) ; hash . put ( new Integer ( HSSFColor . MAROON . index ) , new HSSFColor . MAROON ( ) ) ; hash . put ( new Integer ( HSSFColor . ORCHID . index ) , new HSSFColor . ORCHID ( ) ) ; hash . put ( new Integer ( HSSFColor . CORAL . index ) , new HSSFColor . CORAL ( ) ) ; hash . put ( new Integer ( HSSFColor . ROYAL_BLUE . index ) , new HSSFColor . ROYAL_BLUE ( ) ) ; hash . put ( new Integer ( HSSFColor . LIGHT_CORNFLOWER_BLUE . index ) , new HSSFColor . LIGHT_CORNFLOWER_BLUE ( ) ) ; return hash ; } public final static Hashtable getTripletHash ( ) { Hashtable hash = new Hashtable ( DISTINCT_COLOR_COUNT ) ; hash . put ( HSSFColor . BLACK . hexString , new HSSFColor . BLACK ( ) ) ; hash . put ( HSSFColor . BROWN . hexString , new HSSFColor . BROWN ( ) ) ; hash . put ( HSSFColor . OLIVE_GREEN . hexString , new HSSFColor . OLIVE_GREEN ( ) ) ; hash . put ( HSSFColor . DARK_GREEN . hexString , new HSSFColor . DARK_GREEN ( ) ) ; hash . put ( HSSFColor . DARK_TEAL . hexString , new HSSFColor . DARK_TEAL ( ) ) ; hash . put ( HSSFColor . DARK_BLUE . hexString , new HSSFColor . DARK_BLUE ( ) ) ; hash . put ( HSSFColor . INDIGO . hexString , new HSSFColor . INDIGO ( ) ) ; hash . put ( HSSFColor . GREY_80_PERCENT . hexString , new HSSFColor . GREY_80_PERCENT ( ) ) ; hash . put ( HSSFColor . ORANGE . hexString , new HSSFColor . ORANGE ( ) ) ; hash . put ( HSSFColor . DARK_YELLOW . hexString , new HSSFColor . DARK_YELLOW ( ) ) ; hash . put ( HSSFColor . GREEN . hexString , new HSSFColor . GREEN ( ) ) ; hash . put ( HSSFColor . TEAL . hexString , new HSSFColor . TEAL ( ) ) ; hash . put ( HSSFColor . BLUE . hexString , new HSSFColor . BLUE ( ) ) ; hash . put ( HSSFColor . BLUE_GREY . hexString , new HSSFColor . BLUE_GREY ( ) ) ; hash . put ( HSSFColor . GREY_50_PERCENT . hexString , new HSSFColor . GREY_50_PERCENT ( ) ) ; hash . put ( HSSFColor . RED . hexString , new HSSFColor . RED ( ) ) ; hash . put ( HSSFColor . LIGHT_ORANGE . hexString , new HSSFColor . LIGHT_ORANGE ( ) ) ; hash . put ( HSSFColor . LIME . hexString , new HSSFColor . LIME ( ) ) ; hash . put ( HSSFColor . SEA_GREEN . hexString , new HSSFColor . SEA_GREEN ( ) ) ; hash . put ( HSSFColor . AQUA . hexString , new HSSFColor . AQUA ( ) ) ; hash . put ( HSSFColor . LIGHT_BLUE . hexString , new HSSFColor . LIGHT_BLUE ( ) ) ; hash . put ( HSSFColor . VIOLET . hexString , new HSSFColor . VIOLET ( ) ) ; hash . put ( HSSFColor . GREY_40_PERCENT . hexString , new HSSFColor . GREY_40_PERCENT ( ) ) ; hash . put ( HSSFColor . PINK . hexString , new HSSFColor . PINK ( ) ) ; hash . put ( HSSFColor . GOLD . hexString , new HSSFColor . GOLD ( ) ) ; hash . put ( HSSFColor . YELLOW . hexString , new HSSFColor . YELLOW ( ) ) ; hash . put ( HSSFColor . BRIGHT_GREEN . hexString , new HSSFColor . BRIGHT_GREEN ( ) ) ; hash . put ( HSSFColor . TURQUOISE . hexString , new HSSFColor . TURQUOISE ( ) ) ; hash . put ( HSSFColor . DARK_RED . hexString , new HSSFColor . DARK_RED ( ) ) ; hash . put ( HSSFColor . SKY_BLUE . hexString , new HSSFColor . SKY_BLUE ( ) ) ; hash . put ( HSSFColor . PLUM . hexString , new HSSFColor . PLUM ( ) ) ; hash . put ( HSSFColor . GREY_25_PERCENT . hexString , new HSSFColor . GREY_25_PERCENT ( ) ) ; hash . put ( HSSFColor . ROSE . hexString , new HSSFColor . ROSE ( ) ) ; hash . put ( HSSFColor . LIGHT_YELLOW . hexString , new HSSFColor . LIGHT_YELLOW ( ) ) ; hash . put ( HSSFColor . LIGHT_GREEN . hexString , new HSSFColor . LIGHT_GREEN ( ) ) ; hash . put ( HSSFColor . LIGHT_TURQUOISE . hexString , new HSSFColor . LIGHT_TURQUOISE ( ) ) ; hash . put ( HSSFColor . PALE_BLUE . hexString , new HSSFColor . PALE_BLUE ( ) ) ; hash . put ( HSSFColor . LAVENDER . hexString , new HSSFColor . LAVENDER ( ) ) ; hash . put ( HSSFColor . WHITE . hexString , new HSSFColor . WHITE ( ) ) ; hash . put ( HSSFColor . CORNFLOWER_BLUE . hexString , new HSSFColor . CORNFLOWER_BLUE ( ) ) ; hash . put ( HSSFColor . LEMON_CHIFFON . hexString , new HSSFColor . LEMON_CHIFFON ( ) ) ; hash . put ( HSSFColor . MAROON . hexString , new HSSFColor . MAROON ( ) ) ; hash . put ( HSSFColor . ORCHID . hexString , new HSSFColor . ORCHID ( ) ) ; hash . put ( HSSFColor . CORAL . hexString , new HSSFColor . CORAL ( ) ) ; hash . put ( HSSFColor . ROYAL_BLUE . hexString , new HSSFColor . ROYAL_BLUE ( ) ) ; hash . put ( HSSFColor . LIGHT_CORNFLOWER_BLUE . hexString , new HSSFColor . LIGHT_CORNFLOWER_BLUE ( ) ) ; return hash ; } public short getIndex ( ) { return BLACK . index ; } public short [ ] getTriplet ( ) { return BLACK . triplet ; } public String getHexString ( ) { return BLACK . hexString ; } public final static class BLACK extends HSSFColor { public final static short index = 0x8 ; public final static short [ ] triplet = { 0 , 0 , 0 } ; public final static String hexString = "0:0:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class BROWN extends HSSFColor { public final static short index = 0x3c ; public final static short [ ] triplet = { 153 , 51 , 0 } ; public final static String hexString = "9999:3333:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public static class OLIVE_GREEN extends HSSFColor { public final static short index = 0x3b ; public final static short [ ] triplet = { 51 , 51 , 0 } ; public final static String hexString = "3333:3333:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_GREEN extends HSSFColor { public final static short index = 0x3a ; public final static short [ ] triplet = { 0 , 51 , 0 } ; public final static String hexString = "0:3333:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_TEAL extends HSSFColor { public final static short index = 0x38 ; public final static short [ ] triplet = { 0 , 51 , 102 } ; public final static String hexString = "0:3333:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_BLUE extends HSSFColor { public final static short index = 0x12 ; public final static short index2 = 0x20 ; public final static short [ ] triplet = { 0 , 0 , 128 } ; public final static String hexString = "0:0:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class INDIGO extends HSSFColor { public final static short index = 0x3e ; public final static short [ ] triplet = { 51 , 51 , 153 } ; public final static String hexString = "3333:3333:9999" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREY_80_PERCENT extends HSSFColor { public final static short index = 0x3f ; public final static short [ ] triplet = { 51 , 51 , 51 } ; public final static String hexString = "3333:3333:3333" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_RED extends HSSFColor { public final static short index = 0x10 ; public final static short index2 = 0x25 ; public final static short [ ] triplet = { 128 , 0 , 0 } ; public final static String hexString = "8080:0:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class ORANGE extends HSSFColor { public final static short index = 0x35 ; public final static short [ ] triplet = { 255 , 102 , 0 } ; public final static String hexString = "FFFF:6666:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class DARK_YELLOW extends HSSFColor { public final static short index = 0x13 ; public final static short [ ] triplet = { 128 , 128 , 0 } ; public final static String hexString = "8080:8080:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREEN extends HSSFColor { public final static short index = 0x11 ; public final static short [ ] triplet = { 0 , 128 , 0 } ; public final static String hexString = "0:8080:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class TEAL extends HSSFColor { public final static short index = 0x15 ; public final static short index2 = 0x26 ; public final static short [ ] triplet = { 0 , 128 , 128 } ; public final static String hexString = "0:8080:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class BLUE extends HSSFColor { public final static short index = 0xc ; public final static short index2 = 0x27 ; public final static short [ ] triplet = { 0 , 0 , 255 } ; public final static String hexString = "0:0:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class BLUE_GREY extends HSSFColor { public final static short index = 0x36 ; public final static short [ ] triplet = { 102 , 102 , 153 } ; public final static String hexString = "6666:6666:9999" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREY_50_PERCENT extends HSSFColor { public final static short index = 0x17 ; public final static short [ ] triplet = { 128 , 128 , 128 } ; public final static String hexString = "8080:8080:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class RED extends HSSFColor { public final static short index = 0xa ; public final static short [ ] triplet = { 255 , 0 , 0 } ; public final static String hexString = "FFFF:0:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_ORANGE extends HSSFColor { public final static short index = 0x34 ; public final static short [ ] triplet = { 255 , 153 , 0 } ; public final static String hexString = "FFFF:9999:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIME extends HSSFColor { public final static short index = 0x32 ; public final static short [ ] triplet = { 153 , 204 , 0 } ; public final static String hexString = "9999:CCCC:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class SEA_GREEN extends HSSFColor { public final static short index = 0x39 ; public final static short [ ] triplet = { 51 , 153 , 102 } ; public final static String hexString = "3333:9999:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class AQUA extends HSSFColor { public final static short index = 0x31 ; public final static short [ ] triplet = { 51 , 204 , 204 } ; public final static String hexString = "3333:CCCC:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_BLUE extends HSSFColor { public final static short index = 0x30 ; public final static short [ ] triplet = { 51 , 102 , 255 } ; public final static String hexString = "3333:6666:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class VIOLET extends HSSFColor { public final static short index = 0x14 ; public final static short index2 = 0x24 ; public final static short [ ] triplet = { 128 , 0 , 128 } ; public final static String hexString = "8080:0:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREY_40_PERCENT extends HSSFColor { public final static short index = 0x37 ; public final static short [ ] triplet = { 150 , 150 , 150 } ; public final static String hexString = "9696:9696:9696" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class PINK extends HSSFColor { public final static short index = 0xe ; public final static short index2 = 0x21 ; public final static short [ ] triplet = { 255 , 0 , 255 } ; public final static String hexString = "FFFF:0:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GOLD extends HSSFColor { public final static short index = 0x33 ; public final static short [ ] triplet = { 255 , 204 , 0 } ; public final static String hexString = "FFFF:CCCC:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class YELLOW extends HSSFColor { public final static short index = 0xd ; public final static short index2 = 0x22 ; public final static short [ ] triplet = { 255 , 255 , 0 } ; public final static String hexString = "FFFF:FFFF:0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class BRIGHT_GREEN extends HSSFColor { public final static short index = 0xb ; public final static short index2 = 0x23 ; public final static short [ ] triplet = { 0 , 255 , 0 } ; public final static String hexString = "0:FFFF:0" ; public short getIndex ( ) { return index ; } public String getHexString ( ) { return hexString ; } public short [ ] getTriplet ( ) { return triplet ; } } public final static class TURQUOISE extends HSSFColor { public final static short index = 0xf ; public final static short index2 = 0x23 ; public final static short [ ] triplet = { 0 , 255 , 255 } ; public final static String hexString = "0:FFFF:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class SKY_BLUE extends HSSFColor { public final static short index = 0x28 ; public final static short [ ] triplet = { 0 , 204 , 255 } ; public final static String hexString = "0:CCCC:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class PLUM extends HSSFColor { public final static short index = 0x3d ; public final static short index2 = 0x19 ; public final static short [ ] triplet = { 153 , 51 , 102 } ; public final static String hexString = "9999:3333:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class GREY_25_PERCENT extends HSSFColor { public final static short index = 0x16 ; public final static short [ ] triplet = { 192 , 192 , 192 } ; public final static String hexString = "C0C0:C0C0:C0C0" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class ROSE extends HSSFColor { public final static short index = 0x2d ; public final static short [ ] triplet = { 255 , 153 , 204 } ; public final static String hexString = "FFFF:9999:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class TAN extends HSSFColor { public final static short index = 0x2f ; public final static short [ ] triplet = { 255 , 204 , 153 } ; public final static String hexString = "FFFF:CCCC:9999" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_YELLOW extends HSSFColor { public final static short index = 0x2b ; public final static short [ ] triplet = { 255 , 255 , 153 } ; public final static String hexString = "FFFF:FFFF:9999" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_GREEN extends HSSFColor { public final static short index = 0x2a ; public final static short [ ] triplet = { 204 , 255 , 204 } ; public final static String hexString = "CCCC:FFFF:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_TURQUOISE extends HSSFColor { public final static short index = 0x29 ; public final static short index2 = 0x1b ; public final static short [ ] triplet = { 204 , 255 , 255 } ; public final static String hexString = "CCCC:FFFF:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class PALE_BLUE extends HSSFColor { public final static short index = 0x2c ; public final static short [ ] triplet = { 153 , 204 , 255 } ; public final static String hexString = "9999:CCCC:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LAVENDER extends HSSFColor { public final static short index = 0x2e ; public final static short [ ] triplet = { 204 , 153 , 255 } ; public final static String hexString = "CCCC:9999:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class WHITE extends HSSFColor { public final static short index = 0x9 ; public final static short [ ] triplet = { 255 , 255 , 255 } ; public final static String hexString = "FFFF:FFFF:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class CORNFLOWER_BLUE extends HSSFColor { public final static short index = 0x18 ; public final static short [ ] triplet = { 153 , 153 , 255 } ; public final static String hexString = "9999:9999:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LEMON_CHIFFON extends HSSFColor { public final static short index = 0x1a ; public final static short [ ] triplet = { 255 , 255 , 204 } ; public final static String hexString = "FFFF:FFFF:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class MAROON extends HSSFColor { public final static short index = 0x19 ; public final static short [ ] triplet = { 153 , 51 , 102 } ; public final static String hexString = "9999:3333:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class ORCHID extends HSSFColor { public final static short index = 0x1c ; public final static short [ ] triplet = { 102 , 0 , 102 } ; public final static String hexString = "6666:0:6666" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class CORAL extends HSSFColor { public final static short index = 0x1d ; public final static short [ ] triplet = { 255 , 128 , 128 } ; public final static String hexString = "FFFF:8080:8080" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class ROYAL_BLUE extends HSSFColor { public final static short index = 0x1e ; public final static short [ ] triplet = { 0 , 102 , 204 } ; public final static String hexString = "0:6666:CCCC" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class LIGHT_CORNFLOWER_BLUE extends HSSFColor { public final static short index = 0x1f ; public final static short [ ] triplet = { 204 , 204 , 255 } ; public final static String hexString = "CCCC:CCCC:FFFF" ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return triplet ; } public String getHexString ( ) { return hexString ; } } public final static class AUTOMATIC extends HSSFColor { private static HSSFColor instance = new AUTOMATIC ( ) ; public final static short index = 0x40 ; public short getIndex ( ) { return index ; } public short [ ] getTriplet ( ) { return BLACK . triplet ; } public String getHexString ( ) { return BLACK . hexString ; } public static HSSFColor getInstance ( ) { return instance ; } } } 	0	['6', '1', '49', '51', '56', '15', '51', '46', '6', '1.2', '923', '1', '0', '0', '0.666666667', '0', '0', '152.5', '1', '0.8333', '0']
package org . apache . poi . hpsf ; import java . util . Date ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . apache . poi . hpsf . wellknown . PropertyIDMap ; public class CustomProperties extends HashMap { private Map dictionaryIDToName = new HashMap ( ) ; private Map dictionaryNameToID = new HashMap ( ) ; private boolean isPure = true ; public Object put ( final Object name , final Object customProperty ) throws ClassCastException { final CustomProperty cp = ( CustomProperty ) customProperty ; if ( name == null ) { isPure = false ; return null ; } if ( ! ( name instanceof String ) ) throw new ClassCastException ( "The name of a custom property must " + "be a java.lang.String, but it is a " + name . getClass ( ) . getName ( ) ) ; if ( ! ( name . equals ( cp . getName ( ) ) ) ) throw new IllegalArgumentException ( "Parameter \"name\" (" + name + ") and custom property's name (" + cp . getName ( ) + ") do not match." ) ; final Long idKey = new Long ( cp . getID ( ) ) ; final Object oldID = dictionaryNameToID . get ( name ) ; dictionaryIDToName . remove ( oldID ) ; dictionaryNameToID . put ( name , idKey ) ; dictionaryIDToName . put ( idKey , name ) ; final Object oldCp = super . remove ( oldID ) ; super . put ( idKey , cp ) ; return oldCp ; } private Object put ( final CustomProperty customProperty ) throws ClassCastException { final String name = customProperty . getName ( ) ; final Long oldId = ( Long ) dictionaryNameToID . get ( name ) ; if ( oldId != null ) customProperty . setID ( oldId . longValue ( ) ) ; else { long max = 1 ; for ( final Iterator i = dictionaryIDToName . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final long id = ( ( Long ) i . next ( ) ) . longValue ( ) ; if ( id > max ) max = id ; } customProperty . setID ( max + 1 ) ; } return this . put ( name , customProperty ) ; } public Object remove ( final String name ) { final Long id = ( Long ) dictionaryNameToID . get ( name ) ; if ( id == null ) return null ; dictionaryIDToName . remove ( id ) ; dictionaryNameToID . remove ( name ) ; return super . remove ( id ) ; } public Object put ( final String name , final String value ) { final MutableProperty p = new MutableProperty ( ) ; p . setID ( - 1 ) ; p . setType ( Variant . VT_LPWSTR ) ; p . setValue ( value ) ; final CustomProperty cp = new CustomProperty ( p , name ) ; return put ( cp ) ; } public Object put ( final String name , final Long value ) { final MutableProperty p = new MutableProperty ( ) ; p . setID ( - 1 ) ; p . setType ( Variant . VT_I8 ) ; p . setValue ( value ) ; final CustomProperty cp = new CustomProperty ( p , name ) ; return put ( cp ) ; } public Object put ( final String name , final Double value ) { final MutableProperty p = new MutableProperty ( ) ; p . setID ( - 1 ) ; p . setType ( Variant . VT_R8 ) ; p . setValue ( value ) ; final CustomProperty cp = new CustomProperty ( p , name ) ; return put ( cp ) ; } public Object put ( final String name , final Integer value ) { final MutableProperty p = new MutableProperty ( ) ; p . setID ( - 1 ) ; p . setType ( Variant . VT_I4 ) ; p . setValue ( value ) ; final CustomProperty cp = new CustomProperty ( p , name ) ; return put ( cp ) ; } public Object put ( final String name , final Boolean value ) { final MutableProperty p = new MutableProperty ( ) ; p . setID ( - 1 ) ; p . setType ( Variant . VT_BOOL ) ; p . setValue ( value ) ; final CustomProperty cp = new CustomProperty ( p , name ) ; return put ( cp ) ; } public Object get ( final String name ) { final Long id = ( Long ) dictionaryNameToID . get ( name ) ; final CustomProperty cp = ( CustomProperty ) super . get ( id ) ; return cp != null ? cp . getValue ( ) : null ; } public Object put ( final String name , final Date value ) { final MutableProperty p = new MutableProperty ( ) ; p . setID ( - 1 ) ; p . setType ( Variant . VT_FILETIME ) ; p . setValue ( value ) ; final CustomProperty cp = new CustomProperty ( p , name ) ; return put ( cp ) ; } public void setCodepage ( final int codepage ) { final MutableProperty p = new MutableProperty ( ) ; p . setID ( PropertyIDMap . PID_CODEPAGE ) ; p . setType ( Variant . VT_I2 ) ; p . setValue ( new Integer ( codepage ) ) ; put ( new CustomProperty ( p ) ) ; } Map getDictionary ( ) { return dictionaryIDToName ; } public int getCodepage ( ) { int codepage = - 1 ; for ( final Iterator i = this . values ( ) . iterator ( ) ; codepage == - 1 && i . hasNext ( ) ; ) { final CustomProperty cp = ( CustomProperty ) i . next ( ) ; if ( cp . getID ( ) == PropertyIDMap . PID_CODEPAGE ) codepage = ( ( Integer ) cp . getValue ( ) ) . intValue ( ) ; } return codepage ; } public boolean isPure ( ) { return isPure ; } public void setPure ( final boolean isPure ) { this . isPure = isPure ; } } 	0	['16', '3', '0', '4', '52', '82', '1', '3', '14', '0.266666667', '416', '1', '0', '0.782608696', '0.1875', '2', '7', '24.8125', '3', '1.1875', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaNAPtg extends AreaPtg { public final static short sid = 0x6D ; protected AreaNAPtg ( ) { } public AreaNAPtg ( RecordInputStream in ) { super ( in ) ; } public void writeBytes ( byte [ ] array , int offset ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public String getAreaPtgName ( ) { return "AreaNAPtg" ; } public String toFormulaString ( Workbook book ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public Object clone ( ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } } 	0	['6', '3', '0', '5', '9', '15', '2', '3', '5', '1.2', '31', '0', '0', '0.875', '0.333333333', '1', '1', '4', '1', '0.6667', '0']
package org . apache . poi . hpsf ; import java . io . PrintStream ; import java . io . PrintWriter ; public class HPSFRuntimeException extends RuntimeException { private Throwable reason ; public HPSFRuntimeException ( ) { super ( ) ; } public HPSFRuntimeException ( final String msg ) { super ( msg ) ; } public HPSFRuntimeException ( final Throwable reason ) { super ( ) ; this . reason = reason ; } public HPSFRuntimeException ( final String msg , final Throwable reason ) { super ( msg ) ; this . reason = reason ; } public Throwable getReason ( ) { return reason ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( final PrintStream p ) { final Throwable reason = getReason ( ) ; super . printStackTrace ( p ) ; if ( reason != null ) { p . println ( "Caused by:" ) ; reason . printStackTrace ( p ) ; } } public void printStackTrace ( final PrintWriter p ) { final Throwable reason = getReason ( ) ; super . printStackTrace ( p ) ; if ( reason != null ) { p . println ( "Caused by:" ) ; reason . printStackTrace ( p ) ; } } } 	0	['8', '4', '4', '11', '16', '22', '11', '0', '8', '0.428571429', '66', '1', '0', '0.80952381', '0.35', '1', '1', '7.125', '2', '0.75', '0']
package org . apache . poi . hssf . eventusermodel ; public class HSSFUserException extends Exception { private Throwable reason ; public HSSFUserException ( ) { super ( ) ; } public HSSFUserException ( final String msg ) { super ( msg ) ; } public HSSFUserException ( final Throwable reason ) { super ( ) ; this . reason = reason ; } public HSSFUserException ( final String msg , final Throwable reason ) { super ( msg ) ; this . reason = reason ; } public Throwable getReason ( ) { return reason ; } } 	0	['5', '3', '0', '3', '7', '4', '3', '0', '5', '0.5', '29', '1', '0', '0.944444444', '0.6', '0', '0', '4.6', '1', '0.2', '0']
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	0	['4', '1', '0', '7', '17', '0', '2', '5', '3', '0', '116', '1', '0', '0', '0.5', '0', '0', '27.75', '2', '1.25', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class ConcatPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x08 ; private final static String CONCAT = "&" ; public ConcatPtg ( RecordInputStream in ) { } public ConcatPtg ( ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return CONCAT ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( CONCAT ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new ConcatPtg ( ) ; } } 	0	['9', '2', '0', '5', '13', '36', '2', '3', '9', '1.125', '60', '0.333333333', '0', '0.3', '0.259259259', '0', '0', '5.333333333', '1', '0.7778', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; public class RawDataBlockList extends BlockListImpl { public RawDataBlockList ( final InputStream stream ) throws IOException { List blocks = new ArrayList ( ) ; while ( true ) { RawDataBlock block = new RawDataBlock ( stream ) ; if ( block . eof ( ) ) { break ; } blocks . add ( block ) ; } setBlocks ( ( RawDataBlock [ ] ) blocks . toArray ( new RawDataBlock [ 0 ] ) ) ; } } 	0	['5', '2', '0', '8', '16', '10', '4', '4', '5', '2', '50', '0', '0', '0.555555556', '0.5', '0', '0', '9', '1', '0.8', '0']
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; public class POIFSViewer { public static void main ( final String args [ ] ) { if ( args . length < 0 ) { System . err . println ( "Must specify at least one file to view" ) ; System . exit ( 1 ) ; } boolean printNames = ( args . length > 1 ) ; for ( int j = 0 ; j < args . length ; j ++ ) { viewFile ( args [ j ] , printNames ) ; } } private static void viewFile ( final String filename , final boolean printName ) { if ( printName ) { StringBuffer flowerbox = new StringBuffer ( ) ; flowerbox . append ( "." ) ; for ( int j = 0 ; j < filename . length ( ) ; j ++ ) { flowerbox . append ( "-" ) ; } flowerbox . append ( "." ) ; System . out . println ( flowerbox ) ; System . out . println ( "|" + filename + "|" ) ; System . out . println ( flowerbox ) ; } try { POIFSViewable fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; List strings = POIFSViewEngine . inspectViewable ( fs , true , 0 , "  " ) ; Iterator iter = strings . iterator ( ) ; while ( iter . hasNext ( ) ) { System . out . print ( iter . next ( ) ) ; } } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } } } 	0	['3', '1', '0', '2', '21', '3', '0', '2', '2', '2', '112', '0', '0', '0', '0.333333333', '0', '0', '36.33333333', '4', '2.3333', '0']
package org . apache . poi . hssf . record ; public class DrawingRecordForBiffViewer extends AbstractEscherHolderRecord { public static final short sid = 0xEC ; public DrawingRecordForBiffViewer ( ) { } public DrawingRecordForBiffViewer ( RecordInputStream in ) { super ( in ) ; } protected String getRecordName ( ) { return "MSODRAWING" ; } public short getSid ( ) { return sid ; } } 	0	['4', '3', '0', '3', '6', '6', '1', '2', '3', '1.333333333', '16', '0', '0', '0.923076923', '0.625', '1', '2', '2.75', '1', '0.5', '0']
package org . apache . poi . hssf . eventmodel ; import org . apache . poi . hssf . record . Record ; public interface ERFListener { public boolean processRecord ( Record rec ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class BoolPtg extends Ptg { public final static int SIZE = 2 ; public final static byte sid = 0x1d ; private boolean field_1_value ; private BoolPtg ( ) { } public BoolPtg ( RecordInputStream in ) { field_1_value = ( in . readByte ( ) == 1 ) ; } public BoolPtg ( String formulaToken ) { field_1_value = ( formulaToken . equals ( "TRUE" ) ) ; } public void setValue ( boolean value ) { field_1_value = value ; } public boolean getValue ( ) { return field_1_value ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; array [ offset + 1 ] = ( byte ) ( field_1_value ? 1 : 0 ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return field_1_value ? "TRUE" : "FALSE" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { BoolPtg ptg = new BoolPtg ( ) ; ptg . field_1_value = field_1_value ; return ptg ; } } 	0	['10', '2', '0', '4', '13', '3', '2', '3', '9', '0.851851852', '83', '0.333333333', '0', '0.5', '0.228571429', '1', '2', '7', '2', '0.9', '0']
package org . apache . poi . hssf . model ; import org . apache . poi . ddf . * ; import org . apache . poi . hssf . record . ObjRecord ; import org . apache . poi . hssf . usermodel . * ; public abstract class AbstractShape { public static AbstractShape createShape ( HSSFShape hssfShape , int shapeId ) { AbstractShape shape ; if ( hssfShape instanceof HSSFComment ) { shape = new CommentShape ( ( HSSFComment ) hssfShape , shapeId ) ; } else if ( hssfShape instanceof HSSFTextbox ) { shape = new TextboxShape ( ( HSSFTextbox ) hssfShape , shapeId ) ; } else if ( hssfShape instanceof HSSFPolygon ) { shape = new PolygonShape ( ( HSSFPolygon ) hssfShape , shapeId ) ; } else if ( hssfShape instanceof HSSFSimpleShape ) { HSSFSimpleShape simpleShape = ( HSSFSimpleShape ) hssfShape ; switch ( simpleShape . getShapeType ( ) ) { case HSSFSimpleShape . OBJECT_TYPE_PICTURE : shape = new PictureShape ( simpleShape , shapeId ) ; break ; case HSSFSimpleShape . OBJECT_TYPE_LINE : shape = new LineShape ( simpleShape , shapeId ) ; break ; case HSSFSimpleShape . OBJECT_TYPE_OVAL : case HSSFSimpleShape . OBJECT_TYPE_RECTANGLE : shape = new SimpleFilledShape ( simpleShape , shapeId ) ; break ; default : throw new IllegalArgumentException ( "Do not know how to handle this type of shape" ) ; } } else { throw new IllegalArgumentException ( "Unknown shape type" ) ; } EscherSpRecord sp = shape . getSpContainer ( ) . getChildById ( EscherSpRecord . RECORD_ID ) ; if ( hssfShape . getParent ( ) != null ) sp . setFlags ( sp . getFlags ( ) | EscherSpRecord . FLAG_CHILD ) ; return shape ; } protected AbstractShape ( ) { } public abstract EscherContainerRecord getSpContainer ( ) ; public abstract ObjRecord getObjRecord ( ) ; protected EscherRecord createAnchor ( HSSFAnchor userAnchor ) { return ConvertAnchor . createAnchor ( userAnchor ) ; } protected int addStandardOptions ( HSSFShape shape , EscherOptRecord opt ) { opt . addEscherProperty ( new EscherBoolProperty ( EscherProperties . TEXT__SIZE_TEXT_TO_FIT_SHAPE , 0x080000 ) ) ; if ( shape . isNoFill ( ) ) { opt . addEscherProperty ( new EscherBoolProperty ( EscherProperties . FILL__NOFILLHITTEST , 0x00110000 ) ) ; } else { opt . addEscherProperty ( new EscherBoolProperty ( EscherProperties . FILL__NOFILLHITTEST , 0x00010000 ) ) ; } opt . addEscherProperty ( new EscherRGBProperty ( EscherProperties . FILL__FILLCOLOR , shape . getFillColor ( ) ) ) ; opt . addEscherProperty ( new EscherBoolProperty ( EscherProperties . GROUPSHAPE__PRINT , 0x080000 ) ) ; opt . addEscherProperty ( new EscherRGBProperty ( EscherProperties . LINESTYLE__COLOR , shape . getLineStyleColor ( ) ) ) ; int options = 5 ; if ( shape . getLineWidth ( ) != HSSFShape . LINEWIDTH_DEFAULT ) { opt . addEscherProperty ( new EscherSimpleProperty ( EscherProperties . LINESTYLE__LINEWIDTH , shape . getLineWidth ( ) ) ) ; options ++ ; } if ( shape . getLineStyle ( ) != HSSFShape . LINESTYLE_SOLID ) { opt . addEscherProperty ( new EscherSimpleProperty ( EscherProperties . LINESTYLE__LINEDASHING , shape . getLineStyle ( ) ) ) ; opt . addEscherProperty ( new EscherSimpleProperty ( EscherProperties . LINESTYLE__LINEENDCAPSTYLE , 0 ) ) ; if ( shape . getLineStyle ( ) == HSSFShape . LINESTYLE_NONE ) opt . addEscherProperty ( new EscherBoolProperty ( EscherProperties . LINESTYLE__NOLINEDRAWDASH , 0x00080000 ) ) ; else opt . addEscherProperty ( new EscherBoolProperty ( EscherProperties . LINESTYLE__NOLINEDRAWDASH , 0x00080008 ) ) ; options += 3 ; } opt . sortProperties ( ) ; return options ; } } 	0	['6', '1', '5', '23', '30', '15', '6', '22', '3', '2', '207', '0', '0', '0', '0.333333333', '0', '0', '33.5', '7', '2.5', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class MissingArgPtg extends Ptg { private final static int SIZE = 1 ; public final static byte sid = 0x16 ; public MissingArgPtg ( ) { } public MissingArgPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return " " ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new MissingArgPtg ( ) ; } } 	0	['7', '2', '0', '4', '8', '21', '2', '3', '7', '1.166666667', '32', '0.5', '0', '0.583333333', '0.314285714', '1', '2', '3.285714286', '1', '0.7143', '0']
package org . apache . poi . hpsf ; public class NoFormatIDException extends HPSFRuntimeException { public NoFormatIDException ( ) { super ( ) ; } public NoFormatIDException ( final String msg ) { super ( msg ) ; } public NoFormatIDException ( final Throwable reason ) { super ( reason ) ; } public NoFormatIDException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0	['4', '5', '0', '2', '8', '6', '1', '1', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . record . RecordInputStream ; public class FuncPtg extends AbstractFunctionPtg { public final static byte sid = 0x21 ; public final static int SIZE = 3 ; private int numParams = 0 ; private FuncPtg ( ) { } public FuncPtg ( RecordInputStream in ) { field_2_fnc_index = in . readShort ( ) ; try { numParams = ( ( Integer ) functionData [ field_2_fnc_index ] [ 2 ] ) . intValue ( ) ; } catch ( NullPointerException npe ) { numParams = 0 ; } } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_2_fnc_index ) ; } public int getNumberOfOperands ( ) { return numParams ; } public Object clone ( ) { FuncPtg ptg = new FuncPtg ( ) ; ptg . field_2_fnc_index = field_2_fnc_index ; ptg . setClass ( ptgClass ) ; return ptg ; } public int getSize ( ) { return SIZE ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   numArgs(internal)=" ) . append ( this . numParams ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } } 	0	['7', '3', '0', '5', '17', '0', '2', '3', '6', '0.888888889', '116', '0.333333333', '0', '0.772727273', '0.357142857', '1', '5', '15.14285714', '1', '0.7143', '0']
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . util . List ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . * ; import org . apache . poi . hssf . model . * ; public class FormulaViewer { private String file ; private boolean list = false ; public FormulaViewer ( ) { } public void run ( ) throws Exception { POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( file ) ) ; List records = RecordFactory . createRecords ( fs . createDocumentInputStream ( "Workbook" ) ) ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( Record ) records . get ( k ) ; if ( record . getSid ( ) == FormulaRecord . sid ) { if ( list ) { listFormula ( ( FormulaRecord ) record ) ; } else { parseFormulaRecord ( ( FormulaRecord ) record ) ; } } } } private void listFormula ( FormulaRecord record ) { String sep = "~" ; List tokens = record . getParsedExpression ( ) ; int numptgs = record . getNumberOfExpressionTokens ( ) ; Ptg token = null ; String name , numArg ; if ( tokens != null ) { token = ( Ptg ) tokens . get ( numptgs - 1 ) ; if ( token instanceof FuncPtg ) { numArg = String . valueOf ( numptgs - 1 ) ; } else { numArg = String . valueOf ( - 1 ) ; } StringBuffer buf = new StringBuffer ( ) ; if ( token instanceof ExpPtg ) return ; buf . append ( name = ( ( OperationPtg ) token ) . toFormulaString ( ( Workbook ) null ) ) ; buf . append ( sep ) ; switch ( token . getPtgClass ( ) ) { case Ptg . CLASS_REF : buf . append ( "REF" ) ; break ; case Ptg . CLASS_VALUE : buf . append ( "VALUE" ) ; break ; case Ptg . CLASS_ARRAY : buf . append ( "ARRAY" ) ; break ; } buf . append ( sep ) ; if ( numptgs > 1 ) { token = ( Ptg ) tokens . get ( numptgs - 2 ) ; switch ( token . getPtgClass ( ) ) { case Ptg . CLASS_REF : buf . append ( "REF" ) ; break ; case Ptg . CLASS_VALUE : buf . append ( "VALUE" ) ; break ; case Ptg . CLASS_ARRAY : buf . append ( "ARRAY" ) ; break ; } } else { buf . append ( "VALUE" ) ; } buf . append ( sep ) ; buf . append ( numArg ) ; System . out . println ( buf . toString ( ) ) ; } else { System . out . println ( "#NAME" ) ; } } public void parseFormulaRecord ( FormulaRecord record ) { System . out . println ( "==============================" ) ; System . out . print ( "row = " + record . getRow ( ) ) ; System . out . println ( ", col = " + record . getColumn ( ) ) ; System . out . println ( "value = " + record . getValue ( ) ) ; System . out . print ( "xf = " + record . getXFIndex ( ) ) ; System . out . print ( ", number of ptgs = " + record . getNumberOfExpressionTokens ( ) ) ; System . out . println ( ", options = " + record . getOptions ( ) ) ; System . out . println ( "RPN List = " + formulaString ( record ) ) ; System . out . println ( "Formula text = " + composeFormula ( record ) ) ; } private String formulaString ( FormulaRecord record ) { StringBuffer formula = new StringBuffer ( "=" ) ; int numptgs = record . getNumberOfExpressionTokens ( ) ; List tokens = record . getParsedExpression ( ) ; Ptg token ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < numptgs ; i ++ ) { token = ( Ptg ) tokens . get ( i ) ; buf . append ( token . toFormulaString ( ( Workbook ) null ) ) ; switch ( token . getPtgClass ( ) ) { case Ptg . CLASS_REF : buf . append ( "(R)" ) ; break ; case Ptg . CLASS_VALUE : buf . append ( "(V)" ) ; break ; case Ptg . CLASS_ARRAY : buf . append ( "(A)" ) ; break ; } buf . append ( ' ' ) ; } return buf . toString ( ) ; } private String composeFormula ( FormulaRecord record ) { return org . apache . poi . hssf . model . FormulaParser . toFormulaString ( ( Workbook ) null , record . getParsedExpression ( ) ) ; } public void setFile ( String file ) { this . file = file ; } public void setList ( boolean list ) { this . list = list ; } public static void main ( String args [ ] ) { if ( ( args == null ) || ( args . length > 2 ) || args [ 0 ] . equals ( "--help" ) ) { System . out . println ( "FormulaViewer .8 proof that the devil lies in the details (or just in BIFF8 files in general)" ) ; System . out . println ( "usage: Give me a big fat file name" ) ; } else if ( args [ 0 ] . equals ( "--listFunctions" ) ) { try { FormulaViewer viewer = new FormulaViewer ( ) ; viewer . setFile ( args [ 1 ] ) ; viewer . setList ( true ) ; viewer . run ( ) ; } catch ( Exception e ) { System . out . println ( "Whoops!" ) ; e . printStackTrace ( ) ; } } else { try { FormulaViewer viewer = new FormulaViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( Exception e ) { System . out . println ( "Whoops!" ) ; e . printStackTrace ( ) ; } } } } 	0	['9', '1', '0', '11', '43', '28', '0', '11', '6', '0.6875', '416', '1', '0', '0', '0.333333333', '0', '0', '45', '13', '3.2222', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . IntMapper ; import org . apache . poi . util . LittleEndian ; class SSTSerializer { private IntMapper strings ; private SSTRecordHeader sstRecordHeader ; int [ ] bucketAbsoluteOffsets ; int [ ] bucketRelativeOffsets ; int startOfSST , startOfRecord ; public SSTSerializer ( IntMapper strings , int numStrings , int numUniqueStrings ) { this . strings = strings ; this . sstRecordHeader = new SSTRecordHeader ( numStrings , numUniqueStrings ) ; int infoRecs = ExtSSTRecord . getNumberOfInfoRecsForStrings ( strings . size ( ) ) ; this . bucketAbsoluteOffsets = new int [ infoRecs ] ; this . bucketRelativeOffsets = new int [ infoRecs ] ; } public int serialize ( int offset , byte [ ] data ) { UnicodeString . UnicodeRecordStats stats = new UnicodeString . UnicodeRecordStats ( ) ; sstRecordHeader . writeSSTHeader ( stats , data , 0 + offset , 0 ) ; int pos = offset + SSTRecord . SST_RECORD_OVERHEAD ; for ( int k = 0 ; k < strings . size ( ) ; k ++ ) { if ( k % ExtSSTRecord . DEFAULT_BUCKET_SIZE == 0 ) { int index = k / ExtSSTRecord . DEFAULT_BUCKET_SIZE ; if ( index < ExtSSTRecord . MAX_BUCKETS ) { bucketAbsoluteOffsets [ index ] = pos - offset ; bucketRelativeOffsets [ index ] = pos - offset ; } } UnicodeString s = getUnicodeString ( k ) ; pos += s . serialize ( stats , pos , data ) ; } if ( stats . lastLengthPos != - 1 ) { short lastRecordLength = ( short ) ( pos - stats . lastLengthPos - 2 ) ; if ( lastRecordLength > 8224 ) throw new InternalError ( ) ; LittleEndian . putShort ( data , stats . lastLengthPos , lastRecordLength ) ; } return pos - offset ; } private UnicodeString getUnicodeString ( int index ) { return getUnicodeString ( strings , index ) ; } private static UnicodeString getUnicodeString ( IntMapper strings , int index ) { return ( ( UnicodeString ) strings . get ( index ) ) ; } public int [ ] getBucketAbsoluteOffsets ( ) { return bucketAbsoluteOffsets ; } public int [ ] getBucketRelativeOffsets ( ) { return bucketRelativeOffsets ; } } 	0	['6', '1', '0', '7', '16', '1', '1', '6', '4', '0.833333333', '145', '0.333333333', '2', '0', '0.5', '0', '0', '22.16666667', '6', '1.6667', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaAPtg extends AreaPtg { public final static short sid = 0x65 ; protected AreaAPtg ( ) { } public AreaAPtg ( short firstRow , short lastRow , short firstColumn , short lastColumn , boolean firstRowRelative , boolean lastRowRelative , boolean firstColRelative , boolean lastColRelative ) { super ( firstRow , lastRow , firstColumn , lastColumn , firstRowRelative , lastRowRelative , firstColRelative , lastColRelative ) ; } public AreaAPtg ( RecordInputStream in ) { super ( in ) ; } public String getAreaPtgName ( ) { return "AreaAPtg" ; } public Object clone ( ) { AreaAPtg ptg = new AreaAPtg ( ) ; ptg . setFirstRow ( getFirstRow ( ) ) ; ptg . setLastRow ( getLastRow ( ) ) ; ptg . setFirstColumnRaw ( getFirstColumnRaw ( ) ) ; ptg . setLastColumnRaw ( getLastColumnRaw ( ) ) ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0	['5', '3', '0', '4', '17', '10', '2', '2', '4', '1.25', '52', '0', '0', '0.933333333', '0.4', '1', '1', '9.2', '1', '0.4', '0']
package org . apache . poi . util ; public class ArrayUtil { public static void arraycopy ( byte [ ] src , int src_position , byte [ ] dst , int dst_position , int length ) { if ( src_position < 0 ) throw new IllegalArgumentException ( "src_position was less than 0.  Actual value " + src_position ) ; if ( src_position >= src . length ) throw new IllegalArgumentException ( "src_position was greater than src array size.  Tried to write starting at position " + src_position + " but the array length is " + src . length ) ; if ( src_position + length > src . length ) throw new IllegalArgumentException ( "src_position + length would overrun the src array.  Expected end at " + ( src_position + length ) + " actual end at " + src . length ) ; if ( dst_position < 0 ) throw new IllegalArgumentException ( "dst_position was less than 0.  Actual value " + dst_position ) ; if ( dst_position >= dst . length ) throw new IllegalArgumentException ( "dst_position was greater than dst array size.  Tried to write starting at position " + dst_position + " but the array length is " + dst . length ) ; if ( dst_position + length > dst . length ) throw new IllegalArgumentException ( "dst_position + length would overrun the dst array.  Expected end at " + ( dst_position + length ) + " actual end at " + dst . length ) ; System . arraycopy ( src , src_position , dst , dst_position , length ) ; } public static void arrayMoveWithin ( Object [ ] array , int moveFrom , int moveTo , int numToMove ) { if ( numToMove <= 0 ) { return ; } if ( moveFrom == moveTo ) { return ; } if ( moveFrom < 0 || moveFrom >= array . length ) { throw new IllegalArgumentException ( "The moveFrom must be a valid array index" ) ; } if ( moveTo < 0 || moveTo >= array . length ) { throw new IllegalArgumentException ( "The moveTo must be a valid array index" ) ; } if ( moveFrom + numToMove > array . length ) { throw new IllegalArgumentException ( "Asked to move more entries than the array has" ) ; } if ( moveTo + numToMove > array . length ) { throw new IllegalArgumentException ( "Asked to move to a position that doesn't have enough space" ) ; } Object [ ] toMove = new Object [ numToMove ] ; System . arraycopy ( array , moveFrom , toMove , 0 , numToMove ) ; Object [ ] toShift ; int shiftTo ; if ( moveFrom > moveTo ) { toShift = new Object [ ( moveFrom - moveTo ) ] ; System . arraycopy ( array , moveTo , toShift , 0 , toShift . length ) ; shiftTo = moveTo + numToMove ; } else { toShift = new Object [ ( moveTo - moveFrom ) ] ; System . arraycopy ( array , moveFrom + numToMove , toShift , 0 , toShift . length ) ; shiftTo = moveFrom ; } System . arraycopy ( toMove , 0 , array , moveTo , toMove . length ) ; System . arraycopy ( toShift , 0 , array , shiftTo , toShift . length ) ; } } 	0	['3', '1', '0', '1', '10', '3', '1', '0', '3', '2', '244', '0', '0', '0', '0.416666667', '0', '0', '80.33333333', '10', '5.6667', '0']
package org . apache . poi . hpsf ; public class WritingNotSupportedException extends UnsupportedVariantTypeException { public WritingNotSupportedException ( final long variantType , final Object value ) { super ( variantType , value ) ; } } 	0	['1', '6', '0', '7', '2', '0', '6', '1', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . poi . hpsf ; public class UnexpectedPropertySetTypeException extends HPSFException { public UnexpectedPropertySetTypeException ( ) { super ( ) ; } public UnexpectedPropertySetTypeException ( final String msg ) { super ( msg ) ; } public UnexpectedPropertySetTypeException ( final Throwable reason ) { super ( reason ) ; } public UnexpectedPropertySetTypeException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0	['4', '4', '0', '4', '8', '6', '3', '1', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . poi . poifs . eventfilesystem ; import java . util . * ; import org . apache . poi . poifs . filesystem . DocumentDescriptor ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; class POIFSReaderRegistry { private Set omnivorousListeners ; private Map selectiveListeners ; private Map chosenDocumentDescriptors ; POIFSReaderRegistry ( ) { omnivorousListeners = new HashSet ( ) ; selectiveListeners = new HashMap ( ) ; chosenDocumentDescriptors = new HashMap ( ) ; } void registerListener ( final POIFSReaderListener listener , final POIFSDocumentPath path , final String documentName ) { if ( ! omnivorousListeners . contains ( listener ) ) { Set descriptors = ( Set ) selectiveListeners . get ( listener ) ; if ( descriptors == null ) { descriptors = new HashSet ( ) ; selectiveListeners . put ( listener , descriptors ) ; } DocumentDescriptor descriptor = new DocumentDescriptor ( path , documentName ) ; if ( descriptors . add ( descriptor ) ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; if ( listeners == null ) { listeners = new HashSet ( ) ; chosenDocumentDescriptors . put ( descriptor , listeners ) ; } listeners . add ( listener ) ; } } } void registerListener ( final POIFSReaderListener listener ) { if ( ! omnivorousListeners . contains ( listener ) ) { removeSelectiveListener ( listener ) ; omnivorousListeners . add ( listener ) ; } } Iterator getListeners ( final POIFSDocumentPath path , final String name ) { Set rval = new HashSet ( omnivorousListeners ) ; Set selectiveListeners = ( Set ) chosenDocumentDescriptors . get ( new DocumentDescriptor ( path , name ) ) ; if ( selectiveListeners != null ) { rval . addAll ( selectiveListeners ) ; } return rval . iterator ( ) ; } private void removeSelectiveListener ( final POIFSReaderListener listener ) { Set selectedDescriptors = ( Set ) selectiveListeners . remove ( listener ) ; if ( selectedDescriptors != null ) { Iterator iter = selectedDescriptors . iterator ( ) ; while ( iter . hasNext ( ) ) { dropDocument ( listener , ( DocumentDescriptor ) iter . next ( ) ) ; } } } private void dropDocument ( final POIFSReaderListener listener , final DocumentDescriptor descriptor ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; listeners . remove ( listener ) ; if ( listeners . size ( ) == 0 ) { chosenDocumentDescriptors . remove ( descriptor ) ; } } } 	0	['6', '1', '0', '4', '22', '0', '1', '3', '0', '0.333333333', '163', '1', '0', '0', '0.5', '0', '0', '25.66666667', '5', '2.3333', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class LongField implements FixedField { private long _value ; private final int _offset ; public LongField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public LongField ( final int offset , final long value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public LongField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public LongField ( final int offset , final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public long get ( ) { return _value ; } public void set ( final long value ) { _value = value ; } public void set ( final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getLong ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readLong ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putLong ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '5', '21', '9', '2', '3', '11', '0.25', '92', '1', '0', '0', '0.454545455', '0', '0', '7.181818182', '1', '0.6364', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class RefAPtg extends ReferencePtg { public final static byte sid = 0x64 ; protected RefAPtg ( ) { super ( ) ; } public RefAPtg ( short row , short column , boolean isRowRelative , boolean isColumnRelative ) { super ( row , column , isRowRelative , isColumnRelative ) ; } public RefAPtg ( RecordInputStream in ) { super ( in ) ; } public String getRefPtgName ( ) { return "RefAPtg" ; } public Object clone ( ) { RefAPtg ptg = new RefAPtg ( ) ; ptg . setRow ( getRow ( ) ) ; ptg . setColumnRaw ( getColumnRaw ( ) ) ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0	['5', '3', '0', '4', '13', '10', '2', '2', '4', '1.25', '40', '0', '0', '0.92', '0.4', '1', '1', '6.8', '1', '0.4', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaNPtg extends AreaPtg { public final static short sid = 0x2D ; protected AreaNPtg ( ) { } public AreaNPtg ( RecordInputStream in ) { super ( in ) ; } public void writeBytes ( byte [ ] array , int offset ) { super . writeBytes ( array , offset ) ; } public String getAreaPtgName ( ) { return "AreaNPtg" ; } public String toFormulaString ( Workbook book ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public Object clone ( ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } } 	0	['6', '3', '0', '5', '10', '15', '2', '3', '5', '1.2', '31', '0', '0', '0.875', '0.333333333', '1', '1', '4', '1', '0.6667', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class RefNAPtg extends ReferencePtg { public final static byte sid = 0x6C ; protected RefNAPtg ( ) { } public RefNAPtg ( RecordInputStream in ) { super ( in ) ; } public void writeBytes ( byte [ ] array , int offset ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public String getRefPtgName ( ) { return "RefNAPtg" ; } public String toFormulaString ( Workbook book ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public Object clone ( ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } } 	0	['6', '3', '0', '5', '9', '15', '2', '3', '5', '1.2', '31', '0', '0', '0.851851852', '0.333333333', '0', '0', '4', '1', '0.6667', '0']
package org . apache . poi . hssf . record ; class RecordProcessor { } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '0', '2', '4', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . poi . hpsf ; import org . apache . poi . util . HexDump ; public abstract class UnsupportedVariantTypeException extends VariantTypeException { public UnsupportedVariantTypeException ( final long variantType , final Object value ) { super ( variantType , value , "HPSF does not yet support the variant type " + variantType + " (" + Variant . getVariantName ( variantType ) + ", " + HexDump . toHex ( variantType ) + "). If you want support for " + "this variant type in one of the next POI releases please " + "submit a request for enhancement (RFE) to " + "<http://issues.apache.org/bugzilla/>! Thank you!" ) ; } } 	0	['1', '5', '2', '8', '8', '0', '5', '3', '1', '2', '32', '0', '0', '1', '1', '0', '0', '31', '0', '0', '0']
package org . apache . poi . hssf . usermodel ; public interface HSSFErrorConstants { public static final byte ERROR_NULL = 0x00 ; public static final byte ERROR_DIV_0 = 0x07 ; public static final byte ERROR_VALUE = 0x0f ; public static final byte ERROR_REF = 0x17 ; public static final byte ERROR_NAME = 0x1d ; public static final byte ERROR_NUM = 0x24 ; public static final byte ERROR_NA = 0x2a ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . ClassID ; public interface DirectoryEntry extends Entry { public Iterator getEntries ( ) ; public boolean isEmpty ( ) ; public int getEntryCount ( ) ; public Entry getEntry ( final String name ) throws FileNotFoundException ; public DocumentEntry createDocument ( final String name , final InputStream stream ) throws IOException ; public DocumentEntry createDocument ( final String name , final int size , final POIFSWriterListener writer ) throws IOException ; public DirectoryEntry createDirectory ( final String name ) throws IOException ; public ClassID getStorageClsid ( ) ; public void setStorageClsid ( ClassID clsidStorage ) ; } 	0	['9', '1', '0', '10', '9', '36', '7', '4', '9', '2', '9', '0', '0', '0', '0.314814815', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . filesystem ; import java . util . * ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DocumentProperty ; public class DocumentNode extends EntryNode implements DocumentEntry , POIFSViewable { private POIFSDocument _document ; DocumentNode ( final DocumentProperty property , final DirectoryNode parent ) { super ( property , parent ) ; _document = property . getDocument ( ) ; } POIFSDocument getDocument ( ) { return _document ; } public int getSize ( ) { return getProperty ( ) . getSize ( ) ; } public boolean isDocumentEntry ( ) { return true ; } protected boolean isDeleteOK ( ) { return true ; } public Object [ ] getViewableArray ( ) { return new Object [ 0 ] ; } public Iterator getViewableIterator ( ) { List components = new ArrayList ( ) ; components . add ( getProperty ( ) ) ; components . add ( _document ) ; return components . iterator ( ) ; } public boolean preferArray ( ) { return false ; } public String getShortDescription ( ) { return getName ( ) ; } } 	0	['9', '2', '0', '9', '17', '30', '3', '7', '6', '0.75', '55', '1', '1', '0.529411765', '0.407407407', '1', '1', '5', '1', '0.8889', '0']
package org . apache . poi . hpsf ; import java . io . InputStream ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . rmi . UnexpectedException ; import org . apache . poi . hpsf . wellknown . SectionIDMap ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnsupportedEncodingException , IOException { final PropertySet ps = new PropertySet ( stream ) ; try { if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } catch ( UnexpectedPropertySetTypeException ex ) { throw new UnexpectedException ( ex . toString ( ) ) ; } } public static SummaryInformation newSummaryInformation ( ) { final MutablePropertySet ps = new MutablePropertySet ( ) ; final MutableSection s = ( MutableSection ) ps . getFirstSection ( ) ; s . setFormatID ( SectionIDMap . SUMMARY_INFORMATION_ID ) ; try { return new SummaryInformation ( ps ) ; } catch ( UnexpectedPropertySetTypeException ex ) { throw new HPSFRuntimeException ( ex ) ; } } public static DocumentSummaryInformation newDocumentSummaryInformation ( ) { final MutablePropertySet ps = new MutablePropertySet ( ) ; final MutableSection s = ( MutableSection ) ps . getFirstSection ( ) ; s . setFormatID ( SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID [ 0 ] ) ; try { return new DocumentSummaryInformation ( ps ) ; } catch ( UnexpectedPropertySetTypeException ex ) { throw new HPSFRuntimeException ( ex ) ; } } } 	0	['4', '1', '0', '11', '16', '6', '0', '11', '4', '2', '83', '0', '0', '0', '0.25', '0', '0', '19.75', '1', '0.75', '0']
package org . apache . poi . hssf . record ; public interface CellValueRecordInterface { public int getRow ( ) ; public short getColumn ( ) ; public void setRow ( int row ) ; public void setColumn ( short col ) ; public void setXFIndex ( short xf ) ; public short getXFIndex ( ) ; public boolean isBefore ( CellValueRecordInterface i ) ; public boolean isAfter ( CellValueRecordInterface i ) ; public boolean isEqual ( CellValueRecordInterface i ) ; public Object clone ( ) ; } 	0	['10', '1', '0', '14', '10', '45', '14', '0', '10', '2', '10', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . util ; public class PaneInformation { public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; private short x ; private short y ; private short topRow ; private short leftColumn ; private byte activePane ; private boolean frozen = false ; public PaneInformation ( short x , short y , short top , short left , byte active , boolean frozen ) { this . x = x ; this . y = y ; this . topRow = top ; this . leftColumn = left ; this . activePane = active ; this . frozen = frozen ; } public short getVerticalSplitPosition ( ) { return x ; } public short getHorizontalSplitPosition ( ) { return y ; } public short getHorizontalSplitTopRow ( ) { return topRow ; } public short getVerticalSplitLeftColumn ( ) { return leftColumn ; } public byte getActivePane ( ) { return activePane ; } public boolean isFreezePane ( ) { return frozen ; } } 	0	['7', '1', '0', '2', '8', '9', '2', '0', '7', '0.966666667', '59', '0.6', '0', '0', '0.357142857', '0', '0', '6', '1', '0.8571', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . record . RecordInputStream ; public class DeletedRef3DPtg extends Ref3DPtg { public final static byte sid = 0x3c ; public DeletedRef3DPtg ( RecordInputStream in ) { super ( in ) ; } public DeletedRef3DPtg ( String cellref , short externIdx ) { super ( cellref , externIdx ) ; } } 	0	['2', '3', '0', '3', '4', '1', '1', '2', '2', '2', '12', '0', '0', '1', '0.625', '0', '0', '4.5', '0', '0', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class UnionPtg extends OperationPtg { public final static byte sid = 0x10 ; public UnionPtg ( ) { } public UnionPtg ( RecordInputStream in ) { } public int getSize ( ) { return 1 ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public Object clone ( ) { return new UnionPtg ( ) ; } public int getType ( ) { return TYPE_BINARY ; } public String toFormulaString ( Workbook book ) { return "," ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( "," ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public int getNumberOfOperands ( ) { return 2 ; } } 	0	['9', '2', '0', '5', '13', '36', '2', '3', '9', '1.125', '58', '0', '0', '0.3', '0.259259259', '0', '0', '5.333333333', '1', '0.7778', '0']
package org . apache . poi . hpsf ; public class MarkUnsupportedException extends HPSFException { public MarkUnsupportedException ( ) { super ( ) ; } public MarkUnsupportedException ( final String msg ) { super ( msg ) ; } public MarkUnsupportedException ( final Throwable reason ) { super ( reason ) ; } public MarkUnsupportedException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0	['4', '4', '0', '3', '8', '6', '2', '1', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ShortField implements FixedField { private short _value ; private final int _offset ; public ShortField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public ShortField ( final int offset , final short value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public ShortField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ShortField ( final int offset , final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public short get ( ) { return _value ; } public void set ( final short value ) { _value = value ; } public void set ( final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getShort ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readShort ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putShort ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '5', '21', '9', '2', '3', '11', '0.25', '92', '1', '0', '0', '0.454545455', '0', '0', '7.181818182', '1', '0.6364', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . IntMapper ; class SSTRecordSizeCalculator { private IntMapper strings ; public SSTRecordSizeCalculator ( IntMapper strings ) { this . strings = strings ; } public int getRecordSize ( ) { UnicodeString . UnicodeRecordStats rs = new UnicodeString . UnicodeRecordStats ( ) ; rs . remainingSize -= SSTRecord . SST_RECORD_OVERHEAD ; rs . recordSize += SSTRecord . SST_RECORD_OVERHEAD ; for ( int i = 0 ; i < strings . size ( ) ; i ++ ) { UnicodeString unistr = ( ( UnicodeString ) strings . get ( i ) ) ; unistr . getRecordSize ( rs ) ; } return rs . recordSize ; } } 	0	['2', '1', '0', '4', '7', '0', '1', '3', '2', '0', '46', '1', '1', '0', '0.75', '0', '0', '21.5', '2', '1', '0']
package org . apache . poi . util ; import org . apache . poi . hssf . usermodel . HSSFSheet ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import java . io . FileInputStream ; import java . io . IOException ; public class DrawingDump { public static void main ( String [ ] args ) throws IOException { POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( args [ 0 ] ) ) ; HSSFWorkbook wb = new HSSFWorkbook ( fs ) ; System . out . println ( "Drawing group:" ) ; wb . dumpDrawingGroupRecords ( true ) ; for ( int sheetNum = 1 ; sheetNum <= wb . getNumberOfSheets ( ) ; sheetNum ++ ) { System . out . println ( "Sheet " + sheetNum + ":" ) ; HSSFSheet sheet = wb . getSheetAt ( sheetNum - 1 ) ; sheet . dumpDrawingRecords ( true ) ; } } } 	0	['2', '1', '0', '3', '15', '1', '0', '3', '2', '2', '56', '0', '0', '0', '0.5', '0', '0', '27', '1', '0.5', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class DividePtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x06 ; public DividePtg ( ) { } public DividePtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "/" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { DividePtg ptg = new DividePtg ( ) ; return ptg ; } } 	0	['9', '2', '0', '5', '13', '36', '2', '3', '9', '1.125', '64', '0', '0', '0.3', '0.259259259', '0', '0', '5.888888889', '1', '0.7778', '0']
package org . apache . poi . hpsf ; public class HPSFException extends Exception { private Throwable reason ; public HPSFException ( ) { super ( ) ; } public HPSFException ( final String msg ) { super ( msg ) ; } public HPSFException ( final Throwable reason ) { super ( ) ; this . reason = reason ; } public HPSFException ( final String msg , final Throwable reason ) { super ( msg ) ; this . reason = reason ; } public Throwable getReason ( ) { return reason ; } } 	0	['5', '3', '4', '5', '7', '4', '5', '0', '5', '0.5', '29', '1', '0', '0.944444444', '0.6', '0', '0', '4.6', '1', '0.2', '0']
package org . apache . poi . hssf . model ; public interface Model { } 	0	['0', '1', '0', '4', '0', '0', '4', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . util ; import java . util . List ; import java . util . ArrayList ; public class DoubleList2d { List rows = new ArrayList ( ) ; public double get ( int col , int row ) { if ( row >= rows . size ( ) ) { return 0 ; } else { DoubleList cols = ( DoubleList ) rows . get ( row ) ; if ( col >= cols . size ( ) ) return 0 ; else return cols . get ( col ) ; } } public void set ( int col , int row , double value ) { resizeRows ( row ) ; resizeCols ( row , col ) ; DoubleList cols = ( DoubleList ) rows . get ( row ) ; cols . set ( col , value ) ; } private void resizeRows ( int row ) { while ( rows . size ( ) <= row ) rows . add ( new DoubleList ( ) ) ; } private void resizeCols ( int row , int col ) { DoubleList cols = ( DoubleList ) rows . get ( row ) ; while ( cols . size ( ) <= col ) cols . add ( 0 ) ; } } 	0	['5', '1', '0', '1', '15', '0', '0', '1', '3', '0', '86', '0', '0', '0', '0.666666667', '0', '0', '16', '3', '1.6', '0']
package org . apache . poi . hpsf ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; public class Variant { public static final int VT_EMPTY = 0 ; public static final int VT_NULL = 1 ; public static final int VT_I2 = 2 ; public static final int VT_I4 = 3 ; public static final int VT_R4 = 4 ; public static final int VT_R8 = 5 ; public static final int VT_CY = 6 ; public static final int VT_DATE = 7 ; public static final int VT_BSTR = 8 ; public static final int VT_DISPATCH = 9 ; public static final int VT_ERROR = 10 ; public static final int VT_BOOL = 11 ; public static final int VT_VARIANT = 12 ; public static final int VT_UNKNOWN = 13 ; public static final int VT_DECIMAL = 14 ; public static final int VT_I1 = 16 ; public static final int VT_UI1 = 17 ; public static final int VT_UI2 = 18 ; public static final int VT_UI4 = 19 ; public static final int VT_I8 = 20 ; public static final int VT_UI8 = 21 ; public static final int VT_INT = 22 ; public static final int VT_UINT = 23 ; public static final int VT_VOID = 24 ; public static final int VT_HRESULT = 25 ; public static final int VT_PTR = 26 ; public static final int VT_SAFEARRAY = 27 ; public static final int VT_CARRAY = 28 ; public static final int VT_USERDEFINED = 29 ; public static final int VT_LPSTR = 30 ; public static final int VT_LPWSTR = 31 ; public static final int VT_FILETIME = 64 ; public static final int VT_BLOB = 65 ; public static final int VT_STREAM = 66 ; public static final int VT_STORAGE = 67 ; public static final int VT_STREAMED_OBJECT = 68 ; public static final int VT_STORED_OBJECT = 69 ; public static final int VT_BLOB_OBJECT = 70 ; public static final int VT_CF = 71 ; public static final int VT_CLSID = 72 ; public static final int VT_VECTOR = 0x1000 ; public static final int VT_ARRAY = 0x2000 ; public static final int VT_BYREF = 0x4000 ; public static final int VT_RESERVED = 0x8000 ; public static final int VT_ILLEGAL = 0xFFFF ; public static final int VT_ILLEGALMASKED = 0xFFF ; public static final int VT_TYPEMASK = 0xFFF ; private static Map numberToName ; private static Map numberToLength ; public static final Integer LENGTH_UNKNOWN = new Integer ( - 2 ) ; public static final Integer LENGTH_VARIABLE = new Integer ( - 1 ) ; public static final Integer LENGTH_0 = new Integer ( 0 ) ; public static final Integer LENGTH_2 = new Integer ( 2 ) ; public static final Integer LENGTH_4 = new Integer ( 4 ) ; public static final Integer LENGTH_8 = new Integer ( 8 ) ; static { Map tm1 = new HashMap ( ) ; tm1 . put ( new Long ( 0 ) , "VT_EMPTY" ) ; tm1 . put ( new Long ( 1 ) , "VT_NULL" ) ; tm1 . put ( new Long ( 2 ) , "VT_I2" ) ; tm1 . put ( new Long ( 3 ) , "VT_I4" ) ; tm1 . put ( new Long ( 4 ) , "VT_R4" ) ; tm1 . put ( new Long ( 5 ) , "VT_R8" ) ; tm1 . put ( new Long ( 6 ) , "VT_CY" ) ; tm1 . put ( new Long ( 7 ) , "VT_DATE" ) ; tm1 . put ( new Long ( 8 ) , "VT_BSTR" ) ; tm1 . put ( new Long ( 9 ) , "VT_DISPATCH" ) ; tm1 . put ( new Long ( 10 ) , "VT_ERROR" ) ; tm1 . put ( new Long ( 11 ) , "VT_BOOL" ) ; tm1 . put ( new Long ( 12 ) , "VT_VARIANT" ) ; tm1 . put ( new Long ( 13 ) , "VT_UNKNOWN" ) ; tm1 . put ( new Long ( 14 ) , "VT_DECIMAL" ) ; tm1 . put ( new Long ( 16 ) , "VT_I1" ) ; tm1 . put ( new Long ( 17 ) , "VT_UI1" ) ; tm1 . put ( new Long ( 18 ) , "VT_UI2" ) ; tm1 . put ( new Long ( 19 ) , "VT_UI4" ) ; tm1 . put ( new Long ( 20 ) , "VT_I8" ) ; tm1 . put ( new Long ( 21 ) , "VT_UI8" ) ; tm1 . put ( new Long ( 22 ) , "VT_INT" ) ; tm1 . put ( new Long ( 23 ) , "VT_UINT" ) ; tm1 . put ( new Long ( 24 ) , "VT_VOID" ) ; tm1 . put ( new Long ( 25 ) , "VT_HRESULT" ) ; tm1 . put ( new Long ( 26 ) , "VT_PTR" ) ; tm1 . put ( new Long ( 27 ) , "VT_SAFEARRAY" ) ; tm1 . put ( new Long ( 28 ) , "VT_CARRAY" ) ; tm1 . put ( new Long ( 29 ) , "VT_USERDEFINED" ) ; tm1 . put ( new Long ( 30 ) , "VT_LPSTR" ) ; tm1 . put ( new Long ( 31 ) , "VT_LPWSTR" ) ; tm1 . put ( new Long ( 64 ) , "VT_FILETIME" ) ; tm1 . put ( new Long ( 65 ) , "VT_BLOB" ) ; tm1 . put ( new Long ( 66 ) , "VT_STREAM" ) ; tm1 . put ( new Long ( 67 ) , "VT_STORAGE" ) ; tm1 . put ( new Long ( 68 ) , "VT_STREAMED_OBJECT" ) ; tm1 . put ( new Long ( 69 ) , "VT_STORED_OBJECT" ) ; tm1 . put ( new Long ( 70 ) , "VT_BLOB_OBJECT" ) ; tm1 . put ( new Long ( 71 ) , "VT_CF" ) ; tm1 . put ( new Long ( 72 ) , "VT_CLSID" ) ; Map tm2 = new HashMap ( tm1 . size ( ) , 1.0F ) ; tm2 . putAll ( tm1 ) ; numberToName = Collections . unmodifiableMap ( tm2 ) ; tm1 . clear ( ) ; tm1 . put ( new Long ( 0 ) , LENGTH_0 ) ; tm1 . put ( new Long ( 1 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 2 ) , LENGTH_2 ) ; tm1 . put ( new Long ( 3 ) , LENGTH_4 ) ; tm1 . put ( new Long ( 4 ) , LENGTH_4 ) ; tm1 . put ( new Long ( 5 ) , LENGTH_8 ) ; tm1 . put ( new Long ( 6 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 7 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 8 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 9 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 10 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 11 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 12 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 13 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 14 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 16 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 17 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 18 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 19 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 20 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 21 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 22 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 23 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 24 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 25 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 26 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 27 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 28 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 29 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 30 ) , LENGTH_VARIABLE ) ; tm1 . put ( new Long ( 31 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 64 ) , LENGTH_8 ) ; tm1 . put ( new Long ( 65 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 66 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 67 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 68 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 69 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 70 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 71 ) , LENGTH_UNKNOWN ) ; tm1 . put ( new Long ( 72 ) , LENGTH_UNKNOWN ) ; tm2 = new HashMap ( tm1 . size ( ) , 1.0F ) ; tm2 . putAll ( tm1 ) ; numberToLength = Collections . unmodifiableMap ( tm2 ) ; } public static String getVariantName ( final long variantType ) { final String name = ( String ) numberToName . get ( new Long ( variantType ) ) ; return name != null ? name : "unknown variant type" ; } public static int getVariantLength ( final long variantType ) { final Long key = new Long ( ( int ) variantType ) ; final Long length = ( Long ) numberToLength . get ( key ) ; if ( length == null ) return - 2 ; return length . intValue ( ) ; } } 	0	['4', '1', '1', '3', '16', '2', '3', '0', '3', '1.272727273', '798', '0.036363636', '0', '0', '0.5', '0', '0', '184.75', '2', '1', '0']
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class UnaryPlusPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x12 ; private final static String ADD = "+" ; public UnaryPlusPtg ( ) { } public UnaryPlusPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return this . TYPE_UNARY ; } public int getNumberOfOperands ( ) { return 1 ; } public String toFormulaString ( Workbook book ) { return "+" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( ADD ) ; buffer . append ( operands [ 0 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new UnaryPlusPtg ( ) ; } } 	0	['10', '2', '0', '6', '14', '45', '3', '3', '10', '1.111111111', '59', '0.333333333', '0', '0.272727273', '0.25', '0', '0', '4.6', '1', '0.8', '0']
package org . apache . poi . poifs . filesystem ; public interface BATManaged { public int countBlocks ( ) ; public void setStartBlock ( final int index ) ; } 	0	['2', '1', '0', '5', '2', '1', '5', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . filesystem ; public interface DocumentEntry extends Entry { public int getSize ( ) ; } 	0	['1', '1', '0', '8', '1', '0', '7', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; abstract class BigBlock implements BlockWritable { protected void doWriteData ( final OutputStream stream , final byte [ ] data ) throws IOException { stream . write ( data ) ; } abstract void writeData ( final OutputStream stream ) throws IOException ; public void writeBlocks ( final OutputStream stream ) throws IOException { writeData ( stream ) ; } } 	0	['4', '1', '4', '5', '6', '6', '4', '1', '1', '2', '15', '0', '0', '0', '0.666666667', '0', '0', '2.75', '1', '0.75', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; public interface BlockWritable { public void writeBlocks ( final OutputStream stream ) throws IOException ; } 	0	['1', '1', '0', '9', '1', '0', '9', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class EqualPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0b ; public EqualPtg ( ) { } public EqualPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "=" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new EqualPtg ( ) ; } } 	0	['9', '2', '0', '5', '13', '36', '2', '3', '9', '1.125', '62', '0', '0', '0.3', '0.259259259', '0', '0', '5.666666667', '1', '0.7778', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class IntegerField implements FixedField { private int _value ; private final int _offset ; public IntegerField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "negative offset" ) ; } _offset = offset ; } public IntegerField ( final int offset , final int value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public IntegerField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public IntegerField ( final int offset , final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public int get ( ) { return _value ; } public void set ( final int value ) { _value = value ; } public void set ( final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getInt ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readInt ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putInt ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '7', '17', '9', '4', '3', '11', '0.25', '85', '1', '0', '0', '0.522727273', '0', '0', '6.545454545', '1', '0.6364', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class AddPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x03 ; private final static String ADD = "+" ; public AddPtg ( ) { } public AddPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "+" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( ADD ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new AddPtg ( ) ; } } 	0	['10', '2', '0', '5', '14', '45', '2', '3', '10', '1.111111111', '63', '0.333333333', '0', '0.272727273', '0.25', '0', '0', '5', '1', '0.8', '0']
package org . apache . poi . poifs . dev ; import java . util . Iterator ; public interface POIFSViewable { public Object [ ] getViewableArray ( ) ; public Iterator getViewableIterator ( ) ; public boolean preferArray ( ) ; public String getShortDescription ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '6', '0', '4', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFRequest ; import org . apache . poi . hssf . eventusermodel . HSSFListener ; import org . apache . poi . hssf . eventusermodel . HSSFEventFactory ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	0	['4', '1', '0', '6', '16', '4', '1', '6', '4', '0.333333333', '82', '0', '0', '0', '0.416666667', '0', '0', '19.25', '3', '1.25', '0']
package org . apache . poi . hssf . usermodel ; import java . util . ArrayList ; import java . util . List ; import java . util . Iterator ; public class HSSFShapeGroup extends HSSFShape implements HSSFShapeContainer { List shapes = new ArrayList ( ) ; int x1 = 0 ; int y1 = 0 ; int x2 = 1023 ; int y2 = 255 ; public HSSFShapeGroup ( HSSFShape parent , HSSFAnchor anchor ) { super ( parent , anchor ) ; } public HSSFShapeGroup createGroup ( HSSFChildAnchor anchor ) { HSSFShapeGroup group = new HSSFShapeGroup ( this , anchor ) ; group . anchor = anchor ; shapes . add ( group ) ; return group ; } public HSSFSimpleShape createShape ( HSSFChildAnchor anchor ) { HSSFSimpleShape shape = new HSSFSimpleShape ( this , anchor ) ; shape . anchor = anchor ; shapes . add ( shape ) ; return shape ; } public HSSFTextbox createTextbox ( HSSFChildAnchor anchor ) { HSSFTextbox shape = new HSSFTextbox ( this , anchor ) ; shape . anchor = anchor ; shapes . add ( shape ) ; return shape ; } public HSSFPolygon createPolygon ( HSSFChildAnchor anchor ) { HSSFPolygon shape = new HSSFPolygon ( this , anchor ) ; shape . anchor = anchor ; shapes . add ( shape ) ; return shape ; } public HSSFPicture createPicture ( HSSFChildAnchor anchor , int pictureIndex ) { HSSFPicture shape = new HSSFPicture ( this , anchor ) ; shape . anchor = anchor ; shape . setPictureIndex ( pictureIndex ) ; shapes . add ( shape ) ; return shape ; } public List getChildren ( ) { return shapes ; } public void setCoordinates ( int x1 , int y1 , int x2 , int y2 ) { this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; } public int getX1 ( ) { return x1 ; } public int getY1 ( ) { return y1 ; } public int getX2 ( ) { return x2 ; } public int getY2 ( ) { return y2 ; } public int countOfAllChildren ( ) { int count = shapes . size ( ) ; for ( Iterator iterator = shapes . iterator ( ) ; iterator . hasNext ( ) ; ) { HSSFShape shape = ( HSSFShape ) iterator . next ( ) ; count += shape . countOfAllChildren ( ) ; } return count ; } } 	0	['13', '2', '0', '11', '26', '4', '3', '8', '13', '0.683333333', '174', '0', '0', '0.571428571', '0.338461538', '1', '1', '12', '2', '1', '0']
package org . apache . poi . util ; import java . io . * ; import java . util . List ; import java . util . ArrayList ; public class HexRead { public static byte [ ] readData ( String filename ) throws IOException { File file = new File ( filename ) ; FileInputStream stream = new FileInputStream ( file ) ; try { return readData ( stream , - 1 ) ; } finally { stream . close ( ) ; } } public static byte [ ] readData ( String filename , String section ) throws IOException { File file = new File ( filename ) ; FileInputStream stream = new FileInputStream ( file ) ; try { StringBuffer sectionText = new StringBuffer ( ) ; boolean inSection = false ; int c = stream . read ( ) ; while ( c != - 1 ) { switch ( c ) { case '[' : inSection = true ; break ; case '\n' : case '\r' : inSection = false ; sectionText = new StringBuffer ( ) ; break ; case ']' : inSection = false ; if ( sectionText . toString ( ) . equals ( section ) ) return readData ( stream , '[' ) ; sectionText = new StringBuffer ( ) ; break ; default : if ( inSection ) sectionText . append ( ( char ) c ) ; } c = stream . read ( ) ; } } finally { stream . close ( ) ; } throw new IOException ( "Section '" + section + "' not found" ) ; } static public byte [ ] readData ( InputStream stream , int eofChar ) throws IOException { int characterCount = 0 ; byte b = ( byte ) 0 ; List bytes = new ArrayList ( ) ; boolean done = false ; while ( ! done ) { int count = stream . read ( ) ; char baseChar = 'a' ; if ( count == eofChar ) break ; switch ( count ) { case '#' : readToEOL ( stream ) ; break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : b <<= 4 ; b += ( byte ) ( count - '0' ) ; characterCount ++ ; if ( characterCount == 2 ) { bytes . add ( new Byte ( b ) ) ; characterCount = 0 ; b = ( byte ) 0 ; } break ; case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : baseChar = 'A' ; case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : b <<= 4 ; b += ( byte ) ( count + 10 - baseChar ) ; characterCount ++ ; if ( characterCount == 2 ) { bytes . add ( new Byte ( b ) ) ; characterCount = 0 ; b = ( byte ) 0 ; } break ; case - 1 : done = true ; break ; default : break ; } } Byte [ ] polished = ( Byte [ ] ) bytes . toArray ( new Byte [ 0 ] ) ; byte [ ] rval = new byte [ polished . length ] ; for ( int j = 0 ; j < polished . length ; j ++ ) { rval [ j ] = polished [ j ] . byteValue ( ) ; } return rval ; } static public byte [ ] readFromString ( String data ) throws IOException { return readData ( new ByteArrayInputStream ( data . getBytes ( ) ) , - 1 ) ; } static private void readToEOL ( InputStream stream ) throws IOException { int c = stream . read ( ) ; while ( c != - 1 && c != '\n' && c != '\r' ) { c = stream . read ( ) ; } } } 	0	['6', '1', '0', '1', '27', '15', '1', '0', '5', '2', '264', '0', '0', '0', '0.291666667', '0', '0', '43', '1', '0.8333', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . RecordInputStream ; public class NamePtg extends Ptg { public final static short sid = 0x23 ; private final static int SIZE = 5 ; private short field_1_label_index ; private short field_2_zero ; boolean xtra = false ; private NamePtg ( ) { } public NamePtg ( String name , Workbook book ) { final short n = ( short ) ( book . getNumNames ( ) + 1 ) ; NameRecord rec ; for ( short i = 1 ; i < n ; i ++ ) { rec = book . getNameRecord ( i - 1 ) ; if ( name . equals ( rec . getNameText ( ) ) ) { field_1_label_index = i ; return ; } } rec = new NameRecord ( ) ; rec . setNameText ( name ) ; rec . setNameTextLength ( ( byte ) name . length ( ) ) ; book . addName ( rec ) ; field_1_label_index = n ; } public NamePtg ( RecordInputStream in ) { field_1_label_index = in . readShort ( ) ; field_2_zero = in . readShort ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_label_index ) ; LittleEndian . putShort ( array , offset + 3 , field_2_zero ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { NameRecord rec = book . getNameRecord ( field_1_label_index - 1 ) ; return rec . getNameText ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { NamePtg ptg = new NamePtg ( ) ; ptg . field_1_label_index = field_1_label_index ; ptg . field_2_zero = field_2_zero ; return ptg ; } } 	0	['8', '2', '0', '6', '20', '4', '2', '5', '7', '0.8', '143', '0.6', '0', '0.583333333', '0.291666667', '1', '2', '16.25', '1', '0.625', '0']
package org . apache . poi . hpsf ; import org . apache . poi . util . HexDump ; public class IllegalVariantTypeException extends VariantTypeException { public IllegalVariantTypeException ( final long variantType , final Object value , final String msg ) { super ( variantType , value , msg ) ; } public IllegalVariantTypeException ( final long variantType , final Object value ) { this ( variantType , value , "The variant type " + variantType + " (" + Variant . getVariantName ( variantType ) + ", " + HexDump . toHex ( variantType ) + ") is illegal in this context." ) ; } } 	0	['2', '5', '0', '3', '9', '1', '0', '3', '2', '2', '33', '0', '0', '1', '0.875', '0', '0', '15.5', '0', '0', '0']
package org . apache . poi . poifs . eventfilesystem ; public interface POIFSReaderListener { public void processPOIFSReaderEvent ( POIFSReaderEvent event ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . util ; public class BitField { private final int _mask ; private final int _shift_count ; public BitField ( final int mask ) { _mask = mask ; int count = 0 ; int bit_pattern = mask ; if ( bit_pattern != 0 ) { while ( ( bit_pattern & 1 ) == 0 ) { count ++ ; bit_pattern >>= 1 ; } } _shift_count = count ; } public int getValue ( final int holder ) { return getRawValue ( holder ) > > _shift_count ; } public short getShortValue ( final short holder ) { return ( short ) getValue ( holder ) ; } public int getRawValue ( final int holder ) { return ( holder & _mask ) ; } public short getShortRawValue ( final short holder ) { return ( short ) getRawValue ( holder ) ; } public boolean isSet ( final int holder ) { return ( holder & _mask ) != 0 ; } public boolean isAllSet ( final int holder ) { return ( holder & _mask ) == _mask ; } public int setValue ( final int holder , final int value ) { return ( holder & ~ _mask ) | ( ( value << _shift_count ) & _mask ) ; } public short setShortValue ( final short holder , final short value ) { return ( short ) setValue ( holder , value ) ; } public int clear ( final int holder ) { return holder & ~ _mask ; } public short clearShort ( final short holder ) { return ( short ) clear ( holder ) ; } public byte clearByte ( final byte holder ) { return ( byte ) clear ( holder ) ; } public int set ( final int holder ) { return holder | _mask ; } public short setShort ( final short holder ) { return ( short ) set ( holder ) ; } public byte setByte ( final byte holder ) { return ( byte ) set ( holder ) ; } public int setBoolean ( final int holder , final boolean flag ) { return flag ? set ( holder ) : clear ( holder ) ; } public short setShortBoolean ( final short holder , final boolean flag ) { return flag ? setShort ( holder ) : clearShort ( holder ) ; } public byte setByteBoolean ( final byte holder , final boolean flag ) { return flag ? setByte ( holder ) : clearByte ( holder ) ; } } 	0	['18', '1', '0', '37', '19', '107', '37', '0', '18', '0.382352941', '170', '1', '0', '0', '0.433333333', '0', '0', '8.333333333', '2', '1.2222', '0']
package org . apache . poi . util ; import java . io . InputStream ; import java . io . IOException ; public class BlockingInputStream extends InputStream { protected InputStream is ; public BlockingInputStream ( InputStream is ) { this . is = is ; } public int available ( ) throws IOException { return is . available ( ) ; } public void close ( ) throws IOException { is . close ( ) ; } public void mark ( int readLimit ) { is . mark ( readLimit ) ; } public boolean markSupported ( ) { return is . markSupported ( ) ; } public int read ( ) throws IOException { return is . read ( ) ; } public int read ( byte [ ] bf ) throws IOException { int i = 0 ; int b = 4611 ; while ( i < bf . length ) { b = is . read ( ) ; if ( b == - 1 ) break ; bf [ i ++ ] = ( byte ) b ; } if ( i == 0 && b == - 1 ) return - 1 ; return i ; } public int read ( byte [ ] bf , int s , int l ) throws IOException { return is . read ( bf , s , l ) ; } public void reset ( ) throws IOException { is . reset ( ) ; } public long skip ( long n ) throws IOException { return is . skip ( n ) ; } } 	0	['10', '2', '0', '0', '19', '0', '0', '0', '10', '0', '86', '1', '0', '0.5', '0.32', '1', '2', '7.5', '1', '0.9', '0']
package org . apache . poi . poifs . property ; public interface PropertyConstants { public static final int PROPERTY_TYPE_OFFSET = 0x42 ; public static final byte DIRECTORY_TYPE = 1 ; public static final byte DOCUMENT_TYPE = 2 ; public static final byte ROOT_TYPE = 5 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . hpsf ; public class MissingSectionException extends HPSFRuntimeException { public MissingSectionException ( ) { super ( ) ; } public MissingSectionException ( final String msg ) { super ( msg ) ; } public MissingSectionException ( final Throwable reason ) { super ( reason ) ; } public MissingSectionException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0	['4', '5', '0', '2', '8', '6', '1', '1', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . poi . hpsf ; public class NoPropertySetStreamException extends HPSFException { public NoPropertySetStreamException ( ) { super ( ) ; } public NoPropertySetStreamException ( final String msg ) { super ( msg ) ; } public NoPropertySetStreamException ( final Throwable reason ) { super ( reason ) ; } public NoPropertySetStreamException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0	['4', '4', '0', '3', '8', '6', '2', '1', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class IntersectionPtg extends OperationPtg { public final static byte sid = 0x0f ; public IntersectionPtg ( ) { } public IntersectionPtg ( RecordInputStream in ) { } public int getSize ( ) { return 1 ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public Object clone ( ) { return new IntersectionPtg ( ) ; } public int getType ( ) { return TYPE_BINARY ; } public String toFormulaString ( Workbook book ) { return " " ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public int getNumberOfOperands ( ) { return 2 ; } } 	0	['9', '2', '0', '4', '13', '36', '1', '3', '9', '1.125', '58', '0', '0', '0.3', '0.259259259', '0', '0', '5.333333333', '1', '0.7778', '0']
package org . apache . poi . hssf . record . formula ; public abstract class ControlPtg extends Ptg { } 	0	['1', '2', '1', '2', '2', '0', '1', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . poi . hpsf ; public class IllegalPropertySetDataException extends HPSFRuntimeException { public IllegalPropertySetDataException ( ) { super ( ) ; } public IllegalPropertySetDataException ( final String msg ) { super ( msg ) ; } public IllegalPropertySetDataException ( final Throwable reason ) { super ( reason ) ; } public IllegalPropertySetDataException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0	['4', '5', '0', '4', '8', '6', '3', '1', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . ColumnInfoRecord ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordInputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class ColumnInfoRecordsAggregate extends Record { List records = null ; public ColumnInfoRecordsAggregate ( ) { records = new ArrayList ( ) ; } protected void fillFields ( RecordInputStream in ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return - 1012 ; } public int getRecordSize ( ) { int size = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) size += ( ( ColumnInfoRecord ) iterator . next ( ) ) . getRecordSize ( ) ; return size ; } public Iterator getIterator ( ) { return records . iterator ( ) ; } public Object clone ( ) { ColumnInfoRecordsAggregate rec = new ColumnInfoRecordsAggregate ( ) ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { ColumnInfoRecord ci = ( ColumnInfoRecord ) records . get ( k ) ; ci = ( ColumnInfoRecord ) ci . clone ( ) ; rec . insertColumn ( ci ) ; } return rec ; } public void insertColumn ( ColumnInfoRecord col ) { records . add ( col ) ; } public void insertColumn ( int idx , ColumnInfoRecord col ) { records . add ( idx , col ) ; } public int getNumColumns ( ) { return records . size ( ) ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } public int findStartOfColumnOutlineGroup ( int idx ) { ColumnInfoRecord columnInfo = ( ColumnInfoRecord ) records . get ( idx ) ; int level = columnInfo . getOutlineLevel ( ) ; while ( idx != 0 ) { ColumnInfoRecord prevColumnInfo = ( ColumnInfoRecord ) records . get ( idx - 1 ) ; if ( columnInfo . getFirstColumn ( ) - 1 == prevColumnInfo . getLastColumn ( ) ) { if ( prevColumnInfo . getOutlineLevel ( ) < level ) { break ; } idx -- ; columnInfo = prevColumnInfo ; } else { break ; } } return idx ; } public int findEndOfColumnOutlineGroup ( int idx ) { ColumnInfoRecord columnInfo = ( ColumnInfoRecord ) records . get ( idx ) ; int level = columnInfo . getOutlineLevel ( ) ; while ( idx < records . size ( ) - 1 ) { ColumnInfoRecord nextColumnInfo = ( ColumnInfoRecord ) records . get ( idx + 1 ) ; if ( columnInfo . getLastColumn ( ) + 1 == nextColumnInfo . getFirstColumn ( ) ) { if ( nextColumnInfo . getOutlineLevel ( ) < level ) { break ; } idx ++ ; columnInfo = nextColumnInfo ; } else { break ; } } return idx ; } public ColumnInfoRecord getColInfo ( int idx ) { return ( ColumnInfoRecord ) records . get ( idx ) ; } public ColumnInfoRecord writeHidden ( ColumnInfoRecord columnInfo , int idx , boolean hidden ) { int level = columnInfo . getOutlineLevel ( ) ; while ( idx < records . size ( ) ) { columnInfo . setHidden ( hidden ) ; if ( idx + 1 < records . size ( ) ) { ColumnInfoRecord nextColumnInfo = ( ColumnInfoRecord ) records . get ( idx + 1 ) ; if ( columnInfo . getLastColumn ( ) + 1 == nextColumnInfo . getFirstColumn ( ) ) { if ( nextColumnInfo . getOutlineLevel ( ) < level ) break ; columnInfo = nextColumnInfo ; } else { break ; } } idx ++ ; } return columnInfo ; } public boolean isColumnGroupCollapsed ( int idx ) { int endOfOutlineGroupIdx = findEndOfColumnOutlineGroup ( idx ) ; if ( endOfOutlineGroupIdx >= records . size ( ) ) return false ; if ( getColInfo ( endOfOutlineGroupIdx ) . getLastColumn ( ) + 1 != getColInfo ( endOfOutlineGroupIdx + 1 ) . getFirstColumn ( ) ) return false ; else return getColInfo ( endOfOutlineGroupIdx + 1 ) . getCollapsed ( ) ; } public boolean isColumnGroupHiddenByParent ( int idx ) { int endLevel ; boolean endHidden ; int endOfOutlineGroupIdx = findEndOfColumnOutlineGroup ( idx ) ; if ( endOfOutlineGroupIdx >= records . size ( ) ) { endLevel = 0 ; endHidden = false ; } else if ( getColInfo ( endOfOutlineGroupIdx ) . getLastColumn ( ) + 1 != getColInfo ( endOfOutlineGroupIdx + 1 ) . getFirstColumn ( ) ) { endLevel = 0 ; endHidden = false ; } else { endLevel = getColInfo ( endOfOutlineGroupIdx + 1 ) . getOutlineLevel ( ) ; endHidden = getColInfo ( endOfOutlineGroupIdx + 1 ) . getHidden ( ) ; } int startLevel ; boolean startHidden ; int startOfOutlineGroupIdx = findStartOfColumnOutlineGroup ( idx ) ; if ( startOfOutlineGroupIdx <= 0 ) { startLevel = 0 ; startHidden = false ; } else if ( getColInfo ( startOfOutlineGroupIdx ) . getFirstColumn ( ) - 1 != getColInfo ( startOfOutlineGroupIdx - 1 ) . getLastColumn ( ) ) { startLevel = 0 ; startHidden = false ; } else { startLevel = getColInfo ( startOfOutlineGroupIdx - 1 ) . getOutlineLevel ( ) ; startHidden = getColInfo ( startOfOutlineGroupIdx - 1 ) . getHidden ( ) ; } if ( endLevel > startLevel ) { return endHidden ; } else { return startHidden ; } } public void collapseColumn ( short columnNumber ) { int idx = findColumnIdx ( columnNumber , 0 ) ; if ( idx == - 1 ) return ; ColumnInfoRecord columnInfo = ( ColumnInfoRecord ) records . get ( findStartOfColumnOutlineGroup ( idx ) ) ; columnInfo = writeHidden ( columnInfo , idx , true ) ; setColumn ( ( short ) ( columnInfo . getLastColumn ( ) + 1 ) , null , null , null , null , Boolean . TRUE ) ; } public void expandColumn ( short columnNumber ) { int idx = findColumnIdx ( columnNumber , 0 ) ; if ( idx == - 1 ) return ; if ( ! isColumnGroupCollapsed ( idx ) ) return ; int startIdx = findStartOfColumnOutlineGroup ( idx ) ; ColumnInfoRecord columnInfo = getColInfo ( startIdx ) ; int endIdx = findEndOfColumnOutlineGroup ( idx ) ; ColumnInfoRecord endColumnInfo = getColInfo ( endIdx ) ; if ( ! isColumnGroupHiddenByParent ( idx ) ) { for ( int i = startIdx ; i <= endIdx ; i ++ ) { if ( columnInfo . getOutlineLevel ( ) == getColInfo ( i ) . getOutlineLevel ( ) ) getColInfo ( i ) . setHidden ( false ) ; } } setColumn ( ( short ) ( columnInfo . getLastColumn ( ) + 1 ) , null , null , null , null , Boolean . FALSE ) ; } public static Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 2275 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public void setColumn ( short column , Short xfIndex , Short width , Integer level , Boolean hidden , Boolean collapsed ) { ColumnInfoRecord ci = null ; int k = 0 ; for ( k = 0 ; k < records . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) records . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } if ( ci != null ) { boolean styleChanged = xfIndex != null && ci . getXFIndex ( ) != xfIndex . shortValue ( ) ; boolean widthChanged = width != null && ci . getColumnWidth ( ) != width . shortValue ( ) ; boolean levelChanged = level != null && ci . getOutlineLevel ( ) != level . intValue ( ) ; boolean hiddenChanged = hidden != null && ci . getHidden ( ) != hidden . booleanValue ( ) ; boolean collapsedChanged = collapsed != null && ci . getCollapsed ( ) != collapsed . booleanValue ( ) ; boolean columnChanged = styleChanged || widthChanged || levelChanged || hiddenChanged || collapsedChanged ; if ( ! columnChanged ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { setColumnInfoFields ( ci , xfIndex , width , level , hidden , collapsed ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; setColumnInfoFields ( nci , xfIndex , width , level , hidden , collapsed ) ; insertColumn ( k , nci ) ; } else { short lastcolumn = ci . getLastColumn ( ) ; ci . setLastColumn ( ( short ) ( column - 1 ) ) ; ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; setColumnInfoFields ( nci , xfIndex , width , level , hidden , collapsed ) ; insertColumn ( ++ k , nci ) ; nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( ( short ) ( column + 1 ) ) ; nci . setLastColumn ( lastcolumn ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( ci . getColumnWidth ( ) ) ; insertColumn ( ++ k , nci ) ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; setColumnInfoFields ( nci , xfIndex , width , level , hidden , collapsed ) ; insertColumn ( k , nci ) ; } } private void setColumnInfoFields ( ColumnInfoRecord ci , Short xfStyle , Short width , Integer level , Boolean hidden , Boolean collapsed ) { if ( xfStyle != null ) ci . setXFIndex ( xfStyle . shortValue ( ) ) ; if ( width != null ) ci . setColumnWidth ( width . shortValue ( ) ) ; if ( level != null ) ci . setOutlineLevel ( level . shortValue ( ) ) ; if ( hidden != null ) ci . setHidden ( hidden . booleanValue ( ) ) ; if ( collapsed != null ) ci . setCollapsed ( collapsed . booleanValue ( ) ) ; } public int findColumnIdx ( int column , int fromIdx ) { if ( column < 0 ) throw new IllegalArgumentException ( "column parameter out of range: " + column ) ; if ( fromIdx < 0 ) throw new IllegalArgumentException ( "fromIdx parameter out of range: " + fromIdx ) ; ColumnInfoRecord ci ; for ( int k = fromIdx ; k < records . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) records . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { return k ; } ci = null ; } return - 1 ; } public void collapseColInfoRecords ( int columnIdx ) { if ( columnIdx == 0 ) return ; ColumnInfoRecord previousCol = ( ColumnInfoRecord ) records . get ( columnIdx - 1 ) ; ColumnInfoRecord currentCol = ( ColumnInfoRecord ) records . get ( columnIdx ) ; boolean adjacentColumns = previousCol . getLastColumn ( ) == currentCol . getFirstColumn ( ) - 1 ; if ( ! adjacentColumns ) return ; boolean columnsMatch = previousCol . getXFIndex ( ) == currentCol . getXFIndex ( ) && previousCol . getOptions ( ) == currentCol . getOptions ( ) && previousCol . getColumnWidth ( ) == currentCol . getColumnWidth ( ) ; if ( columnsMatch ) { previousCol . setLastColumn ( currentCol . getLastColumn ( ) ) ; records . remove ( columnIdx ) ; } } public void groupColumnRange ( short fromColumn , short toColumn , boolean indent ) { int fromIdx = 0 ; for ( int i = fromColumn ; i <= toColumn ; i ++ ) { int level = 1 ; int columnIdx = findColumnIdx ( i , Math . max ( 0 , fromIdx ) ) ; if ( columnIdx != - 1 ) { level = ( ( ColumnInfoRecord ) records . get ( columnIdx ) ) . getOutlineLevel ( ) ; if ( indent ) level ++ ; else level -- ; level = Math . max ( 0 , level ) ; level = Math . min ( 7 , level ) ; fromIdx = columnIdx - 1 ; } setColumn ( ( short ) i , null , null , new Integer ( level ) , null , null ) ; columnIdx = findColumnIdx ( i , Math . max ( 0 , fromIdx ) ) ; collapseColInfoRecords ( columnIdx ) ; } } } 	0	['25', '2', '0', '4', '67', '0', '1', '3', '22', '0.208333333', '991', '0', '0', '0.314285714', '0.212', '1', '3', '38.6', '26', '3.8', '0']
package org . apache . poi . poifs . storage ; import java . util . * ; public class SmallDocumentBlockList extends BlockListImpl { public SmallDocumentBlockList ( final List blocks ) { setBlocks ( ( SmallDocumentBlock [ ] ) blocks . toArray ( new SmallDocumentBlock [ 0 ] ) ) ; } } 	0	['5', '2', '0', '5', '12', '10', '1', '4', '5', '2', '32', '0', '0', '0.555555556', '0.5', '0', '0', '5.4', '1', '0.8', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; public class DocumentInputStream extends InputStream { private int _current_offset ; private int _marked_offset ; private int _document_size ; private boolean _closed ; private POIFSDocument _document ; private byte [ ] _tiny_buffer ; static private final int EOD = - 1 ; public DocumentInputStream ( final DocumentEntry document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; if ( document instanceof DocumentNode ) { _document = ( ( DocumentNode ) document ) . getDocument ( ) ; } else { throw new IOException ( "Cannot open internal document storage" ) ; } } public DocumentInputStream ( final POIFSDocument document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; _document = document ; } public int available ( ) throws IOException { dieIfClosed ( ) ; return _document_size - _current_offset ; } public void close ( ) throws IOException { _closed = true ; } public void mark ( int ignoredReadlimit ) { _marked_offset = _current_offset ; } public boolean markSupported ( ) { return true ; } public int read ( ) throws IOException { dieIfClosed ( ) ; if ( atEOD ( ) ) { return EOD ; } if ( _tiny_buffer == null ) { _tiny_buffer = new byte [ 1 ] ; } _document . read ( _tiny_buffer , _current_offset ++ ) ; return ( ( int ) _tiny_buffer [ 0 ] ) & 0x000000FF ; } public int read ( final byte [ ] b ) throws IOException , NullPointerException { return read ( b , 0 , b . length ) ; } public int read ( final byte [ ] b , final int off , final int len ) throws IOException , NullPointerException , IndexOutOfBoundsException { dieIfClosed ( ) ; if ( b == null ) { throw new NullPointerException ( "buffer is null" ) ; } if ( ( off < 0 ) || ( len < 0 ) || ( b . length < ( off + len ) ) ) { throw new IndexOutOfBoundsException ( "can't read past buffer boundaries" ) ; } if ( len == 0 ) { return 0 ; } if ( atEOD ( ) ) { return EOD ; } int limit = Math . min ( available ( ) , len ) ; if ( ( off == 0 ) && ( limit == b . length ) ) { _document . read ( b , _current_offset ) ; } else { byte [ ] buffer = new byte [ limit ] ; _document . read ( buffer , _current_offset ) ; System . arraycopy ( buffer , 0 , b , off , limit ) ; } _current_offset += limit ; return limit ; } public void reset ( ) { _current_offset = _marked_offset ; } public long skip ( final long n ) throws IOException { dieIfClosed ( ) ; if ( n < 0 ) { return 0 ; } int new_offset = _current_offset + ( int ) n ; if ( new_offset < _current_offset ) { new_offset = _document_size ; } else if ( new_offset > _document_size ) { new_offset = _document_size ; } long rval = new_offset - _current_offset ; _current_offset = new_offset ; return rval ; } private void dieIfClosed ( ) throws IOException { if ( _closed ) { throw new IOException ( "cannot perform requested operation on a closed stream" ) ; } } private boolean atEOD ( ) { return _current_offset == _document_size ; } } 	0	['13', '2', '0', '12', '23', '0', '9', '3', '11', '0.642857143', '271', '1', '1', '0.45', '0.256410256', '1', '2', '19.30769231', '2', '0.9231', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class MemErrPtg extends MemAreaPtg { public final static short sid = 0x27 ; public MemErrPtg ( ) { } public MemErrPtg ( RecordInputStream in ) { super ( in ) ; } public void writeBytes ( byte [ ] array , int offset ) { super . writeBytes ( array , offset ) ; array [ offset ] = ( byte ) ( sid + ptgClass ) ; } public String toFormulaString ( Workbook book ) { return "ERR#" ; } public Object clone ( ) { MemErrPtg ptg = new MemErrPtg ( ) ; ptg . setReserved ( getReserved ( ) ) ; ptg . setSubexpressionLength ( getSubexpressionLength ( ) ) ; return ptg ; } } 	0	['5', '3', '0', '4', '12', '10', '1', '3', '5', '1.25', '42', '0', '0', '0.842105263', '0.36', '2', '2', '7.2', '1', '0.6', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . record . RecordInputStream ; public class DeletedArea3DPtg extends Area3DPtg { public final static byte sid = 0x3d ; public DeletedArea3DPtg ( String arearef , short externIdx ) { super ( arearef , externIdx ) ; } public DeletedArea3DPtg ( RecordInputStream in ) { super ( in ) ; } } 	0	['2', '3', '0', '3', '4', '1', '1', '2', '2', '2', '12', '0', '0', '1', '0.625', '0', '0', '4.5', '0', '0', '0']
package org . apache . poi . hssf . usermodel ; public class HSSFPolygon extends HSSFShape { int [ ] xPoints ; int [ ] yPoints ; int drawAreaWidth = 100 ; int drawAreaHeight = 100 ; HSSFPolygon ( HSSFShape parent , HSSFAnchor anchor ) { super ( parent , anchor ) ; } public int [ ] getXPoints ( ) { return xPoints ; } public int [ ] getYPoints ( ) { return yPoints ; } public void setPoints ( int [ ] xPoints , int [ ] yPoints ) { this . xPoints = cloneArray ( xPoints ) ; this . yPoints = cloneArray ( yPoints ) ; } private int [ ] cloneArray ( int [ ] a ) { int [ ] result = new int [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) result [ i ] = a [ i ] ; return result ; } public void setPolygonDrawArea ( int width , int height ) { this . drawAreaWidth = width ; this . drawAreaHeight = height ; } public int getDrawAreaWidth ( ) { return drawAreaWidth ; } public int getDrawAreaHeight ( ) { return drawAreaHeight ; } } 	0	['8', '2', '0', '7', '9', '14', '5', '2', '6', '0.785714286', '73', '0', '0', '0.695652174', '0.325', '0', '0', '7.625', '2', '1', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . record . RecordInputStream ; public class FuncVarPtg extends AbstractFunctionPtg { public final static byte sid = 0x22 ; private final static int SIZE = 4 ; private FuncVarPtg ( ) { } public FuncVarPtg ( RecordInputStream in ) { field_1_num_args = in . readByte ( ) ; field_2_fnc_index = in . readShort ( ) ; } public FuncVarPtg ( String pName , byte pNumOperands ) { field_1_num_args = pNumOperands ; field_2_fnc_index = lookupIndex ( pName ) ; try { returnClass = ( ( Byte ) functionData [ field_2_fnc_index ] [ 0 ] ) . byteValue ( ) ; paramClass = ( byte [ ] ) functionData [ field_2_fnc_index ] [ 1 ] ; } catch ( NullPointerException npe ) { returnClass = Ptg . CLASS_VALUE ; paramClass = new byte [ ] { Ptg . CLASS_VALUE } ; } } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = ( byte ) ( sid + ptgClass ) ; array [ offset + 1 ] = field_1_num_args ; LittleEndian . putShort ( array , offset + 2 , field_2_fnc_index ) ; } public int getNumberOfOperands ( ) { return field_1_num_args ; } public Object clone ( ) { FuncVarPtg ptg = new FuncVarPtg ( ) ; ptg . field_1_num_args = field_1_num_args ; ptg . field_2_fnc_index = field_2_fnc_index ; ptg . setClass ( ptgClass ) ; return ptg ; } public int getSize ( ) { return SIZE ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionVarPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } } 	0	['8', '3', '0', '5', '20', '0', '2', '3', '7', '1.142857143', '154', '0.5', '0', '0.772727273', '0.270833333', '1', '5', '18', '1', '0.625', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class AreaErrPtg extends AreaPtg { public final static byte sid = 0x2b ; private AreaErrPtg ( ) { super ( ) ; } public AreaErrPtg ( RecordInputStream in ) { super ( in ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaErrPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { super . writeBytes ( array , offset ) ; array [ offset ] = ( byte ) ( sid + ptgClass ) ; } public String toFormulaString ( Workbook book ) { return "#REF!" ; } public Object clone ( ) { AreaErrPtg ptg = new AreaErrPtg ( ) ; ptg . setFirstRow ( getFirstRow ( ) ) ; ptg . setFirstColumn ( getFirstColumn ( ) ) ; ptg . setLastRow ( getLastRow ( ) ) ; ptg . setLastColumn ( getLastColumn ( ) ) ; ptg . setFirstColRelative ( isFirstColRelative ( ) ) ; ptg . setLastColRelative ( isLastColRelative ( ) ) ; ptg . setFirstRowRelative ( isFirstRowRelative ( ) ) ; ptg . setLastRowRelative ( isLastRowRelative ( ) ) ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0	['6', '3', '0', '4', '34', '13', '1', '3', '5', '1.2', '194', '0', '0', '0.875', '0.333333333', '2', '3', '31.16666667', '1', '0.6667', '0']
package org . apache . poi . hssf . record ; public class DrawingSelectionRecord extends AbstractEscherHolderRecord { public static final short sid = 0xED ; public DrawingSelectionRecord ( ) { } public DrawingSelectionRecord ( RecordInputStream in ) { super ( in ) ; } protected String getRecordName ( ) { return "MSODRAWINGSELECTION" ; } public short getSid ( ) { return sid ; } } 	0	['4', '3', '0', '3', '6', '6', '1', '2', '3', '1.333333333', '16', '0', '0', '0.923076923', '0.625', '1', '2', '2.75', '1', '0.5', '0']
package org . apache . poi . hssf . usermodel ; import java . awt . * ; import java . awt . geom . AffineTransform ; import java . awt . image . BufferedImage ; import java . awt . image . BufferedImageOp ; import java . awt . image . ImageObserver ; import java . awt . image . RenderedImage ; import java . awt . image . renderable . RenderableImage ; import java . awt . font . GlyphVector ; import java . awt . font . FontRenderContext ; import java . util . Map ; import java . text . AttributedCharacterIterator ; public class DummyGraphics2d extends Graphics2D { BufferedImage img ; private Graphics2D g2D ; public DummyGraphics2d ( ) { img = new BufferedImage ( 1000 , 1000 , 2 ) ; g2D = ( Graphics2D ) img . getGraphics ( ) ; } public void addRenderingHints ( Map hints ) { System . out . println ( "addRenderingHinds(Map):" ) ; System . out . println ( "  hints = " + hints ) ; g2D . addRenderingHints ( hints ) ; } public void clip ( Shape s ) { System . out . println ( "clip(Shape):" ) ; System . out . println ( "  s = " + s ) ; g2D . clip ( s ) ; } public void draw ( Shape s ) { System . out . println ( "draw(Shape):" ) ; System . out . println ( "s = " + s ) ; g2D . draw ( s ) ; } public void drawGlyphVector ( GlyphVector g , float x , float y ) { System . out . println ( "drawGlyphVector(GlyphVector, float, float):" ) ; System . out . println ( "g = " + g ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . drawGlyphVector ( g , x , y ) ; } public void drawImage ( BufferedImage img , BufferedImageOp op , int x , int y ) { System . out . println ( "drawImage(BufferedImage, BufferedImageOp, x, y):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "op = " + op ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . drawImage ( img , op , x , y ) ; } public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { System . out . println ( "drawImage(Image,AfflineTransform,ImageObserver):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "xform = " + xform ) ; System . out . println ( "obs = " + obs ) ; return g2D . drawImage ( img , xform , obs ) ; } public void drawRenderableImage ( RenderableImage img , AffineTransform xform ) { System . out . println ( "drawRenderableImage(RenderableImage, AfflineTransform):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "xform = " + xform ) ; g2D . drawRenderableImage ( img , xform ) ; } public void drawRenderedImage ( RenderedImage img , AffineTransform xform ) { System . out . println ( "drawRenderedImage(RenderedImage, AffineTransform):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "xform = " + xform ) ; g2D . drawRenderedImage ( img , xform ) ; } public void drawString ( AttributedCharacterIterator iterator , float x , float y ) { System . out . println ( "drawString(AttributedCharacterIterator):" ) ; System . out . println ( "iterator = " + iterator ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . drawString ( iterator , x , y ) ; } public void drawString ( String s , float x , float y ) { System . out . println ( "drawString(s,x,y):" ) ; System . out . println ( "s = " + s ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . drawString ( s , x , y ) ; } public void fill ( Shape s ) { System . out . println ( "fill(Shape):" ) ; System . out . println ( "s = " + s ) ; g2D . fill ( s ) ; } public Color getBackground ( ) { System . out . println ( "getBackground():" ) ; return g2D . getBackground ( ) ; } public Composite getComposite ( ) { System . out . println ( "getComposite():" ) ; return g2D . getComposite ( ) ; } public GraphicsConfiguration getDeviceConfiguration ( ) { System . out . println ( "getDeviceConfiguration():" ) ; return g2D . getDeviceConfiguration ( ) ; } public FontRenderContext getFontRenderContext ( ) { System . out . println ( "getFontRenderContext():" ) ; return g2D . getFontRenderContext ( ) ; } public Paint getPaint ( ) { System . out . println ( "getPaint():" ) ; return g2D . getPaint ( ) ; } public Object getRenderingHint ( RenderingHints . Key hintKey ) { System . out . println ( "getRenderingHint(RenderingHints.Key):" ) ; System . out . println ( "hintKey = " + hintKey ) ; return g2D . getRenderingHint ( hintKey ) ; } public RenderingHints getRenderingHints ( ) { System . out . println ( "getRenderingHints():" ) ; return g2D . getRenderingHints ( ) ; } public Stroke getStroke ( ) { System . out . println ( "getStroke():" ) ; return g2D . getStroke ( ) ; } public AffineTransform getTransform ( ) { System . out . println ( "getTransform():" ) ; return g2D . getTransform ( ) ; } public boolean hit ( Rectangle rect , Shape s , boolean onStroke ) { System . out . println ( "hit(Rectangle, Shape, onStroke):" ) ; System . out . println ( "rect = " + rect ) ; System . out . println ( "s = " + s ) ; System . out . println ( "onStroke = " + onStroke ) ; return g2D . hit ( rect , s , onStroke ) ; } public void rotate ( double theta ) { System . out . println ( "rotate(theta):" ) ; System . out . println ( "theta = " + theta ) ; g2D . rotate ( theta ) ; } public void rotate ( double theta , double x , double y ) { System . out . println ( "rotate(double,double,double):" ) ; System . out . println ( "theta = " + theta ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . rotate ( theta , x , y ) ; } public void scale ( double sx , double sy ) { System . out . println ( "scale(double,double):" ) ; System . out . println ( "sx = " + sx ) ; System . out . println ( "sy" ) ; g2D . scale ( sx , sy ) ; } public void setBackground ( Color color ) { System . out . println ( "setBackground(Color):" ) ; System . out . println ( "color = " + color ) ; g2D . setBackground ( color ) ; } public void setComposite ( Composite comp ) { System . out . println ( "setComposite(Composite):" ) ; System . out . println ( "comp = " + comp ) ; g2D . setComposite ( comp ) ; } public void setPaint ( Paint paint ) { System . out . println ( "setPain(Paint):" ) ; System . out . println ( "paint = " + paint ) ; g2D . setPaint ( paint ) ; } public void setRenderingHint ( RenderingHints . Key hintKey , Object hintValue ) { System . out . println ( "setRenderingHint(RenderingHints.Key, Object):" ) ; System . out . println ( "hintKey = " + hintKey ) ; System . out . println ( "hintValue = " + hintValue ) ; g2D . setRenderingHint ( hintKey , hintValue ) ; } public void setRenderingHints ( Map hints ) { System . out . println ( "setRenderingHints(Map):" ) ; System . out . println ( "hints = " + hints ) ; g2D . setRenderingHints ( hints ) ; } public void setStroke ( Stroke s ) { System . out . println ( "setStroke(Stoke):" ) ; System . out . println ( "s = " + s ) ; g2D . setStroke ( s ) ; } public void setTransform ( AffineTransform Tx ) { System . out . println ( "setTransform():" ) ; System . out . println ( "Tx = " + Tx ) ; g2D . setTransform ( Tx ) ; } public void shear ( double shx , double shy ) { System . out . println ( "shear(shx, dhy):" ) ; System . out . println ( "shx = " + shx ) ; System . out . println ( "shy = " + shy ) ; g2D . shear ( shx , shy ) ; } public void transform ( AffineTransform Tx ) { System . out . println ( "transform(AffineTransform):" ) ; System . out . println ( "Tx = " + Tx ) ; g2D . transform ( Tx ) ; } public void translate ( double tx , double ty ) { System . out . println ( "translate(double, double):" ) ; System . out . println ( "tx = " + tx ) ; System . out . println ( "ty = " + ty ) ; g2D . translate ( tx , ty ) ; } public void clearRect ( int x , int y , int width , int height ) { System . out . println ( "clearRect(int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; g2D . clearRect ( x , y , width , height ) ; } public void clipRect ( int x , int y , int width , int height ) { System . out . println ( "clipRect(int, int, int, int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; g2D . clipRect ( x , y , width , height ) ; } public void copyArea ( int x , int y , int width , int height , int dx , int dy ) { System . out . println ( "copyArea(int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; g2D . copyArea ( x , y , width , height , dx , dy ) ; } public Graphics create ( ) { System . out . println ( "create():" ) ; return g2D . create ( ) ; } public Graphics create ( int x , int y , int width , int height ) { System . out . println ( "create(int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; return g2D . create ( x , y , width , height ) ; } public void dispose ( ) { System . out . println ( "dispose():" ) ; g2D . dispose ( ) ; } public void draw3DRect ( int x , int y , int width , int height , boolean raised ) { System . out . println ( "draw3DRect(int,int,int,int,boolean):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; System . out . println ( "raised = " + raised ) ; g2D . draw3DRect ( x , y , width , height , raised ) ; } public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) { System . out . println ( "drawArc(int,int,int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; System . out . println ( "startAngle = " + startAngle ) ; System . out . println ( "arcAngle = " + arcAngle ) ; g2D . drawArc ( x , y , width , height , startAngle , arcAngle ) ; } public void drawBytes ( byte data [ ] , int offset , int length , int x , int y ) { System . out . println ( "drawBytes(byte[],int,int,int,int):" ) ; System . out . println ( "data = " + data ) ; System . out . println ( "offset = " + offset ) ; System . out . println ( "length = " + length ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . drawBytes ( data , offset , length , x , y ) ; } public void drawChars ( char data [ ] , int offset , int length , int x , int y ) { System . out . println ( "drawChars(data,int,int,int,int):" ) ; System . out . println ( "data = " + data . toString ( ) ) ; System . out . println ( "offset = " + offset ) ; System . out . println ( "length = " + length ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . drawChars ( data , offset , length , x , y ) ; } public boolean drawImage ( Image img , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , ImageObserver observer ) { System . out . println ( "drawImage(Image,int,int,int,int,int,int,int,int,ImageObserver):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "dx1 = " + dx1 ) ; System . out . println ( "dy1 = " + dy1 ) ; System . out . println ( "dx2 = " + dx2 ) ; System . out . println ( "dy2 = " + dy2 ) ; System . out . println ( "sx1 = " + sx1 ) ; System . out . println ( "sy1 = " + sy1 ) ; System . out . println ( "sx2 = " + sx2 ) ; System . out . println ( "sy2 = " + sy2 ) ; System . out . println ( "observer = " + observer ) ; return g2D . drawImage ( img , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , observer ) ; } public boolean drawImage ( Image img , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , Color bgcolor , ImageObserver observer ) { System . out . println ( "drawImage(Image,int,int,int,int,int,int,int,int,Color,ImageObserver):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "dx1 = " + dx1 ) ; System . out . println ( "dy1 = " + dy1 ) ; System . out . println ( "dx2 = " + dx2 ) ; System . out . println ( "dy2 = " + dy2 ) ; System . out . println ( "sx1 = " + sx1 ) ; System . out . println ( "sy1 = " + sy1 ) ; System . out . println ( "sx2 = " + sx2 ) ; System . out . println ( "sy2 = " + sy2 ) ; System . out . println ( "bgcolor = " + bgcolor ) ; System . out . println ( "observer = " + observer ) ; return g2D . drawImage ( img , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , bgcolor , observer ) ; } public boolean drawImage ( Image img , int x , int y , Color bgcolor , ImageObserver observer ) { System . out . println ( "drawImage(Image,int,int,Color,ImageObserver):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "bgcolor = " + bgcolor ) ; System . out . println ( "observer = " + observer ) ; return g2D . drawImage ( img , x , y , bgcolor , observer ) ; } public boolean drawImage ( Image img , int x , int y , ImageObserver observer ) { System . out . println ( "drawImage(Image,int,int,observer):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "observer = " + observer ) ; return g2D . drawImage ( img , x , y , observer ) ; } public boolean drawImage ( Image img , int x , int y , int width , int height , Color bgcolor , ImageObserver observer ) { System . out . println ( "drawImage(Image,int,int,int,int,Color,ImageObserver):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; System . out . println ( "bgcolor = " + bgcolor ) ; System . out . println ( "observer = " + observer ) ; return g2D . drawImage ( img , x , y , width , height , bgcolor , observer ) ; } public boolean drawImage ( Image img , int x , int y , int width , int height , ImageObserver observer ) { System . out . println ( "drawImage(Image,int,int,width,height,observer):" ) ; System . out . println ( "img = " + img ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; System . out . println ( "observer = " + observer ) ; return g2D . drawImage ( img , x , y , width , height , observer ) ; } public void drawLine ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( "drawLine(int,int,int,int):" ) ; System . out . println ( "x1 = " + x1 ) ; System . out . println ( "y1 = " + y1 ) ; System . out . println ( "x2 = " + x2 ) ; System . out . println ( "y2 = " + y2 ) ; g2D . drawLine ( x1 , y1 , x2 , y2 ) ; } public void drawOval ( int x , int y , int width , int height ) { System . out . println ( "drawOval(int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; g2D . drawOval ( x , y , width , height ) ; } public void drawPolygon ( Polygon p ) { System . out . println ( "drawPolygon(Polygon):" ) ; System . out . println ( "p = " + p ) ; g2D . drawPolygon ( p ) ; } public void drawPolygon ( int xPoints [ ] , int yPoints [ ] , int nPoints ) { System . out . println ( "drawPolygon(int[],int[],int):" ) ; System . out . println ( "xPoints = " + xPoints ) ; System . out . println ( "yPoints = " + yPoints ) ; System . out . println ( "nPoints = " + nPoints ) ; g2D . drawPolygon ( xPoints , yPoints , nPoints ) ; } public void drawPolyline ( int xPoints [ ] , int yPoints [ ] , int nPoints ) { System . out . println ( "drawPolyline(int[],int[],int):" ) ; System . out . println ( "xPoints = " + xPoints ) ; System . out . println ( "yPoints = " + yPoints ) ; System . out . println ( "nPoints = " + nPoints ) ; g2D . drawPolyline ( xPoints , yPoints , nPoints ) ; } public void drawRect ( int x , int y , int width , int height ) { System . out . println ( "drawRect(int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; g2D . drawRect ( x , y , width , height ) ; } public void drawRoundRect ( int x , int y , int width , int height , int arcWidth , int arcHeight ) { System . out . println ( "drawRoundRect(int,int,int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; System . out . println ( "arcWidth = " + arcWidth ) ; System . out . println ( "arcHeight = " + arcHeight ) ; g2D . drawRoundRect ( x , y , width , height , arcWidth , arcHeight ) ; } public void drawString ( AttributedCharacterIterator iterator , int x , int y ) { System . out . println ( "drawString(AttributedCharacterIterator,int,int):" ) ; System . out . println ( "iterator = " + iterator ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . drawString ( iterator , x , y ) ; } public void drawString ( String str , int x , int y ) { System . out . println ( "drawString(str,int,int):" ) ; System . out . println ( "str = " + str ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . drawString ( str , x , y ) ; } public void fill3DRect ( int x , int y , int width , int height , boolean raised ) { System . out . println ( "fill3DRect(int,int,int,int,boolean):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; System . out . println ( "raised = " + raised ) ; g2D . fill3DRect ( x , y , width , height , raised ) ; } public void fillArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) { System . out . println ( "fillArc(int,int,int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; System . out . println ( "startAngle = " + startAngle ) ; System . out . println ( "arcAngle = " + arcAngle ) ; g2D . fillArc ( x , y , width , height , startAngle , arcAngle ) ; } public void fillOval ( int x , int y , int width , int height ) { System . out . println ( "fillOval(int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; g2D . fillOval ( x , y , width , height ) ; } public void fillPolygon ( Polygon p ) { System . out . println ( "fillPolygon(Polygon):" ) ; System . out . println ( "p = " + p ) ; g2D . fillPolygon ( p ) ; } public void fillPolygon ( int xPoints [ ] , int yPoints [ ] , int nPoints ) { System . out . println ( "fillPolygon(int[],int[],int):" ) ; System . out . println ( "xPoints = " + xPoints ) ; System . out . println ( "yPoints = " + yPoints ) ; System . out . println ( "nPoints = " + nPoints ) ; g2D . fillPolygon ( xPoints , yPoints , nPoints ) ; } public void fillRect ( int x , int y , int width , int height ) { System . out . println ( "fillRect(int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; g2D . fillRect ( x , y , width , height ) ; } public void fillRoundRect ( int x , int y , int width , int height , int arcWidth , int arcHeight ) { System . out . println ( "fillRoundRect(int,int,int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; g2D . fillRoundRect ( x , y , width , height , arcWidth , arcHeight ) ; } public void finalize ( ) { System . out . println ( "finalize():" ) ; g2D . finalize ( ) ; } public Shape getClip ( ) { System . out . println ( "getClip():" ) ; return g2D . getClip ( ) ; } public Rectangle getClipBounds ( ) { System . out . println ( "getClipBounds():" ) ; return g2D . getClipBounds ( ) ; } public Rectangle getClipBounds ( Rectangle r ) { System . out . println ( "getClipBounds(Rectangle):" ) ; System . out . println ( "r = " + r ) ; return g2D . getClipBounds ( r ) ; } public Rectangle getClipRect ( ) { System . out . println ( "getClipRect():" ) ; return g2D . getClipRect ( ) ; } public Color getColor ( ) { System . out . println ( "getColor():" ) ; return g2D . getColor ( ) ; } public Font getFont ( ) { System . out . println ( "getFont():" ) ; return g2D . getFont ( ) ; } public FontMetrics getFontMetrics ( ) { System . out . println ( "getFontMetrics():" ) ; return g2D . getFontMetrics ( ) ; } public FontMetrics getFontMetrics ( Font f ) { System . out . println ( "getFontMetrics():" ) ; return g2D . getFontMetrics ( f ) ; } public boolean hitClip ( int x , int y , int width , int height ) { System . out . println ( "hitClip(int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; return g2D . hitClip ( x , y , width , height ) ; } public void setClip ( Shape clip ) { System . out . println ( "setClip(Shape):" ) ; System . out . println ( "clip = " + clip ) ; g2D . setClip ( clip ) ; } public void setClip ( int x , int y , int width , int height ) { System . out . println ( "setClip(int,int,int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; System . out . println ( "width = " + width ) ; System . out . println ( "height = " + height ) ; g2D . setClip ( x , y , width , height ) ; } public void setColor ( Color c ) { System . out . println ( "setColor():" ) ; System . out . println ( "c = " + c ) ; g2D . setColor ( c ) ; } public void setFont ( Font font ) { System . out . println ( "setFont(Font):" ) ; System . out . println ( "font = " + font ) ; g2D . setFont ( font ) ; } public void setPaintMode ( ) { System . out . println ( "setPaintMode():" ) ; g2D . setPaintMode ( ) ; } public void setXORMode ( Color c1 ) { System . out . println ( "setXORMode(Color):" ) ; System . out . println ( "c1 = " + c1 ) ; g2D . setXORMode ( c1 ) ; } public String toString ( ) { System . out . println ( "toString():" ) ; return g2D . toString ( ) ; } public void translate ( int x , int y ) { System . out . println ( "translate(int,int):" ) ; System . out . println ( "x = " + x ) ; System . out . println ( "y = " + y ) ; g2D . translate ( x , y ) ; } } 	0	['85', '3', '0', '0', '182', '0', '0', '0', '85', '0.5', '2891', '0.5', '0', '0.514450867', '0.075456389', '2', '20', '32.98823529', '1', '0.9882', '0']
package org . apache . poi . hssf . util ; import org . apache . poi . hssf . record . MergeCellsRecord . MergedRegion ; public class Region implements Comparable { private int rowFrom ; private short colFrom ; private int rowTo ; private short colTo ; public Region ( ) { } public Region ( int rowFrom , short colFrom , int rowTo , short colTo ) { this . rowFrom = rowFrom ; this . rowTo = rowTo ; this . colFrom = colFrom ; this . colTo = colTo ; } public Region ( MergedRegion region ) { this ( region . row_from , region . col_from , region . row_to , region . col_to ) ; } public short getColumnFrom ( ) { return colFrom ; } public int getRowFrom ( ) { return rowFrom ; } public short getColumnTo ( ) { return colTo ; } public int getRowTo ( ) { return rowTo ; } public void setColumnFrom ( short colFrom ) { this . colFrom = colFrom ; } public void setRowFrom ( int rowFrom ) { this . rowFrom = rowFrom ; } public void setColumnTo ( short colTo ) { this . colTo = colTo ; } public void setRowTo ( int rowTo ) { this . rowTo = rowTo ; } public boolean contains ( int row , short col ) { if ( ( this . rowFrom <= row ) && ( this . rowTo >= row ) && ( this . colFrom <= col ) && ( this . colTo >= col ) ) { return true ; } return false ; } public boolean equals ( Region r ) { return ( compareTo ( r ) == 0 ) ; } public int compareTo ( Region r ) { if ( ( this . getRowFrom ( ) == r . getRowFrom ( ) ) && ( this . getColumnFrom ( ) == r . getColumnFrom ( ) ) && ( this . getRowTo ( ) == r . getRowTo ( ) ) && ( this . getColumnTo ( ) == r . getColumnTo ( ) ) ) { return 0 ; } if ( ( this . getRowFrom ( ) < r . getRowFrom ( ) ) || ( this . getColumnFrom ( ) < r . getColumnFrom ( ) ) || ( this . getRowTo ( ) < r . getRowTo ( ) ) || ( this . getColumnTo ( ) < r . getColumnTo ( ) ) ) { return 1 ; } return - 1 ; } public int compareTo ( Object o ) { return compareTo ( ( Region ) o ) ; } public int getArea ( ) { return ( ( 1 + ( getRowTo ( ) - getRowFrom ( ) ) ) * ( 1 + ( getColumnTo ( ) - getColumnFrom ( ) ) ) ) ; } } 	0	['16', '1', '0', '3', '17', '78', '2', '1', '16', '0.533333333', '172', '1', '0', '0', '0.291666667', '0', '0', '9.5', '9', '1.625', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaNVPtg extends AreaPtg { public final static short sid = 0x4D ; protected AreaNVPtg ( ) { } public AreaNVPtg ( RecordInputStream in ) { super ( in ) ; } public void writeBytes ( byte [ ] array , int offset ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public String getAreaPtgName ( ) { return "AreaNVPtg" ; } public String toFormulaString ( Workbook book ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public Object clone ( ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } } 	0	['6', '3', '0', '5', '9', '15', '2', '3', '5', '1.2', '31', '0', '0', '0.875', '0.333333333', '1', '1', '4', '1', '0.6667', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . LongField ; import org . apache . poi . util . ShortField ; public class HeaderBlockWriter extends BigBlock implements HeaderBlockConstants { private static final byte _default_value = ( byte ) 0xFF ; private IntegerField _bat_count ; private IntegerField _property_start ; private IntegerField _sbat_start ; private IntegerField _sbat_block_count ; private IntegerField _xbat_start ; private IntegerField _xbat_count ; private byte [ ] _data ; public HeaderBlockWriter ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; new LongField ( _signature_offset , _signature , _data ) ; new IntegerField ( 0x08 , 0 , _data ) ; new IntegerField ( 0x0c , 0 , _data ) ; new IntegerField ( 0x10 , 0 , _data ) ; new IntegerField ( 0x14 , 0 , _data ) ; new ShortField ( 0x18 , ( short ) 0x3b , _data ) ; new ShortField ( 0x1a , ( short ) 0x3 , _data ) ; new ShortField ( 0x1c , ( short ) - 2 , _data ) ; new ShortField ( 0x1e , ( short ) 0x9 , _data ) ; new IntegerField ( 0x20 , 0x6 , _data ) ; new IntegerField ( 0x24 , 0 , _data ) ; new IntegerField ( 0x28 , 0 , _data ) ; _bat_count = new IntegerField ( _bat_count_offset , 0 , _data ) ; _property_start = new IntegerField ( _property_start_offset , POIFSConstants . END_OF_CHAIN , _data ) ; new IntegerField ( 0x34 , 0 , _data ) ; new IntegerField ( 0x38 , 0x1000 , _data ) ; _sbat_start = new IntegerField ( _sbat_start_offset , POIFSConstants . END_OF_CHAIN , _data ) ; _sbat_block_count = new IntegerField ( _sbat_block_count_offset , 0 , _data ) ; _xbat_start = new IntegerField ( _xbat_start_offset , POIFSConstants . END_OF_CHAIN , _data ) ; _xbat_count = new IntegerField ( _xbat_count_offset , 0 , _data ) ; } public BATBlock [ ] setBATBlocks ( final int blockCount , final int startBlock ) { BATBlock [ ] rvalue ; _bat_count . set ( blockCount , _data ) ; int limit = Math . min ( blockCount , _max_bats_in_header ) ; int offset = _bat_array_offset ; for ( int j = 0 ; j < limit ; j ++ ) { new IntegerField ( offset , startBlock + j , _data ) ; offset += LittleEndianConsts . INT_SIZE ; } if ( blockCount > _max_bats_in_header ) { int excess_blocks = blockCount - _max_bats_in_header ; int [ ] excess_block_array = new int [ excess_blocks ] ; for ( int j = 0 ; j < excess_blocks ; j ++ ) { excess_block_array [ j ] = startBlock + j + _max_bats_in_header ; } rvalue = BATBlock . createXBATBlocks ( excess_block_array , startBlock + blockCount ) ; _xbat_start . set ( startBlock + blockCount , _data ) ; } else { rvalue = BATBlock . createXBATBlocks ( new int [ 0 ] , 0 ) ; _xbat_start . set ( POIFSConstants . END_OF_CHAIN , _data ) ; } _xbat_count . set ( rvalue . length , _data ) ; return rvalue ; } public void setPropertyStart ( final int startBlock ) { _property_start . set ( startBlock , _data ) ; } public void setSBATStart ( final int startBlock ) { _sbat_start . set ( startBlock , _data ) ; } public void setSBATBlockCount ( final int count ) { _sbat_block_count . set ( count , _data ) ; } static int calculateXBATStorageRequirements ( final int blockCount ) { return ( blockCount > _max_bats_in_header ) ? BATBlock . calculateXBATStorageRequirements ( blockCount - _max_bats_in_header ) : 0 ; } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0	['8', '2', '0', '8', '19', '0', '2', '6', '6', '0.821428571', '324', '1', '6', '0.3', '0.583333333', '1', '2', '38.5', '4', '1.375', '0']
package org . apache . poi . hssf . util ; import java . util . HashMap ; import java . util . Map ; public class SheetReferences { Map map ; public SheetReferences ( ) { map = new HashMap ( 5 ) ; } public void addSheetReference ( String sheetName , int number ) { map . put ( new Integer ( number ) , sheetName ) ; } public String getSheetName ( int number ) { return ( String ) map . get ( new Integer ( number ) ) ; } } 	0	['3', '1', '0', '3', '8', '0', '3', '0', '3', '0', '32', '0', '0', '0', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ByteField implements FixedField { private static final byte _default_value = 0 ; private byte _value ; private final int _offset ; public ByteField ( final int offset ) throws ArrayIndexOutOfBoundsException { this ( offset , _default_value ) ; } public ByteField ( final int offset , final byte value ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "offset cannot be negative" ) ; } _offset = offset ; set ( value ) ; } public ByteField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ByteField ( final int offset , final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset , value ) ; writeToBytes ( data ) ; } public byte get ( ) { return _value ; } public void set ( final byte value ) { _value = value ; } public void set ( final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { set ( value ) ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = data [ _offset ] ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = ( LittleEndian . readFromStream ( stream , LittleEndianConsts . BYTE_SIZE ) ) [ 0 ] ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { data [ _offset ] = _value ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '4', '15', '21', '1', '3', '11', '0.533333333', '90', '1', '0', '0', '0.454545455', '0', '0', '6.909090909', '1', '0.6364', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; class SSTRecordHeader { int numStrings ; int numUniqueStrings ; public SSTRecordHeader ( int numStrings , int numUniqueStrings ) { this . numStrings = numStrings ; this . numUniqueStrings = numUniqueStrings ; } public int writeSSTHeader ( UnicodeString . UnicodeRecordStats stats , byte [ ] data , int bufferIndex , int recSize ) { int offset = bufferIndex ; LittleEndian . putShort ( data , offset , SSTRecord . sid ) ; offset += LittleEndianConsts . SHORT_SIZE ; stats . recordSize += LittleEndianConsts . SHORT_SIZE ; stats . remainingSize -= LittleEndianConsts . SHORT_SIZE ; stats . lastLengthPos = offset ; offset += LittleEndianConsts . SHORT_SIZE ; stats . recordSize += LittleEndianConsts . SHORT_SIZE ; stats . remainingSize -= LittleEndianConsts . SHORT_SIZE ; LittleEndian . putInt ( data , offset , numStrings ) ; offset += LittleEndianConsts . INT_SIZE ; stats . recordSize += LittleEndianConsts . INT_SIZE ; stats . remainingSize -= LittleEndianConsts . INT_SIZE ; LittleEndian . putInt ( data , offset , numUniqueStrings ) ; offset += LittleEndianConsts . INT_SIZE ; stats . recordSize += LittleEndianConsts . INT_SIZE ; stats . remainingSize -= LittleEndianConsts . INT_SIZE ; return offset - bufferIndex ; } } 	0	['2', '1', '0', '3', '5', '0', '1', '2', '2', '0', '88', '0', '0', '0', '0.75', '0', '0', '42', '1', '0.5', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class ExtSSTInfoSubRecord extends Record { public static final int INFO_SIZE = 8 ; public final static short sid = 0xFFF ; private int field_1_stream_pos ; private short field_2_bucket_sst_offset ; private short field_3_zero ; public ExtSSTInfoSubRecord ( ) { } public ExtSSTInfoSubRecord ( RecordInputStream in ) { super ( in ) ; } protected void validateSid ( short id ) { } protected void fillFields ( RecordInputStream in ) { field_1_stream_pos = in . readInt ( ) ; field_2_bucket_sst_offset = in . readShort ( ) ; field_3_zero = in . readShort ( ) ; } public void setStreamPos ( int pos ) { field_1_stream_pos = pos ; } public void setBucketRecordOffset ( short offset ) { field_2_bucket_sst_offset = offset ; } public int getStreamPos ( ) { return field_1_stream_pos ; } public short getBucketSSTOffset ( ) { return field_2_bucket_sst_offset ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTSST]\n" ) ; buffer . append ( "    .streampos      = " ) . append ( Integer . toHexString ( getStreamPos ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .bucketsstoffset= " ) . append ( Integer . toHexString ( getBucketSSTOffset ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .zero           = " ) . append ( Integer . toHexString ( field_3_zero ) ) . append ( "\n" ) ; buffer . append ( "[/EXTSST]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putInt ( data , 0 + offset , getStreamPos ( ) ) ; LittleEndian . putShort ( data , 4 + offset , getBucketSSTOffset ( ) ) ; LittleEndian . putShort ( data , 6 + offset , ( short ) 0 ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 ; } public short getSid ( ) { return sid ; } } 	0	['12', '2', '0', '4', '22', '52', '1', '3', '10', '0.872727273', '124', '0.6', '0', '0.523809524', '0.316666667', '1', '4', '8.916666667', '1', '0.8333', '0']
package org . apache . poi . poifs . property ; public interface Child { public Child getNextChild ( ) ; public Child getPreviousChild ( ) ; public void setNextChild ( final Child child ) ; public void setPreviousChild ( final Child child ) ; } 	0	['4', '1', '0', '3', '4', '6', '3', '0', '4', '2', '4', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . record ; public class RecordFormatException extends RuntimeException { public RecordFormatException ( String exception ) { super ( exception ) ; } public RecordFormatException ( String exception , Throwable thr ) { super ( exception , thr ) ; } public RecordFormatException ( Throwable thr ) { super ( thr ) ; } } 	0	['3', '4', '0', '147', '6', '3', '147', '0', '3', '2', '16', '0', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . poi . hpsf ; import java . io . IOException ; import java . io . OutputStream ; public class MutableProperty extends Property { public MutableProperty ( ) { } public MutableProperty ( final Property p ) { setID ( p . getID ( ) ) ; setType ( p . getType ( ) ) ; setValue ( p . getValue ( ) ) ; } public void setID ( final long id ) { this . id = id ; } public void setType ( final long type ) { this . type = type ; } public void setValue ( final Object value ) { this . value = value ; } public int write ( final OutputStream out , final int codepage ) throws IOException , WritingNotSupportedException { int length = 0 ; long variantType = getType ( ) ; if ( codepage == Constants . CP_UNICODE && variantType == Variant . VT_LPSTR ) variantType = Variant . VT_LPWSTR ; length += TypeWriter . writeUIntToStream ( out , variantType ) ; length += VariantSupport . write ( out , variantType , getValue ( ) , codepage ) ; return length ; } } 	0	['6', '2', '1', '7', '14', '15', '3', '4', '6', '2', '67', '0', '0', '0.555555556', '0.333333333', '1', '2', '10.16666667', '1', '0.6667', '0']
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	0	['9', '1', '0', '10', '20', '0', '10', '0', '9', '0.25', '294', '1', '0', '0', '0.311111111', '1', '1', '31.44444444', '7', '1.8889', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; import org . apache . poi . util . BitFieldFactory ; import org . apache . poi . util . StringUtil ; import org . apache . poi . hssf . record . RecordInputStream ; public class StringPtg extends Ptg { public final static int SIZE = 9 ; public final static byte sid = 0x17 ; int field_1_length ; byte field_2_options ; BitField fHighByte = BitFieldFactory . getInstance ( 0x01 ) ; private String field_3_string ; private StringPtg ( ) { } public StringPtg ( RecordInputStream in ) { field_1_length = in . readByte ( ) & 0xFF ; field_2_options = in . readByte ( ) ; if ( fHighByte . isSet ( field_2_options ) ) { field_3_string = in . readUnicodeLEString ( field_1_length ) ; } else { field_3_string = in . readCompressedUnicode ( field_1_length ) ; } } public StringPtg ( String value ) { if ( value . length ( ) > 255 ) { throw new IllegalArgumentException ( "String literals in formulas cant be bigger than 255 characters ASCII" ) ; } this . field_2_options = 0 ; field_2_options = ( byte ) this . fHighByte . setBoolean ( field_2_options , StringUtil . hasMultibyte ( value ) ) ; this . field_3_string = value ; this . field_1_length = value . length ( ) ; } public String getValue ( ) { return field_3_string ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; array [ offset + 1 ] = ( byte ) field_1_length ; array [ offset + 2 ] = field_2_options ; if ( fHighByte . isSet ( field_2_options ) ) { StringUtil . putUnicodeLE ( getValue ( ) , array , offset + 3 ) ; } else { StringUtil . putCompressedUnicode ( getValue ( ) , array , offset + 3 ) ; } } public int getSize ( ) { if ( fHighByte . isSet ( field_2_options ) ) { return 2 * field_1_length + 3 ; } else { return field_1_length + 3 ; } } public String toFormulaString ( Workbook book ) { return "\"" + getValue ( ) + "\"" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { StringPtg ptg = new StringPtg ( ) ; ptg . field_1_length = field_1_length ; ptg . field_2_options = field_2_options ; ptg . field_3_string = field_3_string ; return ptg ; } } 	0	['9', '2', '0', '7', '24', '2', '2', '6', '8', '0.666666667', '190', '0.166666667', '1', '0.538461538', '0.259259259', '1', '2', '19.44444444', '2', '0.8889', '0']
package org . apache . poi . poifs . filesystem ; public interface Entry { public String getName ( ) ; public boolean isDirectoryEntry ( ) ; public boolean isDocumentEntry ( ) ; public DirectoryEntry getParent ( ) ; public boolean delete ( ) ; public boolean renameTo ( final String newName ) ; } 	0	['6', '1', '0', '7', '6', '15', '7', '1', '6', '2', '6', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . IntMapper ; class SSTDeserializer { private IntMapper strings ; public SSTDeserializer ( IntMapper strings ) { this . strings = strings ; } public void manufactureStrings ( int stringCount , RecordInputStream in ) { for ( int i = 0 ; i < stringCount ; i ++ ) { UnicodeString str = new UnicodeString ( in ) ; addToStringTable ( strings , str ) ; } } static public void addToStringTable ( IntMapper strings , UnicodeString string ) { strings . add ( string ) ; } } 	0	['3', '1', '0', '4', '6', '1', '1', '3', '3', '0.5', '32', '1', '1', '0', '0.466666667', '0', '0', '9.333333333', '2', '1', '0']
package org . apache . poi . hpsf ; public class ReadingNotSupportedException extends UnsupportedVariantTypeException { public ReadingNotSupportedException ( final long variantType , final Object value ) { super ( variantType , value ) ; } } 	0	['1', '6', '0', '2', '2', '0', '1', '1', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . poi . hssf . model ; import org . apache . poi . ddf . EscherDgRecord ; import org . apache . poi . ddf . EscherDggRecord ; import java . util . List ; import java . util . ArrayList ; public class DrawingManager2 { EscherDggRecord dgg ; List drawingGroups = new ArrayList ( ) ; public DrawingManager2 ( EscherDggRecord dgg ) { this . dgg = dgg ; } public EscherDgRecord createDgRecord ( ) { EscherDgRecord dg = new EscherDgRecord ( ) ; dg . setRecordId ( EscherDgRecord . RECORD_ID ) ; short dgId = findNewDrawingGroupId ( ) ; dg . setOptions ( ( short ) ( dgId << 4 ) ) ; dg . setNumShapes ( 0 ) ; dg . setLastMSOSPID ( - 1 ) ; drawingGroups . add ( dg ) ; dgg . addCluster ( dgId , 0 ) ; dgg . setDrawingsSaved ( dgg . getDrawingsSaved ( ) + 1 ) ; return dg ; } public int allocateShapeId ( short drawingGroupId ) { dgg . setNumShapesSaved ( dgg . getNumShapesSaved ( ) + 1 ) ; for ( int i = 0 ; i < dgg . getFileIdClusters ( ) . length ; i ++ ) { EscherDggRecord . FileIdCluster c = dgg . getFileIdClusters ( ) [ i ] ; if ( c . getDrawingGroupId ( ) == drawingGroupId && c . getNumShapeIdsUsed ( ) != 1024 ) { int result = c . getNumShapeIdsUsed ( ) + ( 1024 * ( i + 1 ) ) ; c . incrementShapeId ( ) ; EscherDgRecord dg = getDrawingGroup ( drawingGroupId ) ; dg . setNumShapes ( dg . getNumShapes ( ) + 1 ) ; dg . setLastMSOSPID ( result ) ; if ( result >= dgg . getShapeIdMax ( ) ) dgg . setShapeIdMax ( result + 1 ) ; return result ; } } dgg . addCluster ( drawingGroupId , 0 ) ; dgg . getFileIdClusters ( ) [ dgg . getFileIdClusters ( ) . length - 1 ] . incrementShapeId ( ) ; EscherDgRecord dg = getDrawingGroup ( drawingGroupId ) ; dg . setNumShapes ( dg . getNumShapes ( ) + 1 ) ; int result = ( 1024 * dgg . getFileIdClusters ( ) . length ) ; dg . setLastMSOSPID ( result ) ; if ( result >= dgg . getShapeIdMax ( ) ) dgg . setShapeIdMax ( result + 1 ) ; return result ; } short findNewDrawingGroupId ( ) { short dgId = 1 ; while ( drawingGroupExists ( dgId ) ) dgId ++ ; return dgId ; } EscherDgRecord getDrawingGroup ( int drawingGroupId ) { return ( EscherDgRecord ) drawingGroups . get ( drawingGroupId - 1 ) ; } boolean drawingGroupExists ( short dgId ) { for ( int i = 0 ; i < dgg . getFileIdClusters ( ) . length ; i ++ ) { if ( dgg . getFileIdClusters ( ) [ i ] . getDrawingGroupId ( ) == dgId ) return true ; } return false ; } int findFreeSPIDBlock ( ) { int max = dgg . getShapeIdMax ( ) ; int next = ( ( max / 1024 ) + 1 ) * 1024 ; return next ; } public EscherDggRecord getDgg ( ) { return dgg ; } } 	0	['8', '1', '0', '7', '29', '0', '4', '3', '4', '0.357142857', '242', '0', '1', '0', '0.375', '0', '0', '29', '6', '1.875', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class MultiplyPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x05 ; public MultiplyPtg ( ) { } public MultiplyPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public int getStringLength ( ) { return 1 ; } public String toFormulaString ( Workbook book ) { return "*" ; } public String toFormulaString ( Ptg [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] . toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( "*" ) ; buffer . append ( operands [ 1 ] . toFormulaString ( ( Workbook ) null ) ) ; return buffer . toString ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new MultiplyPtg ( ) ; } } 	0	['11', '2', '0', '5', '16', '55', '2', '4', '11', '1.1', '95', '0', '0', '0.25', '0.220779221', '0', '0', '7.454545455', '1', '0.8182', '0']
package org . apache . poi . poifs . filesystem ; public class OfficeXmlFileException extends IllegalArgumentException { public OfficeXmlFileException ( String s ) { super ( s ) ; } } 	0	['1', '5', '0', '1', '2', '0', '1', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . poi . hpsf ; public class Constants { public static final int CP_037 = 37 ; public static final int CP_SJIS = 932 ; public static final int CP_GBK = 936 ; public static final int CP_MS949 = 949 ; public static final int CP_UTF16 = 1200 ; public static final int CP_UTF16_BE = 1201 ; public static final int CP_WINDOWS_1250 = 1250 ; public static final int CP_WINDOWS_1251 = 1251 ; public static final int CP_WINDOWS_1252 = 1252 ; public static final int CP_WINDOWS_1253 = 1253 ; public static final int CP_WINDOWS_1254 = 1254 ; public static final int CP_WINDOWS_1255 = 1255 ; public static final int CP_WINDOWS_1256 = 1256 ; public static final int CP_WINDOWS_1257 = 1257 ; public static final int CP_WINDOWS_1258 = 1258 ; public static final int CP_JOHAB = 1361 ; public static final int CP_MAC_ROMAN = 10000 ; public static final int CP_MAC_JAPAN = 10001 ; public static final int CP_MAC_CHINESE_TRADITIONAL = 10002 ; public static final int CP_MAC_KOREAN = 10003 ; public static final int CP_MAC_ARABIC = 10004 ; public static final int CP_MAC_HEBREW = 10005 ; public static final int CP_MAC_GREEK = 10006 ; public static final int CP_MAC_CYRILLIC = 10007 ; public static final int CP_MAC_CHINESE_SIMPLE = 10008 ; public static final int CP_MAC_ROMANIA = 10010 ; public static final int CP_MAC_UKRAINE = 10017 ; public static final int CP_MAC_THAI = 10021 ; public static final int CP_MAC_CENTRAL_EUROPE = 10029 ; public static final int CP_MAC_ICELAND = 10079 ; public static final int CP_MAC_TURKISH = 10081 ; public static final int CP_MAC_CROATIAN = 10082 ; public static final int CP_US_ACSII = 20127 ; public static final int CP_KOI8_R = 20866 ; public static final int CP_ISO_8859_1 = 28591 ; public static final int CP_ISO_8859_2 = 28592 ; public static final int CP_ISO_8859_3 = 28593 ; public static final int CP_ISO_8859_4 = 28594 ; public static final int CP_ISO_8859_5 = 28595 ; public static final int CP_ISO_8859_6 = 28596 ; public static final int CP_ISO_8859_7 = 28597 ; public static final int CP_ISO_8859_8 = 28598 ; public static final int CP_ISO_8859_9 = 28599 ; public static final int CP_ISO_2022_JP1 = 50220 ; public static final int CP_ISO_2022_JP2 = 50221 ; public static final int CP_ISO_2022_JP3 = 50222 ; public static final int CP_ISO_2022_KR = 50225 ; public static final int CP_EUC_JP = 51932 ; public static final int CP_EUC_KR = 51949 ; public static final int CP_GB2312 = 52936 ; public static final int CP_GB18030 = 54936 ; public static final int CP_US_ASCII2 = 65000 ; public static final int CP_UTF8 = 65001 ; public static final int CP_UNICODE = CP_UTF16 ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '58', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Arrays ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IOUtils ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class DocumentBlock extends BigBlock { private static final byte _default_value = ( byte ) 0xFF ; private byte [ ] _data ; private int _bytes_read ; public DocumentBlock ( final RawDataBlock block ) throws IOException { _data = block . getData ( ) ; _bytes_read = _data . length ; } public DocumentBlock ( final InputStream stream ) throws IOException { this ( ) ; int count = IOUtils . readFully ( stream , _data ) ; _bytes_read = ( count == - 1 ) ? 0 : count ; } private DocumentBlock ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; } public int size ( ) { return _bytes_read ; } public boolean partiallyRead ( ) { return _bytes_read != POIFSConstants . BIG_BLOCK_SIZE ; } public static byte getFillByte ( ) { return _default_value ; } public static DocumentBlock [ ] convert ( final byte [ ] array , final int size ) { DocumentBlock [ ] rval = new DocumentBlock [ ( size + POIFSConstants . BIG_BLOCK_SIZE - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ] ; int offset = 0 ; for ( int k = 0 ; k < rval . length ; k ++ ) { rval [ k ] = new DocumentBlock ( ) ; if ( offset < array . length ) { int length = Math . min ( POIFSConstants . BIG_BLOCK_SIZE , array . length - offset ) ; System . arraycopy ( array , offset , rval [ k ] . _data , 0 , length ) ; if ( length != POIFSConstants . BIG_BLOCK_SIZE ) { Arrays . fill ( rval [ k ] . _data , length , POIFSConstants . BIG_BLOCK_SIZE , _default_value ) ; } } else { Arrays . fill ( rval [ k ] . _data , _default_value ) ; } offset += POIFSConstants . BIG_BLOCK_SIZE ; } return rval ; } public static void read ( final DocumentBlock [ ] blocks , final byte [ ] buffer , final int offset ) { int firstBlockIndex = offset / POIFSConstants . BIG_BLOCK_SIZE ; int firstBlockOffset = offset % POIFSConstants . BIG_BLOCK_SIZE ; int lastBlockIndex = ( offset + buffer . length - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ; if ( firstBlockIndex == lastBlockIndex ) { System . arraycopy ( blocks [ firstBlockIndex ] . _data , firstBlockOffset , buffer , 0 , buffer . length ) ; } else { int buffer_offset = 0 ; System . arraycopy ( blocks [ firstBlockIndex ] . _data , firstBlockOffset , buffer , buffer_offset , POIFSConstants . BIG_BLOCK_SIZE - firstBlockOffset ) ; buffer_offset += POIFSConstants . BIG_BLOCK_SIZE - firstBlockOffset ; for ( int j = firstBlockIndex + 1 ; j < lastBlockIndex ; j ++ ) { System . arraycopy ( blocks [ j ] . _data , 0 , buffer , buffer_offset , POIFSConstants . BIG_BLOCK_SIZE ) ; buffer_offset += POIFSConstants . BIG_BLOCK_SIZE ; } System . arraycopy ( blocks [ lastBlockIndex ] . _data , 0 , buffer , buffer_offset , buffer . length - buffer_offset ) ; } } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0	['10', '2', '0', '5', '19', '5', '2', '3', '8', '0.740740741', '223', '1', '0', '0.3', '0.228571429', '1', '2', '21', '3', '1.2', '0']
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class PowerPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x07 ; public PowerPtg ( ) { } public PowerPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return "^" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( toFormulaString ( ( Workbook ) null ) ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public Object clone ( ) { return new PowerPtg ( ) ; } } 	0	['9', '2', '0', '5', '13', '36', '2', '3', '9', '1.125', '62', '0', '0', '0.3', '0.259259259', '0', '0', '5.666666667', '1', '0.7778', '0']
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; public class POIFSViewEngine { private static final String _EOL = System . getProperty ( "line.separator" ) ; public static List inspectViewable ( final Object viewable , final boolean drilldown , final int indentLevel , final String indentString ) { List objects = new ArrayList ( ) ; if ( viewable instanceof POIFSViewable ) { POIFSViewable inspected = ( POIFSViewable ) viewable ; objects . add ( indent ( indentLevel , indentString , inspected . getShortDescription ( ) ) ) ; if ( drilldown ) { if ( inspected . preferArray ( ) ) { Object [ ] data = inspected . getViewableArray ( ) ; for ( int j = 0 ; j < data . length ; j ++ ) { objects . addAll ( inspectViewable ( data [ j ] , drilldown , indentLevel + 1 , indentString ) ) ; } } else { Iterator iter = inspected . getViewableIterator ( ) ; while ( iter . hasNext ( ) ) { objects . addAll ( inspectViewable ( iter . next ( ) , drilldown , indentLevel + 1 , indentString ) ) ; } } } } else { objects . add ( indent ( indentLevel , indentString , viewable . toString ( ) ) ) ; } return objects ; } private static String indent ( final int indentLevel , final String indentString , final String data ) { StringBuffer finalBuffer = new StringBuffer ( ) ; StringBuffer indentPrefix = new StringBuffer ( ) ; for ( int j = 0 ; j < indentLevel ; j ++ ) { indentPrefix . append ( indentString ) ; } LineNumberReader reader = new LineNumberReader ( new StringReader ( data ) ) ; try { String line = reader . readLine ( ) ; while ( line != null ) { finalBuffer . append ( indentPrefix ) . append ( line ) . append ( _EOL ) ; line = reader . readLine ( ) ; } } catch ( IOException e ) { finalBuffer . append ( indentPrefix ) . append ( e . getMessage ( ) ) . append ( _EOL ) ; } return finalBuffer . toString ( ) ; } } 	0	['4', '1', '0', '2', '24', '4', '1', '1', '2', '0.333333333', '146', '1', '0', '0', '0.466666667', '0', '0', '35.25', '3', '1.25', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . util . * ; public class RightMarginRecord extends Record implements Margin { public final static short sid = 0x27 ; private double field_1_margin ; public RightMarginRecord ( ) { } public RightMarginRecord ( RecordInputStream in ) { super ( in ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "Not a RightMargin record" ) ; } } protected void fillFields ( RecordInputStream in ) { field_1_margin = in . readDouble ( ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[RightMargin]\n" ) ; buffer . append ( "    .margin               = " ) . append ( " (" ) . append ( getMargin ( ) ) . append ( " )\n" ) ; buffer . append ( "[/RightMargin]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putDouble ( data , 4 + offset , field_1_margin ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 8 ; } public short getSid ( ) { return sid ; } public double getMargin ( ) { return field_1_margin ; } public void setMargin ( double field_1_margin ) { this . field_1_margin = field_1_margin ; } public Object clone ( ) { RightMarginRecord rec = new RightMarginRecord ( ) ; rec . field_1_margin = this . field_1_margin ; return rec ; } } 	0	['11', '2', '0', '7', '21', '35', '2', '5', '9', '0.8', '107', '0.5', '0', '0.55', '0.257575758', '1', '4', '8.545454545', '2', '0.9091', '0']
package org . apache . poi . poifs . property ; import org . apache . poi . poifs . filesystem . POIFSDocument ; public class DocumentProperty extends Property { private POIFSDocument _document ; public DocumentProperty ( final String name , final int size ) { super ( ) ; _document = null ; setName ( name ) ; setSize ( size ) ; setNodeColor ( _NODE_BLACK ) ; setPropertyType ( PropertyConstants . DOCUMENT_TYPE ) ; } protected DocumentProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; _document = null ; } public void setDocument ( POIFSDocument doc ) { _document = doc ; } public POIFSDocument getDocument ( ) { return _document ; } public boolean shouldUseSmallBlocks ( ) { return super . shouldUseSmallBlocks ( ) ; } public boolean isDirectory ( ) { return false ; } protected void preWrite ( ) { } } 	0	['7', '2', '0', '6', '14', '9', '5', '2', '5', '0.5', '48', '1', '1', '0.848484848', '0.342857143', '0', '0', '5.714285714', '1', '0.7143', '0']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . PrintSetupRecord ; public class HSSFPrintSetup extends Object { public static final short LETTER_PAPERSIZE = 1 ; public static final short LEGAL_PAPERSIZE = 5 ; public static final short EXECUTIVE_PAPERSIZE = 7 ; public static final short A4_PAPERSIZE = 9 ; public static final short A5_PAPERSIZE = 11 ; public static final short ENVELOPE_10_PAPERSIZE = 20 ; public static final short ENVELOPE_DL_PAPERSIZE = 27 ; public static final short ENVELOPE_CS_PAPERSIZE = 28 ; public static final short ENVELOPE_MONARCH_PAPERSIZE = 37 ; PrintSetupRecord printSetupRecord ; protected HSSFPrintSetup ( PrintSetupRecord printSetupRecord ) { this . printSetupRecord = printSetupRecord ; } public void setPaperSize ( short size ) { printSetupRecord . setPaperSize ( size ) ; } public void setScale ( short scale ) { printSetupRecord . setScale ( scale ) ; } public void setPageStart ( short start ) { printSetupRecord . setPageStart ( start ) ; } public void setFitWidth ( short width ) { printSetupRecord . setFitWidth ( width ) ; } public void setFitHeight ( short height ) { printSetupRecord . setFitHeight ( height ) ; } public void setOptions ( short options ) { printSetupRecord . setOptions ( options ) ; } public void setLeftToRight ( boolean ltor ) { printSetupRecord . setLeftToRight ( ltor ) ; } public void setLandscape ( boolean ls ) { printSetupRecord . setLandscape ( ! ls ) ; } public void setValidSettings ( boolean valid ) { printSetupRecord . setValidSettings ( valid ) ; } public void setNoColor ( boolean mono ) { printSetupRecord . setNoColor ( mono ) ; } public void setDraft ( boolean d ) { printSetupRecord . setDraft ( d ) ; } public void setNotes ( boolean printnotes ) { printSetupRecord . setNotes ( printnotes ) ; } public void setNoOrientation ( boolean orientation ) { printSetupRecord . setNoOrientation ( orientation ) ; } public void setUsePage ( boolean page ) { printSetupRecord . setUsePage ( page ) ; } public void setHResolution ( short resolution ) { printSetupRecord . setHResolution ( resolution ) ; } public void setVResolution ( short resolution ) { printSetupRecord . setVResolution ( resolution ) ; } public void setHeaderMargin ( double headermargin ) { printSetupRecord . setHeaderMargin ( headermargin ) ; } public void setFooterMargin ( double footermargin ) { printSetupRecord . setFooterMargin ( footermargin ) ; } public void setCopies ( short copies ) { printSetupRecord . setCopies ( copies ) ; } public short getPaperSize ( ) { return printSetupRecord . getPaperSize ( ) ; } public short getScale ( ) { return printSetupRecord . getScale ( ) ; } public short getPageStart ( ) { return printSetupRecord . getPageStart ( ) ; } public short getFitWidth ( ) { return printSetupRecord . getFitWidth ( ) ; } public short getFitHeight ( ) { return printSetupRecord . getFitHeight ( ) ; } public short getOptions ( ) { return printSetupRecord . getOptions ( ) ; } public boolean getLeftToRight ( ) { return printSetupRecord . getLeftToRight ( ) ; } public boolean getLandscape ( ) { return ! printSetupRecord . getLandscape ( ) ; } public boolean getValidSettings ( ) { return printSetupRecord . getValidSettings ( ) ; } public boolean getNoColor ( ) { return printSetupRecord . getNoColor ( ) ; } public boolean getDraft ( ) { return printSetupRecord . getDraft ( ) ; } public boolean getNotes ( ) { return printSetupRecord . getNotes ( ) ; } public boolean getNoOrientation ( ) { return printSetupRecord . getNoOrientation ( ) ; } public boolean getUsePage ( ) { return printSetupRecord . getUsePage ( ) ; } public short getHResolution ( ) { return printSetupRecord . getHResolution ( ) ; } public short getVResolution ( ) { return printSetupRecord . getVResolution ( ) ; } public double getHeaderMargin ( ) { return printSetupRecord . getHeaderMargin ( ) ; } public double getFooterMargin ( ) { return printSetupRecord . getFooterMargin ( ) ; } public short getCopies ( ) { return printSetupRecord . getCopies ( ) ; } } 	0	['39', '1', '0', '3', '78', '0', '2', '1', '38', '0.923684211', '234', '0', '1', '0', '0.302564103', '0', '0', '4.743589744', '2', '1.0256', '0']
package org . apache . poi . util ; public interface LittleEndianConsts { public static final int BYTE_SIZE = 1 ; public static final int SHORT_SIZE = 2 ; public static final int INT_SIZE = 4 ; public static final int LONG_SIZE = 8 ; public static final int DOUBLE_SIZE = 8 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '5', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class RefNVPtg extends ReferencePtg { public final static byte sid = 0x4C ; protected RefNVPtg ( ) { } public RefNVPtg ( RecordInputStream in ) { super ( in ) ; } public void writeBytes ( byte [ ] array , int offset ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public String getRefPtgName ( ) { return "RefNVPtg" ; } public String toFormulaString ( Workbook book ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } public Object clone ( ) { throw new RuntimeException ( "Coding Error: This method should never be called. This ptg should be converted" ) ; } } 	0	['6', '3', '0', '5', '9', '15', '2', '3', '5', '1.2', '31', '0', '0', '0.851851852', '0.333333333', '0', '0', '4', '1', '0.6667', '0']
package org . apache . poi . hssf . record . formula ; public abstract class OperationPtg extends Ptg { public final static int TYPE_UNARY = 0 ; public final static int TYPE_BINARY = 1 ; public final static int TYPE_FUNCTION = 2 ; public abstract int getType ( ) ; public abstract String toFormulaString ( String [ ] operands ) ; public abstract int getNumberOfOperands ( ) ; public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } } 	0	['5', '2', '21', '24', '6', '10', '23', '1', '5', '1.25', '13', '0', '0', '0.636363636', '0.6', '0', '0', '1', '1', '0.8', '0']
package org . apache . poi . poifs . property ; import java . util . Iterator ; import java . io . IOException ; public interface Parent extends Child { public Iterator getChildren ( ) ; public void addChild ( final Property property ) throws IOException ; public void setPreviousChild ( final Child child ) ; public void setNextChild ( final Child child ) ; } 	0	['4', '1', '0', '3', '4', '6', '1', '2', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . eventfilesystem ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; public class POIFSReaderEvent { private DocumentInputStream stream ; private POIFSDocumentPath path ; private String documentName ; POIFSReaderEvent ( final DocumentInputStream stream , final POIFSDocumentPath path , final String documentName ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; } public DocumentInputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } } 	0	['4', '1', '0', '5', '5', '0', '3', '2', '3', '0.666666667', '28', '1', '2', '0', '0.4375', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . poi . hpsf ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Collections ; import java . util . Comparator ; import java . util . Date ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import org . apache . poi . hpsf . wellknown . PropertyIDMap ; import org . apache . poi . util . LittleEndian ; public class MutableSection extends Section { private boolean dirty = true ; private List preprops ; private byte [ ] sectionBytes ; public MutableSection ( ) { dirty = true ; formatID = null ; offset = - 1 ; preprops = new LinkedList ( ) ; } public MutableSection ( final Section s ) { setFormatID ( s . getFormatID ( ) ) ; final Property [ ] pa = s . getProperties ( ) ; final MutableProperty [ ] mpa = new MutableProperty [ pa . length ] ; for ( int i = 0 ; i < pa . length ; i ++ ) mpa [ i ] = new MutableProperty ( pa [ i ] ) ; setProperties ( mpa ) ; setDictionary ( s . getDictionary ( ) ) ; } public void setFormatID ( final ClassID formatID ) { this . formatID = formatID ; } public void setFormatID ( final byte [ ] formatID ) { ClassID fid = getFormatID ( ) ; if ( fid == null ) { fid = new ClassID ( ) ; setFormatID ( fid ) ; } fid . setBytes ( formatID ) ; } public void setProperties ( final Property [ ] properties ) { this . properties = properties ; preprops = new LinkedList ( ) ; for ( int i = 0 ; i < properties . length ; i ++ ) preprops . add ( properties [ i ] ) ; dirty = true ; } public void setProperty ( final int id , final String value ) { setProperty ( id , Variant . VT_LPWSTR , value ) ; dirty = true ; } public void setProperty ( final int id , final int value ) { setProperty ( id , Variant . VT_I4 , new Integer ( value ) ) ; dirty = true ; } public void setProperty ( final int id , final long value ) { setProperty ( id , Variant . VT_I8 , new Long ( value ) ) ; dirty = true ; } public void setProperty ( final int id , final boolean value ) { setProperty ( id , Variant . VT_BOOL , new Boolean ( value ) ) ; dirty = true ; } public void setProperty ( final int id , final long variantType , final Object value ) { final MutableProperty p = new MutableProperty ( ) ; p . setID ( id ) ; p . setType ( variantType ) ; p . setValue ( value ) ; setProperty ( p ) ; dirty = true ; } public void setProperty ( final Property p ) { final long id = p . getID ( ) ; removeProperty ( id ) ; preprops . add ( p ) ; dirty = true ; } public void removeProperty ( final long id ) { for ( final Iterator i = preprops . iterator ( ) ; i . hasNext ( ) ; ) if ( ( ( Property ) i . next ( ) ) . getID ( ) == id ) { i . remove ( ) ; break ; } dirty = true ; } protected void setPropertyBooleanValue ( final int id , final boolean value ) { setProperty ( id , Variant . VT_BOOL , new Boolean ( value ) ) ; } public int getSize ( ) { if ( dirty ) { try { size = calcSize ( ) ; dirty = false ; } catch ( HPSFRuntimeException ex ) { throw ex ; } catch ( Exception ex ) { throw new HPSFRuntimeException ( ex ) ; } } return size ; } private int calcSize ( ) throws WritingNotSupportedException , IOException { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; write ( out ) ; out . close ( ) ; sectionBytes = Util . pad4 ( out . toByteArray ( ) ) ; return sectionBytes . length ; } public int write ( final OutputStream out ) throws WritingNotSupportedException , IOException { if ( ! dirty && sectionBytes != null ) { out . write ( sectionBytes ) ; return sectionBytes . length ; } final ByteArrayOutputStream propertyStream = new ByteArrayOutputStream ( ) ; final ByteArrayOutputStream propertyListStream = new ByteArrayOutputStream ( ) ; int position = 0 ; position += 2 * LittleEndian . INT_SIZE + getPropertyCount ( ) * 2 * LittleEndian . INT_SIZE ; int codepage = - 1 ; if ( getProperty ( PropertyIDMap . PID_DICTIONARY ) != null ) { final Object p1 = getProperty ( PropertyIDMap . PID_CODEPAGE ) ; if ( p1 != null ) { if ( ! ( p1 instanceof Integer ) ) throw new IllegalPropertySetDataException ( "The codepage property (ID = 1) must be an " + "Integer object." ) ; } else setProperty ( PropertyIDMap . PID_CODEPAGE , Variant . VT_I2 , new Integer ( Constants . CP_UNICODE ) ) ; codepage = getCodepage ( ) ; } Collections . sort ( preprops , new Comparator ( ) { public int compare ( final Object o1 , final Object o2 ) { final Property p1 = ( Property ) o1 ; final Property p2 = ( Property ) o2 ; if ( p1 . getID ( ) < p2 . getID ( ) ) return - 1 ; else if ( p1 . getID ( ) == p2 . getID ( ) ) return 0 ; else return 1 ; } } ) ; for ( final ListIterator i = preprops . listIterator ( ) ; i . hasNext ( ) ; ) { final MutableProperty p = ( MutableProperty ) i . next ( ) ; final long id = p . getID ( ) ; TypeWriter . writeUIntToStream ( propertyListStream , p . getID ( ) ) ; TypeWriter . writeUIntToStream ( propertyListStream , position ) ; if ( id != 0 ) position += p . write ( propertyStream , getCodepage ( ) ) ; else { if ( codepage == - 1 ) throw new IllegalPropertySetDataException ( "Codepage (property 1) is undefined." ) ; position += writeDictionary ( propertyStream , dictionary , codepage ) ; } } propertyStream . close ( ) ; propertyListStream . close ( ) ; byte [ ] pb1 = propertyListStream . toByteArray ( ) ; byte [ ] pb2 = propertyStream . toByteArray ( ) ; TypeWriter . writeToStream ( out , LittleEndian . INT_SIZE * 2 + pb1 . length + pb2 . length ) ; TypeWriter . writeToStream ( out , getPropertyCount ( ) ) ; out . write ( pb1 ) ; out . write ( pb2 ) ; int streamLength = LittleEndian . INT_SIZE * 2 + pb1 . length + pb2 . length ; return streamLength ; } private static int writeDictionary ( final OutputStream out , final Map dictionary , final int codepage ) throws IOException { int length = TypeWriter . writeUIntToStream ( out , dictionary . size ( ) ) ; for ( final Iterator i = dictionary . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final Long key = ( Long ) i . next ( ) ; final String value = ( String ) dictionary . get ( key ) ; if ( codepage == Constants . CP_UNICODE ) { int sLength = value . length ( ) + 1 ; if ( sLength % 2 == 1 ) sLength ++ ; length += TypeWriter . writeUIntToStream ( out , key . longValue ( ) ) ; length += TypeWriter . writeUIntToStream ( out , sLength ) ; final byte [ ] ca = value . getBytes ( VariantSupport . codepageToEncoding ( codepage ) ) ; for ( int j = 2 ; j < ca . length ; j += 2 ) { out . write ( ca [ j + 1 ] ) ; out . write ( ca [ j ] ) ; length += 2 ; } sLength -= value . length ( ) ; while ( sLength > 0 ) { out . write ( 0x00 ) ; out . write ( 0x00 ) ; length += 2 ; sLength -- ; } } else { length += TypeWriter . writeUIntToStream ( out , key . longValue ( ) ) ; length += TypeWriter . writeUIntToStream ( out , value . length ( ) + 1 ) ; final byte [ ] ba = value . getBytes ( VariantSupport . codepageToEncoding ( codepage ) ) ; for ( int j = 0 ; j < ba . length ; j ++ ) { out . write ( ba [ j ] ) ; length ++ ; } out . write ( 0x00 ) ; length ++ ; } } return length ; } public int getPropertyCount ( ) { return preprops . size ( ) ; } public Property [ ] getProperties ( ) { properties = ( Property [ ] ) preprops . toArray ( new Property [ 0 ] ) ; return properties ; } public Object getProperty ( final long id ) { getProperties ( ) ; return super . getProperty ( id ) ; } public void setDictionary ( final Map dictionary ) throws IllegalPropertySetDataException { if ( dictionary != null ) { for ( final Iterator i = dictionary . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) if ( ! ( i . next ( ) instanceof Long ) ) throw new IllegalPropertySetDataException ( "Dictionary keys must be of type Long." ) ; for ( final Iterator i = dictionary . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) if ( ! ( i . next ( ) instanceof String ) ) throw new IllegalPropertySetDataException ( "Dictionary values must be of type String." ) ; this . dictionary = dictionary ; setProperty ( PropertyIDMap . PID_DICTIONARY , - 1 , dictionary ) ; final Integer codepage = ( Integer ) getProperty ( PropertyIDMap . PID_CODEPAGE ) ; if ( codepage == null ) setProperty ( PropertyIDMap . PID_CODEPAGE , Variant . VT_I2 , new Integer ( Constants . CP_UNICODE ) ) ; } else removeProperty ( PropertyIDMap . PID_DICTIONARY ) ; } public void setProperty ( final int id , final Object value ) { if ( value instanceof String ) setProperty ( id , ( String ) value ) ; else if ( value instanceof Long ) setProperty ( id , ( ( Long ) value ) . longValue ( ) ) ; else if ( value instanceof Integer ) setProperty ( id , ( ( Integer ) value ) . intValue ( ) ) ; else if ( value instanceof Short ) setProperty ( id , ( ( Short ) value ) . intValue ( ) ) ; else if ( value instanceof Boolean ) setProperty ( id , ( ( Boolean ) value ) . booleanValue ( ) ) ; else if ( value instanceof Date ) setProperty ( id , Variant . VT_FILETIME , value ) ; else throw new HPSFRuntimeException ( "HPSF does not support properties of type " + value . getClass ( ) . getName ( ) + "." ) ; } public void clear ( ) { final Property [ ] properties = getProperties ( ) ; for ( int i = 0 ; i < properties . length ; i ++ ) { final Property p = properties [ i ] ; removeProperty ( p . getID ( ) ) ; } } public void setCodepage ( final int codepage ) { setProperty ( PropertyIDMap . PID_CODEPAGE , Variant . VT_I2 , new Integer ( codepage ) ) ; } } 	0	['24', '2', '0', '15', '86', '116', '5', '11', '21', '0.507246377', '781', '1', '0', '0.290322581', '0.16025641', '1', '7', '31.41666667', '7', '1.4167', '0']
package org . apache . poi . util ; import java . util . List ; import java . util . ArrayList ; public class IntList2d { List rows = new ArrayList ( ) ; public int get ( int col , int row ) { if ( row >= rows . size ( ) ) { return 0 ; } else { IntList cols = ( IntList ) rows . get ( row ) ; if ( col >= cols . size ( ) ) return 0 ; else return cols . get ( col ) ; } } public void set ( int col , int row , int value ) { resizeRows ( row ) ; resizeCols ( row , col ) ; IntList cols = ( IntList ) rows . get ( row ) ; cols . set ( col , value ) ; } private void resizeRows ( int row ) { while ( rows . size ( ) <= row ) rows . add ( new IntList ( ) ) ; } private void resizeCols ( int row , int col ) { IntList cols = ( IntList ) rows . get ( row ) ; while ( cols . size ( ) <= col ) cols . add ( 0 ) ; } public boolean isAllocated ( int col , int row ) { if ( row < rows . size ( ) ) { IntList cols = ( IntList ) rows . get ( row ) ; return ( col < cols . size ( ) ) ; } else { return false ; } } } 	0	['6', '1', '0', '1', '16', '0', '0', '1', '4', '0', '108', '0', '0', '0', '0.916666667', '0', '0', '16.83333333', '3', '1.8333', '0']
package org . apache . poi . hpsf ; public class CustomProperty extends MutableProperty { private String name ; public CustomProperty ( ) { this . name = null ; } public CustomProperty ( final Property property ) { this ( property , null ) ; } public CustomProperty ( final Property property , final String name ) { super ( property ) ; this . name = name ; } public String getName ( ) { return name ; } public void setName ( final String name ) { this . name = name ; } public boolean equalsContents ( final Object o ) { final CustomProperty c = ( CustomProperty ) o ; final String name1 = c . getName ( ) ; final String name2 = this . getName ( ) ; boolean equalNames = true ; if ( name1 == null ) equalNames = name2 == null ; else equalNames = name1 . equals ( name2 ) ; return equalNames && c . getID ( ) == this . getID ( ) && c . getType ( ) == this . getType ( ) && c . getValue ( ) . equals ( this . getValue ( ) ) ; } public int hashCode ( ) { return ( int ) this . getID ( ) ; } } 	0	['7', '3', '0', '4', '14', '9', '2', '2', '7', '0.166666667', '85', '1', '0', '0.692307692', '0.428571429', '1', '1', '11', '7', '1.4286', '0']
package org . apache . poi . hssf . record ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . LittleEndian ; import java . util . Stack ; import java . util . Iterator ; public class LinkedDataFormulaField implements CustomField { Stack formulaTokens = new Stack ( ) ; public int getSize ( ) { int size = 0 ; for ( Iterator iterator = formulaTokens . iterator ( ) ; iterator . hasNext ( ) ; ) { Ptg token = ( Ptg ) iterator . next ( ) ; size += token . getSize ( ) ; } return size + 2 ; } public int fillField ( RecordInputStream in ) { short tokenSize = in . readShort ( ) ; formulaTokens = Ptg . createParsedExpressionTokens ( tokenSize , in ) ; return tokenSize + 2 ; } public void toString ( StringBuffer buffer ) { for ( int k = 0 ; k < formulaTokens . size ( ) ; k ++ ) { buffer . append ( "Formula " ) . append ( k ) . append ( "=" ) . append ( formulaTokens . get ( k ) . toString ( ) ) . append ( "\n" ) . append ( ( ( Ptg ) formulaTokens . get ( k ) ) . toDebugString ( ) ) . append ( "\n" ) ; } } public String toString ( ) { StringBuffer b = new StringBuffer ( ) ; toString ( b ) ; return b . toString ( ) ; } public int serializeField ( int offset , byte [ ] data ) { int size = getSize ( ) ; LittleEndian . putShort ( data , offset , ( short ) ( size - 2 ) ) ; int pos = offset + 2 ; pos += Ptg . serializePtgStack ( formulaTokens , data , pos ) ; return size ; } public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } public void setFormulaTokens ( Stack formulaTokens ) { this . formulaTokens = ( Stack ) formulaTokens . clone ( ) ; } public Stack getFormulaTokens ( ) { return ( Stack ) this . formulaTokens . clone ( ) ; } } 	0	['9', '1', '0', '5', '29', '0', '1', '4', '9', '0.125', '139', '0', '0', '0', '0.259259259', '0', '0', '14.33333333', '2', '1.1111', '0']
package org . apache . poi . hpsf ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . poi . util . LittleEndian ; public class TypeWriter { public static int writeToStream ( final OutputStream out , final short n ) throws IOException { final int length = LittleEndian . SHORT_SIZE ; byte [ ] buffer = new byte [ length ] ; LittleEndian . putShort ( buffer , 0 , n ) ; out . write ( buffer , 0 , length ) ; return length ; } public static int writeToStream ( final OutputStream out , final int n ) throws IOException { final int l = LittleEndian . INT_SIZE ; final byte [ ] buffer = new byte [ l ] ; LittleEndian . putInt ( buffer , 0 , n ) ; out . write ( buffer , 0 , l ) ; return l ; } public static int writeToStream ( final OutputStream out , final long n ) throws IOException { final int l = LittleEndian . LONG_SIZE ; final byte [ ] buffer = new byte [ l ] ; LittleEndian . putLong ( buffer , 0 , n ) ; out . write ( buffer , 0 , l ) ; return l ; } public static void writeUShortToStream ( final OutputStream out , final int n ) throws IOException { int high = n & 0xFFFF0000 ; if ( high != 0 ) throw new IllegalPropertySetDataException ( "Value " + n + " cannot be represented by 2 bytes." ) ; writeToStream ( out , ( short ) n ) ; } public static int writeUIntToStream ( final OutputStream out , final long n ) throws IOException { long high = n & 0xFFFFFFFF00000000L ; if ( high != 0 && high != 0xFFFFFFFF00000000L ) throw new IllegalPropertySetDataException ( "Value " + n + " cannot be represented by 4 bytes." ) ; return writeToStream ( out , ( int ) n ) ; } public static int writeToStream ( final OutputStream out , final ClassID n ) throws IOException { byte [ ] b = new byte [ 16 ] ; n . write ( b , 0 ) ; out . write ( b , 0 , b . length ) ; return b . length ; } public static void writeToStream ( final OutputStream out , final Property [ ] properties , final int codepage ) throws IOException , UnsupportedVariantTypeException { if ( properties == null ) return ; for ( int i = 0 ; i < properties . length ; i ++ ) { final Property p = properties [ i ] ; writeUIntToStream ( out , p . getID ( ) ) ; writeUIntToStream ( out , p . getSize ( ) ) ; } for ( int i = 0 ; i < properties . length ; i ++ ) { final Property p = properties [ i ] ; long type = p . getType ( ) ; writeUIntToStream ( out , type ) ; VariantSupport . write ( out , ( int ) type , p . getValue ( ) , codepage ) ; } } public static int writeToStream ( final OutputStream out , final double n ) throws IOException { final int l = LittleEndian . DOUBLE_SIZE ; final byte [ ] buffer = new byte [ l ] ; LittleEndian . putDouble ( buffer , 0 , n ) ; out . write ( buffer , 0 , l ) ; return l ; } } 	0	['9', '1', '0', '9', '27', '36', '4', '6', '9', '2', '204', '0', '0', '0', '0.25', '0', '0', '21.66666667', '1', '0.8889', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaVPtg extends AreaPtg { public final static short sid = 0x45 ; protected AreaVPtg ( ) { } public AreaVPtg ( short firstRow , short lastRow , short firstColumn , short lastColumn , boolean firstRowRelative , boolean lastRowRelative , boolean firstColRelative , boolean lastColRelative ) { super ( firstRow , lastRow , firstColumn , lastColumn , firstRowRelative , lastRowRelative , firstColRelative , lastColRelative ) ; } public AreaVPtg ( RecordInputStream in ) { super ( in ) ; } public String getAreaPtgName ( ) { return "AreaVPtg" ; } public Object clone ( ) { AreaVPtg ptg = new AreaVPtg ( ) ; ptg . setFirstRow ( getFirstRow ( ) ) ; ptg . setLastRow ( getLastRow ( ) ) ; ptg . setFirstColumnRaw ( getFirstColumnRaw ( ) ) ; ptg . setLastColumnRaw ( getLastColumnRaw ( ) ) ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0	['5', '3', '0', '4', '17', '10', '2', '2', '4', '1.25', '52', '0', '0', '0.933333333', '0.4', '1', '1', '9.2', '1', '0.4', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . util . BitFieldFactory ; import org . apache . poi . util . StringUtil ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordFormatException ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnicodeString ; public class ArrayPtgV extends ArrayPtg { public final static byte sid = 0x40 ; protected ArrayPtgV ( ) { } public ArrayPtgV ( RecordInputStream in ) { super ( in ) ; } public Object clone ( ) { ArrayPtgV ptg = new ArrayPtgV ( ) ; ptg . field_1_reserved = field_1_reserved ; ptg . field_2_reserved = field_2_reserved ; ptg . field_3_reserved = field_3_reserved ; ptg . field_4_reserved = field_4_reserved ; ptg . field_5_reserved = field_5_reserved ; ptg . field_6_reserved = field_6_reserved ; ptg . field_7_reserved = field_7_reserved ; ptg . token_1_columns = token_1_columns ; ptg . token_2_rows = token_2_rows ; ptg . token_3_arrayValues = new Object [ getColumnCount ( ) ] [ getRowCount ( ) ] ; for ( int x = 0 ; x < getColumnCount ( ) ; x ++ ) { for ( int y = 0 ; y < getRowCount ( ) ; y ++ ) { ptg . token_3_arrayValues [ x ] [ y ] = token_3_arrayValues [ x ] [ y ] ; } } ptg . setClass ( ptgClass ) ; return ptg ; } } 	0	['3', '3', '0', '3', '8', '3', '1', '2', '2', '1.5', '92', '0', '0', '0.95', '0.666666667', '1', '5', '29.33333333', '3', '1', '0']
package org . apache . poi . poifs . common ; public interface POIFSConstants { public static final int BIG_BLOCK_SIZE = 0x0200 ; public static final int END_OF_CHAIN = - 2 ; public static final int PROPERTY_SIZE = 0x0080 ; public static final int UNUSED_BLOCK = - 1 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . hpsf ; import java . util . Iterator ; import java . util . Map ; import org . apache . poi . hpsf . wellknown . PropertyIDMap ; import org . apache . poi . hpsf . wellknown . SectionIDMap ; public class DocumentSummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005DocumentSummaryInformation" ; public DocumentSummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isDocumentSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getCategory ( ) { return ( String ) getProperty ( PropertyIDMap . PID_CATEGORY ) ; } public void setCategory ( final String category ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_CATEGORY , category ) ; } public void removeCategory ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_CATEGORY ) ; } public String getPresentationFormat ( ) { return ( String ) getProperty ( PropertyIDMap . PID_PRESFORMAT ) ; } public void setPresentationFormat ( final String presentationFormat ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_PRESFORMAT , presentationFormat ) ; } public void removePresentationFormat ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_PRESFORMAT ) ; } public int getByteCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_BYTECOUNT ) ; } public void setByteCount ( final int byteCount ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_BYTECOUNT , byteCount ) ; } public void removeByteCount ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_BYTECOUNT ) ; } public int getLineCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_LINECOUNT ) ; } public void setLineCount ( final int lineCount ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_LINECOUNT , lineCount ) ; } public void removeLineCount ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_LINECOUNT ) ; } public int getParCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PARCOUNT ) ; } public void setParCount ( final int parCount ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_PARCOUNT , parCount ) ; } public void removeParCount ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_PARCOUNT ) ; } public int getSlideCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SLIDECOUNT ) ; } public void setSlideCount ( final int slideCount ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_SLIDECOUNT , slideCount ) ; } public void removeSlideCount ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_SLIDECOUNT ) ; } public int getNoteCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_NOTECOUNT ) ; } public void setNoteCount ( final int noteCount ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_NOTECOUNT , noteCount ) ; } public void removeNoteCount ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_NOTECOUNT ) ; } public int getHiddenCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_HIDDENCOUNT ) ; } public void setHiddenCount ( final int hiddenCount ) { final MutableSection s = ( MutableSection ) getSections ( ) . get ( 0 ) ; s . setProperty ( PropertyIDMap . PID_HIDDENCOUNT , hiddenCount ) ; } public void removeHiddenCount ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_HIDDENCOUNT ) ; } public int getMMClipCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_MMCLIPCOUNT ) ; } public void setMMClipCount ( final int mmClipCount ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_MMCLIPCOUNT , mmClipCount ) ; } public void removeMMClipCount ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_MMCLIPCOUNT ) ; } public boolean getScale ( ) { return getPropertyBooleanValue ( PropertyIDMap . PID_SCALE ) ; } public void setScale ( final boolean scale ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_SCALE , scale ) ; } public void removeScale ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_SCALE ) ; } public byte [ ] getHeadingPair ( ) { notYetImplemented ( "Reading byte arrays " ) ; return ( byte [ ] ) getProperty ( PropertyIDMap . PID_HEADINGPAIR ) ; } public void setHeadingPair ( final byte [ ] headingPair ) { notYetImplemented ( "Writing byte arrays " ) ; } public void removeHeadingPair ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_HEADINGPAIR ) ; } public byte [ ] getDocparts ( ) { notYetImplemented ( "Reading byte arrays" ) ; return ( byte [ ] ) getProperty ( PropertyIDMap . PID_DOCPARTS ) ; } public void setDocparts ( final byte [ ] docparts ) { notYetImplemented ( "Writing byte arrays" ) ; } public void removeDocparts ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_DOCPARTS ) ; } public String getManager ( ) { return ( String ) getProperty ( PropertyIDMap . PID_MANAGER ) ; } public void setManager ( final String manager ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_MANAGER , manager ) ; } public void removeManager ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_MANAGER ) ; } public String getCompany ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMPANY ) ; } public void setCompany ( final String company ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_COMPANY , company ) ; } public void removeCompany ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_COMPANY ) ; } public boolean getLinksDirty ( ) { return getPropertyBooleanValue ( PropertyIDMap . PID_LINKSDIRTY ) ; } public void setLinksDirty ( final boolean linksDirty ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . setProperty ( PropertyIDMap . PID_LINKSDIRTY , linksDirty ) ; } public void removeLinksDirty ( ) { final MutableSection s = ( MutableSection ) getFirstSection ( ) ; s . removeProperty ( PropertyIDMap . PID_LINKSDIRTY ) ; } public CustomProperties getCustomProperties ( ) { CustomProperties cps = null ; if ( getSectionCount ( ) >= 2 ) { cps = new CustomProperties ( ) ; final Section section = ( Section ) getSections ( ) . get ( 1 ) ; final Map dictionary = section . getDictionary ( ) ; final Property [ ] properties = section . getProperties ( ) ; int propertyCount = 0 ; for ( int i = 0 ; i < properties . length ; i ++ ) { final Property p = properties [ i ] ; final long id = p . getID ( ) ; if ( id != 0 && id != 1 ) { propertyCount ++ ; final CustomProperty cp = new CustomProperty ( p , ( String ) dictionary . get ( new Long ( id ) ) ) ; cps . put ( cp . getName ( ) , cp ) ; } } if ( cps . size ( ) != propertyCount ) cps . setPure ( false ) ; } return cps ; } public void setCustomProperties ( final CustomProperties customProperties ) { ensureSection2 ( ) ; final MutableSection section = ( MutableSection ) getSections ( ) . get ( 1 ) ; final Map dictionary = customProperties . getDictionary ( ) ; section . clear ( ) ; int cpCodepage = customProperties . getCodepage ( ) ; if ( cpCodepage < 0 ) cpCodepage = section . getCodepage ( ) ; if ( cpCodepage < 0 ) cpCodepage = Constants . CP_UNICODE ; customProperties . setCodepage ( cpCodepage ) ; section . setCodepage ( cpCodepage ) ; section . setDictionary ( dictionary ) ; for ( final Iterator i = customProperties . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final Property p = ( Property ) i . next ( ) ; section . setProperty ( p ) ; } } private void ensureSection2 ( ) { if ( getSectionCount ( ) < 2 ) { MutableSection s2 = new MutableSection ( ) ; s2 . setFormatID ( SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID [ 1 ] ) ; addSection ( s2 ) ; } } public void removeCustomProperties ( ) { if ( getSectionCount ( ) >= 2 ) getSections ( ) . remove ( 1 ) ; else throw new HPSFRuntimeException ( "Illegal internal format of Document SummaryInformation stream: second section is missing." ) ; } private void notYetImplemented ( final String msg ) { throw new UnsupportedOperationException ( msg + " is not yet implemented." ) ; } } 	0	['51', '3', '0', '11', '99', '1275', '1', '10', '49', '1.02', '564', '0', '0', '0.333333333', '0.193277311', '0', '0', '10.03921569', '6', '1.1765', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . util . BitFieldFactory ; import org . apache . poi . util . StringUtil ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordFormatException ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnicodeString ; public class ArrayPtgA extends ArrayPtg { public final static byte sid = 0x60 ; protected ArrayPtgA ( ) { super ( ) ; } public ArrayPtgA ( RecordInputStream in ) { super ( in ) ; } public Object clone ( ) { ArrayPtgA ptg = new ArrayPtgA ( ) ; ptg . field_1_reserved = field_1_reserved ; ptg . field_2_reserved = field_2_reserved ; ptg . field_3_reserved = field_3_reserved ; ptg . field_4_reserved = field_4_reserved ; ptg . field_5_reserved = field_5_reserved ; ptg . field_6_reserved = field_6_reserved ; ptg . field_7_reserved = field_7_reserved ; ptg . token_1_columns = token_1_columns ; ptg . token_2_rows = token_2_rows ; ptg . token_3_arrayValues = new Object [ getColumnCount ( ) ] [ getRowCount ( ) ] ; for ( int x = 0 ; x < getColumnCount ( ) ; x ++ ) { for ( int y = 0 ; y < getRowCount ( ) ; y ++ ) { ptg . token_3_arrayValues [ x ] [ y ] = token_3_arrayValues [ x ] [ y ] ; } } ptg . setClass ( ptgClass ) ; return ptg ; } } 	0	['3', '3', '0', '3', '8', '3', '1', '2', '2', '1.5', '92', '0', '0', '0.95', '0.666666667', '1', '5', '29.33333333', '3', '1', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; import org . apache . poi . hssf . usermodel . HSSFErrorConstants ; public class ErrPtg extends Ptg { public static final short sid = 0x1c ; private static final int SIZE = 7 ; private byte field_1_error_code ; public ErrPtg ( ) { } public ErrPtg ( RecordInputStream in ) { field_1_error_code = in . readByte ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; array [ offset + 1 ] = field_1_error_code ; } public String toFormulaString ( Workbook book ) { switch ( field_1_error_code ) { case HSSFErrorConstants . ERROR_NULL : return "#NULL!" ; case HSSFErrorConstants . ERROR_DIV_0 : return "#DIV/0!" ; case HSSFErrorConstants . ERROR_VALUE : return "#VALUE!" ; case HSSFErrorConstants . ERROR_REF : return "#REF!" ; case HSSFErrorConstants . ERROR_NAME : return "#NAME?" ; case HSSFErrorConstants . ERROR_NUM : return "#NUM!" ; case HSSFErrorConstants . ERROR_NA : return "#N/A" ; } return "#N/A" ; } public int getSize ( ) { return SIZE ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { ErrPtg ptg = new ErrPtg ( ) ; ptg . field_1_error_code = field_1_error_code ; return ptg ; } } 	0	['7', '2', '0', '3', '9', '9', '1', '3', '7', '0.944444444', '69', '0.666666667', '0', '0.583333333', '0.314285714', '1', '2', '8.428571429', '9', '1.8571', '0']
package org . apache . poi . poifs . filesystem ; public class POIFSWriterEvent { private DocumentOutputStream stream ; private POIFSDocumentPath path ; private String documentName ; private int limit ; POIFSWriterEvent ( final DocumentOutputStream stream , final POIFSDocumentPath path , final String documentName , final int limit ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; this . limit = limit ; } public DocumentOutputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } public int getLimit ( ) { return limit ; } } 	0	['5', '1', '0', '5', '6', '2', '3', '2', '4', '0.75', '36', '1', '2', '0', '0.36', '0', '0', '5.4', '1', '0.8', '0']
package org . apache . poi . util ; import java . util . * ; public class POILogFactory { private static Map _loggers = new HashMap ( ) ; ; private POILogFactory ( ) { } public static POILogger getLogger ( final Class theclass ) { return getLogger ( theclass . getName ( ) ) ; } public static POILogger getLogger ( final String cat ) { POILogger logger = null ; if ( _loggers . containsKey ( cat ) ) { logger = ( POILogger ) _loggers . get ( cat ) ; } else { try { String loggerClassName = System . getProperty ( "org.apache.poi.util.POILogger" ) ; Class loggerClass = Class . forName ( loggerClassName ) ; logger = ( POILogger ) loggerClass . newInstance ( ) ; } catch ( Exception e ) { logger = new NullLogger ( ) ; } logger . initialize ( cat ) ; _loggers . put ( cat , logger ) ; } return logger ; } } 	0	['4', '1', '0', '8', '15', '4', '6', '2', '2', '0.333333333', '55', '1', '0', '0', '0.333333333', '0', '0', '12.5', '2', '0.75', '0']
package org . apache . poi . hpsf ; public class NoSingleSectionException extends HPSFRuntimeException { public NoSingleSectionException ( ) { super ( ) ; } public NoSingleSectionException ( final String msg ) { super ( msg ) ; } public NoSingleSectionException ( final Throwable reason ) { super ( reason ) ; } public NoSingleSectionException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0	['4', '5', '0', '3', '8', '6', '2', '1', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . poi . hssf . usermodel ; public class HSSFSimpleShape extends HSSFShape { public final static short OBJECT_TYPE_LINE = 1 ; public final static short OBJECT_TYPE_RECTANGLE = 2 ; public final static short OBJECT_TYPE_OVAL = 3 ; public final static short OBJECT_TYPE_PICTURE = 8 ; public final static short OBJECT_TYPE_COMMENT = 25 ; int shapeType = OBJECT_TYPE_LINE ; HSSFSimpleShape ( HSSFShape parent , HSSFAnchor anchor ) { super ( parent , anchor ) ; } public int getShapeType ( ) { return shapeType ; } public void setShapeType ( int shapeType ) { this . shapeType = shapeType ; } } 	0	['3', '2', '2', '12', '4', '0', '10', '2', '2', '1.25', '24', '0', '0', '0.888888889', '0.5', '0', '0', '5', '1', '0.6667', '0']
package org . apache . poi . hpsf ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . hpsf . wellknown . SectionIDMap ; import org . apache . poi . util . LittleEndian ; public class PropertySet { static final byte [ ] BYTE_ORDER_ASSERTION = new byte [ ] { ( byte ) 0xFE , ( byte ) 0xFF } ; protected int byteOrder ; public int getByteOrder ( ) { return byteOrder ; } static final byte [ ] FORMAT_ASSERTION = new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 } ; protected int format ; public int getFormat ( ) { return format ; } protected int osVersion ; public static final int OS_WIN16 = 0x0000 ; public static final int OS_MACINTOSH = 0x0001 ; public static final int OS_WIN32 = 0x0002 ; public int getOSVersion ( ) { return osVersion ; } protected ClassID classID ; public ClassID getClassID ( ) { return classID ; } public int getSectionCount ( ) { return sections . size ( ) ; } protected List sections ; public List getSections ( ) { return sections ; } protected PropertySet ( ) { } public PropertySet ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , IOException , UnsupportedEncodingException { if ( isPropertySetStream ( stream ) ) { final int avail = stream . available ( ) ; final byte [ ] buffer = new byte [ avail ] ; stream . read ( buffer , 0 , buffer . length ) ; init ( buffer , 0 , buffer . length ) ; } else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream , final int offset , final int length ) throws NoPropertySetStreamException , UnsupportedEncodingException { if ( isPropertySetStream ( stream , offset , length ) ) init ( stream , offset , length ) ; else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream ) throws NoPropertySetStreamException , UnsupportedEncodingException { this ( stream , 0 , stream . length ) ; } public static boolean isPropertySetStream ( final InputStream stream ) throws MarkUnsupportedException , IOException { final int BUFFER_SIZE = 50 ; if ( ! stream . markSupported ( ) ) throw new MarkUnsupportedException ( stream . getClass ( ) . getName ( ) ) ; stream . mark ( BUFFER_SIZE ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final int bytes = stream . read ( buffer , 0 , Math . min ( buffer . length , stream . available ( ) ) ) ; final boolean isPropertySetStream = isPropertySetStream ( buffer , 0 , bytes ) ; stream . reset ( ) ; return isPropertySetStream ; } public static boolean isPropertySetStream ( final byte [ ] src , final int offset , final int length ) { int o = offset ; final int byteOrder = LittleEndian . getUShort ( src , o ) ; o += LittleEndian . SHORT_SIZE ; byte [ ] temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) byteOrder ) ; if ( ! Util . equal ( temp , BYTE_ORDER_ASSERTION ) ) return false ; final int format = LittleEndian . getUShort ( src , o ) ; o += LittleEndian . SHORT_SIZE ; temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) format ) ; if ( ! Util . equal ( temp , FORMAT_ASSERTION ) ) return false ; o += LittleEndian . INT_SIZE ; o += ClassID . LENGTH ; final long sectionCount = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( sectionCount < 1 ) return false ; return true ; } private void init ( final byte [ ] src , final int offset , final int length ) throws UnsupportedEncodingException { int o = offset ; byteOrder = LittleEndian . getUShort ( src , o ) ; o += LittleEndian . SHORT_SIZE ; format = LittleEndian . getUShort ( src , o ) ; o += LittleEndian . SHORT_SIZE ; osVersion = ( int ) LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; classID = new ClassID ( src , o ) ; o += ClassID . LENGTH ; final int sectionCount = LittleEndian . getInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( sectionCount <= 0 ) throw new HPSFRuntimeException ( "Section count " + sectionCount + " must be greater than 0." ) ; sections = new ArrayList ( sectionCount ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) { final Section s = new Section ( src , o ) ; o += ClassID . LENGTH + LittleEndian . INT_SIZE ; sections . add ( s ) ; } } public boolean isSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . SUMMARY_INFORMATION_ID ) ; } public boolean isDocumentSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID [ 0 ] ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return getFirstSection ( ) . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return getFirstSection ( ) . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return getFirstSection ( ) . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getFirstSection ( ) . getPropertyIntValue ( id ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return getFirstSection ( ) . wasNull ( ) ; } public Section getFirstSection ( ) { if ( getSectionCount ( ) < 1 ) throw new MissingSectionException ( "Property set does not contain any sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } public Section getSingleSection ( ) { final int sectionCount = getSectionCount ( ) ; if ( sectionCount != 1 ) throw new NoSingleSectionException ( "Property set contains " + sectionCount + " sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } public boolean equals ( final Object o ) { if ( o == null || ! ( o instanceof PropertySet ) ) return false ; final PropertySet ps = ( PropertySet ) o ; int byteOrder1 = ps . getByteOrder ( ) ; int byteOrder2 = getByteOrder ( ) ; ClassID classID1 = ps . getClassID ( ) ; ClassID classID2 = getClassID ( ) ; int format1 = ps . getFormat ( ) ; int format2 = getFormat ( ) ; int osVersion1 = ps . getOSVersion ( ) ; int osVersion2 = getOSVersion ( ) ; int sectionCount1 = ps . getSectionCount ( ) ; int sectionCount2 = getSectionCount ( ) ; if ( byteOrder1 != byteOrder2 || ! classID1 . equals ( classID2 ) || format1 != format2 || osVersion1 != osVersion2 || sectionCount1 != sectionCount2 ) return false ; return Util . equals ( getSections ( ) , ps . getSections ( ) ) ; } public int hashCode ( ) { throw new UnsupportedOperationException ( "FIXME: Not yet implemented." ) ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int sectionCount = getSectionCount ( ) ; b . append ( getClass ( ) . getName ( ) ) ; b . append ( '[' ) ; b . append ( "byteOrder: " ) ; b . append ( getByteOrder ( ) ) ; b . append ( ", classID: " ) ; b . append ( getClassID ( ) ) ; b . append ( ", format: " ) ; b . append ( getFormat ( ) ) ; b . append ( ", OSVersion: " ) ; b . append ( getOSVersion ( ) ) ; b . append ( ", sectionCount: " ) ; b . append ( sectionCount ) ; b . append ( ", sections: [\n" ) ; final List sections = getSections ( ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) b . append ( ( ( Section ) sections . get ( i ) ) . toString ( ) ) ; b . append ( ']' ) ; b . append ( ']' ) ; return b . toString ( ) ; } } 	0	['26', '1', '1', '16', '72', '273', '5', '11', '20', '0.82', '553', '0.5', '1', '0', '0.288', '1', '1', '19.88461538', '8', '1.3077', '0']
package org . apache . poi . util ; import java . util . List ; import java . util . ArrayList ; public class List2d { List rows = new ArrayList ( ) ; public Object get ( int col , int row ) { if ( row >= rows . size ( ) ) { return null ; } else { List cols = ( List ) rows . get ( row ) ; if ( col >= cols . size ( ) ) return null ; else return cols . get ( col ) ; } } public void set ( int col , int row , Object value ) { resizeRows ( row ) ; resizeCols ( row , col ) ; List cols = ( List ) rows . get ( row ) ; cols . set ( col , value ) ; } private void resizeRows ( int row ) { while ( rows . size ( ) <= row ) rows . add ( new ArrayList ( ) ) ; } private void resizeCols ( int row , int col ) { List cols = ( List ) rows . get ( row ) ; while ( cols . size ( ) <= col ) cols . add ( null ) ; } } 	0	['5', '1', '0', '0', '11', '0', '0', '0', '3', '0', '86', '0', '0', '0', '0.666666667', '0', '0', '16', '3', '1.6', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . ClassID ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DirectoryProperty ; import org . apache . poi . poifs . property . DocumentProperty ; import org . apache . poi . poifs . property . Property ; public class DirectoryNode extends EntryNode implements DirectoryEntry , POIFSViewable { private Map _entries ; private POIFSFileSystem _filesystem ; private POIFSDocumentPath _path ; DirectoryNode ( final DirectoryProperty property , final POIFSFileSystem filesystem , final DirectoryNode parent ) { super ( property , parent ) ; if ( parent == null ) { _path = new POIFSDocumentPath ( ) ; } else { _path = new POIFSDocumentPath ( parent . _path , new String [ ] { property . getName ( ) } ) ; } _filesystem = filesystem ; _entries = new HashMap ( ) ; Iterator iter = property . getChildren ( ) ; while ( iter . hasNext ( ) ) { Property child = ( Property ) iter . next ( ) ; Entry childNode = null ; if ( child . isDirectory ( ) ) { childNode = new DirectoryNode ( ( DirectoryProperty ) child , _filesystem , this ) ; } else { childNode = new DocumentNode ( ( DocumentProperty ) child , this ) ; } _entries . put ( childNode . getName ( ) , childNode ) ; } } public POIFSDocumentPath getPath ( ) { return _path ; } DocumentEntry createDocument ( final POIFSDocument document ) throws IOException { DocumentProperty property = document . getDocumentProperty ( ) ; DocumentNode rval = new DocumentNode ( property , this ) ; ( ( DirectoryProperty ) getProperty ( ) ) . addChild ( property ) ; _filesystem . addDocument ( document ) ; _entries . put ( property . getName ( ) , rval ) ; return rval ; } boolean changeName ( final String oldName , final String newName ) { boolean rval = false ; EntryNode child = ( EntryNode ) _entries . get ( oldName ) ; if ( child != null ) { rval = ( ( DirectoryProperty ) getProperty ( ) ) . changeName ( child . getProperty ( ) , newName ) ; if ( rval ) { _entries . remove ( oldName ) ; _entries . put ( child . getProperty ( ) . getName ( ) , child ) ; } } return rval ; } boolean deleteEntry ( final EntryNode entry ) { boolean rval = ( ( DirectoryProperty ) getProperty ( ) ) . deleteChild ( entry . getProperty ( ) ) ; if ( rval ) { _entries . remove ( entry . getName ( ) ) ; _filesystem . remove ( entry ) ; } return rval ; } public Iterator getEntries ( ) { return _entries . values ( ) . iterator ( ) ; } public boolean isEmpty ( ) { return _entries . isEmpty ( ) ; } public int getEntryCount ( ) { return _entries . size ( ) ; } public Entry getEntry ( final String name ) throws FileNotFoundException { Entry rval = null ; if ( name != null ) { rval = ( Entry ) _entries . get ( name ) ; } if ( rval == null ) { throw new FileNotFoundException ( "no such entry: \"" + name + "\"" ) ; } return rval ; } public DocumentEntry createDocument ( final String name , final InputStream stream ) throws IOException { return createDocument ( new POIFSDocument ( name , stream ) ) ; } public DocumentEntry createDocument ( final String name , final int size , final POIFSWriterListener writer ) throws IOException { return createDocument ( new POIFSDocument ( name , size , _path , writer ) ) ; } public DirectoryEntry createDirectory ( final String name ) throws IOException { DirectoryProperty property = new DirectoryProperty ( name ) ; DirectoryNode rval = new DirectoryNode ( property , _filesystem , this ) ; ( ( DirectoryProperty ) getProperty ( ) ) . addChild ( property ) ; _filesystem . addDirectory ( property ) ; _entries . put ( name , rval ) ; return rval ; } public ClassID getStorageClsid ( ) { return getProperty ( ) . getStorageClsid ( ) ; } public void setStorageClsid ( ClassID clsidStorage ) { getProperty ( ) . setStorageClsid ( clsidStorage ) ; } public boolean isDirectoryEntry ( ) { return true ; } protected boolean isDeleteOK ( ) { return isEmpty ( ) ; } public Object [ ] getViewableArray ( ) { return new Object [ 0 ] ; } public Iterator getViewableIterator ( ) { List components = new ArrayList ( ) ; components . add ( getProperty ( ) ) ; SortedMap sortedEntries = new TreeMap ( _entries ) ; Iterator iter = sortedEntries . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { components . add ( iter . next ( ) ) ; } return components . iterator ( ) ; } public boolean preferArray ( ) { return false ; } public String getShortDescription ( ) { return getName ( ) ; } } 	0	['20', '2', '0', '14', '65', '94', '3', '14', '15', '0.649122807', '327', '1', '2', '0.321428571', '0.154545455', '1', '1', '15.2', '3', '1.15', '0']
package org . apache . poi . dev ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . Reader ; import java . util . Properties ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class RecordGenerator { public static void main ( String [ ] args ) throws Exception { Class . forName ( "org.apache.poi.generator.FieldIterator" ) ; if ( args . length != 4 ) { System . out . println ( "Usage:" ) ; System . out . println ( "  java org.apache.poi.hssf.util.RecordGenerator RECORD_DEFINTIONS RECORD_STYLES DEST_SRC_PATH TEST_SRC_PATH" ) ; } else { generateRecords ( args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; } } private static void generateRecords ( String defintionsDir , String recordStyleDir , String destSrcPathDir , String testSrcPathDir ) throws Exception { File definitionsFile = new File ( defintionsDir ) ; for ( int i = 0 ; i < definitionsFile . listFiles ( ) . length ; i ++ ) { File file = definitionsFile . listFiles ( ) [ i ] ; if ( file . isFile ( ) && ( file . getName ( ) . endsWith ( "_record.xml" ) || file . getName ( ) . endsWith ( "_type.xml" ) ) ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document document = builder . parse ( file ) ; Element record = document . getDocumentElement ( ) ; String extendstg = record . getElementsByTagName ( "extends" ) . item ( 0 ) . getFirstChild ( ) . getNodeValue ( ) ; String suffix = record . getElementsByTagName ( "suffix" ) . item ( 0 ) . getFirstChild ( ) . getNodeValue ( ) ; String recordName = record . getAttributes ( ) . getNamedItem ( "name" ) . getNodeValue ( ) ; String packageName = record . getAttributes ( ) . getNamedItem ( "package" ) . getNodeValue ( ) ; packageName = packageName . replace ( '.' , '/' ) ; String destinationPath = destSrcPathDir + "/" + packageName ; File destinationPathFile = new File ( destinationPath ) ; destinationPathFile . mkdirs ( ) ; String destinationFilepath = destinationPath + "/" + recordName + suffix + ".java" ; transform ( file , new File ( destinationFilepath ) , new File ( recordStyleDir + "/" + extendstg . toLowerCase ( ) + ".xsl" ) ) ; System . out . println ( "Generated " + suffix + ": " + destinationFilepath ) ; destinationPath = testSrcPathDir + "/" + packageName ; destinationPathFile = new File ( destinationPath ) ; destinationPathFile . mkdirs ( ) ; destinationFilepath = destinationPath + "/Test" + recordName + suffix + ".java" ; if ( new File ( destinationFilepath ) . exists ( ) == false ) { String temp = ( recordStyleDir + "/" + extendstg . toLowerCase ( ) + "_test.xsl" ) ; transform ( file , new File ( destinationFilepath ) , new File ( temp ) ) ; System . out . println ( "Generated test: " + destinationFilepath ) ; } else { System . out . println ( "Skipped test generation: " + destinationFilepath ) ; } } } } private static void transform ( final File in , final File out , final File xslt ) throws FileNotFoundException , TransformerException { final Reader r = new FileReader ( xslt ) ; final StreamSource ss = new StreamSource ( r ) ; final TransformerFactory tf = TransformerFactory . newInstance ( ) ; final Transformer t ; try { t = tf . newTransformer ( ss ) ; } catch ( TransformerException ex ) { System . err . println ( "Error compiling XSL style sheet " + xslt ) ; throw ex ; } final Properties p = new Properties ( ) ; p . setProperty ( OutputKeys . METHOD , "text" ) ; t . setOutputProperties ( p ) ; final Result result = new StreamResult ( out ) ; t . transform ( new StreamSource ( in ) , result ) ; } } 	0	['4', '1', '0', '0', '40', '6', '0', '0', '2', '2', '323', '0', '0', '0', '0.25', '0', '0', '79.75', '1', '0.75', '0']
package org . apache . poi . hpsf ; import org . apache . poi . util . HexDump ; public class ClassID { protected byte [ ] bytes ; public ClassID ( final byte [ ] src , final int offset ) { read ( src , offset ) ; } public ClassID ( ) { bytes = new byte [ LENGTH ] ; for ( int i = 0 ; i < LENGTH ; i ++ ) bytes [ i ] = 0x00 ; } public static final int LENGTH = 16 ; public int length ( ) { return LENGTH ; } public byte [ ] getBytes ( ) { return bytes ; } public void setBytes ( final byte [ ] bytes ) { for ( int i = 0 ; i < this . bytes . length ; i ++ ) this . bytes [ i ] = bytes [ i ] ; } public byte [ ] read ( final byte [ ] src , final int offset ) { bytes = new byte [ 16 ] ; bytes [ 0 ] = src [ 3 + offset ] ; bytes [ 1 ] = src [ 2 + offset ] ; bytes [ 2 ] = src [ 1 + offset ] ; bytes [ 3 ] = src [ 0 + offset ] ; bytes [ 4 ] = src [ 5 + offset ] ; bytes [ 5 ] = src [ 4 + offset ] ; bytes [ 6 ] = src [ 7 + offset ] ; bytes [ 7 ] = src [ 6 + offset ] ; for ( int i = 8 ; i < 16 ; i ++ ) bytes [ i ] = src [ i + offset ] ; return bytes ; } public void write ( final byte [ ] dst , final int offset ) throws ArrayStoreException { if ( dst . length < 16 ) throw new ArrayStoreException ( "Destination byte[] must have room for at least 16 bytes, " + "but has a length of only " + dst . length + "." ) ; dst [ 0 + offset ] = bytes [ 3 ] ; dst [ 1 + offset ] = bytes [ 2 ] ; dst [ 2 + offset ] = bytes [ 1 ] ; dst [ 3 + offset ] = bytes [ 0 ] ; dst [ 4 + offset ] = bytes [ 5 ] ; dst [ 5 + offset ] = bytes [ 4 ] ; dst [ 6 + offset ] = bytes [ 7 ] ; dst [ 7 + offset ] = bytes [ 6 ] ; for ( int i = 8 ; i < 16 ; i ++ ) dst [ i + offset ] = bytes [ i ] ; } public boolean equals ( final Object o ) { if ( o == null || ! ( o instanceof ClassID ) ) return false ; final ClassID cid = ( ClassID ) o ; if ( bytes . length != cid . bytes . length ) return false ; for ( int i = 0 ; i < bytes . length ; i ++ ) if ( bytes [ i ] != cid . bytes [ i ] ) return false ; return true ; } public int hashCode ( ) { return new String ( bytes ) . hashCode ( ) ; } public String toString ( ) { StringBuffer sbClassId = new StringBuffer ( 38 ) ; sbClassId . append ( '{' ) ; for ( int i = 0 ; i < 16 ; i ++ ) { sbClassId . append ( HexDump . toHex ( bytes [ i ] ) ) ; if ( i == 3 || i == 5 || i == 7 || i == 9 ) sbClassId . append ( '-' ) ; } sbClassId . append ( '}' ) ; return sbClassId . toString ( ) ; } } 	0	['10', '1', '0', '11', '23', '0', '10', '1', '10', '0.611111111', '359', '0.5', '0', '0', '0.45', '1', '1', '34.7', '6', '2', '0']
package org . apache . poi . poifs . filesystem ; public interface POIFSWriterListener { public void processPOIFSWriterEvent ( POIFSWriterEvent event ) ; } 	0	['1', '1', '0', '7', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . filesystem ; public class DocumentDescriptor { private POIFSDocumentPath path ; private String name ; private int hashcode = 0 ; public DocumentDescriptor ( final POIFSDocumentPath path , final String name ) { if ( path == null ) { throw new NullPointerException ( "path must not be null" ) ; } if ( name == null ) { throw new NullPointerException ( "name must not be null" ) ; } if ( name . length ( ) == 0 ) { throw new IllegalArgumentException ( "name cannot be empty" ) ; } this . path = path ; this . name = name ; } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { DocumentDescriptor descriptor = ( DocumentDescriptor ) o ; rval = this . path . equals ( descriptor . path ) && this . name . equals ( descriptor . name ) ; } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { hashcode = path . hashCode ( ) ^ name . hashCode ( ) ; } return hashcode ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( 40 * ( path . length ( ) + 1 ) ) ; for ( int j = 0 ; j < path . length ( ) ; j ++ ) { buffer . append ( path . getComponent ( j ) ) . append ( "/" ) ; } buffer . append ( name ) ; return buffer . toString ( ) ; } } 	0	['4', '1', '0', '2', '18', '0', '1', '1', '4', '0.222222222', '129', '1', '1', '0', '0.4375', '1', '1', '30.5', '6', '2.5', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class PercentPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x14 ; private final static String PERCENT = "%" ; public PercentPtg ( ) { } public PercentPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_UNARY ; } public int getNumberOfOperands ( ) { return 1 ; } public String toFormulaString ( Workbook book ) { return "%" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( PERCENT ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new PercentPtg ( ) ; } } 	0	['10', '2', '0', '4', '14', '45', '1', '3', '10', '1.111111111', '57', '0.333333333', '0', '0.272727273', '0.25', '0', '0', '4.4', '1', '0.8', '0']
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	0	['5', '2', '0', '3', '20', '0', '0', '3', '4', '0.5', '138', '1', '0', '0.888888889', '0.5', '1', '1', '26.2', '12', '4.8', '0']
package org . apache . poi . hssf . eventmodel ; import org . apache . poi . hssf . model . Model ; public interface ModelFactoryListener { public boolean process ( Model model ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; public interface ListManagedBlock { public byte [ ] getData ( ) throws IOException ; } 	0	['1', '1', '0', '13', '1', '0', '13', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . util ; import java . util . * ; public class DoubleList { private double [ ] _array ; private int _limit ; private static final int _default_size = 128 ; public DoubleList ( ) { this ( _default_size ) ; } public DoubleList ( final DoubleList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; } public DoubleList ( final int initialCapacity ) { _array = new double [ initialCapacity ] ; _limit = 0 ; } public void add ( final int index , final double value ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } else if ( index == _limit ) { add ( value ) ; } else { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } System . arraycopy ( _array , index , _array , index + 1 , _limit - index ) ; _array [ index ] = value ; _limit ++ ; } } public boolean add ( final double value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; } public boolean addAll ( final DoubleList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; } public boolean addAll ( final int index , final DoubleList c ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( _array , index , _array , index + c . _limit , _limit - index ) ; System . arraycopy ( c . _array , 0 , _array , index , c . _limit ) ; _limit += c . _limit ; } return true ; } public void clear ( ) { _limit = 0 ; } public boolean contains ( final double o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; } public boolean containsAll ( final DoubleList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; } public boolean equals ( final Object o ) { boolean rval = this == o ; if ( ! rval && ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { DoubleList other = ( DoubleList ) o ; if ( other . _limit == _limit ) { rval = true ; for ( int j = 0 ; rval && ( j < _limit ) ; j ++ ) { rval = _array [ j ] == other . _array [ j ] ; } } } return rval ; } public double get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } return _array [ index ] ; } public int hashCode ( ) { int hash = 0 ; for ( int j = 0 ; j < _limit ; j ++ ) { hash = ( 31 * hash ) + ( ( int ) _array [ j ] ) ; } return hash ; } public int indexOf ( final double o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; } public boolean isEmpty ( ) { return _limit == 0 ; } public int lastIndexOf ( final double o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; } public double remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } double rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; } public boolean removeValue ( final double o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; _limit -- ; rval = true ; } } return rval ; } public boolean removeAll ( final DoubleList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; } public boolean retainAll ( final DoubleList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; } public double set ( final int index , final double element ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } double rval = _array [ index ] ; _array [ index ] = element ; return rval ; } public int size ( ) { return _limit ; } public double [ ] toArray ( ) { double [ ] rval = new double [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; } public double [ ] toArray ( final double [ ] a ) { double [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; } private void growArray ( final int new_size ) { int size = ( new_size == _array . length ) ? new_size + 1 : new_size ; double [ ] new_array = new double [ size ] ; System . arraycopy ( _array , 0 , new_array , 0 , _limit ) ; _array = new_array ; } } 	0	['25', '1', '0', '1', '29', '0', '1', '0', '24', '0.388888889', '635', '1', '0', '0', '0.313333333', '1', '1', '24.28', '9', '2.6', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; import org . apache . poi . util . BitFieldFactory ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class Ref3DPtg extends Ptg { public final static byte sid = 0x3a ; private final static int SIZE = 7 ; private short field_1_index_extern_sheet ; private short field_2_row ; private short field_3_column ; private BitField rowRelative = BitFieldFactory . getInstance ( 0x8000 ) ; private BitField colRelative = BitFieldFactory . getInstance ( 0x4000 ) ; public Ref3DPtg ( ) { } public Ref3DPtg ( RecordInputStream in ) { field_1_index_extern_sheet = in . readShort ( ) ; field_2_row = in . readShort ( ) ; field_3_column = in . readShort ( ) ; } public Ref3DPtg ( String cellref , short externIdx ) { CellReference c = new CellReference ( cellref ) ; setRow ( ( short ) c . getRow ( ) ) ; setColumn ( ( short ) c . getCol ( ) ) ; setColRelative ( ! c . isColAbsolute ( ) ) ; setRowRelative ( ! c . isRowAbsolute ( ) ) ; setExternSheetIndex ( externIdx ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Ref3dPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "Row = " + getRow ( ) ) . append ( "\n" ) ; buffer . append ( "Col  = " + getColumn ( ) ) . append ( "\n" ) ; buffer . append ( "ColRowRel= " + isRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "ColRel   = " + isColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getRow ( ) { return field_2_row ; } public void setRow ( short row ) { field_2_row = row ; } public short getColumn ( ) { return ( short ) ( field_3_column & 0xFF ) ; } public short getColumnRaw ( ) { return field_3_column ; } public boolean isRowRelative ( ) { return rowRelative . isSet ( field_3_column ) ; } public void setRowRelative ( boolean rel ) { field_3_column = rowRelative . setShortBoolean ( field_3_column , rel ) ; } public boolean isColRelative ( ) { return colRelative . isSet ( field_3_column ) ; } public void setColRelative ( boolean rel ) { field_3_column = colRelative . setShortBoolean ( field_3_column , rel ) ; } public void setColumn ( short column ) { field_3_column &= 0xFF00 ; field_3_column |= column & 0xFF ; } public void setColumnRaw ( short column ) { field_3_column = column ; } public void setArea ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String from = ra . getFromCell ( ) ; setColumn ( ( short ) ( ra . getXPosition ( from ) - 1 ) ) ; setRow ( ( short ) ( ra . getYPosition ( from ) - 1 ) ) ; } public String toFormulaString ( Workbook book ) { StringBuffer retval = new StringBuffer ( ) ; SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; if ( refs != null ) { String sheetName = refs . getSheetName ( ( int ) this . field_1_index_extern_sheet ) ; boolean appendQuotes = sheetName . indexOf ( " " ) >= 0 ; if ( appendQuotes ) retval . append ( "'" ) ; retval . append ( sheetName ) ; if ( appendQuotes ) retval . append ( "'" ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getRow ( ) , getColumn ( ) , ! isRowRelative ( ) , ! isColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Ref3DPtg ptg = new Ref3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_row = field_2_row ; ptg . field_3_column = field_3_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0	['22', '2', '1', '12', '52', '89', '4', '9', '22', '0.721088435', '417', '0.857142857', '2', '0.269230769', '0.198863636', '1', '2', '17.63636364', '8', '1.1818', '0']
package org . apache . poi . hpsf ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . List ; import org . apache . poi . poifs . filesystem . DirectoryEntry ; public abstract class SpecialPropertySet extends MutablePropertySet { private MutablePropertySet delegate ; public SpecialPropertySet ( final PropertySet ps ) { delegate = new MutablePropertySet ( ps ) ; } public SpecialPropertySet ( final MutablePropertySet ps ) { delegate = ps ; } public int getByteOrder ( ) { return delegate . getByteOrder ( ) ; } public int getFormat ( ) { return delegate . getFormat ( ) ; } public int getOSVersion ( ) { return delegate . getOSVersion ( ) ; } public ClassID getClassID ( ) { return delegate . getClassID ( ) ; } public int getSectionCount ( ) { return delegate . getSectionCount ( ) ; } public List getSections ( ) { return delegate . getSections ( ) ; } public boolean isSummaryInformation ( ) { return delegate . isSummaryInformation ( ) ; } public boolean isDocumentSummaryInformation ( ) { return delegate . isDocumentSummaryInformation ( ) ; } public Section getFirstSection ( ) { return delegate . getFirstSection ( ) ; } public void addSection ( final Section section ) { delegate . addSection ( section ) ; } public void clearSections ( ) { delegate . clearSections ( ) ; } public void setByteOrder ( final int byteOrder ) { delegate . setByteOrder ( byteOrder ) ; } public void setClassID ( final ClassID classID ) { delegate . setClassID ( classID ) ; } public void setFormat ( final int format ) { delegate . setFormat ( format ) ; } public void setOSVersion ( final int osVersion ) { delegate . setOSVersion ( osVersion ) ; } public InputStream toInputStream ( ) throws IOException , WritingNotSupportedException { return delegate . toInputStream ( ) ; } public void write ( final DirectoryEntry dir , final String name ) throws WritingNotSupportedException , IOException { delegate . write ( dir , name ) ; } public void write ( final OutputStream out ) throws WritingNotSupportedException , IOException { delegate . write ( out ) ; } public boolean equals ( final Object o ) { return delegate . equals ( o ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return delegate . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return delegate . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return delegate . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return delegate . getPropertyIntValue ( id ) ; } public int hashCode ( ) { return delegate . hashCode ( ) ; } public String toString ( ) { return delegate . toString ( ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return delegate . wasNull ( ) ; } } 	0	['28', '3', '2', '10', '56', '0', '2', '8', '25', '0', '160', '1', '1', '0.490196078', '0.15', '2', '7', '4.678571429', '1', '0.9286', '0']
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; public interface HSSFListener { public void processRecord ( Record record ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . FormatRecord ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Vector ; public class HSSFDataFormat { private static List builtinFormats = createBuiltinFormats ( ) ; private Vector formats = new Vector ( ) ; private Workbook workbook ; private boolean movedBuiltins = false ; public HSSFDataFormat ( Workbook workbook ) { this . workbook = workbook ; Iterator i = workbook . getFormats ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { FormatRecord r = ( FormatRecord ) i . next ( ) ; if ( formats . size ( ) < r . getIndexCode ( ) + 1 ) { formats . setSize ( r . getIndexCode ( ) + 1 ) ; } formats . set ( r . getIndexCode ( ) , r . getFormatString ( ) ) ; } } private static synchronized List createBuiltinFormats ( ) { List builtinFormats = new Vector ( ) ; builtinFormats . add ( 0 , "General" ) ; builtinFormats . add ( 1 , "0" ) ; builtinFormats . add ( 2 , "0.00" ) ; builtinFormats . add ( 3 , "#,##0" ) ; builtinFormats . add ( 4 , "#,##0.00" ) ; builtinFormats . add ( 5 , "($#,##0_);($#,##0)" ) ; builtinFormats . add ( 6 , "($#,##0_);[Red]($#,##0)" ) ; builtinFormats . add ( 7 , "($#,##0.00);($#,##0.00)" ) ; builtinFormats . add ( 8 , "($#,##0.00_);[Red]($#,##0.00)" ) ; builtinFormats . add ( 9 , "0%" ) ; builtinFormats . add ( 0xa , "0.00%" ) ; builtinFormats . add ( 0xb , "0.00E+00" ) ; builtinFormats . add ( 0xc , "# ?/?" ) ; builtinFormats . add ( 0xd , "# ??/??" ) ; builtinFormats . add ( 0xe , "m/d/yy" ) ; builtinFormats . add ( 0xf , "d-mmm-yy" ) ; builtinFormats . add ( 0x10 , "d-mmm" ) ; builtinFormats . add ( 0x11 , "mmm-yy" ) ; builtinFormats . add ( 0x12 , "h:mm AM/PM" ) ; builtinFormats . add ( 0x13 , "h:mm:ss AM/PM" ) ; builtinFormats . add ( 0x14 , "h:mm" ) ; builtinFormats . add ( 0x15 , "h:mm:ss" ) ; builtinFormats . add ( 0x16 , "m/d/yy h:mm" ) ; builtinFormats . add ( 0x17 , "0x17" ) ; builtinFormats . add ( 0x18 , "0x18" ) ; builtinFormats . add ( 0x19 , "0x19" ) ; builtinFormats . add ( 0x1a , "0x1a" ) ; builtinFormats . add ( 0x1b , "0x1b" ) ; builtinFormats . add ( 0x1c , "0x1c" ) ; builtinFormats . add ( 0x1d , "0x1d" ) ; builtinFormats . add ( 0x1e , "0x1e" ) ; builtinFormats . add ( 0x1f , "0x1f" ) ; builtinFormats . add ( 0x20 , "0x20" ) ; builtinFormats . add ( 0x21 , "0x21" ) ; builtinFormats . add ( 0x22 , "0x22" ) ; builtinFormats . add ( 0x23 , "0x23" ) ; builtinFormats . add ( 0x24 , "0x24" ) ; builtinFormats . add ( 0x25 , "(#,##0_);(#,##0)" ) ; builtinFormats . add ( 0x26 , "(#,##0_);[Red](#,##0)" ) ; builtinFormats . add ( 0x27 , "(#,##0.00_);(#,##0.00)" ) ; builtinFormats . add ( 0x28 , "(#,##0.00_);[Red](#,##0.00)" ) ; builtinFormats . add ( 0x29 , "_(*#,##0_);_(*(#,##0);_(* \"-\"_);_(@_)" ) ; builtinFormats . add ( 0x2a , "_($*#,##0_);_($*(#,##0);_($* \"-\"_);_(@_)" ) ; builtinFormats . add ( 0x2b , "_(*#,##0.00_);_(*(#,##0.00);_(*\"-\"??_);_(@_)" ) ; builtinFormats . add ( 0x2c , "_($*#,##0.00_);_($*(#,##0.00);_($*\"-\"??_);_(@_)" ) ; builtinFormats . add ( 0x2d , "mm:ss" ) ; builtinFormats . add ( 0x2e , "[h]:mm:ss" ) ; builtinFormats . add ( 0x2f , "mm:ss.0" ) ; builtinFormats . add ( 0x30 , "##0.0E+0" ) ; builtinFormats . add ( 0x31 , "@" ) ; return builtinFormats ; } public static List getBuiltinFormats ( ) { return builtinFormats ; } public static short getBuiltinFormat ( String format ) { if ( format . toUpperCase ( ) . equals ( "TEXT" ) ) format = "@" ; short retval = - 1 ; for ( short k = 0 ; k <= 0x31 ; k ++ ) { String nformat = ( String ) builtinFormats . get ( k ) ; if ( ( nformat != null ) && nformat . equals ( format ) ) { retval = k ; break ; } } return retval ; } public short getFormat ( String format ) { ListIterator i ; int ind ; if ( format . toUpperCase ( ) . equals ( "TEXT" ) ) format = "@" ; if ( ! movedBuiltins ) { i = builtinFormats . listIterator ( ) ; while ( i . hasNext ( ) ) { ind = i . nextIndex ( ) ; if ( formats . size ( ) < ind + 1 ) { formats . setSize ( ind + 1 ) ; } formats . set ( ind , i . next ( ) ) ; } movedBuiltins = true ; } i = formats . listIterator ( ) ; while ( i . hasNext ( ) ) { ind = i . nextIndex ( ) ; if ( format . equals ( i . next ( ) ) ) return ( short ) ind ; } ind = workbook . getFormat ( format , true ) ; if ( formats . size ( ) <= ind ) formats . setSize ( ind + 1 ) ; formats . set ( ind , format ) ; return ( short ) ind ; } public String getFormat ( short index ) { if ( movedBuiltins ) return ( String ) formats . get ( index ) ; else return ( String ) ( builtinFormats . size ( ) > index && builtinFormats . get ( index ) != null ? builtinFormats . get ( index ) : formats . get ( index ) ) ; } public static String getBuiltinFormat ( short index ) { return ( String ) builtinFormats . get ( index ) ; } public static int getNumberOfBuiltinBuiltinFormats ( ) { return builtinFormats . size ( ) ; } } 	0	['9', '1', '0', '5', '32', '0', '3', '2', '7', '0.65625', '431', '1', '1', '0', '0.25', '0', '0', '46.44444444', '8', '2.3333', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class UnknownPtg extends Ptg { private short size ; public UnknownPtg ( ) { } public UnknownPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { } public int getSize ( ) { return size ; } public String toFormulaString ( Workbook book ) { return "UNKNOWN" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new UnknownPtg ( ) ; } } 	0	['7', '2', '0', '3', '8', '21', '0', '3', '7', '1', '26', '1', '0', '0.583333333', '0.314285714', '1', '2', '2.571428571', '1', '0.7143', '0']
package org . apache . poi . hssf . record ; public interface Margin { public double getMargin ( ) ; public void setMargin ( double field_1_margin ) ; } 	0	['2', '1', '0', '5', '2', '1', '5', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class UnaryMinusPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x13 ; private final static String MINUS = "-" ; public UnaryMinusPtg ( ) { } public UnaryMinusPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return this . TYPE_UNARY ; } public int getNumberOfOperands ( ) { return 1 ; } public String toFormulaString ( Workbook book ) { return "+" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( MINUS ) ; buffer . append ( operands [ 0 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new UnaryPlusPtg ( ) ; } } 	0	['10', '2', '0', '6', '15', '45', '2', '4', '10', '1.111111111', '59', '0.333333333', '0', '0.272727273', '0.25', '0', '0', '4.6', '1', '0.8', '0']
package org . apache . poi . hssf . usermodel ; import java . util . List ; public interface HSSFShapeContainer { List getChildren ( ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . property ; import java . io . IOException ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . storage . ListManagedBlock ; class PropertyFactory { private PropertyFactory ( ) { } static List convertToProperties ( ListManagedBlock [ ] blocks ) throws IOException { List properties = new ArrayList ( ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { byte [ ] data = blocks [ j ] . getData ( ) ; int property_count = data . length / POIFSConstants . PROPERTY_SIZE ; int offset = 0 ; for ( int k = 0 ; k < property_count ; k ++ ) { switch ( data [ offset + PropertyConstants . PROPERTY_TYPE_OFFSET ] ) { case PropertyConstants . DIRECTORY_TYPE : properties . add ( new DirectoryProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . DOCUMENT_TYPE : properties . add ( new DocumentProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . ROOT_TYPE : properties . add ( new RootProperty ( properties . size ( ) , data , offset ) ) ; break ; default : properties . add ( null ) ; break ; } offset += POIFSConstants . PROPERTY_SIZE ; } } return properties ; } } 	0	['2', '1', '0', '5', '10', '1', '1', '4', '0', '2', '82', '0', '0', '0', '0.5', '0', '0', '40', '1', '0.5', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class NameXPtg extends Ptg { public final static short sid = 0x39 ; private final static int SIZE = 7 ; private short field_1_ixals ; private short field_2_ilbl ; private short field_3_reserved ; private NameXPtg ( ) { } public NameXPtg ( String name ) { } public NameXPtg ( RecordInputStream in ) { field_1_ixals = in . readShort ( ) ; field_2_ilbl = in . readShort ( ) ; field_3_reserved = in . readShort ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_ixals ) ; LittleEndian . putShort ( array , offset + 3 , field_2_ilbl ) ; LittleEndian . putShort ( array , offset + 5 , field_3_reserved ) ; } public int getSize ( ) { return SIZE ; } public String toFormulaString ( Workbook book ) { return "NO IDEA - NAME" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { NameXPtg ptg = new NameXPtg ( ) ; ptg . field_1_ixals = field_1_ixals ; ptg . field_3_reserved = field_3_reserved ; ptg . field_2_ilbl = field_2_ilbl ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	0	['8', '2', '0', '4', '12', '22', '1', '4', '7', '0.885714286', '94', '0.8', '0', '0.583333333', '0.270833333', '1', '2', '10.125', '1', '0.625', '0']
package org . apache . poi . hssf . usermodel ; public abstract class HSSFAnchor { int dx1 ; int dy1 ; int dx2 ; int dy2 ; public HSSFAnchor ( ) { } public HSSFAnchor ( int dx1 , int dy1 , int dx2 , int dy2 ) { this . dx1 = dx1 ; this . dy1 = dy1 ; this . dx2 = dx2 ; this . dy2 = dy2 ; } public int getDx1 ( ) { return dx1 ; } public void setDx1 ( int dx1 ) { this . dx1 = dx1 ; } public int getDy1 ( ) { return dy1 ; } public void setDy1 ( int dy1 ) { this . dy1 = dy1 ; } public int getDy2 ( ) { return dy2 ; } public void setDy2 ( int dy2 ) { this . dy2 = dy2 ; } public int getDx2 ( ) { return dx2 ; } public void setDx2 ( int dx2 ) { this . dx2 = dx2 ; } public abstract boolean isHorizontallyFlipped ( ) ; public abstract boolean isVerticallyFlipped ( ) ; } 	0	['12', '1', '2', '18', '13', '42', '18', '0', '12', '0.818181818', '62', '0', '0', '0', '0.708333333', '0', '0', '3.833333333', '1', '0.8333', '0']
package org . apache . poi . hssf . model ; import org . apache . poi . ddf . EscherDggRecord ; import org . apache . poi . ddf . EscherDgRecord ; import java . util . Map ; import java . util . HashMap ; public class DrawingManager { EscherDggRecord dgg ; Map dgMap = new HashMap ( ) ; public DrawingManager ( EscherDggRecord dgg ) { this . dgg = dgg ; } public EscherDgRecord createDgRecord ( ) { EscherDgRecord dg = new EscherDgRecord ( ) ; dg . setRecordId ( EscherDgRecord . RECORD_ID ) ; short dgId = findNewDrawingGroupId ( ) ; dg . setOptions ( ( short ) ( dgId << 4 ) ) ; dg . setNumShapes ( 0 ) ; dg . setLastMSOSPID ( - 1 ) ; dgg . addCluster ( dgId , 0 ) ; dgg . setDrawingsSaved ( dgg . getDrawingsSaved ( ) + 1 ) ; dgMap . put ( new Short ( dgId ) , dg ) ; return dg ; } public int allocateShapeId ( short drawingGroupId ) { EscherDgRecord dg = ( EscherDgRecord ) dgMap . get ( new Short ( drawingGroupId ) ) ; int lastShapeId = dg . getLastMSOSPID ( ) ; int newShapeId = 0 ; if ( lastShapeId % 1024 == 1023 ) { newShapeId = findFreeSPIDBlock ( ) ; dgg . addCluster ( drawingGroupId , 1 ) ; } else { for ( int i = 0 ; i < dgg . getFileIdClusters ( ) . length ; i ++ ) { EscherDggRecord . FileIdCluster c = dgg . getFileIdClusters ( ) [ i ] ; if ( c . getDrawingGroupId ( ) == drawingGroupId ) { if ( c . getNumShapeIdsUsed ( ) != 1024 ) { c . incrementShapeId ( ) ; } } if ( dg . getLastMSOSPID ( ) == - 1 ) { newShapeId = findFreeSPIDBlock ( ) ; } else { newShapeId = dg . getLastMSOSPID ( ) + 1 ; } } } dgg . setNumShapesSaved ( dgg . getNumShapesSaved ( ) + 1 ) ; if ( newShapeId >= dgg . getShapeIdMax ( ) ) { dgg . setShapeIdMax ( newShapeId + 1 ) ; } dg . setLastMSOSPID ( newShapeId ) ; dg . incrementShapeCount ( ) ; return newShapeId ; } short findNewDrawingGroupId ( ) { short dgId = 1 ; while ( drawingGroupExists ( dgId ) ) dgId ++ ; return dgId ; } boolean drawingGroupExists ( short dgId ) { for ( int i = 0 ; i < dgg . getFileIdClusters ( ) . length ; i ++ ) { if ( dgg . getFileIdClusters ( ) [ i ] . getDrawingGroupId ( ) == dgId ) return true ; } return false ; } int findFreeSPIDBlock ( ) { int max = dgg . getShapeIdMax ( ) ; int next = ( ( max / 1024 ) + 1 ) * 1024 ; return next ; } public EscherDggRecord getDgg ( ) { return dgg ; } } 	0	['7', '1', '0', '3', '30', '0', '0', '3', '4', '0.333333333', '212', '0', '1', '0', '0.476190476', '0', '0', '29', '7', '2.1429', '0']
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class ParenthesisPtg extends OperationPtg { private final static int SIZE = 1 ; public final static byte sid = 0x15 ; public ParenthesisPtg ( ) { } public ParenthesisPtg ( RecordInputStream in ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 1 ; } public String toFormulaString ( Workbook book ) { return "()" ; } public String toFormulaString ( String [ ] operands ) { return "(" + operands [ 0 ] + ")" ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new ParenthesisPtg ( ) ; } } 	0	['10', '2', '0', '5', '14', '45', '2', '3', '10', '1.111111111', '52', '0.5', '0', '0.272727273', '0.25', '0', '0', '4', '1', '0.8', '0']
package org . apache . poi . poifs . filesystem ; import org . apache . poi . poifs . property . Property ; public abstract class EntryNode implements Entry { private Property _property ; private DirectoryNode _parent ; protected EntryNode ( final Property property , final DirectoryNode parent ) { _property = property ; _parent = parent ; } protected Property getProperty ( ) { return _property ; } protected boolean isRoot ( ) { return ( _parent == null ) ; } protected abstract boolean isDeleteOK ( ) ; public String getName ( ) { return _property . getName ( ) ; } public boolean isDirectoryEntry ( ) { return false ; } public boolean isDocumentEntry ( ) { return false ; } public DirectoryEntry getParent ( ) { return _parent ; } public boolean delete ( ) { boolean rval = false ; if ( ( ! isRoot ( ) ) && isDeleteOK ( ) ) { rval = _parent . deleteEntry ( this ) ; } return rval ; } public boolean renameTo ( final String newName ) { boolean rval = false ; if ( ! isRoot ( ) ) { rval = _parent . changeName ( getName ( ) , newName ) ; } return rval ; } } 	0	['10', '1', '2', '6', '14', '19', '3', '4', '6', '0.611111111', '71', '1', '2', '0', '0.325', '0', '0', '5.9', '3', '1.3', '0']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . RecordInputStream ; public class RangePtg extends OperationPtg { public final static byte sid = 0x11 ; public RangePtg ( ) { } public RangePtg ( RecordInputStream in ) { } public int getSize ( ) { return 1 ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public Object clone ( ) { return new RangePtg ( ) ; } public int getType ( ) { return TYPE_BINARY ; } public String toFormulaString ( Workbook book ) { return ":" ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( ":" ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public int getNumberOfOperands ( ) { return 2 ; } } 	0	['9', '2', '0', '4', '13', '36', '1', '3', '9', '1.125', '58', '0', '0', '0.3', '0.259259259', '0', '0', '5.333333333', '1', '0.7778', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public interface FixedField { public void readFromBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public void readFromStream ( InputStream stream ) throws IOException , BufferUnderrunException ; public void writeToBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public String toString ( ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hpsf . wellknown ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; public class PropertyIDMap extends HashMap { public static final int PID_TITLE = 2 ; public static final int PID_SUBJECT = 3 ; public static final int PID_AUTHOR = 4 ; public static final int PID_KEYWORDS = 5 ; public static final int PID_COMMENTS = 6 ; public static final int PID_TEMPLATE = 7 ; public static final int PID_LASTAUTHOR = 8 ; public static final int PID_REVNUMBER = 9 ; public static final int PID_EDITTIME = 10 ; public static final int PID_LASTPRINTED = 11 ; public static final int PID_CREATE_DTM = 12 ; public static final int PID_LASTSAVE_DTM = 13 ; public static final int PID_PAGECOUNT = 14 ; public static final int PID_WORDCOUNT = 15 ; public static final int PID_CHARCOUNT = 16 ; public static final int PID_THUMBNAIL = 17 ; public static final int PID_APPNAME = 18 ; public static final int PID_SECURITY = 19 ; public static final int PID_DICTIONARY = 0 ; public static final int PID_CODEPAGE = 1 ; public static final int PID_CATEGORY = 2 ; public static final int PID_PRESFORMAT = 3 ; public static final int PID_BYTECOUNT = 4 ; public static final int PID_LINECOUNT = 5 ; public static final int PID_PARCOUNT = 6 ; public static final int PID_SLIDECOUNT = 7 ; public static final int PID_NOTECOUNT = 8 ; public static final int PID_HIDDENCOUNT = 9 ; public static final int PID_MMCLIPCOUNT = 10 ; public static final int PID_SCALE = 11 ; public static final int PID_HEADINGPAIR = 12 ; public static final int PID_DOCPARTS = 13 ; public static final int PID_MANAGER = 14 ; public static final int PID_COMPANY = 15 ; public static final int PID_LINKSDIRTY = 16 ; public static final int PID_MAX = PID_LINKSDIRTY ; private static PropertyIDMap summaryInformationProperties ; private static PropertyIDMap documentSummaryInformationProperties ; public PropertyIDMap ( final int initialCapacity , final float loadFactor ) { super ( initialCapacity , loadFactor ) ; } public PropertyIDMap ( final Map map ) { super ( map ) ; } public Object put ( final long id , final String idString ) { return put ( new Long ( id ) , idString ) ; } public Object get ( final long id ) { return get ( new Long ( id ) ) ; } public static PropertyIDMap getSummaryInformationProperties ( ) { if ( summaryInformationProperties == null ) { PropertyIDMap m = new PropertyIDMap ( 18 , ( float ) 1.0 ) ; m . put ( PID_TITLE , "PID_TITLE" ) ; m . put ( PID_SUBJECT , "PID_SUBJECT" ) ; m . put ( PID_AUTHOR , "PID_AUTHOR" ) ; m . put ( PID_KEYWORDS , "PID_KEYWORDS" ) ; m . put ( PID_COMMENTS , "PID_COMMENTS" ) ; m . put ( PID_TEMPLATE , "PID_TEMPLATE" ) ; m . put ( PID_LASTAUTHOR , "PID_LASTAUTHOR" ) ; m . put ( PID_REVNUMBER , "PID_REVNUMBER" ) ; m . put ( PID_EDITTIME , "PID_EDITTIME" ) ; m . put ( PID_LASTPRINTED , "PID_LASTPRINTED" ) ; m . put ( PID_CREATE_DTM , "PID_CREATE_DTM" ) ; m . put ( PID_LASTSAVE_DTM , "PID_LASTSAVE_DTM" ) ; m . put ( PID_PAGECOUNT , "PID_PAGECOUNT" ) ; m . put ( PID_WORDCOUNT , "PID_WORDCOUNT" ) ; m . put ( PID_CHARCOUNT , "PID_CHARCOUNT" ) ; m . put ( PID_THUMBNAIL , "PID_THUMBNAIL" ) ; m . put ( PID_APPNAME , "PID_APPNAME" ) ; m . put ( PID_SECURITY , "PID_SECURITY" ) ; summaryInformationProperties = new PropertyIDMap ( Collections . unmodifiableMap ( m ) ) ; } return summaryInformationProperties ; } public static PropertyIDMap getDocumentSummaryInformationProperties ( ) { if ( documentSummaryInformationProperties == null ) { PropertyIDMap m = new PropertyIDMap ( 17 , ( float ) 1.0 ) ; m . put ( PID_DICTIONARY , "PID_DICTIONARY" ) ; m . put ( PID_CODEPAGE , "PID_CODEPAGE" ) ; m . put ( PID_CATEGORY , "PID_CATEGORY" ) ; m . put ( PID_PRESFORMAT , "PID_PRESFORMAT" ) ; m . put ( PID_BYTECOUNT , "PID_BYTECOUNT" ) ; m . put ( PID_LINECOUNT , "PID_LINECOUNT" ) ; m . put ( PID_PARCOUNT , "PID_PARCOUNT" ) ; m . put ( PID_SLIDECOUNT , "PID_SLIDECOUNT" ) ; m . put ( PID_NOTECOUNT , "PID_NOTECOUNT" ) ; m . put ( PID_HIDDENCOUNT , "PID_HIDDENCOUNT" ) ; m . put ( PID_MMCLIPCOUNT , "PID_MMCLIPCOUNT" ) ; m . put ( PID_SCALE , "PID_SCALE" ) ; m . put ( PID_HEADINGPAIR , "PID_HEADINGPAIR" ) ; m . put ( PID_DOCPARTS , "PID_DOCPARTS" ) ; m . put ( PID_MANAGER , "PID_MANAGER" ) ; m . put ( PID_COMPANY , "PID_COMPANY" ) ; m . put ( PID_LINKSDIRTY , "PID_LINKSDIRTY" ) ; documentSummaryInformationProperties = new PropertyIDMap ( Collections . unmodifiableMap ( m ) ) ; } return documentSummaryInformationProperties ; } public static void main ( final String [ ] args ) { PropertyIDMap s1 = getSummaryInformationProperties ( ) ; PropertyIDMap s2 = getDocumentSummaryInformationProperties ( ) ; System . out . println ( "s1: " + s1 ) ; System . out . println ( "s2: " + s2 ) ; } } 	0	['7', '3', '0', '1', '18', '21', '1', '0', '7', '1.149122807', '301', '0.052631579', '2', '0.915254237', '0.224489796', '1', '2', '36.57142857', '2', '1', '0']
package org . apache . poi . hpsf ; public abstract class VariantTypeException extends HPSFException { private Object value ; private long variantType ; public VariantTypeException ( final long variantType , final Object value , final String msg ) { super ( msg ) ; this . variantType = variantType ; this . value = value ; } public long getVariantType ( ) { return variantType ; } public Object getValue ( ) { return value ; } } 	0	['3', '4', '2', '3', '4', '0', '2', '1', '3', '0.5', '21', '1', '0', '0.9', '0.5', '0', '0', '5.333333333', '1', '0.6667', '0']
