package org . apache . camel . component . cxf ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . spi . HeaderFilterStrategy ; public class CxfComponent extends DefaultComponent < CxfExchange > implements HeaderFilterStrategyAware { private HeaderFilterStrategy headerFilterStrategy = new CxfHeaderFilterStrategy ( ) ; public CxfComponent ( ) { } public CxfComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < CxfExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { CxfEndpoint result = new CxfEndpoint ( uri , remaining , this ) ; setProperties ( result , parameters ) ; return result ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } } 	0	['5', '3', '0', '7', '10', '0', '1', '7', '4', '0.25', '43', '1', '1', '0.921052632', '0.36', '1', '2', '7.4', '1', '0.6', '0']
package org . apache . camel . language . simple ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . language . IllegalSyntaxException ; import org . apache . camel . util . ObjectHelper ; public class SimpleLanguage extends AbstractSimpleLanguage { public static Expression simple ( String expression ) { SimpleLanguage language = new SimpleLanguage ( ) ; return language . createExpression ( expression ) ; } protected Expression < Exchange > createSimpleExpression ( String expression ) { if ( ObjectHelper . isEqualToAny ( expression , "body" , "in.body" ) ) { return ExpressionBuilder . bodyExpression ( ) ; } else if ( ObjectHelper . equal ( expression , "out.body" ) ) { return ExpressionBuilder . outBodyExpression ( ) ; } else if ( ObjectHelper . equal ( expression , "id" ) ) { return ExpressionBuilder . messageIdExpression ( ) ; } String remainder = ifStartsWithReturnRemainder ( "in.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "header." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "headers." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "in.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . headerExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "out.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "out.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . outHeaderExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "property." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . propertyExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "sys." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . systemProperty ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "date:" , expression ) ; if ( remainder != null ) { String [ ] parts = remainder . split ( ":" ) ; if ( parts . length != 2 ) { throw new IllegalSyntaxException ( this , expression + " ${date:command:pattern} is the correct syntax." ) ; } String command = parts [ 0 ] ; String pattern = parts [ 1 ] ; return ExpressionBuilder . dateExpression ( command , pattern ) ; } remainder = ifStartsWithReturnRemainder ( "bean:" , expression ) ; if ( remainder != null ) { return ExpressionBuilder . beanExpression ( remainder ) ; } throw new IllegalSyntaxException ( this , expression ) ; } } 	1	['3', '2', '0', '8', '22', '3', '2', '6', '2', '2', '165', '0', '0', '0.75', '0.666666667', '1', '3', '54', '15', '5.3333', '1']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . processor . interceptor . ExchangeFormatter ; public class DefaultExchangeFormatter implements ExchangeFormatter { protected static final DefaultExchangeFormatter INSTANCE = new DefaultExchangeFormatter ( ) ; public static DefaultExchangeFormatter getInstance ( ) { return INSTANCE ; } public Object format ( Exchange exchange ) { return exchange ; } } 	0	['4', '1', '0', '3', '5', '4', '1', '2', '3', '0.666666667', '17', '1', '1', '0', '0.5', '0', '0', '3', '1', '0.5', '0']
package org . apache . camel . util ; import java . util . Collection ; import org . apache . camel . Service ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class ServiceHelper { private static final transient Log LOG = LogFactory . getLog ( ServiceHelper . class ) ; private ServiceHelper ( ) { } public static void startService ( Object value ) throws Exception { if ( value instanceof Service ) { Service service = ( Service ) value ; service . start ( ) ; } else if ( value instanceof Collection ) { startServices ( ( Collection ) value ) ; } } public static void startServices ( Object ... services ) throws Exception { for ( Object value : services ) { startService ( value ) ; } } public static void startServices ( Collection services ) throws Exception { for ( Object value : services ) { if ( value instanceof Service ) { Service service = ( Service ) value ; service . start ( ) ; } } } public static void stopServices ( Object ... services ) throws Exception { Exception firstException = null ; for ( Object value : services ) { if ( value instanceof Service ) { Service service = ( Service ) value ; try { service . stop ( ) ; } catch ( Exception e ) { LOG . debug ( "Caught exception shutting down: " + e , e ) ; if ( firstException == null ) { firstException = e ; } } } } if ( firstException != null ) { throw firstException ; } } public static void stopService ( Object value ) throws Exception { if ( value instanceof Service ) { Service service = ( Service ) value ; service . stop ( ) ; } else if ( value instanceof Collection ) { stopServices ( ( Collection ) value ) ; } } public static void stopServices ( Collection services ) throws Exception { Exception firstException = null ; for ( Object value : services ) { if ( value instanceof Service ) { Service service = ( Service ) value ; try { service . stop ( ) ; } catch ( Exception e ) { LOG . debug ( "Caught exception shutting down: " + e , e ) ; if ( firstException == null ) { firstException = e ; } } } } if ( firstException != null ) { throw firstException ; } } } 	1	['8', '1', '0', '25', '20', '22', '22', '3', '6', '0.571428571', '176', '1', '0', '0', '0.25', '0', '0', '20.875', '1', '0.75', '1']
package org . apache . camel . component . jetty ; import java . net . URI ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . component . http . CamelServlet ; import org . apache . camel . component . http . HttpComponent ; import org . apache . camel . component . http . HttpConsumer ; import org . apache . camel . component . http . HttpEndpoint ; import org . apache . camel . component . http . HttpExchange ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; import org . apache . commons . httpclient . params . HttpClientParams ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . mortbay . jetty . Connector ; import org . mortbay . jetty . Server ; import org . mortbay . jetty . handler . ContextHandlerCollection ; import org . mortbay . jetty . nio . SelectChannelConnector ; import org . mortbay . jetty . security . SslSocketConnector ; import org . mortbay . jetty . servlet . Context ; import org . mortbay . jetty . servlet . HashSessionIdManager ; import org . mortbay . jetty . servlet . HashSessionManager ; import org . mortbay . jetty . servlet . ServletHolder ; import org . mortbay . jetty . servlet . SessionHandler ; public class JettyHttpComponent extends HttpComponent { class ConnectorRef { Connector connector ; CamelServlet servlet ; int refCount ; public ConnectorRef ( Connector connector , CamelServlet servlet ) { this . connector = connector ; this . servlet = servlet ; increment ( ) ; } public int increment ( ) { return ++ refCount ; } public int decrement ( ) { return -- refCount ; } } private static final transient Log LOG = LogFactory . getLog ( JettyHttpComponent . class ) ; protected Server server ; protected HashMap < String , ConnectorRef > connectors = new HashMap < String , ConnectorRef > ( ) ; protected String sslKeyPassword ; protected String sslPassword ; protected String sslKeystore ; protected SslSocketConnector sslSocketConnector ; @ Override protected Endpoint < HttpExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { uri = uri . startsWith ( "jetty:" ) ? remaining : uri ; HttpClientParams params = new HttpClientParams ( ) ; IntrospectionSupport . setProperties ( params , parameters , "httpClient." ) ; configureParameters ( parameters ) ; URI httpUri = URISupport . createRemainingURI ( new URI ( uri ) , parameters ) ; uri = httpUri . toString ( ) ; JettyHttpEndpoint result = new JettyHttpEndpoint ( this , uri , httpUri , params , getHttpConnectionManager ( ) , httpClientConfigurer ) ; if ( httpBinding != null ) { result . setBinding ( httpBinding ) ; } setProperties ( result , parameters ) ; return result ; } @ Override public void connect ( HttpConsumer consumer ) throws Exception { JettyHttpEndpoint endpoint = ( JettyHttpEndpoint ) consumer . getEndpoint ( ) ; String connectorKey = getConnectorKey ( endpoint ) ; synchronized ( connectors ) { ConnectorRef connectorRef = connectors . get ( connectorKey ) ; if ( connectorRef == null ) { Connector connector ; if ( "https" . equals ( endpoint . getProtocol ( ) ) ) { connector = getSslSocketConnector ( ) ; } else { connector = new SelectChannelConnector ( ) ; } connector . setPort ( endpoint . getPort ( ) ) ; connector . setHost ( endpoint . getHttpUri ( ) . getHost ( ) ) ; if ( "localhost" . equalsIgnoreCase ( endpoint . getHttpUri ( ) . getHost ( ) ) ) { LOG . warn ( "You use localhost interface! It means that no external connections will be available. Don't you want to use 0.0.0.0 instead (all network interfaces)?" ) ; } getServer ( ) . addConnector ( connector ) ; connectorRef = new ConnectorRef ( connector , createServletForConnector ( connector ) ) ; connector . start ( ) ; connectors . put ( connectorKey , connectorRef ) ; } else { connectorRef . increment ( ) ; } if ( endpoint . isSessionSupport ( ) ) { enableSessionSupport ( ) ; } connectorRef . servlet . connect ( consumer ) ; } } private void enableSessionSupport ( ) throws Exception { Context context = ( Context ) getServer ( ) . getChildHandlerByClass ( Context . class ) ; if ( context . getSessionHandler ( ) == null ) { SessionHandler sessionHandler = new SessionHandler ( ) ; context . setSessionHandler ( sessionHandler ) ; if ( context . isStarted ( ) ) { context . stop ( ) ; context . start ( ) ; } } } @ Override public void disconnect ( HttpConsumer consumer ) throws Exception { HttpEndpoint endpoint = consumer . getEndpoint ( ) ; String connectorKey = getConnectorKey ( endpoint ) ; synchronized ( connectors ) { ConnectorRef connectorRef = connectors . get ( connectorKey ) ; if ( connectorRef != null ) { connectorRef . servlet . disconnect ( consumer ) ; if ( connectorRef . decrement ( ) == 0 ) { getServer ( ) . removeConnector ( connectorRef . connector ) ; connectorRef . connector . stop ( ) ; connectors . remove ( connectorKey ) ; } } } } private String getConnectorKey ( HttpEndpoint endpoint ) { return endpoint . getProtocol ( ) + ":" + endpoint . getHttpUri ( ) . getHost ( ) + ":" + endpoint . getPort ( ) ; } public Server getServer ( ) throws Exception { if ( server == null ) { server = createServer ( ) ; } return server ; } public void setServer ( Server server ) { this . server = server ; } public String getSslKeyPassword ( ) { return sslKeyPassword ; } public void setSslKeyPassword ( String sslKeyPassword ) { this . sslKeyPassword = sslKeyPassword ; } public String getSslPassword ( ) { return sslPassword ; } public void setSslPassword ( String sslPassword ) { this . sslPassword = sslPassword ; } public void setKeystore ( String sslKeystore ) { this . sslKeystore = sslKeystore ; } public String getKeystore ( ) { return sslKeystore ; } public synchronized SslSocketConnector getSslSocketConnector ( ) { if ( sslSocketConnector == null ) { sslSocketConnector = new SslSocketConnector ( ) ; sslSocketConnector . setPassword ( sslPassword ) ; sslSocketConnector . setKeyPassword ( sslKeyPassword ) ; if ( sslKeystore != null ) { sslSocketConnector . setKeystore ( sslKeystore ) ; } } return sslSocketConnector ; } public void setSslSocketConnector ( SslSocketConnector connector ) { sslSocketConnector = connector ; } protected CamelServlet createServletForConnector ( Connector connector ) throws Exception { CamelServlet camelServlet = new CamelContinuationServlet ( ) ; Context context = new Context ( server , "/" , Context . NO_SECURITY | Context . NO_SESSIONS ) ; context . setConnectorNames ( new String [ ] { connector . getName ( ) } ) ; ServletHolder holder = new ServletHolder ( ) ; holder . setServlet ( camelServlet ) ; context . addServlet ( holder , "/*" ) ; connector . start ( ) ; context . start ( ) ; return camelServlet ; } protected Server createServer ( ) throws Exception { Server server = new Server ( ) ; ContextHandlerCollection collection = new ContextHandlerCollection ( ) ; collection . setServer ( server ) ; server . addHandler ( collection ) ; server . start ( ) ; return server ; } @ Override protected void doStop ( ) throws Exception { for ( ConnectorRef connectorRef : connectors . values ( ) ) { connectorRef . connector . stop ( ) ; } connectors . clear ( ) ; if ( server != null ) { server . stop ( ) ; } super . doStop ( ) ; } } 	0	['20', '4', '0', '26', '95', '144', '2', '26', '13', '0.842105263', '433', '1', '0', '0.727272727', '0.197368421', '4', '5', '20.3', '3', '1', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Route ; import org . apache . camel . Service ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . RouteContext ; public class DefaultLifecycleStrategy implements LifecycleStrategy { public void onContextStart ( CamelContext context ) { } public void onEndpointAdd ( Endpoint < ? extends Exchange > endpoint ) { } public void onServiceAdd ( CamelContext context , Service service ) { } public void onRoutesAdd ( Collection < Route > routes ) { } public void onRouteContextCreate ( RouteContext routeContext ) { RouteType routeType = routeContext . getRoute ( ) ; if ( routeType . getInputs ( ) != null && ! routeType . getInputs ( ) . isEmpty ( ) ) { List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( routeType . getOutputs ( ) ) ; routeType . clearOutput ( ) ; for ( ProcessorType < ? > processorType : outputs ) { routeType . addOutput ( processorType ) ; } } } } 	1	['6', '1', '0', '9', '17', '15', '2', '7', '6', '2', '46', '0', '0', '0', '0.333333333', '0', '0', '6.666666667', '4', '1.3333', '2']
package org . apache . camel . component . file ; import java . io . File ; public interface FileProcessStrategy { boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; void rollback ( FileEndpoint endpoint , FileExchange exchange , File file ) ; } 	0	['3', '1', '0', '6', '3', '3', '5', '2', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . language . simple ; import java . text . SimpleDateFormat ; import java . util . Date ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . language . IllegalSyntaxException ; import org . apache . camel . language . constant . ConstantLanguage ; public final class FileExpressionBuilder { private FileExpressionBuilder ( ) { } public static < E extends Exchange > Expression < E > fileNameExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getHeader ( "CamelFileName" , String . class ) ; } @ Override public String toString ( ) { return "file:name" ; } } ; } public static < E extends Exchange > Expression < E > fileNameNoExtensionExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String name = exchange . getIn ( ) . getHeader ( "CamelFileName" , String . class ) ; if ( name . lastIndexOf ( "." ) != - 1 ) { return name . substring ( 0 , name . lastIndexOf ( '.' ) ) ; } else { return name ; } } @ Override public String toString ( ) { return "file:name.noext" ; } } ; } public static < E extends Exchange > Expression < E > fileParentExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getHeader ( "CamelFileParent" , String . class ) ; } @ Override public String toString ( ) { return "file:parent" ; } } ; } public static < E extends Exchange > Expression < E > filePathExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getHeader ( "CamelFilePath" , String . class ) ; } @ Override public String toString ( ) { return "file:path" ; } } ; } public static < E extends Exchange > Expression < E > fileAbsolutePathExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getHeader ( "CamelFileAbsolutePath" , String . class ) ; } @ Override public String toString ( ) { return "file:absolute.path" ; } } ; } public static < E extends Exchange > Expression < E > fileCanoicalPathExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getHeader ( "CamelFileCanonicalPath" , String . class ) ; } @ Override public String toString ( ) { return "file:canonical.path" ; } } ; } public static < E extends Exchange > Expression < E > fileSizeExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getHeader ( "CamelFileLength" , Long . class ) ; } @ Override public String toString ( ) { return "file:length" ; } } ; } public static < E extends Exchange > Expression < E > dateExpression ( final String command , final String pattern ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { if ( "file" . equals ( command ) ) { Date date = exchange . getIn ( ) . getHeader ( "CamelFileLastModified" , Date . class ) ; if ( date != null ) { SimpleDateFormat df = new SimpleDateFormat ( pattern ) ; return df . format ( date ) ; } else { return null ; } } return ExpressionBuilder . dateExpression ( command , pattern ) . evaluate ( exchange ) ; } @ Override public String toString ( ) { return "date(" + command + ":" + pattern + ")" ; } } ; } public static < E extends Exchange > Expression < E > simpleExpression ( final String simple ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { try { return SimpleLanguage . simple ( simple ) . evaluate ( exchange ) ; } catch ( IllegalSyntaxException e ) { return ConstantLanguage . constant ( simple ) . evaluate ( exchange ) ; } } @ Override public String toString ( ) { return "simple(" + simple + ")" ; } } ; } } 	1	['10', '1', '0', '11', '20', '45', '1', '10', '9', '2', '52', '0', '0', '0', '0.15', '0', '0', '4.2', '1', '0.9', '3']
package org . apache . camel . component . restlet ; public final class RestletConstants { public static final String LOGIN = "org.apache.camel.restlet.auth.login" ; public static final String PASSWORD = "org.apache.camel.restlet.auth.password" ; public static final String MEDIA_TYPE = "org.apache.camel.restlet.mediaType" ; public static final String RESPONSE_CODE = "org.apache.camel.restlet.responseCode" ; public static final String QUERY_STRING = "org.apache.camel.restlet.queryString" ; private RestletConstants ( ) { } } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '0', '2', '9', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . model . loadbalancer ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; @ XmlRootElement ( name = "sticky" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class StickyLoadBalanceStrategy extends LoadBalancerType { @ XmlElement ( required = true , name = "expression" , type = ExpressionType . class ) private ExpressionType expressionType ; @ XmlElement ( required = false , name = "loadBalancer" , type = LoadBalancerType . class ) private LoadBalancerType loadBalancerType ; public StickyLoadBalanceStrategy ( ) { super ( "org.apache.camel.processor.loadbalancer.StickyLoadBalancer" ) ; } public StickyLoadBalanceStrategy ( ExpressionType expressionType ) { this ( ) ; this . expressionType = expressionType ; } public StickyLoadBalanceStrategy ( ExpressionType expressionType , LoadBalancerType loadBalancerType ) { this ( ) ; this . expressionType = expressionType ; this . loadBalancerType = loadBalancerType ; } public void setExpressionType ( ExpressionType expressionType ) { this . expressionType = expressionType ; } public ExpressionType getExpressionType ( ) { return expressionType ; } public void setLoadBalancerType ( LoadBalancerType loadBalancerType ) { this . loadBalancerType = loadBalancerType ; } public LoadBalancerType getLoadBalancerType ( ) { return loadBalancerType ; } @ Override protected void configureLoadBalancer ( LoadBalancer loadBalancer ) { ExpressionType expression = getExpressionType ( ) ; if ( expression != null ) { setProperty ( loadBalancer , "correlationExpression" , expression ) ; } LoadBalancerType type = getLoadBalancerType ( ) ; if ( type != null ) { setProperty ( loadBalancer , "loadBalancer" , type ) ; } } @ Override public String toString ( ) { return "StickyLoadBalanceStrategy[" + expressionType + ", " + loadBalancerType + "]" ; } } 	1	['9', '3', '0', '3', '15', '6', '0', '3', '8', '0.4375', '82', '1', '2', '0.666666667', '0.416666667', '1', '2', '7.888888889', '3', '0.8889', '1']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface RecipientList { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; public class StickyLoadBalancer extends QueueLoadBalancer { private Expression < Exchange > correlationExpression ; private QueueLoadBalancer loadBalancer ; private int numberOfHashGroups = 64 * 1024 ; private final Map < Object , Processor > stickyMap = new HashMap < Object , Processor > ( ) ; public StickyLoadBalancer ( ) { this . loadBalancer = new RoundRobinLoadBalancer ( ) ; } public StickyLoadBalancer ( Expression < Exchange > correlationExpression ) { this ( correlationExpression , new RoundRobinLoadBalancer ( ) ) ; } public StickyLoadBalancer ( Expression < Exchange > correlationExpression , QueueLoadBalancer loadBalancer ) { this . correlationExpression = correlationExpression ; this . loadBalancer = loadBalancer ; } public void setCorrelationExpression ( Expression < Exchange > correlationExpression ) { this . correlationExpression = correlationExpression ; } public void setLoadBalancer ( QueueLoadBalancer loadBalancer ) { this . loadBalancer = loadBalancer ; } protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { Object value = correlationExpression . evaluate ( exchange ) ; Object key = getStickyKey ( value ) ; Processor processor ; synchronized ( stickyMap ) { processor = stickyMap . get ( key ) ; if ( processor == null ) { processor = loadBalancer . chooseProcessor ( processors , exchange ) ; stickyMap . put ( key , processor ) ; } } return processor ; } @ Override public void removeProcessor ( Processor processor ) { synchronized ( stickyMap ) { Iterator < Map . Entry < Object , Processor > > iter = stickyMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < Object , Processor > entry = iter . next ( ) ; if ( processor . equals ( entry . getValue ( ) ) ) { iter . remove ( ) ; } } } super . removeProcessor ( processor ) ; } public int getNumberOfHashGroups ( ) { return numberOfHashGroups ; } public void setNumberOfHashGroups ( int numberOfHashGroups ) { this . numberOfHashGroups = numberOfHashGroups ; } protected Object getStickyKey ( Object value ) { int hashCode = 37 ; if ( value != null ) { hashCode = value . hashCode ( ) ; } if ( numberOfHashGroups > 0 ) { hashCode = hashCode % numberOfHashGroups ; } return hashCode ; } } 	1	['10', '4', '0', '6', '27', '5', '1', '5', '8', '0.527777778', '168', '1', '2', '0.75862069', '0.25', '2', '2', '15.4', '3', '1.1', '1']
package org . apache . camel . language . groovy ; import groovy . lang . Closure ; import org . apache . camel . Exchange ; import org . apache . camel . impl . ExpressionSupport ; import org . apache . camel . model . ChoiceType ; import org . apache . camel . model . FilterType ; import org . apache . camel . model . ProcessorType ; public final class CamelGroovyMethods { private CamelGroovyMethods ( ) { } public static FilterType filter ( ProcessorType self , Closure filter ) { return self . filter ( toExpression ( filter ) ) ; } public static ChoiceType when ( ChoiceType self , Closure filter ) { return self . when ( toExpression ( filter ) ) ; } public static ExpressionSupport toExpression ( final Closure filter ) { return new ExpressionSupport < Exchange > ( ) { protected String assertionFailureMessage ( Exchange exchange ) { return filter . toString ( ) ; } public Object evaluate ( Exchange exchange ) { return filter . call ( exchange ) ; } @ Override public String toString ( ) { return "Groovy[" + filter + "]" ; } } ; } } 	0	['4', '1', '0', '7', '8', '6', '0', '7', '3', '2', '22', '0', '0', '0', '0.375', '0', '0', '4.5', '1', '0.75', '0']
package org . apache . camel . component . direct ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DirectEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private static final transient Log LOG = LogFactory . getLog ( DirectEndpoint . class ) ; private boolean allowMultipleConsumers = true ; private final CopyOnWriteArrayList < DefaultConsumer < E > > consumers = new CopyOnWriteArrayList < DefaultConsumer < E > > ( ) ; public DirectEndpoint ( String uri , DirectComponent < E > component ) { super ( uri , component ) ; } public DirectEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public Producer createProducer ( ) throws Exception { return new DirectProducer < E > ( this ) ; } public Consumer < E > createConsumer ( Processor processor ) throws Exception { return new DefaultConsumer < E > ( this , processor ) { @ Override public void start ( ) throws Exception { if ( ! allowMultipleConsumers && ! consumers . isEmpty ( ) ) { throw new IllegalStateException ( "Endpoint " + getEndpointUri ( ) + " only allows 1 active consumer but you attempted to start a 2nd consumer." ) ; } consumers . add ( this ) ; super . start ( ) ; } @ Override public void stop ( ) throws Exception { super . stop ( ) ; consumers . remove ( this ) ; } } ; } public boolean isAllowMultipleConsumers ( ) { return allowMultipleConsumers ; } public void setAllowMultipleConsumers ( boolean allowMutlipleConsumers ) { this . allowMultipleConsumers = allowMutlipleConsumers ; } public boolean isSingleton ( ) { return true ; } public List < DefaultConsumer < E > > getConsumers ( ) { return consumers ; } } 	1	['11', '2', '0', '11', '17', '25', '3', '11', '8', '0.766666667', '73', '1', '0', '0.75', '0.25', '0', '0', '5.363636364', '1', '0.7273', '2']
package org . apache . camel . component . file . remote ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . net . ftp . FTPClientConfig ; public class RemoteFileComponent extends DefaultComponent < RemoteFileExchange > { private RemoteFileConfiguration configuration ; public RemoteFileComponent ( ) { this . configuration = new RemoteFileConfiguration ( ) ; } public RemoteFileComponent ( RemoteFileConfiguration configuration ) { this . configuration = configuration ; } public RemoteFileComponent ( CamelContext context ) { super ( context ) ; this . configuration = new RemoteFileConfiguration ( ) ; } public String toString ( ) { return "RemoteFileComponent" ; } public static RemoteFileComponent remoteFileComponent ( ) { return new RemoteFileComponent ( ) ; } protected RemoteFileEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { RemoteFileConfiguration config = getConfiguration ( ) . copy ( ) ; String baseUri = uri ; if ( uri . indexOf ( "?" ) != - 1 ) { baseUri = uri . substring ( 0 , uri . indexOf ( "?" ) ) ; } config . configure ( new URI ( baseUri ) ) ; final RemoteFileEndpoint endpoint ; if ( "ftp" . equals ( config . getProtocol ( ) ) ) { endpoint = new FtpEndpoint ( uri , this , config ) ; } else if ( "sftp" . equals ( config . getProtocol ( ) ) ) { endpoint = new SftpEndpoint ( uri , this , config ) ; } else { throw new RuntimeCamelException ( "Unsupported protocol: " + config . getProtocol ( ) ) ; } configureFTPClientConfig ( parameters , endpoint ) ; setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } private void configureFTPClientConfig ( Map parameters , RemoteFileEndpoint endpoint ) { String ref = getAndRemoveParameter ( parameters , "ftpClientConfig" , String . class ) ; if ( ref != null ) { FTPClientConfig ftpClientConfig = this . getCamelContext ( ) . getRegistry ( ) . lookup ( ref , FTPClientConfig . class ) ; if ( ftpClientConfig == null ) { throw new IllegalArgumentException ( "FTPClientConfig " + ref + " not found in registry." ) ; } endpoint . getConfiguration ( ) . setFtpClientConfig ( ftpClientConfig ) ; } } public RemoteFileConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( RemoteFileConfiguration configuration ) { this . configuration = configuration ; } } 	0	['10', '3', '0', '10', '33', '25', '3', '10', '7', '0.222222222', '165', '1', '1', '0.833333333', '0.3', '2', '3', '15.4', '3', '0.9', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "json" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class JsonDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private Boolean prettyPrint ; public JsonDataFormat ( ) { super ( "org.apache.camel.dataformat.xstream.JsonDataFormat" ) ; } public Boolean getPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( Boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } } 	1	['3', '3', '0', '2', '4', '1', '1', '1', '3', '0.5', '15', '1', '0', '0.818181818', '0.666666667', '0', '0', '3.666666667', '1', '0.6667', '1']
package org . apache . camel . component . jmx ; import javax . management . MBeanServer ; import javax . management . Notification ; import javax . management . ObjectName ; import javax . management . monitor . CounterMonitor ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JMXEndpoint extends DefaultEndpoint < JMXExchange > { private static final transient Log LOG = LogFactory . getLog ( JMXEndpoint . class ) ; private String name ; private ObjectName ourName ; private String observedObjectName ; private String attributeName ; private long granularityPeriod = 5000 ; private Number threshold ; private Number offset ; private MBeanServer mbeanServer ; private CounterMonitor counterMonitor = new CounterMonitor ( ) ; protected JMXEndpoint ( String endpointUri , JMXComponent component ) { super ( endpointUri , component ) ; observedObjectName = endpointUri ; } public JMXEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public Producer < JMXExchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "Producer not supported" ) ; } public Consumer < JMXExchange > createConsumer ( Processor proc ) throws Exception { ObjectName observedName = new ObjectName ( observedObjectName ) ; if ( name == null ) { String type = observedName . getKeyProperty ( "type" ) ; type = type != null ? type : "UNKNOWN" ; name = mbeanServer . getDefaultDomain ( ) + ":type=CounterMonitor_" + type ; } JMXConsumer result = new JMXConsumer ( this , proc ) ; ourName = new ObjectName ( name ) ; counterMonitor . setNotify ( true ) ; counterMonitor . addObservedObject ( observedName ) ; counterMonitor . setObservedAttribute ( attributeName ) ; counterMonitor . setGranularityPeriod ( granularityPeriod ) ; counterMonitor . setDifferenceMode ( false ) ; counterMonitor . setInitThreshold ( threshold ) ; counterMonitor . setOffset ( offset ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Registering and adding notification listener for [" + counterMonitor + "] with name [" + ourName + "]" ) ; } mbeanServer . registerMBean ( counterMonitor , ourName ) ; mbeanServer . addNotificationListener ( ourName , result , null , new Object ( ) ) ; return result ; } public boolean isSingleton ( ) { return true ; } public JMXExchange createExchange ( Notification notification ) { return new JMXExchange ( getCamelContext ( ) , getExchangePattern ( ) , notification ) ; } public JMXExchange createExchange ( ) { return new JMXExchange ( getCamelContext ( ) , getExchangePattern ( ) , null ) ; } public JMXExchange createExchange ( ExchangePattern pattern ) { return new JMXExchange ( getCamelContext ( ) , pattern , null ) ; } public String getAttributeName ( ) { return attributeName ; } public void setAttributeName ( String attributeName ) { this . attributeName = attributeName ; } public long getGranularityPeriod ( ) { return granularityPeriod ; } public void setGranularityPeriod ( long granularityPeriod ) { this . granularityPeriod = granularityPeriod ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Number getOffset ( ) { return offset ; } public void setOffset ( Number offset ) { this . offset = offset ; } public Number getThreshold ( ) { return threshold ; } public void setThreshold ( Number threshold ) { this . threshold = threshold ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	0	['23', '2', '0', '13', '49', '201', '2', '13', '21', '0.918181818', '266', '1', '0', '0.545454545', '0.176767677', '1', '1', '10.13043478', '1', '0.8696', '0']
package org . apache . camel . builder ; import org . apache . camel . Processor ; import org . apache . camel . spi . RouteContext ; public class NoErrorHandlerBuilder extends ErrorHandlerBuilderSupport { public ErrorHandlerBuilder copy ( ) { return this ; } public Processor createErrorHandler ( RouteContext routeContext , Processor processor ) { return processor ; } } 	1	['3', '2', '0', '6', '4', '3', '2', '4', '3', '2', '10', '0', '0', '0.666666667', '0.555555556', '0', '0', '2.333333333', '1', '0.6667', '1']
package org . apache . camel . component . file . remote ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . JSch ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . UserInfo ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; public class SftpEndpoint extends RemoteFileEndpoint < RemoteFileExchange > { protected final transient Log log = LogFactory . getLog ( getClass ( ) ) ; public SftpEndpoint ( String uri , RemoteFileComponent remoteFileComponent , RemoteFileConfiguration configuration ) { super ( uri , remoteFileComponent , configuration ) ; } public SftpEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public SftpProducer createProducer ( ) throws Exception { return new SftpProducer ( this , createSession ( ) ) ; } public SftpConsumer createConsumer ( Processor processor ) throws Exception { final SftpConsumer consumer = new SftpConsumer ( this , processor , createSession ( ) ) ; configureConsumer ( consumer ) ; return consumer ; } protected Session createSession ( ) throws JSchException { final JSch jsch = new JSch ( ) ; String privateKeyFile = getConfiguration ( ) . getPrivateKeyFile ( ) ; if ( isNotNullAndNonEmpty ( privateKeyFile ) ) { log . debug ( "Using private keyfile: " + privateKeyFile ) ; String privateKeyFilePassphrase = getConfiguration ( ) . getPrivateKeyFilePassphrase ( ) ; if ( isNotNullAndNonEmpty ( privateKeyFilePassphrase ) ) { jsch . addIdentity ( privateKeyFile , privateKeyFilePassphrase ) ; } else { jsch . addIdentity ( privateKeyFile ) ; } } String knownHostsFile = getConfiguration ( ) . getKnownHosts ( ) ; if ( isNotNullAndNonEmpty ( knownHostsFile ) ) { log . debug ( "Using knownHosts: " + knownHostsFile ) ; jsch . setKnownHosts ( knownHostsFile ) ; } final Session session = jsch . getSession ( getConfiguration ( ) . getUsername ( ) , getConfiguration ( ) . getHost ( ) , getConfiguration ( ) . getPort ( ) ) ; session . setUserInfo ( new UserInfo ( ) { public String getPassphrase ( ) { return null ; } public String getPassword ( ) { return getConfiguration ( ) . getPassword ( ) ; } public boolean promptPassword ( String string ) { return true ; } public boolean promptPassphrase ( String string ) { return true ; } public boolean promptYesNo ( String string ) { log . error ( string ) ; return false ; } public void showMessage ( String string ) { } } ) ; return session ; } public ChannelSftp createChannelSftp ( Session session ) throws JSchException { final ChannelSftp channel = ( ChannelSftp ) session . openChannel ( "sftp" ) ; return channel ; } } 	0	['8', '4', '0', '18', '33', '22', '4', '18', '7', '0.142857143', '141', '1', '0', '0.872340426', '0.3125', '0', '0', '16.5', '1', '0.75', '0']
package org . apache . camel ; import java . util . Map ; public interface ProducerTemplate < E extends Exchange > extends Service { E send ( E exchange ) ; E send ( Processor processor ) ; Object sendBody ( Object body ) ; Object sendBodyAndHeader ( Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) ; E send ( String endpointUri , E exchange ) ; E send ( String endpointUri , Processor processor ) ; E send ( String endpointUri , ExchangePattern pattern , Processor processor ) ; E send ( String endpointUri , Processor processor , AsyncCallback callback ) ; E send ( Endpoint < E > endpoint , E exchange ) ; E send ( Endpoint < E > endpoint , Processor processor ) ; E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) ; E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) ; Object sendBody ( Endpoint < E > endpoint , Object body ) ; Object sendBody ( String endpointUri , Object body ) ; Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) ; Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) ; Object sendBodyAndHeader ( String endpointUri , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint < E > endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers ) ; Object sendBodyAndHeaders ( Endpoint < E > endpoint , Object body , Map < String , Object > headers ) ; Object sendBodyAndHeaders ( String endpointUri , ExchangePattern pattern , Object body , Map < String , Object > headers ) ; Object sendBodyAndHeaders ( Endpoint < E > endpoint , ExchangePattern pattern , Object body , Map < String , Object > headers ) ; E request ( Endpoint < E > endpoint , Processor processor ) ; Exchange request ( String endpointUri , Processor processor ) ; Object requestBody ( Endpoint < E > endpoint , Object body ) ; Object requestBody ( String endpointUri , Object body ) ; Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) ; Object requestBodyAndHeader ( String endpointUri , Object body , String header , Object headerValue ) ; Object requestBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers ) ; Object requestBodyAndHeaders ( Endpoint < E > endpoint , Object body , Map < String , Object > headers ) ; } 	1	['33', '1', '0', '17', '33', '528', '11', '6', '33', '2', '33', '0', '0', '0', '0.387205387', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; public class DefaultAnnotationExpressionFactory implements AnnotationExpressionFactory { public Expression createExpression ( CamelContext camelContext , Annotation annotation , LanguageAnnotation languageAnnotation , Class expressionReturnType ) { String languageName = languageAnnotation . language ( ) ; if ( languageName == null ) { throw new IllegalArgumentException ( "Cannot determine the language from the annotation: " + annotation ) ; } Language language = camelContext . resolveLanguage ( languageName ) ; if ( language == null ) { throw new IllegalArgumentException ( "Cannot find the language: " + languageName + " on the classpath" ) ; } String expression = getExpressionFromAnnotation ( annotation ) ; return language . createExpression ( expression ) ; } protected String getExpressionFromAnnotation ( Annotation annotation ) { try { Method method = annotation . getClass ( ) . getMethod ( "value" ) ; Object value = ObjectHelper . invokeMethod ( method , annotation ) ; if ( value == null ) { throw new IllegalArgumentException ( "Cannot determine the expression from the annotation: " + annotation ) ; } return value . toString ( ) ; } catch ( NoSuchMethodException e ) { throw new IllegalArgumentException ( "Cannot determine the expression of the annotation: " + annotation + " as it does not have an value() method" ) ; } } } 	0	['3', '1', '2', '8', '16', '3', '2', '6', '2', '2', '96', '0', '0', '0', '0.533333333', '0', '0', '31', '3', '1.6667', '0']
package org . apache . camel . processor ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class TryProcessor extends ServiceSupport implements Processor { private static final transient Log LOG = LogFactory . getLog ( TryProcessor . class ) ; private final Processor tryProcessor ; private final List < CatchProcessor > catchClauses ; private final Processor finallyProcessor ; public TryProcessor ( Processor tryProcessor , List < CatchProcessor > catchClauses , Processor finallyProcessor ) { this . tryProcessor = tryProcessor ; this . catchClauses = catchClauses ; this . finallyProcessor = finallyProcessor ; } public String toString ( ) { String finallyText = ( finallyProcessor == null ) ? "" : " Finally {" + finallyProcessor + "}" ; return "Try {" + tryProcessor + "} " + catchClauses + finallyText ; } public void process ( Exchange exchange ) throws Exception { Throwable e = null ; try { tryProcessor . process ( exchange ) ; e = exchange . getException ( ) ; if ( e != null && DeadLetterChannel . isFailureHandled ( exchange ) ) { e = null ; } } catch ( Throwable ex ) { e = ex ; exchange . setException ( e ) ; } Exception unexpected = null ; try { if ( e != null ) { LOG . info ( "Caught exception while processing exchange." , e ) ; handleException ( exchange , e ) ; } } catch ( Exception ex ) { unexpected = ex ; } catch ( Throwable ex ) { unexpected = wrapRuntimeCamelException ( ex ) ; } finally { try { processFinally ( exchange ) ; } catch ( Exception ex ) { unexpected = ex ; } catch ( Throwable ex ) { unexpected = wrapRuntimeCamelException ( ex ) ; } if ( unexpected != null ) { LOG . warn ( "Caught exception inside processFinally clause." , unexpected ) ; throw unexpected ; } } if ( unexpected != null ) { LOG . warn ( "Caught exception inside handle clause." , unexpected ) ; throw unexpected ; } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( tryProcessor , catchClauses , finallyProcessor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( tryProcessor , catchClauses , finallyProcessor ) ; } protected void handleException ( Exchange exchange , Throwable e ) throws Throwable { for ( CatchProcessor catchClause : catchClauses ) { if ( catchClause . catches ( e ) ) { Exchange localExchange = exchange . copy ( ) ; localExchange . getIn ( ) . setHeader ( "caught.exception" , e ) ; localExchange . setException ( null ) ; catchClause . process ( localExchange ) ; localExchange . getIn ( ) . removeHeader ( "caught.exception" ) ; ExchangeHelper . copyResults ( exchange , localExchange ) ; return ; } } } protected void processFinally ( Exchange exchange ) throws Throwable { if ( finallyProcessor != null ) { Throwable lastException = exchange . getException ( ) ; exchange . setException ( null ) ; finallyProcessor . process ( exchange ) ; if ( exchange . getException ( ) == null ) { exchange . setException ( lastException ) ; } } } } 	1	['8', '2', '0', '13', '33', '0', '1', '12', '3', '0.464285714', '294', '1', '2', '0.7', '0.371428571', '1', '1', '35.25', '2', '0.875', '8']
package org . apache . camel . view ; import java . io . PrintWriter ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . model . FromType ; import org . apache . camel . model . MulticastType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; public class XmlGraphGenerator extends GraphGeneratorSupport { private boolean addUrl = true ; public XmlGraphGenerator ( String dir ) { super ( dir , ".xml" ) ; } protected void generateFile ( PrintWriter writer , Map < String , List < RouteType > > map ) { writer . println ( "<?xml version='1.0' encoding='UTF-8'?>" ) ; writer . println ( "<Graph>" ) ; writer . println ( ) ; if ( map . size ( ) > 0 ) { writer . println ( "<Node id='root' name='Camel Routes' description='Collection of Camel Routes' nodeType='root'/>" ) ; } printRoutes ( writer , map ) ; writer . println ( ) ; writer . println ( "</Graph>" ) ; } protected void printRoutes ( PrintWriter writer , Map < String , List < RouteType > > map ) { Set < Map . Entry < String , List < RouteType > > > entries = map . entrySet ( ) ; for ( Map . Entry < String , List < RouteType > > entry : entries ) { String group = entry . getKey ( ) ; printRoutes ( writer , group , entry . getValue ( ) ) ; } } protected void printRoutes ( PrintWriter writer , String group , List < RouteType > routes ) { group = encode ( group ) ; if ( group != null ) { int idx = group . lastIndexOf ( '.' ) ; String name = group ; if ( idx > 0 && idx < group . length ( ) - 1 ) { name = group . substring ( idx + 1 ) ; } writer . println ( "<Node id='" + group + "' name='" + name + "' description='" + group + "' nodeType='group'/>" ) ; writer . println ( "<Edge fromID='root' toID='" + group + "'/>" ) ; } for ( RouteType route : routes ) { List < FromType > inputs = route . getInputs ( ) ; boolean first = true ; for ( FromType input : inputs ) { NodeData nodeData = getNodeData ( input ) ; if ( first ) { first = false ; if ( group != null ) { writer . println ( "<Edge fromID='" + group + "' toID='" + encode ( nodeData . id ) + "'/>" ) ; } } printRoute ( writer , route , nodeData ) ; } writer . println ( ) ; } } protected void printRoute ( PrintWriter writer , final RouteType route , NodeData nodeData ) { printNode ( writer , nodeData ) ; NodeData from = nodeData ; for ( ProcessorType output : route . getOutputs ( ) ) { NodeData newData = printNode ( writer , from , output ) ; from = newData ; } } protected NodeData printNode ( PrintWriter writer , NodeData fromData , ProcessorType node ) { if ( node instanceof MulticastType ) { List < ProcessorType > outputs = node . getOutputs ( ) ; for ( ProcessorType output : outputs ) { printNode ( writer , fromData , output ) ; } return fromData ; } NodeData toData = getNodeData ( node ) ; printNode ( writer , toData ) ; if ( fromData != null ) { writer . print ( "<Edge fromID=\"" ) ; writer . print ( encode ( fromData . id ) ) ; writer . print ( "\" toID=\"" ) ; writer . print ( encode ( toData . id ) ) ; String association = toData . edgeLabel ; if ( isNullOrBlank ( association ) ) { writer . print ( "\" association=\"" ) ; writer . print ( encode ( association ) ) ; } writer . println ( "\"/>" ) ; } List < ProcessorType > outputs = toData . outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { NodeData newData = printNode ( writer , toData , output ) ; if ( ! isMulticastNode ( node ) ) { toData = newData ; } } } return toData ; } protected void printNode ( PrintWriter writer , NodeData data ) { if ( ! data . nodeWritten ) { data . nodeWritten = true ; writer . println ( ) ; writer . print ( "<Node id=\"" ) ; writer . print ( encode ( data . id ) ) ; writer . print ( "\" name=\"" ) ; String name = data . label ; if ( isNullOrBlank ( name ) ) { name = data . tooltop ; } writer . print ( encode ( name ) ) ; writer . print ( "\" nodeType=\"" ) ; String nodeType = data . image ; if ( isNullOrBlank ( nodeType ) ) { nodeType = data . shape ; if ( isNullOrBlank ( nodeType ) ) { nodeType = "node" ; } } writer . print ( encode ( nodeType ) ) ; writer . print ( "\" description=\"" ) ; writer . print ( encode ( data . tooltop ) ) ; if ( addUrl ) { writer . print ( "\" url=\"" ) ; writer . print ( encode ( data . url ) ) ; } writer . println ( "\"/>" ) ; } } protected String encode ( String text ) { if ( text == null ) { return "" ; } return text . replaceAll ( "\"" , "&quot;" ) . replaceAll ( "<" , "&lt;" ) . replaceAll ( ">" , "&gt;" ) . replaceAll ( "&" , "&amp;" ) ; } } 	0	['8', '2', '0', '7', '33', '26', '0', '7', '1', '0.571428571', '415', '1', '0', '0.588235294', '0.390625', '1', '1', '50.75', '8', '3.625', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class RandomLoadBalancer extends QueueLoadBalancer { protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { int size = processors . size ( ) ; while ( true ) { int index = ( int ) Math . round ( Math . random ( ) * size ) ; if ( index < size ) { return processors . get ( index ) ; } } } } 	1	['2', '4', '0', '5', '7', '1', '2', '3', '1', '2', '24', '0', '0', '0.956521739', '0.666666667', '1', '1', '11', '1', '0.5', '1']
package org . apache . camel . impl . converter ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . TypeConverter ; import org . apache . camel . processor . DelegateProcessor ; public class AsyncProcessorTypeConverter implements TypeConverter { private static final class ProcessorToAsyncProcessorBridge extends DelegateProcessor implements AsyncProcessor { private ProcessorToAsyncProcessorBridge ( Processor processor ) { super ( processor ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { try { processor . process ( exchange ) ; } catch ( Throwable e ) { exchange . setException ( e ) ; } callback . done ( true ) ; return true ; } } public < T > T convertTo ( Class < T > toType , Object value ) { if ( value != null ) { if ( toType . equals ( AsyncProcessor . class ) ) { if ( value instanceof AsyncProcessor ) { return toType . cast ( value ) ; } else if ( value instanceof Processor ) { final Processor processor = ( Processor ) value ; return toType . cast ( new ProcessorToAsyncProcessorBridge ( processor ) ) ; } } } return null ; } public < T > T convertTo ( Class < T > toType , Exchange exchange , Object value ) { return convertTo ( toType , value ) ; } public static AsyncProcessor convert ( Processor value ) { if ( value instanceof AsyncProcessor ) { return ( AsyncProcessor ) value ; } return new ProcessorToAsyncProcessorBridge ( value ) ; } } 	0	['4', '1', '0', '17', '8', '6', '11', '6', '4', '2', '53', '0', '0', '0', '0.45', '0', '0', '12.25', '5', '2', '0']
package org . apache . camel . component . bean ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . builder . ExpressionBuilder ; public class DefaultParameterMappingStrategy implements ParameterMappingStrategy { private Map < Class , Expression > parameterTypeToExpressionMap = new ConcurrentHashMap < Class , Expression > ( ) ; public DefaultParameterMappingStrategy ( ) { loadDefaultRegistry ( ) ; } public synchronized Expression getDefaultParameterTypeExpression ( Class parameterType ) { Expression expression = parameterTypeToExpressionMap . get ( parameterType ) ; return expression ; } public synchronized void addParameterMapping ( Class parameterType , Expression expression ) { parameterTypeToExpressionMap . put ( parameterType , expression ) ; } public void loadDefaultRegistry ( ) { addParameterMapping ( Exchange . class , ExpressionBuilder . exchangeExpression ( ) ) ; addParameterMapping ( Message . class , ExpressionBuilder . inMessageExpression ( ) ) ; } } 	1	['4', '1', '0', '4', '10', '0', '1', '3', '4', '0', '39', '1', '0', '0', '0.583333333', '0', '0', '8.5', '1', '0.75', '2']
package org . apache . camel . component . irc ; public class IrcBinding { public Object extractBodyFromIrc ( IrcExchange exchange , IrcMessage message ) { String type = message . getMessageType ( ) ; String text = message . getMessage ( ) ; if ( text != null ) { return text ; } else { return type ; } } } 	0	['2', '1', '0', '3', '5', '1', '3', '2', '2', '2', '17', '0', '0', '0', '0.666666667', '0', '0', '7.5', '2', '1', '0']
package org . apache . camel ; public class CamelExchangeException extends CamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final Exchange exchange ; public CamelExchangeException ( String message , Exchange exchange ) { super ( createMessage ( message , exchange ) ) ; this . exchange = exchange ; } public CamelExchangeException ( String message , Exchange exchange , Throwable cause ) { super ( createMessage ( message , exchange ) , cause ) ; this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } protected static String createMessage ( String message , Exchange exchange ) { return message + " on the exchange: " + exchange ; } } 	1	['4', '4', '8', '13', '10', '0', '11', '2', '3', '0.833333333', '39', '1', '1', '0.894736842', '0.625', '0', '0', '8.25', '1', '0.5', '1']
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . ProcessRules ; public class ProcessContext { private Exchange exchange ; private ProcessRules processRules ; private ActivityRules activityRules ; private ProcessInstance processInstance ; private ActivityState activityState ; public ProcessContext ( Exchange exchange , ActivityRules activityRules , ActivityState activityState ) { this . exchange = exchange ; this . activityRules = activityRules ; this . activityState = activityState ; this . processRules = activityRules . getProcessRules ( ) ; this . processInstance = activityState . getProcessInstance ( ) ; } public ActivityRules getActivity ( ) { return activityRules ; } public void setActivity ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public ActivityState getActivityState ( ) { return activityState ; } public void setActivityState ( ActivityState activityState ) { this . activityState = activityState ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public ProcessRules getProcessDefinition ( ) { return processRules ; } public void setProcessDefinition ( ProcessRules processRules ) { this . processRules = processRules ; } public ProcessInstance getProcessInstance ( ) { return processInstance ; } public void setProcessInstance ( ProcessInstance processInstance ) { this . processInstance = processInstance ; } public ActivityState getActivityState ( ActivityRules activityRules ) { return getProcessInstance ( ) . getActivityState ( activityRules ) ; } public void onStarted ( ActivityState activityState ) { } public void onCompleted ( ActivityState activityState ) { } } 	0	['14', '1', '0', '6', '18', '61', '2', '5', '14', '0.830769231', '81', '1', '5', '0', '0.297619048', '0', '0', '4.428571429', '1', '0.9286', '0']
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Predicate ; import org . apache . camel . Route ; import org . apache . camel . Routes ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . ChoiceType ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . model . InterceptType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . RoutesType ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . interceptor . StreamCachingInterceptor ; public abstract class RouteBuilder extends BuilderSupport implements Routes { private AtomicBoolean initialized = new AtomicBoolean ( false ) ; private RoutesType routeCollection = new RoutesType ( ) ; private List < Route > routes = new ArrayList < Route > ( ) ; public RouteBuilder ( ) { this ( null ) ; } public RouteBuilder ( CamelContext context ) { super ( context ) ; } @ Override public String toString ( ) { return routeCollection . toString ( ) ; } public abstract void configure ( ) throws Exception ; public RouteType from ( String uri ) { RouteType answer = routeCollection . from ( uri ) ; configureRoute ( answer ) ; return answer ; } public RouteType from ( Endpoint endpoint ) { RouteType answer = routeCollection . from ( endpoint ) ; configureRoute ( answer ) ; return answer ; } public RouteBuilder errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return this ; } public RouteBuilder inheritErrorHandler ( boolean value ) { routeCollection . setInheritErrorHandlerFlag ( value ) ; return this ; } public RouteBuilder intercept ( DelegateProcessor interceptor ) { routeCollection . intercept ( interceptor ) ; return this ; } public InterceptType intercept ( ) { return routeCollection . intercept ( ) ; } public ChoiceType intercept ( Predicate predicate ) { return routeCollection . intercept ( predicate ) ; } public ExceptionType onException ( Class exceptionType ) { return routeCollection . onException ( exceptionType ) ; } public ExceptionType onException ( Class ... exceptions ) { ExceptionType last = null ; for ( Class ex : exceptions ) { last = last == null ? onException ( ex ) : last . onException ( ex ) ; } return last != null ? last : onException ( Exception . class ) ; } public ExceptionType exception ( Class exceptionType ) { return onException ( exceptionType ) ; } public CamelContext getContext ( ) { CamelContext context = super . getContext ( ) ; if ( context == null ) { context = createContainer ( ) ; setContext ( context ) ; } return context ; } public List < Route > getRouteList ( ) throws Exception { checkInitialized ( ) ; return routes ; } @ Override public void setInheritErrorHandler ( boolean inheritErrorHandler ) { super . setInheritErrorHandler ( inheritErrorHandler ) ; routeCollection . setInheritErrorHandlerFlag ( inheritErrorHandler ) ; } @ Override public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { super . setErrorHandlerBuilder ( errorHandlerBuilder ) ; routeCollection . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } protected void checkInitialized ( ) throws Exception { if ( initialized . compareAndSet ( false , true ) ) { CamelContext camelContext = getContext ( ) ; if ( camelContext . getErrorHandlerBuilder ( ) != null ) { setErrorHandlerBuilder ( camelContext . getErrorHandlerBuilder ( ) ) ; } configure ( ) ; populateRoutes ( routes ) ; } } protected void populateRoutes ( List < Route > routes ) throws Exception { CamelContext camelContext = getContext ( ) ; if ( camelContext == null ) { throw new IllegalArgumentException ( "No CamelContext has been injected!" ) ; } routeCollection . setCamelContext ( camelContext ) ; camelContext . addRouteDefinitions ( routeCollection . getRoutes ( ) ) ; } public void setRouteCollection ( RoutesType routeCollection ) { this . routeCollection = routeCollection ; } public RoutesType getRouteCollection ( ) { return this . routeCollection ; } public void noStreamCaching ( ) { StreamCachingInterceptor . noStreamCaching ( routeCollection . getInterceptors ( ) ) ; } public void streamCaching ( ) { routeCollection . intercept ( new StreamCachingInterceptor ( ) ) ; } protected CamelContext createContainer ( ) { return new DefaultCamelContext ( ) ; } protected void configureRoute ( RouteType route ) { route . setGroup ( getClass ( ) . getName ( ) ) ; } protected void addRoutes ( Routes routes ) throws Exception { getContext ( ) . addRoutes ( routes ) ; } } 	1	['27', '2', '6', '26', '61', '105', '12', '14', '22', '0.666666667', '265', '1', '1', '0.537037037', '0.113756614', '1', '3', '8.703703704', '4', '1.0741', '8']
package org . apache . camel . processor . resequencer ; import java . util . Timer ; public class ResequencerEngine < E > { private Element < E > lastDelivered ; private long timeout ; private Sequence < Element < E > > sequence ; private Timer timer ; private SequenceSender < E > sequenceSender ; public ResequencerEngine ( SequenceElementComparator < E > comparator ) { this . sequence = createSequence ( comparator ) ; this . timeout = 2000L ; this . lastDelivered = null ; } public void start ( ) { timer = new Timer ( "Stream Resequencer Timer" ) ; } public void stop ( ) { timer . cancel ( ) ; } public synchronized int size ( ) { return sequence . size ( ) ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public SequenceSender < E > getSequenceSender ( ) { return sequenceSender ; } public void setSequenceSender ( SequenceSender < E > sequenceSender ) { this . sequenceSender = sequenceSender ; } E getLastDelivered ( ) { if ( lastDelivered == null ) { return null ; } return lastDelivered . getObject ( ) ; } void setLastDelivered ( E o ) { lastDelivered = new Element < E > ( o ) ; } public synchronized void insert ( E o ) { Element < E > element = new Element < E > ( o ) ; sequence . add ( element ) ; Element < E > successor = sequence . successor ( element ) ; if ( successor != null ) { successor . cancel ( ) ; } if ( successorOfLastDelivered ( element ) ) { } else if ( sequence . predecessor ( element ) != null ) { } else { element . schedule ( defineTimeout ( ) ) ; } } public synchronized void deliver ( ) throws Exception { while ( deliverNext ( ) ) { } } public boolean deliverNext ( ) throws Exception { if ( sequence . size ( ) == 0 ) { return false ; } Element < E > element = sequence . first ( ) ; if ( element . scheduled ( ) ) { return false ; } sequence . remove ( element ) ; lastDelivered = element ; sequenceSender . sendElement ( element . getObject ( ) ) ; return true ; } private boolean successorOfLastDelivered ( Element < E > element ) { if ( lastDelivered == null ) { return false ; } if ( sequence . comparator ( ) . successor ( element , lastDelivered ) ) { return true ; } return false ; } private Timeout defineTimeout ( ) { return new Timeout ( timer , timeout ) ; } private static < E > Sequence < Element < E > > createSequence ( SequenceElementComparator < E > comparator ) { return new Sequence < Element < E > > ( new ElementComparator < E > ( comparator ) ) ; } } 	0	['16', '1', '0', '8', '36', '62', '2', '6', '11', '0.72', '184', '1', '3', '0', '0.229166667', '0', '0', '10.1875', '4', '1.3125', '0']
package org . apache . camel . spi ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; public interface InterceptStrategy { Processor wrapProcessorInInterceptors ( ProcessorType processorType , Processor target ) throws Exception ; } 	1	['1', '1', '0', '14', '1', '0', '13', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . camel ; public class RuntimeCamelException extends RuntimeException { private static final long serialVersionUID = 8046489554418284257L ; public RuntimeCamelException ( ) { } public RuntimeCamelException ( String message ) { super ( message ) ; } public RuntimeCamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeCamelException ( Throwable cause ) { super ( cause ) ; } } 	0	['4', '4', '17', '66', '8', '6', '66', '0', '4', '1.333333333', '21', '1', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . camel ; public class FailedToCreateProducerException extends RuntimeCamelException { private final Endpoint endpoint ; public FailedToCreateProducerException ( Endpoint endpoint , Throwable cause ) { super ( "Failed to create Producer for endpoint: " + endpoint + ". Reason: " + cause , cause ) ; this . endpoint = endpoint ; } public Endpoint getEndpoint ( ) { return endpoint ; } } 	1	['2', '5', '0', '4', '7', '0', '2', '2', '2', '0', '25', '1', '1', '0.944444444', '0.666666667', '0', '0', '11', '1', '0.5', '1']
package org . apache . camel . processor . resequencer ; class Element < E > implements TimeoutHandler { private E object ; private Timeout timeout ; public Element ( E object ) { this . object = object ; } public E getObject ( ) { return object ; } public synchronized boolean scheduled ( ) { return timeout != null ; } public synchronized void schedule ( Timeout t ) { this . timeout = t ; this . timeout . setTimeoutHandler ( this ) ; this . timeout . schedule ( ) ; } public synchronized void cancel ( ) { if ( timeout != null ) { timeout . cancel ( ) ; } timeout ( null ) ; } public synchronized void timeout ( Timeout t ) { this . timeout = null ; } } 	0	['6', '1', '0', '4', '10', '1', '2', '2', '6', '0.6', '50', '1', '1', '0', '0.5', '0', '0', '7', '2', '1.1667', '0']
package org . apache . camel . model . dataformat ; import java . util . zip . Deflater ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "zip" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ZipDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private int compressionLevel = Deflater . BEST_SPEED ; public ZipDataFormat ( ) { } public ZipDataFormat ( int compressionLevel ) { this . compressionLevel = compressionLevel ; } @ Override protected DataFormat createDataFormat ( RouteContext routeContext ) { return new org . apache . camel . impl . ZipDataFormat ( compressionLevel ) ; } public int getCompressionLevel ( ) { return compressionLevel ; } public void setCompressionLevel ( int compressionLevel ) { this . compressionLevel = compressionLevel ; } } 	1	['5', '3', '0', '5', '7', '0', '1', '4', '4', '0', '34', '1', '0', '0.75', '0.533333333', '1', '1', '5.6', '1', '0.6', '1']
package org . apache . camel . impl . converter ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; public class ArrayTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isArray ( ) ) { if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; Object array = Array . newInstance ( type . getComponentType ( ) , collection . size ( ) ) ; if ( array instanceof Object [ ] ) { collection . toArray ( ( Object [ ] ) array ) ; } else { int index = 0 ; for ( Object element : collection ) { Array . set ( array , index ++ , element ) ; } } return ( T ) array ; } else if ( value != null && value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; Object answer = Array . newInstance ( type . getComponentType ( ) , size ) ; for ( int i = 0 ; i < size ; i ++ ) { Array . set ( answer , i , Array . get ( value , i ) ) ; } return ( T ) answer ; } } else if ( Collection . class . isAssignableFrom ( type ) ) { if ( value != null ) { if ( value instanceof Object [ ] ) { return ( T ) Arrays . asList ( ( Object [ ] ) value ) ; } else if ( value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; List answer = new ArrayList ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { answer . add ( Array . get ( value , i ) ) ; } return ( T ) answer ; } } } return null ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return convertTo ( type , value ) ; } } 	0	['3', '1', '0', '3', '20', '3', '1', '2', '3', '2', '127', '0', '0', '0', '0.666666667', '0', '0', '41.33333333', '13', '4.6667', '0']
package org . apache . camel . util ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . spi . Injector ; public class FactoryFinder { protected final ConcurrentHashMap < String , Class > classMap = new ConcurrentHashMap < String , Class > ( ) ; private final String path ; public FactoryFinder ( ) { this ( "META-INF/services/org/apache/camel/" ) ; } public FactoryFinder ( String path ) { this . path = path ; } public Object newInstance ( String key ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { return newInstance ( key , ( String ) null ) ; } public Object newInstance ( String key , String propertyPrefix ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { Class clazz = findClass ( key , propertyPrefix ) ; return clazz . newInstance ( ) ; } public Object newInstance ( String key , Injector injector ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , ( String ) null ) ; } public Object newInstance ( String key , Injector injector , String propertyPrefix ) throws IOException , ClassNotFoundException { Class < ? > type = findClass ( key , propertyPrefix ) ; return injector . newInstance ( type ) ; } public < T > T newInstance ( String key , Injector injector , Class < T > expectedType ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , null , expectedType ) ; } public < T > T newInstance ( String key , Injector injector , String propertyPrefix , Class < T > expectedType ) throws IOException , ClassNotFoundException { Class < ? > type = findClass ( key , propertyPrefix ) ; Object value = injector . newInstance ( type ) ; if ( expectedType . isInstance ( value ) ) { return expectedType . cast ( value ) ; } else { throw new ClassCastException ( "Not instanceof " + expectedType . getName ( ) + " value: " + value ) ; } } public < T > List < T > newInstances ( String key , Injector injector , Class < T > type ) throws IOException , ClassNotFoundException { List < Class > list = findClasses ( key ) ; List < T > answer = new ArrayList < T > ( list . size ( ) ) ; answer . add ( newInstance ( key , injector , type ) ) ; return answer ; } public Class findClass ( String key ) throws ClassNotFoundException , IOException { return findClass ( key , null ) ; } public Class findClass ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { if ( propertyPrefix == null ) { propertyPrefix = "" ; } Class clazz = ( Class ) classMap . get ( propertyPrefix + key ) ; if ( clazz == null ) { clazz = newInstance ( doFindFactoryProperties ( key ) , propertyPrefix ) ; if ( clazz != null ) { classMap . put ( propertyPrefix + key , clazz ) ; } } return clazz ; } public List < Class > findClasses ( String key ) throws ClassNotFoundException , IOException { return findClasses ( key , null ) ; } public List < Class > findClasses ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { Class type = findClass ( key , propertyPrefix ) ; return Collections . singletonList ( type ) ; } public String getPath ( ) { return path ; } private Class newInstance ( Properties properties , String propertyPrefix ) throws ClassNotFoundException , IOException { String className = properties . getProperty ( propertyPrefix + "class" ) ; if ( className == null ) { throw new IOException ( "Expected property is missing: " + propertyPrefix + "class" ) ; } return ObjectHelper . loadClass ( className ) ; } private Properties doFindFactoryProperties ( String key ) throws IOException { String uri = path + key ; InputStream in = ObjectHelper . loadResourceAsStream ( uri ) ; if ( in == null ) { throw new NoFactoryAvailableException ( uri ) ; } BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( in ) ; Properties properties = new Properties ( ) ; properties . load ( reader ) ; return properties ; } finally { ObjectHelper . close ( reader , key , null ) ; ObjectHelper . close ( in , key , null ) ; } } } 	1	['16', '1', '1', '11', '43', '112', '7', '4', '14', '0.6', '275', '1', '0', '0', '0.4875', '0', '0', '16.0625', '1', '0.875', '1']
package org . apache . camel . component . xquery ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . language . NamespacePrefix ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "xquery" , factory = XQueryAnnotationExpressionFactory . class ) public @ interface XQuery { String value ( ) ; NamespacePrefix [ ] namespaces ( ) default { @ NamespacePrefix ( prefix = "soap" , uri = "http://www.w3.org/2003/05/soap-envelope" ) , @ NamespacePrefix ( prefix = "xsd" , uri = "http://www.w3.org/2001/XMLSchema" ) } ; } 	0	['2', '1', '0', '2', '2', '1', '1', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; public abstract class DefaultPollingEndpoint < E extends Exchange > extends ScheduledPollEndpoint < E > { protected DefaultPollingEndpoint ( ) { } protected DefaultPollingEndpoint ( String endpointUri ) { super ( endpointUri ) ; } protected DefaultPollingEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } protected DefaultPollingEndpoint ( String endpointUri , CamelContext context ) { super ( endpointUri , context ) ; } public Consumer < E > createConsumer ( Processor processor ) throws Exception { DefaultScheduledPollConsumer result = new DefaultScheduledPollConsumer ( this , processor ) ; configureConsumer ( result ) ; return result ; } } 	1	['5', '3', '4', '11', '11', '10', '4', '7', '1', '2', '33', '0', '0', '0.965517241', '0.44', '0', '0', '5.6', '1', '0.2', '1']
package org . apache . camel . component . mina ; import org . apache . camel . Exchange ; public final class MinaPayloadHelper { private MinaPayloadHelper ( ) { } public static Object getIn ( MinaEndpoint endpoint , Exchange exchange ) { if ( endpoint . isTransferExchange ( ) ) { return MinaPayloadHolder . marshal ( exchange ) ; } else { return exchange . getIn ( ) . getBody ( ) ; } } public static Object getOut ( MinaEndpoint endpoint , Exchange exchange ) { if ( endpoint . isTransferExchange ( ) ) { return MinaPayloadHolder . marshal ( exchange ) ; } else { return exchange . getOut ( ) . getBody ( ) ; } } public static void setIn ( Exchange exchange , Object payload ) { if ( payload instanceof MinaPayloadHolder ) { MinaPayloadHolder . unmarshal ( exchange , ( MinaPayloadHolder ) payload ) ; } else { exchange . getIn ( ) . setBody ( payload ) ; } } public static void setOut ( Exchange exchange , Object payload ) { if ( payload instanceof MinaPayloadHolder ) { MinaPayloadHolder . unmarshal ( exchange , ( MinaPayloadHolder ) payload ) ; } else { exchange . getOut ( ) . setHeaders ( exchange . getIn ( ) . getHeaders ( ) ) ; exchange . getOut ( ) . setBody ( payload ) ; } } } 	0	['5', '1', '0', '6', '15', '10', '3', '4', '4', '2', '60', '0', '0', '0', '0.45', '0', '0', '11', '2', '1.6', '0']
package org . apache . camel . impl ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . AsyncCallback ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class DefaultProducerTemplate < E extends Exchange > extends ServiceSupport implements ProducerTemplate < E > { private CamelContext context ; private final ProducerCache < E > producerCache = new ProducerCache < E > ( ) ; private boolean useEndpointCache = true ; private final Map < String , Endpoint < E > > endpointCache = new HashMap < String , Endpoint < E > > ( ) ; private Endpoint < E > defaultEndpoint ; public DefaultProducerTemplate ( CamelContext context ) { this . context = context ; } public DefaultProducerTemplate ( CamelContext context , Endpoint defaultEndpoint ) { this ( context ) ; this . defaultEndpoint = defaultEndpoint ; } public static DefaultProducerTemplate newInstance ( CamelContext camelContext , String defaultEndpointUri ) { Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( camelContext , defaultEndpointUri ) ; return new DefaultProducerTemplate ( camelContext , endpoint ) ; } public E send ( String endpointUri , E exchange ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , exchange ) ; } public E send ( String endpointUri , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor ) ; } public E send ( String endpointUri , Processor processor , AsyncCallback callback ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor , callback ) ; } public E send ( String endpointUri , ExchangePattern pattern , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , pattern , processor ) ; } public E send ( Endpoint < E > endpoint , E exchange ) { E convertedExchange = exchange ; producerCache . send ( endpoint , convertedExchange ) ; return convertedExchange ; } public E send ( Endpoint < E > endpoint , Processor processor ) { return producerCache . send ( endpoint , processor ) ; } public E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) { return producerCache . send ( endpoint , processor , callback ) ; } public E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) { return producerCache . send ( endpoint , pattern , processor ) ; } public Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) { E result = send ( endpoint , pattern , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result , pattern ) ; } public Object sendBody ( Endpoint < E > endpoint , Object body ) { E result = send ( endpoint , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , body ) ; } public Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , pattern , body ) ; } public Object sendBodyAndHeader ( String endpointUri , final Object body , final String header , final Object headerValue ) { return sendBodyAndHeader ( resolveMandatoryEndpoint ( endpointUri ) , body , header , headerValue ) ; } public Object sendBodyAndHeader ( Endpoint < E > endpoint , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeader ( Endpoint < E > endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result , pattern ) ; } public Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result , pattern ) ; } public Object sendBodyAndHeaders ( String endpointUri , final Object body , final Map < String , Object > headers ) { return sendBodyAndHeaders ( resolveMandatoryEndpoint ( endpointUri ) , body , headers ) ; } public Object sendBodyAndHeaders ( Endpoint < E > endpoint , final Object body , final Map < String , Object > headers ) { E result = send ( endpoint , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; for ( Map . Entry < String , Object > header : headers . entrySet ( ) ) { in . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; } in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeaders ( String endpointUri , ExchangePattern pattern , Object body , Map < String , Object > headers ) { return sendBodyAndHeaders ( resolveMandatoryEndpoint ( endpointUri ) , pattern , body , headers ) ; } public Object sendBodyAndHeaders ( Endpoint < E > endpoint , ExchangePattern pattern , final Object body , final Map < String , Object > headers ) { E result = send ( endpoint , pattern , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { Message in = exchange . getIn ( ) ; for ( Map . Entry < String , Object > header : headers . entrySet ( ) ) { in . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; } in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public E request ( Endpoint < E > endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( Endpoint < E > endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public E request ( String endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( String endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( String endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public Object requestBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers ) { return requestBodyAndHeaders ( resolveMandatoryEndpoint ( endpointUri ) , body , headers ) ; } public Object requestBodyAndHeaders ( Endpoint < E > endpoint , final Object body , final Map < String , Object > headers ) { return sendBodyAndHeaders ( endpoint , ExchangePattern . InOut , body , headers ) ; } public Object sendBody ( Object body ) { return sendBody ( getMandatoryDefaultEndpoint ( ) , body ) ; } public E send ( E exchange ) { return send ( getMandatoryDefaultEndpoint ( ) , exchange ) ; } public E send ( Processor processor ) { return send ( getMandatoryDefaultEndpoint ( ) , processor ) ; } public Object sendBodyAndHeader ( Object body , String header , Object headerValue ) { return sendBodyAndHeader ( getMandatoryDefaultEndpoint ( ) , body , header , headerValue ) ; } public Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) { return sendBodyAndHeaders ( getMandatoryDefaultEndpoint ( ) , body , headers ) ; } public Producer < E > getProducer ( Endpoint < E > endpoint ) { return producerCache . getProducer ( endpoint ) ; } public CamelContext getContext ( ) { return context ; } public Endpoint < E > getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( Endpoint < E > defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } public void setDefaultEndpointUri ( String endpointUri ) { setDefaultEndpoint ( getContext ( ) . getEndpoint ( endpointUri ) ) ; } public boolean isUseEndpointCache ( ) { return useEndpointCache ; } public void setUseEndpointCache ( boolean useEndpointCache ) { this . useEndpointCache = useEndpointCache ; } public < T extends Endpoint < ? > > T getResolvedEndpoint ( String endpointUri , Class < T > expectedClass ) { Endpoint < ? > e = null ; synchronized ( endpointCache ) { e = endpointCache . get ( endpointUri ) ; } if ( e != null && expectedClass . isAssignableFrom ( e . getClass ( ) ) ) { return expectedClass . asSubclass ( expectedClass ) . cast ( e ) ; } return null ; } protected Processor createBodyAndHeaderProcessor ( final Object body , final String header , final Object headerValue ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setHeader ( header , headerValue ) ; in . setBody ( body ) ; } } ; } protected Processor createSetBodyProcessor ( final Object body ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ; } protected Endpoint resolveMandatoryEndpoint ( String endpointUri ) { Endpoint endpoint = null ; if ( isUseEndpointCache ( ) ) { synchronized ( endpointCache ) { endpoint = endpointCache . get ( endpointUri ) ; if ( endpoint == null ) { endpoint = context . getEndpoint ( endpointUri ) ; if ( endpoint != null ) { endpointCache . put ( endpointUri , endpoint ) ; } } } } else { endpoint = context . getEndpoint ( endpointUri ) ; } if ( endpoint == null ) { throw new NoSuchEndpointException ( endpointUri ) ; } return endpoint ; } protected Endpoint < E > getMandatoryDefaultEndpoint ( ) { Endpoint < E > answer = getDefaultEndpoint ( ) ; ObjectHelper . notNull ( answer , "defaultEndpoint" ) ; return answer ; } protected void doStart ( ) throws Exception { producerCache . start ( ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; endpointCache . clear ( ) ; } protected Object extractResultBody ( E result ) { return extractResultBody ( result , null ) ; } protected Object extractResultBody ( E result , ExchangePattern pattern ) { Object answer = null ; if ( result != null ) { if ( result . getException ( ) != null ) { throw wrapRuntimeCamelException ( result . getException ( ) ) ; } if ( hasFaultMessage ( result ) ) { return result . getFault ( ) . getBody ( ) ; } boolean notOut = pattern != null && ! pattern . isOutCapable ( ) ; boolean hasOut = result . getOut ( false ) != null ; if ( hasOut && ! notOut ) { answer = result . getOut ( ) . getBody ( ) ; } else { answer = result . getIn ( ) . getBody ( ) ; } } return answer ; } protected boolean hasFaultMessage ( E result ) { Message faultMessage = result . getFault ( false ) ; if ( faultMessage != null ) { Object faultBody = faultMessage . getBody ( ) ; if ( faultBody != null ) { return true ; } } return false ; } } 	1	['53', '2', '1', '24', '87', '1296', '9', '19', '44', '0.684615385', '614', '1', '3', '0.215384615', '0.240566038', '1', '1', '10.49056604', '9', '1.2642', '5']
package org . apache . camel . component . cxf ; import java . io . OutputStream ; import javax . xml . transform . Source ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . component . cxf . util . CxfEndpointUtils ; import org . apache . camel . component . cxf . util . NullConduit ; import org . apache . camel . component . cxf . util . NullDestinationFactory ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . cxf . Bus ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . frontend . ServerFactoryBean ; import org . apache . cxf . interceptor . InterceptorChain ; import org . apache . cxf . interceptor . OutgoingChainInterceptor ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . transport . MessageObserver ; public class CxfSoapConsumer implements Consumer { private static final Log LOG = LogFactory . getLog ( CxfSoapConsumer . class ) ; private final CxfSoapEndpoint endpoint ; private final Consumer consumer ; private MessageObserver inMessageObserver ; private Server server ; public CxfSoapConsumer ( CxfSoapEndpoint endpoint , Processor processor ) throws Exception { this . endpoint = endpoint ; Processor soapProcessor = new AsyncProcessorDecorator ( processor , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapConsumerIn ( exchange ) ; } } , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapConsumerOut ( exchange ) ; } } ) ; this . consumer = endpoint . getInnerEndpoint ( ) . createConsumer ( soapProcessor ) ; Class sei = null ; if ( ObjectHelper . isNotEmpty ( endpoint . getServiceClass ( ) ) ) { sei = ClassLoaderUtils . loadClass ( endpoint . getServiceClass ( ) , this . getClass ( ) ) ; } ServerFactoryBean sfb = CxfEndpointUtils . getServerFactoryBean ( sei ) ; sfb . setWsdlURL ( endpoint . getWsdl ( ) . getURL ( ) . toString ( ) ) ; if ( endpoint . getServiceName ( ) != null ) { sfb . setServiceName ( endpoint . getServiceName ( ) ) ; } if ( endpoint . getEndpointName ( ) != null ) { sfb . setEndpointName ( endpoint . getEndpointName ( ) ) ; } sfb . setDestinationFactory ( new NullDestinationFactory ( ) ) ; sfb . setStart ( false ) ; server = sfb . create ( ) ; } public void start ( ) throws Exception { server . start ( ) ; inMessageObserver = server . getDestination ( ) . getMessageObserver ( ) ; consumer . start ( ) ; } public void stop ( ) throws Exception { server . stop ( ) ; consumer . stop ( ) ; } protected Bus getBus ( ) { return endpoint . getBus ( ) ; } protected void processSoapConsumerIn ( Exchange exchange ) throws Exception { LOG . info ( "processSoapConsumerIn: " + exchange ) ; org . apache . cxf . message . Message inMessage = CxfSoapBinding . getCxfInMessage ( endpoint . getHeaderFilterStrategy ( ) , exchange , false ) ; org . apache . cxf . message . Exchange cxfExchange = inMessage . getExchange ( ) ; cxfExchange . put ( org . apache . cxf . endpoint . Endpoint . class , server . getEndpoint ( ) ) ; cxfExchange . put ( Bus . class , getBus ( ) ) ; cxfExchange . setConduit ( new NullConduit ( ) ) ; inMessageObserver . onMessage ( inMessage ) ; exchange . getIn ( ) . setBody ( inMessage . getContent ( Source . class ) ) ; exchange . getIn ( ) . setHeaders ( inMessage ) ; } protected void processSoapConsumerOut ( Exchange exchange ) throws Exception { LOG . info ( "processSoapConsumerOut: " + exchange ) ; org . apache . cxf . message . Message outMessage = CxfSoapBinding . getCxfOutMessage ( endpoint . getHeaderFilterStrategy ( ) , exchange , false ) ; org . apache . cxf . message . Exchange cxfExchange = outMessage . getExchange ( ) ; InterceptorChain chain = OutgoingChainInterceptor . getOutInterceptorChain ( cxfExchange ) ; outMessage . setInterceptorChain ( chain ) ; chain . doIntercept ( outMessage ) ; CachedOutputStream outputStream = ( CachedOutputStream ) outMessage . getContent ( OutputStream . class ) ; exchange . getOut ( ) . setBody ( outputStream . getInputStream ( ) ) ; } } 	0	['7', '1', '0', '32', '61', '0', '3', '32', '3', '0.633333333', '204', '1', '2', '0', '0.416666667', '0', '0', '27.42857143', '1', '0.7143', '0']
package org . apache . camel ; public class ExpectedBodyTypeException extends RuntimeCamelException { private final Exchange exchange ; private final Class expectedBodyType ; public ExpectedBodyTypeException ( Exchange exchange , Class expectedBodyType ) { super ( "Could not extract IN message body as type: " + expectedBodyType + " body is: " + exchange . getIn ( ) . getBody ( ) ) ; this . exchange = exchange ; this . expectedBodyType = expectedBodyType ; } public Exchange getExchange ( ) { return exchange ; } public Class getExpectedBodyType ( ) { return expectedBodyType ; } } 	1	['3', '5', '0', '4', '10', '0', '1', '3', '3', '0.5', '34', '1', '1', '0.894736842', '0.555555556', '0', '0', '9.666666667', '1', '0.6667', '1']
package org . apache . camel . converter . xmlbeans ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; import org . apache . xmlbeans . XmlObject ; public class XmlBeansDataFormat implements DataFormat { public void marshal ( Exchange exchange , Object body , OutputStream stream ) throws Exception { XmlObject object = ExchangeHelper . convertToMandatoryType ( exchange , XmlObject . class , body ) ; object . save ( stream ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception { return XmlObject . Factory . parse ( stream ) ; } } 	0	['3', '1', '0', '5', '7', '3', '0', '5', '3', '2', '19', '0', '0', '0', '0.533333333', '0', '0', '5.333333333', '1', '0.6667', '0']
package org . apache . camel . model . loadbalancer ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "topic" ) public class TopicLoadBalanceStrategy extends LoadBalancerType { @ Override protected LoadBalancer createLoadBalancer ( RouteContext routeContext ) { return new org . apache . camel . processor . loadbalancer . TopicLoadBalancer ( ) ; } } 	1	['2', '3', '0', '4', '4', '1', '0', '4', '1', '2', '9', '0', '0', '0.923076923', '0.75', '1', '1', '3.5', '1', '0.5', '1']
package org . apache . camel . component . file ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . language . simple . FileLanguage ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FileProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( FileProducer . class ) ; private FileEndpoint endpoint ; public FileProducer ( FileEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public FileEndpoint getEndpoint ( ) { return endpoint ; } public void process ( Exchange exchange ) throws Exception { FileExchange fileExchange = endpoint . createExchange ( exchange ) ; process ( fileExchange ) ; ExchangeHelper . copyResults ( exchange , fileExchange ) ; } public void process ( FileExchange exchange ) throws Exception { boolean fileSource = exchange . getIn ( ) . getBody ( ) instanceof File ; File target = createFileName ( exchange . getIn ( ) ) ; buildDirectory ( target ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to write to: " + target + " from exchange: " + exchange ) ; } if ( fileSource ) { File source = ExchangeHelper . getMandatoryInBody ( exchange , File . class ) ; writeFileByFile ( source , target ) ; } else { InputStream in = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; writeFileByStream ( in , target ) ; } } private void writeFileByFile ( File source , File target ) throws IOException { FileChannel in = new FileInputStream ( source ) . getChannel ( ) ; FileChannel out = null ; try { out = prepareOutputFileChannel ( target , out ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Using FileChannel to transfer from: " + in + " to: " + out ) ; } in . transferTo ( 0 , in . size ( ) , out ) ; } finally { ObjectHelper . close ( in , source . getName ( ) , LOG ) ; ObjectHelper . close ( out , source . getName ( ) , LOG ) ; } } private void writeFileByStream ( InputStream in , File target ) throws IOException { FileChannel out = null ; try { out = prepareOutputFileChannel ( target , out ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Using InputStream to transfer from: " + in + " to: " + out ) ; } int size = endpoint . getBufferSize ( ) ; byte [ ] buffer = new byte [ size ] ; ByteBuffer byteBuffer = ByteBuffer . wrap ( buffer ) ; while ( true ) { int count = in . read ( buffer ) ; if ( count <= 0 ) { break ; } else if ( count < size ) { byteBuffer = ByteBuffer . wrap ( buffer , 0 , count ) ; out . write ( byteBuffer ) ; break ; } else { out . write ( byteBuffer ) ; byteBuffer . clear ( ) ; } } } finally { ObjectHelper . close ( in , target . getName ( ) , LOG ) ; ObjectHelper . close ( out , target . getName ( ) , LOG ) ; } } private FileChannel prepareOutputFileChannel ( File target , FileChannel out ) throws IOException { if ( endpoint . isAppend ( ) ) { out = new RandomAccessFile ( target , "rw" ) . getChannel ( ) ; out = out . position ( out . size ( ) ) ; } else { out = new FileOutputStream ( target ) . getChannel ( ) ; } return out ; } protected File createFileName ( Message message ) { File answer ; String name = null ; if ( ! endpoint . isIgnoreFileNameHeader ( ) ) { name = message . getHeader ( FileComponent . HEADER_FILE_NAME , String . class ) ; } Expression expression = endpoint . getExpression ( ) ; if ( name != null ) { if ( name . indexOf ( "${" ) > - 1 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( FileComponent . HEADER_FILE_NAME + " contains a FileLanguage expression: " + name ) ; } expression = FileLanguage . file ( name ) ; } } if ( expression != null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Filename evaluated as expression: " + expression ) ; } Object result = expression . evaluate ( message . getExchange ( ) ) ; name = message . getExchange ( ) . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , result ) ; } File endpointFile = endpoint . getFile ( ) ; if ( endpointFile . isDirectory ( ) ) { if ( name != null ) { answer = new File ( endpointFile , name ) ; if ( answer . isDirectory ( ) ) { answer = new File ( answer , endpoint . getGeneratedFileName ( message ) ) ; } } else { answer = new File ( endpointFile , endpoint . getGeneratedFileName ( message ) ) ; } } else { if ( name == null ) { answer = endpointFile ; } else { answer = new File ( endpointFile , name ) ; } } message . setHeader ( FileComponent . HEADER_FILE_NAME_PRODUCED , answer . getAbsolutePath ( ) ) ; return answer ; } private void buildDirectory ( File file ) { String dirName = file . getAbsolutePath ( ) ; int index = dirName . lastIndexOf ( File . separatorChar ) ; if ( index > 0 ) { dirName = dirName . substring ( 0 , index ) ; File dir = new File ( dirName ) ; dir . mkdirs ( ) ; } } } 	0	['11', '3', '0', '14', '63', '7', '1', '14', '5', '0.35', '416', '1', '1', '0.7', '0.25', '0', '0', '36.63636364', '11', '1.8182', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoopProcessor extends DelegateProcessor { public static final String PROP_ITER_COUNT = "CamelIterationCount" ; public static final String PROP_ITER_INDEX = "CamelIterationIndex" ; private static final Log LOG = LogFactory . getLog ( LoopProcessor . class ) ; private Expression < Exchange > expression ; public LoopProcessor ( Expression < Exchange > expression , Processor processor ) { super ( processor ) ; this . expression = expression ; } @ Override public void process ( Exchange exchange ) throws Exception { String text = ExchangeHelper . convertToType ( exchange , String . class , expression . evaluate ( exchange ) ) ; Integer value = ExchangeHelper . convertToType ( exchange , Integer . class , text ) ; if ( value == null ) { throw new RuntimeCamelException ( "Expression \"" + expression + "\" does not evaluate to an int." ) ; } int count = value . intValue ( ) ; exchange . setProperty ( PROP_ITER_COUNT , count ) ; for ( int i = 0 ; i < count ; i ++ ) { LOG . debug ( "LoopProcessor: iteration #" + i ) ; exchange . setProperty ( PROP_ITER_INDEX , i ) ; super . process ( exchange ) ; } } @ Override public String toString ( ) { return "Loop[for: " + expression + " times do: " + getProcessor ( ) + "]" ; } public Expression < Exchange > getExpression ( ) { return expression ; } } 	1	['5', '3', '0', '9', '21', '0', '1', '8', '4', '0.875', '106', '0.5', '1', '0.88', '0.4375', '0', '0', '19.4', '1', '0.6', '1']
package org . apache . camel . component . jhc ; import java . io . IOException ; import org . apache . http . HttpException ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; import org . apache . http . protocol . HttpContext ; import org . apache . http . protocol . HttpRequestHandler ; public interface AsyncHttpRequestHandler extends HttpRequestHandler { void handle ( HttpRequest request , HttpContext context , AsyncResponseHandler handler ) throws HttpException , IOException ; } 	0	['1', '1', '0', '9', '1', '0', '4', '5', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Intercept ; import org . apache . camel . Processor ; import org . apache . camel . util . ServiceHelper ; public class Interceptor extends DelegateProcessor implements Intercept { private Processor interceptorLogic ; public Interceptor ( ) { } public Interceptor ( Processor interceptorLogic ) { this . interceptorLogic = interceptorLogic ; } public void process ( Exchange exchange ) throws Exception { interceptorLogic . process ( exchange ) ; } public Processor getInterceptorLogic ( ) { return interceptorLogic ; } public void setInterceptorLogic ( Processor interceptorLogic ) { this . interceptorLogic = interceptorLogic ; } @ Override protected void doStart ( ) throws Exception { ServiceHelper . startService ( interceptorLogic ) ; super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { ServiceHelper . stopService ( interceptorLogic ) ; super . doStop ( ) ; } } 	1	['7', '3', '0', '8', '13', '0', '3', '5', '5', '0.166666667', '41', '1', '1', '0.814814815', '0.476190476', '1', '1', '4.714285714', '1', '0.7143', '2']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElementRef ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExpressionNode extends ProcessorType < ProcessorType > { @ XmlElementRef private ExpressionType expression ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; public ExpressionNode ( ) { } public ExpressionNode ( ExpressionType expression ) { this . expression = expression ; } public ExpressionNode ( Expression expression ) { if ( expression != null ) { setExpression ( new ExpressionType ( expression ) ) ; } } public ExpressionNode ( Predicate predicate ) { if ( predicate != null ) { setExpression ( new ExpressionType ( predicate ) ) ; } } @ Override public String getShortName ( ) { return "exp" ; } public ExpressionType getExpression ( ) { return expression ; } public void setExpression ( ExpressionType expression ) { this . expression = expression ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } @ Override public String getLabel ( ) { if ( getExpression ( ) == null ) { return "" ; } return getExpression ( ) . getLabel ( ) ; } protected FilterProcessor createFilterProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new FilterProcessor ( getExpression ( ) . createPredicate ( routeContext ) , childProcessor ) ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } } } 	0	['12', '3', '13', '22', '24', '30', '15', '8', '10', '0.5', '114', '1', '1', '0.956521739', '0.226190476', '1', '3', '8.333333333', '2', '0.8333', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Processor ; public final class ProcessorBuilder { private ProcessorBuilder ( ) { } public static Processor setBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setBody(" + expression + ")" ; } } ; } public static Processor setOutBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setOutBody(" + expression + ")" ; } } ; } public static Processor setFaultBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getFault ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setFaultBody(" + expression + ")" ; } } ; } public static Processor setHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setOutHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setOutHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setFaultHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getFault ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setFaultHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setProperty ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . setProperty ( name , value ) ; } @ Override public String toString ( ) { return "setProperty(" + name + ", " + expression + ")" ; } } ; } public static Processor removeHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getIn ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeHeader(" + name + ")" ; } } ; } public static Processor removeFaultHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getFault ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeFaultHeader(" + name + ")" ; } } ; } public static Processor removeProperty ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . removeProperty ( name ) ; } @ Override public String toString ( ) { return "removeProperty(" + name + ")" ; } } ; } public static Processor throwException ( final Exception ex ) { return new Processor ( ) { public void process ( Exchange exchange ) throws Exception { throw ex ; } @ Override public String toString ( ) { return "throwException(" + ex . toString ( ) + ")" ; } } ; } } 	1	['12', '1', '0', '20', '24', '66', '7', '13', '11', '2', '74', '0', '0', '0', '0.333333333', '0', '0', '5.166666667', '1', '0.9167', '1']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . processor . ChoiceProcessor ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlRootElement ( name = "choice" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ChoiceType extends ProcessorType < ChoiceType > { private static final transient Log LOG = LogFactory . getLog ( ChoiceType . class ) ; @ XmlElementRef private List < WhenType > whenClauses = new ArrayList < WhenType > ( ) ; @ XmlElement ( required = false ) private OtherwiseType otherwise ; @ Override public String toString ( ) { if ( getOtherwise ( ) != null ) { return "Choice[" + getWhenClauses ( ) + " " + getOtherwise ( ) + "]" ; } else { return "Choice[" + getWhenClauses ( ) + "]" ; } } @ Override public String getShortName ( ) { return "choice" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; for ( WhenType whenClaus : whenClauses ) { filters . add ( whenClaus . createProcessor ( routeContext ) ) ; } Processor otherwiseProcessor = null ; if ( otherwise != null ) { otherwiseProcessor = otherwise . createProcessor ( routeContext ) ; } else { LOG . warn ( "No otherwise clause was specified for a choice block -- any unmatched exchanges will be dropped" ) ; } return new ChoiceProcessor ( filters , otherwiseProcessor ) ; } public ChoiceType when ( Predicate predicate ) { getWhenClauses ( ) . add ( new WhenType ( predicate ) ) ; return this ; } public ExpressionClause < ChoiceType > when ( ) { WhenType when = new WhenType ( ) ; getWhenClauses ( ) . add ( when ) ; ExpressionClause < ChoiceType > clause = new ExpressionClause < ChoiceType > ( this ) ; when . setExpression ( clause ) ; return clause ; } public ChoiceType otherwise ( ) { OtherwiseType answer = new OtherwiseType ( ) ; setOtherwise ( answer ) ; return this ; } @ Override public String getLabel ( ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; List < WhenType > list = getWhenClauses ( ) ; for ( WhenType whenType : list ) { buffer . append ( whenType . getLabel ( ) ) ; } return buffer . toString ( ) ; } public List < WhenType > getWhenClauses ( ) { return whenClauses ; } public void setWhenClauses ( List < WhenType > whenClauses ) { this . whenClauses = whenClauses ; } public List < ProcessorType < ? > > getOutputs ( ) { if ( otherwise != null ) { return otherwise . getOutputs ( ) ; } else if ( whenClauses . isEmpty ( ) ) { return Collections . EMPTY_LIST ; } else { WhenType when = whenClauses . get ( whenClauses . size ( ) - 1 ) ; return when . getOutputs ( ) ; } } public OtherwiseType getOtherwise ( ) { return otherwise ; } public void setOtherwise ( OtherwiseType otherwise ) { this . otherwise = otherwise ; } } 	0	['14', '3', '0', '21', '43', '59', '9', '13', '13', '0.641025641', '208', '1', '1', '0.936170213', '0.261538462', '1', '3', '13.64285714', '3', '1.1429', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . UuidGenerator ; public abstract class MessageSupport implements Message { private static final UuidGenerator DEFALT_ID_GENERATOR = new UuidGenerator ( ) ; private Exchange exchange ; private Object body ; private String messageId ; public Object getBody ( ) { if ( body == null ) { body = createBody ( ) ; } return body ; } @ SuppressWarnings ( { "unchecked" } ) public < T > T getBody ( Class < T > type ) { return getBody ( type , getBody ( ) ) ; } protected < T > T getBody ( Class < T > type , Object body ) { Exchange e = getExchange ( ) ; if ( e != null ) { CamelContext camelContext = e . getContext ( ) ; if ( camelContext != null ) { TypeConverter converter = camelContext . getTypeConverter ( ) ; try { return converter . convertTo ( type , e , body ) ; } catch ( NoTypeConversionAvailableException ex ) { } return converter . convertTo ( type , this ) ; } } return ( T ) getBody ( ) ; } public void setBody ( Object body ) { this . body = body ; } public < T > void setBody ( Object value , Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { T v = e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , e , value ) ; if ( v != null ) { value = v ; } } setBody ( value ) ; } public Message copy ( ) { Message answer = newInstance ( ) ; answer . copyFrom ( this ) ; return answer ; } public void copyFrom ( Message that ) { setMessageId ( that . getMessageId ( ) ) ; setBody ( that . getBody ( ) ) ; getHeaders ( ) . putAll ( that . getHeaders ( ) ) ; getAttachments ( ) . putAll ( that . getAttachments ( ) ) ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public abstract Message newInstance ( ) ; protected Object createBody ( ) { return null ; } public String getMessageId ( ) { if ( messageId == null ) { messageId = createMessageId ( ) ; } return this . messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } protected String createMessageId ( ) { return DEFALT_ID_GENERATOR . generateId ( ) ; } } 	1	['16', '1', '1', '8', '31', '112', '2', '6', '12', '0.8', '150', '1', '2', '0', '0.266666667', '0', '0', '8.125', '3', '1.25', '2']
package org . apache . camel . component . xquery ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . ResourceBasedComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . springframework . core . io . Resource ; public class XQueryComponent extends ResourceBasedComponent { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Resource resource = resolveMandatoryResource ( remaining ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( this + " using schema resource: " + resource ) ; } XQueryBuilder xslt = XQueryBuilder . xquery ( resource . getURL ( ) ) ; configureXslt ( xslt , uri , remaining , parameters ) ; return new ProcessorEndpoint ( uri , this , xslt ) ; } protected void configureXslt ( XQueryBuilder xQueryBuilder , String uri , String remaining , Map parameters ) throws Exception { setProperties ( xQueryBuilder , parameters ) ; } } 	0	['3', '4', '0', '8', '15', '3', '0', '8', '1', '2', '49', '0', '0', '0.95', '0.666666667', '2', '2', '15.33333333', '1', '0.6667', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultExchangeFormatter ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . processor . interceptor . ExchangeFormatter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class Logger implements Processor { private Log log ; private LoggingLevel level ; private ExchangeFormatter formatter = DefaultExchangeFormatter . getInstance ( ) ; public Logger ( ) { this ( LogFactory . getLog ( Logger . class ) ) ; } public Logger ( Log log ) { this ( log , LoggingLevel . INFO ) ; } public Logger ( Log log , LoggingLevel level ) { this . log = log ; this . level = level ; } public Logger ( String logName ) { this ( LogFactory . getLog ( logName ) ) ; } public Logger ( String logName , LoggingLevel level ) { this ( LogFactory . getLog ( logName ) , level ) ; } public Logger ( Log log , ExchangeFormatter formatter ) { this ( log ) ; this . formatter = formatter ; } @ Override public String toString ( ) { return "Logger[" + log + "]" ; } public void process ( Exchange exchange ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange ) ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange ) ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange ) ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . info ( logMessage ( exchange ) ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange ) ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange ) ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange ) ) ; } } public void process ( Exchange exchange , Throwable exception ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange ) , exception ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange ) , exception ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange ) , exception ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . info ( logMessage ( exchange ) , exception ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange ) , exception ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange ) , exception ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange ) ) ; } } public void log ( String message , LoggingLevel loggingLevel ) { LoggingLevel oldLogLevel = getLevel ( ) ; setLevel ( loggingLevel ) ; log ( message ) ; setLevel ( oldLogLevel ) ; } public void log ( String message ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message ) ; } } public void log ( String message , Throwable exception , LoggingLevel loggingLevel ) { LoggingLevel oldLogLevel = getLevel ( ) ; setLevel ( loggingLevel ) ; log ( message , exception ) ; setLevel ( oldLogLevel ) ; } public void log ( String message , Throwable exception ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message , exception ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message , exception ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message , exception ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message , exception ) ; } break ; case OFF : break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message , exception ) ; } } protected Object logMessage ( Exchange exchange ) { return formatter . format ( exchange ) ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public void setFormatter ( ExchangeFormatter formatter ) { this . formatter = formatter ; } } 	1	['19', '1', '1', '15', '47', '81', '7', '8', '18', '0.388888889', '474', '1', '2', '0', '0.315789474', '0', '0', '23.78947368', '8', '2.1053', '1']
package org . apache . camel . processor . idempotent ; public interface MessageIdRepository { boolean contains ( String messageId ) ; } 	0	['1', '1', '0', '7', '1', '0', '7', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . model . InterceptorRef ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . Logger ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . commons . logging . LogFactory ; public class TraceInterceptor extends DelegateProcessor implements ExchangeFormatter { private Logger logger ; private final ProcessorType node ; private final Tracer tracer ; private TraceFormatter formatter ; public TraceInterceptor ( ProcessorType node , Processor target , TraceFormatter formatter , Tracer tracer ) { super ( target ) ; this . tracer = tracer ; this . node = node ; this . formatter = formatter ; if ( tracer . getLogName ( ) != null ) { logger = new Logger ( LogFactory . getLog ( tracer . getLogName ( ) ) , this ) ; } else { logger = new Logger ( LogFactory . getLog ( TraceInterceptor . class ) , this ) ; } if ( tracer . getLogLevel ( ) != null ) { logger . setLevel ( tracer . getLogLevel ( ) ) ; } if ( tracer . getFormatter ( ) != null ) { this . formatter = tracer . getFormatter ( ) ; } } public TraceInterceptor ( ProcessorType node , Processor target , TraceFormatter formatter ) { this ( node , target , formatter , new Tracer ( ) ) ; } public TraceInterceptor ( ProcessorType node , Processor target , Tracer tracer ) { this ( node , target , null , tracer ) ; } @ Override public String toString ( ) { return "TraceInterceptor[" + node + "]" ; } public void process ( final Exchange exchange ) throws Exception { try { if ( shouldLogNode ( node ) && shouldLogExchange ( exchange ) ) { logExchange ( exchange ) ; } super . proceed ( exchange ) ; if ( tracer . isTraceOutExchanges ( ) && shouldLogNode ( node ) && shouldLogExchange ( exchange ) ) { logExchange ( exchange ) ; } } catch ( Exception e ) { if ( shouldLogException ( exchange ) ) { logException ( exchange , e ) ; } throw e ; } } public Object format ( Exchange exchange ) { return formatter . format ( this , exchange ) ; } public ProcessorType getNode ( ) { return node ; } public Logger getLogger ( ) { return logger ; } public TraceFormatter getFormatter ( ) { return formatter ; } protected void logExchange ( Exchange exchange ) { logger . process ( exchange ) ; } protected void logException ( Exchange exchange , Throwable throwable ) { if ( tracer . isTraceExceptions ( ) ) { logger . process ( exchange , throwable ) ; } } protected boolean shouldLogExchange ( Exchange exchange ) { return ( tracer == null || tracer . isEnabled ( ) ) && ( tracer . getTraceFilter ( ) == null || tracer . getTraceFilter ( ) . matches ( exchange ) ) ; } protected boolean shouldLogException ( Exchange exchange ) { return tracer . isTraceExceptions ( ) ; } public boolean shouldTraceOutExchanges ( ) { return tracer . isTraceOutExchanges ( ) ; } protected boolean shouldLogNode ( ProcessorType node ) { if ( node == null ) { return false ; } if ( ! tracer . isTraceInterceptors ( ) && ( node instanceof InterceptStrategy || node instanceof InterceptorRef ) ) { return false ; } return true ; } } 	1	['15', '3', '0', '15', '38', '37', '3', '14', '10', '0.589285714', '217', '1', '4', '0.647058824', '0.314285714', '1', '1', '13.2', '5', '1.4', '8']
package org . apache . camel . spring . handler ; import org . apache . camel . util . ObjectHelper ; public class LazyLoadingBeanDefinitionParser extends BeanDefinitionParser { private String className ; private String moduleName ; public LazyLoadingBeanDefinitionParser ( String className , String moduleName ) { this . className = className ; this . moduleName = moduleName ; } @ Override protected Class loadType ( ) { Class < ? > answer = ObjectHelper . loadClass ( className , getClass ( ) . getClassLoader ( ) ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Class: " + className + " could not be found. You need to add Camel module: " + moduleName + " to your classpath" ) ; } return answer ; } } 	0	['2', '1', '1', '3', '10', '0', '1', '2', '1', '0', '44', '1', '0', '0.857142857', '0.75', '1', '1', '20', '2', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public class ValueBuilder < E extends Exchange > implements Expression < E > { private Expression < E > expression ; public ValueBuilder ( Expression < E > expression ) { this . expression = expression ; } public Object evaluate ( E exchange ) { return expression . evaluate ( exchange ) ; } public Expression < E > getExpression ( ) { return expression ; } @ Override public String toString ( ) { return expression . toString ( ) ; } public Predicate < E > isNotEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isNotEqualTo ( expression , right ) ) ; } public Predicate < E > isEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isEqualTo ( expression , right ) ) ; } public Predicate < E > isLessThan ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThan ( expression , right ) ) ; } public Predicate < E > isLessThanOrEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThanOrEqualTo ( expression , right ) ) ; } public Predicate < E > isGreaterThan ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThan ( expression , right ) ) ; } public Predicate < E > isGreaterThanOrEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThanOrEqualTo ( expression , right ) ) ; } public Predicate < E > isInstanceOf ( Class type ) { return onNewPredicate ( PredicateBuilder . isInstanceOf ( expression , type ) ) ; } public Predicate < E > matchesRegex ( String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } public Predicate < E > isNull ( ) { return onNewPredicate ( PredicateBuilder . isNull ( expression ) ) ; } public Predicate < E > isNotNull ( ) { return onNewPredicate ( PredicateBuilder . isNotNull ( expression ) ) ; } public Predicate < E > contains ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . contains ( expression , right ) ) ; } public Predicate < E > regex ( String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } public ValueBuilder < E > tokenize ( ) { return tokenize ( "\n" ) ; } public ValueBuilder < E > tokenize ( String token ) { Expression < E > newExp = ExpressionBuilder . tokenizeExpression ( expression , token ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > regexTokenize ( String regex ) { Expression < E > newExp = ExpressionBuilder . regexTokenize ( expression , regex ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > regexReplaceAll ( String regex , String replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > regexReplaceAll ( String regex , Expression < E > replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > convertTo ( Class type ) { Expression < E > newExp = ExpressionBuilder . convertTo ( expression , type ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > convertToString ( ) { return convertTo ( String . class ) ; } public ValueBuilder < E > append ( Object value ) { return new ValueBuilder < E > ( ExpressionBuilder . append ( expression , asExpression ( value ) ) ) ; } protected Predicate < E > onNewPredicate ( Predicate < E > predicate ) { return predicate ; } protected Expression < E > asExpression ( Object value ) { if ( value instanceof Expression ) { return ( Expression < E > ) value ; } else { return ExpressionBuilder . constantExpression ( value ) ; } } } 	1	['26', '1', '1', '9', '47', '0', '4', '5', '24', '0.08', '236', '1', '1', '0', '0.258241758', '0', '0', '8.038461538', '2', '1', '1']
package org . apache . camel . component . cxf . invoker ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . util . ObjectHelper ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . ClientImpl ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . ExchangeImpl ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . PhaseInterceptorChain ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . OperationInfo ; import org . apache . cxf . transport . MessageObserver ; public class CxfClient extends ClientImpl { private static final Logger LOG = LogUtils . getL7dLogger ( CxfClient . class ) ; public CxfClient ( Bus b , Endpoint e ) { super ( b , e ) ; } public Object dispatch ( Map < Class , Object > params , Map < String , Object > context , Exchange exchange ) throws Exception { Object retval = null ; InvokingContext invokingContext = exchange . get ( InvokingContext . class ) ; ObjectHelper . notNull ( invokingContext , "invokingContext" ) ; BindingOperationInfo inBoundOp = exchange . get ( BindingOperationInfo . class ) ; BindingOperationInfo outBoundOp = null ; if ( inBoundOp != null ) { BindingInfo bi = getEndpoint ( ) . getEndpointInfo ( ) . getBinding ( ) ; outBoundOp = bi . getOperation ( inBoundOp . getOperationInfo ( ) . getName ( ) ) ; if ( outBoundOp != null && inBoundOp . isUnwrapped ( ) ) { outBoundOp = outBoundOp . getUnwrappedOperation ( ) ; } } retval = invokeWithMessageStream ( outBoundOp , params , context , invokingContext ) ; return retval ; } @ SuppressWarnings ( "unchecked" ) public Object invokeWithMessageStream ( BindingOperationInfo bi , Map < Class , Object > param , Map < String , Object > context , InvokingContext invokingContext ) throws Exception { Object retval = null ; Map < String , Object > requestContext = null ; Map < String , Object > responseContext = null ; if ( null != context ) { requestContext = ( Map < String , Object > ) context . get ( REQUEST_CONTEXT ) ; responseContext = ( Map < String , Object > ) context . get ( RESPONSE_CONTEXT ) ; } Exchange exchange = new ExchangeImpl ( ) ; exchange . put ( InvokingContext . class , invokingContext ) ; if ( bi != null ) { exchange . put ( BindingMessageInfo . class , bi . getInput ( ) ) ; exchange . setOneWay ( bi . getOperationInfo ( ) . isOneWay ( ) ) ; } Message message = prepareMessage ( exchange , requestContext , param , invokingContext ) ; message . put ( Message . INVOCATION_CONTEXT , context ) ; Endpoint ep = getEndpoint ( ) ; if ( ep != null ) { message . putAll ( ep ) ; } setExchangeProperties ( exchange , ep , bi ) ; PhaseInterceptorChain chain = setupInterceptorChain ( getEndpoint ( ) ) ; message . setInterceptorChain ( chain ) ; modifyChain ( chain , requestContext ) ; chain . setFaultObserver ( outFaultObserver ) ; prepareConduitSelector ( message ) ; modifyChain ( chain , null ) ; chain . doIntercept ( message ) ; Exception ex = message . getContent ( Exception . class ) ; if ( ex != null ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Exception in outgoing chain: " + ex . toString ( ) ) ; } throw ex ; } if ( ! exchange . isOneWay ( ) ) { synchronized ( exchange ) { waitResponse ( exchange ) ; } ex = getException ( exchange ) ; if ( ex != null ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Exception in incoming chain: " + ex . toString ( ) ) ; } throw ex ; } retval = invokingContext . getResponseObject ( exchange , responseContext ) ; } return retval ; } protected void waitResponse ( Exchange exchange ) { int remaining = synchronousTimeout ; while ( ! Boolean . TRUE . equals ( exchange . get ( FINISHED ) ) && remaining > 0 ) { long start = System . currentTimeMillis ( ) ; try { exchange . wait ( remaining ) ; } catch ( InterruptedException ex ) { } long end = System . currentTimeMillis ( ) ; remaining -= ( int ) ( end - start ) ; } if ( ! Boolean . TRUE . equals ( exchange . get ( FINISHED ) ) ) { LogUtils . log ( LOG , Level . WARNING , "RESPONSE_TIMEOUT" , exchange . get ( OperationInfo . class ) . getName ( ) . toString ( ) ) ; } } private Message prepareMessage ( Exchange exchange , Map < String , Object > requestContext , Map < Class , Object > param , InvokingContext invokingContext ) { Message message = getEndpoint ( ) . getBinding ( ) . createMessage ( ) ; message . put ( Message . REQUESTOR_ROLE , Boolean . TRUE ) ; message . put ( Message . INBOUND_MESSAGE , Boolean . FALSE ) ; if ( requestContext != null ) { message . putAll ( requestContext ) ; } if ( param != null ) { invokingContext . setRequestOutMessageContent ( message , param ) ; } if ( null != requestContext ) { exchange . putAll ( requestContext ) ; } exchange . setOutMessage ( message ) ; return message ; } } 	0	['6', '0', '0', '21', '54', '9', '2', '19', '3', '0.4', '309', '1', '0', '0', '0.457142857', '0', '0', '50.33333333', '4', '1.6667', '0']
package org . apache . camel . processor ; import java . io . ByteArrayOutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . spi . DataFormat ; public class MarshalProcessor implements Processor { private final DataFormat dataFormat ; public MarshalProcessor ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } public void process ( Exchange exchange ) throws Exception { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; Message in = exchange . getIn ( ) ; Object body = in . getBody ( ) ; Message out = exchange . getOut ( true ) ; out . copyFrom ( in ) ; dataFormat . marshal ( exchange , body , buffer ) ; byte [ ] data = buffer . toByteArray ( ) ; out . setBody ( data ) ; } } 	1	['2', '1', '0', '5', '11', '0', '1', '4', '2', '0', '39', '1', '1', '0', '0.666666667', '0', '0', '18', '1', '0.5', '1']
package org . apache . camel . component . cxf . transport . spring ; import org . apache . camel . component . cxf . transport . CamelConduit ; public class CamelConduitDefinitionParser extends AbstractCamelContextBeanDefinitionParser { public CamelConduitDefinitionParser ( ) { super ( ) ; setBeanClass ( CamelConduit . class ) ; } } 	0	['1', '1', '0', '2', '3', '0', '1', '1', '1', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . camel . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class PackageHelper { private static final transient Log LOG = LogFactory . getLog ( PackageHelper . class ) ; private PackageHelper ( ) { } public static boolean isValidVersion ( String packageName , double minimumVersion ) { try { Package spring = Package . getPackage ( packageName ) ; String value = spring . getImplementationVersion ( ) ; if ( value != null ) { int idx = value . indexOf ( '.' ) ; if ( idx >= 0 ) { StringBuffer buffer = new StringBuffer ( value . substring ( 0 , ++ idx ) ) ; int i = idx ; for ( int size = value . length ( ) ; i < size ; i ++ ) { char ch = value . charAt ( i ) ; if ( Character . isDigit ( ch ) ) { buffer . append ( ch ) ; } } value = buffer . toString ( ) ; } double number = Double . parseDouble ( value ) ; return number >= minimumVersion ; } } catch ( Exception e ) { LOG . debug ( "Failed to find out " + packageName + " version: " + e , e ) ; } return true ; } } 	1	['3', '1', '0', '3', '21', '1', '1', '2', '1', '0.5', '88', '1', '0', '0', '0.5', '0', '0', '28', '5', '1.6667', '1']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ConvertBodyProcessor implements Processor { private static final transient Log LOG = LogFactory . getLog ( ConvertBodyProcessor . class ) ; private final Class type ; public ConvertBodyProcessor ( Class type ) { this . type = type ; } public void process ( Exchange exchange ) throws Exception { Message in = exchange . getIn ( ) ; Object value = null ; try { value = in . getBody ( type ) ; } catch ( NoTypeConversionAvailableException e ) { LOG . warn ( "Could not convert body of IN message: " + in + " to type: " + type . getName ( ) ) ; } if ( exchange . getPattern ( ) . isOutCapable ( ) ) { Message out = exchange . getOut ( ) ; out . copyFrom ( in ) ; out . setBody ( value ) ; } else { in . setBody ( value ) ; } } } 	0	['3', '1', '0', '9', '18', '0', '2', '7', '2', '0.5', '61', '1', '0', '0', '0.666666667', '0', '0', '18.66666667', '1', '0.3333', '0']
package org . apache . camel . model . loadbalancer ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . model . IdentifiedType ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; @ XmlType ( name = "loadBalancerType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class LoadBalancerType extends IdentifiedType implements LoadBalancer { @ XmlTransient private LoadBalancer loadBalancer ; @ XmlTransient private String loadBalancerTypeName ; public LoadBalancerType ( ) { } public LoadBalancerType ( LoadBalancer loadBalancer ) { this . loadBalancer = loadBalancer ; } protected LoadBalancerType ( String loadBalancerTypeName ) { this . loadBalancerTypeName = loadBalancerTypeName ; } public static LoadBalancer getLoadBalancer ( RouteContext routeContext , LoadBalancerType type , String ref ) { if ( type == null ) { notNull ( ref , "ref or LoadBalancerType" ) ; LoadBalancer loadBalancer = routeContext . lookup ( ref , LoadBalancer . class ) ; if ( loadBalancer instanceof LoadBalancerType ) { type = ( LoadBalancerType ) loadBalancer ; } else { return loadBalancer ; } } return type . getLoadBalancer ( routeContext ) ; } protected void setProperty ( Object bean , String name , Object value ) { try { IntrospectionSupport . setProperty ( bean , name , value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Failed to set property " + name + " on " + bean + ". Reason: " + e , e ) ; } } protected void configureLoadBalancer ( LoadBalancer loadBalancer ) { } public LoadBalancer getLoadBalancer ( RouteContext routeContext ) { if ( loadBalancer == null ) { loadBalancer = createLoadBalancer ( routeContext ) ; ObjectHelper . notNull ( loadBalancer , "loadBalancer" ) ; configureLoadBalancer ( loadBalancer ) ; } return loadBalancer ; } protected LoadBalancer createLoadBalancer ( RouteContext routeContext ) { if ( loadBalancerTypeName != null ) { Class type = ObjectHelper . loadClass ( loadBalancerTypeName , getClass ( ) . getClassLoader ( ) ) ; if ( type == null ) { throw new IllegalArgumentException ( "The class " + loadBalancerTypeName + " is not on the classpath! Cannot use the loadBalancer " + this ) ; } return ( LoadBalancer ) ObjectHelper . newInstance ( type ) ; } return null ; } public void addProcessor ( Processor processor ) { ObjectHelper . notNull ( loadBalancer , "loadBalancer" ) ; loadBalancer . addProcessor ( processor ) ; } public List < Processor > getProcessors ( ) { ObjectHelper . notNull ( loadBalancer , "loadBalancer" ) ; return loadBalancer . getProcessors ( ) ; } public void removeProcessor ( Processor processor ) { ObjectHelper . notNull ( loadBalancer , "loadBalancer" ) ; loadBalancer . removeProcessor ( processor ) ; } public void process ( Exchange exchange ) throws Exception { ObjectHelper . notNull ( loadBalancer , "loadBalancer" ) ; loadBalancer . process ( exchange ) ; } public boolean process ( Exchange exchange , final AsyncCallback callback ) { ObjectHelper . notNull ( loadBalancer , "loadBalancer" ) ; return loadBalancer . process ( exchange , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { if ( doneSynchronously ) { return ; } else { callback . done ( doneSynchronously ) ; } } } ) ; } } 	1	['13', '2', '4', '14', '33', '34', '6', '9', '9', '0.625', '187', '1', '1', '0.166666667', '0.230769231', '0', '0', '13.23076923', '3', '1.1538', '1']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; public class RegistryBean implements BeanHolder { private final CamelContext context ; private final String name ; private final Registry registry ; private Processor processor ; private BeanInfo beanInfo ; private Object bean ; private ParameterMappingStrategy parameterMappingStrategy ; public RegistryBean ( CamelContext context , String name ) { this . context = context ; this . name = name ; this . registry = context . getRegistry ( ) ; } public RegistryBean ( CamelContext context , String name , ParameterMappingStrategy parameterMappingStrategy ) { this ( context , name ) ; this . parameterMappingStrategy = parameterMappingStrategy ; } @ Override public String toString ( ) { return "bean: " + name ; } public ConstantBeanHolder createCacheHolder ( ) throws Exception { return new ConstantBeanHolder ( getBean ( ) , getBeanInfo ( ) ) ; } public Object getBean ( ) throws Exception { Object value = lookupBean ( ) ; if ( value == null ) { throw new NoBeanAvailableException ( name ) ; } if ( value != bean ) { bean = value ; processor = null ; if ( ! ObjectHelper . equal ( ObjectHelper . type ( bean ) , ObjectHelper . type ( value ) ) ) { beanInfo = null ; } } return value ; } public Processor getProcessor ( ) { if ( processor == null && bean != null ) { try { processor = CamelContextHelper . convertTo ( context , Processor . class , bean ) ; } catch ( NoTypeConversionAvailableException ex ) { } } return processor ; } public BeanInfo getBeanInfo ( ) { if ( beanInfo == null && bean != null ) { this . beanInfo = createBeanInfo ( ) ; } return beanInfo ; } public String getName ( ) { return name ; } public Registry getRegistry ( ) { return registry ; } public CamelContext getContext ( ) { return context ; } public ParameterMappingStrategy getParameterMappingStrategy ( ) { if ( parameterMappingStrategy == null ) { parameterMappingStrategy = createParameterMappingStrategy ( ) ; } return parameterMappingStrategy ; } public void setParameterMappingStrategy ( ParameterMappingStrategy parameterMappingStrategy ) { this . parameterMappingStrategy = parameterMappingStrategy ; } protected BeanInfo createBeanInfo ( ) { return new BeanInfo ( context , bean . getClass ( ) , getParameterMappingStrategy ( ) ) ; } protected ParameterMappingStrategy createParameterMappingStrategy ( ) { return BeanInfo . createParameterMappingStrategy ( context ) ; } protected Object lookupBean ( ) throws Exception { return registry . lookup ( name ) ; } } 	0	['15', '1', '1', '15', '29', '45', '4', '11', '12', '0.714285714', '171', '1', '5', '0', '0.35', '0', '0', '9.933333333', '3', '1.2', '0']
package org . apache . camel . spi ; public interface HeaderFilterStrategy { boolean applyFilterToCamelHeaders ( String headerName , Object headerValue ) ; boolean applyFilterToExternalHeaders ( String headerName , Object headerValue ) ; } 	1	['2', '1', '0', '40', '2', '1', '40', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "constant" ) public @ interface Constant { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BeanProcessor extends ServiceSupport implements Processor { public static final String METHOD_NAME = "org.apache.camel.MethodName" ; public static final String MULTI_PARAMETER_ARRAY = "org.apache.camel.MultiParameterArray" ; private static final transient Log LOG = LogFactory . getLog ( BeanProcessor . class ) ; private boolean multiParameterArray ; private Method methodObject ; private String method ; private BeanHolder beanHolder ; public BeanProcessor ( Object pojo , BeanInfo beanInfo ) { this ( new ConstantBeanHolder ( pojo , beanInfo ) ) ; } public BeanProcessor ( Object pojo , CamelContext camelContext , ParameterMappingStrategy parameterMappingStrategy ) { this ( pojo , new BeanInfo ( camelContext , pojo . getClass ( ) , parameterMappingStrategy ) ) ; } public BeanProcessor ( Object pojo , CamelContext camelContext ) { this ( pojo , camelContext , BeanInfo . createParameterMappingStrategy ( camelContext ) ) ; } public BeanProcessor ( BeanHolder beanHolder ) { this . beanHolder = beanHolder ; } @ Override public String toString ( ) { String description = methodObject != null ? " " + methodObject : "" ; return "BeanProcessor[" + beanHolder + description + "]" ; } public void process ( Exchange exchange ) throws Exception { Object bean = beanHolder . getBean ( ) ; exchange . setProperty ( "org.apache.camel.bean.BeanHolder" , beanHolder ) ; Processor processor = getProcessor ( ) ; BeanInfo beanInfo = beanHolder . getBeanInfo ( ) ; if ( processor != null ) { processor . process ( exchange ) ; return ; } Message in = exchange . getIn ( ) ; if ( in . getHeader ( MULTI_PARAMETER_ARRAY ) == null ) { in . setHeader ( MULTI_PARAMETER_ARRAY , isMultiParameterArray ( ) ) ; } try { BeanInvocation beanInvoke = in . getBody ( BeanInvocation . class ) ; if ( beanInvoke != null ) { beanInvoke . invoke ( bean , exchange ) ; return ; } } catch ( NoTypeConversionAvailableException ex ) { } boolean isExplicitMethod = false ; String prevMethod = null ; MethodInvocation invocation ; if ( methodObject != null ) { invocation = beanInfo . createInvocation ( methodObject , bean , exchange ) ; } else { if ( ObjectHelper . isNotNullAndNonEmpty ( method ) ) { prevMethod = in . getHeader ( METHOD_NAME , String . class ) ; in . setHeader ( METHOD_NAME , method ) ; isExplicitMethod = true ; } invocation = beanInfo . createInvocation ( bean , exchange ) ; } if ( invocation == null ) { throw new IllegalStateException ( "No method invocation could be created, no maching method could be found on: " + bean ) ; } try { Object value = invocation . proceed ( ) ; if ( value != null ) { if ( exchange . getPattern ( ) . isOutCapable ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Setting bean invocation result on the OUT message: " + value ) ; } exchange . getOut ( true ) . setBody ( value ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Setting bean invocation result on the IN message: " + value ) ; } exchange . getIn ( ) . setBody ( value ) ; } } } catch ( InvocationTargetException e ) { Throwable throwable = e . getCause ( ) ; if ( throwable instanceof Exception ) { Exception exception = ( Exception ) throwable ; throw exception ; } else { Error error = ( Error ) throwable ; throw error ; } } finally { if ( isExplicitMethod ) { in . setHeader ( METHOD_NAME , prevMethod ) ; } } } protected Processor getProcessor ( ) { return beanHolder . getProcessor ( ) ; } public Method getMethodObject ( ) { return methodObject ; } public void setMethodObject ( Method methodObject ) { this . methodObject = methodObject ; } public String getMethod ( ) { return method ; } public boolean isMultiParameterArray ( ) { return multiParameterArray ; } public void setMultiParameterArray ( boolean mpArray ) { multiParameterArray = mpArray ; } public void setMethod ( String method ) { this . method = method ; } @ Deprecated public void setMethodName ( String method ) { setMethod ( method ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startService ( getProcessor ( ) ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopService ( getProcessor ( ) ) ; } } 	1	['17', '2', '0', '25', '53', '104', '8', '17', '13', '0.866071429', '305', '0.714285714', '1', '0.538461538', '0.18125', '1', '1', '16.52941176', '2', '0.7647', '4']
package org . apache . camel . component . mail ; import javax . mail . internet . MimeMessage ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . mail . javamail . JavaMailSender ; import org . springframework . mail . javamail . MimeMessagePreparator ; public class MailProducer extends DefaultProducer < MailExchange > { private static final transient Log LOG = LogFactory . getLog ( MailProducer . class ) ; private final MailEndpoint endpoint ; private final JavaMailSender sender ; public MailProducer ( MailEndpoint endpoint , JavaMailSender sender ) { super ( endpoint ) ; this . endpoint = endpoint ; this . sender = sender ; } public void process ( final Exchange exchange ) { sender . send ( new MimeMessagePreparator ( ) { public void prepare ( MimeMessage mimeMessage ) throws Exception { endpoint . getBinding ( ) . populateMailMessage ( endpoint , mimeMessage , exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sending MimeMessage: " + MailUtils . dumpMessage ( mimeMessage ) ) ; } } } ) ; } } 	0	['5', '3', '0', '9', '9', '4', '2', '9', '2', '0.75', '36', '1', '1', '0.875', '0.3', '0', '0', '5.6', '1', '0.6', '0']
package org . apache . camel . component . seda ; import java . util . Collection ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; public class CollectionProducer extends DefaultProducer implements AsyncProcessor { private final Collection < Exchange > queue ; public CollectionProducer ( Endpoint endpoint , Collection < Exchange > queue ) { super ( endpoint ) ; this . queue = queue ; } public void process ( Exchange exchange ) throws Exception { queue . add ( exchange . copy ( ) ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { queue . add ( exchange . copy ( ) ) ; callback . done ( true ) ; return true ; } } 	1	['3', '3', '0', '6', '7', '0', '1', '5', '3', '0', '29', '1', '0', '0.913043478', '0.533333333', '0', '0', '8.333333333', '1', '0.6667', '1']
package org . apache . camel . component . cxf . util ; import java . io . IOException ; import java . util . List ; import java . util . Set ; import org . apache . cxf . binding . AbstractBindingFactory ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . DestinationFactory ; public class NullDestinationFactory implements DestinationFactory { public Destination getDestination ( EndpointInfo ei ) throws IOException { ei . setAddress ( "local://" + ei . getService ( ) . getName ( ) . toString ( ) + "/" + ei . getName ( ) . getLocalPart ( ) ) ; ei . getBinding ( ) . setProperty ( AbstractBindingFactory . DATABINDING_DISABLED , Boolean . TRUE ) ; return new NullDestination ( ) ; } public List < String > getTransportIds ( ) { return null ; } public Set < String > getUriPrefixes ( ) { return null ; } } 	0	['4', '1', '0', '7', '17', '6', '1', '6', '4', '2', '39', '0', '0', '0', '0.625', '0', '0', '8.75', '1', '0.75', '0']
package org . apache . camel ; import java . util . Map ; import java . util . Set ; import javax . activation . DataHandler ; public interface Message { String getMessageId ( ) ; void setMessageId ( String messageId ) ; Exchange getExchange ( ) ; Object getHeader ( String name ) ; < T > T getHeader ( String name , Class < T > type ) ; void setHeader ( String name , Object value ) ; Object removeHeader ( String name ) ; Map < String , Object > getHeaders ( ) ; void setHeaders ( Map < String , Object > headers ) ; Object getBody ( ) ; < T > T getBody ( Class < T > type ) ; void setBody ( Object body ) ; < T > void setBody ( Object body , Class < T > type ) ; Message copy ( ) ; void copyFrom ( Message message ) ; DataHandler getAttachment ( String id ) ; Set < String > getAttachmentNames ( ) ; void removeAttachment ( String id ) ; void addAttachment ( String id , DataHandler content ) ; Map < String , DataHandler > getAttachments ( ) ; void setAttachments ( Map < String , DataHandler > attachments ) ; boolean hasAttachments ( ) ; } 	1	['22', '1', '0', '182', '22', '231', '182', '1', '22', '2', '22', '0', '0', '0', '0.25974026', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . cxf ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; public class CxfSoapComponent extends DefaultComponent implements HeaderFilterStrategyAware { private HeaderFilterStrategy headerFilterStrategy ; public CxfSoapComponent ( ) { setHeaderFilterStrategy ( new CxfHeaderFilterStrategy ( ) ) ; } @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Map soapProps = IntrospectionSupport . extractProperties ( parameters , "soap." ) ; if ( parameters . size ( ) > 0 ) { remaining += "?" + URISupport . createQueryString ( parameters ) ; } Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( getCamelContext ( ) , remaining ) ; CxfSoapEndpoint soapEndpoint = new CxfSoapEndpoint ( endpoint , getHeaderFilterStrategy ( ) ) ; setProperties ( soapEndpoint , soapProps ) ; soapEndpoint . init ( ) ; return soapEndpoint ; } @ Override protected boolean useIntrospectionOnEndpoint ( ) { return false ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } } 	0	['5', '3', '0', '10', '18', '8', '0', '10', '3', '0.25', '62', '1', '1', '0.897435897', '0.4', '1', '3', '11.2', '1', '0.8', '0']
package org . apache . camel . processor ; import java . io . Serializable ; public class DelayPolicy implements Cloneable , Serializable { protected long delay = 1000L ; public DelayPolicy ( ) { } @ Override public String toString ( ) { return "DelayPolicy[delay=" + delay + "]" ; } public DelayPolicy copy ( ) { try { return ( DelayPolicy ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( "Could not clone: " + e , e ) ; } } public DelayPolicy delay ( long delay ) { setDelay ( delay ) ; return this ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } } 	1	['6', '1', '1', '3', '14', '3', '3', '0', '6', '0.2', '55', '1', '0', '0', '0.666666667', '0', '0', '8', '1', '0.8333', '1']
package org . apache . camel . dataformat . hl7 ; import ca . uhn . hl7v2 . HL7Exception ; import ca . uhn . hl7v2 . model . Message ; import ca . uhn . hl7v2 . parser . Parser ; import ca . uhn . hl7v2 . parser . PipeParser ; import org . apache . camel . Converter ; @ Converter public final class HL7Converter { private HL7Converter ( ) { } @ Converter public static String toString ( Message message ) throws HL7Exception { Parser parser = new PipeParser ( ) ; String encoded = parser . encode ( message ) ; return encoded ; } @ Converter public static Message toMessage ( String body ) throws HL7Exception { body = body . replace ( '\n' , '\r' ) ; Parser parser = new PipeParser ( ) ; Message message = parser . parse ( body ) ; return message ; } } 	0	['3', '1', '0', '6', '8', '3', '2', '4', '2', '2', '31', '0', '0', '0', '0.333333333', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Producer ; public class CamelInvocationHandler implements InvocationHandler { private final Endpoint endpoint ; private final Producer producer ; private final MethodInfoCache methodInfoCache ; public CamelInvocationHandler ( Endpoint endpoint , Producer producer , MethodInfoCache methodInfoCache ) { this . endpoint = endpoint ; this . producer = producer ; this . methodInfoCache = methodInfoCache ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { BeanInvocation invocation = new BeanInvocation ( method , args ) ; ExchangePattern pattern = ExchangePattern . InOut ; MethodInfo methodInfo = methodInfoCache . getMethodInfo ( method ) ; if ( methodInfo != null ) { pattern = methodInfo . getPattern ( ) ; } BeanExchange exchange = new BeanExchange ( endpoint . getCamelContext ( ) , pattern ) ; exchange . setInvocation ( invocation ) ; producer . process ( exchange ) ; Throwable fault = exchange . getException ( ) ; if ( fault != null ) { throw new InvocationTargetException ( fault ) ; } if ( pattern . isOutCapable ( ) ) { return exchange . getOut ( true ) . getBody ( ) ; } else { return null ; } } } 	1	['2', '1', '0', '12', '15', '0', '2', '10', '2', '0', '70', '1', '3', '0', '0.571428571', '0', '0', '32.5', '1', '0.5', '1']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . TryProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "try" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TryType extends OutputType < TryType > { @ XmlTransient private List < CatchType > catchClauses ; @ XmlTransient private FinallyType finallyClause ; @ XmlTransient private boolean initialized ; @ XmlTransient private List < ProcessorType < ? > > outputsWithoutCatches ; @ Override public String toString ( ) { return "Try[" + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "try" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor tryProcessor = createOutputsProcessor ( routeContext , getOutputsWithoutCatches ( ) ) ; Processor finallyProcessor = null ; if ( finallyClause != null ) { finallyProcessor = finallyClause . createProcessor ( routeContext ) ; } List < CatchProcessor > catchProcessors = new ArrayList < CatchProcessor > ( ) ; if ( catchClauses != null ) { for ( CatchType catchClause : catchClauses ) { catchProcessors . add ( catchClause . createProcessor ( routeContext ) ) ; } } return new TryProcessor ( tryProcessor , catchProcessors , finallyProcessor ) ; } public TryType handle ( Class < ? > exceptionType ) { popBlock ( ) ; CatchType answer = new CatchType ( exceptionType ) ; addOutput ( answer ) ; pushBlock ( answer ) ; return this ; } @ Deprecated public TryType handleAll ( ) { return finallyBlock ( ) ; } public TryType finallyBlock ( ) { popBlock ( ) ; FinallyType answer = new FinallyType ( ) ; addOutput ( answer ) ; pushBlock ( answer ) ; return this ; } @ Override public ProcessorType < ? extends ProcessorType > end ( ) { popBlock ( ) ; return super . end ( ) ; } public List < CatchType > getCatchClauses ( ) { if ( catchClauses == null ) { checkInitialized ( ) ; } return catchClauses ; } public FinallyType getFinallyClause ( ) { if ( finallyClause == null ) { checkInitialized ( ) ; } return finallyClause ; } public List < ProcessorType < ? > > getOutputsWithoutCatches ( ) { if ( outputsWithoutCatches == null ) { checkInitialized ( ) ; } return outputsWithoutCatches ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { initialized = false ; super . setOutputs ( outputs ) ; } @ Override public void addOutput ( ProcessorType output ) { initialized = false ; super . addOutput ( output ) ; } protected void checkInitialized ( ) { if ( ! initialized ) { initialized = true ; outputsWithoutCatches = new ArrayList < ProcessorType < ? > > ( ) ; catchClauses = new ArrayList < CatchType > ( ) ; finallyClause = null ; for ( ProcessorType output : outputs ) { if ( output instanceof CatchType ) { catchClauses . add ( ( CatchType ) output ) ; } else if ( output instanceof FinallyType ) { if ( finallyClause != null ) { throw new IllegalArgumentException ( "Multiple finally clauses added: " + finallyClause + " and " + output ) ; } else { finallyClause = ( FinallyType ) output ; } } else { outputsWithoutCatches . add ( output ) ; } } } } } 	0	['14', '4', '0', '11', '37', '73', '3', '9', '13', '0.634615385', '236', '1', '1', '0.932291667', '0.257142857', '1', '16', '15.57142857', '6', '1.5', '0']
package org . apache . camel . processor ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . processor . exceptionpolicy . DefaultExceptionPolicyStrategy ; import org . apache . camel . processor . exceptionpolicy . ExceptionPolicyKey ; import org . apache . camel . processor . exceptionpolicy . ExceptionPolicyStrategy ; public abstract class ErrorHandlerSupport extends ServiceSupport implements ErrorHandler { private Map < ExceptionPolicyKey , ExceptionType > exceptionPolicies = new LinkedHashMap < ExceptionPolicyKey , ExceptionType > ( ) ; private ExceptionPolicyStrategy exceptionPolicy = createDefaultExceptionPolicyStrategy ( ) ; public void addExceptionPolicy ( ExceptionType exceptionType ) { Processor processor = exceptionType . getErrorHandler ( ) ; addChildService ( processor ) ; List < Class > list = exceptionType . getExceptionClasses ( ) ; for ( Class clazz : list ) { ExceptionPolicyKey key = new ExceptionPolicyKey ( clazz , exceptionType . getOnWhen ( ) ) ; exceptionPolicies . put ( key , exceptionType ) ; } } protected boolean customProcessorForException ( Exchange exchange , Throwable exception ) throws Exception { ExceptionType policy = getExceptionPolicy ( exchange , exception ) ; if ( policy != null ) { Processor processor = policy . getErrorHandler ( ) ; if ( processor != null ) { processor . process ( exchange ) ; return true ; } } return false ; } protected ExceptionType getExceptionPolicy ( Exchange exchange , Throwable exception ) { if ( exceptionPolicy == null ) { throw new IllegalStateException ( "The exception policy has not been set" ) ; } return exceptionPolicy . getExceptionPolicy ( exceptionPolicies , exchange , exception ) ; } public void setExceptionPolicy ( ExceptionPolicyStrategy exceptionPolicy ) { this . exceptionPolicy = exceptionPolicy ; } public static ExceptionPolicyStrategy createDefaultExceptionPolicyStrategy ( ) { return new DefaultExceptionPolicyStrategy ( ) ; } } 	1	['6', '2', '2', '14', '21', '5', '5', '9', '4', '0.4', '96', '1', '1', '0.736842105', '0.366666667', '0', '0', '14.66666667', '2', '1.1667', '1']
package org . apache . camel . model . language ; import java . util . Map ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . NamespaceAware ; import org . apache . camel . spi . RouteContext ; @ XmlAccessorType ( XmlAccessType . FIELD ) public abstract class NamespaceAwareExpression extends ExpressionType implements NamespaceAware { @ XmlTransient private Map < String , String > namespaces ; public NamespaceAwareExpression ( ) { } public NamespaceAwareExpression ( String expression ) { super ( expression ) ; } public Map < String , String > getNamespaces ( ) { return namespaces ; } public void setNamespaces ( Map < String , String > namespaces ) { this . namespaces = namespaces ; } @ Override protected void configureExpression ( RouteContext routeContext , Expression expression ) { configureNamespaceAware ( expression ) ; } @ Override protected void configurePredicate ( RouteContext routeContext , Predicate predicate ) { configureNamespaceAware ( predicate ) ; } protected void configureNamespaceAware ( Object builder ) { if ( namespaces != null && builder instanceof NamespaceAware ) { NamespaceAware namespaceAware = ( NamespaceAware ) builder ; namespaceAware . setNamespaces ( namespaces ) ; } } } 	0	['7', '2', '2', '7', '10', '15', '2', '5', '4', '0.333333333', '44', '1', '0', '0.814814815', '0.285714286', '0', '0', '5.142857143', '3', '1', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . Service ; import org . apache . camel . spi . Synchronization ; import org . apache . camel . spi . UnitOfWork ; import org . apache . camel . util . UuidGenerator ; public class DefaultUnitOfWork implements UnitOfWork , Service { private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator ( ) ; private String id ; private List < Synchronization > synchronizations ; private List < AsyncCallback > asyncCallbacks ; private CountDownLatch latch ; public DefaultUnitOfWork ( ) { } public void start ( ) throws Exception { } public void stop ( ) throws Exception { if ( synchronizations != null ) { synchronizations . clear ( ) ; } if ( asyncCallbacks != null ) { asyncCallbacks . clear ( ) ; } } public synchronized void addSynchronization ( Synchronization synchronization ) { if ( synchronizations == null ) { synchronizations = new ArrayList < Synchronization > ( ) ; } synchronizations . add ( synchronization ) ; } public synchronized void removeSynchronization ( Synchronization synchronization ) { if ( synchronizations != null ) { synchronizations . remove ( synchronization ) ; } } public void reset ( ) { } public void done ( Exchange exchange ) { if ( synchronizations != null ) { boolean failed = exchange . isFailed ( ) ; for ( Synchronization synchronization : synchronizations ) { if ( failed ) { synchronization . onFailure ( exchange ) ; } else { synchronization . onComplete ( exchange ) ; } } } } public boolean isSynchronous ( ) { return asyncCallbacks == null || asyncCallbacks . isEmpty ( ) ; } public String getId ( ) { if ( id == null ) { id = DEFAULT_ID_GENERATOR . generateId ( ) ; } return id ; } } 	1	['10', '1', '0', '7', '24', '29', '2', '5', '9', '0.911111111', '110', '1', '1', '0', '0.444444444', '0', '0', '9.5', '4', '1.6', '7']
package org . apache . camel . component . jpa ; import java . util . Iterator ; import javax . persistence . EntityManager ; import javax . persistence . PersistenceException ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . DefaultProducer ; import org . springframework . orm . jpa . JpaCallback ; public class JpaProducer extends DefaultProducer < Exchange > { private final TransactionStrategy template ; private final JpaEndpoint endpoint ; private final Expression < Exchange > expression ; public JpaProducer ( JpaEndpoint endpoint , Expression < Exchange > expression ) { super ( endpoint ) ; this . endpoint = endpoint ; this . expression = expression ; this . template = endpoint . createTransactionStrategy ( ) ; } public void process ( Exchange exchange ) { final Object values = expression . evaluate ( exchange ) ; if ( values != null ) { template . execute ( new JpaCallback ( ) { public Object doInJpa ( EntityManager entityManager ) throws PersistenceException { Iterator iter = ObjectConverter . iterator ( values ) ; while ( iter . hasNext ( ) ) { Object value = iter . next ( ) ; entityManager . persist ( value ) ; } if ( endpoint . isFlushOnSend ( ) ) { entityManager . flush ( ) ; } return null ; } } ) ; } exchange . setProperty ( "CamelJpaValue" , values ) ; } } 	0	['3', '3', '0', '8', '9', '0', '2', '8', '2', '0.5', '44', '1', '3', '0.913043478', '0.4', '0', '0', '12.66666667', '2', '1', '0']
package org . apache . camel . processor ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . AlreadyStoppedException ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class DelayProcessorSupport extends DelegateProcessor { private static final transient Log LOG = LogFactory . getLog ( Delayer . class ) ; private CountDownLatch stoppedLatch = new CountDownLatch ( 1 ) ; private boolean fastStop = true ; public DelayProcessorSupport ( Processor processor ) { super ( processor ) ; } public void process ( Exchange exchange ) throws Exception { delay ( exchange ) ; super . process ( exchange ) ; } public boolean isFastStop ( ) { return fastStop ; } public void setFastStop ( boolean fastStop ) { this . fastStop = fastStop ; } protected void doStop ( ) throws Exception { stoppedLatch . countDown ( ) ; super . doStop ( ) ; } protected abstract void delay ( Exchange exchange ) throws Exception ; protected void waitUntil ( long time , Exchange exchange ) throws Exception { while ( true ) { long delay = time - currentSystemTime ( ) ; if ( delay < 0 ) { return ; } else { if ( isFastStop ( ) && ! isRunAllowed ( ) ) { throw new AlreadyStoppedException ( ) ; } try { sleep ( delay ) ; } catch ( InterruptedException e ) { handleSleepInteruptedException ( e ) ; } } } } protected void sleep ( long delay ) throws InterruptedException { if ( delay <= 0 ) { return ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Sleeping for: " + delay + " millis" ) ; } if ( isFastStop ( ) ) { stoppedLatch . await ( delay , TimeUnit . MILLISECONDS ) ; } else { Thread . sleep ( delay ) ; } } protected void handleSleepInteruptedException ( InterruptedException e ) { LOG . debug ( "Sleep interupted: " + e , e ) ; } protected long currentSystemTime ( ) { return System . currentTimeMillis ( ) ; } } 	1	['11', '3', '3', '9', '30', '37', '3', '6', '4', '0.666666667', '127', '1', '0', '0.709677419', '0.3', '1', '1', '10.27272727', '1', '0.8182', '1']
package org . apache . camel . component . stream ; import org . apache . camel . impl . DefaultMessage ; public class StreamMessage extends DefaultMessage { private Object o ; public StreamMessage ( Object o ) { this . o = o ; } @ Override protected Object createBody ( ) { return o ; } @ Override public Object getBody ( ) { return o ; } @ Override public String toString ( ) { return o . toString ( ) ; } } 	0	['4', '3', '0', '1', '6', '0', '0', '1', '3', '0', '21', '1', '0', '0.921052632', '0.625', '2', '2', '4', '1', '0.75', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . Collection ; import java . util . LinkedList ; import java . util . List ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . RejectedExecutionHandler ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . camel . util . concurrent . AtomicExchange ; import org . apache . camel . util . concurrent . CountingLatch ; import static org . apache . camel . util . ObjectHelper . notNull ; public class MulticastProcessor extends ServiceSupport implements Processor { static class ProcessorExchangePair { private final Processor processor ; private final Exchange exchange ; public ProcessorExchangePair ( Processor processor , Exchange exchange ) { this . processor = processor ; this . exchange = exchange ; } public Processor getProcessor ( ) { return processor ; } public Exchange getExchange ( ) { return exchange ; } } private Collection < Processor > processors ; private AggregationStrategy aggregationStrategy ; private boolean isParallelProcessing ; private ThreadPoolExecutor executor ; private final boolean streaming ; private final AtomicBoolean shutdown = new AtomicBoolean ( true ) ; public MulticastProcessor ( Collection < Processor > processors ) { this ( processors , null ) ; } public MulticastProcessor ( Collection < Processor > processors , AggregationStrategy aggregationStrategy ) { this ( processors , aggregationStrategy , false , null ) ; } public MulticastProcessor ( Collection < Processor > processors , AggregationStrategy aggregationStrategy , boolean parallelProcessing , ThreadPoolExecutor executor ) { this ( processors , aggregationStrategy , parallelProcessing , executor , false ) ; } public MulticastProcessor ( Collection < Processor > processors , AggregationStrategy aggregationStrategy , boolean parallelProcessing , ThreadPoolExecutor executor , boolean streaming ) { notNull ( processors , "processors" ) ; this . processors = processors ; this . aggregationStrategy = aggregationStrategy ; this . isParallelProcessing = parallelProcessing ; if ( isParallelProcessing ) { if ( executor != null ) { this . executor = executor ; } else { this . executor = new ThreadPoolExecutor ( processors . size ( ) , processors . size ( ) , 0 , TimeUnit . MILLISECONDS , new ArrayBlockingQueue < Runnable > ( processors . size ( ) ) ) ; } } this . streaming = streaming ; } public static < E extends Exchange > Collection < Processor > toProducers ( Collection < Endpoint > endpoints ) throws Exception { Collection < Processor > answer = new ArrayList < Processor > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint . createProducer ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "Multicast" + getProcessors ( ) ; } class ProcessCall implements Runnable { private final Exchange exchange ; private final AsyncCallback callback ; private final Processor processor ; public ProcessCall ( Exchange exchange , Processor processor , AsyncCallback callback ) { this . exchange = exchange ; this . callback = callback ; this . processor = processor ; } public void run ( ) { if ( shutdown . get ( ) ) { exchange . setException ( new RejectedExecutionException ( ) ) ; callback . done ( false ) ; } else { try { processor . process ( exchange ) ; } catch ( Exception ex ) { exchange . setException ( ex ) ; } callback . done ( false ) ; } } } public void process ( Exchange exchange ) throws Exception { final AtomicExchange result = new AtomicExchange ( ) ; Iterable < ProcessorExchangePair > pairs = createProcessorExchangePairs ( exchange ) ; if ( isParallelProcessing ) { List < Exchange > exchanges = new LinkedList < Exchange > ( ) ; final CountingLatch completedExchanges = new CountingLatch ( ) ; int i = 0 ; for ( ProcessorExchangePair pair : pairs ) { Processor producer = pair . getProcessor ( ) ; final Exchange subExchange = pair . getExchange ( ) ; updateNewExchange ( subExchange , i , pairs ) ; exchanges . add ( subExchange ) ; completedExchanges . increment ( ) ; ProcessCall call = new ProcessCall ( subExchange , producer , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { if ( streaming && aggregationStrategy != null ) { doAggregate ( result , subExchange ) ; } completedExchanges . decrement ( ) ; } } ) ; executor . execute ( call ) ; i ++ ; } completedExchanges . await ( ) ; if ( ! streaming && aggregationStrategy != null ) { for ( Exchange resultExchange : exchanges ) { doAggregate ( result , resultExchange ) ; } } } else { int i = 0 ; for ( ProcessorExchangePair pair : pairs ) { Processor producer = pair . getProcessor ( ) ; Exchange subExchange = pair . getExchange ( ) ; updateNewExchange ( subExchange , i , pairs ) ; try { producer . process ( subExchange ) ; } catch ( Exception exception ) { subExchange . setException ( exception ) ; } doAggregate ( result , subExchange ) ; i ++ ; } } if ( result . get ( ) != null ) { ExchangeHelper . copyResults ( exchange , result . get ( ) ) ; } } protected synchronized void doAggregate ( AtomicExchange result , Exchange exchange ) { if ( aggregationStrategy != null ) { if ( result . get ( ) == null ) { result . set ( exchange ) ; } else { result . set ( aggregationStrategy . aggregate ( result . get ( ) , exchange ) ) ; } } } protected void updateNewExchange ( Exchange exchange , int i , Iterable < ProcessorExchangePair > allPairs ) { } protected Iterable < ProcessorExchangePair > createProcessorExchangePairs ( Exchange exchange ) { List < ProcessorExchangePair > result = new ArrayList < ProcessorExchangePair > ( processors . size ( ) ) ; Processor [ ] processorsArray = processors . toArray ( new Processor [ processors . size ( ) ] ) ; for ( int i = 0 ; i < processorsArray . length ; i ++ ) { result . add ( new ProcessorExchangePair ( processorsArray [ i ] , exchange . copy ( ) ) ) ; } return result ; } protected void doStop ( ) throws Exception { shutdown . set ( true ) ; if ( executor != null ) { executor . shutdown ( ) ; executor . awaitTermination ( 0 , TimeUnit . SECONDS ) ; } ServiceHelper . stopServices ( processors ) ; } protected void doStart ( ) throws Exception { shutdown . set ( false ) ; if ( executor != null ) { executor . setRejectedExecutionHandler ( new RejectedExecutionHandler ( ) { public void rejectedExecution ( Runnable runnable , ThreadPoolExecutor executor ) { ProcessCall call = ( ProcessCall ) runnable ; call . exchange . setException ( new RejectedExecutionException ( ) ) ; call . callback . done ( false ) ; } } ) ; } ServiceHelper . startServices ( processors ) ; } protected boolean isStreaming ( ) { return streaming ; } public Collection < Processor > getProcessors ( ) { return processors ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } } 	1	['18', '2', '2', '20', '64', '93', '7', '16', '9', '0.745098039', '377', '1', '1', '0.5', '0.2', '1', '1', '19.61111111', '3', '0.9444', '8']
package org . apache . camel . component . mail ; import java . net . URI ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import javax . mail . Authenticator ; import javax . mail . Message ; import javax . mail . PasswordAuthentication ; import javax . mail . Session ; import org . apache . camel . RuntimeCamelException ; import org . springframework . mail . javamail . JavaMailSenderImpl ; public class MailConfiguration implements Cloneable { public static final String DEFAULT_FOLDER_NAME = "INBOX" ; public static final String DEFAULT_FROM = "camel@localhost" ; public static final long DEFAULT_CONNECTION_TIMEOUT = 30000L ; private Properties javaMailProperties ; private String protocol ; private String host ; private int port = - 1 ; private String username ; private String password ; private Session session ; private String defaultEncoding ; private String from = DEFAULT_FROM ; private String folderName = DEFAULT_FOLDER_NAME ; private boolean deleteProcessedMessages ; private boolean ignoreUriScheme ; private boolean processOnlyUnseenMessages = true ; private Map < Message . RecipientType , String > recipients = new HashMap < Message . RecipientType , String > ( ) ; private String destination ; private int fetchSize = - 1 ; private boolean debugMode ; private long connectionTimeout = DEFAULT_CONNECTION_TIMEOUT ; private boolean dummyTrustManager ; private String contentType = "text/plain" ; public MailConfiguration ( ) { } public MailConfiguration copy ( ) { try { return ( MailConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public void configure ( URI uri ) { String value = uri . getHost ( ) ; if ( value != null ) { setHost ( value ) ; } if ( ! isIgnoreUriScheme ( ) ) { String scheme = uri . getScheme ( ) ; if ( scheme != null ) { setProtocol ( scheme ) ; } } String userInfo = uri . getUserInfo ( ) ; if ( userInfo != null ) { setUsername ( userInfo ) ; } int port = uri . getPort ( ) ; if ( port > 0 ) { setPort ( port ) ; } else if ( port <= 0 && this . port <= 0 ) { setPort ( MailUtils . getDefaultPortForProtocol ( uri . getScheme ( ) ) ) ; } } protected JavaMailSenderImpl createJavaMailSender ( ) { JavaMailSenderImpl answer = new JavaMailSenderImpl ( ) ; answer . getSession ( ) . setDebug ( debugMode ) ; if ( javaMailProperties != null ) { answer . setJavaMailProperties ( javaMailProperties ) ; } else { answer . setJavaMailProperties ( createJavaMailProperties ( ) ) ; } if ( defaultEncoding != null ) { answer . setDefaultEncoding ( defaultEncoding ) ; } if ( host != null ) { answer . setHost ( host ) ; } if ( port >= 0 ) { answer . setPort ( port ) ; } if ( password != null ) { answer . setPassword ( password ) ; } if ( protocol != null ) { answer . setProtocol ( protocol ) ; } if ( session != null ) { answer . setSession ( session ) ; } else { Session session = Session . getDefaultInstance ( answer . getJavaMailProperties ( ) , getAuthenticator ( ) ) ; answer . setSession ( session ) ; } if ( username != null ) { answer . setUsername ( username ) ; } return answer ; } private Properties createJavaMailProperties ( ) { Properties properties = ( Properties ) System . getProperties ( ) . clone ( ) ; properties . put ( "mail." + protocol + ".connectiontimeout" , connectionTimeout ) ; properties . put ( "mail." + protocol + ".timeout" , connectionTimeout ) ; properties . put ( "mail." + protocol + ".host" , host ) ; properties . put ( "mail." + protocol + ".port" , "" + port ) ; if ( username != null ) { properties . put ( "mail." + protocol + ".user" , username ) ; properties . put ( "mail.user" , username ) ; properties . put ( "mail." + protocol + ".auth" , "true" ) ; } else { properties . put ( "mail." + protocol + ".auth" , "false" ) ; } properties . put ( "mail." + protocol + ".rsetbeforequit" , "true" ) ; properties . put ( "mail.transport.protocol" , protocol ) ; properties . put ( "mail.store.protocol" , protocol ) ; properties . put ( "mail.host" , host ) ; if ( debugMode ) { properties . put ( "javax.net.debug" , "all" ) ; } if ( dummyTrustManager && isSecureProtocol ( ) ) { properties . put ( "mail." + protocol + ".socketFactory.class" , "org.apache.camel.component.mail.security.DummySSLSocketFactory" ) ; properties . put ( "mail." + protocol + ".socketFactory.fallback" , "false" ) ; properties . put ( "mail." + protocol + ".socketFactory.port" , "" + port ) ; } return properties ; } public boolean isSecureProtocol ( ) { return this . protocol . equalsIgnoreCase ( "smtps" ) || this . protocol . equalsIgnoreCase ( "pop3s" ) || this . protocol . equalsIgnoreCase ( "imaps" ) ; } public Authenticator getAuthenticator ( ) { return new Authenticator ( ) { protected PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( getUsername ( ) , getPassword ( ) ) ; } } ; } public String getMailStoreLogInformation ( ) { String ssl = "" ; if ( isSecureProtocol ( ) ) { ssl = "(SSL enabled" + ( dummyTrustManager ? " using DummyTrustManager)" : ")" ) ; } return protocol + "//" + host + ":" + port + ssl + ", folder=" + folderName ; } public String getDefaultEncoding ( ) { return defaultEncoding ; } public void setDefaultEncoding ( String defaultEncoding ) { this . defaultEncoding = defaultEncoding ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public Properties getJavaMailProperties ( ) { return javaMailProperties ; } public void setJavaMailProperties ( Properties javaMailProperties ) { this . javaMailProperties = javaMailProperties ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } public String getProtocol ( ) { return protocol ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public Session getSession ( ) { return session ; } public void setSession ( Session session ) { this . session = session ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; if ( destination == null ) { String address = username ; if ( address . indexOf ( "@" ) == - 1 ) { address += "@" + host ; } destination = address ; } } public String getDestination ( ) { return destination ; } public void setDestination ( String destination ) { this . destination = destination ; } public String getFrom ( ) { return from ; } public void setFrom ( String from ) { this . from = from ; } public boolean isDeleteProcessedMessages ( ) { return deleteProcessedMessages ; } public void setDeleteProcessedMessages ( boolean deleteProcessedMessages ) { this . deleteProcessedMessages = deleteProcessedMessages ; } public String getFolderName ( ) { return folderName ; } public void setFolderName ( String folderName ) { this . folderName = folderName ; } public boolean isIgnoreUriScheme ( ) { return ignoreUriScheme ; } public void setIgnoreUriScheme ( boolean ignoreUriScheme ) { this . ignoreUriScheme = ignoreUriScheme ; } public boolean isProcessOnlyUnseenMessages ( ) { return processOnlyUnseenMessages ; } public void setProcessOnlyUnseenMessages ( boolean processOnlyUnseenMessages ) { this . processOnlyUnseenMessages = processOnlyUnseenMessages ; } public void setTo ( String address ) { recipients . put ( Message . RecipientType . TO , address ) ; } public void setCC ( String address ) { recipients . put ( Message . RecipientType . CC , address ) ; } public void setBCC ( String address ) { recipients . put ( Message . RecipientType . BCC , address ) ; } public Map < Message . RecipientType , String > getRecipients ( ) { return recipients ; } public int getFetchSize ( ) { return fetchSize ; } public void setFetchSize ( int fetchSize ) { this . fetchSize = fetchSize ; } public boolean isDebugMode ( ) { return debugMode ; } public void setDebugMode ( boolean debugMode ) { this . debugMode = debugMode ; } public long getConnectionTimeout ( ) { return connectionTimeout ; } public void setConnectionTimeout ( long connectionTimeout ) { this . connectionTimeout = connectionTimeout ; } public boolean isDummyTrustManager ( ) { return dummyTrustManager ; } public void setDummyTrustManager ( boolean dummyTrustManager ) { this . dummyTrustManager = dummyTrustManager ; } public String getContentType ( ) { return contentType ; } public void setContentType ( String contentType ) { this . contentType = contentType ; } } 	0	['50', '1', '0', '8', '84', '1011', '5', '4', '48', '0.947648625', '726', '0.869565217', '0', '0', '0.1825', '0', '0', '13.06', '9', '1.5', '0']
package org . apache . camel . impl ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import javax . naming . Context ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . Routes ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . management . InstrumentationLifecycleStrategy ; import org . apache . camel . management . JmxSystemPropertyKeys ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . processor . interceptor . Delayer ; import org . apache . camel . processor . interceptor . TraceFormatter ; import org . apache . camel . processor . interceptor . Tracer ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ReflectionInjector ; import org . apache . camel . util . SystemHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private static final transient Log LOG = LogFactory . getLog ( DefaultCamelContext . class ) ; private static final String NAME_PREFIX = "camel-" ; private static int nameSuffix ; private String name ; private final Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private final Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; private LanguageResolver languageResolver = new DefaultLanguageResolver ( ) ; private Registry registry ; private LifecycleStrategy lifecycleStrategy ; private List < RouteType > routeDefinitions = new ArrayList < RouteType > ( ) ; private List < InterceptStrategy > interceptStrategies = new ArrayList < InterceptStrategy > ( ) ; private Boolean trace ; private Long delay ; private ErrorHandlerBuilder errorHandlerBuilder ; private Map < String , DataFormatType > dataFormats = new HashMap < String , DataFormatType > ( ) ; private Class < ? extends FactoryFinder > factoryFinderClass = FactoryFinder . class ; public DefaultCamelContext ( ) { name = NAME_PREFIX + ++ nameSuffix ; if ( Boolean . getBoolean ( JmxSystemPropertyKeys . DISABLED ) ) { LOG . info ( "JMX is disabled. Using DefaultLifecycleStrategy." ) ; lifecycleStrategy = new DefaultLifecycleStrategy ( ) ; } else { try { LOG . info ( "JMX enabled. Using InstrumentationLifecycleStrategy." ) ; lifecycleStrategy = new InstrumentationLifecycleStrategy ( ) ; } catch ( NoClassDefFoundError e ) { LOG . warn ( "Could not find needed classes for JMX lifecycle strategy." + " Needed class is in spring-context.jar using Spring 2.5 or newer (" + " spring-jmx.jar using Spring 2.0.x)." + " NoClassDefFoundError: " + e . getMessage ( ) ) ; } catch ( Exception e ) { LOG . warn ( "Could not create JMX lifecycle strategy, caused by: " + e . getMessage ( ) ) ; } if ( lifecycleStrategy == null ) { LOG . warn ( "Not possible to use JMX lifecycle strategy. Using DefaultLifecycleStrategy instead." ) ; lifecycleStrategy = new DefaultLifecycleStrategy ( ) ; } } } public DefaultCamelContext ( Context jndiContext ) { this ( ) ; setJndiContext ( jndiContext ) ; } public DefaultCamelContext ( Registry registry ) { this ( ) ; this . registry = registry ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Collection < Endpoint > getEndpoints ( String uri ) { Collection < Endpoint > answer = new ArrayList < Endpoint > ( ) ; Collection < Endpoint > coll ; synchronized ( endpoints ) { Endpoint ep = endpoints . get ( uri ) ; if ( ep != null ) { answer . add ( ep ) ; return answer ; } coll = new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } for ( Endpoint ep : coll ) { if ( ! ep . isSingleton ( ) && uri . equals ( ep . getEndpointUri ( ) ) ) { answer . add ( ep ) ; } } return answer ; } public Collection < Endpoint > getSingletonEndpoints ( ) { Collection < Endpoint > answer = new ArrayList < Endpoint > ( ) ; Collection < Endpoint > coll = getEndpoints ( ) ; for ( Endpoint ep : coll ) { if ( ep . isSingleton ( ) ) { answer . add ( ep ) ; } } return answer ; } public Endpoint addEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( CamelContextHelper . getEndpointKey ( uri , endpoint ) , endpoint ) ; if ( oldEndpoint != null ) { stopServices ( oldEndpoint ) ; } } return oldEndpoint ; } public Collection < Endpoint > removeEndpoints ( String uri ) throws Exception { Collection < Endpoint > answer = new ArrayList < Endpoint > ( ) ; synchronized ( endpoints ) { Endpoint oldEndpoint = endpoints . remove ( uri ) ; if ( oldEndpoint != null ) { answer . add ( oldEndpoint ) ; stopServices ( oldEndpoint ) ; } else { for ( Map . Entry entry : endpoints . entrySet ( ) ) { oldEndpoint = ( Endpoint ) entry . getValue ( ) ; if ( ! oldEndpoint . isSingleton ( ) && uri . equals ( oldEndpoint . getEndpointUri ( ) ) ) { answer . add ( oldEndpoint ) ; stopServices ( oldEndpoint ) ; endpoints . remove ( entry . getKey ( ) ) ; } } } } return answer ; } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { return addEndpoint ( uri , endpoint ) ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Collection < Endpoint > answer = removeEndpoints ( uri ) ; return ( Endpoint ) ( answer . size ( ) > 0 ? answer . toArray ( ) [ 0 ] : null ) ; } public Endpoint getEndpoint ( String uri ) { Endpoint < ? > answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] != null ) { String scheme = splitURI [ 0 ] ; Component < ? > component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( uri + " converted to endpoint: " + answer + " by component: " + component ) ; } } } if ( answer == null ) { answer = createEndpoint ( uri ) ; } if ( answer != null ) { addService ( answer ) ; endpoints . put ( CamelContextHelper . getEndpointKey ( uri , answer ) , answer ) ; lifecycleStrategy . onEndpointAdd ( answer ) ; } } catch ( Exception e ) { LOG . debug ( "Failed to resolve endpoint " + uri + ". Reason: " + e , e ) ; throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { if ( routes == null ) { routes = new ArrayList < Route > ( ) ; } return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; throw new UnsupportedOperationException ( "overriding existing routes is not supported yet, use addRoutes instead" ) ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( ) ; } if ( routes != null ) { this . routes . addAll ( routes ) ; lifecycleStrategy . onRoutesAdd ( routes ) ; if ( shouldStartRoutes ( ) ) { startRoutes ( routes ) ; } } } public void addRoutes ( Routes builder ) throws Exception { builder . setContext ( this ) ; List < Route > routeList = builder . getRouteList ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Adding routes from: " + builder + " routes: " + routeList ) ; } addRoutes ( routeList ) ; } public void addRouteDefinitions ( Collection < RouteType > routeDefinitions ) throws Exception { this . routeDefinitions . addAll ( routeDefinitions ) ; if ( shouldStartRoutes ( ) ) { startRouteDefinitions ( routeDefinitions ) ; } } public void addService ( Object object ) throws Exception { if ( object instanceof Service ) { Service service = ( Service ) object ; getLifecycleStrategy ( ) . onServiceAdd ( this , service ) ; service . start ( ) ; servicesToClose . add ( service ) ; } } public Language resolveLanguage ( String language ) { return getLanguageResolver ( ) . resolveLanguage ( language , this ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } public LanguageResolver getLanguageResolver ( ) { return languageResolver ; } public void setLanguageResolver ( LanguageResolver languageResolver ) { this . languageResolver = languageResolver ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } public Registry getRegistry ( ) { if ( registry == null ) { registry = createRegistry ( ) ; } return registry ; } public void setJndiContext ( Context jndiContext ) { setRegistry ( new JndiRegistry ( jndiContext ) ) ; } public void setRegistry ( Registry registry ) { this . registry = registry ; } public LifecycleStrategy getLifecycleStrategy ( ) { return lifecycleStrategy ; } public void setLifecycleStrategy ( LifecycleStrategy lifecycleStrategy ) { this . lifecycleStrategy = lifecycleStrategy ; } public List < RouteType > getRouteDefinitions ( ) { return routeDefinitions ; } public List < InterceptStrategy > getInterceptStrategies ( ) { return interceptStrategies ; } public void setInterceptStrategies ( List < InterceptStrategy > interceptStrategies ) { this . interceptStrategies = interceptStrategies ; } public void addInterceptStrategy ( InterceptStrategy interceptStrategy ) { getInterceptStrategies ( ) . add ( interceptStrategy ) ; } public boolean getTrace ( ) { final Boolean value = getTracing ( ) ; if ( value != null ) { return value ; } else { return SystemHelper . isSystemProperty ( "camel.trace" ) ; } } public Boolean getTracing ( ) { return trace ; } public void setTrace ( Boolean trace ) { this . trace = trace ; } public long getDelay ( ) { final Long value = getDelaying ( ) ; if ( value != null ) { return value ; } else { String prop = SystemHelper . getSystemProperty ( "camel.delay" ) ; return prop != null ? Long . getLong ( prop ) : 0 ; } } public Long getDelaying ( ) { return delay ; } public void setDelay ( Long delay ) { this . delay = delay ; } public < E extends Exchange > ProducerTemplate < E > createProducerTemplate ( ) { return new DefaultProducerTemplate < E > ( this ) ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { return errorHandlerBuilder ; } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } protected void doStart ( ) throws Exception { LOG . info ( "Apache Camel " + getVersion ( ) + " (CamelContext:" + getName ( ) + ") is starting" ) ; if ( getTrace ( ) ) { if ( Tracer . getTracer ( this ) == null ) { Tracer tracer = new Tracer ( ) ; TraceFormatter formatter = this . getRegistry ( ) . lookup ( "traceFormatter" , TraceFormatter . class ) ; if ( formatter != null ) { tracer . setFormatter ( formatter ) ; } addInterceptStrategy ( tracer ) ; } } if ( getDelay ( ) > 0 ) { if ( Delayer . getDelayer ( this ) == null ) { addInterceptStrategy ( new Delayer ( getDelay ( ) ) ) ; } } lifecycleStrategy . onContextStart ( this ) ; forceLazyInitialization ( ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRouteDefinitions ( routeDefinitions ) ; startRoutes ( routes ) ; LOG . info ( "Apache Camel " + getVersion ( ) + " (CamelContext:" + getName ( ) + ") started" ) ; } protected void startRouteDefinitions ( Collection < RouteType > list ) throws Exception { if ( list != null ) { Collection < Route > routes = new ArrayList < Route > ( ) ; for ( RouteType route : list ) { route . addRoutes ( this , routes ) ; } addRoutes ( routes ) ; } } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; for ( Service service : services ) { addService ( service ) ; } } } } protected void forceLazyInitialization ( ) { getExchangeConverter ( ) ; getInjector ( ) ; getLanguageResolver ( ) ; getTypeConverter ( ) ; } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( getInjector ( ) ) ; } protected Injector createInjector ( ) { FactoryFinder finder = createFactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } protected Registry createRegistry ( ) { return new JndiRegistry ( ) ; } protected Endpoint createEndpoint ( String uri ) { Object value = getRegistry ( ) . lookup ( uri ) ; if ( value instanceof Endpoint ) { return ( Endpoint ) value ; } else if ( value instanceof Processor ) { return new ProcessorEndpoint ( uri , this , ( Processor ) value ) ; } else if ( value != null ) { return convertBeanToEndpoint ( uri , value ) ; } return null ; } protected Endpoint convertBeanToEndpoint ( String uri , Object bean ) { throw new IllegalArgumentException ( "uri: " + uri + " bean: " + bean + " could not be converted to an Endpoint" ) ; } protected boolean shouldStartRoutes ( ) { return isStarted ( ) && ! isStarting ( ) ; } public void setDataFormats ( Map < String , DataFormatType > dataFormats ) { this . dataFormats = dataFormats ; } public Map < String , DataFormatType > getDataFormats ( ) { return dataFormats ; } public void setFactoryFinderClass ( Class < ? extends FactoryFinder > finderClass ) { factoryFinderClass = finderClass ; } public FactoryFinder createFactoryFinder ( ) { try { return factoryFinderClass . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } public FactoryFinder createFactoryFinder ( String path ) { try { Constructor < ? extends FactoryFinder > constructor ; constructor = factoryFinderClass . getConstructor ( String . class ) ; return constructor . newInstance ( path ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } 	1	['75', '2', '1', '56', '171', '2573', '15', '44', '61', '0.9306698', '1510', '1', '8', '0.164705882', '0.069256757', '1', '1', '18.82666667', '7', '1.36', '18']
package org . apache . camel . util ; import java . util . Comparator ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class ExpressionListComparator implements Comparator < Exchange > { private final List < Expression > expressions ; public ExpressionListComparator ( List < Expression > expressions ) { this . expressions = expressions ; } public int compare ( Exchange e1 , Exchange e2 ) { for ( Expression expression : expressions ) { Object o1 = expression . evaluate ( e1 ) ; Object o2 = expression . evaluate ( e2 ) ; int answer = ObjectHelper . compare ( o1 , o2 ) ; if ( answer != 0 ) { return answer ; } } return 0 ; } } 	0	['3', '1', '0', '4', '9', '1', '1', '3', '3', '0', '47', '1', '0', '0', '0.5', '0', '0', '14.33333333', '2', '1', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . concurrent . ThreadPoolExecutor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . util . CollectionHelper ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; public class Splitter extends MulticastProcessor implements Processor { public static final String SPLIT_SIZE = "org.apache.camel.splitSize" ; public static final String SPLIT_COUNTER = "org.apache.camel.splitCounter" ; private final Expression expression ; public Splitter ( Expression expression , Processor destination , AggregationStrategy aggregationStrategy ) { this ( expression , destination , aggregationStrategy , false , null , false ) ; } public Splitter ( Expression expression , Processor destination , AggregationStrategy aggregationStrategy , boolean parallelProcessing , ThreadPoolExecutor threadPoolExecutor , boolean streaming ) { super ( Collections . singleton ( destination ) , aggregationStrategy , parallelProcessing , threadPoolExecutor , streaming ) ; this . expression = expression ; notNull ( expression , "expression" ) ; notNull ( destination , "destination" ) ; } @ Override public String toString ( ) { return "Splitter[on: " + expression + " to: " + getProcessors ( ) . iterator ( ) . next ( ) + " aggregate: " + getAggregationStrategy ( ) + "]" ; } @ Override protected Iterable < ProcessorExchangePair > createProcessorExchangePairs ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; if ( isStreaming ( ) ) { return createProcessorExchangePairsIterable ( exchange , value ) ; } else { return createProcessorExchangePairsList ( exchange , value ) ; } } private Iterable < ProcessorExchangePair > createProcessorExchangePairsIterable ( final Exchange exchange , Object value ) { final Iterator iterator = ObjectHelper . createIterator ( value ) ; return new Iterable ( ) { public Iterator iterator ( ) { return new Iterator ( ) { public boolean hasNext ( ) { return iterator . hasNext ( ) ; } public Object next ( ) { Object part = iterator . next ( ) ; Exchange newExchange = exchange . copy ( ) ; Message in = newExchange . getIn ( ) ; in . setBody ( part ) ; return new ProcessorExchangePair ( getProcessors ( ) . iterator ( ) . next ( ) , newExchange ) ; } public void remove ( ) { throw new UnsupportedOperationException ( "remove is not supported by this iterator" ) ; } } ; } } ; } private Iterable < ProcessorExchangePair > createProcessorExchangePairsList ( Exchange exchange , Object value ) { List < ProcessorExchangePair > result ; Integer collectionSize = CollectionHelper . size ( value ) ; if ( collectionSize != null ) { result = new ArrayList < ProcessorExchangePair > ( collectionSize ) ; } else { result = new ArrayList < ProcessorExchangePair > ( ) ; } Iterator < Object > iter = ObjectHelper . createIterator ( value ) ; while ( iter . hasNext ( ) ) { Object part = iter . next ( ) ; Exchange newExchange = exchange . copy ( ) ; Message in = newExchange . getIn ( ) ; in . setBody ( part ) ; result . add ( new ProcessorExchangePair ( getProcessors ( ) . iterator ( ) . next ( ) , newExchange ) ) ; } return result ; } @ Override protected void updateNewExchange ( Exchange exchange , int i , Iterable < ProcessorExchangePair > allPairs ) { exchange . getIn ( ) . setHeader ( SPLIT_COUNTER , i ) ; if ( allPairs instanceof Collection ) { exchange . getIn ( ) . setHeader ( SPLIT_SIZE , ( ( Collection ) allPairs ) . size ( ) ) ; } } } 	1	['7', '3', '0', '12', '35', '15', '3', '10', '3', '0.944444444', '156', '0.333333333', '1', '0.848484848', '0.328571429', '1', '2', '20.85714286', '3', '1.2857', '5']
package org . apache . camel . component . jms ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Session ; import javax . jms . TemporaryQueue ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . SessionCallback ; public class JmsTemporaryQueueEndpoint extends JmsQueueEndpoint implements DestinationEndpoint { private Destination jmsDestination ; public JmsTemporaryQueueEndpoint ( String uri , JmsComponent component , String destination , JmsConfiguration configuration ) { super ( uri , component , destination , configuration ) ; } public JmsTemporaryQueueEndpoint ( String uri , JmsComponent component , String destination , JmsConfiguration configuration , QueueBrowseStrategy queueBrowseStrategy ) { super ( uri , component , destination , configuration , queueBrowseStrategy ) ; } public JmsTemporaryQueueEndpoint ( String endpointUri , String destination ) { super ( endpointUri , destination ) ; } public boolean isSingleton ( ) { return true ; } public synchronized Destination getJmsDestination ( Session session ) throws JMSException { if ( jmsDestination == null ) { jmsDestination = createJmsDestination ( session ) ; } return jmsDestination ; } protected Destination createJmsDestination ( Session session ) throws JMSException { return session . createTemporaryQueue ( ) ; } } 	0	['6', '4', '0', '5', '10', '15', '1', '5', '5', '1', '43', '1', '0', '0.950819672', '0.444444444', '0', '0', '6', '1', '0.5', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Producer ; import org . apache . camel . Service ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SendProcessor extends ServiceSupport implements AsyncProcessor , Service { private static final transient Log LOG = LogFactory . getLog ( SendProcessor . class ) ; private Endpoint destination ; private Producer producer ; private AsyncProcessor processor ; private ExchangePattern pattern ; public SendProcessor ( Endpoint destination ) { if ( destination == null ) { throw new IllegalArgumentException ( "Endpoint cannot be null!" ) ; } this . destination = destination ; } public SendProcessor ( Endpoint destination , ExchangePattern pattern ) { this ( destination ) ; this . pattern = pattern ; } @ Override public String toString ( ) { return "sendTo(" + destination + ( pattern != null ? " " + pattern : "" ) + ")" ; } public void process ( Exchange exchange ) throws Exception { if ( producer == null ) { if ( isStopped ( ) ) { LOG . warn ( "Ignoring exchange sent after processor is stopped: " + exchange ) ; } else { throw new IllegalStateException ( "No producer, this processor has not been started!" ) ; } } else { configureExchange ( exchange ) ; producer . process ( exchange ) ; } } public boolean process ( Exchange exchange , AsyncCallback callback ) { if ( producer == null ) { if ( isStopped ( ) ) { LOG . warn ( "Ignoring exchange sent after processor is stopped: " + exchange ) ; } else { exchange . setException ( new IllegalStateException ( "No producer, this processor has not been started!" ) ) ; } callback . done ( true ) ; return true ; } else { configureExchange ( exchange ) ; return processor . process ( exchange , callback ) ; } } public Endpoint getDestination ( ) { return destination ; } protected void doStart ( ) throws Exception { this . producer = destination . createProducer ( ) ; this . producer . start ( ) ; this . processor = AsyncProcessorTypeConverter . convert ( producer ) ; } protected void doStop ( ) throws Exception { if ( producer != null ) { try { producer . stop ( ) ; } finally { producer = null ; processor = null ; } } } protected void configureExchange ( Exchange exchange ) { if ( pattern != null ) { exchange . setPattern ( pattern ) ; } } } 	1	['10', '2', '0', '15', '29', '11', '3', '12', '6', '0.666666667', '181', '1', '4', '0.666666667', '0.355555556', '1', '1', '16.6', '3', '1.1', '5']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "php" ) public class PhpExpression extends ExpressionType { public PhpExpression ( ) { } public PhpExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "php" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingErrorHandler extends ErrorHandlerSupport { private Processor output ; private Log log ; private LoggingLevel level ; public LoggingErrorHandler ( Processor output ) { this ( output , LogFactory . getLog ( LoggingErrorHandler . class ) , LoggingLevel . INFO ) ; } public LoggingErrorHandler ( Processor output , Log log , LoggingLevel level ) { this . output = output ; this . log = log ; this . level = level ; } @ Override public String toString ( ) { return "LoggingErrorHandler[" + output + "]" ; } public void process ( Exchange exchange ) throws Exception { Throwable error = null ; try { output . process ( exchange ) ; if ( exchange . getException ( ) != null ) { error = exchange . getException ( ) ; } } catch ( Throwable e ) { error = e ; } if ( error != null ) { if ( ! customProcessorForException ( exchange , error ) ) { logError ( exchange , error ) ; } } } public Processor getOutput ( ) { return output ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } protected void logError ( Exchange exchange , Throwable e ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange , e ) , e ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange , e ) , e ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange , e ) , e ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . info ( logMessage ( exchange , e ) , e ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange , e ) , e ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange , e ) , e ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange , e ) , e ) ; } } protected Object logMessage ( Exchange exchange , Throwable e ) { return e + " while processing exchange: " + exchange ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( output ) ; } } 	1	['13', '3', '0', '9', '37', '26', '1', '8', '9', '0.555555556', '226', '1', '2', '0.633333333', '0.307692308', '1', '1', '16.15384615', '8', '1.3846', '2']
package org . apache . camel . spi ; import org . apache . camel . CamelContext ; public interface LanguageResolver { Language resolveLanguage ( String name , CamelContext context ) ; } 	0	['1', '1', '0', '7', '1', '0', '5', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . processor . DeadLetterChannel ; import org . apache . camel . processor . ErrorHandlerSupport ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . processor . exceptionpolicy . ExceptionPolicyStrategy ; import org . apache . camel . processor . interceptor . StreamCaching ; import org . apache . camel . spi . RouteContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannelBuilder extends ErrorHandlerBuilderSupport { private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy ( ) ; private Processor onRedelivery ; private ExceptionPolicyStrategy exceptionPolicyStrategy = ErrorHandlerSupport . createDefaultExceptionPolicyStrategy ( ) ; private ProcessorFactory deadLetterFactory ; private Processor defaultDeadLetterEndpoint ; private Expression defaultDeadLetterEndpointExpression ; private String defaultDeadLetterEndpointUri = "log:org.apache.camel.DeadLetterChannel?level=error" ; private Logger logger = DeadLetterChannel . createDefaultLogger ( ) ; public DeadLetterChannelBuilder ( ) { } public DeadLetterChannelBuilder ( Processor processor ) { this ( new ConstantProcessorBuilder ( processor ) ) ; } public DeadLetterChannelBuilder ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public ErrorHandlerBuilder copy ( ) { DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder ( deadLetterFactory ) ; answer . setRedeliveryPolicy ( getRedeliveryPolicy ( ) . copy ( ) ) ; return answer ; } public Processor createErrorHandler ( RouteContext routeContext , Processor processor ) throws Exception { Processor deadLetter = getDeadLetterFactory ( ) . createProcessor ( ) ; DeadLetterChannel answer = new DeadLetterChannel ( processor , deadLetter , onRedelivery , getRedeliveryPolicy ( ) , getLogger ( ) , getExceptionPolicyStrategy ( ) ) ; StreamCaching . enable ( routeContext ) ; configure ( answer ) ; return answer ; } public DeadLetterChannelBuilder backOffMultiplier ( double backOffMultiplier ) { getRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public DeadLetterChannelBuilder collisionAvoidancePercent ( short collisionAvoidancePercent ) { getRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public DeadLetterChannelBuilder initialRedeliveryDelay ( long initialRedeliveryDelay ) { getRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public DeadLetterChannelBuilder maximumRedeliveries ( int maximumRedeliveries ) { getRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public DeadLetterChannelBuilder maximumRedeliveryDelay ( long maximumRedeliveryDelay ) { getRedeliveryPolicy ( ) . maximumRedeliveryDelay ( maximumRedeliveryDelay ) ; return this ; } public DeadLetterChannelBuilder useCollisionAvoidance ( ) { getRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public DeadLetterChannelBuilder useExponentialBackOff ( ) { getRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public DeadLetterChannelBuilder retriesExhaustedLogLevel ( LoggingLevel retriesExhaustedLogLevel ) { getRedeliveryPolicy ( ) . setRetriesExhaustedLogLevel ( retriesExhaustedLogLevel ) ; return this ; } public DeadLetterChannelBuilder retryAttemptedLogLevel ( LoggingLevel retryAttemptedLogLevel ) { getRedeliveryPolicy ( ) . setRetryAttemptedLogLevel ( retryAttemptedLogLevel ) ; return this ; } public DeadLetterChannelBuilder logger ( Logger logger ) { setLogger ( logger ) ; return this ; } public DeadLetterChannelBuilder loggingLevel ( LoggingLevel level ) { getLogger ( ) . setLevel ( level ) ; return this ; } public DeadLetterChannelBuilder log ( Log log ) { getLogger ( ) . setLog ( log ) ; return this ; } public DeadLetterChannelBuilder log ( String log ) { return log ( LogFactory . getLog ( log ) ) ; } public DeadLetterChannelBuilder log ( Class log ) { return log ( LogFactory . getLog ( log ) ) ; } public DeadLetterChannelBuilder exceptionPolicyStrategy ( ExceptionPolicyStrategy exceptionPolicyStrategy ) { setExceptionPolicyStrategy ( exceptionPolicyStrategy ) ; return this ; } public DeadLetterChannelBuilder onRedelivery ( Processor processor ) { setOnRedelivery ( processor ) ; return this ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public ProcessorFactory getDeadLetterFactory ( ) { if ( deadLetterFactory == null ) { deadLetterFactory = new ProcessorFactory ( ) { public Processor createProcessor ( ) { return getDefaultDeadLetterEndpoint ( ) ; } } ; } return deadLetterFactory ; } public void setDeadLetterFactory ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public Processor getDefaultDeadLetterEndpoint ( ) { if ( defaultDeadLetterEndpoint == null ) { defaultDeadLetterEndpoint = new RecipientList ( getDefaultDeadLetterEndpointExpression ( ) ) ; } return defaultDeadLetterEndpoint ; } public void setDefaultDeadLetterEndpoint ( Processor defaultDeadLetterEndpoint ) { this . defaultDeadLetterEndpoint = defaultDeadLetterEndpoint ; } public Expression getDefaultDeadLetterEndpointExpression ( ) { if ( defaultDeadLetterEndpointExpression == null ) { defaultDeadLetterEndpointExpression = ExpressionBuilder . constantExpression ( getDefaultDeadLetterEndpointUri ( ) ) ; } return defaultDeadLetterEndpointExpression ; } public void setDefaultDeadLetterEndpointExpression ( Expression defaultDeadLetterEndpointExpression ) { this . defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression ; } public String getDefaultDeadLetterEndpointUri ( ) { return defaultDeadLetterEndpointUri ; } public void setDefaultDeadLetterEndpointUri ( String defaultDeadLetterEndpointUri ) { this . defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } public ExceptionPolicyStrategy getExceptionPolicyStrategy ( ) { return exceptionPolicyStrategy ; } public void setExceptionPolicyStrategy ( ExceptionPolicyStrategy exceptionPolicyStrategy ) { this . exceptionPolicyStrategy = exceptionPolicyStrategy ; } public Processor getOnRedelivery ( ) { return onRedelivery ; } public void setOnRedelivery ( Processor onRedelivery ) { this . onRedelivery = onRedelivery ; } @ Override public String toString ( ) { return "DeadLetterChannelBuilder(" + ( deadLetterFactory != null ? deadLetterFactory : defaultDeadLetterEndpoint ) + ")" ; } } 	1	['38', '2', '0', '21', '68', '627', '3', '19', '38', '0.824324324', '326', '1', '7', '0.102564103', '0.105263158', '0', '0', '7.368421053', '2', '1.0263', '11']
package org . apache . camel . util ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedHashSet ; import java . util . Map ; import java . util . Set ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . TypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class IntrospectionSupport { private static final transient Log LOG = LogFactory . getLog ( IntrospectionSupport . class ) ; private IntrospectionSupport ( ) { } public static boolean getProperties ( Object target , Map props , String optionPrefix ) { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } if ( optionPrefix == null ) { optionPrefix = "" ; } Class clazz = target . getClass ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { String name = method . getName ( ) ; Class type = method . getReturnType ( ) ; Class params [ ] = method . getParameterTypes ( ) ; if ( name . startsWith ( "get" ) && params . length == 0 && type != null && isSettableType ( type ) ) { try { Object value = method . invoke ( target ) ; if ( value == null ) { continue ; } String strValue = convertToString ( value , type ) ; if ( strValue == null ) { continue ; } name = name . substring ( 3 , 4 ) . toLowerCase ( ) + name . substring ( 4 ) ; props . put ( optionPrefix + name , strValue ) ; rc = true ; } catch ( Throwable ignore ) { } } } return rc ; } public static Object getProperty ( Object target , String prop ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( prop == null ) { throw new IllegalArgumentException ( "prop was null." ) ; } prop = prop . substring ( 0 , 1 ) . toUpperCase ( ) + prop . substring ( 1 ) ; Class clazz = target . getClass ( ) ; Method method = getPropertyGetter ( clazz , prop ) ; return method . invoke ( target ) ; } public static Method getPropertyGetter ( Class type , String propertyName ) throws NoSuchMethodException { Method method = type . getMethod ( "get" + ObjectHelper . capitalize ( propertyName ) ) ; return method ; } public static boolean setProperties ( Object target , Map props , String optionPrefix ) throws Exception { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; if ( setProperty ( target , name , value ) ) { iter . remove ( ) ; rc = true ; } } } return rc ; } public static Map extractProperties ( Map props , String optionPrefix ) { if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } HashMap rc = new HashMap ( props . size ( ) ) ; for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; rc . put ( name , value ) ; iter . remove ( ) ; } } return rc ; } public static boolean setProperties ( TypeConverter typeConverter , Object target , Map props ) throws Exception { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } for ( Iterator iter = props . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( setProperty ( typeConverter , target , ( String ) entry . getKey ( ) , entry . getValue ( ) ) ) { iter . remove ( ) ; rc = true ; } } return rc ; } public static boolean setProperties ( Object target , Map props ) throws Exception { return setProperties ( null , target , props ) ; } public static boolean setProperty ( TypeConverter typeConverter , Object target , String name , Object value ) throws Exception { try { Class clazz = target . getClass ( ) ; Set < Method > setters = findSetterMethods ( typeConverter , clazz , name , value ) ; if ( setters . isEmpty ( ) ) { return false ; } Exception typeConvertionFailed = null ; for ( Method setter : setters ) { if ( value == null || setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( value . getClass ( ) ) ) { setter . invoke ( target , value ) ; return true ; } else { try { Object convertedValue = convert ( typeConverter , setter . getParameterTypes ( ) [ 0 ] , value ) ; setter . invoke ( target , convertedValue ) ; return true ; } catch ( NoTypeConversionAvailableException e ) { typeConvertionFailed = e ; } catch ( IllegalArgumentException e ) { typeConvertionFailed = e ; } LOG . trace ( "Setter \"" + setter + "\" with parameter type \"" + setter . getParameterTypes ( ) [ 0 ] + "\" could not be used for type conertions of " + value ) ; } } if ( typeConvertionFailed != null ) { throw new IllegalArgumentException ( "Could not find a suitable setter for property: " + name + " as there isn't a setter method with same type: " + value . getClass ( ) . getCanonicalName ( ) + " nor type convertion possbile: " + typeConvertionFailed . getMessage ( ) ) ; } else { return false ; } } catch ( InvocationTargetException e ) { Throwable throwable = e . getCause ( ) ; if ( throwable instanceof Exception ) { Exception exception = ( Exception ) throwable ; throw exception ; } else { Error error = ( Error ) throwable ; throw error ; } } } public static boolean setProperty ( Object target , String name , Object value ) throws Exception { return setProperty ( null , target , name , value ) ; } private static Object convert ( TypeConverter typeConverter , Class type , Object value ) throws URISyntaxException { if ( typeConverter != null ) { return typeConverter . convertTo ( type , value ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return editor . getValue ( ) ; } if ( type == URI . class ) { return new URI ( value . toString ( ) ) ; } return null ; } private static String convertToString ( Object value , Class type ) throws URISyntaxException { PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setValue ( value ) ; return editor . getAsText ( ) ; } if ( type == URI . class ) { return value . toString ( ) ; } return null ; } private static Set < Method > findSetterMethods ( TypeConverter typeConverter , Class clazz , String name , Object value ) { Set < Method > candidates = new LinkedHashSet < Method > ( ) ; name = "set" + ObjectHelper . capitalize ( name ) ; while ( clazz != Object . class ) { Method objectSetMethod = null ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { Class params [ ] = method . getParameterTypes ( ) ; if ( method . getName ( ) . equals ( name ) && params . length == 1 ) { Class paramType = params [ 0 ] ; if ( paramType . equals ( Object . class ) ) { objectSetMethod = method ; } else if ( typeConverter != null || isSettableType ( paramType ) || paramType . isInstance ( value ) ) { candidates . add ( method ) ; } } } if ( objectSetMethod != null ) { candidates . add ( objectSetMethod ) ; } clazz = clazz . getSuperclass ( ) ; } if ( candidates . isEmpty ( ) ) { return candidates ; } else if ( candidates . size ( ) == 1 ) { return candidates ; } else { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Found " + candidates . size ( ) + " suitable setter methods for setting " + name ) ; } for ( Method method : candidates ) { if ( method . getParameterTypes ( ) [ 0 ] . isInstance ( value ) ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Method " + method + " is the best candidate as it has parameter with same instance type" ) ; } candidates . clear ( ) ; candidates . add ( method ) ; return candidates ; } } return candidates ; } } private static boolean isSettableType ( Class clazz ) { if ( PropertyEditorManager . findEditor ( clazz ) != null ) { return true ; } if ( clazz == URI . class ) { return true ; } if ( clazz == Boolean . class ) { return true ; } return false ; } public static String toString ( Object target ) { return toString ( target , Object . class ) ; } public static String toString ( Object target , Class stopClass ) { LinkedHashMap map = new LinkedHashMap ( ) ; addFields ( target , target . getClass ( ) , stopClass , map ) ; StringBuffer buffer = new StringBuffer ( simpleName ( target . getClass ( ) ) ) ; buffer . append ( " {" ) ; Set entrySet = map . entrySet ( ) ; boolean first = true ; for ( Iterator iter = entrySet . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( first ) { first = false ; } else { buffer . append ( ", " ) ; } buffer . append ( entry . getKey ( ) ) ; buffer . append ( " = " ) ; appendToString ( buffer , entry . getValue ( ) ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } protected static void appendToString ( StringBuffer buffer , Object value ) { buffer . append ( value ) ; } public static String simpleName ( Class clazz ) { String name = clazz . getName ( ) ; int p = name . lastIndexOf ( "." ) ; if ( p >= 0 ) { name = name . substring ( p + 1 ) ; } return name ; } private static void addFields ( Object target , Class startClass , Class stopClass , LinkedHashMap map ) { if ( startClass != stopClass ) { addFields ( target , startClass . getSuperclass ( ) , stopClass , map ) ; } Field [ ] fields = startClass . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) || Modifier . isTransient ( field . getModifiers ( ) ) || Modifier . isPrivate ( field . getModifiers ( ) ) ) { continue ; } try { field . setAccessible ( true ) ; Object o = field . get ( target ) ; if ( o != null && o . getClass ( ) . isArray ( ) ) { try { o = Arrays . asList ( ( Object [ ] ) o ) ; } catch ( Throwable e ) { } } map . put ( field . getName ( ) , o ) ; } catch ( Throwable e ) { LOG . debug ( "Error adding fields" , e ) ; } } } } 	0	['20', '1', '0', '20', '98', '178', '15', '5', '12', '0.631578947', '880', '1', '0', '0', '0.276315789', '0', '0', '42.95', '15', '2.85', '0']
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ProducerCache ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . RoutingSlipType ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ObjectHelper . notNull ; public class RoutingSlip extends ServiceSupport implements Processor { private static final transient Log LOG = LogFactory . getLog ( RoutingSlip . class ) ; private final String header ; private final String uriDelimiter ; private ProducerCache < Exchange > producerCache = new ProducerCache < Exchange > ( ) ; public RoutingSlip ( String header ) { this ( header , RoutingSlipType . DEFAULT_DELIMITER ) ; } public RoutingSlip ( String header , String uriDelimiter ) { notNull ( header , "header" ) ; notNull ( uriDelimiter , "uriDelimiter" ) ; this . header = header ; this . uriDelimiter = uriDelimiter ; } @ Override public String toString ( ) { return "RoutingSlip[header=" + header + " uriDelimiter=" + uriDelimiter + "]" ; } public void process ( Exchange exchange ) throws Exception { Message message = exchange . getIn ( ) ; String [ ] recipients = recipients ( message ) ; Exchange current = exchange ; for ( String nextRecipient : recipients ) { Endpoint < Exchange > endpoint = resolveEndpoint ( exchange , nextRecipient ) ; Producer < Exchange > producer = producerCache . getProducer ( endpoint ) ; Exchange ex = current . newInstance ( ) ; updateRoutingSlip ( current ) ; copyOutToIn ( ex , current ) ; producer . process ( ex ) ; current = ex ; } ExchangeHelper . copyResults ( exchange , current ) ; } protected Endpoint < Exchange > resolveEndpoint ( Exchange exchange , Object recipient ) { return ExchangeHelper . resolveEndpoint ( exchange , recipient ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected void doStart ( ) throws Exception { } private void updateRoutingSlip ( Exchange current ) { Message message = getResultMessage ( current ) ; message . setHeader ( header , removeFirstElement ( recipients ( message ) ) ) ; } private Message getResultMessage ( Exchange exchange ) { Message message = exchange . getOut ( false ) ; if ( message == null ) { message = exchange . getIn ( ) ; } return message ; } private String [ ] recipients ( Message message ) { Object headerValue = message . getHeader ( header ) ; if ( headerValue != null && ! headerValue . equals ( "" ) ) { return headerValue . toString ( ) . split ( uriDelimiter ) ; } return new String [ ] { } ; } private String removeFirstElement ( String [ ] elements ) { CollectionStringBuffer updatedElements = new CollectionStringBuffer ( uriDelimiter ) ; for ( int i = 1 ; i < elements . length ; i ++ ) { updatedElements . append ( elements [ i ] ) ; } return updatedElements . toString ( ) ; } private void copyOutToIn ( Exchange result , Exchange source ) { result . setException ( source . getException ( ) ) ; Message fault = source . getFault ( false ) ; if ( fault != null ) { result . getFault ( true ) . copyFrom ( fault ) ; } result . setIn ( getResultMessage ( source ) ) ; result . getProperties ( ) . clear ( ) ; result . getProperties ( ) . putAll ( source . getProperties ( ) ) ; } } 	1	['13', '2', '0', '13', '44', '54', '1', '12', '4', '0.708333333', '222', '1', '1', '0.583333333', '0.305555556', '1', '1', '15.76923077', '3', '1.1538', '3']
package org . apache . camel . component . mina ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; import org . apache . mina . common . IoSession ; import org . apache . mina . common . WriteFuture ; public final class MinaHelper { private MinaHelper ( ) { } public static void writeBody ( IoSession session , Object body , Exchange exchange ) throws CamelExchangeException { WriteFuture future = session . write ( body ) ; future . join ( ) ; if ( ! future . isWritten ( ) ) { throw new CamelExchangeException ( "Could not write body" , exchange ) ; } } } 	0	['2', '1', '0', '6', '7', '1', '2', '4', '1', '2', '21', '0', '0', '0', '0.5', '0', '0', '9.5', '1', '0.5', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class TopicLoadBalancer extends LoadBalancerSupport { public void process ( Exchange exchange ) throws Exception { List < Processor > list = getProcessors ( ) ; for ( Processor processor : list ) { Exchange copy = copyExchangeStrategy ( processor , exchange ) ; processor . process ( copy ) ; } } protected Exchange copyExchangeStrategy ( Processor processor , Exchange exchange ) { return exchange . copy ( ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { List < Processor > list = getProcessors ( ) ; for ( Processor processor : list ) { Exchange copy = copyExchangeStrategy ( processor , exchange ) ; try { processor . process ( copy ) ; } catch ( Exception ex ) { } } callback . done ( false ) ; return false ; } } 	1	['4', '3', '0', '8', '12', '6', '4', '4', '3', '2', '62', '0', '0', '0.863636364', '0.5625', '0', '0', '14.5', '2', '1', '1']
package org . apache . camel ; public interface TypeConverter { < T > T convertTo ( Class < T > type , Object value ) ; < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) ; } 	0	['2', '1', '0', '38', '2', '1', '37', '1', '2', '2', '2', '0', '0', '0', '0.875', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . validation ; import java . io . File ; import java . io . IOException ; import java . net . URL ; import javax . xml . XMLConstants ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . validation . Schema ; import javax . xml . validation . SchemaFactory ; import javax . xml . validation . Validator ; import org . xml . sax . SAXException ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class ValidatingProcessor implements Processor { private String schemaLanguage = XMLConstants . W3C_XML_SCHEMA_NS_URI ; private Schema schema ; private Source schemaSource ; private SchemaFactory schemaFactory ; private URL schemaUrl ; private File schemaFile ; private ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler ( ) ; public void process ( Exchange exchange ) throws Exception { Schema schema = getSchema ( ) ; Validator validator = schema . newValidator ( ) ; Source source = exchange . getIn ( ) . getBody ( DOMSource . class ) ; if ( source == null ) { throw new NoXmlBodyValidationException ( exchange ) ; } ValidatorErrorHandler handler = errorHandler . getClass ( ) . newInstance ( ) ; validator . setErrorHandler ( handler ) ; DOMResult result = new DOMResult ( ) ; validator . validate ( source , result ) ; handler . handleErrors ( exchange , schema , result ) ; } public Schema getSchema ( ) throws IOException , SAXException { if ( schema == null ) { schema = createSchema ( ) ; } return schema ; } public void setSchema ( Schema schema ) { this . schema = schema ; } public String getSchemaLanguage ( ) { return schemaLanguage ; } public void setSchemaLanguage ( String schemaLanguage ) { this . schemaLanguage = schemaLanguage ; } public Source getSchemaSource ( ) throws IOException { if ( schemaSource == null ) { schemaSource = createSchemaSource ( ) ; } return schemaSource ; } public void setSchemaSource ( Source schemaSource ) { this . schemaSource = schemaSource ; } public URL getSchemaUrl ( ) { return schemaUrl ; } public void setSchemaUrl ( URL schemaUrl ) { this . schemaUrl = schemaUrl ; } public File getSchemaFile ( ) { return schemaFile ; } public void setSchemaFile ( File schemaFile ) { this . schemaFile = schemaFile ; } public SchemaFactory getSchemaFactory ( ) { if ( schemaFactory == null ) { schemaFactory = createSchemaFactory ( ) ; } return schemaFactory ; } public void setSchemaFactory ( SchemaFactory schemaFactory ) { this . schemaFactory = schemaFactory ; } public ValidatorErrorHandler getErrorHandler ( ) { return errorHandler ; } public void setErrorHandler ( ValidatorErrorHandler errorHandler ) { this . errorHandler = errorHandler ; } protected SchemaFactory createSchemaFactory ( ) { return SchemaFactory . newInstance ( schemaLanguage ) ; } protected Source createSchemaSource ( ) throws IOException { throw new IllegalArgumentException ( "You must specify a schema, " + "schemaFile, schemaSource or schemaUrl property" ) ; } protected Schema createSchema ( ) throws SAXException , IOException { SchemaFactory factory = getSchemaFactory ( ) ; URL url = getSchemaUrl ( ) ; if ( url != null ) { return factory . newSchema ( url ) ; } File file = getSchemaFile ( ) ; if ( file != null ) { return factory . newSchema ( file ) ; } return factory . newSchema ( getSchemaSource ( ) ) ; } } 	1	['19', '1', '1', '7', '36', '137', '1', '6', '16', '0.857142857', '184', '1', '1', '0', '0.157894737', '0', '0', '8.315789474', '2', '1', '2']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class StaticMethodTypeConverter implements TypeConverter { private final Method method ; private final boolean useExchange ; public StaticMethodTypeConverter ( Method method ) { this . method = method ; this . useExchange = method . getParameterTypes ( ) . length == 2 ; } @ Override public String toString ( ) { return "StaticMethodTypeConverter: " + method ; } public < T > T convertTo ( Class < T > type , Object value ) { return convertTo ( type , null , value ) ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return useExchange ? ( T ) ObjectHelper . invokeMethod ( method , null , value , exchange ) : ( T ) ObjectHelper . invokeMethod ( method , null , value ) ; } } 	0	['4', '1', '0', '4', '11', '0', '1', '3', '4', '0.166666667', '67', '1', '0', '0', '0.5', '0', '0', '15.25', '2', '1', '0']
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class LoadBalancerConsumer extends DefaultConsumer < Exchange > { private final LoadBalancer loadBalancer ; public LoadBalancerConsumer ( Endpoint endpoint , Processor processor , LoadBalancer loadBalancer ) { super ( endpoint , processor ) ; this . loadBalancer = loadBalancer ; } @ Override protected void doStart ( ) throws Exception { loadBalancer . addProcessor ( getProcessor ( ) ) ; } @ Override protected void doStop ( ) throws Exception { loadBalancer . removeProcessor ( getProcessor ( ) ) ; } } 	1	['3', '3', '0', '5', '7', '0', '1', '4', '1', '0', '24', '1', '1', '0.92', '0.5', '1', '1', '6.666666667', '1', '0.6667', '1']
package org . apache . camel . component . dataset ; import org . apache . camel . Exchange ; public interface DataSet { String INDEX_HEADER = "camelDataSetIndex" ; void populateMessage ( Exchange exchange , long messageIndex ) throws Exception ; long getSize ( ) ; void assertMessageExpected ( DataSetEndpoint dataSetEndpoint , Exchange expected , Exchange actual , long index ) throws Exception ; long getReportCount ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '5', '2', '4', '1.333333333', '5', '0', '0', '0', '0.5625', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . file ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . channels . FileChannel ; import java . nio . channels . FileLock ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . camel . processor . DeadLetterChannel ; import org . apache . camel . util . LRUCache ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FileConsumer extends ScheduledPollConsumer < FileExchange > { private static final transient Log LOG = LogFactory . getLog ( FileConsumer . class ) ; private FileEndpoint endpoint ; private ConcurrentHashMap < File , File > filesBeingProcessed = new ConcurrentHashMap < File , File > ( ) ; private ConcurrentHashMap < File , Long > fileSizes = new ConcurrentHashMap < File , Long > ( new LRUCache ( 1000 ) ) ; private ConcurrentHashMap < File , Long > noopMap = new ConcurrentHashMap < File , Long > ( new LRUCache ( 1000 ) ) ; private long lastPollTime ; private int unchangedDelay ; private boolean unchangedSize ; private boolean generateEmptyExchangeWhenIdle ; private boolean alwaysConsume ; private boolean recursive ; private String regexPattern = "" ; private boolean exclusiveReadLock = true ; public FileConsumer ( final FileEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } protected synchronized void poll ( ) throws Exception { int rc = pollFileOrDirectory ( endpoint . getFile ( ) , true ) ; if ( rc == 0 && generateEmptyExchangeWhenIdle ) { final FileExchange exchange = endpoint . createExchange ( ( File ) null ) ; getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { } } ) ; } lastPollTime = System . currentTimeMillis ( ) ; } protected int pollFileOrDirectory ( File fileOrDirectory , boolean processDir ) { if ( ! fileOrDirectory . isDirectory ( ) ) { return pollFile ( fileOrDirectory ) ; } else if ( processDir ) { int rc = 0 ; if ( isValidFile ( fileOrDirectory ) ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Polling directory " + fileOrDirectory ) ; } File [ ] files = fileOrDirectory . listFiles ( ) ; for ( File file : files ) { rc += pollFileOrDirectory ( file , isRecursive ( ) ) ; } } return rc ; } else { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Skipping directory " + fileOrDirectory ) ; } return 0 ; } } protected int pollFile ( final File target ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Polling file: " + target ) ; } if ( ! target . exists ( ) ) { return 0 ; } if ( ! isValidFile ( target ) ) { return 0 ; } if ( ! endpoint . isNoop ( ) ) { if ( filesBeingProcessed . contains ( target ) ) { return 1 ; } filesBeingProcessed . put ( target , target ) ; } final FileProcessStrategy processStrategy = endpoint . getFileStrategy ( ) ; final FileExchange exchange = endpoint . createExchange ( target ) ; endpoint . configureMessage ( target , exchange . getIn ( ) ) ; try { if ( exclusiveReadLock ) { acquireExclusiveReadLock ( target ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to process file: " + target + " using exchange: " + exchange ) ; } if ( processStrategy . begin ( endpoint , exchange , target ) ) { getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { final File file = exchange . getFile ( ) ; boolean failed = exchange . isFailed ( ) ; boolean handled = DeadLetterChannel . isFailureHandled ( exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Done processing file: " + file + ". Status is: " + ( failed ? "failed: " + failed + ", handled by failure processor: " + handled : "processed OK" ) ) ; } boolean committed = false ; try { if ( ! failed || handled ) { processStrategyCommit ( processStrategy , exchange , file , handled ) ; committed = true ; } else { handleException ( exchange . getException ( ) ) ; } } finally { if ( ! committed ) { processStrategyRollback ( processStrategy , exchange , file ) ; } filesBeingProcessed . remove ( file ) ; } } } ) ; } else { LOG . warn ( endpoint + " can not process file: " + target ) ; } } catch ( Throwable e ) { handleException ( e ) ; } return 1 ; } protected void acquireExclusiveReadLock ( File file ) throws IOException { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Waiting for exclusive read lock to file: " + file ) ; } FileChannel channel = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; try { FileLock lock = channel . lock ( ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Acquired exclusive read lock: " + lock + " to file: " + file ) ; } lock . release ( ) ; } finally { ObjectHelper . close ( channel , "FileConsumer during acquiring of exclusive read lock" , LOG ) ; } } protected void processStrategyCommit ( FileProcessStrategy processStrategy , FileExchange exchange , File file , boolean failureHandled ) { try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Committing file strategy: " + processStrategy + " for file: " + file + ( failureHandled ? " that was handled by the failure processor." : "" ) ) ; } processStrategy . commit ( endpoint , exchange , file ) ; } catch ( Exception e ) { LOG . warn ( "Error committing file strategy: " + processStrategy , e ) ; handleException ( e ) ; } } protected void processStrategyRollback ( FileProcessStrategy processStrategy , FileExchange exchange , File file ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Rolling back file strategy: " + processStrategy + " for file: " + file ) ; } processStrategy . rollback ( endpoint , exchange , file ) ; } protected boolean isValidFile ( File file ) { boolean result = false ; if ( file != null && file . exists ( ) ) { if ( isMatched ( file ) && ( alwaysConsume || isChanged ( file ) ) ) { result = true ; } } return result ; } protected boolean isChanged ( File file ) { if ( file == null ) { return false ; } else if ( file . isDirectory ( ) ) { return true ; } else { boolean lastModifiedCheck = false ; long modifiedDuration = 0 ; if ( getUnchangedDelay ( ) > 0 ) { modifiedDuration = System . currentTimeMillis ( ) - file . lastModified ( ) ; lastModifiedCheck = modifiedDuration >= getUnchangedDelay ( ) ; } long fileModified = file . lastModified ( ) ; Long previousModified = noopMap . get ( file ) ; noopMap . put ( file , fileModified ) ; if ( previousModified == null || fileModified > previousModified ) { lastModifiedCheck = true ; } boolean sizeCheck = false ; long sizeDifference = 0 ; if ( isUnchangedSize ( ) ) { Long value = fileSizes . get ( file ) ; if ( value == null ) { sizeCheck = true ; } else { sizeCheck = file . length ( ) != value ; } } boolean answer = lastModifiedCheck || sizeCheck ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "file:" + file + " isChanged:" + answer + " " + "sizeCheck:" + sizeCheck + "(" + sizeDifference + ") " + "lastModifiedCheck:" + lastModifiedCheck + "(" + modifiedDuration + ")" ) ; } if ( isUnchangedSize ( ) ) { if ( answer ) { fileSizes . put ( file , file . length ( ) ) ; } else { fileSizes . remove ( file ) ; } } return answer ; } } protected boolean isMatched ( File file ) { String name = file . getName ( ) ; if ( name . startsWith ( "." ) ) { return false ; } if ( name . endsWith ( FileEndpoint . DEFAULT_LOCK_FILE_POSTFIX ) ) { return false ; } if ( file . isDirectory ( ) ) { return true ; } if ( regexPattern != null && regexPattern . length ( ) > 0 ) { if ( ! name . matches ( regexPattern ) ) { return false ; } } if ( endpoint . getExcludedNamePrefix ( ) != null ) { if ( name . startsWith ( endpoint . getExcludedNamePrefix ( ) ) ) { return false ; } } String [ ] prefixes = endpoint . getExcludedNamePrefixes ( ) ; if ( prefixes != null ) { for ( String prefix : prefixes ) { if ( name . startsWith ( prefix ) ) { return false ; } } } if ( endpoint . getExcludedNamePostfix ( ) != null ) { if ( name . endsWith ( endpoint . getExcludedNamePostfix ( ) ) ) { return false ; } } String [ ] postfixes = endpoint . getExcludedNamePostfixes ( ) ; if ( postfixes != null ) { for ( String postfix : postfixes ) { if ( name . endsWith ( postfix ) ) { return false ; } } } return true ; } public boolean isRecursive ( ) { return this . recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public String getRegexPattern ( ) { return this . regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } public boolean isGenerateEmptyExchangeWhenIdle ( ) { return generateEmptyExchangeWhenIdle ; } public void setGenerateEmptyExchangeWhenIdle ( boolean generateEmptyExchangeWhenIdle ) { this . generateEmptyExchangeWhenIdle = generateEmptyExchangeWhenIdle ; } public int getUnchangedDelay ( ) { return unchangedDelay ; } public void setUnchangedDelay ( int unchangedDelay ) { this . unchangedDelay = unchangedDelay ; } public boolean isUnchangedSize ( ) { return unchangedSize ; } public void setUnchangedSize ( boolean unchangedSize ) { this . unchangedSize = unchangedSize ; } public boolean isExclusiveReadLock ( ) { return exclusiveReadLock ; } public void setExclusiveReadLock ( boolean exclusiveReadLock ) { this . exclusiveReadLock = exclusiveReadLock ; } public boolean isAlwaysConsume ( ) { return alwaysConsume ; } public void setAlwaysConsume ( boolean alwaysConsume ) { this . alwaysConsume = alwaysConsume ; } public boolean isTimestamp ( ) { return ! alwaysConsume ; } public void setTimestamp ( boolean timestamp ) { this . alwaysConsume = ! timestamp ; } } 	1	['30', '4', '0', '16', '87', '297', '3', '16', '17', '0.880636605', '793', '1', '1', '0.555555556', '0.166144201', '1', '1', '25', '17', '2.7333', '11']
package org . apache . camel . util ; import org . apache . camel . spi . Injector ; public class ReflectionInjector implements Injector { public < T > T newInstance ( Class < T > type ) { return ObjectHelper . newInstance ( type ) ; } } 	0	['2', '1', '0', '4', '4', '1', '2', '2', '2', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . camel ; public class NoTypeConversionAvailableException extends RuntimeCamelException { private final Object value ; private final Class type ; public NoTypeConversionAvailableException ( Object value , Class type ) { super ( "No type converter available to convert from type: " + ( value != null ? value . getClass ( ) : null ) + " to the required type: " + type . getCanonicalName ( ) + " with value " + value ) ; this . value = value ; this . type = type ; } public Object getValue ( ) { return value ; } public Class getType ( ) { return type ; } public Class getFromType ( ) { if ( value != null ) { return value . getClass ( ) ; } else { return null ; } } } 	1	['4', '5', '0', '25', '11', '0', '24', '1', '4', '0.5', '52', '1', '0', '0.85', '0.5', '0', '0', '11.5', '2', '1', '1']
package org . apache . camel . component . atom ; import org . apache . abdera . model . Document ; import org . apache . abdera . model . Feed ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class AtomPollingConsumer extends AtomConsumerSupport { public AtomPollingConsumer ( AtomEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; } protected void poll ( ) throws Exception { Document < Feed > document = AtomUtils . parseDocument ( endpoint . getAtomUri ( ) ) ; Feed feed = document . getRoot ( ) ; Exchange exchange = endpoint . createExchange ( feed ) ; getProcessor ( ) . process ( exchange ) ; } } 	0	['2', '5', '1', '9', '9', '1', '2', '8', '1', '2', '26', '0', '0', '0.972222222', '0.666666667', '1', '1', '12', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlType ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlType ( name = "outputType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class OutputType < Type extends ProcessorType > extends ProcessorType < Type > { private static final transient Log LOG = LogFactory . getLog ( OutputType . class ) ; @ XmlElementRef protected List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { configureChild ( output ) ; } } } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } } } 	1	['5', '3', '16', '21', '15', '4', '17', '4', '3', '0.75', '53', '1', '0', '0.983240223', '0.5', '1', '3', '9.2', '3', '1.2', '1']
package org . apache . camel . bam . processor ; import java . lang . reflect . Method ; import java . util . List ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . support . TransactionTemplate ; public class JpaBamProcessorSupport < T > extends BamProcessorSupport < T > { private static final transient Log LOG = LogFactory . getLog ( JpaBamProcessorSupport . class ) ; private static final Lock LOCK = new ReentrantLock ( ) ; private ActivityRules activityRules ; private JpaTemplate template ; private String findByKeyQuery ; private String keyPropertyName = "correlationKey" ; private boolean correlationKeyIsPrimary = true ; public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules , Class < T > entitytype ) { super ( transactionTemplate , correlationKeyExpression , entitytype ) ; this . activityRules = activityRules ; this . template = template ; } public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules ) { super ( transactionTemplate , correlationKeyExpression ) ; this . activityRules = activityRules ; this . template = template ; } public String getFindByKeyQuery ( ) { if ( findByKeyQuery == null ) { findByKeyQuery = createFindByKeyQuery ( ) ; } return findByKeyQuery ; } public void setFindByKeyQuery ( String findByKeyQuery ) { this . findByKeyQuery = findByKeyQuery ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public void setActivityRules ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public String getKeyPropertyName ( ) { return keyPropertyName ; } public void setKeyPropertyName ( String keyPropertyName ) { this . keyPropertyName = keyPropertyName ; } public JpaTemplate getTemplate ( ) { return template ; } public void setTemplate ( JpaTemplate template ) { this . template = template ; } public boolean isCorrelationKeyIsPrimary ( ) { return correlationKeyIsPrimary ; } public void setCorrelationKeyIsPrimary ( boolean correlationKeyIsPrimary ) { this . correlationKeyIsPrimary = correlationKeyIsPrimary ; } protected T loadEntity ( Exchange exchange , Object key ) throws Exception { LOCK . lock ( ) ; try { T entity = findEntityByCorrelationKey ( key ) ; if ( entity == null ) { entity = createEntity ( exchange , key ) ; setKeyProperty ( entity , key ) ; ProcessDefinition definition = ProcessDefinition . getRefreshedProcessDefinition ( template , getActivityRules ( ) . getProcessRules ( ) . getProcessDefinition ( ) ) ; setProcessDefinitionProperty ( entity , definition ) ; template . persist ( entity ) ; LOG . debug ( "About to flush on entity: " + entity + " with key: " + key ) ; template . flush ( ) ; } return entity ; } finally { LOCK . unlock ( ) ; } } protected T findEntityByCorrelationKey ( Object key ) { if ( isCorrelationKeyIsPrimary ( ) ) { return template . find ( getEntityType ( ) , key ) ; } else { List < T > list = template . find ( getFindByKeyQuery ( ) , key ) ; if ( list . isEmpty ( ) ) { return null ; } else { return list . get ( 0 ) ; } } } protected Class getKeyType ( ) { try { Method getter = IntrospectionSupport . getPropertyGetter ( getEntityType ( ) , getKeyPropertyName ( ) ) ; return getter . getReturnType ( ) ; } catch ( NoSuchMethodException e ) { LOG . warn ( "no such getter for: " + getKeyPropertyName ( ) + " on " + getEntityType ( ) + ". Reason: " + e , e ) ; return null ; } } protected void setKeyProperty ( T entity , Object key ) throws Exception { IntrospectionSupport . setProperty ( entity , getKeyPropertyName ( ) , key ) ; } protected void setProcessDefinitionProperty ( T entity , ProcessDefinition processDefinition ) throws Exception { IntrospectionSupport . setProperty ( entity , "processDefinition" , processDefinition ) ; } protected T createEntity ( Exchange exchange , Object key ) { return ( T ) exchange . getContext ( ) . getInjector ( ) . newInstance ( getEntityType ( ) ) ; } protected void processEntity ( Exchange exchange , T entity ) throws Exception { if ( entity instanceof Processor ) { Processor processor = ( Processor ) entity ; processor . process ( exchange ) ; } else { throw new IllegalArgumentException ( "No processor defined for this route" ) ; } } protected String createFindByKeyQuery ( ) { return "select x from " + getEntityType ( ) . getName ( ) + " x where x." + getKeyPropertyName ( ) + " = ?1" ; } } 	0	['21', '2', '1', '15', '52', '142', '1', '14', '12', '0.828571429', '292', '1', '1', '0.333333333', '0.2', '1', '2', '12.57142857', '3', '1', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class Throttler extends DelayProcessorSupport { private long maximumRequestsPerPeriod ; private long timePeriodMillis ; private TimeSlot slot ; public Throttler ( Processor processor , long maximumRequestsPerPeriod ) { this ( processor , maximumRequestsPerPeriod , 1000 ) ; } public Throttler ( Processor processor , long maximumRequestsPerPeriod , long timePeriodMillis ) { super ( processor ) ; this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; this . timePeriodMillis = timePeriodMillis ; } @ Override public String toString ( ) { return "Throttler[requests: " + maximumRequestsPerPeriod + " per: " + timePeriodMillis + " (ms) to: " + getProcessor ( ) + "]" ; } public long getMaximumRequestsPerPeriod ( ) { return maximumRequestsPerPeriod ; } public void setMaximumRequestsPerPeriod ( long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } public long getTimePeriodMillis ( ) { return timePeriodMillis ; } public void setTimePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; } protected void delay ( Exchange exchange ) throws Exception { TimeSlot slot = nextSlot ( ) ; if ( ! slot . isActive ( ) ) { waitUntil ( slot . startTime , exchange ) ; } } protected synchronized TimeSlot nextSlot ( ) { if ( slot == null ) { slot = new TimeSlot ( ) ; } if ( slot . isFull ( ) ) { slot = slot . next ( ) ; } slot . assign ( ) ; return slot ; } protected class TimeSlot { private long capacity = Throttler . this . maximumRequestsPerPeriod ; private final long duration = Throttler . this . timePeriodMillis ; private final long startTime ; protected TimeSlot ( ) { this ( System . currentTimeMillis ( ) ) ; } protected TimeSlot ( long startTime ) { this . startTime = startTime ; } protected void assign ( ) { capacity -- ; } protected TimeSlot next ( ) { return new TimeSlot ( Math . max ( System . currentTimeMillis ( ) , this . startTime + this . duration ) ) ; } protected boolean isActive ( ) { return startTime <= System . currentTimeMillis ( ) ; } protected boolean isFull ( ) { return capacity <= 0 ; } } } 	1	['11', '4', '0', '5', '25', '17', '2', '4', '7', '0.633333333', '108', '1', '1', '0.775', '0.327272727', '1', '2', '8.545454545', '3', '1', '1']
package org . apache . camel . component . dataset ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . CamelContextHelper ; public class DataSetComponent extends DefaultComponent < Exchange > { @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { DataSet dataSet = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , remaining , DataSet . class ) ; return new DataSetEndpoint ( uri , this , dataSet ) ; } } 	0	['2', '3', '0', '7', '6', '1', '0', '7', '1', '2', '19', '0', '0', '0.972222222', '0.666666667', '1', '1', '8.5', '1', '0.5', '0']
package org . apache . camel ; import java . util . Map ; import org . apache . camel . spi . UnitOfWork ; public interface Exchange { String CHARSET_NAME = "org.apache.camel.Exchange.CharsetName" ; String AGGREGATED_COUNT = "org.apache.camel.Exchange.AggregatedCount" ; String EXCEPTION_HANDLED_PROPERTY = "CamelExceptionHandled" ; ExchangePattern getPattern ( ) ; void setPattern ( ExchangePattern pattern ) ; Object getProperty ( String name ) ; < T > T getProperty ( String name , Class < T > type ) ; void setProperty ( String name , Object value ) ; Object removeProperty ( String name ) ; Map < String , Object > getProperties ( ) ; Message getIn ( ) ; void setIn ( Message in ) ; Message getOut ( ) ; Message getOut ( boolean lazyCreate ) ; void setOut ( Message out ) ; Message getFault ( ) ; Message getFault ( boolean lazyCreate ) ; Throwable getException ( ) ; void setException ( Throwable e ) ; boolean isFailed ( ) ; boolean isTransacted ( ) ; CamelContext getContext ( ) ; Exchange newInstance ( ) ; Exchange copy ( ) ; void copyFrom ( Exchange source ) ; UnitOfWork getUnitOfWork ( ) ; void setUnitOfWork ( UnitOfWork unitOfWork ) ; String getExchangeId ( ) ; void setExchangeId ( String id ) ; } 	1	['26', '1', '0', '448', '26', '325', '446', '4', '26', '1.04', '29', '0', '0', '0', '0.157692308', '0', '0', '0', '1', '1', '28']
package org . apache . camel . builder . xml ; public class DomResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new DomResultHandler ( ) ; } } 	0	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . camel ; import org . apache . camel . util . ExchangeHelper ; public class NoSuchHeaderException extends CamelExchangeException { private static final long serialVersionUID = - 8721487431101572630L ; private final String headerName ; private final Class < ? > type ; public NoSuchHeaderException ( Exchange exchange , String headerName , Class < ? > type ) { super ( "No '" + headerName + "' header available of type: " + type . getName ( ) + reason ( exchange , headerName ) , exchange ) ; this . headerName = headerName ; this . type = type ; } public String getHeaderName ( ) { return headerName ; } public Class < ? > getType ( ) { return type ; } protected static String reason ( Exchange exchange , String propertyName ) { Object value = exchange . getProperty ( propertyName ) ; return valueDescription ( value ) ; } static String valueDescription ( Object value ) { if ( value == null ) { return "" ; } return " but has value: " + value + " of type: " + value . getClass ( ) . getName ( ) ; } } 	1	['5', '5', '0', '3', '13', '6', '1', '2', '3', '0.916666667', '67', '1', '0', '0.826086957', '0.36', '0', '0', '11.8', '2', '1', '2']
package org . apache . camel . component . bean ; import java . lang . reflect . Method ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . util . LRUCache ; public class MethodInfoCache { private final CamelContext camelContext ; private Map < Method , MethodInfo > methodCache ; private Map < Class , BeanInfo > classCache ; public MethodInfoCache ( CamelContext camelContext ) { this ( camelContext , 1000 , 10000 ) ; } public MethodInfoCache ( CamelContext camelContext , int classCacheSize , int methodCacheSize ) { this ( camelContext , createLruCache ( classCacheSize ) , createLruCache ( methodCacheSize ) ) ; } public MethodInfoCache ( CamelContext camelContext , Map < Class , BeanInfo > classCache , Map < Method , MethodInfo > methodCache ) { this . camelContext = camelContext ; this . classCache = classCache ; this . methodCache = methodCache ; } public synchronized MethodInfo getMethodInfo ( Method method ) { MethodInfo answer = methodCache . get ( method ) ; if ( answer == null ) { answer = createMethodInfo ( method ) ; methodCache . put ( method , answer ) ; } return answer ; } protected MethodInfo createMethodInfo ( Method method ) { Class < ? > declaringClass = method . getDeclaringClass ( ) ; BeanInfo info = getBeanInfo ( declaringClass ) ; return info . getMethodInfo ( method ) ; } protected synchronized BeanInfo getBeanInfo ( Class < ? > declaringClass ) { BeanInfo beanInfo = classCache . get ( declaringClass ) ; if ( beanInfo == null ) { beanInfo = createBeanInfo ( declaringClass ) ; classCache . put ( declaringClass , beanInfo ) ; } return beanInfo ; } protected BeanInfo createBeanInfo ( Class < ? > declaringClass ) { return new BeanInfo ( camelContext , declaringClass ) ; } protected static Map createLruCache ( int size ) { return new LRUCache ( size ) ; } } 	0	['8', '1', '0', '7', '15', '22', '3', '4', '4', '0.619047619', '100', '1', '1', '0', '0.354166667', '0', '0', '11.125', '2', '0.875', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . camel . spi . RouteContext ; public final class StreamCaching implements InterceptStrategy { private StreamCaching ( ) { super ( ) ; } @ SuppressWarnings ( "unchecked" ) public Processor wrapProcessorInInterceptors ( ProcessorType processorType , Processor target ) throws Exception { return new StreamCachingInterceptor ( target ) ; } public static void enable ( RouteContext context ) { for ( InterceptStrategy strategy : context . getInterceptStrategies ( ) ) { if ( strategy instanceof StreamCaching ) { return ; } } context . addInterceptStrategy ( new StreamCaching ( ) ) ; } } 	1	['3', '1', '0', '6', '10', '3', '1', '5', '2', '2', '33', '0', '0', '0', '0.416666667', '0', '0', '10', '2', '1', '3']
package org . apache . camel . component . quartz ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; import org . quartz . JobExecutionContext ; import org . quartz . Trigger ; public class QuartzMessage extends DefaultMessage { private final JobExecutionContext jobExecutionContext ; public QuartzMessage ( QuartzExchange exchange , JobExecutionContext jobExecutionContext ) { this . jobExecutionContext = jobExecutionContext ; setExchange ( exchange ) ; if ( jobExecutionContext != null ) { setBody ( jobExecutionContext . getJobDetail ( ) ) ; } } public JobExecutionContext getJobExecutionContext ( ) { return jobExecutionContext ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { super . populateInitialHeaders ( map ) ; if ( jobExecutionContext != null ) { map . put ( "calendar" , jobExecutionContext . getCalendar ( ) ) ; map . put ( "fireTime" , jobExecutionContext . getFireTime ( ) ) ; map . put ( "jobDetail" , jobExecutionContext . getJobDetail ( ) ) ; map . put ( "jobInstance" , jobExecutionContext . getJobInstance ( ) ) ; map . put ( "jobRunTime" , jobExecutionContext . getJobRunTime ( ) ) ; map . put ( "mergedJobDataMap" , jobExecutionContext . getMergedJobDataMap ( ) ) ; map . put ( "nextFireTime" , jobExecutionContext . getNextFireTime ( ) ) ; map . put ( "previousFireTime" , jobExecutionContext . getPreviousFireTime ( ) ) ; map . put ( "refireCount" , jobExecutionContext . getRefireCount ( ) ) ; map . put ( "result" , jobExecutionContext . getResult ( ) ) ; map . put ( "scheduledFireTime" , jobExecutionContext . getScheduledFireTime ( ) ) ; map . put ( "scheduler" , jobExecutionContext . getScheduler ( ) ) ; Trigger trigger = jobExecutionContext . getTrigger ( ) ; map . put ( "trigger" , trigger ) ; map . put ( "triggerName" , trigger . getName ( ) ) ; map . put ( "triggerGroup" , trigger . getGroup ( ) ) ; } } } 	0	['3', '3', '0', '10', '25', '0', '1', '10', '2', '0', '136', '1', '0', '0.945945946', '0.5', '1', '1', '44', '2', '1', '0']
package org . apache . camel . component . file ; import java . io . File ; import java . io . IOException ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . camel . language . simple . FileLanguage ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . UuidGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FileEndpoint extends ScheduledPollEndpoint < FileExchange > { public static final transient String DEFAULT_LOCK_FILE_POSTFIX = ".camelLock" ; private static final transient Log LOG = LogFactory . getLog ( FileEndpoint . class ) ; private static final transient String DEFAULT_STRATEGYFACTORY_CLASS = "org.apache.camel.component.file.strategy.FileProcessStrategyFactory" ; private File file ; private FileProcessStrategy fileProcessStrategy ; private boolean autoCreate = true ; private boolean lock = true ; private boolean delete ; private boolean noop ; private boolean append = true ; private String moveNamePrefix ; private String moveNamePostfix ; private String [ ] excludedNamePrefixes ; private String [ ] excludedNamePostfixes ; private String preMoveNamePrefix ; private String preMoveNamePostfix ; private String excludedNamePrefix ; private String excludedNamePostfix ; private int bufferSize = 128 * 1024 ; private boolean ignoreFileNameHeader ; private Expression expression ; private Expression preMoveExpression ; protected FileEndpoint ( File file , String endpointUri , FileComponent component ) { super ( endpointUri , component ) ; this . file = file ; } public FileEndpoint ( String endpointUri , File file ) { super ( endpointUri ) ; this . file = file ; } public FileEndpoint ( File file ) { this . file = file ; } public FileEndpoint ( ) { } public Producer < FileExchange > createProducer ( ) throws Exception { Producer < FileExchange > result = new FileProducer ( this ) ; return result ; } public Consumer < FileExchange > createConsumer ( Processor processor ) throws Exception { Consumer < FileExchange > result = new FileConsumer ( this , processor ) ; if ( isDelete ( ) && ( getMoveNamePrefix ( ) != null || getMoveNamePostfix ( ) != null || getExpression ( ) != null ) ) { throw new IllegalArgumentException ( "You cannot set delet and a moveNamePrefix, moveNamePostfix or expression option" ) ; } configureConsumer ( result ) ; return result ; } public FileExchange createExchange ( File file ) { return new FileExchange ( getCamelContext ( ) , getExchangePattern ( ) , file ) ; } @ Override public FileExchange createExchange ( ) { return createExchange ( getFile ( ) ) ; } @ Override public FileExchange createExchange ( ExchangePattern pattern ) { return new FileExchange ( getCamelContext ( ) , pattern , file ) ; } public String getGeneratedFileName ( Message message ) { return getFileFriendlyMessageId ( message . getMessageId ( ) ) ; } public void configureMessage ( File file , Message message ) { message . setBody ( file ) ; String relativePath = file . getPath ( ) . substring ( getFile ( ) . getPath ( ) . length ( ) ) ; if ( relativePath . startsWith ( File . separator ) || relativePath . startsWith ( "/" ) ) { relativePath = relativePath . substring ( 1 ) ; } message . setHeader ( FileComponent . HEADER_FILE_NAME , relativePath ) ; } public File getFile ( ) { ObjectHelper . notNull ( file , "file" ) ; if ( autoCreate && ! file . exists ( ) ) { file . mkdirs ( ) ; } return file ; } public void setFile ( File file ) { this . file = file ; } public boolean isSingleton ( ) { return true ; } public boolean isAutoCreate ( ) { return this . autoCreate ; } public void setAutoCreate ( boolean autoCreate ) { this . autoCreate = autoCreate ; } public FileProcessStrategy getFileStrategy ( ) { if ( fileProcessStrategy == null ) { fileProcessStrategy = createFileStrategy ( ) ; LOG . debug ( "Using file process strategy: " + fileProcessStrategy ) ; } return fileProcessStrategy ; } public void setFileStrategy ( FileProcessStrategy fileProcessStrategy ) { this . fileProcessStrategy = fileProcessStrategy ; } public boolean isDelete ( ) { return delete ; } public void setDelete ( boolean delete ) { this . delete = delete ; } public boolean isLock ( ) { return lock ; } public void setLock ( boolean lock ) { this . lock = lock ; } public String getMoveNamePostfix ( ) { return moveNamePostfix ; } public void setMoveNamePostfix ( String moveNamePostfix ) { this . moveNamePostfix = moveNamePostfix ; } public String getMoveNamePrefix ( ) { return moveNamePrefix ; } public void setMoveNamePrefix ( String moveNamePrefix ) { this . moveNamePrefix = moveNamePrefix ; } public String [ ] getExcludedNamePrefixes ( ) { return excludedNamePrefixes ; } public void setExcludedNamePrefixes ( String [ ] excludedNamePrefixes ) { this . excludedNamePrefixes = excludedNamePrefixes ; } public String [ ] getExcludedNamePostfixes ( ) { return excludedNamePostfixes ; } public void setExcludedNamePostfixes ( String [ ] excludedNamePostfixes ) { this . excludedNamePostfixes = excludedNamePostfixes ; } public String getPreMoveNamePrefix ( ) { return preMoveNamePrefix ; } public void setPreMoveNamePrefix ( String preMoveNamePrefix ) { this . preMoveNamePrefix = preMoveNamePrefix ; } public String getPreMoveNamePostfix ( ) { return preMoveNamePostfix ; } public void setPreMoveNamePostfix ( String preMoveNamePostfix ) { this . preMoveNamePostfix = preMoveNamePostfix ; } public boolean isNoop ( ) { return noop ; } public void setNoop ( boolean noop ) { this . noop = noop ; } public boolean isAppend ( ) { return append ; } public void setAppend ( boolean append ) { this . append = append ; } public int getBufferSize ( ) { return bufferSize ; } public void setBufferSize ( int bufferSize ) { this . bufferSize = bufferSize ; } public boolean isIgnoreFileNameHeader ( ) { return ignoreFileNameHeader ; } public void setIgnoreFileNameHeader ( boolean ignoreFileNameHeader ) { this . ignoreFileNameHeader = ignoreFileNameHeader ; } public String getExcludedNamePrefix ( ) { return excludedNamePrefix ; } public void setExcludedNamePrefix ( String excludedNamePrefix ) { this . excludedNamePrefix = excludedNamePrefix ; } public String getExcludedNamePostfix ( ) { return excludedNamePostfix ; } public void setExcludedNamePostfix ( String excludedNamePostfix ) { this . excludedNamePostfix = excludedNamePostfix ; } public Expression getExpression ( ) { return expression ; } public void setExpression ( Expression expression ) { this . expression = expression ; } public void setExpression ( String fileLanguageExpression ) { this . expression = FileLanguage . file ( fileLanguageExpression ) ; } public Expression getPreMoveExpression ( ) { return preMoveExpression ; } public void setPreMoveExpression ( Expression expression ) { this . preMoveExpression = expression ; } public void setPreMoveExpression ( String fileLanguageExpression ) { this . preMoveExpression = FileLanguage . file ( fileLanguageExpression ) ; } protected FileProcessStrategy createFileStrategy ( ) { Class < ? > factory = null ; try { FactoryFinder finder = getCamelContext ( ) . createFactoryFinder ( "META-INF/services/org/apache/camel/component/" ) ; factory = finder . findClass ( "file" , "strategy.factory." ) ; } catch ( ClassNotFoundException e ) { LOG . debug ( "'strategy.factory.class' not found" , e ) ; } catch ( IOException e ) { LOG . debug ( "No strategy factory defined in 'META-INF/services/org/apache/camel/component/file'" , e ) ; } if ( factory == null ) { factory = ObjectHelper . loadClass ( DEFAULT_STRATEGYFACTORY_CLASS ) ; if ( factory == null ) { throw new TypeNotPresentException ( "FileProcessStrategyFactory class not found" , null ) ; } } try { Method factoryMethod = factory . getMethod ( "createFileProcessStrategy" , Map . class ) ; return ( FileProcessStrategy ) ObjectHelper . invokeMethod ( factoryMethod , null , getParamsAsMap ( ) ) ; } catch ( NoSuchMethodException e ) { throw new TypeNotPresentException ( factory . getSimpleName ( ) + ".createFileProcessStrategy(Properties params) method not found" , e ) ; } } protected Map < String , Object > getParamsAsMap ( ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; if ( isNoop ( ) ) { params . put ( "noop" , Boolean . toString ( true ) ) ; } if ( isDelete ( ) ) { params . put ( "delete" , Boolean . toString ( true ) ) ; } if ( isAppend ( ) ) { params . put ( "append" , Boolean . toString ( true ) ) ; } if ( isLock ( ) ) { params . put ( "lock" , Boolean . toString ( true ) ) ; } if ( moveNamePrefix != null ) { params . put ( "moveNamePrefix" , moveNamePrefix ) ; } if ( moveNamePostfix != null ) { params . put ( "moveNamePostfix" , moveNamePostfix ) ; } if ( preMoveNamePrefix != null ) { params . put ( "preMoveNamePrefix" , preMoveNamePrefix ) ; } if ( preMoveNamePostfix != null ) { params . put ( "preMoveNamePostfix" , preMoveNamePostfix ) ; } if ( expression != null ) { params . put ( "expression" , expression ) ; } if ( preMoveExpression != null ) { params . put ( "preMoveExpression" , preMoveExpression ) ; } return params ; } @ Override protected String createEndpointUri ( ) { return "file://" + getFile ( ) . getAbsolutePath ( ) ; } protected String getFileFriendlyMessageId ( String id ) { return UuidGenerator . generateSanitizedId ( id ) ; } } 	1	['59', '3', '0', '24', '97', '1527', '7', '21', '53', '0.944357367', '617', '0.954545455', '3', '0.341463415', '0.13362069', '1', '2', '9.084745763', '11', '1.2034', '9']
package org . apache . camel . component . mina ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . apache . mina . common . IoSession ; public class MinaExchange extends DefaultExchange { private IoSession session ; public MinaExchange ( CamelContext camelContext , ExchangePattern pattern , IoSession session ) { super ( camelContext , pattern ) ; this . session = session ; } public MinaExchange ( DefaultExchange parent , IoSession session ) { super ( parent ) ; this . session = session ; } public IoSession getSession ( ) { return session ; } @ Override public Exchange newInstance ( ) { return new MinaExchange ( this , getSession ( ) ) ; } } 	0	['4', '2', '0', '7', '6', '0', '2', '5', '4', '0', '30', '1', '0', '0.95', '0.45', '1', '1', '6.25', '1', '0.5', '0']
package org . apache . camel . management ; import java . util . Map ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . InterceptStrategy ; public class InstrumentationInterceptStrategy implements InterceptStrategy { private Map < ProcessorType , PerformanceCounter > counterMap ; public InstrumentationInterceptStrategy ( Map < ProcessorType , PerformanceCounter > counterMap ) { this . counterMap = counterMap ; } public Processor wrapProcessorInInterceptors ( ProcessorType processorType , Processor target ) throws Exception { Processor retval = target ; PerformanceCounter counter = counterMap . get ( processorType ) ; if ( counter != null ) { InstrumentationProcessor wrapper = new InstrumentationProcessor ( counter ) ; wrapper . setProcessor ( target ) ; retval = wrapper ; } return retval ; } } 	1	['2', '1', '0', '6', '6', '0', '1', '5', '2', '0', '31', '1', '0', '0', '0.625', '0', '0', '14', '1', '0.5', '3']
package org . apache . camel . component . jpa ; import javax . persistence . EntityManager ; import javax . persistence . EntityManagerFactory ; import javax . persistence . EntityTransaction ; import org . apache . camel . impl . ServiceSupport ; import org . springframework . orm . jpa . JpaCallback ; import static org . apache . camel . util . ObjectHelper . notNull ; public class DefaultTransactionStrategy extends ServiceSupport implements TransactionStrategy { private EntityManagerFactory entityManagerFactory ; private EntityManager entityManager ; public DefaultTransactionStrategy ( EntityManagerFactory entityManagerFactory ) { notNull ( entityManagerFactory , "entityManagerFactory" ) ; this . entityManagerFactory = entityManagerFactory ; } public DefaultTransactionStrategy ( EntityManager entityManager ) { notNull ( entityManager , "entityManager" ) ; this . entityManager = entityManager ; } public Object execute ( JpaCallback callback ) { EntityManager em = getEntityManager ( ) ; EntityTransaction transaction = em . getTransaction ( ) ; transaction . begin ( ) ; try { Object answer = callback . doInJpa ( em ) ; transaction . commit ( ) ; return answer ; } catch ( RuntimeException e ) { if ( transaction != null ) { transaction . rollback ( ) ; } throw e ; } } public EntityManager getEntityManager ( ) { if ( entityManager == null ) { entityManager = entityManagerFactory . createEntityManager ( ) ; } return entityManager ; } protected void doStart ( ) throws Exception { getEntityManager ( ) ; } protected void doStop ( ) throws Exception { if ( entityManager != null ) { entityManager . close ( ) ; } } } 	0	['6', '2', '0', '4', '15', '7', '0', '4', '4', '0.3', '71', '1', '0', '0.777777778', '0.375', '1', '1', '10.5', '2', '1', '0']
package org . apache . camel . processor . interceptor ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class Debugger implements InterceptStrategy { private static final transient Log LOG = LogFactory . getLog ( Debugger . class ) ; private int exchangeBufferSize = - 1 ; private Map < String , DebugInterceptor > interceptors = new HashMap < String , DebugInterceptor > ( ) ; private boolean logExchanges = true ; private boolean enabled = true ; private Tracer tracer = new Tracer ( ) ; public static Debugger getDebugger ( CamelContext context ) { if ( context instanceof DefaultCamelContext ) { DefaultCamelContext defaultCamelContext = ( DefaultCamelContext ) context ; List < InterceptStrategy > list = defaultCamelContext . getInterceptStrategies ( ) ; for ( InterceptStrategy interceptStrategy : list ) { if ( interceptStrategy instanceof Debugger ) { return ( Debugger ) interceptStrategy ; } } } return null ; } public DebugInterceptor getInterceptor ( String id ) { return interceptors . get ( id ) ; } public List < Exchange > getExchanges ( String id ) { DebugInterceptor interceptor = getInterceptor ( id ) ; if ( interceptor == null ) { return null ; } else { return interceptor . getExchanges ( ) ; } } public void setEnable ( boolean flag ) { enabled = flag ; tracer . setEnabled ( flag ) ; for ( DebugInterceptor interceptor : interceptors . values ( ) ) { interceptor . setEnabled ( flag ) ; } } public boolean isEnabled ( ) { return enabled ; } public Breakpoint getBreakpoint ( String id ) { DebugInterceptor interceptor = getInterceptor ( id ) ; if ( interceptor == null ) { return null ; } else { return interceptor . getBreakpoint ( ) ; } } public TraceFormatter getTraceFormatter ( ) { return tracer . getFormatter ( ) ; } public void setTraceFormatter ( TraceFormatter formatter ) { tracer . setFormatter ( formatter ) ; } public void setLogExchanges ( boolean flag ) { logExchanges = flag ; } public Processor wrapProcessorInInterceptors ( ProcessorType processorType , Processor target ) throws Exception { String id = processorType . idOrCreate ( ) ; if ( logExchanges ) { TraceInterceptor traceInterceptor = new TraceInterceptor ( processorType , target , tracer ) ; target = traceInterceptor ; } DebugInterceptor interceptor = new DebugInterceptor ( processorType , target , createExchangeList ( ) , createExceptionsList ( ) ) ; interceptors . put ( id , interceptor ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Adding " + id + " interceptor: " + interceptor ) ; } return interceptor ; } protected List < Exchange > createExchangeList ( ) { if ( exchangeBufferSize == 0 ) { return null ; } else if ( exchangeBufferSize > 0 ) { return new ArrayList < Exchange > ( ) ; } else { return new ArrayList < Exchange > ( ) ; } } protected List < ExceptionEvent > createExceptionsList ( ) { return new ArrayList < ExceptionEvent > ( ) ; } } 	1	['14', '1', '0', '14', '42', '53', '2', '12', '11', '0.794871795', '213', '1', '1', '0', '0.230769231', '0', '0', '13.78571429', '3', '1.3571', '1']
package org . apache . camel . language . simple ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . spi . Language ; public abstract class AbstractSimpleLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { if ( expression . indexOf ( "${" ) >= 0 ) { return createComplexExpression ( expression ) ; } return createSimpleExpression ( expression ) ; } protected Expression < Exchange > createComplexExpression ( String expression ) { List < Expression > results = new ArrayList < Expression > ( ) ; int pivot = 0 ; int size = expression . length ( ) ; while ( pivot < size ) { int idx = expression . indexOf ( "${" , pivot ) ; if ( idx < 0 ) { results . add ( createConstantExpression ( expression , pivot , size ) ) ; break ; } else { if ( pivot < idx ) { results . add ( createConstantExpression ( expression , pivot , idx ) ) ; } pivot = idx + 2 ; int endIdx = expression . indexOf ( "}" , pivot ) ; if ( endIdx < 0 ) { throw new IllegalArgumentException ( "Expecting } but found end of string for simple expression: " + expression ) ; } String simpleText = expression . substring ( pivot , endIdx ) ; Expression simpleExpression = createSimpleExpression ( simpleText ) ; results . add ( simpleExpression ) ; pivot = endIdx + 1 ; } } return ExpressionBuilder . concatExpression ( results , expression ) ; } protected Expression createConstantExpression ( String expression , int start , int end ) { return ExpressionBuilder . constantExpression ( expression . substring ( start , end ) ) ; } protected abstract < E extends Exchange > Expression < Exchange > createSimpleExpression ( String expression ) ; protected String ifStartsWithReturnRemainder ( String prefix , String text ) { if ( text . startsWith ( prefix ) ) { String remainder = text . substring ( prefix . length ( ) ) ; if ( remainder . length ( ) > 0 ) { return remainder ; } } return null ; } } 	0	['7', '1', '2', '7', '23', '21', '2', '5', '3', '2', '133', '0', '0', '0', '0.666666667', '0', '0', '18', '5', '1.8571', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class ChoiceProcessor extends ServiceSupport implements Processor { private List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; private Processor otherwise ; public ChoiceProcessor ( List < FilterProcessor > filters , Processor otherwise ) { this . filters = filters ; this . otherwise = otherwise ; } public void process ( Exchange exchange ) throws Exception { for ( FilterProcessor filterProcessor : filters ) { Predicate < Exchange > predicate = filterProcessor . getPredicate ( ) ; if ( predicate != null && predicate . matches ( exchange ) ) { filterProcessor . processNext ( exchange ) ; return ; } } if ( otherwise != null ) { otherwise . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "choice{" ) ; boolean first = true ; for ( FilterProcessor processor : filters ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( "when " ) ; builder . append ( processor . getPredicate ( ) . toString ( ) ) ; builder . append ( ": " ) ; builder . append ( processor . getProcessor ( ) ) ; } if ( otherwise != null ) { builder . append ( ", otherwise: " ) ; builder . append ( otherwise ) ; } builder . append ( "}" ) ; return builder . toString ( ) ; } public List < FilterProcessor > getFilters ( ) { return filters ; } public Processor getOtherwise ( ) { return otherwise ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( filters ) ; ServiceHelper . startServices ( otherwise ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( otherwise ) ; ServiceHelper . stopServices ( filters ) ; } } 	1	['7', '2', '0', '7', '26', '0', '1', '6', '5', '0.166666667', '152', '1', '1', '0.7', '0.357142857', '1', '1', '20.42857143', '4', '1.2857', '1']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "simple" ) public @ interface Simple { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . spi . Registry ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface EndpointInject { String uri ( ) default "" ; String name ( ) default "" ; } 	1	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultComponentResolver < E extends Exchange > implements ComponentResolver < E > { protected static final FactoryFinder COMPONENT_FACTORY = new FactoryFinder ( "META-INF/services/org/apache/camel/component/" ) ; private static final transient Log LOG = LogFactory . getLog ( DefaultComponentResolver . class ) ; public Component < E > resolveComponent ( String name , CamelContext context ) { Object bean = null ; try { bean = context . getRegistry ( ) . lookup ( name ) ; if ( bean != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " in registry: " + bean ) ; } } catch ( Exception e ) { LOG . debug ( "Ignored error looking up bean: " + name + ". Error: " + e ) ; } if ( bean != null ) { if ( bean instanceof Component ) { return ( Component ) bean ; } } Class type ; try { type = COMPONENT_FACTORY . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { return null ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Component registered for scheme : " + name , e ) ; } if ( type == null ) { return null ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " via type: " + type . getName ( ) + " via " + COMPONENT_FACTORY . getPath ( ) + name ) ; } if ( Component . class . isAssignableFrom ( type ) ) { return ( Component < E > ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Component implementation. Found: " + type . getName ( ) ) ; } } } 	0	['3', '1', '0', '10', '22', '1', '1', '9', '2', '0.5', '141', '1', '1', '0', '0.666666667', '0', '0', '45.33333333', '6', '2', '0']
package org . apache . camel . impl ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class ScheduledPollConsumer < E extends Exchange > extends DefaultConsumer < E > implements Runnable { private static final transient Log LOG = LogFactory . getLog ( ScheduledPollConsumer . class ) ; private final ScheduledExecutorService executor ; private long initialDelay = 1000 ; private long delay = 500 ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; private boolean useFixedDelay ; private ScheduledFuture < ? > future ; private Exception firstExceptionThrown ; public ScheduledPollConsumer ( DefaultEndpoint < E > endpoint , Processor processor ) { this ( endpoint , processor , endpoint . getExecutorService ( ) ) ; } public ScheduledPollConsumer ( Endpoint < E > endpoint , Processor processor , ScheduledExecutorService executor ) { super ( endpoint , processor ) ; this . executor = executor ; if ( executor == null ) { throw new IllegalArgumentException ( "A non null ScheduledExecutorService must be provided." ) ; } } public void run ( ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Starting to poll: " + this . getEndpoint ( ) ) ; } try { poll ( ) ; } catch ( Exception e ) { LOG . warn ( "An exception occured while polling: " + this . getEndpoint ( ) + ": " + e . getMessage ( ) , e ) ; if ( firstExceptionThrown == null ) { firstExceptionThrown = e ; } } } public long getInitialDelay ( ) { return initialDelay ; } public void setInitialDelay ( long initialDelay ) { this . initialDelay = initialDelay ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } public void setTimeUnit ( TimeUnit timeUnit ) { this . timeUnit = timeUnit ; } public boolean isUseFixedDelay ( ) { return useFixedDelay ; } public void setUseFixedDelay ( boolean useFixedDelay ) { this . useFixedDelay = useFixedDelay ; } protected abstract void poll ( ) throws Exception ; @ Override protected void doStart ( ) throws Exception { firstExceptionThrown = null ; super . doStart ( ) ; if ( isUseFixedDelay ( ) ) { future = executor . scheduleWithFixedDelay ( this , getInitialDelay ( ) , getDelay ( ) , getTimeUnit ( ) ) ; } else { future = executor . scheduleAtFixedRate ( this , getInitialDelay ( ) , getDelay ( ) , getTimeUnit ( ) ) ; } } @ Override protected void doStop ( ) throws Exception { if ( future != null ) { future . cancel ( false ) ; } super . doStop ( ) ; if ( firstExceptionThrown != null ) { throw firstExceptionThrown ; } } } 	1	['15', '3', '6', '12', '33', '75', '6', '6', '11', '0.821428571', '179', '1', '0', '0.657142857', '0.205357143', '1', '1', '10.4', '3', '0.9333', '1']
package org . apache . camel . management ; public final class JmxSystemPropertyKeys { public static final String DISABLED = "org.apache.camel.jmx.disabled" ; public static final String REGISTRY_PORT = "org.apache.camel.jmx.rmiConnector.registryPort" ; public static final String CONNECTOR_PORT = "org.apache.camel.jmx.rmiConnector.connectorPort" ; public static final String DOMAIN = "org.apache.camel.jmx.mbeanServerDefaultDomain" ; public static final String MBEAN_DOMAIN = "org.apache.camel.jmx.mbeanObjectDomainName" ; public static final String SERVICE_URL_PATH = "org.apache.camel.jmx.serviceUrlPath" ; public static final String CREATE_CONNECTOR = "org.apache.camel.jmx.createRmiConnector" ; public static final String USE_PLATFORM_MBS = "org.apache.camel.jmx.usePlatformMBeanServer" ; private JmxSystemPropertyKeys ( ) { } } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '0', '2', '12', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Expression ; import org . apache . camel . Pattern ; import org . apache . camel . model . language . ConstantExpression ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ObjectHelper . asString ; public class MethodInfo { private static final transient Log LOG = LogFactory . getLog ( MethodInfo . class ) ; private Class type ; private Method method ; private final List < ParameterInfo > parameters ; private final List < ParameterInfo > bodyParameters ; private final boolean hasCustomAnnotation ; private Expression parametersExpression ; private ExchangePattern pattern = ExchangePattern . InOut ; private RecipientList recipientList ; public MethodInfo ( Class type , Method method , List < ParameterInfo > parameters , List < ParameterInfo > bodyParameters , boolean hasCustomAnnotation ) { this . type = type ; this . method = method ; this . parameters = parameters ; this . bodyParameters = bodyParameters ; this . hasCustomAnnotation = hasCustomAnnotation ; this . parametersExpression = createParametersExpression ( ) ; Pattern oneway = findOneWayAnnotation ( method ) ; if ( oneway != null ) { pattern = oneway . value ( ) ; } if ( method . getAnnotation ( org . apache . camel . RecipientList . class ) != null ) { recipientList = new RecipientList ( new ConstantExpression ( null ) ) ; } } public String toString ( ) { return method . toString ( ) ; } public MethodInvocation createMethodInvocation ( final Object pojo , final Exchange exchange ) { final Object [ ] arguments = ( Object [ ] ) parametersExpression . evaluate ( exchange ) ; return new MethodInvocation ( ) { public Method getMethod ( ) { return method ; } public Object [ ] getArguments ( ) { return arguments ; } public Object proceed ( ) throws Exception { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( ">>>> invoking: " + method + " on bean: " + pojo + " with arguments: " + asString ( arguments ) + " for exchange: " + exchange ) ; } Object result = invoke ( method , pojo , arguments , exchange ) ; if ( recipientList != null ) { recipientList . sendToRecipientList ( exchange , result ) ; } return result ; } public Object getThis ( ) { return pojo ; } public AccessibleObject getStaticPart ( ) { return method ; } } ; } public Class getType ( ) { return type ; } public Method getMethod ( ) { return method ; } public ExchangePattern getPattern ( ) { return pattern ; } public Expression getParametersExpression ( ) { return parametersExpression ; } public List < ParameterInfo > getBodyParameters ( ) { return bodyParameters ; } public Class getBodyParameterType ( ) { ParameterInfo parameterInfo = bodyParameters . get ( 0 ) ; return parameterInfo . getType ( ) ; } public boolean bodyParameterMatches ( Class bodyType ) { Class actualType = getBodyParameterType ( ) ; return actualType != null && ObjectHelper . isAssignableFrom ( bodyType , actualType ) ; } public List < ParameterInfo > getParameters ( ) { return parameters ; } public boolean hasBodyParameter ( ) { return ! bodyParameters . isEmpty ( ) ; } public boolean isHasCustomAnnotation ( ) { return hasCustomAnnotation ; } public boolean isReturnTypeVoid ( ) { return method . getReturnType ( ) . getName ( ) . equals ( "void" ) ; } protected Object invoke ( Method mth , Object pojo , Object [ ] arguments , Exchange exchange ) throws IllegalAccessException , InvocationTargetException { return mth . invoke ( pojo , arguments ) ; } protected Expression createParametersExpression ( ) { final int size = parameters . size ( ) ; final Expression [ ] expressions = new Expression [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { Expression parameterExpression = parameters . get ( i ) . getExpression ( ) ; expressions [ i ] = parameterExpression ; } return new Expression < Exchange > ( ) { public Object evaluate ( Exchange exchange ) { Object [ ] answer = new Object [ size ] ; Object body = exchange . getIn ( ) . getBody ( ) ; boolean multiParameterArray = false ; if ( exchange . getIn ( ) . getHeader ( BeanProcessor . MULTI_PARAMETER_ARRAY ) != null ) { multiParameterArray = exchange . getIn ( ) . getHeader ( BeanProcessor . MULTI_PARAMETER_ARRAY , Boolean . class ) ; } for ( int i = 0 ; i < size ; i ++ ) { Object value = null ; if ( multiParameterArray ) { value = ( ( Object [ ] ) body ) [ i ] ; } else { value = expressions [ i ] . evaluate ( exchange ) ; } Class expectedType = parameters . get ( i ) . getType ( ) ; value = ExchangeHelper . convertToType ( exchange , expectedType , value ) ; answer [ i ] = value ; } return answer ; } @ Override public String toString ( ) { return "ParametersExpression: " + Arrays . asList ( expressions ) ; } } ; } protected Pattern findOneWayAnnotation ( Method method ) { Pattern answer = getPatternAnnotation ( method ) ; if ( answer == null ) { Class < ? > type = method . getDeclaringClass ( ) ; List < Class < ? > > typesToSearch = new ArrayList < Class < ? > > ( ) ; addTypeAndSuperTypes ( type , typesToSearch ) ; Class [ ] interfaces = type . getInterfaces ( ) ; for ( Class anInterface : interfaces ) { addTypeAndSuperTypes ( anInterface , typesToSearch ) ; } answer = findOneWayAnnotationOnMethod ( typesToSearch , method ) ; if ( answer == null ) { answer = findOneWayAnnotation ( typesToSearch ) ; } } return answer ; } protected Pattern getPatternAnnotation ( AnnotatedElement annotatedElement ) { return getPatternAnnotation ( annotatedElement , 2 ) ; } protected Pattern getPatternAnnotation ( AnnotatedElement annotatedElement , int depth ) { Pattern answer = annotatedElement . getAnnotation ( Pattern . class ) ; int nextDepth = depth - 1 ; if ( nextDepth > 0 ) { Annotation [ ] annotations = annotatedElement . getAnnotations ( ) ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( annotation instanceof Pattern || annotationType . equals ( annotatedElement ) ) { continue ; } else { Pattern another = getPatternAnnotation ( annotationType , nextDepth ) ; if ( pattern != null ) { if ( answer == null ) { answer = another ; } else { LOG . warn ( "Duplicate pattern annotation: " + another + " found on annotation: " + annotation + " which will be ignored" ) ; } } } } } return answer ; } protected void addTypeAndSuperTypes ( Class < ? > type , List < Class < ? > > result ) { for ( Class < ? > t = type ; t != null && t != Object . class ; t = t . getSuperclass ( ) ) { result . add ( t ) ; } } protected Pattern findOneWayAnnotationOnMethod ( List < Class < ? > > classes , Method method ) { for ( Class < ? > type : classes ) { try { Method definedMethod = type . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; Pattern answer = getPatternAnnotation ( definedMethod ) ; if ( answer != null ) { return answer ; } } catch ( NoSuchMethodException e ) { } } return null ; } protected Pattern findOneWayAnnotation ( List < Class < ? > > classes ) { for ( Class < ? > type : classes ) { Pattern answer = getPatternAnnotation ( type ) ; if ( answer != null ) { return answer ; } } return null ; } } 	1	['27', '1', '0', '16', '67', '283', '5', '13', '14', '0.888888889', '410', '1', '3', '0', '0.157342657', '0', '0', '13.85185185', '7', '1.5556', '1']
package org . apache . camel . processor . aggregate ; import org . apache . camel . Exchange ; public interface AggregationStrategy { Exchange aggregate ( Exchange oldExchange , Exchange newExchange ) ; } 	0	['1', '1', '0', '16', '1', '0', '15', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; public class ExchangePatternProcessor implements AsyncProcessor { private ExchangePattern exchangePattern = ExchangePattern . InOnly ; public ExchangePatternProcessor ( ) { } public ExchangePatternProcessor ( ExchangePattern ep ) { setExchangePattern ( ep ) ; } public void setExchangePattern ( ExchangePattern ep ) { exchangePattern = ep ; } public void process ( Exchange exchange ) throws Exception { exchange . setPattern ( exchangePattern ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { exchange . setPattern ( exchangePattern ) ; callback . done ( true ) ; return true ; } } 	1	['5', '1', '0', '5', '8', '0', '1', '4', '5', '0', '39', '1', '1', '0', '0.5', '0', '0', '6.6', '1', '0.6', '2']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . config . BatchResequencerConfig ; import org . apache . camel . model . config . StreamResequencerConfig ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Resequencer ; import org . apache . camel . processor . StreamResequencer ; import org . apache . camel . processor . resequencer . ExpressionResultComparator ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "resequencer" ) public class ResequencerType extends ProcessorType < ProcessorType > { @ XmlElementRef private List < ExpressionType > expressions = new ArrayList < ExpressionType > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; private BatchResequencerConfig batchConfig ; private StreamResequencerConfig streamConfig ; @ XmlTransient private List < Expression > expressionList ; public ResequencerType ( ) { this ( null ) ; } public ResequencerType ( List < Expression > expressions ) { this . expressionList = expressions ; this . batch ( ) ; } @ Override public String getShortName ( ) { return "resequencer" ; } public ResequencerType stream ( ) { return stream ( StreamResequencerConfig . getDefault ( ) ) ; } public ResequencerType batch ( ) { return batch ( BatchResequencerConfig . getDefault ( ) ) ; } public ResequencerType stream ( StreamResequencerConfig config ) { this . streamConfig = config ; this . batchConfig = null ; return this ; } public ResequencerType batch ( BatchResequencerConfig config ) { this . batchConfig = config ; this . streamConfig = null ; return this ; } public ResequencerType expression ( ExpressionType expression ) { expressions . add ( expression ) ; return this ; } @ Override public String toString ( ) { return "Resequencer[" + getExpressions ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return ExpressionType . getLabel ( getExpressions ( ) ) ; } public List < ExpressionType > getExpressions ( ) { return expressions ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public BatchResequencerConfig getBatchConfig ( ) { return batchConfig ; } public BatchResequencerConfig getBatchConfig ( BatchResequencerConfig defaultConfig ) { return batchConfig ; } public StreamResequencerConfig getStreamConfig ( ) { return streamConfig ; } @ XmlElement ( name = "batch-config" , required = false ) public void setBatchConfig ( BatchResequencerConfig batchConfig ) { batch ( batchConfig ) ; } @ XmlElement ( name = "stream-config" , required = false ) public void setStreamConfig ( StreamResequencerConfig streamConfig ) { stream ( streamConfig ) ; } public ResequencerType timeout ( long timeout ) { if ( batchConfig != null ) { batchConfig . setBatchTimeout ( timeout ) ; } else { streamConfig . setTimeout ( timeout ) ; } return this ; } public ResequencerType size ( int batchSize ) { if ( batchConfig == null ) { throw new IllegalStateException ( "size() only supported for batch resequencer" ) ; } batchConfig . setBatchSize ( batchSize ) ; return this ; } public ResequencerType capacity ( int capacity ) { if ( streamConfig == null ) { throw new IllegalStateException ( "capacity() only supported for stream resequencer" ) ; } streamConfig . setCapacity ( capacity ) ; return this ; } public ResequencerType comparator ( ExpressionResultComparator < Exchange > comparator ) { if ( streamConfig == null ) { throw new IllegalStateException ( "comparator() only supported for stream resequencer" ) ; } streamConfig . setComparator ( comparator ) ; return this ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { if ( batchConfig != null ) { return createBatchResequencer ( routeContext , batchConfig ) ; } else { return createStreamResequencer ( routeContext , streamConfig ) ; } } protected Resequencer createBatchResequencer ( RouteContext routeContext , BatchResequencerConfig config ) throws Exception { Processor processor = routeContext . createProcessor ( this ) ; Resequencer resequencer = new Resequencer ( processor , resolveExpressionList ( routeContext ) ) ; resequencer . setBatchSize ( config . getBatchSize ( ) ) ; resequencer . setBatchTimeout ( config . getBatchTimeout ( ) ) ; return resequencer ; } protected StreamResequencer createStreamResequencer ( RouteContext routeContext , StreamResequencerConfig config ) throws Exception { config . getComparator ( ) . setExpressions ( resolveExpressionList ( routeContext ) ) ; Processor processor = routeContext . createProcessor ( this ) ; StreamResequencer resequencer = new StreamResequencer ( processor , config . getComparator ( ) ) ; resequencer . setTimeout ( config . getTimeout ( ) ) ; resequencer . setCapacity ( config . getCapacity ( ) ) ; return resequencer ; } private List < Expression > resolveExpressionList ( RouteContext routeContext ) { if ( expressionList == null ) { expressionList = new ArrayList < Expression > ( ) ; for ( ExpressionType expression : expressions ) { expressionList . add ( expression . createExpression ( routeContext ) ) ; } } if ( expressionList . isEmpty ( ) ) { throw new IllegalArgumentException ( "No expressions configured for: " + this ) ; } return expressionList ; } } 	0	['26', '3', '0', '14', '61', '235', '4', '11', '23', '0.712', '303', '1', '2', '0.88', '0.188034188', '1', '3', '10.46153846', '4', '1.1923', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . Policy ; import org . apache . camel . util . ServiceHelper ; public class DelegateProcessor extends ServiceSupport implements Processor { protected Processor processor ; public DelegateProcessor ( ) { } public DelegateProcessor ( Processor processor ) { if ( processor == this ) { throw new IllegalArgumentException ( "Recursive DelegateProcessor!" ) ; } this . processor = processor ; } public void process ( Exchange exchange ) throws Exception { processNext ( exchange ) ; } protected void processNext ( Exchange exchange ) throws Exception { if ( processor != null ) { processor . process ( exchange ) ; } } @ Override public String toString ( ) { return "Delegate(" + processor + ")" ; } public Processor getProcessor ( ) { return processor ; } public void setProcessor ( Processor processor ) { this . processor = processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } public void proceed ( Exchange exchange ) throws Exception { processNext ( exchange ) ; } } 	1	['10', '2', '14', '26', '19', '3', '22', '4', '7', '0.111111111', '81', '1', '1', '0.636363636', '0.5', '1', '1', '7', '1', '0.8', '2']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "javaScript" ) public class JavaScriptExpression extends ExpressionType { public JavaScriptExpression ( ) { } public JavaScriptExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "js" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultUnitOfWork ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public final class UnitOfWorkProcessor extends DelegateAsyncProcessor { public UnitOfWorkProcessor ( AsyncProcessor processor ) { super ( processor ) ; } @ Override public String toString ( ) { return "UnitOfWrok(" + processor + ")" ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( exchange . getUnitOfWork ( ) == null ) { final DefaultUnitOfWork uow = new DefaultUnitOfWork ( ) ; exchange . setUnitOfWork ( uow ) ; try { uow . start ( ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { callback . done ( sync ) ; exchange . getUnitOfWork ( ) . done ( exchange ) ; try { uow . stop ( ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } exchange . setUnitOfWork ( null ) ; } } ) ; } else { return processor . process ( exchange , callback ) ; } } } 	1	['3', '3', '0', '10', '15', '1', '2', '9', '3', '2', '54', '0', '0', '0.913043478', '0.5', '0', '0', '17', '2', '1', '1']
package org . apache . camel . component . xmpp ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . Chat ; import org . jivesoftware . smack . ChatManager ; import org . jivesoftware . smack . MessageListener ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; public class XmppPrivateChatProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( XmppPrivateChatProducer . class ) ; private final XmppEndpoint endpoint ; private final String participant ; public XmppPrivateChatProducer ( XmppEndpoint endpoint , String participant ) { super ( endpoint ) ; this . endpoint = endpoint ; this . participant = participant ; if ( participant == null ) { throw new IllegalArgumentException ( "No participant property specified" ) ; } } public void process ( Exchange exchange ) { String threadId = exchange . getExchangeId ( ) ; try { ChatManager chatManager = endpoint . getConnection ( ) . getChatManager ( ) ; Chat chat = chatManager . getThreadChat ( threadId ) ; if ( chat == null ) { chat = chatManager . createChat ( getParticipant ( ) , threadId , new MessageListener ( ) { public void processMessage ( Chat chat , Message message ) { } } ) ; } Message message = new Message ( ) ; message . setTo ( participant ) ; message . setThread ( threadId ) ; message . setType ( Message . Type . normal ) ; endpoint . getBinding ( ) . populateXmppMessage ( message , exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> message: " + message . getBody ( ) ) ; } chat . sendMessage ( message ) ; } catch ( XMPPException e ) { throw new RuntimeXmppException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; } public String getParticipant ( ) { return participant ; } } 	0	['6', '3', '0', '16', '31', '7', '2', '16', '3', '0.733333333', '108', '1', '1', '0.84', '0.4', '1', '1', '16.5', '3', '1', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Intercept ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . model . FromType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . processor . Interceptor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . ProceedProcessor ; import org . apache . camel . processor . UnitOfWorkProcessor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . ErrorHandlerWrappingStrategy ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . camel . spi . RouteContext ; public class DefaultRouteContext implements RouteContext { private RouteType route ; private FromType from ; private Collection < Route > routes ; private Endpoint < ? extends Exchange > endpoint ; private List < Processor > eventDrivenProcessors = new ArrayList < Processor > ( ) ; private Interceptor lastInterceptor ; private CamelContext camelContext ; private List < InterceptStrategy > interceptStrategies = new ArrayList < InterceptStrategy > ( ) ; private ErrorHandlerWrappingStrategy errorHandlerWrappingStrategy ; private boolean routeAdded ; public DefaultRouteContext ( RouteType route , FromType from , Collection < Route > routes ) { this . route = route ; this . from = from ; this . routes = routes ; } public DefaultRouteContext ( CamelContext camelContext ) { this . camelContext = camelContext ; routes = new ArrayList < Route > ( ) ; route = new RouteType ( "temporary" ) ; } public Endpoint < ? extends Exchange > getEndpoint ( ) { if ( endpoint == null ) { endpoint = from . resolveEndpoint ( this ) ; } return endpoint ; } public FromType getFrom ( ) { return from ; } public RouteType getRoute ( ) { return route ; } public CamelContext getCamelContext ( ) { if ( camelContext == null ) { camelContext = getRoute ( ) . getCamelContext ( ) ; } return camelContext ; } public Processor createProcessor ( ProcessorType node ) throws Exception { return node . createOutputsProcessor ( this ) ; } public Endpoint < ? extends Exchange > resolveEndpoint ( String uri ) { return route . resolveEndpoint ( uri ) ; } public Endpoint < ? extends Exchange > resolveEndpoint ( String uri , String ref ) { Endpoint < ? extends Exchange > endpoint = null ; if ( uri != null ) { endpoint = resolveEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } } if ( ref != null ) { endpoint = lookup ( ref , Endpoint . class ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( "ref:" + ref ) ; } } if ( endpoint == null ) { throw new IllegalArgumentException ( "Either 'uri' or 'ref' must be specified on: " + this ) ; } else { return endpoint ; } } public < T > T lookup ( String name , Class < T > type ) { return getCamelContext ( ) . getRegistry ( ) . lookup ( name , type ) ; } public void commit ( ) { if ( ! eventDrivenProcessors . isEmpty ( ) ) { Processor processor = Pipeline . newInstance ( eventDrivenProcessors ) ; final AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter . convert ( processor ) ; Processor unitOfWorkProcessor = new UnitOfWorkProcessor ( asyncProcessor ) ; Route edcr = new EventDrivenConsumerRoute ( getEndpoint ( ) , unitOfWorkProcessor ) ; edcr . getProperties ( ) . put ( Route . ID_PROPERTY , route . idOrCreate ( ) ) ; edcr . getProperties ( ) . put ( Route . PARENT_PROPERTY , Integer . toHexString ( route . hashCode ( ) ) ) ; if ( route . getGroup ( ) != null ) { edcr . getProperties ( ) . put ( Route . GROUP_PROPERTY , route . getGroup ( ) ) ; } routes . add ( edcr ) ; } } public void addEventDrivenProcessor ( Processor processor ) { eventDrivenProcessors . add ( processor ) ; } public void intercept ( Intercept interceptor ) { lastInterceptor = ( Interceptor ) interceptor ; } public Processor createProceedProcessor ( ) { if ( lastInterceptor == null ) { throw new IllegalArgumentException ( "Cannot proceed() from outside of an interceptor!" ) ; } else { return new ProceedProcessor ( lastInterceptor ) ; } } public List < InterceptStrategy > getInterceptStrategies ( ) { return interceptStrategies ; } public void setInterceptStrategies ( List < InterceptStrategy > interceptStrategies ) { this . interceptStrategies = interceptStrategies ; } public void addInterceptStrategy ( InterceptStrategy interceptStrategy ) { getInterceptStrategies ( ) . add ( interceptStrategy ) ; } public ErrorHandlerWrappingStrategy getErrorHandlerWrappingStrategy ( ) { return errorHandlerWrappingStrategy ; } public void setErrorHandlerWrappingStrategy ( ErrorHandlerWrappingStrategy strategy ) { errorHandlerWrappingStrategy = strategy ; } public boolean isRouteAdded ( ) { return routeAdded ; } public void setIsRouteAdded ( boolean b ) { routeAdded = b ; } public DataFormatType getDataFormat ( String ref ) { Map < String , DataFormatType > dataFormats = getCamelContext ( ) . getDataFormats ( ) ; if ( dataFormats != null ) { return dataFormats . get ( ref ) ; } else { return null ; } } } 	1	['22', '1', '0', '23', '53', '181', '3', '21', '22', '0.871428571', '302', '1', '6', '0', '0.123376623', '0', '0', '12.27272727', '6', '1.4091', '4']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . model . dataformat . ArtixDSDataFormat ; import org . apache . camel . model . dataformat . CsvDataFormat ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . dataformat . FlatpackDataFormat ; import org . apache . camel . model . dataformat . HL7DataFormat ; import org . apache . camel . model . dataformat . JaxbDataFormat ; import org . apache . camel . model . dataformat . SerializationDataFormat ; import org . apache . camel . model . dataformat . StringDataFormat ; import org . apache . camel . model . dataformat . XMLBeansDataFormat ; import org . apache . camel . model . dataformat . XStreamDataFormat ; import org . apache . camel . model . dataformat . ZipDataFormat ; import org . apache . camel . processor . MarshalProcessor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "marshal" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MarshalType extends OutputType < ProcessorType > { @ XmlAttribute ( required = false ) private String ref ; @ XmlElements ( { @ XmlElement ( required = false , name = "artixDS" , type = ArtixDSDataFormat . class ) , @ XmlElement ( required = false , name = "csv" , type = CsvDataFormat . class ) , @ XmlElement ( required = false , name = "flatpack" , type = FlatpackDataFormat . class ) , @ XmlElement ( required = false , name = "hl7" , type = HL7DataFormat . class ) , @ XmlElement ( required = false , name = "jaxb" , type = JaxbDataFormat . class ) , @ XmlElement ( required = false , name = "serialization" , type = SerializationDataFormat . class ) , @ XmlElement ( required = false , name = "string" , type = StringDataFormat . class ) , @ XmlElement ( required = false , name = "xmlBeans" , type = XMLBeansDataFormat . class ) , @ XmlElement ( required = false , name = "xstream" , type = XStreamDataFormat . class ) , @ XmlElement ( required = false , name = "zip" , type = ZipDataFormat . class ) } ) private DataFormatType dataFormatType ; public MarshalType ( ) { } public MarshalType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } public MarshalType ( String ref ) { this . ref = ref ; } @ Override public String toString ( ) { if ( dataFormatType != null ) { return "Marshal[" + dataFormatType + "]" ; } else { return "Marshal[ref: " + ref + "]" ; } } @ Override public String getShortName ( ) { return "marshal" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public DataFormatType getDataFormatType ( ) { return dataFormatType ; } public void setDataFormatType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { DataFormat dataFormat = DataFormatType . getDataFormat ( routeContext , getDataFormatType ( ) , ref ) ; return new MarshalProcessor ( dataFormat ) ; } } 	0	['10', '4', '0', '7', '17', '13', '1', '6', '10', '0.555555556', '82', '1', '1', '0.962365591', '0.375', '1', '1', '7', '2', '0.8', '0']
package org . apache . camel . component . dataset ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . util . ExchangeHelper ; public abstract class DataSetSupport implements DataSet { private Map < String , Object > defaultHeaders ; private Processor outputTransformer ; private long size = 10 ; private long reportCount = - 1 ; public DataSetSupport ( ) { } public DataSetSupport ( int size ) { setSize ( size ) ; } public void populateMessage ( Exchange exchange , long messageIndex ) throws Exception { Message in = exchange . getIn ( ) ; in . setBody ( createMessageBody ( messageIndex ) ) ; in . setHeaders ( getDefaultHeaders ( ) ) ; applyHeaders ( exchange , messageIndex ) ; if ( outputTransformer != null ) { outputTransformer . process ( exchange ) ; } } public void assertMessageExpected ( DataSetEndpoint dataSetEndpoint , Exchange expected , Exchange actual , long index ) throws Exception { Object expectedBody = expected . getIn ( ) . getBody ( ) ; Object actualBody = actual . getIn ( ) . getBody ( ) ; if ( expectedBody != null ) { actualBody = ExchangeHelper . getMandatoryInBody ( actual , expectedBody . getClass ( ) ) ; } DataSetEndpoint . assertEquals ( "message body" , expectedBody , actualBody , actual ) ; } public long getSize ( ) { return size ; } public void setSize ( long size ) { this . size = size ; } public long getReportCount ( ) { if ( reportCount <= 0 ) { reportCount = getSize ( ) / 5 ; } return reportCount ; } public void setReportCount ( long reportCount ) { this . reportCount = reportCount ; } public Map < String , Object > getDefaultHeaders ( ) { if ( defaultHeaders == null ) { defaultHeaders = new HashMap < String , Object > ( ) ; populateDefaultHeaders ( defaultHeaders ) ; } return defaultHeaders ; } public void setDefaultHeaders ( Map < String , Object > defaultHeaders ) { this . defaultHeaders = defaultHeaders ; } public Processor getOutputTransformer ( ) { return outputTransformer ; } public void setOutputTransformer ( Processor outputTransformer ) { this . outputTransformer = outputTransformer ; } protected abstract Object createMessageBody ( long messageIndex ) ; protected void applyHeaders ( Exchange exchange , long messageIndex ) { } protected void populateDefaultHeaders ( Map < String , Object > map ) { } } 	1	['15', '1', '1', '7', '25', '75', '1', '6', '12', '0.803571429', '139', '1', '1', '0', '0.276190476', '0', '0', '8', '2', '1', '1']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . spring ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . seda ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . TimeUnit ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SedaConsumer extends ServiceSupport implements Consumer , Runnable { private static final transient Log LOG = LogFactory . getLog ( SedaConsumer . class ) ; private SedaEndpoint endpoint ; private AsyncProcessor processor ; private Thread thread ; public SedaConsumer ( SedaEndpoint endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = AsyncProcessorTypeConverter . convert ( processor ) ; } @ Override public String toString ( ) { return "SedaConsumer: " + endpoint . getEndpointUri ( ) ; } public void run ( ) { BlockingQueue < Exchange > queue = endpoint . getQueue ( ) ; while ( queue != null && isRunAllowed ( ) ) { final Exchange exchange ; try { exchange = queue . poll ( 1000 , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Interupted: " + e , e ) ; } continue ; } if ( exchange != null ) { if ( isRunAllowed ( ) ) { try { processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { } } ) ; } catch ( Exception e ) { LOG . error ( "Seda queue caught: " + e , e ) ; } } else { LOG . warn ( "This consumer is stopped during polling an exchange, so putting it back on the seda queue: " + exchange ) ; try { queue . put ( exchange ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Interupted: " + e , e ) ; } } } } } } protected void doStart ( ) throws Exception { thread = new Thread ( this , getThreadName ( endpoint . getEndpointUri ( ) ) ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { thread . join ( ) ; thread = null ; } } 	1	['6', '2', '0', '11', '29', '0', '2', '11', '3', '0.7', '152', '1', '2', '0.777777778', '0.466666667', '1', '2', '23.66666667', '4', '1.1667', '1']
package org . apache . camel . component ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import org . apache . camel . Component ; import org . apache . camel . Processor ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . DefaultResourceLoader ; import org . springframework . core . io . Resource ; import org . springframework . core . io . ResourceLoader ; public abstract class ResourceBasedEndpoint extends ProcessorEndpoint { protected final transient Log log = LogFactory . getLog ( getClass ( ) ) ; private final String resourceUri ; private ResourceLoader resourceLoader = new DefaultResourceLoader ( ) ; private Resource resource ; private boolean contentCache ; private byte [ ] buffer ; public ResourceBasedEndpoint ( String endpointUri , Component component , String resourceUri , Processor processor ) { super ( endpointUri , component , processor ) ; this . resourceUri = resourceUri ; } protected ResourceBasedEndpoint ( String endpointUri , Processor processor , String resourceUri ) { super ( endpointUri , processor ) ; this . resourceUri = resourceUri ; } public Resource getResource ( ) { if ( resource == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Loading resource: " + resourceUri + " using: " + getResourceLoader ( ) ) ; } resource = getResourceLoader ( ) . getResource ( resourceUri ) ; if ( resource == null ) { throw new IllegalArgumentException ( "Could not find resource for URI: " + resourceUri + " using: " + getResourceLoader ( ) ) ; } } return resource ; } public boolean isContentCache ( ) { return contentCache ; } public void setContentCache ( boolean contentCache ) { this . contentCache = contentCache ; } public InputStream getResourceAsInputStream ( ) throws IOException { if ( resource == null ) { resource = getResource ( ) ; } if ( contentCache ) { synchronized ( resource ) { if ( buffer == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Reading resource: " + resourceUri + " into the content cache" ) ; } buffer = IOConverter . toBytes ( resource . getInputStream ( ) ) ; } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Using resource: " + resourceUri + " from the content cache" ) ; } return new ByteArrayInputStream ( buffer ) ; } return resource . getInputStream ( ) ; } public ResourceLoader getResourceLoader ( ) { return resourceLoader ; } public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } public String getResourceUri ( ) { return resourceUri ; } } 	0	['9', '5', '3', '12', '25', '0', '3', '9', '8', '0.6875', '202', '1', '0', '0.833333333', '0.296296296', '0', '0', '20.77777778', '4', '1.1111', '0']
package org . apache . camel . spi ; public interface Registry { < T > T lookup ( String name , Class < T > type ) ; Object lookup ( String name ) ; } 	1	['2', '1', '0', '22', '2', '1', '22', '0', '2', '2', '2', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '1']
package org . apache . camel . converter . jaxb ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBElement ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import javax . xml . bind . Unmarshaller ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . IOHelper ; public class JaxbDataFormat implements DataFormat { private JAXBContext context ; private String contextPath ; private boolean prettyPrint = true ; private boolean ignoreJAXBElement = true ; private Marshaller marshaller ; private Unmarshaller unmarshaller ; public JaxbDataFormat ( ) { } public JaxbDataFormat ( JAXBContext context ) { this . context = context ; } public JaxbDataFormat ( String contextPath ) { this . contextPath = contextPath ; } public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { try { getMarshaller ( ) . marshal ( graph , stream ) ; } catch ( JAXBException e ) { throw IOHelper . createIOException ( e ) ; } } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { try { Object answer = getUnmarshaller ( ) . unmarshal ( stream ) ; if ( answer instanceof JAXBElement && isIgnoreJAXBElement ( ) ) { answer = ( ( JAXBElement ) answer ) . getValue ( ) ; } return answer ; } catch ( JAXBException e ) { throw IOHelper . createIOException ( e ) ; } } public boolean isIgnoreJAXBElement ( ) { return ignoreJAXBElement ; } public void setIgnoreJAXBElement ( boolean flag ) { ignoreJAXBElement = flag ; } public JAXBContext getContext ( ) throws JAXBException { if ( context == null ) { context = createContext ( ) ; } return context ; } public void setContext ( JAXBContext context ) { this . context = context ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public Marshaller getMarshaller ( ) throws JAXBException { if ( marshaller == null ) { marshaller = getContext ( ) . createMarshaller ( ) ; } return marshaller ; } public void setMarshaller ( Marshaller marshaller ) { this . marshaller = marshaller ; } public boolean isPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } public Unmarshaller getUnmarshaller ( ) throws JAXBException { if ( unmarshaller == null ) { unmarshaller = getContext ( ) . createUnmarshaller ( ) ; } return unmarshaller ; } public void setUnmarshaller ( Unmarshaller unmarshaller ) { this . unmarshaller = unmarshaller ; } protected JAXBContext createContext ( ) throws JAXBException { if ( contextPath != null ) { return JAXBContext . newInstance ( contextPath ) ; } else { return JAXBContext . newInstance ( ) ; } } } 	0	['18', '1', '0', '3', '27', '97', '0', '3', '17', '0.774509804', '165', '1', '0', '0', '0.172222222', '0', '0', '7.833333333', '1', '0.8333', '0']
package org . apache . camel . impl ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . TimeUnit ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . processor . Logger ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class EventDrivenPollingConsumer < E extends Exchange > extends PollingConsumerSupport < E > implements Processor { private static final transient Log LOG = LogFactory . getLog ( EventDrivenPollingConsumer . class ) ; private BlockingQueue < E > queue ; private ExceptionHandler interuptedExceptionHandler = new LoggingExceptionHandler ( new Logger ( LOG ) ) ; private Consumer < E > consumer ; public EventDrivenPollingConsumer ( Endpoint < E > endpoint ) { this ( endpoint , new ArrayBlockingQueue < E > ( 1000 ) ) ; } public EventDrivenPollingConsumer ( Endpoint < E > endpoint , BlockingQueue < E > queue ) { super ( endpoint ) ; this . queue = queue ; } public E receiveNoWait ( ) { return receive ( 0 ) ; } public E receive ( ) { while ( isRunAllowed ( ) ) { try { return queue . take ( ) ; } catch ( InterruptedException e ) { handleInteruptedException ( e ) ; } } LOG . debug ( "Consumer is not running, so returning null" ) ; return null ; } public E receive ( long timeout ) { try { return queue . poll ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { handleInteruptedException ( e ) ; return null ; } } public void process ( Exchange exchange ) throws Exception { queue . offer ( ( E ) exchange ) ; } public ExceptionHandler getInteruptedExceptionHandler ( ) { return interuptedExceptionHandler ; } public void setInteruptedExceptionHandler ( ExceptionHandler interuptedExceptionHandler ) { this . interuptedExceptionHandler = interuptedExceptionHandler ; } protected void handleInteruptedException ( InterruptedException e ) { getInteruptedExceptionHandler ( ) . handleException ( e ) ; } protected void doStart ( ) throws Exception { consumer = getEndpoint ( ) . createConsumer ( this ) ; consumer . start ( ) ; } protected void doStop ( ) throws Exception { if ( consumer != null ) { try { consumer . stop ( ) ; } finally { consumer = null ; } } } } 	1	['12', '3', '0', '12', '27', '42', '2', '10', '8', '0.704545455', '124', '1', '2', '0.678571429', '0.233766234', '1', '1', '9', '2', '0.8333', '1']
package org . apache . camel . component . jcr ; import javax . jcr . LoginException ; import javax . jcr . Node ; import javax . jcr . RepositoryException ; import javax . jcr . Session ; import javax . jcr . Value ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; public class JcrProducer extends DefaultProducer < DefaultExchange > { public JcrProducer ( JcrEndpoint jcrEndpoint ) throws LoginException , RepositoryException { super ( jcrEndpoint ) ; } public void process ( Exchange exchange ) throws Exception { Session session = openSession ( ) ; try { Node base = getBaseNode ( session ) ; Node node = base . addNode ( getNodeName ( exchange ) ) ; TypeConverter converter = exchange . getContext ( ) . getTypeConverter ( ) ; for ( String key : exchange . getProperties ( ) . keySet ( ) ) { Value value = converter . convertTo ( Value . class , exchange , exchange . getProperty ( key ) ) ; node . setProperty ( key , value ) ; } node . addMixin ( "mix:referenceable" ) ; session . save ( ) ; exchange . getOut ( ) . setBody ( node . getUUID ( ) ) ; } finally { if ( session != null && session . isLive ( ) ) { session . logout ( ) ; } } } private String getNodeName ( Exchange exchange ) { if ( exchange . getProperty ( JcrComponent . NODE_NAME ) != null ) { return exchange . getProperty ( JcrComponent . NODE_NAME ) . toString ( ) ; } return exchange . getExchangeId ( ) ; } private Node getBaseNode ( Session session ) throws Exception { Node baseNode = session . getRootNode ( ) ; for ( String node : getJcrEndpoint ( ) . getBase ( ) . split ( "/" ) ) { baseNode = baseNode . addNode ( node ) ; } return baseNode ; } protected Session openSession ( ) throws LoginException , RepositoryException { return getJcrEndpoint ( ) . getRepository ( ) . login ( getJcrEndpoint ( ) . getCredentials ( ) ) ; } private JcrEndpoint getJcrEndpoint ( ) { JcrEndpoint endpoint = ( JcrEndpoint ) getEndpoint ( ) ; return endpoint ; } } 	0	['6', '3', '0', '7', '34', '15', '1', '7', '2', '2', '138', '0', '0', '0.807692308', '0.416666667', '0', '0', '22', '2', '1', '0']
package org . apache . camel . builder ; import java . util . List ; import org . apache . camel . Processor ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . spi . RouteContext ; public interface ErrorHandlerBuilder { ErrorHandlerBuilder copy ( ) ; Processor createErrorHandler ( RouteContext routeContext , Processor processor ) throws Exception ; void addErrorHandlers ( ExceptionType exception ) ; void setErrorHandlers ( List < ExceptionType > exceptions ) ; } 	1	['4', '1', '0', '22', '4', '6', '20', '3', '4', '2', '4', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '1']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "header" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class StringHeader extends HeaderType { @ XmlAttribute ( name = "value" , required = true ) private String text ; public StringHeader ( ) { } public StringHeader ( String name , String text ) { super ( name ) ; this . text = text ; } public String getText ( ) { return text ; } public void setText ( String text ) { this . text = text ; } public Object getValue ( ) { return getText ( ) ; } public void setValue ( Object value ) { if ( value instanceof String ) { setText ( ( String ) value ) ; } else { throw new IllegalArgumentException ( "Value must be a String" ) ; } } } 	0	['6', '2', '0', '2', '9', '9', '1', '1', '6', '0.2', '41', '1', '0', '0.5', '0.5', '0', '0', '5.666666667', '2', '0.8333', '0']
package org . apache . camel . impl ; import java . util . Collection ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Route ; import org . apache . camel . Service ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . RouteContext ; public class DelegateLifecycleStrategy implements LifecycleStrategy { private final LifecycleStrategy delegate ; public DelegateLifecycleStrategy ( LifecycleStrategy delegate ) { this . delegate = delegate ; } public void onContextStart ( CamelContext context ) { delegate . onContextStart ( context ) ; } public void onEndpointAdd ( Endpoint < ? extends Exchange > endpoint ) { delegate . onEndpointAdd ( endpoint ) ; } public void onRouteContextCreate ( RouteContext routeContext ) { delegate . onRouteContextCreate ( routeContext ) ; } public void onRoutesAdd ( Collection < Route > routes ) { delegate . onRoutesAdd ( routes ) ; } public void onServiceAdd ( CamelContext context , Service service ) { delegate . onServiceAdd ( context , service ) ; } } 	1	['6', '1', '1', '6', '12', '0', '1', '5', '6', '0', '39', '1', '1', '0', '0.30952381', '0', '0', '5.333333333', '1', '0.8333', '1']
package org . apache . camel . component . cxf . interceptors ; import java . util . List ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import org . w3c . dom . Element ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . staxutils . StaxUtils ; public class PayloadContentRedirectInterceptor extends AbstractPhaseInterceptor < Message > { public PayloadContentRedirectInterceptor ( ) { super ( Phase . POST_STREAM ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message message ) throws Fault { Throwable ex = message . getContent ( Throwable . class ) ; if ( ex != null ) { if ( ex instanceof Fault ) { throw ( Fault ) ex ; } else { throw new Fault ( ex ) ; } } XMLStreamWriter out = message . getContent ( XMLStreamWriter . class ) ; List < Element > in = message . get ( List . class ) ; try { for ( Element el : in ) { StaxUtils . writeElement ( el , out , false , true ) ; } } catch ( XMLStreamException e ) { throw new Fault ( e ) ; } } } 	0	['2', '0', '0', '5', '10', '1', '1', '4', '2', '2', '58', '0', '0', '0', '0.75', '0', '0', '28', '1', '0.5', '0']
package org . apache . camel . impl ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . processor . Logger ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . commons . logging . LogFactory ; public class LoggingExceptionHandler implements ExceptionHandler { private final Logger logger ; public LoggingExceptionHandler ( Class ownerType ) { this ( new Logger ( LogFactory . getLog ( ownerType ) , LoggingLevel . ERROR ) ) ; } public LoggingExceptionHandler ( Logger logger ) { this . logger = logger ; } public void handleException ( Throwable exception ) { logger . log ( exception . getMessage ( ) , exception ) ; } } 	1	['3', '1', '0', '10', '8', '1', '5', '5', '3', '0', '26', '1', '1', '0', '0.5', '0', '0', '7.333333333', '1', '0.3333', '1']
package org . apache . camel . bam ; import java . util . Date ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . TemporalRule ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . equal ; public abstract class TimeExpression { private ActivityRules activityRules ; private ActivityBuilder builder ; private ActivityLifecycle lifecycle ; public TimeExpression ( ActivityBuilder builder , ActivityLifecycle lifecycle ) { this . lifecycle = lifecycle ; this . builder = builder ; this . activityRules = builder . getActivityRules ( ) ; } public boolean isActivityLifecycle ( ActivityRules activityRules , ActivityLifecycle lifecycle ) { return equal ( activityRules , this . activityRules ) && equal ( lifecycle , this . lifecycle ) ; } public TemporalRule after ( TimeExpression expression ) { TemporalRule rule = new TemporalRule ( expression , this ) ; rule . getSecond ( ) . getActivityRules ( ) . addRule ( rule ) ; return rule ; } public Date evaluate ( ProcessInstance processInstance ) { ActivityState state = processInstance . getActivityState ( activityRules ) ; if ( state != null ) { return evaluate ( processInstance , state ) ; } return null ; } public abstract Date evaluate ( ProcessInstance instance , ActivityState state ) ; public ActivityBuilder getBuilder ( ) { return builder ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public ActivityLifecycle getLifecycle ( ) { return lifecycle ; } public ActivityState getActivityState ( ProcessInstance instance ) { return instance . getActivityState ( activityRules ) ; } public ActivityState getOrCreateActivityState ( ProcessInstance instance ) { return instance . getOrCreateActivityState ( activityRules ) ; } } 	0	['10', '1', '2', '9', '18', '9', '4', '7', '10', '0.666666667', '86', '1', '3', '0', '0.285714286', '0', '0', '7.3', '3', '1.2', '0']
package org . apache . camel . builder ; import java . util . List ; import org . apache . camel . Processor ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; public class ErrorHandlerBuilderRef extends ErrorHandlerBuilderSupport { private final String ref ; private ErrorHandlerBuilder handler ; public ErrorHandlerBuilderRef ( String ref ) { this . ref = ref ; } public ErrorHandlerBuilder copy ( ) { return new ErrorHandlerBuilderRef ( ref ) ; } @ Override public void addErrorHandlers ( ExceptionType exception ) { if ( handler != null ) { handler . addErrorHandlers ( exception ) ; } super . addErrorHandlers ( exception ) ; } public Processor createErrorHandler ( RouteContext routeContext , Processor processor ) throws Exception { if ( handler == null ) { handler = routeContext . lookup ( ref , ErrorHandlerBuilder . class ) ; ObjectHelper . notNull ( handler , "error handler '" + ref + "'" ) ; List < ExceptionType > list = getExceptions ( ) ; for ( ExceptionType exceptionType : list ) { handler . addErrorHandlers ( exceptionType ) ; } } return handler . createErrorHandler ( routeContext , processor ) ; } } 	1	['4', '2', '0', '7', '17', '0', '1', '6', '4', '0.5', '78', '1', '1', '0.571428571', '0.4', '0', '0', '18', '2', '1', '3']
package org . apache . camel . component . log ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . ThroughputLogger ; import org . apache . camel . util . IntrospectionSupport ; public class LogComponent extends DefaultComponent < Exchange > { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { LoggingLevel level = getLoggingLevel ( parameters ) ; Integer groupSize = getAndRemoveParameter ( parameters , "groupSize" , Integer . class ) ; Logger logger ; if ( groupSize != null ) { logger = new ThroughputLogger ( remaining , level , ObjectConverter . toInteger ( groupSize ) ) ; } else { LogFormatter formatter = new LogFormatter ( ) ; IntrospectionSupport . setProperties ( formatter , parameters ) ; logger = new Logger ( remaining ) ; logger . setLevel ( level ) ; logger . setFormatter ( formatter ) ; } return new ProcessorEndpoint ( uri , this , logger ) ; } protected LoggingLevel getLoggingLevel ( Map parameters ) { String levelText = getAndRemoveParameter ( parameters , "level" , String . class , "INFO" ) ; return LoggingLevel . valueOf ( levelText . toUpperCase ( ) ) ; } } 	0	['3', '3', '0', '12', '17', '3', '0', '12', '1', '2', '67', '0', '0', '0.945945946', '0.666666667', '1', '3', '21.33333333', '1', '0.6667', '0']
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . processor . SendProcessor ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class BuilderSupport { private CamelContext context ; private ErrorHandlerBuilder errorHandlerBuilder ; private boolean inheritErrorHandler = true ; protected BuilderSupport ( CamelContext context ) { this . context = context ; } protected BuilderSupport ( BuilderSupport parent ) { this . context = parent . getContext ( ) ; this . inheritErrorHandler = parent . inheritErrorHandler ; if ( inheritErrorHandler && parent . errorHandlerBuilder != null ) { this . errorHandlerBuilder = parent . errorHandlerBuilder . copy ( ) ; } } public ValueBuilder header ( String name ) { return Builder . header ( name ) ; } public ValueBuilder body ( ) { return Builder . body ( ) ; } public < T > ValueBuilder body ( Class < T > type ) { return Builder . bodyAs ( type ) ; } public ValueBuilder outBody ( ) { return Builder . outBody ( ) ; } public < T > ValueBuilder outBody ( Class < T > type ) { return Builder . outBodyAs ( type ) ; } public ValueBuilder faultBody ( ) { return Builder . faultBody ( ) ; } public < T > ValueBuilder faultBodyAs ( Class < T > type ) { return Builder . faultBodyAs ( type ) ; } public ValueBuilder systemProperty ( String name ) { return Builder . systemProperty ( name ) ; } public ValueBuilder systemProperty ( String name , String defaultValue ) { return Builder . systemProperty ( name , defaultValue ) ; } public ValueBuilder constant ( Object value ) { return Builder . constant ( value ) ; } public Endpoint endpoint ( String uri ) throws NoSuchEndpointException { ObjectHelper . notNull ( uri , "uri" ) ; Endpoint endpoint = getContext ( ) . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } public < T extends Endpoint > T endpoint ( String uri , Class < T > type ) throws NoSuchEndpointException { ObjectHelper . notNull ( uri , "uri" ) ; T endpoint = getContext ( ) . getEndpoint ( uri , type ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } public List < Endpoint > endpoints ( String ... uris ) throws NoSuchEndpointException { List < Endpoint > endpoints = new ArrayList < Endpoint > ( ) ; for ( String uri : uris ) { endpoints . add ( endpoint ( uri ) ) ; } return endpoints ; } public List < Endpoint > endpoints ( Endpoint ... endpoints ) { List < Endpoint > answer = new ArrayList < Endpoint > ( ) ; answer . addAll ( Arrays . asList ( endpoints ) ) ; return answer ; } public NoErrorHandlerBuilder noErrorHandler ( ) { return new NoErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( ) { return new LoggingErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( String log ) { return loggingErrorHandler ( LogFactory . getLog ( log ) ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log ) { return new LoggingErrorHandlerBuilder ( log ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log , LoggingLevel level ) { return new LoggingErrorHandlerBuilder ( log , level ) ; } public DeadLetterChannelBuilder deadLetterChannel ( ) { return new DeadLetterChannelBuilder ( ) ; } public DeadLetterChannelBuilder deadLetterChannel ( String deadLetterUri ) { return deadLetterChannel ( endpoint ( deadLetterUri ) ) ; } public DeadLetterChannelBuilder deadLetterChannel ( Endpoint deadLetterEndpoint ) { return new DeadLetterChannelBuilder ( new SendProcessor ( deadLetterEndpoint ) ) ; } public CamelContext getContext ( ) { return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } public boolean isInheritErrorHandler ( ) { return inheritErrorHandler ; } public void setInheritErrorHandler ( boolean inheritErrorHandler ) { this . inheritErrorHandler = inheritErrorHandler ; } } 	1	['31', '1', '1', '16', '59', '437', '1', '15', '28', '0.855555556', '251', '1', '2', '0', '0.133995037', '0', '0', '7', '2', '1', '6']
package org . apache . camel . spring . spi ; import org . apache . camel . spi . Injector ; import org . springframework . beans . factory . config . AutowireCapableBeanFactory ; import org . springframework . context . ConfigurableApplicationContext ; public class SpringInjector implements Injector { private final ConfigurableApplicationContext applicationContext ; private int autowireMode = AutowireCapableBeanFactory . AUTOWIRE_CONSTRUCTOR ; private boolean dependencyCheck ; public SpringInjector ( ConfigurableApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public < T > T newInstance ( Class < T > type ) { Object value = applicationContext . getBeanFactory ( ) . createBean ( type , autowireMode , dependencyCheck ) ; return type . cast ( value ) ; } public int getAutowireMode ( ) { return autowireMode ; } public void setAutowireMode ( int autowireMode ) { this . autowireMode = autowireMode ; } public boolean isDependencyCheck ( ) { return dependencyCheck ; } public void setDependencyCheck ( boolean dependencyCheck ) { this . dependencyCheck = dependencyCheck ; } } 	0	['6', '1', '0', '4', '10', '0', '1', '3', '6', '0.6', '46', '1', '0', '0', '0.333333333', '0', '0', '6.166666667', '1', '0.8333', '0']
package org . apache . camel . spi ; import org . apache . camel . Exchange ; public interface UnitOfWork { void addSynchronization ( Synchronization synchronization ) ; void removeSynchronization ( Synchronization synchronization ) ; void done ( Exchange exchange ) ; String getId ( ) ; } 	1	['4', '1', '0', '7', '4', '6', '6', '2', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '3']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "xmlBeans" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class XMLBeansDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private Boolean prettyPrint ; public XMLBeansDataFormat ( ) { super ( "org.apache.camel.converter.xmlbeans.XmlBeansDataFormat" ) ; } public Boolean getPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( Boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } } 	0	['3', '3', '0', '2', '4', '1', '1', '1', '3', '0.5', '15', '1', '0', '0.818181818', '0.666666667', '0', '0', '3.666666667', '1', '0.6667', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . Collection ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . Service ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ServiceHelper ; public abstract class ServiceSupport implements Service { private static int threadCounter ; private AtomicBoolean started = new AtomicBoolean ( false ) ; private AtomicBoolean starting = new AtomicBoolean ( false ) ; private AtomicBoolean stopping = new AtomicBoolean ( false ) ; private AtomicBoolean stopped = new AtomicBoolean ( false ) ; private Collection childServices ; private String version ; public void start ( ) throws Exception { if ( started . compareAndSet ( false , true ) ) { starting . set ( true ) ; try { if ( childServices != null ) { ServiceHelper . startServices ( childServices ) ; } doStart ( ) ; } finally { starting . set ( false ) ; } } } public void stop ( ) throws Exception { if ( started . get ( ) && stopping . compareAndSet ( false , true ) ) { try { doStop ( ) ; } finally { if ( childServices != null ) { ServiceHelper . stopServices ( childServices ) ; } stopped . set ( true ) ; started . set ( false ) ; stopping . set ( false ) ; } } } public boolean isStarted ( ) { return started . get ( ) ; } public boolean isStarting ( ) { return starting . get ( ) ; } public boolean isStopping ( ) { return stopping . get ( ) ; } protected boolean isRunAllowed ( ) { return ! ( stopping . get ( ) || stopped . get ( ) ) ; } public boolean isStopped ( ) { return stopped . get ( ) ; } protected abstract void doStart ( ) throws Exception ; protected abstract void doStop ( ) throws Exception ; protected String getThreadName ( String prefix ) { return prefix + " thread:" + nextThreadCounter ( ) ; } protected static synchronized int nextThreadCounter ( ) { return ++ threadCounter ; } protected void addChildService ( Object childService ) { if ( childServices == null ) { childServices = new ArrayList ( ) ; } childServices . add ( childService ) ; } protected boolean removeChildService ( Object childService ) { if ( childServices != null ) { return childServices . remove ( childService ) ; } else { return false ; } } protected synchronized String getVersion ( ) { if ( ObjectHelper . isNotNullAndNonEmpty ( version ) ) { return version ; } Package aPackage = getClass ( ) . getPackage ( ) ; if ( aPackage != null ) { version = aPackage . getImplementationVersion ( ) ; if ( version == null ) { version = aPackage . getSpecificationVersion ( ) ; if ( version == null ) { version = "" ; } } } else { version = "" ; } return version ; } } 	1	['15', '1', '32', '37', '34', '63', '34', '3', '7', '0.846938776', '239', '1', '0', '0', '0.377777778', '0', '0', '14.46666667', '5', '1.4667', '4']
package org . apache . camel . processor . aggregate ; import java . util . Collection ; import java . util . Iterator ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public interface AggregationCollection extends Collection < Exchange > { Expression < Exchange > getCorrelationExpression ( ) ; void setCorrelationExpression ( Expression < Exchange > correlationExpression ) ; AggregationStrategy getAggregationStrategy ( ) ; void setAggregationStrategy ( AggregationStrategy aggregationStrategy ) ; boolean add ( Exchange exchange ) ; Iterator < Exchange > iterator ( ) ; int size ( ) ; void clear ( ) ; void onAggregation ( Object correlationKey , Exchange newExchange ) ; } 	0	['9', '1', '0', '7', '9', '36', '4', '3', '9', '2', '9', '0', '0', '0', '0.311111111', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . converter . AnnotationTypeConverterLoader ; import org . apache . camel . impl . converter . TypeConverterRegistry ; import org . apache . camel . util . ObjectHelper ; public class ReportingTypeConverterLoader extends AnnotationTypeConverterLoader { private static final Comparator < TypeMapping > COMPARE_LAST_LOADED_FIRST = new Comparator < TypeMapping > ( ) { public int compare ( TypeMapping t1 , TypeMapping t2 ) { if ( ObjectHelper . equal ( t1 . fromType , t2 . fromType ) ) { return ObjectHelper . equal ( t1 . toType , t2 . toType ) ? t1 . index - t2 . index : ObjectHelper . compare ( getTypeName ( t1 . toType ) , getTypeName ( t2 . toType ) ) ; } return ObjectHelper . compare ( getTypeName ( t1 . fromType ) , getTypeName ( t2 . fromType ) ) ; } } ; private List < TypeMapping > typeMappings = new ArrayList < TypeMapping > ( ) ; public TypeMapping [ ] getTypeConversions ( ) { Collections . sort ( typeMappings , COMPARE_LAST_LOADED_FIRST ) ; return typeMappings . toArray ( new TypeMapping [ typeMappings . size ( ) ] ) ; } protected void registerTypeConverter ( TypeConverterRegistry registry , Method method , Class toType , Class fromType , TypeConverter typeConverter ) { TypeMapping mapping = new TypeMapping ( toType , fromType , typeConverter . getClass ( ) , method ) ; typeMappings . add ( mapping ) ; } private static String getTypeName ( Class type ) { return type != null ? type . getName ( ) : null ; } public static class TypeMapping { private static int counter ; private Class toType ; private Class fromType ; private Class converterType ; private Method method ; private int index ; public TypeMapping ( Class toType , Class fromType , Class converterType , Method method ) { this . toType = toType ; this . fromType = fromType ; this . converterType = converterType ; this . method = method ; this . index = counter ++ ; } public Class getFromType ( ) { return fromType ; } public Class getToType ( ) { return toType ; } public Class getConverterType ( ) { return converterType ; } public Method getMethod ( ) { return method ; } public int getIndex ( ) { return index ; } @ Override public boolean equals ( Object object ) { if ( object instanceof TypeMapping ) { TypeMapping that = ( TypeMapping ) object ; return this . index == that . index ; } return false ; } @ Override public int hashCode ( ) { int answer = toType . hashCode ( ) ; if ( fromType != null ) { answer *= 37 + fromType . hashCode ( ) ; } return answer ; } @ Override public String toString ( ) { return "[" + fromType . getSimpleName ( ) + "=>" + toType . getSimpleName ( ) + "]" ; } } } 	1	['6', '2', '0', '5', '16', '7', '1', '5', '2', '0.7', '59', '1', '0', '0.636363636', '0.36', '1', '1', '8.5', '2', '0.8333', '1']
package org . apache . camel . component . jms ; import javax . jms . ConnectionFactory ; import javax . jms . Destination ; import javax . jms . ExceptionListener ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . MessageProducer ; import javax . jms . QueueSender ; import javax . jms . Session ; import javax . jms . TopicPublisher ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . PackageHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . JmsException ; import org . springframework . jms . connection . JmsResourceHolder ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . core . JmsTemplate102 ; import org . springframework . jms . core . MessageCreator ; import org . springframework . jms . core . SessionCallback ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer102 ; import org . springframework . jms . listener . SimpleMessageListenerContainer ; import org . springframework . jms . listener . SimpleMessageListenerContainer102 ; import org . springframework . jms . listener . serversession . ServerSessionFactory ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer102 ; import org . springframework . jms . support . JmsUtils ; import org . springframework . jms . support . converter . MessageConverter ; import org . springframework . jms . support . destination . DestinationResolver ; import org . springframework . transaction . PlatformTransactionManager ; import org . springframework . util . Assert ; import static org . apache . camel . util . ObjectHelper . removeStartingCharacters ; public class JmsConfiguration implements Cloneable { public static final String QUEUE_PREFIX = "queue:" ; public static final String TOPIC_PREFIX = "topic:" ; public static final String TEMP_QUEUE_PREFIX = "temp:queue:" ; public static final String TEMP_TOPIC_PREFIX = "temp:topic:" ; protected static final String TRANSACTED = "TRANSACTED" ; protected static final String CLIENT_ACKNOWLEDGE = "CLIENT_ACKNOWLEDGE" ; protected static final String AUTO_ACKNOWLEDGE = "AUTO_ACKNOWLEDGE" ; protected static final String DUPS_OK_ACKNOWLEDGE = "DUPS_OK_ACKNOWLEDGE" ; protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_COMPONENT = "component" ; protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT = "endpoint" ; protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_PRODUCER = "producer" ; private static final transient Log LOG = LogFactory . getLog ( JmsConfiguration . class ) ; private JmsOperations jmsOperations ; private DestinationResolver destinationResolver ; private ConnectionFactory connectionFactory ; private ConnectionFactory templateConnectionFactory ; private ConnectionFactory listenerConnectionFactory ; private int acknowledgementMode = - 1 ; private String acknowledgementModeName ; private ExceptionListener exceptionListener ; private ConsumerType consumerType = ConsumerType . Default ; private boolean autoStartup = true ; private boolean acceptMessagesWhileStopping ; private String clientId ; private String durableSubscriptionName ; private boolean subscriptionDurable ; private boolean exposeListenerSession = true ; private TaskExecutor taskExecutor ; private boolean pubSubNoLocal ; private int concurrentConsumers = 1 ; private int maxMessagesPerTask = 1 ; private ServerSessionFactory serverSessionFactory ; private int cacheLevel = - 1 ; private String cacheLevelName ; private long recoveryInterval = - 1 ; private long receiveTimeout = - 1 ; private long requestTimeout = 20000L ; private int idleTaskExecutionLimit = 1 ; private int maxConcurrentConsumers = 1 ; private boolean useVersion102 ; private Boolean explicitQosEnabled ; private boolean deliveryPersistent = true ; private boolean replyToDeliveryPersistent = true ; private long timeToLive = - 1 ; private MessageConverter messageConverter ; private boolean messageIdEnabled = true ; private boolean messageTimestampEnabled = true ; private int priority = - 1 ; private boolean transacted ; private boolean transactedInOut ; private PlatformTransactionManager transactionManager ; private String transactionName ; private int transactionTimeout = - 1 ; private boolean preserveMessageQos ; private long requestMapPurgePollTimeMillis = 1000L ; private boolean disableReplyTo ; private boolean eagerLoadingOfProperties ; private boolean alwaysCopyMessage ; private boolean useMessageIDAsCorrelationID ; private JmsProviderMetadata providerMetadata = new JmsProviderMetadata ( ) ; private JmsOperations metadataJmsOperations ; private String replyToTempDestinationAffinity = REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT ; private String replyToDestination ; private String replyToDestinationSelectorName ; public JmsConfiguration ( ) { } public JmsConfiguration ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public JmsConfiguration copy ( ) { try { return ( JmsConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public static interface MessageSentCallback { void sent ( Message message ) ; } public static class CamelJmsTemplate extends JmsTemplate { private JmsConfiguration config ; public CamelJmsTemplate ( JmsConfiguration config , ConnectionFactory connectionFactory ) { super ( connectionFactory ) ; this . config = config ; } public void send ( final String destinationName , final MessageCreator messageCreator , final MessageSentCallback callback ) throws JmsException { execute ( new SessionCallback ( ) { public Object doInJms ( Session session ) throws JMSException { Destination destination = resolveDestinationName ( session , destinationName ) ; Assert . notNull ( messageCreator , "MessageCreator must not be null" ) ; MessageProducer producer = createProducer ( session , destination ) ; Message message = null ; try { message = messageCreator . createMessage ( session ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Sending created message: " + message ) ; } doSend ( producer , message ) ; if ( session . getTransacted ( ) && isSessionLocallyTransacted ( session ) ) { JmsUtils . commitIfNecessary ( session ) ; } } finally { JmsUtils . closeMessageProducer ( producer ) ; } if ( message != null && callback != null ) { callback . sent ( message ) ; } return null ; } } , false ) ; } @ Override protected void doSend ( MessageProducer producer , Message message ) throws JMSException { if ( config . isPreserveMessageQos ( ) ) { long ttl = message . getJMSExpiration ( ) ; if ( ttl != 0 ) { ttl = ttl - System . currentTimeMillis ( ) ; if ( ttl <= 0 ) { ttl = 1 ; } } producer . send ( message , message . getJMSDeliveryMode ( ) , message . getJMSPriority ( ) , ttl ) ; } else { super . doSend ( producer , message ) ; } } } public static class CamelJmsTeemplate102 extends JmsTemplate102 { private JmsConfiguration config ; public CamelJmsTeemplate102 ( JmsConfiguration config , ConnectionFactory connectionFactory , boolean pubSubDomain ) { super ( connectionFactory , pubSubDomain ) ; this . config = config ; } public void send ( final String destinationName , final MessageCreator messageCreator , final MessageSentCallback callback ) throws JmsException { execute ( new SessionCallback ( ) { public Object doInJms ( Session session ) throws JMSException { Destination destination = resolveDestinationName ( session , destinationName ) ; Assert . notNull ( messageCreator , "MessageCreator must not be null" ) ; MessageProducer producer = createProducer ( session , destination ) ; Message message = null ; try { message = messageCreator . createMessage ( session ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Sending created message: " + message ) ; } doSend ( producer , message ) ; if ( session . getTransacted ( ) && isSessionLocallyTransacted ( session ) ) { JmsUtils . commitIfNecessary ( session ) ; } } finally { JmsUtils . closeMessageProducer ( producer ) ; } if ( message != null && callback != null ) { callback . sent ( message ) ; } return null ; } } , false ) ; } @ Override protected void doSend ( MessageProducer producer , Message message ) throws JMSException { if ( config . isPreserveMessageQos ( ) ) { long ttl = message . getJMSExpiration ( ) ; if ( ttl != 0 ) { ttl = ttl - System . currentTimeMillis ( ) ; if ( ttl <= 0 ) { ttl = 1 ; } } if ( isPubSubDomain ( ) ) { ( ( TopicPublisher ) producer ) . publish ( message , message . getJMSDeliveryMode ( ) , message . getJMSPriority ( ) , ttl ) ; } else { ( ( QueueSender ) producer ) . send ( message , message . getJMSDeliveryMode ( ) , message . getJMSPriority ( ) , ttl ) ; } } else { super . doSend ( producer , message ) ; } } } public JmsOperations createInOutTemplate ( JmsEndpoint endpoint , boolean pubSubDomain , String destination , long requestTimeout ) { JmsOperations answer = createInOnlyTemplate ( endpoint , pubSubDomain , destination ) ; if ( answer instanceof JmsTemplate && requestTimeout > 0 ) { JmsTemplate jmsTemplate = ( JmsTemplate ) answer ; jmsTemplate . setExplicitQosEnabled ( true ) ; jmsTemplate . setTimeToLive ( requestTimeout ) ; jmsTemplate . setSessionTransacted ( isTransactedInOut ( ) ) ; if ( isTransactedInOut ( ) ) { jmsTemplate . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( acknowledgementMode >= 0 ) { jmsTemplate . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { jmsTemplate . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } else { jmsTemplate . setSessionAcknowledgeMode ( Session . AUTO_ACKNOWLEDGE ) ; } } } return answer ; } public JmsOperations createInOnlyTemplate ( JmsEndpoint endpoint , boolean pubSubDomain , String destination ) { if ( jmsOperations != null ) { return jmsOperations ; } ConnectionFactory factory = getTemplateConnectionFactory ( ) ; JmsTemplate template = useVersion102 ? new CamelJmsTeemplate102 ( this , factory , pubSubDomain ) : new CamelJmsTemplate ( this , factory ) ; template . setPubSubDomain ( pubSubDomain ) ; if ( destinationResolver != null ) { template . setDestinationResolver ( destinationResolver ) ; if ( endpoint instanceof DestinationEndpoint ) { LOG . debug ( "You are overloading the destinationResolver property on a DestinationEndpoint; are you sure you want to do that?" ) ; } } else if ( endpoint instanceof DestinationEndpoint ) { DestinationEndpoint destinationEndpoint = ( DestinationEndpoint ) endpoint ; template . setDestinationResolver ( createDestinationResolver ( destinationEndpoint ) ) ; } template . setDefaultDestinationName ( destination ) ; template . setExplicitQosEnabled ( isExplicitQosEnabled ( ) ) ; template . setDeliveryPersistent ( deliveryPersistent ) ; if ( messageConverter != null ) { template . setMessageConverter ( messageConverter ) ; } template . setMessageIdEnabled ( messageIdEnabled ) ; template . setMessageTimestampEnabled ( messageTimestampEnabled ) ; if ( priority >= 0 ) { template . setPriority ( priority ) ; } template . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { template . setReceiveTimeout ( receiveTimeout ) ; } if ( timeToLive >= 0 ) { template . setTimeToLive ( timeToLive ) ; } template . setSessionTransacted ( transacted ) ; if ( transacted ) { template . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( acknowledgementMode >= 0 ) { template . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { template . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } } return template ; } public AbstractMessageListenerContainer createMessageListenerContainer ( JmsEndpoint endpoint ) { AbstractMessageListenerContainer container = chooseMessageListenerContainerImplementation ( ) ; configureMessageListenerContainer ( container , endpoint ) ; return container ; } public ConnectionFactory getConnectionFactory ( ) { if ( connectionFactory == null ) { connectionFactory = createConnectionFactory ( ) ; } return connectionFactory ; } public void setConnectionFactory ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public ConnectionFactory getListenerConnectionFactory ( ) { if ( listenerConnectionFactory == null ) { listenerConnectionFactory = createListenerConnectionFactory ( ) ; } return listenerConnectionFactory ; } public void setListenerConnectionFactory ( ConnectionFactory listenerConnectionFactory ) { this . listenerConnectionFactory = listenerConnectionFactory ; } public ConnectionFactory getTemplateConnectionFactory ( ) { if ( templateConnectionFactory == null ) { templateConnectionFactory = createTemplateConnectionFactory ( ) ; } return templateConnectionFactory ; } public void setTemplateConnectionFactory ( ConnectionFactory templateConnectionFactory ) { this . templateConnectionFactory = templateConnectionFactory ; } public boolean isUseVersion102 ( ) { return useVersion102 ; } public void setUseVersion102 ( boolean useVersion102 ) { this . useVersion102 = useVersion102 ; } public boolean isAutoStartup ( ) { return autoStartup ; } public void setAutoStartup ( boolean autoStartup ) { this . autoStartup = autoStartup ; } public boolean isAcceptMessagesWhileStopping ( ) { return acceptMessagesWhileStopping ; } public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { this . acceptMessagesWhileStopping = acceptMessagesWhileStopping ; } public String getClientId ( ) { return clientId ; } public void setClientId ( String consumerClientId ) { this . clientId = consumerClientId ; } public String getDurableSubscriptionName ( ) { return durableSubscriptionName ; } public void setDurableSubscriptionName ( String durableSubscriptionName ) { this . durableSubscriptionName = durableSubscriptionName ; } public ExceptionListener getExceptionListener ( ) { return exceptionListener ; } public void setExceptionListener ( ExceptionListener exceptionListener ) { this . exceptionListener = exceptionListener ; } public boolean isSubscriptionDurable ( ) { return subscriptionDurable ; } public void setSubscriptionDurable ( boolean subscriptionDurable ) { this . subscriptionDurable = subscriptionDurable ; } public String getAcknowledgementModeName ( ) { return acknowledgementModeName ; } public void setAcknowledgementModeName ( String consumerAcknowledgementMode ) { this . acknowledgementModeName = consumerAcknowledgementMode ; this . acknowledgementMode = - 1 ; } public boolean isExposeListenerSession ( ) { return exposeListenerSession ; } public void setExposeListenerSession ( boolean exposeListenerSession ) { this . exposeListenerSession = exposeListenerSession ; } public TaskExecutor getTaskExecutor ( ) { return taskExecutor ; } public void setTaskExecutor ( TaskExecutor taskExecutor ) { this . taskExecutor = taskExecutor ; } public boolean isPubSubNoLocal ( ) { return pubSubNoLocal ; } public void setPubSubNoLocal ( boolean pubSubNoLocal ) { this . pubSubNoLocal = pubSubNoLocal ; } public int getConcurrentConsumers ( ) { return concurrentConsumers ; } public void setConcurrentConsumers ( int concurrentConsumers ) { this . concurrentConsumers = concurrentConsumers ; } public int getMaxMessagesPerTask ( ) { return maxMessagesPerTask ; } public void setMaxMessagesPerTask ( int maxMessagesPerTask ) { this . maxMessagesPerTask = maxMessagesPerTask ; } public ServerSessionFactory getServerSessionFactory ( ) { return serverSessionFactory ; } public void setServerSessionFactory ( ServerSessionFactory serverSessionFactory ) { this . serverSessionFactory = serverSessionFactory ; } public int getCacheLevel ( ) { return cacheLevel ; } public void setCacheLevel ( int cacheLevel ) { this . cacheLevel = cacheLevel ; } public String getCacheLevelName ( ) { return cacheLevelName ; } public void setCacheLevelName ( String cacheName ) { this . cacheLevelName = cacheName ; } public long getRecoveryInterval ( ) { return recoveryInterval ; } public void setRecoveryInterval ( long recoveryInterval ) { this . recoveryInterval = recoveryInterval ; } public long getReceiveTimeout ( ) { return receiveTimeout ; } public void setReceiveTimeout ( long receiveTimeout ) { this . receiveTimeout = receiveTimeout ; } public PlatformTransactionManager getTransactionManager ( ) { return transactionManager ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { this . transactionManager = transactionManager ; } public String getTransactionName ( ) { return transactionName ; } public void setTransactionName ( String transactionName ) { this . transactionName = transactionName ; } public int getTransactionTimeout ( ) { return transactionTimeout ; } public void setTransactionTimeout ( int transactionTimeout ) { this . transactionTimeout = transactionTimeout ; } public int getIdleTaskExecutionLimit ( ) { return idleTaskExecutionLimit ; } public void setIdleTaskExecutionLimit ( int idleTaskExecutionLimit ) { this . idleTaskExecutionLimit = idleTaskExecutionLimit ; } public int getMaxConcurrentConsumers ( ) { return maxConcurrentConsumers ; } public void setMaxConcurrentConsumers ( int maxConcurrentConsumers ) { this . maxConcurrentConsumers = maxConcurrentConsumers ; } public boolean isExplicitQosEnabled ( ) { return explicitQosEnabled != null ? explicitQosEnabled : false ; } public void setExplicitQosEnabled ( boolean explicitQosEnabled ) { this . explicitQosEnabled = explicitQosEnabled ; } public boolean isDeliveryPersistent ( ) { return deliveryPersistent ; } public void setDeliveryPersistent ( boolean deliveryPersistent ) { this . deliveryPersistent = deliveryPersistent ; configuredQoS ( ) ; } public boolean isReplyToDeliveryPersistent ( ) { return replyToDeliveryPersistent ; } public void setReplyToDeliveryPersistent ( boolean replyToDeliveryPersistent ) { this . replyToDeliveryPersistent = replyToDeliveryPersistent ; } public long getTimeToLive ( ) { return timeToLive ; } public void setTimeToLive ( long timeToLive ) { this . timeToLive = timeToLive ; configuredQoS ( ) ; } public MessageConverter getMessageConverter ( ) { return messageConverter ; } public void setMessageConverter ( MessageConverter messageConverter ) { this . messageConverter = messageConverter ; } public boolean isMessageIdEnabled ( ) { return messageIdEnabled ; } public void setMessageIdEnabled ( boolean messageIdEnabled ) { this . messageIdEnabled = messageIdEnabled ; } public boolean isMessageTimestampEnabled ( ) { return messageTimestampEnabled ; } public void setMessageTimestampEnabled ( boolean messageTimestampEnabled ) { this . messageTimestampEnabled = messageTimestampEnabled ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; configuredQoS ( ) ; } public ConsumerType getConsumerType ( ) { return consumerType ; } public void setConsumerType ( ConsumerType consumerType ) { this . consumerType = consumerType ; } public int getAcknowledgementMode ( ) { return acknowledgementMode ; } public void setAcknowledgementMode ( int consumerAcknowledgementMode ) { this . acknowledgementMode = consumerAcknowledgementMode ; this . acknowledgementModeName = null ; } public boolean isTransacted ( ) { return transacted ; } public void setTransacted ( boolean consumerTransacted ) { this . transacted = consumerTransacted ; } public boolean isTransactedInOut ( ) { return transactedInOut ; } public void setTransactedInOut ( boolean transactedInOut ) { this . transactedInOut = transactedInOut ; } public boolean isEagerLoadingOfProperties ( ) { return eagerLoadingOfProperties ; } public void setEagerLoadingOfProperties ( boolean eagerLoadingOfProperties ) { this . eagerLoadingOfProperties = eagerLoadingOfProperties ; } public boolean isDisableReplyTo ( ) { return disableReplyTo ; } public void setDisableReplyTo ( boolean disableReplyTo ) { this . disableReplyTo = disableReplyTo ; } public void setPreserveMessageQos ( boolean preserveMessageQos ) { this . preserveMessageQos = preserveMessageQos ; } public JmsOperations getJmsOperations ( ) { return jmsOperations ; } public void setJmsOperations ( JmsOperations jmsOperations ) { this . jmsOperations = jmsOperations ; } public DestinationResolver getDestinationResolver ( ) { return destinationResolver ; } public void setDestinationResolver ( DestinationResolver destinationResolver ) { this . destinationResolver = destinationResolver ; } public long getRequestMapPurgePollTimeMillis ( ) { return requestMapPurgePollTimeMillis ; } public void setRequestMapPurgePollTimeMillis ( long requestMapPurgePollTimeMillis ) { this . requestMapPurgePollTimeMillis = requestMapPurgePollTimeMillis ; } public JmsProviderMetadata getProviderMetadata ( ) { return providerMetadata ; } public void setProviderMetadata ( JmsProviderMetadata providerMetadata ) { this . providerMetadata = providerMetadata ; } public JmsOperations getMetadataJmsOperations ( JmsEndpoint endpoint ) { if ( metadataJmsOperations == null ) { metadataJmsOperations = getJmsOperations ( ) ; if ( metadataJmsOperations == null ) { metadataJmsOperations = createInOnlyTemplate ( endpoint , false , null ) ; } } return metadataJmsOperations ; } public void setMetadataJmsOperations ( JmsOperations metadataJmsOperations ) { this . metadataJmsOperations = metadataJmsOperations ; } public static DestinationResolver createDestinationResolver ( final DestinationEndpoint destinationEndpoint ) { return new DestinationResolver ( ) { public Destination resolveDestinationName ( Session session , String destinationName , boolean pubSubDomain ) throws JMSException { return destinationEndpoint . getJmsDestination ( session ) ; } } ; } protected void configureMessageListenerContainer ( AbstractMessageListenerContainer container , JmsEndpoint endpoint ) { container . setConnectionFactory ( getListenerConnectionFactory ( ) ) ; if ( endpoint instanceof DestinationEndpoint ) { container . setDestinationResolver ( createDestinationResolver ( ( DestinationEndpoint ) endpoint ) ) ; } else if ( destinationResolver != null ) { container . setDestinationResolver ( destinationResolver ) ; } if ( autoStartup ) { container . setAutoStartup ( true ) ; } if ( clientId != null ) { container . setClientId ( clientId ) ; } container . setSubscriptionDurable ( subscriptionDurable ) ; if ( durableSubscriptionName != null ) { container . setDurableSubscriptionName ( durableSubscriptionName ) ; } if ( durableSubscriptionName != null && clientId != null ) { container . setSubscriptionDurable ( true ) ; } if ( exceptionListener != null ) { container . setExceptionListener ( exceptionListener ) ; } container . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; container . setExposeListenerSession ( exposeListenerSession ) ; container . setSessionTransacted ( transacted ) ; if ( transacted ) { container . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( acknowledgementMode >= 0 ) { container . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { container . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } } if ( endpoint . getSelector ( ) != null && endpoint . getSelector ( ) . length ( ) != 0 ) { container . setMessageSelector ( endpoint . getSelector ( ) ) ; } if ( container instanceof DefaultMessageListenerContainer ) { DefaultMessageListenerContainer listenerContainer = ( DefaultMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } if ( cacheLevel >= 0 ) { listenerContainer . setCacheLevel ( cacheLevel ) ; } else if ( cacheLevelName != null ) { listenerContainer . setCacheLevelName ( cacheLevelName ) ; } else { listenerContainer . setCacheLevel ( defaultCacheLevel ( endpoint ) ) ; } if ( idleTaskExecutionLimit >= 0 ) { listenerContainer . setIdleTaskExecutionLimit ( idleTaskExecutionLimit ) ; } if ( maxConcurrentConsumers >= 0 ) { listenerContainer . setMaxConcurrentConsumers ( maxConcurrentConsumers ) ; } if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { listenerContainer . setReceiveTimeout ( receiveTimeout ) ; } if ( recoveryInterval >= 0 ) { listenerContainer . setRecoveryInterval ( recoveryInterval ) ; } if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } PlatformTransactionManager tm = getTransactionManager ( ) ; if ( tm != null && transacted ) { listenerContainer . setTransactionManager ( tm ) ; } else if ( transacted ) { throw new IllegalArgumentException ( "Property transacted is enabled but a transactionManager was not injected!" ) ; } if ( transactionName != null ) { listenerContainer . setTransactionName ( transactionName ) ; } if ( transactionTimeout >= 0 ) { listenerContainer . setTransactionTimeout ( transactionTimeout ) ; } } else if ( container instanceof ServerSessionMessageListenerContainer ) { ServerSessionMessageListenerContainer listenerContainer = ( ServerSessionMessageListenerContainer ) container ; if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } if ( serverSessionFactory != null ) { listenerContainer . setServerSessionFactory ( serverSessionFactory ) ; } } else if ( container instanceof SimpleMessageListenerContainer ) { SimpleMessageListenerContainer listenerContainer = ( SimpleMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } } } public void configure ( EndpointMessageListener listener ) { if ( isDisableReplyTo ( ) ) { listener . setDisableReplyTo ( true ) ; } if ( isEagerLoadingOfProperties ( ) ) { listener . setEagerLoadingOfProperties ( true ) ; } JmsOperations operations = listener . getTemplate ( ) ; if ( operations instanceof JmsTemplate ) { JmsTemplate template = ( JmsTemplate ) operations ; template . setDeliveryPersistent ( isReplyToDeliveryPersistent ( ) ) ; } } public AbstractMessageListenerContainer chooseMessageListenerContainerImplementation ( ) { switch ( consumerType ) { case Simple : return isUseVersion102 ( ) ? new SimpleMessageListenerContainer102 ( ) : new SimpleMessageListenerContainer ( ) ; case ServerSessionPool : return isUseVersion102 ( ) ? new ServerSessionMessageListenerContainer102 ( ) : new ServerSessionMessageListenerContainer ( ) ; case Default : return isUseVersion102 ( ) ? new DefaultMessageListenerContainer102 ( ) : new DefaultMessageListenerContainer ( ) ; default : throw new IllegalArgumentException ( "Unknown consumer type: " + consumerType ) ; } } protected int defaultCacheLevel ( JmsEndpoint endpoint ) { if ( PackageHelper . isValidVersion ( "org.springframework.jms" , 2.51D ) ) { return DefaultMessageListenerContainer . CACHE_CONSUMER ; } else { if ( endpoint . isPubSubDomain ( ) && ! isSubscriptionDurable ( ) ) { return DefaultMessageListenerContainer . CACHE_CONSUMER ; } else { return DefaultMessageListenerContainer . CACHE_CONNECTION ; } } } protected ConnectionFactory createConnectionFactory ( ) { ObjectHelper . notNull ( connectionFactory , "connectionFactory" ) ; return null ; } protected ConnectionFactory createListenerConnectionFactory ( ) { return getConnectionFactory ( ) ; } protected ConnectionFactory createTemplateConnectionFactory ( ) { return getConnectionFactory ( ) ; } public boolean isPreserveMessageQos ( ) { return preserveMessageQos ; } protected void configuredQoS ( ) { if ( explicitQosEnabled == null ) { explicitQosEnabled = true ; } } public boolean isAlwaysCopyMessage ( ) { return alwaysCopyMessage ; } public void setAlwaysCopyMessage ( boolean alwaysCopyMessage ) { this . alwaysCopyMessage = alwaysCopyMessage ; } public boolean isUseMessageIDAsCorrelationID ( ) { return useMessageIDAsCorrelationID ; } public void setUseMessageIDAsCorrelationID ( boolean useMessageIDAsCorrelationID ) { this . useMessageIDAsCorrelationID = useMessageIDAsCorrelationID ; } public String getReplyToTempDestinationAffinity ( ) { return replyToTempDestinationAffinity ; } public void setReplyToTempDestinationAffinity ( String replyToTempDestinationAffinity ) { this . replyToTempDestinationAffinity = replyToTempDestinationAffinity ; } public long getRequestTimeout ( ) { return requestTimeout ; } public void setRequestTimeout ( long requestTimeout ) { this . requestTimeout = requestTimeout ; } public String getReplyTo ( ) { return replyToDestination ; } public void setReplyTo ( String replyToDestination ) { if ( ! replyToDestination . startsWith ( QUEUE_PREFIX ) ) { throw new IllegalArgumentException ( "ReplyTo destination value has to be of type queue; " + "e.g: \"queue:replyQueue\"" ) ; } this . replyToDestination = removeStartingCharacters ( replyToDestination . substring ( QUEUE_PREFIX . length ( ) ) , '/' ) ; } public String getReplyToDestinationSelectorName ( ) { return replyToDestinationSelectorName ; } public void setReplyToDestinationSelectorName ( String replyToDestinationSelectorName ) { this . replyToDestinationSelectorName = replyToDestinationSelectorName ; if ( replyToDestinationSelectorName != null ) { setAlwaysCopyMessage ( true ) ; } } } 	0	['120', '1', '0', '38', '200', '6646', '14', '28', '113', '0.973345588', '1370', '0.9375', '2', '0', '0.081822203', '0', '0', '9.883333333', '33', '1.5417', '0']
package org . apache . camel . builder ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . nio . channels . ReadableByteChannel ; import java . text . SimpleDateFormat ; import java . util . Collection ; import java . util . Date ; import java . util . Scanner ; import java . util . regex . Pattern ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . language . bean . BeanLanguage ; import org . apache . camel . language . simple . SimpleLanguage ; public final class ExpressionBuilder { private ExpressionBuilder ( ) { } public static < E extends Exchange > Expression < E > headerExpression ( final String headerName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object header = exchange . getIn ( ) . getHeader ( headerName ) ; if ( header == null ) { header = exchange . getProperty ( headerName ) ; } return header ; } @ Override public String toString ( ) { return "header(" + headerName + ")" ; } } ; } public static < E extends Exchange > Expression < E > headersExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getHeaders ( ) ; } @ Override public String toString ( ) { return "headers" ; } } ; } public static < E extends Exchange > Expression < E > outHeaderExpression ( final String headerName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Message out = exchange . getOut ( false ) ; if ( out == null ) { return null ; } Object header = out . getHeader ( headerName ) ; if ( header == null ) { header = exchange . getProperty ( headerName ) ; } return header ; } @ Override public String toString ( ) { return "outHeader(" + headerName + ")" ; } } ; } public static < E extends Exchange > Expression < E > outHeadersExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getOut ( ) . getHeaders ( ) ; } @ Override public String toString ( ) { return "outHeaders" ; } } ; } public static < E extends Exchange > Expression < E > propertyExpression ( final String propertyName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getProperty ( propertyName ) ; } @ Override public String toString ( ) { return "property(" + propertyName + ")" ; } } ; } public static < E extends Exchange > Expression < E > propertiesExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getProperties ( ) ; } @ Override public String toString ( ) { return "properties" ; } } ; } public static < E extends Exchange > Expression < E > systemPropertyExpression ( final String propertyName ) { return systemPropertyExpression ( propertyName , null ) ; } public static < E extends Exchange > Expression < E > systemPropertyExpression ( final String propertyName , final String defaultValue ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return System . getProperty ( propertyName , defaultValue ) ; } @ Override public String toString ( ) { return "systemProperty(" + propertyName + ")" ; } } ; } public static < E extends Exchange > Expression < E > constantExpression ( final Object value ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return value ; } @ Override public String toString ( ) { return "" + value ; } } ; } public static < E extends Exchange > Expression < E > bodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getBody ( ) ; } @ Override public String toString ( ) { return "body" ; } } ; } public static < E extends Exchange , T > Expression < E > bodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getBody ( type ) ; } @ Override public String toString ( ) { return "bodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > outBodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Message out = exchange . getOut ( false ) ; if ( out == null ) { return null ; } return out . getBody ( ) ; } @ Override public String toString ( ) { return "outBody" ; } } ; } public static < E extends Exchange , T > Expression < E > outBodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Message out = exchange . getOut ( false ) ; if ( out == null ) { return null ; } return out . getBody ( type ) ; } @ Override public String toString ( ) { return "outBodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > faultBodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getFault ( ) . getBody ( ) ; } @ Override public String toString ( ) { return "faultBody" ; } } ; } public static < E extends Exchange , T > Expression < E > faultBodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getFault ( ) . getBody ( type ) ; } @ Override public String toString ( ) { return "faultBodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > exchangeExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange ; } @ Override public String toString ( ) { return "exchange" ; } } ; } public static < E extends Exchange > Expression < E > inMessageExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) ; } @ Override public String toString ( ) { return "inMessage" ; } } ; } public static < E extends Exchange > Expression < E > outMessageExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getOut ( ) ; } @ Override public String toString ( ) { return "outMessage" ; } } ; } public static < E extends Exchange > Expression < E > convertTo ( final Expression expression , final Class type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( type , exchange , value ) ; } @ Override public String toString ( ) { return "" + expression + ".convertTo(" + type . getName ( ) + ".class)" ; } } ; } public static < E extends Exchange > Expression < E > tokenizeExpression ( final Expression < E > expression , final String token ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object value = expression . evaluate ( exchange ) ; Scanner scanner = getScanner ( exchange , value ) ; scanner . useDelimiter ( token ) ; return scanner ; } @ Override public String toString ( ) { return "tokenize(" + expression + ", " + token + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexTokenize ( final Expression < E > expression , final String regexTokenizer ) { final Pattern pattern = Pattern . compile ( regexTokenizer ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object value = expression . evaluate ( exchange ) ; Scanner scanner = getScanner ( exchange , value ) ; scanner . useDelimiter ( regexTokenizer ) ; return scanner ; } @ Override public String toString ( ) { return "regexTokenize(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } private static Scanner getScanner ( Exchange exchange , Object value ) { String charset = exchange . getProperty ( Exchange . CHARSET_NAME , String . class ) ; Scanner scanner = null ; if ( value instanceof Readable ) { scanner = new Scanner ( ( Readable ) value ) ; } else if ( value instanceof InputStream ) { scanner = charset == null ? new Scanner ( ( InputStream ) value ) : new Scanner ( ( InputStream ) value , charset ) ; } else if ( value instanceof File ) { try { scanner = charset == null ? new Scanner ( ( File ) value ) : new Scanner ( ( File ) value , charset ) ; } catch ( FileNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } else if ( value instanceof String ) { scanner = new Scanner ( ( String ) value ) ; } else if ( value instanceof ReadableByteChannel ) { scanner = charset == null ? new Scanner ( ( ReadableByteChannel ) value ) : new Scanner ( ( ReadableByteChannel ) value , charset ) ; } if ( scanner == null ) { String text = exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , exchange , value ) ; if ( text != null ) { scanner = new Scanner ( text ) ; } } if ( scanner == null ) { scanner = new Scanner ( "" ) ; } return scanner ; } public static < E extends Exchange > Expression < E > regexReplaceAll ( final Expression < E > expression , final String regex , final String replacement ) { final Pattern pattern = Pattern . compile ( regex ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } return pattern . matcher ( text ) . replaceAll ( replacement ) ; } @ Override public String toString ( ) { return "regexReplaceAll(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexReplaceAll ( final Expression < E > expression , String regex , final Expression < E > replacementExpression ) { final Pattern pattern = Pattern . compile ( regex ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; String replacement = evaluateStringExpression ( replacementExpression , exchange ) ; if ( text == null || replacement == null ) { return null ; } return pattern . matcher ( text ) . replaceAll ( replacement ) ; } @ Override public String toString ( ) { return "regexReplaceAll(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > append ( final Expression < E > left , final Expression < E > right ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return evaluateStringExpression ( left , exchange ) + evaluateStringExpression ( right , exchange ) ; } @ Override public String toString ( ) { return "append(" + left + ", " + right + ")" ; } } ; } public static < E extends Exchange > String evaluateStringExpression ( Expression < E > expression , E exchange ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , exchange , value ) ; } public static < E extends Exchange > Expression < E > systemProperty ( final String name ) { return systemProperty ( name , null ) ; } public static < E extends Exchange > Expression < E > systemProperty ( final String name , final String defaultValue ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return System . getProperty ( name , defaultValue ) ; } } ; } public static < E extends Exchange > Expression < E > concatExpression ( final Collection < Expression > expressions ) { return concatExpression ( expressions , null ) ; } public static < E extends Exchange > Expression < E > concatExpression ( final Collection < Expression > expressions , final String expression ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Expression < E > expression : expressions ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text != null ) { buffer . append ( text ) ; } } return buffer . toString ( ) ; } @ Override public String toString ( ) { if ( expression != null ) { return expression ; } else { return "concat" + expressions ; } } } ; } public static < E extends Exchange > Expression < E > messageIdExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getMessageId ( ) ; } @ Override public String toString ( ) { return "messageId" ; } } ; } public static < E extends Exchange > Expression < E > dateExpression ( final String command , final String pattern ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Date date ; if ( "now" . equals ( command ) ) { date = new Date ( ) ; } else if ( command . startsWith ( "header." ) || command . startsWith ( "in.header." ) ) { String key = command . substring ( command . lastIndexOf ( "." ) + 1 ) ; date = exchange . getIn ( ) . getHeader ( key , Date . class ) ; if ( date == null ) { throw new IllegalArgumentException ( "Could not find java.util.Date object at " + command ) ; } } else if ( command . startsWith ( "out.header." ) ) { String key = command . substring ( command . lastIndexOf ( "." ) + 1 ) ; date = exchange . getOut ( ) . getHeader ( key , Date . class ) ; if ( date == null ) { throw new IllegalArgumentException ( "Could not find java.util.Date object at " + command ) ; } } else { throw new IllegalArgumentException ( "Command not supported for dateExpression: " + command ) ; } SimpleDateFormat df = new SimpleDateFormat ( pattern ) ; return df . format ( date ) ; } @ Override public String toString ( ) { return "date(" + command + ":" + pattern + ")" ; } } ; } public static < E extends Exchange > Expression < E > simpleExpression ( final String simple ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return SimpleLanguage . simple ( simple ) . evaluate ( exchange ) ; } @ Override public String toString ( ) { return "simple(" + simple + ")" ; } } ; } public static < E extends Exchange > Expression < E > beanExpression ( final String bean ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return BeanLanguage . bean ( bean ) . evaluate ( exchange ) ; } @ Override public String toString ( ) { return "bean(" + bean + ")" ; } } ; } } 	1	['36', '1', '0', '52', '81', '630', '24', '34', '33', '2', '342', '0', '0', '0', '0.138888889', '0', '0', '8.5', '12', '1.2778', '4']
package org . apache . camel . component . file ; import java . io . File ; import org . apache . camel . impl . DefaultMessage ; public class FileMessage extends DefaultMessage { private File file ; public FileMessage ( ) { this ( new File ( "." ) ) ; } public FileMessage ( File file ) { this . file = file ; } @ Override public String toString ( ) { return "FileMessage: " + file ; } @ Override public FileExchange getExchange ( ) { return ( FileExchange ) super . getExchange ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } @ Override public FileMessage newInstance ( ) { return new FileMessage ( ) ; } @ Override protected Object createBody ( ) { return file ; } } 	0	['11', '3', '0', '4', '15', '35', '1', '4', '10', '0.2', '62', '1', '0', '0.795454545', '0.590909091', '2', '5', '4.545454545', '1', '0.8182', '0']
package org . apache . camel . language . simple ; import org . apache . camel . Expression ; import org . apache . camel . component . file . FileExchange ; import org . apache . camel . language . IllegalSyntaxException ; import org . apache . camel . util . ObjectHelper ; public class FileLanguage extends AbstractSimpleLanguage { public static Expression file ( String expression ) { FileLanguage language = new FileLanguage ( ) ; return language . createExpression ( expression ) ; } protected Expression < FileExchange > createSimpleExpression ( String expression ) { String remainder = ifStartsWithReturnRemainder ( "file:" , expression ) ; if ( remainder != null ) { if ( ObjectHelper . equal ( remainder , "name" ) ) { return FileExpressionBuilder . fileNameExpression ( ) ; } else if ( ObjectHelper . equal ( remainder , "name.noext" ) ) { return FileExpressionBuilder . fileNameNoExtensionExpression ( ) ; } else if ( ObjectHelper . equal ( remainder , "parent" ) ) { return FileExpressionBuilder . fileParentExpression ( ) ; } else if ( ObjectHelper . equal ( remainder , "path" ) ) { return FileExpressionBuilder . filePathExpression ( ) ; } else if ( ObjectHelper . equal ( remainder , "absolute.path" ) ) { return FileExpressionBuilder . fileAbsolutePathExpression ( ) ; } else if ( ObjectHelper . equal ( remainder , "canonical.path" ) ) { return FileExpressionBuilder . fileCanoicalPathExpression ( ) ; } else if ( ObjectHelper . equal ( remainder , "length" ) ) { return FileExpressionBuilder . fileSizeExpression ( ) ; } } remainder = ifStartsWithReturnRemainder ( "date:" , expression ) ; if ( remainder != null ) { String [ ] parts = remainder . split ( ":" ) ; if ( parts . length != 2 ) { throw new IllegalSyntaxException ( this , expression + " ${date:command:pattern} is the correct syntax." ) ; } String command = parts [ 0 ] ; String pattern = parts [ 1 ] ; return FileExpressionBuilder . dateExpression ( command , pattern ) ; } return FileExpressionBuilder . simpleExpression ( expression ) ; } } 	1	['3', '2', '0', '10', '21', '3', '4', '6', '2', '2', '106', '0', '0', '0.75', '0.666666667', '1', '3', '34.33333333', '11', '4', '4']
package org . apache . camel . component . timer ; import java . util . Date ; import java . util . Timer ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultEndpoint ; public class TimerEndpoint extends DefaultEndpoint < Exchange > { private String timerName ; private Date time ; private long period = 1000 ; private long delay ; private boolean fixedRate ; private boolean daemon = true ; private Timer timer ; public TimerEndpoint ( String fullURI , TimerComponent component , String timerName ) { super ( fullURI , component ) ; this . timer = component . getTimer ( this ) ; this . timerName = timerName ; } public TimerEndpoint ( String endpointUri , Timer timer ) { this ( endpointUri ) ; this . timer = timer ; } public TimerEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public Producer < Exchange > createProducer ( ) throws Exception { throw new RuntimeCamelException ( "Cannot produce to a TimerEndpoint: " + getEndpointUri ( ) ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { return new TimerConsumer ( this , processor ) ; } public String getTimerName ( ) { if ( timerName == null ) { timerName = getEndpointUri ( ) ; } return timerName ; } public void setTimerName ( String timerName ) { this . timerName = timerName ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public boolean isFixedRate ( ) { return fixedRate ; } public void setFixedRate ( boolean fixedRate ) { this . fixedRate = fixedRate ; } public long getPeriod ( ) { return period ; } public void setPeriod ( long period ) { this . period = period ; } public Date getTime ( ) { return time ; } public void setTime ( Date time ) { this . time = time ; } public boolean isSingleton ( ) { return true ; } public Timer getTimer ( ) { if ( timer == null ) { timer = new Timer ( ) ; } return timer ; } public void setTimer ( Timer timer ) { this . timer = timer ; } } 	0	['20', '2', '0', '8', '30', '144', '2', '8', '20', '0.879699248', '148', '1', '0', '0.585365854', '0.20625', '0', '0', '6.05', '2', '0.95', '0']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . builder . xml . XPathBuilder ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . language . NamespacePrefix ; import org . apache . camel . language . XPath ; public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory { @ Override public Expression createExpression ( CamelContext camelContext , Annotation annotation , LanguageAnnotation languageAnnotation , Class expressionReturnType ) { String xpath = getExpressionFromAnnotation ( annotation ) ; XPathBuilder builder = XPathBuilder . xpath ( xpath ) ; if ( annotation instanceof XPath ) { XPath xpathAnnotation = ( XPath ) annotation ; NamespacePrefix [ ] namespaces = xpathAnnotation . namespaces ( ) ; if ( namespaces != null ) { for ( NamespacePrefix namespacePrefix : namespaces ) { builder = builder . namespace ( namespacePrefix . prefix ( ) , namespacePrefix . uri ( ) ) ; } } } return builder ; } } 	1	['2', '2', '0', '7', '9', '1', '0', '7', '2', '2', '48', '0', '0', '0.666666667', '0.6', '1', '1', '23', '4', '2', '1']
package org . apache . camel . component . jpa ; import java . util . Map ; import javax . persistence . EntityManagerFactory ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . ObjectHelper ; public class JpaComponent extends DefaultComponent < Exchange > { private EntityManagerFactory entityManagerFactory ; public Component resolveComponent ( CamelContext container , String uri ) throws Exception { return null ; } public EntityManagerFactory getEntityManagerFactory ( ) { return entityManagerFactory ; } public void setEntityManagerFactory ( EntityManagerFactory entityManagerFactory ) { this . entityManagerFactory = entityManagerFactory ; } @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String path , Map options ) throws Exception { JpaEndpoint endpoint = new JpaEndpoint ( uri , this ) ; if ( path != null ) { Class < ? > type = ObjectHelper . loadClass ( path ) ; if ( type != null ) { endpoint . setEntityType ( type ) ; } } return endpoint ; } } 	0	['5', '3', '0', '6', '9', '8', '1', '6', '4', '0.75', '36', '1', '0', '0.897435897', '0.4', '1', '1', '6', '1', '0.8', '0']
package org . apache . camel . util ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class EndpointHelper { private static final transient Log LOG = LogFactory . getLog ( EndpointHelper . class ) ; private EndpointHelper ( ) { } public static void pollEndpoint ( Endpoint endpoint , Processor processor , long timeout ) throws Exception { PollingConsumer consumer = endpoint . createPollingConsumer ( ) ; try { consumer . start ( ) ; while ( true ) { Exchange exchange = consumer . receive ( timeout ) ; if ( exchange == null ) { break ; } else { processor . process ( exchange ) ; } } } finally { try { consumer . stop ( ) ; } catch ( Exception e ) { LOG . warn ( "Failed to stop PollingConsumer: " + e , e ) ; } } } public static void pollEndpoint ( Endpoint endpoint , Processor processor ) throws Exception { pollEndpoint ( endpoint , processor , 1000L ) ; } } 	1	['4', '1', '0', '7', '16', '4', '1', '6', '2', '0.333333333', '68', '1', '0', '0', '0.5', '0', '0', '15.75', '1', '0.5', '3']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlEnum ; @ XmlEnum ( String . class ) public enum ArtixDSContentType { Default , Auto , Binary , Text , Java , Xml , Sax , TagValuePair } 	0	['4', '2', '0', '3', '7', '4', '2', '1', '2', '0.962962963', '111', '0.111111111', '9', '0.857142857', '0.444444444', '1', '1', '24.5', '1', '0.5', '0']
package org . apache . camel . processor ; import java . util . Collection ; import java . util . Iterator ; import java . util . concurrent . LinkedBlockingQueue ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . LoggingExceptionHandler ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; public class BatchProcessor extends ServiceSupport implements Processor { public static final long DEFAULT_BATCH_TIMEOUT = 1000L ; public static final int DEFAULT_BATCH_SIZE = 100 ; private long batchTimeout = DEFAULT_BATCH_TIMEOUT ; private int batchSize = DEFAULT_BATCH_SIZE ; private int outBatchSize ; private Processor processor ; private Collection < Exchange > collection ; private ExceptionHandler exceptionHandler ; private BatchSender sender ; public BatchProcessor ( Processor processor , Collection < Exchange > collection ) { this . processor = processor ; this . collection = collection ; this . sender = new BatchSender ( ) ; } @ Override public String toString ( ) { return "BatchProcessor[to: " + processor + "]" ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public int getOutBatchSize ( ) { return outBatchSize ; } public void setOutBatchSize ( int outBatchSize ) { this . outBatchSize = outBatchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } public Processor getProcessor ( ) { return processor ; } protected boolean isInBatchCompleted ( int num ) { return num >= batchSize ; } protected boolean isOutBatchCompleted ( ) { if ( outBatchSize == 0 ) { return true ; } return collection . size ( ) > 0 && collection . size ( ) >= outBatchSize ; } protected void processExchange ( Exchange exchange ) throws Exception { processor . process ( exchange ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; sender . start ( ) ; } protected void doStop ( ) throws Exception { sender . cancel ( ) ; ServiceHelper . stopServices ( processor ) ; collection . clear ( ) ; } protected Collection < Exchange > getCollection ( ) { return collection ; } public void process ( Exchange exchange ) throws Exception { sender . enqueueExchange ( exchange ) ; } private class BatchSender extends Thread { private volatile boolean cancelRequested ; private LinkedBlockingQueue < Exchange > queue ; public BatchSender ( ) { super ( "Batch Sender" ) ; this . queue = new LinkedBlockingQueue < Exchange > ( ) ; } @ Override public void run ( ) { while ( true ) { try { Thread . sleep ( batchTimeout ) ; queue . drainTo ( collection , batchSize ) ; } catch ( InterruptedException e ) { if ( cancelRequested ) { return ; } while ( isInBatchCompleted ( queue . size ( ) ) ) { queue . drainTo ( collection , batchSize ) ; } if ( ! isOutBatchCompleted ( ) ) { continue ; } } try { sendExchanges ( ) ; } catch ( Exception e ) { getExceptionHandler ( ) . handleException ( e ) ; } } } public void cancel ( ) { cancelRequested = true ; interrupt ( ) ; } public void enqueueExchange ( Exchange exchange ) { queue . add ( exchange ) ; interrupt ( ) ; } private void sendExchanges ( ) throws Exception { Iterator < Exchange > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { Exchange exchange = iter . next ( ) ; iter . remove ( ) ; processExchange ( exchange ) ; } } } } 	1	['21', '2', '2', '9', '37', '116', '3', '7', '12', '0.888888889', '180', '0.777777778', '3', '0.411764706', '0.178571429', '1', '1', '7.142857143', '4', '1.1905', '8']
package org . apache . camel ; import java . util . HashMap ; import java . util . Map ; import javax . xml . bind . annotation . XmlEnum ; import javax . xml . bind . annotation . XmlType ; @ XmlType @ XmlEnum ( String . class ) public enum ExchangePattern { InOnly , RobustInOnly , InOut , InOptionalOut , OutOnly , RobustOutOnly , OutIn , OutOptionalIn ; protected static final Map < String , ExchangePattern > MAP = new HashMap < String , ExchangePattern > ( ) ; public String getWsdlUri ( ) { switch ( this ) { case InOnly : return "http://www.w3.org/ns/wsdl/in-only" ; case InOptionalOut : return "http://www.w3.org/ns/wsdl/in-optional-out" ; case InOut : return "http://www.w3.org/ns/wsdl/in-out" ; case OutIn : return "http://www.w3.org/ns/wsdl/out-in" ; case OutOnly : return "http://www.w3.org/ns/wsdl/out-only" ; case OutOptionalIn : return "http://www.w3.org/ns/wsdl/out-optional_in" ; case RobustInOnly : return "http://www.w3.org/ns/wsdl/robust-in-only" ; case RobustOutOnly : return "http://www.w3.org/ns/wsdl/robust-out-only" ; default : throw new IllegalArgumentException ( "Unknown message exchange pattern: " + this ) ; } } public boolean isInCapable ( ) { switch ( this ) { case OutOnly : case RobustOutOnly : return false ; default : return true ; } } public boolean isOutCapable ( ) { switch ( this ) { case InOnly : case RobustInOnly : return false ; default : return true ; } } public boolean isFaultCapable ( ) { switch ( this ) { case InOnly : case OutOnly : return false ; default : return true ; } } public static ExchangePattern fromWsdlUri ( String wsdlUri ) { return MAP . get ( wsdlUri ) ; } public static ExchangePattern asEnum ( String value ) { try { return valueOf ( value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Unknown message exchange pattern: " + value ) ; } } static { for ( ExchangePattern mep : values ( ) ) { String uri = mep . getWsdlUri ( ) ; MAP . put ( uri , mep ) ; String name = uri . substring ( uri . lastIndexOf ( '/' ) + 1 ) ; MAP . put ( "http://www.w3.org/2004/08/wsdl/" + name , mep ) ; MAP . put ( "http://www.w3.org/2006/01/wsdl/" + name , mep ) ; } } } 	0	['10', '2', '0', '73', '24', '41', '72', '2', '8', '0.977777778', '259', '0.2', '9', '0.6', '0.37037037', '1', '1', '23.9', '4', '1.8', '0']
package org . apache . camel . model . loadbalancer ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "random" ) public class RandomLoadBalanceStrategy extends LoadBalancerType { @ Override protected LoadBalancer createLoadBalancer ( RouteContext routeContext ) { return new org . apache . camel . processor . loadbalancer . RandomLoadBalancer ( ) ; } } 	1	['2', '3', '0', '4', '4', '1', '0', '4', '1', '2', '9', '0', '0', '0.923076923', '0.75', '1', '1', '3.5', '1', '0.5', '1']
package org . apache . camel . component . cxf ; import java . util . Map ; import javax . wsdl . Definition ; import javax . wsdl . factory . WSDLFactory ; import javax . wsdl . xml . WSDLReader ; import javax . xml . namespace . QName ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . cxf . Bus ; import org . apache . cxf . BusFactory ; import org . apache . cxf . helpers . DOMUtils ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; public class CxfSoapEndpoint implements Endpoint { private final Endpoint endpoint ; private Resource wsdl ; private String serviceClass ; private org . w3c . dom . Document description ; private Definition definition ; private QName serviceName ; private QName endpointName ; private Bus bus ; private HeaderFilterStrategy headerFilterStrategy ; public CxfSoapEndpoint ( Endpoint endpoint ) { this ( endpoint , new CxfHeaderFilterStrategy ( ) ) ; } public CxfSoapEndpoint ( Endpoint endpoint , HeaderFilterStrategy headerFilterStrategy ) { this . endpoint = endpoint ; this . headerFilterStrategy = headerFilterStrategy ; } protected Endpoint getInnerEndpoint ( ) { return endpoint ; } public boolean isSingleton ( ) { return endpoint . isSingleton ( ) ; } public String getEndpointUri ( ) { return endpoint . getEndpointUri ( ) ; } public Exchange createExchange ( ) { return endpoint . createExchange ( ) ; } public Exchange createExchange ( ExchangePattern pattern ) { return endpoint . createExchange ( pattern ) ; } public Exchange createExchange ( Exchange exchange ) { return endpoint . createExchange ( exchange ) ; } public CamelContext getCamelContext ( ) { return endpoint . getCamelContext ( ) ; } public Producer createProducer ( ) throws Exception { return new CxfSoapProducer ( this ) ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new CxfSoapConsumer ( this , processor ) ; } public PollingConsumer createPollingConsumer ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } public void configureProperties ( Map options ) { } public Resource getWsdl ( ) { return wsdl ; } public void setWsdl ( Resource wsdl ) { this . wsdl = wsdl ; } public void setServiceClass ( String serviceClass ) { this . serviceClass = serviceClass ; } public String getServiceClass ( ) { return serviceClass ; } public void setServiceName ( String serviceName ) { this . serviceName = QName . valueOf ( serviceName ) ; } public void setEndpointName ( String endpointName ) { this . endpointName = QName . valueOf ( endpointName ) ; } public QName getEndpointName ( ) { return endpointName ; } public void init ( ) throws Exception { Assert . notNull ( wsdl , "soap.wsdl parameter must be set on the uri" ) ; if ( serviceName == null ) { description = DOMUtils . readXml ( wsdl . getInputStream ( ) ) ; WSDLFactory wsdlFactory = WSDLFactory . newInstance ( ) ; WSDLReader reader = wsdlFactory . newWSDLReader ( ) ; reader . setFeature ( "javax.wsdl.verbose" , false ) ; definition = reader . readWSDL ( wsdl . getURL ( ) . toString ( ) , description ) ; serviceName = ( QName ) definition . getServices ( ) . keySet ( ) . iterator ( ) . next ( ) ; } } protected Bus getBus ( ) { if ( bus == null ) { bus = BusFactory . newInstance ( ) . createBus ( ) ; } return bus ; } public Definition getDefinition ( ) { return definition ; } public QName getServiceName ( ) { return serviceName ; } public void setCamelContext ( CamelContext context ) { endpoint . setCamelContext ( context ) ; } @ Deprecated public CamelContext getContext ( ) { return getCamelContext ( ) ; } @ Deprecated public void setContext ( CamelContext context ) { setCamelContext ( context ) ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public boolean isLenientProperties ( ) { return false ; } } 	0	['29', '1', '0', '18', '57', '314', '3', '17', '27', '0.920634921', '201', '1', '2', '0', '0.144827586', '0', '0', '5.620689655', '2', '0.9655', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . NoSuchLanguageException ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; public class DefaultLanguageResolver implements LanguageResolver { protected static final FactoryFinder LANGUAGE_FACTORY = new FactoryFinder ( "META-INF/services/org/apache/camel/language/" ) ; protected static final FactoryFinder LANGUAGE_RESOLVER = new FactoryFinder ( "META-INF/services/org/apache/camel/language/resolver/" ) ; public Language resolveLanguage ( String name , CamelContext context ) { Class type = null ; try { type = LANGUAGE_FACTORY . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Language registered for scheme : " + name , e ) ; } if ( type != null ) { if ( Language . class . isAssignableFrom ( type ) ) { return ( Language ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Language implementation. Found: " + type . getName ( ) ) ; } } return noSpecificLanguageFound ( name , context ) ; } protected Language noSpecificLanguageFound ( String name , CamelContext context ) { Class type = null ; try { type = LANGUAGE_RESOLVER . findClass ( "default" ) ; } catch ( NoFactoryAvailableException e ) { } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Language registered for scheme : " + name , e ) ; } if ( type != null ) { if ( LanguageResolver . class . isAssignableFrom ( type ) ) { LanguageResolver resolver = ( LanguageResolver ) context . getInjector ( ) . newInstance ( type ) ; return resolver . resolveLanguage ( name , context ) ; } else { throw new IllegalArgumentException ( "Type is not a LanguageResolver implementation. Found: " + type . getName ( ) ) ; } } throw new NoSuchLanguageException ( name ) ; } } 	1	['4', '1', '0', '8', '18', '2', '1', '7', '2', '0.5', '131', '1', '2', '0', '0.777777778', '0', '0', '31.25', '3', '1.5', '1']
package org . apache . camel . component . cxf . spring ; import java . util . List ; import org . apache . cxf . frontend . AbstractWSDLBasedEndpointFactory ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; public class CxfEndpointBean extends AbstractWSDLBasedEndpointFactory { private List handlers ; public CxfEndpointBean ( ) { this ( new ReflectionServiceFactoryBean ( ) ) ; } public CxfEndpointBean ( ReflectionServiceFactoryBean factory ) { setServiceFactory ( factory ) ; } public List getHandlers ( ) { return handlers ; } public void setHandlers ( List handlers ) { this . handlers = handlers ; } } 	0	['4', '0', '1', '7', '7', '4', '5', '2', '4', '0.666666667', '24', '1', '0', '0', '0.5', '0', '0', '4.75', '1', '0.5', '0']
package org . apache . camel . component . mock ; import java . beans . PropertyChangeListener ; import java . beans . PropertyChangeSupport ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . spi . BrowsableEndpoint ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ExpressionComparator ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MockEndpoint extends DefaultEndpoint < Exchange > implements BrowsableEndpoint < Exchange > { private static final transient Log LOG = LogFactory . getLog ( MockEndpoint . class ) ; private int expectedCount ; private int counter ; private Processor defaultProcessor ; private Map < Integer , Processor > processors ; private List < Exchange > receivedExchanges ; private List < Throwable > failures ; private List < Runnable > tests ; private CountDownLatch latch ; private long sleepForEmptyTest ; private long resultWaitTime ; private long resultMinimumWaitTime ; private int expectedMinimumCount ; private List expectedBodyValues ; private List actualBodyValues ; private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport ( this ) ; private String headerName ; private String headerValue ; private Object actualHeader ; private Processor reporter ; public MockEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; init ( ) ; } public MockEndpoint ( String endpointUri ) { super ( endpointUri ) ; init ( ) ; } public static MockEndpoint resolve ( CamelContext context , String uri ) { return CamelContextHelper . getMandatoryEndpoint ( context , uri , MockEndpoint . class ) ; } public static void assertWait ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { long start = System . currentTimeMillis ( ) ; long left = unit . toMillis ( timeout ) ; long end = start + left ; for ( MockEndpoint endpoint : endpoints ) { if ( ! endpoint . await ( left , TimeUnit . MILLISECONDS ) ) { throw new AssertionError ( "Timeout waiting for endpoints to receive enough messages. " + endpoint . getEndpointUri ( ) + " timed out." ) ; } left = end - System . currentTimeMillis ( ) ; if ( left <= 0 ) { left = 0 ; } } } public static void assertIsSatisfied ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { assertWait ( timeout , unit , endpoints ) ; for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( CamelContext context ) throws InterruptedException { ObjectHelper . notNull ( context , "camelContext" ) ; Collection < Endpoint > endpoints = context . getSingletonEndpoints ( ) ; for ( Endpoint endpoint : endpoints ) { if ( endpoint instanceof MockEndpoint ) { MockEndpoint mockEndpoint = ( MockEndpoint ) endpoint ; mockEndpoint . assertIsSatisfied ( ) ; } } } public static void expectsMessageCount ( int count , MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { MockEndpoint . expectsMessageCount ( count ) ; } } public List < Exchange > getExchanges ( ) { return getReceivedExchanges ( ) ; } public void addPropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( listener ) ; } public void removePropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { throw new UnsupportedOperationException ( "You cannot consume from this endpoint" ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) { onExchange ( exchange ) ; } } ; } public void reset ( ) { init ( ) ; } public void whenExchangeReceived ( int index , Processor processor ) { this . processors . put ( index , processor ) ; } public void whenAnyExchangeReceived ( Processor processor ) { this . defaultProcessor = processor ; } public void assertIsSatisfied ( ) throws InterruptedException { assertIsSatisfied ( sleepForEmptyTest ) ; } public void assertIsSatisfied ( long timeoutForEmptyEndpoints ) throws InterruptedException { LOG . info ( "Asserting: " + this + " is satisfied" ) ; if ( expectedCount == 0 ) { if ( timeoutForEmptyEndpoints > 0 ) { LOG . debug ( "Sleeping for: " + timeoutForEmptyEndpoints + " millis to check there really are no messages received" ) ; Thread . sleep ( timeoutForEmptyEndpoints ) ; } assertEquals ( "Received message count" , expectedCount , getReceivedCounter ( ) ) ; } else if ( expectedCount > 0 ) { if ( expectedCount != getReceivedCounter ( ) ) { waitForCompleteLatch ( ) ; } assertEquals ( "Received message count" , expectedCount , getReceivedCounter ( ) ) ; } else if ( expectedMinimumCount > 0 && getReceivedCounter ( ) < expectedMinimumCount ) { waitForCompleteLatch ( ) ; } if ( expectedMinimumCount >= 0 ) { int receivedCounter = getReceivedCounter ( ) ; assertTrue ( "Received message count " + receivedCounter + ", expected at least " + expectedMinimumCount , expectedMinimumCount <= receivedCounter ) ; } for ( Runnable test : tests ) { test . run ( ) ; } for ( Throwable failure : failures ) { if ( failure != null ) { LOG . error ( "Caught on " + getEndpointUri ( ) + " Exception: " + failure , failure ) ; fail ( "Failed due to caught exception: " + failure ) ; } } } public void assertIsNotSatisfied ( ) throws InterruptedException { try { assertIsSatisfied ( ) ; fail ( "Expected assertion failure!" ) ; } catch ( AssertionError e ) { LOG . info ( "Caught expected failure: " + e ) ; } } public void expectedMessageCount ( int expectedCount ) { setExpectedMessageCount ( expectedCount ) ; } public void expectedMinimumMessageCount ( int expectedCount ) { setMinimumExpectedMessageCount ( expectedCount ) ; } public void expectedHeaderReceived ( String name , String value ) { this . headerName = name ; this . headerValue = value ; expects ( new Runnable ( ) { public void run ( ) { assertTrue ( "No header with name " + headerName + " found." , actualHeader != null ) ; assertEquals ( "Header of message" , headerValue , actualHeader ) ; } } ) ; } public void expectedBodiesReceived ( final List bodies ) { expectedMessageCount ( bodies . size ( ) ) ; this . expectedBodyValues = bodies ; this . actualBodyValues = new ArrayList ( ) ; expects ( new Runnable ( ) { public void run ( ) { for ( int i = 0 ; i < expectedBodyValues . size ( ) ; i ++ ) { Exchange exchange = getReceivedExchanges ( ) . get ( i ) ; assertTrue ( "No exchange received for counter: " + i , exchange != null ) ; Object expectedBody = expectedBodyValues . get ( i ) ; Object actualBody = null ; if ( i < actualBodyValues . size ( ) ) { actualBody = actualBodyValues . get ( i ) ; } assertEquals ( "Body of message: " + i , expectedBody , actualBody ) ; } } } ) ; } public void expectedBodiesReceived ( Object ... bodies ) { List bodyList = new ArrayList ( ) ; bodyList . addAll ( Arrays . asList ( bodies ) ) ; expectedBodiesReceived ( bodyList ) ; } public void expectedBodiesReceivedInAnyOrder ( final List bodies ) { expectedMessageCount ( bodies . size ( ) ) ; this . expectedBodyValues = bodies ; this . actualBodyValues = new ArrayList ( ) ; expects ( new Runnable ( ) { public void run ( ) { Set actualBodyValuesSet = new HashSet ( actualBodyValues ) ; for ( int i = 0 ; i < expectedBodyValues . size ( ) ; i ++ ) { Exchange exchange = getReceivedExchanges ( ) . get ( i ) ; assertTrue ( "No exchange received for counter: " + i , exchange != null ) ; Object expectedBody = expectedBodyValues . get ( i ) ; assertTrue ( "Message with body " + expectedBody + " was expected but not found in " + actualBodyValuesSet , actualBodyValuesSet . remove ( expectedBody ) ) ; } } } ) ; } public void expectedBodiesReceivedInAnyOrder ( Object ... bodies ) { List bodyList = new ArrayList ( ) ; bodyList . addAll ( Arrays . asList ( bodies ) ) ; expectedBodiesReceivedInAnyOrder ( bodyList ) ; } public void expectsAscending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesAscending ( expression ) ; } } ) ; } public void expectsDescending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesDescending ( expression ) ; } } ) ; } public void expectsNoDuplicates ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertNoDuplicates ( expression ) ; } } ) ; } public void assertMessagesAscending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , true ) ; } public void assertMessagesDescending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , false ) ; } protected void assertMessagesSorted ( Expression < Exchange > expression , boolean ascending ) { String type = ascending ? "ascending" : "descending" ; ExpressionComparator comparator = new ExpressionComparator ( expression ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 1 ; i < list . size ( ) ; i ++ ) { int j = i - 1 ; Exchange e1 = list . get ( j ) ; Exchange e2 = list . get ( i ) ; int result = comparator . compare ( e1 , e2 ) ; if ( result == 0 ) { fail ( "Messages not " + type + ". Messages" + j + " and " + i + " are equal with value: " + expression . evaluate ( e1 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { if ( ! ascending ) { result = result * - 1 ; } if ( result > 0 ) { fail ( "Messages not " + type + ". Message " + j + " has value: " + expression . evaluate ( e1 ) + " and message " + i + " has value: " + expression . evaluate ( e2 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } } } } public void assertNoDuplicates ( Expression < Exchange > expression ) { Map < Object , Exchange > map = new HashMap < Object , Exchange > ( ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Exchange e2 = list . get ( i ) ; Object key = expression . evaluate ( e2 ) ; Exchange e1 = map . get ( key ) ; if ( e1 != null ) { fail ( "Duplicate message found on message " + i + " has value: " + key + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { map . put ( key , e2 ) ; } } } public void expects ( Runnable runnable ) { tests . add ( runnable ) ; } public AssertionClause message ( final int messageIndex ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { applyAssertionOn ( MockEndpoint . this , messageIndex , assertExchangeReceived ( messageIndex ) ) ; } } ; expects ( clause ) ; return clause ; } public AssertionClause allMessages ( ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { applyAssertionOn ( MockEndpoint . this , index ++ , exchange ) ; } } } ; expects ( clause ) ; return clause ; } public Exchange assertExchangeReceived ( int index ) { int count = getReceivedCounter ( ) ; assertTrue ( "Not enough messages received. Was: " + count , count > index ) ; return getReceivedExchanges ( ) . get ( index ) ; } public List < Throwable > getFailures ( ) { return failures ; } public int getReceivedCounter ( ) { return getReceivedExchanges ( ) . size ( ) ; } public List < Exchange > getReceivedExchanges ( ) { return receivedExchanges ; } public int getExpectedCount ( ) { return expectedCount ; } public long getSleepForEmptyTest ( ) { return sleepForEmptyTest ; } public void setSleepForEmptyTest ( long sleepForEmptyTest ) { this . sleepForEmptyTest = sleepForEmptyTest ; } public long getResultWaitTime ( ) { return resultWaitTime ; } public void setResultWaitTime ( long resultWaitTime ) { this . resultWaitTime = resultWaitTime ; } public void setMinimumResultWaitTime ( long resultMinimumWaitTime ) { this . resultMinimumWaitTime = resultMinimumWaitTime ; } public void setExpectedMessageCount ( int expectedCount ) { this . expectedCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedCount ) ; } } public void setMinimumExpectedMessageCount ( int expectedCount ) { this . expectedMinimumCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedMinimumCount ) ; } } public Processor getReporter ( ) { return reporter ; } public void setReporter ( Processor reporter ) { this . reporter = reporter ; } private void init ( ) { expectedCount = - 1 ; counter = 0 ; processors = new HashMap < Integer , Processor > ( ) ; receivedExchanges = new CopyOnWriteArrayList < Exchange > ( ) ; failures = new CopyOnWriteArrayList < Throwable > ( ) ; tests = new CopyOnWriteArrayList < Runnable > ( ) ; latch = null ; sleepForEmptyTest = 0 ; resultWaitTime = 20000L ; resultMinimumWaitTime = 0L ; expectedMinimumCount = - 1 ; expectedBodyValues = null ; actualBodyValues = new ArrayList ( ) ; } protected synchronized void onExchange ( Exchange exchange ) { try { if ( reporter != null ) { reporter . process ( exchange ) ; } performAssertions ( exchange ) ; } catch ( Throwable e ) { failures . add ( e ) ; } if ( latch != null ) { latch . countDown ( ) ; } } protected void performAssertions ( Exchange exchange ) throws Exception { Message in = exchange . getIn ( ) ; Object actualBody = in . getBody ( ) ; if ( headerName != null ) { actualHeader = in . getHeader ( headerName ) ; } if ( expectedBodyValues != null ) { int index = actualBodyValues . size ( ) ; if ( expectedBodyValues . size ( ) > index ) { Object expectedBody = expectedBodyValues . get ( index ) ; if ( expectedBody != null ) { actualBody = in . getBody ( expectedBody . getClass ( ) ) ; } actualBodyValues . add ( actualBody ) ; } } LOG . debug ( getEndpointUri ( ) + " >>>> " + ( ++ counter ) + " : " + exchange + " with body: " + actualBody ) ; receivedExchanges . add ( exchange ) ; Processor processor = processors . get ( getReceivedCounter ( ) ) != null ? processors . get ( getReceivedCounter ( ) ) : defaultProcessor ; if ( processor != null ) { processor . process ( exchange ) ; } } protected void waitForCompleteLatch ( ) throws InterruptedException { if ( latch == null ) { fail ( "Should have a latch!" ) ; } LOG . debug ( "Waiting on the latch for: " + resultWaitTime + " millis" ) ; long start = System . currentTimeMillis ( ) ; latch . await ( resultWaitTime , TimeUnit . MILLISECONDS ) ; long delta = System . currentTimeMillis ( ) - start ; LOG . debug ( "Took " + delta + " millis to complete latch" ) ; if ( resultMinimumWaitTime > 0 && delta < resultMinimumWaitTime ) { fail ( "Expected minimum " + resultWaitTime + " millis waiting on the result, but was faster with " + delta + " millis." ) ; } } protected void assertEquals ( String message , Object expectedValue , Object actualValue ) { if ( ! ObjectHelper . equal ( expectedValue , actualValue ) ) { fail ( message + ". Expected: <" + expectedValue + "> but was: <" + actualValue + ">" ) ; } } protected void assertTrue ( String message , boolean predicate ) { if ( ! predicate ) { fail ( message ) ; } } protected void fail ( Object message ) { if ( LOG . isDebugEnabled ( ) ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { LOG . debug ( "Received[" + ( ++ index ) + "]: " + exchange ) ; } } throw new AssertionError ( getEndpointUri ( ) + " " + message ) ; } public int getExpectedMinimumCount ( ) { return expectedMinimumCount ; } public void await ( ) throws InterruptedException { if ( latch != null ) { latch . await ( ) ; } } public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { if ( latch != null ) { return latch . await ( timeout , unit ) ; } return true ; } public boolean isSingleton ( ) { return true ; } } 	1	['67', '2', '2', '29', '131', '2017', '13', '26', '53', '0.882575758', '1285', '1', '2', '0.272727273', '0.096801347', '0', '0', '17.88059701', '6', '1.194', '4']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public abstract class LoadBalancerSupport extends ServiceSupport implements LoadBalancer { private List < Processor > processors = new CopyOnWriteArrayList < Processor > ( ) ; public void addProcessor ( Processor processor ) { processors . add ( processor ) ; } public void removeProcessor ( Processor processor ) { processors . remove ( processor ) ; } public List < Processor > getProcessors ( ) { return processors ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processors ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processors ) ; } } 	0	['6', '2', '2', '6', '12', '0', '2', '4', '4', '0', '38', '1', '0', '0.736842105', '0.666666667', '1', '1', '5.166666667', '1', '0.8333', '0']
package org . apache . camel . impl . converter ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . Exchange ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . TypeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . TypeConverterAware ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class DefaultTypeConverter implements TypeConverter , TypeConverterRegistry { private static final transient Log LOG = LogFactory . getLog ( DefaultTypeConverter . class ) ; private final Map < TypeMapping , TypeConverter > typeMappings = new ConcurrentHashMap < TypeMapping , TypeConverter > ( ) ; private Injector injector ; private List < TypeConverterLoader > typeConverterLoaders = new ArrayList < TypeConverterLoader > ( ) ; private List < TypeConverter > fallbackConverters = new ArrayList < TypeConverter > ( ) ; private boolean loaded ; public DefaultTypeConverter ( Injector injector ) { typeConverterLoaders . add ( new AnnotationTypeConverterLoader ( ) ) ; this . injector = injector ; addFallbackConverter ( new AsyncProcessorTypeConverter ( ) ) ; addFallbackConverter ( new PropertyEditorTypeConverter ( ) ) ; addFallbackConverter ( new ToStringTypeConverter ( ) ) ; addFallbackConverter ( new ArrayTypeConverter ( ) ) ; addFallbackConverter ( new EnumTypeConverter ( ) ) ; } public List < TypeConverterLoader > getTypeConverterLoaders ( ) { return typeConverterLoaders ; } public < T > T convertTo ( Class < T > type , Object value ) { return convertTo ( type , null , value ) ; } @ SuppressWarnings ( "unchecked" ) public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Converting " + ( value == null ? "null" : value . getClass ( ) . getCanonicalName ( ) ) + " -> " + type . getCanonicalName ( ) + " with value: " + value ) ; } if ( value == null ) { if ( boolean . class . isAssignableFrom ( type ) ) { return ( T ) Boolean . FALSE ; } return null ; } if ( type . isInstance ( value ) ) { return type . cast ( value ) ; } checkLoaded ( ) ; TypeConverter converter = getOrFindTypeConverter ( type , value ) ; if ( converter != null ) { T rc = converter . convertTo ( type , exchange , value ) ; if ( rc != null ) { return rc ; } } for ( TypeConverter fallback : fallbackConverters ) { T rc = fallback . convertTo ( type , exchange , value ) ; if ( rc != null ) { return rc ; } } if ( type . isPrimitive ( ) ) { Class primitiveType = ObjectHelper . convertPrimitiveTypeToWrapperType ( type ) ; if ( primitiveType != type ) { return ( T ) convertTo ( primitiveType , exchange , value ) ; } } throw new NoTypeConversionAvailableException ( value , type ) ; } public void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) { TypeMapping key = new TypeMapping ( toType , fromType ) ; synchronized ( typeMappings ) { TypeConverter converter = typeMappings . get ( key ) ; if ( converter != null ) { LOG . warn ( "Overriding type converter from: " + converter + " to: " + typeConverter ) ; } typeMappings . put ( key , typeConverter ) ; } } public void addFallbackConverter ( TypeConverter converter ) { fallbackConverters . add ( converter ) ; if ( converter instanceof TypeConverterAware ) { TypeConverterAware typeConverterAware = ( TypeConverterAware ) converter ; typeConverterAware . setTypeConverter ( this ) ; } } public TypeConverter getTypeConverter ( Class toType , Class fromType ) { TypeMapping key = new TypeMapping ( toType , fromType ) ; return typeMappings . get ( key ) ; } public Injector getInjector ( ) { return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } protected < T > TypeConverter getOrFindTypeConverter ( Class toType , Object value ) { Class fromType = null ; if ( value != null ) { fromType = value . getClass ( ) ; } TypeMapping key = new TypeMapping ( toType , fromType ) ; TypeConverter converter ; synchronized ( typeMappings ) { converter = typeMappings . get ( key ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromType , value ) ; if ( converter != null ) { typeMappings . put ( key , converter ) ; } } } return converter ; } protected TypeConverter findTypeConverter ( Class toType , Class fromType , Object value ) { if ( fromType != null ) { Class fromSuperClass = fromType . getSuperclass ( ) ; if ( fromSuperClass != null && ! fromSuperClass . equals ( Object . class ) ) { TypeConverter converter = getTypeConverter ( toType , fromSuperClass ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromSuperClass , value ) ; } if ( converter != null ) { return converter ; } } for ( Class type : fromType . getInterfaces ( ) ) { TypeConverter converter = getTypeConverter ( toType , type ) ; if ( converter != null ) { return converter ; } } if ( fromType . isArray ( ) && ! fromType . getComponentType ( ) . isPrimitive ( ) ) { if ( ! fromType . equals ( Object [ ] . class ) ) { fromSuperClass = Object [ ] . class ; TypeConverter converter = getTypeConverter ( toType , fromSuperClass ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromSuperClass , value ) ; } if ( converter != null ) { return converter ; } } } if ( ! fromType . equals ( Object . class ) ) { TypeConverter converter = getTypeConverter ( toType , Object . class ) ; if ( converter != null ) { return converter ; } } } if ( fromType != null ) { Set < Map . Entry < TypeMapping , TypeConverter > > entries = typeMappings . entrySet ( ) ; for ( Map . Entry < TypeMapping , TypeConverter > entry : entries ) { TypeMapping key = entry . getKey ( ) ; Class aToType = key . getToType ( ) ; if ( toType . isAssignableFrom ( aToType ) ) { if ( key . getFromType ( ) . isAssignableFrom ( fromType ) ) { return entry . getValue ( ) ; } } } } return null ; } protected synchronized void checkLoaded ( ) { if ( ! loaded ) { loaded = true ; try { for ( TypeConverterLoader typeConverterLoader : typeConverterLoaders ) { typeConverterLoader . load ( this ) ; } try { loadFallbackTypeConverters ( ) ; } catch ( NoFactoryAvailableException e ) { } } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } } protected void loadFallbackTypeConverters ( ) throws IOException , ClassNotFoundException { FactoryFinder finder = new FactoryFinder ( ) ; List < TypeConverter > converters = finder . newInstances ( "FallbackTypeConverter" , getInjector ( ) , TypeConverter . class ) ; for ( TypeConverter converter : converters ) { addFallbackConverter ( converter ) ; } } protected static class TypeMapping { Class toType ; Class fromType ; public TypeMapping ( Class toType , Class fromType ) { this . toType = toType ; this . fromType = fromType ; } public Class getFromType ( ) { return fromType ; } public Class getToType ( ) { return toType ; } @ Override public boolean equals ( Object object ) { if ( object instanceof TypeMapping ) { TypeMapping that = ( TypeMapping ) object ; return ObjectHelper . equal ( this . fromType , that . fromType ) && ObjectHelper . equal ( this . toType , that . toType ) ; } return false ; } @ Override public int hashCode ( ) { int answer = toType . hashCode ( ) ; if ( fromType != null ) { answer *= 37 + fromType . hashCode ( ) ; } return answer ; } @ Override public String toString ( ) { return "[" + fromType + "=>" + toType + "]" ; } } } 	1	['14', '1', '0', '22', '63', '47', '2', '20', '9', '0.756410256', '519', '1', '1', '0', '0.358974359', '0', '0', '35.64285714', '17', '3.2143', '3']
package org . apache . camel . component . jmx ; import java . util . Map ; import javax . management . MBeanServer ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class JMXComponent extends DefaultComponent < JMXExchange > { private MBeanServer mbeanServer ; public JMXComponent ( ) { } public JMXComponent ( CamelContext context ) { super ( context ) ; } protected Endpoint < JMXExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { JMXEndpoint result = new JMXEndpoint ( remaining , this ) ; setProperties ( result , parameters ) ; result . setMbeanServer ( getMbeanServer ( ) ) ; return result ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	0	['5', '3', '0', '4', '10', '8', '1', '4', '4', '0.5', '36', '1', '0', '0.921052632', '0.36', '1', '2', '6', '1', '0.6', '0']
package org . apache . camel ; public interface AsyncProcessor extends Processor { boolean process ( Exchange exchange , AsyncCallback callback ) ; } 	1	['1', '1', '0', '34', '1', '0', '31', '3', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import static org . apache . camel . util . ObjectHelper . notNull ; public abstract class BinaryPredicateSupport < E extends Exchange > implements Predicate < E > { private final Expression < E > left ; private final Expression < E > right ; protected BinaryPredicateSupport ( Expression < E > left , Expression < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; this . left = left ; this . right = right ; } @ Override public String toString ( ) { return left + " " + getOperationText ( ) + " " + right ; } public boolean matches ( E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; return matches ( exchange , leftValue , rightValue ) ; } public void assertMatches ( String text , E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; if ( ! matches ( exchange , leftValue , rightValue ) ) { throw new AssertionError ( text + assertionFailureMessage ( exchange , leftValue , rightValue ) ) ; } } protected abstract boolean matches ( E exchange , Object leftValue , Object rightValue ) ; protected abstract String getOperationText ( ) ; protected String assertionFailureMessage ( E exchange , Object leftValue , Object rightValue ) { return this + " failed on " + exchange + " with left value <" + leftValue + "> right value <" + rightValue + ">" ; } } 	0	['9', '1', '7', '11', '17', '24', '7', '4', '5', '0.375', '125', '1', '2', '0', '0.444444444', '0', '0', '12.66666667', '2', '1', '0']
package org . apache . camel . processor . interceptor ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . InterceptStrategy ; public class Tracer implements InterceptStrategy { private TraceFormatter formatter = new TraceFormatter ( ) ; private boolean enabled = true ; private String logName ; private LoggingLevel logLevel ; private Predicate < Exchange > traceFilter ; private boolean traceInterceptors ; private boolean traceExceptions = true ; private boolean traceOutExchanges ; public static Tracer getTracer ( CamelContext context ) { if ( context instanceof DefaultCamelContext ) { DefaultCamelContext defaultCamelContext = ( DefaultCamelContext ) context ; List < InterceptStrategy > list = defaultCamelContext . getInterceptStrategies ( ) ; for ( InterceptStrategy interceptStrategy : list ) { if ( interceptStrategy instanceof Tracer ) { return ( Tracer ) interceptStrategy ; } } } return null ; } public Processor wrapProcessorInInterceptors ( ProcessorType processorType , Processor target ) throws Exception { String id = processorType . idOrCreate ( ) ; return new TraceInterceptor ( processorType , target , this ) ; } public TraceFormatter getFormatter ( ) { return formatter ; } public void setFormatter ( TraceFormatter formatter ) { this . formatter = formatter ; } public void setEnabled ( boolean flag ) { enabled = flag ; } public boolean isEnabled ( ) { return enabled ; } public boolean isTraceInterceptors ( ) { return traceInterceptors ; } public void setTraceInterceptors ( boolean traceInterceptors ) { this . traceInterceptors = traceInterceptors ; } public Predicate getTraceFilter ( ) { return traceFilter ; } public void setTraceFilter ( Predicate traceFilter ) { this . traceFilter = traceFilter ; } public LoggingLevel getLogLevel ( ) { return logLevel ; } public void setLogLevel ( LoggingLevel logLevel ) { this . logLevel = logLevel ; } public boolean isTraceExceptions ( ) { return traceExceptions ; } public void setTraceExceptions ( boolean traceExceptions ) { this . traceExceptions = traceExceptions ; } public String getLogName ( ) { return logName ; } public void setLogName ( String logName ) { this . logName = logName ; } public void setTraceOutExchanges ( boolean traceOutExchanges ) { this . traceOutExchanges = traceOutExchanges ; } public boolean isTraceOutExchanges ( ) { return traceOutExchanges ; } } 	1	['19', '1', '0', '11', '27', '143', '4', '9', '19', '0.923611111', '135', '1', '3', '0', '0.169590643', '0', '0', '5.684210526', '3', '1.0526', '3']
package org . apache . camel . processor . aggregate ; import org . apache . camel . Exchange ; public class UseLatestAggregationStrategy implements AggregationStrategy { public Exchange aggregate ( Exchange oldExchange , Exchange newExchange ) { newExchange . setException ( checkException ( oldExchange , newExchange ) ) ; return newExchange ; } protected Throwable checkException ( Exchange oldExchange , Exchange newExchange ) { return newExchange . getException ( ) != null ? newExchange . getException ( ) : oldExchange . getException ( ) ; } } 	0	['3', '1', '0', '6', '6', '3', '4', '2', '2', '2', '23', '0', '0', '0', '0.833333333', '0', '0', '6.666666667', '2', '1', '0']
package org . apache . camel . impl ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . ExchangeProperty ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . UnitOfWork ; import org . apache . camel . util . UuidGenerator ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class DefaultExchange implements Exchange { private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator ( ) ; protected final CamelContext context ; private Map < String , Object > properties ; private Message in ; private Message out ; private Message fault ; private Throwable exception ; private String exchangeId ; private UnitOfWork unitOfWork ; private ExchangePattern pattern ; public DefaultExchange ( CamelContext context ) { this ( context , ExchangePattern . InOnly ) ; } public DefaultExchange ( CamelContext context , ExchangePattern pattern ) { this . context = context ; this . pattern = pattern ; } public DefaultExchange ( DefaultExchange parent ) { this ( parent . getContext ( ) , parent . getPattern ( ) ) ; this . unitOfWork = parent . getUnitOfWork ( ) ; } @ Override public String toString ( ) { return "Exchange[" + in + "]" ; } public Exchange copy ( ) { Exchange exchange = newInstance ( ) ; exchange . copyFrom ( this ) ; return exchange ; } public void copyFrom ( Exchange exchange ) { if ( exchange == this ) { return ; } setProperties ( safeCopy ( exchange . getProperties ( ) ) ) ; safeCopy ( getIn ( ) , exchange , exchange . getIn ( ) ) ; Message copyOut = exchange . getOut ( false ) ; if ( copyOut != null ) { safeCopy ( getOut ( true ) , exchange , copyOut ) ; } Message copyFault = exchange . getFault ( false ) ; if ( copyFault != null ) { safeCopy ( getFault ( true ) , exchange , copyFault ) ; } setException ( exchange . getException ( ) ) ; unitOfWork = exchange . getUnitOfWork ( ) ; pattern = exchange . getPattern ( ) ; } private static void safeCopy ( Message message , Exchange exchange , Message that ) { if ( message != null ) { message . copyFrom ( that ) ; } } private static Map < String , Object > safeCopy ( Map < String , Object > properties ) { if ( properties == null ) { return null ; } return new ConcurrentHashMap < String , Object > ( properties ) ; } private static Message safeCopy ( Exchange exchange , Message message ) { if ( message == null ) { return null ; } Message answer = message . copy ( ) ; if ( answer instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) answer ; messageSupport . setExchange ( exchange ) ; } return answer ; } public Exchange newInstance ( ) { return new DefaultExchange ( this ) ; } public CamelContext getContext ( ) { return context ; } public Object getProperty ( String name ) { if ( properties != null ) { return properties . get ( name ) ; } return null ; } public < T > T getProperty ( String name , Class < T > type ) { Object value = getProperty ( name ) ; ExchangeProperty < ? > property = ExchangeProperty . getByName ( name ) ; if ( property != null ) { validateExchangePropertyIsExpectedType ( property , type , value ) ; } return getContext ( ) . getTypeConverter ( ) . convertTo ( type , this , value ) ; } public void setProperty ( String name , Object value ) { ExchangeProperty < ? > property = ExchangeProperty . getByName ( name ) ; if ( property != null ) { Class type = value . getClass ( ) ; validateExchangePropertyIsExpectedType ( property , type , value ) ; } if ( value != null ) { getProperties ( ) . put ( name , value ) ; } else { if ( name != null ) { getProperties ( ) . remove ( name ) ; } } } private < T > void validateExchangePropertyIsExpectedType ( ExchangeProperty < ? > property , Class < T > type , Object value ) { if ( value != null && property != null && ! property . type ( ) . isAssignableFrom ( type ) ) { throw new RuntimeCamelException ( "Type cast exception while getting an " + "Exchange Property value '" + value . toString ( ) + "' on Exchange " + this + " for a well known Exchange Property with these traits: " + property ) ; } } public Object removeProperty ( String name ) { return getProperties ( ) . remove ( name ) ; } public Map < String , Object > getProperties ( ) { if ( properties == null ) { properties = new ConcurrentHashMap < String , Object > ( ) ; } return properties ; } public void setProperties ( Map < String , Object > properties ) { this . properties = properties ; } public Message getIn ( ) { if ( in == null ) { in = createInMessage ( ) ; configureMessage ( in ) ; } return in ; } public void setIn ( Message in ) { this . in = in ; configureMessage ( in ) ; } public Message getOut ( ) { return getOut ( true ) ; } public Message getOut ( boolean lazyCreate ) { if ( out == null && lazyCreate ) { out = createOutMessage ( ) ; configureMessage ( out ) ; } return out ; } public void setOut ( Message out ) { this . out = out ; configureMessage ( out ) ; } public Throwable getException ( ) { return exception ; } public void setException ( Throwable exception ) { this . exception = exception ; } public ExchangePattern getPattern ( ) { return pattern ; } public void setPattern ( ExchangePattern pattern ) { this . pattern = pattern ; } public void throwException ( ) throws Exception { if ( exception == null ) { return ; } if ( exception instanceof RuntimeException ) { throw ( RuntimeException ) exception ; } if ( exception instanceof Exception ) { throw ( Exception ) exception ; } throw wrapRuntimeCamelException ( exception ) ; } public Message getFault ( ) { return getFault ( true ) ; } public Message getFault ( boolean lazyCreate ) { if ( fault == null && lazyCreate ) { fault = createFaultMessage ( ) ; configureMessage ( fault ) ; } return fault ; } public void setFault ( Message fault ) { this . fault = fault ; configureMessage ( fault ) ; } public String getExchangeId ( ) { if ( exchangeId == null ) { exchangeId = DefaultExchange . DEFAULT_ID_GENERATOR . generateId ( ) ; } return exchangeId ; } public void setExchangeId ( String id ) { this . exchangeId = id ; } public boolean isFailed ( ) { Message faultMessage = getFault ( false ) ; if ( faultMessage != null ) { Object faultBody = faultMessage . getBody ( ) ; if ( faultBody != null ) { return true ; } } return getException ( ) != null ; } public boolean isTransacted ( ) { ExchangeProperty < ? > property = ExchangeProperty . get ( "transacted" ) ; return property != null && property . get ( this ) == Boolean . TRUE ; } public UnitOfWork getUnitOfWork ( ) { return unitOfWork ; } public void setUnitOfWork ( UnitOfWork unitOfWork ) { this . unitOfWork = unitOfWork ; } protected Message createInMessage ( ) { return new DefaultMessage ( ) ; } protected Message createOutMessage ( ) { return new DefaultMessage ( ) ; } protected Message createFaultMessage ( ) { return new DefaultMessage ( ) ; } protected void configureMessage ( Message message ) { if ( message instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) message ; messageSupport . setExchange ( this ) ; } } } 	1	['42', '1', '14', '28', '78', '809', '16', '12', '33', '0.909756098', '498', '1', '7', '0', '0.118466899', '0', '0', '10.61904762', '4', '1.5714', '17']
package org . apache . camel . component . mock ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . builder . ValueBuilder ; import static org . apache . camel . builder . ExpressionBuilder . bodyExpression ; import static org . apache . camel . builder . ExpressionBuilder . headerExpression ; import static org . apache . camel . builder . ExpressionBuilder . propertyExpression ; public abstract class AssertionClause implements Runnable { private List < Predicate < Exchange > > predicates = new ArrayList < Predicate < Exchange > > ( ) ; public AssertionClause predicate ( Predicate < Exchange > predicate ) { addPredicate ( predicate ) ; return this ; } public ExpressionClause < AssertionClause > predicate ( ) { ExpressionClause < AssertionClause > clause = new ExpressionClause < AssertionClause > ( this ) ; addPredicate ( clause ) ; return clause ; } public ValueBuilder < Exchange > header ( String name ) { Expression < Exchange > expression = headerExpression ( name ) ; return new PredicateValueBuilder ( expression ) ; } public ValueBuilder < Exchange > property ( String name ) { Expression < Exchange > expression = propertyExpression ( name ) ; return new PredicateValueBuilder ( expression ) ; } public PredicateValueBuilder body ( ) { Expression < Exchange > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } public < T > PredicateValueBuilder bodyAs ( Class < T > type ) { Expression < Exchange > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } public PredicateValueBuilder outBody ( ) { Expression < Exchange > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } public < T > PredicateValueBuilder outBody ( Class < T > type ) { Expression < Exchange > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } protected void applyAssertionOn ( MockEndpoint endpoint , int index , Exchange exchange ) { for ( Predicate < Exchange > predicate : predicates ) { predicate . assertMatches ( endpoint . getEndpointUri ( ) + " " , exchange ) ; } } protected void addPredicate ( Predicate < Exchange > predicate ) { predicates . add ( predicate ) ; } public class PredicateValueBuilder extends ValueBuilder < Exchange > { public PredicateValueBuilder ( Expression < Exchange > expression ) { super ( expression ) ; } protected Predicate < Exchange > onNewPredicate ( Predicate < Exchange > predicate ) { addPredicate ( predicate ) ; return predicate ; } } } 	0	['11', '1', '2', '10', '28', '49', '4', '8', '9', '0.6', '118', '1', '0', '0', '0.25974026', '0', '0', '9.636363636', '2', '1', '0']
package org . apache . camel . util ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import org . w3c . dom . NodeList ; public final class CollectionHelper { private CollectionHelper ( ) { } public static Integer size ( Object value ) { if ( value != null ) { if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . size ( ) ; } else if ( value instanceof Map ) { Map map = ( Map ) value ; return map . size ( ) ; } else if ( value instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) value ; return array . length ; } else if ( value . getClass ( ) . isArray ( ) ) { return Array . getLength ( value ) ; } else if ( value instanceof NodeList ) { NodeList nodeList = ( NodeList ) value ; return nodeList . getLength ( ) ; } } return null ; } public static void appendValue ( Map map , Object key , Object value ) { Object oldValue = map . get ( key ) ; if ( oldValue != null ) { List list ; if ( oldValue instanceof List ) { list = ( List ) oldValue ; } else { list = new ArrayList ( ) ; list . add ( oldValue ) ; } list . add ( value ) ; } else { map . put ( key , value ) ; } } public static List filterList ( List list , Object ... filters ) { List answer = new ArrayList ( ) ; for ( Object o : list ) { for ( Object filter : filters ) { if ( ! o . getClass ( ) . isInstance ( filter ) ) { answer . add ( o ) ; } } } return answer ; } } 	1	['4', '1', '0', '3', '20', '6', '3', '0', '3', '2', '133', '0', '0', '0', '0.3', '0', '0', '32.25', '7', '3.25', '1']
package org . apache . camel . component . cxf . util ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; public final class UriUtils { private UriUtils ( ) { } static URL getWsdlUrl ( final URI uri ) throws MalformedURLException { URL wsdlUrl = null ; if ( uri . getScheme ( ) . equals ( CxfConstants . PROTOCOL_NAME_RES ) ) { if ( uri . getPath ( ) != null ) { String path = uri . isAbsolute ( ) ? getRelativePath ( uri ) : uri . getPath ( ) ; wsdlUrl = ClassLoaderUtils . getResource ( path , UriUtils . class ) ; } } else { wsdlUrl = new URL ( uri . getScheme ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) ) ; } return wsdlUrl ; } private static String getRelativePath ( URI uri ) { URI base = null ; try { base = new URI ( CxfConstants . PROTOCOL_NAME_RES , "" , "/" , "" ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } return base . relativize ( uri ) . getPath ( ) ; } } 	0	['3', '1', '0', '2', '15', '3', '1', '1', '0', '2', '63', '0', '0', '0', '0.5', '0', '0', '20', '1', '0.6667', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "flatpack" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FlatpackDataFormat extends DataFormatType { public FlatpackDataFormat ( ) { super ( "org.apache.camel.component.flatpack.FlatpackDataFormat" ) ; } } 	1	['1', '3', '0', '1', '2', '0', '0', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . camel . builder . xml ; import javax . xml . transform . Result ; import org . apache . camel . Message ; public interface ResultHandler { Result getResult ( ) ; void setBody ( Message in ) ; } 	0	['2', '1', '0', '9', '2', '1', '8', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model . loadbalancer ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "roundRobin" ) public class RoundRobinLoadBalanceStrategy extends LoadBalancerType { @ Override protected LoadBalancer createLoadBalancer ( RouteContext routeContext ) { return new org . apache . camel . processor . loadbalancer . RoundRobinLoadBalancer ( ) ; } } 	1	['2', '3', '0', '4', '4', '1', '0', '4', '1', '2', '9', '0', '0', '0.923076923', '0.75', '1', '1', '3.5', '1', '0.5', '1']
package org . apache . camel . component . jhc ; import java . io . IOException ; import org . apache . http . HttpException ; import org . apache . http . HttpResponse ; public interface AsyncResponseHandler { void sendResponse ( HttpResponse response ) throws IOException , HttpException ; } 	0	['1', '1', '0', '7', '1', '0', '5', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . dataset ; import java . util . concurrent . atomic . AtomicInteger ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . component . mock . MockEndpoint ; import org . apache . camel . impl . EventDrivenPollingConsumer ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DataSetEndpoint extends MockEndpoint implements Service { private static final transient Log LOG = LogFactory . getLog ( DataSetEndpoint . class ) ; private DataSet dataSet ; private AtomicInteger receivedCounter = new AtomicInteger ( ) ; private long produceDelay = - 1 ; private long consumeDelay = - 1 ; private long startTime ; private long preloadSize ; public DataSetEndpoint ( String endpointUri , Component component , DataSet dataSet ) { super ( endpointUri , component ) ; this . dataSet = dataSet ; } public DataSetEndpoint ( String endpointUri , DataSet dataSet ) { super ( endpointUri ) ; this . dataSet = dataSet ; } public static void assertEquals ( String description , Object expected , Object actual , Exchange exchange ) { if ( ! ObjectHelper . equal ( expected , actual ) ) { throw new AssertionError ( description + " does not match. Expected: " + expected + " but was: " + actual + " on " + exchange + " with headers: " + exchange . getIn ( ) . getHeaders ( ) ) ; } } @ Override public PollingConsumer < Exchange > createPollingConsumer ( ) throws Exception { return new EventDrivenPollingConsumer < Exchange > ( this ) ; } @ Override public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { return new DataSetConsumer ( this , processor ) ; } @ Override public void reset ( ) { super . reset ( ) ; receivedCounter . set ( 0 ) ; } @ Override public int getReceivedCounter ( ) { return receivedCounter . get ( ) ; } public Exchange createExchange ( long messageIndex ) throws Exception { Exchange exchange = createExchange ( ) ; getDataSet ( ) . populateMessage ( exchange , messageIndex ) ; Message in = exchange . getIn ( ) ; in . setHeader ( DataSet . INDEX_HEADER , messageIndex ) ; return exchange ; } @ Override protected void waitForCompleteLatch ( ) throws InterruptedException { long size = getDataSet ( ) . getSize ( ) ; size *= 4000 ; setResultWaitTime ( size ) ; super . waitForCompleteLatch ( ) ; } public DataSet getDataSet ( ) { return dataSet ; } public void setDataSet ( DataSet dataSet ) { this . dataSet = dataSet ; } public long getPreloadSize ( ) { return preloadSize ; } public void setPreloadSize ( long preloadSize ) { this . preloadSize = preloadSize ; } public long getConsumeDelay ( ) { return consumeDelay ; } public void setConsumeDelay ( long consumeDelay ) { this . consumeDelay = consumeDelay ; } public long getProduceDelay ( ) { return produceDelay ; } public void setProduceDelay ( long produceDelay ) { this . produceDelay = produceDelay ; } @ Override protected void performAssertions ( Exchange actual ) throws Exception { if ( startTime == 0 ) { startTime = System . currentTimeMillis ( ) ; } int receivedCount = receivedCounter . incrementAndGet ( ) ; long index = receivedCount - 1 ; Exchange expected = createExchange ( index ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Received message: " + index + " = " + actual ) ; } assertMessageExpected ( index , expected , actual ) ; if ( consumeDelay > 0 ) { Thread . sleep ( consumeDelay ) ; } long group = getDataSet ( ) . getReportCount ( ) ; if ( receivedCount % group == 0 ) { reportProgress ( actual , receivedCount ) ; } } protected void reportProgress ( Exchange actual , int receivedCount ) { long time = System . currentTimeMillis ( ) ; long elapsed = time - startTime ; startTime = time ; LOG . info ( "Received: " + receivedCount + " messages so far. Last group took: " + elapsed + " millis" ) ; } protected void assertMessageExpected ( long index , Exchange expected , Exchange actual ) throws Exception { long actualCounter = ExchangeHelper . getMandatoryHeader ( actual , DataSet . INDEX_HEADER , Long . class ) ; assertEquals ( "Header: " + DataSet . INDEX_HEADER , index , actualCounter , actual ) ; getDataSet ( ) . assertMessageExpected ( this , expected , actual , index ) ; } public void start ( ) throws Exception { long size = getDataSet ( ) . getSize ( ) ; expectedMessageCount ( ( int ) size ) ; } public void stop ( ) throws Exception { } } 	1	['23', '3', '0', '18', '60', '191', '4', '16', '18', '0.850649351', '312', '1', '1', '0.814814815', '0.202020202', '1', '5', '12.26086957', '2', '0.913', '2']
package org . apache . camel . component . cxf . transport . spring ; import org . apache . camel . component . cxf . transport . CamelDestination ; public class CamelDestinationDefinitionParser extends AbstractCamelContextBeanDefinitionParser { public CamelDestinationDefinitionParser ( ) { super ( ) ; setBeanClass ( CamelDestination . class ) ; } } 	0	['1', '1', '0', '2', '3', '0', '1', '1', '1', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . camel . processor . exceptionpolicy ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . camel . model . ExceptionType ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultExceptionPolicyStrategy implements ExceptionPolicyStrategy { private static final transient Log LOG = LogFactory . getLog ( DefaultExceptionPolicyStrategy . class ) ; public ExceptionType getExceptionPolicy ( Map < ExceptionPolicyKey , ExceptionType > exceptionPolicices , Exchange exchange , Throwable exception ) { Iterator < Throwable > it = createExceptionIterator ( exception ) ; while ( it . hasNext ( ) ) { ExceptionType type = findMatchedExceptionPolicy ( exceptionPolicices , exchange , it . next ( ) ) ; if ( type != null ) { return type ; } } return null ; } private ExceptionType findMatchedExceptionPolicy ( Map < ExceptionPolicyKey , ExceptionType > exceptionPolicices , Exchange exchange , Throwable exception ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Finding best suited exception policy for thrown exception " + exception . getClass ( ) . getName ( ) ) ; } int targetLevel = getInheritanceLevel ( exception . getClass ( ) ) ; ExceptionType candidate = null ; int candidateDiff = Integer . MAX_VALUE ; Set < Map . Entry < ExceptionPolicyKey , ExceptionType > > entries = exceptionPolicices . entrySet ( ) ; for ( Map . Entry < ExceptionPolicyKey , ExceptionType > entry : entries ) { Class clazz = entry . getKey ( ) . getExceptionClass ( ) ; ExceptionType type = entry . getValue ( ) ; if ( filter ( type , clazz , exception ) ) { if ( ! matchesWhen ( type , exchange ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "The type did not match when: " + type ) ; } continue ; } if ( clazz . equals ( exception . getClass ( ) ) ) { candidate = type ; break ; } int level = getInheritanceLevel ( clazz ) ; int diff = targetLevel - level ; if ( diff < candidateDiff ) { candidate = type ; candidateDiff = diff ; } } } if ( LOG . isDebugEnabled ( ) ) { if ( candidate != null ) { LOG . debug ( "Using " + candidate + " as the exception policy" ) ; } else { LOG . debug ( "No candidate found to be used as exception policy" ) ; } } return candidate ; } protected boolean filter ( ExceptionType type , Class exceptionClass , Throwable exception ) { return exceptionClass . isInstance ( exception ) ; } protected boolean matchesWhen ( ExceptionType type , Exchange exchange ) { if ( type . getOnWhen ( ) == null || type . getOnWhen ( ) . getExpression ( ) == null ) { return true ; } return type . getOnWhen ( ) . getExpression ( ) . matches ( exchange ) ; } protected Iterator < Throwable > createExceptionIterator ( Throwable exception ) { return new ExceptionIterator ( exception ) ; } private static int getInheritanceLevel ( Class clazz ) { if ( clazz == null || "java.lang.Object" . equals ( clazz . getName ( ) ) ) { return 0 ; } return 1 + getInheritanceLevel ( clazz . getSuperclass ( ) ) ; } private class ExceptionIterator implements Iterator < Throwable > { private List < Throwable > tree = new ArrayList < Throwable > ( ) ; private Iterator < Throwable > it ; public ExceptionIterator ( Throwable exception ) { Throwable current = exception ; while ( current != null ) { tree . add ( current ) ; current = current . getCause ( ) ; } Collections . reverse ( tree ) ; it = tree . iterator ( ) ; } public boolean hasNext ( ) { return it . hasNext ( ) ; } public Throwable next ( ) { return it . next ( ) ; } public void remove ( ) { it . remove ( ) ; } } } 	1	['8', '1', '0', '10', '33', '26', '2', '9', '2', '0.714285714', '194', '1', '0', '0', '0.452380952', '0', '0', '23.125', '8', '2.25', '2']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . util . CamelContextHelper ; public class ConstantBeanHolder implements BeanHolder { private final Object bean ; private Processor processor ; private BeanInfo beanInfo ; public ConstantBeanHolder ( Object bean , BeanInfo beanInfo ) { this . bean = bean ; this . beanInfo = beanInfo ; try { this . processor = CamelContextHelper . convertTo ( beanInfo . getCamelContext ( ) , Processor . class , bean ) ; } catch ( NoTypeConversionAvailableException ex ) { this . processor = null ; } } public ConstantBeanHolder ( Object bean , CamelContext context ) { this ( bean , new BeanInfo ( context , bean . getClass ( ) ) ) ; } public ConstantBeanHolder ( Object bean , CamelContext context , ParameterMappingStrategy parameterMappingStrategy ) { this ( bean , new BeanInfo ( context , bean . getClass ( ) , parameterMappingStrategy ) ) ; } @ Override public String toString ( ) { return bean . toString ( ) ; } public Object getBean ( ) { return bean ; } public Processor getProcessor ( ) { return processor ; } public BeanInfo getBeanInfo ( ) { return beanInfo ; } } 	0	['7', '1', '0', '11', '14', '11', '4', '7', '7', '0.444444444', '66', '1', '2', '0', '0.4', '0', '0', '8', '1', '0.5714', '0']
package org . apache . camel . management ; import java . util . Map ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . ErrorHandlerWrappingStrategy ; import org . apache . camel . spi . RouteContext ; public class InstrumentationErrorHandlerWrappingStrategy implements ErrorHandlerWrappingStrategy { private Map < ProcessorType , PerformanceCounter > counterMap ; public InstrumentationErrorHandlerWrappingStrategy ( Map < ProcessorType , PerformanceCounter > counterMap ) { this . counterMap = counterMap ; } public Processor wrapProcessorInErrorHandler ( RouteContext routeContext , ProcessorType processorType , Processor target ) throws Exception { if ( counterMap . containsKey ( processorType ) ) { return processorType . getErrorHandlerBuilder ( ) . createErrorHandler ( routeContext , target ) ; } return target ; } } 	1	['2', '1', '0', '6', '6', '0', '1', '5', '2', '0', '22', '1', '0', '0', '0.6', '0', '0', '9.5', '1', '0.5', '2']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Producer ; public abstract class DefaultProducer < E extends Exchange > extends ServiceSupport implements Producer < E > { private Endpoint < E > endpoint ; public DefaultProducer ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } @ Override public String toString ( ) { return "Producer[" + endpoint . getEndpointUri ( ) + "]" ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public E createExchange ( ) { return endpoint . createExchange ( ) ; } public E createExchange ( ExchangePattern pattern ) { return endpoint . createExchange ( pattern ) ; } public E createExchange ( E exchange ) { return endpoint . createExchange ( exchange ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	0	['8', '2', '27', '32', '16', '0', '27', '5', '6', '0.285714286', '47', '1', '1', '0.666666667', '0.34375', '1', '1', '4.75', '1', '0.875', '0']
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . io . StringWriter ; import java . lang . reflect . Constructor ; import java . nio . ByteBuffer ; import java . util . Properties ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . apache . camel . Converter ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . converter . NIOConverter ; import org . apache . camel . util . ObjectHelper ; @ Converter public class XmlConverter { public static final String DEFAULT_CHARSET_PROPERTY = "org.apache.camel.default.charset" ; public static String defaultCharset = ObjectHelper . getSystemProperty ( DEFAULT_CHARSET_PROPERTY , "UTF-8" ) ; private static final Class DOM_TO_SAX_CLASS ; private DocumentBuilderFactory documentBuilderFactory ; private TransformerFactory transformerFactory ; static { Class cl = null ; try { cl = Class . forName ( "org.apache.xalan.xsltc.trax.DOM2SAX" ) ; } catch ( Throwable t ) { } DOM_TO_SAX_CLASS = cl ; } public XmlConverter ( ) { } public XmlConverter ( DocumentBuilderFactory documentBuilderFactory ) { this . documentBuilderFactory = documentBuilderFactory ; } public Properties defaultOutputProperties ( ) { Properties properties = new Properties ( ) ; properties . put ( OutputKeys . ENCODING , defaultCharset ) ; properties . put ( OutputKeys . OMIT_XML_DECLARATION , "yes" ) ; return properties ; } public void toResult ( Source source , Result result ) throws TransformerException { toResult ( source , result , defaultOutputProperties ( ) ) ; } public void toResult ( Source source , Result result , Properties outputProperties ) throws TransformerException { if ( source == null ) { return ; } Transformer transformer = createTransfomer ( ) ; if ( transformer == null ) { throw new TransformerException ( "Could not create a transformer - JAXP is misconfigured!" ) ; } transformer . setOutputProperties ( outputProperties ) ; transformer . transform ( source , result ) ; } @ Converter public BytesSource toSource ( byte [ ] data ) { return new BytesSource ( data ) ; } @ Converter public StringSource toSource ( String data ) { return new StringSource ( data ) ; } @ Converter public DOMSource toSource ( Document document ) { return new DOMSource ( document ) ; } @ Converter public Source toSource ( Node node ) { return new DOMSource ( node ) ; } @ Converter public String toString ( Source source ) throws TransformerException { if ( source == null ) { return null ; } else if ( source instanceof StringSource ) { return ( ( StringSource ) source ) . getText ( ) ; } else if ( source instanceof BytesSource ) { return new String ( ( ( BytesSource ) source ) . getData ( ) ) ; } else { StringWriter buffer = new StringWriter ( ) ; toResult ( source , new StreamResult ( buffer ) ) ; return buffer . toString ( ) ; } } @ Converter public String toString ( Node node ) throws TransformerException { return toString ( new DOMSource ( node ) ) ; } @ Converter public DOMSource toDOMSource ( Source source ) throws ParserConfigurationException , IOException , SAXException , TransformerException { if ( source instanceof DOMSource ) { return ( DOMSource ) source ; } else if ( source instanceof SAXSource ) { return toDOMSourceFromSAX ( ( SAXSource ) source ) ; } else if ( source instanceof StreamSource ) { return toDOMSourceFromStream ( ( StreamSource ) source ) ; } else { return null ; } } @ Converter public DOMSource toDOMSource ( String text ) throws ParserConfigurationException , IOException , SAXException , TransformerException { Source source = toSource ( text ) ; if ( source != null ) { return toDOMSourceFromStream ( ( StreamSource ) source ) ; } else { return null ; } } @ Converter public SAXSource toSAXSource ( String source ) throws IOException , SAXException , TransformerException { return toSAXSource ( toSource ( source ) ) ; } @ Converter public SAXSource toSAXSource ( InputStream source ) throws IOException , SAXException , TransformerException { return toSAXSource ( toStreamSource ( source ) ) ; } @ Converter public SAXSource toSAXSource ( Source source ) throws IOException , SAXException , TransformerException { if ( source instanceof SAXSource ) { return ( SAXSource ) source ; } else if ( source instanceof DOMSource ) { return toSAXSourceFromDOM ( ( DOMSource ) source ) ; } else if ( source instanceof StreamSource ) { return toSAXSourceFromStream ( ( StreamSource ) source ) ; } else { return null ; } } @ Converter public StreamSource toStreamSource ( Source source ) throws TransformerException { if ( source instanceof StreamSource ) { return ( StreamSource ) source ; } else if ( source instanceof DOMSource ) { return toStreamSourceFromDOM ( ( DOMSource ) source ) ; } else if ( source instanceof SAXSource ) { return toStreamSourceFromSAX ( ( SAXSource ) source ) ; } else { return null ; } } @ Converter public StreamSource toStreamSource ( InputStream in ) throws TransformerException { if ( in != null ) { return new StreamSource ( in ) ; } return null ; } @ Converter public StreamSource toStreamSource ( Reader in ) throws TransformerException { if ( in != null ) { return new StreamSource ( in ) ; } return null ; } @ Converter public StreamSource toStreamSource ( File in ) throws TransformerException { if ( in != null ) { return new StreamSource ( in ) ; } return null ; } @ Converter public StreamSource toStreamSource ( byte [ ] in ) throws TransformerException { if ( in != null ) { return new StreamSource ( IOConverter . toInputStream ( in ) ) ; } return null ; } @ Converter public StreamSource toStreamSource ( ByteBuffer in ) throws TransformerException { if ( in != null ) { return new StreamSource ( NIOConverter . toInputStream ( in ) ) ; } return null ; } @ Converter public StreamSource toStreamSourceFromSAX ( SAXSource source ) throws TransformerException { InputSource inputSource = source . getInputSource ( ) ; if ( inputSource != null ) { if ( inputSource . getCharacterStream ( ) != null ) { return new StreamSource ( inputSource . getCharacterStream ( ) ) ; } if ( inputSource . getByteStream ( ) != null ) { return new StreamSource ( inputSource . getByteStream ( ) ) ; } } String result = toString ( source ) ; return new StringSource ( result ) ; } @ Converter public StreamSource toStreamSourceFromDOM ( DOMSource source ) throws TransformerException { String result = toString ( source ) ; return new StringSource ( result ) ; } @ Converter public SAXSource toSAXSourceFromStream ( StreamSource source ) { InputSource inputSource ; if ( source . getReader ( ) != null ) { inputSource = new InputSource ( source . getReader ( ) ) ; } else { inputSource = new InputSource ( source . getInputStream ( ) ) ; } inputSource . setSystemId ( source . getSystemId ( ) ) ; inputSource . setPublicId ( source . getPublicId ( ) ) ; return new SAXSource ( inputSource ) ; } @ Converter public Reader toReaderFromSource ( Source src ) throws TransformerException { StreamSource stSrc = toStreamSource ( src ) ; Reader r = stSrc . getReader ( ) ; if ( r == null ) { r = new InputStreamReader ( stSrc . getInputStream ( ) ) ; } return r ; } @ Converter public DOMSource toDOMSourceFromStream ( StreamSource source ) throws ParserConfigurationException , IOException , SAXException { DocumentBuilder builder = createDocumentBuilder ( ) ; String systemId = source . getSystemId ( ) ; Document document = null ; Reader reader = source . getReader ( ) ; if ( reader != null ) { document = builder . parse ( new InputSource ( reader ) ) ; } else { InputStream inputStream = source . getInputStream ( ) ; if ( inputStream != null ) { InputSource inputsource = new InputSource ( inputStream ) ; inputsource . setSystemId ( systemId ) ; document = builder . parse ( inputsource ) ; } else { throw new IOException ( "No input stream or reader available" ) ; } } return new DOMSource ( document , systemId ) ; } @ Converter public SAXSource toSAXSourceFromDOM ( DOMSource source ) throws TransformerException { if ( DOM_TO_SAX_CLASS != null ) { try { Constructor cns = DOM_TO_SAX_CLASS . getConstructor ( Node . class ) ; XMLReader converter = ( XMLReader ) cns . newInstance ( source . getNode ( ) ) ; return new SAXSource ( converter , new InputSource ( ) ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } else { String str = toString ( source ) ; StringReader reader = new StringReader ( str ) ; return new SAXSource ( new InputSource ( reader ) ) ; } } @ Converter public DOMSource toDOMSourceFromSAX ( SAXSource source ) throws IOException , SAXException , ParserConfigurationException , TransformerException { return new DOMSource ( toDOMNodeFromSAX ( source ) ) ; } @ Converter public Node toDOMNodeFromSAX ( SAXSource source ) throws ParserConfigurationException , IOException , SAXException , TransformerException { DOMResult result = new DOMResult ( ) ; toResult ( source , result ) ; return result . getNode ( ) ; } @ Converter public Node toDOMNode ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { DOMSource domSrc = toDOMSource ( source ) ; return domSrc != null ? domSrc . getNode ( ) : null ; } @ Converter public Element toDOMElement ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { Node node = toDOMNode ( source ) ; return toDOMElement ( node ) ; } @ Converter public Element toDOMElement ( Node node ) throws TransformerException { if ( node instanceof Document ) { return ( ( Document ) node ) . getDocumentElement ( ) ; } else if ( node instanceof Element ) { return ( Element ) node ; } else { throw new TransformerException ( "Unable to convert DOM node to an Element" ) ; } } @ Converter public Document toDOMDocument ( byte [ ] data ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( new ByteArrayInputStream ( data ) ) ; } @ Converter public Document toDOMDocument ( InputStream in ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( in ) ; } @ Converter public Document toDOMDocument ( Reader in ) throws IOException , SAXException , ParserConfigurationException { return toDOMDocument ( new InputSource ( in ) ) ; } @ Converter public Document toDOMDocument ( InputSource in ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( in ) ; } @ Converter public Document toDOMDocument ( String text ) throws IOException , SAXException , ParserConfigurationException { return toDOMDocument ( new StringReader ( text ) ) ; } @ Converter public Document toDOMDocument ( File file ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( file ) ; } @ Converter public Document toDOMDocument ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { Node node = toDOMNode ( source ) ; return toDOMDocument ( node ) ; } @ Converter public Document toDOMDocument ( Node node ) throws ParserConfigurationException , TransformerException { if ( node instanceof Document ) { return ( Document ) node ; } else if ( node instanceof Element ) { Element elem = ( Element ) node ; if ( elem . getOwnerDocument ( ) . getDocumentElement ( ) == elem ) { return elem . getOwnerDocument ( ) ; } else { Document doc = createDocument ( ) ; doc . appendChild ( doc . importNode ( node , true ) ) ; return doc ; } } else { throw new TransformerException ( "Unable to convert DOM node to a Document" ) ; } } public DocumentBuilderFactory getDocumentBuilderFactory ( ) { if ( documentBuilderFactory == null ) { documentBuilderFactory = createDocumentBuilderFactory ( ) ; } return documentBuilderFactory ; } public void setDocumentBuilderFactory ( DocumentBuilderFactory documentBuilderFactory ) { this . documentBuilderFactory = documentBuilderFactory ; } public DocumentBuilderFactory createDocumentBuilderFactory ( ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; factory . setIgnoringElementContentWhitespace ( true ) ; factory . setIgnoringComments ( true ) ; return factory ; } public DocumentBuilder createDocumentBuilder ( ) throws ParserConfigurationException { DocumentBuilderFactory factory = getDocumentBuilderFactory ( ) ; return factory . newDocumentBuilder ( ) ; } public Document createDocument ( ) throws ParserConfigurationException { DocumentBuilder builder = createDocumentBuilder ( ) ; return builder . newDocument ( ) ; } public TransformerFactory getTransformerFactory ( ) { if ( transformerFactory == null ) { transformerFactory = createTransformerFactory ( ) ; } return transformerFactory ; } public void setTransformerFactory ( TransformerFactory transformerFactory ) { this . transformerFactory = transformerFactory ; } public Transformer createTransfomer ( ) throws TransformerConfigurationException { TransformerFactory factory = getTransformerFactory ( ) ; return factory . newTransformer ( ) ; } public TransformerFactory createTransformerFactory ( ) { TransformerFactory answer = TransformerFactory . newInstance ( ) ; return answer ; } } 	1	['51', '1', '0', '15', '113', '1263', '11', '5', '50', '0.924', '731', '0.6', '0', '0', '0.104444444', '0', '0', '13.23529412', '2', '1', '3']
package org . apache . camel . component . restlet ; import java . io . IOException ; import org . apache . camel . Exchange ; import org . restlet . data . Request ; import org . restlet . data . Response ; public interface RestletBinding { void populateRestletResponseFromExchange ( Exchange exchange , Response response ) ; void populateExchangeFromRestletRequest ( Request request , Exchange exchange ) throws Exception ; void populateRestletRequestFromExchange ( Request request , Exchange exchange ) ; void populateExchangeFromRestletResponse ( Exchange exchange , Response response ) throws IOException ; } 	0	['4', '1', '0', '8', '4', '6', '5', '3', '4', '2', '4', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . Registry ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; import static org . apache . camel . util . ObjectHelper . notNull ; public final class CamelContextHelper { private CamelContextHelper ( ) { } public static Endpoint getMandatoryEndpoint ( CamelContext camelContext , String uri ) throws NoSuchEndpointException { Endpoint endpoint = camelContext . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } else { return endpoint ; } } public static String getEndpointKey ( String uri , Endpoint ep ) { return ep . isSingleton ( ) ? uri : ( "Ox" + Integer . toHexString ( ep . hashCode ( ) ) + ":" + uri ) ; } public static < T extends Endpoint > T getMandatoryEndpoint ( CamelContext camelContext , String uri , Class < T > type ) { Endpoint endpoint = getMandatoryEndpoint ( camelContext , uri ) ; return ObjectHelper . cast ( type , endpoint ) ; } public < T > List < T > getEndpoints ( CamelContext camelContext , Class < T > type ) { return getEndpointsImpl ( camelContext , type , false ) ; } public static < T > List < T > getSingletonEndpoints ( CamelContext camelContext , Class < T > type ) { return getEndpointsImpl ( camelContext , type , true ) ; } private static < T > List < T > getEndpointsImpl ( CamelContext camelContext , Class < T > type , boolean singleton ) { List < T > answer = new ArrayList < T > ( ) ; Collection < Endpoint > endpoints = singleton ? camelContext . getSingletonEndpoints ( ) : camelContext . getEndpoints ( ) ; for ( Endpoint endpoint : endpoints ) { if ( type . isInstance ( endpoint ) ) { T value = type . cast ( endpoint ) ; answer . add ( value ) ; } } return answer ; } public static < T > T convertTo ( CamelContext context , Class < T > type , Object value ) { notNull ( context , "camelContext" ) ; return context . getTypeConverter ( ) . convertTo ( type , value ) ; } public static < T > T mandatoryConvertTo ( CamelContext context , Class < T > type , Object value ) { T answer = convertTo ( context , type , value ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Value " + value + " converted to " + type . getName ( ) + " cannot be null" ) ; } return answer ; } public static < T > T newInstance ( CamelContext context , Class < T > beanType ) { return context . getInjector ( ) . newInstance ( beanType ) ; } public static Object lookup ( CamelContext context , String name ) { return context . getRegistry ( ) . lookup ( name ) ; } public static < T > T lookup ( CamelContext context , String name , Class < T > beanType ) { return context . getRegistry ( ) . lookup ( name , beanType ) ; } public static Object mandatoryLookup ( CamelContext context , String name ) { Object answer = lookup ( context , name ) ; notNull ( answer , "registry entry called " + name ) ; return answer ; } public static < T > T mandatoryLookup ( CamelContext context , String name , Class < T > beanType ) { T answer = lookup ( context , name , beanType ) ; notNull ( answer , "registry entry called " + name + " of type " + beanType . getName ( ) ) ; return answer ; } public static Language resolveMandatoryLanguage ( CamelContext camelContext , String languageName ) { notNull ( camelContext , "camelContext" ) ; notNull ( languageName , "languageName" ) ; Language language = camelContext . resolveLanguage ( languageName ) ; if ( language == null ) { throw new IllegalArgumentException ( "Could not resolve language: " + languageName ) ; } return language ; } public static Expression resolveMandatoryExpression ( CamelContext camelContext , String languageName , String expressionText ) { notNull ( expressionText , "expressionText" ) ; Language language = resolveMandatoryLanguage ( camelContext , languageName ) ; Expression < Exchange > expression = language . createExpression ( expressionText ) ; if ( expression == null ) { throw new IllegalArgumentException ( "Could not create expression: " + expressionText + " with language: " + language ) ; } return expression ; } public static Endpoint getEndpointInjection ( CamelContext camelContext , String uri , String name , String injectionPointName , boolean mandatory ) { Endpoint endpoint = null ; if ( isNotNullAndNonEmpty ( uri ) ) { endpoint = camelContext . getEndpoint ( uri ) ; } else { if ( isNullOrBlank ( name ) ) { name = injectionPointName ; } if ( mandatory ) { endpoint = mandatoryLookup ( camelContext , name , Endpoint . class ) ; } else { endpoint = lookup ( camelContext , name , Endpoint . class ) ; } } return endpoint ; } } 	1	['17', '1', '0', '30', '51', '136', '21', '9', '15', '2', '289', '0', '0', '0', '0.344537815', '0', '0', '16', '4', '1.4706', '1']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . Expression ; import org . apache . camel . component . file . FileExchange ; public class FileExpressionRenamer implements FileRenamer { private static final boolean ON_WINDOWS = System . getProperty ( "os.name" ) . startsWith ( "Windows" ) ; private Expression expression ; public File renameFile ( FileExchange exchange , File file ) { if ( expression == null ) { throw new IllegalArgumentException ( "Expression is not set" ) ; } File parent = file . getParentFile ( ) ; Object result = expression . evaluate ( exchange ) ; String name = exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , result ) ; if ( ON_WINDOWS && ( name . indexOf ( ":" ) >= 0 || name . startsWith ( "//" ) ) ) { return new File ( name ) ; } return new File ( parent , name ) ; } public Expression getExpression ( ) { return expression ; } public void setExpression ( Expression expression ) { this . expression = expression ; } } 	0	['5', '1', '0', '7', '17', '2', '1', '6', '4', '0.625', '68', '1', '1', '0', '0.4375', '0', '0', '12.2', '5', '1.4', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . language . bean . BeanExpression ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "methodCall" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MethodCallExpression extends ExpressionType { @ XmlAttribute ( required = false ) private String bean ; @ XmlAttribute ( required = false ) private String method ; public MethodCallExpression ( ) { } public MethodCallExpression ( String beanName ) { super ( beanName ) ; } public MethodCallExpression ( String beanName , String method ) { super ( beanName ) ; this . method = method ; } public String getLanguage ( ) { return "bean" ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } @ Override public Expression createExpression ( RouteContext routeContext ) { return new BeanExpression ( beanName ( ) , getMethod ( ) ) ; } @ Override public Predicate < Exchange > createPredicate ( RouteContext routeContext ) { return new BeanExpression < Exchange > ( beanName ( ) , getMethod ( ) ) ; } protected String beanName ( ) { if ( bean != null ) { return bean ; } return getExpression ( ) ; } } 	1	['9', '2', '0', '6', '13', '30', '1', '5', '8', '0.625', '59', '1', '0', '0.785714286', '0.518518519', '1', '4', '5.333333333', '2', '0.7778', '2']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . Route ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . DefaultRouteContext ; import org . apache . camel . processor . interceptor . StreamCachingInterceptor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . CamelContextHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlRootElement ( name = "route" ) @ XmlType ( propOrder = { "inputs" , "outputs" } ) @ XmlAccessorType ( XmlAccessType . PROPERTY ) public class RouteType extends ProcessorType < ProcessorType > implements CamelContextAware { private static final transient Log LOG = LogFactory . getLog ( RouteType . class ) ; private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; private List < FromType > inputs = new ArrayList < FromType > ( ) ; private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; private String group ; private CamelContext camelContext ; private Boolean streamCaching ; public RouteType ( ) { } public RouteType ( String uri ) { from ( uri ) ; } public RouteType ( Endpoint endpoint ) { from ( endpoint ) ; } @ Override public String toString ( ) { return "Route[" + inputs + " -> " + outputs + "]" ; } public void addRoutes ( CamelContext context , Collection < Route > routes ) throws Exception { setCamelContext ( context ) ; if ( context instanceof CamelContext ) { ErrorHandlerBuilder handler = context . getErrorHandlerBuilder ( ) ; if ( handler != null ) { setErrorHandlerBuilderIfNull ( handler ) ; } } for ( FromType fromType : inputs ) { addRoutes ( routes , fromType ) ; } } public Endpoint resolveEndpoint ( String uri ) throws NoSuchEndpointException { CamelContext context = getCamelContext ( ) ; if ( context == null ) { throw new IllegalArgumentException ( "No CamelContext has been injected!" ) ; } return CamelContextHelper . getMandatoryEndpoint ( context , uri ) ; } public RouteType from ( String uri ) { getInputs ( ) . add ( new FromType ( uri ) ) ; return this ; } public RouteType from ( Endpoint endpoint ) { getInputs ( ) . add ( new FromType ( endpoint ) ) ; return this ; } public RouteType group ( String name ) { setGroup ( name ) ; return this ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } @ XmlTransient public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < FromType > getInputs ( ) { return inputs ; } @ XmlElementRef public void setInputs ( List < FromType > inputs ) { this . inputs = inputs ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } @ XmlElementRef public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { configureChild ( output ) ; } } } public CamelContext getCamelContext ( ) { return camelContext ; } @ XmlTransient public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getGroup ( ) { return group ; } @ XmlAttribute public void setGroup ( String group ) { this . group = group ; } public Boolean getStreamCaching ( ) { return streamCaching ; } @ XmlAttribute ( required = false ) public void setStreamCaching ( Boolean streamCaching ) { this . streamCaching = streamCaching ; if ( streamCaching != null && streamCaching ) { streamCaching ( ) ; } else { noStreamCaching ( ) ; } } protected void addRoutes ( Collection < Route > routes , FromType fromType ) throws Exception { RouteContext routeContext = new DefaultRouteContext ( this , fromType , routes ) ; routeContext . getEndpoint ( ) ; if ( camelContext != null ) { camelContext . getLifecycleStrategy ( ) . onRouteContextCreate ( routeContext ) ; } List < ProcessorType < ? > > list = new ArrayList < ProcessorType < ? > > ( outputs ) ; for ( ProcessorType output : list ) { output . addRoutes ( routeContext , routes ) ; } routeContext . commit ( ) ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } List < InterceptorType > interceptors = getInterceptors ( ) ; for ( InterceptorType interceptor : interceptors ) { output . addInterceptor ( interceptor ) ; } } public RouteType noStreamCaching ( ) { StreamCachingInterceptor . noStreamCaching ( interceptors ) ; return this ; } public RouteType streamCaching ( ) { addInterceptor ( new StreamCachingInterceptor ( ) ) ; return this ; } @ Override public void addInterceptor ( InterceptorType interceptor ) { getInterceptors ( ) . add ( interceptor ) ; } } 	0	['27', '3', '0', '32', '60', '245', '19', '16', '24', '0.835164835', '345', '1', '1', '0.884422111', '0.169230769', '1', '6', '11.51851852', '3', '1.0741', '0']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . spi . ExceptionHandler ; public abstract class PollingConsumerSupport < E extends Exchange > extends ServiceSupport implements PollingConsumer < E > { private final Endpoint < E > endpoint ; private ExceptionHandler exceptionHandler ; public PollingConsumerSupport ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } @ Override public String toString ( ) { return "PullConsumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void handleException ( Throwable t ) { getExceptionHandler ( ) . handleException ( t ) ; } } 	1	['6', '2', '6', '11', '14', '7', '6', '5', '5', '0.6', '49', '1', '2', '0.736842105', '0.375', '0', '0', '6.833333333', '2', '1', '1']
package org . apache . camel . component . jms ; import javax . jms . Message ; import javax . jms . MessageListener ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . impl . DefaultProducerTemplate ; import org . apache . camel . impl . ProducerTemplateProcessor ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class CamelMessageListener implements MessageListener , Processor { private final CamelContext camelContext ; private final Processor processor ; private JmsBinding binding = new JmsBinding ( ) ; private ExchangePattern pattern = ExchangePattern . InOnly ; public CamelMessageListener ( CamelContext camelContext , Processor processor ) { this . camelContext = camelContext ; this . processor = processor ; ObjectHelper . notNull ( processor , "processor" ) ; } public static CamelMessageListener newInstance ( CamelContext camelContext , String endpointUri ) { DefaultProducerTemplate producerTemplate = DefaultProducerTemplate . newInstance ( camelContext , endpointUri ) ; return newInstance ( camelContext , producerTemplate ) ; } public static CamelMessageListener newInstance ( CamelContext camelContext , ProducerTemplate producerTemplate ) { return new CamelMessageListener ( camelContext , new ProducerTemplateProcessor ( producerTemplate ) ) ; } public void onMessage ( Message message ) { try { Exchange exchange = createExchange ( message ) ; process ( exchange ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } public void process ( Exchange exchange ) throws Exception { ObjectHelper . notNull ( exchange , "exchange" ) ; processor . process ( exchange ) ; } public JmsBinding getBinding ( ) { return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } public ExchangePattern getPattern ( ) { return pattern ; } public void setPattern ( ExchangePattern pattern ) { this . pattern = pattern ; } protected Exchange createExchange ( Message message ) { return new JmsExchange ( camelContext , pattern , binding , message ) ; } } 	0	['10', '1', '0', '11', '18', '21', '0', '11', '9', '0.555555556', '97', '1', '4', '0', '0.211111111', '0', '0', '8.3', '1', '0.9', '0']
package org . apache . camel . processor . aggregate ; import java . util . AbstractCollection ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultAggregationCollection extends AbstractCollection < Exchange > implements AggregationCollection { private static final transient Log LOG = LogFactory . getLog ( DefaultAggregationCollection . class ) ; private Expression < Exchange > correlationExpression ; private AggregationStrategy aggregationStrategy ; private Map < Object , Exchange > map = new LinkedHashMap < Object , Exchange > ( ) ; public DefaultAggregationCollection ( ) { } public DefaultAggregationCollection ( Expression < Exchange > correlationExpression , AggregationStrategy aggregationStrategy ) { this . correlationExpression = correlationExpression ; this . aggregationStrategy = aggregationStrategy ; } protected Map < Object , Exchange > getMap ( ) { return map ; } @ Override public boolean add ( Exchange exchange ) { Object correlationKey = correlationExpression . evaluate ( exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "evaluated expression: " + correlationExpression + " as CorrelationKey: " + correlationKey ) ; } Exchange oldExchange = map . get ( correlationKey ) ; Exchange newExchange = exchange ; if ( oldExchange != null ) { Integer count = oldExchange . getProperty ( Exchange . AGGREGATED_COUNT , Integer . class ) ; if ( count == null ) { count = 1 ; } count ++ ; newExchange = aggregationStrategy . aggregate ( oldExchange , newExchange ) ; newExchange . setProperty ( Exchange . AGGREGATED_COUNT , count ) ; } if ( newExchange != oldExchange ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "put exchange:" + newExchange + " for key:" + correlationKey ) ; } if ( oldExchange == null ) { newExchange . setProperty ( Exchange . AGGREGATED_COUNT , Integer . valueOf ( 1 ) ) ; } map . put ( correlationKey , newExchange ) ; } onAggregation ( correlationKey , newExchange ) ; return true ; } public Iterator < Exchange > iterator ( ) { return map . values ( ) . iterator ( ) ; } public int size ( ) { return map . size ( ) ; } @ Override public void clear ( ) { map . clear ( ) ; } public void onAggregation ( Object correlationKey , Exchange newExchange ) { } public Expression < Exchange > getCorrelationExpression ( ) { return correlationExpression ; } public void setCorrelationExpression ( Expression < Exchange > correlationExpression ) { this . correlationExpression = correlationExpression ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } public void setAggregationStrategy ( AggregationStrategy aggregationStrategy ) { this . aggregationStrategy = aggregationStrategy ; } } 	1	['14', '2', '1', '8', '35', '27', '2', '6', '12', '0.673076923', '185', '1', '2', '0.56', '0.323076923', '1', '5', '11.92857143', '7', '1.2143', '4']
package org . apache . camel . component . xmpp ; import java . util . Iterator ; import org . apache . camel . CamelException ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . AccountManager ; import org . jivesoftware . smack . ConnectionConfiguration ; import org . jivesoftware . smack . XMPPConnection ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smackx . muc . MultiUserChat ; public class XmppEndpoint extends DefaultEndpoint < XmppExchange > { private static final transient Log LOG = LogFactory . getLog ( XmppEndpoint . class ) ; private XmppBinding binding ; private XMPPConnection connection ; private String host ; private int port ; private String user ; private String password ; private String resource = "Camel" ; private boolean login = true ; private boolean createAccount ; private String room ; private String participant ; private String nickname ; private String serviceName ; public XmppEndpoint ( String uri , XmppComponent component ) { super ( uri , component ) ; binding = new XmppBinding ( component . getHeaderFilterStrategy ( ) ) ; } public XmppEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public Producer < XmppExchange > createProducer ( ) throws Exception { if ( room != null ) { return createGroupChatProducer ( ) ; } else { if ( participant == null ) { throw new IllegalArgumentException ( "No room or participant configured on this endpoint: " + this ) ; } return createPrivateChatProducer ( participant ) ; } } public Producer < XmppExchange > createGroupChatProducer ( ) throws Exception { return new XmppGroupChatProducer ( this ) ; } public Producer < XmppExchange > createPrivateChatProducer ( String participant ) throws Exception { return new XmppPrivateChatProducer ( this , participant ) ; } public Consumer < XmppExchange > createConsumer ( Processor processor ) throws Exception { return new XmppConsumer ( this , processor ) ; } @ Override public XmppExchange createExchange ( ExchangePattern pattern ) { return new XmppExchange ( getCamelContext ( ) , pattern , getBinding ( ) ) ; } public XmppExchange createExchange ( Message message ) { return new XmppExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , message ) ; } public XmppBinding getBinding ( ) { if ( binding == null ) { binding = new XmppBinding ( ) ; } return binding ; } public void setBinding ( XmppBinding binding ) { this . binding = binding ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } public String getUser ( ) { return user ; } public void setUser ( String user ) { this . user = user ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getResource ( ) { return resource ; } public void setResource ( String resource ) { this . resource = resource ; } public boolean isLogin ( ) { return login ; } public void setLogin ( boolean login ) { this . login = login ; } public boolean isCreateAccount ( ) { return createAccount ; } public void setCreateAccount ( boolean createAccount ) { this . createAccount = createAccount ; } public String getRoom ( ) { return room ; } public void setRoom ( String room ) { this . room = room ; } public String getParticipant ( ) { return participant ; } public void setParticipant ( String participant ) { this . participant = participant ; } public String getNickname ( ) { return nickname != null ? nickname : getUser ( ) ; } public void setNickname ( String nickname ) { this . nickname = nickname ; } public void setServiceName ( String serviceName ) { this . serviceName = serviceName ; } public String getServiceName ( ) { return serviceName ; } public XMPPConnection getConnection ( ) throws XMPPException { if ( connection == null ) { connection = createConnection ( ) ; } return connection ; } public void setConnection ( XMPPConnection connection ) { this . connection = connection ; } protected XMPPConnection createConnection ( ) throws XMPPException { XMPPConnection connection ; if ( port > 0 ) { if ( getServiceName ( ) == null ) { connection = new XMPPConnection ( new ConnectionConfiguration ( host , port ) ) ; } else { connection = new XMPPConnection ( new ConnectionConfiguration ( host , port , getServiceName ( ) ) ) ; } } else { connection = new XMPPConnection ( host ) ; } connection . connect ( ) ; if ( login && ! connection . isAuthenticated ( ) ) { if ( user != null ) { LOG . info ( "Logging in to XMPP as user: " + user + " on connection: " + connection ) ; if ( password == null ) { LOG . warn ( "No password configured for user: " + user ) ; } if ( createAccount ) { AccountManager accountManager = new AccountManager ( connection ) ; accountManager . createAccount ( user , password ) ; } if ( resource != null ) { connection . login ( user , password , resource ) ; } else { connection . login ( user , password ) ; } } else { LOG . info ( "Logging in anonymously to XMPP on connection: " + connection ) ; connection . loginAnonymously ( ) ; } } return connection ; } public String resolveRoom ( ) throws XMPPException , CamelException { if ( room == null ) { throw new IllegalArgumentException ( "room is not specified" ) ; } if ( room . indexOf ( '@' , 0 ) != - 1 ) { return room ; } XMPPConnection conn = getConnection ( ) ; Iterator < String > iterator = MultiUserChat . getServiceNames ( conn ) . iterator ( ) ; if ( ! iterator . hasNext ( ) ) { throw new CamelException ( "Can not find Multi User Chat service" ) ; } String chatServer = iterator . next ( ) ; if ( LOG . isInfoEnabled ( ) ) { LOG . info ( "Detected chat server: " + chatServer ) ; } return room + "@" + chatServer ; } public boolean isSingleton ( ) { return true ; } } 	0	['39', '2', '0', '24', '76', '641', '4', '24', '37', '0.904135338', '453', '1', '1', '0.4', '0.155263158', '1', '1', '10.25641026', '2', '0.9744', '0']
package org . apache . camel . management ; import java . net . InetAddress ; import java . net . UnknownHostException ; import javax . management . MalformedObjectNameException ; import javax . management . ObjectName ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Route ; import org . apache . camel . Service ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . RouteContext ; public class CamelNamingStrategy { public static final String VALUE_UNKNOWN = "unknown" ; public static final String KEY_NAME = "name" ; public static final String KEY_TYPE = "type" ; public static final String KEY_CONTEXT = "context" ; public static final String KEY_GROUP = "group" ; public static final String KEY_ROUTE = "route" ; public static final String KEY_NODE_ID = "nodeid" ; public static final String TYPE_CONTEXT = "context" ; public static final String TYPE_ENDPOINT = "endpoints" ; public static final String TYPE_PROCESSOR = "processors" ; public static final String TYPE_CONSUMER = "consumers" ; public static final String TYPE_ROUTE = "routes" ; protected String domainName ; protected String hostName = "locahost" ; public CamelNamingStrategy ( ) { this ( "org.apache.camel" ) ; } public CamelNamingStrategy ( String domainName ) { if ( domainName != null ) { this . domainName = domainName ; } try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException ex ) { } } public ObjectName getObjectName ( CamelContext context ) throws MalformedObjectNameException { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName ) . append ( ":" ) ; buffer . append ( KEY_CONTEXT + "=" ) . append ( getContextId ( context ) ) . append ( "," ) ; buffer . append ( KEY_NAME + "=" ) . append ( "context" ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( ManagedEndpoint mbean ) throws MalformedObjectNameException { Endpoint < ? extends Exchange > ep = mbean . getEndpoint ( ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName ) . append ( ":" ) ; buffer . append ( KEY_CONTEXT + "=" ) . append ( getContextId ( ep . getCamelContext ( ) ) ) . append ( "," ) ; buffer . append ( KEY_TYPE + "=" + TYPE_ENDPOINT + "," ) ; buffer . append ( KEY_NAME + "=" ) . append ( ObjectName . quote ( getEndpointId ( ep ) ) ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( CamelContext context , ManagedService mbean ) throws MalformedObjectNameException { String serviceBranch ; Service service = mbean . getService ( ) ; if ( service instanceof Consumer ) { serviceBranch = TYPE_CONSUMER ; } else { return null ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName ) . append ( ":" ) ; buffer . append ( KEY_CONTEXT + "=" ) . append ( getContextId ( context ) ) . append ( "," ) ; buffer . append ( KEY_TYPE + "=" + serviceBranch + "," ) ; buffer . append ( KEY_NAME + "=" ) . append ( service . getClass ( ) . getSimpleName ( ) ) . append ( "(0x" ) . append ( Integer . toHexString ( mbean . getService ( ) . hashCode ( ) ) ) . append ( ")" ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( ManagedRoute mbean ) throws MalformedObjectNameException { Route < ? extends Exchange > route = mbean . getRoute ( ) ; Endpoint < ? extends Exchange > ep = route . getEndpoint ( ) ; String id = ( String ) route . getProperties ( ) . get ( Route . ID_PROPERTY ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName ) . append ( ":" ) ; buffer . append ( KEY_CONTEXT + "=" ) . append ( getContextId ( ep . getCamelContext ( ) ) ) . append ( "," ) ; buffer . append ( KEY_TYPE + "=" + TYPE_ROUTE + "," ) ; buffer . append ( KEY_NAME + "=" ) . append ( ObjectName . quote ( id == null ? ( "0x" + Integer . toHexString ( route . hashCode ( ) ) ) : id ) ) ; return createObjectName ( buffer ) ; } public ObjectName getObjectName ( RouteContext routeContext , ProcessorType processor ) throws MalformedObjectNameException { Endpoint < ? extends Exchange > ep = routeContext . getEndpoint ( ) ; String ctxid = ep != null ? getContextId ( ep . getCamelContext ( ) ) : VALUE_UNKNOWN ; String cid = ObjectName . quote ( ep . getEndpointUri ( ) ) ; String nodeId = processor . idOrCreate ( ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( domainName ) . append ( ":" ) ; buffer . append ( KEY_CONTEXT + "=" ) . append ( ctxid ) . append ( "," ) ; buffer . append ( KEY_TYPE + "=" + TYPE_PROCESSOR + "," ) ; buffer . append ( KEY_NODE_ID + "=" ) . append ( nodeId ) . append ( "," ) ; buffer . append ( KEY_NAME + "=" ) . append ( ObjectName . quote ( processor . toString ( ) ) ) ; return createObjectName ( buffer ) ; } public String getDomainName ( ) { return domainName ; } public void setDomainName ( String domainName ) { this . domainName = domainName ; } public String getHostName ( ) { return hostName ; } public void setHostName ( String hostName ) { this . hostName = hostName ; } protected String getContextId ( CamelContext context ) { return hostName + "/" + ( context != null ? context . getName ( ) : VALUE_UNKNOWN ) ; } protected String getEndpointId ( Endpoint < ? extends Exchange > ep ) { String uri = ep . getEndpointUri ( ) ; int pos = uri . indexOf ( '?' ) ; String id = ( pos == - 1 ) ? uri : uri . substring ( 0 , pos ) ; id += "?id=0x" + Integer . toHexString ( ep . hashCode ( ) ) ; return id ; } protected ObjectName createObjectName ( StringBuffer buffer ) throws MalformedObjectNameException { String text = buffer . toString ( ) ; try { return new ObjectName ( text ) ; } catch ( MalformedObjectNameException e ) { throw new MalformedObjectNameException ( "Could not create ObjectName from: " + text + ". Reason: " + e ) ; } } } 	1	['14', '1', '0', '11', '45', '23', '1', '10', '11', '0.972527473', '400', '0.142857143', '0', '0', '0.192857143', '0', '0', '26.57142857', '2', '1', '2']
package org . apache . camel . component . spring . integration . adapter . config ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . camel . util . ObjectHelper ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . AbstractSingleBeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . StringUtils ; public class AbstractCamelContextBeanDefinitionParaser extends AbstractSingleBeanDefinitionParser { private static final String DEFAULT_CAMEL_CONTEXT_NAME = "camelContext" ; private String getContextId ( String contextId ) { if ( ObjectHelper . isNullOrBlank ( contextId ) ) { return DEFAULT_CAMEL_CONTEXT_NAME ; } else { return contextId ; } } protected void mapToProperty ( BeanDefinitionBuilder bean , String propertyName , String val ) { if ( ID_ATTRIBUTE . equals ( propertyName ) ) { return ; } if ( StringUtils . hasText ( val ) ) { if ( val . startsWith ( "#" ) ) { bean . addPropertyReference ( propertyName , val . substring ( 1 ) ) ; } else { bean . addPropertyValue ( propertyName , val ) ; } } } protected void wireCamelContext ( BeanDefinitionBuilder bean , String camelContextId ) { bean . addPropertyReference ( "camelContext" , camelContextId ) ; } protected void parseAttributes ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { NamedNodeMap atts = element . getAttributes ( ) ; for ( int i = 0 ; i < atts . getLength ( ) ; i ++ ) { Attr node = ( Attr ) atts . item ( i ) ; String val = node . getValue ( ) ; String name = node . getLocalName ( ) ; if ( name . equals ( "requestChannel" ) || name . equals ( "replyChannel" ) ) { bean . addPropertyReference ( name , val ) ; } else { mapToProperty ( bean , name , val ) ; } } } protected void parseCamelContext ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node n = children . item ( i ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { String name = n . getLocalName ( ) ; if ( "camelContext" . equals ( name ) ) { BeanDefinition bd = ctx . getDelegate ( ) . parseCustomElement ( ( Element ) n ) ; String contextId = ( String ) bd . getPropertyValues ( ) . getPropertyValue ( "id" ) . getValue ( ) ; wireCamelContext ( bean , getContextId ( contextId ) ) ; } else if ( "camelContextRef" . equals ( name ) ) { String contextId = n . getTextContent ( ) ; wireCamelContext ( bean , getContextId ( contextId ) ) ; } } } } protected void doParse ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { parseAttributes ( element , ctx , bean ) ; parseCamelContext ( element , ctx , bean ) ; } } 	0	['7', '0', '2', '11', '31', '21', '2', '9', '1', '1.166666667', '163', '1', '0', '0', '0.6', '0', '0', '22.14285714', '5', '2.4286', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . AsyncProcessorHelper ; public class HandleFaultProcessor extends DelegateProcessor implements AsyncProcessor { @ Override public String toString ( ) { return "HandleFaultProcessor(" + processor + ")" ; } @ Override public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( processor == null ) { callback . done ( true ) ; return true ; } if ( processor instanceof AsyncProcessor ) { return ( ( AsyncProcessor ) processor ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { Message faultMessage = exchange . getFault ( false ) ; if ( faultMessage != null ) { final Object faultBody = faultMessage . getBody ( ) ; if ( faultBody != null ) { faultMessage . setBody ( null ) ; if ( faultBody instanceof Throwable ) { exchange . setException ( ( Throwable ) faultBody ) ; } else { if ( exchange . getException ( ) == null ) { exchange . setException ( new CamelException ( "Message contains fault of type " + faultBody . getClass ( ) . getName ( ) + ":\n" + faultBody ) ) ; } } } } callback . done ( doneSynchronously ) ; } } ) ; } try { processor . process ( exchange ) ; } catch ( Throwable e ) { exchange . setException ( e ) ; } final Message faultMessage = exchange . getFault ( false ) ; if ( faultMessage != null ) { final Object faultBody = faultMessage . getBody ( ) ; if ( faultBody != null ) { faultMessage . setBody ( null ) ; if ( faultBody instanceof Throwable ) { exchange . setException ( ( Throwable ) faultBody ) ; } else { if ( exchange . getException ( ) == null ) { exchange . setException ( new CamelException ( "Message contains fault of type " + faultBody . getClass ( ) . getName ( ) + ":\n" + faultBody ) ) ; } } } } callback . done ( true ) ; return true ; } } 	1	['4', '3', '0', '10', '22', '4', '2', '9', '4', '2', '105', '0', '0', '0.88', '0.583333333', '0', '0', '25.25', '7', '2.25', '2']
package org . apache . camel . component . restlet ; import java . net . URI ; import java . util . Map ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . util . URISupport ; import org . apache . camel . util . UnsafeUriCharactersEncoder ; import org . restlet . data . Method ; public class RestletEndpoint extends DefaultEndpoint { private static final int DEFAULT_PORT = 80 ; private static final String DEFAULT_PROTOCOL = "http" ; private static final String DEFAULT_HOST = "localhost" ; private Method restletMethod = Method . GET ; private String protocol = DEFAULT_PROTOCOL ; private String host = DEFAULT_HOST ; private int port = DEFAULT_PORT ; private String uriPattern ; private RestletBinding restletBinding ; private Map < String , String > realm ; public RestletEndpoint ( RestletComponent component , String remaining , Map < String , String > parameters , RestletBinding restletBinding ) throws Exception { super ( remaining , component ) ; this . restletBinding = restletBinding ; URI u = new URI ( UnsafeUriCharactersEncoder . encode ( remaining ) ) ; protocol = u . getScheme ( ) ; uriPattern = u . getPath ( ) ; if ( parameters . size ( ) > 0 ) { uriPattern = uriPattern + "?" + URISupport . createQueryString ( parameters ) ; } host = u . getHost ( ) ; if ( u . getPort ( ) > 0 ) { port = u . getPort ( ) ; } } public boolean isSingleton ( ) { return true ; } @ Override public boolean isLenientProperties ( ) { return true ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new RestletConsumer ( this , processor ) ; } public Producer createProducer ( ) throws Exception { return new RestletProducer ( this ) ; } public void connect ( RestletConsumer restletConsumer ) throws Exception { ( ( RestletComponent ) getComponent ( ) ) . connect ( restletConsumer ) ; } public void disconnect ( RestletConsumer restletConsumer ) throws Exception { ( ( RestletComponent ) getComponent ( ) ) . disconnect ( restletConsumer ) ; } public String getProtocol ( ) { return protocol ; } public String getHost ( ) { return host ; } public int getPort ( ) { return port ; } public String getUriPattern ( ) { return uriPattern ; } public RestletBinding getRestletBinding ( ) { return restletBinding ; } public void setRestletMethod ( Method restletMethod ) { this . restletMethod = restletMethod ; } public Method getRestletMethod ( ) { return restletMethod ; } public void setRealm ( Map < String , String > realm ) { this . realm = realm ; } public Map < String , String > getRealm ( ) { return realm ; } } 	0	['16', '2', '0', '14', '33', '102', '4', '13', '16', '0.966666667', '144', '1', '1', '0.615384615', '0.1953125', '0', '0', '7.375', '1', '0.9375', '0']
package org . apache . camel ; import org . apache . camel . spi . Registry ; public class NoSuchBeanException extends RuntimeCamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final String name ; public NoSuchBeanException ( String name ) { super ( "No bean could be found in the registry for: " + name ) ; this . name = name ; } public String getName ( ) { return name ; } } 	1	['2', '5', '0', '2', '6', '0', '1', '1', '2', '1', '21', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '1']
package org . apache . camel . component . jhc ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; public class JhcHeaderFilterStrategy extends DefaultHeaderFilterStrategy { public JhcHeaderFilterStrategy ( ) { initialize ( ) ; } protected void initialize ( ) { getOutFilter ( ) . add ( "content-length" ) ; getOutFilter ( ) . add ( "content-type" ) ; getOutFilter ( ) . add ( JhcProducer . HTTP_RESPONSE_CODE ) ; setIsLowercase ( true ) ; setOutFilterPattern ( "(org\\.apache\\.camel)[\\.|a-z|A-z|0-9]*" ) ; } } 	0	['2', '2', '0', '3', '7', '1', '2', '1', '1', '2', '29', '0', '0', '0.941176471', '1', '0', '0', '13.5', '1', '0.5', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . Policy ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ServiceHelper ; public class DelegateAsyncProcessor extends ServiceSupport implements AsyncProcessor { protected AsyncProcessor processor ; public DelegateAsyncProcessor ( ) { } public DelegateAsyncProcessor ( AsyncProcessor processor ) { this . processor = processor ; } @ Override public String toString ( ) { return "DelegateAsync(" + processor + ")" ; } public AsyncProcessor getProcessor ( ) { return processor ; } public void setProcessor ( AsyncProcessor processor ) { this . processor = processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { return processor . process ( exchange , callback ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } } 	1	['9', '2', '1', '7', '18', '0', '1', '6', '7', '0.25', '66', '1', '1', '0.666666667', '0.388888889', '1', '1', '6.222222222', '1', '0.7778', '1']
package org . apache . camel . bam ; public enum ActivityLifecycle { Started , Completed } 	0	['4', '2', '0', '5', '7', '4', '4', '1', '2', '0.888888889', '45', '0.333333333', '3', '0.857142857', '0.444444444', '1', '1', '9.5', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelException ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . builder . DataFormatClause ; import org . apache . camel . builder . DeadLetterChannelBuilder ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . builder . ErrorHandlerBuilderRef ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . builder . NoErrorHandlerBuilder ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . language . ConstantExpression ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . model . language . LanguageExpression ; import org . apache . camel . processor . ConvertBodyProcessor ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . aggregate . AggregationCollection ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . idempotent . MessageIdRepository ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . ErrorHandlerWrappingStrategy ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . camel . spi . Policy ; import org . apache . camel . spi . RouteContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlAccessorType ( XmlAccessType . PROPERTY ) public abstract class ProcessorType < Type extends ProcessorType > extends OptionalIdentifiedType < Type > implements Block { public static final String DEFAULT_TRACE_CATEGORY = "org.apache.camel.TRACE" ; private static final transient Log LOG = LogFactory . getLog ( ProcessorType . class ) ; private ErrorHandlerBuilder errorHandlerBuilder ; private Boolean inheritErrorHandlerFlag ; private NodeFactory nodeFactory ; private LinkedList < Block > blocks = new LinkedList < Block > ( ) ; private ProcessorType < ? extends ProcessorType > parent ; private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; private String errorHandlerRef ; public abstract List < ProcessorType < ? > > getOutputs ( ) ; public Processor createProcessor ( RouteContext routeContext ) throws Exception { throw new UnsupportedOperationException ( "Not implemented yet for class: " + getClass ( ) . getName ( ) ) ; } public Processor createOutputsProcessor ( RouteContext routeContext ) throws Exception { Collection < ProcessorType < ? > > outputs = getOutputs ( ) ; return createOutputsProcessor ( routeContext , outputs ) ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { Processor processor = makeProcessor ( routeContext ) ; if ( ! routeContext . isRouteAdded ( ) ) { routeContext . addEventDrivenProcessor ( processor ) ; } } public Processor wrapProcessor ( RouteContext routeContext , Processor processor ) throws Exception { processor = wrapProcessorInInterceptors ( routeContext , processor ) ; return wrapInErrorHandler ( routeContext , processor ) ; } public Type to ( String uri ) { addOutput ( new ToType ( uri ) ) ; return ( Type ) this ; } public Type to ( Endpoint endpoint ) { addOutput ( new ToType ( endpoint ) ) ; return ( Type ) this ; } public Type to ( ExchangePattern pattern , String uri ) { addOutput ( new ToType ( uri , pattern ) ) ; return ( Type ) this ; } public Type to ( ExchangePattern pattern , Endpoint endpoint ) { addOutput ( new ToType ( endpoint , pattern ) ) ; return ( Type ) this ; } public Type to ( String ... uris ) { for ( String uri : uris ) { addOutput ( new ToType ( uri ) ) ; } return ( Type ) this ; } public Type to ( Endpoint ... endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint ) ) ; } return ( Type ) this ; } public Type to ( Iterable < Endpoint > endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint ) ) ; } return ( Type ) this ; } public Type to ( ExchangePattern pattern , String ... uris ) { for ( String uri : uris ) { addOutput ( new ToType ( uri , pattern ) ) ; } return ( Type ) this ; } public Type to ( ExchangePattern pattern , Endpoint ... endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint , pattern ) ) ; } return ( Type ) this ; } public Type to ( ExchangePattern pattern , Iterable < Endpoint > endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint , pattern ) ) ; } return ( Type ) this ; } public Type setExchangePattern ( ExchangePattern exchangePattern ) { addOutput ( new SetExchangePatternType ( exchangePattern ) ) ; return ( Type ) this ; } public Type inOnly ( ) { return setExchangePattern ( ExchangePattern . InOnly ) ; } public Type inOnly ( String uri ) { return to ( ExchangePattern . InOnly , uri ) ; } public Type inOnly ( Endpoint endpoint ) { return to ( ExchangePattern . InOnly , endpoint ) ; } public Type inOnly ( String ... uris ) { return to ( ExchangePattern . InOnly , uris ) ; } public Type inOnly ( Endpoint ... endpoints ) { return to ( ExchangePattern . InOnly , endpoints ) ; } public Type inOnly ( Iterable < Endpoint > endpoints ) { return to ( ExchangePattern . InOnly , endpoints ) ; } public Type inOut ( ) { return setExchangePattern ( ExchangePattern . InOut ) ; } public Type inOut ( String uri ) { return to ( ExchangePattern . InOut , uri ) ; } public Type inOut ( Endpoint endpoint ) { return to ( ExchangePattern . InOut , endpoint ) ; } public Type inOut ( String ... uris ) { return to ( ExchangePattern . InOut , uris ) ; } public Type inOut ( Endpoint ... endpoints ) { return to ( ExchangePattern . InOut , endpoints ) ; } public Type inOut ( Iterable < Endpoint > endpoints ) { return to ( ExchangePattern . InOut , endpoints ) ; } public MulticastType multicast ( ) { MulticastType answer = new MulticastType ( ) ; addOutput ( answer ) ; return answer ; } public MulticastType multicast ( AggregationStrategy aggregationStrategy , boolean parallelProcessing ) { MulticastType answer = new MulticastType ( ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; answer . setParallelProcessing ( parallelProcessing ) ; return answer ; } public MulticastType multicast ( AggregationStrategy aggregationStrategy ) { MulticastType answer = new MulticastType ( ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; return answer ; } public Type pipeline ( String ... uris ) { return to ( uris ) ; } public Type pipeline ( Endpoint ... endpoints ) { return to ( endpoints ) ; } public Type pipeline ( Collection < Endpoint > endpoints ) { return to ( endpoints ) ; } public ProcessorType < ? extends ProcessorType > end ( ) { if ( blocks . isEmpty ( ) ) { if ( parent == null ) { throw new IllegalArgumentException ( "Root node with no active block" ) ; } return parent ; } popBlock ( ) ; return this ; } public ThreadType thread ( int coreSize ) { ThreadType answer = new ThreadType ( coreSize ) ; addOutput ( answer ) ; return answer ; } public ProcessorType < Type > thread ( ThreadPoolExecutor executor ) { ThreadType answer = new ThreadType ( executor ) ; addOutput ( answer ) ; return this ; } public IdempotentConsumerType idempotentConsumer ( Expression messageIdExpression , MessageIdRepository messageIdRepository ) { IdempotentConsumerType answer = new IdempotentConsumerType ( messageIdExpression , messageIdRepository ) ; addOutput ( answer ) ; return answer ; } public ExpressionClause < IdempotentConsumerType > idempotentConsumer ( MessageIdRepository messageIdRepository ) { IdempotentConsumerType answer = new IdempotentConsumerType ( ) ; answer . setMessageIdRepository ( messageIdRepository ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public ExpressionClause < FilterType > filter ( ) { FilterType filter = new FilterType ( ) ; addOutput ( filter ) ; return ExpressionClause . createAndSetExpression ( filter ) ; } public FilterType filter ( Predicate predicate ) { FilterType filter = new FilterType ( predicate ) ; addOutput ( filter ) ; return filter ; } public FilterType filter ( ExpressionType expression ) { FilterType filter = getNodeFactory ( ) . createFilter ( ) ; filter . setExpression ( expression ) ; addOutput ( filter ) ; return filter ; } public FilterType filter ( String language , String expression ) { return filter ( new LanguageExpression ( language , expression ) ) ; } public LoadBalanceType loadBalance ( ) { LoadBalanceType answer = new LoadBalanceType ( ) ; addOutput ( answer ) ; return answer ; } public ChoiceType choice ( ) { ChoiceType answer = new ChoiceType ( ) ; addOutput ( answer ) ; return answer ; } public TryType tryBlock ( ) { TryType answer = new TryType ( ) ; addOutput ( answer ) ; return answer ; } public Type recipientList ( Expression recipients ) { RecipientListType answer = new RecipientListType ( recipients ) ; addOutput ( answer ) ; return ( Type ) this ; } public ExpressionClause < ProcessorType < Type > > recipientList ( ) { RecipientListType answer = new RecipientListType ( ) ; addOutput ( answer ) ; ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; answer . setExpression ( clause ) ; return clause ; } public Type routingSlip ( String header , String uriDelimiter ) { RoutingSlipType answer = new RoutingSlipType ( header , uriDelimiter ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type routingSlip ( String header ) { RoutingSlipType answer = new RoutingSlipType ( header ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type routingSlip ( ) { RoutingSlipType answer = new RoutingSlipType ( ) ; addOutput ( answer ) ; return ( Type ) this ; } public SplitterType splitter ( Expression recipients ) { SplitterType answer = new SplitterType ( recipients ) ; addOutput ( answer ) ; return answer ; } public ExpressionClause < SplitterType > splitter ( ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public SplitterType splitter ( Expression partsExpression , AggregationStrategy aggregationStrategy ) { SplitterType answer = new SplitterType ( partsExpression ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; return answer ; } public ExpressionClause < SplitterType > splitter ( AggregationStrategy aggregationStrategy ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public SplitterType splitter ( Expression recipients , boolean parallelProcessing ) { SplitterType answer = new SplitterType ( recipients ) ; addOutput ( answer ) ; answer . setParallelProcessing ( parallelProcessing ) ; return answer ; } public SplitterType splitter ( Expression recipients , boolean parallelProcessing , ThreadPoolExecutor threadPoolExecutor ) { SplitterType answer = new SplitterType ( recipients ) ; addOutput ( answer ) ; answer . setParallelProcessing ( parallelProcessing ) ; answer . setThreadPoolExecutor ( threadPoolExecutor ) ; return answer ; } public ExpressionClause < SplitterType > splitter ( boolean parallelProcessing ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; answer . setParallelProcessing ( parallelProcessing ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public ExpressionClause < SplitterType > splitter ( boolean parallelProcessing , ThreadPoolExecutor threadPoolExecutor ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; answer . setParallelProcessing ( parallelProcessing ) ; answer . setThreadPoolExecutor ( threadPoolExecutor ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public SplitterType splitter ( Expression partsExpression , AggregationStrategy aggregationStrategy , boolean parallelProcessing ) { SplitterType answer = new SplitterType ( partsExpression ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; answer . setParallelProcessing ( parallelProcessing ) ; return answer ; } public SplitterType splitter ( Expression partsExpression , AggregationStrategy aggregationStrategy , boolean parallelProcessing , ThreadPoolExecutor threadPoolExecutor ) { SplitterType answer = new SplitterType ( partsExpression ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; answer . setParallelProcessing ( parallelProcessing ) ; answer . setThreadPoolExecutor ( threadPoolExecutor ) ; return answer ; } public ExpressionClause < SplitterType > splitter ( AggregationStrategy aggregationStrategy , boolean parallelProcessing ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; answer . setParallelProcessing ( parallelProcessing ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public ExpressionClause < SplitterType > splitter ( AggregationStrategy aggregationStrategy , boolean parallelProcessing , ThreadPoolExecutor threadPoolExecutor ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; answer . setParallelProcessing ( parallelProcessing ) ; answer . setThreadPoolExecutor ( threadPoolExecutor ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public ExpressionClause < ResequencerType > resequencer ( ) { ResequencerType answer = new ResequencerType ( ) ; addOutput ( answer ) ; ExpressionClause < ResequencerType > clause = new ExpressionClause < ResequencerType > ( answer ) ; answer . expression ( clause ) ; return clause ; } public ResequencerType resequencer ( Expression < Exchange > expression ) { return resequencer ( Collections . < Expression > singletonList ( expression ) ) ; } public ResequencerType resequencer ( List < Expression > expressions ) { ResequencerType answer = new ResequencerType ( expressions ) ; addOutput ( answer ) ; return answer ; } public ResequencerType resequencer ( Expression ... expressions ) { List < Expression > list = new ArrayList < Expression > ( ) ; list . addAll ( Arrays . asList ( expressions ) ) ; return resequencer ( list ) ; } public ExpressionClause < AggregatorType > aggregator ( ) { AggregatorType answer = new AggregatorType ( ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public ExpressionClause < AggregatorType > aggregator ( AggregationStrategy aggregationStrategy ) { AggregatorType answer = new AggregatorType ( ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public AggregatorType aggregator ( AggregationCollection aggregationCollection ) { AggregatorType answer = new AggregatorType ( ) ; answer . setAggregationCollection ( aggregationCollection ) ; addOutput ( answer ) ; return answer ; } public AggregatorType aggregator ( Expression correlationExpression ) { AggregatorType answer = new AggregatorType ( correlationExpression ) ; addOutput ( answer ) ; return answer ; } public AggregatorType aggregator ( Expression correlationExpression , AggregationStrategy aggregationStrategy ) { AggregatorType answer = new AggregatorType ( correlationExpression , aggregationStrategy ) ; addOutput ( answer ) ; return answer ; } public DelayerType delayer ( Expression < Exchange > processAtExpression ) { return delayer ( processAtExpression , 0L ) ; } public DelayerType delayer ( Expression < Exchange > processAtExpression , long delay ) { DelayerType answer = new DelayerType ( processAtExpression , delay ) ; addOutput ( answer ) ; return answer ; } public ExpressionClause < DelayerType > delayer ( ) { DelayerType answer = new DelayerType ( ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public DelayerType delayer ( long delay ) { return delayer ( null , delay ) ; } public ThrottlerType throttler ( long maximumRequestCount ) { ThrottlerType answer = new ThrottlerType ( maximumRequestCount ) ; addOutput ( answer ) ; return answer ; } public ExpressionClause < LoopType > loop ( ) { LoopType loop = new LoopType ( ) ; addOutput ( loop ) ; return ExpressionClause . createAndSetExpression ( loop ) ; } public LoopType loop ( Expression < ? > expression ) { LoopType loop = getNodeFactory ( ) . createLoop ( ) ; loop . setExpression ( expression ) ; addOutput ( loop ) ; return loop ; } public LoopType loop ( int count ) { LoopType loop = getNodeFactory ( ) . createLoop ( ) ; loop . setExpression ( new ConstantExpression ( Integer . toString ( count ) ) ) ; addOutput ( loop ) ; return loop ; } public Type throwFault ( Throwable fault ) { ThrowFaultType answer = new ThrowFaultType ( ) ; answer . setFault ( fault ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type throwFault ( String message ) { return throwFault ( new CamelException ( message ) ) ; } public Type interceptor ( String ref ) { InterceptorRef interceptor = new InterceptorRef ( ref ) ; intercept ( interceptor ) ; return ( Type ) this ; } public Type intercept ( DelegateProcessor interceptor ) { intercept ( new InterceptorRef ( interceptor ) ) ; return ( Type ) this ; } public InterceptType intercept ( ) { InterceptType answer = new InterceptType ( ) ; addOutput ( answer ) ; return answer ; } public void intercept ( InterceptorType interceptor ) { addOutput ( interceptor ) ; pushBlock ( interceptor ) ; } public void addInterceptor ( InterceptorType interceptor ) { interceptors . add ( interceptor ) ; } public void addInterceptor ( DelegateProcessor interceptor ) { addInterceptor ( new InterceptorRef ( interceptor ) ) ; } public void pushBlock ( Block block ) { blocks . add ( block ) ; } public Block popBlock ( ) { return blocks . isEmpty ( ) ? null : blocks . removeLast ( ) ; } public Type proceed ( ) { ProceedType proceed = null ; ProcessorType currentProcessor = this ; if ( currentProcessor instanceof InterceptType ) { proceed = ( ( InterceptType ) currentProcessor ) . getProceed ( ) ; LOG . info ( "proceed() is the implied and hence not needed for an intercept()" ) ; } if ( proceed == null ) { for ( ProcessorType node = parent ; node != null ; node = node . getParent ( ) ) { if ( node instanceof InterceptType ) { InterceptType intercept = ( InterceptType ) node ; proceed = intercept . getProceed ( ) ; break ; } } if ( proceed == null ) { throw new IllegalArgumentException ( "Cannot use proceed() without being within an intercept() block" ) ; } } addOutput ( proceed ) ; return ( Type ) this ; } public Type stop ( ) { ProcessorType currentProcessor = this ; if ( currentProcessor instanceof InterceptType ) { ( ( InterceptType ) currentProcessor ) . stopIntercept ( ) ; } else { ProcessorType node ; for ( node = parent ; node != null ; node = node . getParent ( ) ) { if ( node instanceof InterceptType ) { ( ( InterceptType ) node ) . stopIntercept ( ) ; break ; } } if ( node == null ) { throw new IllegalArgumentException ( "Cannot use stop() without being within an intercept() block" ) ; } } return ( Type ) this ; } public ExceptionType exception ( Class exceptionType ) { return onException ( exceptionType ) ; } public ExceptionType onException ( Class exceptionType ) { ExceptionType answer = new ExceptionType ( exceptionType ) ; addOutput ( answer ) ; return answer ; } public ChoiceType intercept ( Predicate predicate ) { InterceptType answer = new InterceptType ( ) ; addOutput ( answer ) ; return answer . when ( predicate ) ; } public Type interceptors ( String ... refs ) { for ( String ref : refs ) { interceptor ( ref ) ; } return ( Type ) this ; } public Type trace ( ) { return trace ( DEFAULT_TRACE_CATEGORY ) ; } public Type trace ( String category ) { final Log log = LogFactory . getLog ( category ) ; return intercept ( new DelegateProcessor ( ) { @ Override public void process ( Exchange exchange ) throws Exception { log . trace ( exchange ) ; processNext ( exchange ) ; } } ) ; } public PolicyRef policies ( ) { PolicyRef answer = new PolicyRef ( ) ; addOutput ( answer ) ; return answer ; } public PolicyRef policy ( Policy policy ) { PolicyRef answer = new PolicyRef ( policy ) ; addOutput ( answer ) ; return answer ; } public Type handleFault ( ) { intercept ( new HandleFaultType ( ) ) ; return ( Type ) this ; } public Type errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return ( Type ) this ; } public Type inheritErrorHandler ( boolean condition ) { setInheritErrorHandlerFlag ( condition ) ; return ( Type ) this ; } public Type process ( Processor processor ) { ProcessorRef answer = new ProcessorRef ( processor ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type processRef ( String ref ) { ProcessorRef answer = new ProcessorRef ( ) ; answer . setRef ( ref ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Object bean ) { BeanRef answer = new BeanRef ( ) ; answer . setBean ( bean ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Object bean , String method ) { BeanRef answer = new BeanRef ( ) ; answer . setBean ( bean ) ; answer . setMethod ( method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Class beanType ) { BeanRef answer = new BeanRef ( ) ; answer . setBeanType ( beanType ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Class beanType , String method ) { BeanRef answer = new BeanRef ( ) ; answer . setBeanType ( beanType ) ; answer . setMethod ( method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type beanRef ( String ref ) { BeanRef answer = new BeanRef ( ref ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type beanRef ( String ref , String method ) { BeanRef answer = new BeanRef ( ref , method ) ; addOutput ( answer ) ; return ( Type ) this ; } public ExpressionClause < ProcessorType < Type > > setBody ( ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; SetBodyType answer = new SetBodyType ( clause ) ; addOutput ( answer ) ; return clause ; } public Type setBody ( Expression expression ) { SetBodyType answer = new SetBodyType ( expression ) ; addOutput ( answer ) ; return ( Type ) this ; } @ Deprecated public Type setOutBody ( Expression expression ) { return transform ( expression ) ; } @ Deprecated public ExpressionClause < ProcessorType < Type > > setOutBody ( ) { return transform ( ) ; } public Type transform ( Expression expression ) { TransformType answer = new TransformType ( expression ) ; addOutput ( answer ) ; return ( Type ) this ; } public ExpressionClause < ProcessorType < Type > > transform ( ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; TransformType answer = new TransformType ( clause ) ; addOutput ( answer ) ; return clause ; } public Type setFaultBody ( Expression expression ) { return process ( ProcessorBuilder . setFaultBody ( expression ) ) ; } public ExpressionClause < ProcessorType < Type > > setHeader ( String name ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; SetHeaderType answer = new SetHeaderType ( name , clause ) ; addOutput ( answer ) ; return clause ; } public Type setHeader ( String name , Expression expression ) { SetHeaderType answer = new SetHeaderType ( name , expression ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type setHeader ( String name , String value ) { SetHeaderType answer = new SetHeaderType ( name , value ) ; addOutput ( answer ) ; return ( Type ) this ; } public ExpressionClause < ProcessorType < Type > > setOutHeader ( String name ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; SetOutHeaderType answer = new SetOutHeaderType ( name , clause ) ; addOutput ( answer ) ; return clause ; } public Type setOutHeader ( String name , Expression expression ) { SetOutHeaderType answer = new SetOutHeaderType ( name , expression ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type setFaultHeader ( String name , Expression expression ) { return process ( ProcessorBuilder . setFaultHeader ( name , expression ) ) ; } public Type setProperty ( String name , Expression expression ) { SetPropertyType answer = new SetPropertyType ( name , expression ) ; addOutput ( answer ) ; return ( Type ) this ; } public ExpressionClause < ProcessorType < Type > > setProperty ( String name ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; SetPropertyType answer = new SetPropertyType ( name , clause ) ; addOutput ( answer ) ; return clause ; } public Type removeHeader ( String name ) { RemoveHeaderType answer = new RemoveHeaderType ( name ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type removeFaultHeader ( String name ) { return process ( ProcessorBuilder . removeFaultHeader ( name ) ) ; } public Type removeProperty ( String name ) { RemovePropertyType answer = new RemovePropertyType ( name ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type convertBodyTo ( Class type ) { addOutput ( new ConvertBodyType ( type ) ) ; return ( Type ) this ; } public Type convertBodyTo ( String typeString ) { addOutput ( new ConvertBodyType ( typeString ) ) ; return ( Type ) this ; } @ Deprecated public Type convertOutBodyTo ( Class type ) { return process ( new ConvertBodyProcessor ( type ) ) ; } @ Deprecated public Type convertFaultBodyTo ( Class type ) { return process ( new ConvertBodyProcessor ( type ) ) ; } public DataFormatClause < ProcessorType < Type > > unmarshal ( ) { return new DataFormatClause < ProcessorType < Type > > ( this , DataFormatClause . Operation . Unmarshal ) ; } public Type unmarshal ( DataFormatType dataFormatType ) { addOutput ( new UnmarshalType ( dataFormatType ) ) ; return ( Type ) this ; } public Type unmarshal ( DataFormat dataFormat ) { return unmarshal ( new DataFormatType ( dataFormat ) ) ; } public Type unmarshal ( String dataTypeRef ) { addOutput ( new UnmarshalType ( dataTypeRef ) ) ; return ( Type ) this ; } public DataFormatClause < ProcessorType < Type > > marshal ( ) { return new DataFormatClause < ProcessorType < Type > > ( this , DataFormatClause . Operation . Marshal ) ; } public Type marshal ( DataFormatType dataFormatType ) { addOutput ( new MarshalType ( dataFormatType ) ) ; return ( Type ) this ; } public Type marshal ( DataFormat dataFormat ) { return marshal ( new DataFormatType ( dataFormat ) ) ; } public Type marshal ( String dataTypeRef ) { addOutput ( new MarshalType ( dataTypeRef ) ) ; return ( Type ) this ; } @ XmlTransient public ProcessorType < ? extends ProcessorType > getParent ( ) { return parent ; } public void setParent ( ProcessorType < ? extends ProcessorType > parent ) { this . parent = parent ; } @ XmlTransient public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } protected void setErrorHandlerBuilderIfNull ( ErrorHandlerBuilder errorHandlerBuilder ) { if ( this . errorHandlerBuilder == null ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; } } public String getErrorHandlerRef ( ) { return errorHandlerRef ; } @ XmlAttribute ( required = false ) public void setErrorHandlerRef ( String errorHandlerRef ) { this . errorHandlerRef = errorHandlerRef ; setErrorHandlerBuilder ( new ErrorHandlerBuilderRef ( errorHandlerRef ) ) ; } @ XmlTransient public boolean isInheritErrorHandler ( ) { return isInheritErrorHandler ( getInheritErrorHandlerFlag ( ) ) ; } public static boolean isInheritErrorHandler ( Boolean value ) { return value == null || value . booleanValue ( ) ; } @ XmlAttribute ( name = "inheritErrorHandler" , required = false ) public Boolean getInheritErrorHandlerFlag ( ) { return inheritErrorHandlerFlag ; } public void setInheritErrorHandlerFlag ( Boolean inheritErrorHandlerFlag ) { this . inheritErrorHandlerFlag = inheritErrorHandlerFlag ; } @ XmlTransient public NodeFactory getNodeFactory ( ) { if ( nodeFactory == null ) { nodeFactory = new NodeFactory ( ) ; } return nodeFactory ; } public void setNodeFactory ( NodeFactory nodeFactory ) { this . nodeFactory = nodeFactory ; } public String getLabel ( ) { return "" ; } protected Processor makeProcessor ( RouteContext routeContext ) throws Exception { Processor processor = createProcessor ( routeContext ) ; return wrapProcessor ( routeContext , processor ) ; } protected Processor wrapProcessorInInterceptors ( RouteContext routeContext , Processor target ) throws Exception { if ( target == null ) { throw new IllegalArgumentException ( "target not provided on node: " + this ) ; } List < InterceptStrategy > strategies = new ArrayList < InterceptStrategy > ( ) ; CamelContext camelContext = routeContext . getCamelContext ( ) ; if ( camelContext instanceof DefaultCamelContext ) { DefaultCamelContext defaultCamelContext = ( DefaultCamelContext ) camelContext ; strategies . addAll ( defaultCamelContext . getInterceptStrategies ( ) ) ; } strategies . addAll ( routeContext . getInterceptStrategies ( ) ) ; for ( InterceptStrategy strategy : strategies ) { if ( strategy != null ) { target = strategy . wrapProcessorInInterceptors ( this , target ) ; } } List < InterceptorType > list = routeContext . getRoute ( ) . getInterceptors ( ) ; if ( interceptors != null ) { list . addAll ( interceptors ) ; } Collections . reverse ( list ) ; Set < Processor > interceptors = new HashSet < Processor > ( ) ; interceptors . add ( target ) ; for ( InterceptorType interceptorType : list ) { DelegateProcessor interceptor = interceptorType . createInterceptor ( routeContext ) ; if ( ! interceptors . contains ( interceptor ) ) { interceptors . add ( interceptor ) ; if ( interceptor . getProcessor ( ) != null ) { LOG . warn ( "Interceptor " + interceptor + " currently wraps target " + interceptor . getProcessor ( ) + " is attempting to change target " + target + " new wrapping has been denied." ) ; } else { interceptor . setProcessor ( target ) ; target = interceptor ; } } } return target ; } protected Processor wrapInErrorHandler ( RouteContext routeContext , Processor target ) throws Exception { if ( target == null ) { throw new IllegalArgumentException ( "target not provided on node: " + this ) ; } ErrorHandlerWrappingStrategy strategy = routeContext . getErrorHandlerWrappingStrategy ( ) ; if ( strategy != null ) { return strategy . wrapProcessorInErrorHandler ( routeContext , this , target ) ; } return getErrorHandlerBuilder ( ) . createErrorHandler ( routeContext , target ) ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( errorHandlerRef != null ) { return new ErrorHandlerBuilderRef ( errorHandlerRef ) ; } if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } protected void configureChild ( ProcessorType output ) { output . setNodeFactory ( getNodeFactory ( ) ) ; } public void addOutput ( ProcessorType processorType ) { processorType . setParent ( this ) ; configureChild ( processorType ) ; if ( blocks . isEmpty ( ) ) { getOutputs ( ) . add ( processorType ) ; } else { Block block = blocks . getLast ( ) ; block . addOutput ( processorType ) ; } } protected Processor createCompositeProcessor ( RouteContext routeContext , List < Processor > list ) { return new Pipeline ( list ) ; } protected Processor createOutputsProcessor ( RouteContext routeContext , Collection < ProcessorType < ? > > outputs ) throws Exception { List < Processor > list = new ArrayList < Processor > ( ) ; for ( ProcessorType output : outputs ) { Processor processor = output . createProcessor ( routeContext ) ; if ( output instanceof ProceedType && processor == null ) { continue ; } processor = output . wrapProcessorInInterceptors ( routeContext , processor ) ; ProcessorType currentProcessor = this ; if ( ! ( currentProcessor instanceof ExceptionType || currentProcessor instanceof TryType ) ) { processor = output . wrapInErrorHandler ( routeContext , processor ) ; } list . add ( processor ) ; } Processor processor = null ; if ( ! list . isEmpty ( ) ) { if ( list . size ( ) == 1 ) { processor = list . get ( 0 ) ; } else { processor = createCompositeProcessor ( routeContext , list ) ; } } return processor ; } public void clearOutput ( ) { getOutputs ( ) . clear ( ) ; blocks . clear ( ) ; } } 	1	['166', '2', '14', '118', '322', '13617', '67', '76', '157', '0.893602694', '2077', '0.888888889', '3', '0.068181818', '0.056277056', '0', '0', '11.45783133', '6', '1.1506', '1']
package org . apache . camel . component . cxf . util ; public interface Dummy { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . impl ; import java . util . concurrent . ScheduledExecutorService ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; public class DefaultScheduledPollConsumer < E extends Exchange > extends ScheduledPollConsumer < E > { private PollingConsumer < E > pollingConsumer ; public DefaultScheduledPollConsumer ( DefaultEndpoint < E > defaultEndpoint , Processor processor ) { super ( defaultEndpoint , processor ) ; } public DefaultScheduledPollConsumer ( Endpoint < E > endpoint , Processor processor , ScheduledExecutorService executor ) { super ( endpoint , processor , executor ) ; } protected void poll ( ) throws Exception { while ( true ) { E exchange = pollingConsumer . receiveNoWait ( ) ; if ( exchange == null ) { break ; } Message out = exchange . getOut ( false ) ; if ( out != null ) { E newExchange = getEndpoint ( ) . createExchange ( ) ; newExchange . getIn ( ) . copyFrom ( out ) ; exchange = newExchange ; } getProcessor ( ) . process ( exchange ) ; } } @ Override protected void doStart ( ) throws Exception { pollingConsumer = getEndpoint ( ) . createPollingConsumer ( ) ; super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( pollingConsumer != null ) { pollingConsumer . stop ( ) ; } } } 	1	['5', '4', '0', '8', '19', '4', '1', '7', '2', '0.5', '63', '1', '1', '0.921052632', '0.4', '2', '4', '11.4', '1', '0.6', '1']
package org . apache . camel . component . cxf . transport . spring ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . camel . util . ObjectHelper ; import org . apache . cxf . configuration . spring . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . ParserContext ; public class AbstractCamelContextBeanDefinitionParser extends AbstractBeanDefinitionParser { private static final String DEFAULT_CAMEL_CONTEXT_NAME = "camelContext" ; private String getContextId ( String contextId ) { if ( ObjectHelper . isEmpty ( contextId ) ) { return DEFAULT_CAMEL_CONTEXT_NAME ; } else { return contextId ; } } protected void wireCamelContext ( BeanDefinitionBuilder bean , String camelContextId ) { bean . addPropertyReference ( "camelContext" , camelContextId ) ; } protected void doParse ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { bean . setAbstract ( true ) ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node n = children . item ( i ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { String name = n . getLocalName ( ) ; if ( "camelContext" . equals ( name ) ) { BeanDefinition bd = ctx . getDelegate ( ) . parseCustomElement ( ( Element ) n ) ; String contextId = ( String ) bd . getPropertyValues ( ) . getPropertyValue ( "id" ) . getValue ( ) ; wireCamelContext ( bean , getContextId ( contextId ) ) ; } else if ( "camelContextRef" . equals ( name ) ) { String contextId = n . getTextContent ( ) ; wireCamelContext ( bean , getContextId ( contextId ) ) ; } } } } } 	0	['4', '0', '2', '10', '20', '6', '2', '8', '1', '1.333333333', '85', '1', '0', '0', '0.5', '0', '0', '20', '5', '2', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; public class FilterProcessor extends DelegateProcessor { private Predicate < Exchange > predicate ; public FilterProcessor ( Predicate < Exchange > predicate , Processor processor ) { super ( processor ) ; this . predicate = predicate ; } public void process ( Exchange exchange ) throws Exception { if ( predicate . matches ( exchange ) ) { super . process ( exchange ) ; } } @ Override public String toString ( ) { return "Filter[if: " + predicate + " do: " + getProcessor ( ) + "]" ; } public Predicate < Exchange > getPredicate ( ) { return predicate ; } } 	1	['4', '3', '0', '9', '12', '0', '5', '4', '4', '0', '41', '1', '1', '0.88', '0.4375', '0', '0', '9', '1', '0.75', '2']
package org . apache . camel . component . xmpp ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . SmackConfiguration ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smackx . muc . DiscussionHistory ; import org . jivesoftware . smackx . muc . MultiUserChat ; public class XmppGroupChatProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( XmppGroupChatProducer . class ) ; private final XmppEndpoint endpoint ; private final String room ; private MultiUserChat chat ; public XmppGroupChatProducer ( XmppEndpoint endpoint ) throws XMPPException , CamelException { super ( endpoint ) ; this . endpoint = endpoint ; this . room = endpoint . resolveRoom ( ) ; if ( room == null ) { throw new IllegalArgumentException ( "No room property specified" ) ; } } public void process ( Exchange exchange ) { Message message = chat . createMessage ( ) ; message . setTo ( room ) ; message . setFrom ( endpoint . getUser ( ) ) ; endpoint . getBinding ( ) . populateXmppMessage ( message , exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sending XMPP message: " + message . getBody ( ) ) ; } try { chat . sendMessage ( message ) ; } catch ( XMPPException e ) { throw new RuntimeXmppException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { if ( chat == null ) { chat = new MultiUserChat ( endpoint . getConnection ( ) , room ) ; DiscussionHistory history = new DiscussionHistory ( ) ; history . setMaxChars ( 0 ) ; chat . join ( this . endpoint . getNickname ( ) , null , history , SmackConfiguration . getPacketReplyTimeout ( ) ) ; } super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( chat != null ) { chat . leave ( ) ; chat = null ; } super . doStop ( ) ; } public MultiUserChat getChat ( ) { return chat ; } public void setChat ( MultiUserChat chat ) { this . chat = chat ; } public String getRoom ( ) { return room ; } } 	0	['8', '3', '0', '15', '36', '0', '1', '15', '5', '0.642857143', '135', '1', '1', '0.777777778', '0.357142857', '1', '1', '15.375', '2', '0.875', '0']
package org . apache . camel . impl ; import java . util . Hashtable ; import javax . naming . Context ; import javax . naming . InitialContext ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . Registry ; public class JndiRegistry implements Registry { private Context context ; public JndiRegistry ( ) { } public JndiRegistry ( Context context ) { this . context = context ; } public < T > T lookup ( String name , Class < T > type ) { Object value = lookup ( name ) ; return type . cast ( value ) ; } public Object lookup ( String name ) { try { return getContext ( ) . lookup ( name ) ; } catch ( NameNotFoundException e ) { return null ; } catch ( NamingException e ) { return null ; } } public void bind ( String s , Object o ) { try { getContext ( ) . bind ( s , o ) ; } catch ( NamingException e ) { throw new RuntimeCamelException ( e ) ; } } public void close ( ) throws NamingException { getContext ( ) . close ( ) ; } public Context getContext ( ) throws NamingException { if ( context == null ) { context = createContext ( ) ; } return context ; } public void setContext ( Context context ) { this . context = context ; } protected Context createContext ( ) throws NamingException { Hashtable properties = new Hashtable ( System . getProperties ( ) ) ; return new InitialContext ( properties ) ; } } 	1	['9', '1', '0', '3', '18', '30', '1', '2', '8', '0.375', '79', '1', '0', '0', '0.355555556', '0', '0', '7.666666667', '1', '0.7778', '1']
package org . apache . camel . spring . util ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . util . ObjectHelper ; public class SimpleRouteBuilder extends RouteBuilder { private List < String > fromUris = new ArrayList < String > ( ) ; private List < String > toUris = new ArrayList < String > ( ) ; private Class beanType ; private String beanClass ; private String beanRef ; private String beanMethod ; public void configure ( ) throws Exception { if ( fromUris . isEmpty ( ) ) { throw new IllegalArgumentException ( "the fromUris property must contain at least one valid URI" ) ; } for ( String fromUri : fromUris ) { ProcessorType route = from ( fromUri ) ; addBeanCall ( route ) ; for ( String toUri : toUris ) { route = route . to ( toUri ) ; } } } public void setFromUri ( String uri ) { setFromUris ( singletonList ( uri ) ) ; } public void setToUri ( String uri ) { setToUris ( singletonList ( uri ) ) ; } public List < String > getFromUris ( ) { return fromUris ; } public void setFromUris ( List < String > fromUris ) { this . fromUris = fromUris ; } public List < String > getToUris ( ) { return toUris ; } public void setToUris ( List < String > toUris ) { this . toUris = toUris ; } public String getBeanClass ( ) { return beanClass ; } public void setBeanClass ( String beanClass ) { this . beanClass = beanClass ; } public String getBeanRef ( ) { return beanRef ; } public void setBeanRef ( String beanRef ) { this . beanRef = beanRef ; } public Class getBeanType ( ) { if ( beanType == null ) { if ( beanClass != null ) { beanType = ObjectHelper . loadClass ( beanClass , getClass ( ) . getClassLoader ( ) ) ; } } return beanType ; } public void setBeanType ( Class beanType ) { this . beanType = beanType ; } public String getBeanMethod ( ) { return beanMethod ; } public void setBeanMethod ( String beanMethod ) { this . beanMethod = beanMethod ; } protected void addBeanCall ( ProcessorType route ) { Class type = getBeanType ( ) ; if ( type != null ) { if ( beanMethod != null ) { route = route . bean ( type , beanMethod ) ; } else { route = route . bean ( type ) ; } } else if ( beanRef != null ) { if ( beanMethod != null ) { route = route . beanRef ( beanRef , beanMethod ) ; } else { route = route . beanRef ( beanRef ) ; } } } protected List < String > singletonList ( String value ) { List < String > uris = new ArrayList < String > ( ) ; uris . add ( value ) ; return uris ; } } 	0	['18', '3', '0', '4', '35', '111', '0', '4', '16', '0.81372549', '200', '1', '0', '0.76056338', '0.311111111', '1', '2', '9.777777778', '5', '1.2778', '0']
package org . apache . camel . processor ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . processor . aggregate . AggregationCollection ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . aggregate . DefaultAggregationCollection ; import org . apache . camel . processor . aggregate . PredicateAggregationCollection ; public class Aggregator extends BatchProcessor { private Predicate aggregationCompletedPredicate ; public Aggregator ( Processor processor , Expression correlationExpression , AggregationStrategy aggregationStrategy ) { this ( processor , new DefaultAggregationCollection ( correlationExpression , aggregationStrategy ) ) ; } public Aggregator ( Processor processor , Expression correlationExpression , AggregationStrategy aggregationStrategy , Predicate aggregationCompletedPredicate ) { this ( processor , new PredicateAggregationCollection ( correlationExpression , aggregationStrategy , aggregationCompletedPredicate ) ) ; this . aggregationCompletedPredicate = aggregationCompletedPredicate ; } public Aggregator ( Processor processor , AggregationCollection collection ) { super ( processor , collection ) ; } @ Override public String toString ( ) { return "Aggregator[to: " + getProcessor ( ) + "]" ; } } 	1	['4', '3', '0', '9', '12', '6', '1', '8', '4', '1', '44', '1', '1', '0.971428571', '0.541666667', '0', '0', '9.75', '1', '0.25', '1']
package org . apache . camel . component . jpa ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . METHOD } ) public @ interface Consumed { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class TransformProcessor extends DelegateProcessor implements Processor { private static final transient Log LOG = LogFactory . getLog ( TransformProcessor . class ) ; private Expression expression ; public TransformProcessor ( Expression expression ) { this . expression = expression ; } public TransformProcessor ( Expression expression , Processor childProcessor ) { super ( childProcessor ) ; this . expression = expression ; } public void process ( Exchange exchange ) throws Exception { Object newBody = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setBody ( newBody ) ; exchange . getOut ( ) . getHeaders ( ) . putAll ( exchange . getIn ( ) . getHeaders ( ) ) ; super . process ( exchange ) ; } @ Override public String toString ( ) { return "transform(" + expression + "," + processor + ")" ; } } 	1	['5', '3', '0', '8', '19', '0', '1', '7', '4', '0.625', '61', '1', '1', '0.916666667', '0.5', '0', '0', '10.8', '1', '0.4', '2']
package org . apache . camel . component . jms ; import javax . jms . Message ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class JmsExchange extends DefaultExchange { private JmsBinding binding ; public JmsExchange ( CamelContext context , ExchangePattern pattern , JmsBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public JmsExchange ( CamelContext context , ExchangePattern pattern , JmsBinding binding , Message message ) { this ( context , pattern , binding ) ; setIn ( new JmsMessage ( message ) ) ; } public JmsExchange ( DefaultExchange parent , JmsBinding binding ) { super ( parent ) ; this . binding = binding ; } @ Override public JmsMessage getIn ( ) { return ( JmsMessage ) super . getIn ( ) ; } @ Override public JmsMessage getOut ( ) { return ( JmsMessage ) super . getOut ( ) ; } @ Override public JmsMessage getOut ( boolean lazyCreate ) { return ( JmsMessage ) super . getOut ( lazyCreate ) ; } @ Override public JmsMessage getFault ( ) { return ( JmsMessage ) super . getFault ( ) ; } public JmsBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new JmsExchange ( this , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getJmsMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getJmsMessage ( ) ; } public Message getFaultMessage ( ) { return getFault ( ) . getJmsMessage ( ) ; } @ Override protected JmsMessage createInMessage ( ) { return new JmsMessage ( ) ; } @ Override protected JmsMessage createOutMessage ( ) { return new JmsMessage ( ) ; } @ Override protected org . apache . camel . Message createFaultMessage ( ) { return new JmsMessage ( ) ; } } 	0	['21', '2', '0', '14', '25', '198', '8', '7', '16', '0.8', '119', '1', '1', '0.678571429', '0.217687075', '1', '3', '4.619047619', '1', '0.8571', '0']
package org . apache . camel . management ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . management . JMException ; import javax . management . MalformedObjectNameException ; import javax . management . ObjectName ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Route ; import org . apache . camel . Service ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . spi . InstrumentationAgent ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . RouteContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class InstrumentationLifecycleStrategy implements LifecycleStrategy { private static final transient Log LOG = LogFactory . getLog ( InstrumentationProcessor . class ) ; private InstrumentationAgent agent ; private CamelNamingStrategy namingStrategy ; private boolean initialized ; private Map < Endpoint , InstrumentationProcessor > interceptorMap = new HashMap < Endpoint , InstrumentationProcessor > ( ) ; public InstrumentationLifecycleStrategy ( ) { this ( new DefaultInstrumentationAgent ( ) ) ; } public InstrumentationLifecycleStrategy ( InstrumentationAgent agent ) { this . agent = agent ; } public InstrumentationLifecycleStrategy ( InstrumentationAgent agent , CamelContext context ) { this . agent = agent ; onContextStart ( context ) ; } public void onContextStart ( CamelContext context ) { if ( context instanceof DefaultCamelContext ) { try { initialized = true ; DefaultCamelContext dc = ( DefaultCamelContext ) context ; dc . addService ( agent ) ; namingStrategy = new CamelNamingStrategy ( agent . getMBeanObjectDomainName ( ) ) ; ManagedService ms = new ManagedService ( dc ) ; agent . register ( ms , getNamingStrategy ( ) . getObjectName ( dc ) ) ; } catch ( Exception e ) { LOG . warn ( "Could not register CamelContext MBean" , e ) ; } } } public void onEndpointAdd ( Endpoint < ? extends Exchange > endpoint ) { if ( ! initialized ) { return ; } try { ManagedEndpoint me = new ManagedEndpoint ( endpoint ) ; agent . register ( me , getNamingStrategy ( ) . getObjectName ( me ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register Endpoint MBean" , e ) ; } } public void onRoutesAdd ( Collection < Route > routes ) { if ( ! initialized ) { return ; } for ( Route route : routes ) { try { ManagedRoute mr = new ManagedRoute ( route ) ; InstrumentationProcessor interceptor = interceptorMap . get ( route . getEndpoint ( ) ) ; if ( interceptor == null ) { LOG . warn ( "Instrumentation processor not found for route endpoint " + route . getEndpoint ( ) ) ; } else { interceptor . setCounter ( mr ) ; } agent . register ( mr , getNamingStrategy ( ) . getObjectName ( mr ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register Route MBean" , e ) ; } } } public void onServiceAdd ( CamelContext context , Service service ) { if ( ! initialized ) { return ; } if ( service instanceof ServiceSupport && service instanceof Consumer ) { try { ManagedService ms = new ManagedService ( ( ServiceSupport ) service ) ; agent . register ( ms , getNamingStrategy ( ) . getObjectName ( context , ms ) ) ; } catch ( JMException e ) { LOG . warn ( "Could not register Service MBean" , e ) ; } } } public void onRouteContextCreate ( RouteContext routeContext ) { if ( ! initialized ) { return ; } Map < ProcessorType , PerformanceCounter > counterMap = new HashMap < ProcessorType , PerformanceCounter > ( ) ; RouteType route = routeContext . getRoute ( ) ; for ( ProcessorType processor : route . getOutputs ( ) ) { ObjectName name = null ; try { name = getNamingStrategy ( ) . getObjectName ( routeContext , processor ) ; PerformanceCounter pc = new PerformanceCounter ( ) ; agent . register ( pc , name ) ; counterMap . put ( processor , pc ) ; } catch ( MalformedObjectNameException e ) { LOG . warn ( "Could not create MBean name: " + name , e ) ; } catch ( JMException e ) { LOG . warn ( "Could not register PerformanceCounter MBean: " + name , e ) ; } } routeContext . addInterceptStrategy ( new InstrumentationInterceptStrategy ( counterMap ) ) ; routeContext . setErrorHandlerWrappingStrategy ( new InstrumentationErrorHandlerWrappingStrategy ( counterMap ) ) ; RouteType routeType = routeContext . getRoute ( ) ; if ( routeType . getInputs ( ) != null && ! routeType . getInputs ( ) . isEmpty ( ) ) { if ( routeType . getInputs ( ) . size ( ) > 1 ) { LOG . warn ( "Add InstrumentationProcessor to first input only." ) ; } Endpoint endpoint = routeType . getInputs ( ) . get ( 0 ) . getEndpoint ( ) ; List < ProcessorType < ? > > exceptionHandlers = new ArrayList < ProcessorType < ? > > ( ) ; List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; for ( ProcessorType output : routeType . getOutputs ( ) ) { if ( output instanceof ExceptionType ) { exceptionHandlers . add ( output ) ; } else { outputs . add ( output ) ; } } routeType . clearOutput ( ) ; routeType . getOutputs ( ) . addAll ( exceptionHandlers ) ; InstrumentationProcessor processor = new InstrumentationProcessor ( ) ; routeType . intercept ( processor ) ; for ( ProcessorType < ? > processorType : outputs ) { routeType . addOutput ( processorType ) ; } interceptorMap . put ( endpoint , processor ) ; } } public CamelNamingStrategy getNamingStrategy ( ) { return namingStrategy ; } public void setNamingStrategy ( CamelNamingStrategy strategy ) { this . namingStrategy = strategy ; } public void setAgent ( InstrumentationAgent agent ) { this . agent = agent ; } } 	1	['12', '1', '0', '29', '61', '0', '2', '28', '11', '0.454545455', '395', '1', '2', '0', '0.25', '0', '0', '31.5', '9', '2', '7']
package org . apache . camel . converter . jaxp ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . apache . camel . Converter ; @ Converter public final class DomConverter { private DomConverter ( ) { } @ Converter public static String toString ( NodeList nodeList ) { StringBuffer buffer = new StringBuffer ( ) ; append ( buffer , nodeList ) ; return buffer . toString ( ) ; } protected static void append ( StringBuffer buffer , NodeList nodeList ) { int size = nodeList . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { append ( buffer , nodeList . item ( i ) ) ; } } protected static void append ( StringBuffer buffer , Node node ) { if ( node instanceof Text ) { Text text = ( Text ) node ; buffer . append ( text . getTextContent ( ) ) ; } else if ( node instanceof Attr ) { Attr attribute = ( Attr ) node ; buffer . append ( attribute . getTextContent ( ) ) ; } else if ( node instanceof Element ) { Element element = ( Element ) node ; append ( buffer , element . getChildNodes ( ) ) ; } else if ( node instanceof Document ) { Document doc = ( Document ) node ; append ( buffer , doc . getChildNodes ( ) ) ; } } } 	0	['4', '1', '0', '0', '14', '6', '0', '0', '1', '2', '79', '0', '0', '0', '0.375', '0', '0', '18.75', '5', '2', '0']
package org . apache . camel . management ; import java . io . IOException ; import java . lang . management . ManagementFactory ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . rmi . RemoteException ; import java . rmi . registry . LocateRegistry ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import javax . management . JMException ; import javax . management . MBeanServer ; import javax . management . MBeanServerFactory ; import javax . management . NotCompliantMBeanException ; import javax . management . ObjectInstance ; import javax . management . ObjectName ; import javax . management . modelmbean . InvalidTargetObjectTypeException ; import javax . management . modelmbean . ModelMBeanInfo ; import javax . management . modelmbean . RequiredModelMBean ; import javax . management . remote . JMXConnectorServer ; import javax . management . remote . JMXConnectorServerFactory ; import javax . management . remote . JMXServiceURL ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . InstrumentationAgent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . jmx . export . annotation . AnnotationJmxAttributeSource ; import org . springframework . jmx . export . assembler . MetadataMBeanInfoAssembler ; public class DefaultInstrumentationAgent extends ServiceSupport implements InstrumentationAgent { public static final String DEFAULT_DOMAIN = "org.apache.camel" ; public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_REGISTRY_PORT = 1099 ; public static final int DEFAULT_CONNECTION_PORT = - 1 ; public static final String DEFAULT_SERVICE_URL_PATH = "/jmxrmi/camel" ; private static final transient Log LOG = LogFactory . getLog ( DefaultInstrumentationAgent . class ) ; private MBeanServer server ; private Set < ObjectName > mbeans = new HashSet < ObjectName > ( ) ; private MetadataMBeanInfoAssembler assembler ; private JMXConnectorServer cs ; private Integer registryPort ; private Integer connectorPort ; private String mBeanServerDefaultDomain ; private String mBeanObjectDomainName ; private String serviceUrlPath ; private Boolean usePlatformMBeanServer = true ; private Boolean createConnector ; protected void finalizeSettings ( ) { if ( registryPort == null ) { registryPort = Integer . getInteger ( JmxSystemPropertyKeys . REGISTRY_PORT , DEFAULT_REGISTRY_PORT ) ; } if ( connectorPort == null ) { connectorPort = Integer . getInteger ( JmxSystemPropertyKeys . CONNECTOR_PORT , DEFAULT_CONNECTION_PORT ) ; } if ( mBeanServerDefaultDomain == null ) { mBeanServerDefaultDomain = System . getProperty ( JmxSystemPropertyKeys . DOMAIN , DEFAULT_DOMAIN ) ; } if ( mBeanObjectDomainName == null ) { mBeanObjectDomainName = System . getProperty ( JmxSystemPropertyKeys . MBEAN_DOMAIN , DEFAULT_DOMAIN ) ; } if ( serviceUrlPath == null ) { serviceUrlPath = System . getProperty ( JmxSystemPropertyKeys . SERVICE_URL_PATH , DEFAULT_SERVICE_URL_PATH ) ; } if ( createConnector == null ) { createConnector = Boolean . getBoolean ( JmxSystemPropertyKeys . CREATE_CONNECTOR ) ; } if ( System . getProperty ( JmxSystemPropertyKeys . USE_PLATFORM_MBS ) != null ) { usePlatformMBeanServer = Boolean . getBoolean ( JmxSystemPropertyKeys . USE_PLATFORM_MBS ) ; } } public void setRegistryPort ( Integer value ) { registryPort = value ; } public void setConnectorPort ( Integer value ) { connectorPort = value ; } public void setMBeanServerDefaultDomain ( String value ) { mBeanServerDefaultDomain = value ; } public void setMBeanObjectDomainName ( String value ) { mBeanObjectDomainName = value ; } public void setServiceUrlPath ( String value ) { serviceUrlPath = value ; } public void setCreateConnector ( Boolean flag ) { createConnector = flag ; } public void setUsePlatformMBeanServer ( Boolean flag ) { usePlatformMBeanServer = flag ; } public MBeanServer getMBeanServer ( ) { return server ; } public void register ( Object obj , ObjectName name ) throws JMException { register ( obj , name , false ) ; } public void register ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException { try { registerMBeanWithServer ( obj , name , forceRegistration ) ; } catch ( NotCompliantMBeanException e ) { ModelMBeanInfo mbi = null ; mbi = assembler . getMBeanInfo ( obj , name . toString ( ) ) ; RequiredModelMBean mbean = ( RequiredModelMBean ) server . instantiate ( RequiredModelMBean . class . getName ( ) ) ; mbean . setModelMBeanInfo ( mbi ) ; try { mbean . setManagedResource ( obj , "ObjectReference" ) ; } catch ( InvalidTargetObjectTypeException itotex ) { throw new JMException ( itotex . getMessage ( ) ) ; } registerMBeanWithServer ( mbean , name , forceRegistration ) ; } } public void unregister ( ObjectName name ) throws JMException { server . unregisterMBean ( name ) ; } protected void doStart ( ) throws Exception { assembler = new MetadataMBeanInfoAssembler ( ) ; assembler . setAttributeSource ( new AnnotationJmxAttributeSource ( ) ) ; if ( server == null ) { finalizeSettings ( ) ; createMBeanServer ( ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Starting JMX agent on server: " + getMBeanServer ( ) ) ; } } protected void doStop ( ) throws Exception { if ( cs != null ) { try { cs . stop ( ) ; } catch ( IOException e ) { } cs = null ; } Object [ ] mBeans = mbeans . toArray ( ) ; int caught = 0 ; for ( Object name : mBeans ) { mbeans . remove ( ( ObjectName ) name ) ; try { unregister ( ( ObjectName ) name ) ; } catch ( JMException jmex ) { LOG . info ( "Exception unregistering MBean" , jmex ) ; caught ++ ; } } if ( caught > 0 ) { LOG . warn ( "A number of " + caught + " exceptions caught while unregistering MBeans during stop operation." + " See INFO log for details." ) ; } } private void registerMBeanWithServer ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException { boolean exists = server . isRegistered ( name ) ; if ( exists ) { if ( forceRegistration ) { LOG . info ( "ForceRegistration enabled, unregistering existing MBean" ) ; server . unregisterMBean ( name ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "MBean already registered with objectname: " + name ) ; } } } ObjectInstance instance = null ; if ( forceRegistration || ! exists ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Registering MBean with objectname: " + name ) ; } instance = server . registerMBean ( obj , name ) ; } if ( instance != null ) { ObjectName registeredName = instance . getObjectName ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Registered MBean with objectname: " + registeredName ) ; } mbeans . add ( registeredName ) ; } } protected void createMBeanServer ( ) { String hostName = DEFAULT_HOST ; boolean canAccessSystemProps = true ; try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPropertiesAccess ( ) ; } } catch ( SecurityException se ) { canAccessSystemProps = false ; } if ( canAccessSystemProps ) { try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException uhe ) { LOG . info ( "Cannot determine localhost name. Using default: " + DEFAULT_REGISTRY_PORT , uhe ) ; hostName = DEFAULT_HOST ; } } else { hostName = DEFAULT_HOST ; } server = findOrCreateMBeanServer ( ) ; try { if ( createConnector ) { createJmxConnector ( hostName ) ; } } catch ( IOException ioe ) { LOG . warn ( "Could not create and start JMX connector." , ioe ) ; } } @ SuppressWarnings ( "unchecked" ) protected MBeanServer findOrCreateMBeanServer ( ) { if ( usePlatformMBeanServer ) { return ManagementFactory . getPlatformMBeanServer ( ) ; } List < MBeanServer > servers = ( List < MBeanServer > ) MBeanServerFactory . findMBeanServer ( null ) ; for ( MBeanServer server : servers ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found MBeanServer with default domain " + server . getDefaultDomain ( ) ) ; } if ( mBeanServerDefaultDomain . equals ( server . getDefaultDomain ( ) ) ) { return server ; } } return MBeanServerFactory . createMBeanServer ( mBeanServerDefaultDomain ) ; } protected void createJmxConnector ( String host ) throws IOException { try { LocateRegistry . createRegistry ( registryPort ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Created JMXConnector RMI regisry on port " + registryPort ) ; } } catch ( RemoteException ex ) { } JMXServiceURL url ; if ( connectorPort > 0 ) { url = new JMXServiceURL ( "service:jmx:rmi://" + host + ":" + connectorPort + "/jndi/rmi://" + host + ":" + registryPort + serviceUrlPath ) ; } else { url = new JMXServiceURL ( "service:jmx:rmi:///jndi/rmi://" + host + ":" + registryPort + serviceUrlPath ) ; } cs = JMXConnectorServerFactory . newJMXConnectorServer ( url , null , server ) ; Thread connectorThread = new Thread ( ) { public void run ( ) { try { cs . start ( ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not start JMXConnector thread." , ioe ) ; } } } ; connectorThread . setName ( "Camel JMX Connector Thread [" + url + "]" ) ; connectorThread . start ( ) ; LOG . info ( "JMX Connector thread started and listening at: " + url ) ; } public String getMBeanObjectDomainName ( ) { return mBeanObjectDomainName ; } public void setServer ( MBeanServer value ) { server = value ; } } 	1	['24', '2', '0', '10', '84', '126', '3', '8', '14', '0.879795396', '597', '0.705882353', '0', '0.388888889', '0.193236715', '1', '1', '23.16666667', '8', '1.375', '3']
package org . apache . camel . component . stream ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class StreamComponent extends DefaultComponent < Exchange > { @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new StreamEndpoint ( uri , this ) ; } } 	0	['2', '3', '0', '4', '4', '1', '0', '4', '1', '2', '11', '0', '0', '0.972222222', '0.666666667', '1', '1', '4.5', '1', '0.5', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "csv" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CsvDataFormat extends DataFormatType { public CsvDataFormat ( ) { super ( "org.apache.camel.dataformat.csv.CsvDataFormat" ) ; } } 	1	['1', '3', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . camel . component . spring . integration ; import java . util . Map ; import org . apache . camel . impl . DefaultComponent ; public class SpringIntegrationComponent extends DefaultComponent < SpringIntegrationExchange > { protected SpringIntegrationEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { SpringIntegrationEndpoint endpoint = new SpringIntegrationEndpoint ( uri , remaining , this ) ; setProperties ( endpoint , parameters ) ; return endpoint ; } } 	0	['3', '3', '0', '3', '5', '3', '1', '3', '1', '2', '25', '0', '0', '0.945945946', '0.777777778', '1', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . camel . processor ; import java . util . Comparator ; import java . util . List ; import java . util . Set ; import java . util . TreeSet ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . util . ExpressionComparator ; import org . apache . camel . util . ExpressionListComparator ; public class Resequencer extends BatchProcessor { public Resequencer ( Processor processor , Expression expression ) { this ( processor , createSet ( expression ) ) ; } public Resequencer ( Processor processor , List < Expression > expressions ) { this ( processor , createSet ( expressions ) ) ; } public Resequencer ( Processor processor , Set < Exchange > collection ) { super ( processor , collection ) ; } @ Override public String toString ( ) { return "Resequencer[to: " + getProcessor ( ) + "]" ; } protected static Set < Exchange > createSet ( Expression < Exchange > expression ) { return createSet ( new ExpressionComparator < Exchange > ( expression ) ) ; } protected static Set < Exchange > createSet ( List < Expression > expressions ) { if ( expressions . size ( ) == 1 ) { return createSet ( expressions . get ( 0 ) ) ; } return createSet ( new ExpressionListComparator ( expressions ) ) ; } protected static Set < Exchange > createSet ( Comparator < ? super Exchange > comparator ) { return new TreeSet < Exchange > ( comparator ) ; } } 	1	['7', '3', '0', '6', '18', '21', '1', '5', '4', '2', '63', '0', '0', '0.894736842', '0.30952381', '0', '0', '8', '2', '0.7143', '2']
package org . apache . camel . component . cxf ; public interface CxfConstants { String METHOD = "method" ; String SERVICE_CLASS = "serviceClass" ; String DATA_FORMAT = "dataFormat" ; String SET_DEFAULT_BUS = "setDefaultBus" ; String WSDL_URL = "wsdlURL" ; String ADDRESS = "address" ; String SERVICE_NAME = "serviceName" ; String PORT_NAME = "portName" ; String SERVICE_LOCALNAME = "serviceLocalName" ; String SERVICE_NAMESPACE = "serviceNamespace" ; String PORT_LOCALNAME = "endpointLocalName" ; String PORT_NAMESPACE = "endpointNamespace" ; String PROTOCOL_NAME_RES = "res" ; String OPERATION_NAME = "operationName" ; String OPERATION_NAMESPACE = "operationNameSpace" ; String SPRING_CONTEXT_ENDPOINT = "bean:" ; String CAMEL_TRANSPORT_PREFIX = "camel:" ; String CXF_EXCHANGE = "org.apache.cxf.message.exchange" ; String CAMEL_EXCHANGE = "org.apache.camel.exchange" ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '19', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . converter ; import java . util . Collection ; import java . util . Iterator ; import org . apache . camel . Converter ; import org . apache . camel . util . ObjectHelper ; @ Converter public final class ObjectConverter { private ObjectConverter ( ) { } public static boolean isCollection ( Object value ) { return value instanceof Collection || ( value != null && value . getClass ( ) . isArray ( ) ) ; } @ SuppressWarnings ( "unchecked" ) @ Converter @ Deprecated public static Iterator iterator ( Object value ) { return ObjectHelper . createIterator ( value ) ; } @ Converter public static boolean toBool ( Object value ) { Boolean answer = toBoolean ( value ) ; if ( answer != null ) { return answer . booleanValue ( ) ; } return false ; } @ Converter public static Boolean toBoolean ( Object value ) { return ObjectHelper . toBoolean ( value ) ; } @ Converter public static Boolean toBoolean ( Boolean value ) { if ( value != null ) { return value ; } return Boolean . FALSE ; } @ Converter public static Byte toByte ( Object value ) { if ( value instanceof Byte ) { return ( Byte ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Byte . valueOf ( number . byteValue ( ) ) ; } else if ( value instanceof String ) { return Byte . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static byte [ ] toByteArray ( String value ) { return value . getBytes ( ) ; } @ Converter public static char [ ] toCharArray ( String value ) { return value . toCharArray ( ) ; } @ Converter public static String fromCharArray ( char [ ] value ) { return new String ( value ) ; } @ Converter public static Short toShort ( Object value ) { if ( value instanceof Short ) { return ( Short ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Short . valueOf ( number . shortValue ( ) ) ; } else if ( value instanceof String ) { return Short . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static Integer toInteger ( Object value ) { if ( value instanceof Integer ) { return ( Integer ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Integer . valueOf ( number . intValue ( ) ) ; } else if ( value instanceof String ) { return Integer . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static Long toLong ( Object value ) { if ( value instanceof Long ) { return ( Long ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Long . valueOf ( number . longValue ( ) ) ; } else if ( value instanceof String ) { return Long . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static Float toFloat ( Object value ) { if ( value instanceof Float ) { return ( Float ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Float . valueOf ( number . floatValue ( ) ) ; } else if ( value instanceof String ) { return Float . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static Double toDouble ( Object value ) { if ( value instanceof Double ) { return ( Double ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Double . valueOf ( number . doubleValue ( ) ) ; } else if ( value instanceof String ) { return Double . valueOf ( ( String ) value ) ; } else { return null ; } } } 	1	['15', '1', '0', '8', '42', '105', '7', '1', '14', '2', '214', '0', '0', '0', '0.2', '0', '0', '13.26666667', '4', '2.4667', '1']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeExchangeException ; import org . apache . camel . util . ServiceHelper ; public class ProcessorPollingConsumer extends PollingConsumerSupport { private Processor processor ; public ProcessorPollingConsumer ( Endpoint endpoint , Processor processor ) { super ( endpoint ) ; this . processor = processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startService ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopService ( processor ) ; } public Exchange receive ( ) { Exchange exchange = getEndpoint ( ) . createExchange ( ) ; try { processor . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeExchangeException ( e , exchange ) ; } return exchange ; } public Exchange receiveNoWait ( ) { return receive ( ) ; } public Exchange receive ( long timeout ) { return receive ( ) ; } } 	0	['6', '3', '0', '7', '13', '3', '1', '6', '4', '0', '46', '1', '1', '0.791666667', '0.375', '1', '1', '6.5', '1', '0.8333', '0']
package org . apache . camel ; public interface AsyncCallback { void done ( boolean doneSynchronously ) ; } 	1	['1', '1', '0', '56', '1', '0', '56', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . dataformat . xstream ; import java . io . InputStream ; import java . io . OutputStream ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . stream . XMLStreamWriter ; import com . thoughtworks . xstream . XStream ; import com . thoughtworks . xstream . io . HierarchicalStreamReader ; import com . thoughtworks . xstream . io . HierarchicalStreamWriter ; import com . thoughtworks . xstream . io . xml . QNameMap ; import com . thoughtworks . xstream . io . xml . StaxReader ; import com . thoughtworks . xstream . io . xml . StaxWriter ; import org . apache . camel . Exchange ; import org . apache . camel . converter . jaxp . StaxConverter ; import org . apache . camel . spi . DataFormat ; public class XStreamDataFormat extends AbstractXStreamWrapper { public XStreamDataFormat ( ) { super ( ) ; } public XStreamDataFormat ( XStream xstream ) { super ( xstream ) ; } public static XStreamDataFormat processAnnotations ( Iterable < Class < ? > > types ) { XStreamDataFormat answer = new XStreamDataFormat ( ) ; XStream xstream = answer . getXStream ( ) ; for ( Class < ? > type : types ) { xstream . processAnnotations ( type ) ; } return answer ; } public static XStreamDataFormat processAnnotations ( Class < ? > ... types ) { XStreamDataFormat answer = new XStreamDataFormat ( ) ; XStream xstream = answer . getXStream ( ) ; for ( Class < ? > type : types ) { xstream . processAnnotations ( type ) ; } return answer ; } protected HierarchicalStreamWriter createHierarchicalStreamWriter ( Exchange exchange , Object body , OutputStream stream ) throws XMLStreamException { XMLStreamWriter xmlWriter = getStaxConverter ( ) . createXMLStreamWriter ( stream ) ; return new StaxWriter ( new QNameMap ( ) , xmlWriter ) ; } protected HierarchicalStreamReader createHierarchicalStreamReader ( Exchange exchange , InputStream stream ) throws XMLStreamException { XMLStreamReader xmlReader = getStaxConverter ( ) . createXMLStreamReader ( stream ) ; return new StaxReader ( new QNameMap ( ) , xmlReader ) ; } } 	0	['6', '2', '0', '9', '19', '15', '0', '9', '4', '2', '90', '0', '0', '0.692307692', '0.25', '1', '2', '14', '2', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public final class Builder { private Builder ( ) { } public static < E extends Exchange > ValueBuilder < E > constant ( Object value ) { Expression < E > expression = ExpressionBuilder . constantExpression ( value ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > header ( String name ) { Expression < E > expression = ExpressionBuilder . headerExpression ( name ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > body ( ) { Expression < E > expression = ExpressionBuilder . bodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > bodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . bodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > outBody ( ) { Expression < E > expression = ExpressionBuilder . outBodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > outBodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . outBodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > faultBody ( ) { Expression < E > expression = ExpressionBuilder . faultBodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > faultBodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . faultBodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name ) { return systemProperty ( name , null ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name , final String defaultValue ) { return new ValueBuilder < E > ( ExpressionBuilder . < E > systemProperty ( name , defaultValue ) ) ; } } 	1	['11', '1', '0', '4', '22', '55', '1', '3', '10', '2', '86', '0', '0', '0', '0.181818182', '0', '0', '6.818181818', '1', '0.9091', '3']
package org . apache . camel . builder ; import org . apache . camel . Processor ; public class ConstantProcessorBuilder implements ProcessorFactory { private Processor processor ; public ConstantProcessorBuilder ( Processor processor ) { this . processor = processor ; } public Processor createProcessor ( ) { return processor ; } } 	0	['2', '1', '0', '3', '3', '0', '1', '2', '2', '0', '12', '1', '1', '0', '0.75', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . camel . processor . interceptor ; import java . util . List ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . converter . stream . StreamCache ; import org . apache . camel . model . InterceptorRef ; import org . apache . camel . model . InterceptorType ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . MessageHelper ; public class StreamCachingInterceptor extends DelegateProcessor implements AsyncProcessor { public StreamCachingInterceptor ( ) { super ( ) ; } public StreamCachingInterceptor ( Processor processor ) { this ( ) ; setProcessor ( processor ) ; } @ Override public String toString ( ) { return "StreamCachingInterceptor(" + processor + ")" ; } public static void noStreamCaching ( List < InterceptorType > interceptors ) { for ( int i = 0 ; i < interceptors . size ( ) ; i ++ ) { InterceptorType interceptor = interceptors . get ( i ) ; if ( interceptor instanceof InterceptorRef && ( ( InterceptorRef ) interceptor ) . getInterceptor ( ) instanceof StreamCachingInterceptor ) { interceptors . remove ( interceptor ) ; } } } @ Override public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { try { StreamCache newBody = exchange . getIn ( ) . getBody ( StreamCache . class ) ; if ( newBody != null ) { exchange . getIn ( ) . setBody ( newBody ) ; } MessageHelper . resetStreamCache ( exchange . getIn ( ) ) ; } catch ( NoTypeConversionAvailableException ex ) { } return proceed ( exchange , callback ) ; } public boolean proceed ( Exchange exchange , AsyncCallback callback ) { if ( getProcessor ( ) instanceof AsyncProcessor ) { return ( ( AsyncProcessor ) getProcessor ( ) ) . process ( exchange , callback ) ; } else { try { processor . process ( exchange ) ; } catch ( Throwable e ) { exchange . setException ( e ) ; } callback . done ( true ) ; return true ; } } } 	1	['7', '3', '0', '16', '27', '19', '4', '12', '7', '2', '105', '0', '0', '0.814814815', '0.371428571', '0', '0', '14', '4', '1.4286', '5']
package org . apache . camel . component . restlet ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; public class RestletHeaderFilterStrategy extends DefaultHeaderFilterStrategy { public RestletHeaderFilterStrategy ( ) { getOutFilter ( ) . add ( RestletConstants . LOGIN ) ; getOutFilter ( ) . add ( RestletConstants . PASSWORD ) ; } } 	0	['1', '2', '0', '2', '4', '0', '1', '1', '1', '2', '14', '0', '0', '1', '1', '0', '0', '13', '0', '0', '0']
package org . apache . camel ; public class InvalidPayloadException extends CamelExchangeException { private final Class < ? > type ; public InvalidPayloadException ( Exchange exchange , Class < ? > type ) { this ( exchange , type , exchange . getIn ( ) ) ; } public InvalidPayloadException ( Exchange exchange , Class < ? > type , Message message ) { super ( "No in body available of type: " + type . getName ( ) + NoSuchPropertyException . valueDescription ( message . getBody ( ) ) + " on: " + message , exchange ) ; this . type = type ; } public Class < ? > getType ( ) { return type ; } } 	1	['3', '5', '0', '5', '12', '1', '1', '4', '3', '0', '38', '1', '0', '0.95', '0.666666667', '0', '0', '11.33333333', '1', '0.3333', '1']
package org . apache . camel . spring . spi ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangeProperty ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . processor . DelayPolicy ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . transaction . TransactionDefinition ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . DefaultTransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionSynchronizationManager ; import org . springframework . transaction . support . TransactionTemplate ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class TransactionInterceptor extends DelegateProcessor { public static final ExchangeProperty < Boolean > TRANSACTED = new ExchangeProperty < Boolean > ( "transacted" , "org.apache.camel.transacted" , Boolean . class ) ; private static final transient Log LOG = LogFactory . getLog ( TransactionInterceptor . class ) ; private final TransactionTemplate transactionTemplate ; private RedeliveryPolicy redeliveryPolicy ; private DelayPolicy delayPolicy ; public TransactionInterceptor ( TransactionTemplate transactionTemplate ) { this . transactionTemplate = transactionTemplate ; } public TransactionInterceptor ( Processor processor , TransactionTemplate transactionTemplate ) { super ( processor ) ; this . transactionTemplate = transactionTemplate ; } public TransactionInterceptor ( Processor processor , TransactionTemplate transactionTemplate , RedeliveryPolicy redeliveryPolicy ) { this ( processor , transactionTemplate ) ; this . redeliveryPolicy = redeliveryPolicy ; this . delayPolicy = redeliveryPolicy ; } public TransactionInterceptor ( Processor processor , TransactionTemplate transactionTemplate , DelayPolicy delayPolicy ) { this ( processor , transactionTemplate ) ; this . delayPolicy = delayPolicy ; } @ Override public String toString ( ) { return "TransactionInterceptor:" + propagationBehaviorToString ( transactionTemplate . getPropagationBehavior ( ) ) + "[" + getProcessor ( ) + "]" ; } public void process ( final Exchange exchange ) { transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { RuntimeCamelException rce = null ; boolean activeTx = false ; try { activeTx = TransactionSynchronizationManager . isActualTransactionActive ( ) ; if ( ! activeTx ) { activeTx = status . isNewTransaction ( ) && ! status . isCompleted ( ) ; if ( ! activeTx ) { if ( DefaultTransactionStatus . class . isAssignableFrom ( status . getClass ( ) ) ) { DefaultTransactionStatus defStatus = DefaultTransactionStatus . class . cast ( status ) ; activeTx = defStatus . hasTransaction ( ) && ! status . isCompleted ( ) ; } } } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Is actual transaction active: " + activeTx ) ; } if ( activeTx ) { TRANSACTED . set ( exchange , Boolean . TRUE ) ; } processNext ( exchange ) ; if ( exchange . getException ( ) != null ) { rce = wrapRuntimeCamelException ( exchange . getException ( ) ) ; } } catch ( Exception e ) { rce = wrapRuntimeCamelException ( e ) ; } if ( rce != null ) { delayBeforeRedelivery ( ) ; if ( activeTx ) { status . setRollbackOnly ( ) ; LOG . debug ( "Setting transaction to rollbackOnly due to exception being thrown: " + rce . getMessage ( ) ) ; } throw rce ; } } } ) ; } protected void delayBeforeRedelivery ( ) { long delay = 0 ; if ( redeliveryPolicy != null ) { delay = redeliveryPolicy . getDelay ( ) ; } else if ( delayPolicy != null ) { delay = delayPolicy . getDelay ( ) ; } if ( delay > 0 ) { try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for: " + delay + " millis until attempting redelivery" ) ; } Thread . sleep ( delay ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Thread interrupted: " + e , e ) ; } } } } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public DelayPolicy getDelayPolicy ( ) { return delayPolicy ; } public void setDelayPolicy ( DelayPolicy delayPolicy ) { this . delayPolicy = delayPolicy ; } protected String propagationBehaviorToString ( int propagationBehavior ) { String rc ; switch ( propagationBehavior ) { case TransactionDefinition . PROPAGATION_MANDATORY : rc = "PROPAGATION_MANDATORY" ; break ; case TransactionDefinition . PROPAGATION_NESTED : rc = "PROPAGATION_NESTED" ; break ; case TransactionDefinition . PROPAGATION_NEVER : rc = "PROPAGATION_NEVER" ; break ; case TransactionDefinition . PROPAGATION_NOT_SUPPORTED : rc = "PROPAGATION_NOT_SUPPORTED" ; break ; case TransactionDefinition . PROPAGATION_REQUIRED : rc = "PROPAGATION_REQUIRED" ; break ; case TransactionDefinition . PROPAGATION_REQUIRES_NEW : rc = "PROPAGATION_REQUIRES_NEW" ; break ; case TransactionDefinition . PROPAGATION_SUPPORTS : rc = "PROPAGATION_SUPPORTS" ; break ; default : rc = "UNKNOWN" ; } return rc ; } } 	0	['15', '3', '0', '14', '35', '57', '4', '11', '10', '0.8', '195', '0.8', '3', '0.6875', '0.241071429', '0', '0', '11.66666667', '6', '1.0667', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . util . ExpressionHelper ; public class Delayer extends DelayProcessorSupport { private Expression < Exchange > timeExpression ; private long delay ; public Delayer ( Processor processor , Expression < Exchange > timeExpression , long delay ) { super ( processor ) ; this . timeExpression = timeExpression ; this . delay = delay ; } @ Override public String toString ( ) { return "Delayer[on: " + timeExpression + " delay: " + delay + " to: " + getProcessor ( ) + "]" ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } protected void delay ( Exchange exchange ) throws Exception { long time = 0 ; if ( timeExpression != null ) { Long longValue = ExpressionHelper . evaluateAsType ( timeExpression , exchange , Long . class ) ; if ( longValue != null ) { time = longValue . longValue ( ) ; } } if ( time <= 0 ) { time = defaultProcessTime ( exchange ) ; } time += delay ; waitUntil ( time , exchange ) ; } protected long defaultProcessTime ( Exchange exchange ) { return currentSystemTime ( ) ; } } 	1	['6', '4', '0', '6', '17', '0', '1', '5', '4', '0.4', '85', '1', '1', '0.861111111', '0.4', '1', '2', '12.83333333', '1', '0.8333', '3']
package org . apache . camel . component . jetty ; import java . net . URI ; import java . net . URISyntaxException ; import org . apache . camel . Consumer ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . component . http . HttpClientConfigurer ; import org . apache . camel . component . http . HttpConsumer ; import org . apache . camel . component . http . HttpEndpoint ; import org . apache . camel . component . http . HttpExchange ; import org . apache . camel . component . http . HttpPollingConsumer ; import org . apache . commons . httpclient . HttpConnectionManager ; import org . apache . commons . httpclient . params . HttpClientParams ; public class JettyHttpEndpoint extends HttpEndpoint { private JettyHttpComponent component ; private boolean sessionSupport ; public JettyHttpEndpoint ( JettyHttpComponent component , String uri , URI httpURL , HttpClientParams clientParams , HttpConnectionManager httpConnectionManager , HttpClientConfigurer clientConfigurer ) throws URISyntaxException { super ( uri , component , httpURL , clientParams , httpConnectionManager , clientConfigurer ) ; this . component = component ; } @ Override public Producer < HttpExchange > createProducer ( ) throws Exception { return super . createProducer ( ) ; } @ Override public Consumer < HttpExchange > createConsumer ( Processor processor ) throws Exception { return new HttpConsumer ( this , processor ) ; } @ Override public PollingConsumer < HttpExchange > createPollingConsumer ( ) throws Exception { return new HttpPollingConsumer ( this ) ; } @ Override public JettyHttpComponent getComponent ( ) { return component ; } public void setSessionSupport ( boolean support ) { sessionSupport = support ; } public boolean isSessionSupport ( ) { return sessionSupport ; } } 	0	['8', '5', '0', '13', '11', '24', '1', '13', '8', '0.785714286', '49', '1', '1', '0.877192982', '0.222222222', '1', '1', '4.875', '1', '0.875', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "proceed" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ProceedType extends OutputType < ProcessorType > { @ Override public String getShortName ( ) { return "proceed" ; } public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createOutputsProcessor ( routeContext ) ; } } 	1	['3', '4', '0', '7', '5', '3', '4', '3', '3', '2', '12', '0', '0', '0.988950276', '0.666666667', '1', '2', '3', '1', '0.6667', '1']
package org . apache . camel . component . restlet ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . CamelContextHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . restlet . Component ; import org . restlet . Guard ; import org . restlet . Restlet ; import org . restlet . Server ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Method ; import org . restlet . data . Protocol ; public class RestletComponent extends DefaultComponent < Exchange > implements HeaderFilterStrategyAware { private static final Log LOG = LogFactory . getLog ( RestletComponent . class ) ; private Map < String , Server > servers = new HashMap < String , Server > ( ) ; private Map < String , MethodBasedRouter > routers = new HashMap < String , MethodBasedRouter > ( ) ; private Component component = new Component ( ) ; private HeaderFilterStrategy headerFilterStrategy = new RestletHeaderFilterStrategy ( ) ; @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { RestletBinding restletBinding = null ; String ref = getAndRemoveParameter ( parameters , "restletBindingRef" , String . class ) ; if ( ref != null ) { restletBinding = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , ref , RestletBinding . class ) ; } if ( restletBinding == null ) { restletBinding = new DefaultRestletBinding ( ) ; } if ( restletBinding instanceof HeaderFilterStrategyAware ) { ( ( HeaderFilterStrategyAware ) restletBinding ) . setHeaderFilterStrategy ( headerFilterStrategy ) ; } Map < String , String > realm = null ; ref = getAndRemoveParameter ( parameters , "restletRealmRef" , String . class ) ; if ( ref != null ) { realm = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , ref , Map . class ) ; } Method method = getAndRemoveParameter ( parameters , "restletMethod" , Method . class ) ; RestletEndpoint result = new RestletEndpoint ( this , remaining , parameters , restletBinding ) ; if ( method != null ) { result . setRestletMethod ( method ) ; } if ( realm != null ) { result . setRealm ( realm ) ; } return result ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; component . start ( ) ; } @ Override protected void doStop ( ) throws Exception { component . stop ( ) ; super . doStop ( ) ; } public void connect ( RestletConsumer consumer ) throws Exception { RestletEndpoint endpoint = ( RestletEndpoint ) consumer . getEndpoint ( ) ; addServerIfNeccessary ( endpoint ) ; MethodBasedRouter router = getMethodRouter ( endpoint . getUriPattern ( ) ) ; Map < String , String > realm = endpoint . getRealm ( ) ; Restlet target = consumer . getRestlet ( ) ; if ( realm != null && realm . size ( ) > 0 ) { Guard guard = new Guard ( component . getContext ( ) . createChildContext ( ) , ChallengeScheme . HTTP_BASIC , "Camel-Restlet Endpoint Realm" ) ; for ( Map . Entry < String , String > entry : realm . entrySet ( ) ) { guard . getSecrets ( ) . put ( entry . getKey ( ) , entry . getValue ( ) . toCharArray ( ) ) ; } guard . setNext ( target ) ; target = guard ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Target has been set to guard: " + guard ) ; } } router . addRoute ( endpoint . getRestletMethod ( ) , target ) ; if ( ! router . hasBeenAttached ( ) ) { component . getDefaultHost ( ) . attach ( endpoint . getUriPattern ( ) , router ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Attached methodRouter uriPattern: " + endpoint . getUriPattern ( ) ) ; } } LOG . debug ( "Attached restlet uriPattern: " + endpoint . getUriPattern ( ) + " method: " + endpoint . getRestletMethod ( ) ) ; } public void disconnect ( RestletConsumer consumer ) throws Exception { RestletEndpoint endpoint = ( RestletEndpoint ) consumer . getEndpoint ( ) ; MethodBasedRouter router = getMethodRouter ( endpoint . getUriPattern ( ) ) ; router . removeRoute ( endpoint . getRestletMethod ( ) ) ; LOG . debug ( "Detached restlet uriPattern: " + endpoint . getUriPattern ( ) + " method: " + endpoint . getRestletMethod ( ) ) ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { this . headerFilterStrategy = strategy ; } private MethodBasedRouter getMethodRouter ( String uriPattern ) { synchronized ( routers ) { MethodBasedRouter result = routers . get ( uriPattern ) ; if ( result == null ) { result = new MethodBasedRouter ( uriPattern ) ; routers . put ( uriPattern , result ) ; } return result ; } } private void addServerIfNeccessary ( RestletEndpoint endpoint ) throws Exception { String key = buildKey ( endpoint ) ; Server server = null ; synchronized ( servers ) { server = servers . get ( key ) ; if ( server == null ) { server = component . getServers ( ) . add ( Protocol . valueOf ( endpoint . getProtocol ( ) ) , endpoint . getPort ( ) ) ; servers . put ( key , server ) ; LOG . info ( "Add server: " + key ) ; server . start ( ) ; } } } private static String buildKey ( RestletEndpoint endpoint ) { return endpoint . getHost ( ) + ":" + endpoint . getPort ( ) ; } } 	0	['12', '3', '0', '25', '71', '22', '1', '25', '5', '0.727272727', '391', '1', '1', '0.777777778', '0.272727273', '2', '3', '31.16666667', '2', '0.9167', '0']
package org . apache . camel ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . FactoryFinder ; public interface CamelContext extends Service { String getName ( ) ; void addComponent ( String componentName , Component component ) ; Component getComponent ( String componentName ) ; < T extends Component > T getComponent ( String name , Class < T > componentType ) ; Component removeComponent ( String componentName ) ; Component getOrCreateComponent ( String componentName , Callable < Component > factory ) ; Endpoint getEndpoint ( String uri ) ; < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) ; Collection < Endpoint > getEndpoints ( ) ; Collection < Endpoint > getEndpoints ( String uri ) ; Collection < Endpoint > getSingletonEndpoints ( ) ; Endpoint addEndpoint ( String uri , Endpoint endpoint ) throws Exception ; Collection < Endpoint > removeEndpoints ( String uri ) throws Exception ; @ Deprecated Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception ; @ Deprecated Endpoint removeSingletonEndpoint ( String uri ) throws Exception ; List < RouteType > getRouteDefinitions ( ) ; List < Route > getRoutes ( ) ; @ Deprecated void setRoutes ( List < Route > routes ) ; void addRoutes ( Collection < Route > routes ) throws Exception ; void addRoutes ( Routes builder ) throws Exception ; void addRouteDefinitions ( Collection < RouteType > routeDefinitions ) throws Exception ; ExchangeConverter getExchangeConverter ( ) ; TypeConverter getTypeConverter ( ) ; Registry getRegistry ( ) ; Injector getInjector ( ) ; LifecycleStrategy getLifecycleStrategy ( ) ; Language resolveLanguage ( String language ) ; < E extends Exchange > ProducerTemplate < E > createProducerTemplate ( ) ; void addInterceptStrategy ( InterceptStrategy interceptStrategy ) ; ErrorHandlerBuilder getErrorHandlerBuilder ( ) ; void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) ; void setDataFormats ( Map < String , DataFormatType > dataFormats ) ; Map < String , DataFormatType > getDataFormats ( ) ; FactoryFinder createFactoryFinder ( ) ; FactoryFinder createFactoryFinder ( String path ) ; } 	1	['35', '1', '0', '172', '35', '595', '162', '14', '35', '2', '35', '0', '0', '0', '0.147619048', '0', '0', '0', '1', '1', '10']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class InstanceMethodTypeConverter implements TypeConverter { private final CachingInjector injector ; private final Method method ; private final boolean useExchange ; public InstanceMethodTypeConverter ( CachingInjector injector , Method method ) { this . injector = injector ; this . method = method ; this . useExchange = method . getParameterTypes ( ) . length == 2 ; } @ Override public String toString ( ) { return "InstanceMethodTypeConverter: " + method ; } public < T > T convertTo ( Class < T > type , Object value ) { return convertTo ( type , null , value ) ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { Object instance = injector . newInstance ( ) ; if ( instance == null ) { throw new RuntimeCamelException ( "Could not instantiate an instance of: " + type . getName ( ) ) ; } return useExchange ? ( T ) ObjectHelper . invokeMethod ( method , instance , value , exchange ) : ( T ) ObjectHelper . invokeMethod ( method , instance , value ) ; } } 	0	['4', '1', '0', '6', '14', '0', '1', '5', '4', '0.222222222', '90', '1', '1', '0', '0.458333333', '0', '0', '20.75', '3', '1.25', '0']
package org . apache . camel . processor ; import java . util . Timer ; import java . util . TimerTask ; import java . util . concurrent . RejectedExecutionException ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . processor . exceptionpolicy . ExceptionPolicyStrategy ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . MessageHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannel extends ErrorHandlerSupport implements AsyncProcessor { public static final String REDELIVERY_COUNTER = "org.apache.camel.RedeliveryCounter" ; public static final String REDELIVERED = "org.apache.camel.Redelivered" ; public static final String EXCEPTION_CAUSE_PROPERTY = "CamelCauseException" ; public static final String CAUGHT_EXCEPTION_HEADER = "org.apache.camel.CamelCaughtException" ; private static final transient Log LOG = LogFactory . getLog ( DeadLetterChannel . class ) ; private static final String FAILURE_HANDLED_PROPERTY = DeadLetterChannel . class . getName ( ) + ".FAILURE_HANDLED" ; private static Timer timer = new Timer ( ) ; private Processor output ; private Processor deadLetter ; private AsyncProcessor outputAsync ; private RedeliveryPolicy redeliveryPolicy ; private Logger logger ; private Processor redeliveryProcessor ; private class RedeliveryData { int redeliveryCounter ; long redeliveryDelay ; boolean sync = true ; Predicate handledPredicate ; RedeliveryPolicy currentRedeliveryPolicy = redeliveryPolicy ; Processor failureProcessor = deadLetter ; } private class RedeliverTimerTask extends TimerTask { private final Exchange exchange ; private final AsyncCallback callback ; private final RedeliveryData data ; public RedeliverTimerTask ( Exchange exchange , AsyncCallback callback , RedeliveryData data ) { this . exchange = exchange ; this . callback = callback ; this . data = data ; } @ Override public void run ( ) { outputAsync . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } data . sync = false ; if ( exchange . getException ( ) != null && ! isFailureHandled ( exchange ) ) { asyncProcess ( exchange , callback , data ) ; } else { callback . done ( sync ) ; } } } ) ; } } public DeadLetterChannel ( Processor output , Processor deadLetter , Processor redeliveryProcessor , RedeliveryPolicy redeliveryPolicy , Logger logger , ExceptionPolicyStrategy exceptionPolicyStrategy ) { this . output = output ; this . deadLetter = deadLetter ; this . redeliveryProcessor = redeliveryProcessor ; this . outputAsync = AsyncProcessorTypeConverter . convert ( output ) ; this . redeliveryPolicy = redeliveryPolicy ; this . logger = logger ; setExceptionPolicy ( exceptionPolicyStrategy ) ; } public static < E extends Exchange > Logger createDefaultLogger ( ) { return new Logger ( LOG , LoggingLevel . ERROR ) ; } @ Override public String toString ( ) { return "DeadLetterChannel[" + output + ", " + deadLetter + "]" ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( Exchange exchange , final AsyncCallback callback ) { return process ( exchange , callback , new RedeliveryData ( ) ) ; } protected boolean process ( final Exchange exchange , final AsyncCallback callback , final RedeliveryData data ) { while ( true ) { if ( ! isRunAllowed ( ) ) { if ( exchange . getException ( ) == null ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } callback . done ( data . sync ) ; return data . sync ; } if ( exchange . isTransacted ( ) && exchange . getException ( ) != null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "This is a transacted exchange, bypassing this DeadLetterChannel: " + this + " for exchange: " + exchange ) ; } return data . sync ; } if ( exchange . getException ( ) != null ) { handleException ( exchange , data ) ; } boolean shouldRedeliver = shouldRedeliver ( exchange , data ) ; if ( ! shouldRedeliver ) { return deliverToFaultProcessor ( exchange , callback , data ) ; } if ( data . redeliveryCounter > 0 ) { if ( exchange . getException ( ) != null ) { exchange . setException ( null ) ; } MessageHelper . resetStreamCache ( exchange . getIn ( ) ) ; data . redeliveryDelay = data . currentRedeliveryPolicy . sleep ( data . redeliveryDelay ) ; deliverToRedeliveryProcessor ( exchange , callback , data ) ; } boolean sync = outputAsync . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } data . sync = false ; if ( exchange . getException ( ) != null && ! isFailureHandled ( exchange ) ) { asyncProcess ( exchange , callback , data ) ; } else { callback . done ( sync ) ; } } } ) ; if ( ! sync ) { return false ; } if ( exchange . getException ( ) == null || isFailureHandled ( exchange ) ) { callback . done ( true ) ; return true ; } } } protected void asyncProcess ( final Exchange exchange , final AsyncCallback callback , final RedeliveryData data ) { if ( ! isRunAllowed ( ) ) { if ( exchange . getException ( ) == null ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } callback . done ( data . sync ) ; return ; } if ( exchange . isTransacted ( ) && exchange . getException ( ) != null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "This is a transacted exchange, bypassing this DeadLetterChannel: " + this + " for exchange: " + exchange ) ; } return ; } if ( exchange . getException ( ) != null ) { handleException ( exchange , data ) ; } boolean shouldRedeliver = shouldRedeliver ( exchange , data ) ; if ( ! shouldRedeliver ) { deliverToFaultProcessor ( exchange , callback , data ) ; return ; } if ( data . redeliveryCounter > 0 ) { if ( exchange . getException ( ) != null ) { exchange . setException ( null ) ; } data . redeliveryDelay = data . currentRedeliveryPolicy . getRedeliveryDelay ( data . redeliveryDelay ) ; timer . schedule ( new RedeliverTimerTask ( exchange , callback , data ) , data . redeliveryDelay ) ; deliverToRedeliveryProcessor ( exchange , callback , data ) ; } } private void handleException ( Exchange exchange , RedeliveryData data ) { Throwable e = exchange . getException ( ) ; exchange . setProperty ( EXCEPTION_CAUSE_PROPERTY , e ) ; ExceptionType exceptionPolicy = getExceptionPolicy ( exchange , e ) ; if ( exceptionPolicy != null ) { data . currentRedeliveryPolicy = exceptionPolicy . createRedeliveryPolicy ( exchange . getContext ( ) , data . currentRedeliveryPolicy ) ; data . handledPredicate = exceptionPolicy . getHandledPolicy ( ) ; Processor processor = exceptionPolicy . getErrorHandler ( ) ; if ( processor != null ) { data . failureProcessor = processor ; } } String msg = "Failed delivery for exchangeId: " + exchange . getExchangeId ( ) + ". On delivery attempt: " + data . redeliveryCounter + " caught: " + e ; logFailedDelivery ( true , exchange , msg , data , e ) ; data . redeliveryCounter = incrementRedeliveryCounter ( exchange , e ) ; } private boolean deliverToRedeliveryProcessor ( final Exchange exchange , final AsyncCallback callback , final RedeliveryData data ) { if ( redeliveryProcessor == null ) { return true ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "RedeliveryProcessor " + redeliveryProcessor + " is processing Exchange before its redelivered" ) ; } AsyncProcessor afp = AsyncProcessorTypeConverter . convert ( redeliveryProcessor ) ; boolean sync = afp . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { callback . done ( data . sync ) ; } } ) ; return sync ; } private boolean deliverToFaultProcessor ( final Exchange exchange , final AsyncCallback callback , final RedeliveryData data ) { setFailureHandled ( exchange ) ; decrementRedeliveryCounter ( exchange ) ; AsyncProcessor afp = AsyncProcessorTypeConverter . convert ( data . failureProcessor ) ; boolean sync = afp . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { restoreExceptionOnExchange ( exchange , data . handledPredicate ) ; callback . done ( data . sync ) ; } } ) ; String msg = "Failed delivery for exchangeId: " + exchange . getExchangeId ( ) + ". Handled by the failure processor: " + data . failureProcessor ; logFailedDelivery ( false , exchange , msg , data , null ) ; return sync ; } public static boolean isFailureHandled ( Exchange exchange ) { return exchange . getProperty ( FAILURE_HANDLED_PROPERTY ) != null || exchange . getIn ( ) . getHeader ( CAUGHT_EXCEPTION_HEADER ) != null ; } public static void setFailureHandled ( Exchange exchange ) { exchange . setProperty ( FAILURE_HANDLED_PROPERTY , exchange . getException ( ) ) ; exchange . getIn ( ) . setHeader ( CAUGHT_EXCEPTION_HEADER , exchange . getException ( ) ) ; exchange . setException ( null ) ; } public Processor getOutput ( ) { return output ; } public Processor getDeadLetter ( ) { return deadLetter ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } protected static void restoreExceptionOnExchange ( Exchange exchange , Predicate handledPredicate ) { if ( handledPredicate == null || ! handledPredicate . matches ( exchange ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "This exchange is not handled so its marked as failed: " + exchange ) ; } exchange . setException ( exchange . getProperty ( FAILURE_HANDLED_PROPERTY , Throwable . class ) ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "This exchange is handled so its marked as not failed: " + exchange ) ; } exchange . setProperty ( Exchange . EXCEPTION_HANDLED_PROPERTY , Boolean . TRUE ) ; } } private void logFailedDelivery ( boolean shouldRedeliver , Exchange exchange , String message , RedeliveryData data , Throwable e ) { LoggingLevel newLogLevel ; if ( shouldRedeliver ) { newLogLevel = data . currentRedeliveryPolicy . getRetryAttemptedLogLevel ( ) ; } else { newLogLevel = data . currentRedeliveryPolicy . getRetriesExhaustedLogLevel ( ) ; } if ( e != null ) { logger . log ( message , e , newLogLevel ) ; } else { logger . log ( message , newLogLevel ) ; } } private boolean shouldRedeliver ( Exchange exchange , RedeliveryData data ) { return data . currentRedeliveryPolicy . shouldRedeliver ( data . redeliveryCounter ) ; } protected int incrementRedeliveryCounter ( Exchange exchange , Throwable e ) { Message in = exchange . getIn ( ) ; Integer counter = in . getHeader ( REDELIVERY_COUNTER , Integer . class ) ; int next = 1 ; if ( counter != null ) { next = counter + 1 ; } in . setHeader ( REDELIVERY_COUNTER , next ) ; in . setHeader ( REDELIVERED , Boolean . TRUE ) ; return next ; } private void decrementRedeliveryCounter ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Integer counter = in . getHeader ( REDELIVERY_COUNTER , Integer . class ) ; if ( counter != null ) { int prev = counter - 1 ; in . setHeader ( REDELIVERY_COUNTER , prev ) ; in . setHeader ( REDELIVERED , prev > 0 ? Boolean . TRUE : Boolean . FALSE ) ; } else { in . setHeader ( REDELIVERY_COUNTER , 0 ) ; in . setHeader ( REDELIVERED , Boolean . FALSE ) ; } } @ Override protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output , deadLetter ) ; } @ Override protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( deadLetter , output ) ; } } 	1	['29', '3', '0', '28', '85', '296', '9', '24', '13', '0.914835165', '713', '0.692307692', '6', '0.413043478', '0.167582418', '1', '1', '23.13793103', '12', '2.1379', '11']
package org . apache . camel . component . atom ; import java . util . Date ; import org . apache . abdera . model . Entry ; import org . apache . abdera . model . Feed ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultPollingEndpoint ; import org . apache . camel . util . ObjectHelper ; public class AtomEndpoint extends DefaultPollingEndpoint < Exchange > { public static final String HEADER_ATOM_FEED = "org.apache.camel.component.atom.feed" ; private String atomUri ; private boolean splitEntries = true ; private Date lastUpdate ; private boolean filter = true ; public AtomEndpoint ( String endpointUri , AtomComponent component , String atomUri ) { super ( endpointUri , component ) ; this . atomUri = atomUri ; ObjectHelper . notNull ( atomUri , "atomUri property" ) ; } public AtomEndpoint ( String endpointUri , String atomUri ) { this ( endpointUri ) ; this . atomUri = atomUri ; ObjectHelper . notNull ( atomUri , "atomUri property" ) ; } public AtomEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public boolean isSingleton ( ) { return true ; } public Producer < Exchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "AtomProducer is not implemented" ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { AtomConsumerSupport answer ; if ( isSplitEntries ( ) ) { answer = new AtomEntryPollingConsumer ( this , processor , filter , lastUpdate ) ; } else { answer = new AtomPollingConsumer ( this , processor ) ; } answer . setDelay ( AtomConsumerSupport . DEFAULT_CONSUMER_DELAY ) ; configureConsumer ( answer ) ; return answer ; } public Exchange createExchange ( Feed feed ) { Exchange exchange = createExchange ( ) ; exchange . getIn ( ) . setBody ( feed . getEntries ( ) ) ; exchange . getIn ( ) . setHeader ( HEADER_ATOM_FEED , feed ) ; return exchange ; } public Exchange createExchange ( Feed feed , Entry entry ) { Exchange exchange = createExchange ( ) ; exchange . getIn ( ) . setBody ( entry ) ; exchange . getIn ( ) . setHeader ( HEADER_ATOM_FEED , feed ) ; return exchange ; } public String getAtomUri ( ) { return atomUri ; } public void setAtomUri ( String atomUri ) { this . atomUri = atomUri ; } public boolean isSplitEntries ( ) { return splitEntries ; } public void setSplitEntries ( boolean splitEntries ) { this . splitEntries = splitEntries ; } public Date getLastUpdate ( ) { return lastUpdate ; } public void setLastUpdate ( Date lastUpdate ) { this . lastUpdate = lastUpdate ; } public boolean isFilter ( ) { return filter ; } public void setFilter ( boolean filter ) { this . filter = filter ; } } 	0	['16', '4', '0', '17', '29', '72', '7', '14', '16', '0.813333333', '150', '0.8', '0', '0.69047619', '0.21875', '1', '1', '8.0625', '1', '0.8125', '0']
package org . apache . camel ; public class RuntimeExchangeException extends RuntimeCamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final Exchange exchange ; public RuntimeExchangeException ( String message , Exchange exchange ) { super ( message + " on the exchange: " + exchange ) ; this . exchange = exchange ; } public RuntimeExchangeException ( Exception e , Exchange exchange ) { super ( e . getMessage ( ) , e ) ; this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } } 	1	['3', '5', '1', '5', '10', '0', '3', '2', '3', '0.75', '33', '1', '1', '0.944444444', '0.583333333', '0', '0', '9.333333333', '1', '0.3333', '1']
package org . apache . camel . component . cxf . interceptors ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . apache . cxf . binding . xml . XMLConstants ; import org . apache . cxf . binding . xml . XMLFault ; import org . apache . cxf . bindings . xformat . XMLBindingMessageFormat ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . MessagePartInfo ; import org . apache . cxf . staxutils . StaxUtils ; public class XMLMessageInInterceptor extends AbstractMessageInInterceptor < XMLMessage > { private static final Logger LOG = LogUtils . getL7dLogger ( XMLMessageInInterceptor . class ) ; public XMLMessageInInterceptor ( ) { super ( Phase . READ ) ; } protected Logger getLogger ( ) { return LOG ; } protected boolean isFaultMessage ( XMLMessage message ) { XMLStreamReader xsr = message . getContent ( XMLStreamReader . class ) ; boolean isFault = false ; try { if ( StaxUtils . skipToStartOfElement ( xsr ) ) { QName startQName = xsr . getName ( ) ; isFault = XMLConstants . NS_XML_FORMAT . equals ( startQName . getNamespaceURI ( ) ) && XMLFault . XML_FAULT_ROOT . equals ( startQName . getLocalPart ( ) ) ; } } catch ( XMLStreamException xse ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "STAX_READ_EXC" , LOG ) ) ; } return isFault ; } protected BindingOperationInfo getBindingOperation ( XMLMessage message , Document doc ) { Exchange ex = message . getExchange ( ) ; BindingInfo binding = ex . get ( BindingInfo . class ) ; if ( binding == null ) { Endpoint ep = ex . get ( Endpoint . class ) ; binding = ep . getEndpointInfo ( ) . getBinding ( ) ; } Element payloadEl = ( Element ) doc . getChildNodes ( ) . item ( 0 ) ; QName startQName = new QName ( payloadEl . getNamespaceURI ( ) , payloadEl . getLocalName ( ) ) ; boolean client = isRequestor ( message ) ; List < BindingOperationInfo > boiList = new ArrayList < BindingOperationInfo > ( ) ; for ( BindingOperationInfo boi : binding . getOperations ( ) ) { BindingMessageInfo bmi = client ? boi . getOutput ( ) : boi . getInput ( ) ; QName rootName = null ; if ( bmi != null ) { XMLBindingMessageFormat msgFormat = bmi . getExtensor ( XMLBindingMessageFormat . class ) ; if ( msgFormat != null ) { rootName = msgFormat . getRootNode ( ) ; } else { Collection < MessagePartInfo > bodyParts = bmi . getMessageParts ( ) ; if ( bodyParts . size ( ) == 1 ) { MessagePartInfo p = bodyParts . iterator ( ) . next ( ) ; rootName = p . getConcreteName ( ) ; } } } if ( startQName . equals ( rootName ) ) { boiList . add ( boi ) ; } } BindingOperationInfo match = null ; if ( boiList . size ( ) > 1 ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "Mulitple matching BindingOperationIno found in Binding." ) ; } } else if ( ! boiList . isEmpty ( ) ) { match = boiList . get ( 0 ) ; } return match ; } protected List < Element > getPartList ( XMLMessage inMessage , Element rootNode , BindingMessageInfo bmi ) { List < Element > partList = new ArrayList < Element > ( ) ; XMLBindingMessageFormat msgFormat = bmi . getExtensor ( XMLBindingMessageFormat . class ) ; if ( msgFormat != null ) { NodeList nodeList = rootNode . getChildNodes ( ) ; for ( int idx = 0 ; idx < nodeList . getLength ( ) ; idx ++ ) { partList . add ( ( Element ) nodeList . item ( idx ) ) ; } } else { partList . add ( rootNode ) ; } return partList ; } } 	0	['9', '1', '0', '16', '50', '24', '1', '15', '1', '0.375', '239', '1', '0', '0.5', '0.416666667', '1', '4', '25.44444444', '10', '2.1111', '0']
package org . apache . camel ; public class ResolveEndpointFailedException extends RuntimeCamelException { private final String uri ; public ResolveEndpointFailedException ( String uri , Throwable cause ) { super ( "Failed to resolve endpoint: " + uri + " due to: " + cause , cause ) ; this . uri = uri ; } public ResolveEndpointFailedException ( String uri , String message ) { super ( "Failed to resolve endpoint: " + uri + " due to: " + message ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	1	['3', '5', '0', '5', '9', '0', '4', '1', '3', '0', '44', '1', '0', '0.944444444', '0.666666667', '0', '0', '13.33333333', '1', '0.3333', '1']
package org . apache . camel . component . atom ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; public abstract class AtomConsumerSupport extends ScheduledPollConsumer < Exchange > { public static final long DEFAULT_CONSUMER_DELAY = 60 * 1000L ; protected final AtomEndpoint endpoint ; public AtomConsumerSupport ( AtomEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } } 	0	['1', '4', '1', '5', '2', '0', '2', '4', '1', '2', '11', '0.5', '1', '1', '1', '0', '0', '8', '0', '0', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "hl7" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class HL7DataFormat extends DataFormatType { public HL7DataFormat ( ) { super ( "org.apache.camel.dataformat.hl7.HL7DataFormat" ) ; } } 	1	['1', '3', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . camel . component . spring . integration ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . spring . SpringCamelContext ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . integration . channel . BeanFactoryChannelResolver ; import org . springframework . integration . channel . ChannelResolver ; import org . springframework . integration . channel . DirectChannel ; import org . springframework . integration . core . Message ; import org . springframework . integration . core . MessageChannel ; import org . springframework . integration . core . MessageHeaders ; import org . springframework . integration . message . MessageHandler ; public class SpringIntegrationProducer extends DefaultProducer < SpringIntegrationExchange > implements AsyncProcessor { private static final transient Log LOG = LogFactory . getLog ( SpringIntegrationProducer . class ) ; private SpringCamelContext context ; private DirectChannel inputChannel ; private MessageChannel outputChannel ; private String outputChannelName ; private ChannelResolver channelResolver ; private SpringIntegrationEndpoint endpoint ; public SpringIntegrationProducer ( SpringIntegrationEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; context = ( SpringCamelContext ) endpoint . getCamelContext ( ) ; if ( context != null && endpoint . getMessageChannel ( ) == null ) { outputChannelName = endpoint . getDefaultChannel ( ) ; channelResolver = new BeanFactoryChannelResolver ( context . getApplicationContext ( ) ) ; if ( ObjectHelper . isNullOrBlank ( outputChannelName ) ) { outputChannelName = endpoint . getInputChannel ( ) ; } if ( ObjectHelper . isNullOrBlank ( outputChannelName ) ) { throw new RuntimeCamelException ( "Can't find the right outputChannelName, " + "please check the endpoint uri outputChannel part!" ) ; } else { outputChannel = channelResolver . resolveChannelName ( outputChannelName ) ; } } else { if ( endpoint . getMessageChannel ( ) != null ) { outputChannel = endpoint . getMessageChannel ( ) ; } else { throw new RuntimeCamelException ( "Can't find the right message channel, please check your configuration." ) ; } } if ( endpoint . isInOut ( ) ) { endpoint . setExchangePattern ( ExchangePattern . InOut ) ; if ( ObjectHelper . isNullOrBlank ( endpoint . getInputChannel ( ) ) ) { throw new RuntimeCamelException ( "Can't find the right inputChannel, " + "please check the endpoint uri inputChannel part!" ) ; } else { inputChannel = ( DirectChannel ) channelResolver . resolveChannelName ( endpoint . getInputChannel ( ) ) ; } } else { endpoint . setExchangePattern ( ExchangePattern . InOnly ) ; } } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { Map < String , Object > headers = new HashMap < String , Object > ( ) ; if ( exchange . getPattern ( ) . isOutCapable ( ) ) { headers . put ( MessageHeaders . REPLY_CHANNEL , inputChannel ) ; inputChannel . subscribe ( new MessageHandler ( ) { public void handleMessage ( Message < ? > message ) { SpringIntegrationBinding . storeToCamelMessage ( message , exchange . getOut ( ) ) ; callback . done ( true ) ; } } ) ; } org . springframework . integration . core . Message siOutmessage = SpringIntegrationBinding . createSpringIntegrationMessage ( exchange , headers ) ; outputChannel . send ( siOutmessage ) ; if ( ! exchange . getPattern ( ) . isOutCapable ( ) ) { callback . done ( true ) ; } return true ; } } 	0	['4', '3', '0', '24', '27', '4', '2', '24', '3', '0.904761905', '156', '1', '2', '0.913043478', '0.583333333', '0', '0', '36.25', '3', '1', '0']
package org . apache . camel . builder ; import java . util . Map ; import org . apache . camel . Expression ; import org . apache . camel . builder . xml . Namespaces ; import org . apache . camel . model . ExpressionNode ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . model . language . MethodCallExpression ; import org . apache . camel . model . language . XPathExpression ; import org . apache . camel . model . language . XQueryExpression ; public class ExpressionClause < T > extends ExpressionType { private T result ; private String language ; public ExpressionClause ( T result ) { this . result = result ; } public static < T extends ExpressionNode > ExpressionClause < T > createAndSetExpression ( T result ) { ExpressionClause < T > clause = new ExpressionClause < T > ( result ) ; result . setExpression ( clause ) ; return clause ; } public T expression ( Expression expression ) { setExpressionValue ( expression ) ; return result ; } public T constant ( Object value ) { return expression ( ExpressionBuilder . constantExpression ( value ) ) ; } public T exchange ( ) { return expression ( ExpressionBuilder . exchangeExpression ( ) ) ; } public T inMessage ( ) { return expression ( ExpressionBuilder . inMessageExpression ( ) ) ; } public T outMessage ( ) { return expression ( ExpressionBuilder . outMessageExpression ( ) ) ; } public T body ( ) { return expression ( ExpressionBuilder . bodyExpression ( ) ) ; } public T body ( Class expectedType ) { return expression ( ExpressionBuilder . bodyExpression ( expectedType ) ) ; } public T outBody ( ) { return expression ( ExpressionBuilder . outBodyExpression ( ) ) ; } public T outBody ( Class expectedType ) { return expression ( ExpressionBuilder . outBodyExpression ( expectedType ) ) ; } public T header ( String name ) { return expression ( ExpressionBuilder . headerExpression ( name ) ) ; } public T headers ( ) { return expression ( ExpressionBuilder . headersExpression ( ) ) ; } public T outHeader ( String name ) { return expression ( ExpressionBuilder . outHeaderExpression ( name ) ) ; } public T outHeaders ( ) { return expression ( ExpressionBuilder . outHeadersExpression ( ) ) ; } public T property ( String name ) { return expression ( ExpressionBuilder . propertyExpression ( name ) ) ; } public T properties ( ) { return expression ( ExpressionBuilder . propertiesExpression ( ) ) ; } public T method ( String bean ) { MethodCallExpression expression = new MethodCallExpression ( bean ) ; setExpressionType ( expression ) ; return result ; } public T method ( String bean , String method ) { MethodCallExpression expression = new MethodCallExpression ( bean , method ) ; setExpressionType ( expression ) ; return result ; } public T beanShell ( String text ) { return language ( "beanshell" , text ) ; } public T el ( String text ) { return language ( "el" , text ) ; } public T groovy ( String text ) { return language ( "groovy" , text ) ; } public T javaScript ( String text ) { return language ( "js" , text ) ; } public T jxpath ( String text ) { return language ( "jxpath" , text ) ; } public T ognl ( String text ) { return language ( "ognl" , text ) ; } public T php ( String text ) { return language ( "php" , text ) ; } public T python ( String text ) { return language ( "python" , text ) ; } public T ruby ( String text ) { return language ( "ruby" , text ) ; } public T sql ( String text ) { return language ( "sql" , text ) ; } public T simple ( String text ) { return language ( "simple" , text ) ; } public T xpath ( String text ) { return language ( "xpath" , text ) ; } public T xpath ( String text , Class resultType ) { XPathExpression expression = new XPathExpression ( text ) ; expression . setResultType ( resultType ) ; setExpressionType ( expression ) ; return result ; } public T xpath ( String text , Class resultType , Namespaces namespaces ) { return xpath ( text , resultType , namespaces . getNamespaces ( ) ) ; } public T xpath ( String text , Class resultType , Map < String , String > namespaces ) { XPathExpression expression = new XPathExpression ( text ) ; expression . setResultType ( resultType ) ; expression . setNamespaces ( namespaces ) ; setExpressionType ( expression ) ; return result ; } public T xpath ( String text , Namespaces namespaces ) { return xpath ( text , namespaces . getNamespaces ( ) ) ; } public T xpath ( String text , Map < String , String > namespaces ) { XPathExpression expression = new XPathExpression ( text ) ; expression . setNamespaces ( namespaces ) ; setExpressionType ( expression ) ; return result ; } public T xquery ( String text ) { return language ( "xquery" , text ) ; } public T xquery ( String text , Class resultType ) { XQueryExpression expression = new XQueryExpression ( text ) ; expression . setResultType ( resultType ) ; setExpressionType ( expression ) ; return result ; } public T xquery ( String text , Class resultType , Namespaces namespaces ) { return xquery ( text , resultType , namespaces . getNamespaces ( ) ) ; } public T xquery ( String text , Class resultType , Map < String , String > namespaces ) { XQueryExpression expression = new XQueryExpression ( text ) ; expression . setResultType ( resultType ) ; expression . setNamespaces ( namespaces ) ; setExpressionType ( expression ) ; return result ; } public T xquery ( String text , Namespaces namespaces ) { return xquery ( text , namespaces . getNamespaces ( ) ) ; } public T xquery ( String text , Map < String , String > namespaces ) { XQueryExpression expression = new XQueryExpression ( text ) ; expression . setNamespaces ( namespaces ) ; setExpressionType ( expression ) ; return result ; } public T language ( String language , String expression ) { setLanguage ( language ) ; setExpression ( expression ) ; return result ; } public String getLanguage ( ) { return language ; } public void setLanguage ( String language ) { this . language = language ; } } 	1	['45', '2', '0', '13', '73', '878', '5', '8', '45', '0.5', '351', '1', '0', '0.333333333', '0.261111111', '1', '2', '6.755555556', '1', '0.9778', '1']
package org . apache . camel . component . http ; import java . net . URI ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; import org . apache . commons . httpclient . HttpConnectionManager ; import org . apache . commons . httpclient . MultiThreadedHttpConnectionManager ; import org . apache . commons . httpclient . params . HttpClientParams ; public class HttpComponent extends DefaultComponent < HttpExchange > implements HeaderFilterStrategyAware { protected HttpClientConfigurer httpClientConfigurer ; protected HttpConnectionManager httpConnectionManager = new MultiThreadedHttpConnectionManager ( ) ; protected HeaderFilterStrategy headerFilterStrategy ; protected HttpBinding httpBinding ; public HttpComponent ( ) { this . setHeaderFilterStrategy ( new HttpHeaderFilterStrategy ( ) ) ; } public void connect ( HttpConsumer consumer ) throws Exception { } public void disconnect ( HttpConsumer consumer ) throws Exception { } protected void configureParameters ( Map parameters ) { String ref = getAndRemoveParameter ( parameters , "httpBindingRef" , String . class ) ; if ( ref != null ) { httpBinding = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , ref , HttpBinding . class ) ; } String username = getAndRemoveParameter ( parameters , "username" , String . class ) ; String password = getAndRemoveParameter ( parameters , "password" , String . class ) ; if ( username != null && password != null ) { httpClientConfigurer = new BasicAuthenticationHttpClientConfigurer ( username , password ) ; } ref = getAndRemoveParameter ( parameters , "httpClientConfigurerRef" , String . class ) ; if ( ref != null ) { httpClientConfigurer = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , ref , HttpClientConfigurer . class ) ; } } @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { HttpClientParams params = new HttpClientParams ( ) ; IntrospectionSupport . setProperties ( params , parameters , "httpClient." ) ; configureParameters ( parameters ) ; URI httpUri = URISupport . createRemainingURI ( new URI ( uri ) , parameters ) ; uri = httpUri . toString ( ) ; String part = httpUri . getSchemeSpecificPart ( ) ; if ( part != null ) { part = part . toLowerCase ( ) ; if ( part . startsWith ( "//http//" ) || part . startsWith ( "//https//" ) ) { throw new ResolveEndpointFailedException ( uri , "The uri part is not configured correctly. You have duplicated the http(s) protocol." ) ; } } HttpEndpoint endpoint = new HttpEndpoint ( uri , this , httpUri , params , httpConnectionManager , httpClientConfigurer ) ; if ( httpBinding != null ) { endpoint . setBinding ( httpBinding ) ; } return endpoint ; } @ Override protected boolean useIntrospectionOnEndpoint ( ) { return false ; } public HttpClientConfigurer getHttpClientConfigurer ( ) { return httpClientConfigurer ; } public void setHttpClientConfigurer ( HttpClientConfigurer httpClientConfigurer ) { this . httpClientConfigurer = httpClientConfigurer ; } public HttpConnectionManager getHttpConnectionManager ( ) { return httpConnectionManager ; } public void setHttpConnectionManager ( HttpConnectionManager httpConnectionManager ) { this . httpConnectionManager = httpConnectionManager ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } public HttpBinding getHttpBinding ( ) { return httpBinding ; } public void setHttpBinding ( HttpBinding httpBinding ) { this . httpBinding = httpBinding ; } } 	0	['14', '3', '1', '20', '32', '55', '3', '18', '11', '0.788461538', '188', '1', '3', '0.729166667', '0.205357143', '1', '2', '12.14285714', '5', '1.2143', '0']
package org . apache . camel . component . file . strategy ; import java . util . Map ; import org . apache . camel . Expression ; import org . apache . camel . component . file . FileProcessStrategy ; public final class FileProcessStrategyFactory { private FileProcessStrategyFactory ( ) { } public static FileProcessStrategy createFileProcessStrategy ( Map < String , Object > params ) { boolean isDelete = params . get ( "delete" ) != null ; boolean isLock = params . get ( "lock" ) != null ; String moveNamePrefix = ( String ) params . get ( "moveNamePrefix" ) ; String moveNamePostfix = ( String ) params . get ( "moveNamePostfix" ) ; String preMoveNamePrefix = ( String ) params . get ( "preMoveNamePrefix" ) ; String preMoveNamePostfix = ( String ) params . get ( "preMoveNamePostfix" ) ; Expression expression = ( Expression ) params . get ( "expression" ) ; Expression preMoveExpression = ( Expression ) params . get ( "preMoveExpression" ) ; boolean move = moveNamePrefix != null || moveNamePostfix != null ; boolean preMove = preMoveNamePrefix != null || preMoveNamePostfix != null ; if ( params . containsKey ( "noop" ) ) { return new NoOpFileProcessStrategy ( isLock ) ; } else if ( move || preMove ) { RenameFileProcessStrategy strategy = new RenameFileProcessStrategy ( isLock ) ; if ( move ) { strategy . setCommitRenamer ( new DefaultFileRenamer ( moveNamePrefix , moveNamePostfix ) ) ; } if ( preMove ) { strategy . setBeginRenamer ( new DefaultFileRenamer ( preMoveNamePrefix , preMoveNamePostfix ) ) ; } return strategy ; } else if ( expression != null || preMoveExpression != null ) { RenameFileProcessStrategy strategy = new RenameFileProcessStrategy ( isLock ) ; if ( expression != null ) { FileExpressionRenamer renamer = new FileExpressionRenamer ( ) ; renamer . setExpression ( expression ) ; strategy . setCommitRenamer ( renamer ) ; } if ( preMoveExpression != null ) { FileExpressionRenamer renamer = new FileExpressionRenamer ( ) ; renamer . setExpression ( preMoveExpression ) ; strategy . setBeginRenamer ( renamer ) ; } return strategy ; } else if ( isDelete ) { return new DeleteFileProcessStrategy ( isLock ) ; } else { return new RenameFileProcessStrategy ( isLock ) ; } } } 	1	['2', '1', '0', '8', '13', '1', '0', '8', '1', '2', '152', '0', '0', '0', '0.5', '0', '0', '75', '17', '8.5', '4']
package org . apache . camel . bam . model ; import java . util . List ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . Table ; import javax . persistence . UniqueConstraint ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; @ Entity @ Table ( name = "PROCESSDEFINITION" , uniqueConstraints = @ UniqueConstraint ( columnNames = { "name" } ) ) public class ProcessDefinition extends EntitySupport { private static final transient Log LOG = LogFactory . getLog ( ProcessDefinition . class ) ; private String name ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public static ProcessDefinition getRefreshedProcessDefinition ( JpaTemplate template , ProcessDefinition definition ) { ObjectHelper . notNull ( definition , "definition" ) ; Long id = definition . getId ( ) ; if ( id == null ) { LOG . warn ( "No primary key is available!" ) ; return findOrCreateProcessDefinition ( template , definition . getName ( ) ) ; } definition = template . find ( ProcessDefinition . class , id ) ; return definition ; } public static ProcessDefinition findOrCreateProcessDefinition ( JpaTemplate template , String processName ) { List < ProcessDefinition > list = template . find ( "select x from " + ProcessDefinition . class . getName ( ) + " x where x.name = ?1" , processName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ProcessDefinition answer = new ProcessDefinition ( ) ; answer . setName ( processName ) ; template . persist ( answer ) ; return answer ; } } } 	0	['7', '2', '0', '11', '21', '17', '6', '5', '6', '0.666666667', '90', '1', '0', '0.375', '0.375', '0', '0', '11.57142857', '2', '1', '0']
package org . apache . camel . converter . stream ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . io . StringReader ; import javax . xml . transform . TransformerException ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . Converter ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . converter . jaxp . BytesSource ; import org . apache . camel . converter . jaxp . StringSource ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ Converter public class StreamCacheConverter { private static final transient Log LOG = LogFactory . getLog ( StreamCacheConverter . class ) ; private XmlConverter converter = new XmlConverter ( ) ; @ Converter public StreamCache convertToStreamCache ( StreamSource source ) throws TransformerException { return new SourceCache ( converter . toString ( source ) ) ; } @ Converter public StreamCache convertToStreamCache ( StringSource source ) throws TransformerException { return null ; } @ Converter public StreamCache convertToStreamCache ( BytesSource source ) throws TransformerException { return null ; } @ Converter public StreamCache convertToStreamCache ( SAXSource source ) throws TransformerException { return new SourceCache ( converter . toString ( source ) ) ; } @ Converter public StreamCache convertToStreamCache ( InputStream stream ) throws IOException { return new InputStreamCache ( IOConverter . toBytes ( stream ) ) ; } @ Converter public StreamCache convertToStreamCache ( Reader reader ) throws IOException { return new ReaderCache ( IOConverter . toString ( reader ) ) ; } private class SourceCache extends StringSource implements StreamCache { private static final long serialVersionUID = 4147248494104812945L ; public SourceCache ( ) { } public SourceCache ( String text ) { super ( text ) ; } public void reset ( ) { } } private class InputStreamCache extends ByteArrayInputStream implements StreamCache { public InputStreamCache ( byte [ ] data ) { super ( data ) ; } } private class ReaderCache extends StringReader implements StreamCache { public ReaderCache ( String s ) { super ( s ) ; } public void reset ( ) { try { super . reset ( ) ; } catch ( IOException e ) { LOG . warn ( "Exception is thrown when resets the ReaderCache" , e ) ; } } public void close ( ) { } } } 	1	['9', '1', '0', '10', '18', '28', '3', '10', '7', '0.8125', '61', '1', '1', '0', '0.232142857', '0', '0', '5.555555556', '1', '0.7778', '4']
package org . apache . camel . spring . util ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . InitializingBean ; import static org . apache . camel . util . ObjectHelper . name ; public class MainRunner implements InitializingBean , Runnable { private static final Log LOG = LogFactory . getLog ( MainRunner . class ) ; private Class main ; private String [ ] args = { } ; private boolean asyncRun = true ; private long delay ; public String toString ( ) { return "MainRunner(" + name ( main ) + " " + Arrays . asList ( getArgs ( ) ) + ")" ; } public void run ( ) { try { runMethodWithoutCatchingExceptions ( ) ; } catch ( NoSuchMethodException e ) { LOG . error ( "Class: " + name ( main ) + " does not have a main method: " + e , e ) ; } catch ( IllegalAccessException e ) { LOG . error ( "Failed to run: " + this + ". Reason: " + e , e ) ; } catch ( InvocationTargetException e ) { Throwable throwable = e . getTargetException ( ) ; LOG . error ( "Failed to run: " + this + ". Reason: " + throwable , throwable ) ; } } public void runMethodWithoutCatchingExceptions ( ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( delay > 0 ) { try { Thread . sleep ( delay ) ; } catch ( InterruptedException e ) { LOG . info ( "Caught: " + e , e ) ; } } Method method = main . getMethod ( "main" , String [ ] . class ) ; if ( ! Modifier . isStatic ( method . getModifiers ( ) ) ) { throw new IllegalArgumentException ( "The main method is not static!: " + method ) ; } Object [ ] arguments = { getArgs ( ) } ; method . invoke ( null , arguments ) ; } public String [ ] getArgs ( ) { return args ; } public void setArgs ( String [ ] args ) { this . args = args ; } public boolean isAsyncRun ( ) { return asyncRun ; } public void setAsyncRun ( boolean asyncRun ) { this . asyncRun = asyncRun ; } public Class getMain ( ) { return main ; } public void setMain ( Class main ) { this . main = main ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public void afterPropertiesSet ( ) throws Exception { if ( main == null ) { throw new IllegalArgumentException ( "You must specify a main class!" ) ; } if ( isAsyncRun ( ) ) { Thread thread = new Thread ( this , "Thread for: " + this ) ; thread . start ( ) ; } else { runMethodWithoutCatchingExceptions ( ) ; } } } 	0	['14', '1', '0', '4', '33', '39', '0', '4', '13', '0.692307692', '231', '1', '0', '0', '0.261538462', '0', '0', '15.14285714', '1', '0.8571', '0']
package org . apache . camel . impl ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; public class DefaultConsumer < E extends Exchange > extends ServiceSupport implements Consumer < E > { private Endpoint < E > endpoint ; private Processor processor ; private AsyncProcessor asyncProcessor ; private ExceptionHandler exceptionHandler ; public DefaultConsumer ( Endpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } @ Override public String toString ( ) { return "Consumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } public AsyncProcessor getAsyncProcessor ( ) { if ( asyncProcessor == null ) { asyncProcessor = AsyncProcessorTypeConverter . convert ( processor ) ; } return asyncProcessor ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void handleException ( Throwable t ) { Throwable newt = ( t == null ) ? new Throwable ( "Handling [null] exception" ) : t ; getExceptionHandler ( ) . handleException ( newt ) ; } } 	1	['10', '2', '19', '29', '22', '17', '20', '9', '7', '0.777777778', '99', '1', '4', '0.608695652', '0.28', '1', '1', '8.5', '2', '1.2', '1']
package org . apache . camel . component . stringtemplate ; import java . io . StringWriter ; import java . util . Map ; import org . antlr . stringtemplate . AutoIndentWriter ; import org . antlr . stringtemplate . StringTemplate ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . component . ResourceBasedEndpoint ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . util . ExchangeHelper ; public class StringTemplateEndpoint extends ResourceBasedEndpoint { public StringTemplateEndpoint ( String uri , StringTemplateComponent component , String resourceUri , Map parameters ) { super ( uri , component , resourceUri , null ) ; } public StringTemplateEndpoint ( String endpointUri , Processor processor , String resourceUri ) { super ( endpointUri , processor , resourceUri ) ; } @ Override public boolean isSingleton ( ) { return true ; } @ Override public ExchangePattern getExchangePattern ( ) { return ExchangePattern . InOut ; } @ Override protected void onExchange ( Exchange exchange ) throws Exception { StringWriter buffer = new StringWriter ( ) ; Map variableMap = ExchangeHelper . createVariableMap ( exchange ) ; String text = IOConverter . toString ( getResourceAsInputStream ( ) ) ; StringTemplate template = new StringTemplate ( text ) ; template . setAttributes ( variableMap ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "StringTemplate is writing using attributes: " + variableMap ) ; } template . write ( new AutoIndentWriter ( buffer ) ) ; Message out = exchange . getOut ( true ) ; out . setBody ( buffer . toString ( ) ) ; out . setHeader ( "org.apache.camel.stringtemplate.resource" , getResource ( ) ) ; } } 	0	['5', '6', '0', '14', '26', '10', '1', '14', '4', '2', '77', '0', '0', '0.933333333', '0.366666667', '0', '0', '14.4', '1', '0.6', '0']
package org . apache . camel . view ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . util . List ; import java . util . Properties ; import javax . xml . bind . Binder ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . stream . StreamResult ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . RuntimeTransformException ; import org . apache . camel . builder . xml . Namespaces ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . RoutesType ; import org . apache . camel . util . ObjectHelper ; public class ModelFileGenerator { private static final String DEFAULT_ROOT_ELEMENT_NAME = "routes" ; private final JAXBContext jaxbContext ; private Binder < Node > binder ; public ModelFileGenerator ( JAXBContext jaxbContext ) { this . jaxbContext = jaxbContext ; } public void marshalRoutesUsingJaxb ( String fileName , List < RouteType > routeTypes ) throws IOException { OutputStream outputStream = outputStream ( fileName ) ; try { XmlConverter converter = converter ( ) ; Document doc = converter . createDocument ( ) ; Element root = doc . createElement ( rootElementName ( ) ) ; root . setAttribute ( "xmlns" , Namespaces . DEFAULT_NAMESPACE ) ; doc . appendChild ( root ) ; for ( RouteType routeType : routeTypes ) { addJaxbElementToNode ( root , routeType ) ; } Result result = new StreamResult ( new OutputStreamWriter ( outputStream , XmlConverter . defaultCharset ) ) ; copyToResult ( converter , doc , result ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeTransformException ( e ) ; } catch ( TransformerException e ) { throw new RuntimeTransformException ( e ) ; } finally { outputStream . close ( ) ; } } private XmlConverter converter ( ) { XmlConverter converter = new XmlConverter ( ) ; TransformerFactory transformerFactory = converter . getTransformerFactory ( ) ; transformerFactory . setAttribute ( "indent-number" , new Integer ( 2 ) ) ; return converter ; } private void copyToResult ( XmlConverter converter , Document doc , Result result ) throws TransformerException { Properties outputProperties = converter . defaultOutputProperties ( ) ; outputProperties . put ( OutputKeys . OMIT_XML_DECLARATION , "no" ) ; outputProperties . put ( OutputKeys . INDENT , "yes" ) ; converter . toResult ( converter . toSource ( doc ) , result , outputProperties ) ; } private void addJaxbElementToNode ( Node node , Object jaxbElement ) { try { if ( binder == null ) { binder = jaxbContext . createBinder ( ) ; } binder . marshal ( jaxbElement , node ) ; } catch ( JAXBException e ) { throw new RuntimeCamelException ( e ) ; } } private String rootElementName ( ) { XmlRootElement annotation = ( RoutesType . class ) . getAnnotation ( XmlRootElement . class ) ; if ( annotation != null ) { String elementName = annotation . name ( ) ; if ( ObjectHelper . isNotNullAndNonEmpty ( elementName ) ) { return elementName ; } } return DEFAULT_ROOT_ELEMENT_NAME ; } private OutputStream outputStream ( String fileName ) throws FileNotFoundException { File file = new File ( fileName ) ; if ( ! file . exists ( ) ) { File parentFile = file . getParentFile ( ) ; if ( parentFile != null ) { parentFile . mkdirs ( ) ; } } return new FileOutputStream ( file ) ; } } 	1	['7', '1', '0', '8', '38', '19', '3', '5', '2', '0.888888889', '185', '1', '0', '0', '0.253968254', '0', '0', '25', '3', '1.2857', '1']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class EnumTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isEnum ( ) && value != null ) { String text = value . toString ( ) ; Method method = null ; try { method = type . getMethod ( "valueOf" , String . class ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeCamelException ( "Could not find valueOf method on enum type: " + type . getName ( ) ) ; } return ( T ) ObjectHelper . invokeMethod ( method , null , text ) ; } return null ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return convertTo ( type , value ) ; } } 	0	['3', '1', '0', '5', '13', '3', '1', '4', '3', '2', '58', '0', '0', '0', '0.666666667', '0', '0', '18.33333333', '3', '1.3333', '0']
package org . apache . camel . util ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . converter . stream . StreamCache ; public final class MessageHelper { private MessageHelper ( ) { } public static String extractBodyAsString ( Message message ) { if ( message == null ) { return null ; } StreamCache newBody = null ; try { newBody = message . getBody ( StreamCache . class ) ; if ( newBody != null ) { message . setBody ( newBody ) ; } } catch ( NoTypeConversionAvailableException ex ) { } Object answer ; try { answer = message . getBody ( String . class ) ; } catch ( NoTypeConversionAvailableException ex ) { answer = message . getBody ( ) ; } if ( newBody != null ) { newBody . reset ( ) ; } return answer != null ? answer . toString ( ) : null ; } public static String getBodyTypeName ( Message message ) { if ( message == null ) { return null ; } String answer = ObjectHelper . classCanonicalName ( message . getBody ( ) ) ; if ( answer != null && answer . startsWith ( "java.lang." ) ) { return answer . substring ( 10 ) ; } return answer ; } public static void resetStreamCache ( Message message ) { if ( message == null ) { return ; } if ( message . getBody ( ) instanceof StreamCache ) { ( ( StreamCache ) message . getBody ( ) ) . reset ( ) ; } } } 	1	['4', '1', '0', '6', '13', '6', '2', '4', '3', '2', '77', '0', '0', '0', '0.5', '0', '0', '18.25', '4', '2.75', '4']
package org . apache . camel . component . direct ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class DirectComponent < E extends Exchange > extends DefaultComponent < E > { protected Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Endpoint < E > endpoint = new DirectEndpoint < E > ( uri , this ) ; setProperties ( endpoint , parameters ) ; return endpoint ; } } 	0	['2', '3', '0', '3', '5', '1', '1', '3', '1', '2', '17', '0', '0', '0.972222222', '0.666666667', '1', '2', '7.5', '1', '0.5', '0']
package org . apache . camel . converter ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . ObjectInput ; import java . io . ObjectInputStream ; import java . io . ObjectOutput ; import java . io . ObjectOutputStream ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . net . URL ; import javax . xml . transform . TransformerException ; import javax . xml . transform . dom . DOMSource ; import org . apache . camel . Converter ; import org . apache . camel . Exchange ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ Converter public final class IOConverter { private static final transient Log LOG = LogFactory . getLog ( IOConverter . class ) ; private static XmlConverter xmlConverter ; private IOConverter ( ) { } @ Converter public static InputStream toInputStream ( URL url ) throws IOException { return url . openStream ( ) ; } @ Converter public static InputStream toInputStream ( File file ) throws FileNotFoundException { return new BufferedInputStream ( new FileInputStream ( file ) ) ; } @ Converter public static BufferedReader toReader ( File file ) throws FileNotFoundException { return new BufferedReader ( new FileReader ( file ) ) ; } @ Converter public static File toFile ( String name ) throws FileNotFoundException { return new File ( name ) ; } @ Converter public static OutputStream toOutputStream ( File file ) throws FileNotFoundException { return new BufferedOutputStream ( new FileOutputStream ( file ) ) ; } @ Converter public static BufferedWriter toWriter ( File file ) throws IOException { return new BufferedWriter ( new FileWriter ( file ) ) ; } @ Converter public static Reader toReader ( InputStream in ) throws FileNotFoundException { return new InputStreamReader ( in ) ; } @ Converter public static Writer toWriter ( OutputStream out ) throws FileNotFoundException { return new OutputStreamWriter ( out ) ; } @ Converter public static StringReader toReader ( String text ) { return new StringReader ( text ) ; } @ Converter public static InputStream toInputStream ( String text , Exchange exchange ) { if ( exchange != null ) { String charsetName = exchange . getProperty ( Exchange . CHARSET_NAME , String . class ) ; if ( charsetName != null ) { try { return toInputStream ( text . getBytes ( charsetName ) ) ; } catch ( UnsupportedEncodingException e ) { LOG . warn ( "Can't convert the String into the bytes with the charset " + charsetName , e ) ; } } } return toInputStream ( text . getBytes ( ) ) ; } @ Converter public static InputStream toInputStream ( BufferedReader buffer , Exchange exchange ) throws IOException { return toInputStream ( toString ( buffer ) , exchange ) ; } @ Converter public static InputStream toInputStrean ( DOMSource source ) throws TransformerException , IOException { XmlConverter xmlConverter = createXmlConverter ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( xmlConverter . toString ( source ) . getBytes ( ) ) ; return bais ; } private static XmlConverter createXmlConverter ( ) { if ( xmlConverter == null ) { xmlConverter = new XmlConverter ( ) ; } return xmlConverter ; } @ Converter public static String toString ( byte [ ] data , Exchange exchange ) { if ( exchange != null ) { String charsetName = exchange . getProperty ( Exchange . CHARSET_NAME , String . class ) ; if ( charsetName != null ) { try { return new String ( data , charsetName ) ; } catch ( UnsupportedEncodingException e ) { LOG . warn ( "Can't convert the byte to String with the charset " + charsetName , e ) ; } } } return new String ( data ) ; } @ Converter public static String toString ( File file ) throws IOException { return toString ( toReader ( file ) ) ; } @ Converter public static byte [ ] toByteArray ( File file ) throws IOException { return toBytes ( toInputStream ( file ) ) ; } @ Converter public static byte [ ] toByteArray ( Reader reader ) throws IOException { if ( reader instanceof BufferedReader ) { return toByteArray ( ( BufferedReader ) reader ) ; } else { return toByteArray ( new BufferedReader ( reader ) ) ; } } @ Converter public static String toString ( URL url ) throws IOException { return toString ( toInputStream ( url ) ) ; } @ Converter public static String toString ( Reader reader ) throws IOException { if ( reader instanceof BufferedReader ) { return toString ( ( BufferedReader ) reader ) ; } else { return toString ( new BufferedReader ( reader ) ) ; } } @ Converter public static String toString ( BufferedReader reader ) throws IOException { if ( reader == null ) { return null ; } try { CollectionStringBuffer builder = new CollectionStringBuffer ( "\n" ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { return builder . toString ( ) ; } builder . append ( line ) ; } } finally { try { reader . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Failed to close stream: " + e , e ) ; } } } @ Converter public static byte [ ] toByteArray ( BufferedReader reader ) throws IOException { if ( reader == null ) { return null ; } StringBuilder sb = new StringBuilder ( 1024 ) ; char [ ] buf = new char [ 1024 ] ; try { int len = reader . read ( buf ) ; if ( len != - 1 ) { sb . append ( buf , 0 , len ) ; } } finally { try { reader . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Failed to close stream: " + e , e ) ; } } return sb . toString ( ) . getBytes ( ) ; } @ Converter public static String toString ( InputStream in ) throws IOException { return toString ( toReader ( in ) ) ; } @ Converter public static InputStream toInputStream ( byte [ ] data ) { return new ByteArrayInputStream ( data ) ; } @ Converter public static ObjectOutput toObjectOutput ( OutputStream stream ) throws IOException { if ( stream instanceof ObjectOutput ) { return ( ObjectOutput ) stream ; } else { return new ObjectOutputStream ( stream ) ; } } @ Converter public static ObjectInput toObjectInput ( InputStream stream ) throws IOException { if ( stream instanceof ObjectInput ) { return ( ObjectInput ) stream ; } else { return new ObjectInputStream ( stream ) ; } } @ Converter public static byte [ ] toBytes ( InputStream stream ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; copy ( stream , bos ) ; return bos . toByteArray ( ) ; } public static void copy ( InputStream stream , OutputStream os ) throws IOException { byte [ ] data = new byte [ 4096 ] ; int read = stream . read ( data ) ; while ( read != - 1 ) { os . write ( data , 0 , read ) ; read = stream . read ( data ) ; } os . flush ( ) ; } } 	1	['29', '1', '0', '16', '72', '386', '12', '5', '26', '0.821428571', '403', '1', '1', '0', '0.100649351', '0', '0', '12.82758621', '3', '1.1034', '3']
package org . apache . camel . impl ; import org . apache . camel . Processor ; import org . apache . camel . spi . Policy ; public class NoPolicy < E > implements Policy < E > { public Processor wrap ( Processor processor ) { return processor ; } } 	0	['2', '1', '0', '2', '3', '1', '0', '2', '2', '2', '7', '0', '0', '0', '0.75', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . camel . spi ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Intercept ; import org . apache . camel . Processor ; import org . apache . camel . model . FromType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . dataformat . DataFormatType ; public interface RouteContext { Endpoint < ? extends Exchange > getEndpoint ( ) ; FromType getFrom ( ) ; RouteType getRoute ( ) ; CamelContext getCamelContext ( ) ; Processor createProcessor ( ProcessorType node ) throws Exception ; Endpoint < ? extends Exchange > resolveEndpoint ( String uri ) ; Endpoint < ? extends Exchange > resolveEndpoint ( String uri , String ref ) ; < T > T lookup ( String name , Class < T > type ) ; void commit ( ) ; void addEventDrivenProcessor ( Processor processor ) ; void intercept ( Intercept interceptor ) ; Processor createProceedProcessor ( ) ; List < InterceptStrategy > getInterceptStrategies ( ) ; void setInterceptStrategies ( List < InterceptStrategy > interceptStrategies ) ; void addInterceptStrategy ( InterceptStrategy interceptStrategy ) ; ErrorHandlerWrappingStrategy getErrorHandlerWrappingStrategy ( ) ; void setErrorHandlerWrappingStrategy ( ErrorHandlerWrappingStrategy strategy ) ; void setIsRouteAdded ( boolean value ) ; boolean isRouteAdded ( ) ; DataFormatType getDataFormat ( String ref ) ; } 	1	['20', '1', '0', '80', '20', '190', '75', '10', '20', '2', '20', '0', '0', '0', '0.16', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . mail ; import javax . mail . Flags ; import javax . mail . Folder ; import javax . mail . FolderNotFoundException ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Store ; import javax . mail . search . FlagTerm ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . mail . javamail . JavaMailSenderImpl ; public class MailConsumer extends ScheduledPollConsumer < MailExchange > { public static final long DEFAULT_CONSUMER_DELAY = 60 * 1000L ; private static final transient Log LOG = LogFactory . getLog ( MailConsumer . class ) ; private final MailEndpoint endpoint ; private final JavaMailSenderImpl sender ; private Folder folder ; private Store store ; public MailConsumer ( MailEndpoint endpoint , Processor processor , JavaMailSenderImpl sender ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . sender = sender ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( folder != null && folder . isOpen ( ) ) { folder . close ( true ) ; } if ( store != null && store . isConnected ( ) ) { store . close ( ) ; } super . doStop ( ) ; } protected void poll ( ) throws Exception { ensureIsConnected ( ) ; if ( store == null || folder == null ) { throw new IllegalStateException ( "MailConsumer did not connect properly to the MailStore: " + endpoint . getConfiguration ( ) . getMailStoreLogInformation ( ) ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Polling mailfolder: " + endpoint . getConfiguration ( ) . getMailStoreLogInformation ( ) ) ; } if ( endpoint . getConfiguration ( ) . getFetchSize ( ) == 0 ) { LOG . warn ( "Fetch size is 0 meaning the configuration is set to poll no new messages at all. Camel will skip this poll." ) ; return ; } if ( ! folder . isOpen ( ) ) { folder . open ( Folder . READ_WRITE ) ; } try { int count = folder . getMessageCount ( ) ; if ( count > 0 ) { Message [ ] messages ; if ( endpoint . getConfiguration ( ) . isProcessOnlyUnseenMessages ( ) ) { messages = folder . search ( new FlagTerm ( new Flags ( Flags . Flag . SEEN ) , false ) ) ; } else { messages = folder . getMessages ( ) ; } processMessages ( messages ) ; } else if ( count == - 1 ) { throw new MessagingException ( "Folder: " + folder . getFullName ( ) + " is closed" ) ; } } finally { try { if ( folder . isOpen ( ) ) { folder . close ( true ) ; } } catch ( MessagingException e ) { LOG . debug ( "Could not close mailbox folder: " + folder . getName ( ) , e ) ; } } } protected void ensureIsConnected ( ) throws MessagingException { MailConfiguration config = endpoint . getConfiguration ( ) ; if ( store == null || ! store . isConnected ( ) ) { store = sender . getSession ( ) . getStore ( config . getProtocol ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connecting to MailStore " + endpoint . getConfiguration ( ) . getMailStoreLogInformation ( ) ) ; } store . connect ( config . getHost ( ) , config . getPort ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; } if ( folder == null ) { folder = store . getFolder ( config . getFolderName ( ) ) ; if ( folder == null || ! folder . exists ( ) ) { throw new FolderNotFoundException ( folder , "Folder not found or invalid: " + config . getFolderName ( ) ) ; } } } protected void processMessages ( Message [ ] messages ) throws Exception { int fetchSize = endpoint . getConfiguration ( ) . getFetchSize ( ) ; int count = fetchSize == - 1 ? messages . length : Math . min ( fetchSize , messages . length ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Fetching " + count + " messages. Total " + messages . length + " messages." ) ; } for ( int i = 0 ; i < count ; i ++ ) { Message message = messages [ i ] ; if ( ! message . getFlags ( ) . contains ( Flags . Flag . DELETED ) ) { processMessage ( message ) ; flagMessageProcessed ( message ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Skipping message as it was flagged as deleted: " + MailUtils . dumpMessage ( message ) ) ; } } } } protected void processMessage ( Message message ) throws Exception { MailExchange exchange = endpoint . createExchange ( message ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Processing message: " + MailUtils . dumpMessage ( message ) ) ; } getProcessor ( ) . process ( exchange ) ; } protected void flagMessageProcessed ( Message message ) throws MessagingException { if ( endpoint . getConfiguration ( ) . isDeleteProcessedMessages ( ) ) { message . setFlag ( Flags . Flag . DELETED , true ) ; } else { message . setFlag ( Flags . Flag . SEEN , true ) ; } } } 	0	['9', '4', '0', '11', '60', '0', '1', '11', '1', '0.708333333', '407', '0.833333333', '1', '0.833333333', '0.291666667', '2', '4', '43.55555556', '1', '0.7778', '0']
package org . apache . camel . processor . validation ; import java . util . ArrayList ; import java . util . List ; import javax . xml . transform . dom . DOMResult ; import javax . xml . validation . Schema ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultValidationErrorHandler implements ValidatorErrorHandler { private static final transient Log LOG = LogFactory . getLog ( DefaultValidationErrorHandler . class ) ; private List < SAXParseException > warnings = new ArrayList < SAXParseException > ( ) ; private List < SAXParseException > errors = new ArrayList < SAXParseException > ( ) ; private List < SAXParseException > fatalErrors = new ArrayList < SAXParseException > ( ) ; public void warning ( SAXParseException e ) throws SAXException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "warning: " + e , e ) ; } warnings . add ( e ) ; } public void error ( SAXParseException e ) throws SAXException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "error: " + e , e ) ; } errors . add ( e ) ; } public void fatalError ( SAXParseException e ) throws SAXException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "fatalError: " + e , e ) ; } fatalErrors . add ( e ) ; } public void reset ( ) { warnings . clear ( ) ; errors . clear ( ) ; fatalErrors . clear ( ) ; } public boolean isValid ( ) { return errors . isEmpty ( ) && fatalErrors . isEmpty ( ) ; } public void handleErrors ( Exchange exchange , Schema schema , DOMResult result ) throws ValidationException { if ( ! isValid ( ) ) { throw new SchemaValidationException ( exchange , schema , fatalErrors , errors , warnings ) ; } } public void handleErrors ( Exchange exchange , Object schema ) throws ValidationException { if ( ! isValid ( ) ) { throw new SchemaValidationException ( exchange , schema , fatalErrors , errors , warnings ) ; } } } 	1	['9', '1', '0', '8', '22', '0', '2', '6', '8', '0.46875', '149', '1', '0', '0', '0.333333333', '0', '0', '15.11111111', '3', '1', '1']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlType ( name = "interceptorType" ) public abstract class InterceptorType extends OutputType implements Block { public abstract DelegateProcessor createInterceptor ( RouteContext routeContext ) throws Exception ; } 	0	['2', '4', '1', '9', '3', '1', '5', '4', '2', '2', '5', '0', '0', '0.994444444', '0.75', '0', '0', '1.5', '1', '0.5', '0']
package org . apache . camel . impl ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import javax . activation . DataHandler ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; public class DefaultMessage extends MessageSupport { private Map < String , Object > headers ; private Map < String , DataHandler > attachments ; @ Override public String toString ( ) { return "Message: " + getBody ( ) ; } public Object getHeader ( String name ) { return getHeaders ( ) . get ( name ) ; } public < T > T getHeader ( String name , Class < T > type ) { Object value = getHeader ( name ) ; Exchange e = getExchange ( ) ; return e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , e , value ) ; } public void setHeader ( String name , Object value ) { if ( headers == null ) { headers = createHeaders ( ) ; } headers . put ( name , value ) ; } public Object removeHeader ( String name ) { if ( headers != null ) { return headers . remove ( name ) ; } else { return null ; } } public Map < String , Object > getHeaders ( ) { if ( headers == null ) { headers = createHeaders ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public DefaultMessage newInstance ( ) { return new DefaultMessage ( ) ; } protected Map < String , Object > createHeaders ( ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; populateInitialHeaders ( map ) ; return map ; } protected void populateInitialHeaders ( Map < String , Object > map ) { } protected Map < String , DataHandler > createAttachments ( ) { HashMap < String , DataHandler > map = new HashMap < String , DataHandler > ( ) ; populateInitialAttachments ( map ) ; return map ; } protected void populateInitialAttachments ( Map < String , DataHandler > map ) { } public void addAttachment ( String id , DataHandler content ) { if ( attachments == null ) { attachments = createAttachments ( ) ; } attachments . put ( id , content ) ; } public DataHandler getAttachment ( String id ) { return getAttachments ( ) . get ( id ) ; } public Set < String > getAttachmentNames ( ) { if ( attachments == null ) { attachments = createAttachments ( ) ; } return attachments . keySet ( ) ; } public void removeAttachment ( String id ) { if ( attachments != null && attachments . containsKey ( id ) ) { attachments . remove ( id ) ; } } public Map < String , DataHandler > getAttachments ( ) { if ( attachments == null ) { attachments = createAttachments ( ) ; } return attachments ; } public void setAttachments ( Map < String , DataHandler > attachments ) { this . attachments = attachments ; } public boolean hasAttachments ( ) { if ( attachments == null ) { attachments = createAttachments ( ) ; } return this . attachments != null && this . attachments . size ( ) > 0 ; } protected boolean hasPopulatedHeaders ( ) { return headers != null ; } } 	1	['22', '2', '13', '20', '38', '181', '15', '5', '17', '0.714285714', '206', '1', '0', '0.4', '0.272727273', '1', '2', '8.272727273', '4', '1.5', '5']
package org . apache . camel . component . bean ; import java . io . Externalizable ; import java . io . IOException ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Arrays ; import org . apache . camel . Exchange ; import org . apache . camel . util . IOHelper ; import org . apache . camel . util . ObjectHelper ; public class BeanInvocation implements Externalizable { private Object [ ] args ; private MethodBean methodBean ; private transient Method method ; public BeanInvocation ( ) { } public BeanInvocation ( Method method , Object [ ] args ) { this . method = method ; this . args = args ; } @ Override public String toString ( ) { Object list = null ; if ( args != null ) { list = Arrays . asList ( args ) ; } return "BeanInvocation " + method + " with " + list + "]" ; } public Object [ ] getArgs ( ) { return args ; } public Method getMethod ( ) { return method ; } public void setMethod ( Method method ) { this . method = method ; } public void setArgs ( Object [ ] args ) { this . args = args ; } public void invoke ( Object pojo , Exchange exchange ) { try { Object response = getMethod ( ) . invoke ( pojo , getArgs ( ) ) ; exchange . getOut ( ) . setBody ( response ) ; } catch ( InvocationTargetException e ) { exchange . setException ( e . getCause ( ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable e ) { throw new RuntimeException ( e ) ; } } public void readExternal ( ObjectInput objectInput ) throws IOException , ClassNotFoundException { methodBean = ObjectHelper . cast ( MethodBean . class , objectInput . readObject ( ) ) ; try { method = methodBean . getMethod ( ) ; } catch ( NoSuchMethodException e ) { throw IOHelper . createIOException ( e ) ; } args = ObjectHelper . cast ( Object [ ] . class , objectInput . readObject ( ) ) ; } public void writeExternal ( ObjectOutput objectOutput ) throws IOException { if ( methodBean == null ) { methodBean = new MethodBean ( method ) ; } objectOutput . writeObject ( methodBean ) ; objectOutput . writeObject ( args ) ; } } 	0	['10', '1', '0', '10', '28', '0', '5', '5', '10', '0.518518519', '136', '1', '1', '0', '0.257142857', '0', '0', '12.3', '2', '0.9', '0']
package org . apache . camel . processor ; import java . io . Serializable ; import java . util . Random ; import org . apache . camel . model . LoggingLevel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class RedeliveryPolicy extends DelayPolicy { protected static transient Random randomNumberGenerator ; private static final transient Log LOG = LogFactory . getLog ( RedeliveryPolicy . class ) ; protected int maximumRedeliveries = 5 ; protected long maximumRedeliveryDelay = 60 * 1000L ; protected double backOffMultiplier = 2 ; protected boolean useExponentialBackOff ; protected double collisionAvoidanceFactor = 0.15d ; protected boolean useCollisionAvoidance ; protected LoggingLevel retriesExhaustedLogLevel = LoggingLevel . ERROR ; protected LoggingLevel retryAttemptedLogLevel = LoggingLevel . ERROR ; public RedeliveryPolicy ( ) { } @ Override public String toString ( ) { return "RedeliveryPolicy[maximumRedeliveries=" + maximumRedeliveries + ", initialRedeliveryDelay=" + delay + ", maximumRedeliveryDelay=" + maximumRedeliveryDelay + ", retriesExhaustedLogLevel=" + retriesExhaustedLogLevel + ", retryAttemptedLogLevel=" + retryAttemptedLogLevel + ", useExponentialBackOff=" + useExponentialBackOff + ", backOffMultiplier=" + backOffMultiplier + ", useCollisionAvoidance=" + useCollisionAvoidance + ", collisionAvoidanceFactor=" + collisionAvoidanceFactor + "]" ; } public RedeliveryPolicy copy ( ) { try { return ( RedeliveryPolicy ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( "Could not clone: " + e , e ) ; } } public boolean shouldRedeliver ( int redeliveryCounter ) { if ( getMaximumRedeliveries ( ) < 0 ) { return true ; } return redeliveryCounter <= getMaximumRedeliveries ( ) ; } public long sleep ( long redeliveryDelay ) { redeliveryDelay = getRedeliveryDelay ( redeliveryDelay ) ; if ( redeliveryDelay > 0 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for: " + redeliveryDelay + " millis until attempting redelivery" ) ; } try { Thread . sleep ( redeliveryDelay ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Thread interrupted: " + e , e ) ; } } } return redeliveryDelay ; } public long getRedeliveryDelay ( long previousDelay ) { long redeliveryDelay ; if ( previousDelay == 0 ) { redeliveryDelay = delay ; } else if ( useExponentialBackOff && backOffMultiplier > 1 ) { redeliveryDelay = Math . round ( backOffMultiplier * previousDelay ) ; } else { redeliveryDelay = previousDelay ; } if ( useCollisionAvoidance ) { Random random = getRandomNumberGenerator ( ) ; double variance = ( random . nextBoolean ( ) ? collisionAvoidanceFactor : - collisionAvoidanceFactor ) * random . nextDouble ( ) ; redeliveryDelay += redeliveryDelay * variance ; } if ( maximumRedeliveryDelay > 0 && redeliveryDelay > maximumRedeliveryDelay ) { redeliveryDelay = maximumRedeliveryDelay ; } return redeliveryDelay ; } public RedeliveryPolicy maximumRedeliveries ( int maximumRedeliveries ) { setMaximumRedeliveries ( maximumRedeliveries ) ; return this ; } public RedeliveryPolicy initialRedeliveryDelay ( long initialRedeliveryDelay ) { setDelay ( initialRedeliveryDelay ) ; return this ; } public RedeliveryPolicy useCollisionAvoidance ( ) { setUseCollisionAvoidance ( true ) ; return this ; } public RedeliveryPolicy useExponentialBackOff ( ) { setUseExponentialBackOff ( true ) ; return this ; } public RedeliveryPolicy backOffMultiplier ( double multiplier ) { useExponentialBackOff ( ) ; setBackOffMultiplier ( multiplier ) ; return this ; } public RedeliveryPolicy collisionAvoidancePercent ( double collisionAvoidancePercent ) { useCollisionAvoidance ( ) ; setCollisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public RedeliveryPolicy maximumRedeliveryDelay ( long maximumRedeliveryDelay ) { setMaximumRedeliveryDelay ( maximumRedeliveryDelay ) ; return this ; } public RedeliveryPolicy retriesExhaustedLogLevel ( LoggingLevel retriesExhaustedLogLevel ) { setRetriesExhaustedLogLevel ( retriesExhaustedLogLevel ) ; return this ; } public RedeliveryPolicy retryAttemptedLogLevel ( LoggingLevel retryAttemptedLogLevel ) { setRetryAttemptedLogLevel ( retryAttemptedLogLevel ) ; return this ; } public double getBackOffMultiplier ( ) { return backOffMultiplier ; } public void setBackOffMultiplier ( double backOffMultiplier ) { this . backOffMultiplier = backOffMultiplier ; } public short getCollisionAvoidancePercent ( ) { return ( short ) Math . round ( collisionAvoidanceFactor * 100 ) ; } public void setCollisionAvoidancePercent ( double collisionAvoidancePercent ) { this . collisionAvoidanceFactor = collisionAvoidancePercent * 0.01d ; } public double getCollisionAvoidanceFactor ( ) { return collisionAvoidanceFactor ; } public void setCollisionAvoidanceFactor ( double collisionAvoidanceFactor ) { this . collisionAvoidanceFactor = collisionAvoidanceFactor ; } public long getInitialRedeliveryDelay ( ) { return getDelay ( ) ; } public void setInitialRedeliveryDelay ( long initialRedeliveryDelay ) { setDelay ( initialRedeliveryDelay ) ; } public int getMaximumRedeliveries ( ) { return maximumRedeliveries ; } public void setMaximumRedeliveries ( int maximumRedeliveries ) { this . maximumRedeliveries = maximumRedeliveries ; } public long getMaximumRedeliveryDelay ( ) { return maximumRedeliveryDelay ; } public void setMaximumRedeliveryDelay ( long maximumRedeliveryDelay ) { this . maximumRedeliveryDelay = maximumRedeliveryDelay ; } public boolean isUseCollisionAvoidance ( ) { return useCollisionAvoidance ; } public void setUseCollisionAvoidance ( boolean useCollisionAvoidance ) { this . useCollisionAvoidance = useCollisionAvoidance ; } public boolean isUseExponentialBackOff ( ) { return useExponentialBackOff ; } public void setUseExponentialBackOff ( boolean useExponentialBackOff ) { this . useExponentialBackOff = useExponentialBackOff ; } protected static synchronized Random getRandomNumberGenerator ( ) { if ( randomNumberGenerator == null ) { randomNumberGenerator = new Random ( ) ; } return randomNumberGenerator ; } public void setRetriesExhaustedLogLevel ( LoggingLevel retriesExhaustedLogLevel ) { this . retriesExhaustedLogLevel = retriesExhaustedLogLevel ; } public LoggingLevel getRetriesExhaustedLogLevel ( ) { return retriesExhaustedLogLevel ; } public void setRetryAttemptedLogLevel ( LoggingLevel retryAttemptedLogLevel ) { this . retryAttemptedLogLevel = retryAttemptedLogLevel ; } public LoggingLevel getRetryAttemptedLogLevel ( ) { return retryAttemptedLogLevel ; } } 	1	['38', '2', '0', '11', '59', '581', '7', '4', '36', '0.872972973', '406', '1', '2', '0.12195122', '0.252252252', '0', '0', '9.421052632', '8', '1.2895', '2']
package org . apache . camel . component . jms ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . util . ObjectHelper ; public class JmsHeaderFilterStrategy extends DefaultHeaderFilterStrategy { public JmsHeaderFilterStrategy ( ) { initialize ( ) ; } protected void initialize ( ) { getOutFilter ( ) . add ( "JMSXUserID" ) ; getOutFilter ( ) . add ( "JMSXAppID" ) ; getOutFilter ( ) . add ( "JMSXDeliveryCount" ) ; getOutFilter ( ) . add ( "JMSXProducerTXID" ) ; getOutFilter ( ) . add ( "JMSXConsumerTXID" ) ; getOutFilter ( ) . add ( "JMSXRcvTimestamp" ) ; getOutFilter ( ) . add ( "JMSXRecvTimestamp" ) ; getOutFilter ( ) . add ( "JMSXState" ) ; } @ Override protected boolean extendedFilter ( Direction direction , String key , Object value ) { return Direction . OUT == direction && ! ObjectHelper . isJavaIdentifier ( JmsBinding . encodeToSafeJmsHeaderName ( key ) ) ; } } 	0	['3', '2', '0', '6', '8', '3', '3', '4', '1', '2', '60', '0', '0', '0.888888889', '0.5', '1', '1', '19', '3', '1.3333', '0']
package org . apache . camel . builder ; import java . util . zip . Deflater ; import org . w3c . dom . Node ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . dataformat . ArtixDSContentType ; import org . apache . camel . model . dataformat . ArtixDSDataFormat ; import org . apache . camel . model . dataformat . CsvDataFormat ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . dataformat . HL7DataFormat ; import org . apache . camel . model . dataformat . JaxbDataFormat ; import org . apache . camel . model . dataformat . JsonDataFormat ; import org . apache . camel . model . dataformat . SerializationDataFormat ; import org . apache . camel . model . dataformat . StringDataFormat ; import org . apache . camel . model . dataformat . TidyMarkupDataFormat ; import org . apache . camel . model . dataformat . XMLBeansDataFormat ; import org . apache . camel . model . dataformat . XStreamDataFormat ; import org . apache . camel . model . dataformat . ZipDataFormat ; import org . apache . camel . spi . DataFormat ; public class DataFormatClause < T extends ProcessorType > { private final T processorType ; private final Operation operation ; public enum Operation { Marshal , Unmarshal } public DataFormatClause ( T processorType , Operation operation ) { this . processorType = processorType ; this . operation = operation ; } public T artixDS ( ) { return dataFormat ( new ArtixDSDataFormat ( ) ) ; } public T artixDS ( Class < ? > dataObjectType ) { return dataFormat ( new ArtixDSDataFormat ( dataObjectType ) ) ; } public T artixDS ( Class < ? > elementType , ArtixDSContentType contentType ) { return dataFormat ( new ArtixDSDataFormat ( elementType , contentType ) ) ; } public T artixDS ( ArtixDSContentType contentType ) { return dataFormat ( new ArtixDSDataFormat ( contentType ) ) ; } public T csv ( ) { return dataFormat ( new CsvDataFormat ( ) ) ; } public T hl7 ( ) { return dataFormat ( new HL7DataFormat ( ) ) ; } public T jaxb ( ) { return dataFormat ( new JaxbDataFormat ( ) ) ; } public T jaxb ( boolean prettyPrint ) { return dataFormat ( new JaxbDataFormat ( prettyPrint ) ) ; } public T serialization ( ) { return dataFormat ( new SerializationDataFormat ( ) ) ; } public T string ( ) { return string ( null ) ; } public T string ( String charset ) { StringDataFormat sdf = new StringDataFormat ( ) ; sdf . setCharset ( charset ) ; return dataFormat ( sdf ) ; } public T xmlBeans ( ) { return dataFormat ( new XMLBeansDataFormat ( ) ) ; } public T tidyMarkup ( Class < ? > dataObjectType ) { return dataFormat ( new TidyMarkupDataFormat ( dataObjectType ) ) ; } public T tidyMarkup ( ) { return dataFormat ( new TidyMarkupDataFormat ( Node . class ) ) ; } public T xstream ( ) { return dataFormat ( new XStreamDataFormat ( ) ) ; } public T json ( ) { return dataFormat ( new JsonDataFormat ( ) ) ; } private T dataFormat ( DataFormatType dataFormatType ) { switch ( operation ) { case Unmarshal : return ( T ) processorType . unmarshal ( dataFormatType ) ; case Marshal : return ( T ) processorType . marshal ( dataFormatType ) ; default : throw new IllegalArgumentException ( "Unknown DataFormat operation: " + operation ) ; } } public T zip ( ) { ZipDataFormat zdf = new ZipDataFormat ( Deflater . DEFAULT_COMPRESSION ) ; return dataFormat ( zdf ) ; } public T zip ( int compressionLevel ) { ZipDataFormat zdf = new ZipDataFormat ( compressionLevel ) ; return dataFormat ( zdf ) ; } } 	1	['20', '1', '0', '16', '45', '188', '1', '16', '19', '0.052631579', '184', '1', '2', '0', '0.172222222', '0', '0', '8.1', '4', '1.1', '1']
package org . apache . camel . component . mock ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . processor . ThroughputLogger ; public class MockComponent extends DefaultComponent < Exchange > { @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { MockEndpoint endpoint = new MockEndpoint ( uri , this ) ; Integer value = getAndRemoveParameter ( parameters , "reportGroup" , Integer . class ) ; if ( value != null ) { Processor reporter = new ThroughputLogger ( "org.apache.camel.mock:" + remaining , value ) ; endpoint . setReporter ( reporter ) ; } return endpoint ; } } 	0	['2', '3', '0', '6', '11', '1', '0', '6', '1', '2', '39', '0', '0', '0.972222222', '0.666666667', '1', '2', '18.5', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Intercept ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . processor . Interceptor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "intercept" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class InterceptType extends OutputType < ProcessorType > { @ XmlTransient private ProceedType proceed = new ProceedType ( ) ; @ XmlTransient private Boolean stopIntercept = Boolean . FALSE ; @ XmlTransient private Boolean usePredicate = Boolean . FALSE ; @ Override public String toString ( ) { return "Intercept[" + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "intercept" ; } @ Override public String getLabel ( ) { return "intercept" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Interceptor interceptor = new Interceptor ( ) ; routeContext . intercept ( interceptor ) ; final Processor interceptRoute = createOutputsProcessor ( routeContext ) ; interceptor . setInterceptorLogic ( interceptRoute ) ; return interceptor ; } public ChoiceType when ( Predicate predicate ) { usePredicate = Boolean . TRUE ; ChoiceType choice = choice ( ) . when ( PredicateBuilder . not ( predicate ) ) ; choice . addOutput ( proceed ) ; return choice . otherwise ( ) ; } public ProceedType getProceed ( ) { return proceed ; } public void stopIntercept ( ) { setStopIntercept ( Boolean . TRUE ) ; } @ XmlElement ( name = "stop" , required = false ) public void setStop ( String elementValue ) { stopIntercept ( ) ; } public InterceptType createProxy ( ) { InterceptType answer = new InterceptType ( ) ; answer . getOutputs ( ) . addAll ( this . getOutputs ( ) ) ; answer . setStopIntercept ( getStopIntercept ( ) ) ; if ( answer . getOutputs ( ) . size ( ) > 0 ) { ChoiceType choice = null ; for ( ProcessorType processor : answer . getOutputs ( ) ) { if ( processor instanceof ChoiceType ) { choice = ( ChoiceType ) processor ; if ( usePredicate . booleanValue ( ) && getStopIntercept ( ) . booleanValue ( ) ) { WhenType when = choice . getWhenClauses ( ) . get ( 0 ) ; when . getOutputs ( ) . remove ( this . getProceed ( ) ) ; } addProceedProxy ( this . getProceed ( ) , answer . getProceed ( ) , choice . getWhenClauses ( ) . get ( choice . getWhenClauses ( ) . size ( ) - 1 ) , usePredicate . booleanValue ( ) && ! getStopIntercept ( ) . booleanValue ( ) ) ; addProceedProxy ( this . getProceed ( ) , answer . getProceed ( ) , choice . getOtherwise ( ) , ! getStopIntercept ( ) . booleanValue ( ) ) ; if ( getStopIntercept ( ) . booleanValue ( ) ) { addProceedProxy ( this . getProceed ( ) , answer . getProceed ( ) , choice . getWhenClauses ( ) . get ( choice . getWhenClauses ( ) . size ( ) - 1 ) , usePredicate . booleanValue ( ) ) ; } break ; } } if ( choice == null ) { addProceedProxy ( this . getProceed ( ) , answer . getProceed ( ) , answer , ! getStopIntercept ( ) . booleanValue ( ) ) ; } } return answer ; } private void addProceedProxy ( ProceedType orig , ProceedType proxy , ProcessorType < ? > processor , boolean force ) { int index = processor . getOutputs ( ) . indexOf ( orig ) ; if ( index >= 0 ) { processor . addOutput ( proxy ) ; List < ProcessorType < ? > > outs = processor . getOutputs ( ) ; outs . remove ( proxy ) ; outs . set ( index , proxy ) ; } else if ( force ) { processor . addOutput ( proxy ) ; } } public void setStopIntercept ( Boolean stop ) { this . stopIntercept = stop ; } public Boolean getStopIntercept ( ) { return stopIntercept ; } } 	1	['13', '4', '0', '15', '44', '62', '4', '12', '12', '0.722222222', '264', '1', '1', '0.937172775', '0.192307692', '1', '2', '19.07692308', '11', '1.8462', '1']
package org . apache . camel . component . xmpp ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . jivesoftware . smack . packet . Message ; public class XmppExchange extends DefaultExchange { private XmppBinding binding ; public XmppExchange ( CamelContext context , ExchangePattern pattern , XmppBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public XmppExchange ( CamelContext context , ExchangePattern pattern , XmppBinding binding , Message message ) { this ( context , pattern , binding ) ; setIn ( new XmppMessage ( message ) ) ; } public XmppExchange ( DefaultExchange parent , XmppBinding binding ) { super ( parent ) ; this . binding = binding ; } public XmppMessage getIn ( ) { return ( XmppMessage ) super . getIn ( ) ; } @ Override public XmppMessage getOut ( ) { return ( XmppMessage ) super . getOut ( ) ; } @ Override public XmppMessage getOut ( boolean lazyCreate ) { return ( XmppMessage ) super . getOut ( lazyCreate ) ; } @ Override public XmppMessage getFault ( ) { return ( XmppMessage ) super . getFault ( ) ; } public XmppBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new XmppExchange ( this , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getXmppMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } public Message getFaultMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } @ Override protected XmppMessage createInMessage ( ) { return new XmppMessage ( ) ; } @ Override protected XmppMessage createOutMessage ( ) { return new XmppMessage ( ) ; } } 	0	['20', '2', '0', '10', '24', '178', '4', '8', '16', '0.789473684', '114', '1', '1', '0.690909091', '0.221428571', '1', '3', '4.65', '1', '0.85', '0']
package org . apache . camel . util ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . InvalidPayloadException ; import org . apache . camel . InvalidTypeException ; import org . apache . camel . Message ; import org . apache . camel . NoSuchBeanException ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . NoSuchHeaderException ; import org . apache . camel . NoSuchPropertyException ; import org . apache . camel . NoTypeConversionAvailableException ; public final class ExchangeHelper { private ExchangeHelper ( ) { } public static < T > T getExchangeProperty ( Exchange exchange , String propertyName , Class < T > type , T defaultValue ) { T answer = exchange . getProperty ( propertyName , type ) ; if ( answer == null ) { return defaultValue ; } return answer ; } @ SuppressWarnings ( { "unchecked" } ) public static < E extends Exchange > Endpoint < E > resolveEndpoint ( E exchange , Object value ) throws NoSuchEndpointException { Endpoint < E > endpoint ; if ( value instanceof Endpoint ) { endpoint = ( Endpoint < E > ) value ; } else { String uri = value . toString ( ) ; endpoint = CamelContextHelper . getMandatoryEndpoint ( exchange . getContext ( ) , uri ) ; } return endpoint ; } public static < T > T getMandatoryProperty ( Exchange exchange , String propertyName , Class < T > type ) throws NoSuchPropertyException { try { T result = exchange . getProperty ( propertyName , type ) ; if ( result != null ) { return result ; } } catch ( NoTypeConversionAvailableException ex ) { } throw new NoSuchPropertyException ( exchange , propertyName , type ) ; } public static < T > T getMandatoryHeader ( Exchange exchange , String propertyName , Class < T > type ) throws NoSuchHeaderException { T answer = exchange . getIn ( ) . getHeader ( propertyName , type ) ; if ( answer == null ) { throw new NoSuchHeaderException ( exchange , propertyName , type ) ; } return answer ; } public static Object getMandatoryInBody ( Exchange exchange ) throws InvalidPayloadException { Object answer = exchange . getIn ( ) . getBody ( ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , Object . class ) ; } return answer ; } public static < T > T getMandatoryInBody ( Exchange exchange , Class < T > type ) throws InvalidPayloadException { T answer = exchange . getIn ( ) . getBody ( type ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , type ) ; } return answer ; } public static Object getMandatoryOutBody ( Exchange exchange ) throws InvalidPayloadException { Message out = exchange . getOut ( ) ; Object answer = out . getBody ( ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , Object . class , out ) ; } return answer ; } public static < T > T getMandatoryOutBody ( Exchange exchange , Class < T > type ) throws InvalidPayloadException { Message out = exchange . getOut ( ) ; T answer = out . getBody ( type ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , type , out ) ; } return answer ; } public static < T > T convertToMandatoryType ( Exchange exchange , Class < T > type , Object value ) throws InvalidTypeException { T answer = convertToType ( exchange , type , value ) ; if ( answer == null ) { throw new InvalidTypeException ( exchange , value , type ) ; } return answer ; } public static < T > T convertToType ( Exchange exchange , Class < T > type , Object value ) { return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( type , exchange , value ) ; } public static void copyResults ( Exchange result , Exchange source ) { if ( result != source ) { result . setException ( source . getException ( ) ) ; Message fault = source . getFault ( false ) ; if ( fault != null ) { result . getFault ( true ) . copyFrom ( fault ) ; } Message out = source . getOut ( false ) ; if ( out != null ) { result . getOut ( true ) . copyFrom ( out ) ; } else { if ( result . getPattern ( ) . isOutCapable ( ) ) { result . getOut ( true ) . copyFrom ( source . getIn ( ) ) ; } else { result . getIn ( ) . copyFrom ( source . getIn ( ) ) ; } } result . getProperties ( ) . clear ( ) ; result . getProperties ( ) . putAll ( source . getProperties ( ) ) ; } } public static boolean isInCapable ( Exchange exchange ) { ExchangePattern pattern = exchange . getPattern ( ) ; return pattern != null && pattern . isInCapable ( ) ; } public static boolean isOutCapable ( Exchange exchange ) { ExchangePattern pattern = exchange . getPattern ( ) ; return pattern != null && pattern . isOutCapable ( ) ; } public static < T > T newInstance ( Exchange exchange , Class < T > type ) { return exchange . getContext ( ) . getInjector ( ) . newInstance ( type ) ; } public static Map createVariableMap ( Exchange exchange ) { Map answer = new HashMap ( ) ; populateVariableMap ( exchange , answer ) ; return answer ; } public static void populateVariableMap ( Exchange exchange , Map map ) { map . put ( "exchange" , exchange ) ; Message in = exchange . getIn ( ) ; map . put ( "in" , in ) ; map . put ( "request" , in ) ; map . put ( "headers" , in . getHeaders ( ) ) ; map . put ( "body" , in . getBody ( ) ) ; if ( isOutCapable ( exchange ) ) { Message out = exchange . getOut ( true ) ; map . put ( "out" , out ) ; map . put ( "response" , out ) ; } map . put ( "camelContext" , exchange . getContext ( ) ) ; } public static String getContentType ( Exchange exchange ) { return exchange . getIn ( ) . getHeader ( "Content-Type" , String . class ) ; } public static Object lookupMandatoryBean ( Exchange exchange , String name ) { Object value = lookupBean ( exchange , name ) ; if ( value == null ) { throw new NoSuchBeanException ( name ) ; } return value ; } public static < T > T lookupMandatoryBean ( Exchange exchange , String name , Class < T > type ) { T value = lookupBean ( exchange , name , type ) ; if ( value == null ) { throw new NoSuchBeanException ( name ) ; } return value ; } public static Object lookupBean ( Exchange exchange , String name ) { return exchange . getContext ( ) . getRegistry ( ) . lookup ( name ) ; } public static < T > T lookupBean ( Exchange exchange , String name , Class < T > type ) { return exchange . getContext ( ) . getRegistry ( ) . lookup ( name , type ) ; } } 	1	['22', '1', '0', '45', '59', '231', '29', '16', '21', '2', '371', '0', '0', '0', '0.333333333', '0', '0', '15.86363636', '5', '1.5', '13']
package org . apache . camel . component . http ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; public class HttpHeaderFilterStrategy extends DefaultHeaderFilterStrategy { public HttpHeaderFilterStrategy ( ) { initialize ( ) ; } protected void initialize ( ) { getOutFilter ( ) . add ( "content-length" ) ; getOutFilter ( ) . add ( "content-type" ) ; getOutFilter ( ) . add ( HttpMethods . HTTP_METHOD ) ; getOutFilter ( ) . add ( HttpProducer . QUERY ) ; getOutFilter ( ) . add ( HttpProducer . HTTP_RESPONSE_CODE . toLowerCase ( ) ) ; setIsLowercase ( true ) ; setOutFilterPattern ( "(org\\.apache\\.camel)[\\.|a-z|A-z|0-9]*" ) ; } } 	0	['2', '2', '0', '3', '8', '1', '2', '1', '1', '2', '40', '0', '0', '0.941176471', '1', '0', '0', '19', '1', '0.5', '0']
package org . apache . camel . util ; import java . io . IOException ; public final class IOHelper { private IOHelper ( ) { } public static IOException createIOException ( Throwable cause ) { return createIOException ( cause . getMessage ( ) , cause ) ; } public static IOException createIOException ( String message , Throwable cause ) { IOException answer = new IOException ( message ) ; answer . initCause ( cause ) ; return answer ; } } 	1	['3', '1', '0', '2', '7', '3', '2', '0', '2', '2', '22', '0', '0', '0', '0.444444444', '0', '0', '6.333333333', '1', '0.6667', '1']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "catch" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CatchType extends ProcessorType < CatchType > { @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; public CatchType ( ) { } public CatchType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public CatchType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Catch[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "catch" ; } @ Override public String getLabel ( ) { return getExceptionClasses ( ) . toString ( ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	0	['15', '3', '0', '6', '32', '61', '1', '5', '14', '0.595238095', '168', '1', '0', '0.936170213', '0.366666667', '1', '3', '10', '2', '0.9333', '0']
package org . apache . camel ; public class NoSuchEndpointException extends RuntimeCamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final String uri ; public NoSuchEndpointException ( String uri ) { super ( "No endpoint could be found for: " + uri + ", please check your classpath contains the needed camel component jar." ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	1	['2', '5', '0', '8', '6', '0', '7', '1', '2', '1', '23', '1', '0', '0.944444444', '0.75', '0', '0', '9.5', '1', '0.5', '1']
package org . apache . camel . component . http ; import java . io . IOException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . camel . Message ; import org . apache . camel . spi . HeaderFilterStrategy ; public interface HttpBinding { void readRequest ( HttpServletRequest request , HttpMessage message ) ; Object parseBody ( HttpMessage httpMessage ) throws IOException ; void writeResponse ( HttpExchange exchange , HttpServletResponse response ) throws IOException ; void doWriteExceptionResponse ( Throwable exception , HttpServletResponse response ) throws IOException ; void doWriteFaultResponse ( Message message , HttpServletResponse response ) throws IOException ; void doWriteResponse ( Message message , HttpServletResponse response ) throws IOException ; boolean isUseReaderForPayload ( ) ; void setUseReaderForPayload ( boolean useReaderForPayload ) ; HeaderFilterStrategy getHeaderFilterStrategy ( ) ; void setHeaderFilterStrategy ( HeaderFilterStrategy headerFilterStrategy ) ; } 	0	['10', '1', '0', '11', '10', '45', '8', '4', '10', '2', '10', '0', '0', '0', '0.255555556', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; public class InvalidPayloadRuntimeException extends RuntimeExchangeException { private final Class < ? > type ; public InvalidPayloadRuntimeException ( Exchange exchange , Class < ? > type ) { super ( "No in body available of type: " + type . getName ( ) + NoSuchPropertyException . valueDescription ( exchange . getIn ( ) . getBody ( ) ) , exchange ) ; this . type = type ; } public Class < ? > getType ( ) { return type ; } } 	1	['2', '6', '0', '4', '10', '0', '0', '4', '2', '0', '27', '1', '0', '0.947368421', '0.666666667', '0', '0', '12', '1', '0.5', '1']
package org . apache . camel . component . amqp ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . component . jms . JmsComponent ; import org . apache . camel . component . jms . JmsConfiguration ; import org . apache . qpid . client . AMQConnectionFactory ; import org . apache . qpid . url . URLSyntaxException ; public class AMQPComponent extends JmsComponent { public AMQPComponent ( ) { init ( ) ; } public AMQPComponent ( JmsConfiguration configuration ) { super ( configuration ) ; } public AMQPComponent ( CamelContext context ) { super ( context ) ; init ( ) ; } public AMQPComponent ( AMQConnectionFactory connectionFactory ) { setConnectionFactory ( connectionFactory ) ; } public static Component amqpComponent ( String uri ) throws URLSyntaxException { AMQConnectionFactory connectionFactory = new AMQConnectionFactory ( uri ) ; return new AMQPComponent ( connectionFactory ) ; } private void init ( ) { AMQConnectionFactory connectionFactory = new AMQConnectionFactory ( ) ; setConnectionFactory ( connectionFactory ) ; } } 	0	['6', '4', '0', '6', '12', '15', '0', '6', '5', '2', '45', '0', '0', '0.979166667', '0.3', '0', '0', '6.5', '1', '0.3333', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . LoggingExceptionHandler ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . processor . resequencer . ResequencerEngine ; import org . apache . camel . processor . resequencer . SequenceElementComparator ; import org . apache . camel . processor . resequencer . SequenceSender ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; public class StreamResequencer extends ServiceSupport implements SequenceSender < Exchange > , Processor { private static final long DELIVERY_ATTEMPT_INTERVAL = 1000L ; private ExceptionHandler exceptionHandler ; private ResequencerEngine < Exchange > engine ; private Processor processor ; private Delivery delivery ; private int capacity ; public StreamResequencer ( Processor processor , SequenceElementComparator < Exchange > comparator ) { this . exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; this . engine = new ResequencerEngine < Exchange > ( comparator ) ; this . engine . setSequenceSender ( this ) ; this . processor = processor ; } public ExceptionHandler getExceptionHandler ( ) { return exceptionHandler ; } public Processor getProcessor ( ) { return processor ; } public int getCapacity ( ) { return capacity ; } public long getTimeout ( ) { return engine . getTimeout ( ) ; } public void setCapacity ( int capacity ) { this . capacity = capacity ; } public void setTimeout ( long timeout ) { engine . setTimeout ( timeout ) ; } @ Override public String toString ( ) { return "StreamResequencer[to: " + processor + "]" ; } @ Override protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; delivery = new Delivery ( ) ; engine . start ( ) ; delivery . start ( ) ; } @ Override protected void doStop ( ) throws Exception { engine . stop ( ) ; ServiceHelper . stopServices ( processor ) ; } public void sendElement ( Exchange o ) throws Exception { processor . process ( o ) ; } public void process ( Exchange exchange ) throws Exception { while ( engine . size ( ) >= capacity ) { Thread . sleep ( getTimeout ( ) ) ; } engine . insert ( exchange ) ; delivery . request ( ) ; } private class Delivery extends Thread { private volatile boolean cancelRequested ; public Delivery ( ) { super ( "Delivery Thread" ) ; } @ Override public void run ( ) { while ( true ) { try { Thread . sleep ( DELIVERY_ATTEMPT_INTERVAL ) ; } catch ( InterruptedException e ) { if ( cancelRequested ) { return ; } } try { engine . deliver ( ) ; } catch ( Exception e ) { exceptionHandler . handleException ( e ) ; } } } public void cancel ( ) { cancelRequested = true ; interrupt ( ) ; } public void request ( ) { interrupt ( ) ; } } } 	1	['15', '2', '0', '11', '37', '27', '2', '10', '11', '0.80952381', '145', '1', '4', '0.5', '0.183333333', '1', '1', '8.266666667', '1', '0.9333', '2']
package org . apache . camel . component . cxf . invoker ; import java . util . Map ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; public interface InvokingContext { void setRequestOutMessageContent ( Message message , Map < Class , Object > contents ) ; Object getResponseObject ( Exchange exchange , Map < String , Object > responseContext ) ; void setResponseContent ( Message outMessage , Object resultPayload ) ; Map < Class , Object > getRequestContent ( Message inMessage ) ; } 	0	['4', '1', '0', '6', '4', '6', '4', '2', '4', '2', '4', '0', '0', '0', '0.55', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; public interface CamelContextAware { void setCamelContext ( CamelContext camelContext ) ; } 	1	['1', '1', '0', '10', '1', '0', '9', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . jdbc ; import java . sql . Connection ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . sql . Statement ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import javax . sql . DataSource ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JdbcProducer extends DefaultProducer < DefaultExchange > { private static final transient Log LOG = LogFactory . getLog ( JdbcProducer . class ) ; private DataSource dataSource ; private int readSize ; public JdbcProducer ( JdbcEndpoint endpoint , DataSource dataSource , int readSize ) throws Exception { super ( endpoint ) ; this . dataSource = dataSource ; this . readSize = readSize ; } public void process ( Exchange exchange ) throws Exception { String sql = exchange . getIn ( ) . getBody ( String . class ) ; Connection conn = null ; Statement stmt = null ; ResultSet rs = null ; try { conn = dataSource . getConnection ( ) ; stmt = conn . createStatement ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Executing JDBC statement: " + sql ) ; } if ( stmt . execute ( sql ) ) { rs = stmt . getResultSet ( ) ; setResultSet ( exchange , rs ) ; } else { int updateCount = stmt . getUpdateCount ( ) ; exchange . getOut ( ) . setHeader ( "jdbc.updateCount" , updateCount ) ; } } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( stmt != null ) { stmt . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { LOG . warn ( "Error closing JDBC resource: " + e , e ) ; } } } protected void setResultSet ( Exchange exchange , ResultSet rs ) throws SQLException { ResultSetMetaData meta = rs . getMetaData ( ) ; HashMap < String , Object > props = new HashMap < String , Object > ( ) ; IntrospectionSupport . getProperties ( meta , props , "jdbc." ) ; exchange . getOut ( ) . setHeaders ( props ) ; int count = meta . getColumnCount ( ) ; List < HashMap < String , Object > > data = new ArrayList < HashMap < String , Object > > ( ) ; int rowNumber = 0 ; while ( rs . next ( ) && ( readSize == 0 || rowNumber < readSize ) ) { HashMap < String , Object > row = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int columnNumber = i + 1 ; String columnName = meta . getColumnName ( columnNumber ) ; row . put ( columnName , rs . getObject ( columnName ) ) ; } data . add ( row ) ; rowNumber ++ ; } exchange . getOut ( ) . setBody ( data ) ; } } 	0	['4', '3', '0', '8', '38', '0', '1', '8', '2', '0.555555556', '201', '1', '0', '0.913043478', '0.5', '0', '0', '48.5', '1', '0.5', '0']
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . processor . ErrorHandlerSupport ; public abstract class ErrorHandlerBuilderSupport implements ErrorHandlerBuilder { private List < ExceptionType > exceptions = new ArrayList < ExceptionType > ( ) ; public void addErrorHandlers ( ExceptionType exception ) { exceptions . add ( exception ) ; } protected void configure ( ErrorHandlerSupport handler ) { for ( ExceptionType exception : exceptions ) { handler . addExceptionPolicy ( exception ) ; } } public List < ExceptionType > getExceptions ( ) { return exceptions ; } public void setErrorHandlers ( List < ExceptionType > exceptions ) { this . exceptions . clear ( ) ; this . exceptions . addAll ( exceptions ) ; } } 	1	['5', '1', '5', '8', '14', '0', '5', '3', '4', '0', '48', '1', '0', '0', '0.4', '0', '0', '8.4', '2', '1', '1']
package org . apache . camel . component . test ; import java . net . URI ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . UnsafeUriCharactersEncoder ; public class TestComponent extends DefaultComponent < Exchange > { public Endpoint < Exchange > createEndpoint ( String uri ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; URI u = new URI ( UnsafeUriCharactersEncoder . encode ( uri ) ) ; String path = u . getSchemeSpecificPart ( ) ; return createEndpoint ( uri , path , new HashMap ( ) ) ; } @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( getCamelContext ( ) , remaining ) ; return new TestEndpoint ( uri , this , endpoint ) ; } } 	0	['3', '3', '0', '8', '12', '3', '0', '8', '2', '2', '39', '0', '0', '0.945945946', '0.666666667', '1', '1', '12', '1', '0.6667', '0']
package org . apache . camel . processor ; import java . io . InputStream ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; public class UnmarshalProcessor implements Processor { private final DataFormat dataFormat ; public UnmarshalProcessor ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } public void process ( Exchange exchange ) throws Exception { InputStream stream = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; try { Message out = exchange . getOut ( true ) ; out . copyFrom ( exchange . getIn ( ) ) ; Object result = dataFormat . unmarshal ( exchange , stream ) ; out . setBody ( result ) ; } finally { if ( stream != null ) { stream . close ( ) ; } } } } 	1	['2', '1', '0', '6', '10', '0', '1', '5', '2', '0', '44', '1', '1', '0', '0.666666667', '0', '0', '20.5', '1', '0.5', '1']
package org . apache . camel . component . quartz ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class QuartzConsumer extends DefaultConsumer < QuartzExchange > { public QuartzConsumer ( QuartzEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; } @ Override public QuartzEndpoint getEndpoint ( ) { return ( QuartzEndpoint ) super . getEndpoint ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; getEndpoint ( ) . consumerStarted ( this ) ; } @ Override protected void doStop ( ) throws Exception { getEndpoint ( ) . consumerStopped ( this ) ; super . doStop ( ) ; } } 	0	['5', '3', '0', '4', '10', '10', '1', '4', '3', '2', '31', '0', '0', '0.851851852', '0.466666667', '1', '1', '5.2', '1', '0.8', '0']
package org . apache . camel . impl ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . PollingConsumer ; import org . apache . camel . util . ObjectHelper ; public abstract class DefaultEndpoint < E extends Exchange > implements Endpoint < E > , CamelContextAware { private String endpointUri ; private CamelContext camelContext ; private Component component ; private ScheduledExecutorService executorService ; private ExchangePattern exchangePattern = ExchangePattern . InOnly ; protected DefaultEndpoint ( String endpointUri , Component component ) { this ( endpointUri , component . getCamelContext ( ) ) ; this . component = component ; } protected DefaultEndpoint ( String endpointUri , CamelContext camelContext ) { this ( endpointUri ) ; this . camelContext = camelContext ; } protected DefaultEndpoint ( String endpointUri ) { this . setEndpointUri ( endpointUri ) ; } protected DefaultEndpoint ( ) { } public int hashCode ( ) { return getEndpointUri ( ) . hashCode ( ) * 37 + 1 ; } @ Override public boolean equals ( Object object ) { if ( object instanceof DefaultEndpoint ) { DefaultEndpoint that = ( DefaultEndpoint ) object ; return ObjectHelper . equal ( this . getEndpointUri ( ) , that . getEndpointUri ( ) ) ; } return false ; } @ Override public String toString ( ) { return "Endpoint[" + getEndpointUri ( ) + "]" ; } public String getEndpointUri ( ) { if ( endpointUri == null ) { endpointUri = createEndpointUri ( ) ; if ( endpointUri == null ) { throw new IllegalArgumentException ( "endpointUri is not specified and " + getClass ( ) . getName ( ) + " does not implement createEndpointUri() to create a default value" ) ; } } return endpointUri ; } public CamelContext getCamelContext ( ) { return camelContext ; } public Component getComponent ( ) { return component ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public synchronized ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { Component c = getComponent ( ) ; if ( c != null && c instanceof DefaultComponent ) { DefaultComponent dc = ( DefaultComponent ) c ; executorService = dc . getExecutorService ( ) ; } if ( executorService == null ) { executorService = createExecutorService ( ) ; } } return executorService ; } public synchronized void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } public PollingConsumer < E > createPollingConsumer ( ) throws Exception { return new EventDrivenPollingConsumer < E > ( this ) ; } public E convertTo ( Class < E > type , Exchange exchange ) { if ( type . isInstance ( exchange ) ) { return type . cast ( exchange ) ; } return getCamelContext ( ) . getExchangeConverter ( ) . convertTo ( type , exchange ) ; } public E createExchange ( Exchange exchange ) { Class < E > exchangeType = getExchangeType ( ) ; if ( exchangeType != null ) { if ( exchangeType . isInstance ( exchange ) ) { return exchangeType . cast ( exchange ) ; } } E answer = createExchange ( ) ; answer . copyFrom ( exchange ) ; return answer ; } public Class < E > getExchangeType ( ) { Type type = getClass ( ) . getGenericSuperclass ( ) ; if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; if ( arguments . length > 0 ) { Type argumentType = arguments [ 0 ] ; if ( argumentType instanceof Class ) { return ( Class < E > ) argumentType ; } } } return null ; } public E createExchange ( ) { return createExchange ( getExchangePattern ( ) ) ; } public E createExchange ( ExchangePattern pattern ) { return ( E ) new DefaultExchange ( getCamelContext ( ) , pattern ) ; } public ExchangePattern getExchangePattern ( ) { return exchangePattern ; } public void setExchangePattern ( ExchangePattern exchangePattern ) { this . exchangePattern = exchangePattern ; } protected ScheduledThreadPoolExecutor createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( 10 ) ; } public void configureProperties ( Map options ) { } protected String createEndpointUri ( ) { return null ; } protected void setEndpointUri ( String endpointUri ) { this . endpointUri = endpointUri ; } @ Deprecated public CamelContext getContext ( ) { return getCamelContext ( ) ; } @ Deprecated public void setContext ( CamelContext context ) { setCamelContext ( context ) ; } public boolean isLenientProperties ( ) { return false ; } } 	1	['28', '1', '21', '41', '49', '354', '29', '12', '21', '0.851851852', '281', '1', '3', '0', '0.157142857', '1', '1', '8.857142857', '5', '1.3214', '5']
package org . apache . camel . component . cxf . invoker ; import java . util . List ; import org . w3c . dom . Element ; import org . apache . cxf . binding . soap . SoapHeader ; public class PayloadMessage { private List < Element > payload ; private List < SoapHeader > headers ; public PayloadMessage ( List < Element > payload , List < SoapHeader > headers ) { this . payload = payload ; this . headers = headers ; } public List < Element > getPayload ( ) { return payload ; } public List < SoapHeader > getHeaders ( ) { return headers ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "payload: " + payload ) ; buf . append ( " headers: " + headers ) ; return buf . toString ( ) ; } } 	0	['4', '1', '0', '1', '12', '0', '1', '0', '4', '0.333333333', '52', '1', '0', '0', '0.625', '0', '0', '11.5', '1', '0.75', '0']
package org . apache . camel . impl ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . FailedToCreateProducerException ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class ProducerCache < E extends Exchange > extends ServiceSupport { private static final transient Log LOG = LogFactory . getLog ( ProducerCache . class ) ; private Map < String , Producer < E > > producers = new HashMap < String , Producer < E > > ( ) ; public synchronized Producer < E > getProducer ( Endpoint < E > endpoint ) { String key = endpoint . getEndpointUri ( ) ; Producer < E > answer = producers . get ( key ) ; if ( answer == null ) { try { answer = endpoint . createProducer ( ) ; answer . start ( ) ; } catch ( Exception e ) { throw new FailedToCreateProducerException ( endpoint , e ) ; } producers . put ( key , answer ) ; } return answer ; } public void send ( Endpoint < E > endpoint , E exchange ) { try { Producer < E > producer = getProducer ( endpoint ) ; producer . process ( exchange ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } public E send ( Endpoint < E > endpoint , Processor processor ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( ) ; return sendExchange ( endpoint , producer , processor , exchange ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } public E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( ) ; boolean sync = sendExchange ( endpoint , producer , processor , exchange , callback ) ; setProcessedSync ( exchange , sync ) ; return exchange ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } public static boolean isProcessedSync ( Exchange exchange ) { Boolean rc = exchange . getProperty ( ProducerCache . class . getName ( ) + ".SYNC" , Boolean . class ) ; return rc == null ? false : rc ; } public static void setProcessedSync ( Exchange exchange , boolean b ) { exchange . setProperty ( ProducerCache . class . getName ( ) + ".SYNC" , b ? Boolean . TRUE : Boolean . FALSE ) ; } public E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) { try { Producer < E > producer = getProducer ( endpoint ) ; E exchange = producer . createExchange ( pattern ) ; return sendExchange ( endpoint , producer , processor , exchange ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } protected E sendExchange ( Endpoint < E > endpoint , Producer < E > producer , Processor processor , E exchange ) throws Exception { processor . process ( exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> " + endpoint + " " + exchange ) ; } producer . process ( exchange ) ; return exchange ; } protected boolean sendExchange ( Endpoint < E > endpoint , Producer < E > producer , Processor processor , E exchange , AsyncCallback callback ) throws Exception { processor . process ( exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> " + endpoint + " " + exchange ) ; } return AsyncProcessorTypeConverter . convert ( producer ) . process ( exchange , callback ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( producers . values ( ) ) ; producers . clear ( ) ; } protected void doStart ( ) throws Exception { } } 	1	['13', '2', '0', '18', '42', '66', '3', '15', '8', '0.541666667', '231', '1', '0', '0.56', '0.34375', '1', '1', '16.61538462', '2', '1.0769', '7']
package org . apache . camel . model ; public class NodeFactory { public FilterType createFilter ( ) { return new FilterType ( ) ; } public LoopType createLoop ( ) { return new LoopType ( ) ; } public RouteType createRoute ( ) { return new RouteType ( ) ; } } 	0	['4', '1', '0', '4', '8', '6', '1', '3', '4', '2', '19', '0', '0', '0', '1', '0', '0', '3.75', '1', '0.75', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "xstream" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class XStreamDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private Boolean prettyPrint ; public XStreamDataFormat ( ) { super ( "org.apache.camel.dataformat.xstream.XStreamDataFormat" ) ; } public Boolean getPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( Boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } } 	1	['3', '3', '0', '2', '4', '1', '1', '1', '3', '0.5', '15', '1', '0', '0.818181818', '0.666666667', '0', '0', '3.666666667', '1', '0.6667', '1']
package org . apache . camel . component . jhc ; import java . io . IOException ; import org . apache . http . ConnectionReuseStrategy ; import org . apache . http . HttpException ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; import org . apache . http . HttpResponseFactory ; import org . apache . http . HttpStatus ; import org . apache . http . HttpVersion ; import org . apache . http . ProtocolVersion ; import org . apache . http . impl . DefaultConnectionReuseStrategy ; import org . apache . http . impl . DefaultHttpResponseFactory ; import org . apache . http . nio . NHttpServerConnection ; import org . apache . http . nio . util . ByteBufferAllocator ; import org . apache . http . params . HttpParams ; import org . apache . http . protocol . BasicHttpProcessor ; import org . apache . http . protocol . ExecutionContext ; import org . apache . http . protocol . HttpContext ; import org . apache . http . protocol . HttpProcessor ; import org . apache . http . protocol . HttpRequestHandler ; import org . apache . http . protocol . ResponseConnControl ; import org . apache . http . protocol . ResponseContent ; import org . apache . http . protocol . ResponseDate ; import org . apache . http . protocol . ResponseServer ; public class AsyncBufferingHttpServiceHandler extends BufferingHttpServiceHandler { public AsyncBufferingHttpServiceHandler ( final HttpParams params ) { super ( createDefaultProcessor ( ) , new DefaultHttpResponseFactory ( ) , new DefaultConnectionReuseStrategy ( ) , params ) ; } public AsyncBufferingHttpServiceHandler ( final HttpProcessor httpProcessor , final HttpResponseFactory responseFactory , final ConnectionReuseStrategy connStrategy , final HttpParams params ) { super ( httpProcessor , responseFactory , connStrategy , params ) ; } public AsyncBufferingHttpServiceHandler ( final HttpProcessor httpProcessor , final HttpResponseFactory responseFactory , final ConnectionReuseStrategy connStrategy , final ByteBufferAllocator allocator , final HttpParams params ) { super ( httpProcessor , responseFactory , connStrategy , allocator , params ) ; } protected static HttpProcessor createDefaultProcessor ( ) { BasicHttpProcessor httpproc = new BasicHttpProcessor ( ) ; httpproc . addInterceptor ( new ResponseDate ( ) ) ; httpproc . addInterceptor ( new ResponseServer ( ) ) ; httpproc . addInterceptor ( new ResponseContent ( ) ) ; httpproc . addInterceptor ( new ResponseConnControl ( ) ) ; return httpproc ; } protected void processRequest ( final NHttpServerConnection conn , final HttpRequest request ) throws IOException , HttpException { HttpContext context = conn . getContext ( ) ; ProtocolVersion ver = request . getRequestLine ( ) . getProtocolVersion ( ) ; if ( ! ver . lessEquals ( HttpVersion . HTTP_1_1 ) ) { ver = HttpVersion . HTTP_1_1 ; } context . setAttribute ( ExecutionContext . HTTP_REQUEST , request ) ; context . setAttribute ( ExecutionContext . HTTP_CONNECTION , conn ) ; try { this . httpProcessor . process ( request , context ) ; HttpRequestHandler handler = null ; if ( handlerResolver != null ) { String requestURI = request . getRequestLine ( ) . getUri ( ) ; handler = handlerResolver . lookup ( requestURI ) ; } if ( handler != null ) { if ( handler instanceof AsyncHttpRequestHandler ) { ( ( AsyncHttpRequestHandler ) handler ) . handle ( request , context , new AsyncResponseHandler ( ) { public void sendResponse ( HttpResponse response ) throws IOException , HttpException { try { AsyncBufferingHttpServiceHandler . this . sendResponse ( conn , response ) ; } catch ( HttpException ex ) { response = AsyncBufferingHttpServiceHandler . this . responseFactory . newHttpResponse ( HttpVersion . HTTP_1_0 , HttpStatus . SC_INTERNAL_SERVER_ERROR , conn . getContext ( ) ) ; response . setParams ( AsyncBufferingHttpServiceHandler . this . params ) ; AsyncBufferingHttpServiceHandler . this . handleException ( ex , response ) ; AsyncBufferingHttpServiceHandler . this . sendResponse ( conn , response ) ; } } } ) ; } else { HttpResponse response = this . responseFactory . newHttpResponse ( ver , HttpStatus . SC_OK , conn . getContext ( ) ) ; response . setParams ( this . params ) ; context . setAttribute ( ExecutionContext . HTTP_RESPONSE , response ) ; handler . handle ( request , response , context ) ; sendResponse ( conn , response ) ; } } else { HttpResponse response = this . responseFactory . newHttpResponse ( ver , HttpStatus . SC_OK , conn . getContext ( ) ) ; response . setStatusCode ( HttpStatus . SC_NOT_IMPLEMENTED ) ; } } catch ( HttpException ex ) { HttpResponse response = this . responseFactory . newHttpResponse ( HttpVersion . HTTP_1_0 , HttpStatus . SC_INTERNAL_SERVER_ERROR , context ) ; response . setParams ( this . params ) ; handleException ( ex , response ) ; sendResponse ( conn , response ) ; } } } 	0	['7', '1', '0', '28', '33', '17', '2', '27', '3', '2', '180', '0', '0', '0.714285714', '0.285714286', '1', '4', '24.71428571', '1', '0.5714', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "jaxb" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class JaxbDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private String contextPath ; @ XmlAttribute ( required = false ) private Boolean prettyPrint ; @ XmlAttribute ( required = false ) private Boolean ignoreJAXBElement ; public JaxbDataFormat ( ) { super ( "org.apache.camel.converter.jaxb.JaxbDataFormat" ) ; } public JaxbDataFormat ( boolean prettyPrint ) { this ( ) ; setPrettyPrint ( prettyPrint ) ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public Boolean getPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( Boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } public Boolean getIgnoreJAXBElement ( ) { return ignoreJAXBElement ; } public void setIgnoreJAXBElement ( Boolean ignoreJAXBElement ) { this . ignoreJAXBElement = ignoreJAXBElement ; } @ Override protected void configureDataFormat ( DataFormat dataFormat ) { Boolean answer = ObjectHelper . toBoolean ( getPrettyPrint ( ) ) ; if ( answer != null && ! answer . booleanValue ( ) ) { setProperty ( dataFormat , "prettyPrint" , Boolean . FALSE ) ; } else { setProperty ( dataFormat , "prettyPrint" , Boolean . TRUE ) ; } answer = ObjectHelper . toBoolean ( getIgnoreJAXBElement ( ) ) ; if ( answer != null && ! answer . booleanValue ( ) ) { setProperty ( dataFormat , "ignoreJAXBElement" , Boolean . FALSE ) ; } else { setProperty ( dataFormat , "ignoreJAXBElement" , Boolean . TRUE ) ; } setProperty ( dataFormat , "contextPath" , contextPath ) ; } } 	1	['9', '3', '0', '4', '14', '26', '1', '3', '8', '0.708333333', '91', '1', '0', '0.5625', '0.311111111', '1', '2', '8.777777778', '5', '1.2222', '1']
package org . apache . camel . processor ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Service ; import org . apache . camel . util . AsyncProcessorHelper ; public class ThreadProcessor implements AsyncProcessor , Service { private ThreadPoolExecutor executor ; private long stackSize ; private ThreadGroup threadGroup ; private int priority = Thread . NORM_PRIORITY ; private boolean daemon = true ; private String name = "Thread Processor" ; private BlockingQueue < Runnable > taskQueue ; private long keepAliveTime ; private int maxSize = 1 ; private int coreSize = 1 ; private final AtomicBoolean shutdown = new AtomicBoolean ( true ) ; private boolean callerRunsWhenRejected = true ; class ProcessCall implements Runnable { private final Exchange exchange ; private final AsyncCallback callback ; public ProcessCall ( Exchange exchange , AsyncCallback callback ) { this . exchange = exchange ; this . callback = callback ; } public void run ( ) { if ( shutdown . get ( ) ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } callback . done ( false ) ; } } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( shutdown . get ( ) ) { throw new IllegalStateException ( "ThreadProcessor is not running." ) ; } ProcessCall call = new ProcessCall ( exchange , callback ) ; try { executor . execute ( call ) ; return false ; } catch ( RejectedExecutionException e ) { if ( callerRunsWhenRejected ) { if ( shutdown . get ( ) ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } else { callback . done ( true ) ; } } else { exchange . setException ( e ) ; } return true ; } } public void start ( ) throws Exception { shutdown . set ( false ) ; getExecutor ( ) ; } public void stop ( ) throws Exception { shutdown . set ( true ) ; executor . shutdown ( ) ; executor . awaitTermination ( 0 , TimeUnit . SECONDS ) ; } public long getStackSize ( ) { return stackSize ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public ThreadGroup getThreadGroup ( ) { return threadGroup ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public long getKeepAliveTime ( ) { return keepAliveTime ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public int getMaxSize ( ) { return maxSize ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public int getCoreSize ( ) { return coreSize ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public BlockingQueue < Runnable > getTaskQueue ( ) { if ( taskQueue == null ) { taskQueue = new ArrayBlockingQueue < Runnable > ( 1000 ) ; } return taskQueue ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public ThreadPoolExecutor getExecutor ( ) { if ( executor == null ) { executor = new ThreadPoolExecutor ( getCoreSize ( ) , getMaxSize ( ) , getKeepAliveTime ( ) , TimeUnit . MILLISECONDS , getTaskQueue ( ) , new ThreadFactory ( ) { public Thread newThread ( Runnable runnable ) { Thread thread ; if ( getStackSize ( ) > 0 ) { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) , getStackSize ( ) ) ; } else { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) ) ; } thread . setDaemon ( isDaemon ( ) ) ; thread . setPriority ( getPriority ( ) ) ; return thread ; } } ) ; } return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } public boolean isCallerRunsWhenRejected ( ) { return callerRunsWhenRejected ; } public void setCallerRunsWhenRejected ( boolean callerRunsWhenRejected ) { this . callerRunsWhenRejected = callerRunsWhenRejected ; } } 	0	['28', '1', '0', '8', '44', '300', '3', '7', '27', '0.910493827', '248', '1', '0', '0', '0.136363636', '0', '0', '7.428571429', '4', '1.1429', '0']
package org . apache . camel . component . log ; import java . io . InputStream ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . converter . stream . StreamCache ; import org . apache . camel . processor . interceptor . ExchangeFormatter ; import org . apache . camel . util . ObjectHelper ; public class LogFormatter implements ExchangeFormatter { private boolean showExchangeId ; private boolean showProperties ; private boolean showHeaders ; private boolean showBodyType = true ; private boolean showBody = true ; private boolean showOut ; private boolean showAll ; private boolean multiline ; public Object format ( Exchange exchange ) { Message in = exchange . getIn ( ) ; StringBuilder sb = new StringBuilder ( "" ) ; if ( showAll || showExchangeId ) { if ( multiline ) { sb . append ( '\n' ) ; } sb . append ( ", Id:" ) . append ( exchange . getExchangeId ( ) ) ; } if ( showAll || showProperties ) { if ( multiline ) { sb . append ( '\n' ) ; } sb . append ( ", Properties:" ) . append ( exchange . getProperties ( ) ) ; } if ( showAll || showHeaders ) { if ( multiline ) { sb . append ( '\n' ) ; } sb . append ( ", Headers:" ) . append ( in . getHeaders ( ) ) ; } if ( showAll || showBodyType ) { if ( multiline ) { sb . append ( '\n' ) ; } sb . append ( ", BodyType:" ) . append ( getBodyTypeAsString ( in ) ) ; } if ( showAll || showBody ) { if ( multiline ) { sb . append ( '\n' ) ; } sb . append ( ", Body:" ) . append ( getBodyAsString ( in ) ) ; } Message out = exchange . getOut ( false ) ; if ( showAll || showOut ) { if ( out != null ) { if ( showAll || showHeaders ) { if ( multiline ) { sb . append ( '\n' ) ; } sb . append ( ", OutHeaders:" ) . append ( out . getHeaders ( ) ) ; } if ( showAll || showBodyType ) { if ( multiline ) { sb . append ( '\n' ) ; } sb . append ( ", OutBodyType:" ) . append ( getBodyTypeAsString ( out ) ) ; } if ( showAll || showBody ) { if ( multiline ) { sb . append ( '\n' ) ; } sb . append ( ", OutBody:" ) . append ( getBodyAsString ( out ) ) ; } } else { if ( multiline ) { sb . append ( '\n' ) ; } sb . append ( ", Out: null" ) ; } } return "Exchange[" + ( multiline ? sb . append ( ']' ) . toString ( ) : sb . toString ( ) . substring ( 2 ) + "]" ) ; } public boolean isShowExchangeId ( ) { return showExchangeId ; } public void setShowExchangeId ( boolean showExchangeId ) { this . showExchangeId = showExchangeId ; } public boolean isShowProperties ( ) { return showProperties ; } public void setShowProperties ( boolean showProperties ) { this . showProperties = showProperties ; } public boolean isShowHeaders ( ) { return showHeaders ; } public void setShowHeaders ( boolean showHeaders ) { this . showHeaders = showHeaders ; } public boolean isShowBodyType ( ) { return showBodyType ; } public void setShowBodyType ( boolean showBodyType ) { this . showBodyType = showBodyType ; } public boolean isShowBody ( ) { return showBody ; } public void setShowBody ( boolean showBody ) { this . showBody = showBody ; } public boolean isShowOut ( ) { return showOut ; } public void setShowOut ( boolean showOut ) { this . showOut = showOut ; } public boolean isShowAll ( ) { return showAll ; } public void setShowAll ( boolean showAll ) { this . showAll = showAll ; } public boolean isMultiline ( ) { return multiline ; } public void setMultiline ( boolean multiline ) { this . multiline = multiline ; } protected Object getBodyAsString ( Message message ) { StreamCache newBody = null ; try { newBody = message . getBody ( StreamCache . class ) ; if ( newBody != null ) { message . setBody ( newBody ) ; } } catch ( NoTypeConversionAvailableException ex ) { } Object answer = null ; try { answer = message . getBody ( String . class ) ; } catch ( NoTypeConversionAvailableException ex ) { answer = message . getBody ( ) ; } if ( newBody != null ) { newBody . reset ( ) ; } return answer ; } protected Object getBodyTypeAsString ( Message message ) { String answer = ObjectHelper . classCanonicalName ( message . getBody ( ) ) ; if ( answer != null && answer . startsWith ( "java.lang." ) ) { return answer . substring ( 10 ) ; } return answer ; } } 	1	['20', '1', '0', '7', '39', '132', '1', '6', '18', '0.881578947', '363', '1', '0', '0', '0.3875', '0', '0', '16.75', '30', '2.55', '1']
package org . apache . camel . component . dataset ; import org . apache . camel . Processor ; public class SimpleDataSet extends DataSetSupport { private Object defaultBody = "<hello>world!</hello>" ; private Processor inputTransformer ; public SimpleDataSet ( ) { } public SimpleDataSet ( int size ) { super ( size ) ; } public Object getDefaultBody ( ) { return defaultBody ; } public void setDefaultBody ( Object defaultBody ) { this . defaultBody = defaultBody ; } public Processor getInputTransformer ( ) { return inputTransformer ; } public void setInputTransformer ( Processor inputTransformer ) { this . inputTransformer = inputTransformer ; } protected Object createMessageBody ( long messageIndex ) { return getDefaultBody ( ) ; } } 	0	['7', '2', '0', '2', '9', '7', '0', '2', '6', '0.583333333', '39', '1', '1', '0.722222222', '0.314285714', '1', '1', '4.285714286', '1', '0.7143', '0']
package org . apache . camel ; import java . util . List ; public interface Routes { CamelContext getContext ( ) ; void setContext ( CamelContext context ) ; List < Route > getRouteList ( ) throws Exception ; } 	1	['3', '1', '0', '7', '3', '3', '7', '1', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class BeanExchange extends DefaultExchange { public BeanExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } public BeanExchange ( DefaultExchange parent ) { super ( parent ) ; } public BeanInvocation getInvocation ( ) { return getIn ( ) . getBody ( BeanInvocation . class ) ; } public void setInvocation ( BeanInvocation invocation ) { getIn ( ) . setBody ( invocation ) ; } @ Override public Exchange newInstance ( ) { return new BeanExchange ( this ) ; } } 	0	['5', '2', '0', '9', '10', '10', '3', '6', '5', '2', '30', '0', '0', '0.926829268', '0.36', '1', '1', '5', '1', '0.6', '0']
package org . apache . camel . builder . xml ; import java . io . StringReader ; import java . util . List ; import java . util . Map ; import javax . xml . namespace . QName ; import javax . xml . transform . dom . DOMSource ; import javax . xml . xpath . XPath ; import javax . xml . xpath . XPathConstants ; import javax . xml . xpath . XPathExpression ; import javax . xml . xpath . XPathExpressionException ; import javax . xml . xpath . XPathFactory ; import javax . xml . xpath . XPathFactoryConfigurationException ; import javax . xml . xpath . XPathFunction ; import javax . xml . xpath . XPathFunctionException ; import javax . xml . xpath . XPathFunctionResolver ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . InputSource ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . RuntimeExpressionException ; import org . apache . camel . spi . NamespaceAware ; import org . apache . camel . util . ExchangeHelper ; import static org . apache . camel . builder . xml . Namespaces . DEFAULT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . IN_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . OUT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . isMatchingNamespaceOrEmptyNamespace ; import static org . apache . camel . converter . ObjectConverter . toBoolean ; public class XPathBuilder < E extends Exchange > implements Expression < E > , Predicate < E > , NamespaceAware { private final String text ; private XPathFactory xpathFactory ; private Class documentType = Document . class ; private Class resultType ; private QName resultQName = XPathConstants . NODESET ; private String objectModelUri ; private DefaultNamespaceContext namespaceContext ; private XPathFunctionResolver functionResolver ; private XPathExpression expression ; private MessageVariableResolver variableResolver = new MessageVariableResolver ( ) ; private E exchange ; private XPathFunction bodyFunction ; private XPathFunction headerFunction ; private XPathFunction outBodyFunction ; private XPathFunction outHeaderFunction ; public XPathBuilder ( String text ) { this . text = text ; } public static XPathBuilder xpath ( String text ) { return new XPathBuilder ( text ) ; } @ Override public String toString ( ) { return "XPath: " + text ; } public boolean matches ( E exchange ) { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; return toBoolean ( booleanResult ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; if ( ! toBoolean ( booleanResult ) ) { throw new AssertionError ( this + " failed on " + exchange + " as returned <" + booleanResult + ">" ) ; } } public Object evaluate ( E exchange ) { Object answer = evaluateAs ( exchange , resultQName ) ; if ( resultType != null ) { return ExchangeHelper . convertToType ( exchange , resultType , answer ) ; } return answer ; } public XPathBuilder < E > booleanResult ( ) { resultQName = XPathConstants . BOOLEAN ; return this ; } public XPathBuilder < E > nodeResult ( ) { resultQName = XPathConstants . NODE ; return this ; } public XPathBuilder < E > nodeSetResult ( ) { resultQName = XPathConstants . NODESET ; return this ; } public XPathBuilder < E > numberResult ( ) { resultQName = XPathConstants . NUMBER ; return this ; } public XPathBuilder < E > stringResult ( ) { resultQName = XPathConstants . STRING ; return this ; } public XPathBuilder < E > resultType ( Class resultType ) { setResultType ( resultType ) ; return this ; } public XPathBuilder < E > objectModel ( String uri ) { this . objectModelUri = uri ; return this ; } public XPathBuilder < E > functionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; return this ; } public XPathBuilder < E > namespace ( String prefix , String uri ) { getNamespaceContext ( ) . add ( prefix , uri ) ; return this ; } public XPathBuilder < E > namespaces ( Namespaces namespaces ) { namespaces . configure ( this ) ; return this ; } public XPathBuilder < E > variable ( String name , Object value ) { variableResolver . addVariable ( name , value ) ; return this ; } public XPathFactory getXPathFactory ( ) throws XPathFactoryConfigurationException { if ( xpathFactory == null ) { if ( objectModelUri != null ) { xpathFactory = XPathFactory . newInstance ( objectModelUri ) ; } xpathFactory = XPathFactory . newInstance ( ) ; } return xpathFactory ; } public void setXPathFactory ( XPathFactory xpathFactory ) { this . xpathFactory = xpathFactory ; } public Class getDocumentType ( ) { return documentType ; } public void setDocumentType ( Class documentType ) { this . documentType = documentType ; } public String getText ( ) { return text ; } public QName getResultQName ( ) { return resultQName ; } public void setResultQName ( QName resultQName ) { this . resultQName = resultQName ; } public DefaultNamespaceContext getNamespaceContext ( ) { if ( namespaceContext == null ) { try { DefaultNamespaceContext defaultNamespaceContext = new DefaultNamespaceContext ( getXPathFactory ( ) ) ; populateDefaultNamespaces ( defaultNamespaceContext ) ; namespaceContext = defaultNamespaceContext ; } catch ( XPathFactoryConfigurationException e ) { throw new RuntimeExpressionException ( e ) ; } } return namespaceContext ; } public void setNamespaceContext ( DefaultNamespaceContext namespaceContext ) { this . namespaceContext = namespaceContext ; } public XPathFunctionResolver getFunctionResolver ( ) { return functionResolver ; } public void setFunctionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; } public XPathExpression getExpression ( ) throws XPathFactoryConfigurationException , XPathExpressionException { if ( expression == null ) { expression = createXPathExpression ( ) ; } return expression ; } public void setNamespaces ( Map < String , String > namespaces ) { getNamespaceContext ( ) . setNamespaces ( namespaces ) ; } public XPathFunction getBodyFunction ( ) { if ( bodyFunction == null ) { bodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange == null ) { return null ; } return exchange . getIn ( ) . getBody ( ) ; } } ; } return bodyFunction ; } public void setBodyFunction ( XPathFunction bodyFunction ) { this . bodyFunction = bodyFunction ; } public XPathFunction getHeaderFunction ( ) { if ( headerFunction == null ) { headerFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getIn ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return headerFunction ; } public void setHeaderFunction ( XPathFunction headerFunction ) { this . headerFunction = headerFunction ; } public XPathFunction getOutBodyFunction ( ) { if ( outBodyFunction == null ) { outBodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null ) { Message out = exchange . getOut ( false ) ; if ( out != null ) { return out . getBody ( ) ; } } return null ; } } ; } return outBodyFunction ; } public void setOutBodyFunction ( XPathFunction outBodyFunction ) { this . outBodyFunction = outBodyFunction ; } public XPathFunction getOutHeaderFunction ( ) { if ( outHeaderFunction == null ) { outHeaderFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getOut ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return outHeaderFunction ; } public void setOutHeaderFunction ( XPathFunction outHeaderFunction ) { this . outHeaderFunction = outHeaderFunction ; } public Class getResultType ( ) { return resultType ; } public void setResultType ( Class resultType ) { this . resultType = resultType ; if ( Number . class . isAssignableFrom ( resultType ) ) { numberResult ( ) ; } else if ( String . class . isAssignableFrom ( resultType ) ) { stringResult ( ) ; } else if ( Boolean . class . isAssignableFrom ( resultType ) ) { booleanResult ( ) ; } else if ( Node . class . isAssignableFrom ( resultType ) ) { nodeResult ( ) ; } else if ( NodeList . class . isAssignableFrom ( resultType ) ) { nodeSetResult ( ) ; } } protected synchronized Object evaluateAs ( E exchange , QName resultQName ) { this . exchange = exchange ; variableResolver . setExchange ( exchange ) ; try { Object document = getDocument ( exchange ) ; if ( resultQName != null ) { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource , resultQName ) ; } else if ( document instanceof DOMSource ) { DOMSource source = ( DOMSource ) document ; return getExpression ( ) . evaluate ( source . getNode ( ) , resultQName ) ; } else { return getExpression ( ) . evaluate ( document , resultQName ) ; } } else { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource ) ; } else if ( document instanceof DOMSource ) { DOMSource source = ( DOMSource ) document ; return getExpression ( ) . evaluate ( source . getNode ( ) ) ; } else { return getExpression ( ) . evaluate ( document ) ; } } } catch ( XPathExpressionException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } catch ( XPathFactoryConfigurationException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } } protected XPathExpression createXPathExpression ( ) throws XPathExpressionException , XPathFactoryConfigurationException { XPath xPath = getXPathFactory ( ) . newXPath ( ) ; xpathFactory = null ; xPath . setNamespaceContext ( getNamespaceContext ( ) ) ; xPath . setXPathVariableResolver ( variableResolver ) ; XPathFunctionResolver parentResolver = getFunctionResolver ( ) ; if ( parentResolver == null ) { parentResolver = xPath . getXPathFunctionResolver ( ) ; } xPath . setXPathFunctionResolver ( createDefaultFunctionResolver ( parentResolver ) ) ; return xPath . compile ( text ) ; } protected void populateDefaultNamespaces ( DefaultNamespaceContext context ) { setNamespaceIfNotPresent ( context , "in" , IN_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "out" , OUT_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "env" , Namespaces . ENVIRONMENT_VARIABLES ) ; setNamespaceIfNotPresent ( context , "system" , Namespaces . SYSTEM_PROPERTIES_NAMESPACE ) ; } protected void setNamespaceIfNotPresent ( DefaultNamespaceContext context , String prefix , String uri ) { if ( context != null ) { String current = context . getNamespaceURI ( prefix ) ; if ( current == null ) { context . add ( prefix , uri ) ; } } } protected XPathFunctionResolver createDefaultFunctionResolver ( final XPathFunctionResolver parent ) { return new XPathFunctionResolver ( ) { public XPathFunction resolveFunction ( QName qName , int argumentCount ) { XPathFunction answer = null ; if ( parent != null ) { answer = parent . resolveFunction ( qName , argumentCount ) ; } if ( answer == null ) { if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , IN_NAMESPACE ) || isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , DEFAULT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getHeaderFunction ( ) ; } } if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , OUT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getOutBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getOutHeaderFunction ( ) ; } } } return answer ; } } ; } protected Object getDocument ( E exchange ) { Message in = exchange . getIn ( ) ; Class type = getDocumentType ( ) ; Object answer = null ; if ( type != null ) { answer = in . getBody ( type ) ; } if ( answer == null ) { answer = in . getBody ( ) ; } if ( answer instanceof String ) { answer = new InputSource ( new StringReader ( answer . toString ( ) ) ) ; } return answer ; } } 	1	['49', '1', '0', '20', '93', '1044', '8', '17', '42', '0.915277778', '620', '1', '3', '0', '0.128728414', '0', '0', '11.34693878', '6', '1.4082', '1']
package org . apache . camel . spring ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Routes ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . DefaultLifecycleStrategy ; import org . apache . camel . management . DefaultInstrumentationAgent ; import org . apache . camel . management . InstrumentationLifecycleStrategy ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . model . IdentifiedType ; import org . apache . camel . model . InterceptType ; import org . apache . camel . model . ProceedType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteBuilderRef ; import org . apache . camel . model . RouteContainer ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . dataformat . DataFormatsType ; import org . apache . camel . processor . interceptor . Debugger ; import org . apache . camel . processor . interceptor . Delayer ; import org . apache . camel . processor . interceptor . TraceFormatter ; import org . apache . camel . processor . interceptor . Tracer ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . ResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . ApplicationListener ; import org . springframework . context . event . ContextRefreshedEvent ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; @ XmlRootElement ( name = "camelContext" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelContextFactoryBean extends IdentifiedType implements RouteContainer , FactoryBean , InitializingBean , DisposableBean , ApplicationContextAware , ApplicationListener { private static final Log LOG = LogFactory . getLog ( CamelContextFactoryBean . class ) ; @ XmlAttribute ( required = false ) @ Deprecated private Boolean useJmx = Boolean . TRUE ; @ XmlAttribute ( required = false ) private Boolean autowireRouteBuilders = Boolean . TRUE ; @ XmlAttribute ( required = false ) private Boolean trace ; @ XmlAttribute ( required = false ) private Long delay ; @ XmlAttribute ( required = false ) private String errorHandlerRef ; @ XmlAttribute ( required = false ) private Boolean shouldStartContext = Boolean . TRUE ; @ XmlElement ( name = "package" , required = false ) private String [ ] packages = { } ; @ XmlElement ( name = "jmxAgent" , type = CamelJMXAgentType . class , required = false ) private CamelJMXAgentType camelJMXAgent ; @ XmlElements ( { @ XmlElement ( name = "beanPostProcessor" , type = CamelBeanPostProcessor . class , required = false ) , @ XmlElement ( name = "template" , type = CamelTemplateFactoryBean . class , required = false ) , @ XmlElement ( name = "proxy" , type = CamelProxyFactoryType . class , required = false ) , @ XmlElement ( name = "export" , type = CamelServiceExporterType . class , required = false ) } ) private List beans ; @ XmlElement ( name = "routeBuilderRef" , required = false ) private List < RouteBuilderRef > builderRefs = new ArrayList < RouteBuilderRef > ( ) ; @ XmlElement ( name = "endpoint" , required = false ) private List < EndpointFactoryBean > endpoints ; @ XmlElement ( name = "dataFormats" , required = false ) private DataFormatsType dataFormats ; @ XmlElement ( name = "intercept" , required = false ) private List < InterceptType > intercepts = new ArrayList < InterceptType > ( ) ; @ XmlElement ( name = "route" , required = false ) private List < RouteType > routes = new ArrayList < RouteType > ( ) ; @ XmlTransient private SpringCamelContext context ; @ XmlTransient private RouteBuilder routeBuilder ; @ XmlTransient private List < Routes > additionalBuilders = new ArrayList < Routes > ( ) ; @ XmlTransient private ApplicationContext applicationContext ; @ XmlTransient private ClassLoader contextClassLoaderOnStart ; @ XmlTransient private BeanPostProcessor beanPostProcessor ; public CamelContextFactoryBean ( ) { contextClassLoaderOnStart = Thread . currentThread ( ) . getContextClassLoader ( ) ; } public Object getObject ( ) throws Exception { return getContext ( ) ; } public Class getObjectType ( ) { return SpringCamelContext . class ; } public boolean isSingleton ( ) { return true ; } public ClassLoader getContextClassLoaderOnStart ( ) { return contextClassLoaderOnStart ; } public List < Routes > getAdditionalBuilders ( ) { return additionalBuilders ; } public void afterPropertiesSet ( ) throws Exception { Debugger debugger = getBeanForType ( Debugger . class ) ; if ( debugger != null ) { getContext ( ) . addInterceptStrategy ( debugger ) ; } Tracer tracer = getBeanForType ( Tracer . class ) ; if ( tracer != null ) { TraceFormatter formatter = getBeanForType ( TraceFormatter . class ) ; if ( formatter != null ) { tracer . setFormatter ( formatter ) ; } getContext ( ) . addInterceptStrategy ( tracer ) ; } Delayer delayer = getBeanForType ( Delayer . class ) ; if ( delayer != null ) { getContext ( ) . addInterceptStrategy ( delayer ) ; } LifecycleStrategy lifecycleStrategy = getBeanForType ( LifecycleStrategy . class ) ; if ( lifecycleStrategy != null ) { getContext ( ) . setLifecycleStrategy ( lifecycleStrategy ) ; } Registry registry = getBeanForType ( Registry . class ) ; if ( registry != null ) { getContext ( ) . setRegistry ( registry ) ; } if ( beanPostProcessor != null ) { if ( beanPostProcessor instanceof ApplicationContextAware ) { ( ( ApplicationContextAware ) beanPostProcessor ) . setApplicationContext ( applicationContext ) ; } if ( beanPostProcessor instanceof CamelBeanPostProcessor ) { ( ( CamelBeanPostProcessor ) beanPostProcessor ) . setCamelContext ( getContext ( ) ) ; } } for ( RouteType route : routes ) { for ( InterceptType intercept : intercepts ) { List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; List < ProcessorType < ? > > exceptionHandlers = new ArrayList < ProcessorType < ? > > ( ) ; for ( ProcessorType output : route . getOutputs ( ) ) { if ( output instanceof ExceptionType ) { exceptionHandlers . add ( output ) ; } else { outputs . add ( output ) ; } } route . clearOutput ( ) ; route . getOutputs ( ) . addAll ( exceptionHandlers ) ; InterceptType proxy = intercept . createProxy ( ) ; route . addOutput ( proxy ) ; route . pushBlock ( proxy . getProceed ( ) ) ; int outputsSize = proxy . getOutputs ( ) . size ( ) ; if ( outputsSize > 0 ) { ProcessorType processorType = proxy . getOutputs ( ) . get ( outputsSize - 1 ) ; if ( processorType instanceof ProceedType ) { route . getOutputs ( ) . addAll ( outputs ) ; } } } } if ( dataFormats != null ) { getContext ( ) . setDataFormats ( dataFormats . asMap ( ) ) ; } getContext ( ) . addRouteDefinitions ( routes ) ; if ( ! isJmxEnabled ( ) || ( camelJMXAgent != null && camelJMXAgent . isDisabled ( ) ) ) { LOG . debug ( "JMXAgent disabled" ) ; getContext ( ) . setLifecycleStrategy ( new DefaultLifecycleStrategy ( ) ) ; } else if ( camelJMXAgent != null ) { LOG . debug ( "JMXAgent enabled" ) ; if ( lifecycleStrategy != null ) { LOG . warn ( "lifecycleStrategy will be overriden by InstrumentationLifecycleStrategy" ) ; } DefaultInstrumentationAgent agent = new DefaultInstrumentationAgent ( ) ; agent . setConnectorPort ( camelJMXAgent . getConnectorPort ( ) ) ; agent . setCreateConnector ( camelJMXAgent . isCreateConnector ( ) ) ; agent . setMBeanObjectDomainName ( camelJMXAgent . getMbeanObjectDomainName ( ) ) ; agent . setMBeanServerDefaultDomain ( camelJMXAgent . getMbeanServerDefaultDomain ( ) ) ; agent . setRegistryPort ( camelJMXAgent . getRegistryPort ( ) ) ; agent . setServiceUrlPath ( camelJMXAgent . getServiceUrlPath ( ) ) ; agent . setUsePlatformMBeanServer ( camelJMXAgent . isUsePlatformMBeanServer ( ) ) ; getContext ( ) . setLifecycleStrategy ( new InstrumentationLifecycleStrategy ( agent ) ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found JAXB created routes: " + getRoutes ( ) ) ; } findRouteBuilders ( ) ; installRoutes ( ) ; } private < T > T getBeanForType ( Class < T > clazz ) { T bean = null ; String [ ] names = getApplicationContext ( ) . getBeanNamesForType ( clazz , true , true ) ; if ( names . length == 1 ) { bean = ( T ) getApplicationContext ( ) . getBean ( names [ 0 ] , clazz ) ; } if ( bean == null ) { ApplicationContext parentContext = getApplicationContext ( ) . getParent ( ) ; if ( parentContext != null ) { names = parentContext . getBeanNamesForType ( clazz , true , true ) ; if ( names . length == 1 ) { bean = ( T ) parentContext . getBean ( names [ 0 ] , clazz ) ; } } } return bean ; } public void destroy ( ) throws Exception { getContext ( ) . stop ( ) ; } public void onApplicationEvent ( ApplicationEvent event ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Publishing spring-event: " + event ) ; } if ( event instanceof ContextRefreshedEvent ) { try { LOG . debug ( "Starting the context now!" ) ; getContext ( ) . start ( ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } } public SpringCamelContext getContext ( ) throws Exception { if ( context == null ) { context = createContext ( ) ; } return context ; } public void setContext ( SpringCamelContext context ) { this . context = context ; } public List < RouteType > getRoutes ( ) { return routes ; } public void setRoutes ( List < RouteType > routes ) { this . routes = routes ; } public List < InterceptType > getIntercepts ( ) { return intercepts ; } public void setIntercepts ( List < InterceptType > intercepts ) { this . intercepts = intercepts ; } public RouteBuilder getRouteBuilder ( ) { return routeBuilder ; } public void setRouteBuilder ( RouteBuilder routeBuilder ) { this . routeBuilder = routeBuilder ; } public void setRouteBuilders ( RouteBuilder [ ] builders ) { for ( RouteBuilder builder : builders ) { additionalBuilders . add ( builder ) ; } } public ApplicationContext getApplicationContext ( ) { if ( applicationContext == null ) { throw new IllegalArgumentException ( "No applicationContext has been injected!" ) ; } return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public String [ ] getPackages ( ) { return packages ; } public void setPackages ( String [ ] packages ) { this . packages = packages ; } public void setBeanPostProcessor ( BeanPostProcessor postProcessor ) { this . beanPostProcessor = postProcessor ; } public BeanPostProcessor getBeanPostProcessor ( ) { return beanPostProcessor ; } public boolean isJmxEnabled ( ) { return useJmx . booleanValue ( ) ; } public Boolean getUseJmx ( ) { return useJmx ; } public void setUseJmx ( Boolean useJmx ) { this . useJmx = useJmx ; } public void setCamelJMXAgent ( CamelJMXAgentType agent ) { camelJMXAgent = agent ; } public Boolean getTrace ( ) { return trace ; } public void setTrace ( Boolean trace ) { this . trace = trace ; } public Long getDelay ( ) { return delay ; } public void setDelay ( Long delay ) { this . delay = delay ; } public CamelJMXAgentType getCamelJMXAgent ( ) { return camelJMXAgent ; } public List < RouteBuilderRef > getBuilderRefs ( ) { return builderRefs ; } public void setBuilderRefs ( List < RouteBuilderRef > builderRefs ) { this . builderRefs = builderRefs ; } public void setAutowireRouteBuilders ( Boolean autowireRouteBuilders ) { this . autowireRouteBuilders = autowireRouteBuilders ; } public String getErrorHandlerRef ( ) { return errorHandlerRef ; } public void setErrorHandlerRef ( String errorHandlerRef ) { this . errorHandlerRef = errorHandlerRef ; } public Boolean getShouldStartContext ( ) { return shouldStartContext ; } public void setShouldStartContext ( Boolean shouldStartContext ) { this . shouldStartContext = shouldStartContext ; } protected SpringCamelContext createContext ( ) { SpringCamelContext ctx = new SpringCamelContext ( getApplicationContext ( ) ) ; ctx . setName ( getId ( ) ) ; if ( trace != null ) { ctx . setTrace ( trace ) ; } if ( delay != null ) { ctx . setDelay ( delay ) ; } if ( errorHandlerRef != null ) { ErrorHandlerBuilder errorHandlerBuilder = ( ErrorHandlerBuilder ) getApplicationContext ( ) . getBean ( errorHandlerRef , ErrorHandlerBuilder . class ) ; if ( errorHandlerBuilder == null ) { throw new IllegalArgumentException ( "Could not find bean: " + errorHandlerRef ) ; } ctx . setErrorHandlerBuilder ( errorHandlerBuilder ) ; } if ( shouldStartContext != null ) { ctx . setShouldStartContext ( shouldStartContext ) ; } return ctx ; } protected void installRoutes ( ) throws Exception { if ( autowireRouteBuilders != null && autowireRouteBuilders . booleanValue ( ) ) { Map builders = getApplicationContext ( ) . getBeansOfType ( RouteBuilder . class , true , true ) ; if ( builders != null ) { for ( Object builder : builders . values ( ) ) { getContext ( ) . addRoutes ( ( RouteBuilder ) builder ) ; } } } for ( Routes routeBuilder : additionalBuilders ) { getContext ( ) . addRoutes ( routeBuilder ) ; } if ( routeBuilder != null ) { getContext ( ) . addRoutes ( routeBuilder ) ; } if ( builderRefs != null ) { for ( RouteBuilderRef builderRef : builderRefs ) { RouteBuilder builder = builderRef . createRouteBuilder ( getContext ( ) ) ; getContext ( ) . addRoutes ( builder ) ; } } } protected void findRouteBuilders ( ) throws Exception , InstantiationException { if ( getPackages ( ) != null && getPackages ( ) . length > 0 ) { RouteBuilderFinder finder = new RouteBuilderFinder ( getContext ( ) , getPackages ( ) , getContextClassLoaderOnStart ( ) , getBeanPostProcessor ( ) , createResolverUtil ( ) ) ; finder . appendBuilders ( getAdditionalBuilders ( ) ) ; } } protected ResolverUtil createResolverUtil ( ) { return new ResolverUtil ( ) ; } public void setDataFormats ( DataFormatsType dataFormats ) { this . dataFormats = dataFormats ; } public DataFormatsType getDataFormats ( ) { return dataFormats ; } } 	0	['48', '2', '1', '45', '124', '992', '2', '43', '42', '0.929078014', '824', '1', '4', '0.041666667', '0.093617021', '0', '0', '15.72916667', '6', '1.2292', '0']
package org . apache . camel . util ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Scanner ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . camel . RuntimeCamelException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class ObjectHelper { private static final transient Log LOG = LogFactory . getLog ( ObjectHelper . class ) ; private ObjectHelper ( ) { } @ Deprecated public static boolean equals ( Object a , Object b ) { return equal ( a , b ) ; } public static boolean equal ( Object a , Object b ) { if ( a == b ) { return true ; } if ( a instanceof byte [ ] && b instanceof byte [ ] ) { return equalByteArray ( ( byte [ ] ) a , ( byte [ ] ) b ) ; } return a != null && b != null && a . equals ( b ) ; } public static boolean equalByteArray ( byte [ ] a , byte [ ] b ) { if ( a == b ) { return true ; } if ( a != null && b != null && a . length == b . length ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != b [ i ] ) { return false ; } } return true ; } return false ; } public static boolean isEqualToAny ( Object object , Object ... values ) { for ( Object value : values ) { if ( equal ( object , value ) ) { return true ; } } return false ; } public static int compare ( Object a , Object b ) { if ( a == b ) { return 0 ; } if ( a == null ) { return - 1 ; } if ( b == null ) { return 1 ; } if ( a instanceof Comparable ) { Comparable comparable = ( Comparable ) a ; return comparable . compareTo ( b ) ; } else { int answer = a . getClass ( ) . getName ( ) . compareTo ( b . getClass ( ) . getName ( ) ) ; if ( answer == 0 ) { answer = a . hashCode ( ) - b . hashCode ( ) ; } return answer ; } } public static Boolean toBoolean ( Object value ) { if ( value instanceof Boolean ) { return ( Boolean ) value ; } if ( value instanceof String ) { return "true" . equalsIgnoreCase ( value . toString ( ) ) ? Boolean . TRUE : Boolean . FALSE ; } if ( value instanceof Integer ) { return ( Integer ) value > 0 ? Boolean . TRUE : Boolean . FALSE ; } return null ; } public static void notNull ( Object value , String name ) { if ( value == null ) { throw new IllegalArgumentException ( name + " must be specified" ) ; } } public static void notNull ( Object value , String name , Object on ) { if ( on == null ) { notNull ( value , name ) ; } else if ( value == null ) { throw new IllegalArgumentException ( name + " must be specified on: " + on ) ; } } public static void notEmpty ( String value , String name ) { if ( isEmpty ( value ) ) { throw new IllegalArgumentException ( name + " must be specified and not empty" ) ; } } public static void notEmpty ( String value , String name , Object on ) { if ( on == null ) { notNull ( value , name ) ; } else if ( isEmpty ( value ) ) { throw new IllegalArgumentException ( name + " must be specified and not empty on: " + on ) ; } } public static String [ ] splitOnCharacter ( String value , String needle , int count ) { String rc [ ] = new String [ count ] ; rc [ 0 ] = value ; for ( int i = 1 ; i < count ; i ++ ) { String v = rc [ i - 1 ] ; int p = v . indexOf ( needle ) ; if ( p < 0 ) { return rc ; } rc [ i - 1 ] = v . substring ( 0 , p ) ; rc [ i ] = v . substring ( p + 1 ) ; } return rc ; } public static String removeStartingCharacters ( String text , char ch ) { int idx = 0 ; while ( text . charAt ( idx ) == ch ) { idx ++ ; } if ( idx > 0 ) { return text . substring ( idx ) ; } return text ; } public static String capitalize ( String text ) { if ( text == null ) { return null ; } int length = text . length ( ) ; if ( length == 0 ) { return text ; } String answer = text . substring ( 0 , 1 ) . toUpperCase ( ) ; if ( length > 1 ) { answer += text . substring ( 1 , length ) ; } return answer ; } @ SuppressWarnings ( "unchecked" ) public static boolean contains ( Object collectionOrArray , Object value ) { if ( collectionOrArray instanceof Collection ) { Collection collection = ( Collection ) collectionOrArray ; return collection . contains ( value ) ; } else if ( collectionOrArray instanceof String && value instanceof String ) { String str = ( String ) collectionOrArray ; String subStr = ( String ) value ; return str . contains ( subStr ) ; } else { Iterator iter = createIterator ( collectionOrArray ) ; while ( iter . hasNext ( ) ) { if ( equal ( value , iter . next ( ) ) ) { return true ; } } } return false ; } @ SuppressWarnings ( "unchecked" ) public static Iterator createIterator ( Object value ) { if ( value == null ) { return Collections . EMPTY_LIST . iterator ( ) ; } else if ( value instanceof Iterator ) { return ( Iterator ) value ; } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . iterator ( ) ; } else if ( value . getClass ( ) . isArray ( ) ) { List < Object > list = Arrays . asList ( ( Object [ ] ) value ) ; return list . iterator ( ) ; } else if ( value instanceof NodeList ) { final NodeList nodeList = ( NodeList ) value ; return new Iterator < Node > ( ) { int idx = - 1 ; public boolean hasNext ( ) { return ++ idx < nodeList . getLength ( ) ; } public Node next ( ) { return nodeList . item ( idx ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } else if ( value instanceof String ) { Scanner scanner = new Scanner ( ( String ) value ) ; scanner . useDelimiter ( "," ) ; return scanner ; } else { return Collections . singletonList ( value ) . iterator ( ) ; } } public static boolean matches ( List list ) { if ( ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value instanceof Boolean ) { Boolean flag = ( Boolean ) value ; return flag . booleanValue ( ) ; } else { return true ; } } return false ; } public static boolean isNotNullAndNonEmpty ( String text ) { return isNotEmpty ( text ) ; } public static boolean isNullOrBlank ( String text ) { return isEmpty ( text ) ; } public static boolean isEmpty ( Object value ) { return ! isNotEmpty ( value ) ; } public static boolean isNotEmpty ( Object value ) { if ( value == null ) { return false ; } else if ( value instanceof String ) { String text = ( String ) value ; return text . trim ( ) . length ( ) > 0 ; } else { return true ; } } public static String getSystemProperty ( String name , String defaultValue ) { try { return System . getProperty ( name , defaultValue ) ; } catch ( Exception e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Caught security exception accessing system property: " + name + ". Reason: " + e , e ) ; } return defaultValue ; } } public static boolean getSystemProperty ( String name , Boolean defaultValue ) { String result = getSystemProperty ( name , defaultValue . toString ( ) ) ; return Boolean . parseBoolean ( result ) ; } public static String name ( Class type ) { return type != null ? type . getName ( ) : null ; } public static String className ( Object value ) { return name ( value != null ? value . getClass ( ) : null ) ; } public static String classCanonicalName ( Object value ) { if ( value != null ) { return value . getClass ( ) . getCanonicalName ( ) ; } else { return null ; } } public static Class < ? > loadClass ( String name ) { return loadClass ( name , ObjectHelper . class . getClassLoader ( ) ) ; } public static Class < ? > loadClass ( String name , ClassLoader loader ) { Class clazz = doLoadClass ( name , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; if ( clazz == null ) { clazz = doLoadClass ( name , loader ) ; } if ( clazz == null ) { clazz = doLoadClass ( name , ObjectHelper . class . getClassLoader ( ) ) ; } if ( clazz == null ) { LOG . warn ( "Could not find class: " + name ) ; } return clazz ; } private static Class < ? > doLoadClass ( String name , ClassLoader loader ) { ObjectHelper . notEmpty ( name , "name" ) ; if ( loader == null ) { return null ; } try { return loader . loadClass ( name ) ; } catch ( ClassNotFoundException e ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Can not load class: " + name + " using classloader: " + loader , e ) ; } } return null ; } public static InputStream loadResourceAsStream ( String name ) { InputStream in = null ; ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( contextClassLoader != null ) { in = contextClassLoader . getResourceAsStream ( name ) ; } if ( in == null ) { in = ObjectHelper . class . getClassLoader ( ) . getResourceAsStream ( name ) ; } return in ; } public static Object invokeMethod ( Method method , Object instance , Object ... parameters ) { try { return method . invoke ( instance , parameters ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } } public static List < Method > findMethodsWithAnnotation ( Class < ? > type , Class < ? extends Annotation > annotationType ) { return findMethodsWithAnnotation ( type , annotationType , false ) ; } public static List < Method > findMethodsWithAnnotation ( Class < ? > type , Class < ? extends Annotation > annotationType , boolean checkMetaAnnotations ) { List < Method > answer = new ArrayList < Method > ( ) ; do { Method [ ] methods = type . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( hasAnnotation ( method , annotationType , checkMetaAnnotations ) ) { answer . add ( method ) ; } } type = type . getSuperclass ( ) ; } while ( type != null ) ; return answer ; } public static boolean hasAnnotation ( AnnotatedElement elem , Class < ? extends Annotation > annotationType , boolean checkMetaAnnotations ) { if ( elem . isAnnotationPresent ( annotationType ) ) { return true ; } if ( checkMetaAnnotations ) { for ( Annotation a : elem . getAnnotations ( ) ) { for ( Annotation meta : a . annotationType ( ) . getAnnotations ( ) ) { if ( meta . annotationType ( ) . getName ( ) . equals ( annotationType . getName ( ) ) ) { return true ; } } } } return false ; } public static String asString ( Object [ ] objects ) { if ( objects == null ) { return "null" ; } else { StringBuffer buffer = new StringBuffer ( "{" ) ; int counter = 0 ; for ( Object object : objects ) { if ( counter ++ > 0 ) { buffer . append ( ", " ) ; } String text = ( object == null ) ? "null" : object . toString ( ) ; buffer . append ( text ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } } public static boolean isAssignableFrom ( Class a , Class b ) { a = convertPrimitiveTypeToWrapperType ( a ) ; b = convertPrimitiveTypeToWrapperType ( b ) ; return a . isAssignableFrom ( b ) ; } public static Class convertPrimitiveTypeToWrapperType ( Class type ) { Class rc = type ; if ( type . isPrimitive ( ) ) { if ( type == int . class ) { rc = Integer . class ; } else if ( type == long . class ) { rc = Long . class ; } else if ( type == double . class ) { rc = Double . class ; } else if ( type == float . class ) { rc = Float . class ; } else if ( type == short . class ) { rc = Short . class ; } else if ( type == byte . class ) { rc = Byte . class ; } } return rc ; } public static String getDefaultCharacterSet ( ) { return Charset . defaultCharset ( ) . name ( ) ; } public static String getPropertyName ( Method method ) { String propertyName = method . getName ( ) ; if ( propertyName . startsWith ( "set" ) && method . getParameterTypes ( ) . length == 1 ) { propertyName = propertyName . substring ( 3 , 4 ) . toLowerCase ( ) + propertyName . substring ( 4 ) ; } return propertyName ; } public static boolean hasAnnotation ( Annotation [ ] annotations , Class < ? > type ) { for ( Annotation annotation : annotations ) { if ( type . isInstance ( annotation ) ) { return true ; } } return false ; } public static void close ( Closeable closeable , String name , Log log ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IOException e ) { if ( log != null ) { log . warn ( "Could not close: " + name + ". Reason: " + e , e ) ; } } } } public static < T > T cast ( Class < T > toType , Object value ) { if ( toType == boolean . class ) { return ( T ) cast ( Boolean . class , value ) ; } else if ( toType . isPrimitive ( ) ) { Class newType = convertPrimitiveTypeToWrapperType ( toType ) ; if ( newType != toType ) { return ( T ) cast ( newType , value ) ; } } try { return toType . cast ( value ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( "Failed to convert: " + value + " to type: " + toType . getName ( ) + " due to: " + e , e ) ; } } public static < T > T newInstance ( Class < T > type ) { try { return type . newInstance ( ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } } public static < T > T newInstance ( Class < ? > actualType , Class < T > expectedType ) { try { Object value = actualType . newInstance ( ) ; return cast ( expectedType , value ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } } public static boolean isJavaIdentifier ( String name ) { if ( name == null ) { return false ; } int size = name . length ( ) ; if ( size < 1 ) { return false ; } if ( Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { for ( int i = 1 ; i < size ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { return false ; } } return true ; } return false ; } public static Object type ( Object bean ) { return bean != null ? bean . getClass ( ) : null ; } public static boolean evaluateValuePredicate ( Object value ) { if ( value instanceof Boolean ) { Boolean aBoolean = ( Boolean ) value ; return aBoolean . booleanValue ( ) ; } else if ( value instanceof String ) { if ( "true" . equals ( value ) ) { return true ; } else if ( "false" . equals ( value ) ) { return false ; } } return value != null ; } public static RuntimeCamelException wrapRuntimeCamelException ( Throwable e ) { if ( e instanceof RuntimeCamelException ) { return ( RuntimeCamelException ) e ; } else { return new RuntimeCamelException ( e ) ; } } } 	1	['49', '1', '0', '157', '133', '1164', '153', '4', '46', '0.895833333', '1163', '1', '0', '0', '0.075231481', '0', '0', '22.71428571', '8', '3.102', '4']
package org . apache . camel . dataformat . csv ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . csv . CSVParser ; import org . apache . commons . csv . CSVStrategy ; import org . apache . commons . csv . writer . CSVConfig ; import org . apache . commons . csv . writer . CSVField ; import org . apache . commons . csv . writer . CSVWriter ; public class CsvDataFormat implements DataFormat { private CSVStrategy strategy = CSVStrategy . DEFAULT_STRATEGY ; private CSVConfig config = new CSVConfig ( ) ; public void marshal ( Exchange exchange , Object object , OutputStream outputStream ) throws Exception { Map map = ExchangeHelper . convertToMandatoryType ( exchange , Map . class , object ) ; OutputStreamWriter out = new OutputStreamWriter ( outputStream ) ; try { CSVConfig conf = getConfig ( ) ; Set set = map . keySet ( ) ; for ( Object value : set ) { if ( value != null ) { String text = value . toString ( ) ; CSVField field = new CSVField ( text ) ; conf . addField ( field ) ; } } CSVWriter writer = new CSVWriter ( conf ) ; writer . setWriter ( out ) ; writer . writeRecord ( map ) ; } finally { out . close ( ) ; } } public Object unmarshal ( Exchange exchange , InputStream inputStream ) throws Exception { InputStreamReader in = new InputStreamReader ( inputStream ) ; try { CSVParser parser = new CSVParser ( in , getStrategy ( ) ) ; List < List < String > > list = new ArrayList < List < String > > ( ) ; while ( true ) { String [ ] strings = parser . getLine ( ) ; if ( strings == null ) { break ; } List < String > line = Arrays . asList ( strings ) ; list . add ( line ) ; } if ( list . size ( ) == 1 ) { return list . get ( 0 ) ; } else { return list ; } } finally { in . close ( ) ; } } public CSVConfig getConfig ( ) { if ( config == null ) { config = createConfig ( ) ; } return config ; } public void setConfig ( CSVConfig config ) { this . config = config ; } public CSVStrategy getStrategy ( ) { return strategy ; } public void setStrategy ( CSVStrategy strategy ) { this . strategy = strategy ; } protected CSVConfig createConfig ( ) { return new CSVConfig ( ) ; } } 	0	['8', '1', '0', '8', '32', '16', '0', '8', '7', '0.571428571', '159', '1', '0', '0', '0.267857143', '0', '0', '18.625', '2', '1', '0']
package org . apache . camel . impl ; import java . util . HashSet ; import java . util . Set ; import java . util . regex . Pattern ; import org . apache . camel . spi . HeaderFilterStrategy ; public class DefaultHeaderFilterStrategy implements HeaderFilterStrategy { protected enum Direction { IN , OUT } private Set < String > inFilter ; private Pattern inFilterPattern ; private Set < String > outFilter ; private Pattern outFilterPattern ; private boolean isLowercase ; private boolean allowNullValues ; public boolean applyFilterToCamelHeaders ( String headerName , Object headerValue ) { return doFiltering ( Direction . OUT , headerName , headerValue ) ; } public boolean applyFilterToExternalHeaders ( String headerName , Object headerValue ) { return doFiltering ( Direction . IN , headerName , headerValue ) ; } public Set < String > getOutFilter ( ) { if ( outFilter == null ) { outFilter = new HashSet < String > ( ) ; } return outFilter ; } public void setOutFilter ( Set < String > value ) { outFilter = value ; } public String getOutFilterPattern ( ) { return outFilterPattern == null ? null : outFilterPattern . pattern ( ) ; } public void setOutFilterPattern ( String value ) { if ( value == null ) { outFilterPattern = null ; } else { outFilterPattern = Pattern . compile ( value ) ; } } public Set < String > getInFilter ( ) { if ( inFilter == null ) { inFilter = new HashSet < String > ( ) ; } return inFilter ; } public void setInFilter ( Set < String > value ) { inFilter = value ; } public String getInFilterPattern ( ) { return inFilterPattern == null ? null : inFilterPattern . pattern ( ) ; } public void setInFilterPattern ( String value ) { if ( value == null ) { inFilterPattern = null ; } else { inFilterPattern = Pattern . compile ( value ) ; } } public boolean getIsLowercase ( ) { return isLowercase ; } public void setIsLowercase ( boolean value ) { isLowercase = value ; } public boolean getAllowNullValues ( ) { return allowNullValues ; } public void setAllowNullValues ( boolean value ) { allowNullValues = value ; } protected boolean extendedFilter ( Direction direction , String key , Object value ) { return false ; } private boolean doFiltering ( Direction direction , String headerName , Object headerValue ) { if ( headerName == null ) { return true ; } if ( headerValue == null && ! allowNullValues ) { return true ; } Pattern pattern = null ; Set < String > filter = null ; if ( Direction . OUT == direction ) { pattern = outFilterPattern ; filter = outFilter ; } else if ( Direction . IN == direction ) { pattern = inFilterPattern ; filter = inFilter ; } if ( pattern != null && pattern . matcher ( headerName ) . matches ( ) ) { return true ; } if ( filter != null ) { if ( isLowercase ) { if ( filter . contains ( headerName . toLowerCase ( ) ) ) { return true ; } } else { if ( filter . contains ( headerName ) ) { return true ; } } } if ( extendedFilter ( direction , headerName , headerValue ) ) { return true ; } return false ; } } 	1	['17', '1', '5', '13', '25', '100', '11', '2', '15', '0.75', '195', '1', '0', '0', '0.323529412', '0', '0', '10.11764706', '13', '2', '2']
package org . apache . camel . component . jms . requestor ; import java . math . BigInteger ; import java . util . Random ; import java . util . concurrent . ScheduledExecutorService ; import javax . jms . Destination ; import javax . jms . ExceptionListener ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . Session ; import org . apache . camel . component . jms . JmsConfiguration ; import org . apache . camel . component . jms . requestor . DeferredRequestReplyMap . DeferredMessageSentCallback ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer102 ; import org . springframework . jms . support . destination . DestinationResolver ; import org . springframework . transaction . PlatformTransactionManager ; public class PersistentReplyToRequestor extends Requestor { private String replyToSelectorValue ; public class DestinationResolverDelegate implements DestinationResolver { private DestinationResolver delegate ; private Destination destination ; public DestinationResolverDelegate ( DestinationResolver delegate ) { this . delegate = delegate ; } public Destination resolveDestinationName ( Session session , String destinationName , boolean pubSubDomain ) throws JMSException { synchronized ( getOutterInstance ( ) ) { try { if ( destination == null ) { destination = delegate . resolveDestinationName ( session , destinationName , pubSubDomain ) ; setReplyTo ( destination ) ; } } finally { getOutterInstance ( ) . notifyAll ( ) ; } } return destination ; } } ; public static interface MessageSelectorComposer { void addCorrelationID ( String id ) ; void removeCorrelationID ( String id ) ; } public static class CamelDefaultMessageListenerContainer102 extends DefaultMessageListenerContainer102 implements MessageSelectorComposer { MessageSelectorProvider provider = new MessageSelectorProvider ( ) ; public void addCorrelationID ( String id ) { provider . addCorrelationID ( id ) ; } public void removeCorrelationID ( String id ) { provider . removeCorrelationID ( id ) ; } @ Override public void setMessageSelector ( String messageSelector ) { throw new UnsupportedOperationException ( ) ; } @ Override public String getMessageSelector ( ) { return provider . get ( ) ; } } public static class CamelDefaultMessageListenerContainer extends DefaultMessageListenerContainer implements MessageSelectorComposer { MessageSelectorProvider provider = new MessageSelectorProvider ( ) ; public void addCorrelationID ( String id ) { provider . addCorrelationID ( id ) ; } public void removeCorrelationID ( String id ) { provider . removeCorrelationID ( id ) ; } @ Override public void setMessageSelector ( String messageSelector ) { throw new UnsupportedOperationException ( ) ; } @ Override public String getMessageSelector ( ) { return provider . get ( ) ; } } public PersistentReplyToRequestor ( JmsConfiguration configuration , ScheduledExecutorService executorService ) { super ( configuration , executorService ) ; } @ Override protected FutureHandler createFutureHandler ( String correlationID ) { boolean dynamicSelector = getConfiguration ( ) . getReplyToDestinationSelectorName ( ) == null ; if ( dynamicSelector ) { return new PersistentReplyToFutureHandler ( this , correlationID ) ; } return new FutureHandler ( ) ; } @ Override protected FutureHandler createFutureHandler ( DeferredMessageSentCallback callback ) { boolean dynamicSelector = getConfiguration ( ) . getReplyToDestinationSelectorName ( ) == null ; if ( dynamicSelector ) { return new PersistentReplyToFutureHandler ( this , callback ) ; } return new FutureHandler ( ) ; } @ Override public AbstractMessageListenerContainer createListenerContainer ( ) { JmsConfiguration config = getConfiguration ( ) ; String replyToSelectorName = getConfiguration ( ) . getReplyToDestinationSelectorName ( ) ; AbstractMessageListenerContainer container = config . isUseVersion102 ( ) ? ( replyToSelectorName != null ) ? new DefaultMessageListenerContainer102 ( ) : new CamelDefaultMessageListenerContainer102 ( ) : ( replyToSelectorName != null ) ? new DefaultMessageListenerContainer ( ) : new CamelDefaultMessageListenerContainer ( ) ; container . setConnectionFactory ( config . getListenerConnectionFactory ( ) ) ; DestinationResolver resolver = config . getDestinationResolver ( ) ; if ( resolver == null ) { resolver = container . getDestinationResolver ( ) ; } container . setDestinationResolver ( new DestinationResolverDelegate ( resolver ) ) ; container . setDestinationName ( getConfiguration ( ) . getReplyTo ( ) ) ; if ( replyToSelectorName != null ) { replyToSelectorValue = "ID:" + new BigInteger ( 24 * 8 , new Random ( ) ) . toString ( 16 ) ; container . setMessageSelector ( replyToSelectorName + "='" + replyToSelectorValue + "'" ) ; } else { ( ( MessageSelectorComposer ) container ) . addCorrelationID ( "ID:" + new BigInteger ( 24 * 8 , new Random ( ) ) . toString ( 16 ) ) ; } container . setAutoStartup ( true ) ; container . setMessageListener ( this ) ; container . setPubSubDomain ( false ) ; container . setSubscriptionDurable ( false ) ; ExceptionListener exceptionListener = config . getExceptionListener ( ) ; if ( exceptionListener != null ) { container . setExceptionListener ( exceptionListener ) ; } container . setSessionTransacted ( config . isTransacted ( ) ) ; if ( config . isTransacted ( ) ) { container . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( config . getAcknowledgementMode ( ) >= 0 ) { container . setSessionAcknowledgeMode ( config . getAcknowledgementMode ( ) ) ; } else if ( config . getAcknowledgementModeName ( ) != null ) { container . setSessionAcknowledgeModeName ( config . getAcknowledgementModeName ( ) ) ; } } if ( container instanceof DefaultMessageListenerContainer ) { DefaultMessageListenerContainer defContainer = ( DefaultMessageListenerContainer ) container ; defContainer . setConcurrentConsumers ( 1 ) ; defContainer . setCacheLevel ( DefaultMessageListenerContainer . CACHE_SESSION ) ; if ( config . getReceiveTimeout ( ) >= 0 ) { defContainer . setReceiveTimeout ( config . getReceiveTimeout ( ) ) ; } if ( config . getRecoveryInterval ( ) >= 0 ) { defContainer . setRecoveryInterval ( config . getRecoveryInterval ( ) ) ; } TaskExecutor taskExecutor = config . getTaskExecutor ( ) ; if ( taskExecutor != null ) { defContainer . setTaskExecutor ( taskExecutor ) ; } PlatformTransactionManager tm = config . getTransactionManager ( ) ; if ( tm != null ) { defContainer . setTransactionManager ( tm ) ; } else if ( config . isTransacted ( ) ) { throw new IllegalArgumentException ( "Property transacted is enabled but a transactionManager was not injected!" ) ; } if ( config . getTransactionName ( ) != null ) { defContainer . setTransactionName ( config . getTransactionName ( ) ) ; } if ( config . getTransactionTimeout ( ) >= 0 ) { defContainer . setTransactionTimeout ( config . getTransactionTimeout ( ) ) ; } } return container ; } @ Override public void setReplyToSelectorHeader ( org . apache . camel . Message in , Message jmsIn ) throws JMSException { String replyToSelectorName = getConfiguration ( ) . getReplyToDestinationSelectorName ( ) ; if ( replyToSelectorValue != null ) { in . setHeader ( replyToSelectorName , replyToSelectorValue ) ; jmsIn . setStringProperty ( replyToSelectorName , replyToSelectorValue ) ; } } } 	0	['5', '3', '0', '17', '61', '8', '3', '16', '3', '0.75', '295', '1', '0', '0.9', '0.314285714', '1', '1', '57.8', '18', '5', '0']
package org . apache . camel . processor . validation ; import javax . xml . transform . dom . DOMResult ; import javax . xml . validation . Schema ; import org . xml . sax . ErrorHandler ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; public interface ValidatorErrorHandler extends ErrorHandler { void reset ( ) ; void handleErrors ( Exchange exchange , Schema schema , DOMResult result ) throws ValidationException ; } 	1	['2', '1', '0', '4', '2', '1', '2', '2', '2', '2', '2', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '1']
package org . apache . camel ; public class RuntimeTransformException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; public RuntimeTransformException ( String message ) { super ( message ) ; } public RuntimeTransformException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeTransformException ( Throwable cause ) { super ( cause ) ; } } 	0	['3', '5', '0', '3', '6', '3', '2', '1', '3', '1.5', '17', '1', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . camel . processor . idempotent ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ExpressionHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class IdempotentConsumer extends ServiceSupport implements Processor { private static final transient Log LOG = LogFactory . getLog ( IdempotentConsumer . class ) ; private Expression < Exchange > messageIdExpression ; private Processor nextProcessor ; private MessageIdRepository messageIdRepository ; public IdempotentConsumer ( Expression < Exchange > messageIdExpression , MessageIdRepository messageIdRepository , Processor nextProcessor ) { this . messageIdExpression = messageIdExpression ; this . messageIdRepository = messageIdRepository ; this . nextProcessor = nextProcessor ; } @ Override public String toString ( ) { return "IdempotentConsumer[expression=" + messageIdExpression + ", repository=" + messageIdRepository + ", processor=" + nextProcessor + "]" ; } public void process ( Exchange exchange ) throws Exception { String messageId = ExpressionHelper . evaluateAsString ( messageIdExpression , exchange ) ; if ( messageId == null ) { throw new NoMessageIdException ( exchange , messageIdExpression ) ; } if ( ! messageIdRepository . contains ( messageId ) ) { nextProcessor . process ( exchange ) ; } else { onDuplicateMessage ( exchange , messageId ) ; } } public Expression < Exchange > getMessageIdExpression ( ) { return messageIdExpression ; } public MessageIdRepository getMessageIdRepository ( ) { return messageIdRepository ; } public Processor getNextProcessor ( ) { return nextProcessor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( nextProcessor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( nextProcessor ) ; } protected void onDuplicateMessage ( Exchange exchange , String messageId ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Ignoring duplicate message with id: " + messageId + " for exchange: " + exchange ) ; } } } 	1	['10', '2', '0', '11', '24', '1', '1', '10', '6', '0.638888889', '126', '1', '3', '0.636363636', '0.277777778', '1', '1', '11.2', '2', '0.9', '2']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; public class ProxyInstantiationException extends RuntimeException { private final Class < ? > type ; private final Endpoint endpoint ; public ProxyInstantiationException ( Class < ? > type , Endpoint endpoint , Throwable cause ) { super ( "Could not instantiate proxy of type " + type . getName ( ) + " on endpoint " + endpoint , cause ) ; this . type = type ; this . endpoint = endpoint ; } public Class < ? > getType ( ) { return type ; } public Endpoint getEndpoint ( ) { return endpoint ; } } 	0	['3', '4', '0', '2', '9', '0', '1', '1', '3', '0.5', '34', '1', '1', '0.894736842', '0.5', '0', '0', '9.666666667', '1', '0.6667', '0']
package org . apache . camel . impl ; import java . net . URI ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . ThreadFactory ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . URISupport ; import org . apache . camel . util . UnsafeUriCharactersEncoder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class DefaultComponent < E extends Exchange > extends ServiceSupport implements Component < E > { private static final transient Log LOG = LogFactory . getLog ( DefaultComponent . class ) ; private int defaultThreadPoolSize = 5 ; private CamelContext camelContext ; private ScheduledExecutorService executorService ; public DefaultComponent ( ) { } public DefaultComponent ( CamelContext context ) { this . camelContext = context ; } public Endpoint < E > createEndpoint ( String uri ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; URI u = new URI ( UnsafeUriCharactersEncoder . encode ( uri ) ) ; String path = u . getSchemeSpecificPart ( ) ; if ( path . startsWith ( "//" ) ) { path = path . substring ( 2 ) ; } int idx = path . indexOf ( '?' ) ; if ( idx > 0 ) { path = path . substring ( 0 , idx ) ; } Map parameters = URISupport . parseParameters ( u ) ; validateURI ( uri , path , parameters ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Creating endpoint uri=[" + uri + "], path=[" + path + "], parameters=[" + parameters + "]" ) ; } Endpoint < E > endpoint = createEndpoint ( uri , path , parameters ) ; if ( endpoint == null ) { return null ; } if ( parameters != null ) { endpoint . configureProperties ( parameters ) ; if ( useIntrospectionOnEndpoint ( ) ) { setProperties ( endpoint , parameters ) ; } if ( ! endpoint . isLenientProperties ( ) && parameters . size ( ) > 0 ) { throw new ResolveEndpointFailedException ( uri , "There are " + parameters . size ( ) + " parameters that couldn't be set on the endpoint." + " Check the uri if the parameters are spelt correctly and that they are properties of the endpoint." + " Unknown parameters=[" + parameters + "]" ) ; } } return endpoint ; } protected void validateURI ( String uri , String path , Map parameters ) throws ResolveEndpointFailedException { if ( uri . contains ( "&" ) && ! uri . contains ( "?" ) ) { throw new ResolveEndpointFailedException ( uri , "Invalid uri syntax: no ? marker however the uri " + "has & parameter separators. Check the uri if its missing a ? marker." ) ; } if ( uri . contains ( "&&" ) ) { throw new ResolveEndpointFailedException ( uri , "Invalid uri syntax: Double && marker found. " + "Check the uri and remove the duplicate & marker." ) ; } } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext context ) { this . camelContext = context ; } public ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { executorService = createExecutorService ( ) ; } return executorService ; } public void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } protected ScheduledExecutorService createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( defaultThreadPoolSize , new ThreadFactory ( ) { int counter ; public synchronized Thread newThread ( Runnable runnable ) { Thread thread = new Thread ( runnable ) ; thread . setName ( "Thread: " + ( ++ counter ) + " " + DefaultComponent . this . toString ( ) ) ; return thread ; } } ) ; } protected void doStart ( ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; } protected void doStop ( ) throws Exception { if ( executorService != null ) { executorService . shutdown ( ) ; } } protected abstract Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception ; protected void setProperties ( Object bean , Map parameters ) throws Exception { IntrospectionSupport . setProperties ( getCamelContext ( ) . getTypeConverter ( ) , bean , parameters ) ; } protected boolean useIntrospectionOnEndpoint ( ) { return true ; } public < T > T convertTo ( Class < T > type , Object value ) { return CamelContextHelper . convertTo ( getCamelContext ( ) , type , value ) ; } public < T > T mandatoryConvertTo ( Class < T > type , Object value ) { return CamelContextHelper . mandatoryConvertTo ( getCamelContext ( ) , type , value ) ; } public < T > T newInstance ( Class < T > beanType ) { return getCamelContext ( ) . getInjector ( ) . newInstance ( beanType ) ; } public Object lookup ( String name ) { return getCamelContext ( ) . getRegistry ( ) . lookup ( name ) ; } public < T > T lookup ( String name , Class < T > beanType ) { return getCamelContext ( ) . getRegistry ( ) . lookup ( name , beanType ) ; } public Object mandatoryLookup ( String name ) { return CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , name ) ; } public < T > T mandatoryLookup ( String name , Class < T > beanType ) { return CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , name , beanType ) ; } public < T > T getAndRemoveParameter ( Map parameters , String key , Class < T > type ) { return getAndRemoveParameter ( parameters , key , type , null ) ; } public < T > T getAndRemoveParameter ( Map parameters , String key , Class < T > type , T defaultValue ) { Object value = parameters . remove ( key ) ; if ( value == null ) { value = defaultValue ; } if ( value == null ) { return null ; } return convertTo ( type , value ) ; } } 	1	['24', '2', '39', '56', '62', '256', '41', '16', '16', '0.793478261', '308', '1', '1', '0.4', '0.316770186', '1', '1', '11.66666667', '3', '1', '3']
package org . apache . camel . component . freemarker ; import java . util . Map ; import freemarker . cache . ClassTemplateLoader ; import freemarker . template . Configuration ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . springframework . core . io . Resource ; public class FreemarkerComponent extends DefaultComponent { private Configuration configuraiton ; private Configuration noCacheConfiguration ; protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { FreemarkerEndpoint endpoint = new FreemarkerEndpoint ( uri , this , remaining , parameters ) ; Configuration config ; boolean cache = ( Boolean ) getAndRemoveParameter ( parameters , "contentCache" , Boolean . class , Boolean . TRUE ) ; if ( cache ) { config = getConfiguraiton ( ) ; } else { config = getNoCacheConfiguration ( ) ; } endpoint . setConfiguration ( config ) ; return endpoint ; } public synchronized Configuration getConfiguraiton ( ) { if ( configuraiton == null ) { configuraiton = new Configuration ( ) ; configuraiton . setTemplateLoader ( new ClassTemplateLoader ( Resource . class , "/" ) ) ; } return ( Configuration ) configuraiton . clone ( ) ; } public void setConfiguraiton ( Configuration configuraiton ) { this . configuraiton = configuraiton ; } private synchronized Configuration getNoCacheConfiguration ( ) { if ( noCacheConfiguration == null ) { noCacheConfiguration = ( Configuration ) getConfiguraiton ( ) . clone ( ) ; noCacheConfiguration . setCacheStorage ( new NoCacheStorage ( ) ) ; } return noCacheConfiguration ; } } 	0	['5', '3', '0', '9', '16', '8', '0', '9', '3', '0.5', '84', '1', '0', '0.897435897', '0.4', '1', '2', '15.4', '2', '1.2', '0']
package org . apache . camel . builder ; import org . apache . camel . Processor ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingErrorHandler ; import org . apache . camel . spi . RouteContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingErrorHandlerBuilder extends ErrorHandlerBuilderSupport { private Log log = LogFactory . getLog ( Logger . class ) ; private LoggingLevel level = LoggingLevel . ERROR ; public LoggingErrorHandlerBuilder ( ) { } public LoggingErrorHandlerBuilder ( final Log log ) { this . log = log ; } public LoggingErrorHandlerBuilder ( final Log log , final LoggingLevel level ) { this . log = log ; this . level = level ; } public ErrorHandlerBuilder copy ( ) { LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder ( ) ; answer . setLog ( getLog ( ) ) ; answer . setLevel ( getLevel ( ) ) ; return answer ; } public Processor createErrorHandler ( final RouteContext routeContext , final Processor processor ) { LoggingErrorHandler handler = new LoggingErrorHandler ( processor , log , level ) ; configure ( handler ) ; return handler ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( final LoggingLevel level ) { this . level = level ; } public Log getLog ( ) { return log ; } public void setLog ( final Log log ) { this . log = log ; } public LoggingErrorHandlerBuilder level ( final LoggingLevel level ) { this . level = level ; return this ; } public LoggingErrorHandlerBuilder log ( final Log log ) { this . log = log ; return this ; } } 	1	['11', '2', '0', '10', '15', '0', '1', '9', '11', '0.3', '104', '1', '1', '0.333333333', '0.363636364', '0', '0', '8.272727273', '1', '0.7273', '1']
package org . apache . camel . component . irc ; import org . apache . commons . logging . Log ; import org . schwering . irc . lib . IRCEventAdapter ; import org . schwering . irc . lib . IRCModeParser ; import org . schwering . irc . lib . IRCUser ; public class IrcErrorLogger extends IRCEventAdapter { private Log log ; public IrcErrorLogger ( Log log ) { this . log = log ; } @ Override public void onRegistered ( ) { super . onRegistered ( ) ; log . info ( "onRegistered" ) ; } @ Override public void onDisconnected ( ) { super . onDisconnected ( ) ; log . info ( "onDisconnected" ) ; } @ Override public void onMode ( String string , IRCUser ircUser , IRCModeParser ircModeParser ) { super . onMode ( string , ircUser , ircModeParser ) ; log . info ( "onMode.string = " + string ) ; log . info ( "onMode.ircUser = " + ircUser ) ; log . info ( "onMode.ircModeParser = " + ircModeParser ) ; } @ Override public void onMode ( IRCUser ircUser , String string , String string1 ) { super . onMode ( ircUser , string , string1 ) ; log . info ( "onMode.ircUser = " + ircUser ) ; log . info ( "onMode.string = " + string ) ; log . info ( "onMode.string1 = " + string1 ) ; } @ Override public void onPing ( String string ) { super . onPing ( string ) ; log . info ( "onPing.string = " + string ) ; } @ Override public void onError ( String string ) { log . info ( "onError.string = " + string ) ; } @ Override public void onError ( int i , String string ) { super . onError ( i , string ) ; log . error ( "onError.i = " + i ) ; log . error ( "onError.string = " + string ) ; } @ Override public void unknown ( String string , String string1 , String string2 , String string3 ) { super . unknown ( string , string1 , string2 , string3 ) ; log . error ( "unknown.string = " + string ) ; log . error ( "unknown.string1 = " + string1 ) ; log . error ( "unknown.string2 = " + string2 ) ; log . error ( "unknown.string3 = " + string3 ) ; } } 	0	['9', '0', '0', '5', '24', '0', '1', '4', '9', '0', '213', '1', '0', '0', '0.37037037', '0', '0', '22.55555556', '1', '0.8889', '0']
package org . apache . camel . management ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class InstrumentationProcessor extends DelegateProcessor implements AsyncProcessor { private static final transient Log LOG = LogFactory . getLog ( InstrumentationProcessor . class ) ; private PerformanceCounter counter ; public InstrumentationProcessor ( PerformanceCounter counter ) { this . counter = counter ; } public InstrumentationProcessor ( ) { } @ Override public String toString ( ) { return "Instrumentation(" + processor + ")" ; } public void setCounter ( PerformanceCounter counter ) { this . counter = counter ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( processor == null ) { callback . done ( true ) ; return true ; } final long startTime = System . nanoTime ( ) ; if ( processor instanceof AsyncProcessor ) { return ( ( AsyncProcessor ) processor ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { if ( counter != null ) { recordTime ( exchange , ( System . nanoTime ( ) - startTime ) / 1000000.0 ) ; } callback . done ( doneSynchronously ) ; } } ) ; } try { processor . process ( exchange ) ; } catch ( Throwable e ) { exchange . setException ( e ) ; } if ( counter != null ) { recordTime ( exchange , ( System . nanoTime ( ) - startTime ) / 1000000.0 ) ; } callback . done ( true ) ; return true ; } protected void recordTime ( Exchange exchange , double duration ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Recording duration: " + duration + " millis for exchange: " + exchange ) ; } if ( ! exchange . isFailed ( ) && exchange . getException ( ) == null ) { counter . completedExchange ( duration ) ; } else { counter . failedExchange ( ) ; } } } 	1	['9', '3', '0', '12', '29', '12', '3', '10', '6', '0.625', '132', '1', '1', '0.785714286', '0.3125', '0', '0', '13.44444444', '4', '1.3333', '2']
package org . apache . camel . component . cxf . transport ; import java . io . IOException ; import java . io . OutputStream ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . camel . component . cxf . CxfSoapBinding ; import org . apache . camel . component . cxf . util . CxfHeaderHelper ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public class CamelConduit extends AbstractConduit implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-conduit" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelConduit . class ) ; private CamelContext camelContext ; private EndpointInfo endpointInfo ; private String targetCamelEndpointUri ; private ProducerTemplate < Exchange > camelTemplate ; private Bus bus ; private HeaderFilterStrategy headerFilterStrategy ; public CamelConduit ( CamelContext context , Bus b , EndpointInfo endpointInfo ) { this ( context , b , endpointInfo , null ) ; } public CamelConduit ( CamelContext context , Bus b , EndpointInfo epInfo , EndpointReferenceType targetReference ) { this ( context , b , epInfo , targetReference , null ) ; } public CamelConduit ( CamelContext context , Bus b , EndpointInfo epInfo , EndpointReferenceType targetReference , HeaderFilterStrategy headerFilterStrategy ) { super ( getTargetReference ( epInfo , targetReference , b ) ) ; String address = epInfo . getAddress ( ) ; if ( address != null ) { targetCamelEndpointUri = address . substring ( CxfConstants . CAMEL_TRANSPORT_PREFIX . length ( ) ) ; if ( targetCamelEndpointUri . startsWith ( "//" ) ) { targetCamelEndpointUri = targetCamelEndpointUri . substring ( 2 ) ; } } camelContext = context ; endpointInfo = epInfo ; bus = b ; initConfig ( ) ; this . headerFilterStrategy = headerFilterStrategy ; } public void setCamelContext ( CamelContext context ) { camelContext = context ; } public CamelContext getCamelContext ( ) { if ( camelContext == null ) { getLogger ( ) . log ( Level . INFO , "No CamelContext injected, create a default one" ) ; camelContext = new DefaultCamelContext ( ) ; } return camelContext ; } public void prepare ( Message message ) throws IOException { getLogger ( ) . log ( Level . FINE , "CamelConduit send message" ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( message ) ) ; } public void close ( ) { getLogger ( ) . log ( Level . FINE , "CamelConduit closed " ) ; } protected Logger getLogger ( ) { return LOG ; } public String getBeanName ( ) { if ( endpointInfo == null || endpointInfo . getName ( ) == null ) { return "default" + BASE_BEAN_NAME_SUFFIX ; } return endpointInfo . getName ( ) . toString ( ) + BASE_BEAN_NAME_SUFFIX ; } private void initConfig ( ) { if ( bus != null ) { Configurer configurer = bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( this ) ; } } } public ProducerTemplate < Exchange > getCamelTemplate ( ) { if ( camelTemplate == null ) { camelTemplate = getCamelContext ( ) . createProducerTemplate ( ) ; } return camelTemplate ; } public void setCamelTemplate ( ProducerTemplate < Exchange > template ) { camelTemplate = template ; } private class CamelOutputStream extends CachedOutputStream { private Message outMessage ; private boolean isOneWay ; public CamelOutputStream ( Message m ) { outMessage = m ; } protected void doFlush ( ) throws IOException { } protected void doClose ( ) throws IOException { isOneWay = outMessage . getExchange ( ) . isOneWay ( ) ; commitOutputMessage ( ) ; } protected void onWrite ( ) throws IOException { } private void commitOutputMessage ( ) { ExchangePattern pattern ; if ( isOneWay ) { pattern = ExchangePattern . InOnly ; } else { pattern = ExchangePattern . InOut ; } getLogger ( ) . log ( Level . FINE , "send the message to endpoint" + targetCamelEndpointUri ) ; org . apache . camel . Exchange exchange = getCamelTemplate ( ) . send ( targetCamelEndpointUri , pattern , new Processor ( ) { public void process ( org . apache . camel . Exchange ex ) throws IOException { CachedOutputStream outputStream = ( CachedOutputStream ) outMessage . getContent ( OutputStream . class ) ; CxfHeaderHelper . propagateCxfToCamel ( headerFilterStrategy , outMessage , ex . getIn ( ) . getHeaders ( ) ) ; ex . getIn ( ) . setBody ( outputStream . getBytes ( ) ) ; getLogger ( ) . log ( Level . FINE , "template sending request: " , ex . getIn ( ) ) ; } } ) ; exchange . setProperty ( CxfConstants . CXF_EXCHANGE , outMessage . getExchange ( ) ) ; if ( ! isOneWay ) { handleResponse ( exchange ) ; } } private void handleResponse ( org . apache . camel . Exchange exchange ) { org . apache . cxf . message . Message inMessage = CxfSoapBinding . getCxfInMessage ( headerFilterStrategy , exchange , true ) ; incomingObserver . onMessage ( inMessage ) ; } } protected class DecoupledDestination implements Destination { protected MessageObserver decoupledMessageObserver ; private EndpointReferenceType address ; DecoupledDestination ( EndpointReferenceType ref , MessageObserver incomingObserver ) { address = ref ; decoupledMessageObserver = incomingObserver ; } public EndpointReferenceType getAddress ( ) { return address ; } public Conduit getBackChannel ( Message inMessage , Message partialResponse , EndpointReferenceType addr ) throws IOException { return null ; } public void shutdown ( ) { } public synchronized void setMessageObserver ( MessageObserver observer ) { decoupledMessageObserver = observer ; } public synchronized MessageObserver getMessageObserver ( ) { return decoupledMessageObserver ; } } } 	0	['16', '0', '0', '17', '35', '102', '4', '14', '10', '0.858333333', '189', '1', '3', '0', '0.222222222', '0', '0', '10.3125', '3', '1.125', '0']
package org . apache . camel . impl . converter ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . StringTokenizer ; import static java . lang . reflect . Modifier . isAbstract ; import static java . lang . reflect . Modifier . isPublic ; import static java . lang . reflect . Modifier . isStatic ; import org . apache . camel . Converter ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ResolverUtil ; import org . apache . camel . util . WebSphereResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AnnotationTypeConverterLoader implements TypeConverterLoader { public static final String META_INF_SERVICES = "META-INF/services/org/apache/camel/TypeConverter" ; private static final transient Log LOG = LogFactory . getLog ( AnnotationTypeConverterLoader . class ) ; private ResolverUtil resolver ; private Set < Class > visitedClasses = new HashSet < Class > ( ) ; public AnnotationTypeConverterLoader ( ) { if ( WebSphereResolverUtil . isWebSphereClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ) { LOG . info ( "Using WebSphere specific ResolverUtil" ) ; resolver = new WebSphereResolverUtil ( META_INF_SERVICES ) ; } else { resolver = new ResolverUtil ( ) ; } } public AnnotationTypeConverterLoader ( ResolverUtil resolverUtil ) { this . resolver = resolverUtil ; } public void load ( TypeConverterRegistry registry ) throws Exception { String [ ] packageNames = findPackageNames ( ) ; resolver . findAnnotated ( Converter . class , packageNames ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class type : classes ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading converter class: " + ObjectHelper . name ( type ) ) ; } loadConverterMethods ( registry , type ) ; } } protected String [ ] findPackageNames ( ) throws IOException { Set < String > packages = new HashSet < String > ( ) ; ClassLoader ccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( ccl != null ) { findPackages ( packages , ccl ) ; } findPackages ( packages , getClass ( ) . getClassLoader ( ) ) ; return packages . toArray ( new String [ packages . size ( ) ] ) ; } protected void findPackages ( Set < String > packages , ClassLoader classLoader ) throws IOException { Enumeration < URL > resources = classLoader . getResources ( META_INF_SERVICES ) ; while ( resources . hasMoreElements ( ) ) { URL url = resources . nextElement ( ) ; if ( url != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; try { while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . startsWith ( "#" ) || line . length ( ) == 0 ) { continue ; } tokenize ( packages , line ) ; } } finally { ObjectHelper . close ( reader , null , LOG ) ; } } } } protected void tokenize ( Set < String > packages , String line ) { StringTokenizer iter = new StringTokenizer ( line , "," ) ; while ( iter . hasMoreTokens ( ) ) { String name = iter . nextToken ( ) . trim ( ) ; if ( name . length ( ) > 0 ) { packages . add ( name ) ; } } } protected void loadConverterMethods ( TypeConverterRegistry registry , Class type ) { if ( visitedClasses . contains ( type ) ) { return ; } visitedClasses . add ( type ) ; try { Method [ ] methods = type . getDeclaredMethods ( ) ; CachingInjector injector = null ; for ( Method method : methods ) { if ( ObjectHelper . hasAnnotation ( method , Converter . class , true ) ) { if ( isValidConverterMethod ( method ) ) { int modifiers = method . getModifiers ( ) ; if ( isAbstract ( modifiers ) || ! isPublic ( modifiers ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method is not a public and concrete method" ) ; } else { Class < ? > toType = method . getReturnType ( ) ; if ( toType . equals ( Void . class ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method returns a void method" ) ; } else { Class < ? > fromType = method . getParameterTypes ( ) [ 0 ] ; if ( isStatic ( modifiers ) ) { registerTypeConverter ( registry , method , toType , fromType , new StaticMethodTypeConverter ( method ) ) ; } else { if ( injector == null ) { injector = new CachingInjector ( registry , type ) ; } registerTypeConverter ( registry , method , toType , fromType , new InstanceMethodTypeConverter ( injector , method ) ) ; } } } } else { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method should have one parameter" ) ; } } } Class superclass = type . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { loadConverterMethods ( registry , superclass ) ; } } catch ( NoClassDefFoundError e ) { LOG . warn ( "Ignoring converter type: " + type . getName ( ) + " as a dependent class could not be found: " + e , e ) ; } } protected void registerTypeConverter ( TypeConverterRegistry registry , Method method , Class toType , Class fromType , TypeConverter typeConverter ) { registry . addTypeConverter ( toType , fromType , typeConverter ) ; } protected boolean isValidConverterMethod ( Method method ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; return ( parameterTypes != null ) && ( parameterTypes . length == 1 || ( parameterTypes . length == 2 && Exchange . class . isAssignableFrom ( parameterTypes [ 1 ] ) ) ) ; } } 	1	['10', '1', '2', '15', '69', '19', '4', '11', '3', '0.75', '415', '0.75', '1', '0', '0.271604938', '0', '0', '40.1', '10', '2.1', '1']
package org . apache . camel . util ; public interface TimeoutMap extends Runnable { Object get ( Object key ) ; Object [ ] getKeys ( ) ; int size ( ) ; void put ( Object key , Object value , long timeoutMillis ) ; void remove ( Object key ) ; void purge ( ) ; } 	0	['6', '1', '0', '3', '6', '15', '3', '0', '6', '2', '6', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . camel . spi ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public interface Synchronization { void onComplete ( Exchange exchange ) ; void onFailure ( Exchange exchange ) ; } 	1	['2', '1', '0', '3', '2', '1', '2', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . xmpp ; import org . jivesoftware . smack . XMPPException ; public class RuntimeXmppException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeXmppException ( XMPPException cause ) { super ( cause ) ; } public RuntimeXmppException ( String message , XMPPException cause ) { super ( message , cause ) ; } } 	0	['2', '4', '0', '3', '4', '1', '2', '1', '2', '2', '12', '1', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '0']
package org . apache . camel . util ; import java . net . InetAddress ; import java . net . ServerSocket ; import java . util . logging . Level ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class UuidGenerator { private static final transient Log LOG = LogFactory . getLog ( UuidGenerator . class ) ; private static final String UNIQUE_STUB ; private static int instanceCount ; private static String hostName ; private String seed ; private long sequence ; static { String stub = "" ; boolean canAccessSystemProps = true ; try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPropertiesAccess ( ) ; } } catch ( SecurityException se ) { canAccessSystemProps = false ; } if ( canAccessSystemProps ) { try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; ServerSocket ss = new ServerSocket ( 0 ) ; stub = "/" + ss . getLocalPort ( ) + "-" + System . currentTimeMillis ( ) + "/" ; Thread . sleep ( 100 ) ; ss . close ( ) ; } catch ( Exception ioe ) { LOG . warn ( "Could not generate unique stub" , ioe ) ; } } else { hostName = "localhost" ; stub = "-1-" + System . currentTimeMillis ( ) + "-" ; } UNIQUE_STUB = stub ; } public UuidGenerator ( String prefix ) { synchronized ( UNIQUE_STUB ) { this . seed = prefix + UNIQUE_STUB + ( instanceCount ++ ) + "-" ; } } public UuidGenerator ( ) { this ( "ID-" + hostName ) ; } public static String getHostName ( ) { return hostName ; } public synchronized String generateId ( ) { return this . seed + ( this . sequence ++ ) ; } public String generateSanitizedId ( ) { return generateSanitizedId ( generateId ( ) ) ; } public static String generateSanitizedId ( String id ) { id = id . replace ( ':' , '-' ) ; id = id . replace ( '_' , '-' ) ; id = id . replace ( '.' , '-' ) ; return id ; } } 	1	['7', '1', '0', '11', '25', '11', '9', '2', '6', '0.75', '166', '1', '0', '0', '0.5', '0', '0', '21.85714286', '1', '0.5714', '1']
package org . apache . camel . component . cxf ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . impl . DefaultMessage ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageContentsList ; import org . apache . cxf . message . MessageImpl ; public class CxfMessage extends DefaultMessage { private Message cxfMessage ; public CxfMessage ( ) { this ( new MessageImpl ( ) ) ; } public CxfMessage ( Message cxfMessage ) { if ( cxfMessage == null ) { this . cxfMessage = new MessageImpl ( ) ; } else { this . cxfMessage = cxfMessage ; } } @ Override public void copyFrom ( org . apache . camel . Message that ) { setMessageId ( that . getMessageId ( ) ) ; setBody ( that . getBody ( ) ) ; if ( that . getBody ( ) instanceof Message ) { setMessage ( ( Message ) that . getBody ( ) ) ; } getHeaders ( ) . putAll ( that . getHeaders ( ) ) ; if ( that instanceof CxfMessage ) { CxfMessage orig = ( CxfMessage ) that ; setMessage ( orig . getMessage ( ) ) ; } } @ Override public String toString ( ) { if ( cxfMessage != null ) { return "CxfMessage: " + cxfMessage ; } else { return "CxfMessage: " + getBody ( ) ; } } @ Override public CxfExchange getExchange ( ) { return ( CxfExchange ) super . getExchange ( ) ; } public Message getMessage ( ) { return cxfMessage ; } public void setMessage ( Message cxfMessage ) { this . cxfMessage = cxfMessage ; } @ Override public CxfMessage newInstance ( ) { return new CxfMessage ( ) ; } @ Override protected Object createBody ( ) { return CxfBinding . extractBodyFromCxf ( getExchange ( ) , cxfMessage ) ; } @ Override public void setBody ( Object body ) { super . setBody ( body ) ; if ( body instanceof Message ) { setMessage ( ( Message ) body ) ; } } public < T > T getBody ( Class < T > type ) { if ( ! ( MessageContentsList . class . isAssignableFrom ( type ) ) && getBody ( ) instanceof MessageContentsList ) { MessageContentsList list = ( MessageContentsList ) getBody ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Object value = list . get ( i ) ; try { T answer = getBody ( type , value ) ; if ( answer != null ) { return answer ; } } catch ( NoTypeConversionAvailableException ex ) { } } } return super . getBody ( type ) ; } } 	0	['14', '3', '0', '11', '32', '71', '4', '9', '13', '0.230769231', '171', '1', '0', '0.744680851', '0.271428571', '2', '7', '11.14285714', '4', '1.3571', '0']
package org . apache . camel . util ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLDecoder ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . jar . JarEntry ; import java . util . jar . JarInputStream ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ResolverUtil < T > { protected static final transient Log LOG = LogFactory . getLog ( ResolverUtil . class ) ; public static interface Test { boolean matches ( Class type ) ; } public static class IsA implements Test { private Class parent ; public IsA ( Class parentType ) { this . parent = parentType ; } public boolean matches ( Class type ) { return type != null && parent . isAssignableFrom ( type ) ; } @ Override public String toString ( ) { return "is assignable to " + parent . getSimpleName ( ) ; } } public static class AnnotatedWith implements Test { private Class < ? extends Annotation > annotation ; private boolean checkMetaAnnotations ; public AnnotatedWith ( Class < ? extends Annotation > annotation ) { this ( annotation , false ) ; } public AnnotatedWith ( Class < ? extends Annotation > annotation , boolean checkMetaAnnotations ) { this . annotation = annotation ; this . checkMetaAnnotations = checkMetaAnnotations ; } public boolean matches ( Class type ) { return type != null && ObjectHelper . hasAnnotation ( type , annotation , checkMetaAnnotations ) ; } @ Override public String toString ( ) { return "annotated with @" + annotation . getSimpleName ( ) ; } } private Set < Class < ? extends T > > matches = new HashSet < Class < ? extends T > > ( ) ; private Set < ClassLoader > classLoaders ; public Set < Class < ? extends T > > getClasses ( ) { return matches ; } public Set < ClassLoader > getClassLoaders ( ) { if ( classLoaders == null ) { classLoaders = new HashSet < ClassLoader > ( ) ; ClassLoader ccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( ccl != null ) { classLoaders . add ( ccl ) ; } classLoaders . add ( ResolverUtil . class . getClassLoader ( ) ) ; } return classLoaders ; } public void setClassLoaders ( Set < ClassLoader > classLoaders ) { this . classLoaders = classLoaders ; } public void findImplementations ( Class parent , String ... packageNames ) { if ( packageNames == null ) { return ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Searching for implementations of " + parent . getName ( ) + " in packages: " + Arrays . asList ( packageNames ) ) ; } Test test = new IsA ( parent ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found: " + getClasses ( ) ) ; } } public void findAnnotated ( Class < ? extends Annotation > annotation , String ... packageNames ) { if ( packageNames == null ) { return ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Searching for annotations of " + annotation . getName ( ) + " in packages: " + Arrays . asList ( packageNames ) ) ; } Test test = new AnnotatedWith ( annotation , true ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found: " + getClasses ( ) ) ; } } public void find ( Test test , String packageName ) { packageName = packageName . replace ( '.' , '/' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; LOG . debug ( "Using only regular classloaders" ) ; for ( ClassLoader classLoader : set ) { find ( test , packageName , classLoader ) ; } } protected void find ( Test test , String packageName , ClassLoader loader ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Searching for: " + test + " in package: " + packageName + " using classloader: " + loader . getClass ( ) . getName ( ) ) ; } Enumeration < URL > urls ; try { urls = getResources ( loader , packageName ) ; if ( ! urls . hasMoreElements ( ) ) { LOG . trace ( "No URLs returned by classloader" ) ; } } catch ( IOException ioe ) { LOG . warn ( "Could not read package: " + packageName , ioe ) ; return ; } while ( urls . hasMoreElements ( ) ) { URL url = null ; try { url = urls . nextElement ( ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "URL from classloader: " + url ) ; } String urlPath = url . getFile ( ) ; urlPath = URLDecoder . decode ( urlPath , "UTF-8" ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Decoded urlPath: " + urlPath ) ; } if ( urlPath . startsWith ( "file:" ) ) { urlPath = urlPath . substring ( 5 ) ; } if ( url . toString ( ) . startsWith ( "bundle:" ) || urlPath . startsWith ( "bundle:" ) ) { LOG . trace ( "It's a virtual osgi bundle, skipping" ) ; continue ; } if ( urlPath . indexOf ( '!' ) > 0 ) { urlPath = urlPath . substring ( 0 , urlPath . indexOf ( '!' ) ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Scanning for classes in [" + urlPath + "] matching criteria: " + test ) ; } File file = new File ( urlPath ) ; if ( file . isDirectory ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading from directory: " + file ) ; } loadImplementationsInDirectory ( test , packageName , file ) ; } else { InputStream stream ; if ( urlPath . startsWith ( "http:" ) ) { LOG . debug ( "The current jar is accessed via http" ) ; URL urlStream = new URL ( urlPath ) ; URLConnection con = urlStream . openConnection ( ) ; con . setUseCaches ( false ) ; stream = con . getInputStream ( ) ; } else { stream = new FileInputStream ( file ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading from jar: " + file ) ; } loadImplementationsInJar ( test , packageName , stream , urlPath ) ; } } catch ( IOException ioe ) { LOG . warn ( "Could not read entries in url: " + url , ioe ) ; } } } protected Enumeration < URL > getResources ( ClassLoader loader , String packageName ) throws IOException { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Getting resource URL for package: " + packageName + " with classloader: " + loader ) ; } return loader . getResources ( packageName ) ; } private void loadImplementationsInDirectory ( Test test , String parent , File location ) { File [ ] files = location . listFiles ( ) ; StringBuilder builder = null ; for ( File file : files ) { builder = new StringBuilder ( 100 ) ; String name = file . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; builder . append ( parent ) . append ( "/" ) . append ( name ) ; String packageOrClass = parent == null ? name : builder . toString ( ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageOrClass , file ) ; } else if ( name . endsWith ( ".class" ) ) { addIfMatching ( test , packageOrClass ) ; } } } } private void loadImplementationsInJar ( Test test , String parent , InputStream stream , String urlPath ) { JarInputStream jarStream = null ; try { jarStream = new JarInputStream ( stream ) ; JarEntry entry ; while ( ( entry = jarStream . getNextJarEntry ( ) ) != null ) { String name = entry . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; if ( ! entry . isDirectory ( ) && name . startsWith ( parent ) && name . endsWith ( ".class" ) ) { addIfMatching ( test , name ) ; } } } } catch ( IOException ioe ) { LOG . error ( "Could not search jar file '" + urlPath + "' for classes matching criteria: " + test + " due to an IOException: " + ioe . getMessage ( ) , ioe ) ; } finally { ObjectHelper . close ( jarStream , urlPath , LOG ) ; } } protected void addIfMatching ( Test test , String fqn ) { try { String externalName = fqn . substring ( 0 , fqn . indexOf ( '.' ) ) . replace ( '/' , '.' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; boolean found = false ; for ( ClassLoader classLoader : set ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Testing for class " + externalName + " matches criteria [" + test + "]" ) ; } try { Class type = classLoader . loadClass ( externalName ) ; if ( test . matches ( type ) ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Found class: " + type + " in classloader: " + classLoader ) ; } matches . add ( ( Class < T > ) type ) ; } found = true ; break ; } catch ( ClassNotFoundException e ) { LOG . debug ( "Could not find class '" + fqn + "' in classloader: " + classLoader + ". Reason: " + e , e ) ; } catch ( NoClassDefFoundError e ) { LOG . debug ( "Could not find the class defintion '" + fqn + "' in classloader: " + classLoader + ". Reason: " + e , e ) ; } } if ( ! found ) { LOG . warn ( "Could not find class '" + fqn + "' in any classloaders: " + set ) ; } } catch ( Throwable t ) { LOG . warn ( "Could not examine class '" + fqn + "' due to a " + t . getClass ( ) . getName ( ) + " with message: " + t . getMessage ( ) , t ) ; } } } 	1	['13', '1', '2', '13', '72', '14', '7', '6', '7', '0.527777778', '765', '1', '0', '0', '0.296296296', '0', '0', '57.61538462', '14', '3.4615', '2']
package org . apache . camel . component . timer ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import java . util . Timer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class TimerComponent extends DefaultComponent < Exchange > { private Map < String , Timer > timers = new HashMap < String , Timer > ( ) ; public Timer getTimer ( TimerEndpoint endpoint ) { String key = endpoint . getTimerName ( ) ; if ( ! endpoint . isDaemon ( ) ) { key = "nonDaemon:" + key ; } Timer answer = timers . get ( key ) ; if ( answer == null ) { answer = new Timer ( endpoint . getTimerName ( ) , endpoint . isDaemon ( ) ) ; timers . put ( key , answer ) ; } return answer ; } @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { TimerEndpoint answer = new TimerEndpoint ( uri , this , remaining ) ; setProperties ( answer , parameters ) ; return answer ; } @ Override protected void doStop ( ) throws Exception { Collection < Timer > collection = timers . values ( ) ; for ( Timer timer : collection ) { timer . cancel ( ) ; } timers . clear ( ) ; } } 	0	['4', '3', '0', '3', '22', '0', '1', '3', '2', '0.333333333', '86', '1', '0', '0.921052632', '0.4375', '2', '3', '20.25', '3', '1.25', '0']
package org . apache . camel . component . file ; import java . io . File ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class FileComponent extends DefaultComponent < FileExchange > { public static final String HEADER_FILE_NAME = "org.apache.camel.file.name" ; public static final String HEADER_FILE_NAME_PRODUCED = "org.apache.camel.file.name.produced" ; public FileComponent ( ) { } public FileComponent ( CamelContext context ) { super ( context ) ; } protected Endpoint < FileExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { File file = new File ( remaining ) ; FileEndpoint result = new FileEndpoint ( file , uri , this ) ; setProperties ( result , parameters ) ; return result ; } } 	1	['3', '3', '0', '4', '8', '3', '1', '4', '2', '1.5', '30', '0', '0', '0.972222222', '0.5', '1', '2', '8.333333333', '1', '0.3333', '4']
package org . apache . camel . component . cxf . interceptors ; import java . util . ResourceBundle ; import java . util . logging . Logger ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . interceptor . MessageSenderInterceptor ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; public class DOMOutInterceptor extends AbstractPhaseInterceptor < Message > { private static final Logger LOG = LogUtils . getL7dLogger ( DOMOutInterceptor . class ) ; private final XMLMessageOutInterceptor xmlInterceptor = new XMLMessageOutInterceptor ( ) ; private final SoapMessageOutInterceptor soapInterceptor = new SoapMessageOutInterceptor ( ) ; public DOMOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; this . addBefore ( MessageSenderInterceptor . class . getName ( ) ) ; } public boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message message ) throws Fault { if ( message instanceof XMLMessage ) { xmlInterceptor . handleMessage ( ( XMLMessage ) message ) ; } else if ( message instanceof SoapMessage ) { soapInterceptor . handleMessage ( ( SoapMessage ) message ) ; } else { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NOT_SUPPORTED_MESSAGE" , LOG , message . getClass ( ) . getName ( ) ) ) ; } } } 	0	['4', '0', '0', '10', '17', '2', '1', '9', '3', '0.666666667', '71', '1', '2', '0', '0.833333333', '0', '0', '16', '1', '0.5', '0']
package org . apache . camel . util . jndi ; import java . util . Hashtable ; import javax . naming . Context ; import javax . naming . NamingException ; import javax . naming . spi . InitialContextFactory ; public class CamelInitialContextFactory implements InitialContextFactory { public Context getInitialContext ( Hashtable environment ) throws NamingException { try { return new JndiContext ( environment ) ; } catch ( NamingException e ) { throw e ; } catch ( Exception e ) { NamingException exception = new NamingException ( e . getMessage ( ) ) ; exception . initCause ( e ) ; throw exception ; } } } 	1	['2', '1', '0', '1', '7', '1', '0', '1', '2', '2', '26', '0', '0', '0', '0.75', '0', '0', '12', '1', '0.5', '1']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . Message ; @ XmlType ( name = "headerType" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public abstract class HeaderType { @ XmlAttribute private String name ; public HeaderType ( ) { } protected HeaderType ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public abstract Object getValue ( ) ; public abstract void setValue ( Object value ) ; } 	0	['6', '1', '4', '5', '7', '9', '5', '0', '5', '0.6', '23', '1', '0', '0', '0.5', '0', '0', '2.666666667', '1', '0.6667', '0']
package org . apache . camel . util ; import java . io . IOException ; import java . net . URL ; import java . util . Enumeration ; public class WebSphereResolverUtil extends ResolverUtil { private String resourcePath ; public WebSphereResolverUtil ( String resourcePath ) { this . resourcePath = resourcePath ; } public static boolean isWebSphereClassLoader ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . startsWith ( "com.ibm" ) ; } @ Override protected Enumeration < URL > getResources ( ClassLoader loader , String packageName ) throws IOException { Enumeration < URL > enumeration = super . getResources ( loader , packageName ) ; if ( ! enumeration . hasMoreElements ( ) ) { LOG . trace ( "Using WebSphere workaround to load the camel jars with the annotated converters." ) ; enumeration = loader . getResources ( resourcePath ) ; } return enumeration ; } } 	1	['3', '2', '0', '3', '11', '1', '1', '2', '2', '0.5', '34', '1', '0', '0.846153846', '0.666666667', '1', '1', '10', '1', '0.6667', '2']
package org . apache . camel . component . seda ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . spi . BrowsableEndpoint ; import org . apache . camel . util . ObjectHelper ; public class SedaEndpoint extends DefaultEndpoint < Exchange > implements BrowsableEndpoint < Exchange > { private BlockingQueue < Exchange > queue ; public SedaEndpoint ( String endpointUri , Component component , BlockingQueue < Exchange > queue ) { super ( endpointUri , component ) ; this . queue = queue ; } public SedaEndpoint ( String uri , SedaComponent component , Map parameters ) { this ( uri , component , component . createQueue ( uri , parameters ) ) ; } public SedaEndpoint ( String endpointUri , BlockingQueue < Exchange > queue ) { super ( endpointUri ) ; ObjectHelper . notNull ( queue , "queue" ) ; this . queue = queue ; } public Producer createProducer ( ) throws Exception { return new CollectionProducer ( this , getQueue ( ) ) ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new SedaConsumer ( this , processor ) ; } public BlockingQueue < Exchange > getQueue ( ) { return queue ; } public boolean isSingleton ( ) { return true ; } public List < Exchange > getExchanges ( ) { return new ArrayList < Exchange > ( getQueue ( ) ) ; } } 	0	['8', '2', '0', '12', '15', '22', '3', '11', '8', '0.285714286', '60', '1', '0', '0.827586207', '0.303571429', '0', '0', '6.375', '1', '0.625', '0']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . Body ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Header ; import org . apache . camel . Headers ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . OutHeaders ; import org . apache . camel . Properties ; import org . apache . camel . Property ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ExchangeHelper . convertToType ; public class BeanInfo { private static final transient Log LOG = LogFactory . getLog ( BeanInfo . class ) ; private final CamelContext camelContext ; private Class type ; private ParameterMappingStrategy strategy ; private Map < String , MethodInfo > operations = new ConcurrentHashMap < String , MethodInfo > ( ) ; private MethodInfo defaultMethod ; private List < MethodInfo > operationsWithBody = new ArrayList < MethodInfo > ( ) ; private List < MethodInfo > operationsWithCustomAnnotation = new ArrayList < MethodInfo > ( ) ; private Map < Method , MethodInfo > methodMap = new HashMap < Method , MethodInfo > ( ) ; private BeanInfo superBeanInfo ; public BeanInfo ( CamelContext camelContext , Class type ) { this ( camelContext , type , createParameterMappingStrategy ( camelContext ) ) ; } public BeanInfo ( CamelContext camelContext , Class type , ParameterMappingStrategy strategy ) { this . camelContext = camelContext ; this . type = type ; this . strategy = strategy ; introspect ( getType ( ) ) ; if ( operations . size ( ) == 1 ) { Collection < MethodInfo > methodInfos = operations . values ( ) ; for ( MethodInfo methodInfo : methodInfos ) { defaultMethod = methodInfo ; } } } public Class getType ( ) { return type ; } public CamelContext getCamelContext ( ) { return camelContext ; } public MethodInvocation createInvocation ( Method method , Object pojo , Exchange exchange ) throws RuntimeCamelException { MethodInfo methodInfo = introspect ( type , method ) ; if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } public MethodInvocation createInvocation ( Object pojo , Exchange exchange ) throws RuntimeCamelException , AmbiguousMethodCallException { MethodInfo methodInfo = null ; String name = exchange . getIn ( ) . getHeader ( BeanProcessor . METHOD_NAME , String . class ) ; if ( name != null ) { methodInfo = operations . get ( name ) ; } if ( methodInfo == null ) { methodInfo = chooseMethod ( pojo , exchange ) ; } if ( methodInfo == null ) { methodInfo = defaultMethod ; } if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } protected void introspect ( Class clazz ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Introspecting class: " + clazz ) ; } Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( isValidMethod ( clazz , method ) ) { introspect ( clazz , method ) ; } } Class superclass = clazz . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { introspect ( superclass ) ; } } protected MethodInfo introspect ( Class clazz , Method method ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Introspecting class: " + clazz + ", method: " + method ) ; } String opName = method . getName ( ) ; MethodInfo methodInfo = createMethodInfo ( clazz , method ) ; MethodInfo existingMethodInfo = overridesExistingMethod ( methodInfo ) ; if ( existingMethodInfo != null ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "This method is already overriden in a subclass, so the method from the sub class is prefered: " + existingMethodInfo ) ; } return existingMethodInfo ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Adding operation: " + opName + " for method: " + methodInfo ) ; } operations . put ( opName , methodInfo ) ; if ( methodInfo . hasBodyParameter ( ) ) { operationsWithBody . add ( methodInfo ) ; } if ( methodInfo . isHasCustomAnnotation ( ) && ! methodInfo . hasBodyParameter ( ) ) { operationsWithCustomAnnotation . add ( methodInfo ) ; } methodMap . put ( method , methodInfo ) ; return methodInfo ; } private MethodInfo overridesExistingMethod ( MethodInfo methodInfo ) { for ( MethodInfo info : methodMap . values ( ) ) { if ( ! info . getMethod ( ) . getName ( ) . equals ( methodInfo . getMethod ( ) . getName ( ) ) ) { continue ; } if ( info . getMethod ( ) . getParameterTypes ( ) . length != methodInfo . getMethod ( ) . getParameterTypes ( ) . length ) { continue ; } for ( int i = 0 ; i < info . getMethod ( ) . getParameterTypes ( ) . length ; i ++ ) { Class type1 = info . getMethod ( ) . getParameterTypes ( ) [ i ] ; Class type2 = methodInfo . getMethod ( ) . getParameterTypes ( ) [ i ] ; if ( ! type1 . equals ( type2 ) ) { continue ; } } return info ; } return null ; } public MethodInfo getMethodInfo ( Method method ) { MethodInfo answer = methodMap . get ( method ) ; if ( answer == null ) { if ( superBeanInfo == null && type != Object . class ) { Class superclass = type . getSuperclass ( ) ; if ( superclass != null && superclass != Object . class ) { superBeanInfo = new BeanInfo ( camelContext , superclass , strategy ) ; return superBeanInfo . getMethodInfo ( method ) ; } } } return answer ; } protected MethodInfo createMethodInfo ( Class clazz , Method method ) { Class [ ] parameterTypes = method . getParameterTypes ( ) ; Annotation [ ] [ ] parametersAnnotations = method . getParameterAnnotations ( ) ; List < ParameterInfo > parameters = new ArrayList < ParameterInfo > ( ) ; List < ParameterInfo > bodyParameters = new ArrayList < ParameterInfo > ( ) ; boolean hasCustomAnnotation = false ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { Class parameterType = parameterTypes [ i ] ; Annotation [ ] parameterAnnotations = parametersAnnotations [ i ] ; Expression expression = createParameterUnmarshalExpression ( clazz , method , parameterType , parameterAnnotations ) ; hasCustomAnnotation |= expression != null ; ParameterInfo parameterInfo = new ParameterInfo ( i , parameterType , parameterAnnotations , expression ) ; parameters . add ( parameterInfo ) ; if ( expression == null ) { hasCustomAnnotation |= ObjectHelper . hasAnnotation ( parameterAnnotations , Body . class ) ; if ( bodyParameters . isEmpty ( ) ) { if ( Exchange . class . isAssignableFrom ( parameterType ) ) { expression = ExpressionBuilder . exchangeExpression ( ) ; } else { expression = ExpressionBuilder . bodyExpression ( parameterType ) ; } parameterInfo . setExpression ( expression ) ; bodyParameters . add ( parameterInfo ) ; } else { } } } MethodInfo methodInfo = new MethodInfo ( clazz , method , parameters , bodyParameters , hasCustomAnnotation ) ; return methodInfo ; } protected MethodInfo chooseMethod ( Object pojo , Exchange exchange ) throws AmbiguousMethodCallException { if ( operationsWithBody . size ( ) == 1 ) { return operationsWithBody . get ( 0 ) ; } else if ( ! operationsWithBody . isEmpty ( ) ) { return chooseMethodWithMatchingBody ( exchange , operationsWithBody ) ; } else if ( operationsWithCustomAnnotation . size ( ) == 1 ) { return operationsWithCustomAnnotation . get ( 0 ) ; } return null ; } protected MethodInfo chooseMethodWithMatchingBody ( Exchange exchange , Collection < MethodInfo > operationList ) throws AmbiguousMethodCallException { Message in = exchange . getIn ( ) ; Object body = in . getBody ( ) ; if ( body != null ) { Class bodyType = body . getClass ( ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Matching for method with a single parameter that matches type: " + bodyType . getCanonicalName ( ) ) ; } List < MethodInfo > possibles = new ArrayList < MethodInfo > ( ) ; for ( MethodInfo methodInfo : operationList ) { boolean out = exchange . getPattern ( ) . isOutCapable ( ) ; if ( out && methodInfo . isReturnTypeVoid ( ) ) { continue ; } if ( methodInfo . bodyParameterMatches ( bodyType ) ) { possibles . add ( methodInfo ) ; } } if ( possibles . size ( ) == 1 ) { return possibles . get ( 0 ) ; } else if ( possibles . isEmpty ( ) ) { Object newBody = null ; MethodInfo matched = null ; for ( MethodInfo methodInfo : operationList ) { Object value = null ; try { value = convertToType ( exchange , methodInfo . getBodyParameterType ( ) , body ) ; if ( value != null ) { if ( newBody != null ) { throw new AmbiguousMethodCallException ( exchange , Arrays . asList ( matched , methodInfo ) ) ; } else { newBody = value ; matched = methodInfo ; } } } catch ( NoTypeConversionAvailableException e ) { } } if ( matched != null ) { in . setBody ( newBody ) ; return matched ; } } else { if ( operationsWithCustomAnnotation . size ( ) == 1 ) { return operationsWithCustomAnnotation . get ( 0 ) ; } return chooseMethodWithCustomAnnotations ( exchange , possibles ) ; } } return null ; } protected MethodInfo chooseMethodWithCustomAnnotations ( Exchange exchange , Collection < MethodInfo > possibles ) throws AmbiguousMethodCallException { MethodInfo chosen = null ; for ( MethodInfo possible : possibles ) { if ( possible . isHasCustomAnnotation ( ) ) { if ( chosen != null ) { chosen = null ; break ; } else { chosen = possible ; } } } if ( chosen != null ) { return chosen ; } throw new AmbiguousMethodCallException ( exchange , possibles ) ; } protected Expression createParameterUnmarshalExpression ( Class clazz , Method method , Class parameterType , Annotation [ ] parameterAnnotation ) { for ( Annotation annotation : parameterAnnotation ) { Expression answer = createParameterUnmarshalExpressionForAnnotation ( clazz , method , parameterType , annotation ) ; if ( answer != null ) { return answer ; } } return strategy . getDefaultParameterTypeExpression ( parameterType ) ; } protected boolean isPossibleBodyParameter ( Annotation [ ] annotations ) { if ( annotations != null ) { for ( Annotation annotation : annotations ) { if ( ( annotation instanceof Property ) || ( annotation instanceof Header ) || ( annotation instanceof Headers ) || ( annotation instanceof OutHeaders ) || ( annotation instanceof Properties ) ) { return false ; } LanguageAnnotation languageAnnotation = annotation . annotationType ( ) . getAnnotation ( LanguageAnnotation . class ) ; if ( languageAnnotation != null ) { return false ; } } } return true ; } protected Expression createParameterUnmarshalExpressionForAnnotation ( Class clazz , Method method , Class parameterType , Annotation annotation ) { if ( annotation instanceof Property ) { Property propertyAnnotation = ( Property ) annotation ; return ExpressionBuilder . propertyExpression ( propertyAnnotation . name ( ) ) ; } else if ( annotation instanceof Properties ) { return ExpressionBuilder . propertiesExpression ( ) ; } else if ( annotation instanceof Header ) { Header headerAnnotation = ( Header ) annotation ; return ExpressionBuilder . headerExpression ( headerAnnotation . name ( ) ) ; } else if ( annotation instanceof Headers ) { return ExpressionBuilder . headersExpression ( ) ; } else if ( annotation instanceof OutHeaders ) { return ExpressionBuilder . outHeadersExpression ( ) ; } else { LanguageAnnotation languageAnnotation = annotation . annotationType ( ) . getAnnotation ( LanguageAnnotation . class ) ; if ( languageAnnotation != null ) { Class < ? > type = languageAnnotation . factory ( ) ; Object object = camelContext . getInjector ( ) . newInstance ( type ) ; if ( object instanceof AnnotationExpressionFactory ) { AnnotationExpressionFactory expressionFactory = ( AnnotationExpressionFactory ) object ; return expressionFactory . createExpression ( camelContext , annotation , languageAnnotation , parameterType ) ; } else { LOG . error ( "Ignoring bad annotation: " + languageAnnotation + "on method: " + method + " which declares a factory: " + type . getName ( ) + " which does not implement " + AnnotationExpressionFactory . class . getName ( ) ) ; } } } return null ; } protected boolean isValidMethod ( Class clazz , Method method ) { if ( ! Modifier . isPublic ( method . getModifiers ( ) ) ) { return false ; } if ( method . getReturnType ( ) != null && Exchange . class . isAssignableFrom ( method . getReturnType ( ) ) ) { return false ; } return true ; } public static ParameterMappingStrategy createParameterMappingStrategy ( CamelContext camelContext ) { Registry registry = camelContext . getRegistry ( ) ; ParameterMappingStrategy answer = registry . lookup ( ParameterMappingStrategy . class . getName ( ) , ParameterMappingStrategy . class ) ; if ( answer == null ) { answer = new DefaultParameterMappingStrategy ( ) ; } return answer ; } } 	1	['20', '1', '0', '33', '96', '122', '6', '27', '8', '0.726315789', '930', '1', '4', '0', '0.244019139', '0', '0', '45', '9', '3.25', '4']
package org . apache . camel . component . cxf . interceptors ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . OperationInfo ; import org . apache . cxf . staxutils . StaxUtils ; public abstract class AbstractMessageInInterceptor < T extends Message > extends AbstractPhaseInterceptor < T > { public AbstractMessageInInterceptor ( String phase ) { super ( phase ) ; } protected boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } public void handleMessage ( T message ) throws Fault { Logger logger = getLogger ( ) ; if ( isFaultMessage ( message ) ) { message . getInterceptorChain ( ) . abort ( ) ; Endpoint ep = message . getExchange ( ) . get ( Endpoint . class ) ; if ( ep . getInFaultObserver ( ) != null ) { ep . getInFaultObserver ( ) . onMessage ( message ) ; return ; } } Document document = createDOMMessage ( message ) ; Element payloadEl = ( Element ) document . getChildNodes ( ) . item ( 0 ) ; Exchange ex = message . getExchange ( ) ; BindingOperationInfo boi = ex . get ( BindingOperationInfo . class ) ; if ( boi == null ) { BindingInfo bi = ex . get ( BindingInfo . class ) ; if ( bi == null ) { Endpoint ep = ex . get ( Endpoint . class ) ; bi = ep . getEndpointInfo ( ) . getBinding ( ) ; ex . put ( BindingInfo . class , bi ) ; } if ( logger . isLoggable ( Level . INFO ) ) { logger . info ( "AbstractRoutingMessageInInterceptor Infer BindingOperationInfo." ) ; } boi = getBindingOperation ( message , document ) ; if ( boi == null ) { QName startQName = new QName ( payloadEl . getNamespaceURI ( ) , payloadEl . getLocalName ( ) ) ; throw new Fault ( new org . apache . cxf . common . i18n . Message ( "REQ_NOT_UNDERSTOOD" , getLogger ( ) , startQName ) ) ; } if ( boi != null ) { ex . put ( BindingOperationInfo . class , boi ) ; ex . put ( OperationInfo . class , boi . getOperationInfo ( ) ) ; ex . setOneWay ( boi . getOperationInfo ( ) . isOneWay ( ) ) ; if ( logger . isLoggable ( Level . INFO ) ) { logger . info ( "DOMInInterceptor- BindingOperation is:" + boi . getName ( ) ) ; } } } BindingMessageInfo bmi = isRequestor ( message ) ? boi . getOutput ( ) : boi . getInput ( ) ; List < Element > partList = getPartList ( message , payloadEl , bmi ) ; message . put ( List . class , partList ) ; } protected Document createDOMMessage ( T message ) { Document doc = null ; try { if ( getLogger ( ) . isLoggable ( Level . INFO ) ) { getLogger ( ) . info ( "AbstractMessageInInterceptor Converting Stax Stream to DOM" ) ; } XMLStreamReader xsr = message . getContent ( XMLStreamReader . class ) ; doc = StaxUtils . read ( xsr ) ; } catch ( XMLStreamException xe ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "STAX_READ_EXC" , getLogger ( ) ) , xe ) ; } return doc ; } protected abstract Logger getLogger ( ) ; protected abstract boolean isFaultMessage ( T message ) ; protected abstract BindingOperationInfo getBindingOperation ( T inMessage , Document document ) ; protected abstract List < Element > getPartList ( T inMessage , Element rootElement , BindingMessageInfo boi ) ; } 	0	['8', '0', '2', '16', '43', '28', '2', '14', '2', '2', '208', '0', '0', '0', '0.375', '0', '0', '25', '2', '1', '0']
package org . apache . camel ; import org . apache . camel . util . ExchangeHelper ; public class NoSuchPropertyException extends CamelExchangeException { private static final long serialVersionUID = - 8721487431101572630L ; private final String propertyName ; private final Class < ? > type ; public NoSuchPropertyException ( Exchange exchange , String propertyName , Class < ? > type ) { super ( "No '" + propertyName + "' property available of type: " + type . getName ( ) + reason ( exchange , propertyName ) , exchange ) ; this . propertyName = propertyName ; this . type = type ; } public String getPropertyName ( ) { return propertyName ; } public Class < ? > getType ( ) { return type ; } protected static String reason ( Exchange exchange , String propertyName ) { Object value = exchange . getProperty ( propertyName ) ; return valueDescription ( value ) ; } static String valueDescription ( Object value ) { if ( value == null ) { return "" ; } return " but has value: " + value + " of type: " + value . getClass ( ) . getName ( ) ; } } 	1	['5', '5', '0', '6', '13', '6', '4', '2', '3', '0.916666667', '67', '1', '0', '0.826086957', '0.36', '0', '0', '11.8', '2', '1', '2']
package org . apache . camel . component . xmpp ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . jivesoftware . smack . packet . Message ; public class XmppBinding { private HeaderFilterStrategy headerFilterStrategy ; public XmppBinding ( ) { this . headerFilterStrategy = new DefaultHeaderFilterStrategy ( ) ; } public XmppBinding ( HeaderFilterStrategy headerFilterStrategy ) { this . headerFilterStrategy = headerFilterStrategy ; } public void populateXmppMessage ( Message message , Exchange exchange ) { message . setBody ( exchange . getIn ( ) . getBody ( String . class ) ) ; Set < Map . Entry < String , Object > > entries = exchange . getIn ( ) . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String name = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( headerFilterStrategy != null && ! headerFilterStrategy . applyFilterToCamelHeaders ( name , value ) ) { message . setProperty ( name , value ) ; } } String id = exchange . getExchangeId ( ) ; if ( id != null ) { message . setProperty ( "exchangeId" , id ) ; } } public Object extractBodyFromXmpp ( XmppExchange exchange , Message message ) { return message . getBody ( ) ; } public Map < String , Object > extractHeadersFromXmpp ( Message xmppMessage ) { Map < String , Object > answer = new HashMap < String , Object > ( ) ; for ( String name : xmppMessage . getPropertyNames ( ) ) { Object value = xmppMessage . getProperty ( name ) ; if ( headerFilterStrategy != null && ! headerFilterStrategy . applyFilterToExternalHeaders ( name , value ) ) { answer . put ( name , value ) ; } } return answer ; } } 	0	['5', '1', '0', '10', '27', '0', '5', '6', '5', '0.25', '112', '1', '1', '0', '0.44', '0', '0', '21.2', '3', '1.2', '0']
package org . apache . camel . component . dataset ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . processor . ThroughputLogger ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DataSetConsumer extends DefaultConsumer < Exchange > { private static final transient Log LOG = LogFactory . getLog ( DataSetConsumer . class ) ; private DataSetEndpoint endpoint ; private Processor reporter ; public DataSetConsumer ( DataSetEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( reporter == null ) { reporter = createReporter ( ) ; } final DataSet dataSet = endpoint . getDataSet ( ) ; final long preloadSize = endpoint . getPreloadSize ( ) ; sendMessages ( 0 , preloadSize ) ; endpoint . getExecutorService ( ) . execute ( new Runnable ( ) { public void run ( ) { sendMessages ( preloadSize , dataSet . getSize ( ) ) ; } } ) ; } protected void sendMessages ( long startIndex , long endIndex ) { try { for ( long i = startIndex ; i < endIndex ; i ++ ) { Exchange exchange = endpoint . createExchange ( i ) ; getProcessor ( ) . process ( exchange ) ; try { long delay = endpoint . getProduceDelay ( ) ; if ( delay < 3 ) { delay = 3 ; } Thread . sleep ( delay ) ; } catch ( InterruptedException e ) { LOG . debug ( e ) ; } if ( reporter != null ) { reporter . process ( exchange ) ; } } } catch ( Exception e ) { LOG . error ( e ) ; } } protected ThroughputLogger createReporter ( ) { ThroughputLogger answer = new ThroughputLogger ( endpoint . getEndpointUri ( ) , ( int ) endpoint . getDataSet ( ) . getReportCount ( ) ) ; answer . setAction ( "Sent" ) ; return answer ; } } 	1	['5', '3', '0', '10', '24', '0', '2', '10', '1', '0.5', '119', '1', '2', '0.884615385', '0.4375', '1', '1', '22.2', '3', '1', '3']
package org . apache . camel . component . spring . integration . converter ; import org . apache . camel . Converter ; import org . apache . camel . Endpoint ; import org . apache . camel . component . spring . integration . SpringIntegrationEndpoint ; import org . apache . camel . component . spring . integration . SpringIntegrationMessage ; import org . springframework . integration . core . MessageChannel ; import org . springframework . integration . core . MessageHeaders ; import org . springframework . integration . message . GenericMessage ; @ Converter public final class SpringIntegrationConverter { private SpringIntegrationConverter ( ) { } @ Converter public static Endpoint toEndpoint ( final MessageChannel channel ) throws Exception { if ( channel == null ) { throw new IllegalArgumentException ( "The MessageChannel is null" ) ; } Endpoint answer = new SpringIntegrationEndpoint ( "URL" , channel , null ) ; return answer ; } @ SuppressWarnings ( "unchecked" ) @ Converter public static org . springframework . integration . core . Message toSpringMessage ( final org . apache . camel . Message camelMessage ) throws Exception { if ( camelMessage instanceof SpringIntegrationMessage ) { SpringIntegrationMessage siMessage = ( SpringIntegrationMessage ) camelMessage ; org . springframework . integration . core . Message message = siMessage . getMessage ( ) ; if ( message != null ) { return message ; } } MessageHeaders messageHeaders = new MessageHeaders ( camelMessage . getHeaders ( ) ) ; return new GenericMessage ( camelMessage . getBody ( ) , messageHeaders ) ; } @ Converter public static org . apache . camel . Message toCamelMessage ( final org . springframework . integration . core . Message springMessage ) throws Exception { return new SpringIntegrationMessage ( springMessage ) ; } } 	0	['4', '1', '0', '9', '13', '6', '0', '9', '3', '2', '54', '0', '0', '0', '0.25', '0', '0', '12.5', '1', '0.75', '0']
package org . apache . camel ; import java . util . Map ; public interface Endpoint < E extends Exchange > { boolean isSingleton ( ) ; String getEndpointUri ( ) ; E createExchange ( ) ; E createExchange ( ExchangePattern pattern ) ; E createExchange ( Exchange exchange ) ; CamelContext getCamelContext ( ) ; Producer < E > createProducer ( ) throws Exception ; Consumer < E > createConsumer ( Processor processor ) throws Exception ; PollingConsumer < E > createPollingConsumer ( ) throws Exception ; void configureProperties ( Map options ) ; void setCamelContext ( CamelContext context ) ; @ Deprecated CamelContext getContext ( ) ; @ Deprecated void setContext ( CamelContext context ) ; boolean isLenientProperties ( ) ; } 	1	['14', '1', '0', '179', '14', '91', '174', '7', '14', '2', '14', '0', '0', '0', '0.238095238', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . jms . requestor ; import java . util . concurrent . Callable ; import java . util . concurrent . FutureTask ; import javax . jms . JMSException ; import javax . jms . Message ; public class FutureHandler extends FutureTask < Message > implements ReplyHandler { private static final Callable < Message > EMPTY_CALLABLE = new Callable < Message > ( ) { public Message call ( ) throws Exception { return null ; } } ; public FutureHandler ( ) { super ( EMPTY_CALLABLE ) ; } public synchronized void set ( Message result ) { super . set ( result ) ; } public boolean handle ( Message message ) throws JMSException { set ( message ) ; return true ; } } 	0	['5', '2', '1', '5', '8', '8', '3', '2', '4', '0.75', '29', '1', '0', '0.769230769', '0.583333333', '0', '0', '4.6', '1', '0.6', '0']
package org . apache . camel . processor ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class Pipeline extends MulticastProcessor implements AsyncProcessor { private static final transient Log LOG = LogFactory . getLog ( Pipeline . class ) ; public Pipeline ( Collection < Processor > processors ) { super ( processors ) ; } public static Processor newInstance ( List < Processor > processors ) { if ( processors . isEmpty ( ) ) { return null ; } else if ( processors . size ( ) == 1 ) { return processors . get ( 0 ) ; } return new Pipeline ( processors ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( Exchange original , AsyncCallback callback ) { Iterator < Processor > processors = getProcessors ( ) . iterator ( ) ; Exchange nextExchange = original ; boolean first = true ; while ( true ) { boolean exceptionHandled = hasExceptionBeenHandled ( nextExchange ) ; if ( nextExchange . isFailed ( ) || exceptionHandled ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Message exchange has failed so breaking out of pipeline: " + nextExchange + " exception: " + nextExchange . getException ( ) + " fault: " + nextExchange . getFault ( false ) + ( exceptionHandled ? " handled by the error handler" : "" ) ) ; } break ; } if ( ! processors . hasNext ( ) ) { break ; } AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( processors . next ( ) ) ; if ( first ) { first = false ; } else { nextExchange = createNextExchange ( processor , nextExchange ) ; } boolean sync = process ( original , nextExchange , callback , processors , processor ) ; if ( ! sync ) { return false ; } } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Processing compelete for exchangeId: " + original . getExchangeId ( ) + " >>> " + nextExchange ) ; } ExchangeHelper . copyResults ( original , nextExchange ) ; callback . done ( true ) ; return true ; } private boolean process ( final Exchange original , final Exchange exchange , final AsyncCallback callback , final Iterator < Processor > processors , AsyncProcessor processor ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Processing exchangeId: " + exchange . getExchangeId ( ) + " >>> " + exchange ) ; } return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } Exchange nextExchange = exchange ; while ( processors . hasNext ( ) ) { AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( processors . next ( ) ) ; boolean exceptionHandled = hasExceptionBeenHandled ( nextExchange ) ; if ( nextExchange . isFailed ( ) || exceptionHandled ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Message exchange has failed so breaking out of pipeline: " + nextExchange + " exception: " + nextExchange . getException ( ) + " fault: " + nextExchange . getFault ( false ) + ( exceptionHandled ? " handled by the error handler" : "" ) ) ; } break ; } nextExchange = createNextExchange ( processor , nextExchange ) ; sync = process ( original , nextExchange , callback , processors , processor ) ; if ( ! sync ) { return ; } } ExchangeHelper . copyResults ( original , nextExchange ) ; callback . done ( false ) ; } } ) ; } private static boolean hasExceptionBeenHandled ( Exchange nextExchange ) { return Boolean . TRUE . equals ( nextExchange . getProperty ( Exchange . EXCEPTION_HANDLED_PROPERTY ) ) ; } protected Exchange createNextExchange ( Processor producer , Exchange previousExchange ) { Exchange answer = previousExchange . newInstance ( ) ; answer . setExchangeId ( previousExchange . getExchangeId ( ) ) ; answer . getProperties ( ) . putAll ( previousExchange . getProperties ( ) ) ; Message previousOut = previousExchange . getOut ( false ) ; Message in = answer . getIn ( ) ; if ( previousOut != null ) { in . copyFrom ( previousOut ) ; } else { in . copyFrom ( previousExchange . getIn ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "Pipeline" + getProcessors ( ) ; } } 	1	['12', '3', '0', '15', '48', '54', '4', '12', '5', '0.636363636', '239', '1', '0', '0.736842105', '0.242424242', '0', '0', '18.83333333', '8', '1.75', '6']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "sql" ) public class SqlExpression extends ExpressionType { public SqlExpression ( ) { } public SqlExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "sql" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class ExchangeProperty < T > { private static final List < ExchangeProperty < ? > > VALUES = new ArrayList < ExchangeProperty < ? > > ( ) ; private static final Map < String , ExchangeProperty < ? > > LITERAL_MAP = new HashMap < String , ExchangeProperty < ? > > ( ) ; private static final Map < String , ExchangeProperty < ? > > NAME_MAP = new HashMap < String , ExchangeProperty < ? > > ( ) ; private final String literal ; private final String name ; private final Class < T > type ; public ExchangeProperty ( String literal , String name , Class < T > type ) { this . literal = literal ; this . name = name ; this . type = type ; register ( this ) ; } public String literal ( ) { return literal ; } public String name ( ) { return name ; } public Class < T > type ( ) { return type ; } public T get ( Exchange exchange ) { return exchange . getProperty ( name , type ) ; } public static ExchangeProperty < ? > get ( String literal ) { return LITERAL_MAP . get ( literal ) ; } public static ExchangeProperty < ? > getByName ( String name ) { return NAME_MAP . get ( name ) ; } public T set ( Exchange exchange , T value ) { T oldValue = get ( exchange ) ; exchange . setProperty ( name , value ) ; return oldValue ; } public T remove ( Exchange exchange ) { T oldValue = get ( exchange ) ; exchange . removeProperty ( name ) ; return oldValue ; } @ Override public String toString ( ) { return type ( ) . getCanonicalName ( ) + " " + name + " (" + literal ( ) + ")" ; } public static synchronized void register ( ExchangeProperty < ? > property ) { ExchangeProperty < ? > existingProperty = LITERAL_MAP . get ( property . literal ( ) ) ; if ( existingProperty != null && existingProperty != property ) { throw new RuntimeCamelException ( "An Exchange Property '" + property . literal ( ) + "' has already been registered; its traits are: " + existingProperty . toString ( ) ) ; } VALUES . add ( property ) ; LITERAL_MAP . put ( property . literal ( ) , property ) ; NAME_MAP . put ( property . name ( ) , property ) ; } public static synchronized void deregister ( ExchangeProperty < ? > property ) { if ( property != null ) { VALUES . remove ( property ) ; LITERAL_MAP . remove ( property . literal ( ) ) ; NAME_MAP . put ( property . name ( ) , property ) ; } } public static synchronized void deregister ( String literal ) { ExchangeProperty < ? > property = LITERAL_MAP . get ( literal ) ; if ( property != null ) { VALUES . remove ( property ) ; LITERAL_MAP . remove ( property . literal ( ) ) ; NAME_MAP . put ( property . name ( ) , property ) ; } } public static synchronized ExchangeProperty < ? > [ ] values ( ) { return VALUES . toArray ( new ExchangeProperty [ 0 ] ) ; } } 	1	['15', '1', '0', '5', '32', '33', '3', '2', '14', '0.595238095', '210', '1', '0', '0', '0.226190476', '0', '0', '12.6', '3', '1.1333', '1']
package org . apache . camel . osgi ; import org . apache . camel . impl . converter . AnnotationTypeConverterLoader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . osgi . framework . BundleContext ; public class OsgiAnnotationTypeConverterLoader extends AnnotationTypeConverterLoader { private static final transient Log LOG = LogFactory . getLog ( OsgiAnnotationTypeConverterLoader . class ) ; public OsgiAnnotationTypeConverterLoader ( BundleContext context ) { super ( new OsgiResolverUtil ( context ) ) ; } protected String [ ] findPackageNames ( ) { return Activator . findTypeConverterPackageNames ( ) ; } } 	0	['3', '2', '0', '8', '7', '3', '1', '7', '1', '1', '17', '1', '0', '0.875', '0.75', '1', '1', '4.333333333', '1', '0.3333', '0']
package org . apache . camel . processor ; import java . util . List ; import org . apache . camel . Processor ; public class CatchProcessor extends DelegateProcessor { private List < Class > exceptions ; public CatchProcessor ( List < Class > exceptions , Processor processor ) { super ( processor ) ; this . exceptions = exceptions ; } @ Override public String toString ( ) { return "Catch[" + exceptions + " -> " + getProcessor ( ) + "]" ; } public boolean catches ( Throwable e ) { for ( Class type : exceptions ) { if ( type . isInstance ( e ) ) { return true ; } } return false ; } public List < Class > getExceptions ( ) { return exceptions ; } } 	1	['4', '3', '0', '6', '14', '0', '4', '2', '4', '0', '52', '1', '0', '0.88', '0.4375', '0', '0', '11.75', '2', '1', '4']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface Consume { String uri ( ) default "" ; String ref ( ) default "" ; } 	0	['2', '1', '0', '1', '2', '1', '1', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; public class CollectionStringBuffer { private StringBuffer buffer = new StringBuffer ( ) ; private String separator ; private boolean first = true ; public CollectionStringBuffer ( ) { this ( ", " ) ; } public CollectionStringBuffer ( String separator ) { this . separator = separator ; } @ Override public String toString ( ) { return buffer . toString ( ) ; } public void append ( Object value ) { if ( first ) { first = false ; } else { buffer . append ( separator ) ; } buffer . append ( value ) ; } public String getSeparator ( ) { return separator ; } public void setSeparator ( String separator ) { this . separator = separator ; } } 	1	['6', '1', '0', '6', '11', '0', '6', '0', '6', '0.4', '57', '1', '0', '0', '0.5', '0', '0', '8', '2', '0.8333', '1']
package org . apache . camel . impl ; import java . io . ByteArrayOutputStream ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . zip . Deflater ; import java . util . zip . DeflaterOutputStream ; import java . util . zip . InflaterInputStream ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; public class ZipDataFormat implements DataFormat { private int compressionLevel ; public ZipDataFormat ( ) { this . compressionLevel = Deflater . BEST_SPEED ; } public ZipDataFormat ( int compressionLevel ) { this . compressionLevel = compressionLevel ; } public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws Exception { InputStream is = exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( InputStream . class , graph ) ; if ( is == null ) { throw new IllegalArgumentException ( "Cannot get the inputstream for ZipDataFormat mashalling" ) ; } DeflaterOutputStream zipOutput = new DeflaterOutputStream ( stream , new Deflater ( compressionLevel ) ) ; try { IOConverter . copy ( is , zipOutput ) ; } finally { zipOutput . close ( ) ; } } public Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception { InputStream is = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; InflaterInputStream unzipInput = new InflaterInputStream ( is ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; IOConverter . copy ( unzipInput , bos ) ; return bos . toByteArray ( ) ; } } 	0	['4', '1', '0', '7', '17', '0', '1', '6', '4', '0.333333333', '74', '1', '0', '0', '0.416666667', '0', '0', '17.25', '1', '0.5', '0']
package org . apache . camel . model . dataformat ; import java . io . InputStream ; import java . io . OutputStream ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . Exchange ; import org . apache . camel . model . IdentifiedType ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; @ XmlType ( name = "dataFormatType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DataFormatType extends IdentifiedType implements DataFormat { @ XmlTransient private DataFormat dataFormat ; @ XmlTransient private String dataFormatTypeName ; public DataFormatType ( ) { } public DataFormatType ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } protected DataFormatType ( String dataFormatTypeName ) { this . dataFormatTypeName = dataFormatTypeName ; } public static DataFormat getDataFormat ( RouteContext routeContext , DataFormatType type , String ref ) { if ( type == null ) { notNull ( ref , "ref or dataFormatType" ) ; DataFormat dataFormat = routeContext . lookup ( ref , DataFormat . class ) ; if ( dataFormat == null ) { dataFormat = routeContext . getDataFormat ( ref ) ; } if ( dataFormat instanceof DataFormatType ) { type = ( DataFormatType ) dataFormat ; } else { return dataFormat ; } } return type . getDataFormat ( routeContext ) ; } public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws Exception { ObjectHelper . notNull ( dataFormat , "dataFormat" ) ; dataFormat . marshal ( exchange , graph , stream ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception { ObjectHelper . notNull ( dataFormat , "dataFormat" ) ; return dataFormat . unmarshal ( exchange , stream ) ; } public DataFormat getDataFormat ( RouteContext routeContext ) { if ( dataFormat == null ) { dataFormat = createDataFormat ( routeContext ) ; ObjectHelper . notNull ( dataFormat , "dataFormat" ) ; configureDataFormat ( dataFormat ) ; } return dataFormat ; } protected DataFormat createDataFormat ( RouteContext routeContext ) { if ( dataFormatTypeName != null ) { Class type = ObjectHelper . loadClass ( dataFormatTypeName , getClass ( ) . getClassLoader ( ) ) ; if ( type == null ) { throw new IllegalArgumentException ( "The class " + dataFormatTypeName + " is not on the classpath! Cannot use the dataFormat " + this ) ; } return ( DataFormat ) ObjectHelper . newInstance ( type ) ; } return null ; } protected void configureDataFormat ( DataFormat dataFormat ) { } protected void setProperty ( Object bean , String name , Object value ) { try { IntrospectionSupport . setProperty ( bean , name , value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Failed to set property " + name + " on " + bean + ". Reason: " + e , e ) ; } } } 	1	['10', '2', '12', '24', '27', '31', '19', '6', '6', '0.666666667', '162', '1', '1', '0.222222222', '0.266666667', '0', '0', '15', '4', '1.3', '1']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . processor . DelegateProcessor ; @ XmlRootElement ( name = "routes" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RoutesType extends OptionalIdentifiedType < RoutesType > implements RouteContainer { @ XmlAttribute private Boolean inheritErrorHandlerFlag ; @ XmlElementRef private List < RouteType > routes = new ArrayList < RouteType > ( ) ; @ XmlElementRef private List < ServiceActivationType > activations = new ArrayList < ServiceActivationType > ( ) ; @ XmlTransient private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlTransient private List < InterceptType > intercepts = new ArrayList < InterceptType > ( ) ; @ XmlTransient private List < ExceptionType > exceptions = new ArrayList < ExceptionType > ( ) ; @ XmlTransient private CamelContext camelContext ; @ XmlTransient private ErrorHandlerBuilder errorHandlerBuilder ; @ Override public String toString ( ) { return "Routes: " + routes ; } public List < RouteType > getRoutes ( ) { return routes ; } public void setRoutes ( List < RouteType > routes ) { this . routes = routes ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < InterceptType > getIntercepts ( ) { return intercepts ; } public void setIntercepts ( List < InterceptType > intercepts ) { this . intercepts = intercepts ; } public List < ExceptionType > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < ExceptionType > exceptions ) { this . exceptions = exceptions ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public boolean isInheritErrorHandler ( ) { return ProcessorType . isInheritErrorHandler ( getInheritErrorHandlerFlag ( ) ) ; } public Boolean getInheritErrorHandlerFlag ( ) { return inheritErrorHandlerFlag ; } public void setInheritErrorHandlerFlag ( Boolean inheritErrorHandlerFlag ) { this . inheritErrorHandlerFlag = inheritErrorHandlerFlag ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { return errorHandlerBuilder ; } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } public RouteType route ( ) { RouteType route = createRoute ( ) ; return route ( route ) ; } public RouteType from ( String uri ) { RouteType route = createRoute ( ) ; route . from ( uri ) ; return route ( route ) ; } public RouteType from ( Endpoint endpoint ) { RouteType route = createRoute ( ) ; route . from ( endpoint ) ; return route ( route ) ; } public RouteType route ( RouteType route ) { route . setCamelContext ( getCamelContext ( ) ) ; route . setInheritErrorHandlerFlag ( getInheritErrorHandlerFlag ( ) ) ; List < InterceptorType > list = getInterceptors ( ) ; for ( InterceptorType interceptorType : list ) { route . addInterceptor ( interceptorType ) ; } List < InterceptType > intercepts = getIntercepts ( ) ; for ( InterceptType intercept : intercepts ) { InterceptType proxy = intercept . createProxy ( ) ; route . addOutput ( proxy ) ; route . pushBlock ( proxy . getProceed ( ) ) ; } route . getOutputs ( ) . addAll ( getExceptions ( ) ) ; getRoutes ( ) . add ( route ) ; return route ; } public RoutesType intercept ( DelegateProcessor interceptor ) { getInterceptors ( ) . add ( new InterceptorRef ( interceptor ) ) ; return this ; } public InterceptType intercept ( ) { InterceptType answer = new InterceptType ( ) ; getIntercepts ( ) . add ( answer ) ; return answer ; } public ChoiceType intercept ( Predicate predicate ) { InterceptType answer = new InterceptType ( ) ; getIntercepts ( ) . add ( answer ) ; return answer . when ( predicate ) ; } public ExceptionType onException ( Class exceptionType ) { ExceptionType answer = new ExceptionType ( exceptionType ) ; getExceptions ( ) . add ( answer ) ; return answer ; } protected RouteType createRoute ( ) { RouteType route = new RouteType ( ) ; ErrorHandlerBuilder handler = getErrorHandlerBuilder ( ) ; if ( isInheritErrorHandler ( ) && handler != null ) { route . setErrorHandlerBuilderIfNull ( handler ) ; } return route ; } } 	0	['26', '2', '0', '17', '54', '289', '1', '16', '25', '0.875', '279', '1', '2', '0.324324324', '0.136363636', '0', '0', '9.423076923', '3', '1.1154', '0']
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . util . ObjectHelper ; public class BytesSource extends StreamSource { private byte [ ] data ; public BytesSource ( byte [ ] data ) { ObjectHelper . notNull ( data , "data" ) ; this . data = data ; } public BytesSource ( byte [ ] data , String systemId ) { ObjectHelper . notNull ( data , "data" ) ; this . data = data ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { return new ByteArrayInputStream ( data ) ; } public Reader getReader ( ) { return new InputStreamReader ( getInputStream ( ) ) ; } public byte [ ] getData ( ) { return data ; } public String toString ( ) { return "BytesSource[" + new String ( data ) + "]" ; } } 	1	['6', '2', '0', '4', '15', '0', '3', '1', '6', '0', '58', '1', '0', '0.692307692', '0.5', '0', '0', '8.5', '1', '0.6667', '1']
package org . apache . camel . component . cxf . invoker ; import javax . xml . ws . soap . SOAPBinding ; import org . apache . cxf . BusException ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . endpoint . ClientImpl ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . endpoint . EndpointException ; import org . apache . cxf . frontend . ClientFactoryBean ; import org . apache . cxf . jaxws . binding . soap . JaxWsSoapBindingConfiguration ; import org . apache . cxf . jaxws . support . JaxWsServiceFactoryBean ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; import org . apache . cxf . service . factory . ServiceConstructionException ; public class CxfClientFactoryBean extends ClientFactoryBean { private boolean isJSR181Enabled ; public CxfClientFactoryBean ( ) { super ( ) ; } public void setJSR181Enabled ( boolean enabled ) { if ( enabled ) { setServiceFactory ( new JaxWsServiceFactoryBean ( ) ) ; } else { setServiceFactory ( new ReflectionServiceFactoryBean ( ) ) ; } isJSR181Enabled = enabled ; } @ Override public void setBindingId ( String bind ) { super . setBindingId ( bind ) ; if ( isJSR181Enabled ) { if ( SOAPBinding . SOAP11HTTP_BINDING . equals ( bind ) || SOAPBinding . SOAP12HTTP_BINDING . equals ( bind ) ) { setBindingConfig ( new JaxWsSoapBindingConfiguration ( ( JaxWsServiceFactoryBean ) getServiceFactory ( ) ) ) ; } else if ( SOAPBinding . SOAP11HTTP_MTOM_BINDING . equals ( bind ) || SOAPBinding . SOAP12HTTP_MTOM_BINDING . equals ( bind ) ) { setBindingConfig ( new JaxWsSoapBindingConfiguration ( ( JaxWsServiceFactoryBean ) getServiceFactory ( ) ) ) ; ( ( JaxWsSoapBindingConfiguration ) getBindingConfig ( ) ) . setMtomEnabled ( true ) ; } } } protected void createClient ( Endpoint ep ) { CxfClient client = new CxfClient ( getBus ( ) , ep ) ; setClient ( client ) ; } } 	0	['4', '0', '0', '10', '18', '4', '1', '9', '3', '0.666666667', '81', '1', '0', '0', '0.4375', '0', '0', '19', '6', '2.25', '0']
package org . apache . camel . processor . interceptor ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . InterceptStrategy ; public class Delayer implements InterceptStrategy { private boolean enabled = true ; private long delay ; public Delayer ( ) { } public Delayer ( long delay ) { this . delay = delay ; } public static DelayInterceptor getDelayer ( CamelContext context ) { if ( context instanceof DefaultCamelContext ) { DefaultCamelContext defaultCamelContext = ( DefaultCamelContext ) context ; List < InterceptStrategy > list = defaultCamelContext . getInterceptStrategies ( ) ; for ( InterceptStrategy interceptStrategy : list ) { if ( interceptStrategy instanceof DelayInterceptor ) { return ( DelayInterceptor ) interceptStrategy ; } } } return null ; } public Processor wrapProcessorInInterceptors ( ProcessorType processorType , Processor target ) throws Exception { DelayInterceptor delayer = new DelayInterceptor ( processorType , target , this ) ; return delayer ; } public boolean isEnabled ( ) { return enabled ; } public void setEnabled ( boolean enabled ) { this . enabled = enabled ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } } 	1	['8', '1', '0', '7', '14', '10', '3', '6', '8', '0.642857143', '76', '1', '0', '0', '0.270833333', '0', '0', '8.25', '3', '1', '2']
package org . apache . camel . impl . converter ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class PropertyEditorTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value == null ) { return null ; } if ( value . getClass ( ) == String . class ) { if ( toType == String . class ) { return ObjectHelper . cast ( toType , value ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( toType ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return ObjectHelper . cast ( toType , editor . getValue ( ) ) ; } } else if ( toType == String . class ) { PropertyEditor editor = PropertyEditorManager . findEditor ( value . getClass ( ) ) ; if ( editor != null ) { editor . setValue ( value ) ; return ObjectHelper . cast ( toType , editor . getAsText ( ) ) ; } } return null ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return convertTo ( type , value ) ; } } 	0	['3', '1', '0', '4', '12', '3', '1', '3', '3', '2', '60', '0', '0', '0', '0.666666667', '0', '0', '19', '6', '2.3333', '0']
package org . apache . camel . util ; import java . io . UnsupportedEncodingException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class URISupport { public static class CompositeData { public String host ; String scheme ; String path ; URI components [ ] ; Map parameters ; String fragment ; public URI [ ] getComponents ( ) { return components ; } public String getFragment ( ) { return fragment ; } public Map getParameters ( ) { return parameters ; } public String getScheme ( ) { return scheme ; } public String getPath ( ) { return path ; } public String getHost ( ) { return host ; } public URI toURI ( ) throws URISyntaxException { StringBuffer sb = new StringBuffer ( ) ; if ( scheme != null ) { sb . append ( scheme ) ; sb . append ( ':' ) ; } if ( host != null && host . length ( ) != 0 ) { sb . append ( host ) ; } else { sb . append ( '(' ) ; for ( int i = 0 ; i < components . length ; i ++ ) { if ( i != 0 ) { sb . append ( ',' ) ; } sb . append ( components [ i ] . toString ( ) ) ; } sb . append ( ')' ) ; } if ( path != null ) { sb . append ( '/' ) ; sb . append ( path ) ; } if ( ! parameters . isEmpty ( ) ) { sb . append ( "?" ) ; sb . append ( createQueryString ( parameters ) ) ; } if ( fragment != null ) { sb . append ( "#" ) ; sb . append ( fragment ) ; } return new URI ( sb . toString ( ) ) ; } } public static Map parseQuery ( String uri ) throws URISyntaxException { try { Map rc = new HashMap ( ) ; if ( uri != null ) { String [ ] parameters = uri . split ( "&" ) ; for ( String parameter : parameters ) { int p = parameter . indexOf ( "=" ) ; if ( p >= 0 ) { String name = URLDecoder . decode ( parameter . substring ( 0 , p ) , "UTF-8" ) ; String value = URLDecoder . decode ( parameter . substring ( p + 1 ) , "UTF-8" ) ; rc . put ( name , value ) ; } else { rc . put ( parameter , null ) ; } } } return rc ; } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static Map parseParameters ( URI uri ) throws URISyntaxException { String query = uri . getQuery ( ) ; if ( query == null ) { String schemeSpecificPart = uri . getSchemeSpecificPart ( ) ; int idx = schemeSpecificPart . lastIndexOf ( '?' ) ; if ( idx < 0 ) { return Collections . EMPTY_MAP ; } else { query = schemeSpecificPart . substring ( idx + 1 ) ; } } else { query = stripPrefix ( query , "?" ) ; } return parseQuery ( query ) ; } public static URI removeQuery ( URI uri ) throws URISyntaxException { return createURIWithQuery ( uri , null ) ; } public static URI createURIWithQuery ( URI uri , String query ) throws URISyntaxException { return new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) , query , uri . getFragment ( ) ) ; } public static CompositeData parseComposite ( URI uri ) throws URISyntaxException { CompositeData rc = new CompositeData ( ) ; rc . scheme = uri . getScheme ( ) ; String ssp = stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) . trim ( ) ; parseComposite ( uri , rc , ssp ) ; rc . fragment = uri . getFragment ( ) ; return rc ; } private static void parseComposite ( URI uri , CompositeData rc , String ssp ) throws URISyntaxException { String componentString ; String params ; if ( ! checkParenthesis ( ssp ) ) { throw new URISyntaxException ( uri . toString ( ) , "Not a matching number of '(' and ')' parenthesis" ) ; } int p ; int intialParen = ssp . indexOf ( "(" ) ; if ( intialParen == 0 ) { rc . host = ssp . substring ( 0 , intialParen ) ; p = rc . host . indexOf ( "/" ) ; if ( p >= 0 ) { rc . path = rc . host . substring ( p ) ; rc . host = rc . host . substring ( 0 , p ) ; } p = ssp . lastIndexOf ( ")" ) ; componentString = ssp . substring ( intialParen + 1 , p ) ; params = ssp . substring ( p + 1 ) . trim ( ) ; } else { componentString = ssp ; params = "" ; } String components [ ] = splitComponents ( componentString ) ; rc . components = new URI [ components . length ] ; for ( int i = 0 ; i < components . length ; i ++ ) { rc . components [ i ] = new URI ( components [ i ] . trim ( ) ) ; } p = params . indexOf ( "?" ) ; if ( p >= 0 ) { if ( p > 0 ) { rc . path = stripPrefix ( params . substring ( 0 , p ) , "/" ) ; } rc . parameters = parseQuery ( params . substring ( p + 1 ) ) ; } else { if ( params . length ( ) > 0 ) { rc . path = stripPrefix ( params , "/" ) ; } rc . parameters = Collections . EMPTY_MAP ; } } private static String [ ] splitComponents ( String str ) { ArrayList l = new ArrayList ( ) ; int last = 0 ; int depth = 0 ; char chars [ ] = str . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '(' : depth ++ ; break ; case ')' : depth -- ; break ; case ',' : if ( depth == 0 ) { String s = str . substring ( last , i ) ; l . add ( s ) ; last = i + 1 ; } break ; default : } } String s = str . substring ( last ) ; if ( s . length ( ) != 0 ) { l . add ( s ) ; } String rc [ ] = new String [ l . size ( ) ] ; l . toArray ( rc ) ; return rc ; } public static String stripPrefix ( String value , String prefix ) { if ( value . startsWith ( prefix ) ) { return value . substring ( prefix . length ( ) ) ; } return value ; } public static URI stripScheme ( URI uri ) throws URISyntaxException { return new URI ( stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) ) ; } public static String createQueryString ( Map options ) throws URISyntaxException { try { if ( options . size ( ) > 0 ) { StringBuffer rc = new StringBuffer ( ) ; boolean first = true ; for ( Iterator iter = options . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { if ( first ) { first = false ; } else { rc . append ( "&" ) ; } String key = ( String ) iter . next ( ) ; String value = ( String ) options . get ( key ) ; rc . append ( URLEncoder . encode ( key , "UTF-8" ) ) ; rc . append ( "=" ) ; rc . append ( URLEncoder . encode ( value , "UTF-8" ) ) ; } return rc . toString ( ) ; } else { return "" ; } } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static URI createRemainingURI ( URI originalURI , Map params ) throws URISyntaxException { String s = createQueryString ( params ) ; if ( s . length ( ) == 0 ) { s = null ; } return createURIWithQuery ( originalURI , s ) ; } public static URI changeScheme ( URI bindAddr , String scheme ) throws URISyntaxException { return new URI ( scheme , bindAddr . getUserInfo ( ) , bindAddr . getHost ( ) , bindAddr . getPort ( ) , bindAddr . getPath ( ) , bindAddr . getQuery ( ) , bindAddr . getFragment ( ) ) ; } public static boolean checkParenthesis ( String str ) { boolean result = true ; if ( str != null ) { int open = 0 ; int closed = 0 ; int i = 0 ; while ( ( i = str . indexOf ( '(' , i ) ) >= 0 ) { i ++ ; open ++ ; } i = 0 ; while ( ( i = str . indexOf ( ')' , i ) ) >= 0 ) { i ++ ; closed ++ ; } result = open == closed ; } return result ; } @ Deprecated public int indexOfParenthesisMatch ( String str ) { int result = - 1 ; return result ; } } 	1	['15', '1', '0', '6', '59', '105', '6', '1', '13', '2', '519', '0', '0', '0', '0.28', '0', '0', '33.6', '5', '1.5333', '1']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class RuntimeJmsException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeJmsException ( String message , JMSException cause ) { super ( message , cause ) ; } } 	0	['1', '4', '3', '4', '2', '0', '4', '0', '1', '2', '7', '1', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class RoundRobinLoadBalancer extends QueueLoadBalancer { private int counter = - 1 ; protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { int size = processors . size ( ) ; if ( ++ counter >= size ) { counter = 0 ; } return processors . get ( counter ) ; } } 	1	['2', '4', '0', '7', '5', '0', '4', '3', '1', '0', '30', '1', '0', '0.956521739', '0.666666667', '1', '1', '13.5', '2', '1', '1']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "setHeader" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SetHeaderType extends ExpressionNode { @ XmlAttribute ( required = true ) private String headerName ; public SetHeaderType ( ) { } public SetHeaderType ( String headerName , ExpressionType expression ) { super ( expression ) ; setHeaderName ( headerName ) ; } public SetHeaderType ( String headerName , Expression expression ) { super ( expression ) ; setHeaderName ( headerName ) ; } public SetHeaderType ( String headerName , String value ) { super ( ExpressionBuilder . constantExpression ( value ) ) ; setHeaderName ( headerName ) ; } @ Override public String toString ( ) { return "SetHeader[" + getHeaderName ( ) + ", " + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "setHeader" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ObjectHelper . notEmpty ( headerName , "headerName" ) ; Expression expr = getExpression ( ) . createExpression ( routeContext ) ; return ProcessorBuilder . setHeader ( getHeaderName ( ) , expr ) ; } public void setHeaderName ( String headerName ) { this . headerName = headerName ; } public String getHeaderName ( ) { return headerName ; } } 	0	['9', '4', '0', '9', '21', '30', '1', '8', '9', '0.25', '75', '1', '0', '0.973544974', '0.355555556', '2', '3', '7.222222222', '1', '0.5556', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class ProceedProcessor implements Processor { private final Interceptor interceptor ; public ProceedProcessor ( Interceptor interceptor ) { this . interceptor = interceptor ; } public String toString ( ) { return "Proceed[" + interceptor + "]" ; } public void process ( Exchange exchange ) throws Exception { interceptor . proceed ( exchange ) ; } } 	1	['3', '1', '0', '4', '9', '0', '1', '3', '3', '0', '27', '1', '1', '0', '0.555555556', '0', '0', '7.666666667', '1', '0.6667', '1']
package org . apache . camel . component . restlet ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . restlet . Restlet ; import org . restlet . data . Request ; import org . restlet . data . Response ; public class RestletConsumer extends DefaultConsumer { private static final Log LOG = LogFactory . getLog ( RestletConsumer . class ) ; private Restlet restlet ; public RestletConsumer ( Endpoint endpoint , Processor processor ) throws Exception { super ( endpoint , processor ) ; restlet = new Restlet ( ) { @ Override public void handle ( Request request , Response response ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Consumer restlet handle request method: " + request . getMethod ( ) ) ; } try { Exchange exchange = getEndpoint ( ) . createExchange ( ) ; RestletBinding binding = ( ( RestletEndpoint ) getEndpoint ( ) ) . getRestletBinding ( ) ; binding . populateExchangeFromRestletRequest ( request , exchange ) ; getProcessor ( ) . process ( exchange ) ; binding . populateRestletResponseFromExchange ( exchange , response ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; ( ( RestletEndpoint ) getEndpoint ( ) ) . connect ( this ) ; } @ Override public void doStop ( ) throws Exception { ( ( RestletEndpoint ) getEndpoint ( ) ) . disconnect ( this ) ; super . doStop ( ) ; } public Restlet getRestlet ( ) { return restlet ; } } 	0	['6', '3', '0', '9', '14', '11', '3', '8', '3', '0.8', '44', '1', '0', '0.851851852', '0.4', '1', '1', '6', '1', '0.6667', '0']
package org . apache . camel . util . concurrent ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . AbstractQueuedSynchronizer ; public class CountingLatch { @ SuppressWarnings ( "serial" ) private final class Sync extends AbstractQueuedSynchronizer { private Sync ( ) { super ( ) ; } int getCount ( ) { return getState ( ) ; } public int tryAcquireShared ( int acquires ) { return getState ( ) == 0 ? 1 : - 1 ; } public boolean tryReleaseShared ( int delta ) { for ( ; ; ) { int c = getState ( ) ; int nextc = c + delta ; if ( compareAndSetState ( c , nextc ) ) { return nextc == 0 ; } } } } private final Sync sync ; public CountingLatch ( ) { super ( ) ; this . sync = new Sync ( ) ; } public int getCount ( ) { return sync . getCount ( ) ; } public void increment ( ) { sync . releaseShared ( + 1 ) ; } public void decrement ( ) { sync . releaseShared ( - 1 ) ; } public void await ( ) throws InterruptedException { sync . acquireSharedInterruptibly ( 1 ) ; } public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { return sync . tryAcquireSharedNanos ( 1 , unit . toNanos ( timeout ) ) ; } } 	1	['6', '1', '0', '4', '13', '0', '3', '2', '6', '0', '46', '1', '1', '0', '0.444444444', '0', '0', '6.5', '1', '0.8333', '1']
