package org . apache . xalan . xsltc . runtime . output ; import java . util . Stack ; import java . io . IOException ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . xml . sax . SAXException ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; public class SAXXMLOutput extends SAXOutput { private static final char [ ] BEGCDATA = "<![CDATA[" . toCharArray ( ) ; private static final char [ ] ENDCDATA = "]]>" . toCharArray ( ) ; private static final char [ ] CNTCDATA = "]]]]><![CDATA[>" . toCharArray ( ) ; public SAXXMLOutput ( ContentHandler handler , String encoding ) throws IOException { super ( handler , encoding ) ; initCDATA ( ) ; initNamespaces ( ) ; } public SAXXMLOutput ( ContentHandler handler , LexicalHandler lex , String encoding ) throws IOException { super ( handler , lex , encoding ) ; initCDATA ( ) ; initNamespaces ( ) ; } public void endDocument ( ) throws TransletException { try { if ( _startTagOpen ) { closeStartTag ( ) ; } else if ( _cdataTagOpen ) { closeCDATA ( ) ; } _saxHandler . endDocument ( ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void startElement ( String elementName ) throws TransletException { try { if ( _startTagOpen ) { closeStartTag ( ) ; } else if ( _cdataTagOpen ) { closeCDATA ( ) ; } if ( _firstElement ) { if ( _doctypeSystem != null ) { _lexHandler . startDTD ( elementName , _doctypePublic , _doctypeSystem ) ; } _firstElement = false ; } _depth ++ ; _elementName = elementName ; _attributes . clear ( ) ; _startTagOpen = true ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void attribute ( String name , final String value ) throws TransletException { if ( _startTagOpen ) { final String patchedName = patchName ( name ) ; final String localName = getLocalName ( patchedName ) ; final String uri = getNamespaceURI ( patchedName , false ) ; final int index = ( localName == null ) ? _attributes . getIndex ( name ) : _attributes . getIndex ( uri , localName ) ; if ( index >= 0 ) { _attributes . setAttribute ( index , uri , localName , patchedName , "CDATA" , value ) ; } else { _attributes . addAttribute ( uri , localName , patchedName , "CDATA" , value ) ; } } } public void characters ( char [ ] ch , int off , int len ) throws TransletException { try { if ( _startTagOpen ) { closeStartTag ( ) ; } Integer I = ( Integer ) _cdataStack . peek ( ) ; if ( ( I . intValue ( ) == _depth ) && ( ! _cdataTagOpen ) ) { startCDATA ( ch , off , len ) ; } else { _saxHandler . characters ( ch , off , len ) ; } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void endElement ( String elementName ) throws TransletException { try { if ( _startTagOpen ) { closeStartTag ( ) ; } else if ( _cdataTagOpen ) { closeCDATA ( ) ; } _saxHandler . endElement ( getNamespaceURI ( elementName , true ) , getLocalName ( elementName ) , elementName ) ; popNamespaces ( ) ; if ( ( ( Integer ) _cdataStack . peek ( ) ) . intValue ( ) == _depth ) { _cdataStack . pop ( ) ; } _depth -- ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void namespace ( final String prefix , final String uri ) throws TransletException { if ( _startTagOpen ) { pushNamespace ( prefix , uri ) ; } else { if ( ( prefix == EMPTYSTRING ) && ( uri == EMPTYSTRING ) ) return ; BasisLibrary . runTimeError ( BasisLibrary . STRAY_NAMESPACE_ERR , prefix , uri ) ; } } public void processingInstruction ( String target , String data ) throws TransletException { try { if ( _startTagOpen ) { closeStartTag ( ) ; } else if ( _cdataTagOpen ) { closeCDATA ( ) ; } _saxHandler . processingInstruction ( target , data ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } protected boolean pushNamespace ( String prefix , String uri ) { try { if ( super . pushNamespace ( prefix , uri ) ) { _saxHandler . startPrefixMapping ( prefix , uri ) ; return true ; } } catch ( SAXException e ) { } return false ; } protected boolean popNamespace ( String prefix ) { try { if ( super . popNamespace ( prefix ) ) { _saxHandler . endPrefixMapping ( prefix ) ; return true ; } } catch ( SAXException e ) { } return false ; } protected void closeStartTag ( ) throws TransletException { try { _startTagOpen = false ; final String localName = getLocalName ( _elementName ) ; final String uri = getNamespaceURI ( _elementName , true ) ; _saxHandler . startElement ( uri , localName , _elementName , _attributes ) ; if ( _cdata != null ) { final StringBuffer expandedName = ( uri == EMPTYSTRING ) ? new StringBuffer ( _elementName ) : new StringBuffer ( uri ) . append ( ':' ) . append ( localName ) ; if ( _cdata . containsKey ( expandedName . toString ( ) ) ) { _cdataStack . push ( new Integer ( _depth ) ) ; } } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void startCDATA ( ) throws TransletException { try { _saxHandler . characters ( BEGCDATA , 0 , BEGCDATA . length ) ; _cdataTagOpen = true ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void closeCDATA ( ) throws TransletException { try { _saxHandler . characters ( ENDCDATA , 0 , ENDCDATA . length ) ; _cdataTagOpen = false ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } private void startCDATA ( char [ ] ch , int off , int len ) throws SAXException { final int limit = off + len ; int offset = off ; _saxHandler . characters ( BEGCDATA , 0 , BEGCDATA . length ) ; for ( int i = offset ; i < limit - 2 ; i ++ ) { if ( ch [ i ] == ']' && ch [ i + 1 ] == ']' && ch [ i + 2 ] == '>' ) { _saxHandler . characters ( ch , offset , i - offset ) ; _saxHandler . characters ( CNTCDATA , 0 , CNTCDATA . length ) ; offset = i + 3 ; i += 2 ; } } if ( offset < limit ) { _saxHandler . characters ( ch , offset , limit - offset ) ; } _cdataTagOpen = true ; } } 	0	['16', '3', '0', '6', '52', '112', '1', '5', '11', '0.777777778', '509', '1', '0', '0.74', '0.344444444', '2', '8', '30.625', '1', '0.8125', '0']
package org . apache . xalan . xsltc . runtime ; import java . util . Locale ; import java . util . ResourceBundle ; import java . text . NumberFormat ; import java . text . MessageFormat ; import java . text . FieldPosition ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import org . xml . sax . AttributeList ; import org . apache . xalan . xsltc . * ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . NodeIterator ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xalan . xsltc . dom . DOMAdapter ; import org . apache . xalan . xsltc . dom . MultiDOM ; import org . apache . xalan . xsltc . dom . AbsoluteIterator ; import org . apache . xalan . xsltc . dom . SingletonIterator ; import org . apache . xalan . xsltc . dom . DOMImpl ; import org . apache . xalan . xsltc . dom . DOMBuilder ; import org . apache . xalan . xsltc . dom . StepIterator ; import org . w3c . dom . NodeList ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . DocumentBuilder ; import org . apache . xalan . xsltc . trax . DOM2SAX ; public final class BasisLibrary implements Operators { private final static String EMPTYSTRING = "" ; public static int countF ( NodeIterator iterator ) { return ( iterator . getLast ( ) ) ; } public static double sumF ( NodeIterator iterator , DOM dom ) { try { double result = 0.0 ; int node ; while ( ( node = iterator . next ( ) ) != NodeIterator . END ) { result += Double . parseDouble ( dom . getNodeValue ( node ) ) ; } return result ; } catch ( NumberFormatException e ) { return Double . NaN ; } } public static String stringF ( int node , DOM dom ) { return dom . getNodeValue ( node ) ; } public static String stringF ( Object obj , DOM dom ) { if ( obj instanceof NodeIterator ) { return dom . getNodeValue ( ( ( NodeIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getNodeValue ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else { return obj . toString ( ) ; } } public static String stringF ( Object obj , int node , DOM dom ) { if ( obj instanceof NodeIterator ) { return dom . getNodeValue ( ( ( NodeIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getNodeValue ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else if ( obj instanceof Double ) { Double d = ( Double ) obj ; final String result = d . toString ( ) ; final int length = result . length ( ) ; if ( ( result . charAt ( length - 2 ) == '.' ) && ( result . charAt ( length - 1 ) == '0' ) ) return result . substring ( 0 , length - 2 ) ; else return result ; } else { if ( obj != null ) return obj . toString ( ) ; else return stringF ( node , dom ) ; } } public static double numberF ( int node , DOM dom ) { return stringToReal ( dom . getNodeValue ( node ) ) ; } public static double numberF ( Object obj , DOM dom ) { if ( obj instanceof Double ) { return ( ( Double ) obj ) . doubleValue ( ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . doubleValue ( ) ; } else if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ? 1.0 : 0.0 ; } else if ( obj instanceof String ) { return stringToReal ( ( String ) obj ) ; } else if ( obj instanceof NodeIterator ) { NodeIterator iter = ( NodeIterator ) obj ; return stringToReal ( dom . getNodeValue ( iter . reset ( ) . next ( ) ) ) ; } else if ( obj instanceof Node ) { return stringToReal ( dom . getNodeValue ( ( ( Node ) obj ) . node ) ) ; } else if ( obj instanceof DOM ) { return stringToReal ( ( ( DOM ) obj ) . getStringValue ( ) ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "number()" ) ; return 0.0 ; } } public static boolean booleanF ( Object obj ) { if ( obj instanceof Double ) { final double temp = ( ( Double ) obj ) . doubleValue ( ) ; return temp != 0.0 && ! Double . isNaN ( temp ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . doubleValue ( ) != 0 ; } else if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ; } else if ( obj instanceof String ) { return ! ( ( String ) obj ) . equals ( EMPTYSTRING ) ; } else if ( obj instanceof NodeIterator ) { NodeIterator iter = ( NodeIterator ) obj ; return iter . reset ( ) . next ( ) != NodeIterator . END ; } else if ( obj instanceof Node ) { return true ; } else if ( obj instanceof DOM ) { String temp = ( ( DOM ) obj ) . getStringValue ( ) ; return ! temp . equals ( EMPTYSTRING ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "number()" ) ; } return false ; } public static String substringF ( String value , double start ) { try { final int strlen = value . length ( ) ; int istart = ( int ) Math . round ( start ) - 1 ; if ( Double . isNaN ( start ) ) return ( EMPTYSTRING ) ; if ( istart > strlen ) return ( EMPTYSTRING ) ; if ( istart < 1 ) istart = 0 ; return value . substring ( istart ) ; } catch ( IndexOutOfBoundsException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , "substring()" ) ; return null ; } } public static String substringF ( String value , double start , double length ) { try { final int strlen = value . length ( ) ; int istart = ( int ) Math . round ( start ) - 1 ; int isum = istart + ( int ) Math . round ( length ) ; if ( Double . isInfinite ( length ) ) isum = Integer . MAX_VALUE ; if ( Double . isNaN ( start ) || Double . isNaN ( length ) ) return ( EMPTYSTRING ) ; if ( Double . isInfinite ( start ) ) return ( EMPTYSTRING ) ; if ( istart > strlen ) return ( EMPTYSTRING ) ; if ( isum < 0 ) return ( EMPTYSTRING ) ; if ( istart < 0 ) istart = 0 ; if ( isum > strlen ) return value . substring ( istart ) ; else return value . substring ( istart , isum ) ; } catch ( IndexOutOfBoundsException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , "substring()" ) ; return null ; } } public static String substring_afterF ( String value , String substring ) { final int index = value . indexOf ( substring ) ; if ( index >= 0 ) return value . substring ( index + substring . length ( ) ) ; else return EMPTYSTRING ; } public static String substring_beforeF ( String value , String substring ) { final int index = value . indexOf ( substring ) ; if ( index >= 0 ) return value . substring ( 0 , index ) ; else return EMPTYSTRING ; } public static String translateF ( String value , String from , String to ) { final int tol = to . length ( ) ; final int froml = from . length ( ) ; final int valuel = value . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int j , i = 0 ; i < valuel ; i ++ ) { final char ch = value . charAt ( i ) ; for ( j = 0 ; j < froml ; j ++ ) { if ( ch == from . charAt ( j ) ) { if ( j < tol ) result . append ( to . charAt ( j ) ) ; break ; } } if ( j == froml ) result . append ( ch ) ; } return result . toString ( ) ; } public static String normalize_spaceF ( int node , DOM dom ) { return normalize_spaceF ( dom . getNodeValue ( node ) ) ; } public static String normalize_spaceF ( String value ) { int i = 0 , n = value . length ( ) ; StringBuffer result = new StringBuffer ( ) ; while ( i < n && isWhiteSpace ( value . charAt ( i ) ) ) i ++ ; while ( true ) { while ( i < n && ! isWhiteSpace ( value . charAt ( i ) ) ) { result . append ( value . charAt ( i ++ ) ) ; } if ( i == n ) break ; while ( i < n && isWhiteSpace ( value . charAt ( i ) ) ) { i ++ ; } if ( i < n ) result . append ( ' ' ) ; } return result . toString ( ) ; } public static String generate_idF ( int node ) { if ( node > 0 ) return "N" + node ; else return EMPTYSTRING ; } public static String getLocalName ( String value ) { int idx = value . lastIndexOf ( ':' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; idx = value . lastIndexOf ( '@' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; return ( value ) ; } public static void unresolved_externalF ( String name ) { runTimeError ( EXTERNAL_FUNC_ERR , name ) ; } public static String namespace_uriF ( NodeIterator iter , DOM dom ) { return namespace_uriF ( iter . next ( ) , dom ) ; } public static String system_propertyF ( String name ) { if ( name . equals ( "xsl:version" ) ) return ( "1.0" ) ; if ( name . equals ( "xsl:vendor" ) ) return ( "Apache Software Foundation (Xalan XSLTC)" ) ; if ( name . equals ( "xsl:vendor-url" ) ) return ( "http://xml.apache.org/xalan-j" ) ; runTimeError ( INVALID_ARGUMENT_ERR , name , "system-property()" ) ; return ( EMPTYSTRING ) ; } public static String namespace_uriF ( int node , DOM dom ) { final String value = dom . getNodeName ( node ) ; final int colon = value . lastIndexOf ( ':' ) ; if ( colon >= 0 ) return value . substring ( 0 , colon ) ; else return EMPTYSTRING ; } public static NodeIterator nodesetF ( Object obj ) { if ( obj instanceof DOM ) { final DOMAdapter adapter = ( DOMAdapter ) obj ; return new SingletonIterator ( DOM . ROOTNODE | adapter . getMultiDOMMask ( ) , true ) ; } else if ( obj instanceof NodeIterator ) { return ( NodeIterator ) obj ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "node-set" , className ) ; return null ; } } private static boolean isWhiteSpace ( char ch ) { return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' ; } private static boolean compareStrings ( String lstring , String rstring , int op , DOM dom ) { switch ( op ) { case EQ : return lstring . equals ( rstring ) ; case NE : return ! lstring . equals ( rstring ) ; case GT : return numberF ( lstring , dom ) > numberF ( rstring , dom ) ; case LT : return numberF ( lstring , dom ) < numberF ( rstring , dom ) ; case GE : return numberF ( lstring , dom ) >= numberF ( rstring , dom ) ; case LE : return numberF ( lstring , dom ) <= numberF ( rstring , dom ) ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; return false ; } } public static boolean compare ( NodeIterator left , NodeIterator right , int op , int node , DOM dom ) { int lnode ; left . reset ( ) ; while ( ( lnode = left . next ( ) ) != NodeIterator . END ) { final String lvalue = dom . getNodeValue ( lnode ) ; int rnode ; right . reset ( ) ; while ( ( rnode = right . next ( ) ) != NodeIterator . END ) { if ( compareStrings ( lvalue , dom . getNodeValue ( rnode ) , op , dom ) ) { return true ; } } } return false ; } public static boolean compare ( int node , NodeIterator nodeSet , int op , DOM dom ) { final String lvalue = dom . getNodeValue ( node ) ; int rnode ; while ( ( rnode = nodeSet . next ( ) ) != NodeIterator . END ) { if ( compareStrings ( lvalue , dom . getNodeValue ( rnode ) , op , dom ) ) { return true ; } } return false ; } public static boolean compare ( int node , NodeIterator iterator , int op , int dummy , DOM dom ) { int rnode ; String value ; switch ( op ) { case EQ : value = dom . getNodeValue ( node ) ; while ( ( rnode = iterator . next ( ) ) != NodeIterator . END ) if ( value . equals ( dom . getNodeValue ( rnode ) ) ) return true ; break ; case NE : value = dom . getNodeValue ( node ) ; while ( ( rnode = iterator . next ( ) ) != NodeIterator . END ) if ( ! value . equals ( dom . getNodeValue ( rnode ) ) ) return true ; break ; case LT : while ( ( rnode = iterator . next ( ) ) != NodeIterator . END ) if ( rnode > node ) return true ; break ; case GT : while ( ( rnode = iterator . next ( ) ) != NodeIterator . END ) if ( rnode < node ) return true ; break ; } return ( false ) ; } public static boolean compare ( NodeIterator left , final double rnumber , final int op , final int node , DOM dom ) { return ( compare ( left , rnumber , op , dom ) ) ; } public static boolean compare ( NodeIterator left , final double rnumber , final int op , DOM dom ) { int node ; switch ( op ) { case EQ : while ( ( node = left . next ( ) ) != NodeIterator . END ) { if ( numberF ( dom . getNodeValue ( node ) , dom ) == rnumber ) return true ; } break ; case NE : while ( ( node = left . next ( ) ) != NodeIterator . END ) { if ( numberF ( dom . getNodeValue ( node ) , dom ) != rnumber ) return true ; } break ; case GT : while ( ( node = left . next ( ) ) != NodeIterator . END ) { if ( numberF ( dom . getNodeValue ( node ) , dom ) > rnumber ) return true ; } break ; case LT : while ( ( node = left . next ( ) ) != NodeIterator . END ) { if ( numberF ( dom . getNodeValue ( node ) , dom ) < rnumber ) return true ; } break ; case GE : while ( ( node = left . next ( ) ) != NodeIterator . END ) { if ( numberF ( dom . getNodeValue ( node ) , dom ) >= rnumber ) return true ; } break ; case LE : while ( ( node = left . next ( ) ) != NodeIterator . END ) { if ( numberF ( dom . getNodeValue ( node ) , dom ) <= rnumber ) return true ; } break ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; } return false ; } public static boolean compare ( NodeIterator left , final String rstring , int op , DOM dom ) { int node ; while ( ( node = left . next ( ) ) != NodeIterator . END ) { if ( compareStrings ( dom . getNodeValue ( node ) , rstring , op , dom ) ) { return true ; } } return false ; } public static boolean compare ( NodeIterator left , final String rstring , int op , int node , DOM dom ) { if ( compareStrings ( dom . getNodeValue ( node ) , rstring , op , dom ) ) { return true ; } else { return false ; } } public static boolean compare ( Object left , Object right , int op , int node , DOM dom ) { boolean result = false ; boolean hasSimpleArgs = hasSimpleType ( left ) && hasSimpleType ( right ) ; if ( op != EQ && op != NE ) { if ( left instanceof Node || right instanceof Node ) { if ( left instanceof Boolean ) { right = new Boolean ( booleanF ( right ) ) ; hasSimpleArgs = true ; } if ( right instanceof Boolean ) { left = new Boolean ( booleanF ( left ) ) ; hasSimpleArgs = true ; } } if ( hasSimpleArgs ) { switch ( op ) { case GT : return numberF ( left , dom ) > numberF ( right , dom ) ; case LT : return numberF ( left , dom ) < numberF ( right , dom ) ; case GE : return numberF ( left , dom ) >= numberF ( right , dom ) ; case LE : return numberF ( left , dom ) <= numberF ( right , dom ) ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; } } } if ( hasSimpleArgs ) { if ( left instanceof Boolean || right instanceof Boolean ) { result = booleanF ( left ) == booleanF ( right ) ; } else if ( left instanceof Double || right instanceof Double || left instanceof Integer || right instanceof Integer ) { result = numberF ( left , dom ) == numberF ( right , dom ) ; } else { result = stringF ( left , dom ) . equals ( stringF ( right , dom ) ) ; } if ( op == Operators . NE ) { result = ! result ; } } else { if ( left instanceof Node ) { left = new SingletonIterator ( ( ( Node ) left ) . node ) ; } if ( right instanceof Node ) { right = new SingletonIterator ( ( ( Node ) right ) . node ) ; } if ( hasSimpleType ( left ) || left instanceof DOM && right instanceof NodeIterator ) { final Object temp = right ; right = left ; left = temp ; } if ( left instanceof DOM ) { if ( right instanceof Boolean ) { result = ( ( Boolean ) right ) . booleanValue ( ) ; return result == ( op == Operators . EQ ) ; } final String sleft = ( ( DOM ) left ) . getStringValue ( ) ; if ( right instanceof Number ) { result = ( ( Number ) right ) . doubleValue ( ) == stringToReal ( sleft ) ; } else if ( right instanceof String ) { result = sleft . equals ( ( String ) right ) ; } else if ( right instanceof DOM ) { result = sleft . equals ( ( ( DOM ) right ) . getStringValue ( ) ) ; } if ( op == Operators . NE ) { result = ! result ; } return result ; } NodeIterator iter = ( ( NodeIterator ) left ) . reset ( ) ; if ( right instanceof NodeIterator ) { result = compare ( iter , ( NodeIterator ) right , op , node , dom ) ; } else if ( right instanceof String ) { result = compare ( iter , ( String ) right , op , dom ) ; } else if ( right instanceof Number ) { final double temp = ( ( Number ) right ) . doubleValue ( ) ; result = compare ( iter , temp , op , dom ) ; } else if ( right instanceof Boolean ) { boolean temp = ( ( Boolean ) right ) . booleanValue ( ) ; result = ( iter . reset ( ) . next ( ) != NodeIterator . END ) == temp ; } else if ( right instanceof DOM ) { result = compare ( iter , ( ( DOM ) right ) . getStringValue ( ) , op , dom ) ; } else if ( right == null ) { return ( false ) ; } else { final String className = right . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "compare()" ) ; } } return result ; } public static boolean testLanguage ( String testLang , DOM dom , int node ) { String nodeLang = dom . getLanguage ( node ) ; if ( nodeLang == null ) return ( false ) ; else nodeLang = nodeLang . toLowerCase ( ) ; testLang = testLang . toLowerCase ( ) ; if ( testLang . length ( ) == 2 ) { return ( nodeLang . startsWith ( testLang ) ) ; } else { return ( nodeLang . equals ( testLang ) ) ; } } private static boolean hasSimpleType ( Object obj ) { return obj instanceof Boolean || obj instanceof Double || obj instanceof Integer || obj instanceof String || obj instanceof Node || obj instanceof DOM ; } public static double stringToReal ( String s ) { try { return Double . valueOf ( s ) . doubleValue ( ) ; } catch ( NumberFormatException e ) { return Double . NaN ; } } public static int stringToInt ( String s ) { try { return Integer . parseInt ( s ) ; } catch ( NumberFormatException e ) { return ( - 1 ) ; } } private static double lowerBounds = 0.001 ; private static double upperBounds = 10000000 ; private static DecimalFormat defaultFormatter ; private static String defaultPattern = "" ; static { NumberFormat f = NumberFormat . getInstance ( Locale . getDefault ( ) ) ; f . setMaximumFractionDigits ( Integer . MAX_VALUE ) ; defaultFormatter = ( f instanceof DecimalFormat ) ? ( DecimalFormat ) f : new DecimalFormat ( ) ; defaultFormatter . setGroupingUsed ( false ) ; } public static String realToString ( double d ) { final double m = Math . abs ( d ) ; if ( ( m >= lowerBounds ) && ( m < upperBounds ) ) { final String result = Double . toString ( d ) ; final int length = result . length ( ) ; if ( ( result . charAt ( length - 2 ) == '.' ) && ( result . charAt ( length - 1 ) == '0' ) ) return result . substring ( 0 , length - 2 ) ; else return result ; } else { if ( Double . isNaN ( d ) || Double . isInfinite ( d ) ) return ( Double . toString ( d ) ) ; return formatNumber ( d , defaultPattern , defaultFormatter ) ; } } public static int realToInt ( double d ) { return ( int ) d ; } private static FieldPosition _fieldPosition = new FieldPosition ( 0 ) ; public static String formatNumber ( double number , String pattern , DecimalFormat formatter ) { try { StringBuffer result = new StringBuffer ( ) ; if ( pattern != defaultPattern ) { formatter . applyLocalizedPattern ( pattern ) ; } String localizedPattern = formatter . toPattern ( ) ; int index = localizedPattern . indexOf ( '.' ) ; if ( index >= 1 && localizedPattern . charAt ( index - 1 ) == '#' ) { StringBuffer newpattern = new StringBuffer ( ) ; newpattern . append ( localizedPattern . substring ( 0 , index - 1 ) ) ; newpattern . append ( "0" ) ; newpattern . append ( localizedPattern . substring ( index ) ) ; formatter . applyLocalizedPattern ( newpattern . toString ( ) ) ; } else if ( index == 0 ) { StringBuffer newpattern = new StringBuffer ( ) ; newpattern . append ( "0" ) ; newpattern . append ( localizedPattern ) ; formatter . applyLocalizedPattern ( newpattern . toString ( ) ) ; } formatter . format ( number , result , _fieldPosition ) ; return ( result . toString ( ) ) ; } catch ( IllegalArgumentException e ) { runTimeError ( FORMAT_NUMBER_ERR , Double . toString ( number ) , pattern ) ; return ( EMPTYSTRING ) ; } } public static NodeIterator referenceToNodeSet ( Object obj ) { if ( obj instanceof Node ) { return ( new SingletonIterator ( ( ( Node ) obj ) . node ) ) ; } else if ( obj instanceof NodeIterator ) { return ( ( ( NodeIterator ) obj ) . cloneIterator ( ) ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static NodeIterator nodeList2Iterator ( org . w3c . dom . NodeList nodeList , Translet translet , DOM dom ) { int size = nodeList . getLength ( ) ; DocumentBuilderFactory dfac = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docbldr = null ; try { docbldr = dfac . newDocumentBuilder ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return null ; } Document doc = docbldr . newDocument ( ) ; org . w3c . dom . Node topElementNode = doc . appendChild ( doc . createElementNS ( "" , "__top__" ) ) ; for ( int i = 0 ; i < size ; i ++ ) { org . w3c . dom . Node curr = nodeList . item ( i ) ; int nodeType = curr . getNodeType ( ) ; if ( nodeType == org . w3c . dom . Node . DOCUMENT_NODE ) { continue ; } String value = null ; try { value = curr . getNodeValue ( ) ; } catch ( DOMException ex ) { runTimeError ( RUN_TIME_INTERNAL_ERR , ex . getMessage ( ) ) ; return null ; } String namespaceURI = curr . getNamespaceURI ( ) ; String nodeName = curr . getNodeName ( ) ; org . w3c . dom . Node newNode = null ; switch ( nodeType ) { case org . w3c . dom . Node . ATTRIBUTE_NODE : newNode = doc . createAttributeNS ( namespaceURI , nodeName ) ; break ; case org . w3c . dom . Node . CDATA_SECTION_NODE : newNode = doc . createCDATASection ( value ) ; break ; case org . w3c . dom . Node . COMMENT_NODE : newNode = doc . createComment ( value ) ; break ; case org . w3c . dom . Node . DOCUMENT_FRAGMENT_NODE : newNode = doc . createDocumentFragment ( ) ; break ; case org . w3c . dom . Node . DOCUMENT_TYPE_NODE : break ; case org . w3c . dom . Node . ELEMENT_NODE : newNode = doc . createElementNS ( namespaceURI , nodeName ) ; break ; case org . w3c . dom . Node . ENTITY_NODE : break ; case org . w3c . dom . Node . ENTITY_REFERENCE_NODE : newNode = doc . createEntityReference ( nodeName ) ; break ; case org . w3c . dom . Node . NOTATION_NODE : break ; case org . w3c . dom . Node . PROCESSING_INSTRUCTION_NODE : newNode = doc . createProcessingInstruction ( nodeName , value ) ; break ; case org . w3c . dom . Node . TEXT_NODE : newNode = doc . createTextNode ( value ) ; break ; } try { topElementNode . appendChild ( newNode ) ; } catch ( DOMException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return null ; } } DOMImpl idom = new DOMImpl ( ) ; final DOM2SAX dom2sax = new DOM2SAX ( doc ) ; final DOMBuilder domBuilder = idom . getBuilder ( ) ; dom2sax . setContentHandler ( domBuilder ) ; try { dom2sax . parse ( ) ; } catch ( java . io . IOException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return null ; } catch ( org . xml . sax . SAXException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return null ; } if ( dom instanceof MultiDOM ) { final MultiDOM multiDOM = ( MultiDOM ) dom ; DOMAdapter domAdapter = new DOMAdapter ( idom , translet . getNamesArray ( ) , translet . getNamespaceArray ( ) ) ; multiDOM . addDOMAdapter ( domAdapter ) ; NodeIterator iter1 = multiDOM . getAxisIterator ( Axis . CHILD ) ; NodeIterator iter2 = multiDOM . getAxisIterator ( Axis . CHILD ) ; NodeIterator iter = new AbsoluteIterator ( new StepIterator ( iter1 , iter2 ) ) ; iter . setStartNode ( DOM . ROOTNODE | domAdapter . getMultiDOMMask ( ) ) ; return iter ; } else { runTimeError ( RUN_TIME_INTERNAL_ERR , "nodeList2Iterator()" ) ; return null ; } } public static DOM referenceToResultTree ( Object obj ) { try { return ( ( DOM ) obj ) ; } catch ( IllegalArgumentException e ) { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static NodeIterator getSingleNode ( NodeIterator iterator ) { int node = iterator . next ( ) ; return ( new SingletonIterator ( node ) ) ; } private static char [ ] _characterArray = new char [ 32 ] ; public static void copy ( Object obj , TransletOutputHandler handler , int node , DOM dom ) { try { if ( obj instanceof NodeIterator ) { NodeIterator iter = ( NodeIterator ) obj ; dom . copy ( iter . reset ( ) , handler ) ; } else if ( obj instanceof Node ) { dom . copy ( ( ( Node ) obj ) . node , handler ) ; } else if ( obj instanceof DOM ) { ( ( DOM ) obj ) . copy ( 1 , handler ) ; } else { String string = obj . toString ( ) ; final int length = string . length ( ) ; if ( length > _characterArray . length ) _characterArray = new char [ length ] ; string . getChars ( 0 , length , _characterArray , 0 ) ; handler . characters ( _characterArray , 0 , length ) ; } } catch ( TransletException e ) { runTimeError ( RUN_TIME_COPY_ERR ) ; } } public static String getPrefix ( String qname ) { final int index = qname . indexOf ( ':' ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : null ; } private static int prefixIndex = 0 ; public static String generatePrefix ( ) { return ( "ns" + prefixIndex ++ ) ; } public static String makeQName ( String localName , String prefix ) { return ( new StringBuffer ( prefix ) . append ( ':' ) . append ( localName ) . toString ( ) ) ; } public static final int RUN_TIME_INTERNAL_ERR = 0 ; public static final int RUN_TIME_COPY_ERR = 1 ; public static final int DATA_CONVERSION_ERR = 2 ; public static final int EXTERNAL_FUNC_ERR = 3 ; public static final int EQUALITY_EXPR_ERR = 4 ; public static final int INVALID_ARGUMENT_ERR = 5 ; public static final int FORMAT_NUMBER_ERR = 6 ; public static final int ITERATOR_CLONE_ERR = 7 ; public static final int AXIS_SUPPORT_ERR = 8 ; public static final int TYPED_AXIS_SUPPORT_ERR = 9 ; public static final int STRAY_ATTRIBUTE_ERR = 10 ; public static final int STRAY_NAMESPACE_ERR = 11 ; public static final int NAMESPACE_PREFIX_ERR = 12 ; public static final int DOM_ADAPTER_INIT_ERR = 13 ; private static String [ ] _errorMessages ; public final static String ERROR_MESSAGES_KEY = "error-messages" ; static { String resource = "org.apache.xalan.xsltc.runtime.ErrorMessages" ; ResourceBundle bundle = ResourceBundle . getBundle ( resource ) ; _errorMessages = bundle . getStringArray ( ERROR_MESSAGES_KEY ) ; } public static void runTimeError ( int code ) { throw new RuntimeException ( _errorMessages [ code ] ) ; } public static void runTimeError ( int code , Object [ ] args ) { final String message = MessageFormat . format ( _errorMessages [ code ] , args ) ; throw new RuntimeException ( message ) ; } public static void runTimeError ( int code , Object arg0 ) { runTimeError ( code , new Object [ ] { arg0 } ) ; } public static void runTimeError ( int code , Object arg0 , Object arg1 ) { runTimeError ( code , new Object [ ] { arg0 , arg1 } ) ; } public static void consoleOutput ( String msg ) { System . out . println ( msg ) ; } public static String replace ( String base , char ch , String str ) { return ( base . indexOf ( ch ) < 0 ) ? base : replace ( base , String . valueOf ( ch ) , new String [ ] { str } ) ; } public static String replace ( String base , String delim , String [ ] str ) { final int len = base . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i ++ ) { final char ch = base . charAt ( i ) ; final int k = delim . indexOf ( ch ) ; if ( k >= 0 ) { result . append ( str [ k ] ) ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } } 	1	['53', '1', '0', '34', '150', '1362', '22', '15', '49', '1.001602564', '2089', '0.375', '0', '0', '0.125', '0', '0', '37.96226415', '49', '4.3962', '1']
package org . apache . xpath . operations ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public class Operation extends Expression implements ExpressionOwner { protected Expression m_left ; protected Expression m_right ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_left . fixupVariables ( vars , globalsSize ) ; m_right . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_left && m_left . canTraverseOutsideSubtree ( ) ) return true ; if ( null != m_right && m_right . canTraverseOutsideSubtree ( ) ) return true ; return false ; } public void setLeftRight ( Expression l , Expression r ) { m_left = l ; m_right = r ; l . exprSetParent ( this ) ; r . exprSetParent ( this ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject left = m_left . execute ( xctxt , true ) ; XObject right = m_right . execute ( xctxt , true ) ; XObject result = operate ( left , right ) ; left . detach ( ) ; right . detach ( ) ; return result ; } public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return null ; } public Expression getLeftOperand ( ) { return m_left ; } public Expression getRightOperand ( ) { return m_right ; } class LeftExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_left ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( Operation . this ) ; m_left = exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitBinaryOperation ( owner , this ) ) { m_left . callVisitors ( new LeftExprOwner ( ) , visitor ) ; m_right . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_right ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_right = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_left . deepEquals ( ( ( Operation ) expr ) . m_left ) ) return false ; if ( ! m_right . deepEquals ( ( ( Operation ) expr ) . m_right ) ) return false ; return true ; } } 	0	['12', '2', '14', '23', '23', '0', '17', '8', '12', '0.363636364', '149', '1', '2', '0.731707317', '0.21875', '1', '7', '11.25', '5', '1.5833', '0']
package org . apache . xalan . templates ; import org . apache . xml . dtm . DTM ; import org . xml . sax . * ; import org . apache . xpath . * ; import org . apache . xpath . Expression ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XRTreeFragSelectWrapper ; import org . apache . xml . utils . QName ; import org . apache . xalan . trace . SelectionEvent ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . extensions . ExtensionsTable ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . xalan . extensions . ExtensionNamespaceSupport ; import org . apache . xalan . extensions . ExtensionHandlerExsltFunction ; public class ElemExsltFunction extends ElemTemplate { public int getXSLToken ( ) { return Constants . EXSLT_ELEMNAME_FUNCTION ; } public String getNodeName ( ) { return Constants . EXSLT_ELEMNAME_FUNCTION_STRING ; } public void execute ( TransformerImpl transformer , XObject [ ] args ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; VariableStack vars = xctxt . getVarStack ( ) ; NodeList children = this . getChildNodes ( ) ; int numparams = 0 ; for ( int i = 0 ; i < args . length ; i ++ ) { Node child = children . item ( i ) ; if ( children . item ( i ) instanceof ElemParam ) { numparams ++ ; ElemParam param = ( ElemParam ) children . item ( i ) ; vars . setLocalVariable ( param . m_index , args [ i ] ) ; } } if ( numparams < args . length ) throw new TransformerException ( "function called with too many args" ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; vars . setLocalVariable ( _resultIndex , null ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; setResultIndex ( cstate . addVariableName ( new QName ( Constants . S_EXSLT_COMMON_URL , "result" ) ) ) ; String namespace = getName ( ) . getNamespace ( ) ; String handlerClass = "org.apache.xalan.extensions.ExtensionHandlerExsltFunction" ; Object [ ] args = { namespace , sroot } ; ExtensionNamespaceSupport extNsSpt = new ExtensionNamespaceSupport ( namespace , handlerClass , args ) ; sroot . getExtensionNamespacesManager ( ) . registerExtension ( extNsSpt ) ; if ( ! ( namespace . equals ( Constants . S_EXSLT_FUNCTIONS_URL ) ) ) { namespace = Constants . S_EXSLT_FUNCTIONS_URL ; args = new Object [ ] { namespace , sroot } ; extNsSpt = new ExtensionNamespaceSupport ( namespace , handlerClass , args ) ; sroot . getExtensionNamespacesManager ( ) . registerExtension ( extNsSpt ) ; } } private int _resultIndex ; void setResultIndex ( int stackIndex ) { _resultIndex = stackIndex ; } public int getResultIndex ( ) { return _resultIndex ; } } 	1	['7', '4', '0', '18', '28', '15', '4', '14', '6', '0.5', '166', '1', '0', '0.97309417', '0.314285714', '4', '7', '22.57142857', '1', '0.8571', '1']
package org . apache . xalan . xsltc ; import org . apache . xalan . xsltc . DOM ; public interface StripFilter { public boolean stripSpace ( DOM dom , int node , int type ) ; } 	0	['1', '1', '0', '5', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; public class StackGuard { public static int m_recursionLimit = - 1 ; TransformerImpl m_transformer ; public int getRecursionLimit ( ) { return m_recursionLimit ; } public void setRecursionLimit ( int limit ) { m_recursionLimit = limit ; } public StackGuard ( TransformerImpl transformerImpl ) { m_transformer = transformerImpl ; } public int countLikeTemplates ( ElemTemplate templ , int pos ) { ElemTemplateElement [ ] elems = m_transformer . getCurrentTemplateElements ( ) ; int count = 1 ; for ( int i = pos - 1 ; i >= 0 ; i -- ) { if ( elems [ i ] == templ ) count ++ ; } return count ; } private ElemTemplate getNextMatchOrNamedTemplate ( int pos ) { ElemTemplateElement [ ] elems = m_transformer . getCurrentTemplateElements ( ) ; for ( int i = pos ; i >= 0 ; i -- ) { ElemTemplateElement elem = elems [ i ] ; if ( null != elem ) { if ( elem . getXSLToken ( ) == Constants . ELEMNAME_TEMPLATE ) { return ( ElemTemplate ) elem ; } } } return null ; } public void checkForInfinateLoop ( ) throws TransformerException { int nTemplates = m_transformer . getCurrentTemplateElementsCount ( ) ; if ( nTemplates < m_recursionLimit ) return ; if ( m_recursionLimit <= 0 ) return ; for ( int i = ( nTemplates - 1 ) ; i >= m_recursionLimit ; i -- ) { ElemTemplate template = getNextMatchOrNamedTemplate ( i ) ; if ( null == template ) break ; int loopCount = countLikeTemplates ( template , i ) ; if ( loopCount >= m_recursionLimit ) { String idIs = XSLMessages . createMessage ( ( ( null != template . getName ( ) ) ? "nameIs" : "matchPatternIs" ) , null ) ; Object [ ] msgArgs = new Object [ ] { new Integer ( loopCount ) , idIs , ( ( null != template . getName ( ) ) ? template . getName ( ) . toString ( ) : template . getMatch ( ) . getPatternString ( ) ) } ; String msg = XSLMessages . createMessage ( "recursionTooDeep" , msgArgs ) ; throw new TransformerException ( msg ) ; } } } } 	1	['7', '1', '0', '7', '18', '0', '3', '6', '5', '0.5', '155', '0', '1', '0', '0.458333333', '0', '0', '20.85714286', '4', '1.4286', '1']
package org . apache . xalan . serialize ; import java . io . Writer ; import java . io . OutputStream ; import java . io . IOException ; import java . util . Properties ; import org . xml . sax . ContentHandler ; public interface Serializer { public void setOutputStream ( OutputStream output ) ; public OutputStream getOutputStream ( ) ; public void setWriter ( Writer writer ) ; public Writer getWriter ( ) ; public void setOutputFormat ( Properties format ) ; public Properties getOutputFormat ( ) ; public ContentHandler asContentHandler ( ) throws IOException ; public DOMSerializer asDOMSerializer ( ) throws IOException ; public boolean reset ( ) ; } 	0	['9', '1', '0', '8', '9', '36', '7', '1', '9', '2', '9', '0', '0', '0', '0.333333333', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . extensions ; import java . util . Hashtable ; import java . util . Vector ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . io . IOException ; import org . apache . xml . dtm . DTM ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . QName ; import org . apache . xpath . objects . XObject ; import javax . xml . transform . TransformerException ; public class ExtensionHandlerJavaPackage extends ExtensionHandlerJava { public ExtensionHandlerJavaPackage ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang , className ) ; } public boolean isFunctionAvailable ( String function ) { try { String fullName = m_className + function ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot >= 0 ) { Class myClass = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; Method [ ] methods = myClass . getMethods ( ) ; int nMethods = methods . length ; function = fullName . substring ( lastDot + 1 ) ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( function ) ) return true ; } } } catch ( ClassNotFoundException cnfe ) { } return false ; } public boolean isElementAvailable ( String element ) { try { String fullName = m_className + element ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot >= 0 ) { Class myClass = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; Method [ ] methods = myClass . getMethods ( ) ; int nMethods = methods . length ; element = fullName . substring ( lastDot + 1 ) ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( element ) ) { Class [ ] paramTypes = methods [ i ] . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) ) { return true ; } } } } } catch ( ClassNotFoundException cnfe ) { } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { String className ; String methodName ; Class classObj ; Object targetObject ; int lastDot = funcName . lastIndexOf ( "." ) ; Object [ ] methodArgs ; Object [ ] [ ] convertedArgs ; Class [ ] paramTypes ; try { if ( funcName . endsWith ( ".new" ) ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Constructor c = ( Constructor ) getFromCache ( methodKey , null , methodArgs ) ; if ( c != null ) { try { paramTypes = c . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } catch ( Exception e ) { } } className = m_className + funcName . substring ( 0 , lastDot ) ; try { classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } c = MethodResolver . getConstructor ( classObj , methodArgs , convertedArgs , exprContext ) ; putToCache ( methodKey , null , methodArgs , c ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } else if ( - 1 != lastDot ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Method m = ( Method ) getFromCache ( methodKey , null , methodArgs ) ; if ( m != null ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return m . invoke ( null , convertedArgs [ 0 ] ) ; } catch ( Exception e ) { } } className = m_className + funcName . substring ( 0 , lastDot ) ; methodName = funcName . substring ( lastDot + 1 ) ; try { classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } m = MethodResolver . getMethod ( classObj , methodName , methodArgs , convertedArgs , exprContext , MethodResolver . STATIC_ONLY ) ; putToCache ( methodKey , null , methodArgs , m ) ; return m . invoke ( null , convertedArgs [ 0 ] ) ; } else { if ( args . size ( ) < 1 ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INSTANCE_MTHD_CALL_REQUIRES , new Object [ ] { funcName } ) ) ; } targetObject = args . elementAt ( 0 ) ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; methodArgs = new Object [ args . size ( ) - 1 ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i + 1 ) ; } Method m = ( Method ) getFromCache ( methodKey , targetObject , methodArgs ) ; if ( m != null ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } catch ( Exception e ) { } } classObj = targetObject . getClass ( ) ; m = MethodResolver . getMethod ( classObj , funcName , methodArgs , convertedArgs , exprContext , MethodResolver . INSTANCE_ONLY ) ; putToCache ( methodKey , targetObject , methodArgs , m ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } } catch ( InvocationTargetException ite ) { Throwable realException = ite . getTargetException ( ) ; if ( realException instanceof Exception ) throw new TransformerException ( ( Exception ) realException ) ; else throw new TransformerException ( ite ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; Class classObj ; Method m = ( Method ) getFromCache ( methodKey , null , null ) ; if ( null == m ) { try { String fullName = m_className + localPart ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot < 0 ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_ELEMENT_NAME , new Object [ ] { fullName } ) ) ; try { classObj = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } localPart = fullName . substring ( lastDot + 1 ) ; m = MethodResolver . getElementMethod ( classObj , localPart ) ; if ( ! Modifier . isStatic ( m . getModifiers ( ) ) ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEMENT_NAME_METHOD_STATIC , new Object [ ] { fullName } ) ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } putToCache ( methodKey , null , null , m ) ; } XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { result = m . invoke ( null , new Object [ ] { xpc , element } ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1	['6', '3', '0', '10', '44', '15', '0', '10', '5', '1', '615', '0', '0', '0.615384615', '0.375', '3', '6', '101.1666667', '7', '2', '2']
package org . apache . xalan . xsltc . runtime . output ; import java . util . Stack ; import java . io . IOException ; import org . xml . sax . SAXException ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . AttributeList ; public class SAXHTMLOutput extends SAXOutput { public SAXHTMLOutput ( ContentHandler handler , String encoding ) throws IOException { super ( handler , encoding ) ; } public SAXHTMLOutput ( ContentHandler handler , LexicalHandler lex , String encoding ) throws IOException { super ( handler , lex , encoding ) ; } public void endDocument ( ) throws TransletException { try { if ( _startTagOpen ) { closeStartTag ( ) ; } _saxHandler . endDocument ( ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void startElement ( String elementName ) throws TransletException { try { if ( _startTagOpen ) { closeStartTag ( ) ; } if ( _lexHandler != null ) { if ( ( _doctypeSystem != null ) || ( _doctypePublic != null ) ) _lexHandler . startDTD ( elementName , _doctypePublic , _doctypeSystem ) ; _lexHandler = null ; } _depth ++ ; _elementName = elementName ; _attributes . clear ( ) ; _startTagOpen = true ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void endElement ( String elementName ) throws TransletException { try { if ( _startTagOpen ) { closeStartTag ( ) ; } _saxHandler . endElement ( EMPTYSTRING , elementName , elementName ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void attribute ( String name , final String value ) throws TransletException { if ( _startTagOpen ) { final String patchedName = patchName ( name ) ; final String localName = getLocalName ( patchedName ) ; final int index = _attributes . getIndex ( name ) ; if ( index >= 0 ) { _attributes . setAttribute ( index , EMPTYSTRING , localName , name , "CDATA" , value ) ; } else { _attributes . addAttribute ( EMPTYSTRING , localName , name , "CDATA" , value ) ; } } } public void characters ( char [ ] ch , int off , int len ) throws TransletException { try { if ( _startTagOpen ) closeStartTag ( ) ; _saxHandler . characters ( ch , off , len ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } protected void closeStartTag ( ) throws TransletException { try { _startTagOpen = false ; _saxHandler . startElement ( EMPTYSTRING , _elementName , _elementName , _attributes ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } } 	0	['8', '3', '0', '4', '22', '28', '1', '3', '7', '2', '177', '0', '0', '0.860465116', '0.375', '2', '4', '21.125', '1', '0.75', '0']
package org . apache . xpath . axes ; import java . util . Stack ; import org . apache . xpath . Expression ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . XPathContext ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . PsuedoNames ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . VariableStack ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMAxisTraverser ; public class MatchPatternIterator extends LocPathIterator { protected StepPattern m_pattern ; protected int m_superAxis = - 1 ; protected DTMAxisTraverser m_traverser ; private static final boolean DEBUG = false ; MatchPatternIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_pattern = WalkerFactory . loadSteps ( this , compiler , firstStepPos , 0 ) ; boolean fromRoot = false ; boolean walkBack = false ; boolean walkDescendants = false ; boolean walkAttributes = false ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ROOT | WalkerFactory . BIT_ANY_DESCENDANT_FROM_ROOT ) ) ) fromRoot = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ANCESTOR | WalkerFactory . BIT_ANCESTOR_OR_SELF | WalkerFactory . BIT_PRECEDING | WalkerFactory . BIT_PRECEDING_SIBLING | WalkerFactory . BIT_FOLLOWING | WalkerFactory . BIT_FOLLOWING_SIBLING | WalkerFactory . BIT_PARENT | WalkerFactory . BIT_FILTER ) ) ) walkBack = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_DESCENDANT_OR_SELF | WalkerFactory . BIT_DESCENDANT | WalkerFactory . BIT_CHILD ) ) ) walkDescendants = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ATTRIBUTE | WalkerFactory . BIT_NAMESPACE ) ) ) walkAttributes = true ; if ( false || DEBUG ) { System . out . print ( "analysis: " + Integer . toBinaryString ( analysis ) ) ; System . out . println ( ", " + WalkerFactory . getAnalysisString ( analysis ) ) ; } if ( fromRoot || walkBack ) { if ( walkAttributes ) { m_superAxis = Axis . ALL ; } else { m_superAxis = Axis . DESCENDANTSFROMROOT ; } } else if ( walkDescendants ) { if ( walkAttributes ) { m_superAxis = Axis . ALLFROMNODE ; } else { m_superAxis = Axis . DESCENDANTORSELF ; } } else { m_superAxis = Axis . ALL ; } if ( false || DEBUG ) { System . out . println ( "axis: " + Axis . names [ m_superAxis ] ) ; } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_superAxis ) ; } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; return m_lastFetched ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { if ( DEBUG ) System . out . println ( "m_pattern" + m_pattern . toString ( ) ) ; do { next = getNextNode ( ) ; if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next , m_execContext ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { if ( DEBUG ) { System . out . println ( "next: " + next ) ; System . out . println ( "name: " + m_cdtm . getNodeName ( next ) ) ; } incrementCurrentPos ( ) ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public short acceptNode ( int n , XPathContext xctxt ) { try { xctxt . pushCurrentNode ( n ) ; xctxt . pushIteratorRoot ( m_context ) ; if ( DEBUG ) { System . out . println ( "traverser: " + m_traverser ) ; System . out . print ( "node: " + n ) ; System . out . println ( ", " + m_cdtm . getNodeName ( n ) ) ; System . out . println ( "pattern: " + m_pattern . toString ( ) ) ; m_pattern . debugWhatToShow ( m_pattern . getWhatToShow ( ) ) ; } XObject score = m_pattern . execute ( xctxt ) ; if ( DEBUG ) { System . out . println ( "score: " + score ) ; System . out . println ( "skip: " + ( score == NodeTest . SCORE_NONE ) ) ; } return ( score == NodeTest . SCORE_NONE ) ? DTMIterator . FILTER_SKIP : DTMIterator . FILTER_ACCEPT ; } catch ( javax . xml . transform . TransformerException se ) { throw new RuntimeException ( se . getMessage ( ) ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popIteratorRoot ( ) ; } } } 	1	['5', '5', '0', '13', '23', '4', '1', '13', '3', '0.75', '251', '1', '2', '0.968992248', '0.44', '1', '5', '48.4', '10', '3', '1']
package org . apache . xml . dtm . ref ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import java . io . IOException ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . ContentHandler ; import org . xml . sax . XMLReader ; public interface CoroutineParser { public int getParserCoroutineID ( ) ; public CoroutineManager getCoroutineManager ( ) ; public void setContentHandler ( ContentHandler handler ) ; public void setLexHandler ( org . xml . sax . ext . LexicalHandler handler ) ; public Object doParse ( InputSource source , int appCoroutine ) ; public Object doMore ( boolean parsemore , int appCoroutine ) ; public void doTerminate ( int appCoroutine ) ; public void init ( CoroutineManager co , int appCoroutineID , XMLReader parser ) ; } 	0	['8', '1', '0', '1', '8', '28', '0', '1', '8', '2', '8', '0', '0', '0', '0.28125', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . axes ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . patterns . NodeTest ; public class DescendantIterator extends LocPathIterator { DescendantIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int ops [ ] = compiler . getOpMap ( ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int stepType = ops [ firstStepPos ] ; boolean orSelf = ( OpCodes . FROM_DESCENDANTS_OR_SELF == stepType ) ; boolean fromRoot = false ; if ( OpCodes . FROM_SELF == stepType ) { orSelf = true ; } else if ( OpCodes . FROM_ROOT == stepType ) { fromRoot = true ; int nextStepPos = compiler . getNextStepPos ( firstStepPos ) ; if ( ops [ nextStepPos ] == OpCodes . FROM_DESCENDANTS_OR_SELF ) orSelf = true ; } int nextStepPos = firstStepPos ; while ( true ) { nextStepPos = compiler . getNextStepPos ( nextStepPos ) ; if ( nextStepPos > 0 ) { int stepOp = compiler . getOp ( nextStepPos ) ; if ( OpCodes . ENDOP != stepOp ) firstStepPos = nextStepPos ; else break ; } else break ; } if ( ( analysis & WalkerFactory . BIT_CHILD ) != 0 ) orSelf = false ; if ( fromRoot ) { if ( orSelf ) m_axis = Axis . DESCENDANTSORSELFFROMROOT ; else m_axis = Axis . DESCENDANTSFROMROOT ; } else if ( orSelf ) m_axis = Axis . DESCENDANTORSELF ; else m_axis = Axis . DESCENDANT ; int whatToShow = compiler . getWhatToShow ( firstStepPos ) ; if ( ( 0 == ( whatToShow & ( DTMFilter . SHOW_ATTRIBUTE | DTMFilter . SHOW_ELEMENT | DTMFilter . SHOW_PROCESSING_INSTRUCTION ) ) ) || ( whatToShow == DTMFilter . SHOW_ALL ) ) initNodeTest ( whatToShow ) ; else { initNodeTest ( whatToShow , compiler . getStepNS ( firstStepPos ) , compiler . getStepLocalName ( firstStepPos ) ) ; } initPredicateInfo ( compiler , firstStepPos ) ; } public DescendantIterator ( ) { super ( null ) ; m_axis = Axis . DESCENDANTSORSELFFROMROOT ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { DescendantIterator clone = ( DescendantIterator ) super . cloneWithReset ( ) ; clone . m_traverser = m_traverser ; clone . resetProximityPositions ( ) ; return clone ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( DTM . NULL == m_lastFetched ) { resetProximityPositions ( ) ; } int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { do { if ( 0 == m_extendedTypeID ) { next = m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; } else { next = m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context , m_extendedTypeID ) : m_traverser . next ( m_context , m_lastFetched , m_extendedTypeID ) ; } if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_axis ) ; String localName = getLocalName ( ) ; String namespace = getNamespace ( ) ; int what = m_whatToShow ; if ( DTMFilter . SHOW_ALL == what || localName == NodeTest . WILD || namespace == NodeTest . WILD ) { m_extendedTypeID = 0 ; } else { int type = getNodeTypeTest ( what ) ; m_extendedTypeID = m_cdtm . getExpandedTypeID ( namespace , localName , type ) ; } } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( getPredicateCount ( ) > 0 ) return super . asNode ( xctxt ) ; int current = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( current ) ; DTMAxisTraverser traverser = dtm . getAxisTraverser ( m_axis ) ; String localName = getLocalName ( ) ; String namespace = getNamespace ( ) ; int what = m_whatToShow ; if ( DTMFilter . SHOW_ALL == what || localName == NodeTest . WILD || namespace == NodeTest . WILD ) { return traverser . first ( current ) ; } else { int type = getNodeTypeTest ( what ) ; int extendedType = dtm . getExpandedTypeID ( namespace , localName , type ) ; return traverser . first ( current , extendedType ) ; } } public void detach ( ) { m_traverser = null ; m_extendedTypeID = 0 ; super . detach ( ) ; } public int getAxis ( ) { return m_axis ; } transient protected DTMAxisTraverser m_traverser ; protected int m_axis ; protected int m_extendedTypeID ; public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( DescendantIterator ) expr ) . m_axis ) return false ; return true ; } } 	1	['9', '5', '0', '14', '43', '0', '2', '12', '8', '0.583333333', '426', '1', '1', '0.946969697', '0.277777778', '3', '11', '46', '14', '2.7778', '1']
package org . apache . xalan . xsltc . runtime ; import org . apache . xalan . xsltc . * ; public final class StringValueHandler extends TransletOutputBase { private char [ ] _buffer = new char [ 32 ] ; private int _free = 0 ; public void characters ( char [ ] ch , int off , int len ) throws TransletException { if ( _free + len >= _buffer . length ) { char [ ] newBuffer = new char [ _free + len + 32 ] ; System . arraycopy ( _buffer , 0 , newBuffer , 0 , _free ) ; _buffer = newBuffer ; } System . arraycopy ( ch , off , _buffer , _free , len ) ; _free += len ; } public String getValue ( ) { final int length = _free ; _free = 0 ; return new String ( _buffer , 0 , length ) ; } public void characters ( String characters ) throws TransletException { characters ( characters . toCharArray ( ) , 0 , characters . length ( ) ) ; } public String getValueOfPI ( ) { final String value = getValue ( ) ; if ( value . indexOf ( "?>" ) > 0 ) { final int n = value . length ( ) ; final StringBuffer valueOfPI = new StringBuffer ( ) ; for ( int i = 0 ; i < n ; ) { final char ch = value . charAt ( i ++ ) ; if ( ch == '?' && value . charAt ( i ) == '>' ) { valueOfPI . append ( "? >" ) ; i ++ ; } else { valueOfPI . append ( ch ) ; } } return valueOfPI . toString ( ) ; } return value ; } } 	0	['5', '2', '0', '3', '16', '4', '1', '2', '5', '0', '129', '1', '0', '0.851851852', '0.4', '0', '0', '24.4', '5', '1.6', '0']
package org . apache . xalan . extensions ; import org . w3c . dom . traversal . NodeIterator ; import org . w3c . dom . Node ; import org . apache . xpath . objects . XObject ; public interface ExpressionContext { public Node getContextNode ( ) ; public NodeIterator getContextNodes ( ) ; public double toNumber ( Node n ) ; public String toString ( Node n ) ; public XObject getVariableOrParam ( org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException ; public org . apache . xpath . XPathContext getXPathContext ( ) throws javax . xml . transform . TransformerException ; } 	1	['6', '1', '0', '18', '6', '15', '16', '3', '6', '2', '6', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '1']
package org . apache . xml . utils ; public class CharKey extends Object { private char m_char ; public CharKey ( char key ) { m_char = key ; } public CharKey ( ) { } public final void setChar ( char c ) { m_char = c ; } public final int hashCode ( ) { return ( int ) m_char ; } public final boolean equals ( Object obj ) { return ( ( CharKey ) obj ) . m_char == m_char ; } } 	0	['5', '1', '0', '1', '6', '0', '1', '0', '5', '0.25', '32', '1', '0', '0', '0.533333333', '1', '1', '5.2', '2', '0.8', '0']
package org . apache . xalan . xsltc . dom ; import java . io . Externalizable ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . io . IOException ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . Stack ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . DOMException ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Document ; import org . xml . sax . * ; import org . xml . sax . ext . * ; import org . xml . sax . helpers . AttributesImpl ; import org . apache . xalan . xsltc . * ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . SAXAdapter ; import org . apache . xalan . xsltc . runtime . Hashtable ; public final class DOMImpl implements DOM , Externalizable { private final static String EMPTYSTRING = "" ; private final static NodeIterator EMPTYITERATOR = new NodeIterator ( ) { public NodeIterator reset ( ) { return this ; } public NodeIterator setStartNode ( int node ) { return this ; } public int next ( ) { return NULL ; } public void setMark ( ) { } public void gotoMark ( ) { } public int getLast ( ) { return 0 ; } public int getPosition ( ) { return 0 ; } public NodeIterator cloneIterator ( ) { return this ; } public boolean isReverse ( ) { return false ; } public NodeIterator resetOnce ( ) { return this ; } public NodeIterator includeSelf ( ) { return this ; } public void setRestartable ( boolean isRestartable ) { } } ; private int _treeNodeLimit ; private int _firstAttributeNode ; private short [ ] _type ; private Hashtable _types = null ; private String [ ] _namesArray ; private int [ ] _parent ; private int [ ] _nextSibling ; private int [ ] _offsetOrChild ; private int [ ] _lengthOrAttr ; private char [ ] _text ; private String [ ] _uriArray ; private String [ ] _prefixArray ; private short [ ] _namespace ; private short [ ] _prefix ; private Hashtable _nsIndex = new Hashtable ( ) ; private BitArray _whitespace ; private BitArray _dontEscape = null ; private String _documentURI = null ; static private int _documentURIIndex = 0 ; private Node [ ] _nodes ; private NodeList [ ] _nodeLists ; private static NodeList EmptyNodeList ; private static NamedNodeMap EmptyNamedNodeMap ; private final static String XML_LANG_ATTRIBUTE = "http://www.w3.org/XML/1998/namespace:@lang" ; public void setDocumentURI ( String uri ) { _documentURI = uri ; } public String getDocumentURI ( ) { return ( _documentURI != null ) ? _documentURI : "rtf" + _documentURIIndex ++ ; } public String getDocumentURI ( int node ) { return getDocumentURI ( ) ; } public void setupMapping ( String [ ] names , String [ ] namespaces ) { } public String lookupNamespace ( int node , String prefix ) throws TransletException { int anode , nsnode ; final AncestorIterator ancestors = new AncestorIterator ( ) ; if ( isElement ( node ) ) { ancestors . includeSelf ( ) ; } ancestors . setStartNode ( node ) ; while ( ( anode = ancestors . next ( ) ) != NULL ) { final NodeIterator namespaces = new NamespaceIterator ( ) . setStartNode ( anode ) ; while ( ( nsnode = namespaces . next ( ) ) != NULL ) { if ( _prefixArray [ _prefix [ nsnode ] ] . equals ( prefix ) ) { return getNodeValue ( nsnode ) ; } } } throw new TransletException ( "Namespace prefix '" + prefix + "' is undeclared." ) ; } public boolean isElement ( final int node ) { final int type = _type [ node ] ; return ( ( node < _firstAttributeNode ) && ( type >= NTYPES ) ) ; } public boolean isAttribute ( final int node ) { final int type = _type [ node ] ; return ( ( node >= _firstAttributeNode ) && ( type >= NTYPES ) ) ; } public int getSize ( ) { return ( _type . length ) ; } public void setFilter ( StripFilter filter ) { } public boolean lessThan ( int node1 , int node2 ) { if ( node1 >= _firstAttributeNode ) node1 = _parent [ node1 ] ; if ( node2 >= _firstAttributeNode ) node2 = _parent [ node2 ] ; return ( node2 < _treeNodeLimit && node1 < node2 ) ; } public Node makeNode ( int index ) { if ( _nodes == null ) { _nodes = new Node [ _type . length ] ; } return _nodes [ index ] != null ? _nodes [ index ] : ( _nodes [ index ] = new NodeImpl ( index ) ) ; } public Node makeNode ( NodeIterator iter ) { return makeNode ( iter . next ( ) ) ; } public NodeList makeNodeList ( int index ) { if ( _nodeLists == null ) { _nodeLists = new NodeList [ _type . length ] ; } return _nodeLists [ index ] != null ? _nodeLists [ index ] : ( _nodeLists [ index ] = new NodeListImpl ( index ) ) ; } public NodeList makeNodeList ( NodeIterator iter ) { return new NodeListImpl ( iter ) ; } private NodeList getEmptyNodeList ( ) { return EmptyNodeList != null ? EmptyNodeList : ( EmptyNodeList = new NodeListImpl ( new int [ 0 ] ) ) ; } private NamedNodeMap getEmptyNamedNodeMap ( ) { return EmptyNamedNodeMap != null ? EmptyNamedNodeMap : ( EmptyNamedNodeMap = new NamedNodeMapImpl ( new int [ 0 ] ) ) ; } private final class NotSupportedException extends DOMException { public NotSupportedException ( ) { super ( NOT_SUPPORTED_ERR , "modification not supported" ) ; } } private final class NodeListImpl implements NodeList { private final int [ ] _nodes ; public NodeListImpl ( int node ) { _nodes = new int [ 1 ] ; _nodes [ 0 ] = node ; } public NodeListImpl ( int [ ] nodes ) { _nodes = nodes ; } public NodeListImpl ( NodeIterator iter ) { final IntegerArray list = new IntegerArray ( ) ; int node ; while ( ( node = iter . next ( ) ) != NodeIterator . END ) { list . add ( node ) ; } _nodes = list . toIntArray ( ) ; } public int getLength ( ) { return _nodes . length ; } public Node item ( int index ) { return makeNode ( _nodes [ index ] ) ; } } private final class NamedNodeMapImpl implements NamedNodeMap { private final int [ ] _nodes ; public NamedNodeMapImpl ( int [ ] nodes ) { _nodes = nodes ; } public int getLength ( ) { return _nodes . length ; } public Node getNamedItem ( String name ) { for ( int i = 0 ; i < _nodes . length ; i ++ ) { if ( name . equals ( getNodeName ( _nodes [ i ] ) ) ) { return makeNode ( _nodes [ i ] ) ; } } return null ; } public Node item ( int index ) { return makeNode ( _nodes [ index ] ) ; } public Node removeNamedItem ( String name ) { throw new NotSupportedException ( ) ; } public Node setNamedItem ( Node node ) { throw new NotSupportedException ( ) ; } public Node getNamedItemNS ( String uri , String local ) { return ( getNamedItem ( uri + ':' + local ) ) ; } public Node setNamedItemNS ( Node node ) { throw new NotSupportedException ( ) ; } public Node removeNamedItemNS ( String uri , String local ) { throw new NotSupportedException ( ) ; } } private final class NodeImpl implements Node { private final int _index ; public NodeImpl ( int index ) { _index = index ; } public short getNodeType ( ) { switch ( _type [ _index ] ) { case ROOT : return Node . DOCUMENT_NODE ; case TEXT : return Node . TEXT_NODE ; case PROCESSING_INSTRUCTION : return Node . PROCESSING_INSTRUCTION_NODE ; case COMMENT : return Node . COMMENT_NODE ; default : return _index < _firstAttributeNode ? Node . ELEMENT_NODE : Node . ATTRIBUTE_NODE ; } } public Node getParentNode ( ) { final int parent = getParent ( _index ) ; return parent > NULL ? makeNode ( parent ) : null ; } public Node appendChild ( Node node ) throws DOMException { throw new NotSupportedException ( ) ; } public Node cloneNode ( boolean deep ) { throw new NotSupportedException ( ) ; } public NamedNodeMap getAttributes ( ) { if ( getNodeType ( ) == Node . ELEMENT_NODE ) { int attribute = _lengthOrAttr [ _index ] ; while ( _type [ attribute ] == NAMESPACE ) { attribute = _nextSibling [ attribute ] ; } if ( attribute != NULL ) { final IntegerArray attributes = new IntegerArray ( 4 ) ; do { attributes . add ( attribute ) ; } while ( ( attribute = _nextSibling [ attribute ] ) != 0 ) ; return new NamedNodeMapImpl ( attributes . toIntArray ( ) ) ; } else { return getEmptyNamedNodeMap ( ) ; } } else { return null ; } } public NodeList getChildNodes ( ) { if ( hasChildNodes ( ) ) { final IntegerArray children = new IntegerArray ( 8 ) ; int child = _offsetOrChild [ _index ] ; do { children . add ( child ) ; } while ( ( child = _nextSibling [ child ] ) != 0 ) ; return new NodeListImpl ( children . toIntArray ( ) ) ; } else { return getEmptyNodeList ( ) ; } } public Node getFirstChild ( ) { return hasChildNodes ( ) ? makeNode ( _offsetOrChild [ _index ] ) : null ; } public Node getLastChild ( ) { return hasChildNodes ( ) ? makeNode ( lastChild ( _index ) ) : null ; } public Node getNextSibling ( ) { final int next = _nextSibling [ _index ] ; return next != 0 ? makeNode ( next ) : null ; } public String getNodeName ( ) { switch ( _type [ _index ] ) { case ROOT : return "#document" ; case TEXT : return "#text" ; case PROCESSING_INSTRUCTION : return "#pi" ; case COMMENT : return "#comment" ; default : return DOMImpl . this . getNodeName ( _index ) ; } } public String getNodeValue ( ) throws DOMException { return DOMImpl . this . getNodeValue ( _index ) ; } public Document getOwnerDocument ( ) { return null ; } public Node getPreviousSibling ( ) { int node = _parent [ _index ] ; if ( node > NULL ) { int prev = - 1 ; node = _offsetOrChild [ node ] ; while ( node != _index ) { node = _nextSibling [ prev = node ] ; } if ( prev != - 1 ) { return makeNode ( prev ) ; } } return null ; } public boolean hasChildNodes ( ) { switch ( getNodeType ( ) ) { case Node . ELEMENT_NODE : case Node . DOCUMENT_NODE : return _offsetOrChild [ _index ] != 0 ; default : return false ; } } public Node insertBefore ( Node n1 , Node n2 ) throws DOMException { throw new NotSupportedException ( ) ; } public Node removeChild ( Node n ) throws DOMException { throw new NotSupportedException ( ) ; } public Node replaceChild ( Node n1 , Node n2 ) throws DOMException { throw new NotSupportedException ( ) ; } public void setNodeValue ( String s ) throws DOMException { throw new NotSupportedException ( ) ; } public void normalize ( ) { throw new NotSupportedException ( ) ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getNamespaceURI ( ) { return _uriArray [ _namespace [ _type [ _index ] - NTYPES ] ] ; } public String getPrefix ( ) { return _prefixArray [ _prefix [ _index ] ] ; } public void setPrefix ( String prefix ) { throw new NotSupportedException ( ) ; } public String getLocalName ( ) { return DOMImpl . this . getLocalName ( _index ) ; } public boolean hasAttributes ( ) { int attribute = _lengthOrAttr [ _index ] ; while ( _type [ attribute ] == NAMESPACE ) { attribute = _nextSibling [ attribute ] ; } return ( attribute != NULL ) ; } } private Filter _elementFilter ; private Filter getElementFilter ( ) { if ( _elementFilter == null ) { _elementFilter = new Filter ( ) { public boolean test ( int node ) { return isElement ( node ) ; } } ; } return _elementFilter ; } private final class TypeFilter implements Filter { private final int _nodeType ; public TypeFilter ( int type ) { _nodeType = type ; } public boolean test ( int node ) { return _type [ node ] == _nodeType ; } } public Filter getTypeFilter ( int type ) { return new TypeFilter ( type ) ; } private final class ChildrenIterator extends NodeIteratorBase { private int _currentChild ; private int _last = - 1 ; public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( node >= _firstAttributeNode ) node = NULL ; if ( node != _startNode ) _last = - 1 ; _startNode = node ; if ( _includeSelf ) { _currentChild = - 1 ; } else { if ( hasChildren ( node ) ) _currentChild = _offsetOrChild [ node ] ; else _currentChild = END ; } return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentChild ; if ( _includeSelf ) { if ( node == - 1 ) { node = _startNode ; if ( hasChildren ( node ) ) _currentChild = _offsetOrChild [ node ] ; else _currentChild = END ; return node ; } } _currentChild = _nextSibling [ node ] ; return returnNode ( node ) ; } public void setMark ( ) { _markedNode = _currentChild ; } public void gotoMark ( ) { _currentChild = _markedNode ; } public int getLast ( ) { if ( _last == - 1 ) { _last = 1 ; int node = _offsetOrChild [ _startNode ] ; while ( ( node = _nextSibling [ node ] ) != END ) _last ++ ; } return ( _last ) ; } } private final class ParentIterator extends NodeIteratorBase { private int _node ; private int _nodeType = - 1 ; public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { _node = _parent [ _startNode = node ] ; return resetPosition ( ) ; } return this ; } public NodeIterator setNodeType ( final int type ) { _nodeType = type ; return this ; } public int next ( ) { int result = _node ; if ( ( _nodeType != - 1 ) && ( _type [ _node ] != _nodeType ) ) result = END ; else result = _node ; _node = END ; return returnNode ( result ) ; } public void setMark ( ) { _markedNode = _node ; } public void gotoMark ( ) { _node = _markedNode ; } } private final class TypedChildrenIterator extends NodeIteratorBase { private int _nodeType ; private int _currentChild ; public TypedChildrenIterator ( int nodeType ) { _nodeType = nodeType ; } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( node >= _firstAttributeNode ) node = NULL ; _currentChild = hasChildren ( node ) ? _offsetOrChild [ _startNode = node ] : END ; return resetPosition ( ) ; } return this ; } public NodeIterator cloneIterator ( ) { try { final TypedChildrenIterator clone = ( TypedChildrenIterator ) super . clone ( ) ; clone . _nodeType = _nodeType ; clone . setRestartable ( false ) ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public NodeIterator reset ( ) { _currentChild = hasChildren ( _startNode ) ? _offsetOrChild [ _startNode ] : END ; return resetPosition ( ) ; } public int next ( ) { final short [ ] type = _type ; final int nodeType = _nodeType ; final int [ ] nextSibling = _nextSibling ; for ( int node = _currentChild ; node != END ; node = nextSibling [ node ] ) { if ( type [ node ] == nodeType ) { _currentChild = nextSibling [ node ] ; return returnNode ( node ) ; } } return END ; } public void setMark ( ) { _markedNode = _currentChild ; } public void gotoMark ( ) { _currentChild = _markedNode ; } } private final class NamespaceChildrenIterator extends NodeIteratorBase { private final int _nsType ; private int _currentChild ; public NamespaceChildrenIterator ( final int type ) { _nsType = type ; } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( node >= _firstAttributeNode ) node = NULL ; _currentChild = hasChildren ( node ) ? _offsetOrChild [ _startNode = node ] : END ; return resetPosition ( ) ; } return this ; } public int next ( ) { for ( int node = _currentChild ; node != END ; node = _nextSibling [ node ] ) { if ( getNamespaceType ( node ) == _nsType ) { _currentChild = _nextSibling [ node ] ; return returnNode ( node ) ; } } return END ; } public void setMark ( ) { _markedNode = _currentChild ; } public void gotoMark ( ) { _currentChild = _markedNode ; } } private final class NamespaceAttributeIterator extends NodeIteratorBase { private final int _nsType ; private int _attribute ; public NamespaceAttributeIterator ( int nsType ) { super ( ) ; _nsType = nsType ; } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { for ( node = _lengthOrAttr [ _startNode = node ] ; node != NULL && getNamespaceType ( node ) != _nsType ; node = _nextSibling [ node ] ) ; _attribute = node ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int save = _attribute ; int node = save ; do { _attribute = _nextSibling [ _attribute ] ; } while ( _type [ _attribute ] == NAMESPACE ) ; for ( node = _lengthOrAttr [ _startNode = node ] ; node != NULL && getNamespaceType ( node ) != _nsType ; node = _nextSibling [ node ] ) ; _attribute = node ; return returnNode ( save ) ; } public void setMark ( ) { _markedNode = _attribute ; } public void gotoMark ( ) { _attribute = _markedNode ; } } private class FollowingSiblingIterator extends NodeIteratorBase { private int _node ; public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( node >= _firstAttributeNode ) node = NULL ; _node = _startNode = node ; return resetPosition ( ) ; } return this ; } public int next ( ) { return returnNode ( _node = _nextSibling [ _node ] ) ; } public void setMark ( ) { _markedNode = _node ; } public void gotoMark ( ) { _node = _markedNode ; } } private final class TypedFollowingSiblingIterator extends FollowingSiblingIterator { private final int _nodeType ; public TypedFollowingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != NULL ) { if ( _type [ node ] == _nodeType ) return ( node ) ; _position -- ; } return END ; } } private final class AttributeIterator extends NodeIteratorBase { private int _attribute ; public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( isElement ( node ) ) { _attribute = _lengthOrAttr [ _startNode = node ] ; while ( _type [ _attribute ] == NAMESPACE ) { _attribute = _nextSibling [ _attribute ] ; } } else { _attribute = NULL ; } return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _attribute ; _attribute = _nextSibling [ _attribute ] ; return returnNode ( node ) ; } public void setMark ( ) { _markedNode = _attribute ; } public void gotoMark ( ) { _attribute = _markedNode ; } } private final class TypedAttributeIterator extends NodeIteratorBase { private final int _nodeType ; private int _attribute ; public TypedAttributeIterator ( int nodeType ) { _nodeType = nodeType ; } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( ! isElement ( node ) ) { _attribute = END ; return resetPosition ( ) ; } for ( node = _lengthOrAttr [ _startNode = node ] ; node != NULL && _type [ node ] != _nodeType ; node = _nextSibling [ node ] ) ; _attribute = node ; return resetPosition ( ) ; } return this ; } public NodeIterator reset ( ) { int node = _startNode ; for ( node = _lengthOrAttr [ node ] ; node != NULL && _type [ node ] != _nodeType ; node = _nextSibling [ node ] ) ; _attribute = node ; return resetPosition ( ) ; } public int next ( ) { final int node = _attribute ; _attribute = NULL ; return returnNode ( node ) ; } public void setMark ( ) { _markedNode = _attribute ; } public void gotoMark ( ) { _attribute = _markedNode ; } } private class NamespaceIterator extends NodeIteratorBase { protected int _node ; protected int _ns ; public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( isElement ( node ) ) { _startNode = _node = node ; _ns = _lengthOrAttr [ _node ] ; while ( ( _ns != DOM . NULL ) && ( _type [ _ns ] != NAMESPACE ) ) { _ns = _nextSibling [ _ns ] ; } } else { _ns = DOM . NULL ; } return resetPosition ( ) ; } return this ; } public int next ( ) { while ( _node != NULL ) { final int node = _ns ; _ns = _nextSibling [ _ns ] ; while ( ( _ns == DOM . NULL ) && ( _node != DOM . NULL ) ) { _node = _parent [ _node ] ; _ns = _lengthOrAttr [ _node ] ; while ( ( _ns != DOM . NULL ) && ( _type [ _ns ] != NAMESPACE ) ) { _ns = _nextSibling [ _ns ] ; } } if ( _type [ node ] == NAMESPACE ) return returnNode ( node ) ; } return NULL ; } public void setMark ( ) { _markedNode = _ns ; } public void gotoMark ( ) { _ns = _markedNode ; } } private final class TypedNamespaceIterator extends NamespaceIterator { final int _uriType ; public TypedNamespaceIterator ( int type ) { _uriType = type ; } public int next ( ) { int node ; while ( ( node = _ns ) != DOM . NULL ) { _ns = _nextSibling [ _ns ] ; while ( ( _ns == DOM . NULL ) && ( _node != DOM . NULL ) ) { _node = _parent [ _node ] ; _ns = _lengthOrAttr [ _node ] ; while ( ( _ns != DOM . NULL ) && ( _type [ _ns ] != NAMESPACE ) ) { _ns = _nextSibling [ _ns ] ; } } if ( _prefix [ node ] == _uriType ) return returnNode ( node ) ; } return DOM . NULL ; } } private class PrecedingSiblingIterator extends NodeIteratorBase { private int _node ; private int _mom ; public boolean isReverse ( ) { return true ; } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( node >= _firstAttributeNode ) node = NULL ; int tmp = NULL ; _startNode = node ; _mom = _parent [ node ] ; _node = _offsetOrChild [ _mom ] ; while ( ( _node != node ) && ( _node != NULL ) ) { tmp = _node ; _node = _nextSibling [ _node ] ; } _node = tmp ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _node == NULL ) return NULL ; int current = _offsetOrChild [ _mom ] ; int last = NULL ; while ( ( current != _node ) && ( current != NULL ) ) { last = current ; current = _nextSibling [ current ] ; } current = _node ; _node = last ; return returnNode ( current ) ; } public void setMark ( ) { _markedNode = _node ; } public void gotoMark ( ) { _node = _markedNode ; } } private final class TypedPrecedingSiblingIterator extends PrecedingSiblingIterator { private final int _nodeType ; public TypedPrecedingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != NULL && _type [ node ] != _nodeType ) _position -- ; return ( node ) ; } } private class PrecedingIterator extends NodeIteratorBase { private int _node = 0 ; private int _mom = 0 ; public boolean isReverse ( ) { return true ; } public NodeIterator cloneIterator ( ) { try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; clone . setRestartable ( false ) ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( node >= _firstAttributeNode ) node = _parent [ node ] ; _node = _startNode = node ; _mom = _parent [ _startNode ] ; return resetPosition ( ) ; } return this ; } public int next ( ) { while ( -- _node > ROOTNODE ) { if ( _node < _mom ) _mom = _parent [ _mom ] ; if ( _node != _mom ) return returnNode ( _node ) ; } return ( NULL ) ; } public NodeIterator reset ( ) { _node = _startNode ; _mom = _parent [ _startNode ] ; return resetPosition ( ) ; } public void setMark ( ) { _markedNode = _node ; } public void gotoMark ( ) { _node = _markedNode ; } } private final class TypedPrecedingIterator extends PrecedingIterator { private final int _nodeType ; public TypedPrecedingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != NULL && _type [ node ] != _nodeType ) _position -- ; return node ; } } private class FollowingIterator extends NodeIteratorBase { protected int _node ; public NodeIterator setStartNode ( int node ) { int skip = 0 ; if ( _isRestartable ) { if ( node >= _firstAttributeNode ) { skip = 1 ; node = _parent [ node ] ; int child = _offsetOrChild [ node ] ; if ( child != NULL ) node = child ; } _startNode = node ; int current ; while ( ( node = lastChild ( current = node ) ) != NULL ) { } _node = current - skip ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _node + 1 ; return node < _firstAttributeNode ? returnNode ( _node = node ) : NULL ; } public void setMark ( ) { _markedNode = _node ; } public void gotoMark ( ) { _node = _markedNode ; } } private final class TypedFollowingIterator extends FollowingIterator { private final int _nodeType ; public TypedFollowingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != NULL ) { if ( _type [ node ] == _nodeType ) return ( node ) ; _position -- ; } return END ; } } private class AncestorIterator extends NodeIteratorBase { protected int _index ; protected int _last = - 1 ; public final boolean isReverse ( ) { return true ; } public int getLast ( ) { if ( _last > - 1 ) return _last ; int count = 1 ; int node = _startNode ; while ( ( node = _parent [ node ] ) != ROOT ) count ++ ; _last = count ; return ( count ) ; } public NodeIterator cloneIterator ( ) { try { final AncestorIterator clone = ( AncestorIterator ) super . clone ( ) ; clone . setRestartable ( false ) ; clone . _startNode = _startNode ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { _last = - 1 ; if ( _includeSelf ) { _startNode = node ; } else if ( node >= _firstAttributeNode ) { _startNode = node = _parent [ node ] ; } else { _startNode = _parent [ node ] ; } _index = _startNode ; return resetPosition ( ) ; } return this ; } public NodeIterator reset ( ) { _index = _startNode ; return resetPosition ( ) ; } public int next ( ) { if ( _index >= 0 ) { final int node = _index ; _index = ( _index == 0 ) ? - 1 : _parent [ _index ] ; return returnNode ( node ) ; } return ( NULL ) ; } public void setMark ( ) { _markedNode = _index ; } public void gotoMark ( ) { _index = _markedNode ; } } private final class TypedAncestorIterator extends AncestorIterator { private final int _nodeType ; public TypedAncestorIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != NULL ) { if ( _type [ node ] == _nodeType ) return ( node ) ; _position -- ; } return ( NULL ) ; } public int getLast ( ) { if ( _last > - 1 ) return _last ; int count = 1 ; int node = _startNode ; do { if ( _type [ node ] == _nodeType ) count ++ ; } while ( ( node = _parent [ node ] ) != ROOT ) ; _last = count ; return ( count ) ; } } private class DescendantIterator extends NodeIteratorBase { protected int _node ; protected int _limit ; public NodeIterator setStartNode ( int node ) { _startNode = node ; if ( _isRestartable ) { _node = _startNode = _includeSelf ? node - 1 : node ; if ( hasChildren ( node ) == false ) { _limit = node + 1 ; } else if ( ( node = _nextSibling [ node ] ) == 0 ) { _limit = _treeNodeLimit ; } else { _limit = leftmostDescendant ( node ) ; } return resetPosition ( ) ; } return this ; } public int next ( ) { while ( ++ _node < _limit ) { if ( _type [ _node ] > TEXT ) { return ( returnNode ( _node ) ) ; } } return ( NULL ) ; } public void setMark ( ) { _markedNode = _node ; } public void gotoMark ( ) { _node = _markedNode ; } } private final class TypedDescendantIterator extends DescendantIterator { private final int _nodeType ; public TypedDescendantIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int limit = _limit ; final int type = _nodeType ; int node = _node + 1 ; while ( node < limit && _type [ node ] != type ) { ++ node ; } return node < limit ? returnNode ( _node = node ) : NULL ; } } private class NthDescendantIterator extends DescendantIterator { final NodeIterator _source ; final int _pos ; final int _ourtype ; public NthDescendantIterator ( NodeIterator source , int pos , int type ) { _source = source ; _ourtype = type ; _pos = pos ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public NodeIterator setStartNode ( int node ) { _source . setStartNode ( node ) ; return this ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { int parent = _parent [ node ] ; int child = _offsetOrChild [ parent ] ; int pos = 0 ; if ( _ourtype != - 1 ) { do { if ( isElement ( child ) && _type [ child ] == _ourtype ) pos ++ ; } while ( ( pos < _pos ) && ( child = _nextSibling [ child ] ) != 0 ) ; } else { do { if ( isElement ( child ) ) pos ++ ; } while ( ( pos < _pos ) && ( child = _nextSibling [ child ] ) != 0 ) ; } if ( node == child ) return node ; } return ( END ) ; } public NodeIterator reset ( ) { _source . reset ( ) ; return this ; } } private final class TypedSingletonIterator extends SingletonIterator { private final int _nodeType ; public TypedSingletonIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int result = super . next ( ) ; return _type [ result ] == _nodeType ? result : NULL ; } } private final class StrippingIterator extends NodeIteratorBase { private static final int USE_PREDICATE = 0 ; private static final int STRIP_SPACE = 1 ; private static final int PRESERVE_SPACE = 2 ; private StripFilter _filter = null ; private short [ ] _mapping = null ; private final NodeIterator _source ; private boolean _children = false ; private int _action = USE_PREDICATE ; private int _last = - 1 ; public StrippingIterator ( NodeIterator source , short [ ] mapping , StripFilter filter ) { _filter = filter ; _mapping = mapping ; _source = source ; if ( _source instanceof ChildrenIterator || _source instanceof TypedChildrenIterator ) { _children = true ; } } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public NodeIterator setStartNode ( int node ) { if ( _children ) { if ( _filter . stripSpace ( ( DOM ) DOMImpl . this , node , _mapping [ _type [ node ] ] ) ) _action = STRIP_SPACE ; else _action = PRESERVE_SPACE ; } _source . setStartNode ( node ) ; return ( this ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { switch ( _action ) { case STRIP_SPACE : if ( _whitespace . getBit ( node ) ) continue ; case PRESERVE_SPACE : return returnNode ( node ) ; case USE_PREDICATE : default : if ( _whitespace . getBit ( node ) && _filter . stripSpace ( ( DOM ) DOMImpl . this , node , _mapping [ _type [ _parent [ node ] ] ] ) ) continue ; return returnNode ( node ) ; } } return END ; } public NodeIterator reset ( ) { _source . reset ( ) ; return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } public int getLast ( ) { if ( _last != - 1 ) return _last ; int count = getPosition ( ) ; int node ; _source . setMark ( ) ; while ( ( node = _source . next ( ) ) != END ) { switch ( _action ) { case STRIP_SPACE : if ( _whitespace . getBit ( node ) ) continue ; case PRESERVE_SPACE : count ++ ; break ; case USE_PREDICATE : default : if ( _whitespace . getBit ( node ) && _filter . stripSpace ( ( DOM ) DOMImpl . this , node , _mapping [ _type [ _parent [ node ] ] ] ) ) continue ; else count ++ ; } } _source . gotoMark ( ) ; _last = count ; return ( count ) ; } } public NodeIterator strippingIterator ( NodeIterator iterator , short [ ] mapping , StripFilter filter ) { return ( new StrippingIterator ( iterator , mapping , filter ) ) ; } private final class NodeValueIterator extends NodeIteratorBase { private NodeIterator _source ; private String _value ; private boolean _op ; private final boolean _isReverse ; private int _returnType = RETURN_PARENT ; private int _pos ; public NodeValueIterator ( NodeIterator source , int returnType , String value , boolean op ) { _source = source ; _returnType = returnType ; _value = value ; _op = op ; _isReverse = source . isReverse ( ) ; } public boolean isReverse ( ) { return _isReverse ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public NodeIterator cloneIterator ( ) { try { NodeValueIterator clone = ( NodeValueIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . setRestartable ( false ) ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public NodeIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { String val = getNodeValue ( node ) ; if ( _value . equals ( val ) == _op ) { if ( _returnType == RETURN_CURRENT ) return returnNode ( node ) ; else return returnNode ( _parent [ node ] ) ; } } return END ; } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; return resetPosition ( ) ; } return this ; } public void setMark ( ) { _source . setMark ( ) ; _pos = _position ; } public void gotoMark ( ) { _source . gotoMark ( ) ; _position = _pos ; } } public NodeIterator getNodeValueIterator ( NodeIterator iterator , int type , String value , boolean op ) { return ( new NodeValueIterator ( iterator , type , value , op ) ) ; } public NodeIterator orderNodes ( NodeIterator source , int node ) { return new DupFilterIterator ( source ) ; } private int leftmostDescendant ( int node ) { int current ; while ( _type [ current = node ] >= NTYPES && ( node = _offsetOrChild [ node ] ) != NULL ) { } return current ; } private int lastChild ( int node ) { if ( isElement ( node ) || node == ROOTNODE ) { int child ; if ( ( child = _offsetOrChild [ node ] ) != NULL ) { while ( ( child = _nextSibling [ node = child ] ) != NULL ) { } return node ; } } return 0 ; } public int getParent ( final int node ) { return _parent [ node ] ; } public int getElementPosition ( int node ) { int match = 0 ; int curr = _offsetOrChild [ _parent [ node ] ] ; if ( isElement ( curr ) ) match ++ ; while ( curr != node ) { curr = _nextSibling [ curr ] ; if ( isElement ( curr ) ) match ++ ; } return match ; } public int getAttributePosition ( int attr ) { int match = 1 ; int curr = _lengthOrAttr [ _parent [ attr ] ] ; while ( curr != attr ) { curr = _nextSibling [ curr ] ; match ++ ; } return match ; } public int getTypedPosition ( int type , int node ) { switch ( type ) { case ELEMENT : return getElementPosition ( node ) ; case ATTRIBUTE : return getAttributePosition ( node ) ; case - 1 : type = _type [ node ] ; } int match = 0 ; int curr = _offsetOrChild [ _parent [ node ] ] ; if ( _type [ curr ] == type ) match ++ ; while ( curr != node ) { curr = _nextSibling [ curr ] ; if ( _type [ curr ] == type ) match ++ ; } return match ; } public int getTypedLast ( int type , int node ) { if ( type == - 1 ) type = _type [ node ] ; int match = 0 ; int curr = _offsetOrChild [ _parent [ node ] ] ; if ( _type [ curr ] == type ) match ++ ; while ( curr != NULL ) { curr = _nextSibling [ curr ] ; if ( _type [ curr ] == type ) match ++ ; } return match ; } public NodeIterator getIterator ( ) { return new SingletonIterator ( ROOTNODE ) ; } public int getType ( final int node ) { return ( node >= _type . length ) ? 0 : _type [ node ] ; } public int getNamespaceType ( final int node ) { final int type = _type [ node ] ; return ( type >= NTYPES ) ? _namespace [ type - NTYPES ] : 0 ; } public short [ ] getTypeArray ( ) { return _type ; } public String getNodeValue ( final int node ) { if ( ( node == NULL ) || ( node > _treeNodeLimit ) ) return EMPTYSTRING ; switch ( _type [ node ] ) { case ROOT : return getNodeValue ( _offsetOrChild [ node ] ) ; case TEXT : case COMMENT : return makeStringValue ( node ) ; case PROCESSING_INSTRUCTION : final String pistr = makeStringValue ( node ) ; final int col = pistr . indexOf ( ' ' ) ; return ( col > 0 ) ? pistr . substring ( col + 1 ) : pistr ; default : return ( node < _firstAttributeNode ) ? getElementValue ( node ) : makeStringValue ( node ) ; } } private String getLocalName ( int node ) { final int type = _type [ node ] - NTYPES ; final String qname = _namesArray [ type ] ; final String uri = _uriArray [ _namespace [ type ] ] ; if ( uri != null ) { final int len = uri . length ( ) ; if ( len > 0 ) return qname . substring ( len + 1 ) ; } return qname ; } private Hashtable setupMapping ( String [ ] namesArray ) { final int nNames = namesArray . length ; final Hashtable types = new Hashtable ( nNames ) ; for ( int i = 0 ; i < nNames ; i ++ ) { types . put ( namesArray [ i ] , new Integer ( i + NTYPES ) ) ; } return types ; } public int getGeneralizedType ( final String name ) { final Integer type = ( Integer ) _types . get ( name ) ; if ( type == null ) { final int code = name . charAt ( 0 ) == '@' ? ATTRIBUTE : ELEMENT ; _types . put ( name , new Integer ( code ) ) ; return code ; } else { return type . intValue ( ) ; } } public short [ ] getMapping ( String [ ] names ) { int i ; final int namesLength = names . length ; final int mappingLength = _namesArray . length + NTYPES ; final short [ ] result = new short [ mappingLength ] ; for ( i = 0 ; i < NTYPES ; i ++ ) result [ i ] = ( short ) i ; for ( i = NTYPES ; i < mappingLength ; i ++ ) { final int type = i - NTYPES ; final String name = _namesArray [ type ] ; final String uri = _uriArray [ _namespace [ type ] ] ; int len = 0 ; if ( uri != null ) { len = uri . length ( ) ; if ( len > 0 ) len ++ ; } result [ i ] = ( short ) ( ( name . length ( ) > 0 && name . charAt ( len ) == '@' ) ? ATTRIBUTE : ELEMENT ) ; } for ( i = 0 ; i < namesLength ; i ++ ) { result [ getGeneralizedType ( names [ i ] ) ] = ( short ) ( i + NTYPES ) ; } return result ; } public short [ ] getReverseMapping ( String [ ] names ) { int i ; final short [ ] result = new short [ names . length + NTYPES ] ; for ( i = 0 ; i < NTYPES ; i ++ ) { result [ i ] = ( short ) i ; } for ( i = 0 ; i < names . length ; i ++ ) { result [ i + NTYPES ] = ( short ) getGeneralizedType ( names [ i ] ) ; if ( result [ i + NTYPES ] == ELEMENT ) result [ i + NTYPES ] = NO_TYPE ; } return result ; } public short [ ] getNamespaceMapping ( String [ ] namespaces ) { int i ; final int nsLength = namespaces . length ; final int mappingLength = _uriArray . length ; final short [ ] result = new short [ mappingLength ] ; for ( i = 0 ; i < mappingLength ; i ++ ) result [ i ] = ( - 1 ) ; for ( i = 0 ; i < nsLength ; i ++ ) { Integer type = ( Integer ) _nsIndex . get ( namespaces [ i ] ) ; if ( type != null ) { result [ type . intValue ( ) ] = ( short ) i ; } } return ( result ) ; } public short [ ] getReverseNamespaceMapping ( String [ ] namespaces ) { int i ; final int length = namespaces . length ; final short [ ] result = new short [ length ] ; for ( i = 0 ; i < length ; i ++ ) { Integer type = ( Integer ) _nsIndex . get ( namespaces [ i ] ) ; result [ i ] = ( type == null ) ? - 1 : type . shortValue ( ) ; } return result ; } public void writeExternal ( ObjectOutput out ) throws IOException { out . writeInt ( _treeNodeLimit ) ; out . writeInt ( _firstAttributeNode ) ; out . writeObject ( _documentURI ) ; out . writeObject ( _type ) ; out . writeObject ( _namespace ) ; out . writeObject ( _prefix ) ; out . writeObject ( _parent ) ; out . writeObject ( _nextSibling ) ; out . writeObject ( _offsetOrChild ) ; out . writeObject ( _lengthOrAttr ) ; out . writeObject ( _text ) ; out . writeObject ( _namesArray ) ; out . writeObject ( _uriArray ) ; out . writeObject ( _prefixArray ) ; out . writeObject ( _whitespace ) ; if ( _dontEscape != null ) { out . writeObject ( _dontEscape ) ; } else { out . writeObject ( new BitArray ( 0 ) ) ; } out . flush ( ) ; } public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { _treeNodeLimit = in . readInt ( ) ; _firstAttributeNode = in . readInt ( ) ; _documentURI = ( String ) in . readObject ( ) ; _type = ( short [ ] ) in . readObject ( ) ; _namespace = ( short [ ] ) in . readObject ( ) ; _prefix = ( short [ ] ) in . readObject ( ) ; _parent = ( int [ ] ) in . readObject ( ) ; _nextSibling = ( int [ ] ) in . readObject ( ) ; _offsetOrChild = ( int [ ] ) in . readObject ( ) ; _lengthOrAttr = ( int [ ] ) in . readObject ( ) ; _text = ( char [ ] ) in . readObject ( ) ; _namesArray = ( String [ ] ) in . readObject ( ) ; _uriArray = ( String [ ] ) in . readObject ( ) ; _prefixArray = ( String [ ] ) in . readObject ( ) ; _whitespace = ( BitArray ) in . readObject ( ) ; _dontEscape = ( BitArray ) in . readObject ( ) ; if ( _dontEscape . size ( ) == 0 ) { _dontEscape = null ; } _types = setupMapping ( _namesArray ) ; } public DOMImpl ( ) { this ( 8 * 1024 ) ; } public DOMImpl ( int size ) { _type = new short [ size ] ; _parent = new int [ size ] ; _nextSibling = new int [ size ] ; _offsetOrChild = new int [ size ] ; _lengthOrAttr = new int [ size ] ; _text = new char [ size * 10 ] ; _whitespace = new BitArray ( size ) ; _prefix = new short [ size ] ; } public void print ( int node , int level ) { switch ( _type [ node ] ) { case ROOT : print ( _offsetOrChild [ node ] , level ) ; break ; case TEXT : case COMMENT : case PROCESSING_INSTRUCTION : System . out . print ( makeStringValue ( node ) ) ; break ; default : final String name = getNodeName ( node ) ; System . out . print ( "<" + name ) ; for ( int a = _lengthOrAttr [ node ] ; a != NULL ; a = _nextSibling [ a ] ) { System . out . print ( "\n" + getNodeName ( a ) + "=\"" + makeStringValue ( a ) + "\"" ) ; } System . out . print ( '>' ) ; for ( int child = _offsetOrChild [ node ] ; child != NULL ; child = _nextSibling [ child ] ) { print ( child , level + 1 ) ; } System . out . println ( "</" + name + '>' ) ; break ; } } public String getNodeName ( final int node ) { final short type = _type [ node ] ; switch ( type ) { case DOM . ROOT : case DOM . TEXT : case DOM . ELEMENT : case DOM . ATTRIBUTE : case DOM . COMMENT : return EMPTYSTRING ; case DOM . NAMESPACE : final int index = _prefix [ node ] ; return ( index < _prefixArray . length ) ? _prefixArray [ index ] : EMPTYSTRING ; case DOM . PROCESSING_INSTRUCTION : final String pistr = makeStringValue ( node ) ; final int col = pistr . indexOf ( ' ' ) ; return ( col > - 1 ) ? pistr . substring ( 0 , col ) : pistr ; default : String name = getLocalName ( node ) ; if ( node >= _firstAttributeNode ) name = name . substring ( 1 ) ; final int pi = _prefix [ node ] ; if ( pi > 0 ) { final String prefix = _prefixArray [ pi ] ; if ( prefix != EMPTYSTRING ) { name = prefix + ':' + name ; } } return name ; } } public String getNamespaceName ( final int node ) { if ( _type [ node ] == NAMESPACE ) { return ( EMPTYSTRING ) ; } else { final int type = getNamespaceType ( node ) ; final String name = _uriArray [ type ] ; return ( name == null ) ? EMPTYSTRING : name ; } } private String makeStringValue ( final int node ) { return new String ( _text , _offsetOrChild [ node ] , _lengthOrAttr [ node ] ) ; } public int getAttributeNode ( final int type , final int element ) { for ( int attr = _lengthOrAttr [ element ] ; attr != NULL ; attr = _nextSibling [ attr ] ) { if ( _type [ attr ] == type ) return attr ; } return NULL ; } public String getAttributeValue ( final int type , final int element ) { final int attr = getAttributeNode ( type , element ) ; return ( attr != NULL ) ? makeStringValue ( attr ) : EMPTYSTRING ; } public boolean hasAttribute ( final int type , final int node ) { return ( getAttributeNode ( type , node ) != NULL ) ; } public String getAttributeValue ( final String name , final int element ) { return getAttributeValue ( getGeneralizedType ( name ) , element ) ; } private boolean hasChildren ( final int node ) { if ( node < _firstAttributeNode ) { final int type = _type [ node ] ; return ( ( ( type >= NTYPES ) || ( type == ROOT ) ) && ( _offsetOrChild [ node ] != 0 ) ) ; } return ( false ) ; } public NodeIterator getChildren ( final int node ) { return hasChildren ( node ) ? new ChildrenIterator ( ) : EMPTYITERATOR ; } public NodeIterator getTypedChildren ( final int type ) { return ( new TypedChildrenIterator ( type ) ) ; } public NodeIterator getAxisIterator ( final int axis ) { NodeIterator iterator = null ; switch ( axis ) { case Axis . SELF : iterator = new SingletonIterator ( ) ; break ; case Axis . CHILD : iterator = new ChildrenIterator ( ) ; break ; case Axis . PARENT : return ( new ParentIterator ( ) ) ; case Axis . ANCESTOR : return ( new AncestorIterator ( ) ) ; case Axis . ANCESTORORSELF : return ( ( new AncestorIterator ( ) ) . includeSelf ( ) ) ; case Axis . ATTRIBUTE : return ( new AttributeIterator ( ) ) ; case Axis . DESCENDANT : iterator = new DescendantIterator ( ) ; break ; case Axis . DESCENDANTORSELF : iterator = ( new DescendantIterator ( ) ) . includeSelf ( ) ; break ; case Axis . FOLLOWING : iterator = new FollowingIterator ( ) ; break ; case Axis . PRECEDING : iterator = new PrecedingIterator ( ) ; break ; case Axis . FOLLOWINGSIBLING : iterator = new FollowingSiblingIterator ( ) ; break ; case Axis . PRECEDINGSIBLING : iterator = new PrecedingSiblingIterator ( ) ; break ; case Axis . NAMESPACE : iterator = new NamespaceIterator ( ) ; break ; default : BasisLibrary . runTimeError ( BasisLibrary . AXIS_SUPPORT_ERR , Axis . names [ axis ] ) ; } return ( iterator ) ; } public NodeIterator getTypedAxisIterator ( int axis , int type ) { if ( axis == Axis . CHILD && type != ELEMENT ) { return new TypedChildrenIterator ( type ) ; } if ( type == NO_TYPE ) { return EMPTYITERATOR ; } if ( type == ELEMENT && axis != Axis . NAMESPACE ) { return new FilterIterator ( getAxisIterator ( axis ) , getElementFilter ( ) ) ; } else { switch ( axis ) { case Axis . SELF : return new TypedSingletonIterator ( type ) ; case Axis . PARENT : return new ParentIterator ( ) . setNodeType ( type ) ; case Axis . ANCESTOR : return new TypedAncestorIterator ( type ) ; case Axis . ANCESTORORSELF : return ( new TypedAncestorIterator ( type ) ) . includeSelf ( ) ; case Axis . ATTRIBUTE : return new TypedAttributeIterator ( type ) ; case Axis . DESCENDANT : return new TypedDescendantIterator ( type ) ; case Axis . DESCENDANTORSELF : return ( new TypedDescendantIterator ( type ) ) . includeSelf ( ) ; case Axis . FOLLOWING : return new TypedFollowingIterator ( type ) ; case Axis . PRECEDING : return new TypedPrecedingIterator ( type ) ; case Axis . FOLLOWINGSIBLING : return new TypedFollowingSiblingIterator ( type ) ; case Axis . PRECEDINGSIBLING : return new TypedPrecedingSiblingIterator ( type ) ; case Axis . NAMESPACE : return ( type == ELEMENT ) ? ( NodeIterator ) new NamespaceIterator ( ) : ( NodeIterator ) new TypedNamespaceIterator ( type ) ; default : BasisLibrary . runTimeError ( BasisLibrary . TYPED_AXIS_SUPPORT_ERR , Axis . names [ axis ] ) ; } } return null ; } public NodeIterator getNamespaceAxisIterator ( int axis , int ns ) { if ( ns == NO_TYPE ) { return EMPTYITERATOR ; } else { switch ( axis ) { case Axis . CHILD : return new NamespaceChildrenIterator ( ns ) ; case Axis . ATTRIBUTE : return new NamespaceAttributeIterator ( ns ) ; default : BasisLibrary . runTimeError ( BasisLibrary . TYPED_AXIS_SUPPORT_ERR , Axis . names [ axis ] ) ; } } return null ; } public NodeIterator getTypedDescendantIterator ( int type ) { return ( type == ELEMENT ) ? ( NodeIterator ) new FilterIterator ( new DescendantIterator ( ) , getElementFilter ( ) ) : ( NodeIterator ) new TypedDescendantIterator ( type ) ; } public NodeIterator getNthDescendant ( int type , int n , boolean includeself ) { NodeIterator source = ( type == ELEMENT ) ? ( NodeIterator ) new FilterIterator ( new DescendantIterator ( ) , getElementFilter ( ) ) : ( NodeIterator ) new TypedDescendantIterator ( type ) ; if ( includeself ) { ( ( NodeIteratorBase ) source ) . includeSelf ( ) ; } return new NthDescendantIterator ( source , n , type ) ; } public void characters ( final int textNode , TransletOutputHandler handler ) throws TransletException { handler . characters ( _text , _offsetOrChild [ textNode ] , _lengthOrAttr [ textNode ] ) ; } public void copy ( NodeIterator nodes , TransletOutputHandler handler ) throws TransletException { int node ; while ( ( node = nodes . next ( ) ) != NULL ) { copy ( node , handler ) ; } } public void copy ( TransletOutputHandler handler ) throws TransletException { copy ( ROOTNODE , handler ) ; } public void copy ( final int node , TransletOutputHandler handler ) throws TransletException { final int type = _type [ node ] ; switch ( type ) { case ROOT : for ( int c = _offsetOrChild [ node ] ; c != NULL ; c = _nextSibling [ c ] ) copy ( c , handler ) ; break ; case PROCESSING_INSTRUCTION : copyPI ( node , handler ) ; break ; case COMMENT : handler . comment ( new String ( _text , _offsetOrChild [ node ] , _lengthOrAttr [ node ] ) ) ; break ; case TEXT : boolean last = false ; boolean escapeBit = false ; if ( _dontEscape != null ) { escapeBit = _dontEscape . getBit ( node ) ; if ( escapeBit ) { last = handler . setEscaping ( false ) ; } } handler . characters ( _text , _offsetOrChild [ node ] , _lengthOrAttr [ node ] ) ; if ( _dontEscape != null && escapeBit ) { handler . setEscaping ( last ) ; } break ; case ATTRIBUTE : shallowCopy ( node , handler ) ; break ; case NAMESPACE : shallowCopy ( node , handler ) ; break ; default : if ( isElement ( node ) ) { final String name = copyElement ( node , type , handler ) ; for ( int a = _lengthOrAttr [ node ] ; a != NULL ; a = _nextSibling [ a ] ) { if ( _type [ a ] != NAMESPACE ) { final String uri = getNamespaceName ( a ) ; if ( uri != EMPTYSTRING ) { final String prefix = _prefixArray [ _prefix [ a ] ] ; handler . namespace ( prefix , uri ) ; } handler . attribute ( getNodeName ( a ) , makeStringValue ( a ) ) ; } else { handler . namespace ( _prefixArray [ _prefix [ a ] ] , makeStringValue ( a ) ) ; } } for ( int c = _offsetOrChild [ node ] ; c != NULL ; c = _nextSibling [ c ] ) copy ( c , handler ) ; handler . endElement ( name ) ; } else { final String uri = getNamespaceName ( node ) ; if ( uri != EMPTYSTRING ) { final String prefix = _prefixArray [ _prefix [ node ] ] ; handler . namespace ( prefix , uri ) ; } handler . attribute ( getNodeName ( node ) , makeStringValue ( node ) ) ; } break ; } } private void copyPI ( final int node , TransletOutputHandler handler ) throws TransletException { final char [ ] text = _text ; final int start = _offsetOrChild [ node ] ; final int length = _lengthOrAttr [ node ] ; int i = start ; while ( text [ i ] != ' ' ) i ++ ; final int len = i - start ; final String target = new String ( text , start , len ) ; final String value = new String ( text , i + 1 , length - len - 1 ) ; handler . processingInstruction ( target , value ) ; } public String shallowCopy ( final int node , TransletOutputHandler handler ) throws TransletException { final int type = _type [ node ] ; switch ( type ) { case ROOT : return EMPTYSTRING ; case TEXT : handler . characters ( _text , _offsetOrChild [ node ] , _lengthOrAttr [ node ] ) ; return null ; case PROCESSING_INSTRUCTION : copyPI ( node , handler ) ; return null ; case COMMENT : final String comment = new String ( _text , _offsetOrChild [ node ] , _lengthOrAttr [ node ] ) ; handler . comment ( comment ) ; return null ; case NAMESPACE : handler . namespace ( _prefixArray [ _prefix [ node ] ] , makeStringValue ( node ) ) ; return null ; default : if ( isElement ( node ) ) { return ( copyElement ( node , type , handler ) ) ; } else { final String uri = getNamespaceName ( node ) ; if ( uri != EMPTYSTRING ) { final String prefix = _prefixArray [ _prefix [ node ] ] ; handler . namespace ( prefix , uri ) ; } handler . attribute ( getNodeName ( node ) , makeStringValue ( node ) ) ; return null ; } } } private String copyElement ( int node , int type , TransletOutputHandler handler ) throws TransletException { type = type - NTYPES ; String name = _namesArray [ type ] ; final int pi = _prefix [ node ] ; final int ui = _namespace [ type ] ; if ( pi > 0 ) { final String prefix = _prefixArray [ pi ] ; final String uri = _uriArray [ ui ] ; final String local = getLocalName ( node ) ; name = prefix . equals ( EMPTYSTRING ) ? local : ( prefix + ':' + local ) ; handler . startElement ( name ) ; handler . namespace ( prefix , uri ) ; } else { if ( ui > 0 ) { handler . startElement ( name = getLocalName ( node ) ) ; handler . namespace ( EMPTYSTRING , _uriArray [ ui ] ) ; } else { handler . startElement ( name ) ; } } for ( int a = _lengthOrAttr [ node ] ; a != NULL ; a = _nextSibling [ a ] ) { if ( _type [ a ] == NAMESPACE ) { handler . namespace ( _prefixArray [ _prefix [ a ] ] , makeStringValue ( a ) ) ; } } return name ; } private String _cachedStringValue = null ; public String getStringValue ( ) { if ( _cachedStringValue == null ) { _cachedStringValue = getElementValue ( ROOTNODE ) ; } return _cachedStringValue ; } public String getElementValue ( final int element ) { final int child = _offsetOrChild [ element ] ; if ( child == NULL ) return EMPTYSTRING ; if ( ( _type [ child ] == TEXT ) && ( _nextSibling [ child ] == NULL ) ) return makeStringValue ( child ) ; else return stringValueAux ( new StringBuffer ( ) , element ) . toString ( ) ; } private StringBuffer stringValueAux ( StringBuffer buffer , final int element ) { for ( int child = _offsetOrChild [ element ] ; child != NULL ; child = _nextSibling [ child ] ) { switch ( _type [ child ] ) { case TEXT : buffer . append ( _text , _offsetOrChild [ child ] , _lengthOrAttr [ child ] ) ; break ; case PROCESSING_INSTRUCTION : case COMMENT : break ; default : stringValueAux ( buffer , child ) ; } } return buffer ; } public String getTreeString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf = getElementString ( buf , ROOTNODE ) ; return buf . toString ( ) ; } private StringBuffer getElementString ( StringBuffer buffer , int element ) { String name = null ; if ( isElement ( element ) ) { if ( ( name = getNodeName ( element ) ) != null ) { buffer . append ( '<' ) ; buffer . append ( name ) ; int attribute = _lengthOrAttr [ element ] ; while ( attribute != NULL ) { if ( _type [ attribute ] != NAMESPACE ) { buffer . append ( ' ' ) . append ( getNodeName ( attribute ) ) . append ( "=\"" ) . append ( getNodeValue ( attribute ) ) . append ( '"' ) ; } attribute = _nextSibling [ attribute ] ; } if ( _offsetOrChild [ element ] == NULL ) { buffer . append ( "/>" ) ; return buffer ; } buffer . append ( '>' ) ; } } for ( int child = _offsetOrChild [ element ] ; child != NULL ; child = _nextSibling [ child ] ) { switch ( _type [ child ] ) { case COMMENT : buffer . append ( "<!--" ) ; buffer . append ( _text , _offsetOrChild [ child ] , _lengthOrAttr [ child ] ) ; buffer . append ( "-->" ) ; break ; case TEXT : buffer . append ( _text , _offsetOrChild [ child ] , _lengthOrAttr [ child ] ) ; break ; case PROCESSING_INSTRUCTION : buffer . append ( "<?" ) ; buffer . append ( _text , _offsetOrChild [ child ] , _lengthOrAttr [ child ] ) ; buffer . append ( "?>" ) ; break ; default : getElementString ( buffer , child ) ; } } if ( isElement ( element ) && name != null ) { buffer . append ( "</" ) ; buffer . append ( name ) ; buffer . append ( ">" ) ; } return buffer ; } public String getLanguage ( int node ) { final Integer langType = ( Integer ) _types . get ( XML_LANG_ATTRIBUTE ) ; if ( langType != null ) { final int type = langType . intValue ( ) ; while ( node != DOM . NULL ) { int attr = _lengthOrAttr [ node ] ; while ( attr != DOM . NULL ) { if ( _type [ attr ] == type ) return ( getNodeValue ( attr ) ) ; attr = _nextSibling [ attr ] ; } node = getParent ( node ) ; } } return ( null ) ; } public DOMBuilder getBuilder ( ) { return new DOMBuilderImpl ( ) ; } public TransletOutputHandler getOutputDomBuilder ( ) { return new SAXAdapter ( new DOMBuilderImpl ( ) ) ; } private static final boolean isWhitespaceChar ( char c ) { return c == 0x20 || c == 0x0A || c == 0x0D || c == 0x09 ; } private final class DOMBuilderImpl implements DOMBuilder { private final static int ATTR_ARRAY_SIZE = 32 ; private final static int REUSABLE_TEXT_SIZE = 32 ; private final static int INIT_STACK_LENGTH = 64 ; private Hashtable _shortTexts = null ; private Hashtable _names = null ; private int _nextNameCode = NTYPES ; private int _parentStackLength = INIT_STACK_LENGTH ; private int [ ] _parentStack = new int [ INIT_STACK_LENGTH ] ; private int [ ] _previousSiblingStack = new int [ INIT_STACK_LENGTH ] ; private int _sp ; private int _baseOffset = 0 ; private int _currentOffset = 0 ; private int _currentNode = 0 ; private int _currentAttributeNode = 1 ; private short [ ] _type2 = new short [ ATTR_ARRAY_SIZE ] ; private short [ ] _prefix2 = new short [ ATTR_ARRAY_SIZE ] ; private int [ ] _parent2 = new int [ ATTR_ARRAY_SIZE ] ; private int [ ] _nextSibling2 = new int [ ATTR_ARRAY_SIZE ] ; private int [ ] _offset = new int [ ATTR_ARRAY_SIZE ] ; private int [ ] _length = new int [ ATTR_ARRAY_SIZE ] ; private Hashtable _nsPrefixes = new Hashtable ( ) ; private int _uriCount = 0 ; private int _prefixCount = 0 ; private int _nextNamespace = DOM . NULL ; private int _lastNamespace = DOM . NULL ; private int [ ] _xmlSpaceStack = new int [ 64 ] ; private int _idx = 1 ; private boolean _preserve = false ; private static final String XML_STRING = "xml:" ; private static final String XMLSPACE_STRING = "xml:space" ; private static final String PRESERVE_STRING = "preserve" ; private static final String XML_PREFIX = "xml" ; private static final String XMLNS_PREFIX = "xmlns" ; private boolean _escaping = true ; private boolean _disableEscaping = false ; public DOMBuilderImpl ( ) { _xmlSpaceStack [ 0 ] = DOM . ROOTNODE ; } private String getNamespaceURI ( String prefix ) { final Stack stack = ( Stack ) _nsPrefixes . get ( prefix ) ; return ( stack != null && ! stack . empty ( ) ) ? ( String ) stack . peek ( ) : EMPTYSTRING ; } private void xmlSpaceDefine ( String val , final int node ) { final boolean setting = val . equals ( PRESERVE_STRING ) ; if ( setting != _preserve ) { _xmlSpaceStack [ _idx ++ ] = node ; _preserve = setting ; } } private void xmlSpaceRevert ( final int node ) { if ( node == _xmlSpaceStack [ _idx - 1 ] ) { _idx -- ; _preserve = ! _preserve ; } } private int nextNode ( ) { final int index = _currentNode ++ ; if ( index == _type . length ) { resizeArrays ( _type . length * 2 , index ) ; } return index ; } private int nextAttributeNode ( ) { final int index = _currentAttributeNode ++ ; if ( index == _type2 . length ) { resizeArrays2 ( _type2 . length * 2 , index ) ; } return index ; } private void resizeTextArray ( final int newSize ) { final char [ ] newText = new char [ newSize ] ; System . arraycopy ( _text , 0 , newText , 0 , _currentOffset ) ; _text = newText ; } private void linkChildren ( final int node ) { _parent [ node ] = _parentStack [ _sp ] ; if ( _previousSiblingStack [ _sp ] != 0 ) { _nextSibling [ _previousSiblingStack [ _sp ] ] = node ; } else { _offsetOrChild [ _parentStack [ _sp ] ] = node ; } _previousSiblingStack [ _sp ] = node ; } private void linkParent ( final int node ) { if ( ++ _sp >= _parentStackLength ) { int length = _parentStackLength ; _parentStackLength = length + INIT_STACK_LENGTH ; final int newParent [ ] = new int [ _parentStackLength ] ; System . arraycopy ( _parentStack , 0 , newParent , 0 , length ) ; _parentStack = newParent ; final int newSibling [ ] = new int [ _parentStackLength ] ; System . arraycopy ( _previousSiblingStack , 0 , newSibling , 0 , length ) ; _previousSiblingStack = newSibling ; } _parentStack [ _sp ] = node ; } private short makeElementNode ( String uri , String localname ) throws SAXException { final String name ; if ( uri != EMPTYSTRING ) name = uri + ':' + localname ; else name = localname ; Integer obj = ( Integer ) _names . get ( name ) ; if ( obj == null ) { _names . put ( name , obj = new Integer ( _nextNameCode ++ ) ) ; } return ( short ) obj . intValue ( ) ; } private short makeElementNode ( String name , int col ) throws SAXException { if ( col > - 1 ) { final String uri = getNamespaceURI ( name . substring ( 0 , col ) ) ; name = uri + name . substring ( col ) ; } else { final String uri = getNamespaceURI ( EMPTYSTRING ) ; if ( ! uri . equals ( EMPTYSTRING ) ) name = uri + ':' + name ; } Integer obj = ( Integer ) _names . get ( name ) ; if ( obj == null ) { _names . put ( name , obj = new Integer ( _nextNameCode ++ ) ) ; } return ( short ) obj . intValue ( ) ; } private short registerPrefix ( String prefix ) { Stack stack = ( Stack ) _nsPrefixes . get ( prefix ) ; if ( stack != null ) { Integer obj = ( Integer ) stack . elementAt ( 0 ) ; return ( short ) obj . intValue ( ) ; } return 0 ; } private int maybeReuseText ( final int length ) { final int base = _baseOffset ; if ( length <= REUSABLE_TEXT_SIZE ) { char [ ] chars = new char [ length ] ; System . arraycopy ( _text , base , chars , 0 , length ) ; final Integer offsetObj = ( Integer ) _shortTexts . get ( chars ) ; if ( offsetObj != null ) { _currentOffset = base ; return offsetObj . intValue ( ) ; } else { _shortTexts . put ( chars , new Integer ( base ) ) ; } } _baseOffset = _currentOffset ; return base ; } private void storeTextRef ( final int node ) { final int length = _currentOffset - _baseOffset ; _offsetOrChild [ node ] = maybeReuseText ( length ) ; _lengthOrAttr [ node ] = length ; } private int makeTextNode ( boolean isWhitespace ) { if ( _currentOffset > _baseOffset ) { final int node = nextNode ( ) ; final int limit = _currentOffset ; if ( isWhitespace ) { _whitespace . setBit ( node ) ; } else if ( ! _preserve ) { int i = _baseOffset ; while ( isWhitespaceChar ( _text [ i ++ ] ) && i < limit ) ; if ( ( i == limit ) && isWhitespaceChar ( _text [ i - 1 ] ) ) { _whitespace . setBit ( node ) ; } } _type [ node ] = TEXT ; linkChildren ( node ) ; storeTextRef ( node ) ; if ( _disableEscaping ) { if ( _dontEscape == null ) { _dontEscape = new BitArray ( _whitespace . size ( ) ) ; } _dontEscape . setBit ( node ) ; _disableEscaping = false ; } return node ; } return - 1 ; } private void storeAttrValRef ( final int attributeNode ) { final int length = _currentOffset - _baseOffset ; _offset [ attributeNode ] = maybeReuseText ( length ) ; _length [ attributeNode ] = length ; } private int makeNamespaceNode ( String prefix , String uri ) throws SAXException { final int node = nextAttributeNode ( ) ; _type2 [ node ] = NAMESPACE ; characters ( uri ) ; storeAttrValRef ( node ) ; return node ; } private int makeAttributeNode ( int parent , Attributes attList , int i ) throws SAXException { final int node = nextAttributeNode ( ) ; final String qname = attList . getQName ( i ) ; String localName = attList . getLocalName ( i ) ; final String value = attList . getValue ( i ) ; StringBuffer namebuf = new StringBuffer ( EMPTYSTRING ) ; if ( qname . startsWith ( XMLSPACE_STRING ) ) { xmlSpaceDefine ( attList . getValue ( i ) , parent ) ; } if ( localName == null ) { localName = EMPTYSTRING ; } final String uri = attList . getURI ( i ) ; if ( uri != null && ! uri . equals ( EMPTYSTRING ) ) { namebuf . append ( uri ) ; namebuf . append ( ':' ) ; } namebuf . append ( '@' ) ; namebuf . append ( localName . length ( ) > 0 ? localName : qname ) ; String name = namebuf . toString ( ) ; Integer obj = ( Integer ) _names . get ( name ) ; if ( obj == null ) { _type2 [ node ] = ( short ) _nextNameCode ; _names . put ( name , obj = new Integer ( _nextNameCode ++ ) ) ; } else { _type2 [ node ] = ( short ) obj . intValue ( ) ; } final int col = qname . lastIndexOf ( ':' ) ; if ( col > 0 ) { _prefix2 [ node ] = registerPrefix ( qname . substring ( 0 , col ) ) ; } characters ( attList . getValue ( i ) ) ; storeAttrValRef ( node ) ; return node ; } public void characters ( char [ ] ch , int start , int length ) { if ( _currentOffset + length > _text . length ) { resizeTextArray ( Math . max ( _text . length * 2 , _currentOffset + length ) ) ; } System . arraycopy ( ch , start , _text , _currentOffset , length ) ; _currentOffset += length ; _disableEscaping = ! _escaping ; } public void startDocument ( ) throws SAXException { _shortTexts = new Hashtable ( ) ; _names = new Hashtable ( ) ; _sp = 0 ; _parentStack [ 0 ] = ROOTNODE ; _currentNode = ROOTNODE + 1 ; _currentAttributeNode = 1 ; _type2 [ 0 ] = NAMESPACE ; definePrefixAndUri ( EMPTYSTRING , EMPTYSTRING ) ; startPrefixMapping ( XML_PREFIX , "http://www.w3.org/XML/1998/namespace" ) ; _lengthOrAttr [ ROOTNODE ] = _nextNamespace ; _parent2 [ _nextNamespace ] = ROOTNODE ; _nextNamespace = DOM . NULL ; } public void endDocument ( ) { makeTextNode ( false ) ; _shortTexts = null ; final int namesSize = _nextNameCode - NTYPES ; _namesArray = new String [ namesSize ] ; Enumeration keys = _names . keys ( ) ; while ( keys . hasMoreElements ( ) ) { final String name = ( String ) keys . nextElement ( ) ; final Integer idx = ( Integer ) _names . get ( name ) ; _namesArray [ idx . intValue ( ) - NTYPES ] = name ; } _names = null ; _types = setupMapping ( _namesArray ) ; resizeTextArray ( _currentOffset ) ; _firstAttributeNode = _currentNode ; shiftAttributes ( _currentNode ) ; resizeArrays ( _currentNode + _currentAttributeNode , _currentNode ) ; appendAttributes ( ) ; _treeNodeLimit = _currentNode + _currentAttributeNode ; _namespace = new short [ namesSize ] ; _uriArray = new String [ _uriCount ] ; for ( int i = 0 ; i < namesSize ; i ++ ) { final String qname = _namesArray [ i ] ; final int col = _namesArray [ i ] . lastIndexOf ( ':' ) ; if ( ( ! qname . startsWith ( XML_STRING ) ) && ( col > - 1 ) ) { final String uri = _namesArray [ i ] . substring ( 0 , col ) ; final Integer idx = ( Integer ) _nsIndex . get ( uri ) ; if ( idx != null ) { _namespace [ i ] = idx . shortValue ( ) ; _uriArray [ idx . intValue ( ) ] = uri ; } } } _prefixArray = new String [ _prefixCount ] ; Enumeration p = _nsPrefixes . keys ( ) ; while ( p . hasMoreElements ( ) ) { final String prefix = ( String ) p . nextElement ( ) ; final Stack stack = ( Stack ) _nsPrefixes . get ( prefix ) ; final Integer I = ( Integer ) stack . elementAt ( 0 ) ; _prefixArray [ I . shortValue ( ) ] = prefix ; } } public void startElement ( String uri , String localName , String qname , Attributes attributes ) throws SAXException { makeTextNode ( false ) ; final int node = nextNode ( ) ; linkChildren ( node ) ; linkParent ( node ) ; _lengthOrAttr [ node ] = DOM . NULL ; int last = - 1 ; final int count = attributes . getLength ( ) ; if ( _nextNamespace != DOM . NULL ) { _lengthOrAttr [ node ] = _nextNamespace ; while ( _nextNamespace != DOM . NULL ) { _parent2 [ _nextNamespace ] = node ; _nextNamespace = _nextSibling2 [ last = _nextNamespace ] ; if ( _nextNamespace == DOM . NULL && count > 0 ) { _nextSibling2 [ last ] = _currentAttributeNode ; } } } if ( localName == null ) { localName = EMPTYSTRING ; } boolean attrsAdded = false ; if ( count > 0 ) { int attr = _currentAttributeNode ; if ( _lengthOrAttr [ node ] == DOM . NULL ) { _lengthOrAttr [ node ] = attr ; } for ( int i = 0 ; i < count ; i ++ ) { if ( ! attributes . getQName ( i ) . startsWith ( XMLNS_PREFIX ) ) { attr = makeAttributeNode ( node , attributes , i ) ; _parent2 [ attr ] = node ; _nextSibling2 [ attr ] = attr + 1 ; attrsAdded = true ; } } _nextSibling2 [ ( ! attrsAdded && last != - 1 ) ? last : attr ] = DOM . NULL ; } final int col = qname . lastIndexOf ( ':' ) ; _type [ node ] = ( uri != null && localName . length ( ) > 0 ) ? makeElementNode ( uri , localName ) : makeElementNode ( qname , col ) ; if ( col > - 1 ) { _prefix [ node ] = registerPrefix ( qname . substring ( 0 , col ) ) ; } } public void endElement ( String uri , String localName , String qname ) { makeTextNode ( false ) ; xmlSpaceRevert ( _parentStack [ _sp ] ) ; _previousSiblingStack [ _sp -- ] = 0 ; } public void processingInstruction ( String target , String data ) throws SAXException { makeTextNode ( false ) ; final int node = nextNode ( ) ; _type [ node ] = PROCESSING_INSTRUCTION ; linkChildren ( node ) ; characters ( target ) ; characters ( " " ) ; characters ( data ) ; storeTextRef ( node ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { if ( _currentOffset + length > _text . length ) { resizeTextArray ( Math . max ( _text . length * 2 , _currentOffset + length ) ) ; } System . arraycopy ( ch , start , _text , _currentOffset , length ) ; _currentOffset += length ; makeTextNode ( true ) ; } public void setDocumentLocator ( Locator locator ) { } public void skippedEntity ( String name ) { } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { final Stack stack = definePrefixAndUri ( prefix , uri ) ; makeTextNode ( false ) ; int attr = makeNamespaceNode ( prefix , uri ) ; if ( _nextNamespace == DOM . NULL ) { _nextNamespace = attr ; } else { _nextSibling2 [ attr - 1 ] = attr ; } _nextSibling2 [ attr ] = DOM . NULL ; _prefix2 [ attr ] = ( ( Integer ) stack . elementAt ( 0 ) ) . shortValue ( ) ; } private Stack definePrefixAndUri ( String prefix , String uri ) throws SAXException { Stack stack = ( Stack ) _nsPrefixes . get ( prefix ) ; if ( stack == null ) { stack = new Stack ( ) ; stack . push ( new Integer ( _prefixCount ++ ) ) ; _nsPrefixes . put ( prefix , stack ) ; } Integer idx ; if ( ( idx = ( Integer ) _nsIndex . get ( uri ) ) == null ) { _nsIndex . put ( uri , idx = new Integer ( _uriCount ++ ) ) ; } stack . push ( uri ) ; return stack ; } public void endPrefixMapping ( String prefix ) { final Stack stack = ( Stack ) _nsPrefixes . get ( prefix ) ; if ( ( stack != null ) && ( ! stack . empty ( ) ) ) stack . pop ( ) ; } public void comment ( char [ ] ch , int start , int length ) { makeTextNode ( false ) ; if ( _currentOffset + length > _text . length ) { resizeTextArray ( Math . max ( _text . length * 2 , _currentOffset + length ) ) ; } System . arraycopy ( ch , start , _text , _currentOffset , length ) ; _currentOffset += length ; final int node = makeTextNode ( false ) ; _type [ node ] = COMMENT ; } public void startCDATA ( ) { } public void endCDATA ( ) { } public void startDTD ( String name , String publicId , String systemId ) { } public void endDTD ( ) { } public void startEntity ( String name ) { } public void endEntity ( String name ) { } private void characters ( final String string ) { final int length = string . length ( ) ; if ( _currentOffset + length > _text . length ) { resizeTextArray ( Math . max ( _text . length * 2 , _currentOffset + length ) ) ; } string . getChars ( 0 , length , _text , _currentOffset ) ; _currentOffset += length ; } private void resizeArrays ( final int newSize , int length ) { if ( ( length < newSize ) && ( newSize == _currentNode ) ) length = _currentNode ; final short [ ] newType = new short [ newSize ] ; System . arraycopy ( _type , 0 , newType , 0 , length ) ; _type = newType ; final int [ ] newParent = new int [ newSize ] ; System . arraycopy ( _parent , 0 , newParent , 0 , length ) ; _parent = newParent ; final int [ ] newNextSibling = new int [ newSize ] ; System . arraycopy ( _nextSibling , 0 , newNextSibling , 0 , length ) ; _nextSibling = newNextSibling ; final int [ ] newOffsetOrChild = new int [ newSize ] ; System . arraycopy ( _offsetOrChild , 0 , newOffsetOrChild , 0 , length ) ; _offsetOrChild = newOffsetOrChild ; final int [ ] newLengthOrAttr = new int [ newSize ] ; System . arraycopy ( _lengthOrAttr , 0 , newLengthOrAttr , 0 , length ) ; _lengthOrAttr = newLengthOrAttr ; _whitespace . resize ( newSize ) ; if ( _dontEscape != null ) { _dontEscape . resize ( newSize ) ; } final short [ ] newPrefix = new short [ newSize ] ; System . arraycopy ( _prefix , 0 , newPrefix , 0 , length ) ; _prefix = newPrefix ; } private void resizeArrays2 ( final int newSize , final int length ) { if ( newSize > length ) { final short [ ] newType = new short [ newSize ] ; System . arraycopy ( _type2 , 0 , newType , 0 , length ) ; _type2 = newType ; final int [ ] newParent = new int [ newSize ] ; System . arraycopy ( _parent2 , 0 , newParent , 0 , length ) ; _parent2 = newParent ; final int [ ] newNextSibling = new int [ newSize ] ; System . arraycopy ( _nextSibling2 , 0 , newNextSibling , 0 , length ) ; _nextSibling2 = newNextSibling ; final int [ ] newOffset = new int [ newSize ] ; System . arraycopy ( _offset , 0 , newOffset , 0 , length ) ; _offset = newOffset ; final int [ ] newLength = new int [ newSize ] ; System . arraycopy ( _length , 0 , newLength , 0 , length ) ; _length = newLength ; final short [ ] newPrefix = new short [ newSize ] ; System . arraycopy ( _prefix2 , 0 , newPrefix , 0 , length ) ; _prefix2 = newPrefix ; } } private void shiftAttributes ( final int shift ) { int i = 0 ; int next = 0 ; final int limit = _currentAttributeNode ; int lastParent = - 1 ; for ( i = 0 ; i < limit ; i ++ ) { if ( _parent2 [ i ] != lastParent ) { lastParent = _parent2 [ i ] ; _lengthOrAttr [ lastParent ] = i + shift ; } next = _nextSibling2 [ i ] ; _nextSibling2 [ i ] = next != 0 ? next + shift : 0 ; } } private void appendAttributes ( ) { final int len = _currentAttributeNode ; if ( len > 0 ) { final int dst = _currentNode ; System . arraycopy ( _type2 , 0 , _type , dst , len ) ; System . arraycopy ( _prefix2 , 0 , _prefix , dst , len ) ; System . arraycopy ( _parent2 , 0 , _parent , dst , len ) ; System . arraycopy ( _nextSibling2 , 0 , _nextSibling , dst , len ) ; System . arraycopy ( _offset , 0 , _offsetOrChild , dst , len ) ; System . arraycopy ( _length , 0 , _lengthOrAttr , dst , len ) ; } } public boolean setEscaping ( boolean value ) { final boolean temp = _escaping ; _escaping = value ; return temp ; } } } 	1	['116', '1', '0', '60', '203', '4934', '44', '48', '62', '0.905590062', '2911', '1', '6', '0', '0.103864734', '0', '0', '23.85344828', '13', '2.0776', '2']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . NodeTest ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xalan . xsltc . compiler . Constants ; public abstract class Type implements Constants { public static final Type Int = new IntType ( ) ; public static final Type Real = new RealType ( ) ; public static final Type Boolean = new BooleanType ( ) ; public static final Type NodeSet = new NodeSetType ( ) ; public static final Type String = new StringType ( ) ; public static final Type ResultTree = new ResultTreeType ( ) ; public static final Type Reference = new ReferenceType ( ) ; public static final Type Void = new VoidType ( ) ; public static final Type Object = new ObjectType ( ) ; public static final Type Node = new NodeType ( NodeTest . ANODE ) ; public static final Type Root = new NodeType ( NodeTest . ROOT ) ; public static final Type Element = new NodeType ( NodeTest . ELEMENT ) ; public static final Type Attribute = new NodeType ( NodeTest . ATTRIBUTE ) ; public static final Type Text = new NodeType ( NodeTest . TEXT ) ; public static final Type Comment = new NodeType ( NodeTest . COMMENT ) ; public static final Type Processing_Instruction = new NodeType ( NodeTest . PI ) ; public abstract String toString ( ) ; public abstract boolean identicalTo ( Type other ) ; public boolean isNumber ( ) { return false ; } public boolean implementedAsMethod ( ) { return false ; } public boolean isSimple ( ) { return false ; } public abstract org . apache . bcel . generic . Type toJCType ( ) ; public int distanceTo ( Type type ) { return type == this ? 0 : Integer . MAX_VALUE ; } public abstract String toSignature ( ) ; public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { FlowList fl = null ; if ( type == Type . Boolean ) { fl = translateToDesynthesized ( classGen , methodGen , ( BooleanType ) type ) ; } else { translateTo ( classGen , methodGen , type ) ; } return fl ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; return null ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getClass ( ) . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , clazz . getClass ( ) . toString ( ) , toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , "[" + toString ( ) + "]" ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , "[" + toString ( ) + "]" , toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public String getClassName ( ) { return ( EMPTYSTRING ) ; } public Instruction ADD ( ) { return null ; } public Instruction SUB ( ) { return null ; } public Instruction MUL ( ) { return null ; } public Instruction DIV ( ) { return null ; } public Instruction REM ( ) { return null ; } public Instruction NEG ( ) { return null ; } public Instruction LOAD ( int slot ) { return null ; } public Instruction STORE ( int slot ) { return null ; } public Instruction POP ( ) { return POP ; } public BranchInstruction GT ( boolean tozero ) { return null ; } public BranchInstruction GE ( boolean tozero ) { return null ; } public BranchInstruction LT ( boolean tozero ) { return null ; } public BranchInstruction LE ( boolean tozero ) { return null ; } public Instruction CMP ( boolean less ) { return null ; } public Instruction DUP ( ) { return DUP ; } } 	0	['33', '1', '10', '113', '53', '526', '103', '21', '32', '0.998046875', '300', '0', '16', '0', '0.234375', '0', '0', '7.606060606', '2', '1', '0']
package org . apache . xalan . extensions ; import java . util . Vector ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . io . IOException ; import org . w3c . dom . NodeList ; import org . w3c . dom . Node ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . Constants ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPathContext ; import org . apache . xpath . VariableStack ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import javax . xml . transform . TransformerException ; public class ExtensionHandlerExsltFunction extends ExtensionHandler { private String m_namespace ; private StylesheetRoot m_stylesheet ; private static final QName RESULTQNAME = new QName ( Constants . S_EXSLT_FUNCTIONS_URL , Constants . EXSLT_ELEMNAME_FUNCRESULT_STRING ) ; public ExtensionHandlerExsltFunction ( String ns , StylesheetRoot stylesheet ) { super ( ns , "xml" ) ; m_namespace = ns ; m_stylesheet = stylesheet ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { } public ElemExsltFunction getFunction ( String funcName ) { QName qname = new QName ( m_namespace , funcName ) ; ElemTemplate templ = m_stylesheet . getTemplateComposed ( qname ) ; if ( templ != null && templ instanceof ElemExsltFunction ) return ( ElemExsltFunction ) templ ; else return null ; } public boolean isFunctionAvailable ( String funcName ) { return getFunction ( funcName ) != null ; } public boolean isElementAvailable ( String elemName ) { if ( ! ( new QName ( m_namespace , elemName ) . equals ( RESULTQNAME ) ) ) { return false ; } else { ElemTemplateElement elem = m_stylesheet . getFirstChildElem ( ) ; while ( elem != null && elem != m_stylesheet ) { if ( elem instanceof ElemExsltFuncResult && ancestorIsFunction ( elem ) ) return true ; ElemTemplateElement nextElem = elem . getFirstChildElem ( ) ; if ( nextElem == null ) nextElem = elem . getNextSiblingElem ( ) ; if ( nextElem == null ) nextElem = elem . getParentElem ( ) ; elem = nextElem ; } } return false ; } private boolean ancestorIsFunction ( ElemTemplateElement child ) { while ( child . getParentElem ( ) != null && ! ( child . getParentElem ( ) instanceof StylesheetRoot ) ) { if ( child . getParentElem ( ) instanceof ElemExsltFunction ) return true ; child = child . getParentElem ( ) ; } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { XObject [ ] methodArgs ; methodArgs = new XObject [ args . size ( ) ] ; try { for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = XObject . create ( args . elementAt ( i ) ) ; } ElemExsltFunction elemFunc = getFunction ( funcName ) ; XPathContext context = exprContext . getXPathContext ( ) ; TransformerImpl transformer = ( TransformerImpl ) context . getOwnerObject ( ) ; elemFunc . execute ( transformer , methodArgs ) ; VariableStack varStack = context . getVarStack ( ) ; XObject val = new XString ( "" ) ; int resultIndex = elemFunc . getResultIndex ( ) ; if ( varStack . isLocalSet ( resultIndex ) ) val = varStack . getLocalVariable ( context , resultIndex ) ; return val ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } } 	1	['8', '2', '0', '14', '27', '20', '0', '14', '6', '0.571428571', '189', '1', '2', '0.5', '0.349206349', '1', '1', '22.25', '8', '2.375', '1']
package org . apache . xalan . serialize ; import java . io . * ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public final class WriterToUTF8Buffered extends Writer { private OutputStream m_os ; private byte buf [ ] ; private int count ; public WriterToUTF8Buffered ( OutputStream out ) throws UnsupportedEncodingException { this ( out , 8 * 1024 ) ; } public WriterToUTF8Buffered ( final OutputStream out , final int size ) { m_os = out ; if ( size <= 0 ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BUFFER_SIZE_LESSTHAN_ZERO , null ) ) ; } buf = new byte [ size ] ; count = 0 ; } public void write ( final int c ) throws IOException { if ( c < 0x80 ) { if ( count >= buf . length ) flushBuffer ( ) ; buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < 0x800 ) { if ( count + 1 >= buf . length ) flushBuffer ( ) ; buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { if ( count + 2 >= buf . length ) flushBuffer ( ) ; buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } private final void writeDirect ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { final OutputStream os = m_os ; int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } } private final void writeDirect ( final String s ) throws IOException { final int n = s . length ( ) ; final OutputStream os = m_os ; for ( int i = 0 ; i < n ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } } public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf . length ) { flushBuffer ( ) ; writeDirect ( chars , start , length ) ; return ; } if ( lengthx3 > buf . length - count ) { flushBuffer ( ) ; } final OutputStream os = m_os ; int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } public void write ( final String s ) throws IOException { final int length = s . length ( ) ; int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf . length ) { flushBuffer ( ) ; writeDirect ( s ) ; return ; } if ( lengthx3 > buf . length - count ) { flushBuffer ( ) ; } final OutputStream os = m_os ; for ( int i = 0 ; i < length ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } public void flushBuffer ( ) throws IOException { if ( count > 0 ) { m_os . write ( buf , 0 , count ) ; count = 0 ; } } public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } } 	0	['11', '2', '0', '2', '20', '0', '1', '1', '9', '0.2', '632', '1', '0', '0.590909091', '0.381818182', '1', '2', '56.18181818', '1', '0.8182', '0']
package org . apache . xalan . processor ; import org . xml . sax . InputSource ; import org . xml . sax . helpers . XMLReaderFactory ; import org . xml . sax . XMLReader ; import javax . xml . transform . TransformerException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLFilter ; import org . w3c . dom . Node ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . DefaultErrorHandler ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . TransformerIdentityImpl ; import org . apache . xalan . transformer . TrAXFilter ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . Source ; import javax . xml . transform . URIResolver ; import javax . xml . transform . Templates ; import javax . xml . transform . sax . TemplatesHandler ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . stream . StreamSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . ErrorListener ; import java . io . IOException ; import java . io . InputStream ; import java . io . BufferedInputStream ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . StringReader ; import java . util . Properties ; import java . util . Enumeration ; import org . apache . xalan . transformer . XalanProperties ; public class TransformerFactoryImpl extends SAXTransformerFactory { public static String XSLT_PROPERTIES = "org/apache/xalan/res/XSLTInfo.properties" ; private static boolean isInited = false ; public TransformerFactoryImpl ( ) { loadPropertyFileToSystem ( XSLT_PROPERTIES ) ; } private static final Class [ ] NO_CLASSES = new Class [ 0 ] ; private static final Object [ ] NO_OBJS = new Object [ 0 ] ; public static final String FEATURE_INCREMENTAL = "http://xml.apache.org/xalan/features/incremental" ; public static final String FEATURE_OPTIMIZE = "http://xml.apache.org/xalan/features/optimize" ; public static final String FEATURE_SOURCE_LOCATION = XalanProperties . SOURCE_LOCATION ; private static void loadPropertyFileToSystem ( String file ) { if ( false == isInited ) { try { InputStream is = null ; try { Properties props = new Properties ( ) ; try { java . lang . reflect . Method getCCL = Thread . class . getMethod ( "getContextClassLoader" , NO_CLASSES ) ; if ( getCCL != null ) { ClassLoader contextClassLoader = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; is = contextClassLoader . getResourceAsStream ( file ) ; } } catch ( Exception e ) { } if ( is == null ) { is = TransformerFactoryImpl . class . getResourceAsStream ( "/" + file ) ; } BufferedInputStream bis = new BufferedInputStream ( is ) ; props . load ( bis ) ; bis . close ( ) ; Properties systemProps = System . getProperties ( ) ; Enumeration propEnum = props . propertyNames ( ) ; while ( propEnum . hasMoreElements ( ) ) { String prop = ( String ) propEnum . nextElement ( ) ; if ( ! systemProps . containsKey ( prop ) ) systemProps . put ( prop , props . getProperty ( prop ) ) ; } System . setProperties ( systemProps ) ; isInited = true ; } catch ( Exception ex ) { } } catch ( SecurityException se ) { } } } public javax . xml . transform . Templates processFromNode ( Node node ) throws TransformerConfigurationException { try { TemplatesHandler builder = newTemplatesHandler ( ) ; TreeWalker walker = new TreeWalker ( builder , new org . apache . xpath . DOM2Helper ( ) , builder . getSystemId ( ) ) ; walker . traverse ( node ) ; return builder . getTemplates ( ) ; } catch ( org . xml . sax . SAXException se ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( se ) ) ; } catch ( TransformerException ex ) { throw new TransformerConfigurationException ( ex ) ; } return null ; } else throw new TransformerConfigurationException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PROCESSFROMNODE_FAILED , null ) , se ) ; } catch ( TransformerConfigurationException tce ) { throw tce ; } catch ( Exception e ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( e ) ) ; } catch ( TransformerException ex ) { throw new TransformerConfigurationException ( ex ) ; } return null ; } else throw new TransformerConfigurationException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PROCESSFROMNODE_FAILED , null ) , e ) ; } } private String m_DOMsystemID = null ; String getDOMsystemID ( ) { return m_DOMsystemID ; } javax . xml . transform . Templates processFromNode ( Node node , String systemID ) throws TransformerConfigurationException { m_DOMsystemID = systemID ; return processFromNode ( node ) ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { String baseID ; InputSource isource = null ; Node node = null ; XMLReader reader = null ; if ( source instanceof DOMSource ) { DOMSource dsource = ( DOMSource ) source ; node = dsource . getNode ( ) ; baseID = dsource . getSystemId ( ) ; } else { isource = SAXSource . sourceToInputSource ( source ) ; baseID = isource . getSystemId ( ) ; } StylesheetPIHandler handler = new StylesheetPIHandler ( baseID , media , title , charset ) ; if ( m_uriResolver != null ) { handler . setURIResolver ( m_uriResolver ) ; } try { if ( null != node ) { TreeWalker walker = new TreeWalker ( handler , new org . apache . xpath . DOM2Helper ( ) , baseID ) ; walker . traverse ( node ) ; } else { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } reader . setContentHandler ( handler ) ; reader . parse ( isource ) ; } } catch ( StopParseException spe ) { } catch ( org . xml . sax . SAXException se ) { throw new TransformerConfigurationException ( "getAssociatedStylesheets failed" , se ) ; } catch ( IOException ioe ) { throw new TransformerConfigurationException ( "getAssociatedStylesheets failed" , ioe ) ; } return handler . getAssociatedStylesheet ( ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { return new StylesheetHandler ( this ) ; } public boolean getFeature ( String name ) { if ( ( DOMResult . FEATURE == name ) || ( DOMSource . FEATURE == name ) || ( SAXResult . FEATURE == name ) || ( SAXSource . FEATURE == name ) || ( StreamResult . FEATURE == name ) || ( StreamSource . FEATURE == name ) || ( SAXTransformerFactory . FEATURE == name ) || ( SAXTransformerFactory . FEATURE_XMLFILTER == name ) ) return true ; else if ( ( DOMResult . FEATURE . equals ( name ) ) || ( DOMSource . FEATURE . equals ( name ) ) || ( SAXResult . FEATURE . equals ( name ) ) || ( SAXSource . FEATURE . equals ( name ) ) || ( StreamResult . FEATURE . equals ( name ) ) || ( StreamSource . FEATURE . equals ( name ) ) || ( SAXTransformerFactory . FEATURE . equals ( name ) ) || ( SAXTransformerFactory . FEATURE_XMLFILTER . equals ( name ) ) ) return true ; else return false ; } public static boolean m_optimize = true ; public static boolean m_source_location = false ; public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( name . equals ( FEATURE_INCREMENTAL ) ) { if ( value instanceof Boolean ) { org . apache . xml . dtm . DTMManager . setIncremental ( ( ( Boolean ) value ) . booleanValue ( ) ) ; } else if ( value instanceof String ) { org . apache . xml . dtm . DTMManager . setIncremental ( ( new Boolean ( ( String ) value ) ) . booleanValue ( ) ) ; } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BAD_VALUE , new Object [ ] { name , value } ) ) ; } } else if ( name . equals ( FEATURE_OPTIMIZE ) ) { if ( value instanceof Boolean ) { m_optimize = ( ( Boolean ) value ) . booleanValue ( ) ; } else if ( value instanceof String ) { m_optimize = ( new Boolean ( ( String ) value ) ) . booleanValue ( ) ; } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BAD_VALUE , new Object [ ] { name , value } ) ) ; } } else if ( name . equals ( FEATURE_SOURCE_LOCATION ) ) { if ( value instanceof Boolean ) { m_source_location = ( ( Boolean ) value ) . booleanValue ( ) ; } else if ( value instanceof String ) { m_source_location = ( new Boolean ( ( String ) value ) ) . booleanValue ( ) ; } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BAD_VALUE , new Object [ ] { name , value } ) ) ; } } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUPPORTED , new Object [ ] { name } ) ) ; } } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( name . equals ( FEATURE_INCREMENTAL ) ) { return new Boolean ( org . apache . xml . dtm . DTMManager . getIncremental ( ) ) ; } else if ( name . equals ( FEATURE_OPTIMIZE ) ) { return new Boolean ( m_optimize ) ; } else if ( name . equals ( FEATURE_SOURCE_LOCATION ) ) { return new Boolean ( m_source_location ) ; } else throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ATTRIB_VALUE_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerException ex1 ) { new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newTransformerHandler ( templates ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { try { TransformerImpl transformer = ( TransformerImpl ) templates . newTransformer ( ) ; transformer . setURIResolver ( m_uriResolver ) ; TransformerHandler th = ( TransformerHandler ) transformer . getInputContentHandler ( true ) ; return th ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerException ex1 ) { ex = new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { return new TransformerIdentityImpl ( ) ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { try { Templates tmpl = newTemplates ( source ) ; if ( tmpl == null ) return null ; Transformer transformer = tmpl . newTransformer ( ) ; transformer . setURIResolver ( m_uriResolver ) ; return transformer ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerException ex1 ) { ex = new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } } public Transformer newTransformer ( ) throws TransformerConfigurationException { return new TransformerIdentityImpl ( ) ; } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { TemplatesHandler builder = newTemplatesHandler ( ) ; String baseID = source . getSystemId ( ) ; if ( null == baseID ) { try { String currentDir = System . getProperty ( "user.dir" ) ; if ( currentDir . startsWith ( java . io . File . separator ) ) baseID = "file://" + currentDir + java . io . File . separatorChar + source . getClass ( ) . getName ( ) ; else baseID = "file:///" + currentDir + java . io . File . separatorChar + source . getClass ( ) . getName ( ) ; } catch ( SecurityException se ) { } } else { try { baseID = SystemIDResolver . getAbsoluteURI ( baseID ) ; } catch ( TransformerException te ) { throw new TransformerConfigurationException ( te ) ; } } builder . setSystemId ( baseID ) ; if ( source instanceof DOMSource ) { DOMSource dsource = ( DOMSource ) source ; Node node = dsource . getNode ( ) ; if ( null != node ) return processFromNode ( node , baseID ) ; else { String messageStr = XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_DOMSOURCE_INPUT , null ) ; throw new IllegalArgumentException ( messageStr ) ; } } try { InputSource isource = SAXSource . sourceToInputSource ( source ) ; XMLReader reader = null ; if ( source instanceof SAXSource ) reader = ( ( SAXSource ) source ) . getXMLReader ( ) ; boolean isUserReader = ( reader != null ) ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; try { if ( ! isUserReader ) reader . setFeature ( "http://apache.org/xml/features/validation/dynamic" , true ) ; } catch ( org . xml . sax . SAXException ex ) { } reader . setContentHandler ( builder ) ; reader . parse ( isource ) ; } catch ( org . xml . sax . SAXException se ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( se ) ) ; } catch ( TransformerException ex1 ) { throw new TransformerConfigurationException ( ex1 ) ; } } else throw new TransformerConfigurationException ( se . getMessage ( ) , se ) ; } catch ( Exception e ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( e ) ) ; return null ; } catch ( TransformerException ex1 ) { throw new TransformerConfigurationException ( ex1 ) ; } } else throw new TransformerConfigurationException ( e . getMessage ( ) , e ) ; } return builder . getTemplates ( ) ; } URIResolver m_uriResolver ; public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_uriResolver ; } private ErrorListener m_errorListener = new DefaultErrorHandler ( ) ; public ErrorListener getErrorListener ( ) { return m_errorListener ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( null == listener ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ERRORLISTENER , null ) ) ; m_errorListener = listener ; } } 	1	['25', '3', '0', '23', '103', '210', '12', '13', '20', '0.916666667', '979', '0.357142857', '0', '0.465116279', '0.199074074', '1', '2', '37.6', '17', '1.76', '3']
package org . apache . xalan . xsltc . dom ; public final class EmptyFilter implements Filter { public boolean test ( int node ) { return true ; } } 	0	['2', '1', '0', '1', '3', '1', '0', '1', '2', '2', '7', '0', '0', '0', '0.75', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . runtime . output ; import java . util . Stack ; import java . util . Vector ; import java . io . Writer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import org . apache . xalan . xsltc . * ; import org . apache . xalan . xsltc . runtime . * ; import org . apache . xalan . xsltc . runtime . Hashtable ; public class StreamXMLOutput extends StreamOutput { private static final String BEGCDATA = "<![CDATA[" ; private static final String ENDCDATA = "]]>" ; private static final String CNTCDATA = "]]]]><![CDATA[>" ; private static final String BEGCOMM = "<!--" ; private static final String ENDCOMM = "-->" ; private static final String CDATA_ESC_START = "]]>&#" ; private static final String CDATA_ESC_END = ";<![CDATA[" ; private String _elementName ; public StreamXMLOutput ( Writer writer , String encoding ) { super ( writer , encoding ) ; initCDATA ( ) ; initNamespaces ( ) ; } public StreamXMLOutput ( OutputStream out , String encoding ) throws IOException { super ( out , encoding ) ; initCDATA ( ) ; initNamespaces ( ) ; } public void startDocument ( ) throws TransletException { if ( ! _omitHeader ) { final StringBuffer header = new StringBuffer ( "<?xml version=\"" ) ; header . append ( _version ) . append ( "\" encoding=\"" ) . append ( _encoding ) ; if ( _standalone != null ) { header . append ( "\" standalone=\"" ) . append ( _standalone ) ; } header . append ( "\"?>\n" ) ; _buffer . insert ( 0 , header . toString ( ) ) ; } } public void endDocument ( ) throws TransletException { outputBuffer ( ) ; } public void startElement ( String elementName ) throws TransletException { if ( _startTagOpen ) { closeStartTag ( ) ; } else if ( _cdataTagOpen ) { endCDATA ( ) ; } if ( _firstElement ) { if ( _doctypeSystem != null ) { appendDTD ( elementName ) ; } _firstElement = false ; } if ( _indent ) { indent ( _lineFeedNextStartTag ) ; _lineFeedNextStartTag = true ; _indentNextEndTag = false ; _indentLevel ++ ; } _buffer . append ( '<' ) . append ( elementName ) ; _depth ++ ; _startTagOpen = true ; _elementName = elementName ; } public void endElement ( String elementName ) throws TransletException { if ( _cdataTagOpen ) { endCDATA ( ) ; } if ( _startTagOpen ) { appendAttributes ( ) ; _buffer . append ( "/>" ) ; _startTagOpen = false ; if ( _indent ) { _indentLevel -- ; _indentNextEndTag = true ; } } else { if ( _indent ) { _indentLevel -- ; if ( _indentNextEndTag ) { indent ( _indentNextEndTag ) ; _indentNextEndTag = true ; _lineFeedNextStartTag = true ; } } _buffer . append ( "</" ) . append ( elementName ) . append ( '>' ) ; _indentNextEndTag = true ; } if ( ( ( Integer ) _cdataStack . peek ( ) ) . intValue ( ) == _depth ) { _cdataStack . pop ( ) ; } popNamespaces ( ) ; _depth -- ; } public void characters ( String characters ) throws TransletException { characters ( characters . toCharArray ( ) , 0 , characters . length ( ) ) ; } public void characters ( char [ ] characters , int offset , int length ) throws TransletException { if ( length <= 0 ) return ; if ( _startTagOpen ) { closeStartTag ( ) ; } final Integer I = ( Integer ) _cdataStack . peek ( ) ; if ( I . intValue ( ) == _depth && ! _cdataTagOpen ) { startCDATA ( characters , offset , length ) ; } else if ( _escaping ) { if ( _cdataTagOpen ) { escapeCDATA ( characters , offset , length ) ; } else { escapeCharacters ( characters , offset , length ) ; } } else { _buffer . append ( characters , offset , length ) ; } } public void attribute ( String name , String value ) throws TransletException { if ( _startTagOpen ) { int k ; final Attribute attr = new Attribute ( patchName ( name ) , escapeString ( value ) ) ; if ( ( k = _attributes . indexOf ( attr ) ) >= 0 ) { _attributes . setElementAt ( attr , k ) ; } else { _attributes . add ( attr ) ; } } } public void comment ( String comment ) throws TransletException { if ( _startTagOpen ) { closeStartTag ( ) ; } else if ( _cdataTagOpen ) { endCDATA ( ) ; } appendComment ( comment ) ; } public void processingInstruction ( String target , String data ) throws TransletException { if ( _startTagOpen ) { closeStartTag ( ) ; } else if ( _cdataTagOpen ) { endCDATA ( ) ; } _buffer . append ( "<?" ) . append ( target ) . append ( ' ' ) . append ( data ) . append ( "?>" ) ; } public boolean setEscaping ( boolean escape ) throws TransletException { final boolean temp = _escaping ; _escaping = escape ; return temp ; } public void namespace ( final String prefix , final String uri ) throws TransletException { String escaped = escapeString ( uri ) ; if ( _startTagOpen ) { if ( pushNamespace ( prefix , escaped ) ) { _buffer . append ( ' ' ) . append ( XMLNS_PREFIX ) ; if ( prefix != null && prefix != EMPTYSTRING ) { _buffer . append ( ':' ) . append ( prefix ) ; } _buffer . append ( "=\"" ) . append ( escaped ) . append ( '"' ) ; } } else if ( prefix != EMPTYSTRING || uri != EMPTYSTRING ) { BasisLibrary . runTimeError ( BasisLibrary . STRAY_NAMESPACE_ERR , prefix , escaped ) ; } } protected void closeStartTag ( ) throws TransletException { super . closeStartTag ( ) ; if ( _cdata != null ) { final String localName = getLocalName ( _elementName ) ; final String uri = getNamespaceURI ( _elementName , true ) ; final StringBuffer expandedName = ( uri == EMPTYSTRING ) ? new StringBuffer ( _elementName ) : new StringBuffer ( uri ) . append ( ':' ) . append ( localName ) ; if ( _cdata . containsKey ( expandedName . toString ( ) ) ) { _cdataStack . push ( new Integer ( _depth ) ) ; } } } private void startCDATA ( char [ ] ch , int off , int len ) { final int limit = off + len ; int offset = off ; _buffer . append ( BEGCDATA ) ; for ( int i = offset ; i < limit - 2 ; i ++ ) { if ( ch [ i ] == ']' && ch [ i + 1 ] == ']' && ch [ i + 2 ] == '>' ) { _buffer . append ( ch , offset , i - offset ) . append ( CNTCDATA ) ; offset = i + 3 ; i += 2 ; } } if ( offset < limit ) { _buffer . append ( ch , offset , limit - offset ) ; } _cdataTagOpen = true ; } public void startCDATA ( ) throws TransletException { _buffer . append ( BEGCDATA ) ; _cdataTagOpen = true ; } public void endCDATA ( ) throws TransletException { _buffer . append ( ENDCDATA ) ; _cdataTagOpen = false ; } private void escapeCDATA ( char [ ] ch , int off , int len ) { int offset = off ; int limit = off + len ; if ( limit > ch . length ) { limit = ch . length ; } for ( int i = off ; i < limit ; i ++ ) { final char current = ch [ i ] ; if ( current > 'ÿ' ) { _buffer . append ( ch , offset , i - offset ) . append ( CDATA_ESC_START ) . append ( Integer . toString ( ( int ) current ) ) . append ( CDATA_ESC_END ) ; offset = i + 1 ; } } if ( offset < limit ) { _buffer . append ( ch , offset , limit - offset ) ; } } private String escapeString ( String value ) { final char [ ] ch = value . toCharArray ( ) ; final int limit = ch . length ; StringBuffer result = new StringBuffer ( ) ; int offset = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { switch ( ch [ i ] ) { case '&' : result . append ( ch , offset , i - offset ) . append ( AMP ) ; offset = i + 1 ; break ; case '"' : result . append ( ch , offset , i - offset ) . append ( QUOT ) ; offset = i + 1 ; break ; case '<' : result . append ( ch , offset , i - offset ) . append ( LT ) ; offset = i + 1 ; break ; case '>' : result . append ( ch , offset , i - offset ) . append ( GT ) ; offset = i + 1 ; break ; case '\n' : result . append ( ch , offset , i - offset ) . append ( CRLF ) ; offset = i + 1 ; break ; } } if ( offset < limit ) { result . append ( ch , offset , limit - offset ) ; } return result . toString ( ) ; } protected void escapeCharacters ( char [ ] ch , int off , int len ) { int limit = off + len ; int offset = off ; if ( limit > ch . length ) { limit = ch . length ; } for ( int i = off ; i < limit ; i ++ ) { final char current = ch [ i ] ; switch ( current ) { case '&' : _buffer . append ( ch , offset , i - offset ) . append ( AMP ) ; offset = i + 1 ; break ; case '<' : _buffer . append ( ch , offset , i - offset ) . append ( LT ) ; offset = i + 1 ; break ; case '>' : _buffer . append ( ch , offset , i - offset ) . append ( GT ) ; offset = i + 1 ; break ; default : if ( ( current >= '' && current < ' ' ) || ( _is8859Encoded && current > 'ÿ' ) ) { _buffer . append ( ch , offset , i - offset ) . append ( CHAR_ESC_START ) . append ( Integer . toString ( ( int ) ch [ i ] ) ) . append ( ';' ) ; offset = i + 1 ; } } } if ( offset < limit ) { _buffer . append ( ch , offset , limit - offset ) ; } } } 	1	['20', '3', '0', '8', '56', '188', '2', '6', '15', '1.019736842', '859', '1', '0', '0.709677419', '0.292857143', '2', '8', '41.55', '12', '2.3', '1']
package org . apache . xpath . functions ; import java . lang . Math ; import java . util . Vector ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNumber ; public class FuncCeiling extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( Math . ceil ( m_arg0 . execute ( xctxt ) . num ( ) ) ) ; } } 	0	['2', '4', '0', '5', '7', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '0']
package org . apache . xml . dtm . ref . sax2dtm ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import org . apache . xalan . transformer . XalanProperties ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . * ; import org . apache . xml . dtm . ref . * ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . IntVector ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . xml . sax . * ; import org . xml . sax . ext . * ; public class SAX2DTM extends DTMDefaultBaseIterators implements EntityResolver , DTDHandler , ContentHandler , ErrorHandler , DeclHandler , LexicalHandler { private static final boolean DEBUG = false ; private IncrementalSAXSource m_incrementalSAXSource = null ; protected FastStringBuffer m_chars = new FastStringBuffer ( 5 , 13 ) ; protected SuballocatedIntVector m_data ; transient protected IntStack m_parents = new IntStack ( ) ; transient protected int m_previous = 0 ; transient protected java . util . Vector m_prefixMappings = new java . util . Vector ( ) ; transient protected IntStack m_contextIndexes = new IntStack ( ) ; transient private int m_textType = DTM . TEXT_NODE ; transient private int m_coalescedTextType = DTM . TEXT_NODE ; transient private Locator m_locator = null ; transient private boolean m_insideDTD = false ; protected DTMTreeWalker m_walker = new DTMTreeWalker ( ) ; private DTMStringPool m_valuesOrPrefixes = new DTMStringPool ( ) ; protected boolean m_endDocumentOccured = false ; protected SuballocatedIntVector m_dataOrQName ; protected Hashtable m_idAttributes = new Hashtable ( ) ; static final String [ ] m_fixednames = { null , null , null , "#text" , "#cdata_section" , null , null , null , "#comment" , "#document" , null , "#document-fragment" , null } ; private Vector m_entities = null ; private static final int ENTITY_FIELD_PUBLICID = 0 ; private static final int ENTITY_FIELD_SYSTEMID = 1 ; private static final int ENTITY_FIELD_NOTATIONNAME = 2 ; private static final int ENTITY_FIELD_NAME = 3 ; private static final int ENTITY_FIELDS_PER = 4 ; private int m_textPendingStart = - 1 ; protected boolean m_useSourceLocationProperty = false ; protected StringVector m_sourceSystemId ; protected IntVector m_sourceLine ; protected IntVector m_sourceColumn ; public SAX2DTM ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; m_data = new SuballocatedIntVector ( 32 , 1024 ) ; m_data . addElement ( 0 ) ; m_dataOrQName = new SuballocatedIntVector ( m_initialblocksize ) ; m_useSourceLocationProperty = org . apache . xalan . processor . TransformerFactoryImpl . m_source_location ; m_sourceSystemId = ( m_useSourceLocationProperty ) ? new StringVector ( ) : null ; m_sourceLine = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; m_sourceColumn = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; } protected int _dataOrQName ( int identity ) { if ( identity < m_size ) return m_dataOrQName . elementAt ( identity ) ; while ( true ) { boolean isMore = nextNode ( ) ; if ( ! isMore ) return NULL ; else if ( identity < m_size ) return m_dataOrQName . elementAt ( identity ) ; } } public void clearCoRoutine ( ) { clearCoRoutine ( true ) ; } public void clearCoRoutine ( boolean callDoTerminate ) { if ( null != m_incrementalSAXSource ) { if ( callDoTerminate ) m_incrementalSAXSource . deliverMoreNodes ( false ) ; m_incrementalSAXSource = null ; } } public void setIncrementalSAXSource ( IncrementalSAXSource incrementalSAXSource ) { m_incrementalSAXSource = incrementalSAXSource ; incrementalSAXSource . setContentHandler ( this ) ; incrementalSAXSource . setLexicalHandler ( this ) ; incrementalSAXSource . setDTDHandler ( this ) ; } public ContentHandler getContentHandler ( ) { if ( m_incrementalSAXSource instanceof IncrementalSAXSource_Filter ) return ( ContentHandler ) m_incrementalSAXSource ; else return this ; } public LexicalHandler getLexicalHandler ( ) { if ( m_incrementalSAXSource instanceof IncrementalSAXSource_Filter ) return ( LexicalHandler ) m_incrementalSAXSource ; else return this ; } public EntityResolver getEntityResolver ( ) { return this ; } public DTDHandler getDTDHandler ( ) { return this ; } public ErrorHandler getErrorHandler ( ) { return this ; } public DeclHandler getDeclHandler ( ) { return this ; } public boolean needsTwoThreads ( ) { return null != m_incrementalSAXSource ; } public void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws SAXException { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } else { int firstChild = _firstch ( identity ) ; if ( DTM . NULL != firstChild ) { int offset = - 1 ; int length = 0 ; int level = _level ( identity ) ; identity = firstChild ; while ( DTM . NULL != identity && ( _level ( identity ) > level ) ) { type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; if ( - 1 == offset ) { offset = m_data . elementAt ( dataIndex ) ; } length += m_data . elementAt ( dataIndex + 1 ) ; } identity = getNextNodeIdentity ( identity ) ; } if ( length > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } } else if ( type != DTM . ELEMENT_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } String str = m_valuesOrPrefixes . indexToString ( dataIndex ) ; if ( normalize ) FastStringBuffer . sendNormalizedSAXcharacters ( str . toCharArray ( ) , 0 , str . length ( ) , ch ) ; else ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } } } public String getNodeName ( int nodeHandle ) { int expandedTypeID = getExpandedTypeID ( nodeHandle ) ; int namespaceID = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; if ( 0 == namespaceID ) { int type = getNodeType ( nodeHandle ) ; if ( type == DTM . NAMESPACE_NODE ) { if ( null == m_expandedNameTable . getLocalName ( expandedTypeID ) ) return "xmlns" ; else return "xmlns:" + m_expandedNameTable . getLocalName ( expandedTypeID ) ; } else if ( 0 == m_expandedNameTable . getLocalNameID ( expandedTypeID ) ) { return m_fixednames [ type ] ; } else return m_expandedNameTable . getLocalName ( expandedTypeID ) ; } else { int qnameIndex = m_dataOrQName . elementAt ( makeNodeIdentity ( nodeHandle ) ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public String getNodeNameX ( int nodeHandle ) { int expandedTypeID = getExpandedTypeID ( nodeHandle ) ; int namespaceID = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; if ( 0 == namespaceID ) { String name = m_expandedNameTable . getLocalName ( expandedTypeID ) ; if ( name == null ) return "" ; else return name ; } else { int qnameIndex = m_dataOrQName . elementAt ( makeNodeIdentity ( nodeHandle ) ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public boolean isAttributeSpecified ( int attributeHandle ) { return true ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { error ( XSLMessages . createMessage ( XSLTErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } protected int getNextNodeIdentity ( int identity ) { identity += 1 ; while ( identity >= m_size ) { if ( null == m_incrementalSAXSource ) return DTM . NULL ; nextNode ( ) ; } return identity ; } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { DTMTreeWalker treeWalker = m_walker ; ContentHandler prevCH = treeWalker . getcontentHandler ( ) ; if ( null != prevCH ) { treeWalker = new DTMTreeWalker ( ) ; } treeWalker . setcontentHandler ( ch ) ; treeWalker . setDTM ( this ) ; try { treeWalker . traverse ( nodeHandle ) ; } finally { treeWalker . setcontentHandler ( null ) ; } } protected int getNumberOfNodes ( ) { return m_size ; } protected boolean nextNode ( ) { if ( null == m_incrementalSAXSource ) return false ; if ( m_endDocumentOccured ) { clearCoRoutine ( ) ; return false ; } Object gotMore = m_incrementalSAXSource . deliverMoreNodes ( true ) ; if ( ! ( gotMore instanceof Boolean ) ) { if ( gotMore instanceof RuntimeException ) { throw ( RuntimeException ) gotMore ; } else if ( gotMore instanceof Exception ) { throw new WrappedRuntimeException ( ( Exception ) gotMore ) ; } clearCoRoutine ( ) ; return false ; } if ( gotMore != Boolean . TRUE ) { clearCoRoutine ( ) ; } return true ; } private final boolean isTextType ( int type ) { return ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) ; } protected int addNode ( int type , int expandedTypeID , int parentIndex , int previousSibling , int dataOrPrefix , boolean canHaveFirstChild ) { int nodeIndex = m_size ++ ; if ( m_dtmIdent . size ( ) == ( nodeIndex > > > DTMManager . IDENT_DTM_NODE_BITS ) ) { try { if ( m_mgr == null ) throw new ClassCastException ( ) ; DTMManagerDefault mgrD = ( DTMManagerDefault ) m_mgr ; int id = mgrD . getFirstFreeDTMID ( ) ; mgrD . addDTM ( this , id , nodeIndex ) ; m_dtmIdent . addElement ( id << DTMManager . IDENT_DTM_NODE_BITS ) ; } catch ( ClassCastException e ) { error ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } } m_firstch . addElement ( canHaveFirstChild ? NOTPROCESSED : DTM . NULL ) ; m_nextsib . addElement ( NOTPROCESSED ) ; m_prevsib . addElement ( previousSibling ) ; m_parent . addElement ( parentIndex ) ; m_exptype . addElement ( expandedTypeID ) ; m_dataOrQName . addElement ( dataOrPrefix ) ; if ( m_useSourceLocationProperty && m_locator != null ) { m_sourceSystemId . addElement ( m_locator . getSystemId ( ) ) ; m_sourceLine . addElement ( m_locator . getLineNumber ( ) ) ; m_sourceColumn . addElement ( m_locator . getColumnNumber ( ) ) ; if ( m_sourceSystemId . size ( ) != m_size ) { System . err . println ( "CODING ERROR in Source Location: " + m_size + " != " + m_sourceSystemId . size ( ) ) ; System . exit ( 1 ) ; } } if ( DTM . NULL != previousSibling ) m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; switch ( type ) { case DTM . NAMESPACE_NODE : declareNamespaceInContext ( parentIndex , nodeIndex ) ; break ; case DTM . ATTRIBUTE_NODE : break ; default : if ( DTM . NULL != parentIndex && NOTPROCESSED == m_firstch . elementAt ( parentIndex ) ) m_firstch . setElementAt ( nodeIndex , parentIndex ) ; break ; } return nodeIndex ; } public String getNodeValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_chars . getString ( offset , length ) ; } else if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type || DTM . DOCUMENT_NODE == type ) { return null ; } else { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } } public String getLocalName ( int nodeHandle ) { return m_expandedNameTable . getLocalName ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public String getUnparsedEntityURI ( String name ) { String url = "" ; if ( null == m_entities ) return url ; int n = m_entities . size ( ) ; for ( int i = 0 ; i < n ; i += ENTITY_FIELDS_PER ) { String ename = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_NAME ) ; if ( null != ename && ename . equals ( name ) ) { String nname = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_NOTATIONNAME ) ; if ( null != nname ) { url = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_SYSTEMID ) ; if ( null == url ) { url = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_PUBLICID ) ; } } break ; } } return url ; } public String getPrefix ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type ( identity ) ; if ( DTM . ELEMENT_NODE == type ) { int prefixIndex = _dataOrQName ( identity ) ; if ( 0 == prefixIndex ) return "" ; else { String qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; return getPrefix ( qname , null ) ; } } else if ( DTM . ATTRIBUTE_NODE == type ) { int prefixIndex = _dataOrQName ( identity ) ; if ( prefixIndex < 0 ) { prefixIndex = m_data . elementAt ( - prefixIndex ) ; String qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; return getPrefix ( qname , null ) ; } } return "" ; } public int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) { for ( int attrH = getFirstAttribute ( nodeHandle ) ; DTM . NULL != attrH ; attrH = getNextAttribute ( attrH ) ) { String attrNS = getNamespaceURI ( attrH ) ; String attrName = getLocalName ( attrH ) ; boolean nsMatch = namespaceURI == attrNS || ( namespaceURI != null && namespaceURI . equals ( attrNS ) ) ; if ( nsMatch && name . equals ( attrName ) ) return attrH ; } return DTM . NULL ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { error ( XSLMessages . createMessage ( XSLTErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } public String getNamespaceURI ( int nodeHandle ) { return m_expandedNameTable . getNamespace ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public XMLString getStringValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type ; if ( identity == DTM . NULL ) type = DTM . NULL ; else type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_xstrf . newstr ( m_chars , offset , length ) ; } else { int firstChild = _firstch ( identity ) ; if ( DTM . NULL != firstChild ) { int offset = - 1 ; int length = 0 ; int level = _level ( identity ) ; identity = firstChild ; while ( DTM . NULL != identity && ( _level ( identity ) > level ) ) { type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; if ( - 1 == offset ) { offset = m_data . elementAt ( dataIndex ) ; } length += m_data . elementAt ( dataIndex + 1 ) ; } identity = getNextNodeIdentity ( identity ) ; } if ( length > 0 ) { return m_xstrf . newstr ( m_chars , offset , length ) ; } } else if ( type != DTM . ELEMENT_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return m_xstrf . newstr ( m_valuesOrPrefixes . indexToString ( dataIndex ) ) ; } } return m_xstrf . emptystr ( ) ; } public int getElementById ( String elementId ) { Integer intObj ; boolean isMore = true ; do { intObj = ( Integer ) m_idAttributes . get ( elementId ) ; if ( null != intObj ) return makeNodeHandle ( intObj . intValue ( ) ) ; if ( ! isMore || m_endDocumentOccured ) break ; isMore = nextNode ( ) ; } while ( null == intObj ) ; return DTM . NULL ; } private String getPrefix ( String qname , String uri ) { String prefix ; int uriIndex = - 1 ; if ( null != uri && uri . length ( ) > 0 ) { do { uriIndex = m_prefixMappings . indexOf ( uri , ++ uriIndex ) ; } while ( ( uriIndex & 0x01 ) == 0 ) ; if ( uriIndex >= 0 ) { prefix = ( String ) m_prefixMappings . elementAt ( uriIndex - 1 ) ; } else if ( null != qname ) { int indexOfNSSep = qname . indexOf ( ':' ) ; if ( qname . equals ( "xmlns" ) ) prefix = "" ; else if ( qname . startsWith ( "xmlns:" ) ) prefix = qname . substring ( indexOfNSSep + 1 ) ; else prefix = ( indexOfNSSep > 0 ) ? qname . substring ( 0 , indexOfNSSep ) : null ; } else { prefix = null ; } } else if ( null != qname ) { int indexOfNSSep = qname . indexOf ( ':' ) ; if ( qname . equals ( "xmlns" ) ) prefix = "" ; else if ( qname . startsWith ( "xmlns:" ) ) prefix = qname . substring ( indexOfNSSep + 1 ) ; else prefix = ( indexOfNSSep > 0 ) ? qname . substring ( 0 , indexOfNSSep ) : null ; } else { prefix = null ; } return prefix ; } public void setIDAttribute ( String id , int elem ) { m_idAttributes . put ( id , new Integer ( elem ) ) ; } protected void charactersFlush ( ) { if ( m_textPendingStart >= 0 ) { int length = m_chars . size ( ) - m_textPendingStart ; boolean doStrip = false ; if ( getShouldStripWhitespace ( ) ) { doStrip = m_chars . isWhitespace ( m_textPendingStart , length ) ; } if ( doStrip ) m_chars . setLength ( m_textPendingStart ) ; else { int exName = m_expandedNameTable . getExpandedTypeID ( DTM . TEXT_NODE ) ; int dataIndex = m_data . size ( ) ; m_previous = addNode ( m_coalescedTextType , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; m_data . addElement ( m_textPendingStart ) ; m_data . addElement ( length ) ; } m_textPendingStart = - 1 ; m_textType = m_coalescedTextType = DTM . TEXT_NODE ; } } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { return null ; } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( null == m_entities ) { m_entities = new Vector ( ) ; } try { systemId = SystemIDResolver . getAbsoluteURI ( systemId , getDocumentBaseURI ( ) ) ; } catch ( Exception e ) { throw new org . xml . sax . SAXException ( e ) ; } m_entities . addElement ( publicId ) ; m_entities . addElement ( systemId ) ; m_entities . addElement ( notationName ) ; m_entities . addElement ( name ) ; } public void setDocumentLocator ( Locator locator ) { m_locator = locator ; } public void startDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "startDocument" ) ; int doc = addNode ( DTM . DOCUMENT_NODE , m_expandedNameTable . getExpandedTypeID ( DTM . DOCUMENT_NODE ) , DTM . NULL , DTM . NULL , 0 , true ) ; m_parents . push ( doc ) ; m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "endDocument" ) ; charactersFlush ( ) ; m_nextsib . setElementAt ( NULL , 0 ) ; if ( m_firstch . elementAt ( 0 ) == NOTPROCESSED ) m_firstch . setElementAt ( NULL , 0 ) ; if ( DTM . NULL != m_previous ) m_nextsib . setElementAt ( DTM . NULL , m_previous ) ; m_parents = null ; m_prefixMappings = null ; m_contextIndexes = null ; m_endDocumentOccured = true ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( DEBUG ) System . out . println ( "startPrefixMapping: prefix: " + prefix + ", uri: " + uri ) ; if ( null == prefix ) prefix = "" ; m_prefixMappings . addElement ( prefix ) ; m_prefixMappings . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { if ( DEBUG ) System . out . println ( "endPrefixMapping: prefix: " + prefix ) ; if ( null == prefix ) prefix = "" ; int index = m_contextIndexes . peek ( ) - 1 ; do { index = m_prefixMappings . indexOf ( prefix , ++ index ) ; } while ( ( index >= 0 ) && ( ( index & 0x01 ) == 0x01 ) ) ; if ( index > - 1 ) { m_prefixMappings . setElementAt ( "%@$#^@#" , index ) ; m_prefixMappings . setElementAt ( "%@$#^@#" , index + 1 ) ; } } protected boolean declAlreadyDeclared ( String prefix ) { int startDecls = m_contextIndexes . peek ( ) ; java . util . Vector prefixMappings = m_prefixMappings ; int nDecls = prefixMappings . size ( ) ; for ( int i = startDecls ; i < nDecls ; i += 2 ) { String prefixDecl = ( String ) prefixMappings . elementAt ( i ) ; if ( prefixDecl == null ) continue ; if ( prefixDecl . equals ( prefix ) ) return true ; } return false ; } boolean m_pastFirstElement = false ; public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( DEBUG ) { System . out . println ( "startElement: uri: " + uri + ", localname: " + localName + ", qname: " + qName + ", atts: " + attributes ) ; boolean DEBUG_ATTRS = true ; if ( DEBUG_ATTRS & attributes != null ) { int n = attributes . getLength ( ) ; if ( n == 0 ) System . out . println ( "\tempty attribute list" ) ; else for ( int i = 0 ; i < n ; i ++ ) System . out . println ( "\t attr: uri: " + attributes . getURI ( i ) + ", localname: " + attributes . getLocalName ( i ) + ", qname: " + attributes . getQName ( i ) + ", type: " + attributes . getType ( i ) + ", value: " + attributes . getValue ( i ) ) ; } } charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( uri , localName , DTM . ELEMENT_NODE ) ; String prefix = getPrefix ( qName , uri ) ; int prefixIndex = ( null != prefix ) ? m_valuesOrPrefixes . stringToIndex ( qName ) : 0 ; int elemNode = addNode ( DTM . ELEMENT_NODE , exName , m_parents . peek ( ) , m_previous , prefixIndex , true ) ; if ( m_indexing ) indexNode ( exName , elemNode ) ; m_parents . push ( elemNode ) ; int startDecls = m_contextIndexes . peek ( ) ; int nDecls = m_prefixMappings . size ( ) ; int prev = DTM . NULL ; if ( ! m_pastFirstElement ) { prefix = "xml" ; String declURL = "http://www.w3.org/XML/1998/namespace" ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; int val = m_valuesOrPrefixes . stringToIndex ( declURL ) ; prev = addNode ( DTM . NAMESPACE_NODE , exName , elemNode , prev , val , false ) ; m_pastFirstElement = true ; } for ( int i = startDecls ; i < nDecls ; i += 2 ) { prefix = ( String ) m_prefixMappings . elementAt ( i ) ; if ( prefix == null ) continue ; String declURL = ( String ) m_prefixMappings . elementAt ( i + 1 ) ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; int val = m_valuesOrPrefixes . stringToIndex ( declURL ) ; prev = addNode ( DTM . NAMESPACE_NODE , exName , elemNode , prev , val , false ) ; } int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrQName = attributes . getQName ( i ) ; String valString = attributes . getValue ( i ) ; prefix = getPrefix ( attrQName , attrUri ) ; int nodeType ; if ( ( null != attrQName ) && ( attrQName . equals ( "xmlns" ) || attrQName . startsWith ( "xmlns:" ) ) ) { if ( declAlreadyDeclared ( prefix ) ) continue ; nodeType = DTM . NAMESPACE_NODE ; } else { nodeType = DTM . ATTRIBUTE_NODE ; if ( attributes . getType ( i ) . equalsIgnoreCase ( "ID" ) ) setIDAttribute ( valString , elemNode ) ; } if ( null == valString ) valString = "" ; int val = m_valuesOrPrefixes . stringToIndex ( valString ) ; String attrLocalName = attributes . getLocalName ( i ) ; if ( null != prefix ) { prefixIndex = m_valuesOrPrefixes . stringToIndex ( attrQName ) ; int dataIndex = m_data . size ( ) ; m_data . addElement ( prefixIndex ) ; m_data . addElement ( val ) ; val = - dataIndex ; } exName = m_expandedNameTable . getExpandedTypeID ( attrUri , attrLocalName , nodeType ) ; prev = addNode ( nodeType , exName , elemNode , prev , val , false ) ; } if ( DTM . NULL != prev ) m_nextsib . setElementAt ( DTM . NULL , prev ) ; if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( elemNode ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( DEBUG ) System . out . println ( "endElement: uri: " + uri + ", localname: " + localName + ", qname: " + qName ) ; charactersFlush ( ) ; m_prefixMappings . setSize ( m_contextIndexes . pop ( ) ) ; m_prefixMappings . setSize ( m_contextIndexes . pop ( ) ) ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; int lastNode = m_previous ; m_previous = m_parents . pop ( ) ; if ( NOTPROCESSED == m_firstch . elementAt ( m_previous ) ) m_firstch . setElementAt ( DTM . NULL , m_previous ) ; else if ( DTM . NULL != lastNode ) m_nextsib . setElementAt ( DTM . NULL , lastNode ) ; popShouldStripWhitespace ( ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( m_textPendingStart == - 1 ) { m_textPendingStart = m_chars . size ( ) ; m_coalescedTextType = m_textType ; } m_chars . append ( ch , start , length ) ; if ( m_textType == DTM . TEXT_NODE ) m_coalescedTextType = DTM . TEXT_NODE ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { characters ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { if ( DEBUG ) System . out . println ( "processingInstruction: target: " + target + ", data: " + data ) ; charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( null , target , DTM . PROCESSING_INSTRUCTION_NODE ) ; int dataIndex = m_valuesOrPrefixes . stringToIndex ( data ) ; m_previous = addNode ( DTM . PROCESSING_INSTRUCTION_NODE , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void skippedEntity ( String name ) throws SAXException { } public void warning ( SAXParseException e ) throws SAXException { System . err . println ( e . getMessage ( ) ) ; } public void error ( SAXParseException e ) throws SAXException { throw e ; } public void fatalError ( SAXParseException e ) throws SAXException { throw e ; } public void elementDecl ( String name , String model ) throws SAXException { } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { } public void internalEntityDecl ( String name , String value ) throws SAXException { } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { m_insideDTD = true ; } public void endDTD ( ) throws SAXException { m_insideDTD = false ; } public void startEntity ( String name ) throws SAXException { } public void endEntity ( String name ) throws SAXException { } public void startCDATA ( ) throws SAXException { m_textType = DTM . CDATA_SECTION_NODE ; } public void endCDATA ( ) throws SAXException { m_textType = DTM . TEXT_NODE ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( m_insideDTD ) return ; charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( DTM . COMMENT_NODE ) ; int dataIndex = m_valuesOrPrefixes . stringToIndex ( new String ( ch , start , length ) ) ; m_previous = addNode ( DTM . COMMENT_NODE , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { if ( m_useSourceLocationProperty ) { node = makeNodeIdentity ( node ) ; return new NodeLocator ( null , m_sourceSystemId . elementAt ( node ) , m_sourceLine . elementAt ( node ) , m_sourceColumn . elementAt ( node ) ) ; } else if ( m_locator != null ) { return new NodeLocator ( null , m_locator . getSystemId ( ) , - 1 , - 1 ) ; } return null ; } } 	1	['67', '4', '1', '25', '179', '1873', '3', '23', '57', '0.911111111', '2275', '0.933333333', '11', '0.591194969', '0.131313131', '2', '19', '32.50746269', '13', '2.3284', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . ArrayList ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . bcel . classfile . JavaClass ; import org . apache . bcel . generic . * ; import org . apache . bcel . classfile . Field ; import org . apache . xalan . xsltc . compiler . util . * ; final class Number extends Instruction implements Closure { private static final int LEVEL_SINGLE = 0 ; private static final int LEVEL_MULTIPLE = 1 ; private static final int LEVEL_ANY = 2 ; static final private String [ ] ClassNames = { "org.apache.xalan.xsltc.dom.SingleNodeCounter" , "org.apache.xalan.xsltc.dom.MultipleNodeCounter" , "org.apache.xalan.xsltc.dom.AnyNodeCounter" } ; static final private String [ ] FieldNames = { "___single_node_counter" , "___multiple_node_counter" , "___any_node_counter" } ; private Pattern _from = null ; private Pattern _count = null ; private Expression _value = null ; private AttributeValueTemplate _lang = null ; private AttributeValueTemplate _format = null ; private AttributeValueTemplate _letterValue = null ; private AttributeValueTemplate _groupingSeparator = null ; private AttributeValueTemplate _groupingSize = null ; private int _level = LEVEL_SINGLE ; private boolean _formatNeeded = false ; private String _className = null ; private ArrayList _closureVars = null ; public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { return null ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; } } public void parseContents ( Parser parser ) { final int count = _attributes . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final String name = _attributes . getQName ( i ) ; final String value = _attributes . getValue ( i ) ; if ( name . equals ( "value" ) ) { _value = parser . parseExpression ( this , name , null ) ; } else if ( name . equals ( "count" ) ) { _count = parser . parsePattern ( this , name , null ) ; } else if ( name . equals ( "from" ) ) { _from = parser . parsePattern ( this , name , null ) ; } else if ( name . equals ( "level" ) ) { if ( value . equals ( "single" ) ) { _level = LEVEL_SINGLE ; } else if ( value . equals ( "multiple" ) ) { _level = LEVEL_MULTIPLE ; } else if ( value . equals ( "any" ) ) { _level = LEVEL_ANY ; } } else if ( name . equals ( "format" ) ) { _format = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "lang" ) ) { _lang = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "letter-value" ) ) { _letterValue = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "grouping-separator" ) ) { _groupingSeparator = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "grouping-size" ) ) { _groupingSize = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _value != null ) { Type tvalue = _value . typeCheck ( stable ) ; if ( tvalue instanceof RealType == false ) { _value = new CastExpr ( _value , Type . Real ) ; } } if ( _count != null ) { _count . typeCheck ( stable ) ; } if ( _from != null ) { _from . typeCheck ( stable ) ; } if ( _format != null ) { _format . typeCheck ( stable ) ; } if ( _lang != null ) { _lang . typeCheck ( stable ) ; } if ( _letterValue != null ) { _letterValue . typeCheck ( stable ) ; } if ( _groupingSeparator != null ) { _groupingSeparator . typeCheck ( stable ) ; } if ( _groupingSize != null ) { _groupingSize . typeCheck ( stable ) ; } return Type . Void ; } public boolean hasValue ( ) { return _value != null ; } public boolean isDefault ( ) { return _from == null && _count == null ; } private void compileDefault ( ClassGenerator classGen , MethodGenerator methodGen ) { int index ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; int [ ] fieldIndexes = getXSLTC ( ) . getNumberFieldIndexes ( ) ; if ( fieldIndexes [ _level ] == - 1 ) { Field defaultNode = new Field ( ACC_PRIVATE , cpg . addUtf8 ( FieldNames [ _level ] ) , cpg . addUtf8 ( NODE_COUNTER_SIG ) , null , cpg . getConstantPool ( ) ) ; classGen . addField ( defaultNode ) ; fieldIndexes [ _level ] = cpg . addFieldref ( classGen . getClassName ( ) , FieldNames [ _level ] , NODE_COUNTER_SIG ) ; } il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( fieldIndexes [ _level ] ) ) ; final BranchHandle ifBlock1 = il . append ( new IFNONNULL ( null ) ) ; index = cpg . addMethodref ( ClassNames [ _level ] , "getDefaultNodeCounter" , "(" + TRANSLET_INTF_SIG + DOM_INTF_SIG + NODE_ITERATOR_SIG + ")" + NODE_COUNTER_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( SWAP ) ; il . append ( new PUTFIELD ( fieldIndexes [ _level ] ) ) ; final BranchHandle ifBlock2 = il . append ( new GOTO ( null ) ) ; ifBlock1 . setTarget ( il . append ( classGen . loadTranslet ( ) ) ) ; il . append ( new GETFIELD ( fieldIndexes [ _level ] ) ) ; ifBlock2 . setTarget ( il . append ( NOP ) ) ; } private void compileConstructor ( ClassGenerator classGen ) { MethodGenerator cons ; final InstructionList il = new InstructionList ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; cons = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( TRANSLET_INTF_SIG ) , Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) } , new String [ ] { "dom" , "translet" , "iterator" } , "<init>" , _className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ALOAD_1 ) ; il . append ( ALOAD_2 ) ; il . append ( new ALOAD ( 3 ) ) ; int index = cpg . addMethodref ( ClassNames [ _level ] , "<init>" , "(" + TRANSLET_INTF_SIG + DOM_INTF_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new INVOKESPECIAL ( index ) ) ; il . append ( RETURN ) ; cons . stripAttributes ( true ) ; cons . setMaxLocals ( ) ; cons . setMaxStack ( ) ; classGen . addMethod ( cons . getMethod ( ) ) ; } private void compileLocals ( NodeCounterGenerator nodeCounterGen , MatchGenerator matchGen , InstructionList il ) { int field ; LocalVariableGen local ; ConstantPoolGen cpg = nodeCounterGen . getConstantPool ( ) ; local = matchGen . addLocalVariable ( "iterator" , Util . getJCRefType ( NODE_ITERATOR_SIG ) , null , null ) ; field = cpg . addFieldref ( NODE_COUNTER , "_iterator" , ITERATOR_FIELD_SIG ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( field ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; matchGen . setIteratorIndex ( local . getIndex ( ) ) ; local = matchGen . addLocalVariable ( "translet" , Util . getJCRefType ( TRANSLET_SIG ) , null , null ) ; field = cpg . addFieldref ( NODE_COUNTER , "_translet" , "Lorg/apache/xalan/xsltc/Translet;" ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( field ) ) ; il . append ( new CHECKCAST ( cpg . addClass ( TRANSLET_CLASS ) ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; nodeCounterGen . setTransletIndex ( local . getIndex ( ) ) ; local = matchGen . addLocalVariable ( "document" , Util . getJCRefType ( DOM_INTF_SIG ) , null , null ) ; field = cpg . addFieldref ( _className , "_document" , DOM_INTF_SIG ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( field ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; matchGen . setDomIndex ( local . getIndex ( ) ) ; } private void compilePatterns ( ClassGenerator classGen , MethodGenerator methodGen ) { int current ; int field ; LocalVariableGen local ; MatchGenerator matchGen ; NodeCounterGenerator nodeCounterGen ; _className = getXSLTC ( ) . getHelperClassName ( ) ; nodeCounterGen = new NodeCounterGenerator ( _className , ClassNames [ _level ] , toString ( ) , ACC_PUBLIC | ACC_SUPER , null , classGen . getStylesheet ( ) ) ; InstructionList il = null ; ConstantPoolGen cpg = nodeCounterGen . getConstantPool ( ) ; final int closureLen = ( _closureVars == null ) ? 0 : _closureVars . size ( ) ; for ( int i = 0 ; i < closureLen ; i ++ ) { VariableBase var = ( ( VariableRefBase ) _closureVars . get ( i ) ) . getVariable ( ) ; nodeCounterGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; } compileConstructor ( nodeCounterGen ) ; if ( _from != null ) { il = new InstructionList ( ) ; matchGen = new MatchGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , } , new String [ ] { "node" , } , "matchesFrom" , _className , il , cpg ) ; compileLocals ( nodeCounterGen , matchGen , il ) ; il . append ( matchGen . loadContextNode ( ) ) ; _from . translate ( nodeCounterGen , matchGen ) ; _from . synthesize ( nodeCounterGen , matchGen ) ; il . append ( IRETURN ) ; matchGen . stripAttributes ( true ) ; matchGen . setMaxLocals ( ) ; matchGen . setMaxStack ( ) ; matchGen . removeNOPs ( ) ; nodeCounterGen . addMethod ( matchGen . getMethod ( ) ) ; } if ( _count != null ) { il = new InstructionList ( ) ; matchGen = new MatchGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , } , new String [ ] { "node" , } , "matchesCount" , _className , il , cpg ) ; compileLocals ( nodeCounterGen , matchGen , il ) ; il . append ( matchGen . loadContextNode ( ) ) ; _count . translate ( nodeCounterGen , matchGen ) ; _count . synthesize ( nodeCounterGen , matchGen ) ; il . append ( IRETURN ) ; matchGen . stripAttributes ( true ) ; matchGen . setMaxLocals ( ) ; matchGen . setMaxStack ( ) ; matchGen . removeNOPs ( ) ; nodeCounterGen . addMethod ( matchGen . getMethod ( ) ) ; } getXSLTC ( ) . dumpClass ( nodeCounterGen . getJavaClass ( ) ) ; cpg = classGen . getConstantPool ( ) ; il = methodGen . getInstructionList ( ) ; final int index = cpg . addMethodref ( _className , "<init>" , "(" + TRANSLET_INTF_SIG + DOM_INTF_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; for ( int i = 0 ; i < closureLen ; i ++ ) { final VariableRefBase varRef = ( VariableRefBase ) _closureVars . get ( i ) ; final VariableBase var = varRef . getVariable ( ) ; final Type varType = var . getType ( ) ; il . append ( DUP ) ; il . append ( var . loadInstruction ( ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( _className , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { int index ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( hasValue ( ) ) { compileDefault ( classGen , methodGen ) ; _value . translate ( classGen , methodGen ) ; index = cpg . addMethodref ( MATH_CLASS , "round" , "(D)J" ) ; il . append ( new INVOKESTATIC ( index ) ) ; il . append ( new L2I ( ) ) ; index = cpg . addMethodref ( NODE_COUNTER , "setValue" , "(I)" + NODE_COUNTER_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } else if ( isDefault ( ) ) { compileDefault ( classGen , methodGen ) ; } else { compilePatterns ( classGen , methodGen ) ; } if ( ! hasValue ( ) ) { il . append ( methodGen . loadContextNode ( ) ) ; index = cpg . addMethodref ( NODE_COUNTER , SET_START_NODE , "(I)" + NODE_COUNTER_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } if ( _formatNeeded ) { if ( _format != null ) { _format . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , "1" ) ) ; } if ( _lang != null ) { _lang . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , "en" ) ) ; } if ( _letterValue != null ) { _letterValue . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } if ( _groupingSeparator != null ) { _groupingSeparator . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } if ( _groupingSize != null ) { _groupingSize . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , "0" ) ) ; } index = cpg . addMethodref ( NODE_COUNTER , "getCounter" , "(" + STRING_SIG + STRING_SIG + STRING_SIG + STRING_SIG + STRING_SIG + ")" + STRING_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } else { index = cpg . addMethodref ( NODE_COUNTER , "setDefaultFormatting" , "()" + NODE_COUNTER_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; index = cpg . addMethodref ( NODE_COUNTER , "getCounter" , "()" + STRING_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } il . append ( methodGen . loadHandler ( ) ) ; index = cpg . addMethodref ( TRANSLET_CLASS , CHARACTERSW , CHARACTERSW_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } } 	0	['15', '3', '0', '55', '96', '23', '0', '55', '9', '0.798319328', '1308', '1', '8', '0.811594203', '0.214285714', '2', '3', '85.06666667', '14', '3.1333', '0']
package org . apache . xalan . serialize ; import java . io . Writer ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Properties ; import java . util . BitSet ; import org . xml . sax . * ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . ext . DeclHandler ; import org . w3c . dom . Node ; import org . apache . xalan . serialize . Serializer ; import org . apache . xalan . serialize . DOMSerializer ; import org . apache . xml . utils . QName ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . res . XPATHErrorResources ; import javax . xml . transform . Result ; import javax . xml . transform . OutputKeys ; public class SerializerToXML implements ContentHandler , LexicalHandler , DeclHandler , Serializer , DOMSerializer { protected Writer m_writer = null ; boolean m_shouldFlush = true ; protected String m_encoding = null ; static boolean javaEncodingIsISO = false ; public boolean m_shouldNotWriteXMLHeader = false ; public String m_version = null ; protected BoolStack m_elemStack = new BoolStack ( ) ; protected BoolStack m_disableOutputEscapingStates = new BoolStack ( ) ; protected BoolStack m_cdataSectionStates = new BoolStack ( ) ; protected Vector m_cdataSectionNames = null ; protected boolean m_inCData = false ; protected boolean isEscapingDisabled ( ) { return m_disableOutputEscapingStates . peekOrFalse ( ) ; } protected boolean isCDataSection ( ) { return m_inCData || m_cdataSectionStates . peekOrFalse ( ) ; } protected final char [ ] m_lineSep = System . getProperty ( "line.separator" ) . toCharArray ( ) ; protected final int m_lineSepLen = m_lineSep . length ; protected final void outputLineSep ( ) throws org . xml . sax . SAXException { try { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } protected boolean m_ispreserve = false ; protected BoolStack m_preserves = new BoolStack ( ) ; protected boolean m_isprevtext = false ; protected boolean m_doIndent = false ; protected int m_currentIndent = 0 ; public int m_indentAmount = 0 ; protected int level = 0 ; boolean m_startNewLine ; boolean m_needToOutputDocTypeDecl = true ; String m_doctypeSystem ; String m_doctypePublic ; boolean m_standalone = false ; boolean m_standaloneWasSpecified = false ; String m_mediatype ; protected boolean m_inEntityRef = false ; private boolean m_inDoctype = false ; protected static CharInfo m_xmlcharInfo = new CharInfo ( CharInfo . XML_ENTITIES_RESOURCE ) ; protected CharInfo m_charInfo ; private static Hashtable m_charInfos = null ; boolean m_isUTF8 = false ; protected int m_maxCharacter = Encodings . getLastPrintable ( ) ; public boolean m_spaceBeforeClose = false ; protected Properties m_format ; private static final boolean DEBUG = false ; private boolean m_inExternalDTD = false ; public SerializerToXML ( ) { m_charInfo = m_xmlcharInfo ; } public void CopyFrom ( SerializerToXML xmlListener ) { m_writer = xmlListener . m_writer ; m_encoding = xmlListener . m_encoding ; javaEncodingIsISO = xmlListener . javaEncodingIsISO ; m_shouldNotWriteXMLHeader = xmlListener . m_shouldNotWriteXMLHeader ; m_elemStack = xmlListener . m_elemStack ; m_ispreserve = xmlListener . m_ispreserve ; m_preserves = xmlListener . m_preserves ; m_isprevtext = xmlListener . m_isprevtext ; m_doIndent = xmlListener . m_doIndent ; m_currentIndent = xmlListener . m_currentIndent ; m_indentAmount = xmlListener . m_indentAmount ; level = xmlListener . level ; m_startNewLine = xmlListener . m_startNewLine ; m_needToOutputDocTypeDecl = xmlListener . m_needToOutputDocTypeDecl ; m_doctypeSystem = xmlListener . m_doctypeSystem ; m_doctypePublic = xmlListener . m_doctypePublic ; m_standalone = xmlListener . m_standalone ; m_mediatype = xmlListener . m_mediatype ; m_maxCharacter = xmlListener . m_maxCharacter ; m_spaceBeforeClose = xmlListener . m_spaceBeforeClose ; m_inCData = xmlListener . m_inCData ; m_pos = 0 ; } public synchronized void init ( Writer writer , Properties format ) { init ( writer , format , false ) ; } private synchronized void init ( Writer writer , Properties format , boolean shouldFlush ) { m_shouldFlush = shouldFlush ; m_writer = writer ; m_format = format ; m_cdataSectionNames = OutputProperties . getQNameProperties ( OutputKeys . CDATA_SECTION_ELEMENTS , format ) ; m_indentAmount = OutputProperties . getIntProperty ( OutputProperties . S_KEY_INDENT_AMOUNT , format ) ; m_doIndent = OutputProperties . getBooleanProperty ( OutputKeys . INDENT , format ) ; m_shouldNotWriteXMLHeader = OutputProperties . getBooleanProperty ( OutputKeys . OMIT_XML_DECLARATION , format ) ; m_doctypeSystem = format . getProperty ( OutputKeys . DOCTYPE_SYSTEM ) ; m_doctypePublic = format . getProperty ( OutputKeys . DOCTYPE_PUBLIC ) ; m_standaloneWasSpecified = ( null != format . get ( OutputKeys . STANDALONE ) ) ; m_standalone = OutputProperties . getBooleanProperty ( OutputKeys . STANDALONE , format ) ; m_mediatype = format . getProperty ( OutputKeys . MEDIA_TYPE ) ; if ( null != m_doctypePublic ) { if ( m_doctypePublic . startsWith ( "-//W3C//DTD XHTML" ) ) m_spaceBeforeClose = true ; } if ( null == m_encoding ) m_encoding = Encodings . getMimeEncoding ( format . getProperty ( OutputKeys . ENCODING ) ) ; m_isUTF8 = m_encoding . equals ( Encodings . DEFAULT_MIME_ENCODING ) ; m_maxCharacter = Encodings . getLastPrintable ( m_encoding ) ; String entitiesFileName = ( String ) format . get ( OutputProperties . S_KEY_ENTITIES ) ; if ( null != entitiesFileName ) { try { m_charInfo = null ; if ( null == m_charInfos ) { synchronized ( m_xmlcharInfo ) { if ( null == m_charInfos ) m_charInfos = new Hashtable ( ) ; } } else { m_charInfo = ( CharInfo ) m_charInfos . get ( entitiesFileName ) ; } if ( null == m_charInfo ) { try { m_charInfo = new CharInfo ( entitiesFileName ) ; } catch ( Exception e ) { m_charInfo = null ; } } if ( null == m_charInfo ) { String absoluteEntitiesFileName ; if ( entitiesFileName . indexOf ( ':' ) < 0 ) { absoluteEntitiesFileName = SystemIDResolver . getAbsoluteURIFromRelative ( entitiesFileName ) ; } else { absoluteEntitiesFileName = SystemIDResolver . getAbsoluteURI ( entitiesFileName , null ) ; } m_charInfo = new CharInfo ( absoluteEntitiesFileName ) ; m_charInfos . put ( entitiesFileName , m_charInfo ) ; } } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } public synchronized void init ( OutputStream output , Properties format ) throws UnsupportedEncodingException { if ( null == format ) { OutputProperties op = new OutputProperties ( Method . XML ) ; format = op . getProperties ( ) ; } m_encoding = Encodings . getMimeEncoding ( format . getProperty ( OutputKeys . ENCODING ) ) ; if ( m_encoding . equalsIgnoreCase ( "UTF-8" ) ) { m_isUTF8 = true ; if ( output instanceof java . io . BufferedOutputStream ) { init ( new WriterToUTF8 ( output ) , format , true ) ; } else if ( output instanceof java . io . FileOutputStream ) { init ( new WriterToUTF8Buffered ( output ) , format , true ) ; } else { init ( new WriterToUTF8 ( output ) , format , true ) ; } } else if ( m_encoding . equals ( "WINDOWS-1250" ) || m_encoding . equals ( "US-ASCII" ) || m_encoding . equals ( "ASCII" ) ) { init ( new WriterToASCI ( output ) , format , true ) ; } else { Writer osw ; try { osw = Encodings . getWriter ( output , m_encoding ) ; } catch ( UnsupportedEncodingException uee ) { System . out . println ( "Warning: encoding \"" + m_encoding + "\" not supported" + ", using " + Encodings . DEFAULT_MIME_ENCODING ) ; m_encoding = Encodings . DEFAULT_MIME_ENCODING ; osw = Encodings . getWriter ( output , m_encoding ) ; } m_maxCharacter = Encodings . getLastPrintable ( m_encoding ) ; init ( osw , format , true ) ; } } public void setDocumentLocator ( Locator locator ) { } void outputDocTypeDecl ( String name , boolean closeDecl ) throws org . xml . sax . SAXException { try { final Writer writer = m_writer ; writer . write ( "<!DOCTYPE " ) ; writer . write ( name ) ; if ( null != m_doctypePublic ) { writer . write ( " PUBLIC \"" ) ; writer . write ( m_doctypePublic ) ; writer . write ( '\"' ) ; } if ( null != m_doctypeSystem ) { if ( null == m_doctypePublic ) writer . write ( " SYSTEM \"" ) ; else writer . write ( " \"" ) ; writer . write ( m_doctypeSystem ) ; if ( closeDecl ) { writer . write ( "\">" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; ; } else writer . write ( '\"' ) ; } } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } void outputEntityDecl ( String name , String value ) throws org . xml . sax . SAXException { try { final Writer writer = m_writer ; writer . write ( "<!ENTITY " ) ; writer . write ( name ) ; writer . write ( " \"" ) ; writer . write ( value ) ; writer . write ( "\">" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void startDocument ( ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; m_needToOutputDocTypeDecl = true ; m_startNewLine = false ; if ( m_shouldNotWriteXMLHeader == false ) { String encoding = Encodings . getMimeEncoding ( m_encoding ) ; String version = ( null == m_version ) ? "1.0" : m_version ; String standalone ; if ( m_standaloneWasSpecified ) { standalone = " standalone=\"" + ( m_standalone ? "yes" : "no" ) + "\"" ; } else { standalone = "" ; } try { final Writer writer = m_writer ; writer . write ( "<?xml version=\"" ) ; writer . write ( version ) ; writer . write ( "\" encoding=\"" ) ; writer . write ( encoding ) ; writer . write ( '\"' ) ; writer . write ( standalone ) ; writer . write ( "?>" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } } public void endDocument ( ) throws org . xml . sax . SAXException { if ( m_doIndent && ! m_isprevtext ) { outputLineSep ( ) ; } flushWriter ( ) ; } public void startDTD ( String name , String publicId , String systemId ) throws org . xml . sax . SAXException { m_doctypeSystem = systemId ; m_doctypePublic = publicId ; if ( ( true == m_needToOutputDocTypeDecl ) ) { outputDocTypeDecl ( name , false ) ; } m_needToOutputDocTypeDecl = false ; m_inDoctype = true ; } public void endDTD ( ) throws org . xml . sax . SAXException { try { if ( ! m_inDoctype ) m_writer . write ( "]>" ) ; else { m_writer . write ( '>' ) ; } m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } protected static final boolean subPartMatch ( String p , String t ) { return ( p == t ) || ( ( null != p ) && ( p . equals ( t ) ) ) ; } protected void pushState ( String namespaceURI , String localName , Vector qnames , BoolStack state ) { boolean b ; if ( null != qnames ) { b = false ; if ( ( null != namespaceURI ) && namespaceURI . length ( ) == 0 ) namespaceURI = null ; int nElems = qnames . size ( ) ; for ( int i = 0 ; i < nElems ; i ++ ) { QName q = ( QName ) qnames . elementAt ( i ) ; if ( q . getLocalName ( ) . equals ( localName ) && subPartMatch ( namespaceURI , q . getNamespaceURI ( ) ) ) { b = true ; break ; } } } else { b = state . peekOrFalse ( ) ; } state . push ( b ) ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . println ( "SerializerToXML - startElement: " + namespaceURI + ", " + localName ) ; int n = atts . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( "atts[" + i + "]: " + atts . getQName ( i ) + " = " + atts . getValue ( i ) ) ; } if ( null == namespaceURI ) { ( new RuntimeException ( localName + " has a null namespace!" ) ) . printStackTrace ( ) ; } } if ( m_inEntityRef ) return ; if ( ( true == m_needToOutputDocTypeDecl ) && ( null != m_doctypeSystem ) ) { outputDocTypeDecl ( name , true ) ; } m_needToOutputDocTypeDecl = false ; writeParentTagEnd ( ) ; pushState ( namespaceURI , localName , m_cdataSectionNames , m_cdataSectionStates ) ; m_ispreserve = false ; if ( shouldIndent ( ) && m_startNewLine ) { indent ( m_currentIndent ) ; } m_startNewLine = true ; try { m_writer . write ( '<' ) ; m_writer . write ( name ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { processAttribute ( atts . getQName ( i ) , atts . getValue ( i ) ) ; } openElementForChildren ( ) ; m_currentIndent += m_indentAmount ; m_isprevtext = false ; } protected void writeParentTagEnd ( ) throws org . xml . sax . SAXException { if ( ! m_elemStack . peekOrTrue ( ) ) { try { m_writer . write ( '>' ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } m_isprevtext = false ; m_elemStack . setTop ( true ) ; m_preserves . push ( m_ispreserve ) ; } } protected void openElementForChildren ( ) { m_elemStack . push ( false ) ; } protected boolean childNodesWereAdded ( ) { return m_elemStack . isEmpty ( ) ? false : m_elemStack . pop ( ) ; } public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; m_currentIndent -= m_indentAmount ; boolean hasChildNodes = childNodesWereAdded ( ) ; try { final Writer writer = m_writer ; if ( hasChildNodes ) { if ( shouldIndent ( ) ) indent ( m_currentIndent ) ; writer . write ( '<' ) ; writer . write ( '/' ) ; writer . write ( name ) ; writer . write ( '>' ) ; } else { if ( m_spaceBeforeClose ) writer . write ( " />" ) ; else writer . write ( "/>" ) ; } } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } if ( hasChildNodes ) { m_ispreserve = m_preserves . isEmpty ( ) ? false : m_preserves . pop ( ) ; } m_isprevtext = false ; m_cdataSectionStates . pop ( ) ; } protected void processAttribute ( String name , String value ) throws org . xml . sax . SAXException { try { final Writer writer = m_writer ; writer . write ( ' ' ) ; writer . write ( name ) ; writer . write ( "=\"" ) ; writeAttrString ( value , m_encoding ) ; writer . write ( '\"' ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void startNonEscaping ( ) throws org . xml . sax . SAXException { m_disableOutputEscapingStates . push ( true ) ; } public void endNonEscaping ( ) throws org . xml . sax . SAXException { m_disableOutputEscapingStates . pop ( ) ; } public void startPreserving ( ) throws org . xml . sax . SAXException { m_preserves . push ( true ) ; m_ispreserve = true ; } public void endPreserving ( ) throws org . xml . sax . SAXException { m_ispreserve = m_preserves . isEmpty ( ) ? false : m_preserves . pop ( ) ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; if ( target . equals ( Result . PI_DISABLE_OUTPUT_ESCAPING ) ) { startNonEscaping ( ) ; } else if ( target . equals ( Result . PI_ENABLE_OUTPUT_ESCAPING ) ) { endNonEscaping ( ) ; } else { try { final Writer writer = m_writer ; writeParentTagEnd ( ) ; if ( shouldIndent ( ) ) indent ( m_currentIndent ) ; writer . write ( '<' ) ; writer . write ( '?' ) ; writer . write ( target ) ; if ( data . length ( ) > 0 && ! Character . isSpaceChar ( data . charAt ( 0 ) ) ) writer . write ( ' ' ) ; int indexOfQLT = data . indexOf ( "?>" ) ; if ( indexOfQLT >= 0 ) { if ( indexOfQLT > 0 ) { writer . write ( data . substring ( 0 , indexOfQLT ) ) ; } writer . write ( "? >" ) ; if ( ( indexOfQLT + 2 ) < data . length ( ) ) { writer . write ( data . substring ( indexOfQLT + 2 ) ) ; } } else { writer . write ( data ) ; } writer . write ( '?' ) ; writer . write ( '>' ) ; if ( m_elemStack . isEmpty ( ) ) writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_startNewLine = true ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; writeParentTagEnd ( ) ; if ( shouldIndent ( ) ) indent ( m_currentIndent ) ; try { final Writer writer = m_writer ; writer . write ( "<!--" ) ; writer . write ( ch , start , length ) ; writer . write ( "-->" ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } m_startNewLine = true ; } public void startCDATA ( ) throws org . xml . sax . SAXException { m_inCData = true ; } public void endCDATA ( ) throws org . xml . sax . SAXException { m_inCData = false ; } public void cdata ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeParentTagEnd ( ) ; m_ispreserve = true ; if ( shouldIndent ( ) ) indent ( m_currentIndent ) ; boolean writeCDataBrackets = ( ( ( length >= 1 ) && canConvert ( ch [ start ] ) ) ) ; if ( writeCDataBrackets ) { m_writer . write ( "<![CDATA[" ) ; } if ( isEscapingDisabled ( ) ) { charactersRaw ( ch , start , length ) ; } else writeNormalizedChars ( ch , start , length , true ) ; if ( writeCDataBrackets ) { m_writer . write ( "]]>" ) ; } } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_OIERROR , null ) , ioe ) ; } } protected int m_pos = 0 ; protected final void accum ( char b ) throws org . xml . sax . SAXException { try { m_writer . write ( b ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } protected final void accum ( char chars [ ] , int start , int length ) throws org . xml . sax . SAXException { try { m_writer . write ( chars , start , length ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } protected final void accum ( String s ) throws org . xml . sax . SAXException { try { m_writer . write ( s ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public final void flushWriter ( ) throws org . xml . sax . SAXException { if ( null != m_writer ) { try { if ( m_writer instanceof WriterToUTF8Buffered ) { if ( m_shouldFlush ) ( ( WriterToUTF8Buffered ) m_writer ) . flush ( ) ; else ( ( WriterToUTF8Buffered ) m_writer ) . flushBuffer ( ) ; } if ( m_writer instanceof WriterToUTF8 ) { if ( m_shouldFlush ) m_writer . flush ( ) ; } else if ( m_writer instanceof WriterToASCI ) { if ( m_shouldFlush ) m_writer . flush ( ) ; } else { m_writer . flush ( ) ; } } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( ioe ) ; } } } public void characters ( char chars [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( 0 == length ) return ; if ( m_inCData || m_cdataSectionStates . peekOrFalse ( ) ) { cdata ( chars , start , length ) ; return ; } try { if ( m_disableOutputEscapingStates . peekOrFalse ( ) ) { charactersRaw ( chars , start , length ) ; return ; } final Writer writer = m_writer ; if ( ! m_elemStack . peekOrTrue ( ) ) { writer . write ( '>' ) ; m_isprevtext = false ; m_elemStack . setTop ( true ) ; m_preserves . push ( m_ispreserve ) ; } int startClean = start ; int lengthClean = 0 ; int end = start + length ; boolean checkWhite = true ; final int maxCharacter = m_maxCharacter ; final BitSet specialsMap = m_charInfo . m_specialsMap ; for ( int i = start ; i < end ; i ++ ) { char ch = chars [ i ] ; if ( checkWhite && ( ( ch > 0x20 ) || ! ( ( ch == 0x20 ) || ( ch == 0x09 ) || ( ch == 0xD ) || ( ch == 0xA ) ) ) ) { m_ispreserve = true ; checkWhite = false ; } if ( ( canConvert ( ch ) && ( ! specialsMap . get ( ch ) ) ) || ( '"' == ch ) ) { lengthClean ++ ; } else { if ( lengthClean > 0 ) { writer . write ( chars , startClean , lengthClean ) ; lengthClean = 0 ; } if ( CharInfo . S_LINEFEED == ch ) { writer . write ( m_lineSep , 0 , m_lineSepLen ) ; startClean = i + 1 ; } else { startClean = accumDefaultEscape ( ch , i , chars , end , false ) ; i = startClean - 1 ; } } } if ( lengthClean > 0 ) { writer . write ( chars , startClean , lengthClean ) ; } } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } m_isprevtext = true ; } public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { if ( m_inEntityRef ) return ; writeParentTagEnd ( ) ; m_ispreserve = true ; m_writer . write ( ch , start , length ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } static final boolean isUTF16Surrogate ( char c ) { return ( c & 0xFC00 ) == 0xD800 ; } int getURF16SurrogateValue ( char c , char ch [ ] , int i , int end ) throws org . xml . sax . SAXException { int next ; if ( i + 1 >= end ) { throw new org . xml . sax . SAXException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ( int ) c ) } ) ) ; } else { next = ch [ ++ i ] ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new org . xml . sax . SAXException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ( int ) c ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( c - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } return next ; } protected int writeUTF16Surrogate ( char c , char ch [ ] , int i , int end ) throws IOException , org . xml . sax . SAXException { int surrogateValue = getURF16SurrogateValue ( c , ch , i , end ) ; i ++ ; m_writer . write ( '&' ) ; m_writer . write ( '#' ) ; m_writer . write ( Integer . toString ( surrogateValue ) ) ; m_writer . write ( ';' ) ; return i ; } void writeNormalizedChars ( char ch [ ] , int start , int length , boolean isCData ) throws IOException , org . xml . sax . SAXException { int end = start + length ; for ( int i = start ; i < end ; i ++ ) { char c = ch [ i ] ; if ( CharInfo . S_LINEFEED == c ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else if ( isCData && ( ! canConvert ( c ) ) ) { if ( i != 0 ) m_writer . write ( "]]>" ) ; if ( isUTF16Surrogate ( c ) ) { i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { m_writer . write ( "&#" ) ; String intStr = Integer . toString ( ( int ) c ) ; m_writer . write ( intStr ) ; m_writer . write ( ';' ) ; } if ( ( i != 0 ) && ( i < ( end - 1 ) ) ) m_writer . write ( "<![CDATA[" ) ; } else if ( isCData && ( ( i < ( end - 2 ) ) && ( ']' == c ) && ( ']' == ch [ i + 1 ] ) && ( '>' == ch [ i + 2 ] ) ) ) { m_writer . write ( "]]]]><![CDATA[>" ) ; i += 2 ; } else { if ( canConvert ( c ) ) { m_writer . write ( c ) ; } else if ( isUTF16Surrogate ( c ) ) { i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { m_writer . write ( "&#" ) ; String intStr = Integer . toString ( ( int ) c ) ; m_writer . write ( intStr ) ; m_writer . write ( ';' ) ; } } } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( 0 == length ) return ; characters ( ch , start , length ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { } public void startEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( "[dtd]" ) ) m_inExternalDTD = true ; m_inEntityRef = true ; } public void endEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( "[dtd]" ) ) m_inExternalDTD = false ; m_inEntityRef = false ; } public void entityReference ( String name ) throws org . xml . sax . SAXException { writeParentTagEnd ( ) ; if ( shouldIndent ( ) ) indent ( m_currentIndent ) ; try { final Writer writer = m_writer ; writer . write ( "&" ) ; writer . write ( name ) ; writer . write ( ";" ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void elementDecl ( String name , String model ) throws SAXException { if ( m_inExternalDTD ) return ; try { final Writer writer = m_writer ; if ( m_inDoctype ) { writer . write ( " [" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } writer . write ( "<!ELEMENT " ) ; writer . write ( name ) ; writer . write ( ' ' ) ; writer . write ( model ) ; writer . write ( '>' ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } private String m_elemName = "" ; public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( m_inExternalDTD ) return ; try { final Writer writer = m_writer ; if ( m_inDoctype ) { writer . write ( " [" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } writer . write ( "<!ATTLIST " ) ; writer . write ( eName ) ; writer . write ( " " ) ; writer . write ( aName ) ; writer . write ( " " ) ; writer . write ( type ) ; if ( valueDefault != null ) { writer . write ( " " ) ; writer . write ( valueDefault ) ; } writer . write ( ">" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( m_inExternalDTD ) return ; try { if ( m_inDoctype ) { m_writer . write ( " [" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } outputEntityDecl ( name , value ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { } protected int accumDefaultEntity ( char ch , int i , char [ ] chars , int len , boolean escLF ) throws org . xml . sax . SAXException { try { if ( ! escLF && CharInfo . S_LINEFEED == ch ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else { if ( m_charInfo . isSpecial ( ch ) ) { String entityRef = m_charInfo . getEntityNameForChar ( ch ) ; if ( null != entityRef ) { final Writer writer = m_writer ; writer . write ( '&' ) ; writer . write ( entityRef ) ; writer . write ( ';' ) ; } else return i ; } else return i ; } return i + 1 ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } protected int accumDefaultEscape ( char ch , int i , char [ ] chars , int len , boolean escLF ) throws org . xml . sax . SAXException { int pos = accumDefaultEntity ( ch , i , chars , len , escLF ) ; if ( i == pos ) { pos ++ ; try { if ( 0xd800 <= ch && ch < 0xdc00 ) { int next ; if ( i + 1 >= len ) { throw new org . xml . sax . SAXException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) } ) ) ; } else { next = chars [ ++ i ] ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new org . xml . sax . SAXException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( ch - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } m_writer . write ( "&#" ) ; m_writer . write ( Integer . toString ( next ) ) ; m_writer . write ( ";" ) ; } else { if ( ! canConvert ( ch ) || ( m_charInfo . isSpecial ( ch ) ) ) { m_writer . write ( "&#" ) ; m_writer . write ( Integer . toString ( ch ) ) ; m_writer . write ( ";" ) ; } else { m_writer . write ( ch ) ; } } } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } return pos ; } Object m_charToByteConverter = null ; java . lang . reflect . Method m_canConvertMeth ; boolean m_triedToGetConverter = false ; public boolean canConvert ( char ch ) { if ( ch < 127 ) { if ( ch >= 0x20 || ( 0x0A == ch || 0x0D == ch || 0x09 == ch ) ) return true ; else return false ; } if ( null == m_charToByteConverter && false == m_triedToGetConverter ) { m_triedToGetConverter = true ; try { m_charToByteConverter = Encodings . getCharToByteConverter ( m_encoding ) ; if ( null != m_charToByteConverter ) { Class argsTypes [ ] = new Class [ 1 ] ; argsTypes [ 0 ] = Character . TYPE ; Class convClass = m_charToByteConverter . getClass ( ) ; m_canConvertMeth = convClass . getMethod ( "canConvert" , argsTypes ) ; } } catch ( Exception e ) { System . err . println ( "Warning: " + e . getMessage ( ) ) ; } } if ( null != m_charToByteConverter ) { try { Object args [ ] = new Object [ 1 ] ; args [ 0 ] = new Character ( ch ) ; Boolean bool = ( Boolean ) m_canConvertMeth . invoke ( m_charToByteConverter , args ) ; return bool . booleanValue ( ) ? ! Character . isISOControl ( ch ) : false ; } catch ( java . lang . reflect . InvocationTargetException ite ) { System . err . println ( "Warning: InvocationTargetException in canConvert!" ) ; } catch ( java . lang . IllegalAccessException iae ) { System . err . println ( "Warning: IllegalAccessException in canConvert!" ) ; } } return ( ch <= m_maxCharacter ) ; } public void writeAttrString ( String string , String encoding ) throws org . xml . sax . SAXException { try { final char [ ] stringChars = string . toCharArray ( ) ; final int len = stringChars . length ; final Writer writer = m_writer ; for ( int i = 0 ; i < len ; i ++ ) { char ch = stringChars [ i ] ; if ( canConvert ( ch ) && ( ! m_charInfo . isSpecial ( ch ) ) ) { writer . write ( ch ) ; } else { if ( ( CharInfo . S_CARRIAGERETURN == ch ) && ( ( i + 1 ) < len ) && ( CharInfo . S_LINEFEED == stringChars [ i + 1 ] ) ) { i ++ ; ch = CharInfo . S_LINEFEED ; } accumDefaultEscape ( ch , i , stringChars , len , true ) ; } } } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } protected boolean shouldIndent ( ) { return m_doIndent && ( ! m_ispreserve && ! m_isprevtext ) ; } public void printSpace ( int n ) throws org . xml . sax . SAXException { try { for ( int i = 0 ; i < n ; i ++ ) { m_writer . write ( ' ' ) ; } } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void indent ( int n ) throws org . xml . sax . SAXException { if ( m_startNewLine ) outputLineSep ( ) ; if ( m_doIndent ) { printSpace ( n ) ; } } public void setOutputStream ( OutputStream output ) { try { init ( output , m_format ) ; } catch ( UnsupportedEncodingException uee ) { } } public OutputStream getOutputStream ( ) { if ( m_writer instanceof WriterToUTF8Buffered ) return ( ( WriterToUTF8Buffered ) m_writer ) . getOutputStream ( ) ; if ( m_writer instanceof WriterToUTF8 ) return ( ( WriterToUTF8 ) m_writer ) . getOutputStream ( ) ; else if ( m_writer instanceof WriterToASCI ) return ( ( WriterToASCI ) m_writer ) . getOutputStream ( ) ; else return null ; } public void setWriter ( Writer writer ) { m_writer = writer ; } public Writer getWriter ( ) { return m_writer ; } public void setOutputFormat ( Properties format ) { boolean shouldFlush = m_shouldFlush ; init ( m_writer , format , false ) ; m_shouldFlush = shouldFlush ; } public Properties getOutputFormat ( ) { return m_format ; } public ContentHandler asContentHandler ( ) throws IOException { return this ; } public DOMSerializer asDOMSerializer ( ) throws IOException { return this ; } public boolean reset ( ) { return false ; } public void serialize ( Node node ) throws IOException { try { TreeWalker walker = new TreeWalker ( this , new org . apache . xpath . DOM2Helper ( ) ) ; walker . traverse ( node ) ; } catch ( org . xml . sax . SAXException se ) { throw new WrappedRuntimeException ( se ) ; } } } 	1	['71', '1', '2', '24', '151', '1037', '8', '16', '48', '0.878405316', '2724', '0.604651163', '6', '0', '0.133333333', '0', '0', '36.76056338', '12', '1.507', '2']
package org . apache . xpath . compiler ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xpath . XPath ; import org . apache . xpath . compiler . XPathParser ; public class XPathDumper { } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '4', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . XMLNSDecl ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xpath . XPath ; import org . apache . xalan . templates . StylesheetRoot ; import javax . xml . transform . TransformerException ; import org . xml . sax . Attributes ; import org . xml . sax . Locator ; import org . xml . sax . helpers . AttributesImpl ; import javax . xml . transform . TransformerConfigurationException ; import org . apache . xml . utils . SAXSourceLocator ; import java . util . Vector ; public class ProcessorLRE extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { try { ElemTemplateElement p = handler . getElemTemplateElement ( ) ; boolean excludeXSLDecl = false ; boolean isLREAsStyleSheet = false ; if ( null == p ) { XSLTElementProcessor lreProcessor = handler . popProcessor ( ) ; XSLTElementProcessor stylesheetProcessor = handler . getProcessorFor ( Constants . S_XSLNAMESPACEURL , "stylesheet" , "xsl:stylesheet" ) ; handler . pushProcessor ( lreProcessor ) ; Stylesheet stylesheet ; try { stylesheet = new StylesheetRoot ( handler . getSchema ( ) , handler . getStylesheetProcessor ( ) . getErrorListener ( ) ) ; } catch ( TransformerConfigurationException tfe ) { throw new TransformerException ( tfe ) ; } SAXSourceLocator slocator = new SAXSourceLocator ( ) ; Locator locator = handler . getLocator ( ) ; if ( null != locator ) { slocator . setLineNumber ( locator . getLineNumber ( ) ) ; slocator . setColumnNumber ( locator . getColumnNumber ( ) ) ; slocator . setPublicId ( locator . getPublicId ( ) ) ; slocator . setSystemId ( locator . getSystemId ( ) ) ; } stylesheet . setLocaterInfo ( slocator ) ; stylesheet . setPrefixes ( handler . getNamespaceSupport ( ) ) ; handler . pushStylesheet ( stylesheet ) ; isLREAsStyleSheet = true ; AttributesImpl stylesheetAttrs = new AttributesImpl ( ) ; AttributesImpl lreAttrs = new AttributesImpl ( ) ; int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrLocalName = attributes . getLocalName ( i ) ; String attrUri = attributes . getURI ( i ) ; String value = attributes . getValue ( i ) ; if ( ( null != attrUri ) && attrUri . equals ( Constants . S_XSLNAMESPACEURL ) ) { stylesheetAttrs . addAttribute ( null , attrLocalName , attrLocalName , attributes . getType ( i ) , attributes . getValue ( i ) ) ; } else if ( ( attrLocalName . startsWith ( "xmlns:" ) || attrLocalName . equals ( "xmlns" ) ) && value . equals ( Constants . S_XSLNAMESPACEURL ) ) { } else { lreAttrs . addAttribute ( attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getType ( i ) , attributes . getValue ( i ) ) ; } } attributes = lreAttrs ; try { stylesheetProcessor . setPropertiesFromAttributes ( handler , "stylesheet" , stylesheetAttrs , stylesheet ) ; } catch ( Exception e ) { String msg = e . getMessage ( ) ; if ( stylesheet . getDeclaredPrefixes ( ) == null || ! declaredXSLNS ( stylesheet ) ) { msg = msg + "; " + XSLMessages . createWarning ( XSLTErrorResources . WG_OLD_XSLT_NS , null ) ; } throw new org . xml . sax . SAXException ( msg , e ) ; } handler . pushElemTemplateElement ( stylesheet ) ; ElemTemplate template = new ElemTemplate ( ) ; appendAndPush ( handler , template ) ; XPath rootMatch = new XPath ( "/" , stylesheet , stylesheet , XPath . MATCH , handler . getStylesheetProcessor ( ) . getErrorListener ( ) ) ; template . setMatch ( rootMatch ) ; stylesheet . setTemplate ( template ) ; p = handler . getElemTemplateElement ( ) ; excludeXSLDecl = true ; } XSLTElementDef def = getElemDef ( ) ; Class classObject = def . getClassObject ( ) ; boolean isExtension = false ; boolean isComponentDecl = false ; boolean isUnknownTopLevel = false ; while ( null != p ) { if ( p instanceof ElemLiteralResult ) { ElemLiteralResult parentElem = ( ElemLiteralResult ) p ; isExtension = parentElem . containsExtensionElementURI ( uri ) ; } else if ( p instanceof Stylesheet ) { Stylesheet parentElem = ( Stylesheet ) p ; isExtension = parentElem . containsExtensionElementURI ( uri ) ; if ( ( false == isExtension ) && ( null != uri ) && uri . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) ) { isComponentDecl = true ; } else { isUnknownTopLevel = true ; } } if ( isExtension ) break ; p = p . getParentElem ( ) ; } ElemTemplateElement elem = null ; try { if ( isExtension ) { elem = new ElemExtensionCall ( ) ; } else if ( isComponentDecl ) { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; } else if ( isUnknownTopLevel ) { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; } else { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; } elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; elem . setPrefixes ( handler . getNamespaceSupport ( ) , excludeXSLDecl ) ; if ( elem instanceof ElemLiteralResult ) { ( ( ElemLiteralResult ) elem ) . setNamespace ( uri ) ; ( ( ElemLiteralResult ) elem ) . setLocalName ( localName ) ; ( ( ElemLiteralResult ) elem ) . setRawName ( rawName ) ; ( ( ElemLiteralResult ) elem ) . setIsLiteralResultAsStylesheet ( isLREAsStyleSheet ) ; } } catch ( InstantiationException ie ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMLITRSLT , null , ie ) ; } catch ( IllegalAccessException iae ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMLITRSLT , null , iae ) ; } setPropertiesFromAttributes ( handler , rawName , attributes , elem ) ; if ( ! isExtension && ( elem instanceof ElemLiteralResult ) ) { isExtension = ( ( ElemLiteralResult ) elem ) . containsExtensionElementURI ( uri ) ; if ( isExtension ) { elem = new ElemExtensionCall ( ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; elem . setPrefixes ( handler . getNamespaceSupport ( ) ) ; ( ( ElemLiteralResult ) elem ) . setNamespace ( uri ) ; ( ( ElemLiteralResult ) elem ) . setLocalName ( localName ) ; ( ( ElemLiteralResult ) elem ) . setRawName ( rawName ) ; setPropertiesFromAttributes ( handler , rawName , attributes , elem ) ; } } appendAndPush ( handler , elem ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ElemTemplateElement elem = handler . getElemTemplateElement ( ) ; if ( elem instanceof ElemLiteralResult ) { if ( ( ( ElemLiteralResult ) elem ) . getIsLiteralResultAsStylesheet ( ) ) { handler . popStylesheet ( ) ; } } super . endElement ( handler , uri , localName , rawName ) ; } private boolean declaredXSLNS ( Stylesheet stylesheet ) { Vector declaredPrefixes = stylesheet . getDeclaredPrefixes ( ) ; int n = declaredPrefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) declaredPrefixes . elementAt ( i ) ; if ( decl . getURI ( ) . equals ( Constants . S_XSLNAMESPACEURL ) ) return true ; } return false ; } } 	1	['4', '5', '0', '17', '75', '6', '1', '17', '3', '2', '468', '0', '0', '0.986111111', '0.5', '4', '6', '116', '3', '1.25', '1']
package org . apache . xalan . xsltc . runtime ; import java . io . * ; import java . util . Stack ; import java . util . Enumeration ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; import org . apache . xalan . xsltc . * ; public final class TextOutput implements TransletOutputHandler , Constants { public static final int UNKNOWN = 0 ; public static final int XML = 1 ; public static final int HTML = 2 ; public static final int TEXT = 3 ; public static final int QNAME = 4 ; private int _outputType = UNKNOWN ; private String _encoding ; private String _mediaType = "text/html" ; private String _doctypeSystem = null ; private String _doctypePublic = null ; private boolean _escapeChars = false ; private boolean _startTagOpen = false ; private boolean _headTagOpen = false ; private boolean _cdataTagOpen = false ; private boolean _is8859Encoded = false ; private Hashtable _cdata = null ; private static final char [ ] AMP = "&amp;" . toCharArray ( ) ; private static final char [ ] LT = "&lt;" . toCharArray ( ) ; private static final char [ ] GT = "&gt;" . toCharArray ( ) ; private static final char [ ] CRLF = "&#xA;" . toCharArray ( ) ; private static final char [ ] QUOTE = "&quot;" . toCharArray ( ) ; private static final char [ ] NBSP = "&nbsp;" . toCharArray ( ) ; private static final char [ ] BEGCDATA = "<![CDATA[" . toCharArray ( ) ; private static final char [ ] ENDCDATA = "]]>" . toCharArray ( ) ; private static final char [ ] CNTCDATA = "]]]]><![CDATA[>" . toCharArray ( ) ; private static final char [ ] BEGCOMM = "<!--" . toCharArray ( ) ; private static final char [ ] ENDCOMM = "-->" . toCharArray ( ) ; private static final int AMP_length = AMP . length ; private static final int LT_length = LT . length ; private static final int GT_length = GT . length ; private static final int CRLF_length = CRLF . length ; private static final int QUOTE_length = QUOTE . length ; private static final int NBSP_length = NBSP . length ; private static final int BEGCOMM_length = BEGCOMM . length ; private static final int ENDCOMM_length = ENDCOMM . length ; private static final String HREF_STR = "href" ; private static final String CITE_STR = "cite" ; private static final String SRC_STR = "src" ; private static final String CHAR_ESC_START = "&#" ; private static final String CDATA_ESC_START = "]]>&#" ; private static final String CDATA_ESC_END = ";<![CDATA[" ; private AttributesImpl _attributes = new AttributesImpl ( ) ; private String _elementName = null ; private Hashtable _namespaces ; private Stack _nodeStack ; private Stack _prefixStack ; private Stack _qnameStack ; private Stack _cdataStack ; private int _depth = 0 ; private ContentHandler _saxHandler ; private LexicalHandler _lexHandler ; public TextOutput ( ContentHandler handler ) throws IOException { _saxHandler = handler ; init ( ) ; } public TextOutput ( ContentHandler handler , String encoding ) throws IOException { _saxHandler = handler ; init ( ) ; _encoding = encoding ; _is8859Encoded = _encoding . equalsIgnoreCase ( "iso-8859-1" ) ; } public TextOutput ( ContentHandler sax , LexicalHandler lex , String encoding ) throws IOException { _saxHandler = sax ; _lexHandler = lex ; init ( ) ; _encoding = encoding ; _is8859Encoded = _encoding . equalsIgnoreCase ( "iso-8859-1" ) ; } private void init ( ) throws IOException { _outputType = UNKNOWN ; _encoding = "UTF-8" ; _mediaType = "text/html" ; _escapeChars = false ; _startTagOpen = false ; _cdataTagOpen = false ; _qnameStack = new Stack ( ) ; _cdataStack = new Stack ( ) ; _cdataStack . push ( new Integer ( - 1 ) ) ; initNamespaces ( ) ; } public void close ( ) { if ( ( _saxHandler != null ) && ( _saxHandler instanceof DefaultSAXOutputHandler ) ) { ( ( DefaultSAXOutputHandler ) _saxHandler ) . close ( ) ; } } private void setTypeInternal ( int type ) { if ( type == XML ) { _escapeChars = true ; } else if ( type == HTML ) { setIndent ( true ) ; _escapeChars = true ; } setType ( type ) ; } private void emitHeader ( ) throws SAXException { if ( _outputType == HTML ) { AttributeList attrs = new AttributeList ( ) ; attrs . add ( "http-equiv" , "Content-Type" ) ; attrs . add ( "content" , _mediaType + "; charset=" + _encoding ) ; _saxHandler . startElement ( EMPTYSTRING , EMPTYSTRING , "meta" , attrs ) ; _saxHandler . endElement ( EMPTYSTRING , EMPTYSTRING , "meta" ) ; } } public void closeStartTag ( ) throws TransletException { try { _startTagOpen = false ; _saxHandler . startElement ( getNamespaceURI ( _elementName , true ) , getLocalName ( _elementName ) , _elementName , _attributes ) ; if ( _headTagOpen ) { emitHeader ( ) ; _headTagOpen = false ; } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public boolean setEscaping ( boolean escape ) throws TransletException { if ( _outputType == UNKNOWN ) setTypeInternal ( XML ) ; boolean oldSetting = _escapeChars ; _escapeChars = escape ; if ( _outputType == TEXT ) _escapeChars = false ; return ( oldSetting ) ; } public void startDocument ( ) throws TransletException { try { _saxHandler . startDocument ( ) ; if ( _outputType == XML ) _escapeChars = true ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void endDocument ( ) throws TransletException { try { if ( _outputType == UNKNOWN ) setTypeInternal ( XML ) ; if ( _startTagOpen ) closeStartTag ( ) ; if ( _cdataTagOpen ) closeCDATA ( ) ; _saxHandler . endDocument ( ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void characters ( String str ) throws TransletException { try { characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } private void characters ( char [ ] ch ) throws SAXException { characters ( ch , 0 , ch . length ) ; } private void startCDATA ( char [ ] ch , int off , int len ) throws SAXException { final int limit = off + len ; int offset = off ; _saxHandler . characters ( BEGCDATA , 0 , BEGCDATA . length ) ; for ( int i = offset ; i < limit - 2 ; i ++ ) { if ( ch [ i ] == ']' && ch [ i + 1 ] == ']' && ch [ i + 2 ] == '>' ) { _saxHandler . characters ( ch , offset , i - offset ) ; _saxHandler . characters ( CNTCDATA , 0 , CNTCDATA . length ) ; offset = i + 3 ; i = i + 2 ; } } if ( offset < limit ) _saxHandler . characters ( ch , offset , limit - offset ) ; _cdataTagOpen = true ; } private void closeCDATA ( ) throws SAXException { _saxHandler . characters ( ENDCDATA , 0 , ENDCDATA . length ) ; _cdataTagOpen = false ; } public void startCDATA ( ) throws TransletException { } public void endCDATA ( ) throws TransletException { } public void characters ( char [ ] ch , int off , int len ) throws TransletException { try { switch ( _outputType ) { case UNKNOWN : setTypeInternal ( XML ) ; case XML : if ( _startTagOpen ) closeStartTag ( ) ; Integer I = ( Integer ) _cdataStack . peek ( ) ; if ( ( I . intValue ( ) == _depth ) && ( ! _cdataTagOpen ) ) { startCDATA ( ch , off , len ) ; } else if ( _escapeChars ) { if ( _cdataTagOpen ) { escapeCDATA ( ch , off , len ) ; } else { escapeCharacters ( ch , off , len ) ; } } else { _saxHandler . characters ( ch , off , len ) ; } return ; case HTML : if ( _startTagOpen ) closeStartTag ( ) ; if ( _escapeChars ) { if ( ! _qnameStack . isEmpty ( ) ) { String qname = ( String ) _qnameStack . peek ( ) ; qname = qname . toLowerCase ( ) ; if ( ( qname . equals ( "style" ) ) || ( qname . equals ( "script" ) ) ) { _saxHandler . characters ( ch , off , len ) ; return ; } } escapeCharacters ( ch , off , len ) ; } else { _saxHandler . characters ( ch , off , len ) ; } return ; case TEXT : _saxHandler . characters ( ch , off , len ) ; return ; } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void startElement ( String elementName ) throws TransletException { try { switch ( _outputType ) { case UNKNOWN : if ( elementName . toLowerCase ( ) . equals ( "html" ) ) setTypeInternal ( HTML ) ; else setTypeInternal ( XML ) ; startElement ( elementName ) ; return ; case XML : if ( _startTagOpen ) closeStartTag ( ) ; if ( _cdataTagOpen ) closeCDATA ( ) ; if ( _lexHandler != null ) { if ( _doctypeSystem != null ) _lexHandler . startDTD ( elementName , _doctypePublic , _doctypeSystem ) ; _lexHandler = null ; } _depth ++ ; _elementName = elementName ; _attributes . clear ( ) ; _startTagOpen = true ; _qnameStack . push ( elementName ) ; if ( ( _cdata != null ) && ( _cdata . get ( elementName ) != null ) ) _cdataStack . push ( new Integer ( _depth ) ) ; return ; case HTML : if ( _startTagOpen ) closeStartTag ( ) ; if ( _lexHandler != null ) { if ( ( _doctypeSystem != null ) || ( _doctypePublic != null ) ) _lexHandler . startDTD ( elementName , _doctypePublic , _doctypeSystem ) ; _lexHandler = null ; } _depth ++ ; _elementName = elementName ; _attributes . clear ( ) ; _startTagOpen = true ; _qnameStack . push ( elementName ) ; if ( elementName . toLowerCase ( ) . equals ( "head" ) ) _headTagOpen = true ; return ; case TEXT : return ; } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } private void escapeCharacters ( char [ ] ch , int off , int len ) throws SAXException { int limit = off + len ; int offset = off ; if ( limit > ch . length ) limit = ch . length ; ; for ( int i = off ; i < limit ; i ++ ) { char current = ch [ i ] ; switch ( current ) { case '&' : _saxHandler . characters ( ch , offset , i - offset ) ; _saxHandler . characters ( AMP , 0 , AMP_length ) ; offset = i + 1 ; break ; case '<' : _saxHandler . characters ( ch , offset , i - offset ) ; _saxHandler . characters ( LT , 0 , LT_length ) ; offset = i + 1 ; break ; case '>' : _saxHandler . characters ( ch , offset , i - offset ) ; _saxHandler . characters ( GT , 0 , GT_length ) ; offset = i + 1 ; break ; case ' ' : _saxHandler . characters ( ch , offset , i - offset ) ; _saxHandler . characters ( NBSP , 0 , NBSP_length ) ; offset = i + 1 ; break ; default : if ( ( current >= '' && current < ' ' ) || ( _is8859Encoded && ( current > 'ÿ' ) ) ) { StringBuffer buf = new StringBuffer ( CHAR_ESC_START ) ; buf . append ( Integer . toString ( ( int ) ch [ i ] ) ) ; buf . append ( ';' ) ; final String esc = buf . toString ( ) ; final char [ ] chars = esc . toCharArray ( ) ; final int strlen = esc . length ( ) ; _saxHandler . characters ( ch , offset , i - offset ) ; _saxHandler . characters ( chars , 0 , strlen ) ; offset = i + 1 ; } } } if ( offset < limit ) _saxHandler . characters ( ch , offset , limit - offset ) ; } private void escapeCDATA ( char [ ] ch , int off , int len ) throws SAXException { int limit = off + len ; int offset = off ; if ( limit > ch . length ) limit = ch . length ; ; for ( int i = off ; i < limit ; i ++ ) { if ( ch [ i ] > 'ÿ' ) { StringBuffer buf = new StringBuffer ( CDATA_ESC_START ) ; buf . append ( Integer . toString ( ( int ) ch [ i ] ) ) ; buf . append ( CDATA_ESC_END ) ; final String esc = buf . toString ( ) ; final char [ ] chars = esc . toCharArray ( ) ; final int strlen = esc . length ( ) ; _saxHandler . characters ( ch , offset , i - offset ) ; _saxHandler . characters ( chars , 0 , strlen ) ; offset = i + 1 ; } } if ( offset < limit ) _saxHandler . characters ( ch , offset , limit - offset ) ; } private String escapeString ( String value ) { int i ; char [ ] ch = value . toCharArray ( ) ; int limit = ch . length ; int offset = 0 ; StringBuffer buf = new StringBuffer ( ) ; for ( i = 0 ; i < limit ; i ++ ) { switch ( ch [ i ] ) { case '&' : buf . append ( ch , offset , i - offset ) ; buf . append ( AMP ) ; offset = i + 1 ; break ; case '"' : buf . append ( ch , offset , i - offset ) ; buf . append ( QUOTE ) ; offset = i + 1 ; break ; case '<' : buf . append ( ch , offset , i - offset ) ; buf . append ( LT ) ; offset = i + 1 ; break ; case '>' : buf . append ( ch , offset , i - offset ) ; buf . append ( GT ) ; offset = i + 1 ; break ; case '\n' : buf . append ( ch , offset , i - offset ) ; buf . append ( CRLF ) ; offset = i + 1 ; break ; } } if ( offset < limit ) { buf . append ( ch , offset , limit - offset ) ; } return ( buf . toString ( ) ) ; } private String makeHHString ( int i ) { String s = Integer . toHexString ( i ) . toUpperCase ( ) ; if ( s . length ( ) == 1 ) { s = "0" + s ; } return s ; } private String escapeAttr ( String base ) { final int len = base . length ( ) - 1 ; final String str = "&quot;" ; int pos ; char [ ] ch = base . toCharArray ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < base . length ( ) ; i ++ ) { if ( ch [ i ] <= 0x20 ) { buf . append ( '%' ) ; buf . append ( makeHHString ( ch [ i ] ) ) ; } else if ( ch [ i ] > '' ) { int high = ( ch [ i ] > > 6 ) | 0xC0 ; int low = ( ch [ i ] & 0x3F ) | 0x80 ; buf . append ( '%' ) ; buf . append ( makeHHString ( high ) ) ; buf . append ( '%' ) ; buf . append ( makeHHString ( low ) ) ; } else { switch ( ch [ i ] ) { case '' : case '"' : case '{' : case '}' : case '|' : case '\\' : case '\t' : case '^' : case '~' : case '[' : case ']' : case '`' : buf . append ( '%' ) ; buf . append ( Integer . toHexString ( ( int ) ch [ i ] ) ) ; break ; case '&' : buf . append ( "&" ) ; break ; default : buf . append ( ch [ i ] ) ; break ; } } } base = buf . toString ( ) ; while ( ( pos = base . indexOf ( '"' ) ) > - 1 ) { if ( pos == 0 ) { final String after = base . substring ( 1 ) ; base = str + after ; } else if ( pos == len ) { final String before = base . substring ( 0 , pos ) ; base = before + str ; } else { final String before = base . substring ( 0 , pos ) ; final String after = base . substring ( pos + 1 ) ; base = before + str + after ; } } return base ; } private String quickAndDirtyUrlEncode ( String base ) { final String pst20 = "%20" ; final int len = base . length ( ) - 1 ; int pos ; while ( ( pos = base . indexOf ( ' ' ) ) > - 1 ) { if ( pos == 0 ) { final String after = base . substring ( 1 ) ; base = pst20 + after ; } else if ( pos == len ) { final String before = base . substring ( 0 , pos ) ; base = before + pst20 ; } else { final String before = base . substring ( 0 , pos ) ; final String after = base . substring ( pos + 1 ) ; base = before + pst20 + after ; } } return base ; } private String getNamespaceURI ( String qname , boolean isElement ) throws TransletException { String uri = EMPTYSTRING ; int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col > 0 ) ? qname . substring ( 0 , col ) : EMPTYSTRING ; if ( prefix != EMPTYSTRING || isElement ) { uri = lookupNamespace ( prefix ) ; if ( uri == null && ! prefix . equals ( XMLNS_PREFIX ) ) { BasisLibrary . runTimeError ( BasisLibrary . NAMESPACE_PREFIX_ERR , qname . substring ( 0 , col ) ) ; } } return uri ; } private static String getLocalName ( String qname ) throws TransletException { final int col = qname . lastIndexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( col + 1 ) : null ; } private static String patchQName ( String qname ) throws TransletException { final int lastColon = qname . lastIndexOf ( ':' ) ; if ( lastColon > 0 ) { final int firstColon = qname . indexOf ( ':' ) ; if ( firstColon != lastColon ) { return qname . substring ( 0 , firstColon ) + qname . substring ( lastColon ) ; } } return qname ; } public void attribute ( String name , final String value ) throws TransletException { if ( _outputType == TEXT ) return ; final String patchedName = patchQName ( name ) ; final String localName = getLocalName ( patchedName ) ; final String uri = getNamespaceURI ( patchedName , false ) ; final int index = ( localName == null ) ? _attributes . getIndex ( name ) : _attributes . getIndex ( uri , localName ) ; switch ( _outputType ) { case XML : if ( ! _startTagOpen ) { BasisLibrary . runTimeError ( BasisLibrary . STRAY_ATTRIBUTE_ERR , patchedName ) ; } if ( name . startsWith ( XMLNS_PREFIX ) ) { namespace ( name . length ( ) > 6 ? name . substring ( 6 ) : EMPTYSTRING , value ) ; } else { if ( index >= 0 ) { _attributes . setAttribute ( index , uri , localName , patchedName , "CDATA" , escapeString ( value ) ) ; } else { _attributes . addAttribute ( uri , localName , patchedName , "CDATA" , escapeString ( value ) ) ; } } break ; case HTML : if ( ! _startTagOpen ) { BasisLibrary . runTimeError ( BasisLibrary . STRAY_ATTRIBUTE_ERR , name ) ; } final String tmp = name . toLowerCase ( ) ; if ( tmp . equals ( HREF_STR ) || tmp . equals ( SRC_STR ) || tmp . equals ( CITE_STR ) ) { if ( index >= 0 ) { _attributes . setAttribute ( index , EMPTYSTRING , EMPTYSTRING , name , "CDATA" , quickAndDirtyUrlEncode ( escapeAttr ( value ) ) ) ; } else { _attributes . addAttribute ( EMPTYSTRING , EMPTYSTRING , name , "CDATA" , quickAndDirtyUrlEncode ( escapeAttr ( value ) ) ) ; } } else { if ( index >= 0 ) { _attributes . setAttribute ( index , EMPTYSTRING , EMPTYSTRING , name , "CDATA" , escapeNonURLAttr ( value ) ) ; } else { _attributes . addAttribute ( EMPTYSTRING , EMPTYSTRING , name , "CDATA" , escapeNonURLAttr ( value ) ) ; } } break ; } } private String escapeNonURLAttr ( String base ) { final int len = base . length ( ) - 1 ; char [ ] ch = base . toCharArray ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < base . length ( ) ; i ++ ) { if ( ch [ i ] > '' ) { buf . append ( CHAR_ESC_START ) ; buf . append ( Integer . toString ( ( int ) ch [ i ] ) ) ; buf . append ( ';' ) ; } else { buf . append ( ch [ i ] ) ; } } base = buf . toString ( ) ; return base ; } public void endElement ( String elementName ) throws TransletException { try { switch ( _outputType ) { case TEXT : return ; case XML : if ( _startTagOpen ) closeStartTag ( ) ; if ( _cdataTagOpen ) closeCDATA ( ) ; final String qname = ( String ) _qnameStack . pop ( ) ; _saxHandler . endElement ( getNamespaceURI ( qname , true ) , getLocalName ( qname ) , qname ) ; popNamespaces ( ) ; if ( ( ( Integer ) _cdataStack . peek ( ) ) . intValue ( ) == _depth ) _cdataStack . pop ( ) ; _depth -- ; return ; case HTML : if ( _startTagOpen ) closeStartTag ( ) ; _saxHandler . endElement ( EMPTYSTRING , EMPTYSTRING , ( String ) ( _qnameStack . pop ( ) ) ) ; popNamespaces ( ) ; _depth -- ; return ; } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void comment ( String comment ) throws TransletException { try { if ( _startTagOpen ) closeStartTag ( ) ; if ( _cdataTagOpen ) closeCDATA ( ) ; if ( _outputType == UNKNOWN ) setTypeInternal ( XML ) ; _saxHandler . characters ( BEGCOMM , 0 , BEGCOMM_length ) ; characters ( comment ) ; _saxHandler . characters ( ENDCOMM , 0 , ENDCOMM_length ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void processingInstruction ( String target , String data ) throws TransletException { try { if ( _startTagOpen ) closeStartTag ( ) ; if ( _cdataTagOpen ) closeCDATA ( ) ; if ( ( _lexHandler != null ) && ( _outputType == HTML ) ) { if ( ( _doctypeSystem != null ) || ( _doctypePublic != null ) ) _lexHandler . startDTD ( "HTML" , _doctypePublic , _doctypeSystem ) ; _lexHandler = null ; } _saxHandler . processingInstruction ( target , data ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } private void initNamespaces ( ) { _namespaces = new Hashtable ( ) ; _nodeStack = new Stack ( ) ; _prefixStack = new Stack ( ) ; Stack stack ; _namespaces . put ( EMPTYSTRING , stack = new Stack ( ) ) ; stack . push ( EMPTYSTRING ) ; _prefixStack . push ( EMPTYSTRING ) ; _namespaces . put ( XML_PREFIX , stack = new Stack ( ) ) ; stack . push ( "http://www.w3.org/XML/1998/namespace" ) ; _prefixStack . push ( XML_PREFIX ) ; _nodeStack . push ( new Integer ( - 1 ) ) ; _depth = 0 ; } private void pushNamespace ( String prefix , String uri ) throws SAXException { if ( prefix . equals ( XML_PREFIX ) ) return ; Stack stack ; if ( ( stack = ( Stack ) _namespaces . get ( prefix ) ) == null ) { stack = new Stack ( ) ; _namespaces . put ( prefix , stack ) ; } if ( ! stack . empty ( ) && uri . equals ( stack . peek ( ) ) ) return ; stack . push ( uri ) ; _prefixStack . push ( prefix ) ; _nodeStack . push ( new Integer ( _depth ) ) ; _saxHandler . startPrefixMapping ( prefix , escapeString ( uri ) ) ; } private void popNamespace ( String prefix ) throws SAXException { if ( prefix . equals ( XML_PREFIX ) ) return ; Stack stack ; if ( ( stack = ( Stack ) _namespaces . get ( prefix ) ) != null ) { stack . pop ( ) ; _saxHandler . endPrefixMapping ( prefix ) ; } } private void popNamespaces ( ) throws TransletException { try { while ( true ) { if ( _nodeStack . isEmpty ( ) ) return ; Integer i = ( Integer ) ( _nodeStack . peek ( ) ) ; if ( i . intValue ( ) != _depth ) return ; _nodeStack . pop ( ) ; popNamespace ( ( String ) _prefixStack . pop ( ) ) ; } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } private String lookupNamespace ( String prefix ) { final Stack stack = ( Stack ) _namespaces . get ( prefix ) ; return stack != null && ! stack . isEmpty ( ) ? ( String ) stack . peek ( ) : null ; } public void namespace ( final String prefix , final String uri ) throws TransletException { try { if ( _startTagOpen ) pushNamespace ( prefix , uri ) ; else { if ( ( prefix == EMPTYSTRING ) && ( uri == EMPTYSTRING ) ) return ; BasisLibrary . runTimeError ( BasisLibrary . STRAY_NAMESPACE_ERR , prefix , uri ) ; } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void setType ( int type ) { try { _outputType = type ; if ( ( _outputType == HTML ) || ( _outputType == XML ) ) _escapeChars = true ; if ( _encoding == null ) _encoding = "UTF-8" ; if ( _saxHandler instanceof DefaultSAXOutputHandler ) ( ( DefaultSAXOutputHandler ) _saxHandler ) . setOutputType ( type ) ; } catch ( SAXException e ) { } } public void setIndent ( boolean indent ) { if ( _saxHandler instanceof DefaultSAXOutputHandler ) { ( ( DefaultSAXOutputHandler ) _saxHandler ) . setIndent ( indent ) ; } } public void omitHeader ( boolean value ) { if ( _saxHandler instanceof DefaultSAXOutputHandler ) { ( ( DefaultSAXOutputHandler ) _saxHandler ) . omitHeader ( value ) ; } } public void setVersion ( String version ) { if ( _saxHandler instanceof DefaultSAXOutputHandler ) { ( ( DefaultSAXOutputHandler ) _saxHandler ) . setVersion ( version ) ; } } public void setStandalone ( String standalone ) { if ( _saxHandler instanceof DefaultSAXOutputHandler ) { ( ( DefaultSAXOutputHandler ) _saxHandler ) . setStandalone ( standalone ) ; } } public void setDoctype ( String system , String pub ) { _doctypeSystem = system ; _doctypePublic = pub ; } public void setMediaType ( String mediaType ) { _mediaType = mediaType ; } public void setCdataElements ( Hashtable elements ) { _cdata = elements ; } } 	0	['48', '1', '0', '8', '106', '388', '1', '7', '26', '0.895702962', '2321', '0.901960784', '2', '0', '0.236702128', '0', '0', '46.29166667', '21', '1.8958', '0']
package org . apache . xalan . xsltc . runtime . output ; import java . io . Writer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import org . apache . xalan . xsltc . TransletException ; abstract class StreamOutput extends OutputBase { protected static final String AMP = "&amp;" ; protected static final String LT = "&lt;" ; protected static final String GT = "&gt;" ; protected static final String CRLF = "&#xA;" ; protected static final String APOS = "&apos;" ; protected static final String QUOT = "&quot;" ; protected static final String NBSP = "&nbsp;" ; protected static final String CHAR_ESC_START = "&#" ; protected static final char [ ] INDENT = "                    " . toCharArray ( ) ; protected static final int MAX_INDENT_LEVEL = ( INDENT . length > > 1 ) ; protected static final int MAX_INDENT = INDENT . length ; protected static final int BUFFER_SIZE = 32 * 1024 ; protected static final int OUTPUT_BUFFER_SIZE = 4 * 1024 ; protected Writer _writer ; protected StringBuffer _buffer ; protected boolean _is8859Encoded = false ; protected boolean _indent = false ; protected boolean _omitHeader = false ; protected String _standalone = null ; protected String _version = "1.0" ; protected boolean _lineFeedNextStartTag = false ; protected boolean _linefeedNextEndTag = false ; protected boolean _indentNextEndTag = false ; protected int _indentLevel = 0 ; protected boolean _escaping = true ; protected String _encoding = "UTF-8" ; protected int _indentNumber = 2 ; protected Vector _attributes = new Vector ( ) ; static class Attribute { public String name , value ; Attribute ( String name , String value ) { this . name = name ; this . value = value ; } public int hashCode ( ) { return name . hashCode ( ) ; } public boolean equals ( Object obj ) { try { return name . equalsIgnoreCase ( ( ( Attribute ) obj ) . name ) ; } catch ( ClassCastException e ) { return false ; } } } protected StreamOutput ( StreamOutput output ) { _writer = output . _writer ; _encoding = output . _encoding ; _is8859Encoded = output . _is8859Encoded ; _buffer = output . _buffer ; _indentNumber = output . _indentNumber ; } protected StreamOutput ( Writer writer , String encoding ) { _writer = writer ; _encoding = encoding ; _is8859Encoded = encoding . equalsIgnoreCase ( "iso-8859-1" ) ; _buffer = new StringBuffer ( BUFFER_SIZE ) ; } protected StreamOutput ( OutputStream out , String encoding ) throws IOException { try { _writer = new OutputStreamWriter ( out , _encoding = encoding ) ; _is8859Encoded = encoding . equalsIgnoreCase ( "iso-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { _writer = new OutputStreamWriter ( out , _encoding = "utf-8" ) ; } _buffer = new StringBuffer ( BUFFER_SIZE ) ; } public void setIndentNumber ( int value ) { _indentNumber = value ; } public void setDoctype ( String system , String pub ) { _doctypeSystem = system ; _doctypePublic = pub ; } public void setIndent ( boolean indent ) { _indent = indent ; } public void omitHeader ( boolean value ) { _omitHeader = value ; } public void setStandalone ( String standalone ) { _standalone = standalone ; } public void setVersion ( String version ) { _version = version ; } protected void outputBuffer ( ) { try { int n = 0 ; final int length = _buffer . length ( ) ; final String output = _buffer . toString ( ) ; if ( length > OUTPUT_BUFFER_SIZE ) { do { _writer . write ( output , n , OUTPUT_BUFFER_SIZE ) ; n += OUTPUT_BUFFER_SIZE ; } while ( n + OUTPUT_BUFFER_SIZE < length ) ; } _writer . write ( output , n , length - n ) ; _writer . flush ( ) ; } catch ( IOException e ) { } } protected void appendDTD ( String name ) { _buffer . append ( "<!DOCTYPE " ) . append ( name ) ; if ( _doctypePublic == null ) { _buffer . append ( " SYSTEM" ) ; } else { _buffer . append ( " PUBLIC \"" ) . append ( _doctypePublic ) . append ( "\"" ) ; } if ( _doctypeSystem != null ) { _buffer . append ( " \"" ) . append ( _doctypeSystem ) . append ( "\">\n" ) ; } else { _buffer . append ( ">\n" ) ; } } protected void indent ( boolean linefeed ) { if ( linefeed ) { _buffer . append ( '\n' ) ; } _buffer . append ( INDENT , 0 , _indentLevel < MAX_INDENT_LEVEL ? _indentLevel * _indentNumber : MAX_INDENT ) ; } protected void escapeCharacters ( char [ ] ch , int off , int len ) { } protected void appendAttributes ( ) { if ( ! _attributes . isEmpty ( ) ) { int i = 0 ; final int length = _attributes . size ( ) ; do { final Attribute attr = ( Attribute ) _attributes . elementAt ( i ) ; _buffer . append ( ' ' ) . append ( attr . name ) . append ( "=\"" ) . append ( attr . value ) . append ( '"' ) ; } while ( ++ i < length ) ; _attributes . clear ( ) ; } } protected void closeStartTag ( ) throws TransletException { appendAttributes ( ) ; _buffer . append ( '>' ) ; _startTagOpen = false ; } protected void appendComment ( String comment ) throws TransletException { boolean lastIsDash = false ; final int n = comment . length ( ) ; _buffer . append ( "<!--" ) ; for ( int i = 0 ; i < n ; i ++ ) { final char ch = comment . charAt ( i ) ; final boolean isDash = ( ch == '-' ) ; if ( lastIsDash && isDash ) { _buffer . append ( " -" ) ; } else { _buffer . append ( ch ) ; } lastIsDash = isDash ; } if ( lastIsDash ) { _buffer . append ( ' ' ) ; } _buffer . append ( "-->" ) ; } } 	1	['17', '2', '4', '8', '36', '30', '5', '3', '6', '0.912946429', '505', '1', '0', '0.704545455', '0.25', '0', '0', '27.05882353', '3', '1.2353', '1']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . Constants ; import org . apache . xpath . XPath ; import org . apache . xalan . templates . StylesheetRoot ; import javax . xml . transform . TransformerException ; import org . xml . sax . Attributes ; public class ProcessorUnknown extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { } } 	0	['3', '5', '0', '3', '4', '3', '1', '2', '3', '2', '8', '0', '0', '0.990697674', '0.666666667', '1', '2', '1.666666667', '1', '0.6667', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; public class DTMNodeList implements org . w3c . dom . NodeList { private DTMIterator dtm_iter ; private boolean valid = true ; private int m_firstChild ; private DTM m_parentDTM ; public DTMNodeList ( DTMIterator dtmIterator ) { int pos = dtmIterator . getCurrentPos ( ) ; try { dtm_iter = ( DTMIterator ) dtmIterator . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { } dtm_iter . setShouldCacheNodes ( true ) ; dtm_iter . runTo ( - 1 ) ; dtm_iter . setCurrentPos ( pos ) ; } public DTMNodeList ( DTM parentDTM , int parentHandle ) { dtm_iter = null ; m_parentDTM = parentDTM ; m_firstChild = parentDTM . getFirstChild ( parentHandle ) ; } DTMIterator getDTMIterator ( ) { return dtm_iter ; } public Node item ( int index ) { if ( dtm_iter != null ) { int handle = dtm_iter . item ( index ) ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } else { int handle = m_firstChild ; while ( -- index >= 0 && handle != DTM . NULL ) handle = m_parentDTM . getNextSibling ( handle ) ; return m_parentDTM . getNode ( handle ) ; } } public int getLength ( ) { if ( dtm_iter != null ) { return dtm_iter . getLength ( ) ; } else { int count = 0 ; for ( int handle = m_firstChild ; handle != DTM . NULL ; handle = m_parentDTM . getNextSibling ( handle ) ) ++ count ; return count ; } } } 	1	['5', '1', '0', '8', '17', '0', '6', '2', '4', '0.4375', '115', '1', '2', '0', '0.45', '0', '0', '21.2', '4', '1.6', '2']
package org . apache . xml . dtm . ref ; import org . w3c . dom . * ; import org . apache . xml . dtm . * ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . res . XSLMessages ; final class ChunkedIntArray { final int slotsize = 4 ; static final int lowbits = 10 ; static final int chunkalloc = 1 << lowbits ; static final int lowmask = chunkalloc - 1 ; ChunksVector chunks = new ChunksVector ( ) ; final int fastArray [ ] = new int [ chunkalloc ] ; int lastUsed = 0 ; ChunkedIntArray ( int slotsize ) { if ( this . slotsize < slotsize ) throw new ArrayIndexOutOfBoundsException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CHUNKEDINTARRAY_NOT_SUPPORTED , new Object [ ] { Integer . toString ( slotsize ) } ) ) ; else if ( this . slotsize > slotsize ) System . out . println ( "*****WARNING: ChunkedIntArray(" + slotsize + ") wasting " + ( this . slotsize - slotsize ) + " words per slot" ) ; chunks . addElement ( fastArray ) ; } int appendSlot ( int w0 , int w1 , int w2 , int w3 ) { { final int slotsize = 4 ; int newoffset = ( lastUsed + 1 ) * slotsize ; int chunkpos = newoffset > > lowbits ; int slotpos = ( newoffset & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + 1 ] = w1 ; chunk [ slotpos + 2 ] = w2 ; chunk [ slotpos + 3 ] = w3 ; return ++ lastUsed ; } } int readEntry ( int position , int offset ) throws ArrayIndexOutOfBoundsException { { if ( offset >= slotsize ) throw new ArrayIndexOutOfBoundsException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OFFSET_BIGGER_THAN_SLOT , null ) ) ; position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = position & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; return chunk [ slotpos + offset ] ; } } int specialFind ( int startPos , int position ) { int ancestor = startPos ; while ( ancestor > 0 ) { ancestor *= slotsize ; int chunkpos = ancestor > > lowbits ; int slotpos = ancestor & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; ancestor = chunk [ slotpos + 1 ] ; if ( ancestor == position ) break ; } if ( ancestor <= 0 ) { return position ; } return - 1 ; } int slotsUsed ( ) { return lastUsed ; } void discardLast ( ) { -- lastUsed ; } void writeEntry ( int position , int offset , int value ) throws ArrayIndexOutOfBoundsException { { if ( offset >= slotsize ) throw new ArrayIndexOutOfBoundsException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OFFSET_BIGGER_THAN_SLOT , null ) ) ; position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = position & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos + offset ] = value ; } } void writeSlot ( int position , int w0 , int w1 , int w2 , int w3 ) { position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = ( position & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + 1 ] = w1 ; chunk [ slotpos + 2 ] = w2 ; chunk [ slotpos + 3 ] = w3 ; } void readSlot ( int position , int [ ] buffer ) { { position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = ( position & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; System . arraycopy ( chunk , slotpos , buffer , 0 , slotsize ) ; } } class ChunksVector { final int BLOCKSIZE = 64 ; int [ ] m_map [ ] = new int [ BLOCKSIZE ] [ ] ; int m_mapSize = BLOCKSIZE ; int pos = 0 ; ChunksVector ( ) { } final int size ( ) { return pos ; } void addElement ( int [ ] value ) { if ( pos >= m_mapSize ) { int orgMapSize = m_mapSize ; while ( pos >= m_mapSize ) m_mapSize += BLOCKSIZE ; int [ ] newMap [ ] = new int [ m_mapSize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , orgMapSize ) ; m_map = newMap ; } m_map [ pos ] = value ; pos ++ ; } final int [ ] elementAt ( int pos ) { return m_map [ pos ] ; } } } 	0	['9', '1', '0', '3', '24', '0', '2', '2', '0', '0.892857143', '353', '0', '1', '0', '0.62962963', '0', '0', '37.44444444', '3', '1.4444', '0']
package org . apache . xalan . xsltc . trax ; import java . io . Reader ; import java . io . InputStream ; import javax . xml . transform . * ; import javax . xml . transform . sax . * ; import javax . xml . transform . dom . * ; import javax . xml . transform . stream . * ; import org . w3c . dom . Document ; import org . xml . sax . InputSource ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . SourceLoader ; public final class Util { public static String baseName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . baseName ( name ) ; } public static InputSource getInputSource ( XSLTC xsltc , Source source ) throws TransformerConfigurationException { InputSource input = null ; String systemId = source . getSystemId ( ) ; if ( systemId == null ) { systemId = "" ; } try { if ( source instanceof SAXSource ) { final SAXSource sax = ( SAXSource ) source ; input = sax . getInputSource ( ) ; xsltc . setXMLReader ( sax . getXMLReader ( ) ) ; } else if ( source instanceof DOMSource ) { final DOMSource domsrc = ( DOMSource ) source ; final Document dom = ( Document ) domsrc . getNode ( ) ; final DOM2SAX dom2sax = new DOM2SAX ( dom ) ; xsltc . setXMLReader ( dom2sax ) ; input = SAXSource . sourceToInputSource ( source ) ; if ( input == null ) { input = new InputSource ( domsrc . getSystemId ( ) ) ; } } else if ( source instanceof StreamSource ) { final StreamSource stream = ( StreamSource ) source ; final InputStream istream = stream . getInputStream ( ) ; final Reader reader = stream . getReader ( ) ; if ( istream != null ) { input = new InputSource ( istream ) ; } else if ( reader != null ) { input = new InputSource ( reader ) ; } else { input = new InputSource ( systemId ) ; } } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } input . setSystemId ( systemId ) ; } catch ( NullPointerException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_SOURCE_ERR , "TransformerFactory.newTemplates()" ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( SecurityException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . FILE_ACCESS_ERR , systemId ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } finally { return input ; } } } 	1	['3', '1', '0', '6', '23', '3', '2', '4', '3', '2', '141', '0', '0', '0', '0.333333333', '0', '0', '46', '1', '0.6667', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class BinOpExpr extends Expression { public static final int PLUS = 0 ; public static final int MINUS = 1 ; public static final int TIMES = 2 ; public static final int DIV = 3 ; public static final int MOD = 4 ; private static final String [ ] Ops = { "+" , "-" , "*" , "/" , "%" } ; private int _op ; private Expression _left , _right ; public BinOpExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public boolean hasPositionCall ( ) { if ( _left . hasPositionCall ( ) ) return true ; if ( _right . hasPositionCall ( ) ) return true ; return false ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tleft = _left . typeCheck ( stable ) ; final Type tright = _right . typeCheck ( stable ) ; final MethodType ptype = lookupPrimop ( stable , Ops [ _op ] , new MethodType ( Type . Void , tleft , tright ) ) ; if ( ptype != null ) { final Type arg1 = ( Type ) ptype . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) { _left = new CastExpr ( _left , arg1 ) ; } final Type arg2 = ( Type ) ptype . argsType ( ) . elementAt ( 1 ) ; if ( ! arg2 . identicalTo ( tright ) ) { _right = new CastExpr ( _right , arg1 ) ; } return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; switch ( _op ) { case PLUS : il . append ( _type . ADD ( ) ) ; break ; case MINUS : il . append ( _type . SUB ( ) ) ; break ; case TIMES : il . append ( _type . MUL ( ) ) ; break ; case DIV : il . append ( _type . DIV ( ) ) ; break ; case MOD : il . append ( _type . REM ( ) ) ; break ; default : ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_BINARY_OP_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } public String toString ( ) { return Ops [ _op ] + '(' + _left + ", " + _right + ')' ; } } 	0	['7', '3', '0', '15', '36', '0', '0', '15', '6', '0.814814815', '242', '0.444444444', '2', '0.934210526', '0.285714286', '2', '8', '32.28571429', '3', '1.1429', '0']
package org . apache . xpath . axes ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; public class OneStepIterator extends ChildTestIterator { protected int m_axis = - 1 ; protected DTMAxisIterator m_iterator ; OneStepIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_axis = WalkerFactory . getAxisFromStep ( compiler , firstStepPos ) ; } public OneStepIterator ( DTMAxisIterator iterator , int axis ) throws javax . xml . transform . TransformerException { super ( null ) ; m_iterator = iterator ; m_axis = axis ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; if ( m_axis > - 1 ) m_iterator = m_cdtm . getAxisIterator ( m_axis ) ; m_iterator . setStartNode ( m_context ) ; } protected int getNextNode ( ) { return m_lastFetched = m_iterator . next ( ) ; } public Object clone ( ) throws CloneNotSupportedException { OneStepIterator clone = ( OneStepIterator ) super . clone ( ) ; if ( m_iterator != null ) { clone . m_iterator = m_iterator . cloneIterator ( ) ; } return clone ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { OneStepIterator clone = ( OneStepIterator ) super . cloneWithReset ( ) ; clone . m_iterator = m_iterator ; return clone ; } public boolean isReverseAxes ( ) { return m_iterator . isReverse ( ) ; } protected int getProximityPosition ( int predicateIndex ) { if ( ! isReverseAxes ( ) ) return super . getProximityPosition ( predicateIndex ) ; if ( predicateIndex < 0 ) return - 1 ; if ( m_proximityPositions [ predicateIndex ] <= 0 ) { XPathContext xctxt = getXPathContext ( ) ; try { OneStepIterator clone = ( OneStepIterator ) this . clone ( ) ; int root = getRoot ( ) ; xctxt . pushCurrentNode ( root ) ; clone . setRoot ( root , xctxt ) ; clone . m_predCount = predicateIndex ; int count = 1 ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } m_proximityPositions [ predicateIndex ] += count ; } catch ( CloneNotSupportedException cnse ) { } finally { xctxt . popCurrentNode ( ) ; } } return m_proximityPositions [ predicateIndex ] ; } protected void countProximityPosition ( int i ) { if ( ! isReverseAxes ( ) ) super . countProximityPosition ( i ) ; else if ( i < m_proximityPositions . length ) m_proximityPositions [ i ] -- ; } public void reset ( ) { super . reset ( ) ; if ( null != m_iterator ) m_iterator . reset ( ) ; } public int getAxis ( ) { return m_axis ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( OneStepIterator ) expr ) . m_axis ) return false ; return true ; } } 	1	['12', '7', '0', '16', '35', '6', '3', '14', '8', '0.409090909', '230', '1', '1', '0.93006993', '0.291666667', '4', '13', '18', '5', '1.6667', '2']
package org . apache . xalan . serialize ; import org . xml . sax . * ; import java . util . * ; import java . io . * ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . templates . OutputProperties ; import javax . xml . transform . OutputKeys ; public class SerializerToText extends SerializerToXML { public SerializerToText ( ) { super ( ) ; } public void setDocumentLocator ( Locator locator ) { } public void startDocument ( ) throws org . xml . sax . SAXException { } public void endDocument ( ) throws org . xml . sax . SAXException { flushWriter ( ) ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { } public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { } public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } this . flushWriter ( ) ; } public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } flushWriter ( ) ; } protected int writeUTF16Surrogate ( char c , char ch [ ] , int i , int end ) throws IOException , org . xml . sax . SAXException { int surrogateValue = getURF16SurrogateValue ( c , ch , i , end ) ; i ++ ; m_writer . write ( surrogateValue ) ; return i ; } void writeNormalizedChars ( char ch [ ] , int start , int length , boolean isCData ) throws IOException , org . xml . sax . SAXException { int end = start + length ; for ( int i = start ; i < end ; i ++ ) { char c = ch [ i ] ; if ( CharInfo . S_LINEFEED == c ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else if ( isCData && ( c > m_maxCharacter ) ) { if ( i != 0 ) m_writer . write ( "]]>" ) ; if ( isUTF16Surrogate ( c ) ) { i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { m_writer . write ( c ) ; } if ( ( i != 0 ) && ( i < ( end - 1 ) ) ) m_writer . write ( "<![CDATA[" ) ; } else if ( isCData && ( ( i < ( end - 2 ) ) && ( ']' == c ) && ( ']' == ch [ i + 1 ] ) && ( '>' == ch [ i + 2 ] ) ) ) { m_writer . write ( "]]]]><![CDATA[>" ) ; i += 2 ; } else { if ( c <= m_maxCharacter ) { m_writer . write ( c ) ; } else if ( isUTF16Surrogate ( c ) ) { i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { m_writer . write ( c ) ; } } } } public void cdata ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } flushWriter ( ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } flushWriter ( ) ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { } public void comment ( String data ) throws org . xml . sax . SAXException { } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { } public void entityReference ( String name ) throws org . xml . sax . SAXException { } } 	0	['16', '2', '0', '4', '24', '120', '2', '2', '14', '2', '229', '0', '0', '0.821428571', '0.3046875', '1', '7', '13.3125', '1', '0.9375', '0']
package org . apache . xalan . xsltc . runtime ; import java . util . Vector ; import java . util . Enumeration ; import java . util . ResourceBundle ; public class ErrorMessages extends ResourceBundle { private static final String errorMessages [ ] = { "Run-time internal error in ''{0}''" , "Run-time error when executing <xsl:copy>." , "Invalid conversion from ''{0}'' to ''{1}''." , "External function ''{0}'' not supported by XSLTC." , "Unknown argument type in equality expression." , "Invalid argument type ''{0}'' in call to ''{1}''" , "Attempting to format number ''{0}'' using pattern ''{1}''." , "Cannot clone iterator ''{0}''." , "Iterator for axis ''{0}'' not supported." , "Iterator for typed axis ''{0}'' not supported." , "Attribute ''{0}'' outside of element." , "Namespace declaration ''{0}''=''{1}'' outside of element." , "Namespace for prefix ''{0}'' has not been declared." , "DOMAdapter created using wrong type of source DOM." } ; private static Vector _keys ; static { _keys = new Vector ( ) ; _keys . addElement ( BasisLibrary . ERROR_MESSAGES_KEY ) ; } public Enumeration getKeys ( ) { return _keys . elements ( ) ; } public Object handleGetObject ( String key ) { if ( key == null ) return null ; if ( key . equals ( BasisLibrary . ERROR_MESSAGES_KEY ) ) return errorMessages ; return ( null ) ; } } 	1	['4', '2', '1', '1', '9', '2', '1', '0', '3', '0.666666667', '91', '1', '0', '0.942857143', '0.666666667', '2', '3', '21.25', '3', '1', '1']
package org . apache . xml . utils ; public interface PrefixResolver { String getNamespaceForPrefix ( String prefix ) ; String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) ; public String getBaseIdentifier ( ) ; public boolean handlesNullPrefixes ( ) ; } 	0	['4', '1', '0', '67', '4', '6', '67', '0', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class GenerateIdCall extends FunctionCall { public GenerateIdCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( argumentCount ( ) == 0 ) { il . append ( new ILOAD ( methodGen . getLocalIndex ( "current" ) ) ) ; } else { argument ( ) . translate ( classGen , methodGen ) ; } final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "generate_idF" , GET_NODE_NAME_SIG ) ) ) ; } } 	1	['2', '4', '0', '13', '13', '1', '0', '13', '2', '2', '43', '0', '0', '0.989690722', '0.6', '2', '4', '20.5', '2', '1', '1']
package org . apache . xml . utils ; public abstract class XMLStringFactory { public abstract XMLString newstr ( String string ) ; public abstract XMLString newstr ( FastStringBuffer string , int start , int length ) ; public abstract XMLString newstr ( char [ ] string , int start , int length ) ; public abstract XMLString emptystr ( ) ; } 	0	['5', '1', '1', '17', '6', '10', '15', '2', '5', '2', '8', '0', '0', '0', '0.4', '0', '0', '0.6', '1', '0.8', '0']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . DOMHelper ; import org . apache . xpath . XPathContext ; import org . apache . xpath . Expression ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . res . XPATHErrorResources ; public class XRTreeFragSelectWrapper extends XRTreeFrag implements Cloneable { XObject m_selected ; public XRTreeFragSelectWrapper ( Expression expr ) { super ( expr ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { ( ( Expression ) m_obj ) . fixupVariables ( vars , globalsSize ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { try { m_selected = ( ( Expression ) m_obj ) . execute ( xctxt ) ; m_selected . allowDetachToRelease ( m_allowRelease ) ; XRTreeFragSelectWrapper xrtf = ( XRTreeFragSelectWrapper ) this . clone ( ) ; return xrtf ; } catch ( CloneNotSupportedException cnse ) { throw new javax . xml . transform . TransformerException ( cnse ) ; } } public void detach ( ) { if ( m_allowRelease ) { m_selected . detach ( ) ; m_selected = null ; } super . detach ( ) ; } public double num ( ) throws javax . xml . transform . TransformerException { return m_selected . num ( ) ; } public XMLString xstr ( ) { return m_selected . xstr ( ) ; } public String str ( ) { return m_selected . str ( ) ; } public int getType ( ) { return CLASS_STRING ; } public int rtf ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , null ) ) ; } public DTMIterator asNodeIterator ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , null ) ) ; } } 	1	['10', '4', '0', '8', '23', '25', '1', '7', '10', '0.555555556', '86', '0', '1', '0.905263158', '0.28', '3', '22', '7.5', '2', '1', '2']
package org . apache . xalan . templates ; import org . apache . xml . dtm . DTM ; import org . xml . sax . * ; import org . apache . xpath . * ; import org . apache . xml . utils . QName ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import javax . xml . transform . TransformerException ; public class ElemComment extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_COMMENT ; } public String getNodeName ( ) { return Constants . ELEMNAME_COMMENT_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { String data = transformer . transformToString ( this ) ; transformer . getResultTreeHandler ( ) . comment ( data ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } } 	0	['5', '3', '0', '4', '17', '10', '0', '4', '5', '2', '74', '0', '0', '0.98', '0.466666667', '2', '5', '13.8', '16', '3.8', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemElement ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemFallback ; import org . apache . xalan . templates . ElemVariable ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemValueOf ; import org . apache . xalan . templates . Constants ; import org . apache . xpath . XPath ; import org . apache . xalan . templates . StylesheetRoot ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerConfigurationException ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . xalan . res . XSLTErrorResources ; public class ProcessorExsltFunction extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws SAXException { String msg = "" ; if ( ! ( handler . getElemTemplateElement ( ) instanceof StylesheetRoot ) ) { msg = "func:function element must be top level." ; handler . error ( msg , new SAXException ( msg ) ) ; } super . startElement ( handler , uri , localName , rawName , attributes ) ; String val = attributes . getValue ( "name" ) ; int indexOfColon = val . indexOf ( ":" ) ; if ( indexOfColon > 0 ) { String prefix = val . substring ( 0 , indexOfColon ) ; String localVal = val . substring ( indexOfColon + 1 ) ; String ns = handler . getNamespaceSupport ( ) . getURI ( prefix ) ; } else { msg = "func:function name must have namespace" ; handler . error ( msg , new SAXException ( msg ) ) ; } } protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws SAXException { super . appendAndPush ( handler , elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; handler . getStylesheet ( ) . setTemplate ( ( ElemTemplate ) elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws SAXException { ElemTemplateElement function = handler . getElemTemplateElement ( ) ; SourceLocator locator = handler . getLocator ( ) ; validate ( function , handler ) ; super . endElement ( handler , uri , localName , rawName ) ; } public void validate ( ElemTemplateElement elem , StylesheetHandler handler ) throws SAXException { String msg = "" ; while ( elem != null ) { if ( elem instanceof ElemExsltFuncResult && elem . getNextSiblingElem ( ) != null && ! ( elem . getNextSiblingElem ( ) instanceof ElemFallback ) ) { msg = "func:result has an illegal following sibling (only xsl:fallback allowed)" ; handler . error ( msg , new SAXException ( msg ) ) ; } if ( elem instanceof ElemValueOf || ( elem instanceof ElemLiteralResult || elem instanceof ElemElement ) && ! ( ancestorIsOk ( elem ) ) ) { msg = "misplaced literal result in a func:function container." ; handler . error ( msg , new SAXException ( msg ) ) ; } ElemTemplateElement nextElem = elem . getFirstChildElem ( ) ; while ( nextElem == null ) { nextElem = elem . getNextSiblingElem ( ) ; if ( nextElem == null ) elem = elem . getParentElem ( ) ; if ( elem == null || elem instanceof ElemExsltFunction ) return ; } elem = nextElem ; } } boolean ancestorIsOk ( ElemTemplateElement child ) { while ( child . getParentElem ( ) != null && ! ( child . getParentElem ( ) instanceof ElemExsltFunction ) ) { ElemTemplateElement parent = child . getParentElem ( ) ; if ( parent instanceof ElemExsltFuncResult || parent instanceof ElemVariable || parent instanceof ElemParam ) return true ; child = parent ; } return false ; } } 	1	['6', '5', '0', '16', '27', '15', '1', '15', '4', '2', '193', '0', '0', '0.97706422', '0.533333333', '2', '4', '31.16666667', '6', '1.6667', '2']
package org . apache . xpath . res ; import java . io . IOException ; import java . io . InputStream ; import java . text . DecimalFormat ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; public class XPATHErrorResources extends PropertyResourceBundle { public XPATHErrorResources ( ) throws java . io . IOException { super ( null ) ; } public XPATHErrorResources ( InputStream is ) throws java . io . IOException { super ( is ) ; } public static final String ERROR_SUFFIX = "ER" ; public static final String WARNING_SUFFIX = "WR" ; public static final int ERROR0000 = 0 ; public static final int ER_CURRENT_NOT_ALLOWED_IN_MATCH = 1 ; public static final int ER_CURRENT_TAKES_NO_ARGS = 2 ; public static final int ER_DOCUMENT_REPLACED = 3 ; public static final int ER_CONTEXT_HAS_NO_OWNERDOC = 4 ; public static final int ER_LOCALNAME_HAS_TOO_MANY_ARGS = 5 ; public static final int ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = 6 ; public static final int ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = 7 ; public static final int ER_NUMBER_HAS_TOO_MANY_ARGS = 8 ; public static final int ER_NAME_HAS_TOO_MANY_ARGS = 9 ; public static final int ER_STRING_HAS_TOO_MANY_ARGS = 10 ; public static final int ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = 11 ; public static final int ER_TRANSLATE_TAKES_3_ARGS = 12 ; public static final int ER_UNPARSEDENTITYURI_TAKES_1_ARG = 13 ; public static final int ER_NAMESPACEAXIS_NOT_IMPLEMENTED = 14 ; public static final int ER_UNKNOWN_AXIS = 15 ; public static final int ER_UNKNOWN_MATCH_OPERATION = 16 ; public static final int ER_INCORRECT_ARG_LENGTH = 17 ; public static final int ER_CANT_CONVERT_TO_NUMBER = 18 ; public static final int ER_CANT_CONVERT_TO_NODELIST = 19 ; public static final int ER_CANT_CONVERT_TO_MUTABLENODELIST = 20 ; public static final int ER_CANT_CONVERT_TO_TYPE = 21 ; public static final int ER_EXPECTED_MATCH_PATTERN = 22 ; public static final int ER_COULDNOT_GET_VAR_NAMED = 23 ; public static final int ER_UNKNOWN_OPCODE = 24 ; public static final int ER_EXTRA_ILLEGAL_TOKENS = 25 ; public static final int ER_EXPECTED_DOUBLE_QUOTE = 26 ; public static final int ER_EXPECTED_SINGLE_QUOTE = 27 ; public static final int ER_EMPTY_EXPRESSION = 28 ; public static final int ER_EXPECTED_BUT_FOUND = 29 ; public static final int ER_INCORRECT_PROGRAMMER_ASSERTION = 30 ; public static final int ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = 31 ; public static final int ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = 32 ; public static final int ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = 33 ; public static final int ER_PREDICATE_ILLEGAL_SYNTAX = 34 ; public static final int ER_ILLEGAL_AXIS_NAME = 35 ; public static final int ER_UNKNOWN_NODETYPE = 36 ; public static final int ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = 37 ; public static final int ER_COULDNOT_BE_FORMATTED_TO_NUMBER = 38 ; public static final int ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = 39 ; public static final int ER_DIDNOT_FIND_XPATH_SELECT_EXP = 40 ; public static final int ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = 41 ; public static final int ER_ERROR_OCCURED = 42 ; public static final int ER_ILLEGAL_VARIABLE_REFERENCE = 43 ; public static final int ER_AXES_NOT_ALLOWED = 44 ; public static final int ER_KEY_HAS_TOO_MANY_ARGS = 45 ; public static final int ER_COUNT_TAKES_1_ARG = 46 ; public static final int ER_COULDNOT_FIND_FUNCTION = 47 ; public static final int ER_UNSUPPORTED_ENCODING = 48 ; public static final int ER_PROBLEM_IN_DTM_NEXTSIBLING = 49 ; public static final int ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = 50 ; public static final int ER_SETDOMFACTORY_NOT_SUPPORTED = 51 ; public static final int ER_PREFIX_MUST_RESOLVE = 52 ; public static final int ER_PARSE_NOT_SUPPORTED = 53 ; public static final int ER_CREATEDOCUMENT_NOT_SUPPORTED = 54 ; public static final int ER_CHILD_HAS_NO_OWNER_DOCUMENT = 55 ; public static final int ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = 56 ; public static final int ER_SAX_API_NOT_HANDLED = 57 ; public static final int ER_IGNORABLE_WHITESPACE_NOT_HANDLED = 58 ; public static final int ER_DTM_CANNOT_HANDLE_NODES = 59 ; public static final int ER_XERCES_CANNOT_HANDLE_NODES = 60 ; public static final int ER_XERCES_PARSE_ERROR_DETAILS = 61 ; public static final int ER_XERCES_PARSE_ERROR = 62 ; public static final int ER_CANT_OUTPUT_TEXT_BEFORE_DOC = 63 ; public static final int ER_CANT_HAVE_MORE_THAN_ONE_ROOT = 64 ; public static final int ER_INVALID_UTF16_SURROGATE = 65 ; public static final int ER_OIERROR = 66 ; public static final int ER_CANNOT_CREATE_URL = 67 ; public static final int ER_XPATH_READOBJECT = 68 ; public static final int ER_FUNCTION_TOKEN_NOT_FOUND = 69 ; public static final int ER_ARG_LOCALNAME_NULL = 70 ; public static final int ER_CANNOT_DEAL_XPATH_TYPE = 71 ; public static final int ER_NODESET_NOT_MUTABLE = 72 ; public static final int ER_NODESETDTM_NOT_MUTABLE = 73 ; public static final int ER_VAR_NOT_RESOLVABLE = 74 ; public static final int ER_NULL_ERROR_HANDLER = 75 ; public static final int ER_PROG_ASSERT_UNKNOWN_OPCODE = 76 ; public static final int ER_ZERO_OR_ONE = 77 ; public static final int ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = 78 ; public static final int ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = 79 ; public static final int ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = 80 ; public static final int ER_COULD_NOT_FIND_VAR = 81 ; public static final int ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = 82 ; public static final int ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = 83 ; public static final int ER_TWO_OR_THREE = 84 ; public static final int ER_VARIABLE_ACCESSED_BEFORE_BIND = 85 ; public static final int ER_FSB_CANNOT_TAKE_STRING = 86 ; public static final int ER_SETTING_WALKER_ROOT_TO_NULL = 87 ; public static final int ER_NODESETDTM_CANNOT_ITERATE = 88 ; public static final int ER_NODESET_CANNOT_ITERATE = 89 ; public static final int ER_NODESETDTM_CANNOT_INDEX = 90 ; public static final int ER_NODESET_CANNOT_INDEX = 91 ; public static final int ER_CANNOT_CALL_SETSHOULDCACHENODE = 92 ; public static final int ER_ONLY_ALLOWS = 93 ; public static final int ER_UNKNOWN_STEP = 94 ; public static final int ER_EXPECTED_REL_LOC_PATH = 95 ; public static final int ER_EXPECTED_LOC_PATH = 96 ; public static final int ER_EXPECTED_LOC_STEP = 97 ; public static final int ER_EXPECTED_NODE_TEST = 98 ; public static final int ER_EXPECTED_STEP_PATTERN = 99 ; public static final int ER_EXPECTED_REL_PATH_PATTERN = 100 ; public static final int ER_ARG_LOCALNAME_INVALID = 101 ; public static final int ER_ARG_PREFIX_INVALID = 102 ; public static final int WG_LOCALE_NAME_NOT_HANDLED = 1 ; public static final int WG_PROPERTY_NOT_SUPPORTED = 2 ; public static final int WG_DONT_DO_ANYTHING_WITH_NS = 3 ; public static final int WG_SECURITY_EXCEPTION = 4 ; public static final int WG_QUO_NO_LONGER_DEFINED = 5 ; public static final int WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = 6 ; public static final int WG_FUNCTION_TOKEN_NOT_FOUND = 7 ; public static final int WG_COULDNOT_FIND_FUNCTION = 8 ; public static final int WG_CANNOT_MAKE_URL_FROM = 9 ; public static final int WG_EXPAND_ENTITIES_NOT_SUPPORTED = 10 ; public static final int WG_ILLEGAL_VARIABLE_REFERENCE = 11 ; public static final int WG_UNSUPPORTED_ENCODING = 12 ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public static final ResourceBundle loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } public static String getMessageKey ( int errorCode ) { { DecimalFormat df = new DecimalFormat ( "0000" ) ; return ERROR_SUFFIX + df . format ( errorCode ) ; } } public static String getWarningKey ( int errorCode ) { { DecimalFormat df = new DecimalFormat ( "0000" ) ; return WARNING_SUFFIX + df . format ( errorCode ) ; } } public static String getMKey ( int errorCode ) { { DecimalFormat df = new DecimalFormat ( "0000" ) ; return ERROR_SUFFIX + df . format ( errorCode ) ; } } public static String getWKey ( int errorCode ) { { DecimalFormat df = new DecimalFormat ( "0000" ) ; return WARNING_SUFFIX + df . format ( errorCode ) ; } } } 	0	['8', '3', '0', '1', '21', '28', '1', '0', '7', '1.142857143', '273', '0', '0', '0.857142857', '0.225', '0', '0', '17.375', '2', '0.875', '0']
package org . apache . xalan . lib ; import org . w3c . dom . Node ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . w3c . dom . traversal . NodeIterator ; import org . apache . xpath . NodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . DOMHelper ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xml . utils . XMLString ; import org . xml . sax . SAXNotSupportedException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . xslt . EnvironmentCheck ; import javax . xml . parsers . * ; public class Extensions { private Extensions ( ) { } public static NodeSet nodeset ( ExpressionContext myProcessor , Object rtf ) { String textNodeValue ; if ( rtf instanceof NodeIterator ) { return new NodeSet ( ( NodeIterator ) rtf ) ; } else { if ( rtf instanceof String ) { textNodeValue = ( String ) rtf ; } else if ( rtf instanceof Boolean ) { textNodeValue = new XBoolean ( ( ( Boolean ) rtf ) . booleanValue ( ) ) . str ( ) ; } else if ( rtf instanceof Double ) { textNodeValue = new XNumber ( ( ( Double ) rtf ) . doubleValue ( ) ) . str ( ) ; } else { textNodeValue = rtf . toString ( ) ; } try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document myDoc = db . newDocument ( ) ; Text textNode = myDoc . createTextNode ( textNodeValue ) ; DocumentFragment docFrag = myDoc . createDocumentFragment ( ) ; docFrag . appendChild ( textNode ) ; return new NodeSet ( docFrag ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } } } public static NodeSet intersection ( NodeIterator ni1 , NodeIterator ni2 ) throws javax . xml . transform . TransformerException { NodeSet ns1 = new NodeSet ( ni1 ) ; NodeSet ns2 = new NodeSet ( ni2 ) ; NodeSet inter = new NodeSet ( ) ; inter . setShouldCacheNodes ( true ) ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ns2 . contains ( n ) ) inter . addElement ( n ) ; } return inter ; } public static NodeSet difference ( NodeIterator ni1 , NodeIterator ni2 ) throws javax . xml . transform . TransformerException { NodeSet ns1 = new NodeSet ( ni1 ) ; NodeSet ns2 = new NodeSet ( ni2 ) ; NodeSet diff = new NodeSet ( ) ; diff . setShouldCacheNodes ( true ) ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ! ns2 . contains ( n ) ) diff . addElement ( n ) ; } return diff ; } public static NodeSet distinct ( ExpressionContext myContext , NodeIterator ni ) throws javax . xml . transform . TransformerException { NodeSet dist = new NodeSet ( ) ; dist . setShouldCacheNodes ( true ) ; Hashtable stringTable = new Hashtable ( ) ; Node currNode = ni . nextNode ( ) ; while ( currNode != null ) { String key = myContext . toString ( currNode ) ; if ( ! stringTable . containsKey ( key ) ) { stringTable . put ( key , currNode ) ; dist . addElement ( currNode ) ; } currNode = ni . nextNode ( ) ; } return dist ; } public static boolean hasSameNodes ( NodeIterator ni1 , NodeIterator ni2 ) { NodeSet ns1 = new NodeSet ( ni1 ) ; NodeSet ns2 = new NodeSet ( ni2 ) ; if ( ns1 . getLength ( ) != ns2 . getLength ( ) ) return false ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ! ns2 . contains ( n ) ) return false ; } return true ; } public static XObject evaluate ( ExpressionContext myContext , String xpathExpr ) throws SAXNotSupportedException , Exception { if ( myContext instanceof XPathContext . XPathExpressionContext ) { try { XPathContext xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; XPath dynamicXPath = new XPath ( xpathExpr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; return dynamicXPath . execute ( xctxt , myContext . getContextNode ( ) , xctxt . getNamespaceContext ( ) ) ; } catch ( Exception e ) { throw e ; } } else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; } public static NodeSet tokenize ( ExpressionContext myContext , String toTokenize , String delims ) { Document lDoc ; try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; lDoc = db . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } StringTokenizer lTokenizer = new StringTokenizer ( toTokenize , delims ) ; NodeSet resultSet = new NodeSet ( ) ; while ( lTokenizer . hasMoreTokens ( ) ) { resultSet . addNode ( lDoc . createTextNode ( lTokenizer . nextToken ( ) ) ) ; } return resultSet ; } public static NodeSet tokenize ( ExpressionContext myContext , String toTokenize ) { return tokenize ( myContext , toTokenize , " \t\n\r" ) ; } public static Node checkEnvironment ( ExpressionContext myContext ) { Document factoryDocument ; try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; factoryDocument = db . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } Node resultNode = null ; try { resultNode = checkEnvironmentUsingWhich ( myContext , factoryDocument ) ; if ( null != resultNode ) return resultNode ; EnvironmentCheck envChecker = new EnvironmentCheck ( ) ; Hashtable h = envChecker . getEnvironmentHash ( ) ; resultNode = factoryDocument . createElement ( "checkEnvironmentExtension" ) ; envChecker . appendEnvironmentReport ( resultNode , factoryDocument , h ) ; envChecker = null ; } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } return resultNode ; } private static Node checkEnvironmentUsingWhich ( ExpressionContext myContext , Document factoryDocument ) { final String WHICH_CLASSNAME = "org.apache.env.Which" ; final String WHICH_METHODNAME = "which" ; final Class WHICH_METHOD_ARGS [ ] = { java . util . Hashtable . class , java . lang . String . class , java . lang . String . class } ; try { Class clazz = Class . forName ( WHICH_CLASSNAME ) ; if ( null == clazz ) return null ; java . lang . reflect . Method method = clazz . getMethod ( WHICH_METHODNAME , WHICH_METHOD_ARGS ) ; Hashtable report = new Hashtable ( ) ; Object [ ] methodArgs = { report , "XmlCommons;Xalan;Xerces;Crimson;Ant" , "" } ; Object returnValue = method . invoke ( null , methodArgs ) ; Node resultNode = factoryDocument . createElement ( "checkEnvironmentExtension" ) ; org . apache . xml . utils . Hashtree2Node . appendHashToNode ( report , "whichReport" , resultNode , factoryDocument ) ; return resultNode ; } catch ( Throwable t ) { return null ; } } } 	1	['12', '1', '0', '15', '62', '66', '2', '13', '9', '0.909090909', '477', '0', '0', '0', '0.25', '0', '0', '38.58333333', '5', '2', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionConstants ; public interface Constants extends InstructionConstants { public final int INTERNAL = 0 ; public final int UNSUPPORTED = 1 ; public final int FATAL = 2 ; public final int ERROR = 3 ; public final int WARNING = 4 ; public static final String EMPTYSTRING = "" ; public static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static final String TRANSLET_INTF = "org.apache.xalan.xsltc.Translet" ; public static final String TRANSLET_INTF_SIG = "Lorg/apache/xalan/xsltc/Translet;" ; public static final String ATTRIBUTES_SIG = "Lorg/apache/xalan/xsltc/runtime/Attributes;" ; public static final String NODE_ITERATOR_SIG = "Lorg/apache/xalan/xsltc/NodeIterator;" ; public static final String DOM_INTF_SIG = "Lorg/apache/xalan/xsltc/DOM;" ; public static final String DOM_IMPL_CLASS = "org/apache/xalan/xsltc/dom/DOMImpl" ; public static final String DOM_IMPL_SIG = "Lorg/apache/xalan/xsltc/dom/DOMImpl;" ; public static final String DOM_ADAPTER_CLASS = "org/apache/xalan/xsltc/dom/DOMAdapter" ; public static final String DOM_ADAPTER_SIG = "Lorg/apache/xalan/xsltc/dom/DOMAdapter;" ; public static final String MULTI_DOM_CLASS = "org.apache.xalan.xsltc.dom.MultiDOM" ; public static final String MULTI_DOM_SIG = "Lorg/apache/xalan/xsltc/dom/MultiDOM;" ; public static final String STRING = "java.lang.String" ; public static final int ACC_PUBLIC = org . apache . bcel . Constants . ACC_PUBLIC ; public static final int ACC_SUPER = org . apache . bcel . Constants . ACC_SUPER ; public static final int ACC_FINAL = org . apache . bcel . Constants . ACC_FINAL ; public static final int ACC_PRIVATE = org . apache . bcel . Constants . ACC_PRIVATE ; public static final int ACC_PROTECTED = org . apache . bcel . Constants . ACC_PROTECTED ; public static final int ACC_STATIC = org . apache . bcel . Constants . ACC_STATIC ; public static final String STRING_SIG = "Ljava/lang/String;" ; public static final String STRING_BUFFER_SIG = "Ljava/lang/StringBuffer;" ; public static final String OBJECT_SIG = "Ljava/lang/Object;" ; public static final String DOUBLE_SIG = "Ljava/lang/Double;" ; public static final String INTEGER_SIG = "Ljava/lang/Integer;" ; public static final String COLLATOR_CLASS = "java/text/Collator" ; public static final String COLLATOR_SIG = "Ljava/text/Collator;" ; public static final String NODE = "int" ; public static final String NODE_ITERATOR = "org.apache.xalan.xsltc.NodeIterator" ; public static final String NODE_ITERATOR_BASE = "org.apache.xalan.xsltc.dom.NodeIteratorBase" ; public static final String SORT_ITERATOR = "org.apache.xalan.xsltc.dom.SortingIterator" ; public static final String SORT_ITERATOR_SIG = "Lorg.apache.xalan.xsltc.dom.SortingIterator;" ; public static final String REVERSE_ITERATOR = "org.apache.xalan.xsltc.dom.ReverseIterator" ; public static final String NODE_SORT_RECORD = "org.apache.xalan.xsltc.dom.NodeSortRecord" ; public static final String NODE_SORT_FACTORY = "org/apache/xalan/xsltc/dom/NodeSortRecordFactory" ; public static final String NODE_SORT_RECORD_SIG = "Lorg/apache/xalan/xsltc/dom/NodeSortRecord;" ; public static final String NODE_SORT_FACTORY_SIG = "Lorg/apache/xalan/xsltc/dom/NodeSortRecordFactory;" ; public static final String STRING_VALUE_HANDLER = "org.apache.xalan.xsltc.runtime.StringValueHandler" ; public static final String STRING_VALUE_HANDLER_SIG = "Lorg/apache/xalan/xsltc/runtime/StringValueHandler;" ; public static final String OUTPUT_HANDLER = "org/apache/xalan/xsltc/TransletOutputHandler" ; public static final String OUTPUT_HANDLER_SIG = "Lorg/apache/xalan/xsltc/TransletOutputHandler;" ; public static final String FILTER_INTERFACE = "org.apache.xalan.xsltc.dom.Filter" ; public static final String FILTER_INTERFACE_SIG = "Lorg/apache/xalan/xsltc/dom/Filter;" ; public static final String UNION_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.UnionIterator" ; public static final String STEP_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.StepIterator" ; public static final String NTH_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.NthIterator" ; public static final String ABSOLUTE_ITERATOR = "org.apache.xalan.xsltc.dom.AbsoluteIterator" ; public static final String DUP_FILTERED_ITERATOR = "org.apache.xalan.xsltc.dom.DupFilterIterator" ; public static final String CURRENT_NODE_LIST_ITERATOR = "org.apache.xalan.xsltc.dom.CurrentNodeListIterator" ; public static final String CURRENT_NODE_LIST_FILTER = "org.apache.xalan.xsltc.dom.CurrentNodeListFilter" ; public static final String CURRENT_NODE_LIST_ITERATOR_SIG = "Lorg/apache/xalan/xsltc/dom/CurrentNodeListIterator;" ; public static final String CURRENT_NODE_LIST_FILTER_SIG = "Lorg/apache/xalan/xsltc/dom/CurrentNodeListFilter;" ; public static final String FILTER_STEP_ITERATOR = "org.apache.xalan.xsltc.dom.FilteredStepIterator" ; public static final String FILTER_ITERATOR = "org.apache.xalan.xsltc.dom.FilterIterator" ; public static final String SINGLETON_ITERATOR = "org.apache.xalan.xsltc.dom.SingletonIterator" ; public static final String MATCHING_ITERATOR = "org.apache.xalan.xsltc.dom.MatchingIterator" ; public static final String NODE_SIG = "I" ; public static final String GET_PARENT = "getParent" ; public static final String GET_PARENT_SIG = "(" + NODE_SIG + ")" + NODE_SIG ; public static final String NEXT_SIG = "()" + NODE_SIG ; public static final String NEXT = "next" ; public static final String MAKE_NODE = "makeNode" ; public static final String MAKE_NODE_LIST = "makeNodeList" ; public static final String STRING_TO_REAL = "stringToReal" ; public static final String STRING_TO_REAL_SIG = "(" + STRING_SIG + ")D" ; public static final String STRING_TO_INT = "stringToInt" ; public static final String STRING_TO_INT_SIG = "(" + STRING_SIG + ")I" ; public static final String XSLT_PACKAGE = "org.apache.xalan.xsltc" ; public static final String COMPILER_PACKAGE = XSLT_PACKAGE + ".compiler" ; public static final String RUNTIME_PACKAGE = XSLT_PACKAGE + ".runtime" ; public static final String TRANSLET_CLASS = RUNTIME_PACKAGE + ".AbstractTranslet" ; public static final String TRANSLET_SIG = "Lorg/apache/xalan/xsltc/runtime/AbstractTranslet;" ; public static final String UNION_ITERATOR_SIG = "Lorg/apache/xalan/xsltc/dom/UnionIterator;" ; public static final String TRANSLET_OUTPUT_BASE_SIG = "Lorg/apache/xalan/xsltc/TransletOutputBase;" ; public static final String TRANSLET_OUTPUT_SIG = "Lorg/apache/xalan/xsltc/TransletOutputHandler;" ; public static final String MAKE_NODE_SIG = "(I)Lorg/w3c/dom/Node;" ; public static final String MAKE_NODE_SIG2 = "(" + NODE_ITERATOR_SIG + ")Lorg/w3c/dom/Node;" ; public static final String MAKE_NODE_LIST_SIG = "(I)Lorg/w3c/dom/NodeList;" ; public static final String MAKE_NODE_LIST_SIG2 = "(" + NODE_ITERATOR_SIG + ")Lorg/w3c/dom/NodeList;" ; public static final String LOAD_DOCUMENT_CLASS = "org.apache.xalan.xsltc.dom.LoadDocument" ; public static final String KEY_INDEX_CLASS = "org/apache/xalan/xsltc/dom/KeyIndex" ; public static final String KEY_INDEX_SIG = "Lorg/apache/xalan/xsltc/dom/KeyIndex;" ; public static final String DOM_INTF = "org.apache.xalan.xsltc.DOM" ; public static final String DOM_IMPL = "org.apache.xalan.xsltc.dom.DOMImpl" ; public static final String STRING_CLASS = "java.lang.String" ; public static final String OBJECT_CLASS = "java.lang.Object" ; public static final String BOOLEAN_CLASS = "java.lang.Boolean" ; public static final String STRING_BUFFER_CLASS = "java.lang.StringBuffer" ; public static final String TRANSLET_OUTPUT_BASE = "org.apache.xalan.xsltc.TransletOutputBase" ; public static final String TRANSLET_OUTPUT_INTERFACE = "org.apache.xalan.xsltc.TransletOutputHandler" ; public static final String BASIS_LIBRARY_CLASS = "org.apache.xalan.xsltc.runtime.BasisLibrary" ; public static final String ATTRIBUTE_LIST_IMPL_CLASS = "org.apache.xalan.xsltc.runtime.AttributeListImpl" ; public static final String DOUBLE_CLASS = "java.lang.Double" ; public static final String INTEGER_CLASS = "java.lang.Integer" ; public static final String RUNTIME_NODE_CLASS = "org.apache.xalan.xsltc.runtime.Node" ; public static final String MATH_CLASS = "java.lang.Math" ; public static final String BOOLEAN_VALUE = "booleanValue" ; public static final String BOOLEAN_VALUE_SIG = "()Z" ; public static final String INT_VALUE = "intValue" ; public static final String INT_VALUE_SIG = "()I" ; public static final String DOUBLE_VALUE = "doubleValue" ; public static final String DOUBLE_VALUE_SIG = "()D" ; public static final String NODE_PNAME = "node" ; public static final String TRANSLET_OUTPUT_PNAME = "handler" ; public static final String ITERATOR_PNAME = "iterator" ; public static final String DOCUMENT_PNAME = "document" ; public static final String TRANSLET_PNAME = "translet" ; public static final String GET_NODE_NAME = "getNodeName" ; public static final String CHARACTERSW = "characters" ; public static final String GET_CHILDREN = "getChildren" ; public static final String GET_TYPED_CHILDREN = "getTypedChildren" ; public static final String CHARACTERS = "characters" ; public static final String APPLY_TEMPLATES = "applyTemplates" ; public static final String GET_NODE_TYPE = "getNodeType" ; public static final String GET_NODE_VALUE = "getNodeValue" ; public static final String GET_ELEMENT_VALUE = "getElementValue" ; public static final String GET_ATTRIBUTE_VALUE = "getAttributeValue" ; public static final String HAS_ATTRIBUTE = "hasAttribute" ; public static final String ADD_ITERATOR = "addIterator" ; public static final String SET_START_NODE = "setStartNode" ; public static final String RESET = "reset" ; public static final String ATTR_SET_SIG = "(" + TRANSLET_OUTPUT_SIG + NODE_ITERATOR_SIG + ")V" ; public static final String GET_NODE_NAME_SIG = "(" + NODE_SIG + ")" + STRING_SIG ; public static final String CHARACTERSW_SIG = "(" + STRING_SIG + TRANSLET_OUTPUT_SIG + ")V" ; public static final String CHARACTERS_SIG = "(" + NODE_SIG + TRANSLET_OUTPUT_SIG + ")V" ; public static final String GET_CHILDREN_SIG = "(" + NODE_SIG + ")" + NODE_ITERATOR_SIG ; public static final String GET_TYPED_CHILDREN_SIG = "(I)" + NODE_ITERATOR_SIG ; public static final String GET_NODE_TYPE_SIG = "()S" ; public static final String GET_NODE_VALUE_SIG = "(I)" + STRING_SIG ; public static final String GET_ELEMENT_VALUE_SIG = "(I)" + STRING_SIG ; public static final String GET_ATTRIBUTE_VALUE_SIG = "(II)" + STRING_SIG ; public static final String HAS_ATTRIBUTE_SIG = "(II)Z" ; public static final String GET_ITERATOR_SIG = "()" + NODE_ITERATOR_SIG ; public static final String NAMES_INDEX = "namesArray" ; public static final String NAMES_INDEX_SIG = "[" + STRING_SIG ; public static final String NAMESPACE_INDEX = "namespaceArray" ; public static final String NAMESPACE_INDEX_SIG = "[" + STRING_SIG ; public static final String DOM_FIELD = "_dom" ; public static final String FORMAT_SYMBOLS_FIELD = "format_symbols" ; public static final String ITERATOR_FIELD_SIG = NODE_ITERATOR_SIG ; public static final String NODE_FIELD = "node" ; public static final String NODE_FIELD_SIG = "I" ; public static final String EMPTYATTR_FIELD = "EmptyAttributes" ; public static final String ATTRIBUTE_LIST_FIELD = "attributeList" ; public static final String CLEAR_ATTRIBUTES = "clear" ; public static final String ADD_ATTRIBUTE = "addAttribute" ; public static final String ATTRIBUTE_LIST_IMPL_SIG = "Lorg/apache/xalan/xsltc/runtime/AttributeListImpl;" ; public static final String CLEAR_ATTRIBUTES_SIG = "()" + ATTRIBUTE_LIST_IMPL_SIG ; public static final String ADD_ATTRIBUTE_SIG = "(" + STRING_SIG + STRING_SIG + ")" + ATTRIBUTE_LIST_IMPL_SIG ; public static final String ADD_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + ")" + UNION_ITERATOR_SIG ; public static final String ORDER_ITERATOR = "orderNodes" ; public static final String ORDER_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + "I)" + NODE_ITERATOR_SIG ; public static final String SET_START_NODE_SIG = "(" + NODE_SIG + ")" + NODE_ITERATOR_SIG ; public static final String NODE_COUNTER = "org.apache.xalan.xsltc.dom.NodeCounter" ; public static final String NODE_COUNTER_SIG = "Lorg/apache/xalan/xsltc/dom/NodeCounter;" ; public static final String DEFAULT_NODE_COUNTER = "org.apache.xalan.xsltc.dom.DefaultNodeCounter" ; public static final String DEFAULT_NODE_COUNTER_SIG = "Lorg/apache/xalan/xsltc/dom/DefaultNodeCounter;" ; public static final String TRANSLET_FIELD = "translet" ; public static final String TRANSLET_FIELD_SIG = TRANSLET_SIG ; public static final String RESET_SIG = "()" + NODE_ITERATOR_SIG ; public static final String GET_PARAMETER = "getParameter" ; public static final String ADD_PARAMETER = "addParameter" ; public static final String PUSH_PARAM_FRAME = "pushParamFrame" ; public static final String PUSH_PARAM_FRAME_SIG = "()V" ; public static final String POP_PARAM_FRAME = "popParamFrame" ; public static final String POP_PARAM_FRAME_SIG = "()V" ; public static final String GET_PARAMETER_SIG = "(" + STRING_SIG + ")" + OBJECT_SIG ; public static final String ADD_PARAMETER_SIG = "(" + STRING_SIG + OBJECT_SIG + "Z)" + OBJECT_SIG ; public static final String STRIP_SPACE = "stripSpace" ; public static final String STRIP_SPACE_INTF = "org/apache/xalan/xsltc/StripFilter" ; public static final String STRIP_SPACE_SIG = "Lorg/apache/xalan/xsltc/StripFilter;" ; public static final String STRIP_SPACE_PARAMS = "(Lorg/apache/xalan/xsltc/DOM;II)Z" ; public static final String GET_NODE_VALUE_ITERATOR = "getNodeValueIterator" ; public static final String GET_NODE_VALUE_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + "I" + STRING_SIG + "Z)" + NODE_ITERATOR_SIG ; public static final int POSITION_INDEX = 2 ; public static final int LAST_INDEX = 3 ; public static final String XMLNS_PREFIX = "xmlns" ; public static final String XMLNS_STRING = "xmlns:" ; public static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/" ; public static final String XSLT_URI = "http://www.w3.org/1999/XSL/Transform" ; public static final String XHTML_URI = "http://www.w3.org/1999/xhtml" ; public static final String TRANSLET_URI = "http://xml.apache.org/xalan/xsltc" ; public static final String FALLBACK_CLASS = "org.apache.xalan.xsltc.compiler.Fallback" ; } 	0	['0', '1', '0', '6', '0', '0', '5', '1', '0', '2', '188', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xpath . objects ; import org . w3c . dom . traversal . NodeIterator ; import org . w3c . dom . NodeList ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . DOMHelper ; import org . apache . xpath . XPathContext ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . axes . ContextNodeList ; import org . apache . xpath . axes . NodeSequence ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . XMLString ; public class XNodeSet extends NodeSequence { protected XNodeSet ( ) { } public XNodeSet ( DTMIterator val ) { super ( ) ; if ( val instanceof XNodeSet ) { setIter ( ( ( XNodeSet ) val ) . m_iter ) ; m_dtmMgr = ( ( XNodeSet ) val ) . m_dtmMgr ; m_last = ( ( XNodeSet ) val ) . m_last ; if ( ! ( ( XNodeSet ) val ) . hasCache ( ) ) ( ( XNodeSet ) val ) . setShouldCacheNodes ( true ) ; m_obj = ( ( XNodeSet ) val ) . m_obj ; } else setIter ( val ) ; } public XNodeSet ( XNodeSet val ) { super ( ) ; setIter ( val . m_iter ) ; m_dtmMgr = val . m_dtmMgr ; m_last = val . m_last ; if ( ! val . hasCache ( ) ) val . setShouldCacheNodes ( true ) ; m_obj = val . m_obj ; } public XNodeSet ( DTMManager dtmMgr ) { super ( dtmMgr ) ; } public XNodeSet ( int n , DTMManager dtmMgr ) { super ( new NodeSetDTM ( dtmMgr ) ) ; m_dtmMgr = dtmMgr ; if ( DTM . NULL != n ) { ( ( NodeSetDTM ) m_obj ) . addNode ( n ) ; m_last = 1 ; } else m_last = 0 ; } public int getType ( ) { return CLASS_NODESET ; } public String getTypeString ( ) { return "#NODESET" ; } public double getNumberFromNode ( int n ) { XMLString xstr = m_dtmMgr . getDTM ( n ) . getStringValue ( n ) ; return xstr . toDouble ( ) ; } public double num ( ) { int node = item ( 0 ) ; return ( node != DTM . NULL ) ? getNumberFromNode ( node ) : Double . NaN ; } public double numWithSideEffects ( ) { int node = nextNode ( ) ; return ( node != DTM . NULL ) ? getNumberFromNode ( node ) : Double . NaN ; } public boolean bool ( ) { return ( item ( 0 ) != DTM . NULL ) ; } public boolean boolWithSideEffects ( ) { return ( nextNode ( ) != DTM . NULL ) ; } public XMLString getStringFromNode ( int n ) { if ( DTM . NULL != n ) { return m_dtmMgr . getDTM ( n ) . getStringValue ( n ) ; } else { return org . apache . xpath . objects . XString . EMPTYSTRING ; } } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { int node = item ( 0 ) ; if ( node != DTM . NULL ) { m_dtmMgr . getDTM ( node ) . dispatchCharactersEvents ( node , ch , false ) ; } } public XMLString xstr ( ) { int node = item ( 0 ) ; return ( node != DTM . NULL ) ? getStringFromNode ( node ) : XString . EMPTYSTRING ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { XString xstring = ( XString ) xstr ( ) ; xstring . appendToFsb ( fsb ) ; } public String str ( ) { int node = item ( 0 ) ; return ( node != DTM . NULL ) ? getStringFromNode ( node ) . toString ( ) : "" ; } public Object object ( ) { if ( null == m_obj ) return this ; else return m_obj ; } public NodeIterator nodeset ( ) throws javax . xml . transform . TransformerException { return new org . apache . xml . dtm . ref . DTMNodeIterator ( iter ( ) ) ; } public NodeList nodelist ( ) throws javax . xml . transform . TransformerException { return new org . apache . xml . dtm . ref . DTMNodeList ( iter ( ) ) ; } public DTMIterator iterRaw ( ) { return this ; } public void release ( DTMIterator iter ) { } public DTMIterator iter ( ) { try { if ( hasCache ( ) ) return cloneWithReset ( ) ; else return this ; } catch ( CloneNotSupportedException cnse ) { throw new RuntimeException ( cnse . getMessage ( ) ) ; } } public XObject getFresh ( ) { try { if ( hasCache ( ) ) return ( XObject ) cloneWithReset ( ) ; else return this ; } catch ( CloneNotSupportedException cnse ) { throw new RuntimeException ( cnse . getMessage ( ) ) ; } } public NodeSetDTM mutableNodeset ( ) { NodeSetDTM mnl ; if ( m_obj instanceof NodeSetDTM ) { mnl = ( NodeSetDTM ) m_obj ; } else { mnl = new NodeSetDTM ( iter ( ) ) ; m_obj = mnl ; setCurrentPos ( 0 ) ; } return mnl ; } static LessThanComparator S_LT = new LessThanComparator ( ) ; static LessThanOrEqualComparator S_LTE = new LessThanOrEqualComparator ( ) ; static GreaterThanComparator S_GT = new GreaterThanComparator ( ) ; static GreaterThanOrEqualComparator S_GTE = new GreaterThanOrEqualComparator ( ) ; static EqualComparator S_EQ = new EqualComparator ( ) ; static NotEqualComparator S_NEQ = new NotEqualComparator ( ) ; public boolean compare ( XObject obj2 , Comparator comparator ) throws javax . xml . transform . TransformerException { boolean result = false ; int type = obj2 . getType ( ) ; if ( XObject . CLASS_NODESET == type ) { DTMIterator list1 = iterRaw ( ) ; DTMIterator list2 = ( ( XNodeSet ) obj2 ) . iterRaw ( ) ; int node1 ; java . util . Vector node2Strings = null ; while ( DTM . NULL != ( node1 = list1 . nextNode ( ) ) ) { XMLString s1 = getStringFromNode ( node1 ) ; if ( null == node2Strings ) { int node2 ; while ( DTM . NULL != ( node2 = list2 . nextNode ( ) ) ) { XMLString s2 = getStringFromNode ( node2 ) ; if ( comparator . compareStrings ( s1 , s2 ) ) { result = true ; break ; } if ( null == node2Strings ) node2Strings = new java . util . Vector ( ) ; node2Strings . addElement ( s2 ) ; } } else { int n = node2Strings . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( comparator . compareStrings ( s1 , ( XMLString ) node2Strings . elementAt ( i ) ) ) { result = true ; break ; } } } } list1 . reset ( ) ; list2 . reset ( ) ; } else if ( XObject . CLASS_BOOLEAN == type ) { double num1 = bool ( ) ? 1.0 : 0.0 ; double num2 = obj2 . num ( ) ; result = comparator . compareNumbers ( num1 , num2 ) ; } else if ( XObject . CLASS_NUMBER == type ) { DTMIterator list1 = iterRaw ( ) ; double num2 = obj2 . num ( ) ; int node ; while ( DTM . NULL != ( node = list1 . nextNode ( ) ) ) { double num1 = getNumberFromNode ( node ) ; if ( comparator . compareNumbers ( num1 , num2 ) ) { result = true ; break ; } } list1 . reset ( ) ; } else if ( XObject . CLASS_RTREEFRAG == type ) { XMLString s2 = obj2 . xstr ( ) ; DTMIterator list1 = iterRaw ( ) ; int node ; while ( DTM . NULL != ( node = list1 . nextNode ( ) ) ) { XMLString s1 = getStringFromNode ( node ) ; if ( comparator . compareStrings ( s1 , s2 ) ) { result = true ; break ; } } list1 . reset ( ) ; } else if ( XObject . CLASS_STRING == type ) { XMLString s2 = obj2 . xstr ( ) ; DTMIterator list1 = iterRaw ( ) ; int node ; while ( DTM . NULL != ( node = list1 . nextNode ( ) ) ) { XMLString s1 = getStringFromNode ( node ) ; if ( comparator . compareStrings ( s1 , s2 ) ) { result = true ; break ; } } list1 . reset ( ) ; } else { result = comparator . compareNumbers ( this . num ( ) , obj2 . num ( ) ) ; } return result ; } public boolean lessThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_LT ) ; } public boolean lessThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_LTE ) ; } public boolean greaterThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_GT ) ; } public boolean greaterThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_GTE ) ; } public boolean equals ( XObject obj2 ) { try { return compare ( obj2 , S_EQ ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } public boolean notEquals ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_NEQ ) ; } } abstract class Comparator { abstract boolean compareStrings ( XMLString s1 , XMLString s2 ) ; abstract boolean compareNumbers ( double n1 , double n2 ) ; } class LessThanComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) < s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 < n2 ; } } class LessThanOrEqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) <= s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 <= n2 ; } } class GreaterThanComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) > s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 > n2 ; } } class GreaterThanOrEqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) >= s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 >= n2 ; } } class EqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return s1 . equals ( s2 ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 == n2 ; } } class NotEqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ! s1 . equals ( s2 ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 != n2 ; } } 	1	['33', '4', '2', '42', '74', '516', '24', '19', '31', '0.96875', '600', '0', '6', '0.801470588', '0.173611111', '3', '29', '17', '2', '1.1515', '2']
package org . apache . xalan . xsltc . runtime . output ; import java . io . Writer ; import java . io . IOException ; import java . io . OutputStream ; import org . w3c . dom . Node ; import org . xml . sax . SAXException ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; import org . apache . xalan . xsltc . runtime . * ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . TransletOutputHandler ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xalan . xsltc . trax . SAX2DOM ; public class TransletOutputHandlerFactory { public static final int STREAM = 0 ; public static final int SAX = 1 ; public static final int DOM = 2 ; private String _encoding = "utf-8" ; private String _method = null ; private int _outputType = STREAM ; private OutputStream _ostream = System . out ; private Writer _writer = null ; private Node _node = null ; private int _indentNumber = - 1 ; private ContentHandler _handler = null ; private LexicalHandler _lexHandler = null ; static public TransletOutputHandlerFactory newInstance ( ) { return new TransletOutputHandlerFactory ( ) ; } public void setOutputType ( int outputType ) { _outputType = outputType ; } public void setEncoding ( String encoding ) { if ( encoding != null ) { _encoding = encoding ; } } public void setOutputMethod ( String method ) { _method = method ; } public void setOutputStream ( OutputStream ostream ) { _ostream = ostream ; } public void setWriter ( Writer writer ) { _writer = writer ; } public void setHandler ( ContentHandler handler ) { _handler = handler ; } public void setLexicalHandler ( LexicalHandler lex ) { _lexHandler = lex ; } public void setNode ( Node node ) { _node = node ; } public Node getNode ( ) { return ( _handler instanceof SAX2DOM ) ? ( ( SAX2DOM ) _handler ) . getDOM ( ) : null ; } public void setIndentNumber ( int value ) { _indentNumber = value ; } public TransletOutputHandler getTransletOutputHandler ( ) throws IOException , ParserConfigurationException { switch ( _outputType ) { case STREAM : StreamOutput result = null ; if ( _method == null ) { result = ( _writer == null ) ? new StreamUnknownOutput ( _ostream , _encoding ) : new StreamUnknownOutput ( _writer , _encoding ) ; } else if ( _method . equalsIgnoreCase ( "xml" ) ) { result = ( _writer == null ) ? new StreamXMLOutput ( _ostream , _encoding ) : new StreamXMLOutput ( _writer , _encoding ) ; } else if ( _method . equalsIgnoreCase ( "html" ) ) { result = ( _writer == null ) ? new StreamHTMLOutput ( _ostream , _encoding ) : new StreamHTMLOutput ( _writer , _encoding ) ; } else if ( _method . equalsIgnoreCase ( "text" ) ) { result = ( _writer == null ) ? new StreamTextOutput ( _ostream , _encoding ) : new StreamTextOutput ( _writer , _encoding ) ; } if ( result != null && _indentNumber >= 0 ) { result . setIndentNumber ( _indentNumber ) ; } return result ; case DOM : _handler = ( _node != null ) ? new SAX2DOM ( _node ) : new SAX2DOM ( ) ; _lexHandler = ( LexicalHandler ) _handler ; case SAX : if ( _method == null ) { _method = "xml" ; } if ( _method . equalsIgnoreCase ( "xml" ) ) { return ( _lexHandler == null ) ? new SAXXMLOutput ( _handler , _encoding ) : new SAXXMLOutput ( _handler , _lexHandler , _encoding ) ; } else if ( _method . equalsIgnoreCase ( "html" ) ) { return ( _lexHandler == null ) ? new SAXHTMLOutput ( _handler , _encoding ) : new SAXHTMLOutput ( _handler , _lexHandler , _encoding ) ; } else if ( _method . equalsIgnoreCase ( "text" ) ) { return ( _lexHandler == null ) ? new SAXTextOutput ( _handler , _encoding ) : new SAXTextOutput ( _handler , _lexHandler , _encoding ) ; } break ; } return null ; } public TransletOutputHandler getOldTransletOutputHandler ( ) throws IOException { DefaultSAXOutputHandler saxHandler = new DefaultSAXOutputHandler ( _ostream , _encoding ) ; return new TextOutput ( ( ContentHandler ) saxHandler , ( LexicalHandler ) saxHandler , _encoding ) ; } } 	0	['14', '1', '0', '15', '36', '39', '3', '12', '14', '0.826923077', '343', '0.75', '0', '0', '0.196428571', '0', '0', '22.64285714', '2', '1.0714', '0']
package org . apache . xalan . trace ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . traversal . NodeIterator ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xalan . templates . Constants ; import org . apache . xpath . axes . ContextNodeList ; import javax . xml . transform . SourceLocator ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . ref . DTMNodeProxy ; public class PrintTraceListener implements TraceListenerEx2 { public PrintTraceListener ( java . io . PrintWriter pw ) { m_pw = pw ; } java . io . PrintWriter m_pw ; public boolean m_traceTemplates = false ; public boolean m_traceElements = false ; public boolean m_traceGeneration = false ; public boolean m_traceSelection = false ; public void _trace ( TracerEvent ev ) { switch ( ev . m_styleNode . getXSLToken ( ) ) { case Constants . ELEMNAME_TEXTLITERALRESULT : if ( m_traceElements ) { m_pw . print ( ev . m_styleNode . getSystemId ( ) + " Line #" + ev . m_styleNode . getLineNumber ( ) + ", " + "Column #" + ev . m_styleNode . getColumnNumber ( ) + " -- " + ev . m_styleNode . getNodeName ( ) + ": " ) ; ElemTextLiteral etl = ( ElemTextLiteral ) ev . m_styleNode ; String chars = new String ( etl . getChars ( ) , 0 , etl . getChars ( ) . length ) ; m_pw . println ( "    " + chars . trim ( ) ) ; } break ; case Constants . ELEMNAME_TEMPLATE : if ( m_traceTemplates || m_traceElements ) { ElemTemplate et = ( ElemTemplate ) ev . m_styleNode ; m_pw . print ( et . getSystemId ( ) + " Line #" + et . getLineNumber ( ) + ", " + "Column #" + et . getColumnNumber ( ) + ": " + et . getNodeName ( ) + " " ) ; if ( null != et . getMatch ( ) ) { m_pw . print ( "match='" + et . getMatch ( ) . getPatternString ( ) + "' " ) ; } if ( null != et . getName ( ) ) { m_pw . print ( "name='" + et . getName ( ) + "' " ) ; } m_pw . println ( ) ; } break ; default : if ( m_traceElements ) { m_pw . println ( ev . m_styleNode . getSystemId ( ) + " Line #" + ev . m_styleNode . getLineNumber ( ) + ", " + "Column #" + ev . m_styleNode . getColumnNumber ( ) + ": " + ev . m_styleNode . getNodeName ( ) ) ; } } } int m_indent = 0 ; public void trace ( TracerEvent ev ) { _trace ( ev ) ; } public void traceEnd ( TracerEvent ev ) { } public void selected ( SelectionEvent ev ) throws javax . xml . transform . TransformerException { if ( m_traceSelection ) { ElemTemplateElement ete = ( ElemTemplateElement ) ev . m_styleNode ; Node sourceNode = ev . m_sourceNode ; SourceLocator locator = null ; if ( sourceNode instanceof DTMNodeProxy ) { int nodeHandler = ( ( DTMNodeProxy ) sourceNode ) . getDTMNodeNumber ( ) ; locator = ( ( DTMNodeProxy ) sourceNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; } if ( locator != null ) m_pw . println ( "Selected source node '" + sourceNode . getNodeName ( ) + "', at " + locator ) ; else m_pw . println ( "Selected source node '" + sourceNode . getNodeName ( ) + "'" ) ; if ( ev . m_styleNode . getLineNumber ( ) == 0 ) { ElemTemplateElement parent = ( ElemTemplateElement ) ete . getParentElem ( ) ; if ( parent == ete . getStylesheetRoot ( ) . getDefaultRootRule ( ) ) { m_pw . print ( "(default root rule) " ) ; } else if ( parent == ete . getStylesheetRoot ( ) . getDefaultTextRule ( ) ) { m_pw . print ( "(default text rule) " ) ; } else if ( parent == ete . getStylesheetRoot ( ) . getDefaultRule ( ) ) { m_pw . print ( "(default rule) " ) ; } m_pw . print ( ete . getNodeName ( ) + ", " + ev . m_attributeName + "='" + ev . m_xpath . getPatternString ( ) + "': " ) ; } else { m_pw . print ( ev . m_styleNode . getSystemId ( ) + " Line #" + ev . m_styleNode . getLineNumber ( ) + ", " + "Column #" + ev . m_styleNode . getColumnNumber ( ) + ": " + ete . getNodeName ( ) + ", " + ev . m_attributeName + "='" + ev . m_xpath . getPatternString ( ) + "': " ) ; } if ( ev . m_selection . getType ( ) == ev . m_selection . CLASS_NODESET ) { m_pw . println ( ) ; org . apache . xml . dtm . DTMIterator nl = ev . m_selection . iter ( ) ; try { nl = nl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { m_pw . println ( "     [Can't trace nodelist because it it threw a CloneNotSupportedException]" ) ; return ; } int pos = nl . nextNode ( ) ; if ( DTM . NULL == pos ) { m_pw . println ( "     [empty node list]" ) ; } else { while ( DTM . NULL != pos ) { DTM dtm = ev . m_processor . getXPathContext ( ) . getDTM ( pos ) ; m_pw . print ( "     " ) ; m_pw . print ( Integer . toHexString ( pos ) ) ; m_pw . print ( ": " ) ; m_pw . println ( dtm . getNodeName ( pos ) ) ; pos = nl . nextNode ( ) ; } } } else { m_pw . println ( ev . m_selection . str ( ) ) ; } } } public void selectEnd ( EndSelectionEvent ev ) throws javax . xml . transform . TransformerException { } public void generated ( GenerateEvent ev ) { if ( m_traceGeneration ) { switch ( ev . m_eventtype ) { case GenerateEvent . EVENTTYPE_STARTDOCUMENT : m_pw . println ( "STARTDOCUMENT" ) ; break ; case GenerateEvent . EVENTTYPE_ENDDOCUMENT : m_pw . println ( "ENDDOCUMENT" ) ; break ; case GenerateEvent . EVENTTYPE_STARTELEMENT : m_pw . println ( "STARTELEMENT: " + ev . m_name ) ; break ; case GenerateEvent . EVENTTYPE_ENDELEMENT : m_pw . println ( "ENDELEMENT: " + ev . m_name ) ; break ; case GenerateEvent . EVENTTYPE_CHARACTERS : { String chars = new String ( ev . m_characters , ev . m_start , ev . m_length ) ; m_pw . println ( "CHARACTERS: " + chars ) ; } break ; case GenerateEvent . EVENTTYPE_CDATA : { String chars = new String ( ev . m_characters , ev . m_start , ev . m_length ) ; m_pw . println ( "CDATA: " + chars ) ; } break ; case GenerateEvent . EVENTTYPE_COMMENT : m_pw . println ( "COMMENT: " + ev . m_data ) ; break ; case GenerateEvent . EVENTTYPE_PI : m_pw . println ( "PI: " + ev . m_name + ", " + ev . m_data ) ; break ; case GenerateEvent . EVENTTYPE_ENTITYREF : m_pw . println ( "ENTITYREF: " + ev . m_name ) ; break ; case GenerateEvent . EVENTTYPE_IGNORABLEWHITESPACE : m_pw . println ( "IGNORABLEWHITESPACE" ) ; break ; } } } } 	1	['7', '1', '0', '18', '47', '9', '1', '17', '7', '0.722222222', '593', '0', '0', '0', '0.333333333', '0', '0', '82.85714286', '10', '2.4286', '1']
package org . apache . xalan . serialize ; public final class Method { public static final String XML = "xml" ; public static final String HTML = "html" ; public static final String XHTML = "xhtml" ; public static final String Text = "text" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '8', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xalan . xsltc . compiler . Constants ; public final class ResultTreeType extends Type { private final String _methodName ; protected ResultTreeType ( ) { _methodName = null ; } public ResultTreeType ( String methodName ) { _methodName = methodName ; } public String toString ( ) { return "result-tree" ; } public boolean identicalTo ( Type other ) { return ( other instanceof ResultTreeType ) ; } public String toSignature ( ) { return DOM_INTF_SIG ; } public org . apache . bcel . generic . Type toJCType ( ) { return Util . getJCRefType ( toSignature ( ) ) ; } public String getMethodName ( ) { return _methodName ; } public boolean implementedAsMethod ( ) { return _methodName != null ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . NodeSet ) { translateTo ( classGen , methodGen , ( NodeSetType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( POP ) ; il . append ( ICONST_1 ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _methodName == null ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , "getStringValue" , "()" + STRING_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; } else { final String className = classGen . getClassName ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( DUP ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , "_dom" , DOM_INTF_SIG ) ) ) ; int index = cpg . addMethodref ( STRING_VALUE_HANDLER , "<init>" , "()V" ) ; il . append ( new NEW ( cpg . addClass ( STRING_VALUE_HANDLER ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( index ) ) ; final LocalVariableGen handler = methodGen . addLocalVariable ( "rt_to_string_handler" , Util . getJCRefType ( STRING_VALUE_HANDLER_SIG ) , null , null ) ; il . append ( new ASTORE ( handler . getIndex ( ) ) ) ; index = cpg . addMethodref ( className , _methodName , "(" + DOM_INTF_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( new ALOAD ( handler . getIndex ( ) ) ) ; index = cpg . addMethodref ( STRING_VALUE_HANDLER , "getValue" , "()" + STRING_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { translateTo ( classGen , methodGen , Type . String ) ; Type . String . translateTo ( classGen , methodGen , Type . Real ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _methodName == null ) { il . append ( NOP ) ; } else { LocalVariableGen domBuilder , newDom ; final String className = classGen . getClassName ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addMethodref ( DOM_IMPL , "<init>" , "(I)V" ) ; il . append ( new NEW ( cpg . addClass ( DOM_IMPL ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , 64 ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; newDom = methodGen . addLocalVariable ( "rt_to_reference_dom" , Util . getJCRefType ( DOM_INTF_SIG ) , null , null ) ; il . append ( new CHECKCAST ( cpg . addClass ( DOM_INTF_SIG ) ) ) ; il . append ( new ASTORE ( newDom . getIndex ( ) ) ) ; index = cpg . addMethodref ( DOM_IMPL , "getOutputDomBuilder" , "()" + TRANSLET_OUTPUT_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; domBuilder = methodGen . addLocalVariable ( "rt_to_reference_handler" , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) , null , null ) ; il . append ( new ASTORE ( domBuilder . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "startDocument" , "()V" ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; index = cpg . addMethodref ( className , _methodName , "(" + DOM_INTF_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( new ALOAD ( domBuilder . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "endDocument" , "()V" ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; il . append ( new ALOAD ( newDom . getIndex ( ) ) ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeSetType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; final int mapping = cpg . addInterfaceMethodref ( DOM_INTF , "setupMapping" , "([" + STRING_SIG + "[" + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( mapping , 3 ) ) ; il . append ( DUP ) ; final int iter = cpg . addInterfaceMethodref ( DOM_INTF , "getChildren" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( new PUSH ( cpg , DOM . ROOTNODE ) ) ; il . append ( new INVOKEINTERFACE ( iter , 2 ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; translateTo ( classGen , methodGen , Type . Boolean ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final String className = clazz . getName ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( className . equals ( "org.w3c.dom.Node" ) ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE , MAKE_NODE_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "org.w3c.dom.NodeList" ) ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE_LIST , MAKE_NODE_LIST_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "java.lang.Object" ) ) { il . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , className ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public String getClassName ( ) { return ( DOM_INTF ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	1	['22', '2', '0', '43', '58', '201', '9', '36', '21', '0.523809524', '715', '1', '0', '0.622641509', '0.199300699', '2', '4', '31.45454545', '7', '1.5455', '1']
package org . apache . xml . utils ; import org . w3c . dom . * ; import org . xml . sax . * ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . LocatorImpl ; import org . apache . xpath . DOM2Helper ; import org . apache . xpath . DOMHelper ; import org . apache . xml . utils . NodeConsumer ; public class TreeWalker { private ContentHandler m_contentHandler = null ; protected DOMHelper m_dh ; private LocatorImpl m_locator = new LocatorImpl ( ) ; public ContentHandler getContentHandler ( ) { return m_contentHandler ; } public void setContentHandler ( ContentHandler ch ) { m_contentHandler = ch ; } public TreeWalker ( ContentHandler contentHandler , DOMHelper dh , String systemId ) { this . m_contentHandler = contentHandler ; m_contentHandler . setDocumentLocator ( m_locator ) ; if ( systemId != null ) m_locator . setSystemId ( systemId ) ; else { try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { m_locator . setSystemId ( "" ) ; } } m_dh = dh ; } public TreeWalker ( ContentHandler contentHandler , DOMHelper dh ) { this . m_contentHandler = contentHandler ; m_contentHandler . setDocumentLocator ( m_locator ) ; try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { m_locator . setSystemId ( "" ) ; } m_dh = dh ; } public TreeWalker ( ContentHandler contentHandler ) { this . m_contentHandler = contentHandler ; if ( m_contentHandler != null ) m_contentHandler . setDocumentLocator ( m_locator ) ; try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { m_locator . setSystemId ( "" ) ; } m_dh = new org . apache . xpath . DOM2Helper ( ) ; } public void traverse ( Node pos ) throws org . xml . sax . SAXException { this . m_contentHandler . startDocument ( ) ; Node top = pos ; while ( null != pos ) { startNode ( pos ) ; Node nextNode = pos . getFirstChild ( ) ; while ( null == nextNode ) { endNode ( pos ) ; if ( top . equals ( pos ) ) break ; nextNode = pos . getNextSibling ( ) ; if ( null == nextNode ) { pos = pos . getParentNode ( ) ; if ( ( null == pos ) || ( top . equals ( pos ) ) ) { if ( null != pos ) endNode ( pos ) ; nextNode = null ; break ; } } } pos = nextNode ; } this . m_contentHandler . endDocument ( ) ; } public void traverse ( Node pos , Node top ) throws org . xml . sax . SAXException { this . m_contentHandler . startDocument ( ) ; while ( null != pos ) { startNode ( pos ) ; Node nextNode = pos . getFirstChild ( ) ; while ( null == nextNode ) { endNode ( pos ) ; if ( ( null != top ) && top . equals ( pos ) ) break ; nextNode = pos . getNextSibling ( ) ; if ( null == nextNode ) { pos = pos . getParentNode ( ) ; if ( ( null == pos ) || ( ( null != top ) && top . equals ( pos ) ) ) { nextNode = null ; break ; } } } pos = nextNode ; } this . m_contentHandler . endDocument ( ) ; } boolean nextIsRaw = false ; private final void dispatachChars ( Node node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler ) { ( ( org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler ) m_contentHandler ) . characters ( node ) ; } else { String data = ( ( Text ) node ) . getData ( ) ; this . m_contentHandler . characters ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } protected void startNode ( Node node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof NodeConsumer ) { ( ( NodeConsumer ) m_contentHandler ) . setOriginatingNode ( node ) ; } if ( node instanceof Locator ) { Locator loc = ( Locator ) node ; m_locator . setColumnNumber ( loc . getColumnNumber ( ) ) ; m_locator . setLineNumber ( loc . getLineNumber ( ) ) ; m_locator . setPublicId ( loc . getPublicId ( ) ) ; m_locator . setSystemId ( loc . getSystemId ( ) ) ; } else { m_locator . setColumnNumber ( 0 ) ; m_locator . setLineNumber ( 0 ) ; } switch ( node . getNodeType ( ) ) { case Node . COMMENT_NODE : { String data = ( ( Comment ) node ) . getData ( ) ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } break ; case Node . DOCUMENT_FRAGMENT_NODE : break ; case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : NamedNodeMap atts = ( ( Element ) node ) . getAttributes ( ) ; int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { Node attr = atts . item ( i ) ; String attrName = attr . getNodeName ( ) ; if ( attrName . equals ( "xmlns" ) || attrName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = attrName . indexOf ( ":" ) ) < 0 ? "" : attrName . substring ( index + 1 ) ; this . m_contentHandler . startPrefixMapping ( prefix , attr . getNodeValue ( ) ) ; } } String ns = m_dh . getNamespaceOfNode ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . startElement ( ns , m_dh . getLocalNameOfNode ( node ) , node . getNodeName ( ) , new AttList ( atts , m_dh ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : { ProcessingInstruction pi = ( ProcessingInstruction ) node ; String name = pi . getNodeName ( ) ; if ( name . equals ( "xslt-next-is-raw" ) ) { nextIsRaw = true ; } else { this . m_contentHandler . processingInstruction ( pi . getNodeName ( ) , pi . getData ( ) ) ; } } break ; case Node . CDATA_SECTION_NODE : { boolean isLexH = ( m_contentHandler instanceof LexicalHandler ) ; LexicalHandler lh = isLexH ? ( ( LexicalHandler ) this . m_contentHandler ) : null ; if ( isLexH ) { lh . startCDATA ( ) ; } dispatachChars ( node ) ; { if ( isLexH ) { lh . endCDATA ( ) ; } } } break ; case Node . TEXT_NODE : { if ( nextIsRaw ) { nextIsRaw = false ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; dispatachChars ( node ) ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { dispatachChars ( node ) ; } } break ; case Node . ENTITY_REFERENCE_NODE : { EntityReference eref = ( EntityReference ) node ; if ( m_contentHandler instanceof LexicalHandler ) { ( ( LexicalHandler ) this . m_contentHandler ) . startEntity ( eref . getNodeName ( ) ) ; } else { } } break ; default : } } protected void endNode ( Node node ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : String ns = m_dh . getNamespaceOfNode ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . endElement ( ns , m_dh . getLocalNameOfNode ( node ) , node . getNodeName ( ) ) ; NamedNodeMap atts = ( ( Element ) node ) . getAttributes ( ) ; int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { Node attr = atts . item ( i ) ; String attrName = attr . getNodeName ( ) ; if ( attrName . equals ( "xmlns" ) || attrName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = attrName . indexOf ( ":" ) ) < 0 ? "" : attrName . substring ( index + 1 ) ; this . m_contentHandler . endPrefixMapping ( prefix ) ; } } break ; case Node . CDATA_SECTION_NODE : break ; case Node . ENTITY_REFERENCE_NODE : { EntityReference eref = ( EntityReference ) node ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . endEntity ( eref . getNodeName ( ) ) ; } } break ; default : } } } 	0	['10', '1', '0', '12', '59', '0', '7', '5', '7', '0.305555556', '596', '0.75', '1', '0', '0.44', '0', '0', '58.2', '1', '0.7', '0']
package org . apache . xalan . templates ; import org . apache . xml . dtm . DTM ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . QName ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . ResultTreeHandler ; import org . apache . xpath . XPathContext ; import org . xml . sax . SAXException ; public class ElemAttribute extends ElemElement { public int getXSLToken ( ) { return Constants . ELEMNAME_ATTRIBUTE ; } public String getNodeName ( ) { return Constants . ELEMNAME_ATTRIBUTE_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { ResultTreeHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( ! rhandler . isElementPending ( ) ) { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; String attrName = m_name_avt . evaluate ( xctxt , sourceNode , this ) ; transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_ILLEGAL_ATTRIBUTE , new Object [ ] { attrName } ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; return ; } super . execute ( transformer ) ; } protected String resolvePrefix ( ResultTreeHandler rhandler , String prefix , String nodeNamespace ) throws TransformerException { if ( null != prefix && ( prefix . length ( ) == 0 || prefix . equals ( "xmlns" ) ) ) { prefix = rhandler . getPrefix ( nodeNamespace ) ; if ( null == prefix || prefix . length ( ) == 0 || prefix . equals ( "xmlns" ) ) { if ( nodeNamespace . length ( ) > 0 ) { prefix = rhandler . getNewUniqueNSPrefix ( ) ; } else prefix = "" ; } } return prefix ; } protected boolean validateNodeName ( String nodeName ) { if ( null == nodeName ) return false ; if ( nodeName . equals ( "xmlns" ) ) return false ; return super . validateNodeName ( nodeName ) ; } void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { if ( null != nodeName && nodeName . length ( ) > 0 ) { ResultTreeHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( prefix != null && prefix . length ( ) > 0 ) { try { rhandler . startPrefixMapping ( prefix , nodeNamespace , false ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } } String val = transformer . transformToString ( this ) ; String localName = QName . getLocalPart ( nodeName ) ; rhandler . addAttribute ( nodeNamespace , localName , nodeName , "CDATA" , val ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } public void setName ( AVT v ) { if ( v . isSimple ( ) ) { if ( v . getSimpleString ( ) . equals ( "xmlns" ) ) { throw new IllegalArgumentException ( ) ; } } super . setName ( v ) ; } } 	1	['9', '5', '0', '11', '39', '36', '1', '10', '6', '2', '195', '0', '0', '0.963800905', '0.314814815', '4', '7', '20.66666667', '16', '3', '2']
package org . apache . xalan . lib . sql ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTM ; import java . sql . SQLException ; public class SQLErrorDocument extends DTMDocument { private static final String S_EXT_ERROR = "ext-error" ; private static final String S_SQL_ERROR = "sql-error" ; private static final String S_MESSAGE = "message" ; private static final String S_CODE = "code" ; private int m_ErrorExt_TypeID = DTM . NULL ; private int m_Message_TypeID = DTM . NULL ; private int m_Code_TypeID = DTM . NULL ; private int m_SQLError_TypeID = DTM . NULL ; private int m_rootID = DTM . NULL ; private int m_extErrorID = DTM . NULL ; private int m_MainMessageID = DTM . NULL ; public SQLErrorDocument ( DTMManager mgr , int ident , SQLException error ) { super ( mgr , ident ) ; createExpandedNameTable ( ) ; buildBasicStructure ( error ) ; int sqlError = addElement ( 2 , m_SQLError_TypeID , m_extErrorID , m_MainMessageID ) ; int element = DTM . NULL ; element = addElementWithData ( new Integer ( error . getErrorCode ( ) ) , 3 , m_Code_TypeID , sqlError , element ) ; element = addElementWithData ( error . getLocalizedMessage ( ) , 3 , m_Message_TypeID , sqlError , element ) ; } public SQLErrorDocument ( DTMManager mgr , int ident , Exception error ) { super ( mgr , ident ) ; createExpandedNameTable ( ) ; buildBasicStructure ( error ) ; } private void buildBasicStructure ( Exception e ) { m_rootID = addElement ( 0 , m_Document_TypeID , DTM . NULL , DTM . NULL ) ; m_extErrorID = addElement ( 1 , m_ErrorExt_TypeID , m_rootID , DTM . NULL ) ; m_MainMessageID = addElementWithData ( e . getLocalizedMessage ( ) , 2 , m_Message_TypeID , m_extErrorID , DTM . NULL ) ; } protected void createExpandedNameTable ( ) { super . createExpandedNameTable ( ) ; m_ErrorExt_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_EXT_ERROR , DTM . ELEMENT_NODE ) ; m_SQLError_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SQL_ERROR , DTM . ELEMENT_NODE ) ; m_Message_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_MESSAGE , DTM . ELEMENT_NODE ) ; m_Code_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CODE , DTM . ELEMENT_NODE ) ; } } 	0	['4', '5', '0', '5', '12', '0', '1', '4', '2', '0.636363636', '179', '1', '0', '0.989528796', '0.55', '1', '1', '41', '1', '0.5', '0']
package org . apache . xpath . axes ; import java . io . Serializable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . utils . NodeVector ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class NodeSequence extends XObject implements DTMIterator , Cloneable , PathComponent { protected int m_last = - 1 ; protected int m_next = 0 ; protected NodeVector getVector ( ) { return ( NodeVector ) m_obj ; } protected void SetVector ( NodeVector v ) { m_obj = v ; } public boolean hasCache ( ) { return ( m_obj != null ) ; } protected DTMIterator m_iter ; public final void setIter ( DTMIterator iter ) { m_iter = iter ; } public final DTMIterator getContainedIter ( ) { return m_iter ; } protected DTMManager m_dtmMgr ; public NodeSequence ( DTMIterator iter , int context , XPathContext xctxt , boolean shouldCacheNodes ) { setIter ( iter ) ; setRoot ( context , xctxt ) ; setShouldCacheNodes ( shouldCacheNodes ) ; } public NodeSequence ( Object nodeVector ) { super ( nodeVector ) ; if ( null != nodeVector ) { assertion ( nodeVector instanceof NodeVector , "Must have a NodeVector as the object for NodeSequence!" ) ; if ( nodeVector instanceof DTMIterator ) { setIter ( ( DTMIterator ) nodeVector ) ; m_last = ( ( DTMIterator ) nodeVector ) . getLength ( ) ; } } } public NodeSequence ( DTMManager dtmMgr ) { super ( new NodeVector ( ) ) ; m_last = 0 ; m_dtmMgr = dtmMgr ; } public NodeSequence ( ) { } public DTM getDTM ( int nodeHandle ) { DTMManager mgr = getDTMManager ( ) ; if ( null != mgr ) return getDTMManager ( ) . getDTM ( nodeHandle ) ; else { assertion ( false , "Can not get a DTM Unless a DTMManager has been set!" ) ; return null ; } } public DTMManager getDTMManager ( ) { return m_dtmMgr ; } public int getRoot ( ) { if ( null != m_iter ) return m_iter . getRoot ( ) ; else { return DTM . NULL ; } } public void setRoot ( int nodeHandle , Object environment ) { if ( null != m_iter ) { XPathContext xctxt = ( XPathContext ) environment ; m_dtmMgr = xctxt . getDTMManager ( ) ; m_iter . setRoot ( nodeHandle , environment ) ; if ( ! m_iter . isDocOrdered ( ) ) { if ( ! hasCache ( ) ) setShouldCacheNodes ( true ) ; runTo ( - 1 ) ; m_next = 0 ; } } else assertion ( false , "Can not setRoot on a non-iterated NodeSequence!" ) ; } public void reset ( ) { m_next = 0 ; } public int getWhatToShow ( ) { return hasCache ( ) ? ( DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ) : m_iter . getWhatToShow ( ) ; } public boolean getExpandEntityReferences ( ) { if ( null != m_iter ) return m_iter . getExpandEntityReferences ( ) ; else return true ; } public int nextNode ( ) { NodeVector vec = getVector ( ) ; if ( null != vec ) { if ( m_next < vec . size ( ) ) { int next = vec . elementAt ( m_next ) ; m_next ++ ; return next ; } else if ( ( - 1 != m_last ) || ( null == m_iter ) ) { m_next ++ ; return DTM . NULL ; } } if ( null == m_iter ) return DTM . NULL ; int next = m_iter . nextNode ( ) ; if ( DTM . NULL != next ) { if ( hasCache ( ) ) { if ( m_iter . isDocOrdered ( ) ) { getVector ( ) . addElement ( next ) ; m_next ++ ; } else { int insertIndex = addNodeInDocOrder ( next ) ; if ( insertIndex >= 0 ) m_next ++ ; } } else m_next ++ ; } else { m_last = m_next ; m_next ++ ; } return next ; } public int previousNode ( ) { if ( hasCache ( ) ) { if ( m_next <= 0 ) return DTM . NULL ; else { m_next -- ; return item ( m_next ) ; } } else { int n = m_iter . previousNode ( ) ; m_next = m_iter . getCurrentPos ( ) ; return m_next ; } } public void detach ( ) { if ( null != m_iter ) m_iter . detach ( ) ; super . detach ( ) ; } public void allowDetachToRelease ( boolean allowRelease ) { if ( ( false == allowRelease ) && ! hasCache ( ) ) { setShouldCacheNodes ( true ) ; } if ( null != m_iter ) m_iter . allowDetachToRelease ( allowRelease ) ; super . allowDetachToRelease ( allowRelease ) ; } public int getCurrentNode ( ) { if ( hasCache ( ) ) { int currentIndex = m_next - 1 ; NodeVector vec = getVector ( ) ; if ( ( currentIndex >= 0 ) && ( currentIndex < vec . size ( ) ) ) return vec . elementAt ( currentIndex ) ; else return DTM . NULL ; } if ( null != m_iter ) { return m_iter . getCurrentNode ( ) ; } else return DTM . NULL ; } public boolean isFresh ( ) { return ( 0 == m_next ) ; } public void setShouldCacheNodes ( boolean b ) { if ( b ) { if ( ! hasCache ( ) ) { SetVector ( new NodeVector ( ) ) ; } } else SetVector ( null ) ; } public boolean isMutable ( ) { return hasCache ( ) ; } public int getCurrentPos ( ) { return m_next ; } public void runTo ( int index ) { int n ; if ( - 1 == index ) { int pos = m_next ; while ( DTM . NULL != ( n = nextNode ( ) ) ) ; m_next = pos ; } else if ( m_next == index ) { return ; } else if ( hasCache ( ) && m_next < getVector ( ) . size ( ) ) { m_next = index ; } else if ( ( null == getVector ( ) ) && ( index < m_next ) ) { while ( ( m_next >= index ) && DTM . NULL != ( n = previousNode ( ) ) ) ; } else { while ( ( m_next < index ) && DTM . NULL != ( n = nextNode ( ) ) ) ; } } public void setCurrentPos ( int i ) { runTo ( i ) ; } public int item ( int index ) { setCurrentPos ( index ) ; int n = nextNode ( ) ; m_next = index ; return n ; } public void setItem ( int node , int index ) { NodeVector vec = getVector ( ) ; if ( null != vec ) { vec . setElementAt ( node , index ) ; m_last = vec . size ( ) ; } else m_iter . setItem ( node , index ) ; } public int getLength ( ) { if ( hasCache ( ) ) { if ( - 1 == m_last ) { int pos = m_next ; runTo ( - 1 ) ; m_next = pos ; } return m_last ; } else { return m_iter . getLength ( ) ; } } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { NodeSequence seq = ( NodeSequence ) super . clone ( ) ; seq . m_next = 0 ; return seq ; } public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } public boolean isDocOrdered ( ) { if ( null != m_iter ) return m_iter . isDocOrdered ( ) ; else return true ; } public int getAxis ( ) { if ( null != m_iter ) return m_iter . getAxis ( ) ; else { assertion ( false , "Can not getAxis from a non-iterated node sequence!" ) ; return 0 ; } } public int getAnalysisBits ( ) { if ( ( null != m_iter ) && ( m_iter instanceof PathComponent ) ) return ( ( PathComponent ) m_iter ) . getAnalysisBits ( ) ; else return 0 ; } public void fixupVariables ( Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; } protected int addNodeInDocOrder ( int node ) { assertion ( hasCache ( ) , "addNodeInDocOrder must be done on a mutable sequence!" ) ; int insertIndex = - 1 ; NodeVector vec = getVector ( ) ; int size = vec . size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { int child = vec . elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } DTM dtm = m_dtmMgr . getDTM ( node ) ; if ( ! dtm . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; vec . insertElementAt ( node , insertIndex ) ; } return insertIndex ; } } 	1	['37', '3', '1', '18', '68', '218', '10', '8', '34', '0.625', '693', '1', '2', '0.682692308', '0.171171171', '2', '9', '17.62162162', '12', '2.2432', '4']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class ProcessingInstruction extends Instruction { private AttributeValue _name ; public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; _name = AttributeValue . create ( this , name , parser ) ; if ( name . equals ( "xml" ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_PI_ERR , "xml" ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _name . typeCheck ( stable ) ; typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; _name . translate ( classGen , methodGen ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , "stringValueHandler" , STRING_VALUE_HANDLER_SIG ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_VALUE_HANDLER , "getValueOfPI" , "()" + STRING_SIG ) ) ) ; final int processingInstruction = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "processingInstruction" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( processingInstruction , 3 ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	0	['4', '3', '0', '21', '26', '0', '0', '21', '3', '0.333333333', '123', '1', '1', '0.949152542', '0.4', '2', '5', '29.5', '2', '1', '0']
package org . apache . xalan . templates ; import org . apache . xml . utils . res . XResourceBundle ; public class Constants { public static final String S_XMLNAMESPACEURI = "http://www.w3.org/XML/1998/namespace" , S_XSLNAMESPACEURL = "http://www.w3.org/1999/XSL/Transform" , S_OLDXSLNAMESPACEURL = "http://www.w3.org/XSL/Transform/1.0" ; public static final String S_VENDOR = "Apache Software Foundation" , S_VENDORURL = "http://xml.apache.org" ; public static final String S_BUILTIN_EXTENSIONS_URL = "http://xml.apache.org/xslt" ; public static final String S_EXTENSIONS_JAVA_URL = "http://xml.apache.org/xslt/java" , S_EXTENSIONS_LOTUSXSL_JAVA_URL = "http://xsl.lotus.com/java" , S_EXTENSIONS_XALANLIB_URL = "http://xml.apache.org/xalan" ; public static final String S_EXSLT_COMMON_URL = "http://exslt.org/common" , S_EXSLT_MATH_URL = "http://exslt.org/math" , S_EXSLT_SETS_URL = "http://exslt.org/sets" , S_EXSLT_DATETIME_URL = "http://exslt.org/dates-and-times" , S_EXSLT_FUNCTIONS_URL = "http://exslt.org/functions" ; public static final double XSLTVERSUPPORTED = 1.0 ; public static final int ELEMNAME_UNDEFINED = - 1 , ELEMNAME_WITHPARAM = 2 , ELEMNAME_ADDATTRIBUTE = 4 , ELEMNAME_ANCHOR = 22 , ELEMNAME_APPLY_TEMPLATES = 50 , ELEMNAME_USE = 34 , ELEMNAME_CHILDREN = 6 , ELEMNAME_CHOOSE = 37 , ELEMNAME_COMMENT = 59 , ELEMNAME_CONSTRUCT = 7 , ELEMNAME_CONTENTS = 8 , ELEMNAME_COPY = 9 , ELEMNAME_COPY_OF = 74 , ELEMNAME_DECIMALFORMAT = 83 , ELEMNAME_DEFINEATTRIBUTESET = 40 , ELEMNAME_DEFINESCRIPT = 11 , ELEMNAME_DISPLAYIF = 12 , ELEMNAME_EMPTY = 14 , ELEMNAME_EVAL = 15 , ELEMNAME_EXPECTEDCHILDREN = 16 , ELEMNAME_EXTENSION = 54 , ELEMNAME_EXTENSIONHANDLER = 63 , ELEMNAME_FOREACH = 28 , ELEMNAME_KEY = 31 , ELEMNAME_IF = 36 , ELEMNAME_IMPORT = 26 , ELEMNAME_INCLUDE = 27 , ELEMNAME_CALLTEMPLATE = 17 , ELEMNAME_PARAMVARIABLE = 41 , ELEMNAME_NUMBER = 35 , ELEMNAME_NSALIAS = 84 , ELEMNAME_OTHERWISE = 39 , ELEMNAME_PI = 58 , ELEMNAME_PRESERVESPACE = 33 , ELEMNAME_REMOVEATTRIBUTE = 5 , ELEMNAME_TEMPLATE = 19 , ELEMNAME_SORT = 64 , ELEMNAME_STRIPSPACE = 32 , ELEMNAME_STYLESHEET = 25 , ELEMNAME_TEXT = 42 , ELEMNAME_VALUEOF = 30 , ELEMNAME_WHEN = 38 , ELEMNAME_ROOT = 44 , ELEMNAME_ANY = 45 , ELEMNAME_ELEMENT = 46 , ELEMNAME_TARGETELEMENT = 47 , ELEMNAME_ATTRIBUTE = 48 , ELEMNAME_TARGETATTRIBUTE = 49 , ELEMNAME_URL = 52 , ELEMNAME_CALL = 55 , ELEMNAME_FALLBACK = 57 , ELEMNAME_TARGETPI = 60 , ELEMNAME_TARGETCOMMENT = 61 , ELEMNAME_TARGETTEXT = 62 , ELEMNAME_CSSSTYLECONVERSION = 65 , ELEMNAME_COUNTER = 66 , ELEMNAME_COUNTERS = 67 , ELEMNAME_COUNTERINCREMENT = 68 , ELEMNAME_COUNTERRESET = 69 , ELEMNAME_COUNTERSCOPE = 71 , ELEMNAME_APPLY_IMPORTS = 72 , ELEMNAME_VARIABLE = 73 , ELEMNAME_MESSAGE = 75 , ELEMNAME_LOCALE = 76 , ELEMNAME_LITERALRESULT = 77 , ELEMNAME_TEXTLITERALRESULT = 78 , ELEMNAME_EXTENSIONCALL = 79 , ELEMNAME_EXTENSIONDECL = 85 , ELEMNAME_EXTENSIONSCRIPT = 86 , ELEMNAME_OUTPUT = 80 , ELEMNAME_COMPONENT = 81 , ELEMNAME_SCRIPT = 82 ; public static final String ELEMNAME_ANCHOR_STRING = "anchor" , ELEMNAME_ANY_STRING = "any" , ELEMNAME_APPLY_IMPORTS_STRING = "apply-imports" , ELEMNAME_APPLY_TEMPLATES_STRING = "apply-templates" , ELEMNAME_ARG_STRING = "arg" , ELEMNAME_ATTRIBUTESET_STRING = "attribute-set" , ELEMNAME_ATTRIBUTE_STRING = "attribute" , ELEMNAME_CALLTEMPLATEARG_STRING = "invoke-arg" , ELEMNAME_CALLTEMPLATE_STRING = "call-template" , ELEMNAME_CALL_STRING = "call" , ELEMNAME_CHILDREN_STRING = "children" , ELEMNAME_CHOOSE_STRING = "choose" , ELEMNAME_COMMENT_STRING = "comment" , ELEMNAME_COMPONENT_STRING = "component" , ELEMNAME_CONSTRUCT_STRING = "construct" , ELEMNAME_CONTENTS_STRING = "contents" , ELEMNAME_COPY_OF_STRING = "copy-of" , ELEMNAME_COPY_STRING = "copy" , ELEMNAME_COUNTERINCREMENT_STRING = "counter-increment" , ELEMNAME_COUNTERRESET_STRING = "counter-reset" , ELEMNAME_COUNTERSCOPE_STRING = "counter-scope" , ELEMNAME_COUNTERS_STRING = "counters" , ELEMNAME_COUNTER_STRING = "counter" , ELEMNAME_CSSSTYLECONVERSION_STRING = "css-style-conversion" , ELEMNAME_DECIMALFORMAT_STRING = "decimal-format" , ELEMNAME_DISPLAYIF_STRING = "display-if" , ELEMNAME_ELEMENT_STRING = "element" , ELEMNAME_EMPTY_STRING = "empty" , ELEMNAME_EVAL_STRING = "eval" , ELEMNAME_EXPECTEDCHILDREN_STRING = "expectedchildren" , ELEMNAME_EXTENSIONHANDLER_STRING = "code-dispatcher" , ELEMNAME_EXTENSION_STRING = "functions" , ELEMNAME_FALLBACK_STRING = "fallback" , ELEMNAME_FOREACH_STRING = "for-each" , ELEMNAME_IF_STRING = "if" , ELEMNAME_IMPORT_STRING = "import" , ELEMNAME_INCLUDE_STRING = "include" , ELEMNAME_KEY_STRING = "key" , ELEMNAME_LOCALE_STRING = "locale" , ELEMNAME_MESSAGE_STRING = "message" , ELEMNAME_NSALIAS_STRING = "namespace-alias" , ELEMNAME_NUMBER_STRING = "number" , ELEMNAME_OTHERWISE_STRING = "otherwise" , ELEMNAME_OUTPUT_STRING = "output" , ELEMNAME_PARAMVARIABLE_STRING = "param" , ELEMNAME_PI_OLD_STRING = "pi" , ELEMNAME_PI_STRING = "processing-instruction" , ELEMNAME_PRESERVESPACE_STRING = "preserve-space" , ELEMNAME_ROOT_STRING = "root" , ELEMNAME_SCRIPT_STRING = "script" , ELEMNAME_SORT_STRING = "sort" , ELEMNAME_STRIPSPACE_STRING = "strip-space" , ELEMNAME_STYLESHEET_STRING = "stylesheet" , ELEMNAME_TARGETATTRIBUTE_STRING = "target-attribute" , ELEMNAME_TARGETCOMMENT_STRING = "target-comment" , ELEMNAME_TARGETELEMENT_STRING = "target-element" , ELEMNAME_TARGETPI_STRING = "target-pi" , ELEMNAME_TARGETTEXT_STRING = "target-text" , ELEMNAME_TEMPLATE_STRING = "template" , ELEMNAME_TEXT_STRING = "text" , ELEMNAME_TRANSFORM_STRING = "transform" , ELEMNAME_URL_STRING = "uri" , ELEMNAME_USE_STRING = "use" , ELEMNAME_VALUEOF_STRING = "value-of" , ELEMNAME_VARIABLE_STRING = "variable" , ELEMNAME_WHEN_STRING = "when" , ELEMNAME_WITHPARAM_STRING = "with-param" ; public static final String EXSLT_ELEMNAME_FUNCTION_STRING = "function" , EXSLT_ELEMNAME_FUNCRESULT_STRING = "result" ; public static final int EXSLT_ELEMNAME_FUNCTION = 88 , EXSLT_ELEMNAME_FUNCRESULT = 89 ; public static final String ATTRNAME_AMOUNT = "amount" , ATTRNAME_ANCESTOR = "ancestor" , ATTRNAME_ARCHIVE = "archive" , ATTRNAME_ATTRIBUTE = "attribute" , ATTRNAME_ATTRIBUTE_SET = "attribute-set" , ATTRNAME_CASEORDER = "case-order" , ATTRNAME_CLASS = "class" , ATTRNAME_CLASSID = "classid" , ATTRNAME_CODEBASE = "codebase" , ATTRNAME_CODETYPE = "type" , ATTRNAME_CONDITION = "condition" , ATTRNAME_COPYTYPE = "copy-type" , ATTRNAME_COUNT = "count" , ATTRNAME_DATATYPE = "data-type" , ATTRNAME_DECIMALSEPARATOR = "decimal-separator" , ATTRNAME_DEFAULT = "default" , ATTRNAME_DEFAULTSPACE = "default-space" , ATTRNAME_DEPTH = "with-children" , ATTRNAME_DIGIT = "digit" , ATTRNAME_DIGITGROUPSEP = "digit-group-sep" , ATTRNAME_DISABLE_OUTPUT_ESCAPING = "disable-output-escaping" , ATTRNAME_ELEMENT = "element" , ATTRNAME_ELEMENTS = "elements" , ATTRNAME_EXCLUDE_RESULT_PREFIXES = "exclude-result-prefixes" , ATTRNAME_EXPR = "expr" , ATTRNAME_EXTENSIONELEMENTPREFIXES = "extension-element-prefixes" , ATTRNAME_FORMAT = "format" , ATTRNAME_FROM = "from" , ATTRNAME_GROUPINGSEPARATOR = "grouping-separator" , ATTRNAME_GROUPINGSIZE = "grouping-size" , ATTRNAME_HREF = "href" , ATTRNAME_ID = "id" , ATTRNAME_IMPORTANCE = "importance" , ATTRNAME_INDENTRESULT = "indent-result" , ATTRNAME_INFINITY = "infinity" , ATTRNAME_LANG = "lang" , ATTRNAME_LETTERVALUE = "letter-value" , ATTRNAME_LEVEL = "level" , ATTRNAME_MATCH = "match" , ATTRNAME_METHOD = "calls" , ATTRNAME_MINUSSIGN = "minus-sign" , ATTRNAME_MODE = "mode" , ATTRNAME_NAME = "name" , ATTRNAME_NAMESPACE = "namespace" , ATTRNAME_NAN = "NaN" , ATTRNAME_NDIGITSPERGROUP = "n-digits-per-group" , ATTRNAME_NS = "ns" , ATTRNAME_ONLY = "only" , ATTRNAME_ORDER = "order" , ATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = "cdata-section-elements" , ATTRNAME_OUTPUT_DOCTYPE_PUBLIC = "doctype-public" , ATTRNAME_OUTPUT_DOCTYPE_SYSTEM = "doctype-system" , ATTRNAME_OUTPUT_ENCODING = "encoding" , ATTRNAME_OUTPUT_INDENT = "indent" , ATTRNAME_OUTPUT_MEDIATYPE = "media-type" , ATTRNAME_OUTPUT_METHOD = "method" , ATTRNAME_OUTPUT_OMITXMLDECL = "omit-xml-declaration" , ATTRNAME_OUTPUT_STANDALONE = "standalone" , ATTRNAME_OUTPUT_VERSION = "version" , ATTRNAME_PATTERNSEPARATOR = "pattern-separator" , ATTRNAME_PERCENT = "percent" , ATTRNAME_PERMILLE = "per-mille" , ATTRNAME_PRIORITY = "priority" , ATTRNAME_REFID = "refID" , ATTRNAME_RESULTNS = "result-ns" , ATTRNAME_RESULT_PREFIX = "result-prefix" , ATTRNAME_SELECT = "select" , ATTRNAME_SEQUENCESRC = "sequence-src" , ATTRNAME_STYLE = "style" , ATTRNAME_STYLESHEET_PREFIX = "stylesheet-prefix" , ATTRNAME_TERMINATE = "terminate" , ATTRNAME_TEST = "test" , ATTRNAME_TOSTRING = "to-string" , ATTRNAME_TYPE = "type" , ATTRNAME_USE = "use" , ATTRNAME_USEATTRIBUTESETS = "use-attribute-sets" , ATTRNAME_VALUE = "value" , ATTRNAME_VERSION = "version" , ATTRNAME_XMLNS = "xmlns:" , ATTRNAME_XMLNSDEF = "xmlns" , ATTRNAME_XMLSPACE = "xml:space" , ATTRNAME_ZERODIGIT = "zero-digit" ; public static final int TATTRNAME_OUTPUT_METHOD = 1 , TATTRNAME_AMOUNT = 2 , TATTRNAME_ANCESTOR = 3 , TATTRNAME_ARCHIVE = 4 , TATTRNAME_ATTRIBUTE = 5 , TATTRNAME_ATTRIBUTE_SET = 6 , TATTRNAME_CASEORDER = 7 , TATTRNAME_CLASS = 8 , TATTRNAME_CLASSID = 9 , TATTRNAME_CODEBASE = 10 , TATTRNAME_CODETYPE = 11 , TATTRNAME_CONDITION = 12 , TATTRNAME_COPYTYPE = 13 , TATTRNAME_COUNT = 14 , TATTRNAME_DATATYPE = 15 , TATTRNAME_DEFAULT = 16 , TATTRNAME_DEFAULTSPACE = 17 , TATTRNAME_DEPTH = 18 , TATTRNAME_DIGITGROUPSEP = 19 , TATTRNAME_DISABLE_OUTPUT_ESCAPING = 20 , TATTRNAME_ELEMENT = 21 , TATTRNAME_ELEMENTS = 22 , TATTRNAME_EXPR = 23 , TATTRNAME_EXTENSIONELEMENTPREFIXES = 24 , TATTRNAME_FORMAT = 25 , TATTRNAME_FROM = 26 , TATTRNAME_GROUPINGSEPARATOR = 27 , TATTRNAME_GROUPINGSIZE = 28 , TATTRNAME_HREF = 29 , TATTRNAME_ID = 30 , TATTRNAME_IMPORTANCE = 31 , TATTRNAME_INDENTRESULT = 32 , TATTRNAME_LANG = 33 , TATTRNAME_LETTERVALUE = 34 , TATTRNAME_LEVEL = 35 , TATTRNAME_MATCH = 36 , TATTRNAME_METHOD = 37 , TATTRNAME_MODE = 38 , TATTRNAME_NAME = 39 , TATTRNAME_NAMESPACE = 40 , TATTRNAME_NDIGITSPERGROUP = 41 , TATTRNAME_NS = 42 , TATTRNAME_ONLY = 43 , TATTRNAME_ORDER = 44 , TATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = 45 , TATTRNAME_OUTPUT_DOCTYPE_PUBLIC = 46 , TATTRNAME_OUTPUT_DOCTYPE_SYSTEM = 47 , TATTRNAME_OUTPUT_ENCODING = 48 , TATTRNAME_OUTPUT_INDENT = 49 , TATTRNAME_OUTPUT_MEDIATYPE = 50 , TATTRNAME_OUTPUT_STANDALONE = 51 , TATTRNAME_OUTPUT_VERSION = 52 , TATTRNAME_OUTPUT_OMITXMLDECL = 53 , TATTRNAME_PRIORITY = 54 , TATTRNAME_REFID = 55 , TATTRNAME_RESULTNS = 56 , TATTRNAME_SELECT = 57 , TATTRNAME_SEQUENCESRC = 58 , TATTRNAME_STYLE = 59 , TATTRNAME_TEST = 60 , TATTRNAME_TOSTRING = 61 , TATTRNAME_TYPE = 62 , TATTRNAME_USE = 63 , TATTRNAME_USEATTRIBUTESETS = 64 , TATTRNAME_VALUE = 65 , TATTRNAME_XMLNSDEF = 66 , TATTRNAME_XMLNS = 67 , TATTRNAME_XMLSPACE = 68 , TATTRNAME_EXCLUDE_RESULT_PREFIXES = 69 ; public static final String ATTRVAL_OUTPUT_METHOD_HTML = "html" , ATTRVAL_OUTPUT_METHOD_XML = "xml" , ATTRVAL_OUTPUT_METHOD_TEXT = "text" ; public static final int ATTRVAL_PRESERVE = 1 , ATTRVAL_STRIP = 2 ; public static final boolean ATTRVAL_YES = true , ATTRVAL_NO = false ; public static final String ATTRVAL_ALPHABETIC = "alphabetic" , ATTRVAL_OTHER = "other" , ATTRVAL_TRADITIONAL = "traditional" ; public static final String ATTRVAL_SINGLE = "single" , ATTRVAL_MULTI = "multiple" , ATTRVAL_ANY = "any" ; public static final String ATTRVAL_DEFAULT_PREFIX = "#default" ; public static final int NUMBERLETTER_ALPHABETIC = 1 , NUMBERLETTER_TRADITIONAL = 2 ; public static final int NUMBERLEVEL_SINGLE = 1 , NUMBERLEVEL_MULTI = 2 , NUMBERLEVEL_ANY = 3 , MAX_MULTI_COUNTING_DEPTH = 32 ; public static final String ATTRVAL_THIS = "." , ATTRVAL_PARENT = ".." , ATTRVAL_ANCESTOR = "ancestor" , ATTRVAL_ID = "id" ; public static final String ATTRVAL_DATATYPE_TEXT = "text" , ATTRVAL_DATATYPE_NUMBER = "number" , ATTRVAL_ORDER_ASCENDING = "ascending" , ATTRVAL_ORDER_DESCENDING = "descending" , ATTRVAL_CASEORDER_UPPER = "upper-first" , ATTRVAL_CASEORDER_LOWER = "lower-first" ; public static final int SORTDATATYPE_TEXT = 1 , SORTDATATYPE_NUMBER = 2 ; public static final int SORTORDER_ASCENDING = 1 , SORTORDER_DESCENDING = 2 ; public static final int SORTCASEORDER_UPPERFIRST = 1 , SORTCASEORDER_LOWERFIRST = 2 ; public static final String ATTRVAL_INFINITY = "Infinity" , ATTRVAL_NAN = "NaN" , DEFAULT_DECIMAL_FORMAT = "#default" ; public static final String ATTRNAME_XXXX = "XXXX" ; } 	1	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '353', '0', '0', '0', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xml . utils ; public class StringToIntTable { public static final int INVALID_KEY = - 10000 ; private int m_blocksize ; private String m_map [ ] ; private int m_values [ ] ; private int m_firstFree = 0 ; private int m_mapSize ; public StringToIntTable ( ) { m_blocksize = 8 ; m_mapSize = m_blocksize ; m_map = new String [ m_blocksize ] ; m_values = new int [ m_blocksize ] ; } public StringToIntTable ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new String [ blocksize ] ; m_values = new int [ m_blocksize ] ; } public final int getLength ( ) { return m_firstFree ; } public final void put ( String key , int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; int newValues [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_values , 0 , newValues , 0 , m_firstFree + 1 ) ; m_values = newValues ; } m_map [ m_firstFree ] = key ; m_values [ m_firstFree ] = value ; m_firstFree ++ ; } public final int get ( String key ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( key ) ) return m_values [ i ] ; } return INVALID_KEY ; } public final int getIgnoreCase ( String key ) { if ( null == key ) return INVALID_KEY ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equalsIgnoreCase ( key ) ) return m_values [ i ] ; } return INVALID_KEY ; } public final boolean contains ( String key ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( key ) ) return true ; } return false ; } public final String [ ] keys ( ) { String [ ] keysArr = new String [ m_firstFree ] ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { keysArr [ i ] = m_map [ i ] ; } return keysArr ; } } 	0	['8', '1', '0', '2', '12', '0', '2', '0', '8', '0.523809524', '217', '0.833333333', '0', '0', '0.583333333', '0', '0', '25.375', '4', '1.875', '0']
package org . apache . xalan . res ; import java . io . IOException ; import java . io . InputStream ; import java . text . DecimalFormat ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; public class XSLTErrorResources extends PropertyResourceBundle { public XSLTErrorResources ( ) throws java . io . IOException { super ( null ) ; } public XSLTErrorResources ( InputStream is ) throws java . io . IOException { super ( is ) ; } public static final String ERROR_SUFFIX = "ER" ; public static final String WARNING_SUFFIX = "WR" ; public static final int ERROR0000 = 0 ; public static final int ER_NO_CURLYBRACE = 1 ; public static final int ER_ILLEGAL_ATTRIBUTE = 2 ; public static final int ER_NULL_SOURCENODE_APPLYIMPORTS = 3 ; public static final int ER_CANNOT_ADD = 4 ; public static final int ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = 5 ; public static final int ER_NO_NAME_ATTRIB = 6 ; public static final int ER_TEMPLATE_NOT_FOUND = 7 ; public static final int ER_CANT_RESOLVE_NAME_AVT = 8 ; public static final int ER_REQUIRES_ATTRIB = 9 ; public static final int ER_MUST_HAVE_TEST_ATTRIB = 10 ; public static final int ER_BAD_VAL_ON_LEVEL_ATTRIB = 11 ; public static final int ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = 12 ; public static final int ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = 13 ; public static final int ER_NEED_MATCH_ATTRIB = 14 ; public static final int ER_NEED_NAME_OR_MATCH_ATTRIB = 15 ; public static final int ER_CANT_RESOLVE_NSPREFIX = 16 ; public static final int ER_ILLEGAL_VALUE = 17 ; public static final int ER_NO_OWNERDOC = 18 ; public static final int ER_ELEMTEMPLATEELEM_ERR = 19 ; public static final int ER_NULL_CHILD = 20 ; public static final int ER_NEED_SELECT_ATTRIB = 21 ; public static final int ER_NEED_TEST_ATTRIB = 22 ; public static final int ER_NEED_NAME_ATTRIB = 23 ; public static final int ER_NO_CONTEXT_OWNERDOC = 24 ; public static final int ER_COULD_NOT_CREATE_XML_PROC_LIAISON = 25 ; public static final int ER_PROCESS_NOT_SUCCESSFUL = 26 ; public static final int ER_NOT_SUCCESSFUL = 27 ; public static final int ER_ENCODING_NOT_SUPPORTED = 28 ; public static final int ER_COULD_NOT_CREATE_TRACELISTENER = 29 ; public static final int ER_KEY_REQUIRES_NAME_ATTRIB = 30 ; public static final int ER_KEY_REQUIRES_MATCH_ATTRIB = 31 ; public static final int ER_KEY_REQUIRES_USE_ATTRIB = 32 ; public static final int ER_REQUIRES_ELEMENTS_ATTRIB = 33 ; public static final int ER_MISSING_PREFIX_ATTRIB = 34 ; public static final int ER_BAD_STYLESHEET_URL = 35 ; public static final int ER_FILE_NOT_FOUND = 36 ; public static final int ER_IOEXCEPTION = 37 ; public static final int ER_NO_HREF_ATTRIB = 38 ; public static final int ER_STYLESHEET_INCLUDES_ITSELF = 39 ; public static final int ER_PROCESSINCLUDE_ERROR = 40 ; public static final int ER_MISSING_LANG_ATTRIB = 41 ; public static final int ER_MISSING_CONTAINER_ELEMENT_COMPONENT = 42 ; public static final int ER_CAN_ONLY_OUTPUT_TO_ELEMENT = 43 ; public static final int ER_PROCESS_ERROR = 44 ; public static final int ER_UNIMPLNODE_ERROR = 45 ; public static final int ER_NO_SELECT_EXPRESSION = 46 ; public static final int ER_CANNOT_SERIALIZE_XSLPROCESSOR = 47 ; public static final int ER_NO_INPUT_STYLESHEET = 48 ; public static final int ER_FAILED_PROCESS_STYLESHEET = 49 ; public static final int ER_COULDNT_PARSE_DOC = 50 ; public static final int ER_COULDNT_FIND_FRAGMENT = 51 ; public static final int ER_NODE_NOT_ELEMENT = 52 ; public static final int ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = 53 ; public static final int ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = 54 ; public static final int ER_NO_CLONE_OF_DOCUMENT_FRAG = 55 ; public static final int ER_CANT_CREATE_ITEM = 56 ; public static final int ER_XMLSPACE_ILLEGAL_VALUE = 57 ; public static final int ER_NO_XSLKEY_DECLARATION = 58 ; public static final int ER_CANT_CREATE_URL = 59 ; public static final int ER_XSLFUNCTIONS_UNSUPPORTED = 60 ; public static final int ER_PROCESSOR_ERROR = 61 ; public static final int ER_NOT_ALLOWED_INSIDE_STYLESHEET = 62 ; public static final int ER_RESULTNS_NOT_SUPPORTED = 63 ; public static final int ER_DEFAULTSPACE_NOT_SUPPORTED = 64 ; public static final int ER_INDENTRESULT_NOT_SUPPORTED = 65 ; public static final int ER_ILLEGAL_ATTRIB = 66 ; public static final int ER_UNKNOWN_XSL_ELEM = 67 ; public static final int ER_BAD_XSLSORT_USE = 68 ; public static final int ER_MISPLACED_XSLWHEN = 69 ; public static final int ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = 70 ; public static final int ER_MISPLACED_XSLOTHERWISE = 71 ; public static final int ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = 72 ; public static final int ER_NOT_ALLOWED_INSIDE_TEMPLATE = 73 ; public static final int ER_UNKNOWN_EXT_NS_PREFIX = 74 ; public static final int ER_IMPORTS_AS_FIRST_ELEM = 75 ; public static final int ER_IMPORTING_ITSELF = 76 ; public static final int ER_XMLSPACE_ILLEGAL_VAL = 77 ; public static final int ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = 78 ; public static final int ER_SAX_EXCEPTION = 79 ; public static final int ER_FUNCTION_NOT_SUPPORTED = 80 ; public static final int ER_XSLT_ERROR = 81 ; public static final int ER_CURRENCY_SIGN_ILLEGAL = 82 ; public static final int ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = 83 ; public static final int ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = 84 ; public static final int ER_REDIRECT_COULDNT_GET_FILENAME = 85 ; public static final int ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = 86 ; public static final int ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = 87 ; public static final int ER_MISSING_NS_URI = 88 ; public static final int ER_MISSING_ARG_FOR_OPTION = 89 ; public static final int ER_INVALID_OPTION = 90 ; public static final int ER_MALFORMED_FORMAT_STRING = 91 ; public static final int ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = 92 ; public static final int ER_ILLEGAL_ATTRIBUTE_VALUE = 93 ; public static final int ER_CHOOSE_REQUIRES_WHEN = 94 ; public static final int ER_NO_APPLY_IMPORT_IN_FOR_EACH = 95 ; public static final int ER_CANT_USE_DTM_FOR_OUTPUT = 96 ; public static final int ER_CANT_USE_DTM_FOR_INPUT = 97 ; public static final int ER_CALL_TO_EXT_FAILED = 98 ; public static final int ER_PREFIX_MUST_RESOLVE = 99 ; public static final int ER_INVALID_UTF16_SURROGATE = 100 ; public static final int ER_XSLATTRSET_USED_ITSELF = 101 ; public static final int ER_CANNOT_MIX_XERCESDOM = 102 ; public static final int ER_TOO_MANY_LISTENERS = 103 ; public static final int ER_IN_ELEMTEMPLATEELEM_READOBJECT = 104 ; public static final int ER_DUPLICATE_NAMED_TEMPLATE = 105 ; public static final int ER_INVALID_KEY_CALL = 106 ; public static final int ER_REFERENCING_ITSELF = 107 ; public static final int ER_ILLEGAL_DOMSOURCE_INPUT = 108 ; public static final int ER_CLASS_NOT_FOUND_FOR_OPTION = 109 ; public static final int ER_REQUIRED_ELEM_NOT_FOUND = 110 ; public static final int ER_INPUT_CANNOT_BE_NULL = 111 ; public static final int ER_URI_CANNOT_BE_NULL = 112 ; public static final int ER_FILE_CANNOT_BE_NULL = 113 ; public static final int ER_SOURCE_CANNOT_BE_NULL = 114 ; public static final int ER_CANNOT_OVERWRITE_CAUSE = 115 ; public static final int ER_CANNOT_INIT_BSFMGR = 116 ; public static final int ER_CANNOT_CMPL_EXTENSN = 117 ; public static final int ER_CANNOT_CREATE_EXTENSN = 118 ; public static final int ER_INSTANCE_MTHD_CALL_REQUIRES = 119 ; public static final int ER_INVALID_ELEMENT_NAME = 120 ; public static final int ER_ELEMENT_NAME_METHOD_STATIC = 121 ; public static final int ER_EXTENSION_FUNC_UNKNOWN = 122 ; public static final int ER_MORE_MATCH_CONSTRUCTOR = 123 ; public static final int ER_MORE_MATCH_METHOD = 124 ; public static final int ER_MORE_MATCH_ELEMENT = 125 ; public static final int ER_INVALID_CONTEXT_PASSED = 126 ; public static final int ER_POOL_EXISTS = 127 ; public static final int ER_NO_DRIVER_NAME = 128 ; public static final int ER_NO_URL = 129 ; public static final int ER_POOL_SIZE_LESSTHAN_ONE = 130 ; public static final int ER_INVALID_DRIVER = 131 ; public static final int ER_NO_STYLESHEETROOT = 132 ; public static final int ER_ILLEGAL_XMLSPACE_VALUE = 133 ; public static final int ER_PROCESSFROMNODE_FAILED = 134 ; public static final int ER_RESOURCE_COULD_NOT_LOAD = 135 ; public static final int ER_BUFFER_SIZE_LESSTHAN_ZERO = 136 ; public static final int ER_UNKNOWN_ERROR_CALLING_EXTENSION = 137 ; public static final int ER_NO_NAMESPACE_DECL = 138 ; public static final int ER_ELEM_CONTENT_NOT_ALLOWED = 139 ; public static final int ER_STYLESHEET_DIRECTED_TERMINATION = 140 ; public static final int ER_ONE_OR_TWO = 141 ; public static final int ER_TWO_OR_THREE = 142 ; public static final int ER_COULD_NOT_LOAD_RESOURCE = 143 ; public static final int ER_CANNOT_INIT_DEFAULT_TEMPLATES = 144 ; public static final int ER_RESULT_NULL = 145 ; public static final int ER_RESULT_COULD_NOT_BE_SET = 146 ; public static final int ER_NO_OUTPUT_SPECIFIED = 147 ; public static final int ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = 148 ; public static final int ER_CANNOT_TRANSFORM_SOURCE_TYPE = 149 ; public static final int ER_NULL_CONTENT_HANDLER = 150 ; public static final int ER_NULL_ERROR_HANDLER = 151 ; public static final int ER_CANNOT_CALL_PARSE = 152 ; public static final int ER_NO_PARENT_FOR_FILTER = 153 ; public static final int ER_NO_STYLESHEET_IN_MEDIA = 154 ; public static final int ER_NO_STYLESHEET_PI = 155 ; public static final int ER_NO_DEFAULT_IMPL = 156 ; public static final int ER_CHUNKEDINTARRAY_NOT_SUPPORTED = 157 ; public static final int ER_OFFSET_BIGGER_THAN_SLOT = 158 ; public static final int ER_COROUTINE_NOT_AVAIL = 159 ; public static final int ER_COROUTINE_CO_EXIT = 160 ; public static final int ER_COJOINROUTINESET_FAILED = 161 ; public static final int ER_COROUTINE_PARAM = 162 ; public static final int ER_PARSER_DOTERMINATE_ANSWERS = 163 ; public static final int ER_NO_PARSE_CALL_WHILE_PARSING = 164 ; public static final int ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = 165 ; public static final int ER_ITERATOR_AXIS_NOT_IMPLEMENTED = 166 ; public static final int ER_ITERATOR_CLONE_NOT_SUPPORTED = 167 ; public static final int ER_UNKNOWN_AXIS_TYPE = 168 ; public static final int ER_AXIS_NOT_SUPPORTED = 169 ; public static final int ER_NO_DTMIDS_AVAIL = 170 ; public static final int ER_NOT_SUPPORTED = 171 ; public static final int ER_NODE_NON_NULL = 172 ; public static final int ER_COULD_NOT_RESOLVE_NODE = 173 ; public static final int ER_STARTPARSE_WHILE_PARSING = 174 ; public static final int ER_STARTPARSE_NEEDS_SAXPARSER = 175 ; public static final int ER_COULD_NOT_INIT_PARSER = 176 ; public static final int ER_PROPERTY_VALUE_BOOLEAN = 177 ; public static final int ER_EXCEPTION_CREATING_POOL = 178 ; public static final int ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = 179 ; public static final int ER_SCHEME_REQUIRED = 180 ; public static final int ER_NO_SCHEME_IN_URI = 181 ; public static final int ER_NO_SCHEME_INURI = 182 ; public static final int ER_PATH_INVALID_CHAR = 183 ; public static final int ER_SCHEME_FROM_NULL_STRING = 184 ; public static final int ER_SCHEME_NOT_CONFORMANT = 185 ; public static final int ER_HOST_ADDRESS_NOT_WELLFORMED = 186 ; public static final int ER_PORT_WHEN_HOST_NULL = 187 ; public static final int ER_INVALID_PORT = 188 ; public static final int ER_FRAG_FOR_GENERIC_URI = 189 ; public static final int ER_FRAG_WHEN_PATH_NULL = 190 ; public static final int ER_FRAG_INVALID_CHAR = 191 ; public static final int ER_PARSER_IN_USE = 192 ; public static final int ER_CANNOT_CHANGE_WHILE_PARSING = 193 ; public static final int ER_SELF_CAUSATION_NOT_PERMITTED = 194 ; public static final int ER_COULD_NOT_FIND_EXTERN_SCRIPT = 195 ; public static final int ER_RESOURCE_COULD_NOT_FIND = 196 ; public static final int ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = 197 ; public static final int ER_NO_USERINFO_IF_NO_HOST = 198 ; public static final int ER_NO_PORT_IF_NO_HOST = 199 ; public static final int ER_NO_QUERY_STRING_IN_PATH = 200 ; public static final int ER_NO_FRAGMENT_STRING_IN_PATH = 201 ; public static final int ER_CANNOT_INIT_URI_EMPTY_PARMS = 202 ; public static final int ER_FAILED_CREATING_ELEMLITRSLT = 203 ; public static final int ER_VALUE_SHOULD_BE_NUMBER = 204 ; public static final int ER_VALUE_SHOULD_EQUAL = 205 ; public static final int ER_FAILED_CALLING_METHOD = 206 ; public static final int ER_FAILED_CREATING_ELEMTMPL = 207 ; public static final int ER_CHARS_NOT_ALLOWED = 208 ; public static final int ER_ATTR_NOT_ALLOWED = 209 ; public static final int ER_METHOD_NOT_SUPPORTED = 210 ; public static final int ER_BAD_VALUE = 211 ; public static final int ER_ATTRIB_VALUE_NOT_FOUND = 212 ; public static final int ER_ATTRIB_VALUE_NOT_RECOGNIZED = 213 ; public static final int ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = 214 ; public static final int ER_XMLRDR_NOT_BEFORE_STARTPARSE = 215 ; public static final int ER_NULL_URI_NAMESPACE = 216 ; public static final int ER_NUMBER_TOO_BIG = 217 ; public static final int ER_NO_DRIVER_NAME_SPECIFIED = 228 ; public static final int ER_NO_URL_SPECIFIED = 229 ; public static final int ER_POOLSIZE_LESS_THAN_ONE = 230 ; public static final int ER_INVALID_DRIVER_NAME = 231 ; public static final int ER_ERRORLISTENER = 232 ; public static final int ER_ASSERT_NO_TEMPLATE_PARENT = 233 ; public static final int ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = 234 ; public static final int ER_AXIS_TRAVERSER_NOT_SUPPORTED = 235 ; public static final int ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = 236 ; public static final int ER_NOT_ALLOWED_IN_POSITION = 237 ; public static final int ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = 238 ; public static final int INVALID_TCHAR = 239 ; public static final int ER_SYSTEMID_UNKNOWN = 240 ; public static final int ER_LOCATION_UNKNOWN = 241 ; public static final int INVALID_QNAME = 242 ; public static final int INVALID_ENUM = 243 ; public static final int INVALID_NMTOKEN = 244 ; public static final int INVALID_NCNAME = 245 ; public static final int INVALID_BOOLEAN = 246 ; public static final int INVALID_NUMBER = 247 ; public static final int WG_FOUND_CURLYBRACE = 1 ; public static final int WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = 2 ; public static final int WG_EXPR_ATTRIB_CHANGED_TO_SELECT = 3 ; public static final int WG_NO_LOCALE_IN_FORMATNUMBER = 4 ; public static final int WG_LOCALE_NOT_FOUND = 5 ; public static final int WG_CANNOT_MAKE_URL_FROM = 6 ; public static final int WG_CANNOT_LOAD_REQUESTED_DOC = 7 ; public static final int WG_CANNOT_FIND_COLLATOR = 8 ; public static final int WG_FUNCTIONS_SHOULD_USE_URL = 9 ; public static final int WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = 10 ; public static final int WG_ENCODING_NOT_SUPPORTED_USING_JAVA = 11 ; public static final int WG_SPECIFICITY_CONFLICTS = 12 ; public static final int WG_PARSING_AND_PREPARING = 13 ; public static final int WG_ATTR_TEMPLATE = 14 ; public static final int WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = 15 ; public static final int WG_ATTRIB_NOT_HANDLED = 16 ; public static final int WG_NO_DECIMALFORMAT_DECLARATION = 17 ; public static final int WG_OLD_XSLT_NS = 18 ; public static final int WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = 19 ; public static final int WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = 20 ; public static final int WG_ILLEGAL_ATTRIBUTE = 21 ; public static final int WG_COULD_NOT_RESOLVE_PREFIX = 22 ; public static final int WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = 23 ; public static final int WG_ILLEGAL_ATTRIBUTE_NAME = 24 ; public static final int WG_ILLEGAL_ATTRIBUTE_VALUE = 25 ; public static final int WG_EMPTY_SECOND_ARG = 26 ; public static final int WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = 27 ; public static final int WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = 28 ; public static final int WG_INVALID_TCHAR = 239 ; public static final int WG_INVALID_QNAME = 242 ; public static final int WG_INVALID_ENUM = 243 ; public static final int WG_INVALID_NMTOKEN = 244 ; public static final int WG_INVALID_NCNAME = 245 ; public static final int WG_INVALID_BOOLEAN = 246 ; public static final int WG_INVALID_NUMBER = 247 ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public static final ResourceBundle loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } public static String getMessageKey ( int errorCode ) { { DecimalFormat df = new DecimalFormat ( "0000" ) ; return ERROR_SUFFIX + df . format ( errorCode ) ; } } public static String getWarningKey ( int errorCode ) { { DecimalFormat df = new DecimalFormat ( "0000" ) ; return WARNING_SUFFIX + df . format ( errorCode ) ; } } public static String getMKey ( int errorCode ) { { DecimalFormat df = new DecimalFormat ( "0000" ) ; return ERROR_SUFFIX + df . format ( errorCode ) ; } } public static String getWKey ( int errorCode ) { { DecimalFormat df = new DecimalFormat ( "0000" ) ; return WARNING_SUFFIX + df . format ( errorCode ) ; } } } 	1	['8', '3', '0', '1', '21', '28', '1', '0', '7', '1.142857143', '430', '0', '0', '0.857142857', '0.225', '0', '0', '17.375', '2', '0.875', '3']
package org . apache . xpath . operations ; import javax . xml . transform . TransformerException ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Equals extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . equals ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject left = m_left . execute ( xctxt , true ) ; XObject right = m_right . execute ( xctxt , true ) ; boolean result = left . equals ( right ) ? true : false ; left . detach ( ) ; right . detach ( ) ; return result ; } } 	0	['3', '3', '0', '6', '7', '3', '1', '5', '3', '2', '40', '0', '0', '0.953488372', '0.555555556', '2', '2', '12.33333333', '1', '0.6667', '0']
package org . apache . xpath . compiler ; import java . util . Vector ; import org . apache . xml . utils . QName ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; public class OpMap { protected String m_currentPattern ; public String toString ( ) { return m_currentPattern ; } public String getPatternString ( ) { return m_currentPattern ; } static final int MAXTOKENQUEUESIZE = 500 ; public Object [ ] m_tokenQueue = new Object [ MAXTOKENQUEUESIZE ] ; public Object [ ] getTokenQueue ( ) { return m_tokenQueue ; } public Object getToken ( int pos ) { return m_tokenQueue [ pos ] ; } public int m_tokenQueueSize = 0 ; public int getTokenQueueSize ( ) { return m_tokenQueueSize ; } public int m_opMap [ ] = null ; public int [ ] getOpMap ( ) { return m_opMap ; } public static final int MAPINDEX_LENGTH = 1 ; void shrink ( ) { int map [ ] = m_opMap ; int n = m_opMap [ MAPINDEX_LENGTH ] ; ; m_opMap = new int [ n + 4 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { m_opMap [ i ] = map [ i ] ; } m_opMap [ i ] = 0 ; m_opMap [ i + 1 ] = 0 ; m_opMap [ i + 2 ] = 0 ; Object [ ] tokens = m_tokenQueue ; n = m_tokenQueueSize ; m_tokenQueue = new Object [ n + 4 ] ; for ( i = 0 ; i < n ; i ++ ) { m_tokenQueue [ i ] = tokens [ i ] ; } m_tokenQueue [ i ] = null ; m_tokenQueue [ i + 1 ] = null ; m_tokenQueue [ i + 2 ] = null ; } public int getOp ( int opPos ) { return m_opMap [ opPos ] ; } public int getNextOpPos ( int opPos ) { return opPos + m_opMap [ opPos + 1 ] ; } public int getNextStepPos ( int opPos ) { int stepType = getOp ( opPos ) ; if ( ( stepType >= OpCodes . AXES_START_TYPES ) && ( stepType <= OpCodes . AXES_END_TYPES ) ) { return getNextOpPos ( opPos ) ; } else if ( ( stepType >= OpCodes . FIRST_NODESET_OP ) && ( stepType <= OpCodes . LAST_NODESET_OP ) ) { int newOpPos = getNextOpPos ( opPos ) ; while ( OpCodes . OP_PREDICATE == getOp ( newOpPos ) ) { newOpPos = getNextOpPos ( newOpPos ) ; } stepType = getOp ( newOpPos ) ; if ( ! ( ( stepType >= OpCodes . AXES_START_TYPES ) && ( stepType <= OpCodes . AXES_END_TYPES ) ) ) { return OpCodes . ENDOP ; } return newOpPos ; } else { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_UNKNOWN_STEP , new Object [ ] { new Integer ( stepType ) . toString ( ) } ) ) ; } } public static int getNextOpPos ( int [ ] opMap , int opPos ) { return opPos + opMap [ opPos + 1 ] ; } public int getFirstPredicateOpPos ( int opPos ) throws javax . xml . transform . TransformerException { int stepType = m_opMap [ opPos ] ; if ( ( stepType >= OpCodes . AXES_START_TYPES ) && ( stepType <= OpCodes . AXES_END_TYPES ) ) { return opPos + m_opMap [ opPos + 2 ] ; } else if ( ( stepType >= OpCodes . FIRST_NODESET_OP ) && ( stepType <= OpCodes . LAST_NODESET_OP ) ) { return opPos + m_opMap [ opPos + 1 ] ; } else if ( - 2 == stepType ) { return - 2 ; } else { error ( org . apache . xpath . res . XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { String . valueOf ( stepType ) } ) ; return - 1 ; } } public void error ( int msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = org . apache . xalan . res . XSLMessages . createXPATHMessage ( msg , args ) ; throw new javax . xml . transform . TransformerException ( fmsg ) ; } public static int getFirstChildPos ( int opPos ) { return opPos + 2 ; } public int getArgLength ( int opPos ) { return m_opMap [ opPos + MAPINDEX_LENGTH ] ; } public int getArgLengthOfStep ( int opPos ) { return m_opMap [ opPos + MAPINDEX_LENGTH + 1 ] - 3 ; } public static int getFirstChildPosOfStep ( int opPos ) { return opPos + 3 ; } public int getStepTestType ( int opPosOfStep ) { return m_opMap [ opPosOfStep + 3 ] ; } public String getStepNS ( int opPosOfStep ) { int argLenOfStep = getArgLengthOfStep ( opPosOfStep ) ; if ( argLenOfStep == 3 ) { int index = m_opMap [ opPosOfStep + 4 ] ; if ( index >= 0 ) return ( String ) m_tokenQueue [ index ] ; else if ( OpCodes . ELEMWILDCARD == index ) return NodeTest . WILD ; else return null ; } else return null ; } public String getStepLocalName ( int opPosOfStep ) { int argLenOfStep = getArgLengthOfStep ( opPosOfStep ) ; int index ; switch ( argLenOfStep ) { case 0 : index = OpCodes . EMPTY ; break ; case 1 : index = OpCodes . ELEMWILDCARD ; break ; case 2 : index = m_opMap [ opPosOfStep + 4 ] ; break ; case 3 : index = m_opMap [ opPosOfStep + 5 ] ; break ; default : index = OpCodes . EMPTY ; break ; } if ( index >= 0 ) return ( String ) m_tokenQueue [ index ] . toString ( ) ; else if ( OpCodes . ELEMWILDCARD == index ) return NodeTest . WILD ; else return null ; } } 	1	['21', '1', '1', '12', '29', '76', '11', '1', '20', '0.858333333', '409', '0.166666667', '0', '0', '0.404761905', '0', '0', '18.19047619', '8', '1.6667', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . dom . Axis ; final class LastCall extends FunctionCall { private int _type = - 1 ; public LastCall ( QName fname ) { super ( fname ) ; } public LastCall ( QName fname , int type ) { this ( fname ) ; _type = type ; } public boolean hasPositionCall ( ) { return true ; } public boolean hasLastCall ( ) { return true ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; boolean lastChild = false ; if ( getParent ( ) instanceof Expression ) { if ( getParent ( ) . getParent ( ) instanceof Predicate ) { Predicate pred = ( Predicate ) getParent ( ) . getParent ( ) ; _type = pred . getPosType ( ) ; if ( ( _type == DOM . ELEMENT ) || ( _type == DOM . ATTRIBUTE ) ) _type = - 1 ; } } if ( getParent ( ) instanceof Predicate ) { _type = ( ( Predicate ) getParent ( ) ) . getPosType ( ) ; if ( ( _type == DOM . ELEMENT ) || ( _type == DOM . ATTRIBUTE ) ) _type = - 1 ; if ( getParent ( ) . getParent ( ) instanceof Step ) { lastChild = true ; } } if ( methodGen instanceof CompareGenerator ) { il . append ( ( ( CompareGenerator ) methodGen ) . loadLastNode ( ) ) ; } else if ( classGen . isExternal ( ) ) { il . append ( new ILOAD ( LAST_INDEX ) ) ; } else if ( _type == - 1 ) { final int last = cpg . addInterfaceMethodref ( NODE_ITERATOR , "getLast" , "()I" ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , "getTypedAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; final int start = cpg . addInterfaceMethodref ( NODE_ITERATOR , "setStartNode" , "(I)" + NODE_ITERATOR_SIG ) ; if ( lastChild ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . CHILD ) ) ; il . append ( new PUSH ( cpg , DOM . ELEMENT ) ) ; il . append ( new INVOKEINTERFACE ( git , 3 ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( start , 2 ) ) ; } else { il . append ( methodGen . loadIterator ( ) ) ; } il . append ( new INVOKEINTERFACE ( last , 1 ) ) ; } else { final int last = cpg . addInterfaceMethodref ( DOM_INTF , "getTypedLast" , "(II)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _type ) ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( last , 3 ) ) ; } } } 	0	['5', '4', '0', '19', '22', '4', '1', '19', '5', '0.5', '225', '1', '0', '0.96969697', '0.4', '2', '4', '43.8', '13', '3', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . Constants ; public final class Util { static public char filesep ; static { String temp = System . getProperty ( "file.separator" , "/" ) ; filesep = temp . charAt ( 0 ) ; } public static String noExtName ( String name ) { final int index = name . lastIndexOf ( '.' ) ; return name . substring ( 0 , index >= 0 ? index : name . length ( ) ) ; } public static String baseName ( String name ) { int index = name . lastIndexOf ( '/' ) ; if ( index < 0 ) { index = name . lastIndexOf ( '\\' ) ; } return name . substring ( index + 1 ) ; } public static String pathName ( String name ) { int index = name . lastIndexOf ( '/' ) ; if ( index < 0 ) { index = name . lastIndexOf ( '\\' ) ; } return name . substring ( 0 , index + 1 ) ; } public static String toJavaName ( String name ) { if ( name . length ( ) > 0 ) { final StringBuffer result = new StringBuffer ( ) ; char ch = name . charAt ( 0 ) ; result . append ( Character . isJavaIdentifierStart ( ch ) ? ch : '_' ) ; final int n = name . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { ch = name . charAt ( i ) ; result . append ( Character . isJavaIdentifierPart ( ch ) ? ch : '_' ) ; } return result . toString ( ) ; } return name ; } public static Type getJCRefType ( String signature ) { return Type . getType ( signature ) ; } public static String internalName ( String cname ) { return cname . replace ( '.' , filesep ) ; } public static void println ( String s ) { System . out . println ( s ) ; } public static void println ( char ch ) { System . out . println ( ch ) ; } public static void TRACE1 ( ) { System . out . println ( "TRACE1" ) ; } public static void TRACE2 ( ) { System . out . println ( "TRACE2" ) ; } public static void TRACE3 ( ) { System . out . println ( "TRACE3" ) ; } public static String replace ( String base , char ch , String str ) { return ( base . indexOf ( ch ) < 0 ) ? base : replace ( base , String . valueOf ( ch ) , new String [ ] { str } ) ; } public static String replace ( String base , String delim , String [ ] str ) { final int len = base . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i ++ ) { final char ch = base . charAt ( i ) ; final int k = delim . indexOf ( ch ) ; if ( k >= 0 ) { result . append ( str [ k ] ) ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } public static String escape ( String input ) { return replace ( input , ".-/:" , new String [ ] { "$dot$" , "$dash$" , "$slash$" , "$colon$" } ) ; } public static String getLocalName ( String qname ) { final int index = qname . lastIndexOf ( ":" ) ; return ( index > 0 ) ? qname . substring ( index + 1 ) : qname ; } public static String getPrefix ( String qname ) { final int index = qname . lastIndexOf ( ":" ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : Constants . EMPTYSTRING ; } } 	1	['18', '1', '0', '44', '38', '151', '43', '1', '17', '0.941176471', '258', '0', '0', '0', '0.235294118', '0', '0', '13.27777778', '5', '1.5556', '1']
package org . apache . xml . dtm . ref ; import java . util . * ; import org . apache . xml . dtm . * ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . res . XSLMessages ; public class CoroutineManager { BitSet m_activeIDs = new BitSet ( ) ; static final int m_unreasonableId = 1024 ; Object m_yield = null ; final static int NOBODY = - 1 ; final static int ANYBODY = - 1 ; int m_nextCoroutine = NOBODY ; public synchronized int co_joinCoroutineSet ( int coroutineID ) { if ( coroutineID >= 0 ) { if ( coroutineID >= m_unreasonableId || m_activeIDs . get ( coroutineID ) ) return - 1 ; } else { coroutineID = 0 ; while ( coroutineID < m_unreasonableId ) { if ( m_activeIDs . get ( coroutineID ) ) ++ coroutineID ; else break ; } if ( coroutineID >= m_unreasonableId ) return - 1 ; } m_activeIDs . set ( coroutineID ) ; return coroutineID ; } public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; } public synchronized Object co_resume ( Object arg_object , int thisCoroutine , int toCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( toCoroutine ) ) throw new java . lang . NoSuchMethodException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COROUTINE_NOT_AVAIL , new Object [ ] { Integer . toString ( toCoroutine ) } ) ) ; m_yield = arg_object ; m_nextCoroutine = toCoroutine ; notify ( ) ; while ( m_nextCoroutine != thisCoroutine || m_nextCoroutine == ANYBODY || m_nextCoroutine == NOBODY ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } if ( m_nextCoroutine == NOBODY ) { co_exit ( thisCoroutine ) ; throw new java . lang . NoSuchMethodException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COROUTINE_CO_EXIT , null ) ) ; } return m_yield ; } public synchronized void co_exit ( int thisCoroutine ) { m_activeIDs . clear ( thisCoroutine ) ; m_nextCoroutine = NOBODY ; notify ( ) ; } public synchronized void co_exit_to ( Object arg_object , int thisCoroutine , int toCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( toCoroutine ) ) throw new java . lang . NoSuchMethodException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COROUTINE_NOT_AVAIL , new Object [ ] { Integer . toString ( toCoroutine ) } ) ) ; m_yield = arg_object ; m_nextCoroutine = toCoroutine ; m_activeIDs . clear ( thisCoroutine ) ; notify ( ) ; } } 	0	['6', '1', '0', '4', '17', '0', '3', '1', '6', '0.7', '183', '0', '0', '0', '0.722222222', '0', '0', '28.5', '7', '1.8333', '0']
package org . apache . xpath . objects ; import org . w3c . dom . * ; public class XBoolean extends XObject { public static XBoolean S_TRUE = new XBooleanStatic ( true ) ; public static XBoolean S_FALSE = new XBooleanStatic ( false ) ; boolean m_val ; public XBoolean ( boolean b ) { super ( ) ; m_val = b ; } public XBoolean ( Boolean b ) { super ( ) ; m_val = b . booleanValue ( ) ; m_obj = b ; } public int getType ( ) { return CLASS_BOOLEAN ; } public String getTypeString ( ) { return "#BOOLEAN" ; } public double num ( ) { return m_val ? 1.0 : 0.0 ; } public boolean bool ( ) { return m_val ; } public String str ( ) { return m_val ? "true" : "false" ; } public Object object ( ) { if ( null == m_obj ) m_obj = m_val ? S_TRUE : S_FALSE ; return m_obj ; } public boolean equals ( XObject obj2 ) { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . equals ( this ) ; try { return m_val == obj2 . bool ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } 	1	['10', '3', '1', '26', '17', '1', '24', '3', '9', '0.703703704', '99', '0', '2', '0.91025641', '0.333333333', '2', '22', '8.6', '3', '1.3', '1']
package org . apache . xpath . functions ; import org . apache . xpath . res . XPATHErrorResources ; import java . util . Vector ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XNodeSet ; public class FuncStringLength extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( getArg0AsString ( xctxt ) . length ( ) ) ; } } 	0	['2', '5', '0', '5', '6', '1', '0', '5', '2', '2', '14', '0', '0', '0.982142857', '0.75', '2', '7', '6', '1', '0.5', '0']
package org . apache . xpath . axes ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . Serializable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; public class UnionPathIterator extends LocPathIterator implements Cloneable , DTMIterator , java . io . Serializable , PathComponent { public UnionPathIterator ( ) { super ( ) ; m_iterators = null ; m_exprs = null ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; try { if ( null != m_exprs ) { int n = m_exprs . length ; DTMIterator newIters [ ] = new DTMIterator [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { DTMIterator iter = m_exprs [ i ] . asIterator ( m_execContext , context ) ; newIters [ i ] = iter ; iter . nextNode ( ) ; } m_iterators = newIters ; } } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } public void addIterator ( DTMIterator expr ) { if ( null == m_iterators ) { m_iterators = new DTMIterator [ 1 ] ; m_iterators [ 0 ] = expr ; } else { DTMIterator [ ] exprs = m_iterators ; int len = m_iterators . length ; m_iterators = new DTMIterator [ len + 1 ] ; System . arraycopy ( exprs , 0 , m_iterators , 0 , len ) ; m_iterators [ len ] = expr ; } expr . nextNode ( ) ; if ( expr instanceof Expression ) ( ( Expression ) expr ) . exprSetParent ( this ) ; } public void detach ( ) { if ( null != m_iterators ) { int n = m_iterators . length ; for ( int i = 0 ; i < n ; i ++ ) { m_iterators [ i ] . detach ( ) ; } m_iterators = null ; } } public UnionPathIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { super ( ) ; opPos = compiler . getFirstChildPos ( opPos ) ; loadLocationPaths ( compiler , opPos , 0 ) ; } public static LocPathIterator createUnionIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { UnionPathIterator upi = new UnionPathIterator ( compiler , opPos ) ; int nPaths = upi . m_exprs . length ; boolean isAllChildIterators = true ; for ( int i = 0 ; i < nPaths ; i ++ ) { LocPathIterator lpi = upi . m_exprs [ i ] ; if ( lpi . getAxis ( ) != Axis . CHILD ) { isAllChildIterators = false ; break ; } else { if ( HasPositionalPredChecker . check ( lpi ) ) { isAllChildIterators = false ; break ; } } } if ( isAllChildIterators ) { UnionChildIterator uci = new UnionChildIterator ( ) ; for ( int i = 0 ; i < nPaths ; i ++ ) { PredicatedNodeTest lpi = upi . m_exprs [ i ] ; uci . addNodeTest ( lpi ) ; } return uci ; } else return upi ; } public int getAnalysisBits ( ) { int bits = 0 ; if ( m_exprs != null ) { int n = m_exprs . length ; for ( int i = 0 ; i < n ; i ++ ) { int bit = m_exprs [ i ] . getAnalysisBits ( ) ; bits |= bit ; } } return bits ; } private void readObject ( java . io . ObjectInputStream stream ) throws java . io . IOException , javax . xml . transform . TransformerException { try { stream . defaultReadObject ( ) ; m_clones = new IteratorPool ( this ) ; } catch ( ClassNotFoundException cnfe ) { throw new javax . xml . transform . TransformerException ( cnfe ) ; } } public Object clone ( ) throws CloneNotSupportedException { UnionPathIterator clone = ( UnionPathIterator ) super . clone ( ) ; return clone ; } protected LocPathIterator createDTMIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { LocPathIterator lpi = ( LocPathIterator ) WalkerFactory . newDTMIterator ( compiler , opPos , ( compiler . getLocationPathDepth ( ) <= 0 ) ) ; return lpi ; } protected void loadLocationPaths ( Compiler compiler , int opPos , int count ) throws javax . xml . transform . TransformerException { int steptype = compiler . getOpMap ( ) [ opPos ] ; if ( steptype == OpCodes . OP_LOCATIONPATH ) { loadLocationPaths ( compiler , compiler . getNextOpPos ( opPos ) , count + 1 ) ; m_exprs [ count ] = createDTMIterator ( compiler , opPos ) ; m_exprs [ count ] . exprSetParent ( this ) ; } else { switch ( steptype ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : loadLocationPaths ( compiler , compiler . getNextOpPos ( opPos ) , count + 1 ) ; WalkingIterator iter = new WalkingIterator ( compiler . getNamespaceContext ( ) ) ; iter . exprSetParent ( this ) ; if ( compiler . getLocationPathDepth ( ) <= 0 ) iter . setIsTopLevel ( true ) ; iter . m_firstWalker = new org . apache . xpath . axes . FilterExprWalker ( iter ) ; iter . m_firstWalker . init ( compiler , opPos , steptype ) ; m_exprs [ count ] = iter ; break ; default : m_exprs = new LocPathIterator [ count ] ; } } } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int earliestNode = DTM . NULL ; if ( null != m_iterators ) { int n = m_iterators . length ; int iteratorUsed = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int node = m_iterators [ i ] . getCurrentNode ( ) ; if ( DTM . NULL == node ) continue ; else if ( DTM . NULL == earliestNode ) { iteratorUsed = i ; earliestNode = node ; } else { if ( node == earliestNode ) { m_iterators [ i ] . nextNode ( ) ; } else { DTM dtm = getDTM ( node ) ; if ( dtm . isNodeAfter ( node , earliestNode ) ) { iteratorUsed = i ; earliestNode = node ; } } } } if ( DTM . NULL != earliestNode ) { m_iterators [ iteratorUsed ] . nextNode ( ) ; incrementCurrentPos ( ) ; } else m_foundLast = true ; } m_lastFetched = earliestNode ; return earliestNode ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { for ( int i = 0 ; i < m_exprs . length ; i ++ ) { m_exprs [ i ] . fixupVariables ( vars , globalsSize ) ; } } protected LocPathIterator [ ] m_exprs ; protected DTMIterator [ ] m_iterators ; public int getAxis ( ) { return - 1 ; } class iterOwner implements ExpressionOwner { int m_index ; iterOwner ( int index ) { m_index = index ; } public Expression getExpression ( ) { return m_exprs [ m_index ] ; } public void setExpression ( Expression exp ) { if ( ! ( exp instanceof LocPathIterator ) ) { WalkingIterator wi = new WalkingIterator ( getPrefixResolver ( ) ) ; FilterExprWalker few = new FilterExprWalker ( wi ) ; wi . setFirstWalker ( few ) ; few . setInnerExpression ( exp ) ; wi . exprSetParent ( UnionPathIterator . this ) ; few . exprSetParent ( wi ) ; exp . exprSetParent ( few ) ; exp = wi ; } else exp . exprSetParent ( UnionPathIterator . this ) ; m_exprs [ m_index ] = ( LocPathIterator ) exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitUnionPath ( owner , this ) ) { if ( null != m_exprs ) { int n = m_exprs . length ; for ( int i = 0 ; i < n ; i ++ ) { m_exprs [ i ] . callVisitors ( new iterOwner ( i ) , visitor ) ; } } } } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; UnionPathIterator upi = ( UnionPathIterator ) expr ; if ( null != m_exprs ) { int n = m_exprs . length ; if ( ( null == upi . m_exprs ) || ( upi . m_exprs . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_exprs [ i ] . deepEquals ( upi . m_exprs [ i ] ) ) return false ; } } else if ( null != upi . m_exprs ) { return false ; } return true ; } } 	1	['16', '5', '0', '23', '52', '46', '4', '22', '13', '0.6', '561', '1', '2', '0.899280576', '0.2', '2', '13', '33.9375', '9', '2.4375', '1']
package org . apache . xalan . xsltc . dom ; import java . util . Vector ; import java . text . Collator ; import java . text . CollationKey ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; public abstract class NodeSortRecord { public static int COMPARE_STRING = 0 ; public static int COMPARE_NUMERIC = 1 ; public static int COMPARE_ASCENDING = 0 ; public static int COMPARE_DESCENDING = 1 ; protected static Collator _collator = Collator . getInstance ( ) ; protected int _levels = 1 ; protected int [ ] _compareType ; protected int [ ] _sortOrder ; private AbstractTranslet _translet = null ; private DOM _dom = null ; private int _node ; private int _last = 0 ; private int _scanned = 0 ; private Object [ ] _values ; public NodeSortRecord ( int node ) { _node = node ; } public NodeSortRecord ( ) { this ( 0 ) ; } public final void initialize ( int node , int last , DOM dom , AbstractTranslet translet , int [ ] order , int [ ] type ) { _dom = dom ; _node = node ; _last = last ; _translet = translet ; _scanned = 0 ; _levels = order . length ; _sortOrder = order ; _compareType = type ; _values = new Object [ _levels ] ; } public final int getNode ( ) { return _node ; } public final int compareDocOrder ( NodeSortRecord other ) { return _node - other . _node ; } private final CollationKey stringValue ( int level ) { if ( _scanned <= level ) { final String str = extractValueFromDOM ( _dom , _node , level , _translet , _last ) ; final CollationKey key = _collator . getCollationKey ( str ) ; _values [ _scanned ++ ] = key ; return ( key ) ; } return ( ( CollationKey ) _values [ level ] ) ; } private final Double numericValue ( int level ) { if ( _scanned <= level ) { final String str = extractValueFromDOM ( _dom , _node , level , _translet , _last ) ; Double num ; try { num = new Double ( str ) ; } catch ( NumberFormatException e ) { num = new Double ( Double . NEGATIVE_INFINITY ) ; } _values [ _scanned ++ ] = num ; return ( num ) ; } return ( ( Double ) _values [ level ] ) ; } public int compareTo ( NodeSortRecord other ) { int cmp , level ; for ( level = 0 ; level < _levels ; level ++ ) { if ( _compareType [ level ] == COMPARE_NUMERIC ) { final Double our = numericValue ( level ) ; final Double their = other . numericValue ( level ) ; cmp = our . compareTo ( their ) ; } else { final CollationKey our = stringValue ( level ) ; final CollationKey their = other . stringValue ( level ) ; cmp = our . compareTo ( their ) ; } if ( cmp != 0 ) { return _sortOrder [ level ] == COMPARE_DESCENDING ? 0 - cmp : cmp ; } } return ( _node - other . _node ) ; } public Collator getCollator ( ) { return _collator ; } public abstract String extractValueFromDOM ( DOM dom , int current , int level , AbstractTranslet translet , int last ) ; } 	0	['11', '1', '0', '4', '18', '5', '2', '2', '8', '0.714285714', '248', '0.714285714', '2', '0', '0.366666667', '0', '0', '20.27272727', '5', '1.2727', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import java . util . Vector ; import java . util . Hashtable ; public class ExpandedNameTable { private DTMStringPool m_locNamesPool ; private DTMStringPool m_namespaceNames ; private Vector m_extendedTypes ; private int m_nextType ; public static final int ELEMENT = ( ( int ) DTM . ELEMENT_NODE ) ; public static final int ATTRIBUTE = ( ( int ) DTM . ATTRIBUTE_NODE ) ; public static final int TEXT = ( ( int ) DTM . TEXT_NODE ) ; public static final int CDATA_SECTION = ( ( int ) DTM . CDATA_SECTION_NODE ) ; public static final int ENTITY_REFERENCE = ( ( int ) DTM . ENTITY_REFERENCE_NODE ) ; public static final int ENTITY = ( ( int ) DTM . ENTITY_NODE ) ; public static final int PROCESSING_INSTRUCTION = ( ( int ) DTM . PROCESSING_INSTRUCTION_NODE ) ; public static final int COMMENT = ( ( int ) DTM . COMMENT_NODE ) ; public static final int DOCUMENT = ( ( int ) DTM . DOCUMENT_NODE ) ; public static final int DOCUMENT_TYPE = ( ( int ) DTM . DOCUMENT_TYPE_NODE ) ; public static final int DOCUMENT_FRAGMENT = ( ( int ) DTM . DOCUMENT_FRAGMENT_NODE ) ; public static final int NOTATION = ( ( int ) DTM . NOTATION_NODE ) ; public static final int NAMESPACE = ( ( int ) DTM . NAMESPACE_NODE ) ; Hashtable m_hashtable = new Hashtable ( ) ; ExtendedType hashET = new ExtendedType ( - 1 , "" , "" ) ; public ExpandedNameTable ( ) { m_locNamesPool = new DTMSafeStringPool ( ) ; m_namespaceNames = new DTMSafeStringPool ( ) ; initExtendedTypes ( ) ; } public ExpandedNameTable ( DTMStringPool locNamesPool , DTMStringPool namespaceNames ) { m_locNamesPool = locNamesPool ; m_namespaceNames = namespaceNames ; initExtendedTypes ( ) ; } private void initExtendedTypes ( ) { m_extendedTypes = new Vector ( ) ; int i ; for ( i = 0 ; i < DTM . NTYPES ; i ++ ) { ExtendedType newET = new ExtendedType ( i , "" , "" ) ; m_extendedTypes . addElement ( newET ) ; m_hashtable . put ( newET , new Integer ( i ) ) ; } m_nextType = m_extendedTypes . size ( ) ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { if ( null == namespace ) namespace = "" ; if ( null == localName ) localName = "" ; hashET . redefine ( type , namespace , localName ) ; Object eType ; if ( ( eType = m_hashtable . get ( hashET ) ) != null ) return ( ( Integer ) eType ) . intValue ( ) ; ExtendedType newET = new ExtendedType ( type , namespace , localName ) ; m_extendedTypes . addElement ( newET ) ; m_hashtable . put ( newET , new Integer ( m_nextType ) ) ; return m_nextType ++ ; } public int getExpandedTypeID ( int type ) { return type ; } public String getLocalName ( int ExpandedNameID ) { ExtendedType etype = ( ExtendedType ) m_extendedTypes . elementAt ( ExpandedNameID ) ; return etype . localName ; } public final int getLocalNameID ( int ExpandedNameID ) { ExtendedType etype = ( ExtendedType ) m_extendedTypes . elementAt ( ExpandedNameID ) ; if ( etype . localName . equals ( "" ) ) return 0 ; else return ExpandedNameID ; } public String getNamespace ( int ExpandedNameID ) { ExtendedType etype = ( ExtendedType ) m_extendedTypes . elementAt ( ExpandedNameID ) ; return ( etype . namespace . equals ( "" ) ? null : etype . namespace ) ; } public final int getNamespaceID ( int ExpandedNameID ) { ExtendedType etype = ( ExtendedType ) m_extendedTypes . elementAt ( ExpandedNameID ) ; if ( etype . namespace . equals ( "" ) ) return 0 ; else return ExpandedNameID ; } public final short getType ( int ExpandedNameID ) { ExtendedType etype = ( ExtendedType ) m_extendedTypes . elementAt ( ExpandedNameID ) ; return ( short ) etype . nodetype ; } private class ExtendedType { protected int nodetype ; protected String namespace ; protected String localName ; protected int hash ; protected ExtendedType ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; } protected void redefine ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; } public int hashCode ( ) { return hash ; } public boolean equals ( Object other ) { try { ExtendedType et = ( ExtendedType ) other ; return et . nodetype == this . nodetype && et . localName . equals ( this . localName ) && et . namespace . equals ( this . namespace ) ; } catch ( ClassCastException e ) { return false ; } catch ( NullPointerException e ) { return false ; } } } } 	1	['10', '1', '0', '15', '24', '0', '13', '3', '9', '0.970760234', '247', '0.210526316', '3', '0', '0.475', '0', '0', '21.8', '4', '1.5', '1']
package org . apache . xalan . templates ; import java . io . Serializable ; import javax . xml . transform . TransformerException ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xml . utils . QName ; class TemplateSubPatternAssociation implements Serializable , Cloneable { StepPattern m_stepPattern ; private String m_pattern ; private ElemTemplate m_template ; private TemplateSubPatternAssociation m_next = null ; private boolean m_wild ; private String m_targetString ; TemplateSubPatternAssociation ( ElemTemplate template , StepPattern pattern , String pat ) { m_pattern = pat ; m_template = template ; m_stepPattern = pattern ; m_targetString = m_stepPattern . getTargetString ( ) ; m_wild = m_targetString . equals ( "*" ) ; } public Object clone ( ) throws CloneNotSupportedException { TemplateSubPatternAssociation tspa = ( TemplateSubPatternAssociation ) super . clone ( ) ; tspa . m_next = null ; return tspa ; } public final String getTargetString ( ) { return m_targetString ; } public void setTargetString ( String key ) { m_targetString = key ; } boolean matchMode ( QName m1 ) { return matchModes ( m1 , m_template . getMode ( ) ) ; } private boolean matchModes ( QName m1 , QName m2 ) { return ( ( ( null == m1 ) && ( null == m2 ) ) || ( ( null != m1 ) && ( null != m2 ) && m1 . equals ( m2 ) ) ) ; } public boolean matches ( XPathContext xctxt , int targetNode , QName mode ) throws TransformerException { double score = m_stepPattern . getMatchScore ( xctxt , targetNode ) ; return ( XPath . MATCH_SCORE_NONE != score ) && matchModes ( mode , m_template . getMode ( ) ) ; } public final boolean isWild ( ) { return m_wild ; } public final StepPattern getStepPattern ( ) { return m_stepPattern ; } public final String getPattern ( ) { return m_pattern ; } public int getDocOrderPos ( ) { return m_template . getUid ( ) ; } public final int getImportLevel ( ) { return m_template . getStylesheetComposed ( ) . getImportCountComposed ( ) ; } public final ElemTemplate getTemplate ( ) { return m_template ; } public final TemplateSubPatternAssociation getNext ( ) { return m_next ; } public void setNext ( TemplateSubPatternAssociation mp ) { m_next = mp ; } } 	0	['15', '1', '0', '8', '25', '49', '2', '6', '12', '0.833333333', '139', '0.833333333', '3', '0', '0.208333333', '0', '0', '7.866666667', '6', '1.2667', '0']
package org . apache . xalan . xsltc . runtime . output ; import java . util . Vector ; import java . io . Writer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import org . apache . xalan . xsltc . * ; import org . apache . xalan . xsltc . runtime . * ; import org . apache . xalan . xsltc . runtime . Hashtable ; public class StreamHTMLOutput extends StreamOutput { private static final String HREF_STR = "href" ; private static final String CITE_STR = "cite" ; private static final String SRC_STR = "src" ; private static final Hashtable _emptyElements = new Hashtable ( ) ; private static final String [ ] tags = { "area" , "base" , "basefont" , "br" , "col" , "frame" , "hr" , "img" , "input" , "isindex" , "link" , "meta" , "param" } ; static { for ( int i = 0 ; i < tags . length ; i ++ ) { _emptyElements . put ( tags [ i ] , "" ) ; } } private boolean _headTagOpen = false ; private boolean _inStyleScript = false ; private String _mediaType = "text/html" ; public StreamHTMLOutput ( StreamOutput output ) { super ( output ) ; setIndent ( true ) ; } public StreamHTMLOutput ( Writer writer , String encoding ) { super ( writer , encoding ) ; setIndent ( true ) ; } public StreamHTMLOutput ( OutputStream out , String encoding ) throws IOException { super ( out , encoding ) ; setIndent ( true ) ; } public void startDocument ( ) throws TransletException { } public void endDocument ( ) throws TransletException { outputBuffer ( ) ; } public void startElement ( String elementName ) throws TransletException { if ( _startTagOpen ) { closeStartTag ( ) ; } if ( _firstElement ) { if ( _doctypeSystem != null || _doctypePublic != null ) { appendDTD ( elementName ) ; } _firstElement = false ; } if ( _indent ) { if ( ! _emptyElements . containsKey ( elementName . toLowerCase ( ) ) ) { indent ( _lineFeedNextStartTag ) ; _lineFeedNextStartTag = true ; _indentNextEndTag = false ; } _indentLevel ++ ; } _buffer . append ( '<' ) . append ( elementName ) ; _startTagOpen = true ; _indentNextEndTag = false ; if ( elementName . equalsIgnoreCase ( "head" ) ) { _headTagOpen = true ; } else if ( elementName . equalsIgnoreCase ( "style" ) || elementName . equalsIgnoreCase ( "script" ) ) { _inStyleScript = true ; } } public void endElement ( String elementName ) throws TransletException { if ( _inStyleScript && ( elementName . equalsIgnoreCase ( "style" ) || elementName . equalsIgnoreCase ( "script" ) ) ) { _inStyleScript = false ; } if ( _startTagOpen ) { appendAttributes ( ) ; if ( _emptyElements . containsKey ( elementName . toLowerCase ( ) ) ) { _buffer . append ( '>' ) ; } else { closeStartTag ( ) ; _buffer . append ( "</" ) . append ( elementName ) . append ( '>' ) ; } _startTagOpen = false ; if ( _indent ) { _indentLevel -- ; _indentNextEndTag = true ; } } else { if ( _indent ) { _indentLevel -- ; if ( _indentNextEndTag ) { indent ( _indentNextEndTag ) ; _indentNextEndTag = true ; _lineFeedNextStartTag = true ; } } _buffer . append ( "</" ) . append ( elementName ) . append ( '>' ) ; _indentNextEndTag = true ; } } public void characters ( String characters ) throws TransletException { if ( _startTagOpen ) { closeStartTag ( ) ; } if ( _escaping && ! _inStyleScript ) { escapeCharacters ( characters . toCharArray ( ) , 0 , characters . length ( ) ) ; } else { _buffer . append ( characters ) ; } } public void characters ( char [ ] characters , int offset , int length ) throws TransletException { if ( _startTagOpen ) { closeStartTag ( ) ; } if ( _escaping && ! _inStyleScript ) { escapeCharacters ( characters , offset , length ) ; } else { _buffer . append ( characters , offset , length ) ; } } public void attribute ( String name , String value ) throws TransletException { if ( _startTagOpen ) { int k ; Attribute attr ; if ( name . equalsIgnoreCase ( HREF_STR ) || name . equalsIgnoreCase ( SRC_STR ) || name . equals ( CITE_STR ) ) { attr = new Attribute ( name , escapeURL ( value ) ) ; } else { attr = new Attribute ( name , escapeNonURL ( value ) ) ; } if ( ( k = _attributes . indexOf ( attr ) ) >= 0 ) { _attributes . setElementAt ( attr , k ) ; } else { _attributes . add ( attr ) ; } } } public void comment ( String comment ) throws TransletException { if ( _startTagOpen ) { closeStartTag ( ) ; } appendComment ( comment ) ; } public void processingInstruction ( String target , String data ) throws TransletException { if ( _startTagOpen ) { closeStartTag ( ) ; } if ( _firstElement ) { if ( _doctypeSystem != null || _doctypePublic != null ) { appendDTD ( "html" ) ; } _firstElement = false ; } _buffer . append ( "<?" ) . append ( target ) . append ( ' ' ) . append ( data ) . append ( '>' ) ; } public boolean setEscaping ( boolean escape ) throws TransletException { final boolean temp = _escaping ; _escaping = escape ; return temp ; } public void close ( ) { try { _writer . close ( ) ; } catch ( Exception e ) { } } public void namespace ( String prefix , String uri ) throws TransletException { } public void setCdataElements ( Hashtable elements ) { } public void setType ( int type ) { } public void setMediaType ( String mediaType ) { _mediaType = mediaType ; } private String escapeNonURL ( String base ) { final int length = base . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final char ch = base . charAt ( i ) ; if ( ( ch >= '' && ch < ' ' ) || ( _is8859Encoded && ch > 'ÿ' ) ) { result . append ( CHAR_ESC_START ) . append ( Integer . toString ( ( int ) ch ) ) . append ( ';' ) ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } private String escapeURL ( String base ) { final char [ ] chs = base . toCharArray ( ) ; final StringBuffer result = new StringBuffer ( ) ; final int length = chs . length ; for ( int i = 0 ; i < length ; i ++ ) { final char ch = chs [ i ] ; if ( ch <= 0x20 ) { result . append ( '%' ) . append ( makeHHString ( ch ) ) ; } else if ( ch > '' ) { result . append ( '%' ) . append ( makeHHString ( ( ch > > 6 ) | 0xC0 ) ) . append ( '%' ) . append ( makeHHString ( ( ch & 0x3F ) | 0x80 ) ) ; } else { switch ( ch ) { case '' : case '{' : case '}' : case '|' : case '\\' : case '\t' : case '^' : case '~' : case '[' : case ']' : case '`' : case ' ' : result . append ( '%' ) . append ( Integer . toHexString ( ( int ) ch ) ) ; break ; case '"' : result . append ( "%22" ) ; break ; default : result . append ( ch ) ; break ; } } } return result . toString ( ) ; } private String makeHHString ( int i ) { final String s = Integer . toHexString ( i ) . toUpperCase ( ) ; return ( s . length ( ) == 1 ) ? "0" + s : s ; } private void appendHeader ( ) { _buffer . append ( "<meta http-equiv=\"Content-Type\" content=\"" ) . append ( _mediaType ) . append ( "; charset=" ) . append ( _encoding ) . append ( "\">" ) ; } protected void closeStartTag ( ) throws TransletException { super . closeStartTag ( ) ; if ( _headTagOpen ) { appendHeader ( ) ; _headTagOpen = false ; } } protected void escapeCharacters ( char [ ] ch , int off , int len ) { int limit = off + len ; int offset = off ; if ( limit > ch . length ) { limit = ch . length ; } for ( int i = off ; i < limit ; i ++ ) { final char current = ch [ i ] ; switch ( current ) { case '&' : _buffer . append ( ch , offset , i - offset ) . append ( AMP ) ; offset = i + 1 ; break ; case '<' : _buffer . append ( ch , offset , i - offset ) . append ( LT ) ; offset = i + 1 ; break ; case '>' : _buffer . append ( ch , offset , i - offset ) . append ( GT ) ; offset = i + 1 ; break ; case ' ' : _buffer . append ( ch , offset , i - offset ) . append ( NBSP ) ; offset = i + 1 ; break ; default : if ( ( current >= '' && current < ' ' ) || ( _is8859Encoded && current > 'ÿ' ) ) { _buffer . append ( ch , offset , i - offset ) . append ( CHAR_ESC_START ) . append ( Integer . toString ( ( int ) ch [ i ] ) ) . append ( ';' ) ; offset = i + 1 ; } } } if ( offset < limit ) { _buffer . append ( ch , offset , limit - offset ) ; } } } 	1	['25', '3', '0', '7', '57', '232', '2', '5', '18', '0.901041667', '807', '1', '1', '0.676923077', '0.217592593', '2', '6', '30.96', '18', '2.24', '1']
package org . apache . xalan . templates ; import org . apache . xpath . * ; import org . apache . xpath . Expression ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . XPathParser ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . ExpressionOwner ; import org . apache . xml . dtm . DTM ; public class AVTPartXPath extends AVTPart { private XPath m_xpath ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_xpath . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { return m_xpath . getExpression ( ) . canTraverseOutsideSubtree ( ) ; } public AVTPartXPath ( XPath xpath ) { m_xpath = xpath ; } public AVTPartXPath ( String val , org . apache . xml . utils . PrefixResolver nsNode , XPathParser xpathProcessor , XPathFactory factory , XPathContext liaison ) throws javax . xml . transform . TransformerException { m_xpath = new XPath ( val , null , nsNode , XPath . SELECT , liaison . getErrorListener ( ) ) ; } public String getSimpleString ( ) { return "{" + m_xpath . getPatternString ( ) + "}" ; } public void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException { XObject xobj = m_xpath . execute ( xctxt , context , nsNode ) ; if ( null != xobj ) { xobj . appendToFsb ( buf ) ; } } public void callVisitors ( XSLTVisitor visitor ) { m_xpath . getExpression ( ) . callVisitors ( m_xpath , visitor ) ; } } 	0	['7', '2', '0', '14', '20', '0', '1', '13', '7', '0', '74', '1', '1', '0.5', '0.25974026', '0', '0', '9.428571429', '1', '0.7143', '0']
package org . apache . xalan . serialize ; import java . io . InputStream ; import java . io . Writer ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Properties ; public class Encodings extends Object { static final int m_defaultLastPrintable = 0x7F ; static final String ENCODINGS_FILE = "org/apache/xalan/serialize/Encodings.properties" ; private static final Class [ ] NO_CLASSES = new Class [ 0 ] ; private static final Object [ ] NO_OBJS = new Object [ 0 ] ; public static Writer getWriter ( OutputStream output , String encoding ) throws UnsupportedEncodingException { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { try { return new OutputStreamWriter ( output , _encodings [ i ] . javaName ) ; } catch ( java . lang . IllegalArgumentException iae ) { } catch ( UnsupportedEncodingException usee ) { } } } try { return new OutputStreamWriter ( output , encoding ) ; } catch ( java . lang . IllegalArgumentException iae ) { throw new UnsupportedEncodingException ( encoding ) ; } } public static Object getCharToByteConverter ( String encoding ) { Class charToByteConverterClass = null ; java . lang . reflect . Method getConverterMethod = null ; try { charToByteConverterClass = Class . forName ( "sun.io.CharToByteConverter" ) ; Class argTypes [ ] = new Class [ 1 ] ; argTypes [ 0 ] = String . class ; getConverterMethod = charToByteConverterClass . getMethod ( "getConverter" , argTypes ) ; } catch ( Exception e ) { System . err . println ( "Warning: Could not get charToByteConverterClass!" ) ; return null ; } Object args [ ] = new Object [ 1 ] ; for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { try { args [ 0 ] = _encodings [ i ] . javaName ; Object converter = getConverterMethod . invoke ( null , args ) ; if ( null != converter ) return converter ; } catch ( Exception iae ) { } } } return null ; } public static int getLastPrintable ( String encoding ) { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) || _encodings [ i ] . javaName . equalsIgnoreCase ( encoding ) ) return _encodings [ i ] . lastPrintable ; } return m_defaultLastPrintable ; } public static int getLastPrintable ( ) { return m_defaultLastPrintable ; } public static final String DEFAULT_MIME_ENCODING = "UTF-8" ; public static String getMimeEncoding ( String encoding ) { if ( null == encoding ) { try { encoding = System . getProperty ( "file.encoding" , "UTF8" ) ; if ( null != encoding ) { String jencoding = ( encoding . equalsIgnoreCase ( "Cp1252" ) || encoding . equalsIgnoreCase ( "ISO8859_1" ) || encoding . equalsIgnoreCase ( "8859_1" ) || encoding . equalsIgnoreCase ( "UTF8" ) ) ? DEFAULT_MIME_ENCODING : convertJava2MimeEncoding ( encoding ) ; encoding = ( null != jencoding ) ? jencoding : DEFAULT_MIME_ENCODING ; } else { encoding = DEFAULT_MIME_ENCODING ; } } catch ( SecurityException se ) { encoding = DEFAULT_MIME_ENCODING ; } } else { encoding = convertJava2MimeEncoding ( encoding ) ; } return encoding ; } public static String convertJava2MimeEncoding ( String encoding ) { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . javaName . equalsIgnoreCase ( encoding ) ) { return _encodings [ i ] . name ; } } return encoding ; } public static String convertMime2JavaEncoding ( String encoding ) { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { return _encodings [ i ] . javaName ; } } return encoding ; } private static EncodingInfo [ ] loadEncodingInfo ( ) { URL url = null ; try { String urlString = null ; try { urlString = System . getProperty ( "org.apache.xalan.serialize.encodings" , "" ) ; } catch ( SecurityException e ) { } if ( urlString != null && urlString . length ( ) > 0 ) url = new URL ( urlString ) ; if ( url == null ) { ClassLoader cl = null ; try { java . lang . reflect . Method getCCL = Thread . class . getMethod ( "getContextClassLoader" , NO_CLASSES ) ; if ( getCCL != null ) { cl = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; } } catch ( Exception e ) { } if ( cl != null ) { url = cl . getResource ( ENCODINGS_FILE ) ; } } if ( url == null ) url = ClassLoader . getSystemResource ( ENCODINGS_FILE ) ; Properties props = new Properties ( ) ; if ( url != null ) { InputStream is = url . openStream ( ) ; props . load ( is ) ; is . close ( ) ; } else { } int totalEntries = props . size ( ) ; EncodingInfo [ ] ret = new EncodingInfo [ totalEntries ] ; Enumeration keys = props . keys ( ) ; for ( int i = 0 ; i < totalEntries ; ++ i ) { String mimeName = ( String ) keys . nextElement ( ) ; String val = props . getProperty ( mimeName ) ; int pos = val . indexOf ( ' ' ) ; String javaName ; int lastPrintable ; if ( pos < 0 ) { javaName = val ; lastPrintable = 0x00FF ; } else { javaName = val . substring ( 0 , pos ) ; lastPrintable = Integer . decode ( val . substring ( pos ) . trim ( ) ) . intValue ( ) ; } ret [ i ] = new EncodingInfo ( mimeName , javaName , lastPrintable ) ; } return ret ; } catch ( java . net . MalformedURLException mue ) { throw new org . apache . xml . utils . WrappedRuntimeException ( mue ) ; } catch ( java . io . IOException ioe ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ioe ) ; } } private static final EncodingInfo [ ] _encodings = loadEncodingInfo ( ) ; } 	1	['11', '1', '0', '6', '43', '23', '4', '2', '8', '0.925', '419', '0.375', '1', '0', '0.3', '0', '0', '36.36363636', '10', '3.1818', '1']
package org . apache . xpath . operations ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . objects . XObject ; public abstract class UnaryOperation extends Expression implements ExpressionOwner { protected Expression m_right ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_right . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_right && m_right . canTraverseOutsideSubtree ( ) ) return true ; return false ; } public void setRight ( Expression r ) { m_right = r ; r . exprSetParent ( this ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return operate ( m_right . execute ( xctxt ) ) ; } public abstract XObject operate ( XObject right ) throws javax . xml . transform . TransformerException ; public Expression getOperand ( ) { return m_right ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitUnaryOperation ( owner , this ) ) { m_right . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_right ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_right = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_right . deepEquals ( ( ( UnaryOperation ) expr ) . m_right ) ) return false ; return true ; } } 	0	['11', '2', '4', '12', '20', '0', '6', '7', '11', '0.2', '88', '1', '1', '0.75', '0.227272727', '1', '7', '6.909090909', '3', '1.3636', '0']
package org . apache . xpath ; import java . io . File ; import java . io . IOException ; import java . util . Stack ; import java . util . Vector ; import java . lang . reflect . Method ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . NSInfo ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . NodeVector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xpath . axes . ContextNodeList ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XString ; import org . apache . xalan . extensions . ExpressionContext ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import javax . xml . transform . URIResolver ; import javax . xml . transform . TransformerException ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Source ; import javax . xml . transform . ErrorListener ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . Axis ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . utils . IntStack ; import org . apache . xpath . axes . DescendantIterator ; import org . apache . xml . dtm . ref . sax2dtm . SAX2RTFDTM ; public class XPathContext extends DTMManager { IntStack m_last_pushed_rtfdtm = new IntStack ( ) ; private Vector m_rtfdtm_stack = null ; private int m_which_rtfdtm = - 1 ; private SAX2RTFDTM m_global_rtfdtm = null ; protected DTMManager m_dtmManager = DTMManager . newInstance ( org . apache . xpath . objects . XMLStringFactoryImpl . getFactory ( ) ) ; public DTMManager getDTMManager ( ) { return m_dtmManager ; } public DTM getDTM ( javax . xml . transform . Source source , boolean unique , DTMWSFilter wsfilter , boolean incremental , boolean doIndexing ) { return m_dtmManager . getDTM ( source , unique , wsfilter , incremental , doIndexing ) ; } public DTM getDTM ( int nodeHandle ) { return m_dtmManager . getDTM ( nodeHandle ) ; } public int getDTMHandleFromNode ( org . w3c . dom . Node node ) { return m_dtmManager . getDTMHandleFromNode ( node ) ; } public int getDTMIdentity ( DTM dtm ) { return m_dtmManager . getDTMIdentity ( dtm ) ; } public DTM createDocumentFragment ( ) { return m_dtmManager . createDocumentFragment ( ) ; } public boolean release ( DTM dtm , boolean shouldHardDelete ) { if ( m_rtfdtm_stack != null && m_rtfdtm_stack . contains ( dtm ) ) { return false ; } return m_dtmManager . release ( dtm , shouldHardDelete ) ; } public DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) { return m_dtmManager . createDTMIterator ( xpathCompiler , pos ) ; } public DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) { return m_dtmManager . createDTMIterator ( xpathString , presolver ) ; } public DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) { return m_dtmManager . createDTMIterator ( whatToShow , filter , entityReferenceExpansion ) ; } public DTMIterator createDTMIterator ( int node ) { DTMIterator iter = new org . apache . xpath . axes . OneStepIteratorForward ( Axis . SELF ) ; iter . setRoot ( node , this ) ; return iter ; } public XPathContext ( ) { m_prefixResolvers [ m_prefixResolversTop ++ ] = null ; m_currentNodes [ m_currentNodesFirstFree ++ ] = DTM . NULL ; m_currentNodes [ m_currentExpressionNodesFirstFree ++ ] = DTM . NULL ; m_saxLocations [ m_saxLocationsTop ++ ] = null ; } public XPathContext ( Object owner ) { m_owner = owner ; try { m_ownerGetErrorListener = m_owner . getClass ( ) . getMethod ( "getErrorListener" , new Class [ ] { } ) ; } catch ( NoSuchMethodException nsme ) { } m_prefixResolvers [ m_prefixResolversTop ++ ] = null ; m_currentNodes [ m_currentNodesFirstFree ++ ] = DTM . NULL ; m_currentNodes [ m_currentExpressionNodesFirstFree ++ ] = DTM . NULL ; m_saxLocations [ m_saxLocationsTop ++ ] = null ; } public void reset ( ) { if ( m_rtfdtm_stack != null ) for ( java . util . Enumeration e = m_rtfdtm_stack . elements ( ) ; e . hasMoreElements ( ) ; ) m_dtmManager . release ( ( DTM ) e . nextElement ( ) , true ) ; m_rtfdtm_stack = null ; m_which_rtfdtm = - 1 ; if ( m_global_rtfdtm != null ) m_dtmManager . release ( m_global_rtfdtm , true ) ; m_global_rtfdtm = null ; m_dtmManager = DTMManager . newInstance ( org . apache . xpath . objects . XMLStringFactoryImpl . getFactory ( ) ) ; m_saxLocations = new SourceLocator [ RECURSIONLIMIT ] ; m_saxLocationsTop = 0 ; m_axesIteratorStack = new Stack ( ) ; m_contextNodeLists = new Stack ( ) ; m_currentExpressionNodes = new int [ RECURSIONLIMIT ] ; m_currentExpressionNodesFirstFree = 0 ; m_currentNodes = new int [ RECURSIONLIMIT ] ; m_currentNodesFirstFree = 0 ; m_iteratorRoots = new NodeVector ( ) ; m_predicatePos = new IntStack ( ) ; m_predicateRoots = new NodeVector ( ) ; m_prefixResolvers = new PrefixResolver [ RECURSIONLIMIT ] ; int m_prefixResolversTop = 0 ; m_prefixResolvers [ m_prefixResolversTop ++ ] = null ; m_currentNodes [ m_currentNodesFirstFree ++ ] = DTM . NULL ; m_currentNodes [ m_currentExpressionNodesFirstFree ++ ] = DTM . NULL ; m_saxLocations [ m_saxLocationsTop ++ ] = null ; } SourceLocator [ ] m_saxLocations = new SourceLocator [ RECURSIONLIMIT ] ; int m_saxLocationsTop = 0 ; public void setSAXLocator ( SourceLocator location ) { m_saxLocations [ m_saxLocationsTop - 1 ] = location ; } public void pushSAXLocator ( SourceLocator location ) { m_saxLocations [ m_saxLocationsTop ++ ] = location ; } public void pushSAXLocatorNull ( ) { m_saxLocationsTop ++ ; } public void popSAXLocator ( ) { m_saxLocationsTop -- ; } public SourceLocator getSAXLocator ( ) { return m_saxLocations [ m_saxLocationsTop - 1 ] ; } private Object m_owner ; private Method m_ownerGetErrorListener ; public Object getOwnerObject ( ) { return m_owner ; } private VariableStack m_variableStacks = new VariableStack ( ) ; public final VariableStack getVarStack ( ) { return m_variableStacks ; } public final void setVarStack ( VariableStack varStack ) { m_variableStacks = varStack ; } private SourceTreeManager m_sourceTreeManager = new SourceTreeManager ( ) ; public final SourceTreeManager getSourceTreeManager ( ) { return m_sourceTreeManager ; } public void setSourceTreeManager ( SourceTreeManager mgr ) { m_sourceTreeManager = mgr ; } private ErrorListener m_errorListener ; private ErrorListener m_defaultErrorListener ; public final ErrorListener getErrorListener ( ) { if ( null != m_errorListener ) return m_errorListener ; ErrorListener retval = null ; try { if ( null != m_ownerGetErrorListener ) retval = ( ErrorListener ) m_ownerGetErrorListener . invoke ( m_owner , new Object [ ] { } ) ; } catch ( Exception e ) { } if ( null == retval ) { if ( null == m_defaultErrorListener ) m_defaultErrorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; retval = m_defaultErrorListener ; } return retval ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , null ) ) ; m_errorListener = listener ; } private URIResolver m_uriResolver ; public final URIResolver getURIResolver ( ) { return m_uriResolver ; } public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public XMLReader m_primaryReader ; public final XMLReader getPrimaryReader ( ) { return m_primaryReader ; } public void setPrimaryReader ( XMLReader reader ) { m_primaryReader = reader ; } private static XSLMessages m_XSLMessages = new XSLMessages ( ) ; private void assertion ( boolean b , String msg ) throws javax . xml . transform . TransformerException { ErrorListener errorHandler = getErrorListener ( ) ; if ( errorHandler != null ) { errorHandler . fatalError ( new TransformerException ( m_XSLMessages . createMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) , ( SAXSourceLocator ) this . getSAXLocator ( ) ) ) ; } } private Stack m_contextNodeLists = new Stack ( ) ; public Stack getContextNodeListsStack ( ) { return m_contextNodeLists ; } public void setContextNodeListsStack ( Stack s ) { m_contextNodeLists = s ; } public final DTMIterator getContextNodeList ( ) { if ( m_contextNodeLists . size ( ) > 0 ) return ( DTMIterator ) m_contextNodeLists . peek ( ) ; else return null ; } public final void pushContextNodeList ( DTMIterator nl ) { m_contextNodeLists . push ( nl ) ; } public final void popContextNodeList ( ) { if ( m_contextNodeLists . isEmpty ( ) ) System . err . println ( "Warning: popContextNodeList when stack is empty!" ) ; else m_contextNodeLists . pop ( ) ; } public static final int RECURSIONLIMIT = ( 1024 * 4 ) ; private int m_currentNodes [ ] = new int [ RECURSIONLIMIT ] ; protected int m_currentNodesFirstFree = 0 ; public int [ ] getCurrentNodeStack ( ) { return m_currentNodes ; } public void setCurrentNodeStack ( int [ ] nv ) { m_currentNodes = nv ; } public final int getCurrentNode ( ) { return m_currentNodes [ m_currentNodesFirstFree - 1 ] ; } public final void pushCurrentNodeAndExpression ( int cn , int en ) { m_currentNodes [ m_currentNodesFirstFree ++ ] = cn ; m_currentExpressionNodes [ m_currentExpressionNodesFirstFree ++ ] = cn ; } public final void popCurrentNodeAndExpression ( ) { m_currentNodesFirstFree -- ; m_currentExpressionNodesFirstFree -- ; } public final void pushExpressionState ( int cn , int en , PrefixResolver nc ) { m_currentNodes [ m_currentNodesFirstFree ++ ] = cn ; m_currentExpressionNodes [ m_currentExpressionNodesFirstFree ++ ] = cn ; m_prefixResolvers [ m_prefixResolversTop ++ ] = nc ; } public final void popExpressionState ( ) { m_currentNodesFirstFree -- ; m_currentExpressionNodesFirstFree -- ; m_prefixResolversTop -- ; } public final void pushCurrentNode ( int n ) { m_currentNodes [ m_currentNodesFirstFree ++ ] = n ; } public int getCurrentNodeFirstFree ( ) { return m_currentNodesFirstFree ; } public final void popCurrentNode ( ) { m_currentNodesFirstFree -- ; } public final void pushPredicateRoot ( int n ) { m_predicateRoots . push ( n ) ; } public final void popPredicateRoot ( ) { m_predicateRoots . popQuick ( ) ; } public final int getPredicateRoot ( ) { return m_predicateRoots . peepOrNull ( ) ; } public final void pushIteratorRoot ( int n ) { m_iteratorRoots . push ( n ) ; } public final void popIteratorRoot ( ) { m_iteratorRoots . popQuick ( ) ; } public final int getIteratorRoot ( ) { return m_iteratorRoots . peepOrNull ( ) ; } private NodeVector m_iteratorRoots = new NodeVector ( ) ; private NodeVector m_predicateRoots = new NodeVector ( ) ; private int m_currentExpressionNodes [ ] = new int [ RECURSIONLIMIT ] ; protected int m_currentExpressionNodesFirstFree = 0 ; public int [ ] getCurrentExpressionNodeStack ( ) { return m_currentExpressionNodes ; } public void setCurrentExpressionNodeStack ( int [ ] nv ) { m_currentExpressionNodes = nv ; } public int getCurrentExpressionNodesFirstFree ( ) { return m_currentExpressionNodesFirstFree ; } private IntStack m_predicatePos = new IntStack ( ) ; public final int getPredicatePos ( ) { return m_predicatePos . peek ( ) ; } public final void pushPredicatePos ( int n ) { m_predicatePos . push ( n ) ; } public final void popPredicatePos ( ) { m_predicatePos . pop ( ) ; } public final int getCurrentExpressionNode ( ) { return m_currentExpressionNodes [ m_currentExpressionNodesFirstFree - 1 ] ; } public final void pushCurrentExpressionNode ( int n ) { m_currentExpressionNodes [ m_currentExpressionNodesFirstFree ++ ] = n ; } public final void popCurrentExpressionNode ( ) { m_currentExpressionNodesFirstFree -- ; } private PrefixResolver [ ] m_prefixResolvers = new PrefixResolver [ RECURSIONLIMIT ] ; private int m_prefixResolversTop = 0 ; public final PrefixResolver getNamespaceContext ( ) { return m_prefixResolvers [ m_prefixResolversTop - 1 ] ; } public final void setNamespaceContext ( PrefixResolver pr ) { m_prefixResolvers [ m_prefixResolversTop - 1 ] = pr ; } public final void pushNamespaceContext ( PrefixResolver pr ) { m_prefixResolvers [ m_prefixResolversTop ++ ] = pr ; } public final void pushNamespaceContextNull ( ) { m_prefixResolversTop ++ ; } public final void popNamespaceContext ( ) { m_prefixResolversTop -- ; } private Stack m_axesIteratorStack = new Stack ( ) ; public Stack getAxesIteratorStackStacks ( ) { return m_axesIteratorStack ; } public void setAxesIteratorStackStacks ( Stack s ) { m_axesIteratorStack = s ; } public final void pushSubContextList ( SubContextList iter ) { m_axesIteratorStack . push ( iter ) ; } public final void popSubContextList ( ) { m_axesIteratorStack . pop ( ) ; } public SubContextList getSubContextList ( ) { return m_axesIteratorStack . isEmpty ( ) ? null : ( SubContextList ) m_axesIteratorStack . peek ( ) ; } public org . apache . xpath . axes . LocPathIterator getCurrentNodeList ( ) { for ( int i = m_axesIteratorStack . size ( ) - 1 ; i >= 0 ; i -- ) { org . apache . xpath . axes . PredicatedNodeTest iter = ( org . apache . xpath . axes . PredicatedNodeTest ) m_axesIteratorStack . elementAt ( i ) ; org . apache . xpath . axes . LocPathIterator lpi = iter . getLocPathIterator ( ) ; if ( lpi . getIsTopLevel ( ) ) return lpi ; } return null ; } public final int getContextNode ( ) { return this . getCurrentNode ( ) ; } public final DTMIterator getContextNodes ( ) { try { DTMIterator cnl = getContextNodeList ( ) ; if ( null != cnl ) return cnl . cloneWithReset ( ) ; else return null ; } catch ( CloneNotSupportedException cnse ) { return null ; } } XPathExpressionContext expressionContext = new XPathExpressionContext ( ) ; public ExpressionContext getExpressionContext ( ) { return expressionContext ; } public class XPathExpressionContext implements ExpressionContext { public XPathContext getXPathContext ( ) { return XPathContext . this ; } public DTMManager getDTMManager ( ) { return m_dtmManager ; } public org . w3c . dom . Node getContextNode ( ) { int context = getCurrentNode ( ) ; return getDTM ( context ) . getNode ( context ) ; } public org . w3c . dom . traversal . NodeIterator getContextNodes ( ) { return new org . apache . xml . dtm . ref . DTMNodeIterator ( getContextNodeList ( ) ) ; } public double toNumber ( org . w3c . dom . Node n ) { int nodeHandle = getDTMHandleFromNode ( n ) ; DTM dtm = getDTM ( nodeHandle ) ; XString xobj = ( XString ) dtm . getStringValue ( nodeHandle ) ; return xobj . num ( ) ; } public String toString ( org . w3c . dom . Node n ) { int nodeHandle = getDTMHandleFromNode ( n ) ; DTM dtm = getDTM ( nodeHandle ) ; XMLString strVal = dtm . getStringValue ( nodeHandle ) ; return strVal . toString ( ) ; } public final XObject getVariableOrParam ( org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException { return m_variableStacks . getVariableOrParam ( XPathContext . this , qname ) ; } } public DTM getGlobalRTFDTM ( ) { if ( m_global_rtfdtm == null || m_global_rtfdtm . isTreeIncomplete ( ) ) { m_global_rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; } return m_global_rtfdtm ; } public DTM getRTFDTM ( ) { SAX2RTFDTM rtfdtm ; if ( m_rtfdtm_stack == null ) { m_rtfdtm_stack = new Vector ( ) ; rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; m_rtfdtm_stack . addElement ( rtfdtm ) ; ++ m_which_rtfdtm ; } else if ( m_which_rtfdtm < 0 ) { rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( ++ m_which_rtfdtm ) ; } else { rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ; if ( rtfdtm . isTreeIncomplete ( ) ) { if ( ++ m_which_rtfdtm < m_rtfdtm_stack . size ( ) ) rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ; else { rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; m_rtfdtm_stack . addElement ( rtfdtm ) ; } } } return rtfdtm ; } public void pushRTFContext ( ) { m_last_pushed_rtfdtm . push ( m_which_rtfdtm ) ; if ( null != m_rtfdtm_stack ) ( ( SAX2RTFDTM ) ( getRTFDTM ( ) ) ) . pushRewindMark ( ) ; } public void popRTFContext ( ) { if ( null == m_rtfdtm_stack ) return ; int previous = m_last_pushed_rtfdtm . pop ( ) ; if ( m_which_rtfdtm == previous ) { if ( previous >= 0 ) { boolean isEmpty = ( ( SAX2RTFDTM ) ( m_rtfdtm_stack . elementAt ( previous ) ) ) . popRewindMark ( ) ; } } else while ( m_which_rtfdtm != previous ) { boolean isEmpty = ( ( SAX2RTFDTM ) ( m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ) ) . popRewindMark ( ) ; -- m_which_rtfdtm ; } } } 	1	['81', '2', '1', '171', '136', '2426', '155', '22', '78', '0.936206897', '1294', '0.793103448', '11', '0.195876289', '0.069318182', '0', '0', '14.61728395', '5', '1.2716', '3']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemParam ; import javax . xml . transform . TransformerException ; import org . xml . sax . Attributes ; class ProcessorGlobalParamDecl extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { handler . pushElemTemplateElement ( elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ElemParam v = ( ElemParam ) handler . getElemTemplateElement ( ) ; handler . getStylesheet ( ) . appendChild ( v ) ; handler . getStylesheet ( ) . setParam ( v ) ; super . endElement ( handler , uri , localName , rawName ) ; } } 	0	['3', '5', '0', '6', '10', '3', '1', '5', '1', '2', '30', '0', '0', '0.990697674', '0.583333333', '1', '2', '9', '1', '0.6667', '0']
package org . apache . xalan . processor ; import java . util . Hashtable ; import org . apache . xalan . templates . * ; import org . apache . xml . utils . QName ; public class XSLTSchema extends XSLTElementDef { XSLTSchema ( ) { build ( ) ; } void build ( ) { XSLTAttributeDef hrefAttr = new XSLTAttributeDef ( null , "href" , XSLTAttributeDef . T_URL , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef elementsAttr = new XSLTAttributeDef ( null , "elements" , XSLTAttributeDef . T_SIMPLEPATTERNLIST , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef methodAttr = new XSLTAttributeDef ( null , "method" , XSLTAttributeDef . T_QNAME , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef versionAttr = new XSLTAttributeDef ( null , "version" , XSLTAttributeDef . T_NMTOKEN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef encodingAttr = new XSLTAttributeDef ( null , "encoding" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef omitXmlDeclarationAttr = new XSLTAttributeDef ( null , "omit-xml-declaration" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef standaloneAttr = new XSLTAttributeDef ( null , "standalone" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef doctypePublicAttr = new XSLTAttributeDef ( null , "doctype-public" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef doctypeSystemAttr = new XSLTAttributeDef ( null , "doctype-system" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef cdataSectionElementsAttr = new XSLTAttributeDef ( null , "cdata-section-elements" , XSLTAttributeDef . T_QNAMES_RESOLVE_NULL , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef indentAttr = new XSLTAttributeDef ( null , "indent" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef mediaTypeAttr = new XSLTAttributeDef ( null , "media-type" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef nameAttrRequired = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_QNAME , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef nameAVTRequired = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_AVT_QNAME , true , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef nameAVT_NCNAMERequired = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_NCNAME , true , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef nameAttrOpt_ERROR = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_QNAME , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef useAttr = new XSLTAttributeDef ( null , "use" , XSLTAttributeDef . T_EXPR , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef namespaceAVTOpt = new XSLTAttributeDef ( null , "namespace" , XSLTAttributeDef . T_URL , false , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef decimalSeparatorAttr = new XSLTAttributeDef ( null , "decimal-separator" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "." ) ; XSLTAttributeDef infinityAttr = new XSLTAttributeDef ( null , "infinity" , XSLTAttributeDef . T_CDATA , false , XSLTAttributeDef . ERROR , "Infinity" ) ; XSLTAttributeDef minusSignAttr = new XSLTAttributeDef ( null , "minus-sign" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "-" ) ; XSLTAttributeDef NaNAttr = new XSLTAttributeDef ( null , "NaN" , XSLTAttributeDef . T_CDATA , false , XSLTAttributeDef . ERROR , "NaN" ) ; XSLTAttributeDef percentAttr = new XSLTAttributeDef ( null , "percent" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "%" ) ; XSLTAttributeDef perMilleAttr = new XSLTAttributeDef ( null , "per-mille" , XSLTAttributeDef . T_CHAR , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef zeroDigitAttr = new XSLTAttributeDef ( null , "zero-digit" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "0" ) ; XSLTAttributeDef digitAttr = new XSLTAttributeDef ( null , "digit" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "#" ) ; XSLTAttributeDef patternSeparatorAttr = new XSLTAttributeDef ( null , "pattern-separator" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , ";" ) ; XSLTAttributeDef groupingSeparatorAttr = new XSLTAttributeDef ( null , "grouping-separator" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "," ) ; XSLTAttributeDef useAttributeSetsAttr = new XSLTAttributeDef ( null , "use-attribute-sets" , XSLTAttributeDef . T_QNAMES , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef testAttrRequired = new XSLTAttributeDef ( null , "test" , XSLTAttributeDef . T_EXPR , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef selectAttrRequired = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef selectAttrOpt = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef selectAttrDefNode = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , false , XSLTAttributeDef . ERROR , "node()" ) ; XSLTAttributeDef selectAttrDefDot = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , false , XSLTAttributeDef . ERROR , "." ) ; XSLTAttributeDef matchAttrRequired = new XSLTAttributeDef ( null , "match" , XSLTAttributeDef . T_PATTERN , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef matchAttrOpt = new XSLTAttributeDef ( null , "match" , XSLTAttributeDef . T_PATTERN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef priorityAttr = new XSLTAttributeDef ( null , "priority" , XSLTAttributeDef . T_NUMBER , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef modeAttr = new XSLTAttributeDef ( null , "mode" , XSLTAttributeDef . T_QNAME , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef spaceAttr = new XSLTAttributeDef ( Constants . S_XMLNAMESPACEURI , "space" , false , false , false , XSLTAttributeDef . WARNING , "default" , Constants . ATTRVAL_STRIP , "preserve" , Constants . ATTRVAL_PRESERVE ) ; XSLTAttributeDef spaceAttrLiteral = new XSLTAttributeDef ( Constants . S_XMLNAMESPACEURI , "space" , XSLTAttributeDef . T_URL , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef stylesheetPrefixAttr = new XSLTAttributeDef ( null , "stylesheet-prefix" , XSLTAttributeDef . T_CDATA , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef resultPrefixAttr = new XSLTAttributeDef ( null , "result-prefix" , XSLTAttributeDef . T_CDATA , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef disableOutputEscapingAttr = new XSLTAttributeDef ( null , "disable-output-escaping" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef levelAttr = new XSLTAttributeDef ( null , "level" , false , false , false , XSLTAttributeDef . ERROR , "single" , Constants . NUMBERLEVEL_SINGLE , "multiple" , Constants . NUMBERLEVEL_MULTI , "any" , Constants . NUMBERLEVEL_ANY ) ; levelAttr . setDefault ( "single" ) ; XSLTAttributeDef countAttr = new XSLTAttributeDef ( null , "count" , XSLTAttributeDef . T_PATTERN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef fromAttr = new XSLTAttributeDef ( null , "from" , XSLTAttributeDef . T_PATTERN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef valueAttr = new XSLTAttributeDef ( null , "value" , XSLTAttributeDef . T_EXPR , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef formatAttr = new XSLTAttributeDef ( null , "format" , XSLTAttributeDef . T_CDATA , false , true , XSLTAttributeDef . ERROR ) ; formatAttr . setDefault ( "1" ) ; XSLTAttributeDef langAttr = new XSLTAttributeDef ( null , "lang" , XSLTAttributeDef . T_NMTOKEN , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef letterValueAttr = new XSLTAttributeDef ( null , "letter-value" , false , true , false , XSLTAttributeDef . ERROR , "alphabetic" , Constants . NUMBERLETTER_ALPHABETIC , "traditional" , Constants . NUMBERLETTER_TRADITIONAL ) ; XSLTAttributeDef groupingSeparatorAVT = new XSLTAttributeDef ( null , "grouping-separator" , XSLTAttributeDef . T_CHAR , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef groupingSizeAttr = new XSLTAttributeDef ( null , "grouping-size" , XSLTAttributeDef . T_NUMBER , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef dataTypeAttr = new XSLTAttributeDef ( null , "data-type" , false , true , true , XSLTAttributeDef . ERROR , "text" , Constants . SORTDATATYPE_TEXT , "number" , Constants . SORTDATATYPE_TEXT ) ; dataTypeAttr . setDefault ( "text" ) ; XSLTAttributeDef orderAttr = new XSLTAttributeDef ( null , "order" , false , true , false , XSLTAttributeDef . ERROR , "ascending" , Constants . SORTORDER_ASCENDING , "descending" , Constants . SORTORDER_DESCENDING ) ; orderAttr . setDefault ( "ascending" ) ; XSLTAttributeDef caseOrderAttr = new XSLTAttributeDef ( null , "case-order" , false , true , false , XSLTAttributeDef . ERROR , "upper-first" , Constants . SORTCASEORDER_UPPERFIRST , "lower-first" , Constants . SORTCASEORDER_LOWERFIRST ) ; XSLTAttributeDef terminateAttr = new XSLTAttributeDef ( null , "terminate" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; terminateAttr . setDefault ( "no" ) ; XSLTAttributeDef xslExcludeResultPrefixesAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "exclude-result-prefixes" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef xslExtensionElementPrefixesAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "extension-element-prefixes" , XSLTAttributeDef . T_PREFIX_URLLIST , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef xslUseAttributeSetsAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "use-attribute-sets" , XSLTAttributeDef . T_QNAMES , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef xslVersionAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "version" , XSLTAttributeDef . T_NMTOKEN , false , false , XSLTAttributeDef . ERROR ) ; XSLTElementDef charData = new XSLTElementDef ( this , null , "text()" , null , null , null , new ProcessorCharacters ( ) , ElemTextLiteral . class ) ; charData . setType ( XSLTElementDef . T_PCDATA ) ; XSLTElementDef whiteSpaceOnly = new XSLTElementDef ( this , null , "text()" , null , null , null , null , ElemTextLiteral . class ) ; charData . setType ( XSLTElementDef . T_PCDATA ) ; XSLTAttributeDef resultAttr = new XSLTAttributeDef ( null , "*" , XSLTAttributeDef . T_AVT , false , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef xslResultAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "*" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . WARNING ) ; XSLTElementDef [ ] templateElements = new XSLTElementDef [ 22 ] ; XSLTElementDef [ ] templateElementsAndParams = new XSLTElementDef [ 23 ] ; XSLTElementDef [ ] templateElementsAndSort = new XSLTElementDef [ 23 ] ; XSLTElementDef [ ] exsltFunctionElements = new XSLTElementDef [ 23 ] ; XSLTElementDef [ ] charTemplateElements = new XSLTElementDef [ 15 ] ; XSLTElementDef resultElement = new XSLTElementDef ( this , null , "*" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttrLiteral , xslExcludeResultPrefixesAttr , xslExtensionElementPrefixesAttr , xslUseAttributeSetsAttr , xslVersionAttr , xslResultAttr , resultAttr } , new ProcessorLRE ( ) , ElemLiteralResult . class , 20 , true ) ; XSLTElementDef unknownElement = new XSLTElementDef ( this , "*" , "unknown" , null , templateElementsAndParams , new XSLTAttributeDef [ ] { xslExcludeResultPrefixesAttr , xslExtensionElementPrefixesAttr , xslUseAttributeSetsAttr , xslVersionAttr , xslResultAttr , resultAttr } , new ProcessorUnknown ( ) , ElemUnknown . class , 20 , true ) ; XSLTElementDef xslValueOf = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "value-of" , null , null , new XSLTAttributeDef [ ] { selectAttrRequired , disableOutputEscapingAttr } , new ProcessorTemplateElem ( ) , ElemValueOf . class , 20 , true ) ; XSLTElementDef xslCopyOf = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "copy-of" , null , null , new XSLTAttributeDef [ ] { selectAttrRequired } , new ProcessorTemplateElem ( ) , ElemCopyOf . class , 20 , true ) ; XSLTElementDef xslNumber = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "number" , null , null , new XSLTAttributeDef [ ] { levelAttr , countAttr , fromAttr , valueAttr , formatAttr , langAttr , letterValueAttr , groupingSeparatorAVT , groupingSizeAttr } , new ProcessorTemplateElem ( ) , ElemNumber . class , 20 , true ) ; XSLTElementDef xslSort = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "sort" , null , null , new XSLTAttributeDef [ ] { selectAttrDefDot , langAttr , dataTypeAttr , orderAttr , caseOrderAttr } , new ProcessorTemplateElem ( ) , ElemSort . class , 19 , true ) ; XSLTElementDef xslWithParam = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "with-param" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorTemplateElem ( ) , ElemWithParam . class , 19 , true ) ; XSLTElementDef xslApplyTemplates = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "apply-templates" , null , new XSLTElementDef [ ] { xslSort , xslWithParam } , new XSLTAttributeDef [ ] { selectAttrDefNode , modeAttr } , new ProcessorTemplateElem ( ) , ElemApplyTemplates . class , 20 , true ) ; XSLTElementDef xslApplyImports = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "apply-imports" , null , null , new XSLTAttributeDef [ ] { } , new ProcessorTemplateElem ( ) , ElemApplyImport . class ) ; XSLTElementDef xslForEach = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "for-each" , null , templateElementsAndSort , new XSLTAttributeDef [ ] { selectAttrRequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemForEach . class , true , false , true , 20 , true ) ; XSLTElementDef xslIf = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "if" , null , templateElements , new XSLTAttributeDef [ ] { testAttrRequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemIf . class , 20 , true ) ; XSLTElementDef xslWhen = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "when" , null , templateElements , new XSLTAttributeDef [ ] { testAttrRequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemWhen . class , false , true , 1 , true ) ; XSLTElementDef xslOtherwise = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "otherwise" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemOtherwise . class , false , false , 2 , false ) ; XSLTElementDef xslChoose = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "choose" , null , new XSLTElementDef [ ] { xslWhen , xslOtherwise } , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemChoose . class , true , false , true , 20 , true ) ; XSLTElementDef xslAttribute = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "attribute" , null , charTemplateElements , new XSLTAttributeDef [ ] { nameAVTRequired , namespaceAVTOpt , spaceAttr } , new ProcessorTemplateElem ( ) , ElemAttribute . class , 20 , true ) ; XSLTElementDef xslCallTemplate = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "call-template" , null , new XSLTElementDef [ ] { xslWithParam } , new XSLTAttributeDef [ ] { nameAttrRequired } , new ProcessorTemplateElem ( ) , ElemCallTemplate . class , 20 , true ) ; XSLTElementDef xslVariable = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "variable" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorTemplateElem ( ) , ElemVariable . class , 20 , true ) ; XSLTElementDef xslParam = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "param" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorTemplateElem ( ) , ElemParam . class , 19 , true ) ; XSLTElementDef xslText = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "text" , null , new XSLTElementDef [ ] { charData } , new XSLTAttributeDef [ ] { disableOutputEscapingAttr } , new ProcessorText ( ) , ElemText . class , 20 , true ) ; XSLTElementDef xslProcessingInstruction = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "processing-instruction" , null , charTemplateElements , new XSLTAttributeDef [ ] { nameAVT_NCNAMERequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemPI . class , 20 , true ) ; XSLTElementDef xslElement = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "element" , null , templateElements , new XSLTAttributeDef [ ] { nameAVTRequired , namespaceAVTOpt , useAttributeSetsAttr , spaceAttr } , new ProcessorTemplateElem ( ) , ElemElement . class , 20 , true ) ; XSLTElementDef xslComment = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "comment" , null , charTemplateElements , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemComment . class , 20 , true ) ; XSLTElementDef xslCopy = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "copy" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttr , useAttributeSetsAttr } , new ProcessorTemplateElem ( ) , ElemCopy . class , 20 , true ) ; XSLTElementDef xslMessage = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "message" , null , templateElements , new XSLTAttributeDef [ ] { terminateAttr } , new ProcessorTemplateElem ( ) , ElemMessage . class , 20 , true ) ; XSLTElementDef xslFallback = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "fallback" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemFallback . class , 20 , true ) ; XSLTElementDef exsltFunction = new XSLTElementDef ( this , Constants . S_EXSLT_FUNCTIONS_URL , "function" , null , exsltFunctionElements , new XSLTAttributeDef [ ] { nameAttrRequired } , new ProcessorExsltFunction ( ) , ElemExsltFunction . class ) ; XSLTElementDef exsltResult = new XSLTElementDef ( this , Constants . S_EXSLT_FUNCTIONS_URL , "result" , null , templateElements , new XSLTAttributeDef [ ] { selectAttrOpt } , new ProcessorExsltFuncResult ( ) , ElemExsltFuncResult . class ) ; int i = 0 ; templateElements [ i ++ ] = charData ; templateElements [ i ++ ] = xslApplyTemplates ; templateElements [ i ++ ] = xslCallTemplate ; templateElements [ i ++ ] = xslApplyImports ; templateElements [ i ++ ] = xslForEach ; templateElements [ i ++ ] = xslValueOf ; templateElements [ i ++ ] = xslCopyOf ; templateElements [ i ++ ] = xslNumber ; templateElements [ i ++ ] = xslChoose ; templateElements [ i ++ ] = xslIf ; templateElements [ i ++ ] = xslText ; templateElements [ i ++ ] = xslCopy ; templateElements [ i ++ ] = xslVariable ; templateElements [ i ++ ] = xslMessage ; templateElements [ i ++ ] = xslFallback ; templateElements [ i ++ ] = xslProcessingInstruction ; templateElements [ i ++ ] = xslComment ; templateElements [ i ++ ] = xslElement ; templateElements [ i ++ ] = xslAttribute ; templateElements [ i ++ ] = resultElement ; templateElements [ i ++ ] = unknownElement ; templateElements [ i ++ ] = exsltResult ; int k ; for ( k = 0 ; k < i ; k ++ ) { templateElementsAndParams [ k ] = templateElements [ k ] ; templateElementsAndSort [ k ] = templateElements [ k ] ; exsltFunctionElements [ k ] = templateElements [ k ] ; } templateElementsAndParams [ k ] = xslParam ; templateElementsAndSort [ k ] = xslSort ; exsltFunctionElements [ k ] = xslParam ; i = 0 ; charTemplateElements [ i ++ ] = charData ; charTemplateElements [ i ++ ] = xslApplyTemplates ; charTemplateElements [ i ++ ] = xslCallTemplate ; charTemplateElements [ i ++ ] = xslApplyImports ; charTemplateElements [ i ++ ] = xslForEach ; charTemplateElements [ i ++ ] = xslValueOf ; charTemplateElements [ i ++ ] = xslCopyOf ; charTemplateElements [ i ++ ] = xslNumber ; charTemplateElements [ i ++ ] = xslChoose ; charTemplateElements [ i ++ ] = xslIf ; charTemplateElements [ i ++ ] = xslText ; charTemplateElements [ i ++ ] = xslCopy ; charTemplateElements [ i ++ ] = xslVariable ; charTemplateElements [ i ++ ] = xslMessage ; charTemplateElements [ i ++ ] = xslFallback ; XSLTElementDef importDef = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "import" , null , null , new XSLTAttributeDef [ ] { hrefAttr } , new ProcessorImport ( ) , null , 1 , true ) ; XSLTElementDef includeDef = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "include" , null , null , new XSLTAttributeDef [ ] { hrefAttr } , new ProcessorInclude ( ) , null , 20 , true ) ; XSLTElementDef [ ] topLevelElements = new XSLTElementDef [ ] { includeDef , importDef , whiteSpaceOnly , unknownElement , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "strip-space" , null , null , new XSLTAttributeDef [ ] { elementsAttr } , new ProcessorStripSpace ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "preserve-space" , null , null , new XSLTAttributeDef [ ] { elementsAttr } , new ProcessorPreserveSpace ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "output" , null , null , new XSLTAttributeDef [ ] { methodAttr , versionAttr , encodingAttr , omitXmlDeclarationAttr , standaloneAttr , doctypePublicAttr , doctypeSystemAttr , cdataSectionElementsAttr , indentAttr , mediaTypeAttr , XSLTAttributeDef . m_foreignAttr } , new ProcessorOutputElem ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "key" , null , null , new XSLTAttributeDef [ ] { nameAttrRequired , matchAttrRequired , useAttr } , new ProcessorKey ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "decimal-format" , null , null , new XSLTAttributeDef [ ] { nameAttrOpt_ERROR , decimalSeparatorAttr , groupingSeparatorAttr , infinityAttr , minusSignAttr , NaNAttr , percentAttr , perMilleAttr , zeroDigitAttr , digitAttr , patternSeparatorAttr } , new ProcessorDecimalFormat ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "attribute-set" , null , new XSLTElementDef [ ] { xslAttribute } , new XSLTAttributeDef [ ] { nameAttrRequired , useAttributeSetsAttr } , new ProcessorAttributeSet ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "variable" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorGlobalVariableDecl ( ) , ElemVariable . class , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "param" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorGlobalParamDecl ( ) , ElemParam . class , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "template" , null , templateElementsAndParams , new XSLTAttributeDef [ ] { matchAttrOpt , nameAttrOpt_ERROR , priorityAttr , modeAttr , spaceAttr } , new ProcessorTemplate ( ) , ElemTemplate . class , true , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "namespace-alias" , null , null , new XSLTAttributeDef [ ] { stylesheetPrefixAttr , resultPrefixAttr } , new ProcessorNamespaceAlias ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_BUILTIN_EXTENSIONS_URL , "component" , null , new XSLTElementDef [ ] { new XSLTElementDef ( this , Constants . S_BUILTIN_EXTENSIONS_URL , "script" , null , new XSLTElementDef [ ] { charData } , new XSLTAttributeDef [ ] { new XSLTAttributeDef ( null , "lang" , XSLTAttributeDef . T_NMTOKEN , true , false , XSLTAttributeDef . WARNING ) , new XSLTAttributeDef ( null , "src" , XSLTAttributeDef . T_URL , false , false , XSLTAttributeDef . WARNING ) } , new ProcessorLRE ( ) , ElemExtensionScript . class , 20 , true ) } , new XSLTAttributeDef [ ] { new XSLTAttributeDef ( null , "prefix" , XSLTAttributeDef . T_NMTOKEN , true , false , XSLTAttributeDef . WARNING ) , new XSLTAttributeDef ( null , "elements" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . WARNING ) , new XSLTAttributeDef ( null , "functions" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . WARNING ) } , new ProcessorLRE ( ) , ElemExtensionDecl . class ) , exsltFunction } ; XSLTAttributeDef excludeResultPrefixesAttr = new XSLTAttributeDef ( null , "exclude-result-prefixes" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef extensionElementPrefixesAttr = new XSLTAttributeDef ( null , "extension-element-prefixes" , XSLTAttributeDef . T_PREFIX_URLLIST , false , false , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef idAttr = new XSLTAttributeDef ( null , "id" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef versionAttrRequired = new XSLTAttributeDef ( null , "version" , XSLTAttributeDef . T_NMTOKEN , true , false , XSLTAttributeDef . WARNING ) ; XSLTElementDef stylesheetElemDef = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "stylesheet" , "transform" , topLevelElements , new XSLTAttributeDef [ ] { extensionElementPrefixesAttr , excludeResultPrefixesAttr , idAttr , versionAttrRequired , spaceAttr } , new ProcessorStylesheetElement ( ) , null , true , - 1 , false ) ; importDef . setElements ( new XSLTElementDef [ ] { stylesheetElemDef , resultElement , unknownElement } ) ; includeDef . setElements ( new XSLTElementDef [ ] { stylesheetElemDef , resultElement , unknownElement } ) ; build ( null , null , null , new XSLTElementDef [ ] { stylesheetElemDef , whiteSpaceOnly , resultElement , unknownElement } , null , new ProcessorStylesheetDoc ( ) , null ) ; } private Hashtable m_availElems = new Hashtable ( ) ; public Hashtable getElemsAvailable ( ) { return m_availElems ; } void addAvailableElement ( QName elemName ) { m_availElems . put ( elemName , elemName ) ; } public boolean elementAvailable ( QName elemName ) { return m_availElems . containsKey ( elemName ) ; } } 	1	['6', '2', '0', '27', '47', '3', '5', '25', '2', '0.7875', '2654', '0.03125', '0', '0.848484848', '0.444444444', '1', '2', '436', '36', '6.6667', '2']
package org . apache . xalan . xsltc . compiler . util ; import java . util . Vector ; import org . apache . bcel . generic . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . Template ; public final class NamedMethodGenerator extends MethodGenerator { protected static int CURRENT_INDEX = 4 ; public NamedMethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_INDEX ; } return super . getLocalIndex ( name ) ; } } 	0	['3', '5', '0', '5', '6', '1', '1', '4', '2', '0.5', '28', '1', '0', '0.992805755', '0.625', '2', '3', '8', '2', '0.6667', '0']
package org . apache . xpath . objects ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . XPathContext ; import org . w3c . dom . NodeList ; import org . apache . xml . dtm . Axis ; import org . apache . xpath . axes . RTFIterator ; public class XRTreeFrag extends XObject implements Cloneable { DTM m_dtm ; int m_dtmRoot ; XPathContext m_xctxt ; boolean m_allowRelease = false ; public XRTreeFrag ( int root , XPathContext xctxt , ExpressionNode parent ) { super ( null ) ; exprSetParent ( parent ) ; m_dtmRoot = root ; m_xctxt = xctxt ; m_dtm = xctxt . getDTM ( root ) ; } public XRTreeFrag ( int root , XPathContext xctxt ) { super ( null ) ; m_dtmRoot = root ; m_xctxt = xctxt ; m_dtm = xctxt . getDTM ( root ) ; } public Object object ( ) { if ( m_xctxt != null ) return new org . apache . xml . dtm . ref . DTMNodeIterator ( ( DTMIterator ) ( new org . apache . xpath . NodeSetDTM ( m_dtmRoot , m_xctxt . getDTMManager ( ) ) ) ) ; else return super . object ( ) ; } public XRTreeFrag ( Expression expr ) { super ( expr ) ; } protected void finalize ( ) throws Throwable { try { destruct ( ) ; } finally { super . finalize ( ) ; } } public void allowDetachToRelease ( boolean allowRelease ) { m_allowRelease = allowRelease ; } public void detach ( ) { if ( m_allowRelease ) { int ident = m_xctxt . getDTMIdentity ( m_dtm ) ; DTM foundDTM = m_xctxt . getDTM ( ident ) ; if ( foundDTM == m_dtm ) { m_xctxt . release ( m_dtm , true ) ; m_dtm = null ; m_xctxt = null ; } m_obj = null ; } } public void destruct ( ) { if ( null != m_dtm ) { int ident = m_xctxt . getDTMIdentity ( m_dtm ) ; DTM foundDTM = m_xctxt . getDTM ( ident ) ; if ( foundDTM == m_dtm ) { m_xctxt . release ( m_dtm , true ) ; m_dtm = null ; m_xctxt = null ; } } m_obj = null ; } public int getType ( ) { return CLASS_RTREEFRAG ; } public String getTypeString ( ) { return "#RTREEFRAG" ; } public double num ( ) throws javax . xml . transform . TransformerException { XMLString s = xstr ( ) ; return s . toDouble ( ) ; } public boolean bool ( ) { return true ; } private XMLString m_xmlStr = null ; public XMLString xstr ( ) { if ( null == m_xmlStr ) m_xmlStr = m_dtm . getStringValue ( m_dtmRoot ) ; return m_xmlStr ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { XString xstring = ( XString ) xstr ( ) ; xstring . appendToFsb ( fsb ) ; } public String str ( ) { String str = m_dtm . getStringValue ( m_dtmRoot ) . toString ( ) ; return ( null == str ) ? "" : str ; } public int rtf ( ) { return m_dtmRoot ; } public DTMIterator asNodeIterator ( ) { DTMIterator iter = new RTFIterator ( Axis . SELF ) ; iter . setRoot ( m_dtmRoot , m_xctxt ) ; return iter ; } public NodeList convertToNodeset ( ) { if ( m_obj instanceof NodeList ) return ( NodeList ) m_obj ; else return new org . apache . xml . dtm . ref . DTMNodeList ( asNodeIterator ( ) ) ; } public boolean equals ( XObject obj2 ) { try { if ( XObject . CLASS_NODESET == obj2 . getType ( ) ) { return obj2 . equals ( this ) ; } else if ( XObject . CLASS_BOOLEAN == obj2 . getType ( ) ) { return bool ( ) == obj2 . bool ( ) ; } else if ( XObject . CLASS_NUMBER == obj2 . getType ( ) ) { return num ( ) == obj2 . num ( ) ; } else if ( XObject . CLASS_NODESET == obj2 . getType ( ) ) { return xstr ( ) . equals ( obj2 . xstr ( ) ) ; } else if ( XObject . CLASS_STRING == obj2 . getType ( ) ) { return xstr ( ) . equals ( obj2 . xstr ( ) ) ; } else if ( XObject . CLASS_RTREEFRAG == obj2 . getType ( ) ) { return xstr ( ) . equals ( obj2 . xstr ( ) ) ; } else { return super . equals ( obj2 ) ; } } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } 	1	['19', '3', '1', '21', '43', '87', '6', '15', '18', '0.6', '336', '0.2', '3', '0.816091954', '0.184210526', '2', '24', '16.42105263', '9', '1.6842', '1']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import javax . xml . transform . TransformerException ; import org . xml . sax . Attributes ; class ProcessorTemplate extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { super . appendAndPush ( handler , elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; handler . getStylesheet ( ) . setTemplate ( ( ElemTemplate ) elem ) ; } } 	0	['2', '5', '0', '6', '8', '1', '1', '5', '0', '2', '19', '0', '0', '0.995327103', '0.666666667', '1', '1', '8.5', '1', '0.5', '0']
package org . apache . xalan . processor ; import org . apache . xml . utils . StringToIntTable ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xalan . templates . AVT ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . XMLChar ; import org . apache . xpath . XPath ; import javax . xml . transform . TransformerException ; public class XSLTAttributeDef { static final int FATAL = 0 ; static final int ERROR = 1 ; static final int WARNING = 2 ; XSLTAttributeDef ( String namespace , String name , int type , boolean required , boolean supportsAVT , int errorType ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = type ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; } XSLTAttributeDef ( String namespace , String name , int type , boolean supportsAVT , int errorType , String defaultVal ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = type ; this . m_required = false ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; this . m_default = defaultVal ; } XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 2 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; } XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 , String k3 , int v3 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 3 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; m_enums . put ( k3 , v3 ) ; } XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 , String k3 , int v3 , String k4 , int v4 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 4 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; m_enums . put ( k3 , v3 ) ; m_enums . put ( k4 , v4 ) ; } static final int T_CDATA = 1 , T_URL = 2 , T_AVT = 3 , T_PATTERN = 4 , T_EXPR = 5 , T_CHAR = 6 , T_NUMBER = 7 , T_YESNO = 8 , T_QNAME = 9 , T_QNAMES = 10 , T_ENUM = 11 , T_SIMPLEPATTERNLIST = 12 , T_NMTOKEN = 13 , T_STRINGLIST = 14 , T_PREFIX_URLLIST = 15 , T_ENUM_OR_PQNAME = 16 , T_NCNAME = 17 , T_AVT_QNAME = 18 , T_QNAMES_RESOLVE_NULL = 19 ; static XSLTAttributeDef m_foreignAttr = new XSLTAttributeDef ( "*" , "*" , XSLTAttributeDef . T_CDATA , false , false , WARNING ) ; static String S_FOREIGNATTR_SETTER = "setForeignAttr" ; private String m_namespace ; String getNamespace ( ) { return m_namespace ; } private String m_name ; String getName ( ) { return m_name ; } private int m_type ; int getType ( ) { return m_type ; } private StringToIntTable m_enums ; private int getEnum ( String key ) { return m_enums . get ( key ) ; } private String [ ] getEnumNames ( ) { return m_enums . keys ( ) ; } private String m_default ; String getDefault ( ) { return m_default ; } void setDefault ( String def ) { m_default = def ; } private boolean m_required ; boolean getRequired ( ) { return m_required ; } private boolean m_supportsAVT ; boolean getSupportsAVT ( ) { return m_supportsAVT ; } int m_errorType = this . WARNING ; int getErrorType ( ) { return m_errorType ; } String m_setterString = null ; public String getSetterMethodName ( ) { if ( null == m_setterString ) { if ( m_foreignAttr == this ) { return S_FOREIGNATTR_SETTER ; } else if ( m_name . equals ( "*" ) ) { m_setterString = "addLiteralResultAttribute" ; return m_setterString ; } StringBuffer outBuf = new StringBuffer ( ) ; outBuf . append ( "set" ) ; if ( ( m_namespace != null ) && m_namespace . equals ( Constants . S_XMLNAMESPACEURI ) ) { outBuf . append ( "Xml" ) ; } int n = m_name . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char c = m_name . charAt ( i ) ; if ( '-' == c ) { i ++ ; c = m_name . charAt ( i ) ; c = Character . toUpperCase ( c ) ; } else if ( 0 == i ) { c = Character . toUpperCase ( c ) ; } outBuf . append ( c ) ; } m_setterString = outBuf . toString ( ) ; } return m_setterString ; } AVT processAVT ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } Object processCDATA ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { return value ; } } Object processCHAR ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( value . length ( ) != 1 ) ) { handleError ( handler , XSLTErrorResources . INVALID_TCHAR , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( value . length ( ) != 1 ) { handleError ( handler , XSLTErrorResources . INVALID_TCHAR , new Object [ ] { name , value } , null ) ; return null ; } return new Character ( value . charAt ( 0 ) ) ; } } Object processENUM ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { AVT avt = null ; if ( getSupportsAVT ( ) ) { try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ! avt . isSimple ( ) ) return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } int retVal = this . getEnum ( value ) ; if ( retVal == StringToIntTable . INVALID_KEY ) { StringBuffer enumNamesList = getListOfEnums ( ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , null ) ; return null ; } if ( getSupportsAVT ( ) ) return avt ; else return new Integer ( retVal ) ; } Object processENUM_OR_PQNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { Object objToReturn = null ; if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ! avt . isSimple ( ) ) return avt ; else objToReturn = avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } int enum = this . getEnum ( value ) ; if ( enum != StringToIntTable . INVALID_KEY ) { if ( objToReturn == null ) objToReturn = new Integer ( enum ) ; } else { try { QName qname = new QName ( value , handler , true ) ; if ( objToReturn == null ) objToReturn = qname ; if ( qname . getPrefix ( ) == null ) { StringBuffer enumNamesList = getListOfEnums ( ) ; enumNamesList . append ( " <qname-but-not-ncname>" ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , null ) ; return null ; } } catch ( IllegalArgumentException ie ) { StringBuffer enumNamesList = getListOfEnums ( ) ; enumNamesList . append ( " <qname-but-not-ncname>" ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , ie ) ; return null ; } catch ( RuntimeException re ) { StringBuffer enumNamesList = getListOfEnums ( ) ; enumNamesList . append ( " <qname-but-not-ncname>" ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , re ) ; return null ; } } return objToReturn ; } Object processEXPR ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { XPath expr = handler . createXPath ( value , owner ) ; return expr ; } catch ( TransformerException te ) { org . xml . sax . SAXException se = new org . xml . sax . SAXException ( te ) ; throw new org . xml . sax . SAXException ( te ) ; } } Object processNMTOKEN ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( ! XMLChar . isValidNmtoken ( value ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_NMTOKEN , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( ! XMLChar . isValidNmtoken ( value ) ) { handleError ( handler , XSLTErrorResources . INVALID_NMTOKEN , new Object [ ] { name , value } , null ) ; return null ; } } return value ; } Object processPATTERN ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { XPath pattern = handler . createMatchPatternXPath ( value , owner ) ; return pattern ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } Object processNUMBER ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { Double val ; AVT avt = null ; try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( avt . isSimple ( ) ) { val = Double . valueOf ( value ) ; } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } catch ( NumberFormatException nfe ) { handleError ( handler , XSLTErrorResources . INVALID_NUMBER , new Object [ ] { name , value } , nfe ) ; return null ; } return avt ; } else { try { return Double . valueOf ( value ) ; } catch ( NumberFormatException nfe ) { handleError ( handler , XSLTErrorResources . INVALID_NUMBER , new Object [ ] { name , value } , nfe ) ; return null ; } } } Object processQNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { QName qname = new QName ( value , handler , true ) ; return qname ; } catch ( IllegalArgumentException ie ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , ie ) ; return null ; } catch ( RuntimeException re ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , re ) ; return null ; } } Object processAVT_QNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { AVT avt = null ; try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( avt . isSimple ( ) ) { int indexOfNSSep = value . indexOf ( ':' ) ; if ( indexOfNSSep >= 0 ) { String prefix = value . substring ( 0 , indexOfNSSep ) ; if ( ! XMLChar . isValidNCName ( prefix ) ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , null ) ; return null ; } } String localName = ( indexOfNSSep < 0 ) ? value : value . substring ( indexOfNSSep + 1 ) ; if ( ( localName == null ) || ( localName . length ( ) == 0 ) || ( ! XMLChar . isValidNCName ( localName ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , null ) ; return null ; } } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } return avt ; } Object processNCNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { AVT avt = null ; try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( ! XMLChar . isValidNCName ( value ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_NCNAME , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( ! XMLChar . isValidNCName ( value ) ) { handleError ( handler , XSLTErrorResources . INVALID_NCNAME , new Object [ ] { name , value } , null ) ; return null ; } return value ; } } Vector processQNAMES ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nQNames = tokenizer . countTokens ( ) ; Vector qnames = new Vector ( nQNames ) ; for ( int i = 0 ; i < nQNames ; i ++ ) { qnames . addElement ( new QName ( tokenizer . nextToken ( ) , handler ) ) ; } return qnames ; } final Vector processQNAMESRNU ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nQNames = tokenizer . countTokens ( ) ; Vector qnames = new Vector ( nQNames ) ; String defaultURI = handler . getNamespaceForPrefix ( "" ) ; for ( int i = 0 ; i < nQNames ; i ++ ) { String tok = tokenizer . nextToken ( ) ; if ( tok . indexOf ( ':' ) == - 1 ) { qnames . addElement ( new QName ( defaultURI , tok ) ) ; } else { qnames . addElement ( new QName ( tok , handler ) ) ; } } return qnames ; } Vector processSIMPLEPATTERNLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nPatterns = tokenizer . countTokens ( ) ; Vector patterns = new Vector ( nPatterns ) ; for ( int i = 0 ; i < nPatterns ; i ++ ) { XPath pattern = handler . createMatchPatternXPath ( tokenizer . nextToken ( ) , owner ) ; patterns . addElement ( pattern ) ; } return patterns ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } StringVector processSTRINGLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { strings . addElement ( tokenizer . nextToken ( ) ) ; } return strings ; } StringVector processPREFIX_URLLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { String prefix = tokenizer . nextToken ( ) ; String url = handler . getNamespaceForPrefix ( prefix ) ; strings . addElement ( url ) ; } return strings ; } Object processURL ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { return value ; } } private Boolean processYESNO ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { if ( ! ( value . equals ( "yes" ) || value . equals ( "no" ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_BOOLEAN , new Object [ ] { name , value } , null ) ; return null ; } return new Boolean ( value . equals ( "yes" ) ? true : false ) ; } Object processValue ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { int type = getType ( ) ; Object processedValue = null ; switch ( type ) { case T_AVT : processedValue = processAVT ( handler , uri , name , rawName , value , owner ) ; break ; case T_CDATA : processedValue = processCDATA ( handler , uri , name , rawName , value , owner ) ; break ; case T_CHAR : processedValue = processCHAR ( handler , uri , name , rawName , value , owner ) ; break ; case T_ENUM : processedValue = processENUM ( handler , uri , name , rawName , value , owner ) ; break ; case T_EXPR : processedValue = processEXPR ( handler , uri , name , rawName , value , owner ) ; break ; case T_NMTOKEN : processedValue = processNMTOKEN ( handler , uri , name , rawName , value , owner ) ; break ; case T_PATTERN : processedValue = processPATTERN ( handler , uri , name , rawName , value , owner ) ; break ; case T_NUMBER : processedValue = processNUMBER ( handler , uri , name , rawName , value , owner ) ; break ; case T_QNAME : processedValue = processQNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_QNAMES : processedValue = processQNAMES ( handler , uri , name , rawName , value ) ; break ; case T_QNAMES_RESOLVE_NULL : processedValue = processQNAMESRNU ( handler , uri , name , rawName , value ) ; break ; case T_SIMPLEPATTERNLIST : processedValue = processSIMPLEPATTERNLIST ( handler , uri , name , rawName , value , owner ) ; break ; case T_URL : processedValue = processURL ( handler , uri , name , rawName , value , owner ) ; break ; case T_YESNO : processedValue = processYESNO ( handler , uri , name , rawName , value ) ; break ; case T_STRINGLIST : processedValue = processSTRINGLIST ( handler , uri , name , rawName , value ) ; break ; case T_PREFIX_URLLIST : processedValue = processPREFIX_URLLIST ( handler , uri , name , rawName , value ) ; break ; case T_ENUM_OR_PQNAME : processedValue = processENUM_OR_PQNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_NCNAME : processedValue = processNCNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_AVT_QNAME : processedValue = processAVT_QNAME ( handler , uri , name , rawName , value , owner ) ; break ; default : } return processedValue ; } void setDefAttrValue ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { setAttrValue ( handler , this . getNamespace ( ) , this . getName ( ) , this . getName ( ) , this . getDefault ( ) , elem ) ; } private Class getPrimativeClass ( Object obj ) { if ( obj instanceof XPath ) return XPath . class ; Class cl = obj . getClass ( ) ; if ( cl == Double . class ) { cl = double . class ; } if ( cl == Float . class ) { cl = float . class ; } else if ( cl == Boolean . class ) { cl = boolean . class ; } else if ( cl == Byte . class ) { cl = byte . class ; } else if ( cl == Character . class ) { cl = char . class ; } else if ( cl == Short . class ) { cl = short . class ; } else if ( cl == Integer . class ) { cl = int . class ; } else if ( cl == Long . class ) { cl = long . class ; } return cl ; } private StringBuffer getListOfEnums ( ) { StringBuffer enumNamesList = new StringBuffer ( ) ; String [ ] enumValues = this . getEnumNames ( ) ; for ( int i = 0 ; i < enumValues . length ; i ++ ) { if ( i > 0 ) { enumNamesList . append ( ' ' ) ; } enumNamesList . append ( enumValues [ i ] ) ; } return enumNamesList ; } boolean setAttrValue ( StylesheetHandler handler , String attrUri , String attrLocalName , String attrRawName , String attrValue , ElemTemplateElement elem ) throws org . xml . sax . SAXException { if ( attrRawName . equals ( "xmlns" ) || attrRawName . startsWith ( "xmlns:" ) ) return true ; String setterString = getSetterMethodName ( ) ; if ( null != setterString ) { try { Method meth ; Object [ ] args ; if ( setterString . equals ( S_FOREIGNATTR_SETTER ) ) { if ( attrUri == null ) attrUri = "" ; Class sclass = attrUri . getClass ( ) ; Class [ ] argTypes = new Class [ ] { sclass , sclass , sclass , sclass } ; meth = elem . getClass ( ) . getMethod ( setterString , argTypes ) ; args = new Object [ ] { attrUri , attrLocalName , attrRawName , attrValue } ; } else { Object value = processValue ( handler , attrUri , attrLocalName , attrRawName , attrValue , elem ) ; if ( null == value ) return false ; Class [ ] argTypes = new Class [ ] { getPrimativeClass ( value ) } ; try { meth = elem . getClass ( ) . getMethod ( setterString , argTypes ) ; } catch ( NoSuchMethodException nsme ) { Class cl = ( ( Object ) value ) . getClass ( ) ; argTypes [ 0 ] = cl ; meth = elem . getClass ( ) . getMethod ( setterString , argTypes ) ; } args = new Object [ ] { value } ; } meth . invoke ( elem , args ) ; } catch ( NoSuchMethodException nsme ) { if ( ! setterString . equals ( S_FOREIGNATTR_SETTER ) ) { handler . error ( XSLTErrorResources . ER_FAILED_CALLING_METHOD , new Object [ ] { setterString } , nsme ) ; return false ; } } catch ( IllegalAccessException iae ) { handler . error ( XSLTErrorResources . ER_FAILED_CALLING_METHOD , new Object [ ] { setterString } , iae ) ; return false ; } catch ( InvocationTargetException nsme ) { handleError ( handler , XSLTErrorResources . WG_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_NAME , getName ( ) } , nsme ) ; return false ; } } return true ; } private void handleError ( StylesheetHandler handler , int msg , Object [ ] args , Exception exc ) throws org . xml . sax . SAXException { switch ( getErrorType ( ) ) { case ( FATAL ) : case ( ERROR ) : handler . error ( msg , args , exc ) ; break ; case ( WARNING ) : handler . warn ( msg , args ) ; default : break ; } } } 	1	['43', '1', '0', '13', '91', '783', '4', '9', '1', '0.962585034', '1954', '0.166666667', '2', '0', '0.328042328', '0', '0', '43.46511628', '19', '1.5349', '1']
package org . apache . xpath . functions ; import java . util . Vector ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xml . utils . XMLString ; public class FuncSubstringAfter extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XMLString s1 = m_arg0 . execute ( xctxt ) . xstr ( ) ; XMLString s2 = m_arg1 . execute ( xctxt ) . xstr ( ) ; int index = s1 . indexOf ( s2 ) ; return ( - 1 == index ) ? XString . EMPTYSTRING : ( XString ) s1 . substring ( index + s2 . length ( ) ) ; } } 	0	['2', '5', '0', '7', '8', '1', '0', '7', '2', '2', '34', '0', '0', '0.98245614', '0.75', '1', '6', '16', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Iterator ; import java . net . URL ; import javax . xml . parsers . * ; import org . xml . sax . * ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . bcel . util . * ; import org . apache . bcel . classfile . JavaClass ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . DOM ; public final class Stylesheet extends SyntaxTreeNode { private String _version ; private QName _name ; private String _systemId ; private Stylesheet _parentStylesheet ; private Vector _globals = new Vector ( ) ; private Boolean _hasLocalParams = null ; private String _className ; private final Vector _templates = new Vector ( ) ; private int _nextModeSerial = 1 ; private final Hashtable _modes = new Hashtable ( ) ; private final Hashtable _extensions = new Hashtable ( ) ; public Stylesheet _importedFrom = null ; public Stylesheet _includedFrom = null ; private int _importPrecedence = 1 ; private Mode _defaultMode ; private boolean _multiDocument = false ; private boolean _callsNodeset = false ; private Hashtable _keys = new Hashtable ( ) ; private boolean _numberFormattingUsed = false ; private boolean _simplified = false ; private SourceLoader _loader = null ; private boolean _templateInlining = true ; private boolean _forwardReference = false ; private Properties _outputProperties = null ; public void setForwardReference ( ) { _forwardReference = true ; } public boolean getTemplateInlining ( ) { return _templateInlining ; } public void setTemplateInlining ( boolean flag ) { _templateInlining = flag ; } public boolean isSimplified ( ) { return ( _simplified ) ; } public void setSimplified ( ) { _simplified = true ; } public void setOutputProperty ( String key , String value ) { if ( _outputProperties == null ) { _outputProperties = new Properties ( ) ; } _outputProperties . setProperty ( key , value ) ; } public void setOutputProperties ( Properties props ) { _outputProperties = props ; } public Properties getOutputProperties ( ) { return _outputProperties ; } public void setMultiDocument ( boolean flag ) { _multiDocument = flag ; } public boolean isMultiDocument ( ) { return _multiDocument ; } public void setCallsNodeset ( boolean flag ) { if ( flag ) setMultiDocument ( flag ) ; _callsNodeset = flag ; } public boolean callsNodeset ( ) { return _callsNodeset ; } public void numberFormattingUsed ( ) { _numberFormattingUsed = true ; } public void setImportPrecedence ( final int precedence ) { _importPrecedence = precedence ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { SyntaxTreeNode child = ( SyntaxTreeNode ) elements . nextElement ( ) ; if ( child instanceof Include ) { Stylesheet included = ( ( Include ) child ) . getIncludedStylesheet ( ) ; if ( included != null ) included . setImportPrecedence ( precedence ) ; } } if ( _importedFrom != null ) { if ( _importedFrom . getImportPrecedence ( ) < precedence ) { final Parser parser = getParser ( ) ; final int nextPrecedence = parser . getNextImportPrecedence ( ) ; _importedFrom . setImportPrecedence ( nextPrecedence ) ; } } else if ( _includedFrom != null ) { if ( _includedFrom . getImportPrecedence ( ) != precedence ) _includedFrom . setImportPrecedence ( precedence ) ; } } public int getImportPrecedence ( ) { return _importPrecedence ; } public boolean checkForLoop ( String systemId ) { if ( _systemId != null && _systemId . equals ( systemId ) ) { return true ; } if ( _parentStylesheet != null ) return _parentStylesheet . checkForLoop ( systemId ) ; return false ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _name = makeStylesheetName ( "__stylesheet_" ) ; } public void setParentStylesheet ( Stylesheet parent ) { _parentStylesheet = parent ; } public Stylesheet getParentStylesheet ( ) { return _parentStylesheet ; } public void setImportingStylesheet ( Stylesheet parent ) { _importedFrom = parent ; } public void setIncludingStylesheet ( Stylesheet parent ) { _importedFrom = parent ; } public void setSystemId ( String systemId ) { _systemId = systemId ; } public String getSystemId ( ) { return _systemId ; } public void setSourceLoader ( SourceLoader loader ) { _loader = loader ; } public SourceLoader getSourceLoader ( ) { return _loader ; } private QName makeStylesheetName ( String prefix ) { return getParser ( ) . getQName ( prefix + getXSLTC ( ) . nextStylesheetSerial ( ) ) ; } public boolean hasGlobals ( ) { return _globals . size ( ) > 0 ; } public boolean hasLocalParams ( ) { if ( _hasLocalParams == null ) { final int n = _templates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Template template = ( Template ) _templates . elementAt ( i ) ; if ( template . hasParams ( ) ) { _hasLocalParams = new Boolean ( true ) ; return true ; } } _hasLocalParams = new Boolean ( false ) ; return false ; } else { return _hasLocalParams . booleanValue ( ) ; } } protected void addPrefixMapping ( String prefix , String uri ) { if ( prefix . equals ( EMPTYSTRING ) && uri . equals ( XHTML_URI ) ) return ; super . addPrefixMapping ( prefix , uri ) ; } private void extensionURI ( String prefixes , SymbolTable stable ) { if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri = lookupNamespace ( prefix ) ; if ( uri != null ) { _extensions . put ( uri , prefix ) ; } } } } public boolean isExtension ( String uri ) { return ( _extensions . get ( uri ) != null ) ; } public void excludeExtensionPrefixes ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; final String excludePrefixes = getAttribute ( "exclude-result-prefixes" ) ; final String extensionPrefixes = getAttribute ( "extension-element-prefixes" ) ; stable . excludeURI ( Constants . XSLT_URI ) ; stable . excludeNamespaces ( excludePrefixes ) ; stable . excludeNamespaces ( extensionPrefixes ) ; extensionURI ( extensionPrefixes , stable ) ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; addPrefixMapping ( "xml" , "http://www.w3.org/XML/1998/namespace" ) ; final Stylesheet sheet = stable . addStylesheet ( _name , this ) ; if ( sheet != null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . MULTIPLE_STYLESHEET_ERR , this ) ; parser . reportError ( Constants . ERROR , err ) ; } if ( _simplified ) { stable . excludeURI ( XSLT_URI ) ; Template template = new Template ( ) ; template . parseSimplified ( this , parser ) ; } else { parseOwnChildren ( parser ) ; } } public final void parseOwnChildren ( Parser parser ) { final Vector contents = getContents ( ) ; final int count = contents . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ( child instanceof VariableBase ) || ( child instanceof NamespaceAlias ) ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } } for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! ( child instanceof VariableBase ) && ! ( child instanceof NamespaceAlias ) ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } if ( ! _templateInlining && ( child instanceof Template ) ) { Template template = ( Template ) child ; String name = "template$dot$" + template . getPosition ( ) ; template . setName ( parser . getQName ( name ) ) ; } } } public void processModes ( ) { if ( _defaultMode == null ) _defaultMode = new Mode ( null , this , Constants . EMPTYSTRING ) ; _defaultMode . processPatterns ( _keys ) ; final Enumeration modes = _modes . elements ( ) ; while ( modes . hasMoreElements ( ) ) { final Mode mode = ( Mode ) modes . nextElement ( ) ; mode . processPatterns ( _keys ) ; } } private void compileModes ( ClassGenerator classGen ) { _defaultMode . compileApplyTemplates ( classGen ) ; final Enumeration modes = _modes . elements ( ) ; while ( modes . hasMoreElements ( ) ) { final Mode mode = ( Mode ) modes . nextElement ( ) ; mode . compileApplyTemplates ( classGen ) ; } } public Mode getMode ( QName modeName ) { if ( modeName == null ) { if ( _defaultMode == null ) { _defaultMode = new Mode ( null , this , Constants . EMPTYSTRING ) ; } return _defaultMode ; } else { Mode mode = ( Mode ) _modes . get ( modeName ) ; if ( mode == null ) { final String suffix = Integer . toString ( _nextModeSerial ++ ) ; _modes . put ( modeName , mode = new Mode ( modeName , this , suffix ) ) ; } return mode ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int count = _globals . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final VariableBase var = ( VariableBase ) _globals . elementAt ( i ) ; var . typeCheck ( stable ) ; } return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { translate ( ) ; } private void addDOMField ( ClassGenerator classGen ) { final FieldGen fgen = new FieldGen ( ACC_PUBLIC , Util . getJCRefType ( DOM_INTF_SIG ) , DOM_FIELD , classGen . getConstantPool ( ) ) ; classGen . addField ( fgen . getField ( ) ) ; } public void translate ( ) { Output lastOutputElement = null ; _className = getXSLTC ( ) . getClassName ( ) ; final ClassGenerator classGen = new ClassGenerator ( _className , TRANSLET_CLASS , Constants . EMPTYSTRING , ACC_PUBLIC | ACC_SUPER , null , this ) ; addDOMField ( classGen ) ; compileTransform ( classGen ) ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { Object element = elements . nextElement ( ) ; if ( element instanceof Template ) { final Template template = ( Template ) element ; _templates . addElement ( template ) ; getMode ( template . getModeName ( ) ) . addTemplate ( template ) ; } else if ( element instanceof AttributeSet ) { ( ( AttributeSet ) element ) . translate ( classGen , null ) ; } else if ( element instanceof Output ) { Output output = ( Output ) element ; if ( output . enabled ( ) ) lastOutputElement = output ; } else { } } processModes ( ) ; compileModes ( classGen ) ; compileConstructor ( classGen , lastOutputElement ) ; if ( ! getParser ( ) . errorsFound ( ) ) { getXSLTC ( ) . dumpClass ( classGen . getJavaClass ( ) ) ; } } private void compileConstructor ( ClassGenerator classGen , Output output ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator constructor = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , null , null , "<init>" , _className , il , cpg ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( TRANSLET_CLASS , "<init>" , "()V" ) ) ) ; final Vector names = getXSLTC ( ) . getNamesIndex ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , names . size ( ) ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { final String name = ( String ) names . elementAt ( i ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , name ) ) ; il . append ( AASTORE ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; final Vector namespaces = getXSLTC ( ) . getNamespaceIndex ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , namespaces . size ( ) ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int i = 0 ; i < namespaces . size ( ) ; i ++ ) { final String ns = ( String ) namespaces . elementAt ( i ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , ns ) ) ; il . append ( AASTORE ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; if ( output != null ) { output . translate ( classGen , constructor ) ; } if ( _numberFormattingUsed ) DecimalFormatting . translateDefaultDFS ( classGen , constructor ) ; il . append ( RETURN ) ; constructor . stripAttributes ( true ) ; constructor . setMaxLocals ( ) ; constructor . setMaxStack ( ) ; classGen . addMethod ( constructor . getMethod ( ) ) ; } private String compileTopLevel ( ClassGenerator classGen , Enumeration elements ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) } ; final String [ ] argNames = { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME } ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator toplevel = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "topLevel" , _className , il , classGen . getConstantPool ( ) ) ; toplevel . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current = toplevel . addLocalVariable ( "current" , org . apache . bcel . generic . Type . INT , il . getEnd ( ) , null ) ; final int setFilter = cpg . addInterfaceMethodref ( DOM_INTF , "setFilter" , "(Lorg/apache/xalan/xsltc/StripFilter;)V" ) ; il . append ( new PUSH ( cpg , DOM . ROOTNODE ) ) ; il . append ( new ISTORE ( current . getIndex ( ) ) ) ; _globals = resolveReferences ( _globals ) ; final int count = _globals . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final VariableBase var = ( VariableBase ) _globals . elementAt ( i ) ; var . translate ( classGen , toplevel ) ; } Vector whitespaceRules = new Vector ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof DecimalFormatting ) { ( ( DecimalFormatting ) element ) . translate ( classGen , toplevel ) ; } else if ( element instanceof Whitespace ) { whitespaceRules . addAll ( ( ( Whitespace ) element ) . getRules ( ) ) ; } } if ( whitespaceRules . size ( ) > 0 ) { Whitespace . translateRules ( whitespaceRules , classGen ) ; } if ( classGen . containsMethod ( STRIP_SPACE , STRIP_SPACE_PARAMS ) != null ) { il . append ( toplevel . loadDOM ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEINTERFACE ( setFilter , 2 ) ) ; } il . append ( RETURN ) ; toplevel . stripAttributes ( true ) ; toplevel . setMaxLocals ( ) ; toplevel . setMaxStack ( ) ; toplevel . removeNOPs ( ) ; classGen . addMethod ( toplevel . getMethod ( ) ) ; return ( "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; } private Vector resolveReferences ( Vector input ) { for ( int i = 0 ; i < input . size ( ) ; i ++ ) { final VariableBase var = ( VariableBase ) input . elementAt ( i ) ; final Vector dep = var . getDependencies ( ) ; final int depSize = ( dep != null ) ? dep . size ( ) : 0 ; for ( int j = 0 ; j < depSize ; j ++ ) { final VariableBase depVar = ( VariableBase ) dep . elementAt ( j ) ; if ( ! input . contains ( depVar ) ) { input . addElement ( depVar ) ; } } } Vector result = new Vector ( ) ; while ( input . size ( ) > 0 ) { boolean changed = false ; for ( int i = 0 ; i < input . size ( ) ; ) { final VariableBase var = ( VariableBase ) input . elementAt ( i ) ; final Vector dep = var . getDependencies ( ) ; if ( dep == null || result . containsAll ( dep ) ) { result . addElement ( var ) ; input . remove ( i ) ; changed = true ; } else { i ++ ; } } if ( ! changed ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CIRCULAR_VARIABLE_ERR , input . toString ( ) , this ) ; getParser ( ) . reportError ( Constants . ERROR , err ) ; return ( result ) ; } } return result ; } private String compileBuildKeys ( ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) , org . apache . bcel . generic . Type . INT } ; final String [ ] argNames = { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME , "current" } ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator buildKeys = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "buildKeys" , _className , il , classGen . getConstantPool ( ) ) ; final int domField = cpg . addFieldref ( getClassName ( ) , DOM_FIELD , DOM_INTF_SIG ) ; buildKeys . addException ( "org.apache.xalan.xsltc.TransletException" ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( new ASTORE ( 1 ) ) ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof Key ) { final Key key = ( Key ) element ; key . translate ( classGen , buildKeys ) ; _keys . put ( key . getName ( ) , key ) ; } } il . append ( RETURN ) ; buildKeys . stripAttributes ( true ) ; buildKeys . setMaxLocals ( ) ; buildKeys . setMaxStack ( ) ; buildKeys . removeNOPs ( ) ; classGen . addMethod ( buildKeys . getMethod ( ) ) ; return ( "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + "I)V" ) ; } private void compileTransform ( ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator transf = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "transform" , _className , il , classGen . getConstantPool ( ) ) ; transf . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current = transf . addLocalVariable ( "current" , org . apache . bcel . generic . Type . INT , il . getEnd ( ) , null ) ; final String applyTemplatesSig = classGen . getApplyTemplatesSig ( ) ; final int applyTemplates = cpg . addMethodref ( getClassName ( ) , "applyTemplates" , applyTemplatesSig ) ; final int domField = cpg . addFieldref ( getClassName ( ) , DOM_FIELD , DOM_INTF_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( isMultiDocument ( ) ) { il . append ( new NEW ( cpg . addClass ( MULTI_DOM_CLASS ) ) ) ; il . append ( DUP ) ; } il . append ( classGen . loadTranslet ( ) ) ; il . append ( transf . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , "makeDOMAdapter" , "(" + DOM_INTF_SIG + ")" + DOM_ADAPTER_SIG ) ) ) ; if ( isMultiDocument ( ) ) { final int init = cpg . addMethodref ( MULTI_DOM_CLASS , "<init>" , "(" + DOM_INTF_SIG + ")V" ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } il . append ( new PUTFIELD ( domField ) ) ; il . append ( new PUSH ( cpg , DOM . ROOTNODE ) ) ; il . append ( new ISTORE ( current . getIndex ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( transf . loadHandler ( ) ) ; final int index = cpg . addMethodref ( TRANSLET_CLASS , "transferOutputSettings" , "(" + OUTPUT_HANDLER_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; final String keySig = compileBuildKeys ( classGen ) ; final int keyIdx = cpg . addMethodref ( getClassName ( ) , "buildKeys" , keySig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , DOM . ROOTNODE ) ) ; il . append ( new INVOKEVIRTUAL ( keyIdx ) ) ; final Enumeration toplevel = elements ( ) ; if ( ( _globals . size ( ) > 0 ) || ( toplevel . hasMoreElements ( ) ) ) { final String topLevelSig = compileTopLevel ( classGen , toplevel ) ; final int topLevelIdx = cpg . addMethodref ( getClassName ( ) , "topLevel" , topLevelSig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( topLevelIdx ) ) ; } il . append ( transf . loadHandler ( ) ) ; il . append ( transf . startDocument ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( transf . endDocument ( ) ) ; il . append ( RETURN ) ; transf . stripAttributes ( true ) ; transf . setMaxLocals ( ) ; transf . setMaxStack ( ) ; transf . removeNOPs ( ) ; classGen . addMethod ( transf . getMethod ( ) ) ; } private void peepHoleOptimization ( MethodGenerator methodGen ) { final String pattern = "`ALOAD'`POP'`Instruction'" ; final InstructionList il = methodGen . getInstructionList ( ) ; final InstructionFinder find = new InstructionFinder ( il ) ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { il . delete ( match [ 0 ] , match [ 1 ] ) ; } catch ( TargetLostException e ) { } } } public int addParam ( Param param ) { _globals . addElement ( param ) ; return _globals . size ( ) - 1 ; } public int addVariable ( Variable global ) { _globals . addElement ( global ) ; return _globals . size ( ) - 1 ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Stylesheet" ) ; displayContents ( indent + IndentIncrement ) ; } public String getNamespace ( String prefix ) { return lookupNamespace ( prefix ) ; } public String getClassName ( ) { return _className ; } public Vector getTemplates ( ) { return _templates ; } } 	1	['54', '2', '0', '70', '185', '1235', '27', '55', '43', '0.948113208', '1914', '0.916666667', '6', '0.504672897', '0.10130719', '2', '7', '34', '9', '2.1296', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . * ; final class IdPattern extends IdKeyPattern { public IdPattern ( String id ) { super ( "##id" , id ) ; } } 	0	['1', '6', '0', '1', '2', '0', '1', '1', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . xalan . xsltc . trax ; import java . io . Serializable ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . io . IOException ; import java . util . Properties ; import java . security . AccessController ; import java . security . PrivilegedAction ; import javax . xml . transform . * ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . compiler . * ; import org . apache . xalan . xsltc . runtime . * ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; public final class TemplatesImpl implements Templates , Serializable { private static String ABSTRACT_TRANSLET = "org.apache.xalan.xsltc.runtime.AbstractTranslet" ; private String _name = null ; private byte [ ] [ ] _bytecodes = null ; private Class [ ] _class = null ; private int _transletIndex = - 1 ; private Properties _outputProperties ; private int _indentNumber ; private URIResolver _uriResolver = null ; private TransformerFactoryImpl _tfactory = null ; private class TransletClassLoader extends ClassLoader { protected TransletClassLoader ( ClassLoader parent ) { super ( parent ) ; } public Class defineClass ( byte [ ] b ) { return super . defineClass ( null , b , 0 , b . length ) ; } } protected TemplatesImpl ( byte [ ] [ ] bytecodes , String transletName , Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { _bytecodes = bytecodes ; _name = transletName ; _outputProperties = outputProperties ; _indentNumber = indentNumber ; _tfactory = tfactory ; } public synchronized void writeExternal ( ObjectOutput out ) throws IOException { out . writeObject ( _name ) ; out . writeObject ( _bytecodes ) ; out . flush ( ) ; } public synchronized void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { _name = ( String ) in . readObject ( ) ; _bytecodes = ( byte [ ] [ ] ) in . readObject ( ) ; _class = null ; } public synchronized void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } protected synchronized void setTransletBytecodes ( byte [ ] [ ] bytecodes ) { _bytecodes = bytecodes ; } public synchronized byte [ ] [ ] getTransletBytecodes ( ) { return _bytecodes ; } public synchronized Class [ ] getTransletClasses ( ) { try { if ( _class == null ) defineTransletClasses ( ) ; } catch ( TransformerConfigurationException e ) { } return _class ; } public synchronized int getTransletIndex ( ) { try { if ( _class == null ) defineTransletClasses ( ) ; } catch ( TransformerConfigurationException e ) { } return _transletIndex ; } protected synchronized void setTransletName ( String name ) { _name = name ; } protected synchronized String getTransletName ( ) { return _name ; } private void defineTransletClasses ( ) throws TransformerConfigurationException { if ( _bytecodes == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NO_TRANSLET_CLASS_ERR ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } TransletClassLoader loader = ( TransletClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new TransletClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } ) ; try { final int classCount = _bytecodes . length ; _class = new Class [ classCount ] ; for ( int i = 0 ; i < classCount ; i ++ ) { _class [ i ] = loader . defineClass ( _bytecodes [ i ] ) ; final Class superClass = _class [ i ] . getSuperclass ( ) ; if ( superClass . getName ( ) . equals ( ABSTRACT_TRANSLET ) ) { _transletIndex = i ; } } if ( _transletIndex < 0 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NO_MAIN_TRANSLET_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } catch ( ClassFormatError e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_CLASS_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( LinkageError e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } private Translet getTransletInstance ( ) throws TransformerConfigurationException { try { if ( _name == null ) return null ; if ( _class == null ) defineTransletClasses ( ) ; Translet translet = ( Translet ) _class [ _transletIndex ] . newInstance ( ) ; final int classCount = _bytecodes . length ; for ( int i = 0 ; i < classCount ; i ++ ) { if ( i != _transletIndex ) { translet . addAuxiliaryClass ( _class [ i ] ) ; } } return translet ; } catch ( InstantiationException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( IllegalAccessException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } public synchronized Transformer newTransformer ( ) throws TransformerConfigurationException { final TransformerImpl transformer = new TransformerImpl ( getTransletInstance ( ) , _outputProperties , _indentNumber , _tfactory ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return transformer ; } public synchronized Properties getOutputProperties ( ) { try { return newTransformer ( ) . getOutputProperties ( ) ; } catch ( TransformerConfigurationException e ) { return null ; } } } 	1	['15', '1', '0', '7', '34', '15', '4', '6', '8', '0.619047619', '331', '1', '1', '0', '0.19047619', '0', '0', '20.46666667', '1', '0.8667', '1']
package org . apache . xalan . templates ; import org . w3c . dom . * ; import org . xml . sax . * ; import org . apache . xpath . * ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemWhen extends ElemTemplateElement { private XPath m_test ; public void setTest ( XPath v ) { m_test = v ; } public XPath getTest ( ) { return m_test ; } public int getXSLToken ( ) { return Constants . ELEMNAME_WHEN ; } public void compose ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_test ) m_test . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_WHEN_STRING ; } public ElemWhen ( ) { } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_test . getExpression ( ) . callVisitors ( m_test , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	0	['7', '3', '0', '10', '16', '9', '1', '9', '6', '0.5', '55', '1', '1', '0.97029703', '0.314285714', '2', '5', '6.714285714', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import javax . xml . parsers . * ; import org . xml . sax . * ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . dom . Axis ; final class Key extends TopLevelElement { private QName _name ; private Pattern _match ; private Expression _use ; private Type _useType ; public void parseContents ( Parser parser ) { _name = parser . getQNameIgnoreDefaultNs ( getAttribute ( "name" ) ) ; _match = parser . parsePattern ( this , "match" , null ) ; _use = parser . parseExpression ( this , "use" , null ) ; if ( _name == null ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; return ; } if ( _match . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "match" ) ; return ; } if ( _use . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "use" ) ; return ; } } public String getName ( ) { return _name . toString ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _match . typeCheck ( stable ) ; _useType = _use . typeCheck ( stable ) ; if ( _useType instanceof NodeType ) { _use = new CastExpr ( _use , Type . String ) ; _useType = Type . String ; } if ( ! ( _useType instanceof StringType ) && ! ( _useType instanceof NodeSetType ) && ! ( _useType instanceof RealType ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . KEY_USE_ATTR_ERR , this ) ; throw new TypeCheckError ( err ) ; } return Type . Void ; } public void traverseNodeSet ( ClassGenerator classGen , MethodGenerator methodGen , int buildKeyIndex ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeValue = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeValue" , "(I)" + STRING_SIG ) ; final LocalVariableGen parentNode = methodGen . addLocalVariable ( "parentNode" , Util . getJCRefType ( "I" ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; _use . translate ( classGen , methodGen ) ; _use . startResetIterator ( classGen , methodGen ) ; il . append ( methodGen . storeIterator ( ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( new ILOAD ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( getNodeValue , 2 ) ) ; il . append ( new INVOKEVIRTUAL ( buildKeyIndex ) ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFNE ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; final int key = cpg . addMethodref ( TRANSLET_CLASS , "buildKeyIndex" , "(" + STRING_SIG + "I" + OBJECT_SIG + ")V" ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . DESCENDANT ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . setStartNode ( ) ) ; il . append ( methodGen . storeIterator ( ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; _match . translate ( classGen , methodGen ) ; _match . synthesize ( classGen , methodGen ) ; final BranchHandle skipNode = il . append ( new IFEQ ( null ) ) ; if ( _useType instanceof RealType ) { final int dbl = cpg . addMethodref ( DOUBLE_CLASS , "<init>" , "(D)V" ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new NEW ( cpg . addClass ( DOUBLE_CLASS ) ) ) ; il . append ( DUP ) ; _use . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( dbl ) ) ; il . append ( new INVOKEVIRTUAL ( key ) ) ; } else if ( _useType instanceof StringType ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; _use . translate ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( key ) ) ; } else { il . append ( methodGen . loadCurrentNode ( ) ) ; traverseNodeSet ( classGen , methodGen , key ) ; } final InstructionHandle skip = il . append ( NOP ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFNE ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; nextNode . setTarget ( skip ) ; skipNode . setTarget ( skip ) ; } } 	1	['6', '3', '0', '42', '56', '0', '1', '41', '5', '0.55', '531', '1', '4', '0.923076923', '0.361111111', '2', '4', '86.83333333', '4', '1.6667', '1']
package org . apache . xpath ; import java . io . Serializable ; import java . util . Vector ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . compiler . XPathParser ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . Node ; public class XPath implements Serializable , ExpressionOwner { private Expression m_mainExp ; public Expression getExpression ( ) { return m_mainExp ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_mainExp . fixupVariables ( vars , globalsSize ) ; } public void setExpression ( Expression exp ) { if ( null != m_mainExp ) exp . exprSetParent ( m_mainExp . exprGetParent ( ) ) ; m_mainExp = exp ; } public SourceLocator getLocator ( ) { return m_mainExp ; } String m_patternString ; public String getPatternString ( ) { return m_patternString ; } public static final int SELECT = 0 ; public static final int MATCH = 1 ; public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type , ErrorListener errorListener ) throws javax . xml . transform . TransformerException { if ( null == errorListener ) errorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; m_patternString = exprString ; XPathParser parser = new XPathParser ( errorListener , locator ) ; Compiler compiler = new Compiler ( errorListener , locator ) ; if ( SELECT == type ) parser . initXPath ( compiler , exprString , prefixResolver ) ; else if ( MATCH == type ) parser . initMatchPattern ( compiler , exprString , prefixResolver ) ; else throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_DEAL_XPATH_TYPE , new Object [ ] { Integer . toString ( type ) } ) ) ; Expression expr = compiler . compile ( 0 ) ; this . setExpression ( expr ) ; if ( ( null != locator ) && locator instanceof ExpressionNode ) { expr . exprSetParent ( ( ExpressionNode ) locator ) ; } } public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type ) throws javax . xml . transform . TransformerException { this ( exprString , locator , prefixResolver , type , null ) ; } public XPath ( Expression expr ) { this . setExpression ( expr ) ; } public XObject execute ( XPathContext xctxt , org . w3c . dom . Node contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { return execute ( xctxt , xctxt . getDTMHandleFromNode ( contextNode ) , namespaceContext ) ; } public XObject execute ( XPathContext xctxt , int contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { xctxt . pushNamespaceContext ( namespaceContext ) ; xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; XObject xobj = null ; try { xobj = m_mainExp . execute ( xctxt ) ; } catch ( TransformerException te ) { te . setLocator ( this . getLocator ( ) ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . error ( te ) ; } else throw te ; } catch ( Exception e ) { while ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } String msg = e . getMessage ( ) ; msg = ( msg == null || msg . length ( ) == 0 ) ? "Unknown error in XPath" : msg ; TransformerException te = new TransformerException ( msg , getLocator ( ) , e ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . fatalError ( te ) ; } else throw te ; } finally { xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } return xobj ; } public boolean bool ( XPathContext xctxt , int contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { xctxt . pushNamespaceContext ( namespaceContext ) ; xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; try { return m_mainExp . bool ( xctxt ) ; } catch ( TransformerException te ) { te . setLocator ( this . getLocator ( ) ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . error ( te ) ; } else throw te ; } catch ( Exception e ) { while ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } String msg = e . getMessage ( ) ; msg = ( msg == null || msg . length ( ) == 0 ) ? "Unknown error in XPath" : msg ; TransformerException te = new TransformerException ( msg , getLocator ( ) , e ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . fatalError ( te ) ; } else throw te ; } finally { xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } return false ; } private static final boolean DEBUG_MATCHES = false ; public double getMatchScore ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { xctxt . pushCurrentNode ( context ) ; xctxt . pushCurrentExpressionNode ( context ) ; try { XObject score = m_mainExp . execute ( xctxt ) ; if ( DEBUG_MATCHES ) { DTM dtm = xctxt . getDTM ( context ) ; System . out . println ( "score: " + score . num ( ) + " for " + dtm . getNodeName ( context ) + " for xpath " + this . getPatternString ( ) ) ; } return score . num ( ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popCurrentExpressionNode ( ) ; } } public void installFunction ( String name , int funcIndex , Function func ) { FunctionTable . installFunction ( func , funcIndex ) ; } public void warn ( XPathContext xctxt , int sourceNode , int msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; ErrorListener ehandler = xctxt . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . warning ( new TransformerException ( fmsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } } public void assertion ( boolean b , String msg ) { if ( ! b ) { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( XPathContext xctxt , int sourceNode , int msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; ErrorListener ehandler = xctxt . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . fatalError ( new TransformerException ( fmsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } else { SourceLocator slocator = xctxt . getSAXLocator ( ) ; System . out . println ( fmsg + "; file " + slocator . getSystemId ( ) + "; line " + slocator . getLineNumber ( ) + "; column " + slocator . getColumnNumber ( ) ) ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { m_mainExp . callVisitors ( this , visitor ) ; } public static final double MATCH_SCORE_NONE = Double . NEGATIVE_INFINITY ; public static final double MATCH_SCORE_QNAME = 0.0 ; public static final double MATCH_SCORE_NSWILD = - 0.25 ; public static final double MATCH_SCORE_NODETEST = - 0.5 ; public static final double MATCH_SCORE_OTHER = 0.5 ; } 	0	['17', '1', '0', '60', '64', '78', '44', '16', '17', '0.96875', '462', '0.2', '1', '0', '0.211764706', '0', '0', '25.58823529', '2', '0.9412', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import java . util . Properties ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . io . OutputStreamWriter ; import javax . xml . transform . OutputKeys ; import org . apache . bcel . generic . * ; import org . apache . bcel . classfile . JavaClass ; import org . apache . xalan . xsltc . compiler . util . * ; final class Output extends TopLevelElement { private String _version ; private String _method ; private String _encoding ; private boolean _omitHeader = false ; private String _standalone ; private String _doctypePublic ; private String _doctypeSystem ; private String _cdata ; private boolean _indent = false ; private String _mediaType ; private boolean _disabled = false ; private final static String STRING_SIG = "Ljava/lang/String;" ; private final static String XML_VERSION = "1.0" ; private final static String HTML_VERSION = "4.0" ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "Output " + _method ) ; } public void disable ( ) { _disabled = true ; } public boolean enabled ( ) { return ! _disabled ; } public void parseContents ( Parser parser ) { final Properties outputProperties = new Properties ( ) ; parser . setOutput ( this ) ; if ( _disabled ) return ; String attrib = null ; _version = getAttribute ( "version" ) ; if ( _version == null || _version . equals ( Constants . EMPTYSTRING ) ) { _version = null ; } else { outputProperties . setProperty ( OutputKeys . VERSION , _version ) ; } _method = getAttribute ( "method" ) ; if ( _method . equals ( Constants . EMPTYSTRING ) ) { _method = null ; } if ( _method != null ) { _method = _method . toLowerCase ( ) ; outputProperties . setProperty ( OutputKeys . METHOD , _method ) ; } _encoding = getAttribute ( "encoding" ) ; if ( _encoding . equals ( Constants . EMPTYSTRING ) ) { _encoding = null ; } else { try { OutputStreamWriter writer = new OutputStreamWriter ( System . out , _encoding ) ; } catch ( java . io . UnsupportedEncodingException e ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_ENCODING , _encoding , this ) ; parser . reportError ( Constants . WARNING , msg ) ; } outputProperties . setProperty ( OutputKeys . ENCODING , _encoding ) ; } attrib = getAttribute ( "omit-xml-declaration" ) ; if ( attrib != null && ! attrib . equals ( Constants . EMPTYSTRING ) ) { if ( attrib . equals ( "yes" ) ) { _omitHeader = true ; } outputProperties . setProperty ( OutputKeys . OMIT_XML_DECLARATION , attrib ) ; } _standalone = getAttribute ( "standalone" ) ; if ( _standalone . equals ( Constants . EMPTYSTRING ) ) { _standalone = null ; } else { outputProperties . setProperty ( OutputKeys . STANDALONE , _standalone ) ; } _doctypeSystem = getAttribute ( "doctype-system" ) ; if ( _doctypeSystem . equals ( Constants . EMPTYSTRING ) ) { _doctypeSystem = null ; } else { outputProperties . setProperty ( OutputKeys . DOCTYPE_SYSTEM , _doctypeSystem ) ; } _doctypePublic = getAttribute ( "doctype-public" ) ; if ( _doctypePublic . equals ( Constants . EMPTYSTRING ) ) { _doctypePublic = null ; } else { outputProperties . setProperty ( OutputKeys . DOCTYPE_PUBLIC , _doctypePublic ) ; } _cdata = getAttribute ( "cdata-section-elements" ) ; if ( _cdata != null && _cdata . equals ( Constants . EMPTYSTRING ) ) { _cdata = null ; } else { StringBuffer expandedNames = new StringBuffer ( ) ; StringTokenizer tokens = new StringTokenizer ( _cdata ) ; while ( tokens . hasMoreTokens ( ) ) { expandedNames . append ( parser . getQName ( tokens . nextToken ( ) ) . toString ( ) ) . append ( ' ' ) ; } _cdata = expandedNames . toString ( ) ; outputProperties . setProperty ( OutputKeys . CDATA_SECTION_ELEMENTS , _cdata ) ; } attrib = getAttribute ( "indent" ) ; if ( attrib != null && ! attrib . equals ( EMPTYSTRING ) ) { if ( attrib . equals ( "yes" ) ) { _indent = true ; } outputProperties . setProperty ( OutputKeys . INDENT , attrib ) ; } else if ( _method != null && _method . equals ( "html" ) ) { _indent = true ; } _mediaType = getAttribute ( "media-type" ) ; if ( _mediaType . equals ( Constants . EMPTYSTRING ) ) { _mediaType = null ; } else { outputProperties . setProperty ( OutputKeys . MEDIA_TYPE , _mediaType ) ; } if ( _method != null ) { if ( _method . equals ( "html" ) ) { if ( _version == null ) { _version = HTML_VERSION ; } if ( _mediaType == null ) { _mediaType = "text/html" ; } } else if ( _method . equals ( "text" ) ) { if ( _mediaType == null ) { _mediaType = "text/plain" ; } } } parser . getCurrentStylesheet ( ) . setOutputProperties ( outputProperties ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _disabled ) return ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; int field = 0 ; il . append ( classGen . loadTranslet ( ) ) ; if ( ( _version != null ) && ( ! _version . equals ( XML_VERSION ) ) ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_version" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _version ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _method != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_method" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _method ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _encoding != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_encoding" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _encoding ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _omitHeader ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_omitHeader" , "Z" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _omitHeader ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _standalone != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_standalone" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _standalone ) ) ; il . append ( new PUTFIELD ( field ) ) ; } field = cpg . addFieldref ( TRANSLET_CLASS , "_doctypeSystem" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _doctypeSystem ) ) ; il . append ( new PUTFIELD ( field ) ) ; field = cpg . addFieldref ( TRANSLET_CLASS , "_doctypePublic" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _doctypePublic ) ) ; il . append ( new PUTFIELD ( field ) ) ; if ( _mediaType != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_mediaType" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _mediaType ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _indent ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_indent" , "Z" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _indent ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _cdata != null ) { int index = cpg . addMethodref ( TRANSLET_CLASS , "addCdataElement" , "(Ljava/lang/String;)V" ) ; StringTokenizer tokens = new StringTokenizer ( _cdata ) ; while ( tokens . hasMoreTokens ( ) ) { il . append ( DUP ) ; il . append ( new PUSH ( cpg , tokens . nextToken ( ) ) ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } } il . append ( POP ) ; } } 	1	['6', '3', '0', '21', '40', '0', '2', '21', '5', '0.8', '706', '1', '0', '0.923076923', '0.333333333', '3', '7', '114.3333333', '28', '7.3333', '1']
package org . apache . xalan . transformer ; import org . apache . xalan . res . XSLMessages ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; import org . w3c . dom . Node ; import javax . xml . transform . TransformerException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . dom . DOMLocator ; import javax . xml . transform . SourceLocator ; public class MsgMgr { public MsgMgr ( TransformerImpl transformer ) { m_transformer = transformer ; } private TransformerImpl m_transformer ; private static XSLMessages m_XSLMessages = new XSLMessages ( ) ; public void message ( SourceLocator srcLctr , String msg , boolean terminate ) throws TransformerException { ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) { errHandler . warning ( new TransformerException ( msg , srcLctr ) ) ; } else { if ( terminate ) throw new TransformerException ( msg , srcLctr ) ; else System . out . println ( msg ) ; } } public void warn ( SourceLocator srcLctr , int msg ) throws TransformerException { warn ( srcLctr , null , null , msg , null ) ; } public void warn ( SourceLocator srcLctr , int msg , Object [ ] args ) throws TransformerException { warn ( srcLctr , null , null , msg , args ) ; } public void warn ( SourceLocator srcLctr , Node styleNode , Node sourceNode , int msg ) throws TransformerException { warn ( srcLctr , styleNode , sourceNode , msg , null ) ; } public void warn ( SourceLocator srcLctr , Node styleNode , Node sourceNode , int msg , Object args [ ] ) throws TransformerException { String formattedMsg = m_XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . warning ( new TransformerException ( formattedMsg , srcLctr ) ) ; else System . out . println ( formattedMsg ) ; } public void error ( SourceLocator srcLctr , String msg ) throws TransformerException { ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . fatalError ( new TransformerException ( msg , srcLctr ) ) ; else throw new TransformerException ( msg , srcLctr ) ; } public void error ( SourceLocator srcLctr , int msg ) throws TransformerException { error ( srcLctr , null , null , msg , null ) ; } public void error ( SourceLocator srcLctr , int msg , Object [ ] args ) throws TransformerException { error ( srcLctr , null , null , msg , args ) ; } public void error ( SourceLocator srcLctr , int msg , Exception e ) throws TransformerException { error ( srcLctr , msg , null , e ) ; } public void error ( SourceLocator srcLctr , int msg , Object args [ ] , Exception e ) throws TransformerException { String formattedMsg = m_XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . fatalError ( new TransformerException ( formattedMsg , srcLctr ) ) ; else throw new TransformerException ( formattedMsg , srcLctr ) ; } public void error ( SourceLocator srcLctr , Node styleNode , Node sourceNode , int msg ) throws TransformerException { error ( srcLctr , styleNode , sourceNode , msg , null ) ; } public void error ( SourceLocator srcLctr , Node styleNode , Node sourceNode , int msg , Object args [ ] ) throws TransformerException { String formattedMsg = m_XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . fatalError ( new TransformerException ( formattedMsg , srcLctr ) ) ; else throw new TransformerException ( formattedMsg , srcLctr ) ; } } 	0	['14', '1', '0', '13', '23', '55', '12', '2', '13', '0.153846154', '212', '1', '2', '0', '0.427350427', '0', '0', '14', '1', '0.8571', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Hashtable ; import java . lang . reflect . * ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . InstructionConstants ; import org . apache . bcel . generic . InvokeInstruction ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . * ; import org . apache . xalan . xsltc . runtime . TransletLoader ; class FunctionCall extends Expression { private QName _fname ; private final Vector _arguments ; private final static Vector EMPTY_ARG_LIST = new Vector ( 0 ) ; protected final static String EXT_XSLTC = TRANSLET_URI ; protected final static String JAVA_EXT_XSLTC = EXT_XSLTC + "/java" ; protected final static String EXT_XALAN = "http://xml.apache.org/xalan" ; protected final static String JAVA_EXT_XALAN = "http://xml.apache.org/xslt/java" ; Expression _thisArgument = null ; private String _className ; private Method _chosenMethod ; private Constructor _chosenConstructor ; private MethodType _chosenMethodType ; private boolean unresolvedExternal ; private boolean _isExtConstructor = false ; private static final MultiHashtable _internal2Java = new MultiHashtable ( ) ; private static final Hashtable _java2Internal = new Hashtable ( ) ; static class JavaType { public Class type ; public int distance ; public JavaType ( Class type , int distance ) { this . type = type ; this . distance = distance ; } public boolean equals ( Object query ) { return query . equals ( type ) ; } } static { try { final Class objectClass = Class . forName ( "java.lang.Object" ) ; final Class stringClass = Class . forName ( "java.lang.String" ) ; final Class nodeClass = Class . forName ( "org.w3c.dom.Node" ) ; final Class nodeListClass = Class . forName ( "org.w3c.dom.NodeList" ) ; _internal2Java . put ( Type . Boolean , new JavaType ( Boolean . TYPE , 0 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Character . TYPE , 6 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Byte . TYPE , 5 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Short . TYPE , 4 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Integer . TYPE , 0 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Long . TYPE , 1 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Float . TYPE , 2 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Double . TYPE , 3 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Character . TYPE , 6 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Byte . TYPE , 5 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Short . TYPE , 4 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Integer . TYPE , 3 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Long . TYPE , 2 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Float . TYPE , 1 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Double . TYPE , 0 ) ) ; _internal2Java . put ( Type . String , new JavaType ( stringClass , 0 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( nodeClass , 0 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( nodeListClass , 1 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( Integer . TYPE , 10 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( nodeClass , 1 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( nodeListClass , 0 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( nodeClass , 1 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( nodeListClass , 0 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( objectClass , 2 ) ) ; _internal2Java . put ( Type . Reference , new JavaType ( objectClass , 0 ) ) ; _java2Internal . put ( Boolean . TYPE , Type . Boolean ) ; _java2Internal . put ( Character . TYPE , Type . Real ) ; _java2Internal . put ( Byte . TYPE , Type . Real ) ; _java2Internal . put ( Short . TYPE , Type . Real ) ; _java2Internal . put ( Integer . TYPE , Type . Real ) ; _java2Internal . put ( Long . TYPE , Type . Real ) ; _java2Internal . put ( Float . TYPE , Type . Real ) ; _java2Internal . put ( Double . TYPE , Type . Real ) ; _java2Internal . put ( stringClass , Type . String ) ; _java2Internal . put ( objectClass , Type . Reference ) ; _java2Internal . put ( nodeListClass , Type . NodeSet ) ; } catch ( ClassNotFoundException e ) { System . err . println ( e ) ; } } public FunctionCall ( QName fname , Vector arguments ) { _fname = fname ; _arguments = arguments ; _type = null ; } public FunctionCall ( QName fname ) { this ( fname , EMPTY_ARG_LIST ) ; } public String getName ( ) { return ( _fname . toString ( ) ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _arguments != null ) { final int n = _arguments . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) _arguments . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public String getClassNameFromUri ( String uri ) throws TypeCheckError { final int length = uri . startsWith ( JAVA_EXT_XSLTC ) ? JAVA_EXT_XSLTC . length ( ) + 1 : uri . startsWith ( JAVA_EXT_XALAN ) ? JAVA_EXT_XALAN . length ( ) + 1 : 0 ; if ( length == 0 ) { throw new TypeCheckError ( this ) ; } return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) return _type ; final String namespace = _fname . getNamespace ( ) ; final String local = _fname . getLocalPart ( ) ; if ( isExtension ( ) ) { _fname = new QName ( null , null , local ) ; return typeCheckStandard ( stable ) ; } else if ( isStandard ( ) ) { return typeCheckStandard ( stable ) ; } else { try { _className = getClassNameFromUri ( namespace ) ; final int pos = local . lastIndexOf ( '.' ) ; if ( pos > 0 ) { _className = _className + local . substring ( 0 , pos ) ; _fname = new QName ( namespace , null , local . substring ( pos + 1 ) ) ; } else { _fname = new QName ( namespace , null , local ) ; } return typeCheckExternal ( stable ) ; } catch ( TypeCheckError e ) { ErrorMsg errorMsg = e . getErrorMsg ( ) ; if ( errorMsg == null ) { final String name = _fname . getLocalPart ( ) ; errorMsg = new ErrorMsg ( ErrorMsg . METHOD_NOT_FOUND_ERR , name ) ; } getParser ( ) . reportError ( ERROR , errorMsg ) ; return _type = Type . Void ; } } } public Type typeCheckStandard ( SymbolTable stable ) throws TypeCheckError { _fname . clearNamespace ( ) ; final int n = _arguments . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; final MethodType args = new MethodType ( Type . Void , argsType ) ; final MethodType ptype = lookupPrimop ( stable , _fname . getLocalPart ( ) , args ) ; if ( ptype != null ) { for ( int i = 0 ; i < n ; i ++ ) { final Type argType = ( Type ) ptype . argsType ( ) . elementAt ( i ) ; final Expression exp = ( Expression ) _arguments . elementAt ( i ) ; if ( ! argType . identicalTo ( exp . getType ( ) ) ) { try { _arguments . setElementAt ( new CastExpr ( exp , argType ) , i ) ; } catch ( TypeCheckError e ) { throw new TypeCheckError ( this ) ; } } } _chosenMethodType = ptype ; return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public Type typeCheckConstructor ( SymbolTable stable ) throws TypeCheckError { final Vector constructors = findConstructors ( ) ; if ( constructors == null ) { throw new TypeCheckError ( ErrorMsg . CONSTRUCTOR_NOT_FOUND , _className ) ; } final int nConstructors = constructors . size ( ) ; final int nArgs = _arguments . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; int bestConstrDistance = Integer . MAX_VALUE ; _type = null ; for ( int j , i = 0 ; i < nConstructors ; i ++ ) { final Constructor constructor = ( Constructor ) constructors . elementAt ( i ) ; final Class [ ] paramTypes = constructor . getParameterTypes ( ) ; Class extType = null ; int currConstrDistance = 0 ; for ( j = 0 ; j < nArgs ; j ++ ) { extType = paramTypes [ j ] ; final Type intType = ( Type ) argsType . elementAt ( j ) ; Object match = _internal2Java . maps ( intType , extType ) ; if ( match != null ) { currConstrDistance += ( ( JavaType ) match ) . distance ; } else { currConstrDistance = Integer . MAX_VALUE ; break ; } } if ( j == nArgs && currConstrDistance < bestConstrDistance ) { _chosenConstructor = constructor ; _isExtConstructor = true ; bestConstrDistance = currConstrDistance ; _type = new ObjectType ( _className ) ; } } if ( _type != null ) { return _type ; } final StringBuffer buf = new StringBuffer ( _className ) ; buf . append ( '.' ) . append ( _fname . getLocalPart ( ) ) . append ( '(' ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { final Type intType = ( Type ) argsType . elementAt ( i ) ; buf . append ( intType . toString ( ) ) ; if ( i < nArgs - 1 ) buf . append ( ", " ) ; } buf . append ( ')' ) ; throw new TypeCheckError ( ErrorMsg . ARGUMENT_CONVERSION_ERR , buf . toString ( ) ) ; } public Type typeCheckExternal ( SymbolTable stable ) throws TypeCheckError { int nArgs = _arguments . size ( ) ; final String name = _fname . getLocalPart ( ) ; if ( _className . length ( ) == 0 ) { if ( nArgs > 0 ) { _thisArgument = ( Expression ) _arguments . elementAt ( 0 ) ; _arguments . remove ( 0 ) ; nArgs -- ; Type type = _thisArgument . typeCheck ( stable ) ; if ( type instanceof ObjectType ) { _className = ( ( ObjectType ) type ) . getJavaClassName ( ) ; } else { throw new TypeCheckError ( ErrorMsg . NO_JAVA_FUNCT_THIS_REF , name ) ; } } else { final Parser parser = getParser ( ) ; if ( parser != null ) { reportWarning ( this , parser , ErrorMsg . FUNCTION_RESOLVE_ERR , _fname . toString ( ) ) ; } unresolvedExternal = true ; return _type = Type . Int ; } } else if ( _fname . getLocalPart ( ) . equals ( "new" ) ) { return typeCheckConstructor ( stable ) ; } final Vector methods = findMethods ( ) ; if ( methods == null ) { throw new TypeCheckError ( ErrorMsg . METHOD_NOT_FOUND_ERR , name ) ; } Class extType = null ; final int nMethods = methods . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; int bestMethodDistance = Integer . MAX_VALUE ; _type = null ; for ( int j , i = 0 ; i < nMethods ; i ++ ) { final Method method = ( Method ) methods . elementAt ( i ) ; final Class [ ] paramTypes = method . getParameterTypes ( ) ; int currMethodDistance = 0 ; for ( j = 0 ; j < nArgs ; j ++ ) { extType = paramTypes [ j ] ; final Type intType = ( Type ) argsType . elementAt ( j ) ; Object match = _internal2Java . maps ( intType , extType ) ; if ( match != null ) { currMethodDistance += ( ( JavaType ) match ) . distance ; } else { currMethodDistance = Integer . MAX_VALUE ; break ; } } if ( j == nArgs ) { extType = method . getReturnType ( ) ; _type = extType . getName ( ) . equals ( "void" ) ? Type . Void : ( Type ) _java2Internal . get ( extType ) ; if ( _type != null && currMethodDistance < bestMethodDistance ) { _chosenMethod = method ; bestMethodDistance = currMethodDistance ; } } } if ( _type != null ) { if ( _type == Type . NodeSet ) { getXSLTC ( ) . setMultiDocument ( true ) ; } return _type ; } final StringBuffer buf = new StringBuffer ( _className ) ; buf . append ( '.' ) . append ( _fname . getLocalPart ( ) ) . append ( '(' ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { final Type intType = ( Type ) argsType . elementAt ( i ) ; buf . append ( intType . toString ( ) ) ; if ( i < nArgs - 1 ) buf . append ( ", " ) ; } buf . append ( ')' ) ; throw new TypeCheckError ( ErrorMsg . ARGUMENT_CONVERSION_ERR , buf . toString ( ) ) ; } public Vector typeCheckArgs ( SymbolTable stable ) throws TypeCheckError { final Vector result = new Vector ( ) ; final Enumeration e = _arguments . elements ( ) ; while ( e . hasMoreElements ( ) ) { final Expression exp = ( Expression ) e . nextElement ( ) ; result . addElement ( exp . typeCheck ( stable ) ) ; } return result ; } protected final Expression argument ( int i ) { return ( Expression ) _arguments . elementAt ( i ) ; } protected final Expression argument ( ) { return argument ( 0 ) ; } protected final int argumentCount ( ) { return _arguments . size ( ) ; } protected final void setArgument ( int i , Expression exp ) { _arguments . setElementAt ( exp , i ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { Type type = Type . Boolean ; if ( _chosenMethodType != null ) type = _chosenMethodType . resultType ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; translate ( classGen , methodGen ) ; if ( ( type instanceof BooleanType ) || ( type instanceof IntType ) ) { _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = argumentCount ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index ; if ( isStandard ( ) || isExtension ( ) ) { for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startResetIterator ( classGen , methodGen ) ; } final String name = _fname . toString ( ) . replace ( '-' , '_' ) + "F" ; String args = Constants . EMPTYSTRING ; if ( name . equals ( "sumF" ) ) { args = DOM_INTF_SIG ; il . append ( methodGen . loadDOM ( ) ) ; } else if ( name . equals ( "normalize_spaceF" ) ) { if ( _chosenMethodType . toSignature ( args ) . equals ( "()Ljava/lang/String;" ) ) { args = "I" + DOM_INTF_SIG ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; } } index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , name , _chosenMethodType . toSignature ( args ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( unresolvedExternal ) { index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "unresolved_externalF" , "(Ljava/lang/String;)V" ) ; il . append ( new PUSH ( cpg , _fname . toString ( ) ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( _isExtConstructor ) { final String clazz = _chosenConstructor . getDeclaringClass ( ) . getName ( ) ; Class [ ] paramTypes = _chosenConstructor . getParameterTypes ( ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( InstructionConstants . DUP ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startResetIterator ( classGen , methodGen ) ; exp . getType ( ) . translateTo ( classGen , methodGen , paramTypes [ i ] ) ; } final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; for ( int i = 0 ; i < paramTypes . length ; i ++ ) { buffer . append ( getSignature ( paramTypes [ i ] ) ) ; } buffer . append ( ')' ) ; buffer . append ( "V" ) ; index = cpg . addMethodref ( clazz , "<init>" , buffer . toString ( ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; ( Type . Object ) . translateFrom ( classGen , methodGen , _chosenConstructor . getDeclaringClass ( ) ) ; } else { final String clazz = _chosenMethod . getDeclaringClass ( ) . getName ( ) ; Class [ ] paramTypes = _chosenMethod . getParameterTypes ( ) ; if ( _thisArgument != null ) { _thisArgument . translate ( classGen , methodGen ) ; } for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startResetIterator ( classGen , methodGen ) ; exp . getType ( ) . translateTo ( classGen , methodGen , paramTypes [ i ] ) ; } final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; for ( int i = 0 ; i < paramTypes . length ; i ++ ) { buffer . append ( getSignature ( paramTypes [ i ] ) ) ; } buffer . append ( ')' ) ; buffer . append ( getSignature ( _chosenMethod . getReturnType ( ) ) ) ; index = cpg . addMethodref ( clazz , _fname . getLocalPart ( ) , buffer . toString ( ) ) ; il . append ( _thisArgument != null ? ( InvokeInstruction ) new INVOKEVIRTUAL ( index ) : ( InvokeInstruction ) new INVOKESTATIC ( index ) ) ; _type . translateFrom ( classGen , methodGen , _chosenMethod . getReturnType ( ) ) ; } } public String toString ( ) { return "funcall(" + _fname + ", " + _arguments + ')' ; } public boolean isStandard ( ) { final String namespace = _fname . getNamespace ( ) ; return ( namespace == null ) || ( namespace . equals ( Constants . EMPTYSTRING ) ) ; } public boolean isExtension ( ) { final String namespace = _fname . getNamespace ( ) ; return ( namespace != null ) && ( namespace . equals ( EXT_XSLTC ) || namespace . equals ( EXT_XALAN ) ) ; } private Vector findMethods ( ) { Vector result = null ; final String namespace = _fname . getNamespace ( ) ; if ( namespace . startsWith ( JAVA_EXT_XSLTC ) || namespace . startsWith ( JAVA_EXT_XALAN ) ) { final int nArgs = _arguments . size ( ) ; try { TransletLoader loader = new TransletLoader ( ) ; final Class clazz = loader . loadClass ( _className ) ; if ( clazz == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } else { final String methodName = _fname . getLocalPart ( ) ; final Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final int mods = methods [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && methods [ i ] . getName ( ) . equals ( methodName ) && methods [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( result == null ) { result = new Vector ( ) ; } result . addElement ( methods [ i ] ) ; } } } } catch ( ClassNotFoundException e ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } return result ; } private Vector findConstructors ( ) { Vector result = null ; final String namespace = _fname . getNamespace ( ) ; if ( namespace . startsWith ( JAVA_EXT_XSLTC ) || namespace . startsWith ( JAVA_EXT_XALAN ) ) { final int nArgs = _arguments . size ( ) ; try { TransletLoader loader = new TransletLoader ( ) ; final Class clazz = loader . loadClass ( _className ) ; if ( clazz == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } else { final Constructor [ ] constructors = clazz . getConstructors ( ) ; for ( int i = 0 ; i < constructors . length ; i ++ ) { final int mods = constructors [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && constructors [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( result == null ) { result = new Vector ( ) ; } result . addElement ( constructors [ i ] ) ; } } } } catch ( ClassNotFoundException e ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } return result ; } static final String getSignature ( Class clazz ) { if ( clazz . isArray ( ) ) { final StringBuffer sb = new StringBuffer ( ) ; Class cl = clazz ; while ( cl . isArray ( ) ) { sb . append ( "[" ) ; cl = cl . getComponentType ( ) ; } sb . append ( getSignature ( cl ) ) ; return sb . toString ( ) ; } else if ( clazz . isPrimitive ( ) ) { if ( clazz == Integer . TYPE ) { return "I" ; } else if ( clazz == Byte . TYPE ) { return "B" ; } else if ( clazz == Long . TYPE ) { return "J" ; } else if ( clazz == Float . TYPE ) { return "F" ; } else if ( clazz == Double . TYPE ) { return "D" ; } else if ( clazz == Short . TYPE ) { return "S" ; } else if ( clazz == Character . TYPE ) { return "C" ; } else if ( clazz == Boolean . TYPE ) { return "Z" ; } else if ( clazz == Void . TYPE ) { return "V" ; } else { final String name = clazz . toString ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . UNKNOWN_SIG_TYPE_ERR , name ) ; throw new Error ( err . toString ( ) ) ; } } else { return "L" + clazz . getName ( ) . replace ( '.' , '/' ) + ';' ; } } static final String getSignature ( Method meth ) { final StringBuffer sb = new StringBuffer ( ) ; sb . append ( '(' ) ; final Class [ ] params = meth . getParameterTypes ( ) ; for ( int j = 0 ; j < params . length ; j ++ ) { sb . append ( getSignature ( params [ j ] ) ) ; } return sb . append ( ')' ) . append ( getSignature ( meth . getReturnType ( ) ) ) . toString ( ) ; } static final String getSignature ( Constructor cons ) { final StringBuffer sb = new StringBuffer ( ) ; sb . append ( '(' ) ; final Class [ ] params = cons . getParameterTypes ( ) ; for ( int j = 0 ; j < params . length ; j ++ ) { sb . append ( getSignature ( params [ j ] ) ) ; } return sb . append ( ")V" ) . toString ( ) ; } } 	1	['25', '3', '23', '62', '126', '68', '25', '37', '15', '0.848958333', '1894', '0.9375', '4', '0.76344086', '0.131410256', '3', '10', '74.12', '15', '2.92', '3']
package org . apache . xalan . xsltc . compiler ; final class ArgumentList { private final Expression _arg ; private final ArgumentList _rest ; public ArgumentList ( Expression arg , ArgumentList rest ) { _arg = arg ; _rest = rest ; } public String toString ( ) { return _rest == null ? _arg . toString ( ) : _arg . toString ( ) + ", " + _rest . toString ( ) ; } } 	0	['2', '1', '0', '1', '7', '0', '0', '1', '2', '0', '35', '1', '2', '0', '0.666666667', '0', '0', '15.5', '2', '1', '0']
package org . apache . xpath . axes ; import javax . xml . transform . TransformerException ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . XPathContext ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . dtm . DTM ; public class SelfIteratorNoPredicate extends LocPathIterator { SelfIteratorNoPredicate ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; } public SelfIteratorNoPredicate ( ) throws javax . xml . transform . TransformerException { super ( null ) ; } public int nextNode ( ) { int next ; DTM dtm = m_cdtm ; m_lastFetched = next = ( DTM . NULL == m_lastFetched ) ? m_context : DTM . NULL ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return xctxt . getCurrentNode ( ) ; } public int getLastPos ( XPathContext xctxt ) { return 1 ; } } 	1	['5', '5', '0', '9', '8', '10', '3', '6', '4', '2', '52', '0', '0', '0.9765625', '0.45', '1', '4', '9.4', '3', '1', '1']
package org . apache . xalan . templates ; import java . util . Vector ; import java . util . Hashtable ; import org . apache . xpath . functions . Function ; import org . apache . xpath . functions . Function2Args ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . axes . UnionPathIterator ; import org . apache . xml . utils . QName ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . KeyManager ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xpath . XPathContext ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; public class FuncKey extends Function2Args { static private Boolean ISTRUE = new Boolean ( true ) ; public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { TransformerImpl transformer = ( TransformerImpl ) xctxt . getOwnerObject ( ) ; XNodeSet nodes = null ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocumentRoot ( context ) ; if ( DTM . NULL == docContext ) { } String xkeyname = getArg0 ( ) . execute ( xctxt ) . str ( ) ; QName keyname = new QName ( xkeyname , xctxt . getNamespaceContext ( ) ) ; XObject arg = getArg1 ( ) . execute ( xctxt ) ; boolean argIsNodeSetDTM = ( XObject . CLASS_NODESET == arg . getType ( ) ) ; KeyManager kmgr = transformer . getKeyManager ( ) ; if ( argIsNodeSetDTM ) { XNodeSet ns = ( XNodeSet ) arg ; ns . setShouldCacheNodes ( true ) ; int len = ns . getLength ( ) ; if ( len <= 1 ) argIsNodeSetDTM = false ; } if ( argIsNodeSetDTM ) { Hashtable usedrefs = null ; DTMIterator ni = arg . iter ( ) ; int pos ; UnionPathIterator upi = new UnionPathIterator ( ) ; upi . exprSetParent ( this ) ; while ( DTM . NULL != ( pos = ni . nextNode ( ) ) ) { dtm = xctxt . getDTM ( pos ) ; XMLString ref = dtm . getStringValue ( pos ) ; if ( null == ref ) continue ; if ( null == usedrefs ) usedrefs = new Hashtable ( ) ; if ( usedrefs . get ( ref ) != null ) { continue ; } else { usedrefs . put ( ref , ISTRUE ) ; } XNodeSet nl = kmgr . getNodeSetDTMByKey ( xctxt , docContext , keyname , ref , xctxt . getNamespaceContext ( ) ) ; nl . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; upi . addIterator ( nl ) ; } int current = xctxt . getCurrentNode ( ) ; upi . setRoot ( current , xctxt ) ; nodes = new XNodeSet ( upi ) ; } else { XMLString ref = arg . xstr ( ) ; nodes = kmgr . getNodeSetDTMByKey ( xctxt , docContext , keyname , ref , xctxt . getNamespaceContext ( ) ) ; nodes . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; } return nodes ; } } 	0	['3', '5', '0', '17', '33', '1', '1', '16', '2', '0.5', '177', '1', '0', '0.98245614', '0.75', '1', '7', '57.66666667', '1', '0.3333', '0']
package org . apache . xpath . compiler ; import org . apache . xml . utils . PrefixResolver ; import java . util . Vector ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xpath . XPath ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . compiler . XPathParser ; class Lexer { private Compiler m_compiler ; PrefixResolver m_namespaceContext ; XPathParser m_processor ; static final int TARGETEXTRA = 10000 ; private int m_patternMap [ ] = new int [ 100 ] ; private int m_patternMapSize ; Lexer ( Compiler compiler , PrefixResolver resolver , XPathParser xpathProcessor ) { m_compiler = compiler ; m_namespaceContext = resolver ; m_processor = xpathProcessor ; } void tokenize ( String pat ) throws javax . xml . transform . TransformerException { tokenize ( pat , null ) ; } void tokenize ( String pat , Vector targetStrings ) throws javax . xml . transform . TransformerException { m_compiler . m_tokenQueueSize = 0 ; m_compiler . m_currentPattern = pat ; m_patternMapSize = 0 ; m_compiler . m_opMap = new int [ OpMap . MAXTOKENQUEUESIZE * 5 ] ; int nChars = pat . length ( ) ; int startSubstring = - 1 ; int posOfNSSep = - 1 ; boolean isStartOfPat = true ; boolean isAttrName = false ; boolean isNum = false ; int nesting = 0 ; for ( int i = 0 ; i < nChars ; i ++ ) { char c = pat . charAt ( i ) ; switch ( c ) { case '\"' : { if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } } startSubstring = i ; for ( i ++ ; ( i < nChars ) && ( ( c = pat . charAt ( i ) ) != '\"' ) ; i ++ ) ; if ( c == '\"' && i < nChars ) { addToTokenQueue ( pat . substring ( startSubstring , i + 1 ) ) ; startSubstring = - 1 ; } else { m_processor . error ( XPATHErrorResources . ER_EXPECTED_DOUBLE_QUOTE , null ) ; } } break ; case '\'' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } } startSubstring = i ; for ( i ++ ; ( i < nChars ) && ( ( c = pat . charAt ( i ) ) != '\'' ) ; i ++ ) ; if ( c == '\'' && i < nChars ) { addToTokenQueue ( pat . substring ( startSubstring , i + 1 ) ) ; startSubstring = - 1 ; } else { m_processor . error ( XPATHErrorResources . ER_EXPECTED_SINGLE_QUOTE , null ) ; } break ; case 0x0A : case 0x0D : case ' ' : case '\t' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } startSubstring = - 1 ; } break ; case '@' : isAttrName = true ; case '-' : if ( '-' == c ) { if ( ! ( isNum || ( startSubstring == - 1 ) ) ) { break ; } isNum = false ; } case '(' : case '[' : case ')' : case ']' : case '|' : case '/' : case '*' : case '+' : case '=' : case ',' : case '\\' : case '^' : case '!' : case '$' : case '<' : case '>' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } startSubstring = - 1 ; } else if ( ( '/' == c ) && isStartOfPat ) { isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; } else if ( '*' == c ) { isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; } if ( 0 == nesting ) { if ( '|' == c ) { if ( null != targetStrings ) { recordTokenString ( targetStrings ) ; } isStartOfPat = true ; } } if ( ( ')' == c ) || ( ']' == c ) ) { nesting -- ; } else if ( ( '(' == c ) || ( '[' == c ) ) { nesting ++ ; } addToTokenQueue ( pat . substring ( i , i + 1 ) ) ; break ; case ':' : if ( i > 0 ) { if ( posOfNSSep == ( i - 1 ) ) { if ( startSubstring != - 1 ) { if ( startSubstring < ( i - 1 ) ) addToTokenQueue ( pat . substring ( startSubstring , i - 1 ) ) ; } isNum = false ; isAttrName = false ; startSubstring = - 1 ; posOfNSSep = - 1 ; addToTokenQueue ( pat . substring ( i - 1 , i + 1 ) ) ; break ; } else { posOfNSSep = i ; } } default : if ( - 1 == startSubstring ) { startSubstring = i ; isNum = Character . isDigit ( c ) ; } else if ( isNum ) { isNum = Character . isDigit ( c ) ; } } } if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; if ( ( - 1 != posOfNSSep ) || ( ( m_namespaceContext != null ) && ( m_namespaceContext . handlesNullPrefixes ( ) ) ) ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , nChars ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , nChars ) ) ; } } if ( 0 == m_compiler . m_tokenQueueSize ) { m_processor . error ( XPATHErrorResources . ER_EMPTY_EXPRESSION , null ) ; } else if ( null != targetStrings ) { recordTokenString ( targetStrings ) ; } m_processor . m_queueMark = 0 ; } private boolean mapPatternElemPos ( int nesting , boolean isStart , boolean isAttrName ) { if ( 0 == nesting ) { if ( m_patternMapSize >= m_patternMap . length ) { int patternMap [ ] = m_patternMap ; int len = m_patternMap . length ; m_patternMap = new int [ m_patternMapSize + 100 ] ; System . arraycopy ( patternMap , 0 , m_patternMap , 0 , len ) ; } if ( ! isStart ) { m_patternMap [ m_patternMapSize - 1 ] -= TARGETEXTRA ; } m_patternMap [ m_patternMapSize ] = ( m_compiler . m_tokenQueueSize - ( isAttrName ? 1 : 0 ) ) + TARGETEXTRA ; m_patternMapSize ++ ; isStart = false ; } return isStart ; } private int getTokenQueuePosFromMap ( int i ) { int pos = m_patternMap [ i ] ; return ( pos >= TARGETEXTRA ) ? ( pos - TARGETEXTRA ) : pos ; } private final void resetTokenMark ( int mark ) { int qsz = m_compiler . m_tokenQueueSize ; m_processor . m_queueMark = ( mark > 0 ) ? ( ( mark <= qsz ) ? mark - 1 : mark ) : 0 ; if ( m_processor . m_queueMark < qsz ) { m_processor . m_token = ( String ) m_compiler . m_tokenQueue [ m_processor . m_queueMark ++ ] ; m_processor . m_tokenChar = m_processor . m_token . charAt ( 0 ) ; } else { m_processor . m_token = null ; m_processor . m_tokenChar = 0 ; } } final int getKeywordToken ( String key ) { int tok ; try { Integer itok = ( Integer ) Keywords . m_keywords . get ( key ) ; tok = ( null != itok ) ? itok . intValue ( ) : 0 ; } catch ( NullPointerException npe ) { tok = 0 ; } catch ( ClassCastException cce ) { tok = 0 ; } return tok ; } private void recordTokenString ( Vector targetStrings ) { int tokPos = getTokenQueuePosFromMap ( m_patternMapSize - 1 ) ; resetTokenMark ( tokPos + 1 ) ; if ( m_processor . lookahead ( '(' , 1 ) ) { int tok = getKeywordToken ( m_processor . m_token ) ; switch ( tok ) { case OpCodes . NODETYPE_COMMENT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_COMMENT ) ; break ; case OpCodes . NODETYPE_TEXT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_TEXT ) ; break ; case OpCodes . NODETYPE_NODE : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; case OpCodes . NODETYPE_ROOT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ROOT ) ; break ; case OpCodes . NODETYPE_ANYELEMENT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; case OpCodes . NODETYPE_PI : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; default : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; } } else { if ( m_processor . tokenIs ( '@' ) ) { tokPos ++ ; resetTokenMark ( tokPos + 1 ) ; } if ( m_processor . lookahead ( ':' , 1 ) ) { tokPos += 2 ; } targetStrings . addElement ( m_compiler . m_tokenQueue [ tokPos ] ) ; } } private final void addToTokenQueue ( String s ) { m_compiler . m_tokenQueue [ m_compiler . m_tokenQueueSize ++ ] = s ; } private int mapNSTokens ( String pat , int startSubstring , int posOfNSSep , int posOfScan ) throws javax . xml . transform . TransformerException { String prefix = "" ; if ( ( startSubstring >= 0 ) && ( posOfNSSep >= 0 ) ) { prefix = pat . substring ( startSubstring , posOfNSSep ) ; } String uName ; if ( ( null != m_namespaceContext ) && ! prefix . equals ( "*" ) && ! prefix . equals ( "xmlns" ) ) { try { if ( prefix . length ( ) > 0 ) uName = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; else { if ( false ) { addToTokenQueue ( ":" ) ; String s = pat . substring ( posOfNSSep + 1 , posOfScan ) ; if ( s . length ( ) > 0 ) addToTokenQueue ( s ) ; return - 1 ; } else { uName = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; } } } catch ( ClassCastException cce ) { uName = m_namespaceContext . getNamespaceForPrefix ( prefix ) ; } } else { uName = prefix ; } if ( ( null != uName ) && ( uName . length ( ) > 0 ) ) { addToTokenQueue ( uName ) ; addToTokenQueue ( ":" ) ; String s = pat . substring ( posOfNSSep + 1 , posOfScan ) ; if ( s . length ( ) > 0 ) addToTokenQueue ( s ) ; } else { m_processor . error ( XPATHErrorResources . ER_PREFIX_MUST_RESOLVE , new String [ ] { prefix } ) ; } return - 1 ; } } 	1	['10', '1', '0', '5', '25', '3', '1', '5', '0', '0.611111111', '815', '0.5', '3', '0', '0.3125', '0', '0', '79.9', '11', '2.8', '1']
package org . apache . xalan . lib . sql ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . DriverManager ; import java . sql . SQLException ; import java . sql . Statement ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . Date ; import java . sql . Timestamp ; import java . sql . Time ; import java . util . Properties ; import java . util . Vector ; import java . util . StringTokenizer ; import java . lang . IllegalArgumentException ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . NodeList ; import org . w3c . dom . Node ; import java . util . Vector ; import java . util . Enumeration ; import java . math . BigDecimal ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xpath . XPathContext ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xpath . objects . XBooleanStatic ; import org . w3c . dom . * ; import java . sql . * ; import java . util . * ; public class XConnection { private static final boolean DEBUG = false ; private ConnectionPool m_ConnectionPool = null ; private boolean m_DefaultPoolingEnabled = false ; private Vector m_OpenSQLDocuments = new Vector ( ) ; private ConnectionPoolManager m_PoolMgr = new ConnectionPoolManager ( ) ; private Vector m_ParameterList = new Vector ( ) ; private SQLErrorDocument m_Error = null ; private boolean m_IsDefaultPool = false ; private boolean m_IsStreamingEnabled = true ; public XConnection ( ) { } public XConnection ( ExpressionContext exprContext , String ConnPoolName ) { connect ( exprContext , ConnPoolName ) ; } public XConnection ( ExpressionContext exprContext , String driver , String dbURL ) { connect ( exprContext , driver , dbURL ) ; } public XConnection ( ExpressionContext exprContext , NodeList list ) { connect ( exprContext , list ) ; } public XConnection ( ExpressionContext exprContext , String driver , String dbURL , String user , String password ) { connect ( exprContext , driver , dbURL , user , password ) ; } public XConnection ( ExpressionContext exprContext , String driver , String dbURL , Element protocolElem ) { connect ( exprContext , driver , dbURL , protocolElem ) ; } public XBooleanStatic connect ( ExpressionContext exprContext , String ConnPoolName ) { try { m_ConnectionPool = m_PoolMgr . getPool ( ConnPoolName ) ; if ( m_ConnectionPool == null ) throw new java . lang . IllegalArgumentException ( "Invalid Pool Name" ) ; m_IsDefaultPool = false ; return new XBooleanStatic ( true ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , String driver , String dbURL ) { try { init ( driver , dbURL , new Properties ( ) ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , Element protocolElem ) { try { initFromElement ( protocolElem ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , NodeList list ) { try { initFromElement ( ( Element ) list . item ( 0 ) ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , String driver , String dbURL , String user , String password ) { try { Properties prop = new Properties ( ) ; prop . put ( "user" , user ) ; prop . put ( "password" , password ) ; init ( driver , dbURL , prop ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , String driver , String dbURL , Element protocolElem ) { try { Properties prop = new Properties ( ) ; NamedNodeMap atts = protocolElem . getAttributes ( ) ; for ( int i = 0 ; i < atts . getLength ( ) ; i ++ ) { prop . put ( atts . item ( i ) . getNodeName ( ) , atts . item ( i ) . getNodeValue ( ) ) ; } init ( driver , dbURL , prop ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } private void initFromElement ( Element e ) throws SQLException { Properties prop = new Properties ( ) ; String driver = "" ; String dbURL = "" ; Node n = e . getFirstChild ( ) ; if ( null == n ) return ; do { String nName = n . getNodeName ( ) ; if ( nName . equalsIgnoreCase ( "dbdriver" ) ) { driver = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { driver = n1 . getNodeValue ( ) ; } } if ( nName . equalsIgnoreCase ( "dburl" ) ) { dbURL = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { dbURL = n1 . getNodeValue ( ) ; } } if ( nName . equalsIgnoreCase ( "password" ) ) { String s = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { s = n1 . getNodeValue ( ) ; } prop . put ( "password" , s ) ; } if ( nName . equalsIgnoreCase ( "user" ) ) { String s = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { s = n1 . getNodeValue ( ) ; } prop . put ( "user" , s ) ; } if ( nName . equalsIgnoreCase ( "protocol" ) ) { String Name = "" ; NamedNodeMap attrs = n . getAttributes ( ) ; Node n1 = attrs . getNamedItem ( "name" ) ; if ( null != n1 ) { String s = "" ; Name = n1 . getNodeValue ( ) ; Node n2 = n . getFirstChild ( ) ; if ( null != n2 ) s = n2 . getNodeValue ( ) ; prop . put ( Name , s ) ; } } } while ( ( n = n . getNextSibling ( ) ) != null ) ; init ( driver , dbURL , prop ) ; } private void init ( String driver , String dbURL , Properties prop ) throws SQLException { Connection con = null ; if ( DEBUG ) System . out . println ( "XConnection, Connection Init" ) ; String user = prop . getProperty ( "user" ) ; if ( user == null ) user = "" ; String passwd = prop . getProperty ( "password" ) ; if ( passwd == null ) passwd = "" ; String poolName = driver + dbURL + user + passwd ; ConnectionPool cpool = m_PoolMgr . getPool ( poolName ) ; if ( cpool == null ) { if ( DEBUG ) { System . out . println ( "XConnection, Creating Connection" ) ; System . out . println ( " Driver  :" + driver ) ; System . out . println ( " URL     :" + dbURL ) ; System . out . println ( " user    :" + user ) ; System . out . println ( " passwd  :" + passwd ) ; } DefaultConnectionPool defpool = new DefaultConnectionPool ( ) ; if ( ( DEBUG ) && ( defpool == null ) ) System . out . println ( "Failed to Create a Default Connection Pool" ) ; defpool . setDriver ( driver ) ; defpool . setURL ( dbURL ) ; defpool . setProtocol ( prop ) ; if ( m_DefaultPoolingEnabled ) defpool . setPoolEnabled ( true ) ; m_PoolMgr . registerPool ( poolName , defpool ) ; m_ConnectionPool = defpool ; } else { m_ConnectionPool = cpool ; } m_IsDefaultPool = true ; try { con = m_ConnectionPool . getConnection ( ) ; } catch ( SQLException e ) { if ( con != null ) { m_ConnectionPool . releaseConnectionOnError ( con ) ; con = null ; } throw e ; } finally { m_ConnectionPool . releaseConnection ( con ) ; } } public DTM query ( ExpressionContext exprContext , String queryString ) { Connection con = null ; Statement stmt = null ; ResultSet rs = null ; DTMManagerDefault mgrDefault = null ; SQLDocument doc = null ; try { if ( DEBUG ) System . out . println ( "query()" ) ; if ( null == m_ConnectionPool ) { return null ; } try { con = m_ConnectionPool . getConnection ( ) ; stmt = con . createStatement ( ) ; rs = stmt . executeQuery ( queryString ) ; } catch ( SQLException e ) { try { if ( null != rs ) rs . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } buildErrorDocument ( exprContext , e ) ; return null ; } if ( DEBUG ) System . out . println ( "..creatingSQLDocument" ) ; DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; doc = new SQLDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , m_ConnectionPool , con , stmt , rs , m_IsStreamingEnabled ) ; if ( null != doc ) { if ( DEBUG ) System . out . println ( "..returning Document" ) ; mgrDefault . addDTM ( doc , dtmIdent ) ; m_OpenSQLDocuments . addElement ( doc ) ; return doc ; } else { return null ; } } catch ( SQLException e ) { if ( ( doc != null ) && ( mgrDefault != null ) ) { doc . closeOnError ( ) ; mgrDefault . release ( doc , true ) ; } buildErrorDocument ( exprContext , e ) ; return null ; } catch ( Exception e ) { if ( ( doc != null ) && ( mgrDefault != null ) ) { doc . closeOnError ( ) ; mgrDefault . release ( doc , true ) ; } if ( DEBUG ) System . out . println ( "exception in query()" ) ; buildErrorDocument ( exprContext , e ) ; return null ; } finally { if ( DEBUG ) System . out . println ( "leaving query()" ) ; } } public DTM pquery ( ExpressionContext exprContext , String queryString ) { Connection con = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { int indx ; try { con = m_ConnectionPool . getConnection ( ) ; stmt = con . prepareStatement ( queryString ) ; } catch ( SQLException e ) { try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } throw e ; } if ( DEBUG ) System . out . println ( "..building Prepared Statement" ) ; try { Enumeration enum = m_ParameterList . elements ( ) ; indx = 1 ; while ( enum . hasMoreElements ( ) ) { QueryParameter qp = ( QueryParameter ) enum . nextElement ( ) ; setParameter ( indx , stmt , qp ) ; indx ++ ; } rs = stmt . executeQuery ( ) ; } catch ( SQLException e ) { try { if ( null != rs ) rs . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } throw e ; } if ( DEBUG ) System . out . println ( "..creatingSQLDocument" ) ; DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; SQLDocument doc = new SQLDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , m_ConnectionPool , con , stmt , rs , m_IsStreamingEnabled ) ; if ( null != doc ) { if ( DEBUG ) System . out . println ( "..returning Document" ) ; mgrDefault . addDTM ( doc , dtmIdent ) ; m_OpenSQLDocuments . addElement ( doc ) ; return doc ; } else { return null ; } } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return null ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return null ; } } public DTM pquery ( ExpressionContext exprContext , String queryString , String typeInfo ) { Connection con = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { int indx ; StringTokenizer plist = new StringTokenizer ( typeInfo ) ; indx = 0 ; while ( plist . hasMoreTokens ( ) ) { String value = plist . nextToken ( ) ; QueryParameter qp = ( QueryParameter ) m_ParameterList . elementAt ( indx ) ; if ( null != qp ) { qp . setType ( value ) ; } indx ++ ; } try { con = m_ConnectionPool . getConnection ( ) ; stmt = con . prepareStatement ( queryString ) ; } catch ( SQLException e ) { try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } throw e ; } if ( DEBUG ) System . out . println ( "..building Prepared Statement" ) ; try { Enumeration enum = m_ParameterList . elements ( ) ; indx = 1 ; while ( enum . hasMoreElements ( ) ) { QueryParameter qp = ( QueryParameter ) enum . nextElement ( ) ; setParameter ( indx , stmt , qp ) ; indx ++ ; } rs = stmt . executeQuery ( ) ; } catch ( SQLException e ) { try { if ( null != rs ) rs . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } throw e ; } if ( DEBUG ) System . out . println ( "..creatingSQLDocument" ) ; DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; SQLDocument doc = new SQLDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , m_ConnectionPool , con , stmt , rs , m_IsStreamingEnabled ) ; if ( null != doc ) { if ( DEBUG ) System . out . println ( "..returning Document" ) ; mgrDefault . addDTM ( doc , dtmIdent ) ; m_OpenSQLDocuments . addElement ( doc ) ; return doc ; } else { return null ; } } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return null ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return null ; } } public void addParameter ( String value ) { addParameterWithType ( value , null ) ; } public void addParameterWithType ( String value , String Type ) { m_ParameterList . addElement ( new QueryParameter ( value , Type ) ) ; } public void addParameterFromElement ( Element e ) { NamedNodeMap attrs = e . getAttributes ( ) ; Node Type = attrs . getNamedItem ( "type" ) ; Node n1 = e . getFirstChild ( ) ; if ( null != n1 ) { String value = n1 . getNodeValue ( ) ; if ( value == null ) value = "" ; m_ParameterList . addElement ( new QueryParameter ( value , Type . getNodeValue ( ) ) ) ; } } public void addParameterFromElement ( NodeList nl ) { int count = nl . getLength ( ) ; for ( int x = 0 ; x < count ; x ++ ) { addParameters ( ( Element ) nl . item ( x ) ) ; } } private void addParameters ( Element elem ) { Node n = elem . getFirstChild ( ) ; if ( null == n ) return ; do { if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap attrs = n . getAttributes ( ) ; Node Type = attrs . getNamedItem ( "type" ) ; String TypeStr ; if ( Type == null ) TypeStr = "string" ; else TypeStr = Type . getNodeValue ( ) ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { String value = n1 . getNodeValue ( ) ; if ( value == null ) value = "" ; m_ParameterList . addElement ( new QueryParameter ( value , TypeStr ) ) ; } } } while ( ( n = n . getNextSibling ( ) ) != null ) ; } public void clearParameters ( ) { m_ParameterList . removeAllElements ( ) ; } public void enableDefaultConnectionPool ( ) { if ( DEBUG ) System . out . println ( "Enabling Default Connection Pool" ) ; m_DefaultPoolingEnabled = true ; if ( m_ConnectionPool == null ) return ; if ( m_IsDefaultPool ) return ; m_ConnectionPool . setPoolEnabled ( true ) ; } public void disableDefaultConnectionPool ( ) { if ( DEBUG ) System . out . println ( "Disabling Default Connection Pool" ) ; m_DefaultPoolingEnabled = false ; if ( m_ConnectionPool == null ) return ; if ( ! m_IsDefaultPool ) return ; m_ConnectionPool . setPoolEnabled ( false ) ; } public void enableStreamingMode ( ) { if ( DEBUG ) System . out . println ( "Enabling Streaming Mode" ) ; m_IsStreamingEnabled = true ; } public void disableStreamingMode ( ) { if ( DEBUG ) System . out . println ( "Disable Streaming Mode" ) ; m_IsStreamingEnabled = false ; } public DTM getError ( ) { return m_Error ; } public void close ( ) throws SQLException { if ( DEBUG ) System . out . println ( "Entering XConnection.close" ) ; while ( m_OpenSQLDocuments . size ( ) != 0 ) { SQLDocument d = ( SQLDocument ) m_OpenSQLDocuments . elementAt ( 0 ) ; d . close ( ) ; m_OpenSQLDocuments . removeElementAt ( 0 ) ; } if ( DEBUG ) System . out . println ( "Exiting XConnection.close" ) ; } public void close ( SQLDocument sqldoc ) throws SQLException { if ( DEBUG ) System . out . println ( "Entering XConnection.close" ) ; int size = m_OpenSQLDocuments . size ( ) ; for ( int x = 0 ; x < size ; x ++ ) { SQLDocument d = ( SQLDocument ) m_OpenSQLDocuments . elementAt ( x ) ; if ( d == sqldoc ) { d . close ( ) ; m_OpenSQLDocuments . removeElementAt ( x ) ; } } } public void setParameter ( int pos , PreparedStatement stmt , QueryParameter p ) throws SQLException { String type = p . getType ( ) ; if ( type . equalsIgnoreCase ( "string" ) ) { stmt . setString ( pos , p . getValue ( ) ) ; } if ( type . equalsIgnoreCase ( "bigdecimal" ) ) { stmt . setBigDecimal ( pos , new BigDecimal ( p . getValue ( ) ) ) ; } if ( type . equalsIgnoreCase ( "boolean" ) ) { Integer i = new Integer ( p . getValue ( ) ) ; boolean b = ( ( i . intValue ( ) != 0 ) ? false : true ) ; stmt . setBoolean ( pos , b ) ; } if ( type . equalsIgnoreCase ( "bytes" ) ) { stmt . setBytes ( pos , p . getValue ( ) . getBytes ( ) ) ; } if ( type . equalsIgnoreCase ( "date" ) ) { stmt . setDate ( pos , Date . valueOf ( p . getValue ( ) ) ) ; } if ( type . equalsIgnoreCase ( "double" ) ) { Double d = new Double ( p . getValue ( ) ) ; stmt . setDouble ( pos , d . doubleValue ( ) ) ; } if ( type . equalsIgnoreCase ( "float" ) ) { Float f = new Float ( p . getValue ( ) ) ; stmt . setFloat ( pos , f . floatValue ( ) ) ; } if ( type . equalsIgnoreCase ( "long" ) ) { Long l = new Long ( p . getValue ( ) ) ; stmt . setLong ( pos , l . longValue ( ) ) ; } if ( type . equalsIgnoreCase ( "short" ) ) { Short s = new Short ( p . getValue ( ) ) ; stmt . setShort ( pos , s . shortValue ( ) ) ; } if ( type . equalsIgnoreCase ( "time" ) ) { stmt . setTime ( pos , Time . valueOf ( p . getValue ( ) ) ) ; } if ( type . equalsIgnoreCase ( "timestamp" ) ) { stmt . setTimestamp ( pos , Timestamp . valueOf ( p . getValue ( ) ) ) ; } } private void buildErrorDocument ( ExpressionContext exprContext , SQLException excp ) { try { DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; m_Error = new SQLErrorDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , excp ) ; mgrDefault . addDTM ( m_Error , dtmIdent ) ; } catch ( Exception e ) { m_Error = null ; } } private void buildErrorDocument ( ExpressionContext exprContext , Exception excp ) { try { DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; m_Error = new SQLErrorDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , excp ) ; mgrDefault . addDTM ( m_Error , dtmIdent ) ; } catch ( Exception e ) { m_Error = null ; } } protected void finalize ( ) { if ( DEBUG ) System . out . println ( "In XConnection, finalize" ) ; try { close ( ) ; } catch ( Exception e ) { } } } 	0	['34', '1', '0', '12', '124', '211', '0', '12', '28', '0.656565657', '1600', '1', '3', '0', '0.196078431', '0', '0', '45.79411765', '7', '1.6176', '0']
package org . apache . xpath . objects ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; import java . util . Locale ; public class XStringForFSB extends XString { int m_start ; int m_length ; protected String m_strCache = null ; protected int m_hash = 0 ; public XStringForFSB ( FastStringBuffer val , int start , int length ) { super ( val ) ; m_start = start ; m_length = length ; if ( null == val ) throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , null ) ) ; } private XStringForFSB ( String val ) { super ( val ) ; throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FSB_CANNOT_TAKE_STRING , null ) ) ; } public FastStringBuffer fsb ( ) { return ( ( FastStringBuffer ) m_obj ) ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { fsb . append ( str ( ) ) ; } public boolean hasString ( ) { return ( null != m_strCache ) ; } public Object object ( ) { return str ( ) ; } public String str ( ) { if ( null == m_strCache ) { m_strCache = fsb ( ) . getString ( m_start , m_length ) ; } return m_strCache ; } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { fsb ( ) . sendSAXcharacters ( ch , m_start , m_length ) ; } public void dispatchAsComment ( org . xml . sax . ext . LexicalHandler lh ) throws org . xml . sax . SAXException { fsb ( ) . sendSAXComment ( lh , m_start , m_length ) ; } public int length ( ) { return m_length ; } public char charAt ( int index ) { return fsb ( ) . charAt ( m_start + index ) ; } public void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { int n = srcEnd - srcBegin ; if ( n > m_length ) n = m_length ; if ( n > ( dst . length - dstBegin ) ) n = ( dst . length - dstBegin ) ; int end = srcBegin + m_start + n ; int d = dstBegin ; FastStringBuffer fsb = fsb ( ) ; for ( int i = srcBegin + m_start ; i < end ; i ++ ) { dst [ d ++ ] = fsb . charAt ( i ) ; } } public boolean equals ( XMLString obj2 ) { if ( this == obj2 ) { return true ; } int n = m_length ; if ( n == obj2 . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != obj2 . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( XObject obj2 ) { if ( this == obj2 ) { return true ; } if ( obj2 . getType ( ) == XObject . CLASS_NUMBER ) return obj2 . equals ( this ) ; String str = obj2 . str ( ) ; int n = m_length ; if ( n == str . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != str . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( String anotherString ) { int n = m_length ; if ( n == anotherString . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != anotherString . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( Object obj2 ) { if ( null == obj2 ) return false ; if ( obj2 instanceof XNumber ) return obj2 . equals ( this ) ; else if ( obj2 instanceof XNodeSet ) return obj2 . equals ( this ) ; else if ( obj2 instanceof XStringForFSB ) return equals ( ( XMLString ) this ) ; else return equals ( obj2 . toString ( ) ) ; } public boolean equalsIgnoreCase ( String anotherString ) { return ( m_length == anotherString . length ( ) ) ? str ( ) . equalsIgnoreCase ( anotherString ) : false ; } public int compareTo ( XMLString xstr ) { int len1 = m_length ; int len2 = xstr . length ( ) ; int n = Math . min ( len1 , len2 ) ; FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { char c1 = fsb . charAt ( i ) ; char c2 = xstr . charAt ( j ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len1 - len2 ; } public int compareToIgnoreCase ( XMLString xstr ) { int len1 = m_length ; int len2 = xstr . length ( ) ; int n = Math . min ( len1 , len2 ) ; FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { char c1 = Character . toLowerCase ( fsb . charAt ( i ) ) ; char c2 = Character . toLowerCase ( xstr . charAt ( j ) ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len1 - len2 ; } public int hashCode ( ) { return super . hashCode ( ) ; } public boolean startsWith ( XMLString prefix , int toffset ) { FastStringBuffer fsb = fsb ( ) ; int to = m_start + toffset ; int tlim = m_start + m_length ; int po = 0 ; int pc = prefix . length ( ) ; if ( ( toffset < 0 ) || ( toffset > m_length - pc ) ) { return false ; } while ( -- pc >= 0 ) { if ( fsb . charAt ( to ) != prefix . charAt ( po ) ) { return false ; } to ++ ; po ++ ; } return true ; } public boolean startsWith ( XMLString prefix ) { return startsWith ( prefix , 0 ) ; } public int indexOf ( int ch ) { return indexOf ( ch , 0 ) ; } public int indexOf ( int ch , int fromIndex ) { int max = m_start + m_length ; FastStringBuffer fsb = fsb ( ) ; if ( fromIndex < 0 ) { fromIndex = 0 ; } else if ( fromIndex >= m_length ) { return - 1 ; } for ( int i = m_start + fromIndex ; i < max ; i ++ ) { if ( fsb . charAt ( i ) == ch ) { return i - m_start ; } } return - 1 ; } public XMLString substring ( int beginIndex ) { int len = m_length - beginIndex ; if ( len <= 0 ) return XString . EMPTYSTRING ; else { int start = m_start + beginIndex ; return new XStringForFSB ( fsb ( ) , start , len ) ; } } public XMLString substring ( int beginIndex , int endIndex ) { int len = endIndex - beginIndex ; if ( len > m_length ) len = m_length ; if ( len <= 0 ) return XString . EMPTYSTRING ; else { int start = m_start + beginIndex ; return new XStringForFSB ( fsb ( ) , start , len ) ; } } public XMLString concat ( String str ) { return new XString ( str ( ) . concat ( str ) ) ; } public XMLString trim ( ) { return fixWhiteSpace ( true , true , false ) ; } private static boolean isSpace ( char ch ) { return XMLCharacterRecognizer . isWhiteSpace ( ch ) ; } public XMLString fixWhiteSpace ( boolean trimHead , boolean trimTail , boolean doublePunctuationSpaces ) { int end = m_length + m_start ; char [ ] buf = new char [ m_length ] ; FastStringBuffer fsb = fsb ( ) ; boolean edit = false ; int d = 0 ; boolean pres = false ; for ( int s = m_start ; s < end ; s ++ ) { char c = fsb . charAt ( s ) ; if ( isSpace ( c ) ) { if ( ! pres ) { if ( ' ' != c ) { edit = true ; } buf [ d ++ ] = ' ' ; if ( doublePunctuationSpaces && ( d != 0 ) ) { char prevChar = buf [ d - 1 ] ; if ( ! ( ( prevChar == '.' ) || ( prevChar == '!' ) || ( prevChar == '?' ) ) ) { pres = true ; } } else { pres = true ; } } else { edit = true ; pres = true ; } } else { buf [ d ++ ] = c ; pres = false ; } } if ( trimTail && 1 <= d && ' ' == buf [ d - 1 ] ) { edit = true ; d -- ; } int start = 0 ; if ( trimHead && 0 < d && ' ' == buf [ 0 ] ) { edit = true ; start ++ ; } XMLStringFactory xsf = XMLStringFactoryImpl . getFactory ( ) ; return edit ? xsf . newstr ( buf , start , d - start ) : this ; } public double toDouble ( ) { int end = m_length + m_start ; if ( 0 == end ) return Double . NaN ; int start = m_start ; FastStringBuffer fsb = fsb ( ) ; long longResult = 0 ; boolean isNegative = false ; boolean trailingSpace = false ; int [ ] digitsFound = { 0 , 0 } ; int digitType = 0 ; double doubleResult ; while ( start < end && XMLCharacterRecognizer . isWhiteSpace ( fsb . charAt ( start ) ) ) ++ start ; if ( start < end && fsb . charAt ( start ) == '-' ) { isNegative = true ; start ++ ; } for ( int i = start ; i < end ; i ++ ) { char c = fsb . charAt ( i ) ; if ( XMLCharacterRecognizer . isWhiteSpace ( c ) ) { trailingSpace = true ; break ; } else if ( trailingSpace ) return Double . NaN ; switch ( c ) { case '.' : if ( digitType == 0 ) digitType = 1 ; else return Double . NaN ; break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : longResult = longResult * 10 + ( c - '0' ) ; ++ digitsFound [ digitType ] ; break ; default : return Double . NaN ; } } if ( 0 == digitsFound [ 0 ] && 0 == digitsFound [ 1 ] ) return Double . NaN ; long scale = 1 ; for ( int i = digitsFound [ 1 ] ; i > 0 ; -- i ) scale *= 10 ; doubleResult = ( ( double ) longResult ) / scale ; if ( isNegative ) doubleResult *= - 1 ; return doubleResult ; } } 	1	['31', '4', '0', '10', '57', '117', '1', '10', '29', '0.5', '904', '0.5', '0', '0.802721088', '0.150537634', '4', '20', '28.03225806', '15', '3', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . * ; abstract class Instruction extends SyntaxTreeNode { public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . NOT_IMPLEMENTED_ERR , getClass ( ) , this ) ; getParser ( ) . reportError ( FATAL , msg ) ; } } 	0	['3', '2', '26', '37', '9', '3', '29', '8', '2', '2', '24', '0', '0', '0.964285714', '0.5', '1', '2', '7', '1', '0.6667', '0']
package org . apache . xalan . templates ; import java . io . * ; import java . util . * ; import org . xml . sax . * ; import org . xml . sax . helpers . * ; import java . util . StringTokenizer ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . NameSpace ; import org . apache . xml . utils . StringToStringTable ; import org . apache . xpath . XPathContext ; import org . apache . xml . utils . MutableAttrListImpl ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . XPathContext ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . extensions . ExtensionHandler ; import org . apache . xalan . extensions . ExtensionsTable ; import org . apache . xalan . transformer . TransformerImpl ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; public class ElemExtensionCall extends ElemLiteralResult { String m_extns ; String m_lang ; String m_srcURL ; String m_scriptSrc ; ElemExtensionDecl m_decl = null ; public int getXSLToken ( ) { return Constants . ELEMNAME_EXTENSIONCALL ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; m_extns = this . getNamespace ( ) ; m_decl = getElemExtensionDecl ( sroot , m_extns ) ; if ( m_decl == null ) sroot . getExtensionNamespacesManager ( ) . registerExtension ( m_extns ) ; } private ElemExtensionDecl getElemExtensionDecl ( StylesheetRoot stylesheet , String namespace ) { ElemExtensionDecl decl = null ; int n = stylesheet . getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Stylesheet imported = stylesheet . getGlobalImport ( i ) ; for ( ElemTemplateElement child = imported . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { if ( Constants . ELEMNAME_EXTENSIONDECL == child . getXSLToken ( ) ) { decl = ( ElemExtensionDecl ) child ; String prefix = decl . getPrefix ( ) ; String declNamespace = child . getNamespaceForPrefix ( prefix ) ; if ( namespace . equals ( declNamespace ) ) { return decl ; } } } } return decl ; } public void executeFallbacks ( TransformerImpl transformer ) throws TransformerException { for ( ElemTemplateElement child = m_firstChild ; child != null ; child = child . m_nextSibling ) { if ( child . getXSLToken ( ) == Constants . ELEMNAME_FALLBACK ) { try { transformer . pushElemTemplateElement ( child ) ; ( ( ElemFallback ) child ) . executeFallback ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; } } } } public void execute ( TransformerImpl transformer ) throws TransformerException { try { transformer . getResultTreeHandler ( ) . flushPending ( ) ; ExtensionsTable etable = transformer . getExtensionsTable ( ) ; ExtensionHandler nsh = etable . get ( m_extns ) ; if ( null == nsh ) { executeFallbacks ( transformer ) ; return ; } try { nsh . processElement ( this . getLocalName ( ) , this , transformer , getStylesheet ( ) , this ) ; } catch ( Exception e ) { String msg = e . getMessage ( ) ; TransformerException te ; if ( e instanceof TransformerException ) { te = ( TransformerException ) e ; } else { if ( null != msg ) te = new TransformerException ( e ) ; else te = new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_UNKNOWN_ERROR_CALLING_EXTENSION , null ) , e ) ; } if ( null == te . getLocator ( ) ) te . setLocator ( this ) ; if ( null != msg ) { if ( msg . indexOf ( "fatal" ) >= 0 ) { transformer . getErrorListener ( ) . fatalError ( te ) ; } else if ( e instanceof RuntimeException ) transformer . getErrorListener ( ) . error ( te ) ; else transformer . getErrorListener ( ) . warning ( te ) ; } else transformer . getErrorListener ( ) . error ( te ) ; executeFallbacks ( transformer ) ; } } catch ( org . xml . sax . SAXException se ) { transformer . getErrorListener ( ) . fatalError ( new TransformerException ( se ) ) ; } } public String getAttribute ( String rawName ) { AVT avt = getLiteralResultAttribute ( rawName ) ; if ( ( null != avt ) && avt . getRawName ( ) . equals ( rawName ) ) { return avt . getSimpleString ( ) ; } return null ; } public String getAttribute ( String rawName , org . w3c . dom . Node sourceNode , TransformerImpl transformer ) throws TransformerException { AVT avt = getLiteralResultAttribute ( rawName ) ; if ( ( null != avt ) && avt . getRawName ( ) . equals ( rawName ) ) { XPathContext xctxt = transformer . getXPathContext ( ) ; return avt . evaluate ( xctxt , xctxt . getDTMHandleFromNode ( sourceNode ) , this ) ; } return null ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitExtensionElement ( this ) ; } } 	1	['9', '5', '0', '20', '50', '32', '4', '17', '7', '1.025', '272', '0', '1', '0.967611336', '0.351851852', '3', '7', '28.66666667', '5', '1.5556', '2']
package org . apache . xalan . transformer ; import java . util . Vector ; import java . text . NumberFormat ; import java . text . CollationKey ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . axes . ContextNodeList ; import org . apache . xpath . XPathContext ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xml . utils . NodeVector ; import javax . xml . transform . TransformerException ; public class NodeSorter { XPathContext m_execContext ; Vector m_keys ; public NodeSorter ( XPathContext p ) { m_execContext = p ; } public void sort ( DTMIterator v , Vector keys , XPathContext support ) throws javax . xml . transform . TransformerException { m_keys = keys ; int n = v . getLength ( ) ; Vector nodes = new Vector ( ) ; for ( int i = 0 ; i < n ; i ++ ) { NodeCompareElem elem = new NodeCompareElem ( v . item ( i ) ) ; nodes . addElement ( elem ) ; } Vector scratchVector = new Vector ( ) ; mergesort ( nodes , scratchVector , 0 , n - 1 , support ) ; for ( int i = 0 ; i < n ; i ++ ) { v . setItem ( ( ( NodeCompareElem ) nodes . elementAt ( i ) ) . m_node , i ) ; } v . setCurrentPos ( 0 ) ; } int compare ( NodeCompareElem n1 , NodeCompareElem n2 , int kIndex , XPathContext support ) throws TransformerException { int result = 0 ; NodeSortKey k = ( NodeSortKey ) m_keys . elementAt ( kIndex ) ; if ( k . m_treatAsNumbers ) { double n1Num , n2Num ; if ( kIndex == 0 ) { n1Num = ( ( Double ) n1 . m_key1Value ) . doubleValue ( ) ; n2Num = ( ( Double ) n2 . m_key1Value ) . doubleValue ( ) ; } else if ( kIndex == 1 ) { n1Num = ( ( Double ) n1 . m_key2Value ) . doubleValue ( ) ; n2Num = ( ( Double ) n2 . m_key2Value ) . doubleValue ( ) ; } else { XObject r1 = k . m_selectPat . execute ( m_execContext , n1 . m_node , k . m_namespaceContext ) ; XObject r2 = k . m_selectPat . execute ( m_execContext , n2 . m_node , k . m_namespaceContext ) ; n1Num = r1 . num ( ) ; n2Num = r2 . num ( ) ; } if ( ( n1Num == n2Num ) && ( ( kIndex + 1 ) < m_keys . size ( ) ) ) { result = compare ( n1 , n2 , kIndex + 1 , support ) ; } else { double diff ; if ( Double . isNaN ( n1Num ) ) { if ( Double . isNaN ( n2Num ) ) diff = 0.0 ; else diff = - 1 ; } else if ( Double . isNaN ( n2Num ) ) diff = 1 ; else diff = n1Num - n2Num ; result = ( int ) ( ( diff < 0.0 ) ? ( k . m_descending ? 1 : - 1 ) : ( diff > 0.0 ) ? ( k . m_descending ? - 1 : 1 ) : 0 ) ; } } else { CollationKey n1String , n2String ; if ( kIndex == 0 ) { n1String = ( CollationKey ) n1 . m_key1Value ; n2String = ( CollationKey ) n2 . m_key1Value ; } else if ( kIndex == 1 ) { n1String = ( CollationKey ) n1 . m_key2Value ; n2String = ( CollationKey ) n2 . m_key2Value ; } else { XObject r1 = k . m_selectPat . execute ( m_execContext , n1 . m_node , k . m_namespaceContext ) ; XObject r2 = k . m_selectPat . execute ( m_execContext , n2 . m_node , k . m_namespaceContext ) ; n1String = k . m_col . getCollationKey ( r1 . str ( ) ) ; n2String = k . m_col . getCollationKey ( r2 . str ( ) ) ; } result = n1String . compareTo ( n2String ) ; if ( k . m_caseOrderUpper ) { String tempN1 = n1String . getSourceString ( ) . toLowerCase ( ) ; String tempN2 = n2String . getSourceString ( ) . toLowerCase ( ) ; if ( tempN1 . equals ( tempN2 ) ) { result = result == 0 ? 0 : - result ; } } if ( k . m_descending ) { result = - result ; } } if ( 0 == result ) { if ( ( kIndex + 1 ) < m_keys . size ( ) ) { result = compare ( n1 , n2 , kIndex + 1 , support ) ; } } if ( 0 == result ) { DTM dtm = support . getDTM ( n1 . m_node ) ; result = dtm . isNodeAfter ( n1 . m_node , n2 . m_node ) ? - 1 : 1 ; } return result ; } void mergesort ( Vector a , Vector b , int l , int r , XPathContext support ) throws TransformerException { if ( ( r - l ) > 0 ) { int m = ( r + l ) / 2 ; mergesort ( a , b , l , m , support ) ; mergesort ( a , b , m + 1 , r , support ) ; int i , j , k ; for ( i = m ; i >= l ; i -- ) { if ( i >= b . size ( ) ) b . insertElementAt ( a . elementAt ( i ) , i ) ; else b . setElementAt ( a . elementAt ( i ) , i ) ; } i = l ; for ( j = ( m + 1 ) ; j <= r ; j ++ ) { if ( r + m + 1 - j >= b . size ( ) ) b . insertElementAt ( a . elementAt ( j ) , r + m + 1 - j ) ; else b . setElementAt ( a . elementAt ( j ) , r + m + 1 - j ) ; } j = r ; int compVal ; for ( k = l ; k <= r ; k ++ ) { if ( i == j ) compVal = - 1 ; else compVal = compare ( ( NodeCompareElem ) b . elementAt ( i ) , ( NodeCompareElem ) b . elementAt ( j ) , 0 , support ) ; if ( compVal < 0 ) { a . setElementAt ( b . elementAt ( i ) , k ) ; i ++ ; } else if ( compVal > 0 ) { a . setElementAt ( b . elementAt ( j ) , k ) ; j -- ; } } } } class NodeCompareElem { int m_node ; int maxkey = 2 ; Object m_key1Value ; Object m_key2Value ; NodeCompareElem ( int node ) throws javax . xml . transform . TransformerException { boolean tryNextKey = true ; m_node = node ; if ( ! m_keys . isEmpty ( ) ) { NodeSortKey k1 = ( NodeSortKey ) m_keys . elementAt ( 0 ) ; XObject r = k1 . m_selectPat . execute ( m_execContext , node , k1 . m_namespaceContext ) ; if ( r == null ) tryNextKey = false ; double d ; if ( k1 . m_treatAsNumbers ) { d = r . num ( ) ; m_key1Value = new Double ( d ) ; } else { m_key1Value = k1 . m_col . getCollationKey ( r . str ( ) ) ; } if ( r . getType ( ) == XObject . CLASS_NODESET ) { DTMIterator ni = ( ( XNodeSet ) r ) . iterRaw ( ) ; int current = ni . getCurrentNode ( ) ; if ( DTM . NULL == current ) current = ni . nextNode ( ) ; tryNextKey = ( DTM . NULL != current ) ; } if ( m_keys . size ( ) > 1 ) { NodeSortKey k2 = ( NodeSortKey ) m_keys . elementAt ( 1 ) ; if ( ! tryNextKey ) { if ( k2 . m_treatAsNumbers ) m_key2Value = new Double ( 0.0 ) ; else m_key2Value = k2 . m_col . getCollationKey ( "" ) ; } else { XObject r2 = k2 . m_selectPat . execute ( m_execContext , node , k2 . m_namespaceContext ) ; if ( k2 . m_treatAsNumbers ) { d = r2 . num ( ) ; m_key2Value = new Double ( d ) ; } else m_key2Value = k2 . m_col . getCollationKey ( r2 . str ( ) ) ; } } } } } } 	0	['4', '1', '0', '9', '28', '2', '2', '8', '2', '0.333333333', '475', '0', '1', '0', '0.583333333', '0', '0', '117.25', '1', '0.75', '0']
package org . apache . xalan . templates ; import java . lang . InstantiationException ; import java . io . Serializable ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . xml . utils . UnImplNode ; import org . apache . xml . utils . NameSpace ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . StringToStringTable ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . ResultNameSpace ; import org . apache . xalan . transformer . ResultTreeHandler ; import org . apache . xpath . VariableStack ; import org . apache . xpath . WhitespaceStrippingElementMatcher ; import org . apache . xpath . ExpressionNode ; import javax . xml . transform . Templates ; import javax . xml . transform . SourceLocator ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . apache . xml . dtm . DTM ; import org . xml . sax . Locator ; import javax . xml . transform . TransformerException ; import org . xml . sax . helpers . NamespaceSupport ; import org . apache . xml . utils . NamespaceSupport2 ; public class ElemTemplateElement extends UnImplNode implements PrefixResolver , Serializable , ExpressionNode , WhitespaceStrippingElementMatcher , XSLTVisitable { public ElemTemplateElement ( ) { } public boolean isCompiledTemplate ( ) { return false ; } public int getXSLToken ( ) { return Constants . ELEMNAME_UNDEFINED ; } public String getNodeName ( ) { return "Unknown XSLT Element" ; } public String getLocalName ( ) { return getNodeName ( ) ; } public void runtimeInit ( TransformerImpl transformer ) throws TransformerException { } public void execute ( TransformerImpl transformer ) throws TransformerException { } public StylesheetComposed getStylesheetComposed ( ) { return m_parentNode . getStylesheetComposed ( ) ; } public Stylesheet getStylesheet ( ) { return ( null == m_parentNode ) ? null : m_parentNode . getStylesheet ( ) ; } public StylesheetRoot getStylesheetRoot ( ) { return m_parentNode . getStylesheetRoot ( ) ; } public void recompose ( StylesheetRoot root ) throws TransformerException { } public void compose ( StylesheetRoot sroot ) throws TransformerException { resolvePrefixTables ( ) ; ElemTemplateElement t = getFirstChildElem ( ) ; m_hasTextLitOnly = ( ( t != null ) && ( t . getXSLToken ( ) == Constants . ELEMNAME_TEXTLITERALRESULT ) && ( t . getNextSiblingElem ( ) == null ) ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; cstate . pushStackMark ( ) ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; cstate . popStackMark ( ) ; } protected boolean isValidNCName ( String s ) { int len = s . length ( ) ; char c = s . charAt ( 0 ) ; if ( ! ( Character . isLetter ( c ) || ( c == '_' ) ) ) return false ; if ( len > 0 ) { for ( int i = 1 ; i < len ; i ++ ) { c = s . charAt ( i ) ; if ( ! ( Character . isLetterOrDigit ( c ) || ( c == '_' ) || ( c == '-' ) || ( c == '.' ) ) ) return false ; } } return true ; } public void error ( int msg , Object [ ] args ) { String themsg = XSLMessages . createMessage ( msg , args ) ; error ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEMTEMPLATEELEM_ERR , new Object [ ] { themsg } ) ) ; } public void error ( int msg ) { error ( msg , null ) ; } public void error ( String msg ) { throw new RuntimeException ( msg ) ; } public Node appendChild ( Node newChild ) throws DOMException { if ( null == newChild ) { error ( XSLTErrorResources . ER_NULL_CHILD , null ) ; } ElemTemplateElement elem = ( ElemTemplateElement ) newChild ; if ( null == m_firstChild ) { m_firstChild = elem ; } else { ElemTemplateElement last = ( ElemTemplateElement ) getLastChild ( ) ; last . m_nextSibling = elem ; } elem . m_parentNode = this ; return newChild ; } public ElemTemplateElement appendChild ( ElemTemplateElement elem ) { if ( null == elem ) { error ( XSLTErrorResources . ER_NULL_CHILD , null ) ; } if ( null == m_firstChild ) { m_firstChild = elem ; } else { ElemTemplateElement last = getLastChildElem ( ) ; last . m_nextSibling = elem ; } elem . setParentElem ( this ) ; return elem ; } public boolean hasChildNodes ( ) { return ( null != m_firstChild ) ; } public short getNodeType ( ) { return org . w3c . dom . Node . ELEMENT_NODE ; } public NodeList getChildNodes ( ) { return this ; } public ElemTemplateElement removeChild ( ElemTemplateElement childETE ) { if ( childETE == null || childETE . m_parentNode != this ) return null ; if ( childETE == m_firstChild ) m_firstChild = childETE . m_nextSibling ; else { ElemTemplateElement prev = childETE . getPreviousSiblingElem ( ) ; prev . m_nextSibling = childETE . m_nextSibling ; } childETE . m_parentNode = null ; childETE . m_nextSibling = null ; return childETE ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { if ( oldChild == null || oldChild . getParentNode ( ) != this ) return null ; ElemTemplateElement newChildElem = ( ( ElemTemplateElement ) newChild ) ; ElemTemplateElement oldChildElem = ( ( ElemTemplateElement ) oldChild ) ; ElemTemplateElement prev = ( ElemTemplateElement ) oldChildElem . getPreviousSibling ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { if ( null == refChild ) { appendChild ( newChild ) ; return newChild ; } if ( newChild == refChild ) { return newChild ; } Node node = m_firstChild ; Node prev = null ; boolean foundit = false ; while ( null != node ) { if ( newChild == node ) { if ( null != prev ) ( ( ElemTemplateElement ) prev ) . m_nextSibling = ( ElemTemplateElement ) node . getNextSibling ( ) ; else m_firstChild = ( ElemTemplateElement ) node . getNextSibling ( ) ; node = node . getNextSibling ( ) ; continue ; } if ( refChild == node ) { if ( null != prev ) { ( ( ElemTemplateElement ) prev ) . m_nextSibling = ( ElemTemplateElement ) newChild ; } else { m_firstChild = ( ElemTemplateElement ) newChild ; } ( ( ElemTemplateElement ) newChild ) . m_nextSibling = ( ElemTemplateElement ) refChild ; ( ( ElemTemplateElement ) newChild ) . setParentElem ( this ) ; prev = newChild ; node = node . getNextSibling ( ) ; foundit = true ; continue ; } prev = node ; node = node . getNextSibling ( ) ; } if ( ! foundit ) throw new DOMException ( DOMException . NOT_FOUND_ERR , "refChild was not found in insertBefore method!" ) ; else return newChild ; } public ElemTemplateElement replaceChild ( ElemTemplateElement newChildElem , ElemTemplateElement oldChildElem ) { if ( oldChildElem == null || oldChildElem . getParentElem ( ) != this ) return null ; ElemTemplateElement prev = oldChildElem . getPreviousSiblingElem ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; } public int getLength ( ) { int count = 0 ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { count ++ ; } return count ; } public Node item ( int index ) { ElemTemplateElement node = m_firstChild ; for ( int i = 0 ; i < index && node != null ; i ++ ) { node = node . m_nextSibling ; } return node ; } public Document getOwnerDocument ( ) { return getStylesheet ( ) ; } public ElemTemplate getOwnerXSLTemplate ( ) { ElemTemplateElement el = this ; int type = el . getXSLToken ( ) ; while ( ( null != el ) && ( type != Constants . ELEMNAME_TEMPLATE ) ) { el = el . getParentElem ( ) ; if ( null != el ) type = el . getXSLToken ( ) ; } return ( ElemTemplate ) el ; } public String getTagName ( ) { return getNodeName ( ) ; } public boolean hasTextLitOnly ( ) { return m_hasTextLitOnly ; } public String getBaseIdentifier ( ) { return this . getSystemId ( ) ; } private int m_lineNumber ; public int getLineNumber ( ) { return m_lineNumber ; } private int m_columnNumber ; public int getColumnNumber ( ) { return m_columnNumber ; } public String getPublicId ( ) { return ( null != m_parentNode ) ? m_parentNode . getPublicId ( ) : null ; } public String getSystemId ( ) { Stylesheet sheet = getStylesheet ( ) ; return ( sheet == null ) ? null : sheet . getHref ( ) ; } public void setLocaterInfo ( SourceLocator locator ) { m_lineNumber = locator . getLineNumber ( ) ; m_columnNumber = locator . getColumnNumber ( ) ; } private boolean m_defaultSpace = true ; private boolean m_hasTextLitOnly = false ; protected boolean m_hasVariableDecl = false ; public boolean hasVariableDecl ( ) { return m_hasVariableDecl ; } public void setXmlSpace ( int v ) { m_defaultSpace = ( ( Constants . ATTRVAL_STRIP == v ) ? true : false ) ; } public boolean getXmlSpace ( ) { return m_defaultSpace ; } private Vector m_declaredPrefixes ; public Vector getDeclaredPrefixes ( ) { return m_declaredPrefixes ; } public void setPrefixes ( NamespaceSupport nsSupport ) throws TransformerException { setPrefixes ( nsSupport , false ) ; } public void setPrefixes ( NamespaceSupport nsSupport , boolean excludeXSLDecl ) throws TransformerException { Enumeration decls = nsSupport . getDeclaredPrefixes ( ) ; while ( decls . hasMoreElements ( ) ) { String prefix = ( String ) decls . nextElement ( ) ; if ( null == m_declaredPrefixes ) m_declaredPrefixes = new Vector ( ) ; String uri = nsSupport . getURI ( prefix ) ; if ( excludeXSLDecl && uri . equals ( Constants . S_XSLNAMESPACEURL ) ) continue ; XMLNSDecl decl = new XMLNSDecl ( prefix , uri , false ) ; m_declaredPrefixes . addElement ( decl ) ; } } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) { this . error ( XSLTErrorResources . ER_CANT_RESOLVE_NSPREFIX , null ) ; return null ; } public String getNamespaceForPrefix ( String prefix ) { Vector nsDecls = m_declaredPrefixes ; if ( null != nsDecls ) { int n = nsDecls . size ( ) ; if ( prefix . equals ( Constants . ATTRVAL_DEFAULT_PREFIX ) ) { prefix = "" ; } for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) nsDecls . elementAt ( i ) ; if ( prefix . equals ( decl . getPrefix ( ) ) ) return decl . getURI ( ) ; } } if ( null != m_parentNode ) return m_parentNode . getNamespaceForPrefix ( prefix ) ; if ( "xml" . equals ( prefix ) ) return "http://www.w3.org/XML/1998/namespace" ; return null ; } Vector m_prefixTable ; public Vector getPrefixes ( ) { return m_prefixTable ; } public boolean containsExcludeResultPrefix ( String prefix , String uri ) { ElemTemplateElement parent = this . getParentElem ( ) ; if ( null != parent ) return parent . containsExcludeResultPrefix ( prefix , uri ) ; return false ; } private boolean excludeResultNSDecl ( String prefix , String uri ) throws TransformerException { if ( uri != null ) { if ( uri . equals ( Constants . S_XSLNAMESPACEURL ) || getStylesheet ( ) . containsExtensionElementURI ( uri ) || uri . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) ) return true ; if ( containsExcludeResultPrefix ( prefix , uri ) ) return true ; } return false ; } public void resolvePrefixTables ( ) throws TransformerException { m_prefixTable = null ; if ( null != this . m_declaredPrefixes ) { StylesheetRoot stylesheet = this . getStylesheetRoot ( ) ; int n = m_declaredPrefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) m_declaredPrefixes . elementAt ( i ) ; String prefix = decl . getPrefix ( ) ; String uri = decl . getURI ( ) ; if ( null == uri ) uri = "" ; boolean shouldExclude = excludeResultNSDecl ( prefix , uri ) ; if ( null == m_prefixTable ) m_prefixTable = new Vector ( ) ; NamespaceAlias nsAlias = stylesheet . getNamespaceAliasComposed ( uri ) ; if ( null != nsAlias ) { decl = new XMLNSDecl ( nsAlias . getStylesheetPrefix ( ) , nsAlias . getResultNamespace ( ) , shouldExclude ) ; } else decl = new XMLNSDecl ( prefix , uri , shouldExclude ) ; m_prefixTable . addElement ( decl ) ; } } ElemTemplateElement parent = this . getParentNodeElem ( ) ; if ( null != parent ) { Vector prefixes = parent . m_prefixTable ; if ( null == m_prefixTable && ! needToCheckExclude ( ) ) { this . m_prefixTable = parent . m_prefixTable ; } else { int n = prefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) prefixes . elementAt ( i ) ; boolean shouldExclude = excludeResultNSDecl ( decl . getPrefix ( ) , decl . getURI ( ) ) ; if ( shouldExclude != decl . getIsExcluded ( ) ) { decl = new XMLNSDecl ( decl . getPrefix ( ) , decl . getURI ( ) , shouldExclude ) ; } addOrReplaceDecls ( decl ) ; } } } else if ( null == m_prefixTable ) { m_prefixTable = new Vector ( ) ; } } void addOrReplaceDecls ( XMLNSDecl newDecl ) { int n = m_prefixTable . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( decl . getPrefix ( ) . equals ( newDecl . getPrefix ( ) ) ) { return ; } } m_prefixTable . addElement ( newDecl ) ; } boolean needToCheckExclude ( ) { return false ; } void executeNSDecls ( TransformerImpl transformer ) throws TransformerException { try { if ( null != m_prefixTable ) { ResultTreeHandler rhandler = transformer . getResultTreeHandler ( ) ; int n = m_prefixTable . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( ! decl . getIsExcluded ( ) ) { rhandler . startPrefixMapping ( decl . getPrefix ( ) , decl . getURI ( ) , true ) ; } } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } void unexecuteNSDecls ( TransformerImpl transformer ) throws TransformerException { try { if ( null != m_prefixTable ) { ResultTreeHandler rhandler = transformer . getResultTreeHandler ( ) ; int n = m_prefixTable . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( ! decl . getIsExcluded ( ) ) { rhandler . endPrefixMapping ( decl . getPrefix ( ) ) ; } } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } protected int m_docOrderNumber = - 1 ; public void setUid ( int i ) { m_docOrderNumber = i ; } public int getUid ( ) { return m_docOrderNumber ; } protected ElemTemplateElement m_parentNode ; public Node getParentNode ( ) { return m_parentNode ; } public ElemTemplateElement getParentElem ( ) { return m_parentNode ; } public void setParentElem ( ElemTemplateElement p ) { m_parentNode = p ; } ElemTemplateElement m_nextSibling ; public Node getNextSibling ( ) { return m_nextSibling ; } public Node getPreviousSibling ( ) { Node walker = getParentNode ( ) , prev = null ; if ( walker != null ) for ( walker = walker . getFirstChild ( ) ; walker != null ; prev = walker , walker = walker . getNextSibling ( ) ) { if ( walker == this ) return prev ; } return null ; } public ElemTemplateElement getPreviousSiblingElem ( ) { ElemTemplateElement walker = getParentNodeElem ( ) ; ElemTemplateElement prev = null ; if ( walker != null ) for ( walker = walker . getFirstChildElem ( ) ; walker != null ; prev = walker , walker = walker . getNextSiblingElem ( ) ) { if ( walker == this ) return prev ; } return null ; } public ElemTemplateElement getNextSiblingElem ( ) { return m_nextSibling ; } public ElemTemplateElement getParentNodeElem ( ) { return m_parentNode ; } ElemTemplateElement m_firstChild ; public Node getFirstChild ( ) { return m_firstChild ; } public ElemTemplateElement getFirstChildElem ( ) { return m_firstChild ; } public Node getLastChild ( ) { ElemTemplateElement lastChild = null ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { lastChild = node ; } return lastChild ; } public ElemTemplateElement getLastChildElem ( ) { ElemTemplateElement lastChild = null ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { lastChild = node ; } return lastChild ; } transient private org . w3c . dom . Node m_DOMBackPointer ; public org . w3c . dom . Node getDOMBackPointer ( ) { return m_DOMBackPointer ; } public void setDOMBackPointer ( org . w3c . dom . Node n ) { m_DOMBackPointer = n ; } public int compareTo ( Object o ) throws ClassCastException { ElemTemplateElement ro = ( ElemTemplateElement ) o ; int roPrecedence = ro . getStylesheetComposed ( ) . getImportCountComposed ( ) ; int myPrecedence = this . getStylesheetComposed ( ) . getImportCountComposed ( ) ; if ( myPrecedence < roPrecedence ) return - 1 ; else if ( myPrecedence > roPrecedence ) return 1 ; else return this . getUid ( ) - ro . getUid ( ) ; } public boolean shouldStripWhiteSpace ( org . apache . xpath . XPathContext support , org . w3c . dom . Element targetElement ) throws TransformerException { StylesheetRoot sroot = this . getStylesheetRoot ( ) ; return ( null != sroot ) ? sroot . shouldStripWhiteSpace ( support , targetElement ) : false ; } public boolean canStripWhiteSpace ( ) { StylesheetRoot sroot = this . getStylesheetRoot ( ) ; return ( null != sroot ) ? sroot . canStripWhiteSpace ( ) : false ; } public boolean canAcceptVariables ( ) { return true ; } public void exprSetParent ( ExpressionNode n ) { setParentElem ( ( ElemTemplateElement ) n ) ; } public ExpressionNode exprGetParent ( ) { return getParentElem ( ) ; } public void exprAddChild ( ExpressionNode n , int i ) { appendChild ( ( ElemTemplateElement ) n ) ; } public ExpressionNode exprGetChild ( int i ) { return ( ExpressionNode ) item ( i ) ; } public int exprGetNumChildren ( ) { return getLength ( ) ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitInstruction ( this ) ; } public void callVisitors ( XSLTVisitor visitor ) { if ( accept ( visitor ) ) { callChildVisitors ( visitor ) ; } } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttributes ) { for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { node . callVisitors ( visitor ) ; } } protected void callChildVisitors ( XSLTVisitor visitor ) { callChildVisitors ( visitor , true ) ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1	['84', '2', '29', '101', '125', '3056', '91', '17', '75', '0.913654618', '1279', '0.75', '3', '0.567708333', '0.090336134', '1', '12', '14.08333333', '9', '1.5595', '1']
package org . apache . xalan . xsltc . trax ; import javax . xml . transform . * ; import javax . xml . transform . sax . * ; import javax . xml . transform . dom . * ; import javax . xml . transform . stream . * ; import org . xml . sax . XMLFilter ; import org . xml . sax . InputSource ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . SourceLoader ; public class SmartTransformerFactoryImpl extends SAXTransformerFactory { private TransformerFactory _xsltcFactory = null ; private TransformerFactory _xalanFactory = null ; private TransformerFactory _currFactory = null ; private ErrorListener _errorlistener = null ; private URIResolver _uriresolver = null ; public SmartTransformerFactoryImpl ( ) { } private void createXSLTCTransformerFactory ( ) { final String xsltcMessage = "org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl " + "could not create an " + "org.apache.xalan.xsltc.trax.TransformerFactoryImpl." ; try { Class xsltcFactClass = Class . forName ( "org.apache.xalan.xsltc.trax.TransformerFactoryImpl" ) ; _xsltcFactory = ( org . apache . xalan . xsltc . trax . TransformerFactoryImpl ) xsltcFactClass . newInstance ( ) ; } catch ( ClassNotFoundException e ) { System . err . println ( xsltcMessage ) ; } catch ( InstantiationException e ) { System . err . println ( xsltcMessage ) ; } catch ( IllegalAccessException e ) { System . err . println ( xsltcMessage ) ; } _currFactory = _xsltcFactory ; } private void createXalanTransformerFactory ( ) { final String xalanMessage = "org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl " + "could not create an " + "org.apache.xalan.processor.TransformerFactoryImpl." ; try { Class xalanFactClass = Class . forName ( "org.apache.xalan.processor.TransformerFactoryImpl" ) ; _xalanFactory = ( org . apache . xalan . processor . TransformerFactoryImpl ) xalanFactClass . newInstance ( ) ; } catch ( ClassNotFoundException e ) { System . err . println ( xalanMessage ) ; } catch ( InstantiationException e ) { System . err . println ( xalanMessage ) ; } catch ( IllegalAccessException e ) { System . err . println ( xalanMessage ) ; } _currFactory = _xalanFactory ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { _errorlistener = listener ; } public ErrorListener getErrorListener ( ) { return _errorlistener ; } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( ( name . equals ( "translet-name" ) ) || ( name . equals ( "debug" ) ) ) { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } return _xsltcFactory . getAttribute ( name ) ; } else { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } return _xalanFactory . getAttribute ( name ) ; } } public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( ( name . equals ( "translet-name" ) ) || ( name . equals ( "debug" ) ) ) { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } _xsltcFactory . setAttribute ( name , value ) ; } else { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } _xalanFactory . setAttribute ( name , value ) ; } } public boolean getFeature ( String name ) { String [ ] features = { DOMSource . FEATURE , DOMResult . FEATURE , SAXSource . FEATURE , SAXResult . FEATURE , StreamSource . FEATURE , StreamResult . FEATURE } ; for ( int i = 0 ; i < features . length ; i ++ ) { if ( name . equals ( features [ i ] ) ) return true ; } return false ; } public URIResolver getURIResolver ( ) { return _uriresolver ; } public void setURIResolver ( URIResolver resolver ) { _uriresolver = resolver ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { if ( _currFactory == null ) { createXSLTCTransformerFactory ( ) ; } return _currFactory . getAssociatedStylesheet ( source , media , title , charset ) ; } public Transformer newTransformer ( ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } _currFactory = _xalanFactory ; return _currFactory . newTransformer ( ) ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } _currFactory = _xalanFactory ; return _currFactory . newTransformer ( source ) ; } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } _currFactory = _xsltcFactory ; return _currFactory . newTemplates ( source ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } return ( ( SAXTransformerFactory ) _xsltcFactory ) . newTemplatesHandler ( ) ; } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } return ( ( SAXTransformerFactory ) _xalanFactory ) . newTransformerHandler ( ) ; } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } return ( ( SAXTransformerFactory ) _xalanFactory ) . newTransformerHandler ( src ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } return ( ( SAXTransformerFactory ) _xsltcFactory ) . newTransformerHandler ( templates ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } Templates templates = _xsltcFactory . newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new org . apache . xalan . xsltc . trax . TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException e1 ) { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } ErrorListener errorListener = _xsltcFactory . getErrorListener ( ) ; if ( errorListener != null ) { try { errorListener . fatalError ( e1 ) ; return null ; } catch ( TransformerException e2 ) { new TransformerConfigurationException ( e2 ) ; } } throw e1 ; } } } 	0	['21', '3', '0', '3', '43', '0', '0', '3', '19', '0.5', '498', '1', '0', '0.5', '0.220238095', '1', '2', '22.47619048', '3', '1.0476', '0']
package org . apache . xml . utils ; import java . util . EmptyStackException ; public class IntStack extends IntVector { public IntStack ( ) { super ( ) ; } public IntStack ( int blocksize ) { super ( blocksize ) ; } public int push ( int i ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = i ; m_firstFree ++ ; return i ; } public int pop ( ) { return m_map [ -- m_firstFree ] ; } public void quickPop ( int n ) { m_firstFree -= n ; } public int peek ( ) { try { return m_map [ m_firstFree - 1 ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public int peek ( int n ) { try { return m_map [ m_firstFree - ( 1 + n ) ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public void setTop ( int val ) { try { m_map [ m_firstFree - 1 ] = val ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public boolean empty ( ) { return m_firstFree == 0 ; } public int search ( int o ) { int i = lastIndexOf ( o ) ; if ( i >= 0 ) { return size ( ) - i ; } return - 1 ; } } 	1	['10', '2', '0', '6', '16', '45', '5', '1', '10', '2', '143', '0', '0', '0.666666667', '0.8', '1', '14', '13.3', '2', '1.1', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class BooleanExpr extends Expression { private boolean _value ; public BooleanExpr ( boolean value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _type = Type . Boolean ; return _type ; } public String toString ( ) { return _value ? "true()" : "false()" ; } public boolean getValue ( ) { return _value ; } public boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( _value ) { il . append ( NOP ) ; } else { _falseList . add ( il . append ( new GOTO ( null ) ) ) ; } } } 	0	['7', '3', '0', '20', '16', '1', '1', '19', '7', '0.333333333', '70', '1', '0', '0.922077922', '0.371428571', '2', '8', '8.857142857', '2', '1.1429', '0']
package org . apache . xalan . xsltc . compiler ; import java . io . * ; import java . net . URL ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Stack ; import java . net . MalformedURLException ; import javax . xml . parsers . * ; import org . w3c . dom . * ; import org . xml . sax . * ; import java_cup . runtime . Symbol ; import org . apache . xalan . xsltc . compiler . util . * ; import org . apache . xalan . xsltc . runtime . AttributeList ; public class Parser implements Constants , ContentHandler { private static final String XSL = "xsl" ; private static final String TRANSLET = "translet" ; private Locator _locator = null ; private XSLTC _xsltc ; private XPathParser _xpathParser ; private Vector _errors ; private Vector _warnings ; private Hashtable _instructionClasses ; private Hashtable _instructionAttrs ; ; private Hashtable _qNames ; private Hashtable _namespaces ; private QName _useAttributeSets ; private QName _excludeResultPrefixes ; private QName _extensionElementPrefixes ; private Hashtable _variableScope ; private Stylesheet _currentStylesheet ; private SymbolTable _symbolTable ; private Output _output = null ; private Template _template ; private boolean _rootNamespaceDef = false ; private SyntaxTreeNode _root = null ; private String _target ; private int _currentImportPrecedence = 1 ; public Parser ( XSLTC xsltc ) { _xsltc = xsltc ; } public void init ( ) { _qNames = new Hashtable ( 512 ) ; _namespaces = new Hashtable ( ) ; _instructionClasses = new Hashtable ( ) ; _instructionAttrs = new Hashtable ( ) ; _variableScope = new Hashtable ( ) ; _template = null ; _errors = new Vector ( ) ; _warnings = new Vector ( ) ; _symbolTable = new SymbolTable ( ) ; _xpathParser = new XPathParser ( this ) ; _currentStylesheet = null ; _currentImportPrecedence = 1 ; initStdClasses ( ) ; initInstructionAttrs ( ) ; initExtClasses ( ) ; initSymbolTable ( ) ; _useAttributeSets = getQName ( XSLT_URI , XSL , "use-attribute-sets" ) ; _excludeResultPrefixes = getQName ( XSLT_URI , XSL , "exclude-result-prefixes" ) ; _extensionElementPrefixes = getQName ( XSLT_URI , XSL , "extension-element-prefixes" ) ; } public void setOutput ( Output output ) { if ( _output != null ) { if ( _output . getImportPrecedence ( ) <= output . getImportPrecedence ( ) ) { _output . disable ( ) ; _output = output ; } else { output . disable ( ) ; } } else { _output = output ; } } public Output getOutput ( ) { return _output ; } public Properties getOutputProperties ( ) { return getTopLevelStylesheet ( ) . getOutputProperties ( ) ; } public void addVariable ( Variable var ) { addVariableOrParam ( var ) ; } public void addParameter ( Param param ) { addVariableOrParam ( param ) ; } private void addVariableOrParam ( VariableBase var ) { Object existing = _variableScope . get ( var . getName ( ) ) ; if ( existing != null ) { if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; stack . push ( var ) ; } else if ( existing instanceof VariableBase ) { Stack stack = new Stack ( ) ; stack . push ( existing ) ; stack . push ( var ) ; _variableScope . put ( var . getName ( ) , stack ) ; } } else { _variableScope . put ( var . getName ( ) , var ) ; } } public void removeVariable ( QName name ) { Object existing = _variableScope . get ( name ) ; if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; if ( ! stack . isEmpty ( ) ) stack . pop ( ) ; if ( ! stack . isEmpty ( ) ) return ; } _variableScope . remove ( name ) ; } public VariableBase lookupVariable ( QName name ) { Object existing = _variableScope . get ( name ) ; if ( existing instanceof VariableBase ) { return ( ( VariableBase ) existing ) ; } else if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; return ( ( VariableBase ) stack . peek ( ) ) ; } return ( null ) ; } public void setXSLTC ( XSLTC xsltc ) { _xsltc = xsltc ; } public XSLTC getXSLTC ( ) { return _xsltc ; } public int getCurrentImportPrecedence ( ) { return _currentImportPrecedence ; } public int getNextImportPrecedence ( ) { return ++ _currentImportPrecedence ; } public void setCurrentStylesheet ( Stylesheet stylesheet ) { _currentStylesheet = stylesheet ; } public Stylesheet getCurrentStylesheet ( ) { return _currentStylesheet ; } public Stylesheet getTopLevelStylesheet ( ) { return _xsltc . getStylesheet ( ) ; } public QName getQNameSafe ( final String stringRep ) { final int colon = stringRep . lastIndexOf ( ':' ) ; if ( colon != - 1 ) { final String prefix = stringRep . substring ( 0 , colon ) ; final String localname = stringRep . substring ( colon + 1 ) ; String namespace = null ; if ( prefix . equals ( XMLNS_PREFIX ) == false ) { namespace = _symbolTable . lookupNamespace ( prefix ) ; if ( namespace == null ) namespace = EMPTYSTRING ; } return getQName ( namespace , prefix , localname ) ; } else { final String uri = stringRep . equals ( XMLNS_PREFIX ) ? null : _symbolTable . lookupNamespace ( EMPTYSTRING ) ; return getQName ( uri , null , stringRep ) ; } } public QName getQName ( final String stringRep ) { return getQName ( stringRep , true , false ) ; } public QName getQNameIgnoreDefaultNs ( final String stringRep ) { return getQName ( stringRep , true , true ) ; } public QName getQName ( final String stringRep , boolean reportError ) { return getQName ( stringRep , reportError , false ) ; } private QName getQName ( final String stringRep , boolean reportError , boolean ignoreDefaultNs ) { final int colon = stringRep . lastIndexOf ( ':' ) ; if ( colon != - 1 ) { final String prefix = stringRep . substring ( 0 , colon ) ; final String localname = stringRep . substring ( colon + 1 ) ; String namespace = null ; if ( prefix . equals ( XMLNS_PREFIX ) == false ) { namespace = _symbolTable . lookupNamespace ( prefix ) ; if ( namespace == null && reportError ) { final int line = _locator . getLineNumber ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . NAMESPACE_UNDEF_ERR , line , prefix ) ; reportError ( ERROR , err ) ; } } return getQName ( namespace , prefix , localname ) ; } else { if ( stringRep . equals ( XMLNS_PREFIX ) ) { ignoreDefaultNs = true ; } final String defURI = ignoreDefaultNs ? null : _symbolTable . lookupNamespace ( EMPTYSTRING ) ; return getQName ( defURI , null , stringRep ) ; } } public QName getQName ( String namespace , String prefix , String localname ) { if ( namespace == null || namespace . equals ( EMPTYSTRING ) ) { QName name = ( QName ) _qNames . get ( localname ) ; if ( name == null ) { name = new QName ( null , prefix , localname ) ; _qNames . put ( localname , name ) ; } return name ; } else { Dictionary space = ( Dictionary ) _namespaces . get ( namespace ) ; if ( space == null ) { final QName name = new QName ( namespace , prefix , localname ) ; _namespaces . put ( namespace , space = new Hashtable ( ) ) ; space . put ( localname , name ) ; return name ; } else { QName name = ( QName ) space . get ( localname ) ; if ( name == null ) { name = new QName ( namespace , prefix , localname ) ; space . put ( localname , name ) ; } return name ; } } } public QName getQName ( String scope , String name ) { return getQName ( scope + name ) ; } public QName getQName ( QName scope , QName name ) { return getQName ( scope . toString ( ) + name . toString ( ) ) ; } public QName getUseAttributeSets ( ) { return _useAttributeSets ; } public QName getExtensionElementPrefixes ( ) { return _extensionElementPrefixes ; } public QName getExcludeResultPrefixes ( ) { return _excludeResultPrefixes ; } public Stylesheet makeStylesheet ( SyntaxTreeNode element ) throws CompilerException { try { Stylesheet stylesheet ; if ( element instanceof Stylesheet ) { stylesheet = ( Stylesheet ) element ; } else { stylesheet = new Stylesheet ( ) ; stylesheet . setSimplified ( ) ; stylesheet . addElement ( element ) ; stylesheet . setAttributes ( element . getAttributes ( ) ) ; if ( element . lookupNamespace ( EMPTYSTRING ) == null ) { element . addPrefixMapping ( EMPTYSTRING , EMPTYSTRING ) ; } } stylesheet . setParser ( this ) ; return stylesheet ; } catch ( ClassCastException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NOT_STYLESHEET_ERR , element ) ; throw new CompilerException ( err . toString ( ) ) ; } } public void createAST ( Stylesheet stylesheet ) { try { if ( stylesheet != null ) { stylesheet . parseContents ( this ) ; final int precedence = stylesheet . getImportPrecedence ( ) ; final Enumeration elements = stylesheet . elements ( ) ; while ( elements . hasMoreElements ( ) ) { Object child = elements . nextElement ( ) ; if ( child instanceof Text ) { final int l = _locator . getLineNumber ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_TEXT_NODE_ERR , l , null ) ; reportError ( ERROR , err ) ; } } if ( ! errorsFound ( ) ) { stylesheet . typeCheck ( _symbolTable ) ; } } } catch ( TypeCheckError e ) { reportError ( ERROR , new ErrorMsg ( e . toString ( ) ) ) ; } } public SyntaxTreeNode parse ( XMLReader reader , InputSource input ) { try { reader . setContentHandler ( this ) ; reader . parse ( input ) ; return ( SyntaxTreeNode ) getStylesheet ( _root ) ; } catch ( IOException e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) ) ) ; } catch ( SAXException e ) { Throwable ex = e . getException ( ) ; if ( _xsltc . debug ( ) ) { e . printStackTrace ( ) ; if ( ex != null ) ex . printStackTrace ( ) ; } reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) ) ) ; } catch ( CompilerException e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) ) ) ; } catch ( Exception e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) ) ) ; } return null ; } public SyntaxTreeNode parse ( InputSource input ) { try { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { factory . setFeature ( Constants . NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { factory . setNamespaceAware ( true ) ; } final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; return ( parse ( reader , input ) ) ; } catch ( ParserConfigurationException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . SAX_PARSER_CONFIG_ERR ) ; reportError ( ERROR , err ) ; } catch ( SAXParseException e ) { reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) , e . getLineNumber ( ) ) ) ; } catch ( SAXException e ) { reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) ) ) ; } return null ; } public SyntaxTreeNode getDocumentRoot ( ) { return _root ; } private String _PImedia = null ; private String _PItitle = null ; private String _PIcharset = null ; protected void setPIParameters ( String media , String title , String charset ) { _PImedia = media ; _PItitle = title ; _PIcharset = charset ; } private SyntaxTreeNode getStylesheet ( SyntaxTreeNode root ) throws CompilerException { if ( _target == null ) { if ( ! _rootNamespaceDef ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . MISSING_XSLT_URI_ERR ) ; throw new CompilerException ( msg . toString ( ) ) ; } return ( root ) ; } if ( _target . charAt ( 0 ) == '#' ) { SyntaxTreeNode element = findStylesheet ( root , _target . substring ( 1 ) ) ; if ( element == null ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . MISSING_XSLT_TARGET_ERR , _target , root ) ; throw new CompilerException ( msg . toString ( ) ) ; } return ( element ) ; } else { return ( loadExternalStylesheet ( _target ) ) ; } } private SyntaxTreeNode findStylesheet ( SyntaxTreeNode root , String href ) { if ( root == null ) return null ; if ( root instanceof Stylesheet ) { String id = root . getAttribute ( "id" ) ; if ( id . equals ( href ) ) return root ; } Vector children = root . getContents ( ) ; if ( children != null ) { final int count = children . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) children . elementAt ( i ) ; SyntaxTreeNode node = findStylesheet ( child , href ) ; if ( node != null ) return node ; } } return null ; } private SyntaxTreeNode loadExternalStylesheet ( String location ) throws CompilerException { InputSource source ; if ( ( new File ( location ) ) . exists ( ) ) source = new InputSource ( "file:" + location ) ; else source = new InputSource ( location ) ; SyntaxTreeNode external = ( SyntaxTreeNode ) parse ( source ) ; return ( external ) ; } private void initAttrTable ( String elementName , String [ ] attrs ) { _instructionAttrs . put ( getQName ( XSLT_URI , XSL , elementName ) , attrs ) ; } private void initInstructionAttrs ( ) { initAttrTable ( "template" , new String [ ] { "match" , "name" , "priority" , "mode" } ) ; initAttrTable ( "stylesheet" , new String [ ] { "id" , "version" , "extension-element-prefixes" , "exclude-result-prefixes" } ) ; initAttrTable ( "transform" , new String [ ] { "id" , "version" , "extension-element-prefixes" , "exclude-result-prefixes" } ) ; initAttrTable ( "text" , new String [ ] { "disable-output-escaping" } ) ; initAttrTable ( "if" , new String [ ] { "test" } ) ; initAttrTable ( "choose" , new String [ ] { } ) ; initAttrTable ( "when" , new String [ ] { "test" } ) ; initAttrTable ( "otherwise" , new String [ ] { } ) ; initAttrTable ( "for-each" , new String [ ] { "select" } ) ; initAttrTable ( "message" , new String [ ] { "terminate" } ) ; initAttrTable ( "number" , new String [ ] { "level" , "count" , "from" , "value" , "format" , "lang" , "letter-value" , "grouping-separator" , "grouping-size" } ) ; initAttrTable ( "comment" , new String [ ] { } ) ; initAttrTable ( "copy" , new String [ ] { "use-attribute-sets" } ) ; initAttrTable ( "copy-of" , new String [ ] { "select" } ) ; initAttrTable ( "param" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "with-param" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "variable" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "output" , new String [ ] { "method" , "version" , "encoding" , "omit-xml-declaration" , "standalone" , "doctype-public" , "doctype-system" , "cdata-section-elements" , "indent" , "media-type" } ) ; initAttrTable ( "sort" , new String [ ] { "select" , "order" , "case-order" , "lang" , "data-type" } ) ; initAttrTable ( "key" , new String [ ] { "name" , "match" , "use" } ) ; initAttrTable ( "fallback" , new String [ ] { } ) ; initAttrTable ( "attribute" , new String [ ] { "name" , "namespace" } ) ; initAttrTable ( "attribute-set" , new String [ ] { "name" , "use-attribute-sets" } ) ; initAttrTable ( "value-of" , new String [ ] { "select" , "disable-output-escaping" } ) ; initAttrTable ( "element" , new String [ ] { "name" , "namespace" , "use-attribute-sets" } ) ; initAttrTable ( "call-template" , new String [ ] { "name" } ) ; initAttrTable ( "apply-templates" , new String [ ] { "select" , "mode" } ) ; initAttrTable ( "apply-imports" , new String [ ] { } ) ; initAttrTable ( "decimal-format" , new String [ ] { "name" , "decimal-separator" , "grouping-separator" , "infinity" , "minus-sign" , "NaN" , "percent" , "per-mille" , "zero-digit" , "digit" , "pattern-separator" } ) ; initAttrTable ( "import" , new String [ ] { "href" } ) ; initAttrTable ( "include" , new String [ ] { "href" } ) ; initAttrTable ( "strip-space" , new String [ ] { "elements" } ) ; initAttrTable ( "preserve-space" , new String [ ] { "elements" } ) ; initAttrTable ( "processing-instruction" , new String [ ] { "name" } ) ; initAttrTable ( "namespace-alias" , new String [ ] { "stylesheet-prefix" , "result-prefix" } ) ; } private void initStdClasses ( ) { initStdClass ( "template" , "Template" ) ; initStdClass ( "stylesheet" , "Stylesheet" ) ; initStdClass ( "transform" , "Stylesheet" ) ; initStdClass ( "text" , "Text" ) ; initStdClass ( "if" , "If" ) ; initStdClass ( "choose" , "Choose" ) ; initStdClass ( "when" , "When" ) ; initStdClass ( "otherwise" , "Otherwise" ) ; initStdClass ( "for-each" , "ForEach" ) ; initStdClass ( "message" , "Message" ) ; initStdClass ( "number" , "Number" ) ; initStdClass ( "comment" , "Comment" ) ; initStdClass ( "copy" , "Copy" ) ; initStdClass ( "copy-of" , "CopyOf" ) ; initStdClass ( "param" , "Param" ) ; initStdClass ( "with-param" , "WithParam" ) ; initStdClass ( "variable" , "Variable" ) ; initStdClass ( "output" , "Output" ) ; initStdClass ( "sort" , "Sort" ) ; initStdClass ( "key" , "Key" ) ; initStdClass ( "fallback" , "Fallback" ) ; initStdClass ( "attribute" , "XslAttribute" ) ; initStdClass ( "attribute-set" , "AttributeSet" ) ; initStdClass ( "value-of" , "ValueOf" ) ; initStdClass ( "element" , "XslElement" ) ; initStdClass ( "call-template" , "CallTemplate" ) ; initStdClass ( "apply-templates" , "ApplyTemplates" ) ; initStdClass ( "apply-imports" , "ApplyImports" ) ; initStdClass ( "decimal-format" , "DecimalFormatting" ) ; initStdClass ( "import" , "Import" ) ; initStdClass ( "include" , "Include" ) ; initStdClass ( "strip-space" , "Whitespace" ) ; initStdClass ( "preserve-space" , "Whitespace" ) ; initStdClass ( "processing-instruction" , "ProcessingInstruction" ) ; initStdClass ( "namespace-alias" , "NamespaceAlias" ) ; } private void initStdClass ( String elementName , String className ) { _instructionClasses . put ( getQName ( XSLT_URI , XSL , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } public boolean elementSupported ( String namespace , String localName ) { return ( _instructionClasses . get ( getQName ( namespace , XSL , localName ) ) != null ) ; } public boolean functionSupported ( String fname ) { return ( _symbolTable . lookupPrimop ( fname ) != null ) ; } private void initExtClasses ( ) { initExtClass ( "output" , "TransletOutput" ) ; } private void initExtClass ( String elementName , String className ) { _instructionClasses . put ( getQName ( TRANSLET_URI , TRANSLET , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } private void initSymbolTable ( ) { MethodType I_V = new MethodType ( Type . Int , Type . Void ) ; MethodType I_R = new MethodType ( Type . Int , Type . Real ) ; MethodType I_S = new MethodType ( Type . Int , Type . String ) ; MethodType I_D = new MethodType ( Type . Int , Type . NodeSet ) ; MethodType R_I = new MethodType ( Type . Real , Type . Int ) ; MethodType R_V = new MethodType ( Type . Real , Type . Void ) ; MethodType R_R = new MethodType ( Type . Real , Type . Real ) ; MethodType R_D = new MethodType ( Type . Real , Type . NodeSet ) ; MethodType R_O = new MethodType ( Type . Real , Type . Reference ) ; MethodType I_I = new MethodType ( Type . Int , Type . Int ) ; MethodType D_O = new MethodType ( Type . NodeSet , Type . Reference ) ; MethodType D_V = new MethodType ( Type . NodeSet , Type . Void ) ; MethodType D_S = new MethodType ( Type . NodeSet , Type . String ) ; MethodType D_D = new MethodType ( Type . NodeSet , Type . NodeSet ) ; MethodType A_V = new MethodType ( Type . Node , Type . Void ) ; MethodType S_V = new MethodType ( Type . String , Type . Void ) ; MethodType S_S = new MethodType ( Type . String , Type . String ) ; MethodType S_A = new MethodType ( Type . String , Type . Node ) ; MethodType S_D = new MethodType ( Type . String , Type . NodeSet ) ; MethodType S_O = new MethodType ( Type . String , Type . Reference ) ; MethodType B_O = new MethodType ( Type . Boolean , Type . Reference ) ; MethodType B_V = new MethodType ( Type . Boolean , Type . Void ) ; MethodType B_B = new MethodType ( Type . Boolean , Type . Boolean ) ; MethodType B_S = new MethodType ( Type . Boolean , Type . String ) ; MethodType D_X = new MethodType ( Type . NodeSet , Type . Object ) ; MethodType R_RR = new MethodType ( Type . Real , Type . Real , Type . Real ) ; MethodType I_II = new MethodType ( Type . Int , Type . Int , Type . Int ) ; MethodType B_RR = new MethodType ( Type . Boolean , Type . Real , Type . Real ) ; MethodType B_II = new MethodType ( Type . Boolean , Type . Int , Type . Int ) ; MethodType S_SS = new MethodType ( Type . String , Type . String , Type . String ) ; MethodType S_DS = new MethodType ( Type . String , Type . Real , Type . String ) ; MethodType S_SR = new MethodType ( Type . String , Type . String , Type . Real ) ; MethodType D_SS = new MethodType ( Type . NodeSet , Type . String , Type . String ) ; MethodType D_SD = new MethodType ( Type . NodeSet , Type . String , Type . NodeSet ) ; MethodType B_BB = new MethodType ( Type . Boolean , Type . Boolean , Type . Boolean ) ; MethodType B_SS = new MethodType ( Type . Boolean , Type . String , Type . String ) ; MethodType S_SD = new MethodType ( Type . String , Type . String , Type . NodeSet ) ; MethodType S_DSS = new MethodType ( Type . String , Type . Real , Type . String , Type . String ) ; MethodType S_SRR = new MethodType ( Type . String , Type . String , Type . Real , Type . Real ) ; MethodType S_SSS = new MethodType ( Type . String , Type . String , Type . String , Type . String ) ; _symbolTable . addPrimop ( "current" , A_V ) ; _symbolTable . addPrimop ( "last" , I_V ) ; _symbolTable . addPrimop ( "position" , I_V ) ; _symbolTable . addPrimop ( "true" , B_V ) ; _symbolTable . addPrimop ( "false" , B_V ) ; _symbolTable . addPrimop ( "not" , B_B ) ; _symbolTable . addPrimop ( "name" , S_V ) ; _symbolTable . addPrimop ( "name" , S_A ) ; _symbolTable . addPrimop ( "generate-id" , S_V ) ; _symbolTable . addPrimop ( "generate-id" , S_A ) ; _symbolTable . addPrimop ( "ceiling" , R_R ) ; _symbolTable . addPrimop ( "floor" , R_R ) ; _symbolTable . addPrimop ( "round" , R_R ) ; _symbolTable . addPrimop ( "contains" , B_SS ) ; _symbolTable . addPrimop ( "number" , R_O ) ; _symbolTable . addPrimop ( "number" , R_V ) ; _symbolTable . addPrimop ( "boolean" , B_O ) ; _symbolTable . addPrimop ( "string" , S_O ) ; _symbolTable . addPrimop ( "string" , S_V ) ; _symbolTable . addPrimop ( "translate" , S_SSS ) ; _symbolTable . addPrimop ( "string-length" , I_V ) ; _symbolTable . addPrimop ( "string-length" , I_S ) ; _symbolTable . addPrimop ( "starts-with" , B_SS ) ; _symbolTable . addPrimop ( "format-number" , S_DS ) ; _symbolTable . addPrimop ( "format-number" , S_DSS ) ; _symbolTable . addPrimop ( "unparsed-entity-uri" , S_S ) ; _symbolTable . addPrimop ( "key" , D_SS ) ; _symbolTable . addPrimop ( "key" , D_SD ) ; _symbolTable . addPrimop ( "id" , D_S ) ; _symbolTable . addPrimop ( "id" , D_D ) ; _symbolTable . addPrimop ( "namespace-uri" , S_V ) ; _symbolTable . addPrimop ( "function-available" , B_S ) ; _symbolTable . addPrimop ( "element-available" , B_S ) ; _symbolTable . addPrimop ( "document" , D_S ) ; _symbolTable . addPrimop ( "document" , D_V ) ; _symbolTable . addPrimop ( "count" , I_D ) ; _symbolTable . addPrimop ( "sum" , R_D ) ; _symbolTable . addPrimop ( "local-name" , S_V ) ; _symbolTable . addPrimop ( "local-name" , S_D ) ; _symbolTable . addPrimop ( "namespace-uri" , S_V ) ; _symbolTable . addPrimop ( "namespace-uri" , S_D ) ; _symbolTable . addPrimop ( "substring" , S_SR ) ; _symbolTable . addPrimop ( "substring" , S_SRR ) ; _symbolTable . addPrimop ( "substring-after" , S_SS ) ; _symbolTable . addPrimop ( "substring-before" , S_SS ) ; _symbolTable . addPrimop ( "normalize-space" , S_V ) ; _symbolTable . addPrimop ( "normalize-space" , S_S ) ; _symbolTable . addPrimop ( "system-property" , S_S ) ; _symbolTable . addPrimop ( "nodeset" , D_X ) ; _symbolTable . addPrimop ( "+" , R_RR ) ; _symbolTable . addPrimop ( "-" , R_RR ) ; _symbolTable . addPrimop ( "*" , R_RR ) ; _symbolTable . addPrimop ( "/" , R_RR ) ; _symbolTable . addPrimop ( "%" , R_RR ) ; _symbolTable . addPrimop ( "+" , I_II ) ; _symbolTable . addPrimop ( "-" , I_II ) ; _symbolTable . addPrimop ( "*" , I_II ) ; _symbolTable . addPrimop ( "<" , B_RR ) ; _symbolTable . addPrimop ( "<=" , B_RR ) ; _symbolTable . addPrimop ( ">" , B_RR ) ; _symbolTable . addPrimop ( ">=" , B_RR ) ; _symbolTable . addPrimop ( "<" , B_II ) ; _symbolTable . addPrimop ( "<=" , B_II ) ; _symbolTable . addPrimop ( ">" , B_II ) ; _symbolTable . addPrimop ( ">=" , B_II ) ; _symbolTable . addPrimop ( "<" , B_BB ) ; _symbolTable . addPrimop ( "<=" , B_BB ) ; _symbolTable . addPrimop ( ">" , B_BB ) ; _symbolTable . addPrimop ( ">=" , B_BB ) ; _symbolTable . addPrimop ( "or" , B_BB ) ; _symbolTable . addPrimop ( "and" , B_BB ) ; _symbolTable . addPrimop ( "u-" , R_R ) ; _symbolTable . addPrimop ( "u-" , I_I ) ; } public SymbolTable getSymbolTable ( ) { return _symbolTable ; } public Template getTemplate ( ) { return _template ; } public void setTemplate ( Template template ) { _template = template ; } private int _templateIndex = 0 ; public int getTemplateIndex ( ) { return ( _templateIndex ++ ) ; } private boolean versionIsOne = true ; public SyntaxTreeNode makeInstance ( String uri , String prefix , String local , Attributes attributes ) { SyntaxTreeNode node = null ; QName qname = getQName ( uri , prefix , local ) ; String className = ( String ) _instructionClasses . get ( qname ) ; if ( className != null ) { try { final Class clazz = Class . forName ( className ) ; node = ( SyntaxTreeNode ) clazz . newInstance ( ) ; node . setQName ( qname ) ; node . setParser ( this ) ; if ( _locator != null ) { node . setLineNumber ( _locator . getLineNumber ( ) ) ; } if ( node instanceof Stylesheet ) { _xsltc . setStylesheet ( ( Stylesheet ) node ) ; } checkForSuperfluousAttributes ( node , attributes ) ; } catch ( ClassNotFoundException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , node ) ; reportError ( ERROR , err ) ; } catch ( Exception e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , e . getMessage ( ) , node ) ; reportError ( FATAL , err ) ; } } else { if ( uri != null ) { if ( uri . equals ( XSLT_URI ) ) { node = new UnsupportedElement ( uri , prefix , local ) ; UnsupportedElement element = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_XSL_ERR , _locator . getLineNumber ( ) , local ) ; element . setErrorMessage ( msg ) ; } else if ( uri . equals ( TRANSLET_URI ) ) { node = new UnsupportedElement ( uri , prefix , local ) ; UnsupportedElement element = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_EXT_ERR , _locator . getLineNumber ( ) , local ) ; element . setErrorMessage ( msg ) ; } else { Stylesheet sheet = _xsltc . getStylesheet ( ) ; if ( ( sheet != null ) && ( sheet . isExtension ( uri ) ) ) { if ( sheet != ( SyntaxTreeNode ) _parentStack . peek ( ) ) { node = new UnsupportedElement ( uri , prefix , local ) ; UnsupportedElement elem = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_EXT_ERR , _locator . getLineNumber ( ) , prefix + ":" + local ) ; elem . setErrorMessage ( msg ) ; } } } } if ( node == null ) node = new LiteralElement ( ) ; } if ( ( node != null ) && ( node instanceof LiteralElement ) ) { ( ( LiteralElement ) node ) . setQName ( qname ) ; } return ( node ) ; } private void checkForSuperfluousAttributes ( SyntaxTreeNode node , Attributes attrs ) { QName qname = node . getQName ( ) ; boolean isStylesheet = ( node instanceof Stylesheet ) ; String [ ] legal = ( String [ ] ) _instructionAttrs . get ( qname ) ; if ( versionIsOne && legal != null ) { int j ; final int n = attrs . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final String attrQName = attrs . getQName ( i ) ; if ( isStylesheet && attrQName . equals ( "version" ) ) { versionIsOne = attrs . getValue ( i ) . equals ( "1.0" ) ; } if ( attrQName . startsWith ( "xml" ) || attrQName . indexOf ( ':' ) > 0 ) continue ; for ( j = 0 ; j < legal . length ; j ++ ) { if ( attrQName . equalsIgnoreCase ( legal [ j ] ) ) { break ; } } if ( j == legal . length ) { final ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , attrQName , node ) ; reportError ( WARNING , err ) ; } } } } public Expression parseExpression ( SyntaxTreeNode parent , String exp ) { return ( Expression ) parseTopLevel ( parent , "<EXPRESSION>" + exp , null ) ; } public Expression parseExpression ( SyntaxTreeNode parent , String attr , String def ) { String exp = parent . getAttribute ( attr ) ; if ( ( exp . length ( ) == 0 ) && ( def != null ) ) exp = def ; return ( Expression ) parseTopLevel ( parent , "<EXPRESSION>" + exp , exp ) ; } public Pattern parsePattern ( SyntaxTreeNode parent , String pattern ) { return ( Pattern ) parseTopLevel ( parent , "<PATTERN>" + pattern , pattern ) ; } public Pattern parsePattern ( SyntaxTreeNode parent , String attr , String def ) { String pattern = parent . getAttribute ( attr ) ; if ( ( pattern . length ( ) == 0 ) && ( def != null ) ) pattern = def ; return ( Pattern ) parseTopLevel ( parent , "<PATTERN>" + pattern , pattern ) ; } private SyntaxTreeNode parseTopLevel ( SyntaxTreeNode parent , String text , String expression ) { int line = 0 ; if ( _locator != null ) line = _locator . getLineNumber ( ) ; try { _xpathParser . setScanner ( new XPathLexer ( new StringReader ( text ) ) ) ; Symbol result = _xpathParser . parse ( expression , line ) ; if ( result != null ) { final SyntaxTreeNode node = ( SyntaxTreeNode ) result . value ; if ( node != null ) { node . setParser ( this ) ; node . setParent ( parent ) ; node . setLineNumber ( line ) ; return node ; } } reportError ( ERROR , new ErrorMsg ( ErrorMsg . XPATH_PARSER_ERR , expression , parent ) ) ; } catch ( Exception e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( ErrorMsg . XPATH_PARSER_ERR , expression , parent ) ) ; } SyntaxTreeNode . Dummy . setParser ( this ) ; return SyntaxTreeNode . Dummy ; } public boolean errorsFound ( ) { return _errors . size ( ) > 0 ; } public void printErrors ( ) { final int size = _errors . size ( ) ; if ( size > 0 ) { System . err . println ( ErrorMsg . getCompileErrorMessage ( ) ) ; for ( int i = 0 ; i < size ; i ++ ) { System . err . println ( "  " + _errors . elementAt ( i ) ) ; } } } public void printWarnings ( ) { final int size = _warnings . size ( ) ; if ( size > 0 ) { System . err . println ( ErrorMsg . getCompileWarningMessage ( ) ) ; for ( int i = 0 ; i < size ; i ++ ) { System . err . println ( "  " + _warnings . elementAt ( i ) ) ; } } } public void reportError ( final int category , final ErrorMsg error ) { switch ( category ) { case Constants . INTERNAL : _errors . addElement ( error ) ; break ; case Constants . UNSUPPORTED : _errors . addElement ( error ) ; break ; case Constants . FATAL : _errors . addElement ( error ) ; break ; case Constants . ERROR : _errors . addElement ( error ) ; break ; case Constants . WARNING : _warnings . addElement ( error ) ; break ; } } public Vector getErrors ( ) { return _errors ; } public Vector getWarnings ( ) { return _warnings ; } private Stack _parentStack = null ; private Hashtable _prefixMapping = null ; public void startDocument ( ) { _root = null ; _target = null ; _prefixMapping = null ; _parentStack = new Stack ( ) ; } public void endDocument ( ) { } public void startPrefixMapping ( String prefix , String uri ) { if ( _prefixMapping == null ) { _prefixMapping = new Hashtable ( ) ; } _prefixMapping . put ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) { } public void startElement ( String uri , String localname , String qname , Attributes attributes ) throws SAXException { final int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col == - 1 ) ? null : qname . substring ( 0 , col ) ; SyntaxTreeNode element = makeInstance ( uri , prefix , localname , attributes ) ; if ( element == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ELEMENT_PARSE_ERR , prefix + ':' + localname ) ; throw new SAXException ( err . toString ( ) ) ; } if ( _root == null ) { if ( ( _prefixMapping == null ) || ( _prefixMapping . containsValue ( Constants . XSLT_URI ) == false ) ) _rootNamespaceDef = false ; else _rootNamespaceDef = true ; _root = element ; } else { SyntaxTreeNode parent = ( SyntaxTreeNode ) _parentStack . peek ( ) ; parent . addElement ( element ) ; element . setParent ( parent ) ; } element . setAttributes ( ( Attributes ) new AttributeList ( attributes ) ) ; element . setPrefixMapping ( _prefixMapping ) ; if ( element instanceof Stylesheet ) { getSymbolTable ( ) . setCurrentNode ( element ) ; ( ( Stylesheet ) element ) . excludeExtensionPrefixes ( this ) ; } _prefixMapping = null ; _parentStack . push ( element ) ; } public void endElement ( String uri , String localname , String qname ) { _parentStack . pop ( ) ; } public void characters ( char [ ] ch , int start , int length ) { String string = new String ( ch , start , length ) ; SyntaxTreeNode parent = ( SyntaxTreeNode ) _parentStack . peek ( ) ; if ( string . length ( ) == 0 ) return ; if ( parent instanceof Text ) { ( ( Text ) parent ) . setText ( string ) ; return ; } if ( parent instanceof Stylesheet ) return ; SyntaxTreeNode bro = parent . lastChild ( ) ; if ( ( bro != null ) && ( bro instanceof Text ) ) { Text text = ( Text ) bro ; if ( ! text . isTextElement ( ) ) { if ( ( length > 1 ) || ( ( ( int ) ch [ 0 ] ) < 0x100 ) ) { text . setText ( string ) ; return ; } } } parent . addElement ( new Text ( string ) ) ; } private String getTokenValue ( String token ) { final int start = token . indexOf ( '"' ) ; final int stop = token . lastIndexOf ( '"' ) ; return token . substring ( start + 1 , stop ) ; } public void processingInstruction ( String name , String value ) { if ( ( _target == null ) && ( name . equals ( "xml-stylesheet" ) ) ) { String href = null ; String media = null ; String title = null ; String charset = null ; StringTokenizer tokens = new StringTokenizer ( value ) ; while ( tokens . hasMoreElements ( ) ) { String token = ( String ) tokens . nextElement ( ) ; if ( token . startsWith ( "href" ) ) href = getTokenValue ( token ) ; else if ( token . startsWith ( "media" ) ) media = getTokenValue ( token ) ; else if ( token . startsWith ( "title" ) ) title = getTokenValue ( token ) ; else if ( token . startsWith ( "charset" ) ) charset = getTokenValue ( token ) ; } if ( ( ( _PImedia == null ) || ( _PImedia . equals ( media ) ) ) && ( ( _PItitle == null ) || ( _PImedia . equals ( title ) ) ) && ( ( _PIcharset == null ) || ( _PImedia . equals ( charset ) ) ) ) { _target = href ; } } } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { } public void skippedEntity ( String name ) { } public void setDocumentLocator ( Locator locator ) { _locator = locator ; } } 	1	['75', '1', '1', '96', '196', '2497', '86', '23', '59', '0.933783784', '3247', '1', '9', '0', '0.093333333', '0', '0', '41.89333333', '13', '2.2667', '1']
package org . apache . xpath . axes ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public interface ContextNodeList { public Node getCurrentNode ( ) ; public int getCurrentPos ( ) ; public void reset ( ) ; public void setShouldCacheNodes ( boolean b ) ; public void runTo ( int index ) ; public void setCurrentPos ( int i ) ; public int size ( ) ; public boolean isFresh ( ) ; public NodeIterator cloneWithReset ( ) throws CloneNotSupportedException ; public Object clone ( ) throws CloneNotSupportedException ; public int getLast ( ) ; public void setLast ( int last ) ; } 	0	['12', '1', '0', '1', '12', '66', '1', '0', '12', '2', '12', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . apache . xml . utils ; public class IntVector { protected int m_blocksize ; protected int m_map [ ] ; protected int m_firstFree = 0 ; protected int m_mapSize ; public IntVector ( ) { m_blocksize = 32 ; m_mapSize = m_blocksize ; m_map = new int [ m_blocksize ] ; } public IntVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new int [ blocksize ] ; } public IntVector ( int blocksize , int increaseSize ) { m_blocksize = increaseSize ; m_mapSize = blocksize ; m_map = new int [ blocksize ] ; } public final int size ( ) { return m_firstFree ; } public final void setSize ( int sz ) { m_firstFree = sz ; } public final void addElement ( int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void addElements ( int value , int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map [ m_firstFree ] = value ; m_firstFree ++ ; } } public final void addElements ( int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_firstFree += numberOfElements ; } public final void insertElementAt ( int value , int at ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public final void removeAllElements ( ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = java . lang . Integer . MIN_VALUE ; } m_firstFree = 0 ; } public final boolean removeElement ( int s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + 1 ) < m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return true ; } } return false ; } public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i , m_firstFree ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; } public final void setElementAt ( int value , int index ) { m_map [ index ] = value ; } public final int elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( int s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) return true ; } return false ; } public final int indexOf ( int elem , int index ) { for ( int i = index ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int indexOf ( int elem ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int lastIndexOf ( int elem ) { for ( int i = ( m_firstFree - 1 ) ; i >= 0 ; i -- ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } } 	1	['18', '1', '1', '4', '20', '0', '4', '0', '18', '0.382352941', '458', '1', '0', '0', '0.916666667', '0', '0', '24.22222222', '4', '1.8889', '1']
package org . apache . xml . utils ; import java . util . Hashtable ; class ElemDesc { Hashtable m_attrs = null ; int m_flags ; static final int EMPTY = ( 1 << 1 ) ; static final int FLOW = ( 1 << 2 ) ; static final int BLOCK = ( 1 << 3 ) ; static final int BLOCKFORM = ( 1 << 4 ) ; static final int BLOCKFORMFIELDSET = ( 1 << 5 ) ; static final int CDATA = ( 1 << 6 ) ; static final int PCDATA = ( 1 << 7 ) ; static final int RAW = ( 1 << 8 ) ; static final int INLINE = ( 1 << 9 ) ; static final int INLINEA = ( 1 << 10 ) ; static final int INLINELABEL = ( 1 << 11 ) ; static final int FONTSTYLE = ( 1 << 12 ) ; static final int PHRASE = ( 1 << 13 ) ; static final int FORMCTRL = ( 1 << 14 ) ; static final int SPECIAL = ( 1 << 15 ) ; static final int ASPECIAL = ( 1 << 16 ) ; static final int HEADMISC = ( 1 << 17 ) ; static final int HEAD = ( 1 << 18 ) ; static final int LIST = ( 1 << 19 ) ; static final int PREFORMATTED = ( 1 << 20 ) ; static final int WHITESPACESENSITIVE = ( 1 << 21 ) ; static final int ATTRURL = ( 1 << 1 ) ; static final int ATTREMPTY = ( 1 << 2 ) ; ElemDesc ( int flags ) { m_flags = flags ; } boolean is ( int flags ) { return ( m_flags & flags ) != 0 ; } void setAttr ( String name , int flags ) { if ( null == m_attrs ) m_attrs = new Hashtable ( ) ; m_attrs . put ( name , new Integer ( flags ) ) ; } boolean isAttrFlagSet ( String name , int flags ) { if ( null != m_attrs ) { Integer _flags = ( Integer ) m_attrs . get ( name ) ; if ( null != _flags ) { return ( _flags . intValue ( ) & flags ) != 0 ; } } return false ; } } 	0	['4', '1', '0', '0', '10', '0', '0', '0', '0', '1.266666667', '90', '0', '0', '0', '0.833333333', '0', '0', '15.25', '4', '2', '0']
package org . apache . xalan . lib ; import org . w3c . dom . Node ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . w3c . dom . traversal . NodeIterator ; import org . apache . xpath . NodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . DOMHelper ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xml . utils . XMLString ; import org . xml . sax . SAXNotSupportedException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . xslt . EnvironmentCheck ; import javax . xml . parsers . * ; public class ExsltMath { public static String max ( ExpressionContext expCon , NodeIterator ni ) { NodeSet ns = new NodeSet ( ni ) ; Node maxNode = null ; double m = Double . MIN_VALUE ; for ( int i = 0 ; i < ns . getLength ( ) ; i ++ ) { Node n = ns . elementAt ( i ) ; double d = expCon . toNumber ( n ) ; if ( Double . isNaN ( d ) ) return "NaN" ; else if ( d > m ) { m = d ; maxNode = n ; } } return expCon . toString ( maxNode ) ; } public static String min ( ExpressionContext expCon , NodeIterator ni ) { NodeSet ns = new NodeSet ( ni ) ; Node minNode = null ; double m = Double . MAX_VALUE ; for ( int i = 0 ; i < ns . getLength ( ) ; i ++ ) { Node n = ns . elementAt ( i ) ; double d = expCon . toNumber ( n ) ; if ( Double . isNaN ( d ) ) return "NaN" ; else if ( d < m ) { m = d ; minNode = n ; } } return expCon . toString ( minNode ) ; } public static NodeSet highest ( ExpressionContext expCon , NodeIterator ni ) throws java . lang . CloneNotSupportedException { NodeSet ns = new NodeSet ( ni ) ; NodeIterator niClone = ns . cloneWithReset ( ) ; double high = new Double ( max ( expCon , niClone ) ) . doubleValue ( ) ; NodeSet highNodes = new NodeSet ( ) ; highNodes . setShouldCacheNodes ( true ) ; if ( Double . isNaN ( high ) ) return highNodes ; for ( int i = 0 ; i < ns . getLength ( ) ; i ++ ) { Node n = ns . elementAt ( i ) ; double d = expCon . toNumber ( n ) ; if ( d == high ) highNodes . addElement ( n ) ; } return highNodes ; } public static NodeSet lowest ( ExpressionContext expCon , NodeIterator ni ) throws java . lang . CloneNotSupportedException { NodeSet ns = new NodeSet ( ni ) ; NodeIterator niClone = ns . cloneWithReset ( ) ; double low = new Double ( min ( expCon , niClone ) ) . doubleValue ( ) ; NodeSet lowNodes = new NodeSet ( ) ; lowNodes . setShouldCacheNodes ( true ) ; if ( Double . isNaN ( low ) ) return lowNodes ; for ( int i = 0 ; i < ns . getLength ( ) ; i ++ ) { Node n = ns . elementAt ( i ) ; double d = expCon . toNumber ( n ) ; if ( d == low ) lowNodes . addElement ( n ) ; } return lowNodes ; } } 	1	['5', '1', '0', '2', '18', '10', '0', '2', '5', '2', '198', '0', '0', '0', '0.6', '0', '0', '38.6', '4', '2', '2']
package org . apache . xalan . xsltc ; public interface Translet { public void transform ( DOM document , TransletOutputHandler handler ) throws TransletException ; public void transform ( DOM document , TransletOutputHandler [ ] handlers ) throws TransletException ; public void transform ( DOM document , NodeIterator iterator , TransletOutputHandler handler ) throws TransletException ; public Object addParameter ( String name , Object value ) ; public void buildKeys ( DOM document , NodeIterator iterator , TransletOutputHandler handler , int root ) throws TransletException ; public void addAuxiliaryClass ( Class auxClass ) ; public Class getAuxiliaryClass ( String className ) ; public String [ ] getNamesArray ( ) ; public String [ ] getNamespaceArray ( ) ; } 	0	['9', '1', '0', '20', '9', '36', '16', '4', '9', '2', '9', '0', '0', '0', '0.296296296', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . util . Vector ; import java . util . Enumeration ; import java . util . ResourceBundle ; public class ErrorMessages extends ResourceBundle { private static final String errorMessages [ ] = { "More than one stylesheet defined in the same file." , "Template ''{0}'' already defined in this stylesheet." , "Template ''{0}'' not defined in this stylesheet." , "Variable ''{0}'' is multiply defined in the same scope." , "Variable or parameter ''{0}'' is undefined." , "Cannot find class ''{0}''." , "Cannot find external method ''{0}'' (must be public)." , "Cannot convert argument/return type in call to method ''{0}''" , "File or URI ''{0}'' not found." , "Invalid URI ''{0}''." , "Cannot open file or URI ''{0}''." , "<xsl:stylesheet> or <xsl:transform> element expected." , "Namespace prefix ''{0}'' is undeclared." , "Unable to resolve call to function ''{0}''." , "Argument to ''{0}'' must be a literal string." , "Error parsing XPath expression ''{0}''." , "Required attribute ''{0}'' is missing." , "Illegal character ''{0}'' in XPath expression." , "Illegal name ''{0}'' for processing instruction." , "Attribute ''{0}'' outside of element." , "Illegal attribute ''{0}''." , "Circular import/include. Stylesheet ''{0}'' already loaded." , "Result-tree fragments cannot be sorted (<xsl:sort> elements are " + "ignored). You must sort the nodes when creating the result tree." , "Decimal formatting ''{0}'' is already defined." , "XSL version ''{0}'' is not supported by XSLTC." , "Circular variable/parameter reference in ''{0}''." , "Unknown operator for binary expression." , "Illegal argument(s) for function call." , "Second argument to document() function must be a node-set." , "At least one <xsl:when> element required in <xsl:choose>." , "Only one <xsl:otherwise> element allowed in <xsl:choose>." , "<xsl:otherwise> can only be used within <xsl:choose>." , "<xsl:when> can only be used within <xsl:choose>." , "Only <xsl:when> and <xsl:otherwise> elements allowed in <xsl:choose>." , "<xsl:attribute-set> is missing the 'name' attribute." , "Illegal child element." , "You cannot call an element ''{0}''" , "You cannot call an attribute ''{0}''" , "Text data outside of top-level <xsl:stylesheet> element." , "JAXP parser not configured correctly" , "Unrecoverable XSLTC-internal error: ''{0}''" , "Unsupported XSL element ''{0}''." , "Unrecognised XSLTC extension ''{0}''." , "The input document is not a stylesheet " + "(the XSL namespace is not declared in the root element)." , "Could not find stylesheet target ''{0}''." , "Not implemented: ''{0}''." , "The input document does not contain an XSL stylesheet." , "Could not parse element ''{0}''" , "The use-attribute of <key> must be node, node-set, string or number." , "Output XML document version should be 1.0" , "Unknown operator for relational expression" , "Attempting to use non-existing attribute set ''{0}''." , "Cannot parse attribute value template ''{0}''." , "Unknown data-type in signature for class ''{0}''." , "Cannot convert data-type ''{0}'' to ''{1}''." , "This Templates does not contain a valid translet class definition." , "This Templates does not contain a class with the name ''{0}''." , "Could not load the translet class ''{0}''." , "Translet class loaded, but unable to create translet instance." , "Attempting to set ErrorListener for ''{0}'' to null" , "Only StreamSource, SAXSource and DOMSOurce are supported by XSLTC" , "Source object passed to ''{0}'' has no contents." , "Could not compile stylesheet" , "TransformerFactory does not recognise attribute ''{0}''." , "setResult() must be called prior to startDocument()." , "The transformer has no encapsulated translet object." , "No defined output handler for transformation result." , "Result object passed to ''{0}'' is invalid." , "Attempting to access invalid Transformer property ''{0}''." , "Could not crate SAX2DOM adapter: ''{0}''." , "XSLTCSource.build() called without systemId being set." , "The -i option must be used with the -o option." , "SYNOPSIS\n" + "   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n" + "      [-d <directory>] [-j <jarfile>] [-p <package>]\n" + "      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\n" + "OPTIONS\n" + "   -o <output>    assigns the name <output> to the generated\n" + "                  translet. By default the translet name\n" + "                  is taken from the <stylesheet> name. This option\n" + "                  is ignored if compiling multiple stylesheets.\n" + "   -d <directory> specifies a destination directory for translet\n" + "   -j <jarfile>   packages translet classes into a jar file of the\n" + "                  name specified as <jarfile>\n" + "   -p <package>   specifies a package name prefix for all generated\n" + "                  translet classes.\n" + "   -n             disables template inlining to reduce method\n" + "                  length.\n" + "   -x             turns on additional debugging message output\n" + "   -s             disables calling System.exit\n" + "   -u             interprets <stylesheet> arguments as URLs\n" + "   -i             forces compiler to read stylesheet from stdin\n" + "   -v             prints the version of the compiler\n" + "   -h             prints this usage statement\n" , "SYNOPSIS \n" + "   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n" + "      [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}\n" + "      <class> [<param1>=<value1> ...]\n\n" + "   uses the translet <class> to transform an XML document \n" + "   specified as <document>. The translet <class> is either in\n" + "   the user's CLASSPATH or in the optionally specified <jarfile>.\n" + "OPTIONS\n" + "   -j <jarfile>    specifies a jarfile from which to load translet\n" + "   -x              turns on additional debugging message output\n" + "   -s              disables calling System.exit\n" + "   -n <iterations> runs the transformation <iterations> times and\n" + "                   displays profiling information\n" + "   -u <document_url> specifies XML input document as a URL\n" , "<xsl:sort> can only be used within <xsl:for-each> or <xsl:apply-templates>." , "Output encoding ''{0}'' is not supported on this JVM." , "Syntax error in ''{0}''." , "Cannot find external constructor ''{0}''." , "First argument to non-static Java function ''{0}'' is not valid object ref." } ; private static Vector _keys ; static { _keys = new Vector ( ) ; _keys . addElement ( ErrorMsg . ERROR_MESSAGES_KEY ) ; _keys . addElement ( ErrorMsg . COMPILER_ERROR_KEY ) ; _keys . addElement ( ErrorMsg . COMPILER_WARNING_KEY ) ; _keys . addElement ( ErrorMsg . RUNTIME_ERROR_KEY ) ; } public Enumeration getKeys ( ) { return _keys . elements ( ) ; } public Object handleGetObject ( String key ) { if ( key == null ) return null ; if ( key . equals ( ErrorMsg . ERROR_MESSAGES_KEY ) ) return errorMessages ; else if ( key . equals ( ErrorMsg . COMPILER_ERROR_KEY ) ) return "Compiler error(s): " ; else if ( key . equals ( ErrorMsg . COMPILER_WARNING_KEY ) ) return "Compiler warning(s): " ; else if ( key . equals ( ErrorMsg . RUNTIME_ERROR_KEY ) ) return "Translet error(s): " ; return ( null ) ; } } 	1	['4', '2', '1', '1', '9', '2', '1', '0', '3', '0.666666667', '378', '1', '0', '0.942857143', '0.666666667', '2', '3', '93', '6', '1.75', '1']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . Constants ; public final class ObjectType extends Type { private String _javaClassName = "java.lang.Object" ; protected ObjectType ( ) { } public ObjectType ( String javaClassName ) { _javaClassName = javaClassName ; } public int hashCode ( ) { return toString ( ) . hashCode ( ) ; } public boolean equals ( Object obj ) { return ( obj instanceof ObjectType ) ; } public String getJavaClassName ( ) { return _javaClassName ; } public String toString ( ) { return "object" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { final StringBuffer result = new StringBuffer ( "L" ) ; result . append ( _javaClassName . replace ( '.' , '/' ) ) . append ( ';' ) ; return result . toString ( ) ; } public org . apache . bcel . generic . Type toJCType ( ) { return Util . getJCRefType ( toSignature ( ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP ) ; final BranchHandle ifNull = il . append ( new IFNULL ( null ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( _javaClassName , "toString" , "()" + STRING_SIG ) ) ) ; final BranchHandle gotobh = il . append ( new GOTO ( null ) ) ; ifNull . setTarget ( il . append ( POP ) ) ; il . append ( new PUSH ( cpg , "" ) ) ; gotobh . setTarget ( il . append ( NOP ) ) ; } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['14', '2', '0', '30', '39', '71', '6', '25', '13', '0.538461538', '167', '1', '0', '0.733333333', '0.222222222', '2', '3', '10.85714286', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class KeyCall extends FunctionCall { private Expression _name ; private Expression _value ; private Type _valueType ; private QName _resolvedQName = null ; public KeyCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; switch ( argumentCount ( ) ) { case 1 : _name = null ; _value = argument ( 0 ) ; break ; case 2 : _name = argument ( 0 ) ; _value = argument ( 1 ) ; break ; default : _name = _value = null ; break ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type returnType = super . typeCheck ( stable ) ; if ( _name != null ) { final Type nameType = _name . typeCheck ( stable ) ; if ( _name instanceof LiteralExpr ) { final LiteralExpr literal = ( LiteralExpr ) _name ; _resolvedQName = getParser ( ) . getQNameIgnoreDefaultNs ( literal . getValue ( ) ) ; } else if ( nameType instanceof StringType == false ) { _name = new CastExpr ( _name , Type . String ) ; } } _valueType = _value . typeCheck ( stable ) ; if ( ( _valueType != Type . NodeSet ) && ( _valueType != Type . ResultTree ) && ( _valueType != Type . String ) && ( _valueType != Type . Real ) && ( _valueType != Type . Int ) ) { _value = new CastExpr ( _value , Type . String ) ; } return returnType ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int dupInit = cpg . addMethodref ( DUP_FILTERED_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( DUP_FILTERED_ITERATOR ) ) ) ; il . append ( DUP ) ; translateCall ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( dupInit ) ) ; } private void translateCall ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeValue = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeValue" , "(I)" + STRING_SIG ) ; final int getKeyIndex = cpg . addMethodref ( TRANSLET_CLASS , "getKeyIndex" , "(Ljava/lang/String;)" + KEY_INDEX_SIG ) ; final int lookupId = cpg . addMethodref ( KEY_INDEX_CLASS , "lookupId" , "(Ljava/lang/Object;)V" ) ; final int lookupKey = cpg . addMethodref ( KEY_INDEX_CLASS , "lookupKey" , "(Ljava/lang/Object;)V" ) ; final int merge = cpg . addMethodref ( KEY_INDEX_CLASS , "merge" , "(" + KEY_INDEX_SIG + ")V" ) ; final int indexConstructor = cpg . addMethodref ( TRANSLET_CLASS , "createKeyIndex" , "()" + KEY_INDEX_SIG ) ; final LocalVariableGen returnIndex = methodGen . addLocalVariable ( "returnIndex" , Util . getJCRefType ( KEY_INDEX_SIG ) , il . getEnd ( ) , null ) ; final LocalVariableGen searchIndex = methodGen . addLocalVariable ( "searchIndex" , Util . getJCRefType ( KEY_INDEX_SIG ) , il . getEnd ( ) , null ) ; if ( _valueType == Type . NodeSet || _valueType == Type . ResultTree ) { il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; _value . translate ( classGen , methodGen ) ; _value . startResetIterator ( classGen , methodGen ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEVIRTUAL ( indexConstructor ) ) ; il . append ( new ASTORE ( returnIndex . getIndex ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( _name == null ) { il . append ( new PUSH ( cpg , "##id" ) ) ; } else if ( _resolvedQName != null ) { il . append ( new PUSH ( cpg , _resolvedQName . toString ( ) ) ) ; } else { _name . translate ( classGen , methodGen ) ; } il . append ( new INVOKEVIRTUAL ( getKeyIndex ) ) ; il . append ( new ASTORE ( searchIndex . getIndex ( ) ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( new ALOAD ( returnIndex . getIndex ( ) ) ) ; il . append ( new ALOAD ( searchIndex . getIndex ( ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( getNodeValue , 2 ) ) ; if ( _name == null ) { il . append ( new INVOKEVIRTUAL ( lookupId ) ) ; } else { il . append ( new INVOKEVIRTUAL ( lookupKey ) ) ; } il . append ( new INVOKEVIRTUAL ( merge ) ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFNE ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new ALOAD ( returnIndex . getIndex ( ) ) ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; if ( _name == null ) { il . append ( new PUSH ( cpg , "##id" ) ) ; } else if ( _resolvedQName != null ) { il . append ( new PUSH ( cpg , _resolvedQName . toString ( ) ) ) ; } else { _name . translate ( classGen , methodGen ) ; } il . append ( new INVOKEVIRTUAL ( getKeyIndex ) ) ; il . append ( DUP ) ; if ( _valueType == Type . Int || _valueType == Type . Real ) { final int dbl = cpg . addMethodref ( DOUBLE_CLASS , "<init>" , "(D)V" ) ; il . append ( new NEW ( cpg . addClass ( DOUBLE_CLASS ) ) ) ; il . append ( DUP ) ; _value . translate ( classGen , methodGen ) ; if ( _valueType == Type . Int ) il . append ( new I2D ( ) ) ; il . append ( new INVOKESPECIAL ( dbl ) ) ; } else { _value . translate ( classGen , methodGen ) ; } if ( _name == null ) { il . append ( new INVOKEVIRTUAL ( lookupId ) ) ; } else { il . append ( new INVOKEVIRTUAL ( lookupKey ) ) ; } } } } 	1	['4', '4', '0', '38', '46', '0', '1', '37', '3', '0.083333333', '562', '1', '4', '0.96969697', '0.458333333', '3', '7', '138.5', '12', '3.5', '1']
package org . apache . xalan . trace ; public interface TraceListenerEx extends TraceListener { public void selectEnd ( EndSelectionEvent ev ) throws javax . xml . transform . TransformerException ; } 	0	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xml . utils ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . URI ; import org . apache . xml . utils . URI . MalformedURIException ; import java . io . * ; import java . lang . StringBuffer ; public class SystemIDResolver { public static String getAbsoluteURIFromRelative ( String uri ) { String curdir = "" ; try { curdir = System . getProperty ( "user.dir" ) ; } catch ( SecurityException se ) { } if ( null != curdir ) { String base ; if ( curdir . startsWith ( File . separator ) ) base = "file://" + curdir ; else base = "file:///" + curdir ; if ( uri != null ) uri = base + System . getProperty ( "file.separator" ) + uri ; else uri = base + System . getProperty ( "file.separator" ) ; } if ( null != uri && ( uri . indexOf ( '\\' ) > - 1 ) ) uri = uri . replace ( '\\' , '/' ) ; return uri ; } public static String getAbsoluteURI ( String url ) throws TransformerException { if ( url . startsWith ( ".." ) ) url = new File ( url ) . getAbsolutePath ( ) ; if ( url . startsWith ( File . separator ) ) { url = "file://" + url ; } else if ( url . indexOf ( ':' ) < 0 ) { url = getAbsoluteURIFromRelative ( url ) ; } return url ; } public static String getAbsoluteURI ( String urlString , String base ) throws TransformerException { boolean isAbsouteUrl = false ; boolean needToResolve = false ; if ( urlString . indexOf ( ':' ) > 0 ) { isAbsouteUrl = true ; } else if ( urlString . startsWith ( File . separator ) ) { urlString = "file://" + urlString ; isAbsouteUrl = true ; } if ( ( ! isAbsouteUrl ) && ( ( null == base ) || ( base . indexOf ( ':' ) < 0 ) ) ) { if ( base != null && base . startsWith ( File . separator ) ) base = "file://" + base ; else base = getAbsoluteURIFromRelative ( base ) ; } if ( ( null != base ) && needToResolve ) { if ( base . equals ( urlString ) ) { base = "" ; } else { urlString = urlString . substring ( 5 ) ; isAbsouteUrl = false ; } } if ( null != base && ( base . indexOf ( '\\' ) > - 1 ) ) base = base . replace ( '\\' , '/' ) ; if ( null != urlString && ( urlString . indexOf ( '\\' ) > - 1 ) ) urlString = urlString . replace ( '\\' , '/' ) ; URI uri ; try { if ( ( null == base ) || ( base . length ( ) == 0 ) || ( isAbsouteUrl ) ) { uri = new URI ( urlString ) ; } else { URI baseURI = new URI ( base ) ; uri = new URI ( baseURI , urlString ) ; } } catch ( MalformedURIException mue ) { throw new TransformerException ( mue ) ; } String uriStr = uri . toString ( ) ; if ( ( Character . isLetter ( uriStr . charAt ( 0 ) ) && ( uriStr . charAt ( 1 ) == ':' ) && ( uriStr . charAt ( 2 ) == '/' ) && ( uriStr . length ( ) == 3 || uriStr . charAt ( 3 ) != '/' ) ) || ( ( uriStr . charAt ( 0 ) == '/' ) && ( uriStr . length ( ) == 1 || uriStr . charAt ( 1 ) != '/' ) ) ) { uriStr = "file:///" + uriStr ; } return uriStr ; } } 	1	['4', '1', '0', '14', '23', '6', '12', '2', '4', '2', '295', '0', '0', '0', '0.5', '0', '0', '72.75', '6', '2', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import java . util . Vector ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . axes . ContextNodeList ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . compiler . Compiler ; public class FuncPosition extends Function { private boolean m_isTopLevel ; public void postCompileStep ( Compiler compiler ) { m_isTopLevel = compiler . getLocationPathDepth ( ) == - 1 ; } public int getPositionInContextNodeList ( XPathContext xctxt ) { SubContextList iter = m_isTopLevel ? null : xctxt . getSubContextList ( ) ; if ( null != iter ) { int prox = iter . getProximityPosition ( xctxt ) ; return prox ; } DTMIterator cnl = xctxt . getContextNodeList ( ) ; if ( null != cnl ) { int n = cnl . getCurrentNode ( ) ; if ( n == DTM . NULL ) { if ( cnl . getCurrentPos ( ) == 0 ) return 0 ; try { cnl = cnl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } int currentNode = xctxt . getContextNode ( ) ; while ( DTM . NULL != ( n = cnl . nextNode ( ) ) ) { if ( n == currentNode ) break ; } } return cnl . getCurrentPos ( ) ; } return - 1 ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { double pos = ( double ) getPositionInContextNodeList ( xctxt ) ; return new XNumber ( pos ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	0	['5', '3', '0', '9', '17', '8', '1', '8', '5', '0.5', '92', '1', '0', '0.904761905', '0.4', '1', '6', '17.2', '8', '2.4', '0']
package org . apache . xalan . processor ; import org . xml . sax . ContentHandler ; import org . apache . xalan . templates . Constants ; import org . apache . xml . utils . QName ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import java . util . Hashtable ; import java . util . Enumeration ; public class XSLTElementDef { XSLTElementDef ( ) { } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject ) { build ( namespace , name , nameAlias , elements , attributes , contentHandler , classObject ) ; if ( ( null != namespace ) && ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) || namespace . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) ) ) { schema . addAvailableElement ( new QName ( namespace , name ) ) ; if ( null != nameAlias ) schema . addAvailableElement ( new QName ( namespace , nameAlias ) ) ; } } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required ) { this . m_has_required = has_required ; build ( namespace , name , nameAlias , elements , attributes , contentHandler , classObject ) ; if ( ( null != namespace ) && ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) || namespace . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) ) ) { schema . addAvailableElement ( new QName ( namespace , name ) ) ; if ( null != nameAlias ) schema . addAvailableElement ( new QName ( namespace , nameAlias ) ) ; } } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required , boolean required ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , has_required ) ; this . m_required = required ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required , boolean required , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , has_required , required ) ; this . m_order = order ; this . m_multiAllowed = multiAllowed ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required , boolean required , boolean has_order , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , has_required , required ) ; this . m_order = order ; this . m_multiAllowed = multiAllowed ; this . m_isOrdered = has_order ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_order , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , order , multiAllowed ) ; this . m_isOrdered = has_order ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject ) ; this . m_order = order ; this . m_multiAllowed = multiAllowed ; } XSLTElementDef ( Class classObject , XSLTElementProcessor contentHandler , int type ) { this . m_classObject = classObject ; this . m_type = type ; setElementProcessor ( contentHandler ) ; } void build ( String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject ) { this . m_namespace = namespace ; this . m_name = name ; this . m_nameAlias = nameAlias ; this . m_elements = elements ; this . m_attributes = attributes ; setElementProcessor ( contentHandler ) ; this . m_classObject = classObject ; if ( hasRequired ( ) && m_elements != null ) { int n = m_elements . length ; for ( int i = 0 ; i < n ; i ++ ) { XSLTElementDef def = m_elements [ i ] ; if ( def != null && def . getRequired ( ) ) { if ( m_requiredFound == null ) m_requiredFound = new Hashtable ( ) ; m_requiredFound . put ( def . getName ( ) , "xsl:" + def . getName ( ) ) ; } } } } private static boolean equalsMayBeNull ( Object obj1 , Object obj2 ) { return ( obj2 == obj1 ) || ( ( null != obj1 ) && ( null != obj2 ) && obj2 . equals ( obj1 ) ) ; } private static boolean equalsMayBeNullOrZeroLen ( String s1 , String s2 ) { int len1 = ( s1 == null ) ? 0 : s1 . length ( ) ; int len2 = ( s2 == null ) ? 0 : s2 . length ( ) ; return ( len1 != len2 ) ? false : ( len1 == 0 ) ? true : s1 . equals ( s2 ) ; } static final int T_ELEMENT = 1 , T_PCDATA = 2 , T_ANY = 3 ; private int m_type = T_ELEMENT ; int getType ( ) { return m_type ; } void setType ( int t ) { m_type = t ; } private String m_namespace ; String getNamespace ( ) { return m_namespace ; } private String m_name ; String getName ( ) { return m_name ; } private String m_nameAlias ; String getNameAlias ( ) { return m_nameAlias ; } private XSLTElementDef [ ] m_elements ; XSLTElementDef [ ] getElements ( ) { return m_elements ; } void setElements ( XSLTElementDef [ ] defs ) { m_elements = defs ; } private boolean QNameEquals ( String uri , String localName ) { return ( equalsMayBeNullOrZeroLen ( m_namespace , uri ) && ( equalsMayBeNullOrZeroLen ( m_name , localName ) || equalsMayBeNullOrZeroLen ( m_nameAlias , localName ) ) ) ; } XSLTElementProcessor getProcessorFor ( String uri , String localName ) { XSLTElementProcessor elemDef = null ; if ( null == m_elements ) return null ; int n = m_elements . length ; int order = - 1 ; boolean multiAllowed = true ; for ( int i = 0 ; i < n ; i ++ ) { XSLTElementDef def = m_elements [ i ] ; if ( def . m_name . equals ( "*" ) ) { if ( ! equalsMayBeNullOrZeroLen ( uri , Constants . S_XSLNAMESPACEURL ) ) { elemDef = def . m_elementProcessor ; order = def . getOrder ( ) ; multiAllowed = def . getMultiAllowed ( ) ; } } else if ( def . QNameEquals ( uri , localName ) ) { if ( def . getRequired ( ) ) this . setRequiredFound ( def . getName ( ) , true ) ; order = def . getOrder ( ) ; multiAllowed = def . getMultiAllowed ( ) ; elemDef = def . m_elementProcessor ; break ; } } if ( elemDef != null && this . isOrdered ( ) ) { int lastOrder = getLastOrder ( ) ; if ( order > lastOrder ) setLastOrder ( order ) ; else if ( order == lastOrder && ! multiAllowed ) { return null ; } else if ( order < lastOrder && order > 0 ) { return null ; } } return elemDef ; } XSLTElementProcessor getProcessorForUnknown ( String uri , String localName ) { if ( null == m_elements ) return null ; int n = m_elements . length ; for ( int i = 0 ; i < n ; i ++ ) { XSLTElementDef def = m_elements [ i ] ; if ( def . m_name . equals ( "unknown" ) && uri . length ( ) > 0 ) { return def . m_elementProcessor ; } } return null ; } private XSLTAttributeDef [ ] m_attributes ; XSLTAttributeDef [ ] getAttributes ( ) { return m_attributes ; } XSLTAttributeDef getAttributeDef ( String uri , String localName ) { XSLTAttributeDef defaultDef = null ; XSLTAttributeDef [ ] attrDefs = getAttributes ( ) ; int nAttrDefs = attrDefs . length ; for ( int k = 0 ; k < nAttrDefs ; k ++ ) { XSLTAttributeDef attrDef = attrDefs [ k ] ; String uriDef = attrDef . getNamespace ( ) ; String nameDef = attrDef . getName ( ) ; if ( nameDef . equals ( "*" ) && ( equalsMayBeNullOrZeroLen ( uri , uriDef ) || ( uriDef != null && uriDef . equals ( "*" ) && uri != null && uri . length ( ) > 0 ) ) ) { return attrDef ; } else if ( nameDef . equals ( "*" ) && ( uriDef == null ) ) { defaultDef = attrDef ; } else if ( equalsMayBeNullOrZeroLen ( uri , uriDef ) && localName . equals ( nameDef ) ) { return attrDef ; } } if ( null == defaultDef ) { if ( uri . length ( ) > 0 && ! equalsMayBeNullOrZeroLen ( uri , Constants . S_XSLNAMESPACEURL ) ) { return XSLTAttributeDef . m_foreignAttr ; } } return defaultDef ; } private XSLTElementProcessor m_elementProcessor ; XSLTElementProcessor getElementProcessor ( ) { return m_elementProcessor ; } void setElementProcessor ( XSLTElementProcessor handler ) { if ( handler != null ) { m_elementProcessor = handler ; m_elementProcessor . setElemDef ( this ) ; } } private Class m_classObject ; Class getClassObject ( ) { return m_classObject ; } private boolean m_has_required = false ; boolean hasRequired ( ) { return m_has_required ; } private boolean m_required = false ; boolean getRequired ( ) { return m_required ; } Hashtable m_requiredFound ; void setRequiredFound ( String elem , boolean found ) { if ( m_requiredFound . get ( elem ) != null ) m_requiredFound . remove ( elem ) ; } boolean getRequiredFound ( ) { if ( m_requiredFound == null ) return true ; return m_requiredFound . isEmpty ( ) ; } String getRequiredElem ( ) { if ( m_requiredFound == null ) return null ; Enumeration elems = m_requiredFound . elements ( ) ; String s = "" ; boolean first = true ; while ( elems . hasMoreElements ( ) ) { if ( first ) first = false ; else s = s + ", " ; s = s + ( String ) elems . nextElement ( ) ; } return s ; } boolean m_isOrdered = false ; boolean isOrdered ( ) { return m_isOrdered ; } private int m_order = - 1 ; int getOrder ( ) { return m_order ; } private int m_lastOrder = - 1 ; int getLastOrder ( ) { return m_lastOrder ; } void setLastOrder ( int order ) { m_lastOrder = order ; } private boolean m_multiAllowed = true ; boolean getMultiAllowed ( ) { return m_multiAllowed ; } } 	1	['37', '1', '1', '8', '57', '440', '6', '4', '0', '0.793209877', '804', '0.722222222', '3', '0', '0.289189189', '0', '0', '20.24324324', '15', '2.2162', '1']
package org . apache . xalan . xsltc . cmdline . getopt ; import org . apache . xalan . xsltc . cmdline . getopt . GetOptsException ; class IllegalArgumentException extends GetOptsException { public IllegalArgumentException ( String msg ) { super ( msg ) ; } } 	0	['1', '4', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xalan . extensions ; import java . lang . reflect . Method ; import java . lang . reflect . Constructor ; import java . lang . reflect . Modifier ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xml . dtm . * ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xml . dtm . ref . DTMNodeList ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import javax . xml . transform . TransformerException ; public class MethodResolver { public static final int STATIC_ONLY = 1 ; public static final int INSTANCE_ONLY = 2 ; public static final int STATIC_AND_INSTANCE = 3 ; public static final int DYNAMIC = 4 ; public static Constructor getConstructor ( Class classObj , Object [ ] argsIn , Object [ ] [ ] argsOut , ExpressionContext exprContext ) throws NoSuchMethodException , SecurityException , TransformerException { Constructor bestConstructor = null ; Class [ ] bestParamTypes = null ; Constructor [ ] constructors = classObj . getConstructors ( ) ; int nMethods = constructors . length ; int bestScore = Integer . MAX_VALUE ; int bestScoreCount = 0 ; for ( int i = 0 ; i < nMethods ; i ++ ) { Constructor ctor = constructors [ i ] ; Class [ ] paramTypes = ctor . getParameterTypes ( ) ; int numberMethodParams = paramTypes . length ; int paramStart = 0 ; boolean isFirstExpressionContext = false ; int scoreStart ; if ( numberMethodParams == ( argsIn . length + 1 ) ) { Class javaClass = paramTypes [ 0 ] ; if ( ExpressionContext . class . isAssignableFrom ( javaClass ) ) { isFirstExpressionContext = true ; scoreStart = 0 ; paramStart ++ ; } else continue ; } else scoreStart = 1000 ; if ( argsIn . length == ( numberMethodParams - paramStart ) ) { int score = scoreMatch ( paramTypes , paramStart , argsIn , scoreStart ) ; if ( - 1 == score ) continue ; if ( score < bestScore ) { bestConstructor = ctor ; bestParamTypes = paramTypes ; bestScore = score ; bestScoreCount = 1 ; } else if ( score == bestScore ) bestScoreCount ++ ; } } if ( null == bestConstructor ) { throw new NoSuchMethodException ( errString ( "function" , "constructor" , classObj , "" , 0 , argsIn ) ) ; } else convertParams ( argsIn , argsOut , bestParamTypes , exprContext ) ; return bestConstructor ; } public static Method getMethod ( Class classObj , String name , Object [ ] argsIn , Object [ ] [ ] argsOut , ExpressionContext exprContext , int searchMethod ) throws NoSuchMethodException , SecurityException , TransformerException { if ( name . indexOf ( "-" ) > 0 ) name = replaceDash ( name ) ; Method bestMethod = null ; Class [ ] bestParamTypes = null ; Method [ ] methods = classObj . getMethods ( ) ; int nMethods = methods . length ; int bestScore = Integer . MAX_VALUE ; int bestScoreCount = 0 ; boolean isStatic ; for ( int i = 0 ; i < nMethods ; i ++ ) { Method method = methods [ i ] ; int xsltParamStart = 0 ; if ( method . getName ( ) . equals ( name ) ) { isStatic = Modifier . isStatic ( method . getModifiers ( ) ) ; switch ( searchMethod ) { case STATIC_ONLY : if ( ! isStatic ) { continue ; } break ; case INSTANCE_ONLY : if ( isStatic ) { continue ; } break ; case STATIC_AND_INSTANCE : break ; case DYNAMIC : if ( ! isStatic ) xsltParamStart = 1 ; } int javaParamStart = 0 ; Class [ ] paramTypes = method . getParameterTypes ( ) ; int numberMethodParams = paramTypes . length ; boolean isFirstExpressionContext = false ; int scoreStart ; int argsLen = ( null != argsIn ) ? argsIn . length : 0 ; if ( numberMethodParams == ( argsLen - xsltParamStart + 1 ) ) { Class javaClass = paramTypes [ 0 ] ; if ( ExpressionContext . class . isAssignableFrom ( javaClass ) ) { isFirstExpressionContext = true ; scoreStart = 0 ; javaParamStart ++ ; } else { continue ; } } else scoreStart = 1000 ; if ( ( argsLen - xsltParamStart ) == ( numberMethodParams - javaParamStart ) ) { int score = scoreMatch ( paramTypes , javaParamStart , argsIn , scoreStart ) ; if ( - 1 == score ) continue ; if ( score < bestScore ) { bestMethod = method ; bestParamTypes = paramTypes ; bestScore = score ; bestScoreCount = 1 ; } else if ( score == bestScore ) bestScoreCount ++ ; } } } if ( null == bestMethod ) { throw new NoSuchMethodException ( errString ( "function" , "method" , classObj , name , searchMethod , argsIn ) ) ; } else convertParams ( argsIn , argsOut , bestParamTypes , exprContext ) ; return bestMethod ; } private static String replaceDash ( String name ) { char dash = '-' ; StringBuffer buff = new StringBuffer ( "" ) ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { if ( name . charAt ( i ) == dash ) { } else if ( i > 0 && name . charAt ( i - 1 ) == dash ) buff . append ( Character . toUpperCase ( name . charAt ( i ) ) ) ; else buff . append ( name . charAt ( i ) ) ; } return buff . toString ( ) ; } public static Method getElementMethod ( Class classObj , String name ) throws NoSuchMethodException , SecurityException , TransformerException { Method bestMethod = null ; Method [ ] methods = classObj . getMethods ( ) ; int nMethods = methods . length ; int bestScoreCount = 0 ; for ( int i = 0 ; i < nMethods ; i ++ ) { Method method = methods [ i ] ; if ( method . getName ( ) . equals ( name ) ) { Class [ ] paramTypes = method . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) ) { if ( ++ bestScoreCount == 1 ) bestMethod = method ; else break ; } } } if ( null == bestMethod ) { throw new NoSuchMethodException ( errString ( "element" , "method" , classObj , name , 0 , null ) ) ; } else if ( bestScoreCount > 1 ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_MORE_MATCH_ELEMENT , new Object [ ] { name } ) ) ; return bestMethod ; } public static void convertParams ( Object [ ] argsIn , Object [ ] [ ] argsOut , Class [ ] paramTypes , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { if ( paramTypes == null ) argsOut [ 0 ] = null ; else { int nParams = paramTypes . length ; argsOut [ 0 ] = new Object [ nParams ] ; int paramIndex = 0 ; if ( ( nParams > 0 ) && ExpressionContext . class . isAssignableFrom ( paramTypes [ 0 ] ) ) { argsOut [ 0 ] [ 0 ] = exprContext ; paramIndex ++ ; } if ( argsIn != null ) { for ( int i = argsIn . length - nParams + paramIndex ; paramIndex < nParams ; i ++ , paramIndex ++ ) { argsOut [ 0 ] [ paramIndex ] = convert ( argsIn [ i ] , paramTypes [ paramIndex ] ) ; } } } } static class ConversionInfo { ConversionInfo ( Class cl , int score ) { m_class = cl ; m_score = score ; } Class m_class ; int m_score ; } private static final int SCOREBASE = 1 ; static ConversionInfo [ ] m_javaObjConversions = { new ConversionInfo ( Double . TYPE , 11 ) , new ConversionInfo ( Float . TYPE , 12 ) , new ConversionInfo ( Long . TYPE , 13 ) , new ConversionInfo ( Integer . TYPE , 14 ) , new ConversionInfo ( Short . TYPE , 15 ) , new ConversionInfo ( Character . TYPE , 16 ) , new ConversionInfo ( Byte . TYPE , 17 ) , new ConversionInfo ( java . lang . String . class , 18 ) } ; static ConversionInfo [ ] m_booleanConversions = { new ConversionInfo ( Boolean . TYPE , 0 ) , new ConversionInfo ( java . lang . Boolean . class , 1 ) , new ConversionInfo ( java . lang . Object . class , 2 ) , new ConversionInfo ( java . lang . String . class , 3 ) } ; static ConversionInfo [ ] m_numberConversions = { new ConversionInfo ( Double . TYPE , 0 ) , new ConversionInfo ( java . lang . Double . class , 1 ) , new ConversionInfo ( Float . TYPE , 3 ) , new ConversionInfo ( Long . TYPE , 4 ) , new ConversionInfo ( Integer . TYPE , 5 ) , new ConversionInfo ( Short . TYPE , 6 ) , new ConversionInfo ( Character . TYPE , 7 ) , new ConversionInfo ( Byte . TYPE , 8 ) , new ConversionInfo ( Boolean . TYPE , 9 ) , new ConversionInfo ( java . lang . String . class , 10 ) , new ConversionInfo ( java . lang . Object . class , 11 ) } ; static ConversionInfo [ ] m_stringConversions = { new ConversionInfo ( java . lang . String . class , 0 ) , new ConversionInfo ( java . lang . Object . class , 1 ) , new ConversionInfo ( Character . TYPE , 2 ) , new ConversionInfo ( Double . TYPE , 3 ) , new ConversionInfo ( Float . TYPE , 3 ) , new ConversionInfo ( Long . TYPE , 3 ) , new ConversionInfo ( Integer . TYPE , 3 ) , new ConversionInfo ( Short . TYPE , 3 ) , new ConversionInfo ( Byte . TYPE , 3 ) , new ConversionInfo ( Boolean . TYPE , 4 ) } ; static ConversionInfo [ ] m_rtfConversions = { new ConversionInfo ( org . w3c . dom . traversal . NodeIterator . class , 0 ) , new ConversionInfo ( org . w3c . dom . NodeList . class , 1 ) , new ConversionInfo ( org . w3c . dom . Node . class , 2 ) , new ConversionInfo ( java . lang . String . class , 3 ) , new ConversionInfo ( java . lang . Object . class , 5 ) , new ConversionInfo ( Character . TYPE , 6 ) , new ConversionInfo ( Double . TYPE , 7 ) , new ConversionInfo ( Float . TYPE , 7 ) , new ConversionInfo ( Long . TYPE , 7 ) , new ConversionInfo ( Integer . TYPE , 7 ) , new ConversionInfo ( Short . TYPE , 7 ) , new ConversionInfo ( Byte . TYPE , 7 ) , new ConversionInfo ( Boolean . TYPE , 8 ) } ; static ConversionInfo [ ] m_nodesetConversions = { new ConversionInfo ( org . w3c . dom . traversal . NodeIterator . class , 0 ) , new ConversionInfo ( org . w3c . dom . NodeList . class , 1 ) , new ConversionInfo ( org . w3c . dom . Node . class , 2 ) , new ConversionInfo ( java . lang . String . class , 3 ) , new ConversionInfo ( java . lang . Object . class , 5 ) , new ConversionInfo ( Character . TYPE , 6 ) , new ConversionInfo ( Double . TYPE , 7 ) , new ConversionInfo ( Float . TYPE , 7 ) , new ConversionInfo ( Long . TYPE , 7 ) , new ConversionInfo ( Integer . TYPE , 7 ) , new ConversionInfo ( Short . TYPE , 7 ) , new ConversionInfo ( Byte . TYPE , 7 ) , new ConversionInfo ( Boolean . TYPE , 8 ) } ; static ConversionInfo [ ] [ ] m_conversions = { m_javaObjConversions , m_booleanConversions , m_numberConversions , m_stringConversions , m_nodesetConversions , m_rtfConversions } ; public static int scoreMatch ( Class [ ] javaParamTypes , int javaParamsStart , Object [ ] xsltArgs , int score ) { if ( ( xsltArgs == null ) || ( javaParamTypes == null ) ) return score ; int nParams = xsltArgs . length ; for ( int i = nParams - javaParamTypes . length + javaParamsStart , javaParamTypesIndex = javaParamsStart ; i < nParams ; i ++ , javaParamTypesIndex ++ ) { Object xsltObj = xsltArgs [ i ] ; int xsltClassType = ( xsltObj instanceof XObject ) ? ( ( XObject ) xsltObj ) . getType ( ) : XObject . CLASS_UNKNOWN ; Class javaClass = javaParamTypes [ javaParamTypesIndex ] ; if ( xsltClassType == XObject . CLASS_NULL ) { if ( ! javaClass . isPrimitive ( ) ) { score += 10 ; continue ; } else return - 1 ; } ConversionInfo [ ] convInfo = m_conversions [ xsltClassType ] ; int nConversions = convInfo . length ; int k ; for ( k = 0 ; k < nConversions ; k ++ ) { ConversionInfo cinfo = convInfo [ k ] ; if ( javaClass . isAssignableFrom ( cinfo . m_class ) ) { score += cinfo . m_score ; break ; } } if ( k == nConversions ) { if ( XObject . CLASS_UNKNOWN == xsltClassType ) { Class realClass = null ; if ( xsltObj instanceof XObject ) { Object realObj = ( ( XObject ) xsltObj ) . object ( ) ; if ( null != realObj ) { realClass = realObj . getClass ( ) ; } else { score += 10 ; continue ; } } else { realClass = xsltObj . getClass ( ) ; } if ( javaClass . isAssignableFrom ( realClass ) ) { score += 0 ; } else return - 1 ; } else return - 1 ; } } return score ; } static Object convert ( Object xsltObj , Class javaClass ) throws javax . xml . transform . TransformerException { if ( xsltObj instanceof XObject ) { XObject xobj = ( ( XObject ) xsltObj ) ; int xsltClassType = xobj . getType ( ) ; switch ( xsltClassType ) { case XObject . CLASS_NULL : return null ; case XObject . CLASS_BOOLEAN : { if ( javaClass == java . lang . String . class ) return xobj . str ( ) ; else return new Boolean ( xobj . bool ( ) ) ; } case XObject . CLASS_NUMBER : { if ( javaClass == java . lang . String . class ) return xobj . str ( ) ; else if ( javaClass == Boolean . TYPE ) return new Boolean ( xobj . bool ( ) ) ; else { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } } case XObject . CLASS_STRING : { if ( ( javaClass == java . lang . String . class ) || ( javaClass == java . lang . Object . class ) ) return xobj . str ( ) ; else if ( javaClass == Character . TYPE ) { String str = xobj . str ( ) ; if ( str . length ( ) > 0 ) return new Character ( str . charAt ( 0 ) ) ; else return null ; } else if ( javaClass == Boolean . TYPE ) return new Boolean ( xobj . bool ( ) ) ; else { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } } case XObject . CLASS_RTREEFRAG : { if ( ( javaClass == NodeIterator . class ) || ( javaClass == java . lang . Object . class ) ) { DTMIterator dtmIter = ( ( XRTreeFrag ) xobj ) . asNodeIterator ( ) ; return new DTMNodeIterator ( dtmIter ) ; } else if ( javaClass == NodeList . class ) { return ( ( XRTreeFrag ) xobj ) . convertToNodeset ( ) ; } else if ( javaClass == Node . class ) { DTMIterator iter = ( ( XRTreeFrag ) xobj ) . asNodeIterator ( ) ; int rootHandle = iter . nextNode ( ) ; DTM dtm = iter . getDTM ( rootHandle ) ; return dtm . getNode ( dtm . getFirstChild ( rootHandle ) ) ; } else if ( javaClass == java . lang . String . class ) { return xobj . str ( ) ; } else if ( javaClass == Boolean . TYPE ) { return new Boolean ( xobj . bool ( ) ) ; } else if ( javaClass . isPrimitive ( ) ) { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } else { DTMIterator iter = ( ( XRTreeFrag ) xobj ) . asNodeIterator ( ) ; int rootHandle = iter . nextNode ( ) ; DTM dtm = iter . getDTM ( rootHandle ) ; Node child = dtm . getNode ( dtm . getFirstChild ( rootHandle ) ) ; if ( javaClass . isAssignableFrom ( child . getClass ( ) ) ) return child ; else return null ; } } case XObject . CLASS_NODESET : { if ( ( javaClass == NodeIterator . class ) || ( javaClass == java . lang . Object . class ) ) { return xobj . nodeset ( ) ; } else if ( javaClass == NodeList . class ) { return xobj . nodelist ( ) ; } else if ( javaClass == Node . class ) { DTMIterator ni = xobj . iter ( ) ; int handle = ni . nextNode ( ) ; return ni . getDTM ( handle ) . getNode ( handle ) ; } else if ( javaClass == java . lang . String . class ) { return xobj . str ( ) ; } else if ( javaClass == Boolean . TYPE ) { return new Boolean ( xobj . bool ( ) ) ; } else if ( javaClass . isPrimitive ( ) ) { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } else { DTMIterator iter = xobj . iter ( ) ; int childHandle = iter . nextNode ( ) ; DTM dtm = iter . getDTM ( childHandle ) ; Node child = dtm . getNode ( childHandle ) ; if ( javaClass . isAssignableFrom ( child . getClass ( ) ) ) return child ; else return null ; } } } xsltObj = xobj . object ( ) ; } if ( null != xsltObj ) { if ( javaClass == java . lang . String . class ) { return xsltObj . toString ( ) ; } else if ( javaClass . isPrimitive ( ) ) { XString xstr = new XString ( xsltObj . toString ( ) ) ; double num = xstr . num ( ) ; return convertDoubleToNumber ( num , javaClass ) ; } else if ( javaClass == java . lang . Class . class ) { return xsltObj . getClass ( ) ; } else { return xsltObj ; } } else { return xsltObj ; } } static Object convertDoubleToNumber ( double num , Class javaClass ) { if ( ( javaClass == Double . TYPE ) || ( javaClass == java . lang . Double . class ) ) return new Double ( num ) ; else if ( javaClass == Float . TYPE ) return new Float ( num ) ; else if ( javaClass == Long . TYPE ) { return new Long ( ( long ) num ) ; } else if ( javaClass == Integer . TYPE ) { return new Integer ( ( int ) num ) ; } else if ( javaClass == Short . TYPE ) { return new Short ( ( short ) num ) ; } else if ( javaClass == Character . TYPE ) { return new Character ( ( char ) num ) ; } else if ( javaClass == Byte . TYPE ) { return new Byte ( ( byte ) num ) ; } else { return new Double ( num ) ; } } private static String errString ( String callType , String searchType , Class classObj , String funcName , int searchMethod , Object [ ] xsltArgs ) { String resultString = "For extension " + callType + ", could not find " + searchType + " " ; switch ( searchMethod ) { case STATIC_ONLY : return resultString + "static " + classObj . getName ( ) + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ")." ; case INSTANCE_ONLY : return resultString + classObj . getName ( ) + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ")." ; case STATIC_AND_INSTANCE : return resultString + classObj . getName ( ) + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ").\n" + "Checked both static and instance methods." ; case DYNAMIC : return resultString + "static " + classObj . getName ( ) + "." + funcName + "([ExpressionContext, ]" + errArgs ( xsltArgs , 0 ) + ") nor\n" + classObj + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 1 ) + ")." ; default : if ( callType . equals ( "function" ) ) { return resultString + classObj . getName ( ) + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ")." ; } else { return resultString + classObj . getName ( ) + "." + funcName + "(org.apache.xalan.extensions.XSLProcessorContext, " + "org.apache.xalan.templates.ElemExtensionCall)." ; } } } private static String errArgs ( Object [ ] xsltArgs , int startingArg ) { StringBuffer returnArgs = new StringBuffer ( ) ; for ( int i = startingArg ; i < xsltArgs . length ; i ++ ) { if ( i != startingArg ) returnArgs . append ( ", " ) ; if ( xsltArgs [ i ] instanceof XObject ) returnArgs . append ( ( ( XObject ) xsltArgs [ i ] ) . getTypeString ( ) ) ; else returnArgs . append ( xsltArgs [ i ] . getClass ( ) . getName ( ) ) ; } return returnArgs . toString ( ) ; } } 	1	['13', '1', '0', '11', '70', '66', '2', '9', '6', '0.952898551', '1997', '0.043478261', '7', '0', '0.266666667', '0', '0', '150.8461538', '14', '3.2308', '1']
package org . apache . xalan . templates ; import org . apache . xml . dtm . DTM ; import org . xml . sax . * ; import org . apache . xpath . * ; import java . util . * ; import org . apache . xml . utils . QName ; import org . apache . xalan . trace . * ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . ResultTreeHandler ; import org . apache . xalan . transformer . ClonerToResultTree ; import javax . xml . transform . TransformerException ; public class ElemCopy extends ElemUse { public int getXSLToken ( ) { return Constants . ELEMNAME_COPY ; } public String getNodeName ( ) { return Constants . ELEMNAME_COPY_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; try { int sourceNode = xctxt . getCurrentNode ( ) ; xctxt . pushCurrentNode ( sourceNode ) ; DTM dtm = xctxt . getDTM ( sourceNode ) ; short nodeType = dtm . getNodeType ( sourceNode ) ; if ( ( DTM . DOCUMENT_NODE != nodeType ) && ( DTM . DOCUMENT_FRAGMENT_NODE != nodeType ) ) { ResultTreeHandler rthandler = transformer . getResultTreeHandler ( ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; ClonerToResultTree . cloneToResultTree ( sourceNode , nodeType , dtm , rthandler , false ) ; if ( DTM . ELEMENT_NODE == nodeType ) { super . execute ( transformer ) ; rthandler . processNSDecls ( sourceNode , nodeType , dtm ) ; transformer . executeChildTemplates ( this , true ) ; String ns = dtm . getNamespaceURI ( sourceNode ) ; String localName = dtm . getLocalName ( sourceNode ) ; transformer . getResultTreeHandler ( ) . endElement ( ns , localName , dtm . getNodeName ( sourceNode ) ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } else { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; super . execute ( transformer ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { xctxt . popCurrentNode ( ) ; } } } 	0	['4', '4', '0', '8', '24', '6', '0', '8', '4', '2', '121', '0', '0', '0.985365854', '0.625', '2', '4', '29.25', '1', '0.75', '0']
package org . apache . xalan . templates ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . ExpandedNameTable ; import org . xml . sax . * ; import org . apache . xpath . * ; import org . apache . xpath . Expression ; import org . apache . xpath . axes . ContextNodeList ; import org . apache . xpath . objects . XObject ; import java . util . Vector ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . NodeSorter ; import org . apache . xalan . transformer . ResultTreeHandler ; import org . apache . xalan . transformer . ClonerToResultTree ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xpath . ExpressionOwner ; public class ElemForEach extends ElemTemplateElement implements ExpressionOwner { static final boolean DEBUG = false ; public boolean m_doc_cache_off = false ; public ElemForEach ( ) { } protected Expression m_selectExpression = null ; public void setSelect ( XPath xpath ) { m_selectExpression = xpath . getExpression ( ) ; } public Expression getSelect ( ) { return m_selectExpression ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; int length = getSortElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { getSortElem ( i ) . compose ( sroot ) ; } java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_selectExpression ) m_selectExpression . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; else { m_selectExpression = getStylesheetRoot ( ) . m_selectDefault . getExpression ( ) ; } } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { int length = getSortElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { getSortElem ( i ) . endCompose ( sroot ) ; } super . endCompose ( sroot ) ; } protected Vector m_sortElems = null ; public int getSortElemCount ( ) { return ( m_sortElems == null ) ? 0 : m_sortElems . size ( ) ; } public ElemSort getSortElem ( int i ) { return ( ElemSort ) m_sortElems . elementAt ( i ) ; } public void setSortElem ( ElemSort sortElem ) { if ( null == m_sortElems ) m_sortElems = new Vector ( ) ; m_sortElems . addElement ( sortElem ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_FOREACH ; } public String getNodeName ( ) { return Constants . ELEMNAME_FOREACH_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { transformer . pushCurrentTemplateRuleIsNull ( true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { transformSelectedNodes ( transformer ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; transformer . popCurrentTemplateRuleIsNull ( ) ; } } protected ElemTemplateElement getTemplateMatch ( ) { return this ; } public DTMIterator sortNodes ( XPathContext xctxt , Vector keys , DTMIterator sourceNodes ) throws TransformerException { NodeSorter sorter = new NodeSorter ( xctxt ) ; sourceNodes . setShouldCacheNodes ( true ) ; sourceNodes . runTo ( - 1 ) ; xctxt . pushContextNodeList ( sourceNodes ) ; try { sorter . sort ( sourceNodes , keys , xctxt ) ; sourceNodes . setCurrentPos ( 0 ) ; } finally { xctxt . popContextNodeList ( ) ; } return sourceNodes ; } public void transformSelectedNodes ( TransformerImpl transformer ) throws TransformerException { final XPathContext xctxt = transformer . getXPathContext ( ) ; final int sourceNode = xctxt . getCurrentNode ( ) ; DTMIterator sourceNodes = m_selectExpression . asIterator ( xctxt , sourceNode ) ; try { final Vector keys = ( m_sortElems == null ) ? null : transformer . processSortKeys ( this , sourceNode ) ; if ( null != keys ) sourceNodes = sortNodes ( xctxt , keys , sourceNodes ) ; if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; } final ResultTreeHandler rth = transformer . getResultTreeHandler ( ) ; ContentHandler chandler = rth . getContentHandler ( ) ; xctxt . pushCurrentNode ( DTM . NULL ) ; int [ ] currentNodes = xctxt . getCurrentNodeStack ( ) ; int currentNodePos = xctxt . getCurrentNodeFirstFree ( ) - 1 ; xctxt . pushCurrentExpressionNode ( DTM . NULL ) ; int [ ] currentExpressionNodes = xctxt . getCurrentExpressionNodeStack ( ) ; int currentExpressionNodePos = xctxt . getCurrentExpressionNodesFirstFree ( ) - 1 ; xctxt . pushSAXLocatorNull ( ) ; xctxt . pushContextNodeList ( sourceNodes ) ; transformer . pushElemTemplateElement ( null ) ; DTM dtm = xctxt . getDTM ( sourceNode ) ; int docID = sourceNode & DTMManager . IDENT_DTM_DEFAULT ; int child ; while ( DTM . NULL != ( child = sourceNodes . nextNode ( ) ) ) { currentNodes [ currentNodePos ] = child ; currentExpressionNodes [ currentExpressionNodePos ] = child ; if ( ( child & DTMManager . IDENT_DTM_DEFAULT ) != docID ) { dtm = xctxt . getDTM ( child ) ; docID = sourceNode & DTMManager . IDENT_DTM_DEFAULT ; } final int nodeType = dtm . getNodeType ( child ) ; if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; } for ( ElemTemplateElement t = this . m_firstChild ; t != null ; t = t . m_nextSibling ) { xctxt . setSAXLocator ( t ) ; transformer . setCurrentElement ( t ) ; t . execute ( transformer ) ; } if ( TransformerImpl . S_DEBUG ) { transformer . setCurrentElement ( null ) ; transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } if ( m_doc_cache_off ) { if ( DEBUG ) System . out . println ( "JJK***** CACHE RELEASE *****\n" + "\tdtm=" + dtm . getDocumentBaseURI ( ) ) ; xctxt . getSourceTreeManager ( ) . removeDocumentFromCache ( dtm . getDocument ( ) ) ; xctxt . release ( dtm , false ) ; } } } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEndEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; xctxt . popSAXLocator ( ) ; xctxt . popContextNodeList ( ) ; transformer . popElemTemplateElement ( ) ; xctxt . popCurrentExpressionNode ( ) ; xctxt . popCurrentNode ( ) ; sourceNodes . detach ( ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; if ( Constants . ELEMNAME_SORT == type ) { setSortElem ( ( ElemSort ) newChild ) ; return newChild ; } else return super . appendChild ( newChild ) ; } public void callChildVisitors ( XSLTVisitor visitor , boolean callAttributes ) { if ( callAttributes && ( null != m_selectExpression ) ) m_selectExpression . callVisitors ( this , visitor ) ; int length = getSortElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { getSortElem ( i ) . callVisitors ( visitor ) ; } super . callChildVisitors ( visitor , callAttributes ) ; } public Expression getExpression ( ) { return m_selectExpression ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_selectExpression = exp ; } } 	1	['18', '3', '1', '25', '83', '79', '6', '21', '17', '0.735294118', '492', '0.5', '1', '0.920187793', '0.136752137', '2', '6', '26.11111111', '4', '1.2778', '2']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . NodeIterator ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; public class StepIterator extends NodeIteratorBase { protected NodeIterator _source ; protected NodeIterator _iterator ; private int _pos = - 1 ; public StepIterator ( NodeIterator source , NodeIterator iterator ) { _source = source ; _iterator = iterator ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; _iterator . setRestartable ( true ) ; } public NodeIterator cloneIterator ( ) { try { final StepIterator clone = ( StepIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _iterator = _iterator . cloneIterator ( ) ; clone . setRestartable ( false ) ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; _iterator . setStartNode ( _includeSelf ? _startNode : _source . next ( ) ) ; return resetPosition ( ) ; } return this ; } public NodeIterator reset ( ) { _source . reset ( ) ; _iterator . setStartNode ( _includeSelf ? _startNode : _source . next ( ) ) ; return resetPosition ( ) ; } public int next ( ) { for ( int node ; ; ) { if ( ( node = _iterator . next ( ) ) != END ) { return returnNode ( node ) ; } else if ( ( node = _source . next ( ) ) == END ) { return END ; } else { _iterator . setStartNode ( node ) ; } } } public void setMark ( ) { _source . setMark ( ) ; _iterator . setMark ( ) ; _pos = _position ; } public void gotoMark ( ) { _source . gotoMark ( ) ; _iterator . gotoMark ( ) ; _position = _pos ; } } 	0	['8', '2', '1', '4', '21', '0', '2', '3', '8', '0.238095238', '157', '1', '2', '0.588235294', '0.34375', '1', '5', '18.25', '3', '1.5', '0']
package org . apache . xalan . extensions ; import java . util . Vector ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . io . IOException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . QName ; import org . apache . xpath . objects . XObject ; import javax . xml . transform . TransformerException ; public class ExtensionHandlerJavaClass extends ExtensionHandlerJava { private Class m_classObj = null ; private Object m_defaultInstance = null ; public ExtensionHandlerJavaClass ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang , className ) ; try { m_classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { } } public boolean isFunctionAvailable ( String function ) { Method [ ] methods = m_classObj . getMethods ( ) ; int nMethods = methods . length ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( function ) ) return true ; } return false ; } public boolean isElementAvailable ( String element ) { Method [ ] methods = m_classObj . getMethods ( ) ; int nMethods = methods . length ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( element ) ) { Class [ ] paramTypes = methods [ i ] . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) ) { return true ; } } } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { Object [ ] methodArgs ; Object [ ] [ ] convertedArgs ; Class [ ] paramTypes ; try { if ( funcName . equals ( "new" ) ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Constructor c = ( Constructor ) getFromCache ( methodKey , null , methodArgs ) ; if ( c != null ) { try { paramTypes = c . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } catch ( Exception e ) { } } c = MethodResolver . getConstructor ( m_classObj , methodArgs , convertedArgs , exprContext ) ; putToCache ( methodKey , null , methodArgs , c ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } else { int resolveType ; Object targetObject = null ; methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Method m = ( Method ) getFromCache ( methodKey , null , methodArgs ) ; if ( m != null ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; if ( Modifier . isStatic ( m . getModifiers ( ) ) ) return m . invoke ( null , convertedArgs [ 0 ] ) ; else { int nTargetArgs = convertedArgs [ 0 ] . length ; if ( ExpressionContext . class . isAssignableFrom ( paramTypes [ 0 ] ) ) nTargetArgs -- ; if ( methodArgs . length <= nTargetArgs ) return m . invoke ( m_defaultInstance , convertedArgs [ 0 ] ) ; else { targetObject = methodArgs [ 0 ] ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } } } catch ( Exception e ) { } } if ( args . size ( ) > 0 ) { targetObject = methodArgs [ 0 ] ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; if ( m_classObj . isAssignableFrom ( targetObject . getClass ( ) ) ) resolveType = MethodResolver . DYNAMIC ; else resolveType = MethodResolver . STATIC_AND_INSTANCE ; } else { targetObject = null ; resolveType = MethodResolver . STATIC_AND_INSTANCE ; } m = MethodResolver . getMethod ( m_classObj , funcName , methodArgs , convertedArgs , exprContext , resolveType ) ; putToCache ( methodKey , null , methodArgs , m ) ; if ( MethodResolver . DYNAMIC == resolveType ) return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; else { if ( Modifier . isStatic ( m . getModifiers ( ) ) ) return m . invoke ( null , convertedArgs [ 0 ] ) ; else { if ( null == m_defaultInstance ) { m_defaultInstance = m_classObj . newInstance ( ) ; } return m . invoke ( m_defaultInstance , convertedArgs [ 0 ] ) ; } } } } catch ( InvocationTargetException ite ) { Throwable realException = ite . getTargetException ( ) ; if ( realException instanceof Exception ) throw new TransformerException ( ( Exception ) realException ) ; else throw new TransformerException ( ite ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; Method m = ( Method ) getFromCache ( methodKey , null , null ) ; if ( null == m ) { try { m = MethodResolver . getElementMethod ( m_classObj , localPart ) ; if ( ( null == m_defaultInstance ) && ! Modifier . isStatic ( m . getModifiers ( ) ) ) m_defaultInstance = m_classObj . newInstance ( ) ; } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , e ) ; } putToCache ( methodKey , null , null , m ) ; } XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { result = m . invoke ( m_defaultInstance , new Object [ ] { xpc , element } ) ; } catch ( InvocationTargetException e ) { Throwable targetException = e . getTargetException ( ) ; if ( targetException != null ) throw new TransformerException ( targetException . getMessage ( ) , targetException ) ; else throw new TransformerException ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1	['6', '3', '0', '9', '37', '0', '0', '9', '5', '0.76', '505', '0.4', '0', '0.615384615', '0.375', '2', '6', '82.33333333', '8', '2.3333', '2']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . bcel . classfile . Field ; import org . apache . xalan . xsltc . compiler . util . * ; class StepPattern extends RelativePathPattern { private static final int NO_CONTEXT = 0 ; private static final int SIMPLE_CONTEXT = 1 ; private static final int GENERAL_CONTEXT = 2 ; protected final int _axis ; protected final int _nodeType ; protected Vector _predicates ; private Step _step = null ; private boolean _isEpsilon = false ; private int _contextCase ; public StepPattern ( int axis , int nodeType , Vector predicates ) { _axis = axis ; _nodeType = nodeType ; _predicates = predicates ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate exp = ( Predicate ) _predicates . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public int getNodeType ( ) { return _nodeType ; } public StepPattern getKernelPattern ( ) { return this ; } public boolean isWildcard ( ) { return _isEpsilon && hasPredicates ( ) == false ; } public StepPattern setPredicates ( Vector predicates ) { _predicates = predicates ; return ( this ) ; } protected boolean hasPredicates ( ) { return _predicates != null && _predicates . size ( ) > 0 ; } public double getDefaultPriority ( ) { if ( hasPredicates ( ) ) { return 0.5 ; } else { switch ( _nodeType ) { case - 1 : return - 0.5 ; case 0 : return 0.0 ; default : return ( _nodeType >= NodeTest . GTYPE ) ? 0.0 : - 0.5 ; } } } public void reduceKernelPattern ( ) { _isEpsilon = true ; } public String toString ( ) { final StringBuffer buffer = new StringBuffer ( "stepPattern(\"" ) ; buffer . append ( Axis . names [ _axis ] ) . append ( "\", " ) . append ( _isEpsilon ? ( "epsilon{" + Integer . toString ( _nodeType ) + "}" ) : Integer . toString ( _nodeType ) ) ; if ( _predicates != null ) buffer . append ( ", " ) . append ( _predicates . toString ( ) ) ; return buffer . append ( ')' ) . toString ( ) ; } private int analyzeCases ( ) { boolean noContext = true ; final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n && noContext ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; if ( pred . getExpr ( ) . hasPositionCall ( ) ) { noContext = false ; } } if ( noContext ) { return NO_CONTEXT ; } else if ( n == 1 ) { return SIMPLE_CONTEXT ; } return GENERAL_CONTEXT ; } private String getNextFieldName ( ) { return "__step_pattern_iter_" + getXSLTC ( ) . nextStepPatternSerial ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( hasPredicates ( ) ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } _contextCase = analyzeCases ( ) ; if ( _contextCase == SIMPLE_CONTEXT ) { _step = new Step ( _axis , _nodeType , null ) ; _step . setParser ( getParser ( ) ) ; _step . typeCheck ( stable ) ; } else if ( _contextCase == GENERAL_CONTEXT ) { final int len = _predicates . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) ( ( Predicate ) _predicates . elementAt ( i ) ) . dontOptimize ( ) ; _step = new Step ( _axis , _nodeType , _predicates ) ; _step . setParser ( getParser ( ) ) ; _step . typeCheck ( stable ) ; } } return _axis == Axis . CHILD ? Type . Element : Type . Attribute ; } private void translateKernel ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _nodeType == DOM . ELEMENT ) { final int check = cpg . addInterfaceMethodref ( DOM_INTF , "isElement" , "(I)Z" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( check , 2 ) ) ; final BranchHandle icmp = il . append ( new IFNE ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; icmp . setTarget ( il . append ( NOP ) ) ; } else if ( _nodeType == DOM . ATTRIBUTE ) { final int check = cpg . addInterfaceMethodref ( DOM_INTF , "isAttribute" , "(I)Z" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( check , 2 ) ) ; final BranchHandle icmp = il . append ( new IFNE ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; icmp . setTarget ( il . append ( NOP ) ) ; } else { final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getType" , "(I)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; il . append ( new PUSH ( cpg , _nodeType ) ) ; final BranchHandle icmp = il . append ( new IF_ICMPEQ ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; icmp . setTarget ( il . append ( NOP ) ) ; } } private void translateNoContext ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; if ( ! _isEpsilon ) { il . append ( methodGen . loadCurrentNode ( ) ) ; translateKernel ( classGen , methodGen ) ; } final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; Expression exp = pred . getExpr ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; _trueList . append ( exp . _trueList ) ; _falseList . append ( exp . _falseList ) ; } InstructionHandle restore ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchTrueList ( restore ) ; BranchHandle skipFalse = il . append ( new GOTO ( null ) ) ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchFalseList ( restore ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; skipFalse . setTarget ( il . append ( NOP ) ) ; } private void translateSimpleContext ( ClassGenerator classGen , MethodGenerator methodGen ) { int index ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; LocalVariableGen match ; match = methodGen . addLocalVariable ( "step_pattern_tmp1" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( match . getIndex ( ) ) ) ; if ( ! _isEpsilon ) { il . append ( new ILOAD ( match . getIndex ( ) ) ) ; translateKernel ( classGen , methodGen ) ; } il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; index = cpg . addMethodref ( MATCHING_ITERATOR , "<init>" , "(I" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( MATCHING_ITERATOR ) ) ) ; il . append ( DUP ) ; il . append ( new ILOAD ( match . getIndex ( ) ) ) ; _step . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( index ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( match . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; il . append ( methodGen . setStartNode ( ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( new ILOAD ( match . getIndex ( ) ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; Predicate pred = ( Predicate ) _predicates . elementAt ( 0 ) ; Expression exp = pred . getExpr ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; InstructionHandle restore = il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; exp . backPatchTrueList ( restore ) ; BranchHandle skipFalse = il . append ( new GOTO ( null ) ) ; restore = il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; exp . backPatchFalseList ( restore ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; skipFalse . setTarget ( il . append ( NOP ) ) ; } private void translateGeneralContext ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int iteratorIndex = 0 ; BranchHandle ifBlock = null ; LocalVariableGen iter , node , node2 ; final String iteratorName = getNextFieldName ( ) ; node = methodGen . addLocalVariable ( "step_pattern_tmp1" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( node . getIndex ( ) ) ) ; iter = methodGen . addLocalVariable ( "step_pattern_tmp2" , Util . getJCRefType ( NODE_ITERATOR_SIG ) , il . getEnd ( ) , null ) ; if ( ! classGen . isExternal ( ) ) { final Field iterator = new Field ( ACC_PRIVATE , cpg . addUtf8 ( iteratorName ) , cpg . addUtf8 ( NODE_ITERATOR_SIG ) , null , cpg . getConstantPool ( ) ) ; classGen . addField ( iterator ) ; iteratorIndex = cpg . addFieldref ( classGen . getClassName ( ) , iteratorName , NODE_ITERATOR_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( iteratorIndex ) ) ; il . append ( DUP ) ; il . append ( new ASTORE ( iter . getIndex ( ) ) ) ; ifBlock = il . append ( new IFNONNULL ( null ) ) ; il . append ( classGen . loadTranslet ( ) ) ; } _step . translate ( classGen , methodGen ) ; il . append ( new ASTORE ( iter . getIndex ( ) ) ) ; if ( ! classGen . isExternal ( ) ) { il . append ( new ALOAD ( iter . getIndex ( ) ) ) ; il . append ( new PUTFIELD ( iteratorIndex ) ) ; ifBlock . setTarget ( il . append ( NOP ) ) ; } il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( node . getIndex ( ) ) ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; il . append ( new ALOAD ( iter . getIndex ( ) ) ) ; il . append ( SWAP ) ; il . append ( methodGen . setStartNode ( ) ) ; BranchHandle skipNext ; InstructionHandle begin , next ; node2 = methodGen . addLocalVariable ( "step_pattern_tmp3" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) , null ) ; skipNext = il . append ( new GOTO ( null ) ) ; next = il . append ( new ALOAD ( iter . getIndex ( ) ) ) ; begin = il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( new ISTORE ( node2 . getIndex ( ) ) ) ; _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; il . append ( new ILOAD ( node2 . getIndex ( ) ) ) ; il . append ( new ILOAD ( node . getIndex ( ) ) ) ; il . append ( new IF_ICMPLT ( next ) ) ; il . append ( new ILOAD ( node2 . getIndex ( ) ) ) ; il . append ( new ILOAD ( node . getIndex ( ) ) ) ; _falseList . add ( il . append ( new IF_ICMPNE ( null ) ) ) ; skipNext . setTarget ( begin ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( hasPredicates ( ) ) { switch ( _contextCase ) { case NO_CONTEXT : translateNoContext ( classGen , methodGen ) ; break ; case SIMPLE_CONTEXT : translateSimpleContext ( classGen , methodGen ) ; break ; default : translateGeneralContext ( classGen , methodGen ) ; break ; } } else if ( isWildcard ( ) ) { il . append ( POP ) ; } else { translateKernel ( classGen , methodGen ) ; } } } 	0	['18', '6', '1', '57', '94', '31', '9', '49', '11', '0.810457516', '1125', '1', '1', '0.853448276', '0.261904762', '3', '8', '61', '6', '2.6111', '0']
package org . apache . xalan . xsltc . dom ; import java . util . Vector ; import java . util . StringTokenizer ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . NodeIterator ; import org . apache . xalan . xsltc . runtime . Hashtable ; public class KeyIndex implements NodeIterator { private Hashtable _index = new Hashtable ( ) ; private BitArray _nodes = null ; private int _pos = 0 ; private int _mark = 0 ; private int _save = 0 ; private int _start = 0 ; private int _arraySize = 0 ; private int _node = - 1 ; public KeyIndex ( int size ) { _arraySize = size ; } public void setRestartable ( boolean flag ) { } public void add ( Object value , int node ) { if ( ( _nodes = ( BitArray ) _index . get ( value ) ) == null ) { _nodes = new BitArray ( _arraySize ) ; _nodes . setMask ( node & 0xff000000 ) ; _index . put ( value , _nodes ) ; } _nodes . setBit ( node & 0x00ffffff ) ; } public void merge ( KeyIndex other ) { if ( other != null ) { if ( other . _nodes != null ) { if ( _nodes == null ) _nodes = other . _nodes ; else _nodes = _nodes . merge ( other . _nodes ) ; } } } public void lookupId ( Object value ) { if ( value instanceof String ) { final String string = ( String ) value ; if ( string . indexOf ( ' ' ) > - 1 ) { StringTokenizer values = new StringTokenizer ( string ) ; while ( values . hasMoreElements ( ) ) { BitArray nodes = ( BitArray ) _index . get ( values . nextElement ( ) ) ; if ( nodes != null ) { if ( _nodes == null ) _nodes = nodes ; else _nodes = _nodes . merge ( nodes ) ; } } return ; } } _nodes = ( BitArray ) _index . get ( value ) ; } public void lookupKey ( Object value ) { _nodes = ( BitArray ) _index . get ( value ) ; } public int next ( ) { if ( _nodes == null ) return ( END ) ; if ( ( _node = _nodes . getNextBit ( ++ _node ) ) == END ) return ( END ) ; _pos ++ ; return ( _node | _nodes . getMask ( ) ) ; } public int containsID ( int node , Object value ) { if ( value instanceof String ) { final String string = ( String ) value ; if ( string . indexOf ( ' ' ) > - 1 ) { StringTokenizer values = new StringTokenizer ( string ) ; while ( values . hasMoreElements ( ) ) { BitArray nodes = ( BitArray ) _index . get ( values . nextElement ( ) ) ; if ( ( nodes != null ) && ( nodes . getBit ( node ) ) ) return ( 1 ) ; } return ( 0 ) ; } } BitArray nodes = ( BitArray ) _index . get ( value ) ; if ( ( nodes != null ) && ( nodes . getBit ( node ) ) ) return ( 1 ) ; return ( 0 ) ; } public int containsKey ( int node , Object value ) { BitArray nodes = ( BitArray ) _index . get ( value ) ; if ( ( nodes != null ) && ( nodes . getBit ( node ) ) ) return ( 1 ) ; return ( 0 ) ; } public NodeIterator reset ( ) { _pos = _start ; _node = _start - 1 ; return ( this ) ; } public int getLast ( ) { if ( _nodes == null ) return ( 0 ) ; else return ( _nodes . size ( ) ) ; } public int getPosition ( ) { return ( _pos ) ; } public void setMark ( ) { _mark = _pos ; _save = _node ; } public void gotoMark ( ) { _pos = _mark ; _node = _save ; } public NodeIterator setStartNode ( int start ) { if ( start == END ) { _nodes = null ; } else if ( _nodes != null ) { _start = _nodes . getBitNumber ( start - 1 ) ; _node = _start - 1 ; } return ( ( NodeIterator ) this ) ; } public boolean isReverse ( ) { return ( false ) ; } public NodeIterator cloneIterator ( ) { KeyIndex other = new KeyIndex ( _arraySize ) ; other . _index = _index ; other . _nodes = _nodes . cloneArray ( ) ; other . _pos = _pos ; other . _start = _start ; other . _node = _node ; return ( other ) ; } } 	1	['17', '1', '0', '5', '35', '0', '2', '3', '17', '0.7109375', '375', '1', '2', '0', '0.341176471', '0', '0', '20.58823529', '6', '2.1176', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class NumberCall extends FunctionCall { public NumberCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argumentCount ( ) > 0 ) { argument ( ) . typeCheck ( stable ) ; } return _type = Type . Real ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; Type targ ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; targ = Type . Node ; } else { final Expression arg = argument ( ) ; arg . translate ( classGen , methodGen ) ; arg . startResetIterator ( classGen , methodGen ) ; targ = arg . getType ( ) ; } if ( ! targ . identicalTo ( Type . Real ) ) { targ . translateTo ( classGen , methodGen , Type . Real ) ; } } } 	0	['3', '4', '0', '12', '15', '3', '0', '12', '3', '2', '59', '0', '0', '0.979591837', '0.444444444', '3', '13', '18.66666667', '3', '1.3333', '0']
package org . apache . xalan . extensions ; import java . util . Vector ; import java . lang . reflect . Method ; import java . io . IOException ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . QName ; import org . apache . xalan . transformer . TransformerImpl ; public abstract class ExtensionHandler { protected String m_namespaceUri ; protected String m_scriptLang ; private static final Object NO_OBJS [ ] = new Object [ 0 ] ; private static Method getCCL ; static { try { getCCL = Thread . class . getMethod ( "getContextClassLoader" , new Class [ 0 ] ) ; } catch ( Exception e ) { getCCL = null ; } } public static Class getClassForName ( String className ) throws ClassNotFoundException { Class result = null ; if ( className . equals ( "org.apache.xalan.xslt.extensions.Redirect" ) ) className = "org.apache.xalan.lib.Redirect" ; if ( getCCL != null ) { try { ClassLoader contextClassLoader = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; result = contextClassLoader . loadClass ( className ) ; } catch ( ClassNotFoundException cnfe ) { result = Class . forName ( className ) ; } catch ( Exception e ) { getCCL = null ; result = Class . forName ( className ) ; } } else result = Class . forName ( className ) ; return result ; } protected ExtensionHandler ( String namespaceUri , String scriptLang ) { m_namespaceUri = namespaceUri ; m_scriptLang = scriptLang ; } public abstract boolean isFunctionAvailable ( String function ) ; public abstract boolean isElementAvailable ( String element ) ; public abstract Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException ; public abstract void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException ; } 	1	['8', '1', '3', '13', '17', '26', '9', '4', '5', '0.942857143', '91', '0.8', '0', '0', '0.339285714', '0', '0', '9.75', '1', '0.75', '1']
package org . apache . xalan . processor ; import org . apache . xalan . templates . NamespaceAlias ; import javax . xml . transform . TransformerException ; import org . xml . sax . Attributes ; class ProcessorNamespaceAlias extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { NamespaceAlias na = new NamespaceAlias ( handler . nextUid ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , na ) ; String prefix = na . getStylesheetPrefix ( ) ; if ( prefix . equals ( "#default" ) ) { prefix = "" ; na . setStylesheetPrefix ( prefix ) ; } String stylesheetNS = handler . getNamespaceForPrefix ( prefix ) ; na . setStylesheetNamespace ( stylesheetNS ) ; prefix = na . getResultPrefix ( ) ; if ( prefix . equals ( "#default" ) ) { prefix = "" ; na . setResultPrefix ( prefix ) ; } String resultNS = handler . getNamespaceForPrefix ( prefix ) ; na . setResultNamespace ( resultNS ) ; handler . getStylesheet ( ) . setNamespaceAlias ( na ) ; handler . getStylesheet ( ) . appendChild ( na ) ; } } 	0	['2', '4', '0', '6', '17', '1', '1', '5', '1', '2', '65', '0', '0', '0.995260664', '0.625', '3', '4', '31.5', '1', '0.5', '0']
package org . apache . xalan . templates ; import java . util . Vector ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . IOException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . functions . Function ; import org . apache . xpath . functions . Function2Args ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . SourceTreeManager ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xpath . XPathContext ; import org . apache . xalan . transformer . TransformerImpl ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import javax . xml . transform . TransformerException ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . XMLString ; public class FuncDocument extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocumentRoot ( context ) ; XObject arg = ( XObject ) this . getArg0 ( ) . execute ( xctxt ) ; String base = "" ; Expression arg1Expr = this . getArg1 ( ) ; if ( null != arg1Expr ) { XObject arg2 = arg1Expr . execute ( xctxt ) ; if ( XObject . CLASS_NODESET == arg2 . getType ( ) ) { int baseNode = arg2 . iter ( ) . nextNode ( ) ; if ( baseNode == DTM . NULL ) warn ( xctxt , XSLTErrorResources . WG_EMPTY_SECOND_ARG , null ) ; DTM baseDTM = xctxt . getDTM ( baseNode ) ; base = baseDTM . getDocumentBaseURI ( ) ; } else { base = arg2 . str ( ) ; } } else { assertion ( null != xctxt . getNamespaceContext ( ) , "Namespace context can not be null!" ) ; base = xctxt . getNamespaceContext ( ) . getBaseIdentifier ( ) ; } XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; NodeSetDTM mnl = nodes . mutableNodeset ( ) ; DTMIterator iterator = ( XObject . CLASS_NODESET == arg . getType ( ) ) ? arg . iter ( ) : null ; int pos = DTM . NULL ; while ( ( null == iterator ) || ( DTM . NULL != ( pos = iterator . nextNode ( ) ) ) ) { XMLString ref = ( null != iterator ) ? xctxt . getDTM ( pos ) . getStringValue ( pos ) : arg . xstr ( ) ; if ( null == arg1Expr && DTM . NULL != pos ) { DTM baseDTM = xctxt . getDTM ( pos ) ; base = baseDTM . getDocumentBaseURI ( ) ; } if ( null == ref ) continue ; if ( DTM . NULL == docContext ) { error ( xctxt , XSLTErrorResources . ER_NO_CONTEXT_OWNERDOC , null ) ; } int indexOfColon = ref . indexOf ( ':' ) ; int indexOfSlash = ref . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { base = null ; } int newDoc = getDoc ( xctxt , context , ref . toString ( ) , base ) ; if ( DTM . NULL != newDoc ) { if ( ! mnl . contains ( newDoc ) ) { mnl . addElement ( newDoc ) ; } } if ( null == iterator || newDoc == DTM . NULL ) break ; } return nodes ; } int getDoc ( XPathContext xctxt , int context , String uri , String base ) throws javax . xml . transform . TransformerException { SourceTreeManager treeMgr = xctxt . getSourceTreeManager ( ) ; Source source ; int newDoc ; try { source = treeMgr . resolveURI ( base , uri , xctxt . getSAXLocator ( ) ) ; newDoc = treeMgr . getNode ( source ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , ( SourceLocator ) xctxt . getSAXLocator ( ) , ioe ) ; } catch ( TransformerException te ) { throw new TransformerException ( te ) ; } if ( DTM . NULL != newDoc ) return newDoc ; if ( uri . length ( ) == 0 ) { uri = xctxt . getNamespaceContext ( ) . getBaseIdentifier ( ) ; try { source = treeMgr . resolveURI ( base , uri , xctxt . getSAXLocator ( ) ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , ( SourceLocator ) xctxt . getSAXLocator ( ) , ioe ) ; } } String diagnosticsString = null ; try { if ( ( null != uri ) && ( uri . toString ( ) . length ( ) > 0 ) ) { newDoc = treeMgr . getSourceTree ( source , xctxt . getSAXLocator ( ) , xctxt ) ; } else warn ( xctxt , XSLTErrorResources . WG_CANNOT_MAKE_URL_FROM , new Object [ ] { ( ( base == null ) ? "" : base ) + uri } ) ; } catch ( Throwable throwable ) { newDoc = DTM . NULL ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } if ( ( throwable instanceof NullPointerException ) || ( throwable instanceof ClassCastException ) ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ( Exception ) throwable ) ; } StringWriter sw = new StringWriter ( ) ; PrintWriter diagnosticsWriter = new PrintWriter ( sw ) ; if ( throwable instanceof TransformerException ) { TransformerException spe = ( TransformerException ) throwable ; { Throwable e = spe ; while ( null != e ) { if ( null != e . getMessage ( ) ) { diagnosticsWriter . println ( " (" + e . getClass ( ) . getName ( ) + "): " + e . getMessage ( ) ) ; } if ( e instanceof TransformerException ) { TransformerException spe2 = ( TransformerException ) e ; SourceLocator locator = spe2 . getLocator ( ) ; if ( ( null != locator ) && ( null != locator . getSystemId ( ) ) ) diagnosticsWriter . println ( "   ID: " + locator . getSystemId ( ) + " Line #" + locator . getLineNumber ( ) + " Column #" + locator . getColumnNumber ( ) ) ; e = spe2 . getException ( ) ; if ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } else e = null ; } } } else { diagnosticsWriter . println ( " (" + throwable . getClass ( ) . getName ( ) + "): " + throwable . getMessage ( ) ) ; } diagnosticsString = throwable . getMessage ( ) ; } if ( DTM . NULL == newDoc ) { if ( null != diagnosticsString ) { warn ( xctxt , XSLTErrorResources . WG_CANNOT_LOAD_REQUESTED_DOC , new Object [ ] { diagnosticsString } ) ; } else warn ( xctxt , XSLTErrorResources . WG_CANNOT_LOAD_REQUESTED_DOC , new Object [ ] { uri == null ? ( ( base == null ) ? "" : base ) + uri : uri . toString ( ) } ) ; } else { } return newDoc ; } public void error ( XPathContext xctxt , int msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; TransformerException spe = new TransformerException ( formattedMsg , ( SourceLocator ) xctxt . getSAXLocator ( ) ) ; if ( null != errHandler ) errHandler . error ( spe ) ; else System . out . println ( formattedMsg ) ; } public void warn ( XPathContext xctxt , int msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; TransformerException spe = new TransformerException ( formattedMsg , ( SourceLocator ) xctxt . getSAXLocator ( ) ) ; if ( null != errHandler ) errHandler . warning ( spe ) ; else System . out . println ( formattedMsg ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( ( argNum < 1 ) || ( argNum > 2 ) ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ONE_OR_TWO , null ) ) ; } public boolean isNodesetExpr ( ) { return true ; } } 	1	['8', '5', '0', '17', '66', '28', '1', '16', '6', '2', '543', '0', '0', '0.888888889', '0.475', '3', '8', '66.875', '1', '0.875', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . Vector ; import java . util . Hashtable ; public final class MultiHashtable extends Hashtable { public Object put ( Object key , Object value ) { Vector vector = ( Vector ) get ( key ) ; if ( vector == null ) super . put ( key , vector = new Vector ( ) ) ; vector . add ( value ) ; return vector ; } public Object maps ( Object from , Object to ) { if ( from == null ) return null ; final Vector vector = ( Vector ) get ( from ) ; if ( vector != null ) { final int n = vector . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Object item = vector . elementAt ( i ) ; if ( item . equals ( to ) ) { return item ; } } } return null ; } } 	0	['3', '3', '0', '2', '11', '3', '2', '0', '3', '2', '61', '0', '0', '0.95', '0.833333333', '1', '2', '19.33333333', '5', '2.3333', '0']
package org . apache . xalan . extensions ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . xml . utils . StringVector ; import org . apache . xpath . objects . XNull ; import org . apache . xpath . XPathProcessorException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . templates . TemplateList ; import org . apache . xpath . XPathContext ; import org . apache . xml . utils . QName ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class ExtensionsTable { public Hashtable m_extensionFunctionNamespaces = new Hashtable ( ) ; private StylesheetRoot m_sroot ; public ExtensionsTable ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { m_sroot = sroot ; Vector extensions = m_sroot . getExtensions ( ) ; for ( int i = 0 ; i < extensions . size ( ) ; i ++ ) { ExtensionNamespaceSupport extNamespaceSpt = ( ExtensionNamespaceSupport ) extensions . elementAt ( i ) ; ExtensionHandler extHandler = extNamespaceSpt . launch ( ) ; if ( extHandler != null ) addExtensionNamespace ( extNamespaceSpt . getNamespace ( ) , extHandler ) ; } } public ExtensionHandler get ( String extns ) { return ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( extns ) ; } public void addExtensionNamespace ( String uri , ExtensionHandler extNS ) { m_extensionFunctionNamespaces . put ( uri , extNS ) ; } public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException { boolean isAvailable = false ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( extNS != null ) isAvailable = extNS . isFunctionAvailable ( funcName ) ; } return isAvailable ; } public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException { boolean isAvailable = false ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( extNS != null ) isAvailable = extNS . isElementAvailable ( elemName ) ; } return isAvailable ; } public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { Object result = null ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( null != extNS ) { try { result = extNS . callFunction ( funcName , argVec , methodKey , exprContext ) ; } catch ( javax . xml . transform . TransformerException e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } else { throw new XPathProcessorException ( XSLMessages . createMessage ( XSLTErrorResources . ER_EXTENSION_FUNC_UNKNOWN , new Object [ ] { ns , funcName } ) ) ; } } return result ; } } 	1	['6', '1', '0', '8', '21', '0', '2', '6', '6', '0.5', '146', '0.5', '1', '0', '0.380952381', '0', '0', '23', '1', '0.8333', '1']
package org . apache . xml . utils ; import java . io . BufferedReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class ListingErrorHandler implements ErrorHandler , ErrorListener { protected PrintWriter m_pw = null ; public ListingErrorHandler ( PrintWriter pw ) { if ( null == pw ) throw new NullPointerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , null ) ) ; m_pw = pw ; } public ListingErrorHandler ( ) { m_pw = new PrintWriter ( System . err , true ) ; } public void warning ( SAXParseException exception ) throws SAXException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "warning: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnWarning ( ) ) throw exception ; } public void error ( SAXParseException exception ) throws SAXException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "error: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnError ( ) ) throw exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "fatalError: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnFatalError ( ) ) throw exception ; } public void warning ( TransformerException exception ) throws TransformerException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "warning: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnWarning ( ) ) throw exception ; } public void error ( TransformerException exception ) throws TransformerException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "error: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnError ( ) ) throw exception ; } public void fatalError ( TransformerException exception ) throws TransformerException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "error: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnError ( ) ) throw exception ; } public static void logExceptionLocation ( PrintWriter pw , Throwable exception ) { if ( null == pw ) pw = new PrintWriter ( System . err , true ) ; SourceLocator locator = null ; Throwable cause = exception ; do { if ( cause instanceof SAXParseException ) { locator = new SAXSourceLocator ( ( SAXParseException ) cause ) ; } else if ( cause instanceof TransformerException ) { SourceLocator causeLocator = ( ( TransformerException ) cause ) . getLocator ( ) ; if ( null != causeLocator ) { locator = causeLocator ; } } if ( cause instanceof TransformerException ) cause = ( ( TransformerException ) cause ) . getCause ( ) ; else if ( cause instanceof WrappedRuntimeException ) cause = ( ( WrappedRuntimeException ) cause ) . getException ( ) ; else if ( cause instanceof SAXException ) cause = ( ( SAXException ) cause ) . getException ( ) ; else cause = null ; } while ( null != cause ) ; if ( null != locator ) { String id = ( locator . getPublicId ( ) != locator . getPublicId ( ) ) ? locator . getPublicId ( ) : ( null != locator . getSystemId ( ) ) ? locator . getSystemId ( ) : "SystemId-Unknown" ; pw . print ( id + ":Line=" + locator . getLineNumber ( ) + ";Column=" + locator . getColumnNumber ( ) + ": " ) ; pw . println ( "exception:" + exception . getMessage ( ) ) ; pw . println ( "root-cause:" + ( ( null != cause ) ? cause . getMessage ( ) : "null" ) ) ; logSourceLine ( pw , locator ) ; } else { pw . print ( "SystemId-Unknown:locator-unavailable: " ) ; pw . println ( "exception:" + exception . getMessage ( ) ) ; pw . println ( "root-cause:" + ( ( null != cause ) ? cause . getMessage ( ) : "null" ) ) ; } } public static void logSourceLine ( PrintWriter pw , SourceLocator locator ) { if ( null == locator ) return ; if ( null == pw ) pw = new PrintWriter ( System . err , true ) ; String url = locator . getSystemId ( ) ; if ( null == url ) { pw . println ( "line: (No systemId; cannot read file)" ) ; pw . println ( ) ; return ; } try { int line = locator . getLineNumber ( ) ; int column = locator . getColumnNumber ( ) ; pw . println ( "line: " + getSourceLine ( url , line ) ) ; StringBuffer buf = new StringBuffer ( "line: " ) ; for ( int i = 1 ; i < column ; i ++ ) { buf . append ( ' ' ) ; } buf . append ( '^' ) ; pw . println ( buf . toString ( ) ) ; } catch ( Exception e ) { pw . println ( "line: logSourceLine unavailable due to: " + e . getMessage ( ) ) ; pw . println ( ) ; } } protected static String getSourceLine ( String sourceUrl , int lineNum ) throws Exception { URL url = null ; try { url = new URL ( sourceUrl ) ; } catch ( java . net . MalformedURLException mue ) { int indexOfColon = sourceUrl . indexOf ( ':' ) ; int indexOfSlash = sourceUrl . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { throw mue ; } else { url = new URL ( SystemIDResolver . getAbsoluteURI ( sourceUrl ) ) ; } } String line = null ; InputStream is = null ; BufferedReader br = null ; try { URLConnection uc = url . openConnection ( ) ; is = uc . getInputStream ( ) ; br = new BufferedReader ( new InputStreamReader ( is ) ) ; for ( int i = 1 ; i <= lineNum ; i ++ ) { line = br . readLine ( ) ; } } finally { br . close ( ) ; is . close ( ) ; } return line ; } public void setThrowOnWarning ( boolean b ) { throwOnWarning = b ; } public boolean getThrowOnWarning ( ) { return throwOnWarning ; } protected boolean throwOnWarning = false ; public void setThrowOnError ( boolean b ) { throwOnError = b ; } public boolean getThrowOnError ( ) { return throwOnError ; } protected boolean throwOnError = true ; public void setThrowOnFatalError ( boolean b ) { throwOnFatalError = b ; } public boolean getThrowOnFatalError ( ) { return throwOnFatalError ; } protected boolean throwOnFatalError = true ; } 	0	['17', '1', '0', '4', '52', '50', '0', '4', '16', '0.65625', '569', '1', '0', '0', '0.196078431', '0', '0', '32.23529412', '14', '1.8824', '0']
package org . apache . xalan . lib . sql ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTM ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . sql . * ; import org . apache . xml . dtm . ref . * ; public class SQLDocument extends DTMDocument { private boolean DEBUG = false ; private static final String S_NAMESPACE = "http://xml.apache.org/xalan/SQLExtension" ; private static final String S_SQL = "sql" ; private static final String S_ROW_SET = "row-set" ; private static final String S_METADATA = "metadata" ; private static final String S_COLUMN_HEADER = "column-header" ; private static final String S_ROW = "row" ; private static final String S_COL = "col" ; private static final String S_CATALOGUE_NAME = "catalogue-name" ; private static final String S_DISPLAY_SIZE = "column-display-size" ; private static final String S_COLUMN_LABEL = "column-label" ; private static final String S_COLUMN_NAME = "column-name" ; private static final String S_COLUMN_TYPE = "column-type" ; private static final String S_COLUMN_TYPENAME = "column-typename" ; private static final String S_PRECISION = "precision" ; private static final String S_SCALE = "scale" ; private static final String S_SCHEMA_NAME = "schema-name" ; private static final String S_TABLE_NAME = "table-name" ; private static final String S_CASESENSITIVE = "case-sensitive" ; private static final String S_DEFINITLEYWRITABLE = "definitley-writable" ; private static final String S_ISNULLABLE = "nullable" ; private static final String S_ISSIGNED = "signed" ; private static final String S_ISWRITEABLE = "writable" ; private static final String S_ISSEARCHABLE = "searchable" ; private int m_SQL_TypeID = 0 ; private int m_MetaData_TypeID = 0 ; private int m_ColumnHeader_TypeID = 0 ; private int m_RowSet_TypeID = 0 ; private int m_Row_TypeID = 0 ; private int m_Col_TypeID = 0 ; private int m_ColAttrib_CATALOGUE_NAME_TypeID = 0 ; private int m_ColAttrib_DISPLAY_SIZE_TypeID = 0 ; private int m_ColAttrib_COLUMN_LABEL_TypeID = 0 ; private int m_ColAttrib_COLUMN_NAME_TypeID = 0 ; private int m_ColAttrib_COLUMN_TYPE_TypeID = 0 ; private int m_ColAttrib_COLUMN_TYPENAME_TypeID = 0 ; private int m_ColAttrib_PRECISION_TypeID = 0 ; private int m_ColAttrib_SCALE_TypeID = 0 ; private int m_ColAttrib_SCHEMA_NAME_TypeID = 0 ; private int m_ColAttrib_TABLE_NAME_TypeID = 0 ; private int m_ColAttrib_CASESENSITIVE_TypeID = 0 ; private int m_ColAttrib_DEFINITLEYWRITEABLE_TypeID = 0 ; private int m_ColAttrib_ISNULLABLE_TypeID = 0 ; private int m_ColAttrib_ISSIGNED_TypeID = 0 ; private int m_ColAttrib_ISWRITEABLE_TypeID = 0 ; private int m_ColAttrib_ISSEARCHABLE_TypeID = 0 ; private Connection m_Connection = null ; private Statement m_Statement = null ; private ResultSet m_ResultSet = null ; private ConnectionPool m_ConnectionPool = null ; private int [ ] m_ColHeadersIdx ; private int m_ColCount ; private int m_MetaDataIdx = DTM . NULL ; private int m_RowSetIdx = DTM . NULL ; private int m_SQLIdx = DTM . NULL ; private int m_FirstRowIdx = DTM . NULL ; private int m_LastRowIdx = DTM . NULL ; private boolean m_StreamingMode = true ; public SQLDocument ( DTMManager mgr , int ident , ConnectionPool pool , Connection con , Statement stmt , ResultSet data , boolean streamingMode ) throws SQLException { super ( mgr , ident ) ; m_Connection = con ; m_Statement = stmt ; m_ResultSet = data ; m_ConnectionPool = pool ; m_StreamingMode = streamingMode ; createExpandedNameTable ( ) ; extractSQLMetaData ( m_ResultSet . getMetaData ( ) ) ; addRowToDTMFromResultSet ( ) ; } private void extractSQLMetaData ( ResultSetMetaData meta ) { m_DocumentIdx = addElement ( 0 , m_Document_TypeID , DTM . NULL , DTM . NULL ) ; m_SQLIdx = addElement ( 1 , m_SQL_TypeID , m_DocumentIdx , DTM . NULL ) ; m_MetaDataIdx = addElement ( 1 , m_MetaData_TypeID , m_SQLIdx , DTM . NULL ) ; try { m_ColCount = meta . getColumnCount ( ) ; m_ColHeadersIdx = new int [ m_ColCount ] ; } catch ( Exception e ) { error ( "ERROR Extracting Metadata" ) ; } int lastColHeaderIdx = DTM . NULL ; int i = 1 ; for ( i = 1 ; i <= m_ColCount ; i ++ ) { m_ColHeadersIdx [ i - 1 ] = addElement ( 2 , m_ColumnHeader_TypeID , m_MetaDataIdx , lastColHeaderIdx ) ; lastColHeaderIdx = m_ColHeadersIdx [ i - 1 ] ; try { addAttributeToNode ( meta . getColumnName ( i ) , m_ColAttrib_COLUMN_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getColumnLabel ( i ) , m_ColAttrib_COLUMN_LABEL_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_LABEL_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getCatalogName ( i ) , m_ColAttrib_CATALOGUE_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_CATALOGUE_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getColumnDisplaySize ( i ) ) , m_ColAttrib_DISPLAY_SIZE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_DISPLAY_SIZE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getColumnType ( i ) ) , m_ColAttrib_COLUMN_TYPE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_TYPE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getColumnTypeName ( i ) , m_ColAttrib_COLUMN_TYPENAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_TYPENAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getPrecision ( i ) ) , m_ColAttrib_PRECISION_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_PRECISION_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getScale ( i ) ) , m_ColAttrib_SCALE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_SCALE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getSchemaName ( i ) , m_ColAttrib_SCHEMA_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_SCHEMA_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getTableName ( i ) , m_ColAttrib_TABLE_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_TABLE_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isCaseSensitive ( i ) ? S_ISTRUE : S_ISFALSE , m_ColAttrib_CASESENSITIVE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_CASESENSITIVE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isDefinitelyWritable ( i ) ? S_ISTRUE : S_ISFALSE , m_ColAttrib_DEFINITLEYWRITEABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_DEFINITLEYWRITEABLE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isNullable ( i ) != 0 ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISNULLABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISNULLABLE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isSigned ( i ) ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISSIGNED_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISSIGNED_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isWritable ( i ) == true ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISWRITEABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISWRITEABLE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isSearchable ( i ) == true ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISSEARCHABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISSEARCHABLE_TypeID , lastColHeaderIdx ) ; } } } protected void createExpandedNameTable ( ) { super . createExpandedNameTable ( ) ; m_SQL_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SQL , DTM . ELEMENT_NODE ) ; m_MetaData_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_METADATA , DTM . ELEMENT_NODE ) ; m_ColumnHeader_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_HEADER , DTM . ELEMENT_NODE ) ; m_RowSet_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ROW_SET , DTM . ELEMENT_NODE ) ; m_Row_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ROW , DTM . ELEMENT_NODE ) ; m_Col_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COL , DTM . ELEMENT_NODE ) ; m_ColAttrib_CATALOGUE_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CATALOGUE_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_DISPLAY_SIZE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DISPLAY_SIZE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_LABEL_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_LABEL , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_TYPE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_TYPE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_TYPENAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_TYPENAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_PRECISION_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_PRECISION , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_SCALE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SCALE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_SCHEMA_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SCHEMA_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_TABLE_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_TABLE_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_CASESENSITIVE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CASESENSITIVE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_DEFINITLEYWRITEABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DEFINITLEYWRITABLE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISNULLABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISNULLABLE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISSIGNED_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISSIGNED , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISWRITEABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISWRITEABLE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISSEARCHABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISSEARCHABLE , DTM . ATTRIBUTE_NODE ) ; } private boolean addRowToDTMFromResultSet ( ) { try { if ( m_RowSetIdx == DTM . NULL ) { m_RowSetIdx = addElement ( 1 , m_RowSet_TypeID , m_SQLIdx , m_MetaDataIdx ) ; } if ( ! m_ResultSet . next ( ) ) { if ( m_StreamingMode ) { m_nextsib . setElementAt ( DTM . NULL , m_LastRowIdx ) ; } return false ; } if ( m_FirstRowIdx == DTM . NULL ) { m_FirstRowIdx = addElement ( 2 , m_Row_TypeID , m_RowSetIdx , DTM . NULL ) ; m_LastRowIdx = m_FirstRowIdx ; if ( m_StreamingMode ) { m_nextsib . setElementAt ( m_LastRowIdx , m_LastRowIdx ) ; } } else { if ( ! m_StreamingMode ) { m_LastRowIdx = addElement ( 3 , m_Row_TypeID , m_RowSetIdx , m_LastRowIdx ) ; } } int colID = _firstch ( m_LastRowIdx ) ; int pcolID = DTM . NULL ; for ( int i = 1 ; i <= m_ColCount ; i ++ ) { Object o = m_ResultSet . getObject ( i ) ; if ( colID == DTM . NULL ) { pcolID = addElementWithData ( o , 3 , m_Col_TypeID , m_LastRowIdx , pcolID ) ; cloneAttributeFromNode ( pcolID , m_ColHeadersIdx [ i - 1 ] ) ; } else { int dataIdent = _firstch ( colID ) ; if ( dataIdent == DTM . NULL ) { error ( "Streaming Mode, Data Error" ) ; } else { m_ObjectArray . setAt ( dataIdent , o ) ; } } if ( colID != DTM . NULL ) { colID = _nextsib ( colID ) ; } } } catch ( Exception e ) { if ( DEBUG ) { System . out . println ( "SQL Error Fetching next row [" + e . getLocalizedMessage ( ) + "]" ) ; } error ( "SQL Error Fetching next row [" + e . getLocalizedMessage ( ) + "]" ) ; } return true ; } public void close ( ) { if ( DEBUG ) System . out . println ( "close()" ) ; try { if ( null != m_ResultSet ) m_ResultSet . close ( ) ; } catch ( Exception e ) { } try { if ( null != m_Statement ) m_Statement . close ( ) ; } catch ( Exception e ) { } try { if ( null != m_Connection ) m_ConnectionPool . releaseConnection ( m_Connection ) ; } catch ( Exception e ) { } } public void closeOnError ( ) { if ( DEBUG ) System . out . println ( "close()" ) ; try { if ( null != m_ResultSet ) m_ResultSet . close ( ) ; } catch ( Exception e ) { } try { if ( null != m_Statement ) m_Statement . close ( ) ; } catch ( Exception e ) { } try { if ( null != m_Connection ) m_ConnectionPool . releaseConnectionOnError ( m_Connection ) ; } catch ( Exception e ) { } } protected boolean nextNode ( ) { if ( DEBUG ) System . out . println ( "nextNode()" ) ; try { return false ; } catch ( Exception e ) { return false ; } } protected int _nextsib ( int identity ) { int id = _exptype ( identity ) ; if ( ( id == m_Row_TypeID ) && ( identity >= m_LastRowIdx ) ) { if ( DEBUG ) System . out . println ( "reading from the ResultSet" ) ; addRowToDTMFromResultSet ( ) ; } return super . _nextsib ( identity ) ; } public void documentRegistration ( ) { if ( DEBUG ) System . out . println ( "Document Registration" ) ; } public void documentRelease ( ) { if ( DEBUG ) System . out . println ( "Document Release" ) ; } } 	1	['10', '5', '0', '8', '53', '0', '1', '7', '5', '0.883141762', '1073', '1', '1', '0.954545455', '0.211111111', '2', '8', '100.5', '11', '3.4', '2']
package org . apache . xalan . serialize ; import java . io . * ; public class WriterToUTF8 extends Writer { private final OutputStream m_os ; public WriterToUTF8 ( OutputStream os ) throws UnsupportedEncodingException { m_os = os ; } public void write ( final int c ) throws IOException { if ( c < 0x80 ) m_os . write ( c ) ; else if ( c < 0x800 ) { m_os . write ( 0xc0 + ( c > > 6 ) ) ; m_os . write ( 0x80 + ( c & 0x3f ) ) ; } else { m_os . write ( 0xe0 + ( c > > 12 ) ) ; m_os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; m_os . write ( 0x80 + ( c & 0x3f ) ) ; } } public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { final OutputStream os = m_os ; int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } } public void write ( final String s ) throws IOException { final int n = s . length ( ) ; final OutputStream os = m_os ; for ( int i = 0 ; i < n ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } } public void flush ( ) throws java . io . IOException { m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } } 	0	['7', '2', '0', '1', '13', '0', '1', '0', '7', '0', '213', '1', '0', '0.684210526', '0.342857143', '1', '2', '29.28571429', '1', '0.8571', '0']
package org . apache . xalan . xslt ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . io . StringReader ; import java . util . Properties ; import java . util . ResourceBundle ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . TransformerFactoryConfigurationError ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . processor . TransformerFactoryImpl ; import org . apache . xalan . processor . XSLProcessorVersion ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . trace . PrintTraceListener ; import org . apache . xalan . trace . TraceManager ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . XalanProperties ; import org . apache . xml . utils . DefaultErrorHandler ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xml . utils . res . XResourceBundle ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class Process { protected static void printArgOptions ( ResourceBundle resbundle ) { System . out . println ( resbundle . getString ( "xslProc_option" ) ) ; System . out . println ( resbundle . getString ( "optionIN" ) ) ; System . out . println ( resbundle . getString ( "optionXSL" ) ) ; System . out . println ( resbundle . getString ( "optionOUT" ) ) ; System . out . println ( resbundle . getString ( "optionV" ) ) ; System . out . println ( resbundle . getString ( "optionQC" ) ) ; System . out . println ( resbundle . getString ( "optionTT" ) ) ; System . out . println ( resbundle . getString ( "optionTG" ) ) ; System . out . println ( resbundle . getString ( "optionTS" ) ) ; System . out . println ( resbundle . getString ( "optionTTC" ) ) ; System . out . println ( resbundle . getString ( "optionTCLASS" ) ) ; System . out . println ( resbundle . getString ( "optionEDUMP" ) ) ; System . out . println ( resbundle . getString ( "optionXML" ) ) ; System . out . println ( resbundle . getString ( "optionTEXT" ) ) ; System . out . println ( resbundle . getString ( "optionHTML" ) ) ; System . out . println ( resbundle . getString ( "optionPARAM" ) ) ; System . out . println ( resbundle . getString ( "optionLINENUMBERS" ) ) ; System . out . println ( resbundle . getString ( "optionMEDIA" ) ) ; System . out . println ( resbundle . getString ( "optionFLAVOR" ) ) ; System . out . println ( resbundle . getString ( "optionDIAG" ) ) ; System . out . println ( resbundle . getString ( "optionURIRESOLVER" ) ) ; System . out . println ( resbundle . getString ( "optionENTITYRESOLVER" ) ) ; System . out . println ( resbundle . getString ( "optionCONTENTHANDLER" ) ) ; System . out . println ( resbundle . getString ( "optionINCREMENTAL" ) ) ; System . out . println ( resbundle . getString ( "optionNOOPTIMIMIZE" ) ) ; System . out . println ( resbundle . getString ( "optionRL" ) ) ; } public static void main ( String argv [ ] ) { boolean doStackDumpOnError = false ; boolean setQuietMode = false ; boolean doDiag = false ; java . io . PrintWriter diagnosticsWriter = new PrintWriter ( System . err , true ) ; java . io . PrintWriter dumpWriter = diagnosticsWriter ; ResourceBundle resbundle = ( XSLMessages . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . ERROR_RESOURCES ) ) ; String flavor = "s2s" ; if ( argv . length < 1 ) { printArgOptions ( resbundle ) ; } else { TransformerFactory tfactory ; try { tfactory = TransformerFactory . newInstance ( ) ; } catch ( TransformerFactoryConfigurationError pfe ) { pfe . printStackTrace ( dumpWriter ) ; diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUCCESSFUL , null ) ) ; tfactory = null ; doExit ( - 1 ) ; } boolean formatOutput = false ; boolean useSourceLocation = false ; String inFileName = null ; String outFileName = null ; String dumpFileName = null ; String xslFileName = null ; String treedumpFileName = null ; PrintTraceListener tracer = null ; String outputType = null ; String media = null ; Vector params = new Vector ( ) ; boolean quietConflictWarnings = false ; URIResolver uriResolver = null ; EntityResolver entityResolver = null ; ContentHandler contentHandler = null ; int recursionLimit = - 1 ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( "-TT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceTemplates = true ; } else if ( "-TG" . equalsIgnoreCase ( argv [ i ] ) ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceGeneration = true ; } else if ( "-TS" . equalsIgnoreCase ( argv [ i ] ) ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceSelection = true ; } else if ( "-TTC" . equalsIgnoreCase ( argv [ i ] ) ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceElements = true ; } else if ( "-INDENT" . equalsIgnoreCase ( argv [ i ] ) ) { int indentAmount ; if ( ( ( i + 1 ) < argv . length ) && ( argv [ i + 1 ] . charAt ( 0 ) != '-' ) ) { indentAmount = Integer . parseInt ( argv [ ++ i ] ) ; } else { indentAmount = 0 ; } } else if ( "-IN" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) inFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-IN" } ) ) ; } else if ( "-MEDIA" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) media = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-MEDIA" } ) ) ; } else if ( "-OUT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) outFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-OUT" } ) ) ; } else if ( "-XSL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) xslFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XSL" } ) ) ; } else if ( "-FLAVOR" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { flavor = argv [ ++ i ] ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-FLAVOR" } ) ) ; } else if ( "-PARAM" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 2 < argv . length ) { String name = argv [ ++ i ] ; params . addElement ( name ) ; String expression = argv [ ++ i ] ; params . addElement ( expression ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-PARAM" } ) ) ; } else if ( "-TREEDUMP" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) treedumpFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-treedump" } ) ) ; } else if ( "-F" . equalsIgnoreCase ( argv [ i ] ) ) { formatOutput = true ; } else if ( "-E" . equalsIgnoreCase ( argv [ i ] ) ) { } else if ( "-V" . equalsIgnoreCase ( argv [ i ] ) ) { diagnosticsWriter . println ( resbundle . getString ( "version" ) + XSLProcessorVersion . S_VERSION + ", " + resbundle . getString ( "version2" ) ) ; } else if ( "-QC" . equalsIgnoreCase ( argv [ i ] ) ) { quietConflictWarnings = true ; } else if ( "-Q" . equalsIgnoreCase ( argv [ i ] ) ) { setQuietMode = true ; } else if ( "-DIAG" . equalsIgnoreCase ( argv [ i ] ) ) { doDiag = true ; } else if ( "-XML" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "xml" ; } else if ( "-TEXT" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "text" ; } else if ( "-HTML" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "html" ; } else if ( "-EDUMP" . equalsIgnoreCase ( argv [ i ] ) ) { doStackDumpOnError = true ; if ( ( ( i + 1 ) < argv . length ) && ( argv [ i + 1 ] . charAt ( 0 ) != '-' ) ) { dumpFileName = argv [ ++ i ] ; } } else if ( "-URIRESOLVER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { uriResolver = ( URIResolver ) Class . forName ( argv [ ++ i ] ) . newInstance ( ) ; tfactory . setURIResolver ( uriResolver ) ; } catch ( Exception cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-URIResolver" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-URIResolver" } ) ) ; doExit ( - 1 ) ; } } else if ( "-ENTITYRESOLVER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { entityResolver = ( EntityResolver ) Class . forName ( argv [ ++ i ] ) . newInstance ( ) ; } catch ( Exception cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-EntityResolver" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-EntityResolver" } ) ) ; doExit ( - 1 ) ; } } else if ( "-CONTENTHANDLER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { contentHandler = ( ContentHandler ) Class . forName ( argv [ ++ i ] ) . newInstance ( ) ; } catch ( Exception cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-ContentHandler" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-ContentHandler" } ) ) ; doExit ( - 1 ) ; } } else if ( "-L" . equalsIgnoreCase ( argv [ i ] ) ) useSourceLocation = true ; else if ( "-INCREMENTAL" . equalsIgnoreCase ( argv [ i ] ) ) { tfactory . setAttribute ( "http://xml.apache.org/xalan/features/incremental" , java . lang . Boolean . TRUE ) ; } else if ( "-NOOPTIMIZE" . equalsIgnoreCase ( argv [ i ] ) ) { tfactory . setAttribute ( "http://xml.apache.org/xalan/features/optimize" , java . lang . Boolean . FALSE ) ; } else if ( "-RL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) recursionLimit = Integer . parseInt ( argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-rl" } ) ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_OPTION , new Object [ ] { argv [ i ] } ) ) ; } try { long start = System . currentTimeMillis ( ) ; if ( null != dumpFileName ) { dumpWriter = new PrintWriter ( new FileWriter ( dumpFileName ) ) ; } Templates stylesheet = null ; if ( null != xslFileName ) { if ( flavor . equals ( "d2d" ) ) { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setNamespaceAware ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Node xslDOM = docBuilder . parse ( new InputSource ( xslFileName ) ) ; stylesheet = tfactory . newTemplates ( new DOMSource ( xslDOM , xslFileName ) ) ; } else { stylesheet = tfactory . newTemplates ( new StreamSource ( xslFileName ) ) ; } } PrintWriter resultWriter ; StreamResult strResult ; if ( null != outFileName ) { strResult = new StreamResult ( new FileOutputStream ( outFileName ) ) ; strResult . setSystemId ( outFileName ) ; } else { strResult = new StreamResult ( System . out ) ; } SAXTransformerFactory stf = ( SAXTransformerFactory ) tfactory ; if ( useSourceLocation ) stf . setAttribute ( XalanProperties . SOURCE_LOCATION , Boolean . TRUE ) ; if ( null == stylesheet ) { Source source = stf . getAssociatedStylesheet ( new StreamSource ( inFileName ) , media , null , null ) ; if ( null != source ) stylesheet = tfactory . newTemplates ( source ) ; else { if ( null != media ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEET_IN_MEDIA , new Object [ ] { inFileName , media } ) ) ; else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEET_PI , new Object [ ] { inFileName } ) ) ; } } if ( null != stylesheet ) { Transformer transformer = flavor . equals ( "th" ) ? null : stylesheet . newTransformer ( ) ; if ( null != outputType ) { transformer . setOutputProperty ( OutputKeys . METHOD , outputType ) ; } if ( transformer instanceof TransformerImpl ) { TransformerImpl impl = ( ( TransformerImpl ) transformer ) ; TraceManager tm = impl . getTraceManager ( ) ; if ( null != tracer ) tm . addTraceListener ( tracer ) ; impl . setQuietConflictWarnings ( quietConflictWarnings ) ; if ( useSourceLocation ) impl . setProperty ( XalanProperties . SOURCE_LOCATION , Boolean . TRUE ) ; if ( recursionLimit > 0 ) impl . setRecursionLimit ( recursionLimit ) ; } int nParams = params . size ( ) ; for ( int i = 0 ; i < nParams ; i += 2 ) { transformer . setParameter ( ( String ) params . elementAt ( i ) , ( String ) params . elementAt ( i + 1 ) ) ; } if ( uriResolver != null ) transformer . setURIResolver ( uriResolver ) ; if ( null != inFileName ) { if ( flavor . equals ( "d2d" ) ) { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setCoalescing ( true ) ; dfactory . setNamespaceAware ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; if ( entityResolver != null ) docBuilder . setEntityResolver ( entityResolver ) ; Node xmlDoc = docBuilder . parse ( new InputSource ( inFileName ) ) ; Document doc = docBuilder . newDocument ( ) ; org . w3c . dom . DocumentFragment outNode = doc . createDocumentFragment ( ) ; transformer . transform ( new DOMSource ( xmlDoc , inFileName ) , new DOMResult ( outNode ) ) ; Transformer serializer = stf . newTransformer ( ) ; Properties serializationProps = stylesheet . getOutputProperties ( ) ; serializer . setOutputProperties ( serializationProps ) ; if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; serializer . transform ( new DOMSource ( outNode ) , result ) ; } else serializer . transform ( new DOMSource ( outNode ) , strResult ) ; } else if ( flavor . equals ( "th" ) ) { for ( int i = 0 ; i < 1 ; i ++ ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } stf . setAttribute ( org . apache . xalan . processor . TransformerFactoryImpl . FEATURE_INCREMENTAL , Boolean . TRUE ) ; TransformerHandler th = stf . newTransformerHandler ( stylesheet ) ; reader . setContentHandler ( th ) ; reader . setDTDHandler ( th ) ; if ( th instanceof org . xml . sax . ErrorHandler ) reader . setErrorHandler ( ( org . xml . sax . ErrorHandler ) th ) ; try { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , th ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { } catch ( org . xml . sax . SAXNotSupportedException e ) { } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } try { reader . setFeature ( "http://apache.org/xml/features/validation/dynamic" , true ) ; } catch ( org . xml . sax . SAXException se ) { } th . setResult ( strResult ) ; { reader . parse ( new InputSource ( inFileName ) ) ; } } } else { if ( entityResolver != null ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } reader . setEntityResolver ( entityResolver ) ; if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; transformer . transform ( new SAXSource ( reader , new InputSource ( inFileName ) ) , result ) ; } else { transformer . transform ( new SAXSource ( reader , new InputSource ( inFileName ) ) , strResult ) ; } } else if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; transformer . transform ( new StreamSource ( inFileName ) , result ) ; } else { transformer . transform ( new StreamSource ( inFileName ) , strResult ) ; } } } else { StringReader reader = new StringReader ( "<?xml version=\"1.0\"?> <doc/>" ) ; transformer . transform ( new StreamSource ( reader ) , strResult ) ; } } else { diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUCCESSFUL , null ) ) ; doExit ( - 1 ) ; } long stop = System . currentTimeMillis ( ) ; long millisecondsDuration = stop - start ; if ( doDiag ) { Object [ ] msgArgs = new Object [ ] { inFileName , xslFileName , new Long ( millisecondsDuration ) } ; String msg = XSLMessages . createMessage ( "diagTiming" , msgArgs ) ; diagnosticsWriter . println ( '\n' ) ; diagnosticsWriter . println ( msg ) ; } } catch ( Throwable throwable ) { while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } if ( ( throwable instanceof NullPointerException ) || ( throwable instanceof ClassCastException ) ) doStackDumpOnError = true ; diagnosticsWriter . println ( ) ; if ( doStackDumpOnError ) throwable . printStackTrace ( dumpWriter ) ; else { DefaultErrorHandler . printLocation ( diagnosticsWriter , throwable ) ; diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_XSLT_ERROR , null ) + " (" + throwable . getClass ( ) . getName ( ) + "): " + throwable . getMessage ( ) ) ; } if ( null != dumpFileName ) { dumpWriter . close ( ) ; } doExit ( - 1 ) ; } if ( null != dumpFileName ) { dumpWriter . close ( ) ; } if ( null != diagnosticsWriter ) { } diagnosticsWriter . println ( "" ) ; } } static void doExit ( int i ) { System . exit ( i ) ; } } 	1	['4', '1', '0', '8', '96', '6', '0', '8', '2', '2', '1490', '0', '0', '0', '0.25', '0', '0', '371.5', '86', '22', '1']
package org . apache . xpath . functions ; import java . util . Vector ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNumber ; public class FuncRound extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( java . lang . Math . floor ( m_arg0 . execute ( xctxt ) . num ( ) + 0.5 ) ) ; } } 	0	['2', '4', '0', '5', '7', '1', '0', '5', '2', '2', '17', '0', '0', '0.979591837', '0.75', '1', '6', '7.5', '1', '0.5', '0']
package org . apache . xalan . lib ; import java . util . Date ; import java . util . TimeZone ; import java . util . Calendar ; import java . text . SimpleDateFormat ; import java . text . DateFormat ; import java . text . ParseException ; import org . apache . xpath . objects . XString ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class ExsltDatetime { static final String dt = "yyyy-MM-dd'T'HH:mm:ss" ; static final String d = "yyyy-MM-dd" ; static final String gym = "yyyy-MM" ; static final String gy = "yyyy" ; static final String gmd = "MM-dd" ; static final String gm = "MM" ; static final String gd = "dd" ; static final String t = "HH:mm:ss" ; public static XString dateTime ( ) { Calendar cal = Calendar . getInstance ( ) ; Date datetime = cal . getTime ( ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( dt ) ; StringBuffer buff = new StringBuffer ( dateFormat . format ( datetime ) ) ; int offset = cal . get ( Calendar . ZONE_OFFSET ) + cal . get ( Calendar . DST_OFFSET ) ; if ( offset == 0 ) buff . append ( "Z" ) ; else { int hrs = offset / ( 60 * 60 * 1000 ) ; int min = offset % ( 60 * 60 * 1000 ) ; char posneg = hrs < 0 ? '-' : '+' ; buff . append ( posneg + formatDigits ( hrs ) + ':' + formatDigits ( min ) ) ; } return new XString ( buff . toString ( ) ) ; } private static String formatDigits ( int q ) { String dd = String . valueOf ( Math . abs ( q ) ) ; return dd . length ( ) == 1 ? '0' + dd : dd ; } public static XString date ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String leader = edz [ 0 ] ; String datetime = edz [ 1 ] ; String zone = edz [ 2 ] ; if ( datetime == null || zone == null ) return new XString ( "" ) ; String [ ] formatsIn = { dt , d } ; String formatOut = d ; Date date = testFormats ( datetime , formatsIn ) ; if ( date == null ) return new XString ( "" ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( formatOut ) ; dateFormat . setLenient ( false ) ; String dateOut = dateFormat . format ( date ) ; if ( dateOut . length ( ) == 0 ) return new XString ( "" ) ; else return new XString ( leader + dateOut + zone ) ; } public static XString date ( ) { String datetime = dateTime ( ) . toString ( ) ; String date = datetime . substring ( 0 , datetime . indexOf ( "T" ) ) ; String zone = datetime . substring ( getZoneStart ( datetime ) ) ; return new XString ( date + zone ) ; } public static XString time ( String timeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( timeIn ) ; String time = edz [ 1 ] ; String zone = edz [ 2 ] ; if ( time == null || zone == null ) return new XString ( "" ) ; String [ ] formatsIn = { dt , d } ; String formatOut = t ; Date date = testFormats ( time , formatsIn ) ; if ( date == null ) return new XString ( "" ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( formatOut ) ; String out = dateFormat . format ( date ) ; return new XString ( out + zone ) ; } public static XString time ( ) { String datetime = dateTime ( ) . toString ( ) ; String time = datetime . substring ( datetime . indexOf ( "T" ) + 1 ) ; String zone = datetime . substring ( getZoneStart ( datetime ) ) ; return new XString ( time + zone ) ; } public static XNumber year ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; boolean ad = edz [ 0 ] . length ( ) == 0 ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , d , gym , gy } ; double yr = getNumber ( datetime , formats , Calendar . YEAR ) ; if ( ad || yr == Double . NaN ) return new XNumber ( yr ) ; else return new XNumber ( - yr ) ; } public static XNumber year ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . YEAR ) ) ; } public static XNumber monthInYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , d , gym } ; return new XNumber ( getNumber ( datetime , formats , Calendar . MONTH ) ) ; } public static XNumber monthInYear ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . MONTH ) ) ; } public static XNumber weekInYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , d } ; return new XNumber ( getNumber ( datetime , formats , Calendar . WEEK_OF_YEAR ) ) ; } public static XNumber weekInYear ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . WEEK_OF_YEAR ) ) ; } public static XNumber dayInYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , d } ; return new XNumber ( getNumber ( datetime , formats , Calendar . DAY_OF_YEAR ) ) ; } public static XNumber dayInYear ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . DAY_OF_YEAR ) ) ; } public static XNumber dayInMonth ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; String [ ] formats = { dt , d , gmd , gd } ; double day = getNumber ( datetime , formats , Calendar . DAY_OF_MONTH ) ; return new XNumber ( day ) ; } public static XNumber dayInMonth ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . DAY_OF_MONTH ) ) ; } public static XNumber dayOfWeekInMonth ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , d } ; return new XNumber ( getNumber ( datetime , formats , Calendar . DAY_OF_WEEK_IN_MONTH ) ) ; } public static XNumber dayOfWeekInMonth ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . DAY_OF_WEEK_IN_MONTH ) ) ; } public static XNumber dayInWeek ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , d } ; return new XNumber ( getNumber ( datetime , formats , Calendar . DAY_OF_WEEK ) ) ; } public static XNumber dayInWeek ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . DAY_OF_WEEK ) ) ; } public static XNumber hourInDay ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { d , t } ; return new XNumber ( getNumber ( datetime , formats , Calendar . HOUR_OF_DAY ) ) ; } public static XNumber hourInDay ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . HOUR_OF_DAY ) ) ; } public static XNumber minuteInHour ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , t } ; return new XNumber ( getNumber ( datetime , formats , Calendar . MINUTE ) ) ; } public static XNumber minuteInHour ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . MINUTE ) ) ; } public static XNumber secondInMinute ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , t } ; return new XNumber ( getNumber ( datetime , formats , Calendar . SECOND ) ) ; } public static XNumber secondInMinute ( ) { Calendar cal = Calendar . getInstance ( ) ; return new XNumber ( cal . get ( Calendar . SECOND ) ) ; } public static XObject leapYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , d , gym , gy } ; double dbl = getNumber ( datetime , formats , Calendar . YEAR ) ; if ( dbl == Double . NaN ) return new XNumber ( Double . NaN ) ; int yr = ( int ) dbl ; return new XBoolean ( yr % 400 == 0 || ( yr % 100 != 0 && yr % 4 == 0 ) ) ; } public static XBoolean leapYear ( ) { Calendar cal = Calendar . getInstance ( ) ; int yr = ( int ) cal . get ( Calendar . YEAR ) ; return new XBoolean ( yr % 400 == 0 || ( yr % 100 != 0 && yr % 4 == 0 ) ) ; } public static XString monthName ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XString ( "" ) ; String [ ] formatsIn = { dt , d , gym , gm } ; String formatOut = "MMMM" ; return new XString ( getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ) ; } public static XString monthName ( ) { Calendar cal = Calendar . getInstance ( ) ; String format = "MMMM" ; return new XString ( getNameOrAbbrev ( format ) ) ; } public static XString monthAbbreviation ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XString ( "" ) ; String [ ] formatsIn = { dt , d , gym , gm } ; String formatOut = "MMM" ; return new XString ( getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ) ; } public static XString monthAbbreviation ( ) { String format = "MMM" ; return new XString ( getNameOrAbbrev ( format ) ) ; } public static XString dayName ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XString ( "" ) ; String [ ] formatsIn = { dt , d } ; String formatOut = "EEEE" ; return new XString ( getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ) ; } public static XString dayName ( ) { String format = "EEEE" ; return new XString ( getNameOrAbbrev ( format ) ) ; } public static XString dayAbbreviation ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XString ( "" ) ; String [ ] formatsIn = { dt , d } ; String formatOut = "EEE" ; return new XString ( getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ) ; } public static XString dayAbbreviation ( ) { String format = "EEE" ; return new XString ( getNameOrAbbrev ( format ) ) ; } private static String [ ] getEraDatetimeZone ( String in ) { String leader = "" ; String datetime = in ; String zone = "" ; if ( in . charAt ( 0 ) == '-' ) { leader = "-" ; datetime = in . substring ( 1 ) ; } int z = getZoneStart ( datetime ) ; if ( z > 0 ) { zone = datetime . substring ( z ) ; datetime = datetime . substring ( 0 , z ) ; } else if ( z == - 2 ) zone = null ; return new String [ ] { leader , datetime , zone } ; } private static int getZoneStart ( String datetime ) { if ( datetime . indexOf ( "Z" ) == datetime . length ( ) - 1 ) return datetime . indexOf ( "Z" ) ; else if ( ( datetime . lastIndexOf ( "-" ) == datetime . length ( ) - 6 && datetime . charAt ( datetime . length ( ) - 3 ) == ':' ) || ( datetime . indexOf ( "+" ) == datetime . length ( ) - 6 ) ) { try { SimpleDateFormat dateFormat = new SimpleDateFormat ( "HH:mm" ) ; dateFormat . setLenient ( false ) ; Date d = dateFormat . parse ( datetime . substring ( datetime . length ( ) - 5 ) ) ; return datetime . length ( ) - 6 ; } catch ( ParseException pe ) { System . out . println ( "ParseException " + pe . getErrorOffset ( ) ) ; return - 2 ; } } return - 1 ; } private static Date testFormats ( String in , String [ ] formats ) throws ParseException { for ( int i = 0 ; i < formats . length ; i ++ ) { try { SimpleDateFormat dateFormat = new SimpleDateFormat ( formats [ i ] ) ; dateFormat . setLenient ( false ) ; return dateFormat . parse ( in ) ; } catch ( ParseException pe ) { if ( pe . getErrorOffset ( ) < in . length ( ) ) return null ; } } return null ; } private static double getNumber ( String in , String [ ] formats , int calField ) throws ParseException { Calendar cal = Calendar . getInstance ( ) ; cal . setLenient ( false ) ; Date date = testFormats ( in , formats ) ; if ( date == null ) return Double . NaN ; cal . setTime ( date ) ; return cal . get ( calField ) ; } private static String getNameOrAbbrev ( String in , String [ ] formatsIn , String formatOut ) throws ParseException { for ( int i = 0 ; i < formatsIn . length ; i ++ ) { try { SimpleDateFormat dateFormat = new SimpleDateFormat ( formatsIn [ i ] ) ; dateFormat . setLenient ( false ) ; Date dt = dateFormat . parse ( in ) ; dateFormat . applyPattern ( formatOut ) ; return dateFormat . format ( dt ) ; } catch ( ParseException pe ) { if ( pe . getErrorOffset ( ) < in . length ( ) ) return "" ; } } return "" ; } private static String getNameOrAbbrev ( String format ) { Calendar cal = Calendar . getInstance ( ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; return dateFormat . format ( cal . getTime ( ) ) ; } } 	1	['43', '1', '0', '4', '74', '903', '0', '4', '36', '1.023809524', '1326', '0', '0', '0', '0.168604651', '0', '0', '29.65116279', '5', '1.2791', '3']
package org . apache . xalan . transformer ; public class XalanProperties { public final static String SOURCE_LOCATION = "http://xml.apache.org/xalan/properties/source-location" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '5', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xalan . xsltc . dom ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . NodeIterator ; import org . apache . xalan . xsltc . TransletOutputHandler ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; public final class MultiDOM implements DOM { private static final int NO_TYPE = DOM . FIRST_TYPE - 2 ; private static final int INITIAL_SIZE = 4 ; private static final int CLR = 0x00FFFFFF ; private static final int SET = 0xFF000000 ; private DOM [ ] _adapters ; private int _free ; private int _size ; private Hashtable _documents = new Hashtable ( ) ; private final class AxisIterator implements NodeIterator { private final int _axis ; private final int _type ; private int _mask ; private NodeIterator _source = null ; public AxisIterator ( final int axis , final int type ) { _axis = axis ; _type = type ; } public int next ( ) { if ( _source == null ) return ( END ) ; if ( _mask == 0 ) return _source . next ( ) ; final int node = _source . next ( ) ; return node != END ? ( node | _mask ) : END ; } public void setRestartable ( boolean flag ) { _source . setRestartable ( flag ) ; } public NodeIterator setStartNode ( final int node ) { final int dom = node > > > 24 ; final int mask = node & SET ; if ( _source == null || _mask != mask ) { if ( _type == NO_TYPE ) { _source = _adapters [ dom ] . getAxisIterator ( _axis ) ; } else if ( _axis == Axis . CHILD && _type != ELEMENT ) { _source = _adapters [ dom ] . getTypedChildren ( _type ) ; } else { _source = _adapters [ dom ] . getTypedAxisIterator ( _axis , _type ) ; } } _mask = mask ; _source . setStartNode ( node & CLR ) ; return this ; } public NodeIterator reset ( ) { if ( _source != null ) _source . reset ( ) ; return this ; } public int getLast ( ) { return _source . getLast ( ) ; } public int getPosition ( ) { return _source . getPosition ( ) ; } public boolean isReverse ( ) { return ( _source == null ) ? false : _source . isReverse ( ) ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } public NodeIterator cloneIterator ( ) { final AxisIterator clone = new AxisIterator ( _axis , _type ) ; clone . _source = _source . cloneIterator ( ) ; clone . _mask = _mask ; return clone ; } } private final class NodeValueIterator extends NodeIteratorBase { private NodeIterator _source ; private String _value ; private boolean _op ; private final boolean _isReverse ; private int _returnType = RETURN_PARENT ; public NodeValueIterator ( NodeIterator source , int returnType , String value , boolean op ) { _source = source ; _returnType = returnType ; _value = value ; _op = op ; _isReverse = source . isReverse ( ) ; } public boolean isReverse ( ) { return _isReverse ; } public NodeIterator cloneIterator ( ) { try { NodeValueIterator clone = ( NodeValueIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . setRestartable ( false ) ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public NodeIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { String val = getNodeValue ( node ) ; if ( _value . equals ( val ) == _op ) { if ( _returnType == RETURN_CURRENT ) return returnNode ( node ) ; else return returnNode ( getParent ( node ) ) ; } } return END ; } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; return resetPosition ( ) ; } return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } public MultiDOM ( DOM main ) { _size = INITIAL_SIZE ; _free = 1 ; _adapters = new DOM [ INITIAL_SIZE ] ; _adapters [ 0 ] = main ; } public int nextMask ( ) { return ( _free << 24 ) ; } public void setupMapping ( String [ ] names , String [ ] namespaces ) { } public int addDOMAdapter ( DOMAdapter dom ) { final int domNo = _free ++ ; if ( domNo == _size ) { final DOMAdapter [ ] newArray = new DOMAdapter [ _size *= 2 ] ; System . arraycopy ( _adapters , 0 , newArray , 0 , domNo ) ; _adapters = newArray ; } _adapters [ domNo ] = dom ; String uri = dom . getDocumentURI ( 0 ) ; _documents . put ( uri , new Integer ( domNo ) ) ; dom . setMultiDOMMask ( domNo << 24 ) ; return ( domNo << 24 ) ; } public int getDocumentMask ( String uri ) { Integer domIdx = ( Integer ) _documents . get ( uri ) ; if ( domIdx == null ) return ( - 1 ) ; else return ( ( domIdx . intValue ( ) << 24 ) ) ; } public NodeIterator getIterator ( ) { return _adapters [ 0 ] . getIterator ( ) ; } public String getStringValue ( ) { return _adapters [ 0 ] . getStringValue ( ) ; } public String getTreeString ( ) { return _adapters [ 0 ] . getTreeString ( ) ; } public NodeIterator getChildren ( final int node ) { return ( node & SET ) == 0 ? _adapters [ 0 ] . getChildren ( node ) : getAxisIterator ( Axis . CHILD ) . setStartNode ( node ) ; } public NodeIterator getTypedChildren ( final int type ) { return new AxisIterator ( Axis . CHILD , type ) ; } public NodeIterator getAxisIterator ( final int axis ) { return new AxisIterator ( axis , NO_TYPE ) ; } public NodeIterator getTypedAxisIterator ( final int axis , final int type ) { return new AxisIterator ( axis , type ) ; } public NodeIterator getNthDescendant ( int node , int n , boolean includeself ) { return _adapters [ node > > > 24 ] . getNthDescendant ( node & CLR , n , includeself ) ; } public NodeIterator getNodeValueIterator ( NodeIterator iterator , int type , String value , boolean op ) { return ( new NodeValueIterator ( iterator , type , value , op ) ) ; } public NodeIterator getNamespaceAxisIterator ( final int axis , final int ns ) { NodeIterator iterator = _adapters [ 0 ] . getNamespaceAxisIterator ( axis , ns ) ; return ( iterator ) ; } public NodeIterator orderNodes ( NodeIterator source , int node ) { return _adapters [ node > > > 24 ] . orderNodes ( source , node & CLR ) ; } public int getType ( final int node ) { return _adapters [ node > > > 24 ] . getType ( node & CLR ) ; } public int getNamespaceType ( final int node ) { return _adapters [ node > > > 24 ] . getNamespaceType ( node & CLR ) ; } public int getParent ( final int node ) { return _adapters [ node > > > 24 ] . getParent ( node & CLR ) | node & SET ; } public int getTypedPosition ( int type , int node ) { return _adapters [ node > > > 24 ] . getTypedPosition ( type , node & CLR ) ; } public int getTypedLast ( int type , int node ) { return _adapters [ node > > > 24 ] . getTypedLast ( type , node & CLR ) ; } public int getAttributeNode ( final int type , final int el ) { return _adapters [ el > > > 24 ] . getAttributeNode ( type , el & CLR ) | el & SET ; } public String getNodeName ( final int node ) { return _adapters [ node > > > 24 ] . getNodeName ( node & CLR ) ; } public String getNamespaceName ( final int node ) { return _adapters [ node > > > 24 ] . getNamespaceName ( node & CLR ) ; } public String getNodeValue ( final int node ) { return _adapters [ node > > > 24 ] . getNodeValue ( node & CLR ) ; } public void copy ( final int node , TransletOutputHandler handler ) throws TransletException { _adapters [ node > > > 24 ] . copy ( node & CLR , handler ) ; } public void copy ( NodeIterator nodes , TransletOutputHandler handler ) throws TransletException { int node ; while ( ( node = nodes . next ( ) ) != DOM . NULL ) { _adapters [ node > > > 24 ] . copy ( node & CLR , handler ) ; } } public String shallowCopy ( final int node , TransletOutputHandler handler ) throws TransletException { return _adapters [ node > > > 24 ] . shallowCopy ( node & CLR , handler ) ; } public boolean lessThan ( final int node1 , final int node2 ) { final int dom1 = node1 > > > 24 ; final int dom2 = node2 > > > 24 ; return dom1 == dom2 ? _adapters [ dom1 ] . lessThan ( node1 & CLR , node2 & CLR ) : dom1 < dom2 ; } public void characters ( final int textNode , TransletOutputHandler handler ) throws TransletException { _adapters [ textNode > > > 24 ] . characters ( textNode & CLR , handler ) ; } public void setFilter ( StripFilter filter ) { for ( int dom = 0 ; dom < _free ; dom ++ ) { _adapters [ dom ] . setFilter ( filter ) ; } } public Node makeNode ( int index ) { return _adapters [ index > > > 24 ] . makeNode ( index & CLR ) ; } public Node makeNode ( NodeIterator iter ) { return _adapters [ 0 ] . makeNode ( iter ) ; } public NodeList makeNodeList ( int index ) { return _adapters [ index > > > 24 ] . makeNodeList ( index & CLR ) ; } public NodeList makeNodeList ( NodeIterator iter ) { return _adapters [ 0 ] . makeNodeList ( iter ) ; } public String getLanguage ( int node ) { return _adapters [ node > > > 24 ] . getLanguage ( node & CLR ) ; } public int getSize ( ) { int size = 0 ; for ( int i = 0 ; i < _size ; i ++ ) size += _adapters [ i ] . getSize ( ) ; return ( size ) ; } public String getDocumentURI ( int node ) { return _adapters [ node > > > 24 ] . getDocumentURI ( 0 ) ; } public boolean isElement ( final int node ) { return ( _adapters [ node > > > 24 ] . isElement ( node & CLR ) ) ; } public boolean isAttribute ( final int node ) { return ( _adapters [ node > > > 24 ] . isAttribute ( node & CLR ) ) ; } public String lookupNamespace ( int node , String prefix ) throws TransletException { return _adapters [ node > > > 24 ] . lookupNamespace ( node , prefix ) ; } } 	1	['42', '1', '0', '11', '86', '0', '4', '9', '41', '0.887195122', '572', '1', '2', '0', '0.19047619', '0', '0', '12.42857143', '3', '1.1429', '1']
package org . apache . xalan . xsltc . runtime ; public interface Operators { public static final int EQ = 0 ; public static final int NE = 1 ; public static final int GT = 2 ; public static final int LT = 3 ; public static final int GE = 4 ; public static final int LE = 5 ; public static final String [ ] names = { "=" , "!=" , ">" , "<" , ">=" , "<=" } ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '0', '2', '36', '0', '0', '0', '0', '0', '0', '28', '0', '0', '0']
package org . apache . xalan . templates ; import org . apache . xml . dtm . DTM ; import org . xml . sax . * ; import org . apache . xpath . * ; import org . apache . xpath . Expression ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XRTreeFragSelectWrapper ; import org . apache . xml . utils . QName ; import org . apache . xalan . trace . SelectionEvent ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import javax . xml . transform . TransformerException ; public class ElemVariable extends ElemTemplateElement { public ElemVariable ( ) { } protected int m_index ; int m_frameSize = - 1 ; public void setIndex ( int index ) { m_index = index ; } public int getIndex ( ) { return m_index ; } private XPath m_selectPattern ; public void setSelect ( XPath v ) { m_selectPattern = v ; } public XPath getSelect ( ) { return m_selectPattern ; } protected QName m_qname ; public void setName ( QName v ) { m_qname = v ; } public QName getName ( ) { return m_qname ; } private boolean m_isTopLevel = false ; public void setIsTopLevel ( boolean v ) { m_isTopLevel = v ; } public boolean getIsTopLevel ( ) { return m_isTopLevel ; } public int getXSLToken ( ) { return Constants . ELEMNAME_VARIABLE ; } public String getNodeName ( ) { return Constants . ELEMNAME_VARIABLE_STRING ; } public ElemVariable ( ElemVariable param ) throws TransformerException { m_selectPattern = param . m_selectPattern ; m_qname = param . m_qname ; m_isTopLevel = param . m_isTopLevel ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , var ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public XObject getValue ( TransformerImpl transformer , int sourceNode ) throws TransformerException { XObject var ; XPathContext xctxt = transformer . getXPathContext ( ) ; xctxt . pushCurrentNode ( sourceNode ) ; try { if ( null != m_selectPattern ) { var = m_selectPattern . execute ( xctxt , sourceNode , this ) ; var . allowDetachToRelease ( false ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , m_selectPattern , var ) ; } else if ( null == getFirstChildElem ( ) ) { var = XString . EMPTYSTRING ; } else { int df ; try { if ( m_parentNode instanceof Stylesheet ) df = transformer . transformToGlobalRTF ( this ) ; else df = transformer . transformToRTF ( this ) ; } finally { } var = new XRTreeFrag ( df , xctxt , this ) ; } } finally { xctxt . popCurrentNode ( ) ; } return var ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { if ( null == m_selectPattern && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { XPath newSelect = rewriteChildToExpression ( this ) ; if ( null != newSelect ) m_selectPattern = newSelect ; } StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_selectPattern ) m_selectPattern . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( ! ( m_parentNode instanceof Stylesheet ) ) { m_index = cstate . addVariableName ( m_qname ) - cstate . getGlobalsSize ( ) ; } else { cstate . resetStackFrameSize ( ) ; } super . compose ( sroot ) ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { super . endCompose ( sroot ) ; if ( m_parentNode instanceof Stylesheet ) { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; m_frameSize = cstate . getFrameSize ( ) ; cstate . resetStackFrameSize ( ) ; } } static XPath rewriteChildToExpression ( ElemTemplateElement varElem ) throws TransformerException { ElemTemplateElement t = varElem . getFirstChildElem ( ) ; if ( null != t && null == t . getNextSiblingElem ( ) ) { int etype = t . getXSLToken ( ) ; if ( Constants . ELEMNAME_VALUEOF == etype ) { ElemValueOf valueof = ( ElemValueOf ) t ; if ( valueof . getDisableOutputEscaping ( ) == false && valueof . getDOMBackPointer ( ) == null ) { varElem . m_firstChild = null ; return new XPath ( new XRTreeFragSelectWrapper ( valueof . getSelect ( ) . getExpression ( ) ) ) ; } } else if ( Constants . ELEMNAME_TEXTLITERALRESULT == etype ) { ElemTextLiteral lit = ( ElemTextLiteral ) t ; if ( lit . getDisableOutputEscaping ( ) == false && lit . getDOMBackPointer ( ) == null ) { String str = lit . getNodeValue ( ) ; XString xstr = new XString ( str ) ; varElem . m_firstChild = null ; return new XPath ( new XRTreeFragSelectWrapper ( xstr ) ) ; } } } return null ; } public void recompose ( StylesheetRoot root ) { root . recomposeVariables ( this ) ; } public void setParentElem ( ElemTemplateElement p ) { super . setParentElem ( p ) ; p . m_hasVariableDecl = true ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitVariableOrParamDecl ( this ) ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( null != m_selectPattern ) m_selectPattern . getExpression ( ) . callVisitors ( m_selectPattern , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } public boolean isPsuedoVar ( ) { java . lang . String ns = m_qname . getNamespaceURI ( ) ; if ( ( null != ns ) && ns . equals ( RedundentExprEliminator . PSUEDOVARNAMESPACE ) ) { if ( m_qname . getLocalName ( ) . startsWith ( "#" ) ) return true ; } return false ; } } 	1	['22', '3', '3', '38', '68', '155', '20', '24', '19', '0.828571429', '383', '0.8', '2', '0.907407407', '0.168181818', '2', '15', '16.18181818', '4', '1.0909', '1']
package org . apache . xalan . trace ; public interface TraceListenerEx2 extends TraceListenerEx { public void traceEnd ( TracerEvent ev ) ; } 	0	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . runtime ; import org . xml . sax . * ; import org . xml . sax . ext . * ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . TransletOutputHandler ; import org . apache . xalan . xsltc . dom . DOMBuilder ; public final class SAXAdapter implements TransletOutputHandler { private final DOMBuilder _domBuilder ; private final AttributeList _attributes = new AttributeList ( ) ; private String _openElementName ; public SAXAdapter ( DOMBuilder domBuilder ) { _domBuilder = domBuilder ; } private void maybeEmitStartElement ( ) throws SAXException { if ( _openElementName != null ) { _domBuilder . startElement ( null , null , _openElementName , _attributes ) ; _openElementName = null ; } } public void startDocument ( ) throws TransletException { try { _domBuilder . startDocument ( ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void endDocument ( ) throws TransletException { try { _domBuilder . endDocument ( ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void characters ( String characters ) throws TransletException { characters ( characters . toCharArray ( ) , 0 , characters . length ( ) ) ; } public void characters ( char [ ] characters , int offset , int length ) throws TransletException { try { maybeEmitStartElement ( ) ; _domBuilder . characters ( characters , offset , length ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void startElement ( String elementName ) throws TransletException { try { maybeEmitStartElement ( ) ; _openElementName = elementName ; _attributes . clear ( ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void endElement ( String elementName ) throws TransletException { try { maybeEmitStartElement ( ) ; _domBuilder . endElement ( null , null , elementName ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void attribute ( String name , String value ) throws TransletException { if ( _openElementName != null ) { _attributes . add ( name , value ) ; } else { BasisLibrary . runTimeError ( BasisLibrary . STRAY_ATTRIBUTE_ERR , name ) ; } } public void namespace ( String prefix , String uri ) throws TransletException { } public void comment ( String comment ) throws TransletException { try { maybeEmitStartElement ( ) ; if ( _domBuilder != null ) { char [ ] chars = comment . toCharArray ( ) ; _domBuilder . comment ( chars , 0 , chars . length ) ; } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public void processingInstruction ( String target , String data ) throws TransletException { try { maybeEmitStartElement ( ) ; _domBuilder . processingInstruction ( target , data ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } public boolean setEscaping ( boolean escape ) throws TransletException { return _domBuilder . setEscaping ( escape ) ; } public void startCDATA ( ) throws TransletException { } public void endCDATA ( ) throws TransletException { } public void setType ( int type ) { } public void setHeader ( String header ) { } public void setIndent ( boolean indent ) { } public void omitHeader ( boolean value ) { } public void setCdataElements ( Hashtable elements ) { } public void setDoctype ( String system , String pub ) { } public void setMediaType ( String mediaType ) { } public void setStandalone ( String standalone ) { } public void setVersion ( String version ) { } public void close ( ) { } public String getPrefix ( String uri ) { return ( "" ) ; } } 	1	['26', '1', '0', '8', '42', '243', '1', '7', '25', '0.693333333', '205', '1', '2', '0', '0.258241758', '0', '0', '6.769230769', '1', '0.9615', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . NodeIterator ; public abstract class AnyNodeCounter extends NodeCounter { public AnyNodeCounter ( Translet translet , DOM document , NodeIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getType ( node ) ; return this ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next = _node ; result = 0 ; while ( next >= 0 && ! matchesFrom ( next ) ) { if ( matchesCount ( next ) ) { ++ result ; } -- next ; } } return formatNumbers ( result ) ; } public static NodeCounter getDefaultNodeCounter ( Translet translet , DOM document , NodeIterator iterator ) { return new DefaultAnyNodeCounter ( translet , document , iterator ) ; } static class DefaultAnyNodeCounter extends AnyNodeCounter { public DefaultAnyNodeCounter ( Translet translet , DOM document , NodeIterator iterator ) { super ( translet , document , iterator ) ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next = _node ; result = 0 ; final int ntype = _document . getType ( _node ) ; while ( next >= 0 ) { if ( ntype == _document . getType ( next ) ) { result ++ ; } next -- ; } } return formatNumbers ( result ) ; } } } 	0	['4', '2', '1', '5', '10', '6', '1', '5', '4', '2', '58', '0', '0', '0.823529412', '0.5', '1', '4', '13.5', '5', '1.75', '0']
package org . apache . xpath . compiler ; import org . apache . xpath . operations . And ; import org . apache . xpath . operations . Bool ; import org . apache . xpath . operations . Div ; import org . apache . xpath . operations . Equals ; import org . apache . xpath . operations . Gt ; import org . apache . xpath . operations . Gte ; import org . apache . xpath . operations . Lt ; import org . apache . xpath . operations . Lte ; import org . apache . xpath . operations . Minus ; import org . apache . xpath . operations . Mod ; import org . apache . xpath . operations . Mult ; import org . apache . xpath . operations . Neg ; import org . apache . xpath . operations . NotEquals ; import org . apache . xpath . operations . Operation ; import org . apache . xpath . operations . Or ; import org . apache . xpath . operations . Plus ; import org . apache . xpath . operations . UnaryOperation ; import org . apache . xpath . operations . Variable ; import org . apache . xpath . objects . * ; import org . apache . xpath . axes . * ; import org . apache . xpath . patterns . * ; import org . apache . xpath . functions . Function ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . * ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . PrefixResolver ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . SourceLocator ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . Axis ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . TransformerException ; public class Compiler extends OpMap { public Compiler ( ErrorListener errorHandler , SourceLocator locator ) { m_errorHandler = errorHandler ; m_locator = locator ; } public Compiler ( ) { m_errorHandler = null ; m_locator = null ; } public Expression compile ( int opPos ) throws TransformerException { int op = m_opMap [ opPos ] ; Expression expr = null ; switch ( op ) { case OpCodes . OP_XPATH : expr = compile ( opPos + 2 ) ; break ; case OpCodes . OP_OR : expr = or ( opPos ) ; break ; case OpCodes . OP_AND : expr = and ( opPos ) ; break ; case OpCodes . OP_NOTEQUALS : expr = notequals ( opPos ) ; break ; case OpCodes . OP_EQUALS : expr = equals ( opPos ) ; break ; case OpCodes . OP_LTE : expr = lte ( opPos ) ; break ; case OpCodes . OP_LT : expr = lt ( opPos ) ; break ; case OpCodes . OP_GTE : expr = gte ( opPos ) ; break ; case OpCodes . OP_GT : expr = gt ( opPos ) ; break ; case OpCodes . OP_PLUS : expr = plus ( opPos ) ; break ; case OpCodes . OP_MINUS : expr = minus ( opPos ) ; break ; case OpCodes . OP_MULT : expr = mult ( opPos ) ; break ; case OpCodes . OP_DIV : expr = div ( opPos ) ; break ; case OpCodes . OP_MOD : expr = mod ( opPos ) ; break ; case OpCodes . OP_NEG : expr = neg ( opPos ) ; break ; case OpCodes . OP_STRING : expr = string ( opPos ) ; break ; case OpCodes . OP_BOOL : expr = bool ( opPos ) ; break ; case OpCodes . OP_NUMBER : expr = number ( opPos ) ; break ; case OpCodes . OP_UNION : expr = union ( opPos ) ; break ; case OpCodes . OP_LITERAL : expr = literal ( opPos ) ; break ; case OpCodes . OP_VARIABLE : expr = variable ( opPos ) ; break ; case OpCodes . OP_GROUP : expr = group ( opPos ) ; break ; case OpCodes . OP_NUMBERLIT : expr = numberlit ( opPos ) ; break ; case OpCodes . OP_ARGUMENT : expr = arg ( opPos ) ; break ; case OpCodes . OP_EXTFUNCTION : expr = compileExtension ( opPos ) ; break ; case OpCodes . OP_FUNCTION : expr = compileFunction ( opPos ) ; break ; case OpCodes . OP_LOCATIONPATH : expr = locationPath ( opPos ) ; break ; case OpCodes . OP_PREDICATE : expr = null ; break ; case OpCodes . OP_MATCHPATTERN : expr = matchPattern ( opPos + 2 ) ; break ; case OpCodes . OP_LOCATIONPATHPATTERN : expr = locationPathPattern ( opPos ) ; break ; case OpCodes . OP_QUO : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { "quo" } ) ; break ; default : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { Integer . toString ( m_opMap [ opPos ] ) } ) ; } return expr ; } private Expression compileOperation ( Operation operation , int opPos ) throws TransformerException { int leftPos = getFirstChildPos ( opPos ) ; int rightPos = getNextOpPos ( leftPos ) ; operation . setLeftRight ( compile ( leftPos ) , compile ( rightPos ) ) ; return operation ; } private Expression compileUnary ( UnaryOperation unary , int opPos ) throws TransformerException { int rightPos = getFirstChildPos ( opPos ) ; unary . setRight ( compile ( rightPos ) ) ; return unary ; } protected Expression or ( int opPos ) throws TransformerException { return compileOperation ( new Or ( ) , opPos ) ; } protected Expression and ( int opPos ) throws TransformerException { return compileOperation ( new And ( ) , opPos ) ; } protected Expression notequals ( int opPos ) throws TransformerException { return compileOperation ( new NotEquals ( ) , opPos ) ; } protected Expression equals ( int opPos ) throws TransformerException { return compileOperation ( new Equals ( ) , opPos ) ; } protected Expression lte ( int opPos ) throws TransformerException { return compileOperation ( new Lte ( ) , opPos ) ; } protected Expression lt ( int opPos ) throws TransformerException { return compileOperation ( new Lt ( ) , opPos ) ; } protected Expression gte ( int opPos ) throws TransformerException { return compileOperation ( new Gte ( ) , opPos ) ; } protected Expression gt ( int opPos ) throws TransformerException { return compileOperation ( new Gt ( ) , opPos ) ; } protected Expression plus ( int opPos ) throws TransformerException { return compileOperation ( new Plus ( ) , opPos ) ; } protected Expression minus ( int opPos ) throws TransformerException { return compileOperation ( new Minus ( ) , opPos ) ; } protected Expression mult ( int opPos ) throws TransformerException { return compileOperation ( new Mult ( ) , opPos ) ; } protected Expression div ( int opPos ) throws TransformerException { return compileOperation ( new Div ( ) , opPos ) ; } protected Expression mod ( int opPos ) throws TransformerException { return compileOperation ( new Mod ( ) , opPos ) ; } protected Expression neg ( int opPos ) throws TransformerException { return compileUnary ( new Neg ( ) , opPos ) ; } protected Expression string ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . String ( ) , opPos ) ; } protected Expression bool ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . Bool ( ) , opPos ) ; } protected Expression number ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . Number ( ) , opPos ) ; } protected Expression literal ( int opPos ) { opPos = getFirstChildPos ( opPos ) ; return ( XString ) m_tokenQueue [ m_opMap [ opPos ] ] ; } protected Expression numberlit ( int opPos ) { opPos = getFirstChildPos ( opPos ) ; return ( XNumber ) m_tokenQueue [ m_opMap [ opPos ] ] ; } protected Expression variable ( int opPos ) throws TransformerException { Variable var = new Variable ( ) ; opPos = getFirstChildPos ( opPos ) ; int nsPos = m_opMap [ opPos ] ; java . lang . String namespace = ( OpCodes . EMPTY == nsPos ) ? null : ( java . lang . String ) m_tokenQueue [ nsPos ] ; java . lang . String localname = ( java . lang . String ) m_tokenQueue [ m_opMap [ opPos + 1 ] ] ; QName qname = new QName ( namespace , localname ) ; var . setQName ( qname ) ; return var ; } protected Expression group ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression arg ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression union ( int opPos ) throws TransformerException { locPathDepth ++ ; try { return UnionPathIterator . createUnionIterator ( this , opPos ) ; } finally { locPathDepth -- ; } } private int locPathDepth = - 1 ; public int getLocationPathDepth ( ) { return locPathDepth ; } public Expression locationPath ( int opPos ) throws TransformerException { locPathDepth ++ ; try { DTMIterator iter = WalkerFactory . newDTMIterator ( this , opPos , ( locPathDepth == 0 ) ) ; return ( Expression ) iter ; } finally { locPathDepth -- ; } } public Expression predicate ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression matchPattern ( int opPos ) throws TransformerException { locPathDepth ++ ; try { int nextOpPos = opPos ; int i ; for ( i = 0 ; m_opMap [ nextOpPos ] == OpCodes . OP_LOCATIONPATHPATTERN ; i ++ ) { nextOpPos = getNextOpPos ( nextOpPos ) ; } if ( i == 1 ) return compile ( opPos ) ; UnionPattern up = new UnionPattern ( ) ; StepPattern [ ] patterns = new StepPattern [ i ] ; for ( i = 0 ; m_opMap [ opPos ] == OpCodes . OP_LOCATIONPATHPATTERN ; i ++ ) { nextOpPos = getNextOpPos ( opPos ) ; patterns [ i ] = ( StepPattern ) compile ( opPos ) ; opPos = nextOpPos ; } up . setPatterns ( patterns ) ; return up ; } finally { locPathDepth -- ; } } public Expression locationPathPattern ( int opPos ) throws TransformerException { opPos = getFirstChildPos ( opPos ) ; return stepPattern ( opPos , 0 , null ) ; } public int getWhatToShow ( int opPos ) { int axesType = getOp ( opPos ) ; int testType = getOp ( opPos + 3 ) ; switch ( testType ) { case OpCodes . NODETYPE_COMMENT : return DTMFilter . SHOW_COMMENT ; case OpCodes . NODETYPE_TEXT : return DTMFilter . SHOW_TEXT | DTMFilter . SHOW_CDATA_SECTION ; case OpCodes . NODETYPE_PI : return DTMFilter . SHOW_PROCESSING_INSTRUCTION ; case OpCodes . NODETYPE_NODE : switch ( axesType ) { case OpCodes . FROM_NAMESPACE : return DTMFilter . SHOW_NAMESPACE ; case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : return DTMFilter . SHOW_ATTRIBUTE ; case OpCodes . FROM_SELF : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . FROM_DESCENDANTS_OR_SELF : return DTMFilter . SHOW_ALL ; default : if ( getOp ( 0 ) == OpCodes . OP_MATCHPATTERN ) return ~ DTMFilter . SHOW_ATTRIBUTE & ~ DTMFilter . SHOW_DOCUMENT & ~ DTMFilter . SHOW_DOCUMENT_FRAGMENT ; else return ~ DTMFilter . SHOW_ATTRIBUTE ; } case OpCodes . NODETYPE_ROOT : return DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ; case OpCodes . NODETYPE_FUNCTEST : return NodeTest . SHOW_BYFUNCTION ; case OpCodes . NODENAME : switch ( axesType ) { case OpCodes . FROM_NAMESPACE : return DTMFilter . SHOW_NAMESPACE ; case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : return DTMFilter . SHOW_ATTRIBUTE ; case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : return DTMFilter . SHOW_ELEMENT ; default : return DTMFilter . SHOW_ELEMENT ; } default : return DTMFilter . SHOW_ALL ; } } private static final boolean DEBUG = false ; protected StepPattern stepPattern ( int opPos , int stepCount , StepPattern ancestorPattern ) throws TransformerException { int startOpPos = opPos ; int stepType = getOpMap ( ) [ opPos ] ; if ( OpCodes . ENDOP == stepType ) { return null ; } boolean addMagicSelf = true ; int endStep = getNextOpPos ( opPos ) ; StepPattern pattern ; int argLen ; switch ( stepType ) { case OpCodes . OP_FUNCTION : if ( DEBUG ) System . out . println ( "MATCH_FUNCTION: " + m_currentPattern ) ; addMagicSelf = false ; argLen = m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] ; pattern = new FunctionPattern ( compileFunction ( opPos ) , Axis . PARENT , Axis . CHILD ) ; break ; case OpCodes . FROM_ROOT : if ( DEBUG ) System . out . println ( "FROM_ROOT, " + m_currentPattern ) ; addMagicSelf = false ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT , Axis . PARENT , Axis . CHILD ) ; break ; case OpCodes . MATCH_ATTRIBUTE : if ( DEBUG ) System . out . println ( "MATCH_ATTRIBUTE: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( DTMFilter . SHOW_ATTRIBUTE , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . PARENT , Axis . ATTRIBUTE ) ; break ; case OpCodes . MATCH_ANY_ANCESTOR : if ( DEBUG ) System . out . println ( "MATCH_ANY_ANCESTOR: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; int what = getWhatToShow ( startOpPos ) ; if ( 0x00000500 == what ) addMagicSelf = false ; pattern = new StepPattern ( getWhatToShow ( startOpPos ) , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . ANCESTOR , Axis . CHILD ) ; break ; case OpCodes . MATCH_IMMEDIATE_ANCESTOR : if ( DEBUG ) System . out . println ( "MATCH_IMMEDIATE_ANCESTOR: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( getWhatToShow ( startOpPos ) , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . PARENT , Axis . CHILD ) ; break ; default : error ( XPATHErrorResources . ER_UNKNOWN_MATCH_OPERATION , null ) ; return null ; } pattern . setPredicates ( getCompiledPredicates ( opPos + argLen ) ) ; if ( null == ancestorPattern ) { } else { pattern . setRelativePathPattern ( ancestorPattern ) ; } StepPattern relativePathPattern = stepPattern ( endStep , stepCount + 1 , pattern ) ; return ( null != relativePathPattern ) ? relativePathPattern : pattern ; } public Expression [ ] getCompiledPredicates ( int opPos ) throws TransformerException { int count = countPredicates ( opPos ) ; if ( count > 0 ) { Expression [ ] predicates = new Expression [ count ] ; compilePredicates ( opPos , predicates ) ; return predicates ; } return null ; } public int countPredicates ( int opPos ) throws TransformerException { int count = 0 ; while ( OpCodes . OP_PREDICATE == getOp ( opPos ) ) { count ++ ; opPos = getNextOpPos ( opPos ) ; } return count ; } private void compilePredicates ( int opPos , Expression [ ] predicates ) throws TransformerException { for ( int i = 0 ; OpCodes . OP_PREDICATE == getOp ( opPos ) ; i ++ ) { predicates [ i ] = predicate ( opPos ) ; opPos = getNextOpPos ( opPos ) ; } } Expression compileFunction ( int opPos ) throws TransformerException { int endFunc = opPos + m_opMap [ opPos + 1 ] - 1 ; opPos = getFirstChildPos ( opPos ) ; int funcID = m_opMap [ opPos ] ; opPos ++ ; if ( - 1 != funcID ) { Function func = FunctionTable . getFunction ( funcID ) ; func . postCompileStep ( this ) ; try { int i = 0 ; for ( int p = opPos ; p < endFunc ; p = getNextOpPos ( p ) , i ++ ) { func . setArg ( compile ( p ) , i ) ; } func . checkNumberArgs ( i ) ; } catch ( WrongNumberArgsException wnae ) { java . lang . String name = FunctionTable . m_functions [ funcID ] . getName ( ) ; m_errorHandler . fatalError ( new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_ONLY_ALLOWS , new Object [ ] { name , wnae . getMessage ( ) } ) , m_locator ) ) ; } return func ; } else { error ( XPATHErrorResources . ER_FUNCTION_TOKEN_NOT_FOUND , null ) ; return null ; } } private Expression compileExtension ( int opPos ) throws TransformerException { int endExtFunc = opPos + m_opMap [ opPos + 1 ] - 1 ; opPos = getFirstChildPos ( opPos ) ; java . lang . String ns = ( java . lang . String ) m_tokenQueue [ m_opMap [ opPos ] ] ; opPos ++ ; java . lang . String funcName = ( java . lang . String ) m_tokenQueue [ m_opMap [ opPos ] ] ; opPos ++ ; Function extension = new FuncExtFunction ( ns , funcName , String . valueOf ( opPos ) + String . valueOf ( hashCode ( ) ) + String . valueOf ( System . currentTimeMillis ( ) ) ) ; try { int i = 0 ; while ( opPos < endExtFunc ) { int nextOpPos = getNextOpPos ( opPos ) ; extension . setArg ( this . compile ( opPos ) , i ) ; opPos = nextOpPos ; i ++ ; } } catch ( WrongNumberArgsException wnae ) { ; } return extension ; } public void warn ( int msg , Object [ ] args ) throws TransformerException { java . lang . String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; if ( null != m_errorHandler ) { m_errorHandler . warning ( new TransformerException ( fmsg , m_locator ) ) ; } else { System . out . println ( fmsg + "; file " + m_locator . getSystemId ( ) + "; line " + m_locator . getLineNumber ( ) + "; column " + m_locator . getColumnNumber ( ) ) ; } } public void assertion ( boolean b , java . lang . String msg ) { if ( ! b ) { java . lang . String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( int msg , Object [ ] args ) throws TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != m_errorHandler ) { m_errorHandler . fatalError ( new TransformerException ( fmsg , m_locator ) ) ; } else { throw new TransformerException ( fmsg , ( SAXSourceLocator ) m_locator ) ; } } private PrefixResolver m_currentPrefixResolver = null ; public PrefixResolver getNamespaceContext ( ) { return m_currentPrefixResolver ; } public void setNamespaceContext ( PrefixResolver pr ) { m_currentPrefixResolver = pr ; } ErrorListener m_errorHandler ; SourceLocator m_locator ; } 	1	['45', '2', '0', '60', '111', '932', '24', '40', '15', '0.568181818', '1193', '0.6', '1', '0.328125', '0.175925926', '0', '0', '25.4', '12', '1.2222', '1']
package org . apache . xpath ; import org . w3c . dom . Element ; import javax . xml . transform . TransformerException ; public interface WhitespaceStrippingElementMatcher { public boolean shouldStripWhiteSpace ( XPathContext support , Element targetElement ) throws TransformerException ; public boolean canStripWhiteSpace ( ) ; } 	0	['2', '1', '0', '2', '2', '1', '1', '1', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . util ; public final class IntegerArray { private static final int InitialSize = 32 ; private int [ ] _array ; private int _size ; private int _free = 0 ; public IntegerArray ( ) { this ( InitialSize ) ; } public IntegerArray ( int size ) { _array = new int [ _size = size ] ; } public IntegerArray ( int [ ] array ) { this ( array . length ) ; System . arraycopy ( array , 0 , _array , 0 , _free = _size ) ; } public void clear ( ) { _free = 0 ; } public Object clone ( ) { final IntegerArray clone = new IntegerArray ( _array ) ; clone . _free = _free ; return clone ; } public int [ ] toIntArray ( ) { final int [ ] result = new int [ cardinality ( ) ] ; System . arraycopy ( _array , 0 , result , 0 , cardinality ( ) ) ; return result ; } public final int at ( int index ) { return _array [ index ] ; } public final void set ( int index , int value ) { _array [ index ] = value ; } public int indexOf ( int n ) { for ( int i = 0 ; i < _free ; i ++ ) { if ( n == _array [ i ] ) return i ; } return - 1 ; } public final void add ( int value ) { if ( _free == _size ) { growArray ( _size * 2 ) ; } _array [ _free ++ ] = value ; } public void addNew ( int value ) { for ( int i = 0 ; i < _free ; i ++ ) { if ( _array [ i ] == value ) return ; } add ( value ) ; } private void growArray ( int size ) { final int [ ] newArray = new int [ _size = size ] ; System . arraycopy ( _array , 0 , newArray , 0 , _free ) ; _array = newArray ; } public int popLast ( ) { return _array [ -- _free ] ; } public int last ( ) { return _array [ _free - 1 ] ; } public void setLast ( int n ) { _array [ _free - 1 ] = n ; } public void pop ( ) { _free -- ; } public void pop ( int n ) { _free -= n ; } public final int cardinality ( ) { return _free ; } public void print ( java . io . PrintStream out ) { if ( _free > 0 ) { for ( int i = 0 ; i < _free - 1 ; i ++ ) { out . print ( _array [ i ] ) ; out . print ( ' ' ) ; } out . println ( _array [ _free - 1 ] ) ; } else { out . println ( "IntegerArray: empty" ) ; } } } 	1	['19', '1', '0', '4', '25', '0', '4', '0', '18', '0.513888889', '256', '1', '0', '0', '0.394736842', '0', '0', '12.26315789', '3', '1.2105', '1']
package org . apache . xalan . xsltc . runtime ; import java . lang . Class ; import java . lang . ClassLoader ; import java . lang . Thread ; import java . net . * ; final public class TransletLoader { ClassLoader _loader = null ; public TransletLoader ( ) { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final String loaderName = loader . getClass ( ) . getName ( ) ; if ( loaderName . equals ( "sun.misc.Launcher$ExtClassLoader" ) ) { loader = ClassLoader . getSystemClassLoader ( ) ; } _loader = loader ; } public Class loadClass ( String name ) throws ClassNotFoundException { return ( Class . forName ( name , false , _loader ) ) ; } public Class loadTranslet ( String name ) throws ClassNotFoundException { return ( Class . forName ( name , true , _loader ) ) ; } } 	0	['3', '1', '0', '4', '11', '0', '4', '0', '3', '0', '38', '0', '0', '0', '0.833333333', '0', '0', '11.33333333', '1', '0.6667', '0']
package org . apache . xpath . functions ; import java . util . Vector ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . functions . Function3Args . Arg2Owner ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; public class FunctionMultiArgs extends Function3Args { Expression [ ] m_args ; public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( argNum < 3 ) super . setArg ( arg , argNum ) ; else { if ( null == m_args ) { m_args = new Expression [ 1 ] ; m_args [ 0 ] = arg ; } else { Expression [ ] args = new Expression [ m_args . length + 1 ] ; System . arraycopy ( m_args , 0 , args , 0 , m_args . length ) ; args [ m_args . length ] = arg ; m_args = args ; } arg . exprSetParent ( this ) ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_args ) { for ( int i = 0 ; i < m_args . length ; i ++ ) { m_args [ i ] . fixupVariables ( vars , globalsSize ) ; } } } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { "Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called." } ) ; throw new RuntimeException ( fMsg ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( super . canTraverseOutsideSubtree ( ) ) return true ; else { int n = m_args . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( m_args [ i ] . canTraverseOutsideSubtree ( ) ) return true ; } return false ; } } class ArgMultiOwner implements ExpressionOwner { int m_argIndex ; ArgMultiOwner ( int index ) { m_argIndex = index ; } public Expression getExpression ( ) { return m_args [ m_argIndex ] ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FunctionMultiArgs . this ) ; m_args [ m_argIndex ] = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { super . callArgVisitors ( visitor ) ; if ( null != m_args ) { int n = m_args . length ; for ( int i = 0 ; i < n ; i ++ ) { m_args [ i ] . callVisitors ( new ArgMultiOwner ( i ) , visitor ) ; } } } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FunctionMultiArgs fma = ( FunctionMultiArgs ) expr ; if ( null != m_args ) { int n = m_args . length ; if ( ( null == fma ) || ( fma . m_args . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_args [ i ] . deepEquals ( fma . m_args [ i ] ) ) return false ; } } else if ( null != fma . m_args ) { return false ; } return true ; } } 	1	['8', '6', '1', '10', '23', '8', '2', '9', '7', '0.428571429', '214', '0', '1', '0.901408451', '0.375', '5', '22', '25.625', '7', '2.5', '1']
package org . apache . xpath ; public interface ExpressionOwner { public Expression getExpression ( ) ; public void setExpression ( Expression exp ) ; } 	0	['2', '1', '0', '53', '2', '1', '53', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . dom ; import java . net . URL ; import java . io . File ; import java . io . FileNotFoundException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXException ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . NodeIterator ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; public final class LoadDocument { private static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static NodeIterator document ( String uri , String base , AbstractTranslet translet , DOM dom ) throws Exception { final String originalUri = uri ; MultiDOM multiplexer = ( MultiDOM ) dom ; if ( uri == null || uri . equals ( "" ) ) { return new SingletonIterator ( DOM . NULL , true ) ; } if ( base != null && ! base . equals ( "" ) ) { if ( ! uri . startsWith ( base ) && ! uri . startsWith ( "/" ) && ! uri . startsWith ( "http:/" ) && ! uri . startsWith ( "file:/" ) ) { uri = base + uri ; } } final File file = new File ( uri ) ; if ( file . exists ( ) ) { uri = file . toURL ( ) . toExternalForm ( ) ; } int mask = multiplexer . getDocumentMask ( uri ) ; if ( mask != - 1 ) { return new SingletonIterator ( DOM . ROOTNODE | mask , true ) ; } DOMCache cache = translet . getDOMCache ( ) ; DOMImpl newdom ; mask = multiplexer . nextMask ( ) ; if ( cache != null ) { newdom = cache . retrieveDocument ( originalUri , mask , translet ) ; if ( newdom == null ) { final Exception e = new FileNotFoundException ( originalUri ) ; throw new TransletException ( e ) ; } } else { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { factory . setFeature ( NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { factory . setNamespaceAware ( true ) ; } final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; newdom = new DOMImpl ( ) ; reader . setContentHandler ( newdom . getBuilder ( ) ) ; DTDMonitor dtdMonitor = new DTDMonitor ( ) ; dtdMonitor . handleDTD ( reader ) ; newdom . setDocumentURI ( uri ) ; reader . parse ( uri ) ; translet . setIndexSize ( newdom . getSize ( ) ) ; dtdMonitor . buildIdIndex ( newdom , mask , translet ) ; translet . setUnparsedEntityURIs ( dtdMonitor . getUnparsedEntityURIs ( ) ) ; } final DOMAdapter domAdapter = translet . makeDOMAdapter ( newdom ) ; mask = multiplexer . addDOMAdapter ( domAdapter ) ; translet . buildKeys ( ( DOM ) newdom , null , null , DOM . ROOTNODE | mask ) ; return new SingletonIterator ( DOM . ROOTNODE | mask , true ) ; } public static NodeIterator document ( Object arg , String xmlURI , String xslURI , AbstractTranslet translet , DOM dom ) throws TransletException { try { if ( xmlURI != null ) { final int sep = xmlURI . lastIndexOf ( '/' ) + 1 ; xmlURI = xmlURI . substring ( 0 , sep ) ; } else { xmlURI = "" ; } if ( xslURI != null ) { final int sep = xslURI . lastIndexOf ( '/' ) + 1 ; xslURI = xslURI . substring ( 0 , sep ) ; } else { xslURI = "" ; } if ( arg instanceof String ) { try { return document ( ( String ) arg , xmlURI , translet , dom ) ; } catch ( java . io . FileNotFoundException e ) { return document ( ( String ) arg , xslURI , translet , dom ) ; } catch ( org . xml . sax . SAXParseException e ) { return document ( ( String ) arg , xslURI , translet , dom ) ; } } else if ( arg instanceof NodeIterator ) { UnionIterator union = new UnionIterator ( dom ) ; NodeIterator iterator = ( NodeIterator ) arg ; int node ; while ( ( node = iterator . next ( ) ) != DOM . NULL ) { String uri = dom . getNodeValue ( node ) ; if ( ( xmlURI == null ) || xmlURI . equals ( "" ) ) { xmlURI = dom . getDocumentURI ( node ) ; final int sep = xmlURI . lastIndexOf ( '/' ) + 1 ; xmlURI = xmlURI . substring ( 0 , sep ) ; } try { union . addIterator ( document ( uri , xmlURI , translet , dom ) ) ; } catch ( java . io . FileNotFoundException e ) { union . addIterator ( document ( uri , xslURI , translet , dom ) ) ; } } return ( union ) ; } else { final String err = "document(" + arg . toString ( ) + ")" ; throw new IllegalArgumentException ( err ) ; } } catch ( TransletException e ) { throw e ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } } 	1	['3', '1', '0', '15', '49', '3', '0', '15', '3', '1.5', '329', '1', '0', '0', '0.533333333', '0', '0', '108.3333333', '1', '0.6667', '1']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . XPathContext ; public class Div extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) / right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) / m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xpath . axes ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . patterns . ContextMatchStepPattern ; import org . apache . xpath . patterns . FunctionPattern ; import org . apache . xpath . Expression ; import org . apache . xpath . objects . XNumber ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . Axis ; public class WalkerFactory { static AxesWalker loadOneWalker ( WalkingIterator lpi , Compiler compiler , int stepOpCodePos ) throws javax . xml . transform . TransformerException { AxesWalker firstWalker = null ; int stepType = compiler . getOpMap ( ) [ stepOpCodePos ] ; if ( stepType != OpCodes . ENDOP ) { firstWalker = createDefaultWalker ( compiler , stepType , lpi , 0 ) ; firstWalker . init ( compiler , stepOpCodePos , stepType ) ; } return firstWalker ; } static AxesWalker loadWalkers ( WalkingIterator lpi , Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; AxesWalker firstWalker = null ; AxesWalker walker , prevWalker = null ; int ops [ ] = compiler . getOpMap ( ) ; int analysis = analyze ( compiler , stepOpCodePos , stepIndex ) ; while ( OpCodes . ENDOP != ( stepType = ops [ stepOpCodePos ] ) ) { walker = createDefaultWalker ( compiler , stepOpCodePos , lpi , analysis ) ; walker . init ( compiler , stepOpCodePos , stepType ) ; walker . exprSetParent ( lpi ) ; if ( null == firstWalker ) { firstWalker = walker ; } else { prevWalker . setNextWalker ( walker ) ; walker . setPrevWalker ( prevWalker ) ; } prevWalker = walker ; stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } return firstWalker ; } public static boolean isSet ( int analysis , int bits ) { return ( 0 != ( analysis & bits ) ) ; } public static void diagnoseIterator ( String name , int analysis , Compiler compiler ) { System . out . println ( compiler . toString ( ) + ", " + name + ", " + Integer . toBinaryString ( analysis ) + ", " + getAnalysisString ( analysis ) ) ; } public static DTMIterator newDTMIterator ( Compiler compiler , int opPos , boolean isTopLevel ) throws javax . xml . transform . TransformerException { int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int analysis = analyze ( compiler , firstStepPos , 0 ) ; boolean isOneStep = isOneStep ( analysis ) ; DTMIterator iter ; if ( isOneStep && walksSelfOnly ( analysis ) && isWild ( analysis ) && ! hasPredicate ( analysis ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "SelfIteratorNoPredicate" , analysis , compiler ) ; iter = new SelfIteratorNoPredicate ( compiler , opPos , analysis ) ; } else if ( walksChildrenOnly ( analysis ) && isOneStep ) { if ( isWild ( analysis ) && ! hasPredicate ( analysis ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "ChildIterator" , analysis , compiler ) ; iter = new ChildIterator ( compiler , opPos , analysis ) ; } else { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "ChildTestIterator" , analysis , compiler ) ; iter = new ChildTestIterator ( compiler , opPos , analysis ) ; } } else if ( isOneStep && walksAttributes ( analysis ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "AttributeIterator" , analysis , compiler ) ; iter = new AttributeIterator ( compiler , opPos , analysis ) ; } else if ( isOneStep && ! walksFilteredList ( analysis ) ) { if ( ! walksNamespaces ( analysis ) && ( walksInDocOrder ( analysis ) || isSet ( analysis , BIT_PARENT ) ) ) { if ( false || DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "OneStepIteratorForward" , analysis , compiler ) ; iter = new OneStepIteratorForward ( compiler , opPos , analysis ) ; } else { if ( false || DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "OneStepIterator" , analysis , compiler ) ; iter = new OneStepIterator ( compiler , opPos , analysis ) ; } } else if ( isOptimizableForDescendantIterator ( compiler , firstStepPos , 0 ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "DescendantIterator" , analysis , compiler ) ; iter = new DescendantIterator ( compiler , opPos , analysis ) ; } else { if ( isNaturalDocOrder ( compiler , firstStepPos , 0 , analysis ) ) { if ( false || DEBUG_ITERATOR_CREATION ) { diagnoseIterator ( "WalkingIterator" , analysis , compiler ) ; } iter = new WalkingIterator ( compiler , opPos , analysis , true ) ; } else { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "WalkingIteratorSorted" , analysis , compiler ) ; iter = new WalkingIteratorSorted ( compiler , opPos , analysis , true ) ; } } if ( iter instanceof LocPathIterator ) ( ( LocPathIterator ) iter ) . setIsTopLevel ( isTopLevel ) ; return iter ; } public static int getAxisFromStep ( Compiler compiler , int stepOpCodePos ) throws javax . xml . transform . TransformerException { int ops [ ] = compiler . getOpMap ( ) ; int stepType = ops [ stepOpCodePos ] ; switch ( stepType ) { case OpCodes . FROM_FOLLOWING : return Axis . FOLLOWING ; case OpCodes . FROM_FOLLOWING_SIBLINGS : return Axis . FOLLOWINGSIBLING ; case OpCodes . FROM_PRECEDING : return Axis . PRECEDING ; case OpCodes . FROM_PRECEDING_SIBLINGS : return Axis . PRECEDINGSIBLING ; case OpCodes . FROM_PARENT : return Axis . PARENT ; case OpCodes . FROM_NAMESPACE : return Axis . NAMESPACE ; case OpCodes . FROM_ANCESTORS : return Axis . ANCESTOR ; case OpCodes . FROM_ANCESTORS_OR_SELF : return Axis . ANCESTORORSELF ; case OpCodes . FROM_ATTRIBUTES : return Axis . ATTRIBUTE ; case OpCodes . FROM_ROOT : return Axis . ROOT ; case OpCodes . FROM_CHILDREN : return Axis . CHILD ; case OpCodes . FROM_DESCENDANTS_OR_SELF : return Axis . DESCENDANTORSELF ; case OpCodes . FROM_DESCENDANTS : return Axis . DESCENDANT ; case OpCodes . FROM_SELF : return Axis . SELF ; case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . OP_VARIABLE : return Axis . FILTEREDLIST ; } throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } static public int getAnalysisBitFromAxes ( int axis ) { switch ( axis ) { case Axis . ANCESTOR : return BIT_ANCESTOR ; case Axis . ANCESTORORSELF : return BIT_ANCESTOR_OR_SELF ; case Axis . ATTRIBUTE : return BIT_ATTRIBUTE ; case Axis . CHILD : return BIT_CHILD ; case Axis . DESCENDANT : return BIT_DESCENDANT ; case Axis . DESCENDANTORSELF : return BIT_DESCENDANT_OR_SELF ; case Axis . FOLLOWING : return BIT_FOLLOWING ; case Axis . FOLLOWINGSIBLING : return BIT_FOLLOWING_SIBLING ; case Axis . NAMESPACE : case Axis . NAMESPACEDECLS : return BIT_NAMESPACE ; case Axis . PARENT : return BIT_PARENT ; case Axis . PRECEDING : return BIT_PRECEDING ; case Axis . PRECEDINGSIBLING : return BIT_PRECEDING_SIBLING ; case Axis . SELF : return BIT_SELF ; case Axis . ALLFROMNODE : return BIT_DESCENDANT_OR_SELF ; case Axis . DESCENDANTSFROMROOT : case Axis . ALL : case Axis . DESCENDANTSORSELFFROMROOT : return BIT_ANY_DESCENDANT_FROM_ROOT ; case Axis . ROOT : return BIT_ROOT ; case Axis . FILTEREDLIST : return BIT_FILTER ; default : return BIT_FILTER ; } } static boolean functionProximateOrContainsProximate ( Compiler compiler , int opPos ) { int endFunc = opPos + compiler . getOp ( opPos + 1 ) - 1 ; opPos = compiler . getFirstChildPos ( opPos ) ; int funcID = compiler . getOp ( opPos ) ; switch ( funcID ) { case FunctionTable . FUNC_LAST : case FunctionTable . FUNC_POSITION : return true ; default : opPos ++ ; int i = 0 ; for ( int p = opPos ; p < endFunc ; p = compiler . getNextOpPos ( p ) , i ++ ) { int innerExprOpPos = p + 2 ; int argOp = compiler . getOp ( innerExprOpPos ) ; boolean prox = isProximateInnerExpr ( compiler , innerExprOpPos ) ; if ( prox ) return true ; } } return false ; } static boolean isProximateInnerExpr ( Compiler compiler , int opPos ) { int op = compiler . getOp ( opPos ) ; int innerExprOpPos = opPos + 2 ; switch ( op ) { case OpCodes . OP_ARGUMENT : if ( isProximateInnerExpr ( compiler , innerExprOpPos ) ) return true ; break ; case OpCodes . OP_VARIABLE : case OpCodes . OP_NUMBERLIT : case OpCodes . OP_LITERAL : case OpCodes . OP_LOCATIONPATH : break ; case OpCodes . OP_FUNCTION : boolean isProx = functionProximateOrContainsProximate ( compiler , opPos ) ; if ( isProx ) return true ; break ; case OpCodes . OP_GT : case OpCodes . OP_GTE : case OpCodes . OP_LT : case OpCodes . OP_LTE : case OpCodes . OP_EQUALS : int leftPos = compiler . getFirstChildPos ( op ) ; int rightPos = compiler . getNextOpPos ( leftPos ) ; isProx = isProximateInnerExpr ( compiler , leftPos ) ; if ( isProx ) return true ; isProx = isProximateInnerExpr ( compiler , rightPos ) ; if ( isProx ) return true ; break ; default : return true ; } return false ; } public static boolean mightBeProximate ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { boolean mightBeProximate = false ; int argLen ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : argLen = compiler . getArgLength ( opPos ) ; break ; default : argLen = compiler . getArgLengthOfStep ( opPos ) ; } int predPos = compiler . getFirstPredicateOpPos ( opPos ) ; int count = 0 ; while ( OpCodes . OP_PREDICATE == compiler . getOp ( predPos ) ) { count ++ ; int innerExprOpPos = predPos + 2 ; int predOp = compiler . getOp ( innerExprOpPos ) ; switch ( predOp ) { case OpCodes . OP_VARIABLE : return true ; case OpCodes . OP_LOCATIONPATH : break ; case OpCodes . OP_NUMBER : case OpCodes . OP_NUMBERLIT : return true ; case OpCodes . OP_FUNCTION : boolean isProx = functionProximateOrContainsProximate ( compiler , innerExprOpPos ) ; if ( isProx ) return true ; break ; case OpCodes . OP_GT : case OpCodes . OP_GTE : case OpCodes . OP_LT : case OpCodes . OP_LTE : case OpCodes . OP_EQUALS : int leftPos = compiler . getFirstChildPos ( innerExprOpPos ) ; int rightPos = compiler . getNextOpPos ( leftPos ) ; isProx = isProximateInnerExpr ( compiler , leftPos ) ; if ( isProx ) return true ; isProx = isProximateInnerExpr ( compiler , rightPos ) ; if ( isProx ) return true ; break ; default : return true ; } predPos = compiler . getNextOpPos ( predPos ) ; } return mightBeProximate ; } private static boolean isOptimizableForDescendantIterator ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int ops [ ] = compiler . getOpMap ( ) ; int stepCount = 0 ; boolean foundDorDS = false ; boolean foundSelf = false ; boolean foundDS = false ; int nodeTestType = OpCodes . NODETYPE_NODE ; while ( OpCodes . ENDOP != ( stepType = ops [ stepOpCodePos ] ) ) { if ( nodeTestType != OpCodes . NODETYPE_NODE && nodeTestType != OpCodes . NODETYPE_ROOT ) return false ; stepCount ++ ; if ( stepCount > 3 ) return false ; boolean mightBeProximate = mightBeProximate ( compiler , stepOpCodePos , stepType ) ; if ( mightBeProximate ) return false ; switch ( stepType ) { case OpCodes . FROM_FOLLOWING : case OpCodes . FROM_FOLLOWING_SIBLINGS : case OpCodes . FROM_PRECEDING : case OpCodes . FROM_PRECEDING_SIBLINGS : case OpCodes . FROM_PARENT : case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . FROM_NAMESPACE : case OpCodes . FROM_ANCESTORS : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : return false ; case OpCodes . FROM_ROOT : if ( 1 != stepCount ) return false ; break ; case OpCodes . FROM_CHILDREN : if ( ! foundDS && ! ( foundDorDS && foundSelf ) ) return false ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : foundDS = true ; case OpCodes . FROM_DESCENDANTS : if ( 3 == stepCount ) return false ; foundDorDS = true ; break ; case OpCodes . FROM_SELF : if ( 1 != stepCount ) return false ; foundSelf = true ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } nodeTestType = compiler . getStepTestType ( stepOpCodePos ) ; int nextStepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( nextStepOpCodePos < 0 ) break ; if ( OpCodes . ENDOP != ops [ nextStepOpCodePos ] ) { if ( compiler . countPredicates ( stepOpCodePos ) > 0 ) { return false ; } } stepOpCodePos = nextStepOpCodePos ; } return true ; } private static int analyze ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int ops [ ] = compiler . getOpMap ( ) ; int stepCount = 0 ; int analysisResult = 0x00000000 ; while ( OpCodes . ENDOP != ( stepType = ops [ stepOpCodePos ] ) ) { stepCount ++ ; boolean predAnalysis = analyzePredicate ( compiler , stepOpCodePos , stepType ) ; if ( predAnalysis ) analysisResult |= BIT_PREDICATE ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : analysisResult |= BIT_FILTER ; break ; case OpCodes . FROM_ROOT : analysisResult |= BIT_ROOT ; break ; case OpCodes . FROM_ANCESTORS : analysisResult |= BIT_ANCESTOR ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : analysisResult |= BIT_ANCESTOR_OR_SELF ; break ; case OpCodes . FROM_ATTRIBUTES : analysisResult |= BIT_ATTRIBUTE ; break ; case OpCodes . FROM_NAMESPACE : analysisResult |= BIT_NAMESPACE ; break ; case OpCodes . FROM_CHILDREN : analysisResult |= BIT_CHILD ; break ; case OpCodes . FROM_DESCENDANTS : analysisResult |= BIT_DESCENDANT ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : if ( 2 == stepCount && BIT_ROOT == analysisResult ) { analysisResult |= BIT_ANY_DESCENDANT_FROM_ROOT ; } analysisResult |= BIT_DESCENDANT_OR_SELF ; break ; case OpCodes . FROM_FOLLOWING : analysisResult |= BIT_FOLLOWING ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : analysisResult |= BIT_FOLLOWING_SIBLING ; break ; case OpCodes . FROM_PRECEDING : analysisResult |= BIT_PRECEDING ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : analysisResult |= BIT_PRECEDING_SIBLING ; break ; case OpCodes . FROM_PARENT : analysisResult |= BIT_PARENT ; break ; case OpCodes . FROM_SELF : analysisResult |= BIT_SELF ; break ; case OpCodes . MATCH_ATTRIBUTE : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ATTRIBUTE ) ; break ; case OpCodes . MATCH_ANY_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ANCESTOR ) ; break ; case OpCodes . MATCH_IMMEDIATE_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_PARENT ) ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( OpCodes . NODETYPE_NODE == ops [ stepOpCodePos + 3 ] ) { analysisResult |= BIT_NODETEST_ANY ; } stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } analysisResult |= ( stepCount & BITS_COUNT ) ; return analysisResult ; } public static boolean isDownwardAxisOfMany ( int axis ) { return ( ( Axis . DESCENDANTORSELF == axis ) || ( Axis . DESCENDANT == axis ) || ( Axis . FOLLOWING == axis ) || ( Axis . PRECEDING == axis ) ) ; } static StepPattern loadSteps ( MatchPatternIterator mpi , Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { if ( DEBUG_PATTERN_CREATION ) { System . out . println ( "================" ) ; System . out . println ( "loadSteps for: " + compiler . getPatternString ( ) ) ; } int stepType ; StepPattern step = null ; StepPattern firstStep = null , prevStep = null ; int ops [ ] = compiler . getOpMap ( ) ; int analysis = analyze ( compiler , stepOpCodePos , stepIndex ) ; while ( OpCodes . ENDOP != ( stepType = ops [ stepOpCodePos ] ) ) { step = createDefaultStepPattern ( compiler , stepOpCodePos , mpi , analysis , firstStep , prevStep ) ; if ( null == firstStep ) { firstStep = step ; } else { step . setRelativePathPattern ( prevStep ) ; } prevStep = step ; stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } int axis = Axis . SELF ; int paxis = Axis . SELF ; StepPattern tail = step ; for ( StepPattern pat = step ; null != pat ; pat = pat . getRelativePathPattern ( ) ) { int nextAxis = pat . getAxis ( ) ; pat . setAxis ( axis ) ; int whatToShow = pat . getWhatToShow ( ) ; if ( whatToShow == DTMFilter . SHOW_ATTRIBUTE || whatToShow == DTMFilter . SHOW_NAMESPACE ) { int newAxis = ( whatToShow == DTMFilter . SHOW_ATTRIBUTE ) ? Axis . ATTRIBUTE : Axis . NAMESPACE ; if ( isDownwardAxisOfMany ( axis ) ) { StepPattern attrPat = new StepPattern ( whatToShow , pat . getNamespace ( ) , pat . getLocalName ( ) , newAxis , 0 ) ; XNumber score = pat . getStaticScore ( ) ; pat . setNamespace ( null ) ; pat . setLocalName ( NodeTest . WILD ) ; attrPat . setPredicates ( pat . getPredicates ( ) ) ; pat . setPredicates ( null ) ; pat . setWhatToShow ( DTMFilter . SHOW_ELEMENT ) ; StepPattern rel = pat . getRelativePathPattern ( ) ; pat . setRelativePathPattern ( attrPat ) ; attrPat . setRelativePathPattern ( rel ) ; attrPat . setStaticScore ( score ) ; if ( Axis . PRECEDING == pat . getAxis ( ) ) pat . setAxis ( Axis . PRECEDINGANDANCESTOR ) ; else if ( Axis . DESCENDANT == pat . getAxis ( ) ) pat . setAxis ( Axis . DESCENDANTORSELF ) ; pat = attrPat ; } else if ( Axis . CHILD == pat . getAxis ( ) ) { pat . setAxis ( Axis . ATTRIBUTE ) ; } } axis = nextAxis ; tail = pat ; } if ( axis < Axis . ALL ) { StepPattern selfPattern = new ContextMatchStepPattern ( axis , paxis ) ; XNumber score = tail . getStaticScore ( ) ; tail . setRelativePathPattern ( selfPattern ) ; tail . setStaticScore ( score ) ; selfPattern . setStaticScore ( score ) ; } if ( DEBUG_PATTERN_CREATION ) { System . out . println ( "Done loading steps: " + step . toString ( ) ) ; System . out . println ( "" ) ; } return step ; } private static StepPattern createDefaultStepPattern ( Compiler compiler , int opPos , MatchPatternIterator mpi , int analysis , StepPattern tail , StepPattern head ) throws javax . xml . transform . TransformerException { int stepType = compiler . getOp ( opPos ) ; boolean simpleInit = false ; int totalNumberWalkers = ( analysis & BITS_COUNT ) ; boolean prevIsOneStepDown = true ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int whatToShow = compiler . getWhatToShow ( opPos ) ; StepPattern ai = null ; int axis , predicateAxis ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : prevIsOneStepDown = false ; Expression expr ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : expr = compiler . compile ( opPos ) ; break ; default : expr = compiler . compile ( opPos + 2 ) ; } axis = Axis . FILTEREDLIST ; predicateAxis = Axis . FILTEREDLIST ; ai = new FunctionPattern ( expr , axis , predicateAxis ) ; simpleInit = true ; break ; case OpCodes . FROM_ROOT : whatToShow = DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ; axis = Axis . ROOT ; predicateAxis = Axis . ROOT ; ai = new StepPattern ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT , axis , predicateAxis ) ; break ; case OpCodes . FROM_ATTRIBUTES : whatToShow = DTMFilter . SHOW_ATTRIBUTE ; axis = Axis . PARENT ; predicateAxis = Axis . ATTRIBUTE ; break ; case OpCodes . FROM_NAMESPACE : whatToShow = DTMFilter . SHOW_NAMESPACE ; axis = Axis . PARENT ; predicateAxis = Axis . NAMESPACE ; break ; case OpCodes . FROM_ANCESTORS : axis = Axis . DESCENDANT ; predicateAxis = Axis . ANCESTOR ; break ; case OpCodes . FROM_CHILDREN : axis = Axis . PARENT ; predicateAxis = Axis . CHILD ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : axis = Axis . DESCENDANTORSELF ; predicateAxis = Axis . ANCESTORORSELF ; break ; case OpCodes . FROM_SELF : axis = Axis . SELF ; predicateAxis = Axis . SELF ; break ; case OpCodes . FROM_PARENT : axis = Axis . CHILD ; predicateAxis = Axis . PARENT ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : axis = Axis . FOLLOWINGSIBLING ; predicateAxis = Axis . PRECEDINGSIBLING ; break ; case OpCodes . FROM_PRECEDING : axis = Axis . FOLLOWING ; predicateAxis = Axis . PRECEDING ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : axis = Axis . PRECEDINGSIBLING ; predicateAxis = Axis . FOLLOWINGSIBLING ; break ; case OpCodes . FROM_FOLLOWING : axis = Axis . PRECEDING ; predicateAxis = Axis . FOLLOWING ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : axis = Axis . ANCESTORORSELF ; predicateAxis = Axis . DESCENDANTORSELF ; break ; case OpCodes . FROM_DESCENDANTS : axis = Axis . ANCESTOR ; predicateAxis = Axis . DESCENDANT ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( null == ai ) { whatToShow = compiler . getWhatToShow ( opPos ) ; ai = new StepPattern ( whatToShow , compiler . getStepNS ( opPos ) , compiler . getStepLocalName ( opPos ) , axis , predicateAxis ) ; } if ( false || DEBUG_PATTERN_CREATION ) { System . out . print ( "new step: " + ai ) ; System . out . print ( ", axis: " + Axis . names [ ai . getAxis ( ) ] ) ; System . out . print ( ", predAxis: " + Axis . names [ ai . getAxis ( ) ] ) ; System . out . print ( ", what: " ) ; System . out . print ( "    " ) ; ai . debugWhatToShow ( ai . getWhatToShow ( ) ) ; } int argLen = compiler . getFirstPredicateOpPos ( opPos ) ; ai . setPredicates ( compiler . getCompiledPredicates ( argLen ) ) ; return ai ; } static boolean analyzePredicate ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { int argLen ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : argLen = compiler . getArgLength ( opPos ) ; break ; default : argLen = compiler . getArgLengthOfStep ( opPos ) ; } int pos = compiler . getFirstPredicateOpPos ( opPos ) ; int nPredicates = compiler . countPredicates ( pos ) ; return ( nPredicates > 0 ) ? true : false ; } private static AxesWalker createDefaultWalker ( Compiler compiler , int opPos , WalkingIterator lpi , int analysis ) { AxesWalker ai = null ; int stepType = compiler . getOp ( opPos ) ; boolean simpleInit = false ; int totalNumberWalkers = ( analysis & BITS_COUNT ) ; boolean prevIsOneStepDown = true ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : prevIsOneStepDown = false ; if ( DEBUG_WALKER_CREATION ) System . out . println ( "new walker:  FilterExprWalker: " + analysis + ", " + compiler . toString ( ) ) ; ai = new FilterExprWalker ( lpi ) ; simpleInit = true ; break ; case OpCodes . FROM_ROOT : ai = new AxesWalker ( lpi , Axis . ROOT ) ; break ; case OpCodes . FROM_ANCESTORS : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . ANCESTOR ) ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . ANCESTORORSELF ) ; break ; case OpCodes . FROM_ATTRIBUTES : ai = new AxesWalker ( lpi , Axis . ATTRIBUTE ) ; break ; case OpCodes . FROM_NAMESPACE : ai = new AxesWalker ( lpi , Axis . NAMESPACE ) ; break ; case OpCodes . FROM_CHILDREN : ai = new AxesWalker ( lpi , Axis . CHILD ) ; break ; case OpCodes . FROM_DESCENDANTS : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . DESCENDANT ) ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . DESCENDANTORSELF ) ; break ; case OpCodes . FROM_FOLLOWING : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . FOLLOWING ) ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . FOLLOWINGSIBLING ) ; break ; case OpCodes . FROM_PRECEDING : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . PRECEDING ) ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . PRECEDINGSIBLING ) ; break ; case OpCodes . FROM_PARENT : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . PARENT ) ; break ; case OpCodes . FROM_SELF : ai = new AxesWalker ( lpi , Axis . SELF ) ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( simpleInit ) { ai . initNodeTest ( DTMFilter . SHOW_ALL ) ; } else { int whatToShow = compiler . getWhatToShow ( opPos ) ; if ( ( 0 == ( whatToShow & ( DTMFilter . SHOW_ATTRIBUTE | DTMFilter . SHOW_NAMESPACE | DTMFilter . SHOW_ELEMENT | DTMFilter . SHOW_PROCESSING_INSTRUCTION ) ) ) || ( whatToShow == DTMFilter . SHOW_ALL ) ) ai . initNodeTest ( whatToShow ) ; else { ai . initNodeTest ( whatToShow , compiler . getStepNS ( opPos ) , compiler . getStepLocalName ( opPos ) ) ; } } return ai ; } public static String getAnalysisString ( int analysis ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "count: " + getStepCount ( analysis ) + " " ) ; if ( ( analysis & BIT_NODETEST_ANY ) != 0 ) { buf . append ( "NTANY|" ) ; } if ( ( analysis & BIT_PREDICATE ) != 0 ) { buf . append ( "PRED|" ) ; } if ( ( analysis & BIT_ANCESTOR ) != 0 ) { buf . append ( "ANC|" ) ; } if ( ( analysis & BIT_ANCESTOR_OR_SELF ) != 0 ) { buf . append ( "ANCOS|" ) ; } if ( ( analysis & BIT_ATTRIBUTE ) != 0 ) { buf . append ( "ATTR|" ) ; } if ( ( analysis & BIT_CHILD ) != 0 ) { buf . append ( "CH|" ) ; } if ( ( analysis & BIT_DESCENDANT ) != 0 ) { buf . append ( "DESC|" ) ; } if ( ( analysis & BIT_DESCENDANT_OR_SELF ) != 0 ) { buf . append ( "DESCOS|" ) ; } if ( ( analysis & BIT_FOLLOWING ) != 0 ) { buf . append ( "FOL|" ) ; } if ( ( analysis & BIT_FOLLOWING_SIBLING ) != 0 ) { buf . append ( "FOLS|" ) ; } if ( ( analysis & BIT_NAMESPACE ) != 0 ) { buf . append ( "NS|" ) ; } if ( ( analysis & BIT_PARENT ) != 0 ) { buf . append ( "P|" ) ; } if ( ( analysis & BIT_PRECEDING ) != 0 ) { buf . append ( "PREC|" ) ; } if ( ( analysis & BIT_PRECEDING_SIBLING ) != 0 ) { buf . append ( "PRECS|" ) ; } if ( ( analysis & BIT_SELF ) != 0 ) { buf . append ( ".|" ) ; } if ( ( analysis & BIT_FILTER ) != 0 ) { buf . append ( "FLT|" ) ; } if ( ( analysis & BIT_ROOT ) != 0 ) { buf . append ( "R|" ) ; } return buf . toString ( ) ; } static final boolean DEBUG_PATTERN_CREATION = false ; static final boolean DEBUG_WALKER_CREATION = false ; static final boolean DEBUG_ITERATOR_CREATION = false ; public static boolean hasPredicate ( int analysis ) { return ( 0 != ( analysis & BIT_PREDICATE ) ) ; } public static boolean isWild ( int analysis ) { return ( 0 != ( analysis & BIT_NODETEST_ANY ) ) ; } public static boolean walksAncestors ( int analysis ) { return isSet ( analysis , BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF ) ; } public static boolean walksAttributes ( int analysis ) { return ( 0 != ( analysis & BIT_ATTRIBUTE ) ) ; } public static boolean walksNamespaces ( int analysis ) { return ( 0 != ( analysis & BIT_NAMESPACE ) ) ; } public static boolean walksChildren ( int analysis ) { return ( 0 != ( analysis & BIT_CHILD ) ) ; } public static boolean walksDescendants ( int analysis ) { return isSet ( analysis , BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF ) ; } public static boolean walksSubtree ( int analysis ) { return isSet ( analysis , BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF | BIT_CHILD ) ; } public static boolean walksSubtreeOnlyMaybeAbsolute ( int analysis ) { return walksSubtree ( analysis ) && ! walksExtraNodes ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) ; } public static boolean walksSubtreeOnly ( int analysis ) { return walksSubtreeOnlyMaybeAbsolute ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksFilteredList ( int analysis ) { return isSet ( analysis , BIT_FILTER ) ; } public static boolean walksSubtreeOnlyFromRootOrContext ( int analysis ) { return walksSubtree ( analysis ) && ! walksExtraNodes ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isSet ( analysis , BIT_FILTER ) ; } public static boolean walksInDocOrder ( int analysis ) { return ( walksSubtreeOnlyMaybeAbsolute ( analysis ) || walksExtraNodesOnly ( analysis ) || walksFollowingOnlyMaybeAbsolute ( analysis ) ) && ! isSet ( analysis , BIT_FILTER ) ; } public static boolean walksFollowingOnlyMaybeAbsolute ( int analysis ) { return isSet ( analysis , BIT_SELF | BIT_FOLLOWING_SIBLING | BIT_FOLLOWING ) && ! walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) ; } public static boolean walksUp ( int analysis ) { return isSet ( analysis , BIT_PARENT | BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF ) ; } public static boolean walksSideways ( int analysis ) { return isSet ( analysis , BIT_FOLLOWING | BIT_FOLLOWING_SIBLING | BIT_PRECEDING | BIT_PRECEDING_SIBLING ) ; } public static boolean walksExtraNodes ( int analysis ) { return isSet ( analysis , BIT_NAMESPACE | BIT_ATTRIBUTE ) ; } public static boolean walksExtraNodesOnly ( int analysis ) { return walksExtraNodes ( analysis ) && ! isSet ( analysis , BIT_SELF ) && ! walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean isAbsolute ( int analysis ) { return isSet ( analysis , BIT_ROOT | BIT_FILTER ) ; } public static boolean walksChildrenOnly ( int analysis ) { return walksChildren ( analysis ) && ! isSet ( analysis , BIT_SELF ) && ! walksExtraNodes ( analysis ) && ! walksDescendants ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ( ! isAbsolute ( analysis ) || isSet ( analysis , BIT_ROOT ) ) ; } public static boolean walksChildrenAndExtraAndSelfOnly ( int analysis ) { return walksChildren ( analysis ) && ! walksDescendants ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ( ! isAbsolute ( analysis ) || isSet ( analysis , BIT_ROOT ) ) ; } public static boolean walksDescendantsAndExtraAndSelfOnly ( int analysis ) { return ! walksChildren ( analysis ) && walksDescendants ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ( ! isAbsolute ( analysis ) || isSet ( analysis , BIT_ROOT ) ) ; } public static boolean walksSelfOnly ( int analysis ) { return isSet ( analysis , BIT_SELF ) && ! walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksUpOnly ( int analysis ) { return ! walksSubtree ( analysis ) && walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksDownOnly ( int analysis ) { return walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksDownExtraOnly ( int analysis ) { return walksSubtree ( analysis ) && walksExtraNodes ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean canSkipSubtrees ( int analysis ) { return isSet ( analysis , BIT_CHILD ) | walksSideways ( analysis ) ; } public static boolean canCrissCross ( int analysis ) { if ( walksSelfOnly ( analysis ) ) return false ; else if ( walksDownOnly ( analysis ) && ! canSkipSubtrees ( analysis ) ) return false ; else if ( walksChildrenAndExtraAndSelfOnly ( analysis ) ) return false ; else if ( walksDescendantsAndExtraAndSelfOnly ( analysis ) ) return false ; else if ( walksUpOnly ( analysis ) ) return false ; else if ( walksExtraNodesOnly ( analysis ) ) return false ; else if ( walksSubtree ( analysis ) && ( walksSideways ( analysis ) || walksUp ( analysis ) || canSkipSubtrees ( analysis ) ) ) return true ; else return false ; } static public boolean isNaturalDocOrder ( int analysis ) { if ( canCrissCross ( analysis ) || isSet ( analysis , BIT_NAMESPACE ) || walksFilteredList ( analysis ) ) return false ; if ( walksInDocOrder ( analysis ) ) return true ; return false ; } private static boolean isNaturalDocOrder ( Compiler compiler , int stepOpCodePos , int stepIndex , int analysis ) throws javax . xml . transform . TransformerException { if ( canCrissCross ( analysis ) ) return false ; if ( isSet ( analysis , BIT_NAMESPACE ) ) return false ; if ( isSet ( analysis , BIT_FOLLOWING | BIT_FOLLOWING_SIBLING ) && isSet ( analysis , BIT_PRECEDING | BIT_PRECEDING_SIBLING ) ) return false ; int stepType ; int ops [ ] = compiler . getOpMap ( ) ; int stepCount = 0 ; boolean foundWildAttribute = false ; int potentialDuplicateMakingStepCount = 0 ; while ( OpCodes . ENDOP != ( stepType = ops [ stepOpCodePos ] ) ) { stepCount ++ ; switch ( stepType ) { case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : if ( foundWildAttribute ) return false ; String localName = compiler . getStepLocalName ( stepOpCodePos ) ; if ( localName . equals ( "*" ) ) { foundWildAttribute = true ; } break ; case OpCodes . FROM_FOLLOWING : case OpCodes . FROM_FOLLOWING_SIBLINGS : case OpCodes . FROM_PRECEDING : case OpCodes . FROM_PRECEDING_SIBLINGS : case OpCodes . FROM_PARENT : case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . FROM_NAMESPACE : case OpCodes . FROM_ANCESTORS : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : case OpCodes . FROM_DESCENDANTS_OR_SELF : case OpCodes . FROM_DESCENDANTS : if ( potentialDuplicateMakingStepCount > 0 ) return false ; potentialDuplicateMakingStepCount ++ ; case OpCodes . FROM_ROOT : case OpCodes . FROM_CHILDREN : case OpCodes . FROM_SELF : if ( foundWildAttribute ) return false ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } int nextStepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( nextStepOpCodePos < 0 ) break ; stepOpCodePos = nextStepOpCodePos ; } return true ; } public static boolean isOneStep ( int analysis ) { return ( analysis & BITS_COUNT ) == 0x00000001 ; } public static int getStepCount ( int analysis ) { return ( analysis & BITS_COUNT ) ; } public static final int BITS_COUNT = 0x000000FF ; public static final int BITS_RESERVED = 0x00000F00 ; public static final int BIT_PREDICATE = ( 0x00001000 ) ; public static final int BIT_ANCESTOR = ( 0x00001000 << 1 ) ; public static final int BIT_ANCESTOR_OR_SELF = ( 0x00001000 << 2 ) ; public static final int BIT_ATTRIBUTE = ( 0x00001000 << 3 ) ; public static final int BIT_CHILD = ( 0x00001000 << 4 ) ; public static final int BIT_DESCENDANT = ( 0x00001000 << 5 ) ; public static final int BIT_DESCENDANT_OR_SELF = ( 0x00001000 << 6 ) ; public static final int BIT_FOLLOWING = ( 0x00001000 << 7 ) ; public static final int BIT_FOLLOWING_SIBLING = ( 0x00001000 << 8 ) ; public static final int BIT_NAMESPACE = ( 0x00001000 << 9 ) ; public static final int BIT_PARENT = ( 0x00001000 << 10 ) ; public static final int BIT_PRECEDING = ( 0x00001000 << 11 ) ; public static final int BIT_PRECEDING_SIBLING = ( 0x00001000 << 12 ) ; public static final int BIT_SELF = ( 0x00001000 << 13 ) ; public static final int BIT_FILTER = ( 0x00001000 << 14 ) ; public static final int BIT_ROOT = ( 0x00001000 << 15 ) ; public static final int BITMASK_TRAVERSES_OUTSIDE_SUBTREE = ( BIT_NAMESPACE | BIT_PRECEDING_SIBLING | BIT_PRECEDING | BIT_FOLLOWING_SIBLING | BIT_FOLLOWING | BIT_PARENT | BIT_ANCESTOR_OR_SELF | BIT_ANCESTOR | BIT_FILTER | BIT_ROOT ) ; public static final int BIT_BACKWARDS_SELF = ( 0x00001000 << 16 ) ; public static final int BIT_ANY_DESCENDANT_FROM_ROOT = ( 0x00001000 << 17 ) ; public static final int BIT_NODETEST_ANY = ( 0x00001000 << 18 ) ; public static final int BIT_MATCH_PATTERN = ( 0x00001000 << 19 ) ; } 	1	['51', '1', '0', '27', '115', '1275', '11', '25', '40', '1.02', '2159', '0', '0', '0', '0.181372549', '0', '0', '40.82352941', '18', '3.3333', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import java . util . ArrayList ; import java . util . StringTokenizer ; import java . util . NoSuchElementException ; import java . text . Collator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . bcel . classfile . JavaClass ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . Method ; import org . apache . bcel . generic . * ; import org . apache . bcel . Constants ; import org . apache . xalan . xsltc . dom . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class Sort extends Instruction implements Closure { private Expression _select ; private AttributeValue _order ; private AttributeValue _caseOrder ; private AttributeValue _dataType ; private String _data = null ; public String _lang ; public String _country ; private String _className = null ; private ArrayList _closureVars = null ; private boolean _needsSortRecordFactory = false ; public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { return null ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; _needsSortRecordFactory = true ; } } private void setInnerClassName ( String className ) { _className = className ; } public void parseContents ( Parser parser ) { final SyntaxTreeNode parent = getParent ( ) ; if ( ! ( parent instanceof ApplyTemplates ) && ! ( parent instanceof ForEach ) ) { reportError ( this , parser , ErrorMsg . STRAY_SORT_ERR , null ) ; return ; } _select = parser . parseExpression ( this , "select" , "string(.)" ) ; String val = getAttribute ( "order" ) ; if ( val . length ( ) == 0 ) val = "ascending" ; _order = AttributeValue . create ( this , val , parser ) ; val = getAttribute ( "case-order" ) ; if ( val . length ( ) == 0 ) val = "upper-first" ; _caseOrder = AttributeValue . create ( this , val , parser ) ; val = getAttribute ( "data-type" ) ; if ( val . length ( ) == 0 ) { try { final Type type = _select . typeCheck ( parser . getSymbolTable ( ) ) ; if ( type instanceof IntType ) val = "number" ; else val = "text" ; } catch ( TypeCheckError e ) { val = "text" ; } } _dataType = AttributeValue . create ( this , val , parser ) ; if ( ( val = getAttribute ( "lang" ) ) != null ) { try { StringTokenizer st = new StringTokenizer ( val , "-" , false ) ; _lang = st . nextToken ( ) ; _country = st . nextToken ( ) ; } catch ( NoSuchElementException e ) { } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tselect = _select . typeCheck ( stable ) ; if ( ! ( tselect instanceof StringType ) ) { _select = new CastExpr ( _select , Type . String ) ; } _order . typeCheck ( stable ) ; _caseOrder . typeCheck ( stable ) ; _dataType . typeCheck ( stable ) ; return Type . Void ; } public void translateSortType ( ClassGenerator classGen , MethodGenerator methodGen ) { _dataType . translate ( classGen , methodGen ) ; } public void translateSortOrder ( ClassGenerator classGen , MethodGenerator methodGen ) { _order . translate ( classGen , methodGen ) ; } public void translateSelect ( ClassGenerator classGen , MethodGenerator methodGen ) { _select . translate ( classGen , methodGen ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } public static void translateSortIterator ( ClassGenerator classGen , MethodGenerator methodGen , Expression nodeSet , Vector sortObjects ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( SORT_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_SORT_FACTORY_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( SORT_ITERATOR ) ) ) ; il . append ( DUP ) ; if ( nodeSet == null ) { final int children = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . CHILD ) ) ; il . append ( new INVOKEINTERFACE ( children , 2 ) ) ; } else { nodeSet . translate ( classGen , methodGen ) ; } compileSortRecordFactory ( sortObjects , classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } public static void compileSortRecordFactory ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen ) { String sortRecordClass = compileSortRecord ( sortObjects , classGen , methodGen ) ; boolean needsSortRecordFactory = false ; final int nsorts = sortObjects . size ( ) ; for ( int i = 0 ; i < nsorts ; i ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( i ) ; needsSortRecordFactory |= sort . _needsSortRecordFactory ; } String sortRecordFactoryClass = NODE_SORT_FACTORY ; if ( needsSortRecordFactory ) { sortRecordFactoryClass = compileSortRecordFactory ( sortObjects , classGen , methodGen , sortRecordClass ) ; } final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( sortRecordFactoryClass ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , sortRecordClass ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateSortOrder ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateSortType ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new INVOKESPECIAL ( cpg . addMethodref ( sortRecordFactoryClass , "<init>" , "(" + DOM_INTF_SIG + STRING_SIG + TRANSLET_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ) ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableRefBase varRef = ( VariableRefBase ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; il . append ( DUP ) ; il . append ( var . loadInstruction ( ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( sortRecordFactoryClass , var . getVariable ( ) , var . getType ( ) . toSignature ( ) ) ) ) ; dups . add ( varRef ) ; } } } public static String compileSortRecordFactory ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen , String sortRecordClass ) { final XSLTC xsltc = ( ( Sort ) sortObjects . firstElement ( ) ) . getXSLTC ( ) ; final String className = xsltc . getHelperClassName ( ) ; final NodeSortRecordFactGenerator sortRecordFactory = new NodeSortRecordFactGenerator ( className , NODE_SORT_FACTORY , className + ".java" , ACC_PUBLIC | ACC_SUPER | ACC_FINAL , new String [ ] { } , classGen . getStylesheet ( ) ) ; ConstantPoolGen cpg = sortRecordFactory . getConstantPool ( ) ; final int nsorts = sortObjects . size ( ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final VariableRef varRef = ( VariableRef ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; sortRecordFactory . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; dups . add ( varRef ) ; } } final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 5 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( STRING_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_INTF_SIG ) ; argTypes [ 3 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; argTypes [ 4 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; final String [ ] argNames = new String [ 5 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = "className" ; argNames [ 2 ] = TRANSLET_PNAME ; argNames [ 3 ] = "order" ; argNames [ 4 ] = "type" ; InstructionList il = new InstructionList ( ) ; final MethodGenerator constructor = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "<init>" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ALOAD_1 ) ; il . append ( ALOAD_2 ) ; il . append ( new ALOAD ( 3 ) ) ; il . append ( new ALOAD ( 4 ) ) ; il . append ( new ALOAD ( 5 ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_FACTORY , "<init>" , "(" + DOM_INTF_SIG + STRING_SIG + TRANSLET_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ) ) ; il . append ( RETURN ) ; il = new InstructionList ( ) ; final MethodGenerator makeNodeSortRecord = new MethodGenerator ( ACC_PUBLIC , Util . getJCRefType ( NODE_SORT_RECORD_SIG ) , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT } , new String [ ] { "node" , "last" } , "makeNodeSortRecord" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ILOAD_1 ) ; il . append ( ILOAD_2 ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_FACTORY , "makeNodeSortRecord" , "(II)" + NODE_SORT_RECORD_SIG ) ) ) ; il . append ( DUP ) ; il . append ( new CHECKCAST ( cpg . addClass ( sortRecordClass ) ) ) ; final int ndups = dups . size ( ) ; for ( int i = 0 ; i < ndups ; i ++ ) { final VariableRef varRef = ( VariableRef ) dups . get ( i ) ; final VariableBase var = varRef . getVariable ( ) ; final Type varType = var . getType ( ) ; il . append ( DUP ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( sortRecordClass , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; } il . append ( POP ) ; il . append ( ARETURN ) ; constructor . setMaxLocals ( ) ; constructor . setMaxStack ( ) ; sortRecordFactory . addMethod ( constructor . getMethod ( ) ) ; makeNodeSortRecord . setMaxLocals ( ) ; makeNodeSortRecord . setMaxStack ( ) ; sortRecordFactory . addMethod ( makeNodeSortRecord . getMethod ( ) ) ; xsltc . dumpClass ( sortRecordFactory . getJavaClass ( ) ) ; return className ; } private static String compileSortRecord ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen ) { final XSLTC xsltc = ( ( Sort ) sortObjects . firstElement ( ) ) . getXSLTC ( ) ; final String className = xsltc . getHelperClassName ( ) ; final NodeSortRecordGenerator sortRecord = new NodeSortRecordGenerator ( className , NODE_SORT_RECORD , "sort$0.java" , ACC_PUBLIC | ACC_SUPER | ACC_FINAL , new String [ ] { } , classGen . getStylesheet ( ) ) ; final ConstantPoolGen cpg = sortRecord . getConstantPool ( ) ; final int nsorts = sortObjects . size ( ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; sort . setInnerClassName ( className ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final VariableRef varRef = ( VariableRef ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; sortRecord . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; dups . add ( varRef ) ; } } Method clinit = compileClassInit ( sortObjects , sortRecord , cpg , className ) ; Method extract = compileExtract ( sortObjects , sortRecord , cpg , className ) ; sortRecord . addMethod ( clinit ) ; sortRecord . addEmptyConstructor ( ACC_PUBLIC ) ; sortRecord . addMethod ( extract ) ; for ( int i = 0 ; i < sortObjects . size ( ) ; i ++ ) { if ( ( ( Sort ) ( sortObjects . elementAt ( i ) ) ) . _lang != null ) { sortRecord . addMethod ( compileGetCollator ( sortObjects , sortRecord , cpg , className ) ) ; i = sortObjects . size ( ) ; } } xsltc . dumpClass ( sortRecord . getJavaClass ( ) ) ; return className ; } private static Method compileClassInit ( Vector sortObjects , NodeSortRecordGenerator sortRecord , ConstantPoolGen cpg , String className ) { final InstructionList il = new InstructionList ( ) ; final CompareGenerator classInit = new CompareGenerator ( ACC_PUBLIC | ACC_STATIC , org . apache . bcel . generic . Type . VOID , new org . apache . bcel . generic . Type [ ] { } , new String [ ] { } , "<clinit>" , className , il , cpg ) ; final int initLocale = cpg . addMethodref ( "java/util/Locale" , "<init>" , "(Ljava/lang/String;" + "Ljava/lang/String;)V" ) ; final int getCollator = cpg . addMethodref ( COLLATOR_CLASS , "getInstance" , "(Ljava/util/Locale;)" + COLLATOR_SIG ) ; final int setStrength = cpg . addMethodref ( COLLATOR_CLASS , "setStrength" , "(I)V" ) ; final int levels = sortObjects . size ( ) ; String language = null ; String country = null ; Sort sort = ( Sort ) sortObjects . elementAt ( 0 ) ; for ( int level = 0 ; level < levels ; level ++ ) { if ( language == null && sort . _lang != null ) language = sort . _lang ; if ( country == null && sort . _country != null ) country = sort . _country ; } final int collator = cpg . addFieldref ( className , "_collator" , COLLATOR_SIG ) ; if ( language != null ) { il . append ( new NEW ( cpg . addClass ( "java/util/Locale" ) ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , language ) ) ; il . append ( new PUSH ( cpg , ( country != null ? country : EMPTYSTRING ) ) ) ; il . append ( new INVOKESPECIAL ( initLocale ) ) ; il . append ( new INVOKESTATIC ( getCollator ) ) ; il . append ( new PUTSTATIC ( collator ) ) ; } il . append ( new GETSTATIC ( collator ) ) ; il . append ( new ICONST ( Collator . TERTIARY ) ) ; il . append ( new INVOKEVIRTUAL ( setStrength ) ) ; il . append ( RETURN ) ; classInit . stripAttributes ( true ) ; classInit . setMaxLocals ( ) ; classInit . setMaxStack ( ) ; classInit . removeNOPs ( ) ; return classInit . getMethod ( ) ; } private static Method compileExtract ( Vector sortObjects , NodeSortRecordGenerator sortRecord , ConstantPoolGen cpg , String className ) { final InstructionList il = new InstructionList ( ) ; final CompareGenerator extractMethod = new CompareGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . STRING , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , Util . getJCRefType ( TRANSLET_SIG ) , org . apache . bcel . generic . Type . INT } , new String [ ] { "dom" , "current" , "level" , "translet" , "last" } , "extractValueFromDOM" , className , il , cpg ) ; final int levels = sortObjects . size ( ) ; final int match [ ] = new int [ levels ] ; final InstructionHandle target [ ] = new InstructionHandle [ levels ] ; InstructionHandle tblswitch = null ; if ( levels > 1 ) { il . append ( new ILOAD ( extractMethod . getLocalIndex ( "level" ) ) ) ; tblswitch = il . append ( new NOP ( ) ) ; } for ( int level = 0 ; level < levels ; level ++ ) { match [ level ] = level ; final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; target [ level ] = il . append ( NOP ) ; sort . translateSelect ( sortRecord , extractMethod ) ; il . append ( ARETURN ) ; } if ( levels > 1 ) { InstructionHandle defaultTarget = il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; il . insert ( tblswitch , new TABLESWITCH ( match , target , defaultTarget ) ) ; il . append ( ARETURN ) ; } extractMethod . stripAttributes ( true ) ; extractMethod . setMaxLocals ( ) ; extractMethod . setMaxStack ( ) ; extractMethod . removeNOPs ( ) ; return extractMethod . getMethod ( ) ; } private static Method compileGetCollator ( Vector sortObjects , NodeSortRecordGenerator sortRecord , ConstantPoolGen cpg , String className ) { final InstructionList il = new InstructionList ( ) ; final MethodGenerator getCollator = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , Util . getJCRefType ( COLLATOR_SIG ) , new org . apache . bcel . generic . Type [ ] { } , new String [ ] { } , "getCollator" , className , il , cpg ) ; final int collator = cpg . addFieldref ( className , "collator" , COLLATOR_SIG ) ; il . append ( new GETSTATIC ( collator ) ) ; il . append ( ARETURN ) ; getCollator . stripAttributes ( true ) ; getCollator . setMaxLocals ( ) ; getCollator . setMaxStack ( ) ; getCollator . removeNOPs ( ) ; return getCollator . getMethod ( ) ; } } 	0	['19', '3', '0', '64', '101', '119', '2', '64', '13', '0.85', '1465', '0.8', '4', '0.756756757', '0.23923445', '1', '3', '75.57894737', '9', '3.0526', '0']
package org . apache . xpath . compiler ; import java . util . Vector ; import java . util . Hashtable ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . XPathProcessorException ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XString ; import org . apache . xpath . objects . XNumber ; import org . apache . xalan . res . XSLMessages ; import javax . xml . transform . TransformerException ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . ErrorListener ; public class XPathParser { static public final String CONTINUE_AFTER_FATAL_ERROR = "CONTINUE_AFTER_FATAL_ERROR" ; private OpMap m_ops ; transient String m_token ; transient char m_tokenChar = 0 ; int m_queueMark = 0 ; protected final static int FILTER_MATCH_FAILED = 0 ; protected final static int FILTER_MATCH_PRIMARY = 1 ; protected final static int FILTER_MATCH_PREDICATES = 2 ; public XPathParser ( ErrorListener errorListener , javax . xml . transform . SourceLocator sourceLocator ) { m_errorListener = errorListener ; m_sourceLocator = sourceLocator ; } PrefixResolver m_namespaceContext ; public void initXPath ( Compiler compiler , String expression , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { m_ops = compiler ; m_namespaceContext = namespaceContext ; Lexer lexer = new Lexer ( compiler , namespaceContext , this ) ; lexer . tokenize ( expression ) ; m_ops . m_opMap [ 0 ] = OpCodes . OP_XPATH ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] = 2 ; try { nextToken ( ) ; Expr ( ) ; if ( null != m_token ) { String extraTokens = "" ; while ( null != m_token ) { extraTokens += "'" + m_token + "'" ; nextToken ( ) ; if ( null != m_token ) extraTokens += ", " ; } error ( XPATHErrorResources . ER_EXTRA_ILLEGAL_TOKENS , new Object [ ] { extraTokens } ) ; } } catch ( org . apache . xpath . XPathProcessorException e ) { if ( CONTINUE_AFTER_FATAL_ERROR . equals ( e . getMessage ( ) ) ) { initXPath ( compiler , "/.." , namespaceContext ) ; } else throw e ; } compiler . shrink ( ) ; } public void initMatchPattern ( Compiler compiler , String expression , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { m_ops = compiler ; m_namespaceContext = namespaceContext ; Lexer lexer = new Lexer ( compiler , namespaceContext , this ) ; lexer . tokenize ( expression ) ; m_ops . m_opMap [ 0 ] = OpCodes . OP_MATCHPATTERN ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] = 2 ; nextToken ( ) ; Pattern ( ) ; if ( null != m_token ) { String extraTokens = "" ; while ( null != m_token ) { extraTokens += "'" + m_token + "'" ; nextToken ( ) ; if ( null != m_token ) extraTokens += ", " ; } error ( XPATHErrorResources . ER_EXTRA_ILLEGAL_TOKENS , new Object [ ] { extraTokens } ) ; } m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . ENDOP ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; m_ops . shrink ( ) ; } private ErrorListener m_errorListener ; javax . xml . transform . SourceLocator m_sourceLocator ; public void setErrorHandler ( ErrorListener handler ) { m_errorListener = handler ; } public ErrorListener getErrorListener ( ) { return m_errorListener ; } final boolean tokenIs ( String s ) { return ( m_token != null ) ? ( m_token . equals ( s ) ) : ( s == null ) ; } final boolean tokenIs ( char c ) { return ( m_token != null ) ? ( m_tokenChar == c ) : false ; } final boolean lookahead ( char c , int n ) { int pos = ( m_queueMark + n ) ; boolean b ; if ( ( pos <= m_ops . m_tokenQueueSize ) && ( pos > 0 ) && ( m_ops . m_tokenQueueSize != 0 ) ) { String tok = ( ( String ) m_ops . m_tokenQueue [ pos - 1 ] ) ; b = ( tok . length ( ) == 1 ) ? ( tok . charAt ( 0 ) == c ) : false ; } else { b = false ; } return b ; } private final boolean lookbehind ( char c , int n ) { boolean isToken ; int lookBehindPos = m_queueMark - ( n + 1 ) ; if ( lookBehindPos >= 0 ) { String lookbehind = ( String ) m_ops . m_tokenQueue [ lookBehindPos ] ; if ( lookbehind . length ( ) == 1 ) { char c0 = ( lookbehind == null ) ? '|' : lookbehind . charAt ( 0 ) ; isToken = ( c0 == '|' ) ? false : ( c0 == c ) ; } else { isToken = false ; } } else { isToken = false ; } return isToken ; } private final boolean lookbehindHasToken ( int n ) { boolean hasToken ; if ( ( m_queueMark - n ) > 0 ) { String lookbehind = ( String ) m_ops . m_tokenQueue [ m_queueMark - ( n - 1 ) ] ; char c0 = ( lookbehind == null ) ? '|' : lookbehind . charAt ( 0 ) ; hasToken = ( c0 == '|' ) ? false : true ; } else { hasToken = false ; } return hasToken ; } private final boolean lookahead ( String s , int n ) { boolean isToken ; if ( ( m_queueMark + n ) <= m_ops . m_tokenQueueSize ) { String lookahead = ( String ) m_ops . m_tokenQueue [ m_queueMark + ( n - 1 ) ] ; isToken = ( lookahead != null ) ? lookahead . equals ( s ) : ( s == null ) ; } else { isToken = ( null == s ) ; } return isToken ; } private final void nextToken ( ) { if ( m_queueMark < m_ops . m_tokenQueueSize ) { m_token = ( String ) m_ops . m_tokenQueue [ m_queueMark ++ ] ; m_tokenChar = m_token . charAt ( 0 ) ; } else { m_token = null ; m_tokenChar = 0 ; } } private final String getTokenRelative ( int i ) { String tok ; int relative = m_queueMark + i ; if ( ( relative > 0 ) && ( relative < m_ops . m_tokenQueueSize ) ) { tok = ( String ) m_ops . m_tokenQueue [ relative ] ; } else { tok = null ; } return tok ; } private final void prevToken ( ) { if ( m_queueMark > 0 ) { m_queueMark -- ; m_token = ( String ) m_ops . m_tokenQueue [ m_queueMark ] ; m_tokenChar = m_token . charAt ( 0 ) ; } else { m_token = null ; m_tokenChar = 0 ; } } private final void consumeExpected ( String expected ) throws javax . xml . transform . TransformerException { if ( tokenIs ( expected ) ) { nextToken ( ) ; } else { error ( XPATHErrorResources . ER_EXPECTED_BUT_FOUND , new Object [ ] { expected , m_token } ) ; throw new XPathProcessorException ( CONTINUE_AFTER_FATAL_ERROR ) ; } } private final void consumeExpected ( char expected ) throws javax . xml . transform . TransformerException { if ( tokenIs ( expected ) ) { nextToken ( ) ; } else { error ( XPATHErrorResources . ER_EXPECTED_BUT_FOUND , new Object [ ] { String . valueOf ( expected ) , m_token } ) ; throw new XPathProcessorException ( CONTINUE_AFTER_FATAL_ERROR ) ; } } void warn ( int msg , Object [ ] args ) throws TransformerException { String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; ErrorListener ehandler = this . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . warning ( new TransformerException ( fmsg , m_sourceLocator ) ) ; } else { System . err . println ( fmsg ) ; } } private void assertion ( boolean b , String msg ) { if ( ! b ) { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } void error ( int msg , Object [ ] args ) throws TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; ErrorListener ehandler = this . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , m_sourceLocator ) ; if ( null != ehandler ) { ehandler . fatalError ( te ) ; } else { throw te ; } } protected String dumpRemainingTokenQueue ( ) { int q = m_queueMark ; String returnMsg ; if ( q < m_ops . m_tokenQueueSize ) { String msg = "\n Remaining tokens: (" ; while ( q < m_ops . m_tokenQueueSize ) { String t = ( String ) m_ops . m_tokenQueue [ q ++ ] ; msg += ( " '" + t + "'" ) ; } returnMsg = msg + ")" ; } else { returnMsg = "" ; } return returnMsg ; } final int getFunctionToken ( String key ) { int tok ; try { tok = ( ( Integer ) ( Keywords . m_functions . get ( key ) ) ) . intValue ( ) ; } catch ( NullPointerException npe ) { tok = - 1 ; } catch ( ClassCastException cce ) { tok = - 1 ; } return tok ; } void insertOp ( int pos , int length , int op ) { int totalLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; for ( int i = totalLen - 1 ; i >= pos ; i -- ) { m_ops . m_opMap [ i + length ] = m_ops . m_opMap [ i ] ; } m_ops . m_opMap [ pos ] = op ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] = totalLen + length ; } void appendOp ( int length , int op ) { int totalLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; m_ops . m_opMap [ totalLen ] = op ; m_ops . m_opMap [ totalLen + OpMap . MAPINDEX_LENGTH ] = length ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] = totalLen + length ; } protected void Expr ( ) throws javax . xml . transform . TransformerException { OrExpr ( ) ; } protected void OrExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; AndExpr ( ) ; if ( ( null != m_token ) && tokenIs ( "or" ) ) { nextToken ( ) ; insertOp ( opPos , 2 , OpCodes . OP_OR ) ; OrExpr ( ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } } protected void AndExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; EqualityExpr ( - 1 ) ; if ( ( null != m_token ) && tokenIs ( "and" ) ) { nextToken ( ) ; insertOp ( opPos , 2 , OpCodes . OP_AND ) ; AndExpr ( ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } } protected int EqualityExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; if ( - 1 == addPos ) addPos = opPos ; RelationalExpr ( - 1 ) ; if ( null != m_token ) { if ( tokenIs ( '!' ) && lookahead ( '=' , 1 ) ) { nextToken ( ) ; nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_NOTEQUALS ) ; int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = EqualityExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } else if ( tokenIs ( '=' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_EQUALS ) ; int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = EqualityExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } } return addPos ; } protected int RelationalExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; if ( - 1 == addPos ) addPos = opPos ; AdditiveExpr ( - 1 ) ; if ( null != m_token ) { if ( tokenIs ( '<' ) ) { nextToken ( ) ; if ( tokenIs ( '=' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_LTE ) ; } else { insertOp ( addPos , 2 , OpCodes . OP_LT ) ; } int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = RelationalExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } else if ( tokenIs ( '>' ) ) { nextToken ( ) ; if ( tokenIs ( '=' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_GTE ) ; } else { insertOp ( addPos , 2 , OpCodes . OP_GT ) ; } int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = RelationalExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } } return addPos ; } protected int AdditiveExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; if ( - 1 == addPos ) addPos = opPos ; MultiplicativeExpr ( - 1 ) ; if ( null != m_token ) { if ( tokenIs ( '+' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_PLUS ) ; int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = AdditiveExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } else if ( tokenIs ( '-' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_MINUS ) ; int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = AdditiveExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } } return addPos ; } protected int MultiplicativeExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; if ( - 1 == addPos ) addPos = opPos ; UnaryExpr ( ) ; if ( null != m_token ) { if ( tokenIs ( '*' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_MULT ) ; int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } else if ( tokenIs ( "div" ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_DIV ) ; int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } else if ( tokenIs ( "mod" ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_MOD ) ; int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } else if ( tokenIs ( "quo" ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_QUO ) ; int opPlusLeftHandLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . m_opMap [ addPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ addPos + opPlusLeftHandLen + 1 ] + opPlusLeftHandLen ; addPos += 2 ; } } return addPos ; } protected void UnaryExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; boolean isNeg = false ; if ( m_tokenChar == '-' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_NEG ) ; isNeg = true ; } UnionExpr ( ) ; if ( isNeg ) m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } protected void StringExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; appendOp ( 2 , OpCodes . OP_STRING ) ; Expr ( ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } protected void BooleanExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; appendOp ( 2 , OpCodes . OP_BOOL ) ; Expr ( ) ; int opLen = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; if ( opLen == 2 ) { error ( XPATHErrorResources . ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , null ) ; } m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = opLen ; } protected void NumberExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; appendOp ( 2 , OpCodes . OP_NUMBER ) ; Expr ( ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } protected void UnionExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; boolean continueOrLoop = true ; boolean foundUnion = false ; do { PathExpr ( ) ; if ( tokenIs ( '|' ) ) { if ( false == foundUnion ) { foundUnion = true ; insertOp ( opPos , 2 , OpCodes . OP_UNION ) ; } nextToken ( ) ; } else { break ; } } while ( continueOrLoop ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } protected void PathExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; int filterExprMatch = FilterExpr ( ) ; if ( filterExprMatch != FILTER_MATCH_FAILED ) { boolean locationPathStarted = ( filterExprMatch == FILTER_MATCH_PREDICATES ) ; if ( tokenIs ( '/' ) ) { nextToken ( ) ; if ( ! locationPathStarted ) { insertOp ( opPos , 2 , OpCodes . OP_LOCATIONPATH ) ; locationPathStarted = true ; } if ( ! RelativeLocationPath ( ) ) { error ( XPATHErrorResources . ER_EXPECTED_REL_LOC_PATH , null ) ; } } if ( locationPathStarted ) { m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . ENDOP ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } } else { LocationPath ( ) ; } } protected int FilterExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; int filterMatch ; if ( PrimaryExpr ( ) ) { if ( tokenIs ( '[' ) ) { insertOp ( opPos , 2 , OpCodes . OP_LOCATIONPATH ) ; while ( tokenIs ( '[' ) ) { Predicate ( ) ; } filterMatch = FILTER_MATCH_PREDICATES ; } else { filterMatch = FILTER_MATCH_PRIMARY ; } } else { filterMatch = FILTER_MATCH_FAILED ; } return filterMatch ; } protected boolean PrimaryExpr ( ) throws javax . xml . transform . TransformerException { boolean matchFound ; int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; if ( ( m_tokenChar == '\'' ) || ( m_tokenChar == '"' ) ) { appendOp ( 2 , OpCodes . OP_LITERAL ) ; Literal ( ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; matchFound = true ; } else if ( m_tokenChar == '$' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_VARIABLE ) ; QName ( ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; matchFound = true ; } else if ( m_tokenChar == '(' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_GROUP ) ; Expr ( ) ; consumeExpected ( ')' ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; matchFound = true ; } else if ( ( null != m_token ) && ( ( ( '.' == m_tokenChar ) && ( m_token . length ( ) > 1 ) && Character . isDigit ( m_token . charAt ( 1 ) ) ) || Character . isDigit ( m_tokenChar ) ) ) { appendOp ( 2 , OpCodes . OP_NUMBERLIT ) ; Number ( ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; matchFound = true ; } else if ( lookahead ( '(' , 1 ) || ( lookahead ( ':' , 1 ) && lookahead ( '(' , 3 ) ) ) { matchFound = FunctionCall ( ) ; } else { matchFound = false ; } return matchFound ; } protected void Argument ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; appendOp ( 2 , OpCodes . OP_ARGUMENT ) ; Expr ( ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } protected boolean FunctionCall ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; if ( lookahead ( ':' , 1 ) ) { appendOp ( 4 , OpCodes . OP_EXTFUNCTION ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH + 1 ] = m_queueMark - 1 ; nextToken ( ) ; consumeExpected ( ':' ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH + 2 ] = m_queueMark - 1 ; nextToken ( ) ; } else { int funcTok = getFunctionToken ( m_token ) ; if ( - 1 == funcTok ) { error ( XPATHErrorResources . ER_COULDNOT_FIND_FUNCTION , new Object [ ] { m_token } ) ; } switch ( funcTok ) { case OpCodes . NODETYPE_PI : case OpCodes . NODETYPE_COMMENT : case OpCodes . NODETYPE_TEXT : case OpCodes . NODETYPE_NODE : return false ; default : appendOp ( 3 , OpCodes . OP_FUNCTION ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH + 1 ] = funcTok ; } nextToken ( ) ; } consumeExpected ( '(' ) ; while ( ! tokenIs ( ')' ) && m_token != null ) { if ( tokenIs ( ',' ) ) { error ( XPATHErrorResources . ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , null ) ; } Argument ( ) ; if ( ! tokenIs ( ')' ) ) { consumeExpected ( ',' ) ; if ( tokenIs ( ')' ) ) { error ( XPATHErrorResources . ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , null ) ; } } } consumeExpected ( ')' ) ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . ENDOP ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; return true ; } protected void LocationPath ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; appendOp ( 2 , OpCodes . OP_LOCATIONPATH ) ; boolean seenSlash = tokenIs ( '/' ) ; if ( seenSlash ) { appendOp ( 4 , OpCodes . FROM_ROOT ) ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 2 ] = 4 ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 1 ] = OpCodes . NODETYPE_ROOT ; nextToken ( ) ; } if ( m_token != null ) { if ( ! RelativeLocationPath ( ) && ! seenSlash ) { error ( XPATHErrorResources . ER_EXPECTED_LOC_PATH , new Object [ ] { m_token } ) ; } } m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . ENDOP ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } protected boolean RelativeLocationPath ( ) throws javax . xml . transform . TransformerException { if ( ! Step ( ) ) { return false ; } while ( tokenIs ( '/' ) ) { nextToken ( ) ; if ( ! Step ( ) ) { error ( XPATHErrorResources . ER_EXPECTED_LOC_STEP , null ) ; } } return true ; } protected boolean Step ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; boolean doubleSlash = tokenIs ( '/' ) ; if ( doubleSlash ) { nextToken ( ) ; appendOp ( 2 , OpCodes . FROM_DESCENDANTS_OR_SELF ) ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . NODETYPE_NODE ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH + 1 ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; } if ( tokenIs ( "." ) ) { nextToken ( ) ; if ( tokenIs ( '[' ) ) { error ( XPATHErrorResources . ER_PREDICATE_ILLEGAL_SYNTAX , null ) ; } appendOp ( 4 , OpCodes . FROM_SELF ) ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 2 ] = 4 ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 1 ] = OpCodes . NODETYPE_NODE ; } else if ( tokenIs ( ".." ) ) { nextToken ( ) ; appendOp ( 4 , OpCodes . FROM_PARENT ) ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 2 ] = 4 ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 1 ] = OpCodes . NODETYPE_NODE ; } else if ( tokenIs ( '*' ) || tokenIs ( '@' ) || tokenIs ( '_' ) || ( m_token != null && Character . isLetter ( m_token . charAt ( 0 ) ) ) ) { Basis ( ) ; while ( tokenIs ( '[' ) ) { Predicate ( ) ; } m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } else { if ( doubleSlash ) { error ( XPATHErrorResources . ER_EXPECTED_LOC_STEP , null ) ; } return false ; } return true ; } protected void Basis ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; int axesType ; if ( lookahead ( "::" , 1 ) ) { axesType = AxisName ( ) ; nextToken ( ) ; nextToken ( ) ; } else if ( tokenIs ( '@' ) ) { axesType = OpCodes . FROM_ATTRIBUTES ; appendOp ( 2 , axesType ) ; nextToken ( ) ; } else { axesType = OpCodes . FROM_CHILDREN ; appendOp ( 2 , axesType ) ; } m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; NodeTest ( axesType ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH + 1 ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } protected int AxisName ( ) throws javax . xml . transform . TransformerException { Object val = Keywords . m_axisnames . get ( m_token ) ; if ( null == val ) { error ( XPATHErrorResources . ER_ILLEGAL_AXIS_NAME , new Object [ ] { m_token } ) ; } int axesType = ( ( Integer ) val ) . intValue ( ) ; appendOp ( 2 , axesType ) ; return axesType ; } protected void NodeTest ( int axesType ) throws javax . xml . transform . TransformerException { if ( lookahead ( '(' , 1 ) ) { Object nodeTestOp = Keywords . m_nodetypes . get ( m_token ) ; if ( null == nodeTestOp ) { error ( XPATHErrorResources . ER_UNKNOWN_NODETYPE , new Object [ ] { m_token } ) ; } else { nextToken ( ) ; int nt = ( ( Integer ) nodeTestOp ) . intValue ( ) ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = nt ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; consumeExpected ( '(' ) ; if ( OpCodes . NODETYPE_PI == nt ) { if ( ! tokenIs ( ')' ) ) { Literal ( ) ; } } consumeExpected ( ')' ) ; } } else { m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . NODENAME ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; if ( lookahead ( ':' , 1 ) ) { if ( tokenIs ( '*' ) ) { m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . ELEMWILDCARD ; } else { m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = m_queueMark - 1 ; if ( ! Character . isLetter ( m_tokenChar ) && ! tokenIs ( '_' ) ) { error ( XPATHErrorResources . ER_EXPECTED_NODE_TEST , null ) ; } } nextToken ( ) ; consumeExpected ( ':' ) ; } else { m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . EMPTY ; } m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; if ( tokenIs ( '*' ) ) { m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . ELEMWILDCARD ; } else { if ( OpCodes . FROM_NAMESPACE == axesType ) { String prefix = ( String ) this . m_ops . m_tokenQueue [ m_queueMark - 1 ] ; String namespace = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; this . m_ops . m_tokenQueue [ m_queueMark - 1 ] = namespace ; } m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = m_queueMark - 1 ; if ( ! Character . isLetter ( m_tokenChar ) && ! tokenIs ( '_' ) ) { error ( XPATHErrorResources . ER_EXPECTED_NODE_TEST , null ) ; } } m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; nextToken ( ) ; } } protected void Predicate ( ) throws javax . xml . transform . TransformerException { if ( tokenIs ( '[' ) ) { nextToken ( ) ; PredicateExpr ( ) ; consumeExpected ( ']' ) ; } } protected void PredicateExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; appendOp ( 2 , OpCodes . OP_PREDICATE ) ; Expr ( ) ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . ENDOP ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } protected void QName ( ) throws javax . xml . transform . TransformerException { if ( lookahead ( ':' , 1 ) ) { m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = m_queueMark - 1 ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; nextToken ( ) ; consumeExpected ( ':' ) ; } else { m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . EMPTY ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; } m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = m_queueMark - 1 ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; nextToken ( ) ; } protected void NCName ( ) { m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = m_queueMark - 1 ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; nextToken ( ) ; } protected void Literal ( ) throws javax . xml . transform . TransformerException { int last = m_token . length ( ) - 1 ; char c0 = m_tokenChar ; char cX = m_token . charAt ( last ) ; if ( ( ( c0 == '\"' ) && ( cX == '\"' ) ) || ( ( c0 == '\'' ) && ( cX == '\'' ) ) ) { int tokenQueuePos = m_queueMark - 1 ; m_ops . m_tokenQueue [ tokenQueuePos ] = null ; Object obj = new XString ( m_token . substring ( 1 , last ) ) ; m_ops . m_tokenQueue [ tokenQueuePos ] = obj ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = tokenQueuePos ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; nextToken ( ) ; } else { error ( XPATHErrorResources . ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , new Object [ ] { m_token } ) ; } } protected void Number ( ) throws javax . xml . transform . TransformerException { if ( null != m_token ) { double num ; try { num = Double . valueOf ( m_token ) . doubleValue ( ) ; } catch ( NumberFormatException nfe ) { num = 0.0 ; error ( XPATHErrorResources . ER_COULDNOT_BE_FORMATTED_TO_NUMBER , new Object [ ] { m_token } ) ; } m_ops . m_tokenQueue [ m_queueMark - 1 ] = new XNumber ( num ) ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = m_queueMark - 1 ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; nextToken ( ) ; } } protected void Pattern ( ) throws javax . xml . transform . TransformerException { while ( true ) { LocationPathPattern ( ) ; if ( tokenIs ( '|' ) ) { nextToken ( ) ; } else { break ; } } } protected void LocationPathPattern ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; final int RELATIVE_PATH_NOT_PERMITTED = 0 ; final int RELATIVE_PATH_PERMITTED = 1 ; final int RELATIVE_PATH_REQUIRED = 2 ; int relativePathStatus = RELATIVE_PATH_NOT_PERMITTED ; appendOp ( 2 , OpCodes . OP_LOCATIONPATHPATTERN ) ; if ( lookahead ( '(' , 1 ) && ( tokenIs ( Keywords . FUNC_ID_STRING ) || tokenIs ( Keywords . FUNC_KEY_STRING ) ) ) { IdKeyPattern ( ) ; if ( tokenIs ( '/' ) ) { nextToken ( ) ; if ( tokenIs ( '/' ) ) { appendOp ( 4 , OpCodes . MATCH_ANY_ANCESTOR ) ; nextToken ( ) ; } else { appendOp ( 4 , OpCodes . MATCH_IMMEDIATE_ANCESTOR ) ; } m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 2 ] = 4 ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 1 ] = OpCodes . NODETYPE_FUNCTEST ; relativePathStatus = RELATIVE_PATH_REQUIRED ; } } else if ( tokenIs ( '/' ) ) { if ( lookahead ( '/' , 1 ) ) { appendOp ( 4 , OpCodes . MATCH_ANY_ANCESTOR ) ; nextToken ( ) ; relativePathStatus = RELATIVE_PATH_REQUIRED ; } else { appendOp ( 4 , OpCodes . FROM_ROOT ) ; relativePathStatus = RELATIVE_PATH_PERMITTED ; } m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 2 ] = 4 ; m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - 1 ] = OpCodes . NODETYPE_ROOT ; nextToken ( ) ; } else { relativePathStatus = RELATIVE_PATH_REQUIRED ; } if ( relativePathStatus != RELATIVE_PATH_NOT_PERMITTED ) { if ( ! tokenIs ( '|' ) && ( null != m_token ) ) { RelativePathPattern ( ) ; } else if ( relativePathStatus == RELATIVE_PATH_REQUIRED ) { error ( XPATHErrorResources . ER_EXPECTED_REL_PATH_PATTERN , null ) ; } } m_ops . m_opMap [ m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ] = OpCodes . ENDOP ; m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; } protected void IdKeyPattern ( ) throws javax . xml . transform . TransformerException { FunctionCall ( ) ; } protected void RelativePathPattern ( ) throws javax . xml . transform . TransformerException { boolean trailingSlashConsumed = StepPattern ( false ) ; while ( tokenIs ( '/' ) ) { nextToken ( ) ; trailingSlashConsumed = StepPattern ( ! trailingSlashConsumed ) ; } } protected boolean StepPattern ( boolean isLeadingSlashPermitted ) throws javax . xml . transform . TransformerException { return AbbreviatedNodeTestStep ( isLeadingSlashPermitted ) ; } protected boolean AbbreviatedNodeTestStep ( boolean isLeadingSlashPermitted ) throws javax . xml . transform . TransformerException { int opPos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; int axesType ; int matchTypePos = - 1 ; if ( tokenIs ( '@' ) ) { axesType = OpCodes . MATCH_ATTRIBUTE ; appendOp ( 2 , axesType ) ; nextToken ( ) ; } else if ( this . lookahead ( "::" , 1 ) ) { if ( tokenIs ( "attribute" ) ) { axesType = OpCodes . MATCH_ATTRIBUTE ; appendOp ( 2 , axesType ) ; } else if ( tokenIs ( "child" ) ) { matchTypePos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; axesType = OpCodes . MATCH_IMMEDIATE_ANCESTOR ; appendOp ( 2 , axesType ) ; } else { axesType = - 1 ; this . error ( XPATHErrorResources . ER_AXES_NOT_ALLOWED , new Object [ ] { this . m_token } ) ; } nextToken ( ) ; nextToken ( ) ; } else if ( tokenIs ( '/' ) ) { if ( ! isLeadingSlashPermitted ) { error ( XPATHErrorResources . ER_EXPECTED_STEP_PATTERN , null ) ; } axesType = OpCodes . MATCH_ANY_ANCESTOR ; appendOp ( 2 , axesType ) ; nextToken ( ) ; } else { matchTypePos = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] ; axesType = OpCodes . MATCH_IMMEDIATE_ANCESTOR ; appendOp ( 2 , axesType ) ; } m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] += 1 ; NodeTest ( axesType ) ; m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH + 1 ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; while ( tokenIs ( '[' ) ) { Predicate ( ) ; } boolean trailingSlashConsumed ; if ( ( matchTypePos > - 1 ) && tokenIs ( '/' ) && lookahead ( '/' , 1 ) ) { m_ops . m_opMap [ matchTypePos ] = OpCodes . MATCH_ANY_ANCESTOR ; nextToken ( ) ; trailingSlashConsumed = true ; } else { trailingSlashConsumed = false ; } m_ops . m_opMap [ opPos + OpMap . MAPINDEX_LENGTH ] = m_ops . m_opMap [ OpMap . MAPINDEX_LENGTH ] - opPos ; return trailingSlashConsumed ; } } 	1	['58', '1', '0', '13', '88', '0', '4', '10', '5', '0.679425837', '3479', '0.454545455', '2', '0', '0.163793103', '0', '0', '58.79310345', '6', '1.4828', '1']
package org . apache . xpath . axes ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . functions . FuncLast ; import org . apache . xpath . functions . FuncPosition ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . operations . Div ; import org . apache . xpath . operations . Minus ; import org . apache . xpath . operations . Mod ; import org . apache . xpath . operations . Mult ; import org . apache . xpath . operations . Plus ; import org . apache . xpath . operations . Quo ; import org . apache . xpath . operations . Variable ; public class HasPositionalPredChecker extends XPathVisitor { private boolean m_hasPositionalPred = false ; private int m_predDepth = 0 ; public static boolean check ( LocPathIterator path ) { HasPositionalPredChecker hppc = new HasPositionalPredChecker ( ) ; path . callVisitors ( null , hppc ) ; return hppc . m_hasPositionalPred ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { if ( ( func instanceof FuncPosition ) || ( func instanceof FuncLast ) ) m_hasPositionalPred = true ; return true ; } public boolean visitPredicate ( ExpressionOwner owner , Expression pred ) { m_predDepth ++ ; if ( m_predDepth == 1 ) { if ( ( pred instanceof Variable ) || ( pred instanceof XNumber ) || ( pred instanceof Div ) || ( pred instanceof Plus ) || ( pred instanceof Minus ) || ( pred instanceof Mod ) || ( pred instanceof Quo ) || ( pred instanceof Mult ) || ( pred instanceof org . apache . xpath . operations . Number ) || ( pred instanceof Function ) ) m_hasPositionalPred = true ; else pred . callVisitors ( owner , this ) ; } m_predDepth -- ; return false ; } } 	0	['4', '2', '0', '18', '7', '0', '1', '17', '4', '0.166666667', '93', '1', '0', '0.8', '0.4', '0', '0', '21.75', '12', '4', '0']
package org . apache . xalan . transformer ; import java . util . Enumeration ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . trace . TraceManager ; import org . apache . xalan . trace . GenerateEvent ; import org . apache . xml . utils . MutableAttrListImpl ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . ObjectPool ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . XPathContext ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMFilter ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . SAXParseException ; import org . xml . sax . SAXException ; import org . xml . sax . ErrorHandler ; import org . xml . sax . helpers . NamespaceSupport ; import org . apache . xml . utils . NamespaceSupport2 ; import org . xml . sax . Locator ; import javax . xml . transform . TransformerException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Transformer ; public class ResultTreeHandler extends QueuedEvents implements ContentHandler , LexicalHandler , TransformState , org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler , ErrorHandler { private static final boolean DEBUG = false ; public ResultTreeHandler ( ) { } public ResultTreeHandler ( TransformerImpl transformer , ContentHandler realHandler ) { init ( transformer , realHandler ) ; } public void init ( TransformerImpl transformer , ContentHandler realHandler ) { m_transformer = transformer ; TraceManager tracer = transformer . getTraceManager ( ) ; if ( ( null != tracer ) && tracer . hasTraceListeners ( ) ) m_tracer = tracer ; else m_tracer = null ; m_contentHandler = realHandler ; if ( m_contentHandler instanceof LexicalHandler ) m_lexicalHandler = ( LexicalHandler ) m_contentHandler ; else m_lexicalHandler = null ; m_isTransformClient = ( m_contentHandler instanceof TransformerClient ) ; m_cloner = new ClonerToResultTree ( transformer , this ) ; if ( null != m_transformer ) m_stylesheetRoot = m_transformer . getStylesheet ( ) ; pushDocumentEvent ( ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { } public void endDocument ( ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( ! m_docEnded ) { m_contentHandler . endDocument ( ) ; if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_ENDDOCUMENT , null ) ; m_tracer . fireGenerateEvent ( ge ) ; } m_docEnded = true ; m_docPending = false ; } } public void startElement ( String ns , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { if ( DEBUG ) { if ( m_elemIsPending ) System . out . println ( "(ResultTreeHandler#startElement - pended: " + m_url + "#" + m_localName ) ; System . out . println ( "ResultTreeHandler#startElement: " + ns + "#" + localName ) ; } if ( m_docPending ) checkForSerializerSwitch ( ns , localName ) ; flushPending ( true ) ; if ( ! m_nsContextPushed ) { if ( DEBUG ) System . out . println ( "ResultTreeHandler#startElement - push(startElement)" ) ; m_nsSupport . pushContext ( ) ; m_nsContextPushed = true ; } if ( ns != null ) ensurePrefixIsDeclared ( ns , name ) ; m_name = name ; m_url = ns ; m_localName = localName ; if ( null != atts ) m_attributes . addAttributes ( atts ) ; m_elemIsPending = true ; m_elemIsEnded = false ; if ( m_isTransformClient && ( null != m_transformer ) ) { m_snapshot . m_currentElement = m_transformer . getCurrentElement ( ) ; m_snapshot . m_currentTemplate = m_transformer . getCurrentTemplate ( ) ; m_snapshot . m_matchedTemplate = m_transformer . getMatchedTemplate ( ) ; int currentNodeHandle = m_transformer . getCurrentNode ( ) ; DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( currentNodeHandle ) ; m_snapshot . m_currentNode = dtm . getNode ( currentNodeHandle ) ; m_snapshot . m_matchedNode = m_transformer . getMatchedNode ( ) ; m_snapshot . m_contextNodeList = m_transformer . getContextNodeList ( ) ; } m_eventCount ++ ; } public void endElement ( String ns , String localName , String name ) throws org . xml . sax . SAXException { if ( DEBUG ) { if ( m_elemIsPending ) System . out . println ( "(ResultTreeHandler#endElement - pended: " + m_url + "#" + m_localName ) ; System . out . println ( "ResultTreeHandler#endElement: " + ns + "#" + localName ) ; } flushPending ( true ) ; m_contentHandler . endElement ( ns , localName , name ) ; if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_ENDELEMENT , name , ( Attributes ) null ) ; m_tracer . fireGenerateEvent ( ge ) ; } sendEndPrefixMappings ( ) ; popEvent ( ) ; if ( DEBUG ) System . out . println ( "ResultTreeHandler#startElement pop: " + localName ) ; m_nsSupport . popContext ( ) ; } boolean m_nsContextPushed = false ; public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { startPrefixMapping ( prefix , uri , true ) ; } public void startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws org . xml . sax . SAXException { if ( shouldFlush ) flushPending ( false ) ; if ( ! m_nsContextPushed ) { if ( DEBUG ) System . out . println ( "ResultTreeHandler#startPrefixMapping push(startPrefixMapping: " + prefix + ")" ) ; m_nsSupport . pushContext ( ) ; m_nsContextPushed = true ; } if ( null == prefix ) prefix = "" ; String existingURI = m_nsSupport . getURI ( prefix ) ; if ( null == existingURI ) existingURI = "" ; if ( null == uri ) uri = "" ; if ( ! existingURI . equals ( uri ) ) { if ( DEBUG ) { System . out . println ( "ResultTreeHandler#startPrefixMapping Prefix: " + prefix ) ; System . out . println ( "ResultTreeHandler#startPrefixMapping uri: " + uri ) ; } m_nsSupport . declarePrefix ( prefix , uri ) ; } } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . print ( "ResultTreeHandler#characters: " ) ; int n = start + length ; for ( int i = start ; i < n ; i ++ ) { if ( Character . isWhitespace ( ch [ i ] ) ) System . out . print ( "\\" + ( ( int ) ch [ i ] ) ) ; else System . out . print ( ch [ i ] ) ; } System . out . println ( "" ) ; } flushPending ( true ) ; m_contentHandler . characters ( ch , start , length ) ; if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_CHARACTERS , ch , start , length ) ; m_tracer . fireGenerateEvent ( ge ) ; } } public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( m_isTransformClient ) m_snapshot . m_currentNode = node ; String data = node . getNodeValue ( ) ; char [ ] ch = null ; int length = 0 ; if ( data != null ) { ch = data . toCharArray ( ) ; length = data . length ( ) ; m_contentHandler . characters ( ch , 0 , length ) ; } if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_CHARACTERS , ch , 0 , length ) ; m_tracer . fireGenerateEvent ( ge ) ; } if ( m_isTransformClient ) m_snapshot . m_currentNode = null ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( m_docPending && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; flushPending ( true ) ; m_contentHandler . ignorableWhitespace ( ch , start , length ) ; if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_IGNORABLEWHITESPACE , ch , start , length ) ; m_tracer . fireGenerateEvent ( ge ) ; } } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { flushPending ( true ) ; m_contentHandler . processingInstruction ( target , data ) ; if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_PI , target , data ) ; m_tracer . fireGenerateEvent ( ge ) ; } } public void comment ( String data ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_COMMENT , data ) ; m_tracer . fireGenerateEvent ( ge ) ; } } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . comment ( ch , start , length ) ; } if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_COMMENT , new String ( ch , start , length ) ) ; m_tracer . fireGenerateEvent ( ge ) ; } } public void entityReference ( String name ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startEntity ( name ) ; m_lexicalHandler . endEntity ( name ) ; } if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_ENTITYREF , name ) ; m_tracer . fireGenerateEvent ( ge ) ; } } public void startEntity ( String name ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startEntity ( name ) ; } } public void endEntity ( String name ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endEntity ( name ) ; } if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_ENTITYREF , name ) ; m_tracer . fireGenerateEvent ( ge ) ; } } public void startDTD ( String s1 , String s2 , String s3 ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startDTD ( s1 , s2 , s3 ) ; } } public void endDTD ( ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endDTD ( ) ; } } public void startCDATA ( ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws org . xml . sax . SAXException { flushPending ( true ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endCDATA ( ) ; } } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { } public void setNSDeclsHaveBeenAdded ( boolean b ) { m_nsDeclsHaveBeenAdded = b ; } void flushDocEvent ( ) throws org . xml . sax . SAXException { if ( m_docPending ) { m_contentHandler . startDocument ( ) ; if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_STARTDOCUMENT ) ; m_tracer . fireGenerateEvent ( ge ) ; } if ( m_contentHandler instanceof TransformerClient ) { ( ( TransformerClient ) m_contentHandler ) . setTransformState ( this ) ; } m_docPending = false ; } } void flushElem ( ) throws org . xml . sax . SAXException { if ( m_elemIsPending ) { if ( null != m_name ) { try { m_contentHandler . startElement ( m_url , m_localName , m_name , m_attributes ) ; } catch ( Exception re ) { throw new SAXParseException ( re . getMessage ( ) , m_transformer . getCurrentElement ( ) . getPublicId ( ) , m_transformer . getCurrentElement ( ) . getSystemId ( ) , m_transformer . getCurrentElement ( ) . getLineNumber ( ) , m_transformer . getCurrentElement ( ) . getColumnNumber ( ) , re ) ; } if ( null != m_tracer ) { GenerateEvent ge = new GenerateEvent ( m_transformer , GenerateEvent . EVENTTYPE_STARTELEMENT , m_name , m_attributes ) ; m_tracer . fireGenerateEvent ( ge ) ; } if ( m_isTransformClient ) m_snapshot . m_currentNode = null ; } m_elemIsPending = false ; m_attributes . clear ( ) ; m_nsDeclsHaveBeenAdded = false ; m_name = null ; m_url = null ; m_localName = null ; m_namespaces = null ; } } public final void flushPending ( ) throws org . xml . sax . SAXException { flushPending ( true ) ; } public final void flushPending ( boolean flushPrefixes ) throws org . xml . sax . SAXException { if ( flushPrefixes && m_docPending ) { flushDocEvent ( ) ; } if ( m_elemIsPending ) { if ( ! m_nsDeclsHaveBeenAdded ) startAndAddPrefixMappings ( ) ; else sendStartPrefixMappings ( ) ; if ( DEBUG ) { System . out . println ( "ResultTreeHandler#flushPending - start flush: " + m_name ) ; } flushElem ( ) ; if ( DEBUG ) { System . out . println ( "ResultTreeHandler#flushPending - after flush, isPending: " + m_elemIsPending ) ; } m_nsContextPushed = false ; } } public void outputResultTreeFragment ( XObject obj , XPathContext support ) throws org . xml . sax . SAXException { int doc = obj . rtf ( ) ; DTM dtm = support . getDTM ( doc ) ; if ( null != dtm ) { for ( int n = dtm . getFirstChild ( doc ) ; DTM . NULL != n ; n = dtm . getNextSibling ( n ) ) { flushPending ( true ) ; dtm . dispatchToEvents ( n , this ) ; } } } public void setDocumentLocator ( Locator locator ) { } public void ensurePrefixIsDeclared ( String ns , String rawName ) throws org . xml . sax . SAXException { if ( ns != null && ns . length ( ) > 0 ) { int index ; String prefix = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; if ( null != prefix ) { String foundURI = m_nsSupport . getURI ( prefix ) ; if ( ( null == foundURI ) || ! foundURI . equals ( ns ) ) { startPrefixMapping ( prefix , ns , false ) ; m_attributes . addAttribute ( "http://www.w3.org/2000/xmlns/" , prefix , "xmlns" + ( prefix . length ( ) == 0 ? "" : ":" ) + prefix , "CDATA" , ns ) ; } } } } public void ensureNamespaceDeclDeclared ( DTM dtm , int namespace ) throws org . xml . sax . SAXException { String uri = dtm . getNodeValue ( namespace ) ; String prefix = dtm . getNodeNameX ( namespace ) ; if ( ( uri != null && uri . length ( ) > 0 ) && ( null != prefix ) ) { String foundURI = m_nsSupport . getURI ( prefix ) ; if ( ( null == foundURI ) || ! foundURI . equals ( uri ) ) { startPrefixMapping ( prefix , uri , false ) ; } } } protected void sendStartPrefixMappings ( ) throws org . xml . sax . SAXException { Enumeration prefixes = m_nsSupport . getDeclaredPrefixes ( ) ; ContentHandler handler = m_contentHandler ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; handler . startPrefixMapping ( prefix , m_nsSupport . getURI ( prefix ) ) ; } } protected void startAndAddPrefixMappings ( ) throws org . xml . sax . SAXException { Enumeration prefixes = m_nsSupport . getDeclaredPrefixes ( ) ; ContentHandler handler = m_contentHandler ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; String uri = m_nsSupport . getURI ( prefix ) ; handler . startPrefixMapping ( prefix , uri ) ; boolean isDefault = ( prefix . length ( ) == 0 ) ; String name ; if ( isDefault ) { name = "xmlns" ; } else name = "xmlns:" + prefix ; if ( null == uri ) uri = "" ; m_attributes . addAttribute ( "http://www.w3.org/2000/xmlns/" , prefix , name , "CDATA" , uri ) ; } m_nsDeclsHaveBeenAdded = true ; } protected void sendEndPrefixMappings ( ) throws org . xml . sax . SAXException { Enumeration prefixes = m_nsSupport . getDeclaredPrefixes ( ) ; ContentHandler handler = m_contentHandler ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; handler . endPrefixMapping ( prefix ) ; } } private void checkForSerializerSwitch ( String ns , String localName ) throws org . xml . sax . SAXException { try { if ( m_docPending ) { SerializerSwitcher . switchSerializerIfHTML ( m_transformer , ns , localName ) ; } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void addNSDeclsToAttrs ( ) { Enumeration prefixes = m_nsSupport . getDeclaredPrefixes ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; boolean isDefault = ( prefix . length ( ) == 0 ) ; String name ; if ( isDefault ) { name = "xmlns" ; } else name = "xmlns:" + prefix ; String uri = m_nsSupport . getURI ( prefix ) ; if ( null == uri ) uri = "" ; m_attributes . addAttribute ( "http://www.w3.org/2000/xmlns/" , prefix , name , "CDATA" , uri ) ; m_nsDeclsHaveBeenAdded = true ; } } public void processNSDecls ( int src , int type , DTM dtm ) throws TransformerException { try { if ( type == DTM . ELEMENT_NODE ) { for ( int namespace = dtm . getFirstNamespaceNode ( src , true ) ; DTM . NULL != namespace ; namespace = dtm . getNextNamespaceNode ( src , namespace , true ) ) { String prefix = dtm . getNodeNameX ( namespace ) ; String desturi = getURI ( prefix ) ; String srcURI = dtm . getNodeValue ( namespace ) ; if ( ! srcURI . equalsIgnoreCase ( desturi ) ) { this . startPrefixMapping ( prefix , srcURI , false ) ; } } } else if ( type == DTM . NAMESPACE_NODE ) { String prefix = dtm . getNodeNameX ( src ) ; String desturi = getURI ( prefix ) ; String srcURI = dtm . getNodeValue ( src ) ; if ( ! srcURI . equalsIgnoreCase ( desturi ) ) { this . startPrefixMapping ( prefix , srcURI , false ) ; } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } public String getURI ( String prefix ) { return m_nsSupport . getURI ( prefix ) ; } public String getPrefix ( String namespace ) { Enumeration enum = m_nsSupport . getPrefixes ( ) ; while ( enum . hasMoreElements ( ) ) { String prefix = ( String ) enum . nextElement ( ) ; if ( m_nsSupport . getURI ( prefix ) . equals ( namespace ) ) return prefix ; } return null ; } public NamespaceSupport getNamespaceSupport ( ) { return m_nsSupport ; } public final ContentHandler getContentHandler ( ) { return m_contentHandler ; } public void setContentHandler ( ContentHandler ch ) { m_contentHandler = ch ; m_isTransformClient = ( m_contentHandler instanceof TransformerClient ) ; if ( m_contentHandler instanceof LexicalHandler ) m_lexicalHandler = ( LexicalHandler ) m_contentHandler ; else m_lexicalHandler = null ; reInitEvents ( ) ; } public int getUniqueNSValue ( ) { return m_uniqueNSValue ++ ; } public String getNewUniqueNSPrefix ( ) { return S_NAMESPACEPREFIX + String . valueOf ( getUniqueNSValue ( ) ) ; } public MutableAttrListImpl getPendingAttributes ( ) { return m_attributes ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws TransformerException { if ( m_elemIsPending ) { addNSDeclsToAttrs ( ) ; if ( null == uri ) uri = "" ; try { if ( ! rawName . equals ( "xmlns" ) ) ensurePrefixIsDeclared ( uri , rawName ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } if ( DEBUG ) System . out . println ( "ResultTreeHandler#addAttribute Adding attr: " + localName + ", " + uri ) ; if ( ! isDefinedNSDecl ( rawName , value ) ) m_attributes . addAttribute ( uri , localName , rawName , type , value ) ; } } public boolean isDefinedNSDecl ( String rawName , String value ) { if ( rawName . equals ( "xmlns" ) || rawName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; String definedURI = m_nsSupport . getURI ( prefix ) ; if ( null != definedURI ) { if ( definedURI . equals ( value ) ) { return true ; } else return false ; } else return false ; } else return false ; } public boolean isDefinedNSDecl ( int attr ) { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( attr ) ; if ( DTM . NAMESPACE_NODE == dtm . getNodeType ( attr ) ) { String prefix = dtm . getNodeNameX ( attr ) ; String uri = getURI ( prefix ) ; if ( ( null != uri ) && uri . equals ( dtm . getStringValue ( attr ) ) ) return true ; } return false ; } public boolean isDefinedNSDecl ( int attr , DTM dtm ) { if ( DTM . NAMESPACE_NODE == dtm . getNodeType ( attr ) ) { String prefix = dtm . getNodeNameX ( attr ) ; String uri = getURI ( prefix ) ; if ( ( null != uri ) && uri . equals ( dtm . getStringValue ( attr ) ) ) return true ; } return false ; } public void addAttribute ( int attr ) throws TransformerException { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( attr ) ; if ( isDefinedNSDecl ( attr , dtm ) ) return ; String ns = dtm . getNamespaceURI ( attr ) ; if ( ns == null ) ns = "" ; addAttribute ( ns , dtm . getLocalName ( attr ) , dtm . getNodeName ( attr ) , "CDATA" , dtm . getNodeValue ( attr ) ) ; } public void addAttributes ( int src ) throws TransformerException { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( src ) ; for ( int node = dtm . getFirstAttribute ( src ) ; DTM . NULL != node ; node = dtm . getNextAttribute ( node ) ) { addAttribute ( node ) ; } } public final boolean isElementPending ( ) { return m_elemIsPending ; } public ElemTemplateElement getCurrentElement ( ) { if ( m_elemIsPending ) return m_snapshot . m_currentElement ; else return m_transformer . getCurrentElement ( ) ; } public org . w3c . dom . Node getCurrentNode ( ) { if ( m_snapshot . m_currentNode != null ) { return m_snapshot . m_currentNode ; } else { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_transformer . getCurrentNode ( ) ) ; return dtm . getNode ( m_transformer . getCurrentNode ( ) ) ; } } public ElemTemplate getCurrentTemplate ( ) { if ( m_elemIsPending ) return m_snapshot . m_currentTemplate ; else return m_transformer . getCurrentTemplate ( ) ; } public ElemTemplate getMatchedTemplate ( ) { if ( m_elemIsPending ) return m_snapshot . m_matchedTemplate ; else return m_transformer . getMatchedTemplate ( ) ; } public org . w3c . dom . Node getMatchedNode ( ) { if ( m_elemIsPending ) { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_snapshot . m_matchedNode ) ; return dtm . getNode ( m_snapshot . m_matchedNode ) ; } else { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_transformer . getMatchedNode ( ) ) ; return dtm . getNode ( m_transformer . getMatchedNode ( ) ) ; } } public org . w3c . dom . traversal . NodeIterator getContextNodeList ( ) { if ( m_elemIsPending ) { return new org . apache . xml . dtm . ref . DTMNodeIterator ( m_snapshot . m_contextNodeList ) ; } else return new org . apache . xml . dtm . ref . DTMNodeIterator ( m_transformer . getContextNodeList ( ) ) ; } public Transformer getTransformer ( ) { return m_transformer ; } public void warning ( SAXParseException exception ) throws SAXException { if ( m_contentHandler instanceof ErrorHandler ) ( ( ErrorHandler ) m_contentHandler ) . warning ( exception ) ; } public void error ( SAXParseException exception ) throws SAXException { if ( m_contentHandler instanceof ErrorHandler ) ( ( ErrorHandler ) m_contentHandler ) . error ( exception ) ; } public void fatalError ( SAXParseException exception ) throws SAXException { m_elemIsPending = false ; m_docEnded = true ; m_docPending = false ; if ( m_contentHandler instanceof ErrorHandler ) ( ( ErrorHandler ) m_contentHandler ) . fatalError ( exception ) ; } boolean m_isTransformClient = false ; NamespaceSupport m_nsSupport = new NamespaceSupport2 ( ) ; private TransformerImpl m_transformer ; private ContentHandler m_contentHandler ; private LexicalHandler m_lexicalHandler ; private StylesheetRoot m_stylesheetRoot = null ; private int m_uniqueNSValue = 0 ; private static final String S_NAMESPACEPREFIX = "ns" ; public ClonerToResultTree m_cloner ; private TraceManager m_tracer ; private QueuedStateSnapshot m_snapshot = new QueuedStateSnapshot ( ) ; class QueuedStateSnapshot { ElemTemplateElement m_currentElement ; org . w3c . dom . Node m_currentNode ; ElemTemplate m_currentTemplate ; ElemTemplate m_matchedTemplate ; int m_matchedNode ; DTMIterator m_contextNodeList ; } } 	1	['64', '2', '0', '38', '159', '878', '20', '22', '58', '0.820512821', '1706', '0.692307692', '5', '0.088235294', '0.126116071', '1', '1', '25.453125', '6', '1.3906', '2']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class NodeCounterGenerator extends ClassGenerator { private Instruction _aloadTranslet ; public NodeCounterGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; } public void setTransletIndex ( int index ) { _aloadTranslet = new ALOAD ( index ) ; } public Instruction loadTranslet ( ) { return _aloadTranslet ; } public boolean isExternal ( ) { return true ; } } 	0	['4', '4', '0', '5', '6', '4', '1', '4', '4', '0.666666667', '26', '1', '0', '0.964285714', '0.45', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xalan . xsltc . DOM ; final class Step extends RelativeLocationPath { private int _axis ; private Vector _predicates ; private boolean _hadPredicates = false ; private int _nodeType ; public Step ( int axis , int nodeType , Vector predicates ) { _axis = axis ; _nodeType = nodeType ; _predicates = predicates ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate exp = ( Predicate ) _predicates . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public int getAxis ( ) { return _axis ; } public void setAxis ( int axis ) { _axis = axis ; } public int getNodeType ( ) { return _nodeType ; } public Vector getPredicates ( ) { return _predicates ; } public void addPredicates ( Vector predicates ) { if ( _predicates == null ) _predicates = predicates ; else _predicates . addAll ( predicates ) ; } private boolean hasParentPattern ( ) { final SyntaxTreeNode parent = getParent ( ) ; return ( parent instanceof ParentPattern || parent instanceof ParentLocationPath || parent instanceof UnionPathExpr || parent instanceof FilterParentPath ) ; } private boolean hasPredicates ( ) { return _predicates != null && _predicates . size ( ) > 0 ; } private boolean isPredicate ( ) { SyntaxTreeNode parent = this ; while ( parent != null ) { parent = parent . getParent ( ) ; if ( parent instanceof Predicate ) return true ; } return false ; } public boolean isAbbreviatedDot ( ) { return _nodeType == NodeTest . ANODE && _axis == Axis . SELF ; } public boolean isAbbreviatedDDot ( ) { return _nodeType == NodeTest . ANODE && _axis == Axis . PARENT ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _hadPredicates = hasPredicates ( ) ; if ( isAbbreviatedDot ( ) ) { _type = ( hasParentPattern ( ) ) ? Type . NodeSet : Type . Node ; } else { _type = Type . NodeSet ; } if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression pred = ( Expression ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } } return _type ; } private boolean reverseNodeSet ( ) { if ( ( _axis == Axis . ANCESTOR ) || ( _axis == Axis . ANCESTORORSELF ) || ( _axis == Axis . PRECEDING ) || ( _axis == Axis . PRECEDINGSIBLING ) ) { SyntaxTreeNode parent = this ; do { parent = parent . getParent ( ) ; if ( parent instanceof ApplyImports ) return true ; if ( parent instanceof ApplyTemplates ) return true ; if ( parent instanceof ForEach ) return true ; if ( parent instanceof FilterParentPath ) return true ; if ( parent instanceof FilterExpr ) return true ; if ( parent instanceof WithParam ) return true ; if ( parent instanceof ValueOf ) return true ; } while ( parent != null && parent instanceof Instruction == false ) ; } return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( hasPredicates ( ) ) { translatePredicates ( classGen , methodGen ) ; if ( _predicates . size ( ) == 0 ) { orderIterator ( classGen , methodGen ) ; } } else { if ( ( _axis == Axis . ATTRIBUTE ) && ( _nodeType != NodeTest . ATTRIBUTE ) && ( ! hasParentPattern ( ) ) ) { int iter = cpg . addInterfaceMethodref ( DOM_INTF , "getTypedAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . ATTRIBUTE ) ) ; il . append ( new PUSH ( cpg , _nodeType ) ) ; il . append ( new INVOKEINTERFACE ( iter , 3 ) ) ; return ; } if ( isAbbreviatedDot ( ) ) { if ( _type == Type . Node ) { il . append ( methodGen . loadContextNode ( ) ) ; } else { int init = cpg . addMethodref ( SINGLETON_ITERATOR , "<init>" , "(" + NODE_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( SINGLETON_ITERATOR ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } return ; } SyntaxTreeNode parent = getParent ( ) ; if ( ( parent instanceof ParentLocationPath ) && ( parent . getParent ( ) instanceof ParentLocationPath ) ) { if ( ( _nodeType == NodeTest . ELEMENT ) && ( ! _hadPredicates ) ) { _nodeType = NodeTest . ANODE ; } } switch ( _nodeType ) { case NodeTest . ATTRIBUTE : _axis = Axis . ATTRIBUTE ; case NodeTest . ANODE : int git = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _axis ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; break ; default : final XSLTC xsltc = getParser ( ) . getXSLTC ( ) ; final Vector ni = xsltc . getNamesIndex ( ) ; String name = null ; int star = 0 ; if ( _nodeType >= DOM . NTYPES ) { name = ( String ) ni . elementAt ( _nodeType - DOM . NTYPES ) ; star = name . lastIndexOf ( '*' ) ; } if ( star > 1 ) { final String namespace ; if ( _axis == Axis . ATTRIBUTE ) namespace = name . substring ( 0 , star - 2 ) ; else namespace = name . substring ( 0 , star - 1 ) ; final int nsType = xsltc . registerNamespace ( namespace ) ; final int ns = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _axis ) ) ; il . append ( new PUSH ( cpg , nsType ) ) ; il . append ( new INVOKEINTERFACE ( ns , 3 ) ) ; break ; } case NodeTest . ELEMENT : final int ty = cpg . addInterfaceMethodref ( DOM_INTF , "getTypedAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _axis ) ) ; il . append ( new PUSH ( cpg , _nodeType ) ) ; il . append ( new INVOKEINTERFACE ( ty , 3 ) ) ; break ; } if ( ! _hadPredicates ) { orderIterator ( classGen , methodGen ) ; } } } public void translatePredicates ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int idx = 0 ; if ( _predicates . size ( ) == 0 ) { translate ( classGen , methodGen ) ; } else { final Predicate predicate = ( Predicate ) _predicates . lastElement ( ) ; _predicates . remove ( predicate ) ; if ( predicate . isNodeValueTest ( ) ) { Step step = predicate . getStep ( ) ; il . append ( methodGen . loadDOM ( ) ) ; if ( step . isAbbreviatedDot ( ) ) { translate ( classGen , methodGen ) ; il . append ( new ICONST ( DOM . RETURN_CURRENT ) ) ; } else { ParentLocationPath path = new ParentLocationPath ( this , step ) ; try { path . typeCheck ( getParser ( ) . getSymbolTable ( ) ) ; } catch ( TypeCheckError e ) { } path . translate ( classGen , methodGen ) ; il . append ( new ICONST ( DOM . RETURN_PARENT ) ) ; } predicate . translate ( classGen , methodGen ) ; idx = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE_ITERATOR , GET_NODE_VALUE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( idx , 5 ) ) ; } else if ( predicate . isNthDescendant ( ) ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ICONST ( NodeTest . ELEMENT ) ) ; predicate . translate ( classGen , methodGen ) ; il . append ( new ICONST ( 0 ) ) ; idx = cpg . addInterfaceMethodref ( DOM_INTF , "getNthDescendant" , "(IIZ)" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( idx , 4 ) ) ; } else if ( predicate . isNthPositionFilter ( ) ) { idx = cpg . addMethodref ( NTH_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + "I)V" ) ; il . append ( new NEW ( cpg . addClass ( NTH_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; translatePredicates ( classGen , methodGen ) ; predicate . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( idx ) ) ; } else { idx = cpg . addMethodref ( CURRENT_NODE_LIST_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + CURRENT_NODE_LIST_FILTER_SIG + NODE_SIG + TRANSLET_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( CURRENT_NODE_LIST_ITERATOR ) ) ) ; il . append ( DUP ) ; translatePredicates ( classGen , methodGen ) ; predicate . translateFilter ( classGen , methodGen ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { final String className = classGen . getClassName ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new INVOKESPECIAL ( idx ) ) ; } } } public void orderIterator ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( ! reverseNodeSet ( ) ) return ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( REVERSE_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( REVERSE_ITERATOR ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } public String toString ( ) { final StringBuffer buffer = new StringBuffer ( "step(\"" ) ; buffer . append ( Axis . names [ _axis ] ) . append ( "\", " ) . append ( _nodeType ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; buffer . append ( ", " ) . append ( pred . toString ( ) ) ; } } return buffer . append ( ')' ) . toString ( ) ; } } 	1	['18', '4', '0', '41', '70', '21', '6', '38', '14', '0.588235294', '900', '1', '0', '0.811111111', '0.238095238', '2', '9', '48.77777778', '20', '4.0556', '1']
package org . apache . xpath . functions ; public class WrongNumberArgsException extends Exception { public WrongNumberArgsException ( String argsExpected ) { super ( argsExpected ) ; } } 	0	['1', '3', '0', '12', '2', '0', '12', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xalan . transformer ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import java . util . Properties ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . stream . StreamResult ; import org . apache . xalan . processor . TransformerFactoryImpl ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . serialize . Method ; import org . apache . xalan . serialize . Serializer ; import org . apache . xalan . serialize . SerializerFactory ; import org . apache . xalan . templates . AVT ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemAttributeSet ; import org . apache . xalan . templates . ElemForEach ; import org . apache . xalan . templates . ElemSort ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xalan . templates . ElemVariable ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetComposed ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . templates . WhiteSpaceInfo ; import org . apache . xalan . templates . XUnresolvedVariable ; import org . apache . xalan . trace . TraceManager ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . DOMBuilder ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . ObjectPool ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xpath . Arg ; import org . apache . xpath . DOMHelper ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXParseException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xalan . extensions . ExtensionsTable ; public class TransformerImpl extends Transformer implements Runnable , DTMWSFilter , ExtensionsProvider { private Boolean m_reentryGuard = new Boolean ( true ) ; private java . io . FileOutputStream m_outputStream = null ; private boolean m_parserEventsOnMain = true ; private Thread m_transformThread ; private String m_urlOfSource = null ; private Result m_outputTarget = null ; private OutputProperties m_outputFormat ; private Serializer m_serializer ; ContentHandler m_inputContentHandler ; private ContentHandler m_outputContentHandler = null ; DocumentBuilder m_docBuilder = null ; private ObjectPool m_textResultHandlerObjectPool = new ObjectPool ( "org.apache.xalan.transformer.ResultTreeHandler" ) ; private ObjectPool m_stringWriterObjectPool = new ObjectPool ( "java.io.StringWriter" ) ; private OutputProperties m_textformat = new OutputProperties ( Method . Text ) ; ElemTemplateElement [ ] m_currentTemplateElements = new ElemTemplateElement [ XPathContext . RECURSIONLIMIT ] ; int m_currentTemplateElementsTop = 0 ; Stack m_currentMatchTemplates = new Stack ( ) ; NodeVector m_currentMatchedNodes = new NodeVector ( ) ; private StylesheetRoot m_stylesheetRoot = null ; private boolean m_quietConflictWarnings = true ; private XPathContext m_xcontext ; private StackGuard m_stackGuard ; private ResultTreeHandler m_resultTreeHandler ; private KeyManager m_keyManager = new KeyManager ( ) ; Stack m_attrSetStack = null ; CountersTable m_countersTable = null ; BoolStack m_currentTemplateRuleIsNull = new BoolStack ( ) ; private MsgMgr m_msgMgr ; public static boolean S_DEBUG = false ; private ErrorListener m_errorHandler = new org . apache . xml . utils . DefaultErrorHandler ( ) ; private TraceManager m_traceManager = new TraceManager ( this ) ; private Exception m_exceptionThrown = null ; private Source m_xmlSource ; private int m_doc ; private boolean m_isTransformDone = false ; private boolean m_hasBeenReset = false ; private boolean m_shouldReset = true ; public void setShouldReset ( boolean shouldReset ) { m_shouldReset = shouldReset ; } private Stack m_modes = new Stack ( ) ; public TransformerImpl ( StylesheetRoot stylesheet ) { setStylesheet ( stylesheet ) ; setXPathContext ( new XPathContext ( this ) ) ; getXPathContext ( ) . setNamespaceContext ( stylesheet ) ; m_stackGuard = new StackGuard ( this ) ; } private ExtensionsTable m_extensionsTable = null ; public ExtensionsTable getExtensionsTable ( ) { return m_extensionsTable ; } void setExtensionsTable ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { try { if ( sroot . getExtensions ( ) != null ) m_extensionsTable = new ExtensionsTable ( sroot ) ; } catch ( javax . xml . transform . TransformerException te ) { te . printStackTrace ( ) ; } } public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . functionAvailable ( ns , funcName ) ; } public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . elementAvailable ( ns , elemName ) ; } public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . extFunction ( ns , funcName , argVec , methodKey , getXPathContext ( ) . getExpressionContext ( ) ) ; } public void reset ( ) { if ( ! m_hasBeenReset && m_shouldReset ) { m_hasBeenReset = true ; if ( this . m_outputStream != null ) { try { m_outputStream . close ( ) ; } catch ( java . io . IOException ioe ) { } } m_outputStream = null ; m_countersTable = null ; m_xcontext . reset ( ) ; m_xcontext . getVarStack ( ) . reset ( ) ; resetUserParameters ( ) ; int n = m_currentTemplateElements . length ; for ( int i = 0 ; i < n ; i ++ ) { m_currentTemplateElements [ i ] = null ; } m_currentTemplateElementsTop = 0 ; m_currentMatchTemplates . removeAllElements ( ) ; m_currentMatchedNodes . removeAllElements ( ) ; m_resultTreeHandler = null ; m_outputTarget = null ; m_keyManager = new KeyManager ( ) ; m_attrSetStack = null ; m_countersTable = null ; m_currentTemplateRuleIsNull = new BoolStack ( ) ; m_xmlSource = null ; m_doc = DTM . NULL ; m_isTransformDone = false ; m_transformThread = null ; m_xcontext . getSourceTreeManager ( ) . reset ( ) ; } } public boolean getProperty ( String property ) { return false ; } public void setProperty ( String property , Object value ) { } public boolean isParserEventsOnMain ( ) { return m_parserEventsOnMain ; } public Thread getTransformThread ( ) { return m_transformThread ; } public void setTransformThread ( Thread t ) { m_transformThread = t ; } private boolean m_hasTransformThreadErrorCatcher = false ; public boolean hasTransformThreadErrorCatcher ( ) { return m_hasTransformThreadErrorCatcher ; } public void transform ( Source source ) throws TransformerException { transform ( source , true ) ; } public void transform ( Source source , boolean shouldRelease ) throws TransformerException { try { String base = source . getSystemId ( ) ; if ( null == base ) { base = m_stylesheetRoot . getBaseIdentifier ( ) ; } if ( null == base ) { String currentDir = "" ; try { currentDir = System . getProperty ( "user.dir" ) ; } catch ( SecurityException se ) { } if ( currentDir . startsWith ( java . io . File . separator ) ) base = "file://" + currentDir ; else base = "file:///" + currentDir ; base = base + java . io . File . separatorChar + source . getClass ( ) . getName ( ) ; } setBaseURLOfSource ( base ) ; DTMManager mgr = m_xcontext . getDTMManager ( ) ; DTM dtm = mgr . getDTM ( source , false , this , true , true ) ; dtm . setDocumentBaseURI ( base ) ; boolean hardDelete = true ; try { this . transformNode ( dtm . getDocument ( ) ) ; } finally { if ( shouldRelease ) mgr . release ( dtm , hardDelete ) ; } Exception e = getExceptionThrown ( ) ; if ( null != e ) { if ( e instanceof javax . xml . transform . TransformerException ) { throw ( javax . xml . transform . TransformerException ) e ; } else if ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { fatalError ( ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ) ; } else { throw new javax . xml . transform . TransformerException ( e ) ; } } else if ( null != m_resultTreeHandler ) { m_resultTreeHandler . endDocument ( ) ; } } catch ( org . apache . xml . utils . WrappedRuntimeException wre ) { Throwable throwable = wre . getException ( ) ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } fatalError ( throwable ) ; } catch ( org . xml . sax . SAXParseException spe ) { fatalError ( spe ) ; } catch ( org . xml . sax . SAXException se ) { m_errorHandler . fatalError ( new TransformerException ( se ) ) ; } finally { m_hasTransformThreadErrorCatcher = false ; reset ( ) ; } } private void fatalError ( Throwable throwable ) throws TransformerException { if ( throwable instanceof org . xml . sax . SAXParseException ) m_errorHandler . fatalError ( new TransformerException ( throwable . getMessage ( ) , new SAXSourceLocator ( ( org . xml . sax . SAXParseException ) throwable ) ) ) ; else m_errorHandler . fatalError ( new TransformerException ( throwable ) ) ; } public String getBaseURLOfSource ( ) { return m_urlOfSource ; } public void setBaseURLOfSource ( String base ) { m_urlOfSource = base ; } public Result getOutputTarget ( ) { return m_outputTarget ; } public void setOutputTarget ( Result outputTarget ) { m_outputTarget = outputTarget ; } public String getOutputProperty ( String qnameString ) throws IllegalArgumentException { String value = null ; OutputProperties props = getOutputFormat ( ) ; value = props . getProperty ( qnameString ) ; if ( null == value ) { if ( ! props . isLegalPropertyKey ( qnameString ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { qnameString } ) ) ; } return value ; } public String getOutputPropertyNoDefault ( String qnameString ) throws IllegalArgumentException { String value = null ; OutputProperties props = getOutputFormat ( ) ; value = ( String ) props . getProperties ( ) . get ( qnameString ) ; if ( null == value ) { if ( ! props . isLegalPropertyKey ( qnameString ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { qnameString } ) ) ; } return value ; } public void setOutputProperty ( String name , String value ) throws IllegalArgumentException { synchronized ( m_reentryGuard ) { if ( null == m_outputFormat ) { m_outputFormat = ( OutputProperties ) getStylesheet ( ) . getOutputComposed ( ) . clone ( ) ; } if ( ! m_outputFormat . isLegalPropertyKey ( name ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; m_outputFormat . setProperty ( name , value ) ; } } public void setOutputProperties ( Properties oformat ) { synchronized ( m_reentryGuard ) { if ( null != oformat ) { String method = ( String ) oformat . get ( OutputKeys . METHOD ) ; if ( null != method ) m_outputFormat = new OutputProperties ( method ) ; else if ( m_outputFormat == null ) m_outputFormat = new OutputProperties ( ) ; } if ( null != oformat ) { m_outputFormat . copyFrom ( oformat ) ; } m_outputFormat . copyFrom ( m_stylesheetRoot . getOutputProperties ( ) ) ; } } public Properties getOutputProperties ( ) { return ( Properties ) getOutputFormat ( ) . getProperties ( ) . clone ( ) ; } public ContentHandler createResultContentHandler ( Result outputTarget ) throws TransformerException { return createResultContentHandler ( outputTarget , getOutputFormat ( ) ) ; } public ContentHandler createResultContentHandler ( Result outputTarget , OutputProperties format ) throws TransformerException { ContentHandler handler = null ; org . w3c . dom . Node outputNode = null ; if ( outputTarget instanceof DOMResult ) { outputNode = ( ( DOMResult ) outputTarget ) . getNode ( ) ; org . w3c . dom . Document doc ; short type ; if ( null != outputNode ) { type = outputNode . getNodeType ( ) ; doc = ( org . w3c . dom . Node . DOCUMENT_NODE == type ) ? ( org . w3c . dom . Document ) outputNode : outputNode . getOwnerDocument ( ) ; } else { doc = org . apache . xpath . DOMHelper . createDocument ( ) ; outputNode = doc ; type = outputNode . getNodeType ( ) ; ( ( DOMResult ) outputTarget ) . setNode ( outputNode ) ; } handler = ( org . w3c . dom . Node . DOCUMENT_FRAGMENT_NODE == type ) ? new DOMBuilder ( doc , ( org . w3c . dom . DocumentFragment ) outputNode ) : new DOMBuilder ( doc , outputNode ) ; } else if ( outputTarget instanceof SAXResult ) { handler = ( ( SAXResult ) outputTarget ) . getHandler ( ) ; if ( null == handler ) throw new IllegalArgumentException ( "handler can not be null for a SAXResult" ) ; } else if ( outputTarget instanceof StreamResult ) { StreamResult sresult = ( StreamResult ) outputTarget ; String method = format . getProperty ( OutputKeys . METHOD ) ; try { Serializer serializer = SerializerFactory . getSerializer ( format . getProperties ( ) ) ; if ( null != sresult . getWriter ( ) ) serializer . setWriter ( sresult . getWriter ( ) ) ; else if ( null != sresult . getOutputStream ( ) ) serializer . setOutputStream ( sresult . getOutputStream ( ) ) ; else if ( null != sresult . getSystemId ( ) ) { String fileURL = sresult . getSystemId ( ) ; if ( fileURL . startsWith ( "file:///" ) ) { if ( fileURL . substring ( 8 ) . indexOf ( ":" ) > 0 ) fileURL = fileURL . substring ( 8 ) ; else fileURL = fileURL . substring ( 7 ) ; } m_outputStream = new java . io . FileOutputStream ( fileURL ) ; serializer . setOutputStream ( m_outputStream ) ; } else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_OUTPUT_SPECIFIED , null ) ) ; handler = serializer . asContentHandler ( ) ; this . setSerializer ( serializer ) ; } catch ( UnsupportedEncodingException uee ) { throw new TransformerException ( uee ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , new Object [ ] { outputTarget . getClass ( ) . getName ( ) } ) ) ; } return handler ; } public void transform ( Source xmlSource , Result outputTarget ) throws TransformerException { transform ( xmlSource , outputTarget , true ) ; } public void transform ( Source xmlSource , Result outputTarget , boolean shouldRelease ) throws TransformerException { synchronized ( m_reentryGuard ) { ContentHandler handler = createResultContentHandler ( outputTarget ) ; m_outputTarget = outputTarget ; this . setContentHandler ( handler ) ; transform ( xmlSource , shouldRelease ) ; } } public void transformNode ( int node , Result outputTarget ) throws TransformerException { ContentHandler handler = createResultContentHandler ( outputTarget ) ; m_outputTarget = outputTarget ; this . setContentHandler ( handler ) ; transformNode ( node ) ; } public void transformNode ( int node ) throws TransformerException { setExtensionsTable ( getStylesheet ( ) ) ; synchronized ( m_outputContentHandler ) { m_hasBeenReset = false ; XPathContext xctxt = getXPathContext ( ) ; DTM dtm = xctxt . getDTM ( node ) ; try { pushGlobalVars ( node ) ; StylesheetRoot stylesheet = this . getStylesheet ( ) ; int n = stylesheet . getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { StylesheetComposed imported = stylesheet . getGlobalImport ( i ) ; int includedCount = imported . getIncludeCountComposed ( ) ; for ( int j = - 1 ; j < includedCount ; j ++ ) { Stylesheet included = imported . getIncludeComposed ( j ) ; included . runtimeInit ( this ) ; for ( ElemTemplateElement child = included . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { child . runtimeInit ( this ) ; } } } DTMIterator dtmIter = new org . apache . xpath . axes . SelfIteratorNoPredicate ( ) ; dtmIter . setRoot ( node , xctxt ) ; xctxt . pushContextNodeList ( dtmIter ) ; try { this . applyTemplateToNode ( null , null , node ) ; } finally { xctxt . popContextNodeList ( ) ; } if ( null != m_resultTreeHandler ) { m_resultTreeHandler . endDocument ( ) ; } } catch ( Exception se ) { while ( se instanceof org . apache . xml . utils . WrappedRuntimeException ) { Exception e = ( ( org . apache . xml . utils . WrappedRuntimeException ) se ) . getException ( ) ; if ( null != e ) se = e ; } if ( null != m_resultTreeHandler ) { try { if ( se instanceof org . xml . sax . SAXParseException ) m_resultTreeHandler . fatalError ( ( org . xml . sax . SAXParseException ) se ) ; else if ( se instanceof TransformerException ) { TransformerException te = ( ( TransformerException ) se ) ; SAXSourceLocator sl = new SAXSourceLocator ( te . getLocator ( ) ) ; m_resultTreeHandler . fatalError ( new org . xml . sax . SAXParseException ( te . getMessage ( ) , sl , te ) ) ; } else { m_resultTreeHandler . fatalError ( new org . xml . sax . SAXParseException ( se . getMessage ( ) , new SAXSourceLocator ( ) , se ) ) ; } } catch ( Exception e ) { } } if ( se instanceof TransformerException ) { m_errorHandler . fatalError ( ( TransformerException ) se ) ; } else if ( se instanceof org . xml . sax . SAXParseException ) { m_errorHandler . fatalError ( new TransformerException ( se . getMessage ( ) , new SAXSourceLocator ( ( org . xml . sax . SAXParseException ) se ) , se ) ) ; } else { m_errorHandler . fatalError ( new TransformerException ( se ) ) ; } } finally { this . reset ( ) ; } } } public ContentHandler getInputContentHandler ( ) { return getInputContentHandler ( false ) ; } public ContentHandler getInputContentHandler ( boolean doDocFrag ) { if ( null == m_inputContentHandler ) { m_inputContentHandler = new TransformerHandlerImpl ( this , doDocFrag , m_urlOfSource ) ; } return m_inputContentHandler ; } public DeclHandler getInputDeclHandler ( ) { if ( m_inputContentHandler instanceof DeclHandler ) return ( DeclHandler ) m_inputContentHandler ; else return null ; } public LexicalHandler getInputLexicalHandler ( ) { if ( m_inputContentHandler instanceof LexicalHandler ) return ( LexicalHandler ) m_inputContentHandler ; else return null ; } public void setOutputFormat ( OutputProperties oformat ) { m_outputFormat = oformat ; } public OutputProperties getOutputFormat ( ) { OutputProperties format = ( null == m_outputFormat ) ? getStylesheet ( ) . getOutputComposed ( ) : m_outputFormat ; return format ; } public Serializer getSerializer ( ) { return m_serializer ; } public void setSerializer ( Serializer s ) { m_serializer = s ; } public void setParameter ( String name , String namespace , Object value ) { VariableStack varstack = getXPathContext ( ) . getVarStack ( ) ; QName qname = new QName ( namespace , name ) ; XObject xobject = XObject . create ( value , getXPathContext ( ) ) ; StylesheetRoot sroot = m_stylesheetRoot ; Vector vars = sroot . getVariablesAndParamsComposed ( ) ; int i = vars . size ( ) ; while ( -- i >= 0 ) { ElemVariable variable = ( ElemVariable ) vars . elementAt ( i ) ; if ( variable . getXSLToken ( ) == Constants . ELEMNAME_PARAMVARIABLE && variable . getName ( ) . equals ( qname ) ) { varstack . setGlobalVariable ( i , xobject ) ; } } } Vector m_userParams ; public void setParameter ( String name , Object value ) { StringTokenizer tokenizer = new StringTokenizer ( name , "{}" , false ) ; try { String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == m_userParams ) m_userParams = new Vector ( ) ; if ( null == s2 ) { replaceOrPushUserParam ( new QName ( s1 ) , XObject . create ( value , getXPathContext ( ) ) ) ; setParameter ( s1 , null , value ) ; } else { replaceOrPushUserParam ( new QName ( s1 , s2 ) , XObject . create ( value , getXPathContext ( ) ) ) ; setParameter ( s2 , s1 , value ) ; } } catch ( java . util . NoSuchElementException nsee ) { } } private void replaceOrPushUserParam ( QName qname , XObject xval ) { int n = m_userParams . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Arg arg = ( Arg ) m_userParams . elementAt ( i ) ; if ( arg . getQName ( ) . equals ( qname ) ) { m_userParams . setElementAt ( new Arg ( qname , xval , true ) , i ) ; return ; } } m_userParams . addElement ( new Arg ( qname , xval , true ) ) ; } public Object getParameter ( String name ) { try { QName qname = QName . getQNameFromString ( name ) ; if ( null == m_userParams ) return null ; int n = m_userParams . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Arg arg = ( Arg ) m_userParams . elementAt ( i ) ; if ( arg . getQName ( ) . equals ( qname ) ) { return arg . getVal ( ) . object ( ) ; } } return null ; } catch ( java . util . NoSuchElementException nsee ) { return null ; } } private void resetUserParameters ( ) { try { if ( null == m_userParams ) return ; int n = m_userParams . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Arg arg = ( Arg ) m_userParams . elementAt ( i ) ; QName name = arg . getQName ( ) ; String s1 = name . getNamespace ( ) ; String s2 = name . getLocalPart ( ) ; setParameter ( s2 , s1 , arg . getVal ( ) . object ( ) ) ; } } catch ( java . util . NoSuchElementException nsee ) { } } public void setParameters ( Properties params ) { clearParameters ( ) ; Enumeration names = params . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = params . getProperty ( ( String ) names . nextElement ( ) ) ; StringTokenizer tokenizer = new StringTokenizer ( name , "{}" , false ) ; try { String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == s2 ) setParameter ( s1 , null , params . getProperty ( name ) ) ; else setParameter ( s2 , s1 , params . getProperty ( name ) ) ; } catch ( java . util . NoSuchElementException nsee ) { } } } public void clearParameters ( ) { synchronized ( m_reentryGuard ) { VariableStack varstack = new VariableStack ( ) ; m_xcontext . setVarStack ( varstack ) ; m_userParams = null ; } } protected void pushGlobalVars ( int contextNode ) throws TransformerException { XPathContext xctxt = m_xcontext ; VariableStack vs = xctxt . getVarStack ( ) ; StylesheetRoot sr = getStylesheet ( ) ; Vector vars = sr . getVariablesAndParamsComposed ( ) ; int i = vars . size ( ) ; vs . link ( i ) ; while ( -- i >= 0 ) { ElemVariable v = ( ElemVariable ) vars . elementAt ( i ) ; XObject xobj = new XUnresolvedVariable ( v , contextNode , this , vs . getStackFrame ( ) , 0 , true ) ; if ( null == vs . elementAt ( i ) ) vs . setGlobalVariable ( i , xobj ) ; } } public void setURIResolver ( URIResolver resolver ) { synchronized ( m_reentryGuard ) { m_xcontext . getSourceTreeManager ( ) . setURIResolver ( resolver ) ; } } public URIResolver getURIResolver ( ) { return m_xcontext . getSourceTreeManager ( ) . getURIResolver ( ) ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NULL_CONTENT_HANDLER , null ) ) ; } else { m_outputContentHandler = handler ; if ( null == m_resultTreeHandler ) m_resultTreeHandler = new ResultTreeHandler ( this , handler ) ; else m_resultTreeHandler . setContentHandler ( handler ) ; } } public ContentHandler getContentHandler ( ) { return m_outputContentHandler ; } public int transformToRTF ( ElemTemplateElement templateParent ) throws TransformerException { DTM dtmFrag = m_xcontext . getRTFDTM ( ) ; return transformToRTF ( templateParent , dtmFrag ) ; } public int transformToGlobalRTF ( ElemTemplateElement templateParent ) throws TransformerException { DTM dtmFrag = m_xcontext . getGlobalRTFDTM ( ) ; return transformToRTF ( templateParent , dtmFrag ) ; } private int transformToRTF ( ElemTemplateElement templateParent , DTM dtmFrag ) throws TransformerException { XPathContext xctxt = m_xcontext ; ContentHandler rtfHandler = dtmFrag . getContentHandler ( ) ; int resultFragment ; ResultTreeHandler savedRTreeHandler = this . m_resultTreeHandler ; m_resultTreeHandler = new ResultTreeHandler ( this , rtfHandler ) ; ResultTreeHandler rth = m_resultTreeHandler ; try { rth . startDocument ( ) ; rth . flushPending ( ) ; try { executeChildTemplates ( templateParent , true ) ; rth . flushPending ( ) ; resultFragment = dtmFrag . getDocument ( ) ; } finally { rth . endDocument ( ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { this . m_resultTreeHandler = savedRTreeHandler ; } return resultFragment ; } public ObjectPool getStringWriterPool ( ) { return m_stringWriterObjectPool ; } public String transformToString ( ElemTemplateElement elem ) throws TransformerException { ElemTemplateElement firstChild = elem . getFirstChildElem ( ) ; if ( null == firstChild ) return "" ; if ( elem . hasTextLitOnly ( ) && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { return ( ( ElemTextLiteral ) firstChild ) . getNodeValue ( ) ; } ResultTreeHandler savedRTreeHandler = this . m_resultTreeHandler ; StringWriter sw = ( StringWriter ) m_stringWriterObjectPool . getInstance ( ) ; m_resultTreeHandler = ( ResultTreeHandler ) m_textResultHandlerObjectPool . getInstance ( ) ; Serializer serializer = m_resultTreeHandler . getSerializer ( ) ; try { if ( null == serializer ) { serializer = SerializerFactory . getSerializer ( m_textformat . getProperties ( ) ) ; m_resultTreeHandler . setSerializer ( serializer ) ; serializer . setWriter ( sw ) ; ContentHandler shandler = serializer . asContentHandler ( ) ; m_resultTreeHandler . init ( this , shandler ) ; } else { } } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } String result ; try { this . m_resultTreeHandler . startDocument ( ) ; executeChildTemplates ( elem , true ) ; this . m_resultTreeHandler . endDocument ( ) ; result = sw . toString ( ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { sw . getBuffer ( ) . setLength ( 0 ) ; try { sw . close ( ) ; } catch ( Exception ioe ) { } m_stringWriterObjectPool . freeInstance ( sw ) ; m_textResultHandlerObjectPool . freeInstance ( m_resultTreeHandler ) ; m_resultTreeHandler . reset ( ) ; m_resultTreeHandler = savedRTreeHandler ; } return result ; } public boolean applyTemplateToNode ( ElemTemplateElement xslInstruction , ElemTemplate template , int child ) throws TransformerException { DTM dtm = m_xcontext . getDTM ( child ) ; short nodeType = dtm . getNodeType ( child ) ; boolean isDefaultTextRule = false ; if ( null == template ) { int maxImportLevel , endImportLevel = 0 ; boolean isApplyImports = ( ( xslInstruction == null ) ? false : xslInstruction . getXSLToken ( ) == Constants . ELEMNAME_APPLY_IMPORTS ) ; if ( isApplyImports ) { maxImportLevel = xslInstruction . getStylesheetComposed ( ) . getImportCountComposed ( ) - 1 ; endImportLevel = xslInstruction . getStylesheetComposed ( ) . getEndImportCountComposed ( ) ; } else { maxImportLevel = - 1 ; } if ( isApplyImports && ( maxImportLevel == - 1 ) ) { template = null ; } else { XPathContext xctxt = m_xcontext ; try { xctxt . pushNamespaceContext ( xslInstruction ) ; QName mode = this . getMode ( ) ; if ( isApplyImports ) template = m_stylesheetRoot . getTemplateComposed ( xctxt , child , mode , maxImportLevel , endImportLevel , m_quietConflictWarnings , dtm ) ; else template = m_stylesheetRoot . getTemplateComposed ( xctxt , child , mode , m_quietConflictWarnings , dtm ) ; } finally { xctxt . popNamespaceContext ( ) ; } } if ( null == template ) { switch ( nodeType ) { case DTM . DOCUMENT_FRAGMENT_NODE : case DTM . ELEMENT_NODE : template = m_stylesheetRoot . getDefaultRule ( ) ; break ; case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : case DTM . ATTRIBUTE_NODE : template = m_stylesheetRoot . getDefaultTextRule ( ) ; isDefaultTextRule = true ; break ; case DTM . DOCUMENT_NODE : template = m_stylesheetRoot . getDefaultRootRule ( ) ; break ; default : return false ; } } } try { pushElemTemplateElement ( template ) ; m_xcontext . pushCurrentNode ( child ) ; pushPairCurrentMatched ( template , child ) ; DTMIterator cnl = new org . apache . xpath . NodeSetDTM ( child , m_xcontext . getDTMManager ( ) ) ; m_xcontext . pushContextNodeList ( cnl ) ; if ( isDefaultTextRule ) { switch ( nodeType ) { case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : ClonerToResultTree . cloneToResultTree ( child , nodeType , dtm , getResultTreeHandler ( ) , false ) ; break ; case DTM . ATTRIBUTE_NODE : dtm . dispatchCharactersEvents ( child , getResultTreeHandler ( ) , false ) ; break ; } } else { if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEvent ( template ) ; m_xcontext . setSAXLocator ( template ) ; m_xcontext . getVarStack ( ) . link ( template . m_frameSize ) ; executeChildTemplates ( template , true ) ; if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEndEvent ( template ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { m_xcontext . getVarStack ( ) . unlink ( ) ; m_xcontext . popCurrentNode ( ) ; m_xcontext . popContextNodeList ( ) ; popCurrentMatched ( ) ; popElemTemplateElement ( ) ; } return true ; } public void executeChildTemplates ( ElemTemplateElement elem , org . w3c . dom . Node context , QName mode , ContentHandler handler ) throws TransformerException { XPathContext xctxt = m_xcontext ; try { if ( null != mode ) pushMode ( mode ) ; xctxt . pushCurrentNode ( xctxt . getDTMHandleFromNode ( context ) ) ; executeChildTemplates ( elem , handler ) ; } finally { xctxt . popCurrentNode ( ) ; if ( null != mode ) popMode ( ) ; } } public void executeChildTemplates ( ElemTemplateElement elem , ContentHandler handler ) throws TransformerException { ResultTreeHandler rth = this . getResultTreeHandler ( ) ; ContentHandler savedRTHHandler = rth . getContentHandler ( ) ; ContentHandler savedHandler = this . getContentHandler ( ) ; try { getResultTreeHandler ( ) . flushPending ( ) ; this . setContentHandler ( handler ) ; executeChildTemplates ( elem , true ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { this . setContentHandler ( savedHandler ) ; rth . setContentHandler ( savedRTHHandler ) ; } } public void executeChildTemplates ( ElemTemplateElement elem , boolean shouldAddAttrs ) throws TransformerException { ElemTemplateElement t = elem . getFirstChildElem ( ) ; if ( null == t ) return ; if ( elem . hasTextLitOnly ( ) && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { char [ ] chars = ( ( ElemTextLiteral ) t ) . getChars ( ) ; try { this . pushElemTemplateElement ( t ) ; m_resultTreeHandler . characters ( chars , 0 , chars . length ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } finally { this . popElemTemplateElement ( ) ; } return ; } XPathContext xctxt = m_xcontext ; xctxt . pushSAXLocatorNull ( ) ; int currentTemplateElementsTop = m_currentTemplateElementsTop ; m_currentTemplateElementsTop ++ ; try { for ( ; t != null ; t = t . getNextSiblingElem ( ) ) { if ( ! shouldAddAttrs && t . getXSLToken ( ) == Constants . ELEMNAME_ATTRIBUTE ) continue ; xctxt . setSAXLocator ( t ) ; m_currentTemplateElements [ currentTemplateElementsTop ] = t ; t . execute ( this ) ; } } catch ( RuntimeException re ) { TransformerException te = new TransformerException ( re ) ; te . setLocator ( t ) ; throw te ; } finally { m_currentTemplateElementsTop -- ; xctxt . popSAXLocator ( ) ; } } public Vector processSortKeys ( ElemForEach foreach , int sourceNodeContext ) throws TransformerException { Vector keys = null ; XPathContext xctxt = m_xcontext ; int nElems = foreach . getSortElemCount ( ) ; if ( nElems > 0 ) keys = new Vector ( ) ; for ( int i = 0 ; i < nElems ; i ++ ) { ElemSort sort = foreach . getSortElem ( i ) ; if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEvent ( sort ) ; String langString = ( null != sort . getLang ( ) ) ? sort . getLang ( ) . evaluate ( xctxt , sourceNodeContext , foreach ) : null ; String dataTypeString = sort . getDataType ( ) . evaluate ( xctxt , sourceNodeContext , foreach ) ; if ( dataTypeString . indexOf ( ":" ) >= 0 ) System . out . println ( "TODO: Need to write the hooks for QNAME sort data type" ) ; else if ( ! ( dataTypeString . equalsIgnoreCase ( Constants . ATTRVAL_DATATYPE_TEXT ) ) && ! ( dataTypeString . equalsIgnoreCase ( Constants . ATTRVAL_DATATYPE_NUMBER ) ) ) foreach . error ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_DATATYPE , dataTypeString } ) ; boolean treatAsNumbers = ( ( null != dataTypeString ) && dataTypeString . equals ( Constants . ATTRVAL_DATATYPE_NUMBER ) ) ? true : false ; String orderString = sort . getOrder ( ) . evaluate ( xctxt , sourceNodeContext , foreach ) ; if ( ! ( orderString . equalsIgnoreCase ( Constants . ATTRVAL_ORDER_ASCENDING ) ) && ! ( orderString . equalsIgnoreCase ( Constants . ATTRVAL_ORDER_DESCENDING ) ) ) foreach . error ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_ORDER , orderString } ) ; boolean descending = ( ( null != orderString ) && orderString . equals ( Constants . ATTRVAL_ORDER_DESCENDING ) ) ? true : false ; AVT caseOrder = sort . getCaseOrder ( ) ; boolean caseOrderUpper ; if ( null != caseOrder ) { String caseOrderString = caseOrder . evaluate ( xctxt , sourceNodeContext , foreach ) ; if ( ! ( caseOrderString . equalsIgnoreCase ( Constants . ATTRVAL_CASEORDER_UPPER ) ) && ! ( caseOrderString . equalsIgnoreCase ( Constants . ATTRVAL_CASEORDER_LOWER ) ) ) foreach . error ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_CASEORDER , caseOrderString } ) ; caseOrderUpper = ( ( null != caseOrderString ) && caseOrderString . equals ( Constants . ATTRVAL_CASEORDER_UPPER ) ) ? true : false ; } else { caseOrderUpper = false ; } keys . addElement ( new NodeSortKey ( this , sort . getSelect ( ) , treatAsNumbers , descending , langString , caseOrderUpper , foreach ) ) ; if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEndEvent ( sort ) ; } return keys ; } public Vector getElementCallstack ( ) { Vector elems = new Vector ( ) ; int nStackSize = m_currentTemplateElementsTop ; for ( int i = 0 ; i < nStackSize ; i ++ ) { ElemTemplateElement elem = m_currentTemplateElements [ i ] ; if ( null != elem ) { elems . addElement ( elem ) ; } } return elems ; } public int getCurrentTemplateElementsCount ( ) { return m_currentTemplateElementsTop ; } public ElemTemplateElement [ ] getCurrentTemplateElements ( ) { return m_currentTemplateElements ; } public void pushElemTemplateElement ( ElemTemplateElement elem ) { m_currentTemplateElements [ m_currentTemplateElementsTop ++ ] = elem ; } public void popElemTemplateElement ( ) { m_currentTemplateElementsTop -- ; } public void setCurrentElement ( ElemTemplateElement e ) { m_currentTemplateElements [ m_currentTemplateElementsTop - 1 ] = e ; } public ElemTemplateElement getCurrentElement ( ) { return ( m_currentTemplateElementsTop > 0 ) ? m_currentTemplateElements [ m_currentTemplateElementsTop - 1 ] : null ; } public int getCurrentNode ( ) { return m_xcontext . getCurrentNode ( ) ; } public Vector getTemplateCallstack ( ) { Vector elems = new Vector ( ) ; int nStackSize = m_currentTemplateElementsTop ; for ( int i = 0 ; i < nStackSize ; i ++ ) { ElemTemplateElement elem = m_currentTemplateElements [ i ] ; if ( null != elem && ( elem . getXSLToken ( ) != Constants . ELEMNAME_TEMPLATE ) ) { elems . addElement ( elem ) ; } } return elems ; } public ElemTemplate getCurrentTemplate ( ) { ElemTemplateElement elem = getCurrentElement ( ) ; while ( ( null != elem ) && ( elem . getXSLToken ( ) != Constants . ELEMNAME_TEMPLATE ) ) { elem = elem . getParentElem ( ) ; } return ( ElemTemplate ) elem ; } public void pushPairCurrentMatched ( ElemTemplateElement template , int child ) { m_currentMatchTemplates . push ( template ) ; m_currentMatchedNodes . push ( child ) ; } public void popCurrentMatched ( ) { m_currentMatchTemplates . pop ( ) ; m_currentMatchedNodes . pop ( ) ; } public ElemTemplate getMatchedTemplate ( ) { return ( ElemTemplate ) m_currentMatchTemplates . peek ( ) ; } public int getMatchedNode ( ) { return m_currentMatchedNodes . peepTail ( ) ; } public DTMIterator getContextNodeList ( ) { try { DTMIterator cnl = m_xcontext . getContextNodeList ( ) ; return ( cnl == null ) ? null : ( DTMIterator ) cnl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { return null ; } } public Transformer getTransformer ( ) { return this ; } public void setStylesheet ( StylesheetRoot stylesheetRoot ) { m_stylesheetRoot = stylesheetRoot ; } public final StylesheetRoot getStylesheet ( ) { return m_stylesheetRoot ; } public boolean getQuietConflictWarnings ( ) { return m_quietConflictWarnings ; } public void setQuietConflictWarnings ( boolean b ) { m_quietConflictWarnings = b ; } public void setXPathContext ( XPathContext xcontext ) { m_xcontext = xcontext ; } public final XPathContext getXPathContext ( ) { return m_xcontext ; } public StackGuard getStackGuard ( ) { return m_stackGuard ; } public int getRecursionLimit ( ) { return m_stackGuard . getRecursionLimit ( ) ; } public void setRecursionLimit ( int limit ) { m_stackGuard . setRecursionLimit ( limit ) ; } public ResultTreeHandler getResultTreeHandler ( ) { return m_resultTreeHandler ; } public KeyManager getKeyManager ( ) { return m_keyManager ; } public boolean isRecursiveAttrSet ( ElemAttributeSet attrSet ) { if ( null == m_attrSetStack ) { m_attrSetStack = new Stack ( ) ; } if ( ! m_attrSetStack . empty ( ) ) { int loc = m_attrSetStack . search ( attrSet ) ; if ( loc > - 1 ) { return true ; } } return false ; } public void pushElemAttributeSet ( ElemAttributeSet attrSet ) { m_attrSetStack . push ( attrSet ) ; } public void popElemAttributeSet ( ) { m_attrSetStack . pop ( ) ; } public CountersTable getCountersTable ( ) { if ( null == m_countersTable ) m_countersTable = new CountersTable ( ) ; return m_countersTable ; } public boolean currentTemplateRuleIsNull ( ) { return ( ( ! m_currentTemplateRuleIsNull . isEmpty ( ) ) && ( m_currentTemplateRuleIsNull . peek ( ) == true ) ) ; } public void pushCurrentTemplateRuleIsNull ( boolean b ) { m_currentTemplateRuleIsNull . push ( b ) ; } public void popCurrentTemplateRuleIsNull ( ) { m_currentTemplateRuleIsNull . pop ( ) ; } public MsgMgr getMsgMgr ( ) { if ( null == m_msgMgr ) m_msgMgr = new MsgMgr ( this ) ; return m_msgMgr ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { synchronized ( m_reentryGuard ) { if ( listener == null ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NULL_ERROR_HANDLER , null ) ) ; m_errorHandler = listener ; } } public ErrorListener getErrorListener ( ) { return m_errorHandler ; } public TraceManager getTraceManager ( ) { return m_traceManager ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( "http://xml.org/trax/features/sax/input" . equals ( name ) ) return true ; else if ( "http://xml.org/trax/features/dom/input" . equals ( name ) ) return true ; throw new SAXNotRecognizedException ( name ) ; } public QName getMode ( ) { return m_modes . isEmpty ( ) ? null : ( QName ) m_modes . peek ( ) ; } public void pushMode ( QName mode ) { m_modes . push ( mode ) ; } public void popMode ( ) { m_modes . pop ( ) ; } public static class ThreadControler { public Thread run ( Runnable task , int priority ) { Thread t = new Thread ( task ) ; t . start ( ) ; return t ; } public void waitThread ( Thread worker , Runnable task ) throws InterruptedException { worker . join ( ) ; } } static ThreadControler tpool = new ThreadControler ( ) ; public static void setThreadControler ( ThreadControler tp ) { tpool = tp ; } public void runTransformThread ( int priority ) { Thread t = tpool . run ( this , priority ) ; this . setTransformThread ( t ) ; } public void runTransformThread ( ) { tpool . run ( this , - 1 ) ; } public static void runTransformThread ( Runnable runnable ) { tpool . run ( runnable , - 1 ) ; } public void waitTransformThread ( ) throws SAXException { Thread transformThread = this . getTransformThread ( ) ; if ( null != transformThread ) { try { tpool . waitThread ( transformThread , this ) ; if ( ! this . hasTransformThreadErrorCatcher ( ) ) { Exception e = this . getExceptionThrown ( ) ; if ( null != e ) { e . printStackTrace ( ) ; throw new org . xml . sax . SAXException ( e ) ; } } this . setTransformThread ( null ) ; } catch ( InterruptedException ie ) { } } } public Exception getExceptionThrown ( ) { return m_exceptionThrown ; } public void setExceptionThrown ( Exception e ) { m_exceptionThrown = e ; } public void setSourceTreeDocForThread ( int doc ) { m_doc = doc ; } public void setXMLSource ( Source source ) { m_xmlSource = source ; } public boolean isTransformDone ( ) { synchronized ( this ) { return m_isTransformDone ; } } public void setIsTransformDone ( boolean done ) { synchronized ( this ) { m_isTransformDone = done ; } } void postExceptionFromThread ( Exception e ) { ContentHandler ch = getContentHandler ( ) ; m_isTransformDone = true ; m_exceptionThrown = e ; ; synchronized ( this ) { notifyAll ( ) ; } } public void run ( ) { m_hasBeenReset = false ; try { try { m_isTransformDone = false ; transformNode ( m_doc ) ; } catch ( Exception e ) { if ( null != m_transformThread ) postExceptionFromThread ( e ) ; else throw new RuntimeException ( e . getMessage ( ) ) ; } finally { m_isTransformDone = true ; if ( m_inputContentHandler instanceof TransformerHandlerImpl ) { ( ( TransformerHandlerImpl ) m_inputContentHandler ) . clearCoRoutine ( ) ; } } } catch ( Exception e ) { if ( null != m_transformThread ) postExceptionFromThread ( e ) ; else throw new RuntimeException ( e . getMessage ( ) ) ; } } public TransformSnapshot getSnapshot ( ) { return new TransformSnapshotImpl ( this ) ; } public void executeFromSnapshot ( TransformSnapshot ts ) throws TransformerException { ElemTemplateElement template = getMatchedTemplate ( ) ; int child = getMatchedNode ( ) ; pushElemTemplateElement ( template ) ; m_xcontext . pushCurrentNode ( child ) ; this . executeChildTemplates ( template , true ) ; } public void resetToStylesheet ( TransformSnapshot ts ) { ( ( TransformSnapshotImpl ) ts ) . apply ( this ) ; } public void stopTransformation ( ) { } public short getShouldStripSpace ( int elementHandle , DTM dtm ) { try { org . apache . xalan . templates . WhiteSpaceInfo info = m_stylesheetRoot . getWhiteSpaceInfo ( m_xcontext , elementHandle , dtm ) ; if ( null == info ) { return DTMWSFilter . INHERIT ; } else { return info . getShouldStripSpace ( ) ? DTMWSFilter . STRIP : DTMWSFilter . NOTSTRIP ; } } catch ( TransformerException se ) { return DTMWSFilter . INHERIT ; } } } 	1	['123', '2', '0', '106', '355', '6589', '67', '56', '115', '0.93969555', '3260', '0.714285714', '18', '0.097014925', '0.057650273', '1', '2', '25.16260163', '5', '1.3821', '7']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; class TopLevelElement extends SyntaxTreeNode { public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . NOT_IMPLEMENTED_ERR , getClass ( ) , this ) ; getParser ( ) . reportError ( FATAL , msg ) ; } public InstructionList compile ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList result , save = methodGen . getInstructionList ( ) ; methodGen . setInstructionList ( result = new InstructionList ( ) ) ; translate ( classGen , methodGen ) ; methodGen . setInstructionList ( save ) ; return result ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "TopLevelElement" ) ; displayContents ( indent + IndentIncrement ) ; } } 	0	['5', '2', '10', '27', '17', '10', '16', '11', '4', '2', '56', '0', '0', '0.931034483', '0.44', '1', '4', '10.2', '1', '0.8', '0']
package org . apache . xpath . axes ; import java . util . Vector ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . objects . XObject ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . Axis ; public class ReverseAxesWalker extends AxesWalker { ReverseAxesWalker ( LocPathIterator locPathIterator , int axis ) { super ( locPathIterator , axis ) ; } public void setRoot ( int root ) { super . setRoot ( root ) ; m_iterator = getDTM ( root ) . getAxisIterator ( m_axis ) ; m_iterator . setStartNode ( root ) ; } protected int getNextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next = m_iterator . next ( ) ; if ( m_isFresh ) m_isFresh = false ; if ( DTM . NULL == next ) this . m_foundLast = true ; return next ; } public boolean isReverseAxes ( ) { return true ; } protected int getProximityPosition ( int predicateIndex ) { if ( predicateIndex < 0 ) return - 1 ; int count = m_proximityPositions [ predicateIndex ] ; if ( count <= 0 ) { AxesWalker savedWalker = wi ( ) . getLastUsedWalker ( ) ; try { ReverseAxesWalker clone = ( ReverseAxesWalker ) this . clone ( ) ; clone . setRoot ( this . getRoot ( ) ) ; clone . setPredicateCount ( predicateIndex ) ; clone . setPrevWalker ( null ) ; clone . setNextWalker ( null ) ; wi ( ) . setLastUsedWalker ( clone ) ; count ++ ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } m_proximityPositions [ predicateIndex ] = count ; } catch ( CloneNotSupportedException cnse ) { } finally { wi ( ) . setLastUsedWalker ( savedWalker ) ; } } return count ; } protected void countProximityPosition ( int i ) { if ( i < m_proximityPositions . length ) m_proximityPositions [ i ] -- ; } public int getLastPos ( XPathContext xctxt ) { int count = 0 ; AxesWalker savedWalker = wi ( ) . getLastUsedWalker ( ) ; try { ReverseAxesWalker clone = ( ReverseAxesWalker ) this . clone ( ) ; clone . setRoot ( this . getRoot ( ) ) ; clone . setPredicateCount ( this . getPredicateCount ( ) - 1 ) ; clone . setPrevWalker ( null ) ; clone . setNextWalker ( null ) ; wi ( ) . setLastUsedWalker ( clone ) ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } } catch ( CloneNotSupportedException cnse ) { } finally { wi ( ) . setLastUsedWalker ( savedWalker ) ; } return count ; } public boolean isDocOrdered ( ) { return false ; } protected DTMAxisIterator m_iterator ; } 	1	['8', '5', '0', '8', '24', '26', '1', '7', '4', '0.571428571', '200', '1', '1', '0.936363636', '0.4375', '2', '8', '23.875', '4', '1.875', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class XslAttribute extends Instruction { private String _prefix ; private AttributeValue _name ; private AttributeValueTemplate _namespace = null ; private boolean _ignore = false ; public AttributeValue getName ( ) { return _name ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Attribute " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { boolean generated = false ; final SymbolTable stable = parser . getSymbolTable ( ) ; String name = getAttribute ( "name" ) ; String namespace = getAttribute ( "namespace" ) ; QName qname = parser . getQName ( name , false ) ; final String prefix = qname . getPrefix ( ) ; if ( ( prefix != null ) && ( prefix . equals ( XMLNS_PREFIX ) ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_ATTR_NAME_ERR , name ) ; return ; } final SyntaxTreeNode parent = getParent ( ) ; final Vector siblings = parent . getContents ( ) ; for ( int i = 0 ; i < parent . elementCount ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) siblings . elementAt ( i ) ; if ( item == this ) break ; if ( item instanceof XslAttribute ) continue ; if ( item instanceof UseAttributeSets ) continue ; if ( item instanceof LiteralAttribute ) continue ; if ( item instanceof Text ) continue ; if ( item instanceof If ) continue ; if ( item instanceof Choose ) continue ; if ( item instanceof CopyOf ) continue ; if ( item instanceof VariableBase ) continue ; reportWarning ( this , parser , ErrorMsg . STRAY_ATTRIBUTE_ERR , name ) ; _ignore = true ; } if ( namespace != null && namespace != Constants . EMPTYSTRING ) { _prefix = lookupPrefix ( namespace ) ; _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } else if ( prefix != null && prefix != Constants . EMPTYSTRING ) { _prefix = prefix ; namespace = lookupNamespace ( prefix ) ; if ( namespace != null ) { _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } } if ( _namespace != null ) { if ( _prefix == null || _prefix == Constants . EMPTYSTRING ) { if ( prefix != null ) { _prefix = prefix ; } else { _prefix = stable . generateNamespacePrefix ( ) ; generated = true ; } } else if ( prefix != null && ! prefix . equals ( _prefix ) ) { _prefix = prefix ; } name = _prefix + ":" + qname . getLocalPart ( ) ; if ( ( parent instanceof LiteralElement ) && ( ! generated ) ) { ( ( LiteralElement ) parent ) . registerNamespace ( _prefix , namespace , stable , false ) ; } } if ( name . equals ( XMLNS_PREFIX ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_ATTR_NAME_ERR , name ) ; return ; } if ( parent instanceof LiteralElement ) { ( ( LiteralElement ) parent ) . addAttribute ( this ) ; } _name = AttributeValue . create ( this , name , parser ) ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( ! _ignore ) { _name . typeCheck ( stable ) ; if ( _namespace != null ) { _namespace . typeCheck ( stable ) ; } typeCheckContents ( stable ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _ignore ) return ; _ignore = true ; if ( _namespace != null ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _prefix ) ) ; _namespace . translate ( classGen , methodGen ) ; il . append ( methodGen . namespace ( ) ) ; } il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; _name . translate ( classGen , methodGen ) ; if ( ( elementCount ( ) == 1 ) && ( elementAt ( 0 ) instanceof Text ) ) { il . append ( new PUSH ( cpg , ( ( Text ) elementAt ( 0 ) ) . getText ( ) ) ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , "stringValueHandler" , STRING_VALUE_HANDLER_SIG ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_VALUE_HANDLER , "getValue" , "()" + STRING_SIG ) ) ) ; } il . append ( methodGen . attribute ( ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	0	['6', '3', '0', '35', '56', '0', '2', '33', '5', '0.45', '416', '1', '2', '0.918032787', '0.305555556', '2', '8', '67.66666667', '28', '6', '0']
package org . apache . xpath ; import java . util . Vector ; public interface ExtensionsProvider { public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException ; public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException ; public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey ) throws javax . xml . transform . TransformerException ; } 	1	['3', '1', '0', '4', '3', '3', '4', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . serialize ; import java . io . * ; public class WriterToASCI extends Writer { private final OutputStream m_os ; public WriterToASCI ( OutputStream os ) { m_os = os ; } public void write ( char chars [ ] , int start , int length ) throws java . io . IOException { int n = length + start ; for ( int i = start ; i < n ; i ++ ) { m_os . write ( chars [ i ] ) ; } } public void write ( int c ) throws IOException { m_os . write ( c ) ; } public void write ( String s ) throws IOException { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m_os . write ( s . charAt ( i ) ) ; } } public void flush ( ) throws java . io . IOException { m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } } 	0	['7', '2', '0', '1', '13', '0', '1', '0', '7', '0', '65', '1', '0', '0.684210526', '0.342857143', '1', '2', '8.142857143', '1', '0.8571', '0']
package org . apache . xalan . extensions ; import java . util . Hashtable ; import java . util . Vector ; import java . io . IOException ; import java . net . URL ; import java . net . URLConnection ; import java . io . InputStream ; import org . apache . xml . dtm . DTM ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SystemIDResolver ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . XPathProcessorException ; import org . apache . xml . utils . StringVector ; import java . lang . reflect . Method ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xml . dtm . ref . DTMNodeList ; import org . apache . xml . dtm . DTMIterator ; public class ExtensionHandlerGeneral extends ExtensionHandler { private String m_scriptSrc ; private String m_scriptSrcURL ; private Hashtable m_functions = new Hashtable ( ) ; private Hashtable m_elements = new Hashtable ( ) ; private Object m_mgr ; private Object m_engine ; private static final String BSF_MANAGER = "com.ibm.bsf.BSFManager" ; private static Class managerClass ; private static Method mgrLoadScriptingEngine ; private static final String BSF_ENGINE = "com.ibm.bsf.BSFEngine" ; private static Method engineExec ; private static Method engineCall ; private static final Integer NEG1INT = new Integer ( - 1 ) ; static { try { managerClass = ExtensionHandler . getClassForName ( BSF_MANAGER ) ; mgrLoadScriptingEngine = managerClass . getMethod ( "loadScriptingEngine" , new Class [ ] { String . class } ) ; Class engineClass = ExtensionHandler . getClassForName ( BSF_ENGINE ) ; engineExec = engineClass . getMethod ( "exec" , new Class [ ] { String . class , Integer . TYPE , Integer . TYPE , Object . class } ) ; engineCall = engineClass . getMethod ( "call" , new Class [ ] { Object . class , String . class , Class . forName ( "[Ljava.lang.Object;" ) } ) ; } catch ( Exception e ) { managerClass = null ; mgrLoadScriptingEngine = null ; engineExec = null ; engineCall = null ; e . printStackTrace ( ) ; } } public ExtensionHandlerGeneral ( String namespaceUri , StringVector elemNames , StringVector funcNames , String scriptLang , String scriptSrcURL , String scriptSrc , String systemId ) throws TransformerException { super ( namespaceUri , scriptLang ) ; if ( elemNames != null ) { Object junk = new Object ( ) ; int n = elemNames . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String tok = elemNames . elementAt ( i ) ; m_elements . put ( tok , junk ) ; } } if ( funcNames != null ) { Object junk = new Object ( ) ; int n = funcNames . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String tok = funcNames . elementAt ( i ) ; m_functions . put ( tok , junk ) ; } } m_scriptSrcURL = scriptSrcURL ; m_scriptSrc = scriptSrc ; if ( m_scriptSrcURL != null ) { URL url = null ; try { url = new URL ( m_scriptSrcURL ) ; } catch ( java . net . MalformedURLException mue ) { int indexOfColon = m_scriptSrcURL . indexOf ( ':' ) ; int indexOfSlash = m_scriptSrcURL . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { url = null ; throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_FIND_EXTERN_SCRIPT , new Object [ ] { m_scriptSrcURL } ) , mue ) ; } else { try { url = new URL ( new URL ( SystemIDResolver . getAbsoluteURI ( systemId ) ) , m_scriptSrcURL ) ; } catch ( java . net . MalformedURLException mue2 ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_FIND_EXTERN_SCRIPT , new Object [ ] { m_scriptSrcURL } ) , mue2 ) ; } } } if ( url != null ) { try { URLConnection uc = url . openConnection ( ) ; InputStream is = uc . getInputStream ( ) ; byte [ ] bArray = new byte [ uc . getContentLength ( ) ] ; is . read ( bArray ) ; m_scriptSrc = new String ( bArray ) ; } catch ( IOException ioe ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_FIND_EXTERN_SCRIPT , new Object [ ] { m_scriptSrcURL } ) , ioe ) ; } } } if ( null == managerClass ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_INIT_BSFMGR , null ) ) ; try { m_mgr = managerClass . newInstance ( ) ; m_engine = mgrLoadScriptingEngine . invoke ( m_mgr , new Object [ ] { scriptLang } ) ; engineExec . invoke ( m_engine , new Object [ ] { "XalanScript" , NEG1INT , NEG1INT , m_scriptSrc } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_CMPL_EXTENSN , null ) , e ) ; } } public boolean isFunctionAvailable ( String function ) { return ( m_functions . get ( function ) != null ) ; } public boolean isElementAvailable ( String element ) { return ( m_elements . get ( element ) != null ) ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { Object [ ] argArray ; try { argArray = new Object [ args . size ( ) ] ; for ( int i = 0 ; i < argArray . length ; i ++ ) { Object o = args . elementAt ( i ) ; argArray [ i ] = ( o instanceof XObject ) ? ( ( XObject ) o ) . object ( ) : o ; o = argArray [ i ] ; if ( null != o && o instanceof DTMIterator ) { argArray [ i ] = new DTMNodeList ( ( DTMIterator ) o ) ; } } return engineCall . invoke ( m_engine , new Object [ ] { null , funcName , argArray } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; String msg = e . getMessage ( ) ; if ( null != msg ) { if ( msg . startsWith ( "Stopping after fatal error:" ) ) { msg = msg . substring ( "Stopping after fatal error:" . length ( ) ) ; } throw new TransformerException ( e ) ; } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_CREATE_EXTENSN , new Object [ ] { funcName , e } ) ) ; } } } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { Vector argv = new Vector ( 2 ) ; argv . addElement ( xpc ) ; argv . addElement ( element ) ; result = callFunction ( localPart , argv , methodKey , transformer . getXPathContext ( ) . getExpressionContext ( ) ) ; } catch ( XPathProcessorException e ) { throw new TransformerException ( e . getMessage ( ) , e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1	['7', '2', '0', '15', '50', '11', '0', '15', '5', '0.911111111', '555', '0.866666667', '0', '0.545454545', '0.351851852', '0', '0', '76.14285714', '2', '1', '1']
package org . apache . xalan . xsltc . trax ; import java . util . ArrayList ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . SAXException ; import org . apache . xalan . xsltc . runtime . Constants ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . TransletOutputHandler ; public class SAX2TO implements ContentHandler , LexicalHandler , Constants { static private class Pair { String left ; String right ; public Pair ( String ll , String rr ) { left = ll ; right = rr ; } } TransletOutputHandler _handler ; ArrayList _nsDeclarations = new ArrayList ( ) ; public SAX2TO ( TransletOutputHandler handler ) { _handler = handler ; } public void startDocument ( ) throws TransletException { _handler . startDocument ( ) ; } public void endDocument ( ) throws TransletException { _handler . endDocument ( ) ; _handler . close ( ) ; } public void startElement ( String namespace , String localName , String qName , Attributes attrs ) throws TransletException { _handler . startElement ( qName ) ; int n = _nsDeclarations . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Pair pair = ( Pair ) _nsDeclarations . get ( i ) ; _handler . namespace ( pair . left , pair . right ) ; } _nsDeclarations . clear ( ) ; n = attrs . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { _handler . attribute ( attrs . getQName ( i ) , attrs . getValue ( i ) ) ; } } public void endElement ( String namespace , String localName , String qName ) throws TransletException { _handler . endElement ( qName ) ; } public void startPrefixMapping ( String prefix , String uri ) throws TransletException { _nsDeclarations . add ( new Pair ( prefix , uri ) ) ; } public void endPrefixMapping ( String prefix ) { } public void characters ( char [ ] ch , int start , int length ) throws TransletException { _handler . characters ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws TransletException { _handler . processingInstruction ( target , data ) ; } public void comment ( char [ ] ch , int start , int length ) throws TransletException { _handler . comment ( new String ( ch , start , length ) ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws TransletException { _handler . characters ( ch , start , length ) ; } public void startCDATA ( ) throws TransletException { _handler . startCDATA ( ) ; } public void endCDATA ( ) throws TransletException { _handler . endCDATA ( ) ; } public void setDocumentLocator ( Locator locator ) { } public void skippedEntity ( String name ) { } public void startEntity ( java . lang . String name ) { } public void endDTD ( ) { } public void endEntity ( String name ) { } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { } } 	0	['19', '1', '0', '6', '42', '57', '2', '4', '19', '0.666666667', '154', '0', '1', '0', '0.278195489', '0', '0', '7', '1', '0.9474', '0']
package org . apache . xalan . transformer ; import org . apache . xpath . XPathContext ; import org . apache . xpath . VariableStack ; import org . apache . xpath . axes . ContextNodeList ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xalan . templates . ElemTemplateElement ; import java . util . Stack ; import org . xml . sax . helpers . NamespaceSupport ; import org . apache . xml . utils . NamespaceSupport2 ; import java . util . Enumeration ; class TransformSnapshotImpl implements TransformSnapshot { private VariableStack m_variableStacks ; private int [ ] m_currentNodes ; private int [ ] m_currentExpressionNodes ; private Stack m_contextNodeLists ; private DTMIterator m_contextNodeList ; private Stack m_axesIteratorStack ; private BoolStack m_currentTemplateRuleIsNull ; private ElemTemplateElement [ ] m_currentTemplateElements ; private Stack m_currentMatchTemplates ; private NodeVector m_currentMatchNodes ; private CountersTable m_countersTable ; private Stack m_attrSetStack ; boolean m_nsContextPushed ; private NamespaceSupport m_nsSupport ; int m_eventCount ; TransformSnapshotImpl ( TransformerImpl transformer ) { try { ResultTreeHandler rtf = transformer . getResultTreeHandler ( ) ; m_eventCount = rtf . m_eventCount ; m_nsSupport = new NamespaceSupport2 ( ) ; Enumeration prefixes = rtf . m_nsSupport . getPrefixes ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; String uri = rtf . m_nsSupport . getURI ( prefix ) ; m_nsSupport . declarePrefix ( prefix , uri ) ; } m_nsContextPushed = rtf . m_nsContextPushed ; XPathContext xpc = transformer . getXPathContext ( ) ; m_variableStacks = ( VariableStack ) xpc . getVarStack ( ) . clone ( ) ; m_currentNodes = ( int [ ] ) xpc . getCurrentNodeStack ( ) . clone ( ) ; m_currentExpressionNodes = ( int [ ] ) xpc . getCurrentExpressionNodeStack ( ) . clone ( ) ; m_contextNodeLists = ( Stack ) xpc . getContextNodeListsStack ( ) . clone ( ) ; if ( ! m_contextNodeLists . empty ( ) ) m_contextNodeList = ( DTMIterator ) xpc . getContextNodeList ( ) . clone ( ) ; m_axesIteratorStack = ( Stack ) xpc . getAxesIteratorStackStacks ( ) . clone ( ) ; m_currentTemplateRuleIsNull = ( BoolStack ) transformer . m_currentTemplateRuleIsNull . clone ( ) ; m_currentTemplateElements = ( ElemTemplateElement [ ] ) transformer . m_currentTemplateElements . clone ( ) ; m_currentMatchTemplates = ( Stack ) transformer . m_currentMatchTemplates . clone ( ) ; m_currentMatchNodes = ( NodeVector ) transformer . m_currentMatchedNodes . clone ( ) ; m_countersTable = ( CountersTable ) transformer . getCountersTable ( ) . clone ( ) ; if ( transformer . m_attrSetStack != null ) m_attrSetStack = ( Stack ) transformer . m_attrSetStack . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } void apply ( TransformerImpl transformer ) { try { ResultTreeHandler rtf = transformer . getResultTreeHandler ( ) ; if ( rtf != null ) { rtf . m_eventCount = 1 ; rtf . m_nsSupport = new NamespaceSupport ( ) ; Enumeration prefixes = m_nsSupport . getPrefixes ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; String uri = m_nsSupport . getURI ( prefix ) ; rtf . m_nsSupport . declarePrefix ( prefix , uri ) ; } rtf . m_nsContextPushed = m_nsContextPushed ; } XPathContext xpc = transformer . getXPathContext ( ) ; xpc . setVarStack ( ( VariableStack ) m_variableStacks . clone ( ) ) ; xpc . setCurrentNodeStack ( ( int [ ] ) m_currentNodes . clone ( ) ) ; xpc . setCurrentExpressionNodeStack ( ( int [ ] ) m_currentExpressionNodes . clone ( ) ) ; xpc . setContextNodeListsStack ( ( Stack ) m_contextNodeLists . clone ( ) ) ; if ( m_contextNodeList != null ) xpc . pushContextNodeList ( ( DTMIterator ) m_contextNodeList . clone ( ) ) ; xpc . setAxesIteratorStackStacks ( ( Stack ) m_axesIteratorStack . clone ( ) ) ; transformer . m_currentTemplateRuleIsNull = ( BoolStack ) m_currentTemplateRuleIsNull . clone ( ) ; transformer . m_currentTemplateElements = ( ElemTemplateElement [ ] ) m_currentTemplateElements . clone ( ) ; transformer . m_currentMatchTemplates = ( Stack ) m_currentMatchTemplates . clone ( ) ; transformer . m_currentMatchedNodes = ( NodeVector ) m_currentMatchNodes . clone ( ) ; transformer . m_countersTable = ( CountersTable ) m_countersTable . clone ( ) ; if ( m_attrSetStack != null ) transformer . m_attrSetStack = ( Stack ) m_attrSetStack . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } } 	1	['2', '1', '0', '13', '34', '0', '1', '13', '0', '0.066666667', '283', '0.866666667', '6', '0', '1', '0', '0', '133', '4', '2', '1']
package org . apache . xpath ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; import org . xml . sax . XMLReader ; import org . xml . sax . ContentHandler ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . XMLString ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTM ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . ErrorListener ; public abstract class Expression implements java . io . Serializable , ExpressionNode , XPathVisitable { private ExpressionNode m_parent ; public boolean canTraverseOutsideSubtree ( ) { return false ; } public XObject execute ( XPathContext xctxt , int currentNode ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) ; } public XObject execute ( XPathContext xctxt , int currentNode , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) ; } public abstract XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException ; public XObject execute ( XPathContext xctxt , boolean destructiveOK ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) . num ( ) ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) . bool ( ) ; } public XMLString xstr ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) . xstr ( ) ; } public boolean isNodesetExpr ( ) { return false ; } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator iter = execute ( xctxt ) . iter ( ) ; return iter . nextNode ( ) ; } public DTMIterator asIterator ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { try { xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; return execute ( xctxt ) . iter ( ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; } } public DTMIterator asIteratorRaw ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { try { xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; XNodeSet nodeset = ( XNodeSet ) execute ( xctxt ) ; return nodeset . iterRaw ( ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; } } public void executeCharsToContentHandler ( XPathContext xctxt , ContentHandler handler ) throws javax . xml . transform . TransformerException , org . xml . sax . SAXException { XObject obj = execute ( xctxt ) ; obj . dispatchCharactersEvents ( handler ) ; obj . detach ( ) ; } public boolean isStableNumber ( ) { return false ; } public abstract void fixupVariables ( java . util . Vector vars , int globalsSize ) ; public abstract boolean deepEquals ( Expression expr ) ; protected final boolean isSameClass ( Expression expr ) { if ( null == expr ) return false ; return ( getClass ( ) == expr . getClass ( ) ) ; } public void warn ( XPathContext xctxt , int msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; eh . warning ( new TransformerException ( fmsg , xctxt . getSAXLocator ( ) ) ) ; } } public void assertion ( boolean b , java . lang . String msg ) { if ( ! b ) { java . lang . String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( XPathContext xctxt , int msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , this ) ; eh . fatalError ( te ) ; } } public ExpressionNode getExpressionOwner ( ) { ExpressionNode parent = exprGetParent ( ) ; while ( ( null != parent ) && ( parent instanceof Expression ) ) parent = parent . exprGetParent ( ) ; return parent ; } public void exprSetParent ( ExpressionNode n ) { assertion ( n != this , "Can not parent an expression to itself!" ) ; m_parent = n ; } public ExpressionNode exprGetParent ( ) { return m_parent ; } public void exprAddChild ( ExpressionNode n , int i ) { assertion ( false , "exprAddChild method not implemented!" ) ; } public ExpressionNode exprGetChild ( int i ) { return null ; } public int exprGetNumChildren ( ) { return 0 ; } public String getPublicId ( ) { if ( null == m_parent ) return null ; return m_parent . getPublicId ( ) ; } public String getSystemId ( ) { if ( null == m_parent ) return null ; return m_parent . getSystemId ( ) ; } public int getLineNumber ( ) { if ( null == m_parent ) return 0 ; return m_parent . getLineNumber ( ) ; } public int getColumnNumber ( ) { if ( null == m_parent ) return 0 ; return m_parent . getColumnNumber ( ) ; } } 	0	['32', '1', '6', '106', '57', '466', '98', '11', '31', '0.806451613', '276', '1', '1', '0', '0.163461538', '0', '0', '7.59375', '3', '1.2813', '0']
package org . apache . xpath . axes ; import javax . xml . transform . TransformerException ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . objects . XObject ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . Axis ; public class ChildTestIterator extends BasicTestIterator { transient protected DTMAxisTraverser m_traverser ; ChildTestIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; } public ChildTestIterator ( DTMAxisTraverser traverser ) { super ( null ) ; m_traverser = traverser ; } protected int getNextNode ( ) { if ( true ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; } return m_lastFetched ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { ChildTestIterator clone = ( ChildTestIterator ) super . cloneWithReset ( ) ; clone . m_traverser = m_traverser ; return clone ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( Axis . CHILD ) ; } public int getAxis ( ) { return org . apache . xml . dtm . Axis . CHILD ; } } 	1	['6', '6', '5', '13', '13', '3', '7', '7', '4', '0.4', '65', '1', '1', '0.96969697', '0.366666667', '2', '4', '9.666666667', '2', '0.8333', '1']
package org . apache . xpath . functions ; import java . util . Vector ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xml . utils . XMLString ; public class FuncSubstring extends Function3Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XMLString s1 = m_arg0 . execute ( xctxt ) . xstr ( ) ; double start = m_arg1 . execute ( xctxt ) . num ( ) ; int lenOfS1 = s1 . length ( ) ; XMLString substr ; if ( lenOfS1 <= 0 ) return XString . EMPTYSTRING ; else { int startIndex ; if ( Double . isNaN ( start ) ) { start = - 1000000 ; startIndex = 0 ; } else { start = Math . round ( start ) ; startIndex = ( start > 0 ) ? ( int ) start - 1 : 0 ; } if ( null != m_arg2 ) { double len = m_arg2 . num ( xctxt ) ; int end = ( int ) ( Math . round ( len ) + start ) - 1 ; if ( end < 0 ) end = 0 ; else if ( end > lenOfS1 ) end = lenOfS1 ; if ( startIndex > lenOfS1 ) startIndex = lenOfS1 ; substr = s1 . substring ( startIndex , end ) ; } else { if ( startIndex > lenOfS1 ) startIndex = lenOfS1 ; substr = s1 . substring ( startIndex ) ; } } return ( XString ) substr ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum < 2 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_TWO_OR_THREE , null ) ) ; } } 	0	['4', '6', '0', '10', '16', '6', '0', '10', '3', '2', '113', '0', '0', '0.955223881', '0.5', '2', '8', '27.25', '1', '0.75', '0']
package org . apache . xpath . objects ; import javax . xml . transform . TransformerException ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; public class XNumber extends XObject { double m_val ; public XNumber ( double d ) { super ( ) ; m_val = d ; } public XNumber ( Number num ) { super ( ) ; m_val = num . doubleValue ( ) ; m_obj = num ; } public int getType ( ) { return CLASS_NUMBER ; } public String getTypeString ( ) { return "#NUMBER" ; } public double num ( ) { return m_val ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_val ; } public boolean bool ( ) { return ( Double . isNaN ( m_val ) || ( m_val == 0.0 ) ) ? false : true ; } public String str ( ) { if ( Double . isNaN ( m_val ) ) { return "NaN" ; } else if ( Double . isInfinite ( m_val ) ) { if ( m_val > 0 ) return "Infinity" ; else return "-Infinity" ; } double num = m_val ; String s = Double . toString ( num ) ; int len = s . length ( ) ; if ( s . charAt ( len - 2 ) == '.' && s . charAt ( len - 1 ) == '0' ) { s = s . substring ( 0 , len - 2 ) ; if ( s . equals ( "-0" ) ) return "0" ; return s ; } int e = s . indexOf ( 'E' ) ; if ( e < 0 ) return s ; int exp = Integer . parseInt ( s . substring ( e + 1 ) ) ; String sign ; if ( s . charAt ( 0 ) == '-' ) { sign = "-" ; s = s . substring ( 1 ) ; -- e ; } else sign = "" ; int nDigits = e - 2 ; if ( exp >= nDigits ) return sign + s . substring ( 0 , 1 ) + s . substring ( 2 , e ) + zeros ( exp - nDigits ) ; if ( exp > 0 ) return sign + s . substring ( 0 , 1 ) + s . substring ( 2 , 2 + exp ) + "." + s . substring ( 2 + exp , e ) ; return sign + "0." + zeros ( - 1 - exp ) + s . substring ( 0 , 1 ) + s . substring ( 2 , e ) ; } static private String zeros ( int n ) { if ( n < 1 ) return "" ; char [ ] buf = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { buf [ i ] = '0' ; } return new String ( buf ) ; } public Object object ( ) { if ( null == m_obj ) m_obj = new Double ( m_val ) ; return m_obj ; } public boolean equals ( XObject obj2 ) { int t = obj2 . getType ( ) ; try { if ( t == XObject . CLASS_NODESET ) return obj2 . equals ( this ) ; else if ( t == XObject . CLASS_BOOLEAN ) return obj2 . bool ( ) == bool ( ) ; else return m_val == obj2 . num ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } public boolean isStableNumber ( ) { return true ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitNumberLiteral ( owner , this ) ; } } 	1	['13', '3', '0', '41', '36', '22', '37', '5', '12', '0.416666667', '307', '0', '0', '0.865853659', '0.182692308', '2', '22', '22.53846154', '11', '2.3077', '2']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class AttributeValueTemplate extends AttributeValue { public AttributeValueTemplate ( String value , Parser parser , SyntaxTreeNode parent ) { setParent ( parent ) ; setParser ( parser ) ; if ( check ( value , parser ) ) { parseAVTemplate ( 0 , value , parser ) ; } } private void parseAVTemplate ( final int start , String text , Parser parser ) { String str ; if ( text == null ) return ; int open = start - 2 ; do { open = text . indexOf ( '{' , open + 2 ) ; } while ( ( open != - 1 ) && ( open < ( text . length ( ) - 1 ) ) && ( text . charAt ( open + 1 ) == '{' ) ) ; if ( open != - 1 ) { int close = open - 2 ; do { close = text . indexOf ( '}' , close + 2 ) ; } while ( ( close != - 1 ) && ( close < ( text . length ( ) - 1 ) ) && ( text . charAt ( close + 1 ) == '}' ) ) ; if ( open > start ) { str = removeDuplicateBraces ( text . substring ( start , open ) ) ; addElement ( new LiteralExpr ( str ) ) ; } if ( close > open + 1 ) { str = text . substring ( open + 1 , close ) ; str = removeDuplicateBraces ( text . substring ( open + 1 , close ) ) ; addElement ( parser . parseExpression ( this , str ) ) ; } parseAVTemplate ( close + 1 , text , parser ) ; } else if ( start < text . length ( ) ) { str = removeDuplicateBraces ( text . substring ( start ) ) ; addElement ( new LiteralExpr ( str ) ) ; } } public String removeDuplicateBraces ( String orig ) { String result = orig ; int index ; while ( ( index = result . indexOf ( "{{" ) ) != - 1 ) { result = result . substring ( 0 , index ) + result . substring ( index + 1 , result . length ( ) ) ; } while ( ( index = result . indexOf ( "}}" ) ) != - 1 ) { result = result . substring ( 0 , index ) + result . substring ( index + 1 , result . length ( ) ) ; } return ( result ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Vector contents = getContents ( ) ; final int n = contents . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) contents . elementAt ( i ) ; if ( ! exp . typeCheck ( stable ) . identicalTo ( Type . String ) ) { contents . setElementAt ( new CastExpr ( exp , Type . String ) , i ) ; } } return _type = Type . String ; } public String toString ( ) { final StringBuffer buffer = new StringBuffer ( "AVT:[" ) ; final int count = elementCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { buffer . append ( elementAt ( i ) . toString ( ) ) ; if ( i < count - 1 ) buffer . append ( ' ' ) ; } return buffer . append ( ']' ) . toString ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( elementCount ( ) == 1 ) { final Expression exp = ( Expression ) elementAt ( 0 ) ; exp . translate ( classGen , methodGen ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initBuffer = cpg . addMethodref ( STRING_BUFFER_CLASS , "<init>" , "()V" ) ; final Instruction append = new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_BUFFER_CLASS , "append" , "(" + STRING_SIG + ")" + STRING_BUFFER_SIG ) ) ; final int toString = cpg . addMethodref ( STRING_BUFFER_CLASS , "toString" , "()" + STRING_SIG ) ; il . append ( new NEW ( cpg . addClass ( STRING_BUFFER_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( initBuffer ) ) ; final Enumeration enum = elements ( ) ; while ( enum . hasMoreElements ( ) ) { final Expression exp = ( Expression ) enum . nextElement ( ) ; exp . translate ( classGen , methodGen ) ; il . append ( append ) ; } il . append ( new INVOKEVIRTUAL ( toString ) ) ; } } private boolean check ( String value , Parser parser ) { if ( value == null ) return true ; final char [ ] chars = value . toCharArray ( ) ; int level = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '{' : if ( ( ( i + 1 ) == ( chars . length ) ) || ( chars [ i + 1 ] != '{' ) ) ++ level ; else i ++ ; break ; case '}' : if ( ( ( i + 1 ) == ( chars . length ) ) || ( chars [ i + 1 ] != '}' ) ) -- level ; else i ++ ; break ; default : continue ; } switch ( level ) { case 0 : case 1 : continue ; default : reportError ( getParent ( ) , parser , ErrorMsg . ATTR_VAL_TEMPLATE_ERR , value ) ; return false ; } } if ( level != 0 ) { reportError ( getParent ( ) , parser , ErrorMsg . ATTR_VAL_TEMPLATE_ERR , value ) ; return false ; } return true ; } } 	0	['7', '4', '0', '25', '49', '21', '4', '22', '5', '2', '452', '0', '0', '0.923076923', '0.339285714', '2', '7', '63.57142857', '14', '5.1429', '0']
package org . apache . xpath . axes ; import javax . xml . transform . TransformerException ; import org . apache . xpath . compiler . Compiler ; public class RTFIterator extends OneStepIteratorForward { RTFIterator ( Compiler compiler , int opPos , int analysis ) throws TransformerException { super ( compiler , opPos , analysis ) ; } public RTFIterator ( int axis ) { super ( axis ) ; } } 	1	['2', '8', '0', '4', '4', '1', '2', '2', '1', '2', '12', '0', '0', '1', '0.833333333', '0', '0', '5', '0', '0', '1']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class NodeSortRecordFactGenerator extends ClassGenerator { public NodeSortRecordFactGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; } public boolean isExternal ( ) { return true ; } } 	0	['2', '4', '0', '3', '3', '1', '1', '2', '2', '2', '13', '0', '0', '0.987804878', '0.6', '0', '0', '5.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xalan . xsltc . compiler . Constants ; public final class NodeSetType extends Type { protected NodeSetType ( ) { } public String toString ( ) { return "node-set" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return NODE_ITERATOR_SIG ; } public org . apache . bcel . generic . Type toJCType ( ) { return new org . apache . bcel . generic . ObjectType ( NODE_ITERATOR ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Node ) { translateTo ( classGen , methodGen , ( NodeType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { InstructionList il = methodGen . getInstructionList ( ) ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; if ( clazz . getName ( ) . equals ( "org.w3c.dom.NodeList" ) ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int convert = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "nodeList2Iterator" , "(" + "Lorg/w3c/dom/NodeList;" + TRANSLET_INTF_SIG + DOM_INTF_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( convert ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; getFirstNode ( classGen , methodGen ) ; il . append ( DUP ) ; final BranchHandle falsec = il . append ( new IFEQ ( null ) ) ; Type . Node . translateTo ( classGen , methodGen , type ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( POP ) ) ; il . append ( new PUSH ( classGen . getConstantPool ( ) , "" ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { translateTo ( classGen , methodGen , Type . String ) ; Type . String . translateTo ( classGen , methodGen , Type . Real ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeType type ) { getFirstNode ( classGen , methodGen ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; getFirstNode ( classGen , methodGen ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String className = clazz . getName ( ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; if ( className . equals ( "org.w3c.dom.Node" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE , MAKE_NODE_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "org.w3c.dom.NodeList" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE_LIST , MAKE_NODE_LIST_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "int" ) ) { int next = cpg . addInterfaceMethodref ( NODE_ITERATOR , "next" , "()I" ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , "(I)" + STRING_SIG ) ; int str = cpg . addMethodref ( BASIS_LIBRARY_CLASS , STRING_TO_INT , STRING_TO_INT_SIG ) ; il . append ( new INVOKEINTERFACE ( next , 1 ) ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; il . append ( new INVOKESTATIC ( str ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , className ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } private void getFirstNode ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKEINTERFACE ( cpg . addInterfaceMethodref ( NODE_ITERATOR , NEXT , NEXT_SIG ) , 1 ) ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public String getClassName ( ) { return ( NODE_ITERATOR ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	1	['21', '2', '0', '44', '49', '210', '15', '32', '19', '2', '450', '0', '0', '0.622641509', '0.238095238', '2', '4', '20.42857143', '7', '1.4762', '1']
package org . apache . xml . utils ; import java . util . EmptyStackException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; public class NamespaceSupport2 extends org . xml . sax . helpers . NamespaceSupport { private Context2 currentContext ; public final static String XMLNS = "http://www.w3.org/XML/1998/namespace" ; public NamespaceSupport2 ( ) { reset ( ) ; } public void reset ( ) { currentContext = new Context2 ( null ) ; currentContext . declarePrefix ( "xml" , XMLNS ) ; } public void pushContext ( ) { Context2 parentContext = currentContext ; currentContext = parentContext . getChild ( ) ; if ( currentContext == null ) { currentContext = new Context2 ( parentContext ) ; } else { currentContext . setParent ( parentContext ) ; } } public void popContext ( ) { Context2 parentContext = currentContext . getParent ( ) ; if ( parentContext == null ) throw new EmptyStackException ( ) ; else currentContext = parentContext ; } public boolean declarePrefix ( String prefix , String uri ) { if ( prefix . equals ( "xml" ) || prefix . equals ( "xmlns" ) ) { return false ; } else { currentContext . declarePrefix ( prefix , uri ) ; return true ; } } public String [ ] processName ( String qName , String [ ] parts , boolean isAttribute ) { String [ ] name = currentContext . processName ( qName , isAttribute ) ; if ( name == null ) return null ; System . arraycopy ( name , 0 , parts , 0 , 3 ) ; return parts ; } public String getURI ( String prefix ) { return currentContext . getURI ( prefix ) ; } public Enumeration getPrefixes ( ) { return currentContext . getPrefixes ( ) ; } public String getPrefix ( String uri ) { return currentContext . getPrefix ( uri ) ; } public Enumeration getPrefixes ( String uri ) { return new PrefixForUriEnumerator ( this , uri , getPrefixes ( ) ) ; } public Enumeration getDeclaredPrefixes ( ) { return currentContext . getDeclaredPrefixes ( ) ; } } class PrefixForUriEnumerator implements Enumeration { private Enumeration allPrefixes ; private String uri ; private String lookahead = null ; private NamespaceSupport2 nsup ; PrefixForUriEnumerator ( NamespaceSupport2 nsup , String uri , Enumeration allPrefixes ) { this . nsup = nsup ; this . uri = uri ; this . allPrefixes = allPrefixes ; } public boolean hasMoreElements ( ) { if ( lookahead != null ) return true ; while ( allPrefixes . hasMoreElements ( ) ) { String prefix = ( String ) allPrefixes . nextElement ( ) ; if ( uri . equals ( nsup . getURI ( prefix ) ) ) { lookahead = prefix ; return true ; } } return false ; } public Object nextElement ( ) { if ( hasMoreElements ( ) ) { String tmp = lookahead ; lookahead = null ; return tmp ; } else throw new java . util . NoSuchElementException ( ) ; } } final class Context2 { private final static Enumeration EMPTY_ENUMERATION = new Vector ( ) . elements ( ) ; Hashtable prefixTable ; Hashtable uriTable ; Hashtable elementNameTable ; Hashtable attributeNameTable ; String defaultNS = null ; private Vector declarations = null ; private boolean tablesDirty = false ; private Context2 parent = null ; private Context2 child = null ; Context2 ( Context2 parent ) { if ( parent == null ) { prefixTable = new Hashtable ( ) ; uriTable = new Hashtable ( ) ; elementNameTable = null ; attributeNameTable = null ; } else setParent ( parent ) ; } Context2 getChild ( ) { return child ; } Context2 getParent ( ) { return parent ; } void setParent ( Context2 parent ) { this . parent = parent ; parent . child = this ; declarations = null ; prefixTable = parent . prefixTable ; uriTable = parent . uriTable ; elementNameTable = parent . elementNameTable ; attributeNameTable = parent . attributeNameTable ; defaultNS = parent . defaultNS ; tablesDirty = false ; } void declarePrefix ( String prefix , String uri ) { if ( ! tablesDirty ) { copyTables ( ) ; } if ( declarations == null ) { declarations = new Vector ( ) ; } prefix = prefix . intern ( ) ; uri = uri . intern ( ) ; if ( "" . equals ( prefix ) ) { if ( "" . equals ( uri ) ) { defaultNS = null ; } else { defaultNS = uri ; } } else { prefixTable . put ( prefix , uri ) ; uriTable . put ( uri , prefix ) ; } declarations . addElement ( prefix ) ; } String [ ] processName ( String qName , boolean isAttribute ) { String name [ ] ; Hashtable table ; if ( isAttribute ) { if ( elementNameTable == null ) elementNameTable = new Hashtable ( ) ; table = elementNameTable ; } else { if ( attributeNameTable == null ) attributeNameTable = new Hashtable ( ) ; table = attributeNameTable ; } name = ( String [ ] ) table . get ( qName ) ; if ( name != null ) { return name ; } name = new String [ 3 ] ; int index = qName . indexOf ( ':' ) ; if ( index == - 1 ) { if ( isAttribute || defaultNS == null ) { name [ 0 ] = "" ; } else { name [ 0 ] = defaultNS ; } name [ 1 ] = qName . intern ( ) ; name [ 2 ] = name [ 1 ] ; } else { String prefix = qName . substring ( 0 , index ) ; String local = qName . substring ( index + 1 ) ; String uri ; if ( "" . equals ( prefix ) ) { uri = defaultNS ; } else { uri = ( String ) prefixTable . get ( prefix ) ; } if ( uri == null ) { return null ; } name [ 0 ] = uri ; name [ 1 ] = local . intern ( ) ; name [ 2 ] = qName . intern ( ) ; } table . put ( name [ 2 ] , name ) ; tablesDirty = true ; return name ; } String getURI ( String prefix ) { if ( "" . equals ( prefix ) ) { return defaultNS ; } else if ( prefixTable == null ) { return null ; } else { return ( String ) prefixTable . get ( prefix ) ; } } String getPrefix ( String uri ) { if ( uriTable == null ) { return null ; } else { return ( String ) uriTable . get ( uri ) ; } } Enumeration getDeclaredPrefixes ( ) { if ( declarations == null ) { return EMPTY_ENUMERATION ; } else { return declarations . elements ( ) ; } } Enumeration getPrefixes ( ) { if ( prefixTable == null ) { return EMPTY_ENUMERATION ; } else { return prefixTable . keys ( ) ; } } private void copyTables ( ) { prefixTable = ( Hashtable ) prefixTable . clone ( ) ; uriTable = ( Hashtable ) uriTable . clone ( ) ; if ( elementNameTable != null ) elementNameTable = new Hashtable ( ) ; if ( attributeNameTable != null ) attributeNameTable = new Hashtable ( ) ; tablesDirty = true ; } } 	0	['11', '2', '0', '5', '26', '0', '4', '2', '11', '0.55', '127', '0.5', '1', '0.583333333', '0.409090909', '1', '3', '10.36363636', '3', '1.3636', '0']
package org . apache . xml . utils ; public class FastStringBuffer { static final int DEBUG_FORCE_INIT_BITS = 0 ; static boolean DEBUG_FORCE_FIXED_CHUNKSIZE = true ; public static final int SUPPRESS_LEADING_WS = 0x01 ; public static final int SUPPRESS_TRAILING_WS = 0x02 ; public static final int SUPPRESS_BOTH = SUPPRESS_LEADING_WS | SUPPRESS_TRAILING_WS ; private static final int CARRY_WS = 0x04 ; int m_chunkBits = 15 ; int m_maxChunkBits = 15 ; int m_rebundleBits = 2 ; int m_chunkSize ; int m_chunkMask ; char [ ] [ ] m_array ; int m_lastChunk = 0 ; int m_firstFree = 0 ; FastStringBuffer m_innerFSB = null ; public FastStringBuffer ( int initChunkBits , int maxChunkBits , int rebundleBits ) { if ( DEBUG_FORCE_INIT_BITS != 0 ) initChunkBits = DEBUG_FORCE_INIT_BITS ; if ( DEBUG_FORCE_FIXED_CHUNKSIZE ) maxChunkBits = initChunkBits ; m_array = new char [ 16 ] [ ] ; if ( initChunkBits > maxChunkBits ) initChunkBits = maxChunkBits ; m_chunkBits = initChunkBits ; m_maxChunkBits = maxChunkBits ; m_rebundleBits = rebundleBits ; m_chunkSize = 1 << ( initChunkBits ) ; m_chunkMask = m_chunkSize - 1 ; m_array [ 0 ] = new char [ m_chunkSize ] ; } public FastStringBuffer ( int initChunkBits , int maxChunkBits ) { this ( initChunkBits , maxChunkBits , 2 ) ; } public FastStringBuffer ( int initChunkBits ) { this ( initChunkBits , 15 , 2 ) ; } public FastStringBuffer ( ) { this ( 10 , 15 , 2 ) ; } public final int size ( ) { return ( m_lastChunk << m_chunkBits ) + m_firstFree ; } public final int length ( ) { return ( m_lastChunk << m_chunkBits ) + m_firstFree ; } public final void reset ( ) { m_lastChunk = 0 ; m_firstFree = 0 ; FastStringBuffer innermost = this ; while ( innermost . m_innerFSB != null ) { innermost = innermost . m_innerFSB ; } m_chunkBits = innermost . m_chunkBits ; m_chunkSize = innermost . m_chunkSize ; m_chunkMask = innermost . m_chunkMask ; m_innerFSB = null ; m_array = new char [ 16 ] [ 0 ] ; m_array [ 0 ] = new char [ m_chunkSize ] ; } public final void setLength ( int l ) { m_lastChunk = l > > > m_chunkBits ; if ( m_lastChunk == 0 && m_innerFSB != null ) { m_innerFSB . setLength ( l , this ) ; } else { m_firstFree = l & m_chunkMask ; if ( m_firstFree == 0 && m_lastChunk > 0 ) { -- m_lastChunk ; m_firstFree = m_chunkSize ; } } } private final void setLength ( int l , FastStringBuffer rootFSB ) { m_lastChunk = l > > > m_chunkBits ; if ( m_lastChunk == 0 && m_innerFSB != null ) { m_innerFSB . setLength ( l , rootFSB ) ; } else { rootFSB . m_chunkBits = m_chunkBits ; rootFSB . m_maxChunkBits = m_maxChunkBits ; rootFSB . m_rebundleBits = m_rebundleBits ; rootFSB . m_chunkSize = m_chunkSize ; rootFSB . m_chunkMask = m_chunkMask ; rootFSB . m_array = m_array ; rootFSB . m_innerFSB = m_innerFSB ; rootFSB . m_lastChunk = m_lastChunk ; rootFSB . m_firstFree = l & m_chunkMask ; } } public final String toString ( ) { int length = ( m_lastChunk << m_chunkBits ) + m_firstFree ; return getString ( new StringBuffer ( length ) , 0 , 0 , length ) . toString ( ) ; } public final void append ( char value ) { char [ ] chunk ; boolean lastchunk = ( m_lastChunk + 1 == m_array . length ) ; if ( m_firstFree < m_chunkSize ) chunk = m_array [ m_lastChunk ] ; else { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } m_firstFree = 0 ; } chunk [ m_firstFree ++ ] = value ; } public final void append ( String value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; value . getChars ( copyfrom , copyfrom + available , m_array [ m_lastChunk ] , m_firstFree ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( StringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; value . getChars ( copyfrom , copyfrom + available , m_array [ m_lastChunk ] , m_firstFree ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( char [ ] chars , int start , int length ) { int strlen = length ; if ( 0 == strlen ) return ; int copyfrom = start ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; System . arraycopy ( chars , copyfrom , m_array [ m_lastChunk ] , m_firstFree , available ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( FastStringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; int sourcechunk = ( copyfrom + value . m_chunkSize - 1 ) > > > value . m_chunkBits ; int sourcecolumn = copyfrom & value . m_chunkMask ; int runlength = value . m_chunkSize - sourcecolumn ; if ( runlength > available ) runlength = available ; System . arraycopy ( value . m_array [ sourcechunk ] , sourcecolumn , m_array [ m_lastChunk ] , m_firstFree , runlength ) ; if ( runlength != available ) System . arraycopy ( value . m_array [ sourcechunk + 1 ] , 0 , m_array [ m_lastChunk ] , m_firstFree + runlength , available - runlength ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public boolean isWhitespace ( int start , int length ) { int sourcechunk = start > > > m_chunkBits ; int sourcecolumn = start & m_chunkMask ; int available = m_chunkSize - sourcecolumn ; boolean chunkOK ; while ( length > 0 ) { int runlength = ( length <= available ) ? length : available ; if ( sourcechunk == 0 && m_innerFSB != null ) chunkOK = m_innerFSB . isWhitespace ( sourcecolumn , runlength ) ; else chunkOK = org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( m_array [ sourcechunk ] , sourcecolumn , runlength ) ; if ( ! chunkOK ) return false ; length -= runlength ; ++ sourcechunk ; sourcecolumn = 0 ; available = m_chunkSize ; } return true ; } public String getString ( int start , int length ) { return getString ( new StringBuffer ( length ) , start > > > m_chunkBits , start & m_chunkMask , length ) . toString ( ) ; } StringBuffer getString ( StringBuffer sb , int start , int length ) { return getString ( sb , start > > > m_chunkBits , start & m_chunkMask , length ) ; } StringBuffer getString ( StringBuffer sb , int startChunk , int startColumn , int length ) { int stop = ( startChunk << m_chunkBits ) + startColumn + length ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) m_innerFSB . getString ( sb , startColumn , m_chunkSize - startColumn ) ; else sb . append ( m_array [ i ] , startColumn , m_chunkSize - startColumn ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) m_innerFSB . getString ( sb , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) sb . append ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn ) ; return sb ; } public char charAt ( int pos ) { int startChunk = pos > > > m_chunkBits ; if ( startChunk == 0 && m_innerFSB != null ) return m_innerFSB . charAt ( pos & m_chunkMask ) ; else return m_array [ startChunk ] [ pos & m_chunkMask ] ; } public void sendSAXcharacters ( org . xml . sax . ContentHandler ch , int start , int length ) throws org . xml . sax . SAXException { int stop = start + length ; int startChunk = start > > > m_chunkBits ; int startColumn = start & m_chunkMask ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) m_innerFSB . sendSAXcharacters ( ch , startColumn , m_chunkSize - startColumn ) ; else ch . characters ( m_array [ i ] , startColumn , m_chunkSize - startColumn ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) m_innerFSB . sendSAXcharacters ( ch , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) { ch . characters ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn ) ; } } public int sendNormalizedSAXcharacters ( org . xml . sax . ContentHandler ch , int start , int length ) throws org . xml . sax . SAXException { int stateForNextChunk = SUPPRESS_LEADING_WS ; int stop = start + length ; int startChunk = start > > > m_chunkBits ; int startColumn = start & m_chunkMask ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) stateForNextChunk = m_innerFSB . sendNormalizedSAXcharacters ( ch , startColumn , m_chunkSize - startColumn ) ; else stateForNextChunk = sendNormalizedSAXcharacters ( m_array [ i ] , startColumn , m_chunkSize - startColumn , ch , stateForNextChunk ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) stateForNextChunk = m_innerFSB . sendNormalizedSAXcharacters ( ch , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) { stateForNextChunk = sendNormalizedSAXcharacters ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn , ch , stateForNextChunk | SUPPRESS_TRAILING_WS ) ; } return stateForNextChunk ; } static final char [ ] SINGLE_SPACE = { ' ' } ; static int sendNormalizedSAXcharacters ( char ch [ ] , int start , int length , org . xml . sax . ContentHandler handler , int edgeTreatmentFlags ) throws org . xml . sax . SAXException { int end = length + start ; int scanpos = start ; if ( XMLCharacterRecognizer . isWhiteSpace ( ch [ scanpos ] ) ) { if ( 0 == ( edgeTreatmentFlags & SUPPRESS_LEADING_WS ) ) handler . characters ( SINGLE_SPACE , 0 , 1 ) ; while ( ++ scanpos < end ) { char c = ch [ scanpos ] ; if ( ! XMLCharacterRecognizer . isWhiteSpace ( c ) ) break ; } } boolean whiteSpaceFound = false ; boolean needToFlushSpace = 0 != ( edgeTreatmentFlags & CARRY_WS ) ; int datapos = scanpos ; for ( ; scanpos < end ; scanpos ++ ) { char c = ch [ scanpos ] ; if ( XMLCharacterRecognizer . isWhiteSpace ( c ) ) { if ( ! whiteSpaceFound ) { whiteSpaceFound = true ; int len = ( scanpos - datapos ) ; if ( len > 0 ) { if ( needToFlushSpace ) handler . characters ( SINGLE_SPACE , 0 , 1 ) ; handler . characters ( ch , datapos , len ) ; needToFlushSpace = true ; } datapos = scanpos + 1 ; } else { int nonwhitescan = scanpos + 1 ; for ( ; nonwhitescan < end ; nonwhitescan ++ ) { c = ch [ nonwhitescan ] ; if ( ! XMLCharacterRecognizer . isWhiteSpace ( c ) ) break ; } if ( nonwhitescan == end ) { end = scanpos ; break ; } int len = ( scanpos - datapos ) ; if ( len > 0 ) { if ( needToFlushSpace ) { handler . characters ( SINGLE_SPACE , 0 , 1 ) ; needToFlushSpace = false ; } handler . characters ( ch , datapos , len ) ; } whiteSpaceFound = false ; datapos = scanpos = nonwhitescan ; } } else { whiteSpaceFound = false ; } } if ( whiteSpaceFound ) scanpos -- ; int len = ( scanpos - datapos ) ; if ( len > 0 ) { if ( needToFlushSpace ) handler . characters ( SINGLE_SPACE , 0 , 1 ) ; handler . characters ( ch , datapos , len ) ; edgeTreatmentFlags &= ~ ( SUPPRESS_LEADING_WS | CARRY_WS ) ; } if ( whiteSpaceFound && 0 == ( edgeTreatmentFlags & SUPPRESS_TRAILING_WS ) ) { edgeTreatmentFlags |= SUPPRESS_LEADING_WS | CARRY_WS ; } return edgeTreatmentFlags ; } public static void sendNormalizedSAXcharacters ( char ch [ ] , int start , int length , org . xml . sax . ContentHandler handler ) throws org . xml . sax . SAXException { sendNormalizedSAXcharacters ( ch , start , length , handler , SUPPRESS_BOTH ) ; } public void sendSAXComment ( org . xml . sax . ext . LexicalHandler ch , int start , int length ) throws org . xml . sax . SAXException { String comment = getString ( start , length ) ; ch . comment ( comment . toCharArray ( ) , 0 , length ) ; } private void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { } private FastStringBuffer ( FastStringBuffer source ) { m_chunkBits = source . m_chunkBits ; m_maxChunkBits = source . m_maxChunkBits ; m_rebundleBits = source . m_rebundleBits ; m_chunkSize = source . m_chunkSize ; m_chunkMask = source . m_chunkMask ; m_array = source . m_array ; m_innerFSB = source . m_innerFSB ; m_lastChunk = source . m_lastChunk - 1 ; m_firstFree = source . m_chunkSize ; source . m_array = new char [ 16 ] [ ] ; source . m_innerFSB = this ; source . m_lastChunk = 1 ; source . m_firstFree = 0 ; source . m_chunkBits += m_rebundleBits ; source . m_chunkSize = 1 << ( source . m_chunkBits ) ; source . m_chunkMask = source . m_chunkSize - 1 ; } } 	1	['28', '1', '0', '20', '42', '0', '19', '1', '21', '0.62962963', '1676', '0.0625', '1', '0', '0.242798354', '0', '0', '58.28571429', '11', '3', '1']
package org . apache . xalan . extensions ; import java . util . Hashtable ; public abstract class ExtensionHandlerJava extends ExtensionHandler { protected String m_className = "" ; private Hashtable m_cachedMethods = new Hashtable ( ) ; protected ExtensionHandlerJava ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang ) ; m_className = className ; } public Object getFromCache ( Object methodKey , Object objType , Object [ ] methodArgs ) { return m_cachedMethods . get ( methodKey ) ; } public Object putToCache ( Object methodKey , Object objType , Object [ ] methodArgs , Object methodObj ) { return m_cachedMethods . put ( methodKey , methodObj ) ; } } 	0	['3', '2', '2', '3', '7', '0', '2', '1', '2', '0.5', '32', '1', '0', '0.75', '0.666666667', '0', '0', '9', '1', '0.6667', '0']
package org . apache . xalan . templates ; import java . io . BufferedInputStream ; import java . io . InputStream ; import java . io . IOException ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Enumeration ; import java . lang . Cloneable ; import org . w3c . dom . Document ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xalan . serialize . Method ; import org . apache . xalan . extensions . ExtensionHandler ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . res . XSLMessages ; import javax . xml . transform . TransformerException ; import javax . xml . transform . OutputKeys ; public class OutputProperties extends ElemTemplateElement implements Cloneable { public OutputProperties ( ) { this ( Method . XML ) ; } public OutputProperties ( Properties defaults ) { m_properties = new Properties ( defaults ) ; } public OutputProperties ( String method ) { m_properties = new Properties ( getDefaultMethodProperties ( method ) ) ; } static final String S_XSLT_PREFIX = "xslt.output." ; static final int S_XSLT_PREFIX_LEN = S_XSLT_PREFIX . length ( ) ; static final String S_XALAN_PREFIX = "org.apache.xslt." ; static final int S_XALAN_PREFIX_LEN = S_XALAN_PREFIX . length ( ) ; static final String S_BUILTIN_EXTENSIONS_UNIVERSAL = "{" + Constants . S_BUILTIN_EXTENSIONS_URL + "}" ; static private String fixupPropertyString ( String s , boolean doClipping ) { int index ; if ( doClipping && s . startsWith ( S_XSLT_PREFIX ) ) { s = s . substring ( S_XSLT_PREFIX_LEN ) ; } if ( s . startsWith ( S_XALAN_PREFIX ) ) { s = S_BUILTIN_EXTENSIONS_UNIVERSAL + s . substring ( S_XALAN_PREFIX_LEN ) ; } if ( ( index = s . indexOf ( "\\u003a" ) ) > 0 ) { String temp = s . substring ( index + 6 ) ; s = s . substring ( 0 , index ) + ":" + temp ; } return s ; } static private Properties loadPropertiesFile ( String resourceName , Properties defaults ) throws IOException { Properties props = new Properties ( defaults ) ; InputStream is = null ; BufferedInputStream bis = null ; try { try { java . lang . reflect . Method getCCL = Thread . class . getMethod ( "getContextClassLoader" , NO_CLASSES ) ; if ( getCCL != null ) { ClassLoader contextClassLoader = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; is = contextClassLoader . getResourceAsStream ( "org/apache/xalan/templates/" + resourceName ) ; } } catch ( Exception e ) { } if ( is == null ) { is = OutputProperties . class . getResourceAsStream ( resourceName ) ; } bis = new BufferedInputStream ( is ) ; props . load ( bis ) ; } catch ( IOException ioe ) { if ( defaults == null ) { throw ioe ; } else { throw new WrappedRuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_LOAD_RESOURCE , new Object [ ] { resourceName } ) , ioe ) ; } } catch ( SecurityException se ) { if ( defaults == null ) { throw se ; } else { throw new WrappedRuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_LOAD_RESOURCE , new Object [ ] { resourceName } ) , se ) ; } } finally { if ( bis != null ) { bis . close ( ) ; } if ( is != null ) { is . close ( ) ; } } Enumeration keys = ( ( Properties ) props . clone ( ) ) . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; String value = null ; try { value = System . getProperty ( key ) ; } catch ( SecurityException se ) { } if ( value == null ) value = ( String ) props . get ( key ) ; String newKey = fixupPropertyString ( key , true ) ; String newValue = null ; try { newValue = System . getProperty ( newKey ) ; } catch ( SecurityException se ) { } if ( newValue == null ) newValue = fixupPropertyString ( value , false ) ; else newValue = fixupPropertyString ( newValue , false ) ; if ( key != newKey || value != newValue ) { props . remove ( key ) ; props . put ( newKey , newValue ) ; } } return props ; } static public Properties getDefaultMethodProperties ( String method ) { String fileName = null ; Properties defaultProperties = null ; try { synchronized ( m_synch_object ) { if ( null == m_xml_properties ) { fileName = "output_xml.properties" ; m_xml_properties = loadPropertiesFile ( fileName , null ) ; } } if ( method . equals ( Method . XML ) ) { defaultProperties = m_xml_properties ; } else if ( method . equals ( Method . HTML ) ) { if ( null == m_html_properties ) { fileName = "output_html.properties" ; m_html_properties = loadPropertiesFile ( fileName , m_xml_properties ) ; } defaultProperties = m_html_properties ; } else if ( method . equals ( Method . Text ) ) { if ( null == m_text_properties ) { fileName = "output_text.properties" ; m_text_properties = loadPropertiesFile ( fileName , m_xml_properties ) ; if ( null == m_text_properties . getProperty ( OutputKeys . ENCODING ) ) { String mimeEncoding = org . apache . xalan . serialize . Encodings . getMimeEncoding ( null ) ; m_text_properties . put ( OutputKeys . ENCODING , mimeEncoding ) ; } } defaultProperties = m_text_properties ; } else { defaultProperties = m_xml_properties ; } } catch ( IOException ioe ) { throw new WrappedRuntimeException ( "Output method is " + method + " could not load " + fileName + " (check CLASSPATH)" , ioe ) ; } return defaultProperties ; } public Object clone ( ) { try { OutputProperties cloned = ( OutputProperties ) super . clone ( ) ; cloned . m_properties = ( Properties ) cloned . m_properties . clone ( ) ; return cloned ; } catch ( CloneNotSupportedException e ) { return null ; } } public void setProperty ( QName key , String value ) { setProperty ( key . toNamespacedString ( ) , value ) ; } public void setProperty ( String key , String value ) { if ( key . equals ( OutputKeys . METHOD ) ) { setMethodDefaults ( value ) ; } m_properties . put ( key , value ) ; } public String getProperty ( QName key ) { return m_properties . getProperty ( key . toNamespacedString ( ) ) ; } public String getProperty ( String key ) { return m_properties . getProperty ( key ) ; } public void setBooleanProperty ( QName key , boolean value ) { m_properties . put ( key . toNamespacedString ( ) , value ? "yes" : "no" ) ; } public void setBooleanProperty ( String key , boolean value ) { m_properties . put ( key , value ? "yes" : "no" ) ; } public boolean getBooleanProperty ( QName key ) { return getBooleanProperty ( key . toNamespacedString ( ) ) ; } public boolean getBooleanProperty ( String key ) { return getBooleanProperty ( key , m_properties ) ; } public static boolean getBooleanProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null == s || ! s . equals ( "yes" ) ) return false ; else return true ; } public void setIntProperty ( QName key , int value ) { setIntProperty ( key . toNamespacedString ( ) , value ) ; } public void setIntProperty ( String key , int value ) { m_properties . put ( key , Integer . toString ( value ) ) ; } public int getIntProperty ( QName key ) { return getIntProperty ( key . toNamespacedString ( ) ) ; } public int getIntProperty ( String key ) { return getIntProperty ( key , m_properties ) ; } public static int getIntProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null == s ) return 0 ; else return Integer . parseInt ( s ) ; } public void setQNameProperty ( QName key , QName value ) { setQNameProperty ( key . toNamespacedString ( ) , value ) ; } public void setMethodDefaults ( String method ) { String defaultMethod = m_properties . getProperty ( OutputKeys . METHOD ) ; if ( ( null == defaultMethod ) || ! defaultMethod . equals ( method ) ) { Properties savedProps = m_properties ; Properties newDefaults = getDefaultMethodProperties ( method ) ; m_properties = new Properties ( newDefaults ) ; copyFrom ( savedProps , false ) ; } } public void setQNameProperty ( String key , QName value ) { setProperty ( key , value . toNamespacedString ( ) ) ; } public QName getQNameProperty ( QName key ) { return getQNameProperty ( key . toNamespacedString ( ) ) ; } public QName getQNameProperty ( String key ) { return getQNameProperty ( key , m_properties ) ; } public static QName getQNameProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null != s ) return QName . getQNameFromString ( s ) ; else return null ; } public void setQNameProperties ( QName key , Vector v ) { setQNameProperties ( key . toNamespacedString ( ) , v ) ; } public void setQNameProperties ( String key , Vector v ) { int s = v . size ( ) ; FastStringBuffer fsb = new FastStringBuffer ( 9 , 9 ) ; for ( int i = 0 ; i < s ; i ++ ) { QName qname = ( QName ) v . elementAt ( i ) ; fsb . append ( qname . toNamespacedString ( ) ) ; if ( i < s - 1 ) fsb . append ( ' ' ) ; } m_properties . put ( key , fsb . toString ( ) ) ; } public Vector getQNameProperties ( QName key ) { return getQNameProperties ( key . toNamespacedString ( ) ) ; } public Vector getQNameProperties ( String key ) { return getQNameProperties ( key , m_properties ) ; } public static Vector getQNameProperties ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null != s ) { Vector v = new Vector ( ) ; int l = s . length ( ) ; boolean inCurly = false ; FastStringBuffer buf = new FastStringBuffer ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char c = s . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! inCurly ) { if ( buf . length ( ) > 0 ) { QName qname = QName . getQNameFromString ( buf . toString ( ) ) ; v . addElement ( qname ) ; buf . reset ( ) ; } continue ; } } else if ( '{' == c ) inCurly = true ; else if ( '}' == c ) inCurly = false ; buf . append ( c ) ; } if ( buf . length ( ) > 0 ) { QName qname = QName . getQNameFromString ( buf . toString ( ) ) ; v . addElement ( qname ) ; buf . reset ( ) ; } return v ; } else return null ; } public void recompose ( StylesheetRoot root ) throws TransformerException { root . recomposeOutput ( this ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; m_propertiesLevels = null ; } public Properties getProperties ( ) { return m_properties ; } public void copyFrom ( Properties src ) { copyFrom ( src , true ) ; } public void copyFrom ( Properties src , boolean shouldResetDefaults ) { Enumeration enum = src . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; Object oldValue = m_properties . get ( key ) ; if ( null == oldValue ) { String val = ( String ) src . get ( key ) ; if ( shouldResetDefaults && key . equals ( OutputKeys . METHOD ) ) { setMethodDefaults ( val ) ; } m_properties . put ( key , val ) ; } else if ( key . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) ) { m_properties . put ( key , ( String ) oldValue + " " + ( String ) src . get ( key ) ) ; } } } public void copyFrom ( OutputProperties opsrc ) throws TransformerException { checkDuplicates ( opsrc ) ; copyFrom ( opsrc . getProperties ( ) ) ; } private void checkDuplicates ( OutputProperties newProps ) throws TransformerException { if ( null == m_propertiesLevels ) m_propertiesLevels = new Hashtable ( ) ; int newPrecedence = newProps . getStylesheetComposed ( ) . getImportCountComposed ( ) ; Properties p = newProps . getProperties ( ) ; Enumeration enum = p . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; if ( key . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) ) continue ; Integer oldPrecedence = ( Integer ) m_propertiesLevels . get ( key ) ; if ( null == oldPrecedence ) { m_propertiesLevels . put ( key , new Integer ( newPrecedence ) ) ; } else if ( newPrecedence >= oldPrecedence . intValue ( ) ) { String oldValue = ( String ) this . m_properties . get ( key ) ; String newValue = ( String ) newProps . m_properties . get ( key ) ; if ( ( ( oldValue == null ) && ( newValue != null ) ) || ! oldValue . equals ( newValue ) ) { String msg = key + " can not be multiply defined at the same " + "import level! Old value = " + oldValue + "; New value = " + newValue ; throw new TransformerException ( msg , newProps ) ; } } } } public boolean isLegalPropertyKey ( String key ) { return ( key . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) || key . equals ( OutputKeys . DOCTYPE_PUBLIC ) || key . equals ( OutputKeys . DOCTYPE_SYSTEM ) || key . equals ( OutputKeys . ENCODING ) || key . equals ( OutputKeys . INDENT ) || key . equals ( OutputKeys . MEDIA_TYPE ) || key . equals ( OutputKeys . METHOD ) || key . equals ( OutputKeys . OMIT_XML_DECLARATION ) || key . equals ( OutputKeys . STANDALONE ) || key . equals ( OutputKeys . VERSION ) || ( key . length ( ) > 0 ) && ( key . charAt ( 0 ) == '{' ) ) ; } private transient Hashtable m_propertiesLevels ; private Properties m_properties = null ; public static String S_KEY_INDENT_AMOUNT = S_BUILTIN_EXTENSIONS_UNIVERSAL + "indent-amount" ; public static String S_KEY_CONTENT_HANDLER = S_BUILTIN_EXTENSIONS_UNIVERSAL + "content-handler" ; public static String S_KEY_ENTITIES = S_BUILTIN_EXTENSIONS_UNIVERSAL + "entities" ; public static String S_USE_URL_ESCAPING = S_BUILTIN_EXTENSIONS_UNIVERSAL + "use-url-escaping" ; public static String S_OMIT_META_TAG = S_BUILTIN_EXTENSIONS_UNIVERSAL + "omit-meta-tag" ; private static Properties m_xml_properties = null ; private static Properties m_html_properties = null ; private static Properties m_text_properties = null ; private static Integer m_synch_object = new Integer ( 1 ) ; private static final Class [ ] NO_CLASSES = new Class [ 0 ] ; private static final Object [ ] NO_OBJS = new Object [ 0 ] ; } 	1	['42', '3', '0', '18', '103', '547', '12', '8', '37', '0.918292683', '1046', '0.4', '0', '0.837606838', '0.233062331', '0', '0', '23.42857143', '13', '2', '4']
package org . apache . xpath . axes ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xpath . Expression ; import org . apache . xpath . compiler . Compiler ; public class OneStepIteratorForward extends ChildTestIterator { protected int m_axis = - 1 ; OneStepIteratorForward ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_axis = WalkerFactory . getAxisFromStep ( compiler , firstStepPos ) ; } public OneStepIteratorForward ( int axis ) { super ( null ) ; m_axis = axis ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_axis ) ; } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; return m_lastFetched ; } public int getAxis ( ) { return m_axis ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( OneStepIteratorForward ) expr ) . m_axis ) return false ; return true ; } } 	0	['6', '7', '2', '13', '16', '0', '4', '10', '4', '0.2', '94', '1', '0', '0.97080292', '0.4', '4', '10', '14.5', '3', '1.1667', '0']
package org . apache . xml . utils ; import java . io . IOException ; import java . io . Serializable ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . res . XSLMessages ; public class URI implements Serializable { public static class MalformedURIException extends IOException { public MalformedURIException ( ) { super ( ) ; } public MalformedURIException ( String p_msg ) { super ( p_msg ) ; } } private static final String RESERVED_CHARACTERS = ";/?:@&=+$," ; private static final String MARK_CHARACTERS = "-_.!~*'() " ; private static final String SCHEME_CHARACTERS = "+-." ; private static final String USERINFO_CHARACTERS = ";:&=+$," ; private String m_scheme = null ; private String m_userinfo = null ; private String m_host = null ; private int m_port = - 1 ; private String m_path = null ; private String m_queryString = null ; private String m_fragment = null ; private static boolean DEBUG = false ; public URI ( ) { } public URI ( URI p_other ) { initialize ( p_other ) ; } public URI ( String p_uriSpec ) throws MalformedURIException { this ( ( URI ) null , p_uriSpec ) ; } public URI ( URI p_base , String p_uriSpec ) throws MalformedURIException { initialize ( p_base , p_uriSpec ) ; } public URI ( String p_scheme , String p_schemeSpecificPart ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme!" ) ; } if ( p_schemeSpecificPart == null || p_schemeSpecificPart . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme-specific part!" ) ; } setScheme ( p_scheme ) ; setPath ( p_schemeSpecificPart ) ; } public URI ( String p_scheme , String p_host , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { this ( p_scheme , null , p_host , - 1 , p_path , p_queryString , p_fragment ) ; } public URI ( String p_scheme , String p_userinfo , String p_host , int p_port , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_SCHEME_REQUIRED , null ) ) ; } if ( p_host == null ) { if ( p_userinfo != null ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_USERINFO_IF_NO_HOST , null ) ) ; } if ( p_port != - 1 ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_PORT_IF_NO_HOST , null ) ) ; } } if ( p_path != null ) { if ( p_path . indexOf ( '?' ) != - 1 && p_queryString != null ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_QUERY_STRING_IN_PATH , null ) ) ; } if ( p_path . indexOf ( '#' ) != - 1 && p_fragment != null ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_FRAGMENT_STRING_IN_PATH , null ) ) ; } } setScheme ( p_scheme ) ; setHost ( p_host ) ; setPort ( p_port ) ; setUserinfo ( p_userinfo ) ; setPath ( p_path ) ; setQueryString ( p_queryString ) ; setFragment ( p_fragment ) ; } private void initialize ( URI p_other ) { m_scheme = p_other . getScheme ( ) ; m_userinfo = p_other . getUserinfo ( ) ; m_host = p_other . getHost ( ) ; m_port = p_other . getPort ( ) ; m_path = p_other . getPath ( ) ; m_queryString = p_other . getQueryString ( ) ; m_fragment = p_other . getFragment ( ) ; } private void initialize ( URI p_base , String p_uriSpec ) throws MalformedURIException { if ( p_base == null && ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_INIT_URI_EMPTY_PARMS , null ) ) ; } if ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) { initialize ( p_base ) ; return ; } String uriSpec = p_uriSpec . trim ( ) ; int uriSpecLen = uriSpec . length ( ) ; int index = 0 ; if ( uriSpec . indexOf ( ':' ) == - 1 ) { if ( p_base == null ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_SCHEME_IN_URI , new Object [ ] { uriSpec } ) ) ; } } else { initializeScheme ( uriSpec ) ; index = m_scheme . length ( ) + 1 ; } if ( ( ( index + 1 ) < uriSpecLen ) && ( uriSpec . substring ( index ) . startsWith ( "//" ) ) ) { index += 2 ; int startPos = index ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = uriSpec . charAt ( index ) ; if ( testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } if ( index > startPos ) { initializeAuthority ( uriSpec . substring ( startPos , index ) ) ; } else { m_host = "" ; } } initializePath ( uriSpec . substring ( index ) ) ; if ( p_base != null ) { if ( m_path . length ( ) == 0 && m_scheme == null && m_host == null ) { m_scheme = p_base . getScheme ( ) ; m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; m_path = p_base . getPath ( ) ; if ( m_queryString == null ) { m_queryString = p_base . getQueryString ( ) ; } return ; } if ( m_scheme == null ) { m_scheme = p_base . getScheme ( ) ; } else { return ; } if ( m_host == null ) { m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; } else { return ; } if ( m_path . length ( ) > 0 && m_path . startsWith ( "/" ) ) { return ; } String path = new String ( ) ; String basePath = p_base . getPath ( ) ; if ( basePath != null ) { int lastSlash = basePath . lastIndexOf ( '/' ) ; if ( lastSlash != - 1 ) { path = basePath . substring ( 0 , lastSlash + 1 ) ; } } path = path . concat ( m_path ) ; index = - 1 ; while ( ( index = path . indexOf ( "/./" ) ) != - 1 ) { path = path . substring ( 0 , index + 1 ) . concat ( path . substring ( index + 3 ) ) ; } if ( path . endsWith ( "/." ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } index = - 1 ; int segIndex = - 1 ; String tempString = null ; while ( ( index = path . indexOf ( "/../" ) ) > 0 ) { tempString = path . substring ( 0 , path . indexOf ( "/../" ) ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { if ( ! tempString . substring ( segIndex ++ ) . equals ( ".." ) ) { path = path . substring ( 0 , segIndex ) . concat ( path . substring ( index + 4 ) ) ; } } } if ( path . endsWith ( "/.." ) ) { tempString = path . substring ( 0 , path . length ( ) - 3 ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { path = path . substring ( 0 , segIndex + 1 ) ; } } m_path = path ; } } private void initializeScheme ( String p_uriSpec ) throws MalformedURIException { int uriSpecLen = p_uriSpec . length ( ) ; int index = 0 ; String scheme = null ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' || testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } scheme = p_uriSpec . substring ( 0 , index ) ; if ( scheme . length ( ) == 0 ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_SCHEME_INURI , null ) ) ; } else { setScheme ( scheme ) ; } } private void initializeAuthority ( String p_uriSpec ) throws MalformedURIException { int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; String userinfo = null ; if ( p_uriSpec . indexOf ( '@' , start ) != - 1 ) { while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '@' ) { break ; } index ++ ; } userinfo = p_uriSpec . substring ( start , index ) ; index ++ ; } String host = null ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' ) { break ; } index ++ ; } host = p_uriSpec . substring ( start , index ) ; int port = - 1 ; if ( host . length ( ) > 0 ) { if ( testChar == ':' ) { index ++ ; start = index ; while ( index < end ) { index ++ ; } String portStr = p_uriSpec . substring ( start , index ) ; if ( portStr . length ( ) > 0 ) { for ( int i = 0 ; i < portStr . length ( ) ; i ++ ) { if ( ! isDigit ( portStr . charAt ( i ) ) ) { throw new MalformedURIException ( portStr + " is invalid. Port should only contain digits!" ) ; } } try { port = Integer . parseInt ( portStr ) ; } catch ( NumberFormatException nfe ) { } } } } setHost ( host ) ; setPort ( port ) ; setUserinfo ( userinfo ) ; } private void initializePath ( String p_uriSpec ) throws MalformedURIException { if ( p_uriSpec == null ) { throw new MalformedURIException ( "Cannot initialize path from null string!" ) ; } int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '?' || testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , null ) ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { if ( '\\' != testChar ) throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PATH_INVALID_CHAR , new Object [ ] { String . valueOf ( testChar ) } ) ) ; } index ++ ; } m_path = p_uriSpec . substring ( start , index ) ; if ( testChar == '?' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Query string contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Query string contains invalid character:" + testChar ) ; } index ++ ; } m_queryString = p_uriSpec . substring ( start , index ) ; } if ( testChar == '#' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Fragment contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Fragment contains invalid character:" + testChar ) ; } index ++ ; } m_fragment = p_uriSpec . substring ( start , index ) ; } } public String getScheme ( ) { return m_scheme ; } public String getSchemeSpecificPart ( ) { StringBuffer schemespec = new StringBuffer ( ) ; if ( m_userinfo != null || m_host != null || m_port != - 1 ) { schemespec . append ( "//" ) ; } if ( m_userinfo != null ) { schemespec . append ( m_userinfo ) ; schemespec . append ( '@' ) ; } if ( m_host != null ) { schemespec . append ( m_host ) ; } if ( m_port != - 1 ) { schemespec . append ( ':' ) ; schemespec . append ( m_port ) ; } if ( m_path != null ) { schemespec . append ( ( m_path ) ) ; } if ( m_queryString != null ) { schemespec . append ( '?' ) ; schemespec . append ( m_queryString ) ; } if ( m_fragment != null ) { schemespec . append ( '#' ) ; schemespec . append ( m_fragment ) ; } return schemespec . toString ( ) ; } public String getUserinfo ( ) { return m_userinfo ; } public String getHost ( ) { return m_host ; } public int getPort ( ) { return m_port ; } public String getPath ( boolean p_includeQueryString , boolean p_includeFragment ) { StringBuffer pathString = new StringBuffer ( m_path ) ; if ( p_includeQueryString && m_queryString != null ) { pathString . append ( '?' ) ; pathString . append ( m_queryString ) ; } if ( p_includeFragment && m_fragment != null ) { pathString . append ( '#' ) ; pathString . append ( m_fragment ) ; } return pathString . toString ( ) ; } public String getPath ( ) { return m_path ; } public String getQueryString ( ) { return m_queryString ; } public String getFragment ( ) { return m_fragment ; } public void setScheme ( String p_scheme ) throws MalformedURIException { if ( p_scheme == null ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_SCHEME_FROM_NULL_STRING , null ) ) ; } if ( ! isConformantSchemeName ( p_scheme ) ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_SCHEME_NOT_CONFORMANT , null ) ) ; } m_scheme = p_scheme . toLowerCase ( ) ; } public void setUserinfo ( String p_userinfo ) throws MalformedURIException { if ( p_userinfo == null ) { m_userinfo = null ; } else { if ( m_host == null ) { throw new MalformedURIException ( "Userinfo cannot be set when host is null!" ) ; } int index = 0 ; int end = p_userinfo . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_userinfo . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Userinfo contains invalid escape sequence!" ) ; } } else if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { throw new MalformedURIException ( "Userinfo contains invalid character:" + testChar ) ; } index ++ ; } } m_userinfo = p_userinfo ; } public void setHost ( String p_host ) throws MalformedURIException { if ( p_host == null || p_host . trim ( ) . length ( ) == 0 ) { m_host = p_host ; m_userinfo = null ; m_port = - 1 ; } else if ( ! isWellFormedAddress ( p_host ) ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_HOST_ADDRESS_NOT_WELLFORMED , null ) ) ; } m_host = p_host ; } public void setPort ( int p_port ) throws MalformedURIException { if ( p_port >= 0 && p_port <= 65535 ) { if ( m_host == null ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PORT_WHEN_HOST_NULL , null ) ) ; } } else if ( p_port != - 1 ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_PORT , null ) ) ; } m_port = p_port ; } public void setPath ( String p_path ) throws MalformedURIException { if ( p_path == null ) { m_path = null ; m_queryString = null ; m_fragment = null ; } else { initializePath ( p_path ) ; } } public void appendPath ( String p_addToPath ) throws MalformedURIException { if ( p_addToPath == null || p_addToPath . trim ( ) . length ( ) == 0 ) { return ; } if ( ! isURIString ( p_addToPath ) ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PATH_INVALID_CHAR , new Object [ ] { p_addToPath } ) ) ; } if ( m_path == null || m_path . trim ( ) . length ( ) == 0 ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = p_addToPath ; } else { m_path = "/" + p_addToPath ; } } else if ( m_path . endsWith ( "/" ) ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; } else { m_path = m_path . concat ( p_addToPath ) ; } } else { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath ) ; } else { m_path = m_path . concat ( "/" + p_addToPath ) ; } } } public void setQueryString ( String p_queryString ) throws MalformedURIException { if ( p_queryString == null ) { m_queryString = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( "Query string can only be set for a generic URI!" ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( "Query string cannot be set when path is null!" ) ; } else if ( ! isURIString ( p_queryString ) ) { throw new MalformedURIException ( "Query string contains invalid character!" ) ; } else { m_queryString = p_queryString ; } } public void setFragment ( String p_fragment ) throws MalformedURIException { if ( p_fragment == null ) { m_fragment = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_FRAG_FOR_GENERIC_URI , null ) ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_FRAG_WHEN_PATH_NULL , null ) ) ; } else if ( ! isURIString ( p_fragment ) ) { throw new MalformedURIException ( XSLMessages . createMessage ( XSLTErrorResources . ER_FRAG_INVALID_CHAR , null ) ) ; } else { m_fragment = p_fragment ; } } public boolean equals ( Object p_test ) { if ( p_test instanceof URI ) { URI testURI = ( URI ) p_test ; if ( ( ( m_scheme == null && testURI . m_scheme == null ) || ( m_scheme != null && testURI . m_scheme != null && m_scheme . equals ( testURI . m_scheme ) ) ) && ( ( m_userinfo == null && testURI . m_userinfo == null ) || ( m_userinfo != null && testURI . m_userinfo != null && m_userinfo . equals ( testURI . m_userinfo ) ) ) && ( ( m_host == null && testURI . m_host == null ) || ( m_host != null && testURI . m_host != null && m_host . equals ( testURI . m_host ) ) ) && m_port == testURI . m_port && ( ( m_path == null && testURI . m_path == null ) || ( m_path != null && testURI . m_path != null && m_path . equals ( testURI . m_path ) ) ) && ( ( m_queryString == null && testURI . m_queryString == null ) || ( m_queryString != null && testURI . m_queryString != null && m_queryString . equals ( testURI . m_queryString ) ) ) && ( ( m_fragment == null && testURI . m_fragment == null ) || ( m_fragment != null && testURI . m_fragment != null && m_fragment . equals ( testURI . m_fragment ) ) ) ) { return true ; } } return false ; } public String toString ( ) { StringBuffer uriSpecString = new StringBuffer ( ) ; if ( m_scheme != null ) { uriSpecString . append ( m_scheme ) ; uriSpecString . append ( ':' ) ; } uriSpecString . append ( getSchemeSpecificPart ( ) ) ; return uriSpecString . toString ( ) ; } public boolean isGenericURI ( ) { return ( m_host != null ) ; } public static boolean isConformantSchemeName ( String p_scheme ) { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { return false ; } if ( ! isAlpha ( p_scheme . charAt ( 0 ) ) ) { return false ; } char testChar ; for ( int i = 1 ; i < p_scheme . length ( ) ; i ++ ) { testChar = p_scheme . charAt ( i ) ; if ( ! isAlphanum ( testChar ) && SCHEME_CHARACTERS . indexOf ( testChar ) == - 1 ) { return false ; } } return true ; } public static boolean isWellFormedAddress ( String p_address ) { if ( p_address == null ) { return false ; } String address = p_address . trim ( ) ; int addrLength = address . length ( ) ; if ( addrLength == 0 || addrLength > 255 ) { return false ; } if ( address . startsWith ( "." ) || address . startsWith ( "-" ) ) { return false ; } int index = address . lastIndexOf ( '.' ) ; if ( address . endsWith ( "." ) ) { index = address . substring ( 0 , index ) . lastIndexOf ( '.' ) ; } if ( index + 1 < addrLength && isDigit ( p_address . charAt ( index + 1 ) ) ) { char testChar ; int numDots = 0 ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isDigit ( address . charAt ( i - 1 ) ) || ( i + 1 < addrLength && ! isDigit ( address . charAt ( i + 1 ) ) ) ) { return false ; } numDots ++ ; } else if ( ! isDigit ( testChar ) ) { return false ; } } if ( numDots != 3 ) { return false ; } } else { char testChar ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isAlphanum ( address . charAt ( i - 1 ) ) ) { return false ; } if ( i + 1 < addrLength && ! isAlphanum ( address . charAt ( i + 1 ) ) ) { return false ; } } else if ( ! isAlphanum ( testChar ) && testChar != '-' ) { return false ; } } } return true ; } private static boolean isDigit ( char p_char ) { return p_char >= '0' && p_char <= '9' ; } private static boolean isHex ( char p_char ) { return ( isDigit ( p_char ) || ( p_char >= 'a' && p_char <= 'f' ) || ( p_char >= 'A' && p_char <= 'F' ) ) ; } private static boolean isAlpha ( char p_char ) { return ( ( p_char >= 'a' && p_char <= 'z' ) || ( p_char >= 'A' && p_char <= 'Z' ) ) ; } private static boolean isAlphanum ( char p_char ) { return ( isAlpha ( p_char ) || isDigit ( p_char ) ) ; } private static boolean isReservedCharacter ( char p_char ) { return RESERVED_CHARACTERS . indexOf ( p_char ) != - 1 ; } private static boolean isUnreservedCharacter ( char p_char ) { return ( isAlphanum ( p_char ) || MARK_CHARACTERS . indexOf ( p_char ) != - 1 ) ; } private static boolean isURIString ( String p_uric ) { if ( p_uric == null ) { return false ; } int end = p_uric . length ( ) ; char testChar = '\0' ; for ( int i = 0 ; i < end ; i ++ ) { testChar = p_uric . charAt ( i ) ; if ( testChar == '%' ) { if ( i + 2 >= end || ! isHex ( p_uric . charAt ( i + 1 ) ) || ! isHex ( p_uric . charAt ( i + 2 ) ) ) { return false ; } else { i += 2 ; continue ; } } if ( isReservedCharacter ( testChar ) || isUnreservedCharacter ( testChar ) ) { continue ; } else { return false ; } } return true ; } } 	1	['42', '1', '0', '3', '68', '375', '1', '2', '29', '0.780487805', '2042', '1', '0', '0', '0.226480836', '0', '0', '47.33333333', '33', '3.1429', '1']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . NodeSetDTM ; public class XNull extends XNodeSet { public XNull ( ) { super ( ) ; } public int getType ( ) { return CLASS_NULL ; } public String getTypeString ( ) { return "#CLASS_NULL" ; } public double num ( ) { return 0.0 ; } public boolean bool ( ) { return false ; } public String str ( ) { return "" ; } public int rtf ( XPathContext support ) { return DTM . NULL ; } public boolean equals ( XObject obj2 ) { return obj2 . getType ( ) == CLASS_NULL ; } } 	0	['8', '5', '0', '5', '10', '28', '2', '3', '8', '2', '31', '0', '0', '0.951048951', '0.416666667', '3', '19', '2.875', '2', '1', '0']
package org . apache . xalan . trace ; import java . util . Vector ; import java . util . TooManyListenersException ; import org . w3c . dom . Node ; import org . apache . xml . utils . QName ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . XPath ; public class TraceManager { private TransformerImpl m_transformer ; public TraceManager ( TransformerImpl transformer ) { m_transformer = transformer ; } private Vector m_traceListeners = null ; public void addTraceListener ( TraceListener tl ) throws TooManyListenersException { TransformerImpl . S_DEBUG = true ; if ( null == m_traceListeners ) m_traceListeners = new Vector ( ) ; m_traceListeners . addElement ( tl ) ; } public void removeTraceListener ( TraceListener tl ) { if ( null != m_traceListeners ) { m_traceListeners . removeElement ( tl ) ; } } public void fireGenerateEvent ( GenerateEvent te ) { if ( null != m_traceListeners ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . generated ( te ) ; } } } public boolean hasTraceListeners ( ) { return ( null != m_traceListeners ) ; } public void fireTraceEvent ( ElemTemplateElement styleNode ) { if ( hasTraceListeners ( ) ) { int sourceNode = m_transformer . getXPathContext ( ) . getCurrentNode ( ) ; Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireTraceEvent ( new TracerEvent ( m_transformer , source , m_transformer . getMode ( ) , styleNode ) ) ; } } public void fireTraceEndEvent ( ElemTemplateElement styleNode ) { if ( hasTraceListeners ( ) ) { int sourceNode = m_transformer . getXPathContext ( ) . getCurrentNode ( ) ; Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireTraceEndEvent ( new TracerEvent ( m_transformer , source , m_transformer . getMode ( ) , styleNode ) ) ; } } public void fireTraceEndEvent ( TracerEvent te ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx2 ) { ( ( TraceListenerEx2 ) tl ) . traceEnd ( te ) ; } } } } public void fireTraceEvent ( TracerEvent te ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . trace ( te ) ; } } } public void fireSelectedEvent ( int sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireSelectedEvent ( new SelectionEvent ( m_transformer , source , styleNode , attributeName , xpath , selection ) ) ; } } public void fireSelectedEndEvent ( int sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireSelectedEndEvent ( new EndSelectionEvent ( m_transformer , source , styleNode , attributeName , xpath , selection ) ) ; } } public void fireSelectedEndEvent ( EndSelectionEvent se ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx ) ( ( TraceListenerEx ) tl ) . selectEnd ( se ) ; } } } public void fireSelectedEvent ( SelectionEvent se ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . selected ( se ) ; } } } } 	1	['13', '1', '0', '40', '32', '0', '27', '14', '13', '0.333333333', '293', '1', '1', '0', '0.211538462', '0', '0', '21.38461538', '4', '1.7692', '1']
package org . apache . xalan . templates ; import org . w3c . dom . * ; import org . xml . sax . * ; import org . apache . xpath . * ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemOtherwise extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_OTHERWISE ; } public String getNodeName ( ) { return Constants . ELEMNAME_OTHERWISE_STRING ; } } 	0	['3', '3', '0', '1', '4', '3', '0', '1', '3', '2', '10', '0', '0', '0.98989899', '1', '2', '4', '2.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . trax ; import org . w3c . dom . Node ; import org . w3c . dom . Document ; import org . w3c . dom . NamedNodeMap ; import java . io . IOException ; import org . w3c . dom . Entity ; import org . w3c . dom . Notation ; import org . xml . sax . * ; import org . apache . xalan . xsltc . TransletOutputHandler ; public class DOM2TO implements XMLReader , Locator { private final static String EMPTYSTRING = "" ; private static final String XMLNS_PREFIX = "xmlns" ; private Node _dom ; private TransletOutputHandler _handler ; public DOM2TO ( Node root , TransletOutputHandler handler ) { _dom = root ; _handler = handler ; } public ContentHandler getContentHandler ( ) { return null ; } public void setContentHandler ( ContentHandler handler ) { } public void parse ( InputSource unused ) throws IOException , SAXException { parse ( _dom ) ; } public void parse ( ) throws IOException , SAXException { if ( _dom != null ) { boolean isIncomplete = ( _dom . getNodeType ( ) != org . w3c . dom . Node . DOCUMENT_NODE ) ; if ( isIncomplete ) { _handler . startDocument ( ) ; parse ( _dom ) ; _handler . endDocument ( ) ; } else { parse ( _dom ) ; } } } private void parse ( Node node ) throws IOException , SAXException { if ( node == null ) return ; switch ( node . getNodeType ( ) ) { case Node . ATTRIBUTE_NODE : case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . ENTITY_NODE : case Node . ENTITY_REFERENCE_NODE : case Node . NOTATION_NODE : break ; case Node . CDATA_SECTION_NODE : _handler . startCDATA ( ) ; _handler . characters ( node . getNodeValue ( ) ) ; _handler . endCDATA ( ) ; break ; case Node . COMMENT_NODE : _handler . comment ( node . getNodeValue ( ) ) ; break ; case Node . DOCUMENT_NODE : _handler . startDocument ( ) ; Node next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _handler . endDocument ( ) ; break ; case Node . ELEMENT_NODE : final String qname = node . getNodeName ( ) ; _handler . startElement ( qname ) ; String prefix ; final NamedNodeMap map = node . getAttributes ( ) ; final int length = map . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int colon ; final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNodeValue ( ) ; colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( colon + 1 ) : EMPTYSTRING ; _handler . namespace ( prefix , uriAttr ) ; } else { final String uriAttr = attr . getNamespaceURI ( ) ; if ( uriAttr != null && ! uriAttr . equals ( EMPTYSTRING ) ) { colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( 0 , colon ) : EMPTYSTRING ; _handler . namespace ( prefix , uriAttr ) ; } _handler . attribute ( qnameAttr , attr . getNodeValue ( ) ) ; } } final String uri = node . getNamespaceURI ( ) ; if ( uri != null ) { final int colon = qname . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qname . substring ( 0 , colon ) : EMPTYSTRING ; _handler . namespace ( prefix , uri ) ; } next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _handler . endElement ( qname ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : _handler . processingInstruction ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; break ; case Node . TEXT_NODE : _handler . characters ( node . getNodeValue ( ) ) ; break ; } } public DTDHandler getDTDHandler ( ) { return null ; } public ErrorHandler getErrorHandler ( ) { return null ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return false ; } public void setFeature ( String name , boolean value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public void parse ( String sysId ) throws IOException , SAXException { throw new IOException ( "This method is not yet implemented." ) ; } public void setDTDHandler ( DTDHandler handler ) throws NullPointerException { } public void setEntityResolver ( EntityResolver resolver ) throws NullPointerException { } public EntityResolver getEntityResolver ( ) { return null ; } public void setErrorHandler ( ErrorHandler handler ) throws NullPointerException { } public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return null ; } public int getColumnNumber ( ) { return 0 ; } public int getLineNumber ( ) { return 0 ; } public String getPublicId ( ) { return null ; } public String getSystemId ( ) { return null ; } private String getNodeTypeFromCode ( short code ) { String retval = null ; switch ( code ) { case Node . ATTRIBUTE_NODE : retval = "ATTRIBUTE_NODE" ; break ; case Node . CDATA_SECTION_NODE : retval = "CDATA_SECTION_NODE" ; break ; case Node . COMMENT_NODE : retval = "COMMENT_NODE" ; break ; case Node . DOCUMENT_FRAGMENT_NODE : retval = "DOCUMENT_FRAGMENT_NODE" ; break ; case Node . DOCUMENT_NODE : retval = "DOCUMENT_NODE" ; break ; case Node . DOCUMENT_TYPE_NODE : retval = "DOCUMENT_TYPE_NODE" ; break ; case Node . ELEMENT_NODE : retval = "ELEMENT_NODE" ; break ; case Node . ENTITY_NODE : retval = "ENTITY_NODE" ; break ; case Node . ENTITY_REFERENCE_NODE : retval = "ENTITY_REFERENCE_NODE" ; break ; case Node . NOTATION_NODE : retval = "NOTATION_NODE" ; break ; case Node . PROCESSING_INSTRUCTION_NODE : retval = "PROCESSING_INSTRUCTION_NODE" ; break ; case Node . TEXT_NODE : retval = "TEXT_NODE" ; break ; } return retval ; } } 	1	['22', '1', '0', '2', '49', '221', '1', '1', '20', '0.964285714', '327', '1', '1', '0', '0.143939394', '0', '0', '13.68181818', '2', '1', '1']
package org . apache . xpath ; public interface XPathVisitable { public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) ; } 	0	['1', '1', '0', '26', '1', '0', '24', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . runtime . output ; import java . util . Stack ; import org . apache . xalan . xsltc . * ; import org . apache . xalan . xsltc . runtime . * ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . TransletOutputHandler ; import org . apache . xalan . xsltc . runtime . Hashtable ; public abstract class OutputBase implements TransletOutputHandler , Constants { protected String _doctypeSystem = null ; protected String _doctypePublic = null ; protected int _depth = 0 ; protected Hashtable _namespaces ; protected Stack _nodeStack ; protected Stack _prefixStack ; protected Hashtable _cdata = null ; protected Stack _cdataStack ; protected boolean _cdataTagOpen = false ; protected boolean _startTagOpen = false ; protected boolean _firstElement = true ; protected void initCDATA ( ) { _cdataStack = new Stack ( ) ; _cdataStack . push ( new Integer ( - 1 ) ) ; } protected void initNamespaces ( ) { _namespaces = new Hashtable ( ) ; _nodeStack = new Stack ( ) ; _prefixStack = new Stack ( ) ; Stack stack ; _namespaces . put ( EMPTYSTRING , stack = new Stack ( ) ) ; stack . push ( EMPTYSTRING ) ; _prefixStack . push ( EMPTYSTRING ) ; _namespaces . put ( XML_PREFIX , stack = new Stack ( ) ) ; stack . push ( "http://www.w3.org/XML/1998/namespace" ) ; _prefixStack . push ( XML_PREFIX ) ; _nodeStack . push ( new Integer ( - 1 ) ) ; _depth = 0 ; } public void setDoctype ( String system , String pub ) { _doctypeSystem = system ; _doctypePublic = pub ; } public void setCdataElements ( Hashtable elements ) { _cdata = elements ; } protected static String patchName ( String qname ) throws TransletException { final int lastColon = qname . lastIndexOf ( ':' ) ; if ( lastColon > 0 ) { final int firstColon = qname . indexOf ( ':' ) ; if ( firstColon != lastColon ) { return qname . substring ( 0 , firstColon ) + qname . substring ( lastColon ) ; } } return qname ; } protected boolean pushNamespace ( String prefix , String uri ) { if ( prefix . startsWith ( XML_PREFIX ) ) { return false ; } Stack stack ; if ( ( stack = ( Stack ) _namespaces . get ( prefix ) ) == null ) { _namespaces . put ( prefix , stack = new Stack ( ) ) ; } if ( ! stack . empty ( ) && uri . equals ( stack . peek ( ) ) ) { return false ; } stack . push ( uri ) ; _prefixStack . push ( prefix ) ; _nodeStack . push ( new Integer ( _depth ) ) ; return true ; } protected boolean popNamespace ( String prefix ) { if ( prefix . startsWith ( XML_PREFIX ) ) { return false ; } Stack stack ; if ( ( stack = ( Stack ) _namespaces . get ( prefix ) ) != null ) { stack . pop ( ) ; return true ; } return false ; } protected void popNamespaces ( ) { while ( true ) { if ( _nodeStack . isEmpty ( ) ) return ; Integer i = ( Integer ) ( _nodeStack . peek ( ) ) ; if ( i . intValue ( ) != _depth ) return ; _nodeStack . pop ( ) ; popNamespace ( ( String ) _prefixStack . pop ( ) ) ; } } protected String lookupNamespace ( String prefix ) { final Stack stack = ( Stack ) _namespaces . get ( prefix ) ; return stack != null && ! stack . isEmpty ( ) ? ( String ) stack . peek ( ) : null ; } protected static String getLocalName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( col + 1 ) : qname ; } protected String getNamespaceURI ( String qname , boolean isElement ) throws TransletException { String uri = EMPTYSTRING ; int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col > 0 ) ? qname . substring ( 0 , col ) : EMPTYSTRING ; if ( prefix != EMPTYSTRING || isElement ) { uri = lookupNamespace ( prefix ) ; if ( uri == null && ! prefix . equals ( XMLNS_PREFIX ) ) { BasisLibrary . runTimeError ( BasisLibrary . NAMESPACE_PREFIX_ERR , qname . substring ( 0 , col ) ) ; } } return uri ; } public void startCDATA ( ) throws TransletException { } public void endCDATA ( ) throws TransletException { } public void namespace ( String prefix , String uri ) throws TransletException { } public void setType ( int type ) { } public void setIndent ( boolean indent ) { } public void omitHeader ( boolean value ) { } public boolean setEscaping ( boolean escape ) throws TransletException { return true ; } public void setMediaType ( String mediaType ) { } public void setStandalone ( String standalone ) { } public void setVersion ( String version ) { } public void close ( ) { } } 	1	['32', '1', '2', '12', '54', '470', '7', '5', '23', '0.95601173', '371', '1', '2', '0', '0.286458333', '0', '0', '10.25', '5', '1.3125', '1']
package org . apache . xalan . transformer ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . OneStepIteratorForward ; public class KeyIterator extends OneStepIteratorForward { private QName m_name ; public QName getName ( ) { return m_name ; } private Vector m_keyDeclarations ; public Vector getKeyDeclarations ( ) { return m_keyDeclarations ; } KeyIterator ( QName name , Vector keyDeclarations ) { super ( Axis . ALL ) ; m_keyDeclarations = keyDeclarations ; m_name = name ; } public short acceptNode ( int testNode ) { boolean foundKey = false ; KeyIterator ki = ( KeyIterator ) m_lpi ; org . apache . xpath . XPathContext xctxt = ki . getXPathContext ( ) ; Vector keys = ki . getKeyDeclarations ( ) ; QName name = ki . getName ( ) ; try { int nDeclarations = keys . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) keys . elementAt ( i ) ; if ( ! kd . getName ( ) . equals ( name ) ) continue ; foundKey = true ; XPath matchExpr = kd . getMatch ( ) ; double score = matchExpr . getMatchScore ( xctxt , testNode ) ; if ( score == kd . getMatch ( ) . MATCH_SCORE_NONE ) continue ; return DTMIterator . FILTER_ACCEPT ; } } catch ( TransformerException se ) { } if ( ! foundKey ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_XSLKEY_DECLARATION , new Object [ ] { name . getLocalName ( ) } ) ) ; return DTMIterator . FILTER_REJECT ; } } 	0	['4', '8', '0', '10', '15', '2', '2', '8', '3', '0.333333333', '97', '1', '1', '0.978571429', '0.4375', '2', '2', '22.75', '4', '1.5', '0']
package org . apache . xpath . functions ; import java . util . Vector ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xpath . objects . * ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . extensions . ExtensionsTable ; import org . apache . xml . dtm . DTMIterator ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . traversal . NodeIterator ; import org . apache . xml . dtm . * ; import org . apache . xpath . axes . * ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; public class FuncExtFunction extends Function { String m_namespace ; String m_extensionName ; Object m_methodKey ; Vector m_argVec = new Vector ( ) ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { if ( null != m_argVec ) { int nArgs = m_argVec . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; arg . fixupVariables ( vars , globalsSize ) ; } } } public String getNamespace ( ) { return m_namespace ; } public String getFunctionName ( ) { return m_extensionName ; } public FuncExtFunction ( java . lang . String namespace , java . lang . String extensionName , Object methodKey ) { m_namespace = namespace ; m_extensionName = extensionName ; m_methodKey = methodKey ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject result ; Vector argVec = new Vector ( ) ; int nArgs = m_argVec . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; XObject xobj = arg . execute ( xctxt ) ; argVec . addElement ( xobj ) ; } ExtensionsProvider extProvider = ( ExtensionsProvider ) xctxt . getOwnerObject ( ) ; Object val = extProvider . extFunction ( m_namespace , m_extensionName , argVec , m_methodKey ) ; if ( null != val ) { result = XObject . create ( val , xctxt ) ; } else { result = new XNull ( ) ; } return result ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { m_argVec . addElement ( arg ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { "Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called." } ) ; throw new RuntimeException ( fMsg ) ; } } 	1	['8', '3', '0', '11', '21', '8', '3', '8', '7', '0.714285714', '137', '0', '0', '0.844444444', '0.285714286', '2', '8', '15.625', '3', '1.125', '2']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . XPathContext ; public class Neg extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( - right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return - ( m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '6', '7', '3', '1', '5', '3', '2', '19', '0', '0', '0.952380952', '0.555555556', '1', '1', '5.333333333', '1', '0.6667', '0']
package org . apache . xalan . lib . sql ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . DriverManager ; import java . sql . SQLException ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class DefaultConnectionPool implements ConnectionPool { private static final boolean DEBUG = false ; private String m_driver = new String ( "" ) ; private String m_url = new String ( "" ) ; private int m_PoolMinSize = 1 ; private Properties m_ConnectionProtocol = new Properties ( ) ; private Vector m_pool = new Vector ( ) ; private boolean m_IsActive = false ; public DefaultConnectionPool ( ) { } public boolean isEnabled ( ) { return m_IsActive ; } public void setDriver ( String d ) { m_driver = d ; } public void setURL ( String url ) { m_url = url ; } public void freeUnused ( ) { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { if ( DEBUG ) { System . err . println ( "Closing JDBC Connection " + x ) ; } pcon . close ( ) ; } } } public boolean hasActiveConnections ( ) { return ( m_pool . size ( ) > 0 ) ; } public void setPassword ( String p ) { m_ConnectionProtocol . put ( "password" , p ) ; } public void setUser ( String u ) { m_ConnectionProtocol . put ( "user" , u ) ; } public void setProtocol ( Properties p ) { Enumeration e = p . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; m_ConnectionProtocol . put ( key , p . getProperty ( key ) ) ; } } public void setMinConnections ( int n ) { m_PoolMinSize = n ; } public boolean testConnection ( ) { try { if ( DEBUG ) { System . out . println ( "Testing Connection" ) ; } Connection conn = getConnection ( ) ; if ( DEBUG ) { DatabaseMetaData dma = conn . getMetaData ( ) ; System . out . println ( "\nConnected to " + dma . getURL ( ) ) ; System . out . println ( "Driver   " + dma . getDriverName ( ) ) ; System . out . println ( "Version  " + dma . getDriverVersion ( ) ) ; System . out . println ( "" ) ; } if ( conn == null ) return false ; releaseConnection ( conn ) ; if ( DEBUG ) { System . out . println ( "Testing Connection, SUCCESS" ) ; } return true ; } catch ( Exception e ) { if ( DEBUG ) { System . out . println ( "Testing Connection, FAILED" ) ; e . printStackTrace ( ) ; } return false ; } } public synchronized Connection getConnection ( ) throws IllegalArgumentException , SQLException { PooledConnection pcon = null ; if ( m_pool . size ( ) < m_PoolMinSize ) { initializePool ( ) ; } for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { pcon . setInUse ( true ) ; return pcon . getConnection ( ) ; } } Connection con = createConnection ( ) ; pcon = new PooledConnection ( con ) ; pcon . setInUse ( true ) ; m_pool . addElement ( pcon ) ; return pcon . getConnection ( ) ; } public synchronized void releaseConnection ( Connection con ) throws SQLException { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . getConnection ( ) == con ) { if ( DEBUG ) { System . out . println ( "Releasing Connection " + x ) ; } if ( ! isEnabled ( ) ) { con . close ( ) ; m_pool . removeElementAt ( x ) ; if ( DEBUG ) { System . out . println ( "-->Inactive Pool, Closing connection" ) ; } } else { pcon . setInUse ( false ) ; } break ; } } } public synchronized void releaseConnectionOnError ( Connection con ) throws SQLException { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . getConnection ( ) == con ) { if ( DEBUG ) { System . out . println ( "Releasing Connection On Error" + x ) ; } con . close ( ) ; m_pool . removeElementAt ( x ) ; if ( DEBUG ) { System . out . println ( "-->Inactive Pool, Closing connection" ) ; } break ; } } } private Connection createConnection ( ) throws SQLException { Connection con = null ; con = DriverManager . getConnection ( m_url , m_ConnectionProtocol ) ; return con ; } public synchronized void initializePool ( ) throws IllegalArgumentException , SQLException { if ( m_driver == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_DRIVER_NAME_SPECIFIED , null ) ) ; } if ( m_url == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_URL_SPECIFIED , null ) ) ; } if ( m_PoolMinSize < 1 ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_POOLSIZE_LESS_THAN_ONE , null ) ) ; } try { Class . forName ( m_driver ) ; } catch ( ClassNotFoundException e ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_DRIVER_NAME , null ) ) ; } if ( ! m_IsActive ) return ; do { Connection con = createConnection ( ) ; if ( con != null ) { PooledConnection pcon = new PooledConnection ( con ) ; addConnection ( pcon ) ; if ( DEBUG ) System . out . println ( "Adding DB Connection to the Pool" ) ; } } while ( m_pool . size ( ) < m_PoolMinSize ) ; } private void addConnection ( PooledConnection value ) { m_pool . addElement ( value ) ; } protected void finalize ( ) throws Throwable { if ( DEBUG ) { System . out . println ( "In Default Connection Pool, Finalize" ) ; } for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { if ( DEBUG ) { System . out . println ( "Closing JDBC Connection " + x ) ; } PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { pcon . close ( ) ; } else { if ( DEBUG ) { System . out . println ( "--> Force close" ) ; } try { java . lang . Thread . sleep ( 30000 ) ; pcon . close ( ) ; } catch ( InterruptedException ie ) { if ( DEBUG ) System . err . println ( ie . getMessage ( ) ) ; } } } if ( DEBUG ) { System . out . println ( "Exit Default Connection Pool, Finalize" ) ; } super . finalize ( ) ; } public void setPoolEnabled ( final boolean flag ) { } } 	1	['19', '1', '0', '4', '47', '57', '1', '3', '16', '0.784722222', '395', '1', '0', '0', '0.218045113', '0', '0', '19.36842105', '3', '1.2105', '3']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; import org . w3c . dom . traversal . * ; public class DTMNodeIterator implements org . w3c . dom . traversal . NodeIterator { private DTMIterator dtm_iter ; private boolean valid = true ; public DTMNodeIterator ( DTMIterator dtmIterator ) { try { dtm_iter = ( DTMIterator ) dtmIterator . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } public DTMIterator getDTMIterator ( ) { return dtm_iter ; } public void detach ( ) { valid = false ; } public boolean getExpandEntityReferences ( ) { return false ; } public NodeFilter getFilter ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public Node getRoot ( ) { int handle = dtm_iter . getRoot ( ) ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } public int getWhatToShow ( ) { return dtm_iter . getWhatToShow ( ) ; } public Node nextNode ( ) throws DOMException { if ( ! valid ) throw new DTMDOMException ( DOMException . INVALID_STATE_ERR ) ; int handle = dtm_iter . nextNode ( ) ; if ( handle == - 1 ) return null ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } public Node previousNode ( ) { if ( ! valid ) throw new DTMDOMException ( DOMException . INVALID_STATE_ERR ) ; int handle = dtm_iter . previousNode ( ) ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } } 	0	['9', '1', '0', '11', '19', '0', '7', '4', '9', '0.5', '101', '1', '1', '0', '0.555555556', '0', '0', '10', '2', '1', '0']
package org . apache . xalan . templates ; import org . apache . xml . dtm . DTM ; import org . xml . sax . * ; import org . apache . xpath . * ; import org . apache . xpath . Expression ; import org . apache . xpath . objects . XObjectFactory ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XRTreeFragSelectWrapper ; import org . apache . xml . utils . QName ; import org . apache . xalan . trace . SelectionEvent ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import javax . xml . transform . TransformerException ; public class ElemExsltFuncResult extends ElemVariable { public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext context = transformer . getXPathContext ( ) ; VariableStack varStack = context . getVarStack ( ) ; ElemExsltFunction owner = getOwnerFunction ( ) ; if ( owner != null ) { int resultIndex = owner . getResultIndex ( ) ; if ( varStack . isLocalSet ( resultIndex ) ) throw new TransformerException ( "An EXSLT function cannot set more than one result!" ) ; int sourceNode = context . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; varStack . setLocalVariable ( resultIndex , var ) ; } } public int getXSLToken ( ) { return Constants . EXSLT_ELEMNAME_FUNCRESULT ; } public String getNodeName ( ) { return Constants . EXSLT_ELEMNAME_FUNCRESULT_STRING ; } public ElemExsltFunction getOwnerFunction ( ) { ElemTemplateElement elem = this ; while ( ( elem != null ) && ! ( elem instanceof ElemExsltFunction ) ) { elem = elem . getParentElem ( ) ; } return ( ElemExsltFunction ) elem ; } } 	1	['5', '4', '0', '10', '15', '10', '3', '7', '5', '2', '62', '0', '0', '0.981900452', '0.6', '3', '7', '11.4', '3', '1.2', '1']
package org . apache . xpath . functions ; import java . util . Vector ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XNumber ; public class FuncFloor extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( java . lang . Math . floor ( m_arg0 . execute ( xctxt ) . num ( ) ) ) ; } } 	0	['2', '4', '0', '5', '7', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '0']
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . ResultTreeHandler ; import org . apache . xalan . transformer . StackGuard ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; public class ElemApplyTemplates extends ElemCallTemplate { private QName m_mode = null ; public void setMode ( QName mode ) { m_mode = mode ; } public QName getMode ( ) { return m_mode ; } private boolean m_isDefaultTemplate = false ; public void setIsDefaultTemplate ( boolean b ) { m_isDefaultTemplate = b ; } public int getXSLToken ( ) { return Constants . ELEMNAME_APPLY_TEMPLATES ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_APPLY_TEMPLATES_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { transformer . pushCurrentTemplateRuleIsNull ( false ) ; boolean pushMode = false ; try { QName mode = transformer . getMode ( ) ; if ( ! m_isDefaultTemplate ) { if ( ( ( null == mode ) && ( null != m_mode ) ) || ( ( null != mode ) && ! mode . equals ( m_mode ) ) ) { pushMode = true ; transformer . pushMode ( m_mode ) ; } } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformSelectedNodes ( transformer ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; if ( pushMode ) transformer . popMode ( ) ; transformer . popCurrentTemplateRuleIsNull ( ) ; } } public void transformSelectedNodes ( TransformerImpl transformer ) throws TransformerException { final XPathContext xctxt = transformer . getXPathContext ( ) ; final int sourceNode = xctxt . getCurrentNode ( ) ; DTMIterator sourceNodes = m_selectExpression . asIterator ( xctxt , sourceNode ) ; VariableStack vars = xctxt . getVarStack ( ) ; int nParams = getParamElemCount ( ) ; int thisframe = vars . getStackFrame ( ) ; StackGuard guard = transformer . getStackGuard ( ) ; boolean check = ( guard . getRecursionLimit ( ) > - 1 ) ? true : false ; try { final Vector keys = ( m_sortElems == null ) ? null : transformer . processSortKeys ( this , sourceNode ) ; if ( null != keys ) sourceNodes = sortNodes ( xctxt , keys , sourceNodes ) ; if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; } final ResultTreeHandler rth = transformer . getResultTreeHandler ( ) ; ContentHandler chandler = rth . getContentHandler ( ) ; final StylesheetRoot sroot = transformer . getStylesheet ( ) ; final TemplateList tl = sroot . getTemplateListComposed ( ) ; final boolean quiet = transformer . getQuietConflictWarnings ( ) ; DTM dtm = xctxt . getDTM ( sourceNode ) ; int argsFrame = - 1 ; if ( nParams > 0 ) { argsFrame = vars . link ( nParams ) ; vars . setStackFrame ( thisframe ) ; for ( int i = 0 ; i < nParams ; i ++ ) { ElemWithParam ewp = m_paramElems [ i ] ; XObject obj = ewp . getValue ( transformer , sourceNode ) ; vars . setLocalVariable ( i , obj , argsFrame ) ; } vars . setStackFrame ( argsFrame ) ; } xctxt . pushCurrentNode ( DTM . NULL ) ; int [ ] currentNodes = xctxt . getCurrentNodeStack ( ) ; int currentNodePos = xctxt . getCurrentNodeFirstFree ( ) - 1 ; xctxt . pushCurrentExpressionNode ( DTM . NULL ) ; int [ ] currentExpressionNodes = xctxt . getCurrentExpressionNodeStack ( ) ; int currentExpressionNodePos = xctxt . getCurrentExpressionNodesFirstFree ( ) - 1 ; xctxt . pushSAXLocatorNull ( ) ; xctxt . pushContextNodeList ( sourceNodes ) ; transformer . pushElemTemplateElement ( null ) ; int child ; while ( DTM . NULL != ( child = sourceNodes . nextNode ( ) ) ) { currentNodes [ currentNodePos ] = child ; currentExpressionNodes [ currentExpressionNodePos ] = child ; if ( xctxt . getDTM ( child ) != dtm ) { dtm = xctxt . getDTM ( child ) ; } final int exNodeType = dtm . getExpandedTypeID ( child ) ; final int nodeType = dtm . getNodeType ( child ) ; final QName mode = transformer . getMode ( ) ; ElemTemplate template = tl . getTemplateFast ( xctxt , child , exNodeType , mode , - 1 , quiet , dtm ) ; if ( null == template ) { switch ( nodeType ) { case DTM . DOCUMENT_FRAGMENT_NODE : case DTM . ELEMENT_NODE : template = sroot . getDefaultRule ( ) ; break ; case DTM . ATTRIBUTE_NODE : case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : transformer . pushPairCurrentMatched ( sroot . getDefaultTextRule ( ) , child ) ; transformer . setCurrentElement ( sroot . getDefaultTextRule ( ) ) ; dtm . dispatchCharactersEvents ( child , rth , false ) ; transformer . popCurrentMatched ( ) ; continue ; case DTM . DOCUMENT_NODE : template = sroot . getDefaultRootRule ( ) ; break ; default : continue ; } } else { transformer . setCurrentElement ( template ) ; } transformer . pushPairCurrentMatched ( template , child ) ; if ( check ) guard . checkForInfinateLoop ( ) ; int currentFrameBottom ; if ( template . m_frameSize > 0 ) { xctxt . pushRTFContext ( ) ; currentFrameBottom = vars . getStackFrame ( ) ; vars . link ( template . m_frameSize ) ; if ( template . m_inArgsSize > 0 ) { int paramIndex = 0 ; for ( ElemTemplateElement elem = template . getFirstChildElem ( ) ; null != elem ; elem = elem . getNextSiblingElem ( ) ) { if ( Constants . ELEMNAME_PARAMVARIABLE == elem . getXSLToken ( ) ) { ElemParam ep = ( ElemParam ) elem ; int i ; for ( i = 0 ; i < nParams ; i ++ ) { ElemWithParam ewp = m_paramElems [ i ] ; if ( ewp . m_qnameID == ep . m_qnameID ) { XObject obj = vars . getLocalVariable ( i , argsFrame ) ; vars . setLocalVariable ( paramIndex , obj ) ; break ; } } if ( i == nParams ) vars . setLocalVariable ( paramIndex , null ) ; } else break ; paramIndex ++ ; } } } else currentFrameBottom = 0 ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( template ) ; for ( ElemTemplateElement t = template . m_firstChild ; t != null ; t = t . m_nextSibling ) { xctxt . setSAXLocator ( t ) ; try { transformer . pushElemTemplateElement ( t ) ; t . execute ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; } } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( template ) ; if ( template . m_frameSize > 0 ) { vars . unlink ( currentFrameBottom ) ; xctxt . popRTFContext ( ) ; } transformer . popCurrentMatched ( ) ; } } catch ( SAXException se ) { transformer . getErrorListener ( ) . fatalError ( new TransformerException ( se ) ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEndEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; if ( nParams > 0 ) vars . unlink ( thisframe ) ; xctxt . popSAXLocator ( ) ; xctxt . popContextNodeList ( ) ; transformer . popElemTemplateElement ( ) ; xctxt . popCurrentExpressionNode ( ) ; xctxt . popCurrentNode ( ) ; sourceNodes . detach ( ) ; } } } 	1	['9', '5', '0', '21', '84', '20', '1', '21', '9', '0.6875', '586', '1', '1', '0.965811966', '0.311111111', '5', '10', '63.88888889', '1', '0.8889', '1']
package org . apache . xalan . lib ; import org . w3c . dom . Node ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . w3c . dom . traversal . NodeIterator ; import org . apache . xpath . NodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . DOMHelper ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xml . utils . XMLString ; import org . xml . sax . SAXNotSupportedException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . xslt . EnvironmentCheck ; import javax . xml . parsers . * ; public class ExsltCommon { public static String objectType ( Object obj ) { if ( obj instanceof String ) return "string" ; else if ( obj instanceof Boolean ) return "boolean" ; else if ( obj instanceof Number ) return "number" ; else if ( obj instanceof DTMNodeIterator ) { DTMIterator dtmI = ( ( DTMNodeIterator ) obj ) . getDTMIterator ( ) ; if ( dtmI instanceof org . apache . xpath . axes . RTFIterator ) return "RTF" ; else return "node-set" ; } else return "unknown" ; } public static NodeSet nodeSet ( ExpressionContext myProcessor , Object rtf ) { return Extensions . nodeset ( myProcessor , rtf ) ; } } 	0	['3', '1', '0', '6', '6', '3', '0', '6', '3', '2', '41', '0', '0', '0', '0.444444444', '0', '0', '12.66666667', '6', '2.3333', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . NodeIterator ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; public final class UnionIterator extends NodeIteratorBase { final private DOM _dom ; private final static class LookAheadIterator { public int node , markedNode ; public final NodeIterator iterator ; public LookAheadIterator ( NodeIterator iterator ) { this . iterator = iterator ; } public int step ( ) { node = iterator . next ( ) ; return node ; } public void setMark ( ) { markedNode = node ; iterator . setMark ( ) ; } public void gotoMark ( ) { node = markedNode ; iterator . gotoMark ( ) ; } } private static final int InitSize = 8 ; private int _heapSize = 0 ; private int _size = InitSize ; private LookAheadIterator [ ] _heap = new LookAheadIterator [ InitSize ] ; private int _free = 0 ; private int _returnedLast ; public UnionIterator ( DOM dom ) { _dom = dom ; } public NodeIterator cloneIterator ( ) { final LookAheadIterator [ ] heapCopy = new LookAheadIterator [ _heap . length ] ; try { final UnionIterator clone = ( UnionIterator ) super . clone ( ) ; System . arraycopy ( _heap , 0 , heapCopy , 0 , _heap . length ) ; clone . setRestartable ( false ) ; clone . _heap = heapCopy ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public UnionIterator addIterator ( NodeIterator iterator ) { if ( _free == _size ) { LookAheadIterator [ ] newArray = new LookAheadIterator [ _size *= 2 ] ; System . arraycopy ( _heap , 0 , newArray , 0 , _free ) ; _heap = newArray ; } _heapSize ++ ; _heap [ _free ++ ] = new LookAheadIterator ( iterator ) ; return this ; } public int next ( ) { while ( _heapSize > 0 ) { final int smallest = _heap [ 0 ] . node ; if ( smallest == END ) { if ( _heapSize > 1 ) { final LookAheadIterator temp = _heap [ 0 ] ; _heap [ 0 ] = _heap [ -- _heapSize ] ; _heap [ _heapSize ] = temp ; } else { return END ; } } else if ( smallest == _returnedLast ) { _heap [ 0 ] . step ( ) ; } else { _heap [ 0 ] . step ( ) ; heapify ( 0 ) ; return returnNode ( _returnedLast = smallest ) ; } heapify ( 0 ) ; } return END ; } public NodeIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . iterator . setStartNode ( node ) ; _heap [ i ] . step ( ) ; } for ( int i = ( _heapSize = _free ) / 2 ; i >= 0 ; i -- ) { heapify ( i ) ; } _returnedLast = END ; return resetPosition ( ) ; } return this ; } private void heapify ( int i ) { for ( int r , l , smallest ; ; ) { r = ( i + 1 ) << 1 ; l = r - 1 ; smallest = l < _heapSize && _dom . lessThan ( _heap [ l ] . node , _heap [ i ] . node ) ? l : i ; if ( r < _heapSize && _dom . lessThan ( _heap [ r ] . node , _heap [ smallest ] . node ) ) { smallest = r ; } if ( smallest != i ) { final LookAheadIterator temp = _heap [ smallest ] ; _heap [ smallest ] = _heap [ i ] ; _heap [ i ] = temp ; i = smallest ; } else break ; } } public void setMark ( ) { for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . setMark ( ) ; } } public void gotoMark ( ) { for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . gotoMark ( ) ; } } public NodeIterator reset ( ) { super . reset ( ) ; for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . iterator . reset ( ) ; } return resetPosition ( ) ; } } 	1	['9', '2', '0', '6', '25', '0', '1', '5', '8', '0.607142857', '369', '1', '2', '0.555555556', '0.361111111', '1', '6', '39.22222222', '6', '2.6667', '2']
package org . apache . xpath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; import javax . xml . transform . TransformerException ; public class VariableStack implements Cloneable { public VariableStack ( ) { reset ( ) ; } public synchronized Object clone ( ) throws CloneNotSupportedException { VariableStack vs = ( VariableStack ) super . clone ( ) ; vs . _stackFrames = ( XObject [ ] ) _stackFrames . clone ( ) ; vs . _links = ( int [ ] ) _links . clone ( ) ; return vs ; } XObject [ ] _stackFrames = new XObject [ XPathContext . RECURSIONLIMIT * 2 ] ; int _frameTop ; private int _currentFrameBottom ; int [ ] _links = new int [ XPathContext . RECURSIONLIMIT ] ; int _linksTop ; public XObject elementAt ( final int i ) { return _stackFrames [ i ] ; } public int size ( ) { return _frameTop ; } public void reset ( ) { _frameTop = 0 ; _linksTop = 0 ; _links [ _linksTop ++ ] = 0 ; _stackFrames = new XObject [ _stackFrames . length ] ; } public void setStackFrame ( int sf ) { _currentFrameBottom = sf ; } public int getStackFrame ( ) { return _currentFrameBottom ; } public int link ( final int size ) { _currentFrameBottom = _frameTop ; _frameTop += size ; if ( _frameTop >= _stackFrames . length ) { XObject newsf [ ] = new XObject [ _stackFrames . length + ( 1024 * 4 ) + size ] ; System . arraycopy ( _stackFrames , 0 , newsf , 0 , _stackFrames . length ) ; _stackFrames = newsf ; } if ( _linksTop + 1 >= _links . length ) { int newlinks [ ] = new int [ _links . length + ( 1024 * 2 ) ] ; System . arraycopy ( _links , 0 , newlinks , 0 , _links . length ) ; _links = newlinks ; } _links [ _linksTop ++ ] = _currentFrameBottom ; return _currentFrameBottom ; } public void unlink ( ) { _frameTop = _links [ -- _linksTop ] ; _currentFrameBottom = _links [ _linksTop - 1 ] ; } public void unlink ( int currentFrame ) { _frameTop = _links [ -- _linksTop ] ; _currentFrameBottom = currentFrame ; } public void setLocalVariable ( int index , XObject val ) { _stackFrames [ index + _currentFrameBottom ] = val ; } public void setLocalVariable ( int index , XObject val , int stackFrame ) { _stackFrames [ index + stackFrame ] = val ; } public XObject getLocalVariable ( XPathContext xctxt , int index ) throws TransformerException { index += _currentFrameBottom ; XObject val = _stackFrames [ index ] ; if ( null == val ) throw new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VARIABLE_ACCESSED_BEFORE_BIND , null ) , xctxt . getSAXLocator ( ) ) ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return val ; } public XObject getLocalVariable ( int index , int frame ) throws TransformerException { index += frame ; XObject val = _stackFrames [ index ] ; return val ; } public XObject getLocalVariable ( XPathContext xctxt , int index , boolean destructiveOK ) throws TransformerException { index += _currentFrameBottom ; XObject val = _stackFrames [ index ] ; if ( null == val ) throw new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VARIABLE_ACCESSED_BEFORE_BIND , null ) , xctxt . getSAXLocator ( ) ) ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return destructiveOK ? val : val . getFresh ( ) ; } public boolean isLocalSet ( int index ) throws TransformerException { return ( _stackFrames [ index + _currentFrameBottom ] != null ) ; } private static XObject [ ] m_nulls = new XObject [ 1024 ] ; public void clearLocalSlots ( int start , int len ) { start += _currentFrameBottom ; System . arraycopy ( m_nulls , 0 , _stackFrames , start , len ) ; } public void setGlobalVariable ( final int index , final XObject val ) { _stackFrames [ index ] = val ; } public XObject getGlobalVariable ( XPathContext xctxt , final int index ) throws TransformerException { XObject val = _stackFrames [ index ] ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return val ; } public XObject getGlobalVariable ( XPathContext xctxt , final int index , boolean destructiveOK ) throws TransformerException { XObject val = _stackFrames [ index ] ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return destructiveOK ? val : val . getFresh ( ) ; } public XObject getVariableOrParam ( XPathContext xctxt , org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException { org . apache . xml . utils . PrefixResolver prefixResolver = xctxt . getNamespaceContext ( ) ; if ( prefixResolver instanceof org . apache . xalan . templates . ElemTemplateElement ) { org . apache . xalan . templates . ElemVariable vvar ; org . apache . xalan . templates . ElemTemplateElement prev = ( org . apache . xalan . templates . ElemTemplateElement ) prefixResolver ; if ( ! ( prev instanceof org . apache . xalan . templates . Stylesheet ) ) { while ( ! ( prev . getParentNode ( ) instanceof org . apache . xalan . templates . Stylesheet ) ) { org . apache . xalan . templates . ElemTemplateElement savedprev = prev ; while ( null != ( prev = prev . getPreviousSiblingElem ( ) ) ) { if ( prev instanceof org . apache . xalan . templates . ElemVariable ) { vvar = ( org . apache . xalan . templates . ElemVariable ) prev ; if ( vvar . getName ( ) . equals ( qname ) ) return getLocalVariable ( xctxt , vvar . getIndex ( ) ) ; } } prev = savedprev . getParentElem ( ) ; } } vvar = prev . getStylesheetRoot ( ) . getVariableOrParamComposed ( qname ) ; if ( null != vvar ) return getGlobalVariable ( xctxt , vvar . getIndex ( ) ) ; } throw new javax . xml . transform . TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VAR_NOT_RESOLVABLE , new Object [ ] { qname . toString ( ) } ) ) ; } } 	0	['22', '1', '0', '27', '42', '0', '20', '9', '21', '0.682539683', '476', '0.333333333', '2', '0', '0.365079365', '0', '0', '20.36363636', '3', '1', '0']
package org . apache . xml . dtm . ref . dom2dtm ; import org . apache . xml . dtm . ref . * ; import org . apache . xml . dtm . * ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . w3c . dom . * ; import java . util . Vector ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . SourceLocator ; import org . xml . sax . ContentHandler ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . res . XSLMessages ; public class DOM2DTM extends DTMDefaultBaseIterators { static final boolean JJK_DEBUG = false ; static final boolean JJK_NEWCODE = true ; static final String NAMESPACE_DECL_NS = "http://www.w3.org/XML/1998/namespace" ; transient private Node m_pos ; private int m_last_parent = 0 ; private int m_last_kid = NULL ; transient private Node m_root ; boolean m_processedFirstElement = false ; transient private boolean m_nodesAreProcessed ; protected Vector m_nodes = new Vector ( ) ; public DOM2DTM ( DTMManager mgr , DOMSource domSource , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , domSource , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; m_pos = m_root = domSource . getNode ( ) ; m_last_parent = m_last_kid = NULL ; m_last_kid = addNode ( m_root , m_last_parent , m_last_kid , NULL ) ; if ( ELEMENT_NODE == m_root . getNodeType ( ) ) { NamedNodeMap attrs = m_root . getAttributes ( ) ; int attrsize = ( attrs == null ) ? 0 : attrs . getLength ( ) ; if ( attrsize > 0 ) { int attrIndex = NULL ; for ( int i = 0 ; i < attrsize ; ++ i ) { attrIndex = addNode ( attrs . item ( i ) , 0 , attrIndex , NULL ) ; m_firstch . setElementAt ( DTM . NULL , attrIndex ) ; } m_nextsib . setElementAt ( DTM . NULL , attrIndex ) ; } } m_nodesAreProcessed = false ; } protected int addNode ( Node node , int parentIndex , int previousSibling , int forceNodeType ) { int nodeIndex = m_nodes . size ( ) ; if ( m_dtmIdent . size ( ) == ( nodeIndex > > > DTMManager . IDENT_DTM_NODE_BITS ) ) { try { if ( m_mgr == null ) throw new ClassCastException ( ) ; DTMManagerDefault mgrD = ( DTMManagerDefault ) m_mgr ; int id = mgrD . getFirstFreeDTMID ( ) ; mgrD . addDTM ( this , id , nodeIndex ) ; m_dtmIdent . addElement ( id << DTMManager . IDENT_DTM_NODE_BITS ) ; } catch ( ClassCastException e ) { error ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } } m_size ++ ; int type ; if ( NULL == forceNodeType ) type = node . getNodeType ( ) ; else type = forceNodeType ; if ( Node . ATTRIBUTE_NODE == type ) { String name = node . getNodeName ( ) ; if ( name . startsWith ( "xmlns:" ) || name . equals ( "xmlns" ) ) { type = DTM . NAMESPACE_NODE ; } } m_nodes . addElement ( node ) ; m_firstch . setElementAt ( NOTPROCESSED , nodeIndex ) ; m_nextsib . setElementAt ( NOTPROCESSED , nodeIndex ) ; m_prevsib . setElementAt ( previousSibling , nodeIndex ) ; m_parent . setElementAt ( parentIndex , nodeIndex ) ; if ( DTM . NULL != parentIndex && type != DTM . ATTRIBUTE_NODE && type != DTM . NAMESPACE_NODE ) { if ( NOTPROCESSED == m_firstch . elementAt ( parentIndex ) ) m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } String nsURI = node . getNamespaceURI ( ) ; String localName = ( type == Node . PROCESSING_INSTRUCTION_NODE ) ? node . getNodeName ( ) : node . getLocalName ( ) ; if ( ( ( type == Node . ELEMENT_NODE ) || ( type == Node . ATTRIBUTE_NODE ) ) && null == localName ) localName = node . getNodeName ( ) ; ExpandedNameTable exnt = m_expandedNameTable ; if ( node . getLocalName ( ) == null && ( type == Node . ELEMENT_NODE || type == Node . ATTRIBUTE_NODE ) ) { } int expandedNameID = ( null != localName ) ? exnt . getExpandedTypeID ( nsURI , localName , type ) : exnt . getExpandedTypeID ( type ) ; m_exptype . setElementAt ( expandedNameID , nodeIndex ) ; indexNode ( expandedNameID , nodeIndex ) ; if ( DTM . NULL != previousSibling ) m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; if ( type == DTM . NAMESPACE_NODE ) declareNamespaceInContext ( parentIndex , nodeIndex ) ; return nodeIndex ; } protected int getNumberOfNodes ( ) { return m_nodes . size ( ) ; } protected boolean nextNode ( ) { if ( m_nodesAreProcessed ) return false ; Node pos = m_pos ; Node next = null ; int nexttype = NULL ; do { if ( pos . hasChildNodes ( ) ) { next = pos . getFirstChild ( ) ; if ( next != null && DOCUMENT_TYPE_NODE == next . getNodeType ( ) ) next = next . getNextSibling ( ) ; if ( ENTITY_REFERENCE_NODE != pos . getNodeType ( ) ) { m_last_parent = m_last_kid ; m_last_kid = NULL ; if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( m_last_parent ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } } } else { if ( m_last_kid != NULL ) { if ( m_firstch . elementAt ( m_last_kid ) == NOTPROCESSED ) m_firstch . setElementAt ( NULL , m_last_kid ) ; } while ( m_last_parent != NULL ) { next = pos . getNextSibling ( ) ; if ( next != null && DOCUMENT_TYPE_NODE == next . getNodeType ( ) ) next = next . getNextSibling ( ) ; if ( next != null ) break ; pos = pos . getParentNode ( ) ; if ( pos == null ) { if ( JJK_DEBUG ) { System . out . println ( "***** DOM2DTM Pop Control Flow problem" ) ; for ( ; ; ) ; } } if ( pos != null && ENTITY_REFERENCE_NODE == pos . getNodeType ( ) ) { if ( JJK_DEBUG ) System . out . println ( "***** DOM2DTM popping EntRef" ) ; } else { popShouldStripWhitespace ( ) ; if ( m_last_kid == NULL ) m_firstch . setElementAt ( NULL , m_last_parent ) ; else m_nextsib . setElementAt ( NULL , m_last_kid ) ; m_last_parent = m_parent . elementAt ( m_last_kid = m_last_parent ) ; } } if ( m_last_parent == NULL ) next = null ; } if ( next != null ) nexttype = next . getNodeType ( ) ; if ( ENTITY_REFERENCE_NODE == nexttype ) pos = next ; } while ( ENTITY_REFERENCE_NODE == nexttype ) ; if ( next == null ) { m_nextsib . setElementAt ( NULL , 0 ) ; m_nodesAreProcessed = true ; m_pos = null ; if ( JJK_DEBUG ) { System . out . println ( "***** DOM2DTM Crosscheck:" ) ; for ( int i = 0 ; i < m_nodes . size ( ) ; ++ i ) System . out . println ( i + ":\t" + m_firstch . elementAt ( i ) + "\t" + m_nextsib . elementAt ( i ) ) ; } return false ; } boolean suppressNode = false ; Node lastTextNode = null ; nexttype = next . getNodeType ( ) ; if ( TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype ) { suppressNode = ( ( null != m_wsfilter ) && getShouldStripWhitespace ( ) ) ; Node n = next ; while ( n != null ) { lastTextNode = n ; if ( TEXT_NODE == n . getNodeType ( ) ) nexttype = TEXT_NODE ; suppressNode &= XMLCharacterRecognizer . isWhiteSpace ( n . getNodeValue ( ) ) ; n = logicalNextDOMTextNode ( n ) ; } } else if ( PROCESSING_INSTRUCTION_NODE == nexttype ) { suppressNode = ( pos . getNodeName ( ) . toLowerCase ( ) . equals ( "xml" ) ) ; } if ( ! suppressNode ) { int nextindex = addNode ( next , m_last_parent , m_last_kid , nexttype ) ; m_last_kid = nextindex ; if ( ELEMENT_NODE == nexttype ) { int attrIndex = NULL ; NamedNodeMap attrs = next . getAttributes ( ) ; int attrsize = ( attrs == null ) ? 0 : attrs . getLength ( ) ; if ( attrsize > 0 ) { for ( int i = 0 ; i < attrsize ; ++ i ) { attrIndex = addNode ( attrs . item ( i ) , nextindex , attrIndex , NULL ) ; m_firstch . setElementAt ( DTM . NULL , attrIndex ) ; if ( ! m_processedFirstElement && "xmlns:xml" . equals ( attrs . item ( i ) . getNodeName ( ) ) ) m_processedFirstElement = true ; } } if ( ! m_processedFirstElement ) { attrIndex = addNode ( new DOM2DTMdefaultNamespaceDeclarationNode ( ( Element ) next , "xml" , NAMESPACE_DECL_NS , makeNodeHandle ( ( ( attrIndex == NULL ) ? nextindex : attrIndex ) + 1 ) ) , nextindex , attrIndex , NULL ) ; m_firstch . setElementAt ( DTM . NULL , attrIndex ) ; m_processedFirstElement = true ; } if ( attrIndex != NULL ) m_nextsib . setElementAt ( DTM . NULL , attrIndex ) ; } } if ( TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype ) { next = lastTextNode ; } m_pos = next ; return true ; } public Node getNode ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; return ( Node ) m_nodes . elementAt ( identity ) ; } protected Node lookupNode ( int nodeIdentity ) { return ( Node ) m_nodes . elementAt ( nodeIdentity ) ; } protected int getNextNodeIdentity ( int identity ) { identity += 1 ; if ( identity >= m_nodes . size ( ) ) { if ( ! nextNode ( ) ) identity = DTM . NULL ; } return identity ; } private int getHandleFromNode ( Node node ) { if ( null != node ) { int len = m_nodes . size ( ) ; boolean isMore ; int i = 0 ; do { for ( ; i < len ; i ++ ) { if ( m_nodes . elementAt ( i ) == node ) return makeNodeHandle ( i ) ; } isMore = nextNode ( ) ; len = m_nodes . size ( ) ; } while ( isMore || i < len ) ; } return DTM . NULL ; } public int getHandleOfNode ( Node node ) { if ( null != node ) { if ( ( m_root == node ) || ( m_root . getNodeType ( ) == DOCUMENT_NODE && m_root == node . getOwnerDocument ( ) ) || ( m_root . getNodeType ( ) != DOCUMENT_NODE && m_root . getOwnerDocument ( ) == node . getOwnerDocument ( ) ) ) { for ( Node cursor = node ; cursor != null ; cursor = ( cursor . getNodeType ( ) != ATTRIBUTE_NODE ) ? cursor . getParentNode ( ) : ( ( org . w3c . dom . Attr ) cursor ) . getOwnerElement ( ) ) { if ( cursor == m_root ) return getHandleFromNode ( node ) ; } } } return DTM . NULL ; } public int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) { if ( null == namespaceURI ) namespaceURI = "" ; int type = getNodeType ( nodeHandle ) ; if ( DTM . ELEMENT_NODE == type ) { int identity = makeNodeIdentity ( nodeHandle ) ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { type = _type ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE || type == DTM . NAMESPACE_NODE ) { Node node = lookupNode ( identity ) ; String nodeuri = node . getNamespaceURI ( ) ; if ( null == nodeuri ) nodeuri = "" ; String nodelocalname = node . getLocalName ( ) ; if ( nodeuri . equals ( namespaceURI ) && name . equals ( nodelocalname ) ) return makeNodeHandle ( identity ) ; } else { break ; } } } return DTM . NULL ; } public XMLString getStringValue ( int nodeHandle ) { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { getNodeData ( node , buf ) ; s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; } finally { StringBufferPool . free ( buf ) ; } return m_xstrf . newstr ( s ) ; } else if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; while ( node != null ) { buf . append ( node . getNodeValue ( ) ) ; node = logicalNextDOMTextNode ( node ) ; } String s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; StringBufferPool . free ( buf ) ; return m_xstrf . newstr ( s ) ; } else return m_xstrf . newstr ( node . getNodeValue ( ) ) ; } protected static void getNodeData ( Node node , FastStringBuffer buf ) { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { getNodeData ( child , buf ) ; } } break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : buf . append ( node . getNodeValue ( ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : break ; default : break ; } } public String getNodeName ( int nodeHandle ) { Node node = getNode ( nodeHandle ) ; return node . getNodeName ( ) ; } public String getNodeNameX ( int nodeHandle ) { String name ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . NAMESPACE_NODE : { Node node = getNode ( nodeHandle ) ; name = node . getNodeName ( ) ; if ( name . startsWith ( "xmlns:" ) ) { name = QName . getLocalPart ( name ) ; } else if ( name . equals ( "xmlns" ) ) { name = "" ; } } break ; case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : case DTM . ENTITY_REFERENCE_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : { Node node = getNode ( nodeHandle ) ; name = node . getNodeName ( ) ; } break ; default : name = "" ; } return name ; } public String getLocalName ( int nodeHandle ) { if ( JJK_NEWCODE ) { int id = makeNodeIdentity ( nodeHandle ) ; if ( NULL == id ) return null ; Node newnode = ( Node ) m_nodes . elementAt ( id ) ; String newname = newnode . getLocalName ( ) ; if ( null == newname ) { String qname = newnode . getNodeName ( ) ; if ( '#' == newnode . getNodeName ( ) . charAt ( 0 ) ) { newname = "" ; } else { int index = qname . indexOf ( ':' ) ; newname = ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } } return newname ; } else { String name ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : case DTM . ENTITY_REFERENCE_NODE : case DTM . NAMESPACE_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : { Node node = getNode ( nodeHandle ) ; name = node . getLocalName ( ) ; if ( null == name ) { String qname = node . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; name = ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } } break ; default : name = "" ; } return name ; } } public String getPrefix ( int nodeHandle ) { String prefix ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . NAMESPACE_NODE : { Node node = getNode ( nodeHandle ) ; String qname = node . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; prefix = ( index < 0 ) ? "" : qname . substring ( index + 1 ) ; } break ; case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : { Node node = getNode ( nodeHandle ) ; String qname = node . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; prefix = ( index < 0 ) ? "" : qname . substring ( 0 , index ) ; } break ; default : prefix = "" ; } return prefix ; } public String getNamespaceURI ( int nodeHandle ) { if ( JJK_NEWCODE ) { int id = makeNodeIdentity ( nodeHandle ) ; if ( id == NULL ) return null ; Node node = ( Node ) m_nodes . elementAt ( id ) ; return node . getNamespaceURI ( ) ; } else { String nsuri ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : case DTM . ENTITY_REFERENCE_NODE : case DTM . NAMESPACE_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : { Node node = getNode ( nodeHandle ) ; nsuri = node . getNamespaceURI ( ) ; } break ; default : nsuri = null ; } return nsuri ; } } private Node logicalNextDOMTextNode ( Node n ) { Node p = n . getNextSibling ( ) ; if ( p == null ) { for ( n = n . getParentNode ( ) ; n != null && ENTITY_REFERENCE_NODE == n . getNodeType ( ) ; n = n . getParentNode ( ) ) { p = n . getNextSibling ( ) ; if ( p != null ) break ; } } n = p ; while ( n != null && ENTITY_REFERENCE_NODE == n . getNodeType ( ) ) { if ( n . hasChildNodes ( ) ) n = n . getFirstChild ( ) ; else n = n . getNextSibling ( ) ; } if ( n != null ) { int ntype = n . getNodeType ( ) ; if ( TEXT_NODE != ntype && CDATA_SECTION_NODE != ntype ) n = null ; } return n ; } public String getNodeValue ( int nodeHandle ) { int type = _exptype ( makeNodeIdentity ( nodeHandle ) ) ; type = ( NULL != type ) ? getNodeType ( nodeHandle ) : NULL ; if ( TEXT_NODE != type && CDATA_SECTION_NODE != type ) return getNode ( nodeHandle ) . getNodeValue ( ) ; Node node = getNode ( nodeHandle ) ; Node n = logicalNextDOMTextNode ( node ) ; if ( n == null ) return node . getNodeValue ( ) ; FastStringBuffer buf = StringBufferPool . get ( ) ; buf . append ( node . getNodeValue ( ) ) ; while ( n != null ) { buf . append ( n . getNodeValue ( ) ) ; n = logicalNextDOMTextNode ( n ) ; } String s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; StringBufferPool . free ( buf ) ; return s ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { Document doc ; if ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) doc = ( Document ) m_root ; else doc = m_root . getOwnerDocument ( ) ; if ( null != doc ) { DocumentType dtd = doc . getDoctype ( ) ; if ( null != dtd ) { return dtd . getSystemId ( ) ; } } return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { Document doc ; if ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) doc = ( Document ) m_root ; else doc = m_root . getOwnerDocument ( ) ; if ( null != doc ) { DocumentType dtd = doc . getDoctype ( ) ; if ( null != dtd ) { return dtd . getPublicId ( ) ; } } return null ; } public int getElementById ( String elementId ) { Document doc = ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( Document ) m_root : m_root . getOwnerDocument ( ) ; if ( null != doc ) { Node elem = doc . getElementById ( elementId ) ; if ( null != elem ) { int elemHandle = getHandleFromNode ( elem ) ; if ( DTM . NULL == elemHandle ) { int identity = m_nodes . size ( ) - 1 ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { Node node = getNode ( identity ) ; if ( node == elem ) { elemHandle = getHandleFromNode ( elem ) ; break ; } } } return elemHandle ; } } return DTM . NULL ; } public String getUnparsedEntityURI ( String name ) { String url = "" ; Document doc = ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( Document ) m_root : m_root . getOwnerDocument ( ) ; if ( null != doc ) { DocumentType doctype = doc . getDoctype ( ) ; if ( null != doctype ) { NamedNodeMap entities = doctype . getEntities ( ) ; if ( null == entities ) return url ; Entity entity = ( Entity ) entities . getNamedItem ( name ) ; if ( null == entity ) return url ; String notationName = entity . getNotationName ( ) ; if ( null != notationName ) { url = entity . getSystemId ( ) ; if ( null == url ) { url = entity . getPublicId ( ) ; } else { } } } } return url ; } public boolean isAttributeSpecified ( int attributeHandle ) { int type = getNodeType ( attributeHandle ) ; if ( DTM . ATTRIBUTE_NODE == type ) { Attr attr = ( Attr ) getNode ( attributeHandle ) ; return attr . getSpecified ( ) ; } return false ; } public void setIncrementalSAXSource ( IncrementalSAXSource source ) { } public org . xml . sax . ContentHandler getContentHandler ( ) { return null ; } public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) { return null ; } public org . xml . sax . EntityResolver getEntityResolver ( ) { return null ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return null ; } public org . xml . sax . ErrorHandler getErrorHandler ( ) { return null ; } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { return null ; } public boolean needsTwoThreads ( ) { return false ; } private static boolean isSpace ( char ch ) { return XMLCharacterRecognizer . isWhiteSpace ( ch ) ; } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { if ( normalize ) { XMLString str = getStringValue ( nodeHandle ) ; str = str . fixWhiteSpace ( true , true , false ) ; str . dispatchCharactersEvents ( ch ) ; } else { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; dispatchNodeData ( node , ch , 0 ) ; if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { while ( null != ( node = logicalNextDOMTextNode ( node ) ) ) { dispatchNodeData ( node , ch , 0 ) ; } } } } protected static void dispatchNodeData ( Node node , org . xml . sax . ContentHandler ch , int depth ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { dispatchNodeData ( child , ch , depth + 1 ) ; } } break ; case Node . PROCESSING_INSTRUCTION_NODE : case Node . COMMENT_NODE : if ( 0 != depth ) break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : String str = node . getNodeValue ( ) ; if ( ch instanceof CharacterNodeHandler ) { ( ( CharacterNodeHandler ) ch ) . characters ( node ) ; } else { ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } break ; default : break ; } } TreeWalker m_walker = new TreeWalker ( null ) ; public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { TreeWalker treeWalker = m_walker ; ContentHandler prevCH = treeWalker . getContentHandler ( ) ; if ( null != prevCH ) { treeWalker = new TreeWalker ( null ) ; } treeWalker . setContentHandler ( ch ) ; try { Node node = getNode ( nodeHandle ) ; treeWalker . traverse ( node ) ; } finally { treeWalker . setContentHandler ( null ) ; } } public interface CharacterNodeHandler { public void characters ( Node node ) throws org . xml . sax . SAXException ; } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } } 	1	['38', '4', '0', '19', '117', '581', '1', '19', '28', '0.86977887', '1628', '0.545454545', '1', '0.717557252', '0.142857143', '2', '18', '41.55263158', '42', '4.6316', '1']
package org . apache . xalan . xsltc . trax ; import org . xml . sax . * ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . helpers . DefaultHandler ; import javax . xml . transform . * ; import javax . xml . transform . sax . * ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . TransletOutputHandler ; import org . apache . xalan . xsltc . dom . DOMImpl ; import org . apache . xalan . xsltc . dom . DOMBuilder ; import org . apache . xalan . xsltc . dom . DTDMonitor ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; public class TransformerHandlerImpl implements TransformerHandler , DeclHandler { private TransformerImpl _transformer ; private AbstractTranslet _translet = null ; private String _systemId ; private DOMImpl _dom = null ; private ContentHandler _handler = null ; private LexicalHandler _lexHandler = null ; private DTDMonitor _dtd = null ; private Result _result = null ; private boolean _done = false ; private boolean _isIdentity = false ; protected TransformerHandlerImpl ( TransformerImpl transformer ) { _transformer = transformer ; if ( transformer . isIdentity ( ) ) { _handler = new DefaultHandler ( ) ; _isIdentity = true ; } else { _translet = _transformer . getTranslet ( ) ; _dom = new DOMImpl ( ) ; _handler = _dom . getBuilder ( ) ; _lexHandler = ( LexicalHandler ) _handler ; _dtd = new DTDMonitor ( ) ; } } public String getSystemId ( ) { return _systemId ; } public void setSystemId ( String id ) { _systemId = id ; } public Transformer getTransformer ( ) { return _transformer ; } public void setResult ( Result result ) throws IllegalArgumentException { _result = result ; if ( _isIdentity ) { try { TransletOutputHandler outputHandler = _transformer . getOutputHandler ( result ) ; _transformer . transferOutputProperties ( outputHandler ) ; _handler = new SAX2TO ( outputHandler ) ; _lexHandler = ( LexicalHandler ) _handler ; } catch ( TransformerException e ) { _result = null ; } } else if ( _done ) { try { _transformer . setDOM ( _dom ) ; _transformer . transform ( null , _result ) ; } catch ( TransformerException e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } } } public void characters ( char [ ] ch , int start , int length ) throws SAXException { _handler . characters ( ch , start , length ) ; } public void startDocument ( ) throws SAXException { if ( _result == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_SET_RESULT_ERR ) ; throw new SAXException ( err . toString ( ) ) ; } if ( ! _isIdentity ) { _dom . setDocumentURI ( _systemId ) ; } _handler . startDocument ( ) ; } public void endDocument ( ) throws SAXException { _handler . endDocument ( ) ; if ( ! _isIdentity ) { if ( _result != null ) { try { _transformer . setDOM ( _dom ) ; _transformer . setDTDMonitor ( _dtd ) ; _transformer . transform ( null , _result ) ; } catch ( TransformerException e ) { throw new SAXException ( e ) ; } } _done = true ; _transformer . setDOM ( _dom ) ; } } public void startElement ( String uri , String localName , String qname , Attributes attributes ) throws SAXException { _handler . startElement ( uri , localName , qname , attributes ) ; } public void endElement ( String namespaceURI , String localName , String qname ) throws SAXException { _handler . endElement ( namespaceURI , localName , qname ) ; } public void processingInstruction ( String target , String data ) throws SAXException { _handler . processingInstruction ( target , data ) ; } public void startCDATA ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endCDATA ( ) ; } } public void comment ( char [ ] ch , int start , int length ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . comment ( ch , start , length ) ; } } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { _handler . ignorableWhitespace ( ch , start , length ) ; } public void setDocumentLocator ( Locator locator ) { _handler . setDocumentLocator ( locator ) ; } public void skippedEntity ( String name ) throws SAXException { _handler . skippedEntity ( name ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { _handler . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { _handler . endPrefixMapping ( prefix ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startDTD ( name , publicId , systemId ) ; } } public void endDTD ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endDTD ( ) ; } } public void startEntity ( String name ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startEntity ( name ) ; } } public void endEntity ( String name ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endEntity ( name ) ; } } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { _dtd . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { _dtd . notationDecl ( name , publicId , systemId ) ; } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { _dtd . attributeDecl ( eName , aName , type , valueDefault , value ) ; } public void elementDecl ( String name , String model ) throws SAXException { _dtd . elementDecl ( name , model ) ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { _dtd . externalEntityDecl ( name , publicId , systemId ) ; } public void internalEntityDecl ( String name , String value ) throws SAXException { _dtd . internalEntityDecl ( name , value ) ; } } 	0	['29', '1', '0', '10', '73', '114', '2', '8', '29', '0.846428571', '394', '1', '4', '0', '0.237068966', '0', '0', '12.24137931', '1', '0.9655', '0']
package org . apache . xalan . processor ; import java . net . URL ; import java . io . IOException ; import javax . xml . transform . sax . TemplatesHandler ; import javax . xml . transform . Templates ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerConfigurationException ; import java . util . Stack ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemUnknown ; import org . apache . xalan . templates . ElemForEach ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xml . utils . NodeConsumer ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xml . utils . BoolStack ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . compiler . XPathParser ; import org . apache . xpath . functions . Function ; import org . apache . xpath . XPathFactory ; import org . apache . xpath . XPath ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xalan . extensions . ExpressionVisitor ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . helpers . NamespaceSupport ; import org . apache . xml . utils . NamespaceSupport2 ; import org . xml . sax . helpers . DefaultHandler ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . SAXSourceLocator ; public class StylesheetHandler extends DefaultHandler implements TemplatesHandler , PrefixResolver , NodeConsumer { public StylesheetHandler ( TransformerFactoryImpl processor ) throws TransformerConfigurationException { init ( processor ) ; } private static boolean m_xpathFunctionsInited = false ; void init ( TransformerFactoryImpl processor ) { if ( false == m_xpathFunctionsInited ) { synchronized ( this ) { if ( false == m_xpathFunctionsInited ) { m_xpathFunctionsInited = true ; Function func = new org . apache . xalan . templates . FuncDocument ( ) ; FunctionTable . installFunction ( "document" , func ) ; func = new org . apache . xalan . templates . FuncFormatNumb ( ) ; FunctionTable . installFunction ( "format-number" , func ) ; } } } m_stylesheetProcessor = processor ; m_processors . push ( m_schema . getElementProcessor ( ) ) ; this . pushNewNamespaceSupport ( ) ; } public XPath createXPath ( String str , ElemTemplateElement owningTemplate ) throws javax . xml . transform . TransformerException { ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; XPath xpath = new XPath ( str , owningTemplate , this , XPath . SELECT , handler ) ; xpath . callVisitors ( xpath , new ExpressionVisitor ( getStylesheetRoot ( ) ) ) ; return xpath ; } XPath createMatchPatternXPath ( String str , ElemTemplateElement owningTemplate ) throws javax . xml . transform . TransformerException { ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; return new XPath ( str , owningTemplate , this , XPath . MATCH , handler ) ; } public String getNamespaceForPrefix ( String prefix ) { return this . getNamespaceSupport ( ) . getURI ( prefix ) ; } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) { assertion ( true , "can't process a context node in StylesheetHandler!" ) ; return null ; } private boolean stackContains ( Stack stack , String url ) { int n = stack . size ( ) ; boolean contains = false ; for ( int i = 0 ; i < n ; i ++ ) { String url2 = ( String ) stack . elementAt ( i ) ; if ( url2 . equals ( url ) ) { contains = true ; break ; } } return contains ; } public Templates getTemplates ( ) { return getStylesheetRoot ( ) ; } public void setSystemId ( String baseID ) { pushBaseIndentifier ( baseID ) ; } public String getSystemId ( ) { return this . getBaseIdentifier ( ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws org . xml . sax . SAXException { return getCurrentProcessor ( ) . resolveEntity ( this , publicId , systemId ) ; } public void notationDecl ( String name , String publicId , String systemId ) { getCurrentProcessor ( ) . notationDecl ( this , name , publicId , systemId ) ; } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) { getCurrentProcessor ( ) . unparsedEntityDecl ( this , name , publicId , systemId , notationName ) ; } XSLTElementProcessor getProcessorFor ( String uri , String localName , String rawName ) throws org . xml . sax . SAXException { XSLTElementProcessor currentProcessor = getCurrentProcessor ( ) ; XSLTElementDef def = currentProcessor . getElemDef ( ) ; XSLTElementProcessor elemProcessor = def . getProcessorFor ( uri , localName ) ; if ( null == elemProcessor && ( ( null == getStylesheet ( ) || Double . valueOf ( getStylesheet ( ) . getVersion ( ) ) . doubleValue ( ) > Constants . XSLTVERSUPPORTED ) || ( ! uri . equals ( Constants . S_XSLNAMESPACEURL ) && currentProcessor instanceof ProcessorStylesheetElement ) || getElemVersion ( ) > Constants . XSLTVERSUPPORTED ) ) { elemProcessor = def . getProcessorForUnknown ( uri , localName ) ; } if ( null == elemProcessor ) error ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_ALLOWED_IN_POSITION , new Object [ ] { rawName } ) , null ) ; return elemProcessor ; } public void setDocumentLocator ( Locator locator ) { m_stylesheetLocatorStack . push ( new SAXSourceLocator ( locator ) ) ; } private int m_stylesheetLevel = - 1 ; public void startDocument ( ) throws org . xml . sax . SAXException { m_stylesheetLevel ++ ; pushSpaceHandling ( false ) ; } private boolean m_parsingComplete = false ; public boolean isStylesheetParsingComplete ( ) { return m_parsingComplete ; } public void endDocument ( ) throws org . xml . sax . SAXException { try { if ( null != getStylesheetRoot ( ) ) { if ( 0 == m_stylesheetLevel ) getStylesheetRoot ( ) . recompose ( ) ; } else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEETROOT , null ) ) ; XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; if ( null != elemProcessor ) elemProcessor . startNonText ( this ) ; m_stylesheetLevel -- ; popSpaceHandling ( ) ; m_parsingComplete = ( m_stylesheetLevel < 0 ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } private java . util . Vector m_prefixMappings = new java . util . Vector ( ) ; public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { m_prefixMappings . addElement ( prefix ) ; m_prefixMappings . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } private void flushCharacters ( ) throws org . xml . sax . SAXException { XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; if ( null != elemProcessor ) elemProcessor . startNonText ( this ) ; } public void startElement ( String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { NamespaceSupport nssupport = this . getNamespaceSupport ( ) ; nssupport . pushContext ( ) ; int n = m_prefixMappings . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String prefix = ( String ) m_prefixMappings . elementAt ( i ++ ) ; String nsURI = ( String ) m_prefixMappings . elementAt ( i ) ; nssupport . declarePrefix ( prefix , nsURI ) ; } m_prefixMappings . removeAllElements ( ) ; m_elementID ++ ; checkForFragmentID ( attributes ) ; if ( ! m_shouldProcess ) return ; flushCharacters ( ) ; pushSpaceHandling ( attributes ) ; XSLTElementProcessor elemProcessor = getProcessorFor ( uri , localName , rawName ) ; if ( null != elemProcessor ) { this . pushProcessor ( elemProcessor ) ; elemProcessor . startElement ( this , uri , localName , rawName , attributes ) ; } else { m_shouldProcess = false ; popSpaceHandling ( ) ; } } public void endElement ( String uri , String localName , String rawName ) throws org . xml . sax . SAXException { m_elementID -- ; if ( ! m_shouldProcess ) return ; if ( ( m_elementID + 1 ) == m_fragmentID ) m_shouldProcess = false ; flushCharacters ( ) ; popSpaceHandling ( ) ; XSLTElementProcessor p = getCurrentProcessor ( ) ; p . endElement ( this , uri , localName , rawName ) ; this . popProcessor ( ) ; this . getNamespaceSupport ( ) . popContext ( ) ; } public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; XSLTElementDef def = elemProcessor . getElemDef ( ) ; if ( def . getType ( ) != XSLTElementDef . T_PCDATA ) elemProcessor = def . getProcessorFor ( null , "text()" ) ; if ( null == elemProcessor ) { if ( ! XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) error ( XSLMessages . createMessage ( XSLTErrorResources . ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , null ) , null ) ; } else elemProcessor . characters ( this , ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; getCurrentProcessor ( ) . ignorableWhitespace ( this , ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; String prefix = "" , ns = "" , localName = target ; int colon = target . indexOf ( ':' ) ; if ( colon >= 0 ) { ns = getNamespaceForPrefix ( prefix = target . substring ( 0 , colon ) ) ; localName = target . substring ( colon + 1 ) ; } try { if ( "xalan:doc-cache-off" . equals ( target ) || ( "doc-cache-off" . equals ( localName ) && ns . equals ( "org.apache.xalan.xslt.extensions.Redirect" ) ) ) { if ( ! ( m_elems . peek ( ) instanceof ElemForEach ) ) throw new TransformerException ( "xalan:doc-cache-off not allowed here!" , getLocator ( ) ) ; ElemForEach elem = ( ElemForEach ) m_elems . peek ( ) ; elem . m_doc_cache_off = true ; } } catch ( Exception e ) { } flushCharacters ( ) ; getCurrentProcessor ( ) . processingInstruction ( this , target , data ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; getCurrentProcessor ( ) . skippedEntity ( this , name ) ; } public void warn ( int msg , Object args [ ] ) throws org . xml . sax . SAXException { String formattedMsg = m_XSLMessages . createWarning ( msg , args ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { if ( null != handler ) handler . warning ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } private void assertion ( boolean condition , String msg ) throws RuntimeException { if ( ! condition ) throw new RuntimeException ( msg ) ; } protected void error ( String msg , Exception e ) throws org . xml . sax . SAXException { SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; TransformerException pe ; if ( ! ( e instanceof TransformerException ) ) { pe = ( null == e ) ? new TransformerException ( msg , locator ) : new TransformerException ( msg , locator , e ) ; } else pe = ( TransformerException ) e ; if ( null != handler ) { try { handler . error ( pe ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else throw new org . xml . sax . SAXException ( pe ) ; } protected void error ( int msg , Object args [ ] , Exception e ) throws org . xml . sax . SAXException { String formattedMsg = m_XSLMessages . createMessage ( msg , args ) ; error ( formattedMsg , e ) ; } public void warning ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . warning ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void error ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . error ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void fatalError ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . fatalError ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } private boolean m_shouldProcess = true ; private String m_fragmentIDString ; private int m_elementID = 0 ; private int m_fragmentID = 0 ; private void checkForFragmentID ( Attributes attributes ) { if ( ! m_shouldProcess ) { if ( ( null != attributes ) && ( null != m_fragmentIDString ) ) { int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String name = attributes . getQName ( i ) ; if ( name . equals ( Constants . ATTRNAME_ID ) ) { String val = attributes . getValue ( i ) ; if ( val . equalsIgnoreCase ( m_fragmentIDString ) ) { m_shouldProcess = true ; m_fragmentID = m_elementID ; } } } } } } private TransformerFactoryImpl m_stylesheetProcessor ; TransformerFactoryImpl getStylesheetProcessor ( ) { return m_stylesheetProcessor ; } static final int STYPE_ROOT = 1 ; static final int STYPE_INCLUDE = 2 ; static final int STYPE_IMPORT = 3 ; private int m_stylesheetType = STYPE_ROOT ; int getStylesheetType ( ) { return m_stylesheetType ; } void setStylesheetType ( int type ) { m_stylesheetType = type ; } private Stack m_stylesheets = new Stack ( ) ; Stylesheet getStylesheet ( ) { return ( m_stylesheets . size ( ) == 0 ) ? null : ( Stylesheet ) m_stylesheets . peek ( ) ; } Stylesheet getLastPoppedStylesheet ( ) { return m_lastPoppedStylesheet ; } public StylesheetRoot getStylesheetRoot ( ) { return m_stylesheetRoot ; } StylesheetRoot m_stylesheetRoot ; Stylesheet m_lastPoppedStylesheet ; public void pushStylesheet ( Stylesheet s ) { if ( m_stylesheets . size ( ) == 0 ) m_stylesheetRoot = ( StylesheetRoot ) s ; m_stylesheets . push ( s ) ; } Stylesheet popStylesheet ( ) { if ( ! m_stylesheetLocatorStack . isEmpty ( ) ) m_stylesheetLocatorStack . pop ( ) ; if ( ! m_stylesheets . isEmpty ( ) ) m_lastPoppedStylesheet = ( Stylesheet ) m_stylesheets . pop ( ) ; return m_lastPoppedStylesheet ; } private Stack m_processors = new Stack ( ) ; XSLTElementProcessor getCurrentProcessor ( ) { return ( XSLTElementProcessor ) m_processors . peek ( ) ; } void pushProcessor ( XSLTElementProcessor processor ) { m_processors . push ( processor ) ; } XSLTElementProcessor popProcessor ( ) { return ( XSLTElementProcessor ) m_processors . pop ( ) ; } private XSLTSchema m_schema = new XSLTSchema ( ) ; XSLTSchema getSchema ( ) { return m_schema ; } private Stack m_elems = new Stack ( ) ; ElemTemplateElement getElemTemplateElement ( ) { try { return ( ElemTemplateElement ) m_elems . peek ( ) ; } catch ( java . util . EmptyStackException ese ) { return null ; } } private int m_docOrderCount = 0 ; int nextUid ( ) { return m_docOrderCount ++ ; } void pushElemTemplateElement ( ElemTemplateElement elem ) { if ( elem . getUid ( ) == - 1 ) elem . setUid ( nextUid ( ) ) ; m_elems . push ( elem ) ; } ElemTemplateElement popElemTemplateElement ( ) { return ( ElemTemplateElement ) m_elems . pop ( ) ; } private static XSLMessages m_XSLMessages = new XSLMessages ( ) ; XSLMessages getXSLMessages ( ) { return m_XSLMessages ; } Stack m_baseIdentifiers = new Stack ( ) ; void pushBaseIndentifier ( String baseID ) { if ( null != baseID ) { int posOfHash = baseID . indexOf ( '#' ) ; if ( posOfHash > - 1 ) { m_fragmentIDString = baseID . substring ( posOfHash + 1 ) ; m_shouldProcess = false ; } else m_shouldProcess = true ; } else m_shouldProcess = true ; m_baseIdentifiers . push ( baseID ) ; } String popBaseIndentifier ( ) { return ( String ) m_baseIdentifiers . pop ( ) ; } public String getBaseIdentifier ( ) { String base = ( String ) ( m_baseIdentifiers . isEmpty ( ) ? null : m_baseIdentifiers . peek ( ) ) ; if ( null == base ) { SourceLocator locator = getLocator ( ) ; base = ( null == locator ) ? "" : locator . getSystemId ( ) ; } return base ; } private Stack m_stylesheetLocatorStack = new Stack ( ) ; public SAXSourceLocator getLocator ( ) { if ( m_stylesheetLocatorStack . isEmpty ( ) ) { SAXSourceLocator locator = new SAXSourceLocator ( ) ; locator . setSystemId ( this . getStylesheetProcessor ( ) . getDOMsystemID ( ) ) ; return locator ; } return ( ( SAXSourceLocator ) m_stylesheetLocatorStack . peek ( ) ) ; } private Stack m_importStack = new Stack ( ) ; void pushImportURL ( String hrefUrl ) { m_importStack . push ( hrefUrl ) ; } boolean importStackContains ( String hrefUrl ) { return stackContains ( m_importStack , hrefUrl ) ; } String popImportURL ( ) { return ( String ) m_importStack . pop ( ) ; } private boolean warnedAboutOldXSLTNamespace = false ; Stack m_nsSupportStack = new Stack ( ) ; void pushNewNamespaceSupport ( ) { m_nsSupportStack . push ( new NamespaceSupport2 ( ) ) ; } void popNamespaceSupport ( ) { m_nsSupportStack . pop ( ) ; } NamespaceSupport getNamespaceSupport ( ) { return ( NamespaceSupport ) m_nsSupportStack . peek ( ) ; } private Node m_originatingNode ; public void setOriginatingNode ( Node n ) { m_originatingNode = n ; } public Node getOriginatingNode ( ) { return m_originatingNode ; } private BoolStack m_spacePreserveStack = new BoolStack ( ) ; boolean isSpacePreserve ( ) { return m_spacePreserveStack . peek ( ) ; } void popSpaceHandling ( ) { m_spacePreserveStack . pop ( ) ; } void pushSpaceHandling ( boolean b ) throws org . xml . sax . SAXParseException { m_spacePreserveStack . push ( b ) ; } void pushSpaceHandling ( Attributes attrs ) throws org . xml . sax . SAXParseException { String value = attrs . getValue ( "xml:space" ) ; if ( null == value ) { m_spacePreserveStack . push ( m_spacePreserveStack . peekOrFalse ( ) ) ; } else if ( value . equals ( "preserve" ) ) { m_spacePreserveStack . push ( true ) ; } else if ( value . equals ( "default" ) ) { m_spacePreserveStack . push ( false ) ; } else { SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . error ( new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_XMLSPACE_VALUE , null ) , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXParseException ( te . getMessage ( ) , locator , te ) ; } m_spacePreserveStack . push ( m_spacePreserveStack . peek ( ) ) ; } } private double getElemVersion ( ) { ElemTemplateElement elem = getElemTemplateElement ( ) ; double version = - 1 ; while ( ( version == - 1 || version == Constants . XSLTVERSUPPORTED ) && elem != null ) { try { version = Double . valueOf ( elem . getVersion ( ) ) . doubleValue ( ) ; } catch ( Exception ex ) { version = - 1 ; } elem = elem . getParentElem ( ) ; } return ( version == - 1 ) ? Constants . XSLTVERSUPPORTED : version ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1	['71', '2', '0', '47', '152', '2163', '25', '25', '33', '0.941326531', '1340', '0.75', '6', '0.197674419', '0.108035714', '1', '1', '17.47887324', '7', '1.3239', '1']
package org . apache . xml . utils ; public interface RawCharacterHandler { public void charactersRaw ( char ch [ ] , int start , int length ) throws javax . xml . transform . TransformerException ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xalan . xsltc . compiler . Constants ; public final class ReferenceType extends Type { protected ReferenceType ( ) { } public String toString ( ) { return "reference" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "Ljava/lang/Object;" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . OBJECT ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . NodeSet ) { translateTo ( classGen , methodGen , ( NodeSetType ) type ) ; } else if ( type == Type . Node ) { translateTo ( classGen , methodGen , ( NodeType ) type ) ; } else if ( type == Type . ResultTree ) { translateTo ( classGen , methodGen , ( ResultTreeType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final int current = methodGen . getLocalIndex ( "current" ) ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new ILOAD ( current ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int stringF = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "stringF" , "(" + OBJECT_SIG + NODE_SIG + DOM_INTF_SIG + ")" + STRING_SIG ) ; il . append ( new INVOKESTATIC ( stringF ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "numberF" , "(" + OBJECT_SIG + DOM_INTF_SIG + ")D" ) ; il . append ( new INVOKESTATIC ( index ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "booleanF" , "(" + OBJECT_SIG + ")Z" ) ; il . append ( new INVOKESTATIC ( index ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeSetType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNodeSet" , "(" + OBJECT_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( index ) ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , RESET , RESET_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeType type ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; Type . NodeSet . translateTo ( classGen , methodGen , type ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ResultTreeType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToResultTree" , "(" + OBJECT_SIG + ")" + DOM_INTF_SIG ) ; il . append ( new INVOKESTATIC ( index ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz . getName ( ) . equals ( "java.lang.Object" ) ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz . getName ( ) . equals ( "java.lang.Object" ) ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { InstructionList il = methodGen . getInstructionList ( ) ; translateTo ( classGen , methodGen , type ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	1	['20', '2', '0', '41', '44', '190', '18', '30', '19', '2', '353', '0', '0', '0.634615385', '0.230769231', '2', '4', '16.65', '8', '1.45', '1']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemText ; import javax . xml . transform . TransformerException ; public class ProcessorText extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { ProcessorCharacters charProcessor = ( ProcessorCharacters ) handler . getProcessorFor ( null , "text()" , "text" ) ; charProcessor . setXslTextElement ( ( ElemText ) elem ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ProcessorCharacters charProcessor = ( ProcessorCharacters ) handler . getProcessorFor ( null , "text()" , "text" ) ; charProcessor . setXslTextElement ( null ) ; } } 	0	['3', '5', '0', '7', '10', '3', '1', '6', '2', '2', '40', '0', '0', '0.990697674', '0.583333333', '2', '4', '12.33333333', '1', '0.6667', '0']
package org . apache . xalan . transformer ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; public class KeyTable { private int m_docKey ; public int getDocKey ( ) { return m_docKey ; } private XNodeSet m_keyNodes ; KeyIterator getKeyIterator ( ) { return ( KeyIterator ) ( m_keyNodes . getContainedIter ( ) ) ; } public KeyTable ( int doc , PrefixResolver nscontext , QName name , Vector keyDeclarations , XPathContext xctxt ) throws javax . xml . transform . TransformerException { m_docKey = doc ; KeyIterator ki = new KeyIterator ( name , keyDeclarations ) ; m_keyNodes = new XNodeSet ( ki ) ; m_keyNodes . allowDetachToRelease ( false ) ; m_keyNodes . setRoot ( doc , xctxt ) ; } public XNodeSet getNodeSetDTMByKey ( QName name , XMLString ref ) { Vector keyDecls = getKeyIterator ( ) . getKeyDeclarations ( ) ; org . apache . xml . dtm . DTMIterator keyNodes = m_keyNodes . iter ( ) ; XNodeSet refNodes = new XNodeSet ( new KeyRefIterator ( name , ref , keyDecls , keyNodes ) ) ; return refNodes ; } public QName getKeyTableName ( ) { return getKeyIterator ( ) . getName ( ) ; } } 	1	['5', '1', '0', '10', '15', '2', '1', '9', '4', '0.5', '68', '1', '1', '0', '0.342857143', '0', '0', '12.2', '1', '0.8', '1']
package org . apache . xml . utils . res ; import org . apache . xml . utils . res . XResourceBundle ; import java . util . * ; public class XResources_ja_JP_HA extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x3042 , 0x3044 , 0x3046 , 0x3048 , 0x304a , 0x304b , 0x304d , 0x304f , 0x3051 , 0x3053 , 0x3055 , 0x3057 , 0x3059 , 0x305b , 0x305d , 0x305f , 0x3061 , 0x3064 , 0x3066 , 0x3068 , 0x306a , 0x306b , 0x306c , 0x306d , 0x306e , 0x306f , 0x3072 , 0x3075 , 0x3078 , 0x307b , 0x307e , 0x307f , 0x3080 , 0x3081 , 0x3082 , 0x3084 , 0x3086 , 0x3088 , 0x3089 , 0x308a , 0x308b , 0x308c , 0x308d , 0x308f , 0x3090 , 0x3091 , 0x3092 , 0x3093 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	0	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '599', '0', '0', '0.976190476', '1', '0', '0', '198.3333333', '1', '0.3333', '0']
package org . apache . xml . dtm ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . BufferedReader ; import java . util . Properties ; import java . util . Enumeration ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public abstract class DTMManager { private static final String defaultPropName = "org.apache.xml.dtm.DTMManager" ; protected XMLStringFactory m_xsf = null ; protected DTMManager ( ) { } public XMLStringFactory getXMLStringFactory ( ) { return m_xsf ; } public void setXMLStringFactory ( XMLStringFactory xsf ) { m_xsf = xsf ; } public static DTMManager newInstance ( XMLStringFactory xsf ) throws DTMConfigurationException { String classname = findFactory ( defaultPropName , "org.apache.xml.dtm.ref.DTMManagerDefault" ) ; if ( classname == null ) { throw new DTMConfigurationException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_DEFAULT_IMPL , null ) ) ; } DTMManager factoryImpl ; try { Class clazz = Class . forName ( classname ) ; factoryImpl = ( DTMManager ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException cnfe ) { throw new DTMConfigurationException ( cnfe ) ; } catch ( IllegalAccessException iae ) { throw new DTMConfigurationException ( iae ) ; } catch ( InstantiationException ie ) { throw new DTMConfigurationException ( ie ) ; } factoryImpl . setXMLStringFactory ( xsf ) ; return factoryImpl ; } public abstract DTM getDTM ( javax . xml . transform . Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing ) ; public abstract DTM getDTM ( int nodeHandle ) ; public abstract int getDTMHandleFromNode ( org . w3c . dom . Node node ) ; public abstract DTM createDocumentFragment ( ) ; public abstract boolean release ( DTM dtm , boolean shouldHardDelete ) ; public abstract DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) ; public abstract DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) ; public abstract DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) ; public abstract DTMIterator createDTMIterator ( int node ) ; public static boolean m_incremental = false ; public synchronized static boolean getIncremental ( ) { return m_incremental ; } public synchronized static void setIncremental ( boolean incremental ) { m_incremental = incremental ; } private static String foundFactory = null ; private static boolean debug ; static { try { debug = System . getProperty ( "dtm.debug" ) != null ; } catch ( SecurityException ex ) { } } private static String findFactory ( String factoryId , String defaultFactory ) { try { String systemProp = null ; try { systemProp = System . getProperty ( factoryId ) ; } catch ( SecurityException se ) { } if ( systemProp != null ) { if ( debug ) { System . err . println ( "DTM: found system property" + systemProp ) ; } return systemProp ; } } catch ( SecurityException se ) { } if ( foundFactory != null ) { return foundFactory ; } try { String javah = System . getProperty ( "java.home" ) ; String configFile = javah + File . separator + "lib" + File . separator + "jaxp.properties" ; File f = new File ( configFile ) ; if ( f . exists ( ) ) { Properties props = new Properties ( ) ; props . load ( new FileInputStream ( f ) ) ; foundFactory = props . getProperty ( factoryId ) ; if ( debug ) { System . err . println ( "DTM: found java.home property " + foundFactory ) ; } if ( foundFactory != null ) { return foundFactory ; } } } catch ( Exception ex ) { if ( debug ) { ex . printStackTrace ( ) ; } } String serviceId = "META-INF/services/" + factoryId ; try { ClassLoader cl = DTMManager . class . getClassLoader ( ) ; InputStream is = null ; if ( cl == null ) { is = ClassLoader . getSystemResourceAsStream ( serviceId ) ; } else { is = cl . getResourceAsStream ( serviceId ) ; } if ( is != null ) { if ( debug ) { System . err . println ( "DTM: found  " + serviceId ) ; } BufferedReader rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; foundFactory = rd . readLine ( ) ; rd . close ( ) ; if ( debug ) { System . err . println ( "DTM: loaded from services: " + foundFactory ) ; } if ( ( foundFactory != null ) && ! "" . equals ( foundFactory ) ) { return foundFactory ; } } } catch ( Exception ex ) { if ( debug ) { ex . printStackTrace ( ) ; } } return defaultFactory ; } public static final int IDENT_DTM_NODE_BITS = 16 ; public static final int IDENT_NODE_DEFAULT = ( 1 << IDENT_DTM_NODE_BITS ) - 1 ; public static final int IDENT_DTM_DEFAULT = ~ IDENT_NODE_DEFAULT ; public static final int IDENT_MAX_DTMS = ( IDENT_DTM_DEFAULT > > > IDENT_DTM_NODE_BITS ) + 1 ; public abstract int getDTMIdentity ( DTM dtm ) ; public int getDTMIdentityMask ( ) { return IDENT_DTM_DEFAULT ; } public int getNodeIdentityMask ( ) { return IDENT_NODE_DEFAULT ; } } 	1	['21', '1', '2', '43', '49', '196', '36', '8', '17', '0.975', '299', '0.4', '1', '0', '0.15', '0', '0', '12.76190476', '10', '1.3333', '1']
package org . apache . xalan . templates ; import org . w3c . dom . * ; import org . xml . sax . * ; import org . xml . sax . helpers . * ; import java . util . StringTokenizer ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . NameSpace ; import org . apache . xpath . XPathContext ; import org . apache . xml . utils . StringToStringTable ; import org . apache . xml . utils . NameSpace ; import org . apache . xml . utils . StringVector ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . ResultTreeHandler ; import java . io . * ; import java . util . * ; import javax . xml . transform . TransformerException ; public class ElemUnknown extends ElemLiteralResult { public void execute ( TransformerImpl transformer ) throws TransformerException { } } 	0	['2', '5', '0', '2', '3', '1', '0', '2', '2', '2', '6', '0', '0', '0.995833333', '0.75', '1', '1', '2', '1', '0.5', '0']
package org . apache . xalan . lib . sql ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . DTMDefaultBaseIterators ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . utils . SuballocatedIntVector ; import org . w3c . dom . Node ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . ContentHandler ; import java . io . IOException ; import java . io . File ; import java . io . PrintStream ; import java . io . FileOutputStream ; import org . xml . sax . * ; import javax . xml . transform . SourceLocator ; import org . apache . xml . utils . * ; import org . apache . xml . dtm . * ; import org . xml . sax . ext . * ; public class DTMDocument extends DTMDefaultBaseIterators { public interface CharacterNodeHandler { public void characters ( Node node ) throws org . xml . sax . SAXException ; } private boolean DEBUG = false ; protected static final String S_NAMESPACE = "http://xml.apache.org/xalan/SQLExtension" ; protected static final String S_ATTRIB_NOT_SUPPORTED = "Not Supported" ; protected static final String S_ISTRUE = "true" ; protected static final String S_ISFALSE = "false" ; protected static final String S_DOCUMENT = "#root" ; protected static final String S_TEXT_NODE = "#text" ; protected static final String S_ELEMENT_NODE = "#element" ; protected int m_Document_TypeID = 0 ; protected int m_TextNode_TypeID = 0 ; protected ObjectArray m_ObjectArray = new ObjectArray ( ) ; protected SuballocatedIntVector m_attribute ; protected int m_DocumentIdx ; public DTMDocument ( DTMManager mgr , int ident ) { super ( mgr , null , ident , null , mgr . getXMLStringFactory ( ) , true ) ; m_attribute = new SuballocatedIntVector ( m_initialblocksize ) ; } private int allocateNodeObject ( Object o ) { m_size ++ ; return m_ObjectArray . append ( o ) ; } protected int addElementWithData ( Object o , int level , int extendedType , int parent , int prevsib ) { int elementIdx = addElement ( level , extendedType , parent , prevsib ) ; int data = allocateNodeObject ( o ) ; m_firstch . setElementAt ( data , elementIdx ) ; m_exptype . setElementAt ( m_TextNode_TypeID , data ) ; m_parent . setElementAt ( elementIdx , data ) ; m_prevsib . setElementAt ( DTM . NULL , data ) ; m_nextsib . setElementAt ( DTM . NULL , data ) ; m_attribute . setElementAt ( DTM . NULL , data ) ; m_firstch . setElementAt ( DTM . NULL , data ) ; return elementIdx ; } protected int addElement ( int level , int extendedType , int parent , int prevsib ) { int node = DTM . NULL ; try { node = allocateNodeObject ( S_ELEMENT_NODE ) ; m_exptype . setElementAt ( extendedType , node ) ; m_nextsib . setElementAt ( DTM . NULL , node ) ; m_prevsib . setElementAt ( prevsib , node ) ; m_parent . setElementAt ( parent , node ) ; m_firstch . setElementAt ( DTM . NULL , node ) ; m_attribute . setElementAt ( DTM . NULL , node ) ; if ( prevsib != DTM . NULL ) { if ( m_nextsib . elementAt ( prevsib ) != DTM . NULL ) m_nextsib . setElementAt ( m_nextsib . elementAt ( prevsib ) , node ) ; m_nextsib . setElementAt ( node , prevsib ) ; } if ( ( parent != DTM . NULL ) && ( m_prevsib . elementAt ( node ) == DTM . NULL ) ) { m_firstch . setElementAt ( node , parent ) ; } } catch ( Exception e ) { error ( "Error in addElement: " + e . getMessage ( ) ) ; } return node ; } protected int addAttributeToNode ( Object o , int extendedType , int pnode ) { int attrib = DTM . NULL ; int prevsib = DTM . NULL ; int lastattrib = DTM . NULL ; int value = DTM . NULL ; try { attrib = allocateNodeObject ( o ) ; m_attribute . setElementAt ( DTM . NULL , attrib ) ; m_exptype . setElementAt ( extendedType , attrib ) ; m_nextsib . setElementAt ( DTM . NULL , attrib ) ; m_prevsib . setElementAt ( DTM . NULL , attrib ) ; m_parent . setElementAt ( pnode , attrib ) ; m_firstch . setElementAt ( DTM . NULL , attrib ) ; if ( m_attribute . elementAt ( pnode ) != DTM . NULL ) { lastattrib = m_attribute . elementAt ( pnode ) ; m_nextsib . setElementAt ( lastattrib , attrib ) ; m_prevsib . setElementAt ( attrib , lastattrib ) ; } m_attribute . setElementAt ( attrib , pnode ) ; } catch ( Exception e ) { error ( "Error in addAttributeToNode: " + e . getMessage ( ) ) ; } return attrib ; } protected void cloneAttributeFromNode ( int toNode , int fromNode ) { try { if ( m_attribute . elementAt ( toNode ) != DTM . NULL ) { error ( "Cloneing Attributes, where from Node already had addtibures assigned" ) ; } m_attribute . setElementAt ( m_attribute . elementAt ( fromNode ) , toNode ) ; } catch ( Exception e ) { error ( "Cloning attributes" ) ; } } public int getFirstAttribute ( int parm1 ) { if ( DEBUG ) System . out . println ( "getFirstAttribute(" + parm1 + ")" ) ; int nodeIdx = makeNodeIdentity ( parm1 ) ; if ( nodeIdx != DTM . NULL ) { int attribIdx = m_attribute . elementAt ( nodeIdx ) ; return makeNodeHandle ( attribIdx ) ; } else return DTM . NULL ; } public String getNodeValue ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNodeValue(" + parm1 + ")" ) ; try { Object o = m_ObjectArray . getAt ( makeNodeIdentity ( parm1 ) ) ; if ( o != null ) { return o . toString ( ) ; } else { return "" ; } } catch ( Exception e ) { error ( "Getting String Value" ) ; return null ; } } public XMLString getStringValue ( int parm1 ) { int nodeIdx = makeNodeIdentity ( parm1 ) ; if ( DEBUG ) System . out . println ( "getStringValue(" + nodeIdx + ")" ) ; try { Object o = m_ObjectArray . getAt ( nodeIdx ) ; if ( o != null ) { return m_xstrf . newstr ( o . toString ( ) ) ; } else { return m_xstrf . emptystr ( ) ; } } catch ( Exception e ) { error ( "Getting String Value" ) ; return null ; } } public int getNextAttribute ( int parm1 ) { int nodeIdx = makeNodeIdentity ( parm1 ) ; if ( DEBUG ) System . out . println ( "getNextAttribute(" + nodeIdx + ")" ) ; if ( nodeIdx != DTM . NULL ) return makeNodeHandle ( m_nextsib . elementAt ( nodeIdx ) ) ; else return DTM . NULL ; } protected int getNumberOfNodes ( ) { if ( DEBUG ) System . out . println ( "getNumberOfNodes()" ) ; return m_size ; } protected boolean nextNode ( ) { if ( DEBUG ) System . out . println ( "nextNode()" ) ; return false ; } protected void createExpandedNameTable ( ) { m_Document_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DOCUMENT , DTM . DOCUMENT_NODE ) ; m_TextNode_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_TEXT_NODE , DTM . TEXT_NODE ) ; } public void dumpDTM ( ) { try { File f = new File ( "DTMDump.txt" ) ; System . err . println ( "Dumping... " + f . getAbsolutePath ( ) ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( f ) ) ; while ( nextNode ( ) ) { } int nRecords = m_size ; ps . println ( "Total nodes: " + nRecords ) ; for ( int i = 0 ; i < nRecords ; i ++ ) { ps . println ( "=========== " + i + " ===========" ) ; ps . println ( "NodeName: " + getNodeName ( makeNodeHandle ( i ) ) ) ; ps . println ( "NodeNameX: " + getNodeNameX ( makeNodeHandle ( i ) ) ) ; ps . println ( "LocalName: " + getLocalName ( makeNodeHandle ( i ) ) ) ; ps . println ( "NamespaceURI: " + getNamespaceURI ( makeNodeHandle ( i ) ) ) ; ps . println ( "Prefix: " + getPrefix ( makeNodeHandle ( i ) ) ) ; int exTypeID = getExpandedTypeID ( makeNodeHandle ( i ) ) ; ps . println ( "Expanded Type ID: " + Integer . toHexString ( exTypeID ) ) ; int type = getNodeType ( makeNodeHandle ( i ) ) ; String typestring ; switch ( type ) { case DTM . ATTRIBUTE_NODE : typestring = "ATTRIBUTE_NODE" ; break ; case DTM . CDATA_SECTION_NODE : typestring = "CDATA_SECTION_NODE" ; break ; case DTM . COMMENT_NODE : typestring = "COMMENT_NODE" ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : typestring = "DOCUMENT_FRAGMENT_NODE" ; break ; case DTM . DOCUMENT_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . DOCUMENT_TYPE_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . ELEMENT_NODE : typestring = "ELEMENT_NODE" ; break ; case DTM . ENTITY_NODE : typestring = "ENTITY_NODE" ; break ; case DTM . ENTITY_REFERENCE_NODE : typestring = "ENTITY_REFERENCE_NODE" ; break ; case DTM . NAMESPACE_NODE : typestring = "NAMESPACE_NODE" ; break ; case DTM . NOTATION_NODE : typestring = "NOTATION_NODE" ; break ; case DTM . NULL : typestring = "NULL" ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : typestring = "PROCESSING_INSTRUCTION_NODE" ; break ; case DTM . TEXT_NODE : typestring = "TEXT_NODE" ; break ; default : typestring = "Unknown!" ; break ; } ps . println ( "Type: " + typestring ) ; int firstChild = _firstch ( i ) ; if ( DTM . NULL == firstChild ) ps . println ( "First child: DTM.NULL" ) ; else if ( NOTPROCESSED == firstChild ) ps . println ( "First child: NOTPROCESSED" ) ; else ps . println ( "First child: " + firstChild ) ; int prevSibling = _prevsib ( i ) ; if ( DTM . NULL == prevSibling ) ps . println ( "Prev sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == prevSibling ) ps . println ( "Prev sibling: NOTPROCESSED" ) ; else ps . println ( "Prev sibling: " + prevSibling ) ; int nextSibling = _nextsib ( i ) ; if ( DTM . NULL == nextSibling ) ps . println ( "Next sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == nextSibling ) ps . println ( "Next sibling: NOTPROCESSED" ) ; else ps . println ( "Next sibling: " + nextSibling ) ; int parent = _parent ( i ) ; if ( DTM . NULL == parent ) ps . println ( "Parent: DTM.NULL" ) ; else if ( NOTPROCESSED == parent ) ps . println ( "Parent: NOTPROCESSED" ) ; else ps . println ( "Parent: " + parent ) ; int level = _level ( i ) ; ps . println ( "Level: " + level ) ; ps . println ( "Node Value: " + getNodeValue ( i ) ) ; ps . println ( "String Value: " + getStringValue ( i ) ) ; ps . println ( "First Attribute Node: " + m_attribute . elementAt ( i ) ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( System . err ) ; System . exit ( - 1 ) ; } } protected static void dispatchNodeData ( Node node , ContentHandler ch , int depth ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { dispatchNodeData ( child , ch , depth + 1 ) ; } } break ; case Node . PROCESSING_INSTRUCTION_NODE : case Node . COMMENT_NODE : if ( 0 != depth ) break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : String str = node . getNodeValue ( ) ; if ( ch instanceof CharacterNodeHandler ) { ( ( CharacterNodeHandler ) ch ) . characters ( node ) ; } else { ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } break ; default : break ; } } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } protected int getNextNodeIdentity ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNextNodeIdenty(" + parm1 + ")" ) ; return DTM . NULL ; } public int getAttributeNode ( int parm1 , String parm2 , String parm3 ) { if ( DEBUG ) { System . out . println ( "getAttributeNode(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return DTM . NULL ; } public String getLocalName ( int parm1 ) { int exID = getExpandedTypeID ( parm1 ) ; if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalName(" + parm1 + ") -> " ) ; System . out . println ( "..." + getLocalNameFromExpandedNameID ( exID ) ) ; DEBUG = true ; } return getLocalNameFromExpandedNameID ( exID ) ; } public String getNodeName ( int parm1 ) { int exID = getExpandedTypeID ( parm1 ) ; if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalName(" + parm1 + ") -> " ) ; System . out . println ( "..." + getLocalNameFromExpandedNameID ( exID ) ) ; DEBUG = true ; } return getLocalNameFromExpandedNameID ( exID ) ; } public boolean isAttributeSpecified ( int parm1 ) { if ( DEBUG ) System . out . println ( "isAttributeSpecified(" + parm1 + ")" ) ; return false ; } public String getUnparsedEntityURI ( String parm1 ) { if ( DEBUG ) System . out . println ( "getUnparsedEntityURI(" + parm1 + ")" ) ; return "" ; } public DTDHandler getDTDHandler ( ) { if ( DEBUG ) System . out . println ( "getDTDHandler()" ) ; return null ; } public String getPrefix ( int parm1 ) { if ( DEBUG ) System . out . println ( "getPrefix(" + parm1 + ")" ) ; return "" ; } public EntityResolver getEntityResolver ( ) { if ( DEBUG ) System . out . println ( "getEntityResolver()" ) ; return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { if ( DEBUG ) System . out . println ( "get_DTD_PubId()" ) ; return "" ; } public LexicalHandler getLexicalHandler ( ) { if ( DEBUG ) System . out . println ( "getLexicalHandler()" ) ; return null ; } public boolean needsTwoThreads ( ) { if ( DEBUG ) System . out . println ( "needsTwoThreads()" ) ; return false ; } public ContentHandler getContentHandler ( ) { if ( DEBUG ) System . out . println ( "getContentHandler()" ) ; return null ; } public void dispatchToEvents ( int parm1 , ContentHandler parm2 ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . println ( "dispathcToEvents(" + parm1 + "," + parm2 + ")" ) ; } return ; } public String getNamespaceURI ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNamespaceURI(" + parm1 + ")" ) ; return "" ; } public void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . println ( "dispatchCharacterEvents(" + nodeHandle + "," + ch + "," + normalize + ")" ) ; } if ( normalize ) { XMLString str = getStringValue ( nodeHandle ) ; str = str . fixWhiteSpace ( true , true , false ) ; str . dispatchCharactersEvents ( ch ) ; } else { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; dispatchNodeData ( node , ch , 0 ) ; } } public boolean supportsPreStripping ( ) { if ( DEBUG ) System . out . println ( "supportsPreStripping()" ) ; return super . supportsPreStripping ( ) ; } protected int _exptype ( int parm1 ) { if ( DEBUG ) System . out . println ( "_exptype(" + parm1 + ")" ) ; return super . _exptype ( parm1 ) ; } protected SuballocatedIntVector findNamespaceContext ( int parm1 ) { if ( DEBUG ) System . out . println ( "SuballocatedIntVector(" + parm1 + ")" ) ; return super . findNamespaceContext ( parm1 ) ; } protected int _prevsib ( int parm1 ) { if ( DEBUG ) System . out . println ( "_prevsib(" + parm1 + ")" ) ; return super . _prevsib ( parm1 ) ; } protected short _type ( int parm1 ) { if ( DEBUG ) System . out . println ( "_type(" + parm1 + ")" ) ; return super . _type ( parm1 ) ; } public Node getNode ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNode(" + parm1 + ")" ) ; return super . getNode ( parm1 ) ; } public int getPreviousSibling ( int parm1 ) { if ( DEBUG ) System . out . println ( "getPrevSib(" + parm1 + ")" ) ; return super . getPreviousSibling ( parm1 ) ; } public String getDocumentStandalone ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDOcStandAlone(" + parm1 + ")" ) ; return super . getDocumentStandalone ( parm1 ) ; } public String getNodeNameX ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNodeNameX(" + parm1 + ")" ) ; return getNodeName ( parm1 ) ; } public void setFeature ( String parm1 , boolean parm2 ) { if ( DEBUG ) { System . out . println ( "setFeature(" + parm1 + "," + parm2 + ")" ) ; } super . setFeature ( parm1 , parm2 ) ; } protected int _parent ( int parm1 ) { if ( DEBUG ) System . out . println ( "_parent(" + parm1 + ")" ) ; return super . _parent ( parm1 ) ; } protected void indexNode ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "indexNode(" + parm1 + "," + parm2 + ")" ) ; super . indexNode ( parm1 , parm2 ) ; } protected boolean getShouldStripWhitespace ( ) { if ( DEBUG ) System . out . println ( "getShouldStripWS()" ) ; return super . getShouldStripWhitespace ( ) ; } protected void popShouldStripWhitespace ( ) { if ( DEBUG ) System . out . println ( "popShouldStripWS()" ) ; super . popShouldStripWhitespace ( ) ; } public boolean isNodeAfter ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "isNodeAfter(" + parm1 + "," + parm2 + ")" ) ; return super . isNodeAfter ( parm1 , parm2 ) ; } public int getNamespaceType ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNamespaceType(" + parm1 + ")" ) ; return super . getNamespaceType ( parm1 ) ; } protected int _level ( int parm1 ) { if ( DEBUG ) System . out . println ( "_level(" + parm1 + ")" ) ; return super . _level ( parm1 ) ; } protected void pushShouldStripWhitespace ( boolean parm1 ) { if ( DEBUG ) System . out . println ( "push_ShouldStripWS(" + parm1 + ")" ) ; super . pushShouldStripWhitespace ( parm1 ) ; } public String getDocumentVersion ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocVer(" + parm1 + ")" ) ; return super . getDocumentVersion ( parm1 ) ; } public boolean isSupported ( String parm1 , String parm2 ) { if ( DEBUG ) System . out . println ( "isSupported(" + parm1 + "," + parm2 + ")" ) ; return super . isSupported ( parm1 , parm2 ) ; } protected void setShouldStripWhitespace ( boolean parm1 ) { if ( DEBUG ) System . out . println ( "set_ShouldStripWS(" + parm1 + ")" ) ; super . setShouldStripWhitespace ( parm1 ) ; } protected void ensureSizeOfIndex ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "ensureSizeOfIndex(" + parm1 + "," + parm2 + ")" ) ; super . ensureSizeOfIndex ( parm1 , parm2 ) ; } protected void ensureSize ( int parm1 ) { if ( DEBUG ) System . out . println ( "ensureSize(" + parm1 + ")" ) ; } public String getDocumentEncoding ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocumentEncoding(" + parm1 + ")" ) ; return super . getDocumentEncoding ( parm1 ) ; } public void appendChild ( int parm1 , boolean parm2 , boolean parm3 ) { if ( DEBUG ) { System . out . println ( "appendChild(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } super . appendChild ( parm1 , parm2 , parm3 ) ; } public short getLevel ( int parm1 ) { if ( DEBUG ) System . out . println ( "getLevel(" + parm1 + ")" ) ; return super . getLevel ( parm1 ) ; } public String getDocumentBaseURI ( ) { if ( DEBUG ) System . out . println ( "getDocBaseURI()" ) ; return super . getDocumentBaseURI ( ) ; } public int getNextNamespaceNode ( int parm1 , int parm2 , boolean parm3 ) { if ( DEBUG ) { System . out . println ( "getNextNamesapceNode(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return super . getNextNamespaceNode ( parm1 , parm2 , parm3 ) ; } public void appendTextChild ( String parm1 ) { if ( DEBUG ) System . out . println ( "appendTextChild(" + parm1 + ")" ) ; super . appendTextChild ( parm1 ) ; } protected int findGTE ( int [ ] parm1 , int parm2 , int parm3 , int parm4 ) { if ( DEBUG ) { System . out . println ( "findGTE(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return super . findGTE ( parm1 , parm2 , parm3 , parm4 ) ; } public int getFirstNamespaceNode ( int parm1 , boolean parm2 ) { if ( DEBUG ) System . out . println ( "getFirstNamespaceNode()" ) ; return super . getFirstNamespaceNode ( parm1 , parm2 ) ; } public int getStringValueChunkCount ( int parm1 ) { if ( DEBUG ) System . out . println ( "getStringChunkCount(" + parm1 + ")" ) ; return super . getStringValueChunkCount ( parm1 ) ; } public int getLastChild ( int parm1 ) { if ( DEBUG ) System . out . println ( "getLastChild(" + parm1 + ")" ) ; return super . getLastChild ( parm1 ) ; } public boolean hasChildNodes ( int parm1 ) { if ( DEBUG ) System . out . println ( "hasChildNodes(" + parm1 + ")" ) ; return super . hasChildNodes ( parm1 ) ; } public short getNodeType ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getNodeType(" + parm1 + ") " ) ; int exID = getExpandedTypeID ( parm1 ) ; String name = getLocalNameFromExpandedNameID ( exID ) ; System . out . println ( ".. Node name [" + name + "]" + "[" + getNodeType ( parm1 ) + "]" ) ; DEBUG = true ; } return super . getNodeType ( parm1 ) ; } public boolean isCharacterElementContentWhitespace ( int parm1 ) { if ( DEBUG ) System . out . println ( "isCharacterElementContentWhitespace(" + parm1 + ")" ) ; return super . isCharacterElementContentWhitespace ( parm1 ) ; } public int getFirstChild ( int parm1 ) { if ( DEBUG ) System . out . println ( "getFirstChild(" + parm1 + ")" ) ; return super . getFirstChild ( parm1 ) ; } public String getDocumentSystemIdentifier ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocSysID(" + parm1 + ")" ) ; return super . getDocumentSystemIdentifier ( parm1 ) ; } protected void declareNamespaceInContext ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "declareNamespaceContext(" + parm1 + "," + parm2 + ")" ) ; super . declareNamespaceInContext ( parm1 , parm2 ) ; } public String getNamespaceFromExpandedNameID ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getNamespaceFromExpandedNameID(" + parm1 + ")" ) ; System . out . println ( "..." + super . getNamespaceFromExpandedNameID ( parm1 ) ) ; DEBUG = true ; } return super . getNamespaceFromExpandedNameID ( parm1 ) ; } public String getLocalNameFromExpandedNameID ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalNameFromExpandedNameID(" + parm1 + ")" ) ; System . out . println ( "..." + super . getLocalNameFromExpandedNameID ( parm1 ) ) ; DEBUG = true ; } return super . getLocalNameFromExpandedNameID ( parm1 ) ; } public int getExpandedTypeID ( int parm1 ) { if ( DEBUG ) System . out . println ( "getExpandedTypeID(" + parm1 + ")" ) ; return super . getExpandedTypeID ( parm1 ) ; } public int getDocument ( ) { if ( DEBUG ) System . out . println ( "getDocument()" ) ; return super . getDocument ( ) ; } protected int findInSortedSuballocatedIntVector ( SuballocatedIntVector parm1 , int parm2 ) { if ( DEBUG ) { System . out . println ( "findInSortedSubAlloctedVector(" + parm1 + "," + parm2 + ")" ) ; } return super . findInSortedSuballocatedIntVector ( parm1 , parm2 ) ; } public boolean isDocumentAllDeclarationsProcessed ( int parm1 ) { if ( DEBUG ) System . out . println ( "isDocumentAllDeclProc(" + parm1 + ")" ) ; return super . isDocumentAllDeclarationsProcessed ( parm1 ) ; } protected void error ( String parm1 ) { if ( DEBUG ) System . out . println ( "error(" + parm1 + ")" ) ; super . error ( parm1 ) ; } protected int _firstch ( int parm1 ) { if ( DEBUG ) System . out . println ( "_firstch(" + parm1 + ")" ) ; return super . _firstch ( parm1 ) ; } public int getOwnerDocument ( int parm1 ) { if ( DEBUG ) System . out . println ( "getOwnerDoc(" + parm1 + ")" ) ; return super . getOwnerDocument ( parm1 ) ; } protected int _nextsib ( int parm1 ) { if ( DEBUG ) System . out . println ( "_nextSib(" + parm1 + ")" ) ; return super . _nextsib ( parm1 ) ; } public int getNextSibling ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNextSibling(" + parm1 + ")" ) ; return super . getNextSibling ( parm1 ) ; } public boolean getDocumentAllDeclarationsProcessed ( ) { if ( DEBUG ) System . out . println ( "getDocAllDeclProc()" ) ; return super . getDocumentAllDeclarationsProcessed ( ) ; } public int getParent ( int parm1 ) { if ( DEBUG ) System . out . println ( "getParent(" + parm1 + ")" ) ; return super . getParent ( parm1 ) ; } public int getExpandedTypeID ( String parm1 , String parm2 , int parm3 ) { if ( DEBUG ) System . out . println ( "getExpandedTypeID()" ) ; return super . getExpandedTypeID ( parm1 , parm2 , parm3 ) ; } public void setDocumentBaseURI ( String parm1 ) { if ( DEBUG ) System . out . println ( "setDocBaseURI()" ) ; super . setDocumentBaseURI ( parm1 ) ; } public char [ ] getStringValueChunk ( int parm1 , int parm2 , int [ ] parm3 ) { if ( DEBUG ) { System . out . println ( "getStringChunkValue(" + parm1 + "," + parm2 + ")" ) ; } return super . getStringValueChunk ( parm1 , parm2 , parm3 ) ; } public DTMAxisTraverser getAxisTraverser ( int parm1 ) { if ( DEBUG ) System . out . println ( "getAxixTraverser(" + parm1 + ")" ) ; return super . getAxisTraverser ( parm1 ) ; } public DTMAxisIterator getTypedAxisIterator ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "getTypedAxisIterator(" + parm1 + "," + parm2 + ")" ) ; return super . getTypedAxisIterator ( parm1 , parm2 ) ; } public DTMAxisIterator getAxisIterator ( int parm1 ) { if ( DEBUG ) System . out . println ( "getAxisIterator(" + parm1 + ")" ) ; return super . getAxisIterator ( parm1 ) ; } public int getElementById ( String parm1 ) { if ( DEBUG ) System . out . println ( "getElementByID(" + parm1 + ")" ) ; return DTM . NULL ; } public DeclHandler getDeclHandler ( ) { if ( DEBUG ) System . out . println ( "getDeclHandler()" ) ; return null ; } public ErrorHandler getErrorHandler ( ) { if ( DEBUG ) System . out . println ( "getErrorHandler()" ) ; return null ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { if ( DEBUG ) System . out . println ( "get_DTD-SID()" ) ; return null ; } } 	1	['95', '4', '2', '15', '191', '0', '2', '13', '66', '0.920621931', '2509', '1', '2', '0.5', '0.197894737', '1', '25', '25.27368421', '11', '2.0421', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; import org . apache . xalan . xsltc . DOM ; final class PositionCall extends FunctionCall { private int _type = - 1 ; public PositionCall ( QName fname ) { super ( fname ) ; } public PositionCall ( QName fname , int type ) { this ( fname ) ; _type = type ; } public boolean hasPositionCall ( ) { return true ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; SyntaxTreeNode parent = getParent ( ) ; SyntaxTreeNode granny = parent . getParent ( ) ; if ( ( parent instanceof Expression ) && ( granny instanceof Predicate ) ) { _type = ( ( Predicate ) granny ) . getPosType ( ) ; } else { while ( ( granny != null ) && ! ( granny instanceof StepPattern ) ) { parent = granny ; granny = granny . getParent ( ) ; } if ( ( parent instanceof Predicate ) && ( granny instanceof StepPattern ) ) { _type = ( ( StepPattern ) granny ) . getNodeType ( ) ; } } if ( methodGen instanceof CompareGenerator ) { il . append ( ( ( CompareGenerator ) methodGen ) . loadCurrentNode ( ) ) ; } else if ( methodGen instanceof TestGenerator ) { il . append ( new ILOAD ( POSITION_INDEX ) ) ; } else if ( _type == - 1 ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final int getPosition = cpg . addInterfaceMethodref ( NODE_ITERATOR , "getPosition" , "()I" ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKEINTERFACE ( getPosition , 1 ) ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final int pos = cpg . addInterfaceMethodref ( DOM_INTF , "getTypedPosition" , "(II)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _type ) ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( pos , 3 ) ) ; } } } 	0	['4', '4', '0', '20', '20', '0', '1', '20', '4', '0.333333333', '149', '1', '0', '0.979591837', '0.45', '2', '4', '36', '10', '2.75', '0']
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . Reader ; import java . io . InputStream ; import java . io . ByteArrayInputStream ; import java . net . URL ; import java . net . MalformedURLException ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Properties ; import javax . xml . transform . * ; import javax . xml . transform . sax . * ; import javax . xml . transform . dom . * ; import javax . xml . transform . stream . * ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . * ; import org . w3c . dom . Document ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . SourceLoader ; import org . apache . xalan . xsltc . compiler . CompilerException ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; public class TransformerFactoryImpl extends SAXTransformerFactory implements SourceLoader , ErrorListener { private ErrorListener _errorListener = this ; private URIResolver _uriResolver = null ; protected static String _defaultTransletName = "GregorSamsa" ; private Hashtable _piParams = null ; private class PIParamWrapper { public String _media = null ; public String _title = null ; public String _charset = null ; public PIParamWrapper ( String media , String title , String charset ) { _media = media ; _title = title ; _charset = charset ; } } private boolean _debug = false ; private boolean _disableInlining = false ; private int _indentNumber = - 1 ; private XMLReader _xmlReader = null ; public TransformerFactoryImpl ( ) { } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ERROR_LISTENER_NULL_ERR , "TransformerFactory" ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } _errorListener = listener ; } public ErrorListener getErrorListener ( ) { return _errorListener ; } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( name . equals ( "translet-name" ) ) { return _defaultTransletName ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_INVALID_ATTR_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( name . equals ( "translet-name" ) && value instanceof String ) { _defaultTransletName = ( String ) value ; return ; } else if ( name . equals ( "debug" ) ) { if ( value instanceof Boolean ) { _debug = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _debug = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( "disable-inlining" ) ) { if ( value instanceof Boolean ) { _disableInlining = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _disableInlining = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( "indent-number" ) ) { if ( value instanceof String ) { try { _indentNumber = Integer . parseInt ( ( String ) value ) ; return ; } catch ( NumberFormatException e ) { } } else if ( value instanceof Integer ) { _indentNumber = ( ( Integer ) value ) . intValue ( ) ; return ; } } final ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_INVALID_ATTR_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } public boolean getFeature ( String name ) { String [ ] features = { DOMSource . FEATURE , DOMResult . FEATURE , SAXSource . FEATURE , SAXResult . FEATURE , StreamSource . FEATURE , StreamResult . FEATURE } ; for ( int i = 0 ; i < features . length ; i ++ ) { if ( name . equals ( features [ i ] ) ) { return true ; } } return false ; } public URIResolver getURIResolver ( ) { return _uriResolver ; } public void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { if ( _piParams == null ) { _piParams = new Hashtable ( ) ; } _piParams . put ( source , new PIParamWrapper ( media , title , charset ) ) ; return source ; } public Transformer newTransformer ( ) throws TransformerConfigurationException { TransformerImpl result = new TransformerImpl ( new Properties ( ) , _indentNumber , this ) ; if ( _uriResolver != null ) { result . setURIResolver ( _uriResolver ) ; } return result ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { final Templates templates = newTemplates ( source ) ; final Transformer transformer = templates . newTransformer ( ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return ( transformer ) ; } private void passWarningsToListener ( Vector messages ) throws TransformerException { if ( _errorListener == null || messages == null ) { return ; } final int count = messages . size ( ) ; for ( int pos = 0 ; pos < count ; pos ++ ) { String message = messages . elementAt ( pos ) . toString ( ) ; _errorListener . error ( new TransformerConfigurationException ( message ) ) ; } } private void passErrorsToListener ( Vector messages ) { try { if ( _errorListener == null || messages == null ) { return ; } final int count = messages . size ( ) ; for ( int pos = 0 ; pos < count ; pos ++ ) { String message = messages . elementAt ( pos ) . toString ( ) ; _errorListener . error ( new TransformerException ( message ) ) ; } } catch ( TransformerException e ) { } } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { final XSLTC xsltc = new XSLTC ( ) ; if ( _debug ) xsltc . setDebug ( true ) ; if ( _disableInlining ) xsltc . setTemplateInlining ( false ) ; xsltc . init ( ) ; if ( _uriResolver != null ) { xsltc . setSourceLoader ( this ) ; } if ( ( _piParams != null ) && ( _piParams . get ( source ) != null ) ) { PIParamWrapper p = ( PIParamWrapper ) _piParams . get ( source ) ; if ( p != null ) { xsltc . setPIParameters ( p . _media , p . _title , p . _charset ) ; } } final InputSource input = Util . getInputSource ( xsltc , source ) ; byte [ ] [ ] bytecodes = xsltc . compile ( null , input ) ; final String transletName = xsltc . getClassName ( ) ; if ( _errorListener != this ) { try { passWarningsToListener ( xsltc . getWarnings ( ) ) ; } catch ( TransformerException e ) { throw new TransformerConfigurationException ( e ) ; } } else { xsltc . printWarnings ( ) ; } if ( bytecodes == null ) { if ( _errorListener != null ) { passErrorsToListener ( xsltc . getErrors ( ) ) ; } else { xsltc . printErrors ( ) ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_COMPILE_ERR ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } return new TemplatesImpl ( bytecodes , transletName , xsltc . getOutputProperties ( ) , _indentNumber , this ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { final TemplatesHandlerImpl handler = new TemplatesHandlerImpl ( _indentNumber , this ) ; handler . init ( ) ; if ( _uriResolver != null ) { handler . setURIResolver ( _uriResolver ) ; } return handler ; } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { final Transformer transformer = newTransformer ( ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return new TransformerHandlerImpl ( ( TransformerImpl ) transformer ) ; } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { final Transformer transformer = newTransformer ( src ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return new TransformerHandlerImpl ( ( TransformerImpl ) transformer ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { final Transformer transformer = templates . newTransformer ( ) ; final TransformerImpl internal = ( TransformerImpl ) transformer ; return new TransformerHandlerImpl ( internal ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new org . apache . xalan . xsltc . trax . TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException e1 ) { if ( _errorListener != null ) { try { _errorListener . fatalError ( e1 ) ; return null ; } catch ( TransformerException e2 ) { new TransformerConfigurationException ( e2 ) ; } } throw e1 ; } } public void error ( TransformerException e ) throws TransformerException { System . err . println ( "ERROR: " + e . getMessageAndLocation ( ) ) ; Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( "     : " + wrapped . getMessage ( ) ) ; } throw e ; } public void fatalError ( TransformerException e ) throws TransformerException { System . err . println ( "FATAL: " + e . getMessageAndLocation ( ) ) ; Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( "     : " + wrapped . getMessage ( ) ) ; } throw e ; } public void warning ( TransformerException e ) throws TransformerException { System . err . println ( "WARNING: " + e . getMessageAndLocation ( ) ) ; Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( "       : " + wrapped . getMessage ( ) ) ; } } public InputSource loadSource ( String href , String context , XSLTC xsltc ) { try { if ( _uriResolver != null ) { final Source source = _uriResolver . resolve ( href , context ) ; if ( source != null ) { return Util . getInputSource ( xsltc , source ) ; } } } catch ( TransformerException e ) { } return null ; } public XMLReader getXMLReader ( ) throws Exception { if ( _xmlReader == null ) { final SAXParserFactory pfactory = SAXParserFactory . newInstance ( ) ; pfactory . setNamespaceAware ( true ) ; _xmlReader = pfactory . newSAXParser ( ) . getXMLReader ( ) ; } return _xmlReader ; } } 	1	['27', '3', '0', '11', '87', '201', '5', '10', '24', '0.783653846', '697', '1', '0', '0.444444444', '0.171328671', '1', '2', '24.51851852', '3', '1.0741', '2']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; public class ElemVariablePsuedo extends ElemVariable { XUnresolvedVariableSimple m_lazyVar ; public void setSelect ( XPath v ) { super . setSelect ( v ) ; m_lazyVar = new XUnresolvedVariableSimple ( this ) ; } public void execute ( TransformerImpl transformer ) throws TransformerException { transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , m_lazyVar ) ; } } 	0	['3', '4', '0', '8', '9', '1', '1', '7', '3', '0.5', '26', '0', '1', '0.99086758', '0.555555556', '0', '0', '7.333333333', '1', '0.6667', '0']
package org . apache . xpath . axes ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . Serializable ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; public abstract class LocPathIterator extends PredicatedNodeTest implements Cloneable , DTMIterator , java . io . Serializable , PathComponent { protected LocPathIterator ( ) { } protected LocPathIterator ( PrefixResolver nscontext ) { setLocPathIterator ( this ) ; m_prefixResolver = nscontext ; } protected LocPathIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { this ( compiler , opPos , analysis , true ) ; } protected LocPathIterator ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { setLocPathIterator ( this ) ; } public int getAnalysisBits ( ) { int axis = getAxis ( ) ; int bit = WalkerFactory . getAnalysisBitFromAxes ( axis ) ; return bit ; } private void readObject ( java . io . ObjectInputStream stream ) throws java . io . IOException , javax . xml . transform . TransformerException { try { stream . defaultReadObject ( ) ; m_clones = new IteratorPool ( this ) ; } catch ( ClassNotFoundException cnfe ) { throw new javax . xml . transform . TransformerException ( cnfe ) ; } } public void setEnvironment ( Object environment ) { } public DTM getDTM ( int nodeHandle ) { return m_execContext . getDTM ( nodeHandle ) ; } public DTMManager getDTMManager ( ) { return m_execContext . getDTMManager ( ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XNodeSet iter = new XNodeSet ( ( LocPathIterator ) m_clones . getInstance ( ) ) ; iter . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; return iter ; } public void executeCharsToContentHandler ( XPathContext xctxt , org . xml . sax . ContentHandler handler ) throws javax . xml . transform . TransformerException , org . xml . sax . SAXException { LocPathIterator clone = ( LocPathIterator ) m_clones . getInstance ( ) ; int current = xctxt . getCurrentNode ( ) ; clone . setRoot ( current , xctxt ) ; int node = clone . nextNode ( ) ; DTM dtm = clone . getDTM ( node ) ; clone . detach ( ) ; if ( node != DTM . NULL ) { dtm . dispatchCharactersEvents ( node , handler , false ) ; } } public DTMIterator asIterator ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { XNodeSet iter = new XNodeSet ( ( LocPathIterator ) m_clones . getInstance ( ) ) ; iter . setRoot ( contextNode , xctxt ) ; return iter ; } public boolean isNodesetExpr ( ) { return true ; } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator iter = ( DTMIterator ) m_clones . getInstance ( ) ; int current = xctxt . getCurrentNode ( ) ; iter . setRoot ( current , xctxt ) ; int next = iter . nextNode ( ) ; iter . detach ( ) ; return next ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( asNode ( xctxt ) != DTM . NULL ) ; } public void setIsTopLevel ( boolean b ) { m_isTopLevel = b ; } public boolean getIsTopLevel ( ) { return m_isTopLevel ; } public void setRoot ( int context , Object environment ) { m_context = context ; XPathContext xctxt = ( XPathContext ) environment ; m_execContext = xctxt ; m_cdtm = xctxt . getDTM ( context ) ; m_currentContextNode = context ; if ( null == m_prefixResolver ) m_prefixResolver = xctxt . getNamespaceContext ( ) ; m_lastFetched = DTM . NULL ; m_foundLast = false ; m_pos = 0 ; m_length = - 1 ; if ( m_isTopLevel ) this . m_stackFrame = xctxt . getVarStack ( ) . getStackFrame ( ) ; } protected void setNextPosition ( int next ) { assertion ( false , "setNextPosition not supported in this iterator!" ) ; } public final int getCurrentPos ( ) { return m_pos ; } public void setShouldCacheNodes ( boolean b ) { assertion ( false , "setShouldCacheNodes not supported by this iterater!" ) ; } public boolean isMutable ( ) { return false ; } public void setCurrentPos ( int i ) { assertion ( false , "setCurrentPos not supported by this iterator!" ) ; } public void incrementCurrentPos ( ) { m_pos ++ ; } public int size ( ) { assertion ( false , "size() not supported by this iterator!" ) ; return 0 ; } public int item ( int index ) { assertion ( false , "item(int index) not supported by this iterator!" ) ; return 0 ; } public void setItem ( int node , int index ) { assertion ( false , "setItem not supported by this iterator!" ) ; } public int getLength ( ) { boolean isPredicateTest = ( this == m_execContext . getSubContextList ( ) ) ; int predCount = getPredicateCount ( ) ; if ( - 1 != m_length && ! isPredicateTest ) return m_length ; if ( m_foundLast ) return m_pos ; int pos = ( m_predicateIndex >= 0 ) ? getProximityPosition ( ) : m_pos ; LocPathIterator clone ; try { clone = ( LocPathIterator ) clone ( ) ; } catch ( CloneNotSupportedException cnse ) { return - 1 ; } if ( predCount > 0 && isPredicateTest ) { clone . m_predCount = predCount - 1 ; } int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { pos ++ ; } if ( ! isPredicateTest ) m_length = pos ; return pos ; } public boolean isFresh ( ) { return ( m_pos == 0 ) ; } public int previousNode ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_ITERATE , null ) ) ; } public int getWhatToShow ( ) { return DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ; } public DTMFilter getFilter ( ) { return null ; } public int getRoot ( ) { return m_context ; } public boolean getExpandEntityReferences ( ) { return true ; } protected boolean m_allowDetach = true ; public void allowDetachToRelease ( boolean allowRelease ) { m_allowDetach = allowRelease ; } public void detach ( ) { if ( m_allowDetach ) { m_execContext = null ; m_cdtm = null ; m_length = - 1 ; m_pos = 0 ; m_lastFetched = DTM . NULL ; m_context = DTM . NULL ; m_currentContextNode = DTM . NULL ; m_clones . freeInstance ( this ) ; } } public void reset ( ) { assertion ( false , "This iterator can not reset!" ) ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { LocPathIterator clone ; clone = ( LocPathIterator ) m_clones . getInstanceOrThrow ( ) ; clone . m_execContext = m_execContext ; clone . m_cdtm = m_cdtm ; clone . m_context = m_context ; clone . m_currentContextNode = m_currentContextNode ; clone . m_stackFrame = m_stackFrame ; return clone ; } public abstract int nextNode ( ) ; protected int returnNextNode ( int nextNode ) { if ( DTM . NULL != nextNode ) { m_pos ++ ; } m_lastFetched = nextNode ; if ( DTM . NULL == nextNode ) m_foundLast = true ; return nextNode ; } public int getCurrentNode ( ) { return m_lastFetched ; } public void runTo ( int index ) { if ( m_foundLast || ( ( index >= 0 ) && ( index <= getCurrentPos ( ) ) ) ) return ; int n ; if ( - 1 == index ) { while ( DTM . NULL != ( n = nextNode ( ) ) ) ; } else { while ( DTM . NULL != ( n = nextNode ( ) ) ) { if ( getCurrentPos ( ) >= index ) break ; } } } public final boolean getFoundLast ( ) { return m_foundLast ; } public final XPathContext getXPathContext ( ) { return m_execContext ; } public final int getContext ( ) { return m_context ; } public final int getCurrentContextNode ( ) { return m_currentContextNode ; } public final void setCurrentContextNode ( int n ) { m_currentContextNode = n ; } public final PrefixResolver getPrefixResolver ( ) { if ( null == m_prefixResolver ) { m_prefixResolver = ( PrefixResolver ) getExpressionOwner ( ) ; } return m_prefixResolver ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitLocationPath ( owner , this ) ) { visitor . visitStep ( owner , this ) ; callPredicateVisitors ( visitor ) ; } } transient protected IteratorPool m_clones = new IteratorPool ( this ) ; transient protected DTM m_cdtm ; transient int m_stackFrame = - 1 ; private boolean m_isTopLevel = false ; transient public int m_lastFetched = DTM . NULL ; transient protected int m_context = DTM . NULL ; transient protected int m_currentContextNode = DTM . NULL ; transient protected int m_pos = 0 ; transient protected int m_length = - 1 ; private PrefixResolver m_prefixResolver ; transient protected XPathContext m_execContext ; public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } public int getLastPos ( XPathContext xctxt ) { return getLength ( ) ; } } 	1	['52', '4', '8', '46', '84', '1030', '28', '22', '45', '0.85130719', '658', '0.833333333', '4', '0.616', '0.145104895', '2', '9', '11.42307692', '10', '1.3846', '1']
package org . apache . xalan . templates ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . ExpressionOwner ; public class XSLTVisitor extends XPathVisitor { boolean visitInstruction ( ElemTemplateElement elem ) { return true ; } boolean visitStylesheet ( ElemTemplateElement elem ) { return true ; } boolean visitTopLevelInstruction ( ElemTemplateElement elem ) { return true ; } boolean visitTopLevelVariableOrParamDecl ( ElemTemplateElement elem ) { return true ; } boolean visitVariableOrParamDecl ( ElemVariable elem ) { return true ; } boolean visitLiteralResultElement ( ElemLiteralResult elem ) { return true ; } boolean visitAVT ( AVT elem ) { return true ; } boolean visitExtensionElement ( ElemExtensionCall elem ) { return true ; } } 	0	['9', '2', '1', '21', '10', '36', '20', '6', '1', '2', '28', '0', '0', '0.6', '0.314814815', '0', '0', '2.111111111', '1', '0.8889', '0']
package org . apache . xalan . xsltc . trax ; import java . util . Stack ; import java . util . Vector ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Comment ; import org . w3c . dom . DOMException ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; import org . w3c . dom . Attr ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . SAXException ; import org . apache . xalan . xsltc . runtime . Constants ; public class SAX2DOM implements ContentHandler , LexicalHandler , Constants { private Document _root = null ; private Stack _nodeStk = new Stack ( ) ; private Vector _namespaceDecls = null ; public SAX2DOM ( ) throws ParserConfigurationException { final DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; _root = factory . newDocumentBuilder ( ) . newDocument ( ) ; } public SAX2DOM ( Node root ) throws ParserConfigurationException { if ( root != null ) { _root = ( Document ) root ; } else { final DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; _root = factory . newDocumentBuilder ( ) . newDocument ( ) ; } } public Node getDOM ( ) { return _root ; } public void characters ( char [ ] ch , int start , int length ) { final Node last = ( Node ) _nodeStk . peek ( ) ; if ( last != _root ) { final String text = new String ( ch , start , length ) ; last . appendChild ( _root . createTextNode ( text ) ) ; } } public void startDocument ( ) { _nodeStk . push ( _root ) ; } public void endDocument ( ) { } public void startElement ( String namespace , String localName , String qName , Attributes attrs ) { final Element tmp = ( Element ) _root . createElementNS ( namespace , qName ) ; if ( _namespaceDecls != null ) { final int nDecls = _namespaceDecls . size ( ) ; for ( int i = 0 ; i < nDecls ; i ++ ) { final String prefix = ( String ) _namespaceDecls . elementAt ( i ++ ) ; if ( prefix == null || prefix . equals ( EMPTYSTRING ) ) { tmp . setAttributeNS ( XMLNS_URI , XMLNS_PREFIX , ( String ) _namespaceDecls . elementAt ( i ) ) ; } else { tmp . setAttributeNS ( XMLNS_URI , XMLNS_STRING + prefix , ( String ) _namespaceDecls . elementAt ( i ) ) ; } } _namespaceDecls . clear ( ) ; } final int nattrs = attrs . getLength ( ) ; for ( int i = 0 ; i < nattrs ; i ++ ) { if ( attrs . getLocalName ( i ) == null ) { tmp . setAttribute ( attrs . getQName ( i ) , attrs . getValue ( i ) ) ; } else { tmp . setAttributeNS ( attrs . getURI ( i ) , attrs . getQName ( i ) , attrs . getValue ( i ) ) ; } } Node last = ( Node ) _nodeStk . peek ( ) ; last . appendChild ( tmp ) ; _nodeStk . push ( tmp ) ; } public void endElement ( String namespace , String localName , String qName ) { _nodeStk . pop ( ) ; } public void startPrefixMapping ( String prefix , String uri ) { if ( _namespaceDecls == null ) { _namespaceDecls = new Vector ( 2 ) ; } _namespaceDecls . addElement ( prefix ) ; _namespaceDecls . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) { } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { } public void processingInstruction ( String target , String data ) { final Node last = ( Node ) _nodeStk . peek ( ) ; ProcessingInstruction pi = _root . createProcessingInstruction ( target , data ) ; if ( pi != null ) last . appendChild ( pi ) ; } public void setDocumentLocator ( Locator locator ) { } public void skippedEntity ( String name ) { } public void comment ( char [ ] ch , int start , int length ) { final Node last = ( Node ) _nodeStk . peek ( ) ; Comment comment = _root . createComment ( new String ( ch , start , length ) ) ; if ( comment != null ) last . appendChild ( comment ) ; } public void startCDATA ( ) { } public void endCDATA ( ) { } public void startEntity ( java . lang . String name ) { } public void endDTD ( ) { } public void endEntity ( String name ) { } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { } } 	1	['21', '1', '0', '2', '51', '134', '1', '1', '21', '0.716666667', '292', '1', '0', '0', '0.265306122', '0', '0', '12.76190476', '7', '1.381', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . * ; import org . apache . xalan . xsltc . compiler . util . * ; final class DocumentCall extends FunctionCall { private Expression _uri = null ; private Expression _base = null ; private Type _uriType ; public DocumentCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int ac = argumentCount ( ) ; if ( ( ac < 1 ) || ( ac > 2 ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } _uri = argument ( 0 ) ; if ( _uri instanceof LiteralExpr ) { LiteralExpr expr = ( LiteralExpr ) _uri ; if ( expr . getValue ( ) . equals ( EMPTYSTRING ) ) { Stylesheet stylesheet = getStylesheet ( ) ; if ( stylesheet == null ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } _uri = new LiteralExpr ( stylesheet . getSystemId ( ) , EMPTYSTRING ) ; } } _uriType = _uri . typeCheck ( stable ) ; if ( ( _uriType != Type . NodeSet ) && ( _uriType != Type . String ) ) { _uri = new CastExpr ( _uri , Type . String ) ; } if ( ac == 2 ) { _base = argument ( 1 ) ; final Type baseType = _base . typeCheck ( stable ) ; if ( baseType . identicalTo ( Type . Node ) ) { _base = new CastExpr ( _base , Type . NodeSet ) ; } else if ( baseType . identicalTo ( Type . NodeSet ) ) { } else { ErrorMsg msg = new ErrorMsg ( ErrorMsg . DOCUMENT_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int domField = cpg . addFieldref ( classGen . getClassName ( ) , DOM_FIELD , DOM_INTF_SIG ) ; final String docParamList = "(" + OBJECT_SIG + STRING_SIG + STRING_SIG + TRANSLET_SIG + DOM_INTF_SIG + ")" + NODE_ITERATOR_SIG ; final int docIdx = cpg . addMethodref ( LOAD_DOCUMENT_CLASS , "document" , docParamList ) ; final int uriIdx = cpg . addInterfaceMethodref ( DOM_INTF , "getDocumentURI" , "(I)" + STRING_SIG ) ; final int nextIdx = cpg . addInterfaceMethodref ( NODE_ITERATOR , NEXT , NEXT_SIG ) ; _uri . translate ( classGen , methodGen ) ; if ( _uriType == Type . NodeSet ) _uri . startResetIterator ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; if ( _base != null ) { _base . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( nextIdx , 1 ) ) ; } else { il . append ( methodGen . loadContextNode ( ) ) ; } il . append ( new INVOKEINTERFACE ( uriIdx , 2 ) ) ; il . append ( new PUSH ( cpg , getStylesheet ( ) . getSystemId ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( DUP ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( new INVOKESTATIC ( docIdx ) ) ; } } 	0	['3', '4', '0', '26', '33', '0', '0', '26', '3', '0.166666667', '264', '1', '3', '0.979591837', '0.444444444', '4', '15', '86', '3', '1.3333', '0']
package org . apache . xpath . axes ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . res . XPATHErrorResources ; import org . apache . xalan . res . XSLMessages ; public class AxesWalker extends PredicatedNodeTest implements Cloneable , PathComponent , ExpressionOwner { public AxesWalker ( LocPathIterator locPathIterator , int axis ) { super ( locPathIterator ) ; m_axis = axis ; } public final WalkingIterator wi ( ) { return ( WalkingIterator ) m_lpi ; } public void init ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { initPredicateInfo ( compiler , opPos ) ; } public Object clone ( ) throws CloneNotSupportedException { AxesWalker clone = ( AxesWalker ) super . clone ( ) ; return clone ; } AxesWalker cloneDeep ( WalkingIterator cloneOwner , Vector cloneList ) throws CloneNotSupportedException { AxesWalker clone = findClone ( this , cloneList ) ; if ( null != clone ) return clone ; clone = ( AxesWalker ) this . clone ( ) ; clone . setLocPathIterator ( cloneOwner ) ; if ( null != cloneList ) { cloneList . addElement ( this ) ; cloneList . addElement ( clone ) ; } if ( wi ( ) . m_lastUsedWalker == this ) cloneOwner . m_lastUsedWalker = clone ; if ( null != m_nextWalker ) clone . m_nextWalker = m_nextWalker . cloneDeep ( cloneOwner , cloneList ) ; if ( null != cloneList ) { if ( null != m_prevWalker ) clone . m_prevWalker = m_prevWalker . cloneDeep ( cloneOwner , cloneList ) ; } else { if ( null != m_nextWalker ) clone . m_nextWalker . m_prevWalker = clone ; } return clone ; } static AxesWalker findClone ( AxesWalker key , Vector cloneList ) { if ( null != cloneList ) { int n = cloneList . size ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( key == cloneList . elementAt ( i ) ) return ( AxesWalker ) cloneList . elementAt ( i + 1 ) ; } } return null ; } public void detach ( ) { m_currentNode = DTM . NULL ; m_dtm = null ; m_isFresh = true ; m_root = DTM . NULL ; } public int getRoot ( ) { return m_root ; } public int getAnalysisBits ( ) { int axis = getAxis ( ) ; int bit = WalkerFactory . getAnalysisBitFromAxes ( axis ) ; return bit ; } public void setRoot ( int root ) { XPathContext xctxt = wi ( ) . getXPathContext ( ) ; m_dtm = xctxt . getDTM ( root ) ; m_traverser = m_dtm . getAxisTraverser ( m_axis ) ; m_isFresh = true ; m_foundLast = false ; m_root = root ; m_currentNode = root ; if ( DTM . NULL == root ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_SETTING_WALKER_ROOT_TO_NULL , null ) ) ; } resetProximityPositions ( ) ; } public final int getCurrentNode ( ) { return m_currentNode ; } public void setNextWalker ( AxesWalker walker ) { m_nextWalker = walker ; } public AxesWalker getNextWalker ( ) { return m_nextWalker ; } public void setPrevWalker ( AxesWalker walker ) { m_prevWalker = walker ; } public AxesWalker getPrevWalker ( ) { return m_prevWalker ; } private int returnNextNode ( int n ) { return n ; } protected int getNextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( m_isFresh ) { m_currentNode = m_traverser . first ( m_root ) ; m_isFresh = false ; } else if ( DTM . NULL != m_currentNode ) { m_currentNode = m_traverser . next ( m_root , m_currentNode ) ; } if ( DTM . NULL == m_currentNode ) this . m_foundLast = true ; return m_currentNode ; } public int nextNode ( ) { int nextNode = DTM . NULL ; AxesWalker walker = wi ( ) . getLastUsedWalker ( ) ; while ( true ) { if ( null == walker ) break ; nextNode = walker . getNextNode ( ) ; if ( DTM . NULL == nextNode ) { walker = walker . m_prevWalker ; } else { if ( walker . acceptNode ( nextNode ) != DTMIterator . FILTER_ACCEPT ) { continue ; } if ( null == walker . m_nextWalker ) { wi ( ) . setLastUsedWalker ( walker ) ; break ; } else { AxesWalker prev = walker ; walker = walker . m_nextWalker ; walker . setRoot ( nextNode ) ; walker . m_prevWalker = prev ; continue ; } } } return nextNode ; } public int getLastPos ( XPathContext xctxt ) { int pos = getProximityPosition ( ) ; AxesWalker walker ; try { walker = ( AxesWalker ) clone ( ) ; } catch ( CloneNotSupportedException cnse ) { return - 1 ; } walker . setPredicateCount ( walker . getPredicateCount ( ) - 1 ) ; walker . setNextWalker ( null ) ; walker . setPrevWalker ( null ) ; WalkingIterator lpi = wi ( ) ; AxesWalker savedWalker = lpi . getLastUsedWalker ( ) ; try { lpi . setLastUsedWalker ( walker ) ; int next ; while ( DTM . NULL != ( next = walker . nextNode ( ) ) ) { pos ++ ; } } finally { lpi . setLastUsedWalker ( savedWalker ) ; } return pos ; } private DTM m_dtm ; public void setDefaultDTM ( DTM dtm ) { m_dtm = dtm ; } public DTM getDTM ( int node ) { return wi ( ) . getXPathContext ( ) . getDTM ( node ) ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return m_axis ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitStep ( owner , this ) ) { callPredicateVisitors ( visitor ) ; if ( null != m_nextWalker ) { m_nextWalker . callVisitors ( this , visitor ) ; } } } public Expression getExpression ( ) { return m_nextWalker ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_nextWalker = ( AxesWalker ) exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; AxesWalker walker = ( AxesWalker ) expr ; if ( this . m_axis != walker . m_axis ) return false ; return true ; } transient int m_root = DTM . NULL ; private transient int m_currentNode = DTM . NULL ; transient boolean m_isFresh ; protected AxesWalker m_nextWalker ; AxesWalker m_prevWalker ; protected int m_axis = - 1 ; protected DTMAxisTraverser m_traverser ; } 	1	['27', '4', '2', '21', '53', '257', '8', '15', '23', '0.807692308', '451', '0.625', '4', '0.747572816', '0.138888889', '1', '4', '15.40740741', '5', '1.5926', '1']
