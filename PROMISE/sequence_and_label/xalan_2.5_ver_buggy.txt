package org . apache . xpath . res ; public class XPATHErrorResources_sv extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Funktionen current() är inte tillåten i ett matchningsmönster!" } , { ER_CURRENT_TAKES_NO_ARGS , "Funktionen current() tar inte emot argument!" } , { ER_DOCUMENT_REPLACED , "Implementeringen av funktionen document() har ersatts av org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Kontext saknar ägardokument!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() har för många argument." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() har för många argument." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() har för många argument." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() har för många argument." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() har för många argument." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() har för många argument." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string.length() har för många argument." } , { ER_TRANSLATE_TAKES_3_ARGS , "Funktionen translate() tar emot tre argument!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Funktionen unparsed-entity-uri borde ta emot ett argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Namespace-axel inte implementerad än!" } , { ER_UNKNOWN_AXIS , "okänd axel: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "okänd matchningshandling!" } , { ER_INCORRECT_ARG_LENGTH , "Nodtests argumentlängd i processing-instruction() är inte korrekt!" } , { ER_CANT_CONVERT_TO_NUMBER , "Kan inte konvertera {0} till ett nummer" } , { ER_CANT_CONVERT_TO_NODELIST , "Kan inte konvertera {0} till en NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Kan inte konvertera {0} till en NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Kan inte konvertera {0} till en type//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Matchningsmönster i getMatchScore förväntat!" } , { ER_COULDNOT_GET_VAR_NAMED , "Kunde inte hämta variabeln {0}" } , { ER_UNKNOWN_OPCODE , "FEL! Okänd op-kod: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Ytterligare otillåtna tecken: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Litteral omges av fel sorts citationstecken... dubbla citationstecken förväntade!" } , { ER_EXPECTED_SINGLE_QUOTE , "Litteral omges av fel sorts citationstecken... enkla citationstecken förväntade!" } , { ER_EMPTY_EXPRESSION , "Tomt uttryck!" } , { ER_EXPECTED_BUT_FOUND , "{0} förväntat, men hittade: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programmerares försäkran är inte korrekt! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...)-argument är inte längre valfri med 19990709 XPath-utkast." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Hittade ',' men inget föregående argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Hittade ',' men inget efterföljande argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predikat]' or '.[predikat]' är otillåten syntax.  Använd 'self::node()[predikat]' istället." } , { ER_ILLEGAL_AXIS_NAME , "otillåtet axel-namn: {0}" } , { ER_UNKNOWN_NODETYPE , "okänd nodtyp: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Mönsterlitteral {0} måste sättas inom citationstecken!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} kunde inte formateras till ett nummer" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Kunde inte skapa XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Fel! Hittade inte xpath select-uttryck (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "FEL! Hittade inte ENDOP efter OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Fel inträffade!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference angiven för variabel som är utanför sammanhanget eller som saknar definition!  Namn = {0}" } , { ER_AXES_NOT_ALLOWED , "Enbart barn::- och attribut::- axlar är tillåtna i matchningsmönster!  Regelvidriga axlar = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() har ett felaktigt antal argument." } , { ER_COUNT_TAKES_1_ARG , "Funktionen count borde ta emot ett argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Hittade inte funktionen: {0}" } , { ER_UNSUPPORTED_ENCODING , "Ej understödd kodning: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Problem inträffade i DTM i getNextSibling... försöker återhämta" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programmerarfel: EmptyNodeList kan inte skrivas till." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory understöds inte av XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource source) understöds inte av XPathContext! Kan inte öppna {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API-tecken(char ch[]... hanteras inte av DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... hanteras inte av DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison kan inte hantera noder av typen {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper kan inte hantera noder av typen {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse-fel: SystemID - {0} rad - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse-fel" } , { ER_INVALID_UTF16_SURROGATE , "Ogiltigt UTF-16-surrogat upptäckt: {0} ?" } , { ER_OIERROR , "IO-fel" } , { ER_CANNOT_CREATE_URL , "Kan inte skapa url för: {0}" } , { ER_XPATH_READOBJECT , "I XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "funktionstecken saknas." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Kan inte hantera XPath-typ: {0}" } , { ER_NODESET_NOT_MUTABLE , "NodeSet är oföränderlig" } , { ER_NODESETDTM_NOT_MUTABLE , "NodeSetDTM är oföränderlig" } , { ER_VAR_NOT_RESOLVABLE , "Variabel ej lösbar: {0}" } , { ER_NULL_ERROR_HANDLER , "Null error handler" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programmerares försäkran: okänd op-kod: {0}" } , { ER_ZERO_OR_ONE , "0 eller 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() understöds inte av XRTreeFragSelectWrapper!" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() understöds inte av XRTreeFragSelectWrapper!" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() understöds inte av XRStringForChars!" } , { ER_COULD_NOT_FIND_VAR , "Hittade inte variabeln med namn {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars kan inte ta en sträng som argument" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer-argumentet får inte vara null" } , { ER_TWO_OR_THREE , "2 eller 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variabeln användes innan den bands!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB kan inte ha en sträng som argument!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Fel! Anger roten för en \"walker\" till null!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Detta NodeSetDTM kan inte iterera till en tidigare nod!" } , { ER_NODESET_CANNOT_ITERATE , "Detta NodeSet kan inte iterera till en tidigare nod!" } , { ER_NODESETDTM_CANNOT_INDEX , "Detta NodeSetDTM har inte funktioner för indexering och räkning!" } , { ER_NODESET_CANNOT_INDEX , "Detta NodeSet har inte funktioner för indexering och räkning!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Det går inte att anropa setShouldCacheNodes efter att nextNode har anropats!" } , { ER_ONLY_ALLOWS , "{0} tillåter bara {1} argument" } , { ER_UNKNOWN_STEP , "Programmerarkontroll i getNextStepPos: okänt steg Typ: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "En relativ sökväg förväntades efter token '/' eller '//'." } , { ER_EXPECTED_LOC_PATH , "En plats förväntades, men följande token påträffades:  {0}" } , { ER_EXPECTED_LOC_STEP , "Ett platssteg förväntades efter token  '/' eller '//'." } , { ER_EXPECTED_NODE_TEST , "Ett nodtest som matchar antingen NCName:* eller QName förväntades." } , { ER_EXPECTED_STEP_PATTERN , "Ett stegmönster förväntades, men '/' påträffades." } , { ER_EXPECTED_REL_PATH_PATTERN , "Ett mönster för relativ sökväg förväntades." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Det går inte att konvertera {0} till ett Booleskt värde." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Det går inte att konvertera {0} till en enda nod. Gäller typerna ANY_UNORDERED_NODE_TYPE och FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Det går inte att erhålla längd för ögonblicksbild på typ: {0}. Gäller typerna UNORDERED_NODE_SNAPSHOT_TYPE och ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Det går inte att iterera över den icke itererbara typen: {0}" } , { ER_DOC_MUTATED , "Dokumentet har ändrats sedan resultatet genererades. Iterering ogiltig." } , { ER_INVALID_XPATH_TYPE , "Ogiltigt XPath-typargument: {0}" } , { ER_EMPTY_XPATH_RESULT , "Tomt XPath-resultatobjekt" } , { ER_INCOMPATIBLE_TYPES , "Den genererade typen: {0} kan inte bearbetas i den angivna typen: {1}" } , { ER_NULL_RESOLVER , "Det går inte att lösa prefixet utan prefixlösare." } , { ER_CANT_CONVERT_TO_STRING , "Det går inte att konvertera {0} till en sträng." } , { ER_NON_SNAPSHOT_TYPE , "Det går inte att anropa snapshotItem på typ: {0}. Metoden gäller typerna UNORDERED_NODE_SNAPSHOT_TYPE och ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Kontextnoden tillhör inte dokumentet som är bundet till denna XPathEvaluator." } , { ER_WRONG_NODETYPE , "Kontextnoden kan inte hanteras." } , { ER_XPATH_ERROR , "Okänt fel i XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "locale-namnet i format-number-funktionen ännu inte hanterat!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL-Egenskap understöds inte: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Gör för närvarande inte någonting med namespace {0} i egenskap: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException vid försök att få tillgång till XSL-systemegenskap: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Gammal syntax: quo(...) är inte längre definierad i XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath behöver ett deriverat objekt för att implementera nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "funktionstecken saknas." } , { WG_COULDNOT_FIND_FUNCTION , "Hittade inte funktion: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Kan inte skapa URL från: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Alternativet -E understöds inte för DTM-tolk" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference angiven för variabel som är utanför sammanhanget eller som saknar definition!  Namn = {0}" } , { WG_UNSUPPORTED_ENCODING , "Ej understödd kodning: {0}" } , { "ui_language" , "sv" } , { "help_language" , "sv" } , { "language" , "sv" } , { "BAD_CODE" , "Parameter till createMessage ligger utanför tillåtet intervall" } , { "FORMAT_FAILED" , "Undantag utlöst vid messageFormat-anrop" } , { "version" , ">>>>>>> Xalan Version" } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Rad //" } , { "column" , "Kolumn //" } , { "xsldone" , "XSLProcessor färdig" } , { "xpath_option" , "xpath-alternativ" } , { "optionIN" , "    [-in inputXMLURL]" } , { "optionSelect" , "[-select xpath-uttryck]" } , { "optionMatch" , "   [-match matchningsmönster (för matchningsdiagnostik)]" } , { "optionAnyExpr" , "Eller bara ett xpath-uttryck kommer att göra en diagnostik-dump" } , { "noParsermsg1" , "XSL-Process misslyckades." } , { "noParsermsg2" , "** Hittade inte tolk **" } , { "noParsermsg3" , "Vänligen kontrollera din classpath" } , { "noParsermsg4" , "Om du inte har IBMs XML-Tolk för Java, kan du ladda ner den från" } , { "noParsermsg5" , "IBMs AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "DÅLIG_KOD" ; public static final String FORMAT_FAILDE = "FORMATTERING_MISSLYCKADES" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//fel" ; public static final String ERROR_HEADER = "Fel: " ; public static final String WARNING_HEADER = "Varning: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MÖNSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.428571429', '1872', '0', '0', '0.976190476', '1', '0', '0', '618.3333333', '1', '0.3333', '1']
package org . apache . xalan . lib ; import java . util . Hashtable ; import java . util . StringTokenizer ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . xslt . EnvironmentCheck ; import org . apache . xpath . NodeSet ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . w3c . dom . traversal . NodeIterator ; import org . xml . sax . SAXNotSupportedException ; public class Extensions { private static Document m_doc = null ; private static Extensions m_instance = new Extensions ( ) ; private Extensions ( ) { } public static NodeSet nodeset ( ExpressionContext myProcessor , Object rtf ) { String textNodeValue ; if ( rtf instanceof NodeIterator ) { return new NodeSet ( ( NodeIterator ) rtf ) ; } else { if ( rtf instanceof String ) { textNodeValue = ( String ) rtf ; } else if ( rtf instanceof Boolean ) { textNodeValue = new XBoolean ( ( ( Boolean ) rtf ) . booleanValue ( ) ) . str ( ) ; } else if ( rtf instanceof Double ) { textNodeValue = new XNumber ( ( ( Double ) rtf ) . doubleValue ( ) ) . str ( ) ; } else { textNodeValue = rtf . toString ( ) ; } try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document myDoc = db . newDocument ( ) ; Text textNode = myDoc . createTextNode ( textNodeValue ) ; DocumentFragment docFrag = myDoc . createDocumentFragment ( ) ; docFrag . appendChild ( textNode ) ; return new NodeSet ( docFrag ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } } } public static NodeList intersection ( NodeList nl1 , NodeList nl2 ) { return ExsltSets . intersection ( nl1 , nl2 ) ; } public static NodeList difference ( NodeList nl1 , NodeList nl2 ) { return ExsltSets . difference ( nl1 , nl2 ) ; } public static NodeList distinct ( NodeList nl ) { return ExsltSets . distinct ( nl ) ; } public static boolean hasSameNodes ( NodeList nl1 , NodeList nl2 ) { NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet ns2 = new NodeSet ( nl2 ) ; if ( ns1 . getLength ( ) != ns2 . getLength ( ) ) return false ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ! ns2 . contains ( n ) ) return false ; } return true ; } public static XObject evaluate ( ExpressionContext myContext , String xpathExpr ) throws SAXNotSupportedException { return ExsltDynamic . evaluate ( myContext , xpathExpr ) ; } public static NodeList tokenize ( String toTokenize , String delims ) { try { if ( m_doc == null ) { synchronized ( m_instance ) { if ( m_doc == null ) m_doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } } } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } StringTokenizer lTokenizer = new StringTokenizer ( toTokenize , delims ) ; NodeSet resultSet = new NodeSet ( ) ; synchronized ( m_doc ) { while ( lTokenizer . hasMoreTokens ( ) ) { resultSet . addNode ( m_doc . createTextNode ( lTokenizer . nextToken ( ) ) ) ; } } return resultSet ; } public static NodeList tokenize ( String toTokenize ) { return tokenize ( toTokenize , " \t\n\r" ) ; } public static Node checkEnvironment ( ExpressionContext myContext ) { Document factoryDocument ; try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; factoryDocument = db . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } Node resultNode = null ; try { resultNode = checkEnvironmentUsingWhich ( myContext , factoryDocument ) ; if ( null != resultNode ) return resultNode ; EnvironmentCheck envChecker = new EnvironmentCheck ( ) ; Hashtable h = envChecker . getEnvironmentHash ( ) ; resultNode = factoryDocument . createElement ( "checkEnvironmentExtension" ) ; envChecker . appendEnvironmentReport ( resultNode , factoryDocument , h ) ; envChecker = null ; } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } return resultNode ; } private static Node checkEnvironmentUsingWhich ( ExpressionContext myContext , Document factoryDocument ) { final String WHICH_CLASSNAME = "org.apache.env.Which" ; final String WHICH_METHODNAME = "which" ; final Class WHICH_METHOD_ARGS [ ] = { java . util . Hashtable . class , java . lang . String . class , java . lang . String . class } ; try { Class clazz = Class . forName ( WHICH_CLASSNAME ) ; if ( null == clazz ) return null ; java . lang . reflect . Method method = clazz . getMethod ( WHICH_METHODNAME , WHICH_METHOD_ARGS ) ; Hashtable report = new Hashtable ( ) ; Object [ ] methodArgs = { report , "XmlCommons;Xalan;Xerces;Crimson;Ant" , "" } ; Object returnValue = method . invoke ( null , methodArgs ) ; Node resultNode = factoryDocument . createElement ( "checkEnvironmentExtension" ) ; org . apache . xml . utils . Hashtree2Node . appendHashToNode ( report , "whichReport" , resultNode , factoryDocument ) ; return resultNode ; } catch ( Throwable t ) { return null ; } } } 	1	['13', '1', '0', '11', '54', '76', '1', '10', '9', '0.875', '371', '0.5', '1', '0', '0.208333333', '0', '0', '27.23076923', '5', '1.9231', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . util . Properties ; import javax . xml . transform . Result ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . Trie ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ToHTMLStream extends ToStream { protected BoolStack m_isRawStack = new BoolStack ( ) ; private boolean m_inBlockElem = false ; protected static CharInfo m_htmlcharInfo = CharInfo . getCharInfo ( CharInfo . HTML_ENTITIES_RESOURCE ) ; static Trie m_elementFlags = new Trie ( ) ; static { m_elementFlags . put ( "BASEFONT" , new ElemDesc ( 0 | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "FRAME" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "FRAMESET" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "NOFRAMES" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "ISINDEX" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "APPLET" , new ElemDesc ( 0 | ElemDesc . WHITESPACESENSITIVE ) ) ; m_elementFlags . put ( "CENTER" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "DIR" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "MENU" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TT" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "I" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "B" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "BIG" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "SMALL" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "EM" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "STRONG" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "DFN" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "CODE" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "SAMP" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "KBD" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "VAR" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "CITE" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "ABBR" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "ACRONYM" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "SUP" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "SUB" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "SPAN" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "BDO" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "BR" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "BODY" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "ADDRESS" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "DIV" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "A" , new ElemDesc ( 0 | ElemDesc . SPECIAL ) ) ; m_elementFlags . put ( "MAP" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "AREA" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "LINK" , new ElemDesc ( 0 | ElemDesc . HEADMISC | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "IMG" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . EMPTY | ElemDesc . WHITESPACESENSITIVE ) ) ; m_elementFlags . put ( "OBJECT" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . HEADMISC | ElemDesc . WHITESPACESENSITIVE ) ) ; m_elementFlags . put ( "PARAM" , new ElemDesc ( 0 | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "HR" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "P" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "H1" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H2" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H3" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H4" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H5" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H6" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "PRE" , new ElemDesc ( 0 | ElemDesc . PREFORMATTED | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "Q" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "BLOCKQUOTE" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "INS" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "DEL" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "DL" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "DT" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "DD" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "OL" , new ElemDesc ( 0 | ElemDesc . LIST | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "UL" , new ElemDesc ( 0 | ElemDesc . LIST | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "LI" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "FORM" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "LABEL" , new ElemDesc ( 0 | ElemDesc . FORMCTRL ) ) ; m_elementFlags . put ( "INPUT" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "SELECT" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL ) ) ; m_elementFlags . put ( "OPTGROUP" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "OPTION" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "TEXTAREA" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL ) ) ; m_elementFlags . put ( "FIELDSET" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM ) ) ; m_elementFlags . put ( "LEGEND" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "BUTTON" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL ) ) ; m_elementFlags . put ( "TABLE" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "CAPTION" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "THEAD" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TFOOT" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TBODY" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "COLGROUP" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "COL" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TR" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TH" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "TD" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "HEAD" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . HEADELEM ) ) ; m_elementFlags . put ( "TITLE" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "BASE" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "META" , new ElemDesc ( 0 | ElemDesc . HEADMISC | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "STYLE" , new ElemDesc ( 0 | ElemDesc . HEADMISC | ElemDesc . RAW | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "SCRIPT" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . HEADMISC | ElemDesc . RAW ) ) ; m_elementFlags . put ( "NOSCRIPT" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "HTML" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "FONT" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "S" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "STRIKE" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "U" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "NOBR" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "IFRAME" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "LAYER" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "ILAYER" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; ElemDesc elemDesc ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "AREA" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "NOHREF" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "BASE" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "BLOCKQUOTE" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "Q" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "INS" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "DEL" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "A" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "NAME" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "LINK" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "INPUT" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "USEMAP" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "CHECKED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "ISMAP" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "READONLY" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "SELECT" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "MULTIPLE" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "OPTGROUP" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "OPTION" ) ; elemDesc . setAttr ( "SELECTED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "TEXTAREA" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "READONLY" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "BUTTON" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "SCRIPT" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "FOR" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "DEFER" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "IMG" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "LONGDESC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "USEMAP" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "ISMAP" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "OBJECT" ) ; elemDesc . setAttr ( "CLASSID" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "CODEBASE" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "DATA" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "ARCHIVE" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "USEMAP" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "DECLARE" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "FORM" ) ; elemDesc . setAttr ( "ACTION" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "HEAD" ) ; elemDesc . setAttr ( "PROFILE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "FRAME" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "LONGDESC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "IFRAME" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "LONGDESC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "LAYER" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "ILAYER" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "DIV" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; } static private ElemDesc m_dummy = new ElemDesc ( 0 | ElemDesc . BLOCK ) ; private boolean m_specialEscapeURLs = true ; private boolean m_omitMetaTag = false ; private ElemDesc m_elementDesc = null ; public void setSpecialEscapeURLs ( boolean bool ) { m_specialEscapeURLs = bool ; } public void setOmitMetaTag ( boolean bool ) { m_omitMetaTag = bool ; } public void setOutputFormat ( Properties format ) { m_specialEscapeURLs = OutputPropertyUtils . getBooleanProperty ( OutputPropertiesFactory . S_USE_URL_ESCAPING , format ) ; m_omitMetaTag = OutputPropertyUtils . getBooleanProperty ( OutputPropertiesFactory . S_OMIT_META_TAG , format ) ; super . setOutputFormat ( format ) ; } private final boolean getSpecialEscapeURLs ( ) { return m_specialEscapeURLs ; } private final boolean getOmitMetaTag ( ) { return m_omitMetaTag ; } private final ElemDesc getElemDesc ( String name ) { if ( null != name ) { Object obj = m_elementFlags . get ( name ) ; if ( null != obj ) return ( ElemDesc ) obj ; } return m_dummy ; } public ToHTMLStream ( ) { super ( ) ; m_charInfo = m_htmlcharInfo ; m_prefixMap = new NamespaceMappings ( ) ; } private String m_currentElementName = null ; protected void startDocumentInternal ( ) throws org . xml . sax . SAXException { super . startDocumentInternal ( ) ; m_needToCallStartDocument = false ; m_needToOutputDocTypeDecl = true ; m_startNewLine = false ; setOmitXMLDeclaration ( true ) ; if ( true == m_needToOutputDocTypeDecl ) { String doctypeSystem = getDoctypeSystem ( ) ; String doctypePublic = getDoctypePublic ( ) ; if ( ( null != doctypeSystem ) || ( null != doctypePublic ) ) { try { m_writer . write ( "<!DOCTYPE HTML" ) ; if ( null != doctypePublic ) { m_writer . write ( " PUBLIC \"" ) ; m_writer . write ( doctypePublic ) ; m_writer . write ( "\"" ) ; } if ( null != doctypeSystem ) { if ( null == doctypePublic ) m_writer . write ( " SYSTEM \"" ) ; else m_writer . write ( " \"" ) ; m_writer . write ( doctypeSystem ) ; m_writer . write ( "\"" ) ; } m_writer . write ( ">" ) ; outputLineSep ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } } m_needToOutputDocTypeDecl = false ; } public final void endDocument ( ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( m_doIndent && ! m_isprevtext ) { try { outputLineSep ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } flushWriter ( ) ; super . fireEndDoc ( ) ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; else if ( m_needToCallStartDocument ) startDocumentInternal ( ) ; if ( null != namespaceURI && namespaceURI . length ( ) > 0 ) { super . startElement ( namespaceURI , localName , name , atts ) ; return ; } try { boolean savedDoIndent = m_doIndent ; boolean noLineBreak ; if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } ElemDesc elemDesc = getElemDesc ( name ) ; m_elementLocalName = localName ; m_elementURI = namespaceURI ; m_elementName = name ; m_elementDesc = elemDesc ; boolean isBlockElement = elemDesc . is ( ElemDesc . BLOCK ) ; boolean isHeadElement = elemDesc . is ( ElemDesc . HEADELEM ) ; if ( m_ispreserve ) m_ispreserve = false ; else if ( m_doIndent && ( null != m_currentElementName ) && ( ! m_inBlockElem || isBlockElement ) ) { m_startNewLine = true ; indent ( ) ; } m_inBlockElem = ! isBlockElement ; m_isRawStack . push ( elemDesc . is ( ElemDesc . RAW ) ) ; m_currentElementName = name ; m_writer . write ( '<' ) ; m_writer . write ( name ) ; if ( atts != null ) addAttributes ( atts ) ; m_startTagOpen = true ; m_currentElemDepth ++ ; m_isprevtext = false ; m_doIndent = savedDoIndent ; if ( isHeadElement ) { if ( m_startTagOpen ) closeStartTag ( ) ; if ( ! m_omitMetaTag ) { if ( m_doIndent ) indent ( ) ; m_writer . write ( "<META http-equiv=\"Content-Type\" content=\"text/html; charset=" ) ; String encoding = getEncoding ( ) ; String encode = Encodings . getMimeEncoding ( encoding ) ; m_writer . write ( encode ) ; m_writer . write ( '"' ) ; m_writer . write ( '>' ) ; } } } catch ( IOException e ) { throw new SAXException ( e ) ; } } public final void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( null != namespaceURI && namespaceURI . length ( ) > 0 ) { super . endElement ( namespaceURI , localName , name ) ; return ; } m_currentElemDepth -- ; m_isRawStack . pop ( ) ; ElemDesc elemDesc = getElemDesc ( name ) ; m_elementDesc = elemDesc ; boolean isBlockElement = elemDesc . is ( ElemDesc . BLOCK ) ; boolean shouldIndent = false ; if ( m_ispreserve ) { m_ispreserve = false ; } else if ( m_doIndent && ( ! m_inBlockElem || isBlockElement ) ) { m_startNewLine = true ; shouldIndent = true ; } m_inBlockElem = ! isBlockElement ; try { if ( ! m_startTagOpen ) { if ( shouldIndent ) indent ( ) ; m_writer . write ( "</" ) ; m_writer . write ( name ) ; m_writer . write ( '>' ) ; m_currentElementName = name ; m_cdataSectionStates . pop ( ) ; if ( ! m_preserves . isEmpty ( ) ) m_preserves . pop ( ) ; } else { processAttributes ( ) ; if ( ! elemDesc . is ( ElemDesc . EMPTY ) ) { m_writer . write ( '>' ) ; m_writer . write ( '<' ) ; m_writer . write ( '/' ) ; m_writer . write ( name ) ; m_writer . write ( '>' ) ; } else { m_writer . write ( '>' ) ; } } if ( elemDesc . is ( ElemDesc . WHITESPACESENSITIVE ) ) m_ispreserve = true ; m_startTagOpen = false ; m_isprevtext = false ; } catch ( IOException e ) { throw new SAXException ( e ) ; } super . fireEndElem ( name ) ; } protected void processAttribute ( String name , String value , ElemDesc elemDesc ) throws IOException { m_writer . write ( ' ' ) ; if ( ( ( value . length ( ) == 0 ) || value . equalsIgnoreCase ( name ) ) && elemDesc != null && elemDesc . isAttrFlagSet ( name , ElemDesc . ATTREMPTY ) ) { m_writer . write ( name ) ; } else { m_writer . write ( name ) ; m_writer . write ( '=' ) ; m_writer . write ( '\"' ) ; if ( elemDesc != null && elemDesc . isAttrFlagSet ( name , ElemDesc . ATTRURL ) ) writeAttrURI ( value , m_specialEscapeURLs ) ; else writeAttrString ( value , this . getEncoding ( ) ) ; m_writer . write ( '\"' ) ; } } private boolean isASCIIDigit ( char c ) { return ( c >= '0' && c <= '9' ) ; } private String makeHHString ( int i ) { String s = Integer . toHexString ( i ) . toUpperCase ( ) ; if ( s . length ( ) == 1 ) { s = "0" + s ; } return s ; } private boolean isHHSign ( String str ) { boolean sign = true ; try { char r = ( char ) Integer . parseInt ( str , 16 ) ; } catch ( NumberFormatException e ) { sign = false ; } return sign ; } public void writeAttrURI ( String string , boolean doURLEscaping ) throws IOException { char [ ] stringArray = string . toCharArray ( ) ; int len = stringArray . length ; for ( int i = 0 ; i < len ; i ++ ) { char ch = stringArray [ i ] ; if ( ( ch < 32 ) || ( ch > 126 ) ) { if ( doURLEscaping ) { if ( ch <= 0x7F ) { m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( ch ) ) ; } else if ( ch <= 0x7FF ) { int high = ( ch > > 6 ) | 0xC0 ; int low = ( ch & 0x3F ) | 0x80 ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( high ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( low ) ) ; } else if ( isUTF16Surrogate ( ch ) ) { int highSurrogate = ( ( int ) ch ) & 0x03FF ; int wwww = ( ( highSurrogate & 0x03C0 ) > > 6 ) ; int uuuuu = wwww + 1 ; int zzzz = ( highSurrogate & 0x003C ) > > 2 ; int yyyyyy = ( ( highSurrogate & 0x0003 ) << 4 ) & 0x30 ; ch = stringArray [ ++ i ] ; int lowSurrogate = ( ( int ) ch ) & 0x03FF ; yyyyyy = yyyyyy | ( ( lowSurrogate & 0x03C0 ) > > 6 ) ; int xxxxxx = ( lowSurrogate & 0x003F ) ; int byte1 = 0xF0 | ( uuuuu > > 2 ) ; int byte2 = 0x80 | ( ( ( uuuuu & 0x03 ) << 4 ) & 0x30 ) | zzzz ; int byte3 = 0x80 | yyyyyy ; int byte4 = 0x80 | xxxxxx ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( byte1 ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( byte2 ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( byte3 ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( byte4 ) ) ; } else { int high = ( ch > > 12 ) | 0xE0 ; int middle = ( ( ch & 0x0FC0 ) > > 6 ) | 0x80 ; int low = ( ch & 0x3F ) | 0x80 ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( high ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( middle ) ) ; m_writer . write ( '%' ) ; m_writer . write ( makeHHString ( low ) ) ; } } else if ( escapingNotNeeded ( ch ) ) { m_writer . write ( ch ) ; } else { m_writer . write ( "&#" ) ; m_writer . write ( Integer . toString ( ch ) ) ; m_writer . write ( ';' ) ; } } else if ( '%' == ch ) { m_writer . write ( ch ) ; } else if ( ch == '"' ) { if ( doURLEscaping ) m_writer . write ( "%22" ) ; else m_writer . write ( "&quot;" ) ; } else { m_writer . write ( ch ) ; } } } public void writeAttrString ( String string , String encoding ) throws IOException { final char chars [ ] = string . toCharArray ( ) ; final int strLen = chars . length ; for ( int i = 0 ; i < strLen ; i ++ ) { char ch = chars [ i ] ; if ( escapingNotNeeded ( ch ) && ( ! m_charInfo . isSpecial ( ch ) ) ) { m_writer . write ( ch ) ; } else if ( '<' == ch || '>' == ch ) { m_writer . write ( ch ) ; } else if ( ( '&' == ch ) && ( ( i + 1 ) < strLen ) && ( '{' == chars [ i + 1 ] ) ) { m_writer . write ( ch ) ; } else { int pos = accumDefaultEntity ( m_writer , ch , i , chars , strLen , false ) ; if ( i != pos ) { i = pos - 1 ; } else { if ( isUTF16Surrogate ( ch ) ) { i = writeUTF16Surrogate ( ch , chars , i , strLen ) ; } String entityName = m_charInfo . getEntityNameForChar ( ch ) ; if ( null != entityName ) { m_writer . write ( '&' ) ; m_writer . write ( entityName ) ; m_writer . write ( ';' ) ; } else if ( escapingNotNeeded ( ch ) ) { m_writer . write ( ch ) ; } else { m_writer . write ( "&#" ) ; m_writer . write ( Integer . toString ( ch ) ) ; m_writer . write ( ';' ) ; } } } } } public final void characters ( char chars [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( m_isRawStack . peekOrFalse ( ) ) { try { if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } m_ispreserve = true ; writeNormalizedChars ( chars , start , length , false ) ; super . fireCharEvent ( chars , start , length ) ; return ; } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OIERROR , null ) , ioe ) ; } } else { super . characters ( chars , start , length ) ; } } public final void cdata ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ( null != m_currentElementName ) && ( m_currentElementName . equalsIgnoreCase ( "SCRIPT" ) || m_currentElementName . equalsIgnoreCase ( "STYLE" ) ) ) { try { if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } m_ispreserve = true ; if ( shouldIndent ( ) ) indent ( ) ; writeNormalizedChars ( ch , start , length , true ) ; } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OIERROR , null ) , ioe ) ; } } else { super . cdata ( ch , start , length ) ; } } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( target . equals ( Result . PI_DISABLE_OUTPUT_ESCAPING ) ) { startNonEscaping ( ) ; } else if ( target . equals ( Result . PI_ENABLE_OUTPUT_ESCAPING ) ) { endNonEscaping ( ) ; } else { try { if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) startDocumentInternal ( ) ; if ( shouldIndent ( ) ) indent ( ) ; m_writer . write ( "<?" + target ) ; if ( data . length ( ) > 0 && ! Character . isSpaceChar ( data . charAt ( 0 ) ) ) m_writer . write ( " " ) ; m_writer . write ( data + ">" ) ; if ( m_currentElemDepth <= 0 ) outputLineSep ( ) ; m_startNewLine = true ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } super . fireEscapingEvent ( target , data ) ; } public final void entityReference ( String name ) throws org . xml . sax . SAXException { try { m_writer . write ( "&" ) ; m_writer . write ( name ) ; m_writer . write ( ";" ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public final void endElement ( String elemName ) throws SAXException { endElement ( null , null , elemName ) ; } public void processAttributes ( ) throws IOException , SAXException { super . fireStartElem ( m_elementName ) ; int nAttrs = 0 ; if ( ( nAttrs = m_attributes . getLength ( ) ) > 0 ) { for ( int i = 0 ; i < nAttrs ; i ++ ) { processAttribute ( m_attributes . getQName ( i ) , m_attributes . getValue ( i ) , m_elementDesc ) ; } m_attributes . clear ( ) ; } } protected void closeStartTag ( ) throws SAXException { if ( m_startTagOpen ) { try { processAttributes ( ) ; m_writer . write ( '>' ) ; pushCdataSectionState ( ) ; m_isprevtext = false ; m_preserves . push ( m_ispreserve ) ; m_startTagOpen = false ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } } protected synchronized void init ( OutputStream output , Properties format ) throws UnsupportedEncodingException { if ( null == format ) { format = OutputPropertiesFactory . getDefaultMethodProperties ( Method . HTML ) ; } super . init ( output , format , false ) ; } public void setOutputStream ( OutputStream output ) { try { Properties format ; if ( null == m_format ) format = OutputPropertiesFactory . getDefaultMethodProperties ( Method . HTML ) ; else format = m_format ; init ( output , format , true ) ; } catch ( UnsupportedEncodingException uee ) { } } public void namespaceAfterStartElement ( String prefix , String uri ) throws SAXException { if ( m_elementURI == null ) { String prefix1 = getPrefixPart ( m_elementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_elementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; } } 	1	['28', '3', '0', '12', '104', '222', '1', '11', '17', '0.855967078', '2480', '0.888888889', '5', '0.866666667', '0.196296296', '2', '26', '87.25', '3', '1.1429', '4']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncConcat extends FunctionMultiArgs { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { StringBuffer sb = new StringBuffer ( ) ; sb . append ( m_arg0 . execute ( xctxt ) . str ( ) ) ; sb . append ( m_arg1 . execute ( xctxt ) . str ( ) ) ; if ( null != m_arg2 ) sb . append ( m_arg2 . execute ( xctxt ) . str ( ) ) ; if ( null != m_args ) { for ( int i = 0 ; i < m_args . length ; i ++ ) { sb . append ( m_args [ i ] . execute ( xctxt ) . str ( ) ) ; } } return new XString ( sb . toString ( ) ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum < 2 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "gtone" , null ) ) ; } } 	1	['4', '7', '0', '7', '13', '6', '0', '7', '3', '2', '81', '0', '0', '0.96', '0.5', '3', '8', '19.25', '1', '0.75', '1']
package org . apache . xpath . patterns ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . PsuedoNames ; import org . apache . xpath . objects . XObject ; public class StepPattern extends NodeTest implements SubContextList , ExpressionOwner { protected int m_axis ; public StepPattern ( int whatToShow , String namespace , String name , int axis , int axisForPredicate ) { super ( whatToShow , namespace , name ) ; m_axis = axis ; } public StepPattern ( int whatToShow , int axis , int axisForPredicate ) { super ( whatToShow ) ; m_axis = axis ; } String m_targetString ; public void calcTargetString ( ) { int whatToShow = getWhatToShow ( ) ; switch ( whatToShow ) { case DTMFilter . SHOW_COMMENT : m_targetString = PsuedoNames . PSEUDONAME_COMMENT ; break ; case DTMFilter . SHOW_TEXT : case DTMFilter . SHOW_CDATA_SECTION : case ( DTMFilter . SHOW_TEXT | DTMFilter . SHOW_CDATA_SECTION ) : m_targetString = PsuedoNames . PSEUDONAME_TEXT ; break ; case DTMFilter . SHOW_ALL : m_targetString = PsuedoNames . PSEUDONAME_ANY ; break ; case DTMFilter . SHOW_DOCUMENT : case DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT : m_targetString = PsuedoNames . PSEUDONAME_ROOT ; break ; case DTMFilter . SHOW_ELEMENT : if ( this . WILD == m_name ) m_targetString = PsuedoNames . PSEUDONAME_ANY ; else m_targetString = m_name ; break ; default : m_targetString = PsuedoNames . PSEUDONAME_ANY ; break ; } } public String getTargetString ( ) { return m_targetString ; } StepPattern m_relativePathPattern ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_predicates ) { for ( int i = 0 ; i < m_predicates . length ; i ++ ) { m_predicates [ i ] . fixupVariables ( vars , globalsSize ) ; } } if ( null != m_relativePathPattern ) { m_relativePathPattern . fixupVariables ( vars , globalsSize ) ; } } public void setRelativePathPattern ( StepPattern expr ) { m_relativePathPattern = expr ; expr . exprSetParent ( this ) ; calcScore ( ) ; } public StepPattern getRelativePathPattern ( ) { return m_relativePathPattern ; } public Expression [ ] getPredicates ( ) { return m_predicates ; } Expression [ ] m_predicates ; public boolean canTraverseOutsideSubtree ( ) { int n = getPredicateCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( getPredicate ( i ) . canTraverseOutsideSubtree ( ) ) return true ; } return false ; } public Expression getPredicate ( int i ) { return m_predicates [ i ] ; } public final int getPredicateCount ( ) { return ( null == m_predicates ) ? 0 : m_predicates . length ; } public void setPredicates ( Expression [ ] predicates ) { m_predicates = predicates ; if ( null != predicates ) { for ( int i = 0 ; i < predicates . length ; i ++ ) { predicates [ i ] . exprSetParent ( this ) ; } } calcScore ( ) ; } public void calcScore ( ) { if ( ( getPredicateCount ( ) > 0 ) || ( null != m_relativePathPattern ) ) { m_score = SCORE_OTHER ; } else super . calcScore ( ) ; if ( null == m_targetString ) calcTargetString ( ) ; } public XObject execute ( XPathContext xctxt , int currentNode ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( currentNode ) ; if ( dtm != null ) { int expType = dtm . getExpandedTypeID ( currentNode ) ; return execute ( xctxt , currentNode , dtm , expType ) ; } return NodeTest . SCORE_NONE ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt , xctxt . getCurrentNode ( ) ) ; } public XObject execute ( XPathContext xctxt , int currentNode , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { if ( m_whatToShow == NodeTest . SHOW_BYFUNCTION ) { if ( null != m_relativePathPattern ) { return m_relativePathPattern . execute ( xctxt ) ; } else return NodeTest . SCORE_NONE ; } XObject score ; score = super . execute ( xctxt , currentNode , dtm , expType ) ; if ( score == NodeTest . SCORE_NONE ) return NodeTest . SCORE_NONE ; if ( getPredicateCount ( ) != 0 ) { if ( ! executePredicates ( xctxt , dtm , currentNode ) ) return NodeTest . SCORE_NONE ; } if ( null != m_relativePathPattern ) return m_relativePathPattern . executeRelativePathPattern ( xctxt , dtm , currentNode ) ; return score ; } private final boolean checkProximityPosition ( XPathContext xctxt , int predPos , DTM dtm , int context , int pos ) { try { DTMAxisTraverser traverser = dtm . getAxisTraverser ( Axis . PRECEDINGSIBLING ) ; for ( int child = traverser . first ( context ) ; DTM . NULL != child ; child = traverser . next ( context , child ) ) { try { xctxt . pushCurrentNode ( child ) ; if ( NodeTest . SCORE_NONE != super . execute ( xctxt , child ) ) { boolean pass = true ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < predPos ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { throw new Error ( "Why: Should never have been called" ) ; } else if ( ! pred . boolWithSideEffects ( ) ) { pass = false ; break ; } } finally { pred . detach ( ) ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } if ( pass ) pos -- ; if ( pos < 1 ) return false ; } } finally { xctxt . popCurrentNode ( ) ; } } } catch ( javax . xml . transform . TransformerException se ) { throw new java . lang . RuntimeException ( se . getMessage ( ) ) ; } return ( pos == 1 ) ; } private final int getProximityPosition ( XPathContext xctxt , int predPos , boolean findLast ) { int pos = 0 ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int parent = dtm . getParent ( context ) ; try { DTMAxisTraverser traverser = dtm . getAxisTraverser ( Axis . CHILD ) ; for ( int child = traverser . first ( parent ) ; DTM . NULL != child ; child = traverser . next ( parent , child ) ) { try { xctxt . pushCurrentNode ( child ) ; if ( NodeTest . SCORE_NONE != super . execute ( xctxt , child ) ) { boolean pass = true ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < predPos ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { if ( ( pos + 1 ) != ( int ) pred . numWithSideEffects ( ) ) { pass = false ; break ; } } else if ( ! pred . boolWithSideEffects ( ) ) { pass = false ; break ; } } finally { pred . detach ( ) ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } if ( pass ) pos ++ ; if ( ! findLast && child == context ) { return pos ; } } } finally { xctxt . popCurrentNode ( ) ; } } } catch ( javax . xml . transform . TransformerException se ) { throw new java . lang . RuntimeException ( se . getMessage ( ) ) ; } return pos ; } public int getProximityPosition ( XPathContext xctxt ) { return getProximityPosition ( xctxt , xctxt . getPredicatePos ( ) , false ) ; } public int getLastPos ( XPathContext xctxt ) { return getProximityPosition ( xctxt , xctxt . getPredicatePos ( ) , true ) ; } protected final XObject executeRelativePathPattern ( XPathContext xctxt , DTM dtm , int currentNode ) throws javax . xml . transform . TransformerException { XObject score = NodeTest . SCORE_NONE ; int context = currentNode ; DTMAxisTraverser traverser ; traverser = dtm . getAxisTraverser ( m_axis ) ; for ( int relative = traverser . first ( context ) ; DTM . NULL != relative ; relative = traverser . next ( context , relative ) ) { try { xctxt . pushCurrentNode ( relative ) ; score = execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) break ; } finally { xctxt . popCurrentNode ( ) ; } } return score ; } protected final boolean executePredicates ( XPathContext xctxt , DTM dtm , int currentNode ) throws javax . xml . transform . TransformerException { boolean result = true ; boolean positionAlreadySeen = false ; int n = getPredicateCount ( ) ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < n ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { int pos = ( int ) pred . num ( ) ; if ( positionAlreadySeen ) { result = ( pos == 1 ) ; break ; } else { positionAlreadySeen = true ; if ( ! checkProximityPosition ( xctxt , i , dtm , currentNode , pos ) ) { result = false ; break ; } } } else if ( ! pred . boolWithSideEffects ( ) ) { result = false ; break ; } } finally { pred . detach ( ) ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } return result ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( StepPattern pat = this ; pat != null ; pat = pat . m_relativePathPattern ) { if ( pat != this ) buf . append ( "/" ) ; buf . append ( Axis . names [ pat . m_axis ] ) ; buf . append ( "::" ) ; if ( 0x000005000 == pat . m_whatToShow ) { buf . append ( "doc()" ) ; } else if ( DTMFilter . SHOW_BYFUNCTION == pat . m_whatToShow ) { buf . append ( "function()" ) ; } else if ( DTMFilter . SHOW_ALL == pat . m_whatToShow ) { buf . append ( "node()" ) ; } else if ( DTMFilter . SHOW_TEXT == pat . m_whatToShow ) { buf . append ( "text()" ) ; } else if ( DTMFilter . SHOW_PROCESSING_INSTRUCTION == pat . m_whatToShow ) { buf . append ( "processing-instruction(" ) ; if ( null != pat . m_name ) { buf . append ( pat . m_name ) ; } buf . append ( ")" ) ; } else if ( DTMFilter . SHOW_COMMENT == pat . m_whatToShow ) { buf . append ( "comment()" ) ; } else if ( null != pat . m_name ) { if ( DTMFilter . SHOW_ATTRIBUTE == pat . m_whatToShow ) { buf . append ( "@" ) ; } if ( null != pat . m_namespace ) { buf . append ( "{" ) ; buf . append ( pat . m_namespace ) ; buf . append ( "}" ) ; } buf . append ( pat . m_name ) ; } else if ( DTMFilter . SHOW_ATTRIBUTE == pat . m_whatToShow ) { buf . append ( "@" ) ; } else if ( ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ) == pat . m_whatToShow ) { buf . append ( "doc-root()" ) ; } else { buf . append ( "?" + Integer . toHexString ( pat . m_whatToShow ) ) ; } if ( null != pat . m_predicates ) { for ( int i = 0 ; i < pat . m_predicates . length ; i ++ ) { buf . append ( "[" ) ; buf . append ( pat . m_predicates [ i ] ) ; buf . append ( "]" ) ; } } } return buf . toString ( ) ; } private static final boolean DEBUG_MATCHES = false ; public double getMatchScore ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { xctxt . pushCurrentNode ( context ) ; xctxt . pushCurrentExpressionNode ( context ) ; try { XObject score = execute ( xctxt ) ; return score . num ( ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popCurrentExpressionNode ( ) ; } } public void setAxis ( int axis ) { m_axis = axis ; } public int getAxis ( ) { return m_axis ; } class PredOwner implements ExpressionOwner { int m_index ; PredOwner ( int index ) { m_index = index ; } public Expression getExpression ( ) { return m_predicates [ m_index ] ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( StepPattern . this ) ; m_predicates [ m_index ] = exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitMatchPattern ( owner , this ) ) { callSubtreeVisitors ( visitor ) ; } } protected void callSubtreeVisitors ( XPathVisitor visitor ) { if ( null != m_predicates ) { int n = m_predicates . length ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner predOwner = new PredOwner ( i ) ; if ( visitor . visitPredicate ( predOwner , m_predicates [ i ] ) ) { m_predicates [ i ] . callVisitors ( predOwner , visitor ) ; } } } if ( null != m_relativePathPattern ) { m_relativePathPattern . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_relativePathPattern ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_relativePathPattern = ( StepPattern ) exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; StepPattern sp = ( StepPattern ) expr ; if ( null != m_predicates ) { int n = m_predicates . length ; if ( ( null == sp . m_predicates ) || ( sp . m_predicates . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_predicates [ i ] . deepEquals ( sp . m_predicates [ i ] ) ) return false ; } } else if ( null != sp . m_predicates ) return false ; if ( null != m_relativePathPattern ) { if ( ! m_relativePathPattern . deepEquals ( sp . m_relativePathPattern ) ) return false ; } else if ( sp . m_relativePathPattern != null ) return false ; return true ; } } 	1	['31', '3', '2', '22', '78', '239', '11', '13', '26', '0.733333333', '1095', '0.4', '2', '0.641975309', '0.180107527', '2', '9', '34.16129032', '17', '3.0645', '1']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; public class FunctionDef1Arg extends FunctionOneArg { protected int getArg0AsNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( null == m_arg0 ) ? xctxt . getCurrentNode ( ) : m_arg0 . asNode ( xctxt ) ; } public boolean Arg0IsNodesetExpr ( ) { return ( null == m_arg0 ) ? true : m_arg0 . isNodesetExpr ( ) ; } protected XMLString getArg0AsString ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( null == m_arg0 ) { int currentNode = xctxt . getCurrentNode ( ) ; if ( DTM . NULL == currentNode ) return XString . EMPTYSTRING ; else { DTM dtm = xctxt . getDTM ( currentNode ) ; return dtm . getStringValue ( currentNode ) ; } } else return m_arg0 . execute ( xctxt ) . xstr ( ) ; } protected double getArg0AsNumber ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( null == m_arg0 ) { int currentNode = xctxt . getCurrentNode ( ) ; if ( DTM . NULL == currentNode ) return 0 ; else { DTM dtm = xctxt . getDTM ( currentNode ) ; XMLString str = dtm . getStringValue ( currentNode ) ; return str . toDouble ( ) ; } } else return m_arg0 . execute ( xctxt ) . num ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum > 1 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_ZERO_OR_ONE , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return ( null == m_arg0 ) ? false : super . canTraverseOutsideSubtree ( ) ; } } 	1	['8', '4', '9', '18', '21', '8', '9', '9', '4', '2', '110', '0', '0', '0.872727273', '0.5', '2', '5', '12.75', '2', '1.125', '1']
package org . apache . xalan . templates ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . SystemIDResolver ; public class Stylesheet extends ElemTemplateElement implements java . io . Serializable { public Stylesheet ( Stylesheet parent ) { if ( null != parent ) { m_stylesheetParent = parent ; m_stylesheetRoot = parent . getStylesheetRoot ( ) ; } } public Stylesheet getStylesheet ( ) { return this ; } public boolean isAggregatedType ( ) { return false ; } public boolean isRoot ( ) { return false ; } public static final String STYLESHEET_EXT = ".lxc" ; private void readObject ( ObjectInputStream stream ) throws IOException , TransformerException { try { stream . defaultReadObject ( ) ; } catch ( ClassNotFoundException cnfe ) { throw new TransformerException ( cnfe ) ; } } private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; } private String m_XmlnsXsl ; public void setXmlnsXsl ( String v ) { m_XmlnsXsl = v ; } public String getXmlnsXsl ( ) { return m_XmlnsXsl ; } private StringVector m_ExtensionElementURIs ; public void setExtensionElementPrefixes ( StringVector v ) { m_ExtensionElementURIs = v ; } public String getExtensionElementPrefix ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_ExtensionElementURIs ) throw new ArrayIndexOutOfBoundsException ( ) ; return m_ExtensionElementURIs . elementAt ( i ) ; } public int getExtensionElementPrefixCount ( ) { return ( null != m_ExtensionElementURIs ) ? m_ExtensionElementURIs . size ( ) : 0 ; } public boolean containsExtensionElementURI ( String uri ) { if ( null == m_ExtensionElementURIs ) return false ; return m_ExtensionElementURIs . contains ( uri ) ; } private StringVector m_ExcludeResultPrefixs ; public void setExcludeResultPrefixes ( StringVector v ) { m_ExcludeResultPrefixs = v ; } public String getExcludeResultPrefix ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_ExcludeResultPrefixs ) throw new ArrayIndexOutOfBoundsException ( ) ; return m_ExcludeResultPrefixs . elementAt ( i ) ; } public int getExcludeResultPrefixCount ( ) { return ( null != m_ExcludeResultPrefixs ) ? m_ExcludeResultPrefixs . size ( ) : 0 ; } public boolean containsExcludeResultPrefix ( String prefix , String uri ) { if ( null == m_ExcludeResultPrefixs || uri == null ) return false ; for ( int i = 0 ; i < m_ExcludeResultPrefixs . size ( ) ; i ++ ) { if ( uri . equals ( getNamespaceForPrefix ( m_ExcludeResultPrefixs . elementAt ( i ) ) ) ) return true ; } return false ; } private String m_Id ; public void setId ( String v ) { m_Id = v ; } public String getId ( ) { return m_Id ; } private String m_Version ; public void setVersion ( String v ) { m_Version = v ; } public String getVersion ( ) { return m_Version ; } private Vector m_imports ; public void setImport ( StylesheetComposed v ) { if ( null == m_imports ) m_imports = new Vector ( ) ; m_imports . addElement ( v ) ; } public StylesheetComposed getImport ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_imports ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( StylesheetComposed ) m_imports . elementAt ( i ) ; } public int getImportCount ( ) { return ( null != m_imports ) ? m_imports . size ( ) : 0 ; } private Vector m_includes ; public void setInclude ( Stylesheet v ) { if ( null == m_includes ) m_includes = new Vector ( ) ; m_includes . addElement ( v ) ; } public Stylesheet getInclude ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_includes ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( Stylesheet ) m_includes . elementAt ( i ) ; } public int getIncludeCount ( ) { return ( null != m_includes ) ? m_includes . size ( ) : 0 ; } Stack m_DecimalFormatDeclarations ; public void setDecimalFormat ( DecimalFormatProperties edf ) { if ( null == m_DecimalFormatDeclarations ) m_DecimalFormatDeclarations = new Stack ( ) ; m_DecimalFormatDeclarations . push ( edf ) ; } public DecimalFormatProperties getDecimalFormat ( QName name ) { if ( null == m_DecimalFormatDeclarations ) return null ; int n = getDecimalFormatCount ( ) ; for ( int i = ( n - 1 ) ; i >= 0 ; i ++ ) { DecimalFormatProperties dfp = getDecimalFormat ( i ) ; if ( dfp . getName ( ) . equals ( name ) ) return dfp ; } return null ; } public DecimalFormatProperties getDecimalFormat ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_DecimalFormatDeclarations ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( DecimalFormatProperties ) m_DecimalFormatDeclarations . elementAt ( i ) ; } public int getDecimalFormatCount ( ) { return ( null != m_DecimalFormatDeclarations ) ? m_DecimalFormatDeclarations . size ( ) : 0 ; } private Vector m_whitespaceStrippingElements ; public void setStripSpaces ( WhiteSpaceInfo wsi ) { if ( null == m_whitespaceStrippingElements ) { m_whitespaceStrippingElements = new Vector ( ) ; } m_whitespaceStrippingElements . addElement ( wsi ) ; } public WhiteSpaceInfo getStripSpace ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_whitespaceStrippingElements ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( WhiteSpaceInfo ) m_whitespaceStrippingElements . elementAt ( i ) ; } public int getStripSpaceCount ( ) { return ( null != m_whitespaceStrippingElements ) ? m_whitespaceStrippingElements . size ( ) : 0 ; } private Vector m_whitespacePreservingElements ; public void setPreserveSpaces ( WhiteSpaceInfo wsi ) { if ( null == m_whitespacePreservingElements ) { m_whitespacePreservingElements = new Vector ( ) ; } m_whitespacePreservingElements . addElement ( wsi ) ; } public WhiteSpaceInfo getPreserveSpace ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_whitespacePreservingElements ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( WhiteSpaceInfo ) m_whitespacePreservingElements . elementAt ( i ) ; } public int getPreserveSpaceCount ( ) { return ( null != m_whitespacePreservingElements ) ? m_whitespacePreservingElements . size ( ) : 0 ; } private Vector m_output ; public void setOutput ( OutputProperties v ) { if ( null == m_output ) { m_output = new Vector ( ) ; } m_output . addElement ( v ) ; } public OutputProperties getOutput ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_output ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( OutputProperties ) m_output . elementAt ( i ) ; } public int getOutputCount ( ) { return ( null != m_output ) ? m_output . size ( ) : 0 ; } private Vector m_keyDeclarations ; public void setKey ( KeyDeclaration v ) { if ( null == m_keyDeclarations ) m_keyDeclarations = new Vector ( ) ; m_keyDeclarations . addElement ( v ) ; } public KeyDeclaration getKey ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_keyDeclarations ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( KeyDeclaration ) m_keyDeclarations . elementAt ( i ) ; } public int getKeyCount ( ) { return ( null != m_keyDeclarations ) ? m_keyDeclarations . size ( ) : 0 ; } private Vector m_attributeSets ; public void setAttributeSet ( ElemAttributeSet attrSet ) { if ( null == m_attributeSets ) { m_attributeSets = new Vector ( ) ; } m_attributeSets . addElement ( attrSet ) ; } public ElemAttributeSet getAttributeSet ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_attributeSets ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( ElemAttributeSet ) m_attributeSets . elementAt ( i ) ; } public int getAttributeSetCount ( ) { return ( null != m_attributeSets ) ? m_attributeSets . size ( ) : 0 ; } private Vector m_topLevelVariables ; public void setVariable ( ElemVariable v ) { if ( null == m_topLevelVariables ) m_topLevelVariables = new Vector ( ) ; m_topLevelVariables . addElement ( v ) ; } public ElemVariable getVariableOrParam ( QName qname ) { if ( null != m_topLevelVariables ) { int n = getVariableOrParamCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ElemVariable var = ( ElemVariable ) getVariableOrParam ( i ) ; if ( var . getName ( ) . equals ( qname ) ) return var ; } } return null ; } public ElemVariable getVariable ( QName qname ) { if ( null != m_topLevelVariables ) { int n = getVariableOrParamCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ElemVariable var = getVariableOrParam ( i ) ; if ( ( var . getXSLToken ( ) == Constants . ELEMNAME_VARIABLE ) && ( var . getName ( ) . equals ( qname ) ) ) return var ; } } return null ; } public ElemVariable getVariableOrParam ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_topLevelVariables ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( ElemVariable ) m_topLevelVariables . elementAt ( i ) ; } public int getVariableOrParamCount ( ) { return ( null != m_topLevelVariables ) ? m_topLevelVariables . size ( ) : 0 ; } public void setParam ( ElemParam v ) { setVariable ( v ) ; } public ElemParam getParam ( QName qname ) { if ( null != m_topLevelVariables ) { int n = getVariableOrParamCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ElemVariable var = getVariableOrParam ( i ) ; if ( ( var . getXSLToken ( ) == Constants . ELEMNAME_PARAMVARIABLE ) && ( var . getName ( ) . equals ( qname ) ) ) return ( ElemParam ) var ; } } return null ; } private Vector m_templates ; public void setTemplate ( ElemTemplate v ) { if ( null == m_templates ) m_templates = new Vector ( ) ; m_templates . addElement ( v ) ; v . setStylesheet ( this ) ; } public ElemTemplate getTemplate ( int i ) throws TransformerException { if ( null == m_templates ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( ElemTemplate ) m_templates . elementAt ( i ) ; } public int getTemplateCount ( ) { return ( null != m_templates ) ? m_templates . size ( ) : 0 ; } private Vector m_prefix_aliases ; public void setNamespaceAlias ( NamespaceAlias na ) { if ( m_prefix_aliases == null ) m_prefix_aliases = new Vector ( ) ; m_prefix_aliases . addElement ( na ) ; } public NamespaceAlias getNamespaceAlias ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_prefix_aliases ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( NamespaceAlias ) m_prefix_aliases . elementAt ( i ) ; } public int getNamespaceAliasCount ( ) { return ( null != m_prefix_aliases ) ? m_prefix_aliases . size ( ) : 0 ; } private Hashtable m_NonXslTopLevel ; public void setNonXslTopLevel ( QName name , Object obj ) { if ( null == m_NonXslTopLevel ) m_NonXslTopLevel = new Hashtable ( ) ; m_NonXslTopLevel . put ( name , obj ) ; } public Object getNonXslTopLevel ( QName name ) { return ( null != m_NonXslTopLevel ) ? m_NonXslTopLevel . get ( name ) : null ; } private String m_href = null ; private String m_publicId ; private String m_systemId ; public String getHref ( ) { return m_href ; } public void setHref ( String baseIdent ) { m_href = baseIdent ; } public void setLocaterInfo ( SourceLocator locator ) { if ( null != locator ) { m_publicId = locator . getPublicId ( ) ; m_systemId = locator . getSystemId ( ) ; if ( null != m_systemId ) { try { m_href = SystemIDResolver . getAbsoluteURI ( m_systemId , null ) ; } catch ( TransformerException se ) { } } super . setLocaterInfo ( locator ) ; } } private StylesheetRoot m_stylesheetRoot ; public StylesheetRoot getStylesheetRoot ( ) { return m_stylesheetRoot ; } public void setStylesheetRoot ( StylesheetRoot v ) { m_stylesheetRoot = v ; } private Stylesheet m_stylesheetParent ; public Stylesheet getStylesheetParent ( ) { return m_stylesheetParent ; } public void setStylesheetParent ( Stylesheet v ) { m_stylesheetParent = v ; } public StylesheetComposed getStylesheetComposed ( ) { Stylesheet sheet = this ; while ( ! sheet . isAggregatedType ( ) ) { sheet = sheet . getStylesheetParent ( ) ; } return ( StylesheetComposed ) sheet ; } public short getNodeType ( ) { return DTM . DOCUMENT_NODE ; } public int getXSLToken ( ) { return Constants . ELEMNAME_STYLESHEET ; } public String getNodeName ( ) { return Constants . ELEMNAME_STYLESHEET_STRING ; } public void replaceTemplate ( ElemTemplate v , int i ) throws TransformerException { if ( null == m_templates ) throw new ArrayIndexOutOfBoundsException ( ) ; replaceChild ( v , ( ElemTemplateElement ) m_templates . elementAt ( i ) ) ; m_templates . setElementAt ( v , i ) ; v . setStylesheet ( this ) ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { int s = getImportCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { getImport ( j ) . callVisitors ( visitor ) ; } s = getIncludeCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { getInclude ( j ) . callVisitors ( visitor ) ; } s = getOutputCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getOutput ( j ) ) ; } s = getAttributeSetCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { ElemAttributeSet attrSet = getAttributeSet ( j ) ; if ( visitor . visitTopLevelInstruction ( attrSet ) ) { attrSet . callChildVisitors ( visitor ) ; } } s = getDecimalFormatCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getDecimalFormat ( j ) ) ; } s = getKeyCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getKey ( j ) ) ; } s = getNamespaceAliasCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getNamespaceAlias ( j ) ) ; } s = getTemplateCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { try { ElemTemplate template = getTemplate ( j ) ; if ( visitor . visitTopLevelInstruction ( template ) ) { template . callChildVisitors ( visitor ) ; } } catch ( TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } s = getVariableOrParamCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { ElemVariable var = getVariableOrParam ( j ) ; if ( visitor . visitTopLevelVariableOrParamDecl ( var ) ) { var . callChildVisitors ( visitor ) ; } } s = getStripSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getStripSpace ( j ) ) ; } s = getPreserveSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getPreserveSpace ( j ) ) ; } if ( null != m_NonXslTopLevel ) { java . util . Enumeration enum = m_NonXslTopLevel . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ElemTemplateElement elem = ( ElemTemplateElement ) enum . nextElement ( ) ; if ( visitor . visitTopLevelInstruction ( elem ) ) { elem . callChildVisitors ( visitor ) ; } } } } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitStylesheet ( this ) ; } } 	1	['74', '3', '2', '47', '119', '2539', '37', '17', '70', '0.966051221', '1136', '0.913043478', '4', '0.728624535', '0.073443008', '3', '19', '14.04054054', '16', '1.8378', '2']
package org . apache . xalan . xsltc . dom ; import java . io . File ; import java . io . FileNotFoundException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . sax . SAXSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; public final class LoadDocument { private static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static DTMAxisIterator document ( String uri , String base , AbstractTranslet translet , DOM dom ) throws Exception { final String originalUri = uri ; MultiDOM multiplexer = ( MultiDOM ) dom ; if ( uri == null || uri . equals ( "" ) ) { return ( new SingletonIterator ( DTM . NULL , true ) ) ; } if ( base != null && ! base . equals ( "" ) ) { if ( ! uri . startsWith ( base ) && ! uri . startsWith ( "/" ) && ! uri . startsWith ( "http:/" ) && ! uri . startsWith ( "file:/" ) ) { uri = base + uri ; } } final File file = new File ( uri ) ; if ( file . exists ( ) ) { uri = file . toURL ( ) . toExternalForm ( ) ; } int mask = multiplexer . getDocumentMask ( uri ) ; if ( mask != - 1 ) { DOM newDom = ( ( DOMAdapter ) multiplexer . getDOMAdapter ( uri ) ) . getDOMImpl ( ) ; if ( newDom instanceof SAXImpl ) { return new SingletonIterator ( ( ( SAXImpl ) newDom ) . getDocument ( ) , true ) ; } } DOMCache cache = translet . getDOMCache ( ) ; DOM newdom ; mask = multiplexer . nextMask ( ) ; if ( cache != null ) { newdom = cache . retrieveDocument ( uri , mask , translet ) ; if ( newdom == null ) { final Exception e = new FileNotFoundException ( originalUri ) ; throw new TransletException ( e ) ; } } else { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; try { reader . setFeature ( NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { throw new TransletException ( e ) ; } XSLTCDTMManager dtmManager = ( XSLTCDTMManager ) ( ( DTMDefaultBase ) ( ( DOMAdapter ) multiplexer . getMain ( ) ) . getDOMImpl ( ) ) . m_mgr ; newdom = ( SAXImpl ) dtmManager . getDTM ( new SAXSource ( reader , new InputSource ( uri ) ) , false , null , true , false , translet . hasIdCall ( ) ) ; translet . prepassDocument ( newdom ) ; ( ( SAXImpl ) newdom ) . setDocumentURI ( uri ) ; } final DOMAdapter domAdapter = translet . makeDOMAdapter ( newdom ) ; multiplexer . addDOMAdapter ( domAdapter ) ; translet . buildKeys ( domAdapter , null , null , ( ( SAXImpl ) newdom ) . getDocument ( ) ) ; return new SingletonIterator ( ( ( SAXImpl ) newdom ) . getDocument ( ) , true ) ; } public static DTMAxisIterator document ( Object arg , String xmlURI , String xslURI , AbstractTranslet translet , DOM dom ) throws TransletException { try { if ( xmlURI != null ) { int sep = xmlURI . lastIndexOf ( '\\' ) + 1 ; if ( sep <= 0 ) { sep = xmlURI . lastIndexOf ( '/' ) + 1 ; } xmlURI = xmlURI . substring ( 0 , sep ) ; } else { xmlURI = "" ; } if ( xslURI != null ) { int sep = xslURI . lastIndexOf ( '\\' ) + 1 ; if ( sep <= 0 ) { sep = xslURI . lastIndexOf ( '/' ) + 1 ; } xslURI = xslURI . substring ( 0 , sep ) ; } else { xslURI = "" ; } if ( arg instanceof String ) { try { return document ( ( String ) arg , xmlURI , translet , dom ) ; } catch ( java . io . FileNotFoundException e ) { return document ( ( String ) arg , xslURI , translet , dom ) ; } catch ( org . xml . sax . SAXParseException e ) { return document ( ( String ) arg , xslURI , translet , dom ) ; } } else if ( arg instanceof DTMAxisIterator ) { UnionIterator union = new UnionIterator ( dom ) ; DTMAxisIterator iterator = ( DTMAxisIterator ) arg ; int node ; while ( ( node = iterator . next ( ) ) != DTM . NULL ) { String uri = dom . getStringValueX ( node ) ; if ( ( xmlURI == null ) || xmlURI . equals ( "" ) ) { xmlURI = dom . getDocumentURI ( node ) ; int sep = xmlURI . lastIndexOf ( '\\' ) + 1 ; if ( sep <= 0 ) { sep = xmlURI . lastIndexOf ( '/' ) + 1 ; } xmlURI = xmlURI . substring ( 0 , sep ) ; } try { union . addIterator ( document ( uri , xmlURI , translet , dom ) ) ; } catch ( java . io . FileNotFoundException e ) { union . addIterator ( document ( uri , xslURI , translet , dom ) ) ; } } return ( union ) ; } else { final String err = "document(" + arg . toString ( ) + ")" ; throw new IllegalArgumentException ( err ) ; } } catch ( TransletException e ) { throw e ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } } 	1	['6', '1', '0', '17', '51', '15', '0', '17', '3', '1.2', '368', '1', '0', '0', '0.5', '0', '0', '60.16666667', '1', '0.8333', '4']
package org . apache . xalan . templates ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . StringVector ; import org . apache . xpath . XPathContext ; public class ElemLiteralResult extends ElemUse { private boolean isLiteralResultAsStylesheet = false ; public void setIsLiteralResultAsStylesheet ( boolean b ) { isLiteralResultAsStylesheet = b ; } public boolean getIsLiteralResultAsStylesheet ( ) { return isLiteralResultAsStylesheet ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; } } } private Vector m_avts = null ; private Vector m_xslAttr = null ; public void addLiteralResultAttribute ( AVT avt ) { if ( null == m_avts ) m_avts = new Vector ( ) ; m_avts . addElement ( avt ) ; } public void addLiteralResultAttribute ( String att ) { if ( null == m_xslAttr ) m_xslAttr = new Vector ( ) ; m_xslAttr . addElement ( att ) ; } public void setXmlSpace ( AVT avt ) { addLiteralResultAttribute ( avt ) ; String val = avt . getSimpleString ( ) ; if ( val . equals ( "default" ) ) { super . setXmlSpace ( Constants . ATTRVAL_STRIP ) ; } else if ( val . equals ( "preserve" ) ) { super . setXmlSpace ( Constants . ATTRVAL_PRESERVE ) ; } } public AVT getLiteralResultAttribute ( String name ) { if ( null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; if ( avt . getRawName ( ) . equals ( name ) ) { return avt ; } } } return null ; } public boolean containsExcludeResultPrefix ( String prefix , String uri ) { if ( uri == null || ( null == m_excludeResultPrefixes && null == m_ExtensionElementURIs ) ) return super . containsExcludeResultPrefix ( prefix , uri ) ; if ( prefix . length ( ) == 0 ) prefix = Constants . ATTRVAL_DEFAULT_PREFIX ; if ( m_excludeResultPrefixes != null ) for ( int i = 0 ; i < m_excludeResultPrefixes . size ( ) ; i ++ ) { if ( uri . equals ( getNamespaceForPrefix ( m_excludeResultPrefixes . elementAt ( i ) ) ) ) return true ; } if ( m_ExtensionElementURIs != null && m_ExtensionElementURIs . contains ( uri ) ) return true ; return super . containsExcludeResultPrefix ( prefix , uri ) ; } public void resolvePrefixTables ( ) throws TransformerException { super . resolvePrefixTables ( ) ; StylesheetRoot stylesheet = getStylesheetRoot ( ) ; if ( ( null != m_namespace ) && ( m_namespace . length ( ) > 0 ) ) { NamespaceAlias nsa = stylesheet . getNamespaceAliasComposed ( m_namespace ) ; if ( null != nsa ) { m_namespace = nsa . getResultNamespace ( ) ; String resultPrefix = nsa . getStylesheetPrefix ( ) ; if ( ( null != resultPrefix ) && ( resultPrefix . length ( ) > 0 ) ) m_rawName = resultPrefix + ":" + m_localName ; else m_rawName = m_localName ; } } if ( null != m_avts ) { int n = m_avts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; String ns = avt . getURI ( ) ; if ( ( null != ns ) && ( ns . length ( ) > 0 ) ) { NamespaceAlias nsa = stylesheet . getNamespaceAliasComposed ( m_namespace ) ; if ( null != nsa ) { String namespace = nsa . getResultNamespace ( ) ; String resultPrefix = nsa . getStylesheetPrefix ( ) ; String rawName = avt . getName ( ) ; if ( ( null != resultPrefix ) && ( resultPrefix . length ( ) > 0 ) ) rawName = resultPrefix + ":" + rawName ; avt . setURI ( namespace ) ; avt . setRawName ( rawName ) ; } } } } } boolean needToCheckExclude ( ) { if ( null == m_excludeResultPrefixes && null == m_prefixTable && m_ExtensionElementURIs == null ) return false ; else { if ( null == m_prefixTable ) m_prefixTable = new Vector ( ) ; return true ; } } private String m_namespace ; public void setNamespace ( String ns ) { if ( null == ns ) ns = "" ; m_namespace = ns ; } public String getNamespace ( ) { return m_namespace ; } private String m_localName ; public void setLocalName ( String localName ) { m_localName = localName ; } public String getLocalName ( ) { return m_localName ; } private String m_rawName ; public void setRawName ( String rawName ) { m_rawName = rawName ; } public String getRawName ( ) { return m_rawName ; } public String getPrefix ( ) { int len = m_rawName . length ( ) - m_localName . length ( ) - 1 ; return ( len > 0 ) ? m_rawName . substring ( 0 , len ) : "" ; } private StringVector m_ExtensionElementURIs ; public void setExtensionElementPrefixes ( StringVector v ) { m_ExtensionElementURIs = v ; } public String getExtensionElementPrefix ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_ExtensionElementURIs ) throw new ArrayIndexOutOfBoundsException ( ) ; return m_ExtensionElementURIs . elementAt ( i ) ; } public int getExtensionElementPrefixCount ( ) { return ( null != m_ExtensionElementURIs ) ? m_ExtensionElementURIs . size ( ) : 0 ; } public boolean containsExtensionElementURI ( String uri ) { if ( null == m_ExtensionElementURIs ) return false ; return m_ExtensionElementURIs . contains ( uri ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_LITERALRESULT ; } public String getNodeName ( ) { return m_rawName ; } private String m_version ; public void setVersion ( String v ) { m_version = v ; } public String getVersion ( ) { return m_version ; } private StringVector m_excludeResultPrefixes ; public void setExcludeResultPrefixes ( StringVector v ) { m_excludeResultPrefixes = v ; } private boolean excludeResultNSDecl ( String prefix , String uri ) throws TransformerException { if ( null != m_excludeResultPrefixes ) { return containsExcludeResultPrefix ( prefix , uri ) ; } return false ; } public void execute ( TransformerImpl transformer ) throws TransformerException { try { SerializationHandler rhandler = transformer . getSerializationHandler ( ) ; rhandler . startPrefixMapping ( getPrefix ( ) , getNamespace ( ) ) ; executeNSDecls ( transformer ) ; rhandler . startElement ( getNamespace ( ) , getLocalName ( ) , getRawName ( ) ) ; try { super . execute ( transformer ) ; if ( null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; String stringedValue = avt . evaluate ( xctxt , sourceNode , this ) ; if ( null != stringedValue ) { rhandler . addAttribute ( avt . getURI ( ) , avt . getName ( ) , avt . getRawName ( ) , "CDATA" , stringedValue ) ; } } } transformer . executeChildTemplates ( this , true ) ; } finally { rhandler . endElement ( getNamespace ( ) , getLocalName ( ) , getRawName ( ) ) ; unexecuteNSDecls ( transformer ) ; rhandler . endPrefixMapping ( getPrefix ( ) ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } public Enumeration enumerateLiteralResultAttributes ( ) { return ( null == m_avts ) ? null : m_avts . elements ( ) ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitLiteralResultElement ( this ) ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs && null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; avt . callVisitors ( visitor ) ; } } super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['32', '4', '2', '17', '84', '354', '6', '12', '28', '0.88172043', '656', '1', '2', '0.86695279', '0.180555556', '3', '19', '19.21875', '10', '1.8438', '3']
package org . apache . xalan . templates ; import java . text . DecimalFormatSymbols ; import org . apache . xml . utils . QName ; public class DecimalFormatProperties extends ElemTemplateElement { DecimalFormatSymbols m_dfs ; public DecimalFormatProperties ( int docOrderNumber ) { m_dfs = new java . text . DecimalFormatSymbols ( ) ; m_dfs . setInfinity ( Constants . ATTRVAL_INFINITY ) ; m_dfs . setNaN ( Constants . ATTRVAL_NAN ) ; m_docOrderNumber = docOrderNumber ; } public DecimalFormatSymbols getDecimalFormatSymbols ( ) { return m_dfs ; } private QName m_qname = null ; public void setName ( QName qname ) { m_qname = qname ; } public QName getName ( ) { if ( m_qname == null ) return new QName ( "" ) ; else return m_qname ; } public void setDecimalSeparator ( char ds ) { m_dfs . setDecimalSeparator ( ds ) ; } public char getDecimalSeparator ( ) { return m_dfs . getDecimalSeparator ( ) ; } public void setGroupingSeparator ( char gs ) { m_dfs . setGroupingSeparator ( gs ) ; } public char getGroupingSeparator ( ) { return m_dfs . getGroupingSeparator ( ) ; } public void setInfinity ( String inf ) { m_dfs . setInfinity ( inf ) ; } public String getInfinity ( ) { return m_dfs . getInfinity ( ) ; } public void setMinusSign ( char v ) { m_dfs . setMinusSign ( v ) ; } public char getMinusSign ( ) { return m_dfs . getMinusSign ( ) ; } public void setNaN ( String v ) { m_dfs . setNaN ( v ) ; } public String getNaN ( ) { return m_dfs . getNaN ( ) ; } public void setPercent ( char v ) { m_dfs . setPercent ( v ) ; } public char getPercent ( ) { return m_dfs . getPercent ( ) ; } public void setPerMille ( char v ) { m_dfs . setPerMill ( v ) ; } public char getPerMille ( ) { return m_dfs . getPerMill ( ) ; } public void setZeroDigit ( char v ) { m_dfs . setZeroDigit ( v ) ; } public char getZeroDigit ( ) { return m_dfs . getZeroDigit ( ) ; } public void setDigit ( char v ) { m_dfs . setDigit ( v ) ; } public char getDigit ( ) { return m_dfs . getDigit ( ) ; } public void setPatternSeparator ( char v ) { m_dfs . setPatternSeparator ( v ) ; } public char getPatternSeparator ( ) { return m_dfs . getPatternSeparator ( ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeDecimalFormats ( this ) ; } } 	1	['25', '3', '0', '6', '49', '0', '4', '3', '25', '0.520833333', '161', '0.5', '1', '0.890909091', '0.253333333', '1', '1', '5.36', '2', '1', '2']
package org . apache . xpath . compiler ; public class OpMapVector { protected int m_blocksize ; protected int m_map [ ] ; protected int m_lengthPos = 0 ; protected int m_mapSize ; public OpMapVector ( int blocksize , int increaseSize , int lengthPos ) { m_blocksize = increaseSize ; m_mapSize = blocksize ; m_lengthPos = lengthPos ; m_map = new int [ blocksize ] ; } public final int elementAt ( int i ) { return m_map [ i ] ; } public final void setElementAt ( int value , int index ) { if ( index >= m_mapSize ) { int oldSize = m_mapSize ; m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , oldSize ) ; m_map = newMap ; } m_map [ index ] = value ; } public final void setToSize ( int size ) { int newMap [ ] = new int [ size ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map [ m_lengthPos ] ) ; m_mapSize = size ; m_map = newMap ; } } 	1	['4', '1', '0', '2', '6', '0', '2', '0', '4', '0.416666667', '87', '1', '0', '0', '1', '0', '0', '19.75', '2', '1', '1']
package org . apache . xml . utils ; import java . io . PrintStream ; import java . io . PrintWriter ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class DefaultErrorHandler implements ErrorHandler , ErrorListener { PrintWriter m_pw ; public DefaultErrorHandler ( PrintWriter pw ) { m_pw = pw ; } public DefaultErrorHandler ( PrintStream pw ) { m_pw = new PrintWriter ( pw , true ) ; } public DefaultErrorHandler ( ) { m_pw = new PrintWriter ( System . err , true ) ; } public void warning ( SAXParseException exception ) throws SAXException { printLocation ( m_pw , exception ) ; m_pw . println ( "Parser warning: " + exception . getMessage ( ) ) ; } public void error ( SAXParseException exception ) throws SAXException { throw exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { throw exception ; } public void warning ( TransformerException exception ) throws TransformerException { printLocation ( m_pw , exception ) ; m_pw . println ( exception . getMessage ( ) ) ; } public void error ( TransformerException exception ) throws TransformerException { throw exception ; } public void fatalError ( TransformerException exception ) throws TransformerException { throw exception ; } public static void ensureLocationSet ( TransformerException exception ) { SourceLocator locator = null ; Throwable cause = exception ; do { if ( cause instanceof SAXParseException ) { locator = new SAXSourceLocator ( ( SAXParseException ) cause ) ; } else if ( cause instanceof TransformerException ) { SourceLocator causeLocator = ( ( TransformerException ) cause ) . getLocator ( ) ; if ( null != causeLocator ) locator = causeLocator ; } if ( cause instanceof TransformerException ) cause = ( ( TransformerException ) cause ) . getCause ( ) ; else if ( cause instanceof SAXException ) cause = ( ( SAXException ) cause ) . getException ( ) ; else cause = null ; } while ( null != cause ) ; exception . setLocator ( locator ) ; } public static void printLocation ( PrintStream pw , TransformerException exception ) { printLocation ( new PrintWriter ( pw ) , exception ) ; } public static void printLocation ( java . io . PrintStream pw , org . xml . sax . SAXParseException exception ) { printLocation ( new PrintWriter ( pw ) , exception ) ; } public static void printLocation ( PrintWriter pw , Throwable exception ) { SourceLocator locator = null ; Throwable cause = exception ; do { if ( cause instanceof SAXParseException ) { locator = new SAXSourceLocator ( ( SAXParseException ) cause ) ; } else if ( cause instanceof TransformerException ) { SourceLocator causeLocator = ( ( TransformerException ) cause ) . getLocator ( ) ; if ( null != causeLocator ) locator = causeLocator ; } if ( cause instanceof TransformerException ) cause = ( ( TransformerException ) cause ) . getCause ( ) ; else if ( cause instanceof WrappedRuntimeException ) cause = ( ( WrappedRuntimeException ) cause ) . getException ( ) ; else if ( cause instanceof SAXException ) cause = ( ( SAXException ) cause ) . getException ( ) ; else cause = null ; } while ( null != cause ) ; if ( null != locator ) { String id = ( null != locator . getPublicId ( ) ) ? locator . getPublicId ( ) : ( null != locator . getSystemId ( ) ) ? locator . getSystemId ( ) : XMLMessages . createXMLMessage ( XMLErrorResources . ER_SYSTEMID_UNKNOWN , null ) ; pw . print ( id + "; " + XMLMessages . createXMLMessage ( "line" , null ) + locator . getLineNumber ( ) + "; " + XMLMessages . createXMLMessage ( "column" , null ) + locator . getColumnNumber ( ) + "; " ) ; } else pw . print ( "(" + XMLMessages . createXMLMessage ( XMLErrorResources . ER_LOCATION_UNKNOWN , null ) + ")" ) ; } } 	1	['13', '1', '1', '13', '35', '58', '10', '3', '13', '0.666666667', '260', '0', '0', '0', '0.307692308', '0', '0', '18.92307692', '11', '2', '1']
package org . apache . xml . utils ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Attr ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Comment ; import org . w3c . dom . DOMException ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . EntityReference ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; public class UnImplNode implements Node , Element , NodeList , Document { public UnImplNode ( ) { } public void error ( String msg ) { System . out . println ( "DOM ERROR! class: " + this . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( XMLMessages . createXMLMessage ( msg , null ) ) ; } public void error ( String msg , Object [ ] args ) { System . out . println ( "DOM ERROR! class: " + this . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( XMLMessages . createXMLMessage ( msg , args ) ) ; } public Node appendChild ( Node newChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean hasChildNodes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public short getNodeType ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return 0 ; } public Node getParentNode ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public NodeList getChildNodes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getFirstChild ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getLastChild ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getNextSibling ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public int getLength ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return 0 ; } public Node item ( int index ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Document getOwnerDocument ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getTagName ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getNodeName ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void normalize ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public NodeList getElementsByTagName ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr setAttributeNode ( Attr newAttr ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean hasAttribute ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public boolean hasAttributeNS ( String name , String x ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public Attr getAttributeNode ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void removeAttribute ( String name ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void setAttribute ( String name , String value ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getAttribute ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean hasAttributes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getPreviousSibling ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node cloneNode ( boolean deep ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getNodeValue ( ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setNodeValue ( String nodeValue ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void setValue ( String value ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public Element getOwnerElement ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean getSpecified ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public NamedNodeMap getAttributes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node removeChild ( Node oldChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getNamespaceURI ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getPrefix ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setPrefix ( String prefix ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getLocalName ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public DocumentType getDoctype ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public DOMImplementation getImplementation ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element getDocumentElement ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element createElement ( String tagName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public DocumentFragment createDocumentFragment ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Text createTextNode ( String data ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Comment createComment ( String data ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public CDATASection createCDATASection ( String data ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr createAttribute ( String name ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public EntityReference createEntityReference ( String name ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node importNode ( Node importedNode , boolean deep ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element getElementById ( String elementId ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setData ( String data ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String substringData ( int offset , int count ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void appendData ( String arg ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void insertData ( int offset , String arg ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void deleteData ( int offset , int count ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void replaceData ( int offset , int count , String arg ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public Text splitText ( int offset ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node adoptNode ( Node source ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getEncoding ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setEncoding ( String encoding ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public boolean getStandalone ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public void setStandalone ( boolean standalone ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public boolean getStrictErrorChecking ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public void setStrictErrorChecking ( boolean strictErrorChecking ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getVersion ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setVersion ( String version ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } } 	1	['107', '1', '1', '2', '117', '5671', '1', '1', '107', '2', '648', '0', '0', '0', '0.191069574', '0', '0', '5.056074766', '1', '0.9907', '1']
package org . apache . xpath ; import javax . xml . transform . SourceLocator ; import org . apache . xml . utils . PrefixResolver ; public interface XPathFactory { XPath create ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type ) ; } 	1	['1', '1', '0', '5', '1', '0', '3', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xml . utils . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XResourceBundle extends ListResourceBundle { public static final String ERROR_RESOURCES = "org.apache.xalan.res.XSLTErrorResources" , XSLT_RESOURCE = "org.apache.xml.utils.res.XResourceBundle" , LANG_BUNDLE_NAME = "org.apache.xml.utils.res.XResources" , MULT_ORDER = "multiplierOrder" , MULT_PRECEDES = "precedes" , MULT_FOLLOWS = "follows" , LANG_ORIENTATION = "orientation" , LANG_RIGHTTOLEFT = "rightToLeft" , LANG_LEFTTORIGHT = "leftToRight" , LANG_NUMBERING = "numbering" , LANG_ADDITIVE = "additive" , LANG_MULT_ADD = "multiplicative-additive" , LANG_MULTIPLIER = "multiplier" , LANG_MULTIPLIER_CHAR = "multiplierChar" , LANG_NUMBERGROUPS = "numberGroups" , LANG_NUM_TABLES = "tables" , LANG_ALPHABET = "alphabet" , LANG_TRAD_ALPHABET = "tradAlphabet" ; public static final XResourceBundle loadResourceBundle ( String className , Locale locale ) throws MissingResourceException { String suffix = getResourceSuffix ( locale ) ; try { String resourceName = className + suffix ; return ( XResourceBundle ) ResourceBundle . getBundle ( resourceName , locale ) ; } catch ( MissingResourceException e ) { try { return ( XResourceBundle ) ResourceBundle . getBundle ( XSLT_RESOURCE , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String lang = locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; String variant = locale . getVariant ( ) ; String suffix = "_" + locale . getLanguage ( ) ; if ( lang . equals ( "zh" ) ) suffix += "_" + country ; if ( country . equals ( "JP" ) ) suffix += "_" + country + "_" + variant ; return suffix ; } public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['5', '3', '18', '19', '16', '8', '19', '0', '3', '1.223684211', '424', '0', '0', '0.926829268', '0.416666667', '0', '0', '80', '3', '1', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class WithParam extends Instruction { private QName _name ; private Expression _select ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "with-param " + _name ) ; if ( _select != null ) { indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; } displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; if ( name . length ( ) > 0 ) { _name = parser . getQName ( name ) ; } else { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; } final String select = getAttribute ( "select" ) ; if ( select . length ( ) > 0 ) { _select = parser . parseExpression ( this , "select" , null ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { final Type tselect = _select . typeCheck ( stable ) ; if ( tselect instanceof ReferenceType == false ) { _select = new CastExpr ( _select , Type . Reference ) ; } } else { typeCheckContents ( stable ) ; } return Type . Void ; } public void translateValue ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _select != null ) { _select . translate ( classGen , methodGen ) ; _select . startResetIterator ( classGen , methodGen ) ; } else if ( hasContents ( ) ) { compileResultTree ( classGen , methodGen ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; String name = Util . escape ( _name . getLocalPart ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , name ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , ADD_PARAMETER , ADD_PARAMETER_SIG ) ) ) ; il . append ( POP ) ; } } 	1	['6', '3', '0', '21', '39', '0', '0', '21', '5', '0.4', '201', '1', '2', '0.918032787', '0.361111111', '1', '7', '32.16666667', '3', '1.6667', '2']
package org . apache . xalan . lib ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . extensions . XSLProcessorContext ; import org . apache . xalan . templates . AVT ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xpath . XPathContext ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; public class PipeDocument { public void pipeDocument ( XSLProcessorContext context , ElemExtensionCall elem ) throws TransformerException , TransformerConfigurationException , SAXException , IOException , FileNotFoundException { try { SAXTransformerFactory saxTFactory = ( SAXTransformerFactory ) TransformerFactory . newInstance ( ) ; String source = elem . getAttribute ( "source" , context . getContextNode ( ) , context . getTransformer ( ) ) ; TransformerImpl transImpl = context . getTransformer ( ) ; String baseURLOfSource = transImpl . getBaseURLOfSource ( ) ; String absSourceURL = SystemIDResolver . getAbsoluteURI ( source , baseURLOfSource ) ; String target = elem . getAttribute ( "target" , context . getContextNode ( ) , context . getTransformer ( ) ) ; XPathContext xctxt = context . getTransformer ( ) . getXPathContext ( ) ; int xt = xctxt . getDTMHandleFromNode ( context . getContextNode ( ) ) ; String sysId = elem . getSystemId ( ) ; NodeList ssNodes = null ; NodeList paramNodes = null ; Node ssNode = null ; Node paramNode = null ; if ( elem . hasChildNodes ( ) ) { ssNodes = elem . getChildNodes ( ) ; Vector vTHandler = new Vector ( ssNodes . getLength ( ) ) ; for ( int i = 0 ; i < ssNodes . getLength ( ) ; i ++ ) { ssNode = ssNodes . item ( i ) ; if ( ssNode . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) ssNode ) . getTagName ( ) . equals ( "stylesheet" ) && ssNode instanceof ElemLiteralResult ) { AVT avt = ( ( ElemLiteralResult ) ssNode ) . getLiteralResultAttribute ( "href" ) ; String href = avt . evaluate ( xctxt , xt , elem ) ; String absURI = SystemIDResolver . getAbsoluteURI ( href , sysId ) ; Templates tmpl = saxTFactory . newTemplates ( new StreamSource ( absURI ) ) ; TransformerHandler tHandler = saxTFactory . newTransformerHandler ( tmpl ) ; Transformer trans = tHandler . getTransformer ( ) ; vTHandler . addElement ( tHandler ) ; paramNodes = ssNode . getChildNodes ( ) ; for ( int j = 0 ; j < paramNodes . getLength ( ) ; j ++ ) { paramNode = paramNodes . item ( j ) ; if ( paramNode . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) paramNode ) . getTagName ( ) . equals ( "param" ) && paramNode instanceof ElemLiteralResult ) { avt = ( ( ElemLiteralResult ) paramNode ) . getLiteralResultAttribute ( "name" ) ; String pName = avt . evaluate ( xctxt , xt , elem ) ; avt = ( ( ElemLiteralResult ) paramNode ) . getLiteralResultAttribute ( "value" ) ; String pValue = avt . evaluate ( xctxt , xt , elem ) ; trans . setParameter ( pName , pValue ) ; } } } } usePipe ( vTHandler , absSourceURL , target ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void usePipe ( Vector vTHandler , String source , String target ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , IOException , SAXException , SAXNotRecognizedException { XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; TransformerHandler tHFirst = ( TransformerHandler ) vTHandler . firstElement ( ) ; reader . setContentHandler ( tHFirst ) ; reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , tHFirst ) ; for ( int i = 1 ; i < vTHandler . size ( ) ; i ++ ) { TransformerHandler tHFrom = ( TransformerHandler ) vTHandler . elementAt ( i - 1 ) ; TransformerHandler tHTo = ( TransformerHandler ) vTHandler . elementAt ( i ) ; tHFrom . setResult ( new SAXResult ( tHTo ) ) ; } TransformerHandler tHLast = ( TransformerHandler ) vTHandler . lastElement ( ) ; Transformer trans = tHLast . getTransformer ( ) ; Properties outputProps = trans . getOutputProperties ( ) ; Serializer serializer = SerializerFactory . getSerializer ( outputProps ) ; serializer . setOutputStream ( new FileOutputStream ( target ) ) ; tHLast . setResult ( new SAXResult ( serializer . asContentHandler ( ) ) ) ; reader . parse ( source ) ; } } 	1	['3', '1', '0', '10', '46', '3', '0', '10', '3', '2', '257', '0', '0', '0', '0.466666667', '0', '0', '84.66666667', '1', '0.6667', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ACONST_NULL ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DCONST ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Variable extends VariableBase { public int getIndex ( ) { return ( _local != null ) ? _local . getIndex ( ) : - 1 ; } public void parseContents ( Parser parser ) { super . parseContents ( parser ) ; SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof Stylesheet ) { _isLocal = false ; Variable var = parser . getSymbolTable ( ) . lookupVariable ( _name ) ; if ( var != null ) { final int us = this . getImportPrecedence ( ) ; final int them = var . getImportPrecedence ( ) ; if ( us == them ) { final String name = _name . toString ( ) ; reportError ( this , parser , ErrorMsg . VARIABLE_REDEF_ERR , name ) ; } else if ( them > us ) { _ignore = true ; return ; } else { var . disable ( ) ; } } ( ( Stylesheet ) parent ) . addVariable ( this ) ; parser . getSymbolTable ( ) . addVariable ( this ) ; } else { _isLocal = true ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { _type = _select . typeCheck ( stable ) ; } else if ( hasContents ( ) ) { typeCheckContents ( stable ) ; _type = Type . ResultTree ; } else { _type = Type . Reference ; } return Type . Void ; } public void initialize ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( isLocal ( ) && ! _refs . isEmpty ( ) ) { if ( _local == null ) { _local = methodGen . addLocalVariable2 ( _name . getLocalPart ( ) , _type . toJCType ( ) , il . getEnd ( ) ) ; } if ( ( _type instanceof IntType ) || ( _type instanceof NodeType ) || ( _type instanceof BooleanType ) ) il . append ( new ICONST ( 0 ) ) ; else if ( _type instanceof RealType ) il . append ( new DCONST ( 0 ) ) ; else il . append ( new ACONST_NULL ( ) ) ; il . append ( _type . STORE ( _local . getIndex ( ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String name = getVariable ( ) ; if ( _ignore ) return ; _ignore = true ; if ( isLocal ( ) ) { translateValue ( classGen , methodGen ) ; if ( _refs . isEmpty ( ) ) { il . append ( _type . POP ( ) ) ; _local = null ; } else { if ( _local == null ) mapRegister ( methodGen ) ; il . append ( _type . STORE ( _local . getIndex ( ) ) ) ; } } else { String signature = _type . toSignature ( ) ; if ( classGen . containsField ( name ) == null ) { classGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( name ) , cpg . addUtf8 ( signature ) , null , cpg . getConstantPool ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( classGen . getClassName ( ) , name , signature ) ) ) ; } } } } 	1	['6', '4', '0', '34', '48', '1', '10', '28', '5', '2', '282', '0', '0', '0.938271605', '0.4', '2', '13', '46', '8', '3.6667', '1']
package org . apache . xml . utils ; import java . io . IOException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; public class DOM2Helper extends DOMHelper { public DOM2Helper ( ) { } public void checkNode ( Node node ) throws TransformerException { } public boolean supportsSAX ( ) { return true ; } private Document m_doc ; public void setDocument ( Document doc ) { m_doc = doc ; } public Document getDocument ( ) { return m_doc ; } public void parse ( InputSource source ) throws TransformerException { try { DocumentBuilderFactory builderFactory = DocumentBuilderFactory . newInstance ( ) ; builderFactory . setNamespaceAware ( true ) ; builderFactory . setValidating ( true ) ; DocumentBuilder parser = builderFactory . newDocumentBuilder ( ) ; parser . setErrorHandler ( new org . apache . xml . utils . DefaultErrorHandler ( ) ) ; setDocument ( parser . parse ( source ) ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } catch ( ParserConfigurationException pce ) { throw new TransformerException ( pce ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } public Element getElementByID ( String id , Document doc ) { return doc . getElementById ( id ) ; } public static boolean isNodeAfter ( Node node1 , Node node2 ) { if ( node1 instanceof DOMOrder && node2 instanceof DOMOrder ) { int index1 = ( ( DOMOrder ) node1 ) . getUid ( ) ; int index2 = ( ( DOMOrder ) node2 ) . getUid ( ) ; return index1 <= index2 ; } else { return DOMHelper . isNodeAfter ( node1 , node2 ) ; } } public static Node getParentOfNode ( Node node ) { Node parent = node . getParentNode ( ) ; if ( parent == null && ( Node . ATTRIBUTE_NODE == node . getNodeType ( ) ) ) parent = ( ( Attr ) node ) . getOwnerElement ( ) ; return parent ; } public String getLocalNameOfNode ( Node n ) { String name = n . getLocalName ( ) ; return ( null == name ) ? super . getLocalNameOfNode ( n ) : name ; } public String getNamespaceOfNode ( Node n ) { return n . getNamespaceURI ( ) ; } } 	1	['11', '2', '1', '10', '29', '53', '7', '3', '11', '0.8', '125', '1', '0', '0.714285714', '0.327272727', '1', '5', '10.27272727', '4', '1.4545', '1']
package org . apache . xml . res ; public class XMLErrorResources_en extends XMLErrorResources { } 	1	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xalan . transformer ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class KeyRefIterator extends org . apache . xpath . axes . ChildTestIterator { public KeyRefIterator ( QName name , XMLString ref , Vector keyDecls , DTMIterator ki ) { super ( null ) ; m_name = name ; m_ref = ref ; m_keyDeclarations = keyDecls ; m_keysNodes = ki ; setWhatToShow ( org . apache . xml . dtm . DTMFilter . SHOW_ALL ) ; } DTMIterator m_keysNodes ; protected int getNextNode ( ) { int next ; while ( DTM . NULL != ( next = m_keysNodes . nextNode ( ) ) ) { if ( DTMIterator . FILTER_ACCEPT == filterNode ( next ) ) break ; } m_lastFetched = next ; return next ; } public short filterNode ( int testNode ) { boolean foundKey = false ; Vector keys = m_keyDeclarations ; QName name = m_name ; KeyIterator ki = ( KeyIterator ) ( ( ( XNodeSet ) m_keysNodes ) . getContainedIter ( ) ) ; org . apache . xpath . XPathContext xctxt = ki . getXPathContext ( ) ; if ( null == xctxt ) assertion ( false , "xctxt can not be null here!" ) ; try { XMLString lookupKey = m_ref ; int nDeclarations = keys . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) keys . elementAt ( i ) ; if ( ! kd . getName ( ) . equals ( name ) ) continue ; foundKey = true ; XObject xuse = kd . getUse ( ) . execute ( xctxt , testNode , ki . getPrefixResolver ( ) ) ; if ( xuse . getType ( ) != xuse . CLASS_NODESET ) { XMLString exprResult = xuse . xstr ( ) ; if ( lookupKey . equals ( exprResult ) ) return DTMIterator . FILTER_ACCEPT ; } else { DTMIterator nl = ( ( XNodeSet ) xuse ) . iterRaw ( ) ; int useNode ; while ( DTM . NULL != ( useNode = nl . nextNode ( ) ) ) { DTM dtm = getDTM ( useNode ) ; XMLString exprResult = dtm . getStringValue ( useNode ) ; if ( ( null != exprResult ) && lookupKey . equals ( exprResult ) ) return DTMIterator . FILTER_ACCEPT ; } } } } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } if ( ! foundKey ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_XSLKEY_DECLARATION , new Object [ ] { name . getLocalName ( ) } ) ) ; return DTMIterator . FILTER_REJECT ; } protected XMLString m_ref ; protected QName m_name ; protected Vector m_keyDeclarations ; } 	1	['3', '7', '0', '15', '26', '0', '0', '15', '2', '0', '171', '0.75', '3', '0.985185185', '0.444444444', '3', '4', '54.66666667', '6', '3', '1']
package org . apache . xpath . compiler ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . Expression ; import org . apache . xpath . axes . UnionPathIterator ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . functions . Function ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XString ; import org . apache . xpath . operations . And ; import org . apache . xpath . operations . Div ; import org . apache . xpath . operations . Equals ; import org . apache . xpath . operations . Gt ; import org . apache . xpath . operations . Gte ; import org . apache . xpath . operations . Lt ; import org . apache . xpath . operations . Lte ; import org . apache . xpath . operations . Minus ; import org . apache . xpath . operations . Mod ; import org . apache . xpath . operations . Mult ; import org . apache . xpath . operations . Neg ; import org . apache . xpath . operations . NotEquals ; import org . apache . xpath . operations . Operation ; import org . apache . xpath . operations . Or ; import org . apache . xpath . operations . Plus ; import org . apache . xpath . operations . UnaryOperation ; import org . apache . xpath . operations . Variable ; import org . apache . xpath . patterns . FunctionPattern ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . patterns . UnionPattern ; import org . apache . xpath . res . XPATHErrorResources ; public class Compiler extends OpMap { public Compiler ( ErrorListener errorHandler , SourceLocator locator ) { m_errorHandler = errorHandler ; m_locator = locator ; } public Compiler ( ) { m_errorHandler = null ; m_locator = null ; } public Expression compile ( int opPos ) throws TransformerException { int op = getOp ( opPos ) ; Expression expr = null ; switch ( op ) { case OpCodes . OP_XPATH : expr = compile ( opPos + 2 ) ; break ; case OpCodes . OP_OR : expr = or ( opPos ) ; break ; case OpCodes . OP_AND : expr = and ( opPos ) ; break ; case OpCodes . OP_NOTEQUALS : expr = notequals ( opPos ) ; break ; case OpCodes . OP_EQUALS : expr = equals ( opPos ) ; break ; case OpCodes . OP_LTE : expr = lte ( opPos ) ; break ; case OpCodes . OP_LT : expr = lt ( opPos ) ; break ; case OpCodes . OP_GTE : expr = gte ( opPos ) ; break ; case OpCodes . OP_GT : expr = gt ( opPos ) ; break ; case OpCodes . OP_PLUS : expr = plus ( opPos ) ; break ; case OpCodes . OP_MINUS : expr = minus ( opPos ) ; break ; case OpCodes . OP_MULT : expr = mult ( opPos ) ; break ; case OpCodes . OP_DIV : expr = div ( opPos ) ; break ; case OpCodes . OP_MOD : expr = mod ( opPos ) ; break ; case OpCodes . OP_NEG : expr = neg ( opPos ) ; break ; case OpCodes . OP_STRING : expr = string ( opPos ) ; break ; case OpCodes . OP_BOOL : expr = bool ( opPos ) ; break ; case OpCodes . OP_NUMBER : expr = number ( opPos ) ; break ; case OpCodes . OP_UNION : expr = union ( opPos ) ; break ; case OpCodes . OP_LITERAL : expr = literal ( opPos ) ; break ; case OpCodes . OP_VARIABLE : expr = variable ( opPos ) ; break ; case OpCodes . OP_GROUP : expr = group ( opPos ) ; break ; case OpCodes . OP_NUMBERLIT : expr = numberlit ( opPos ) ; break ; case OpCodes . OP_ARGUMENT : expr = arg ( opPos ) ; break ; case OpCodes . OP_EXTFUNCTION : expr = compileExtension ( opPos ) ; break ; case OpCodes . OP_FUNCTION : expr = compileFunction ( opPos ) ; break ; case OpCodes . OP_LOCATIONPATH : expr = locationPath ( opPos ) ; break ; case OpCodes . OP_PREDICATE : expr = null ; break ; case OpCodes . OP_MATCHPATTERN : expr = matchPattern ( opPos + 2 ) ; break ; case OpCodes . OP_LOCATIONPATHPATTERN : expr = locationPathPattern ( opPos ) ; break ; case OpCodes . OP_QUO : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { "quo" } ) ; break ; default : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { Integer . toString ( getOp ( opPos ) ) } ) ; } return expr ; } private Expression compileOperation ( Operation operation , int opPos ) throws TransformerException { int leftPos = getFirstChildPos ( opPos ) ; int rightPos = getNextOpPos ( leftPos ) ; operation . setLeftRight ( compile ( leftPos ) , compile ( rightPos ) ) ; return operation ; } private Expression compileUnary ( UnaryOperation unary , int opPos ) throws TransformerException { int rightPos = getFirstChildPos ( opPos ) ; unary . setRight ( compile ( rightPos ) ) ; return unary ; } protected Expression or ( int opPos ) throws TransformerException { return compileOperation ( new Or ( ) , opPos ) ; } protected Expression and ( int opPos ) throws TransformerException { return compileOperation ( new And ( ) , opPos ) ; } protected Expression notequals ( int opPos ) throws TransformerException { return compileOperation ( new NotEquals ( ) , opPos ) ; } protected Expression equals ( int opPos ) throws TransformerException { return compileOperation ( new Equals ( ) , opPos ) ; } protected Expression lte ( int opPos ) throws TransformerException { return compileOperation ( new Lte ( ) , opPos ) ; } protected Expression lt ( int opPos ) throws TransformerException { return compileOperation ( new Lt ( ) , opPos ) ; } protected Expression gte ( int opPos ) throws TransformerException { return compileOperation ( new Gte ( ) , opPos ) ; } protected Expression gt ( int opPos ) throws TransformerException { return compileOperation ( new Gt ( ) , opPos ) ; } protected Expression plus ( int opPos ) throws TransformerException { return compileOperation ( new Plus ( ) , opPos ) ; } protected Expression minus ( int opPos ) throws TransformerException { return compileOperation ( new Minus ( ) , opPos ) ; } protected Expression mult ( int opPos ) throws TransformerException { return compileOperation ( new Mult ( ) , opPos ) ; } protected Expression div ( int opPos ) throws TransformerException { return compileOperation ( new Div ( ) , opPos ) ; } protected Expression mod ( int opPos ) throws TransformerException { return compileOperation ( new Mod ( ) , opPos ) ; } protected Expression neg ( int opPos ) throws TransformerException { return compileUnary ( new Neg ( ) , opPos ) ; } protected Expression string ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . String ( ) , opPos ) ; } protected Expression bool ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . Bool ( ) , opPos ) ; } protected Expression number ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . Number ( ) , opPos ) ; } protected Expression literal ( int opPos ) { opPos = getFirstChildPos ( opPos ) ; return ( XString ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; } protected Expression numberlit ( int opPos ) { opPos = getFirstChildPos ( opPos ) ; return ( XNumber ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; } protected Expression variable ( int opPos ) throws TransformerException { Variable var = new Variable ( ) ; opPos = getFirstChildPos ( opPos ) ; int nsPos = getOp ( opPos ) ; java . lang . String namespace = ( OpCodes . EMPTY == nsPos ) ? null : ( java . lang . String ) getTokenQueue ( ) . elementAt ( nsPos ) ; java . lang . String localname = ( java . lang . String ) getTokenQueue ( ) . elementAt ( getOp ( opPos + 1 ) ) ; QName qname = new QName ( namespace , localname ) ; var . setQName ( qname ) ; return var ; } protected Expression group ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression arg ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression union ( int opPos ) throws TransformerException { locPathDepth ++ ; try { return UnionPathIterator . createUnionIterator ( this , opPos ) ; } finally { locPathDepth -- ; } } private int locPathDepth = - 1 ; public int getLocationPathDepth ( ) { return locPathDepth ; } public Expression locationPath ( int opPos ) throws TransformerException { locPathDepth ++ ; try { DTMIterator iter = WalkerFactory . newDTMIterator ( this , opPos , ( locPathDepth == 0 ) ) ; return ( Expression ) iter ; } finally { locPathDepth -- ; } } public Expression predicate ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression matchPattern ( int opPos ) throws TransformerException { locPathDepth ++ ; try { int nextOpPos = opPos ; int i ; for ( i = 0 ; getOp ( nextOpPos ) == OpCodes . OP_LOCATIONPATHPATTERN ; i ++ ) { nextOpPos = getNextOpPos ( nextOpPos ) ; } if ( i == 1 ) return compile ( opPos ) ; UnionPattern up = new UnionPattern ( ) ; StepPattern [ ] patterns = new StepPattern [ i ] ; for ( i = 0 ; getOp ( opPos ) == OpCodes . OP_LOCATIONPATHPATTERN ; i ++ ) { nextOpPos = getNextOpPos ( opPos ) ; patterns [ i ] = ( StepPattern ) compile ( opPos ) ; opPos = nextOpPos ; } up . setPatterns ( patterns ) ; return up ; } finally { locPathDepth -- ; } } public Expression locationPathPattern ( int opPos ) throws TransformerException { opPos = getFirstChildPos ( opPos ) ; return stepPattern ( opPos , 0 , null ) ; } public int getWhatToShow ( int opPos ) { int axesType = getOp ( opPos ) ; int testType = getOp ( opPos + 3 ) ; switch ( testType ) { case OpCodes . NODETYPE_COMMENT : return DTMFilter . SHOW_COMMENT ; case OpCodes . NODETYPE_TEXT : return DTMFilter . SHOW_TEXT | DTMFilter . SHOW_CDATA_SECTION ; case OpCodes . NODETYPE_PI : return DTMFilter . SHOW_PROCESSING_INSTRUCTION ; case OpCodes . NODETYPE_NODE : switch ( axesType ) { case OpCodes . FROM_NAMESPACE : return DTMFilter . SHOW_NAMESPACE ; case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : return DTMFilter . SHOW_ATTRIBUTE ; case OpCodes . FROM_SELF : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . FROM_DESCENDANTS_OR_SELF : return DTMFilter . SHOW_ALL ; default : if ( getOp ( 0 ) == OpCodes . OP_MATCHPATTERN ) return ~ DTMFilter . SHOW_ATTRIBUTE & ~ DTMFilter . SHOW_DOCUMENT & ~ DTMFilter . SHOW_DOCUMENT_FRAGMENT ; else return ~ DTMFilter . SHOW_ATTRIBUTE ; } case OpCodes . NODETYPE_ROOT : return DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ; case OpCodes . NODETYPE_FUNCTEST : return NodeTest . SHOW_BYFUNCTION ; case OpCodes . NODENAME : switch ( axesType ) { case OpCodes . FROM_NAMESPACE : return DTMFilter . SHOW_NAMESPACE ; case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : return DTMFilter . SHOW_ATTRIBUTE ; case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : return DTMFilter . SHOW_ELEMENT ; default : return DTMFilter . SHOW_ELEMENT ; } default : return DTMFilter . SHOW_ALL ; } } private static final boolean DEBUG = false ; protected StepPattern stepPattern ( int opPos , int stepCount , StepPattern ancestorPattern ) throws TransformerException { int startOpPos = opPos ; int stepType = getOp ( opPos ) ; if ( OpCodes . ENDOP == stepType ) { return null ; } boolean addMagicSelf = true ; int endStep = getNextOpPos ( opPos ) ; StepPattern pattern ; int argLen ; switch ( stepType ) { case OpCodes . OP_FUNCTION : if ( DEBUG ) System . out . println ( "MATCH_FUNCTION: " + m_currentPattern ) ; addMagicSelf = false ; argLen = getOp ( opPos + OpMap . MAPINDEX_LENGTH ) ; pattern = new FunctionPattern ( compileFunction ( opPos ) , Axis . PARENT , Axis . CHILD ) ; break ; case OpCodes . FROM_ROOT : if ( DEBUG ) System . out . println ( "FROM_ROOT, " + m_currentPattern ) ; addMagicSelf = false ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT , Axis . PARENT , Axis . CHILD ) ; break ; case OpCodes . MATCH_ATTRIBUTE : if ( DEBUG ) System . out . println ( "MATCH_ATTRIBUTE: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( DTMFilter . SHOW_ATTRIBUTE , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . PARENT , Axis . ATTRIBUTE ) ; break ; case OpCodes . MATCH_ANY_ANCESTOR : if ( DEBUG ) System . out . println ( "MATCH_ANY_ANCESTOR: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; int what = getWhatToShow ( startOpPos ) ; if ( 0x00000500 == what ) addMagicSelf = false ; pattern = new StepPattern ( getWhatToShow ( startOpPos ) , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . ANCESTOR , Axis . CHILD ) ; break ; case OpCodes . MATCH_IMMEDIATE_ANCESTOR : if ( DEBUG ) System . out . println ( "MATCH_IMMEDIATE_ANCESTOR: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( getWhatToShow ( startOpPos ) , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . PARENT , Axis . CHILD ) ; break ; default : error ( XPATHErrorResources . ER_UNKNOWN_MATCH_OPERATION , null ) ; return null ; } pattern . setPredicates ( getCompiledPredicates ( opPos + argLen ) ) ; if ( null == ancestorPattern ) { } else { pattern . setRelativePathPattern ( ancestorPattern ) ; } StepPattern relativePathPattern = stepPattern ( endStep , stepCount + 1 , pattern ) ; return ( null != relativePathPattern ) ? relativePathPattern : pattern ; } public Expression [ ] getCompiledPredicates ( int opPos ) throws TransformerException { int count = countPredicates ( opPos ) ; if ( count > 0 ) { Expression [ ] predicates = new Expression [ count ] ; compilePredicates ( opPos , predicates ) ; return predicates ; } return null ; } public int countPredicates ( int opPos ) throws TransformerException { int count = 0 ; while ( OpCodes . OP_PREDICATE == getOp ( opPos ) ) { count ++ ; opPos = getNextOpPos ( opPos ) ; } return count ; } private void compilePredicates ( int opPos , Expression [ ] predicates ) throws TransformerException { for ( int i = 0 ; OpCodes . OP_PREDICATE == getOp ( opPos ) ; i ++ ) { predicates [ i ] = predicate ( opPos ) ; opPos = getNextOpPos ( opPos ) ; } } Expression compileFunction ( int opPos ) throws TransformerException { int endFunc = opPos + getOp ( opPos + 1 ) - 1 ; opPos = getFirstChildPos ( opPos ) ; int funcID = getOp ( opPos ) ; opPos ++ ; if ( - 1 != funcID ) { Function func = FunctionTable . getFunction ( funcID ) ; func . postCompileStep ( this ) ; try { int i = 0 ; for ( int p = opPos ; p < endFunc ; p = getNextOpPos ( p ) , i ++ ) { func . setArg ( compile ( p ) , i ) ; } func . checkNumberArgs ( i ) ; } catch ( WrongNumberArgsException wnae ) { java . lang . String name = FunctionTable . m_functions [ funcID ] . getName ( ) ; m_errorHandler . fatalError ( new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_ONLY_ALLOWS , new Object [ ] { name , wnae . getMessage ( ) } ) , m_locator ) ) ; } return func ; } else { error ( XPATHErrorResources . ER_FUNCTION_TOKEN_NOT_FOUND , null ) ; return null ; } } private Expression compileExtension ( int opPos ) throws TransformerException { int endExtFunc = opPos + getOp ( opPos + 1 ) - 1 ; opPos = getFirstChildPos ( opPos ) ; java . lang . String ns = ( java . lang . String ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; opPos ++ ; java . lang . String funcName = ( java . lang . String ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; opPos ++ ; Function extension = new FuncExtFunction ( ns , funcName , String . valueOf ( opPos ) + String . valueOf ( hashCode ( ) ) + String . valueOf ( System . currentTimeMillis ( ) ) ) ; try { int i = 0 ; while ( opPos < endExtFunc ) { int nextOpPos = getNextOpPos ( opPos ) ; extension . setArg ( this . compile ( opPos ) , i ) ; opPos = nextOpPos ; i ++ ; } } catch ( WrongNumberArgsException wnae ) { ; } return extension ; } public void warn ( String msg , Object [ ] args ) throws TransformerException { java . lang . String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; if ( null != m_errorHandler ) { m_errorHandler . warning ( new TransformerException ( fmsg , m_locator ) ) ; } else { System . out . println ( fmsg + "; file " + m_locator . getSystemId ( ) + "; line " + m_locator . getLineNumber ( ) + "; column " + m_locator . getColumnNumber ( ) ) ; } } public void assertion ( boolean b , java . lang . String msg ) { if ( ! b ) { java . lang . String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( String msg , Object [ ] args ) throws TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != m_errorHandler ) { m_errorHandler . fatalError ( new TransformerException ( fmsg , m_locator ) ) ; } else { throw new TransformerException ( fmsg , ( SAXSourceLocator ) m_locator ) ; } } private PrefixResolver m_currentPrefixResolver = null ; public PrefixResolver getNamespaceContext ( ) { return m_currentPrefixResolver ; } public void setNamespaceContext ( PrefixResolver pr ) { m_currentPrefixResolver = pr ; } ErrorListener m_errorHandler ; SourceLocator m_locator ; } 	1	['45', '2', '0', '60', '112', '932', '23', '41', '15', '0.568181818', '1178', '0.6', '1', '0.328125', '0.175925926', '1', '1', '25.06666667', '12', '1.2222', '2']
package org . apache . xalan . xsltc . util ; public final class IntegerArray { private static final int InitialSize = 32 ; private int [ ] _array ; private int _size ; private int _free = 0 ; public IntegerArray ( ) { this ( InitialSize ) ; } public IntegerArray ( int size ) { _array = new int [ _size = size ] ; } public IntegerArray ( int [ ] array ) { this ( array . length ) ; System . arraycopy ( array , 0 , _array , 0 , _free = _size ) ; } public void clear ( ) { _free = 0 ; } public Object clone ( ) { final IntegerArray clone = new IntegerArray ( _free ) ; System . arraycopy ( _array , 0 , clone . _array , 0 , _free ) ; clone . _free = _free ; return clone ; } public int [ ] toIntArray ( ) { final int [ ] result = new int [ cardinality ( ) ] ; System . arraycopy ( _array , 0 , result , 0 , cardinality ( ) ) ; return result ; } public final int at ( int index ) { return _array [ index ] ; } public final void set ( int index , int value ) { _array [ index ] = value ; } public int indexOf ( int n ) { for ( int i = 0 ; i < _free ; i ++ ) { if ( n == _array [ i ] ) return i ; } return - 1 ; } public final void add ( int value ) { if ( _free == _size ) { growArray ( _size * 2 ) ; } _array [ _free ++ ] = value ; } public void addNew ( int value ) { for ( int i = 0 ; i < _free ; i ++ ) { if ( _array [ i ] == value ) return ; } add ( value ) ; } public void reverse ( ) { int left = 0 ; int right = _free - 1 ; while ( left < right ) { int temp = _array [ left ] ; _array [ left ++ ] = _array [ right ] ; _array [ right -- ] = temp ; } } public void merge ( IntegerArray other ) { final int newSize = _free + other . _free ; int [ ] newArray = new int [ newSize ] ; int i = 0 , j = 0 , k ; for ( k = 0 ; i < _free && j < other . _free ; k ++ ) { int x = _array [ i ] ; int y = other . _array [ j ] ; if ( x < y ) { newArray [ k ] = x ; i ++ ; } else if ( x > y ) { newArray [ k ] = y ; j ++ ; } else { newArray [ k ] = x ; i ++ ; j ++ ; } } if ( i >= _free ) { while ( j < other . _free ) { newArray [ k ++ ] = other . _array [ j ++ ] ; } } else { while ( i < _free ) { newArray [ k ++ ] = _array [ i ++ ] ; } } _array = newArray ; _free = _size = newSize ; } public void sort ( ) { quicksort ( _array , 0 , _free - 1 ) ; } private static void quicksort ( int [ ] array , int p , int r ) { if ( p < r ) { final int q = partition ( array , p , r ) ; quicksort ( array , p , q ) ; quicksort ( array , q + 1 , r ) ; } } private static int partition ( int [ ] array , int p , int r ) { final int x = array [ ( p + r ) > > > 1 ] ; int i = p - 1 ; int j = r + 1 ; while ( true ) { while ( x < array [ -- j ] ) ; while ( x > array [ ++ i ] ) ; if ( i < j ) { int temp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = temp ; } else { return j ; } } } private void growArray ( int size ) { final int [ ] newArray = new int [ _size = size ] ; System . arraycopy ( _array , 0 , newArray , 0 , _free ) ; _array = newArray ; } public int popLast ( ) { return _array [ -- _free ] ; } public int last ( ) { return _array [ _free - 1 ] ; } public void setLast ( int n ) { _array [ _free - 1 ] = n ; } public void pop ( ) { _free -- ; } public void pop ( int n ) { _free -= n ; } public final int cardinality ( ) { return _free ; } public void print ( java . io . PrintStream out ) { if ( _free > 0 ) { for ( int i = 0 ; i < _free - 1 ; i ++ ) { out . print ( _array [ i ] ) ; out . print ( ' ' ) ; } out . println ( _array [ _free - 1 ] ) ; } else { out . println ( "IntegerArray: empty" ) ; } } } 	1	['24', '1', '0', '4', '30', '0', '4', '0', '21', '0.543478261', '481', '1', '0', '0', '0.316666667', '0', '0', '18.875', '8', '1.6667', '1']
package org . apache . xml . utils . synthetic ; import java . lang . reflect . Modifier ; import org . apache . xml . utils . synthetic . reflection . Constructor ; import org . apache . xml . utils . synthetic . reflection . Field ; import org . apache . xml . utils . synthetic . reflection . Method ; public class Class extends Object implements java . io . Serializable { private static java . util . Hashtable global_classtable = new java . util . Hashtable ( ) ; private java . lang . String name ; private java . lang . Class realclass = null ; private int modifiers ; private boolean isInterface = false ; private Class superclass = null ; private Class declaringclass = null ; private Class [ ] interfaces = new Class [ 0 ] ; private Class [ ] allclasses = new Class [ 0 ] ; private Class [ ] declaredclasses = new Class [ 0 ] ; private Constructor [ ] allconstructors = new Constructor [ 0 ] ; private Constructor [ ] declaredconstructors = new Constructor [ 0 ] ; private Method [ ] allmethods = new Method [ 0 ] ; private Method [ ] declaredmethods = new Method [ 0 ] ; private Field [ ] allfields = new Field [ 0 ] ; private Field [ ] declaredfields = new Field [ 0 ] ; private Class [ ] innerclasses = new Class [ 0 ] ; Class ( java . lang . Class realclass ) { this ( realclass . getName ( ) ) ; try { setRealClass ( realclass ) ; } catch ( SynthesisException e ) { e . printStackTrace ( ) ; } } Class ( String fullname ) { this . name = fullname ; global_classtable . put ( fullname , this ) ; } public static Class forClass ( java . lang . Class cls ) { if ( cls == null ) return null ; Class ret = ( Class ) ( global_classtable . get ( cls . getName ( ) ) ) ; if ( null == ret ) ret = new Class ( cls ) ; return ret ; } public Class forNameInContext ( String classname ) throws ClassNotFoundException { for ( int i = innerclasses . length - 1 ; i >= 0 ; -- i ) { if ( classname . equals ( innerclasses [ i ] . getShortName ( ) ) ) return innerclasses [ i ] ; } return forName ( classname ) ; } public static Class forName ( String className ) throws ClassNotFoundException { if ( className . endsWith ( "]" ) ) { StringBuffer arrayname = new StringBuffer ( ) ; for ( int i = className . indexOf ( '[' ) ; i != - 1 ; i = className . indexOf ( '[' , i + 1 ) ) { arrayname . append ( '[' ) ; } String classname = className . substring ( 0 , className . indexOf ( '[' ) ) ; if ( "byte" . equals ( classname ) ) arrayname . append ( 'B' ) ; else if ( "char" . equals ( classname ) ) arrayname . append ( 'C' ) ; else if ( "double" . equals ( classname ) ) arrayname . append ( 'D' ) ; else if ( "float" . equals ( classname ) ) arrayname . append ( 'F' ) ; else if ( "int" . equals ( classname ) ) arrayname . append ( 'I' ) ; else if ( "long" . equals ( classname ) ) arrayname . append ( 'J' ) ; else if ( "short" . equals ( classname ) ) arrayname . append ( 'S' ) ; else if ( "boolean" . equals ( classname ) ) arrayname . append ( 'Z' ) ; else arrayname . append ( 'L' ) . append ( classname ) . append ( ';' ) ; return forName ( arrayname . toString ( ) ) ; } Class ret = ( Class ) ( global_classtable . get ( className ) ) ; if ( null == ret ) { if ( "boolean" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Boolean . TYPE ; } else if ( "byte" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Byte . TYPE ; } else if ( "char" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Character . TYPE ; } else if ( "short" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Short . TYPE ; } else if ( "int" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Integer . TYPE ; } else if ( "long" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Long . TYPE ; } else if ( "float" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Float . TYPE ; } else if ( "double" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Double . TYPE ; } else if ( "void" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Class . forName ( "java.lang.Object" ) ; } else ret = new Class ( java . lang . Class . forName ( className ) ) ; } return ret ; } public static Class declareClass ( String className ) throws SynthesisException { Class ret = ( Class ) ( global_classtable . get ( className ) ) ; if ( null == ret ) ret = new Class ( className ) ; if ( ret . realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; return ret ; } public static Class reallyDeclareClass ( String className ) { Class ret = ( Class ) ( global_classtable . get ( className ) ) ; if ( null != ret ) global_classtable . remove ( ret ) ; ret = new Class ( className ) ; return ret ; } public Class [ ] getClasses ( ) { if ( realclass != null && allclasses == null ) { java . lang . Class [ ] realDE = realclass . getClasses ( ) ; allclasses = new Class [ realDE . length ] ; for ( int i = 0 ; i < realDE . length ; ++ i ) { allclasses [ i ] = forClass ( realDE [ i ] ) ; } } return allclasses ; } public ClassLoader getClassLoader ( ) { return ( realclass == null ) ? null : realclass . getClassLoader ( ) ; } public Class getComponentType ( ) { return realclass == null ? null : new Class ( realclass . getComponentType ( ) ) ; } public Constructor getConstructor ( Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException , SynthesisException { if ( realclass == null ) throw new SynthesisException ( SynthesisException . UNREIFIED ) ; java . lang . Class [ ] real = new java . lang . Class [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; ++ i ) { if ( ( real [ i ] = parameterTypes [ i ] . getRealClass ( ) ) == null ) throw new SynthesisException ( SynthesisException . UNREIFIED ) ; } return new Constructor ( realclass . getConstructor ( real ) , this ) ; } public Constructor [ ] getConstructors ( ) throws SecurityException { if ( realclass != null && allconstructors == null ) { java . lang . reflect . Constructor [ ] realDC = realclass . getConstructors ( ) ; allconstructors = new Constructor [ realDC . length ] ; for ( int i = 0 ; i < realDC . length ; ++ i ) { allconstructors [ i ] = new Constructor ( realDC [ i ] , this ) ; } } return allconstructors ; } public Class [ ] getDeclaredClasses ( ) throws SecurityException { if ( realclass != null && declaredclasses == null ) { java . lang . Class [ ] realDE = realclass . getDeclaredClasses ( ) ; declaredclasses = new Class [ realDE . length ] ; for ( int i = 0 ; i < realDE . length ; ++ i ) { declaredclasses [ i ] = forClass ( realDE [ i ] ) ; if ( ! realDE [ i ] . isInterface ( ) ) superclass = declaredclasses [ i ] ; } } return declaredclasses ; } public void addExtends ( Class newclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Class [ ] scratch = new Class [ declaredclasses . length + 1 ] ; System . arraycopy ( declaredclasses , 0 , scratch , 0 , declaredclasses . length ) ; scratch [ declaredclasses . length ] = newclass ; declaredclasses = scratch ; } public Constructor getDeclaredConstructor ( Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Constructor declareConstructor ( ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Constructor newctor = new Constructor ( this ) ; Constructor [ ] scratch = new Constructor [ declaredconstructors . length + 1 ] ; System . arraycopy ( declaredconstructors , 0 , scratch , 0 , declaredconstructors . length ) ; scratch [ declaredconstructors . length ] = newctor ; declaredconstructors = scratch ; scratch = new Constructor [ allconstructors . length + 1 ] ; System . arraycopy ( allconstructors , 0 , scratch , 0 , allconstructors . length ) ; scratch [ allconstructors . length ] = newctor ; allconstructors = scratch ; return newctor ; } public Class declareInterface ( Class newifce ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; if ( ! newifce . isInterface ( ) ) throw new SynthesisException ( SynthesisException . SYNTAX , newifce . getName ( ) + " isn't an interface" ) ; Class [ ] scratch = new Class [ interfaces . length + 1 ] ; System . arraycopy ( interfaces , 0 , scratch , 0 , interfaces . length ) ; scratch [ interfaces . length ] = newifce ; interfaces = scratch ; scratch = new Class [ allclasses . length + 1 ] ; System . arraycopy ( allclasses , 0 , scratch , 0 , allclasses . length ) ; scratch [ allclasses . length ] = newifce ; allclasses = scratch ; return newifce ; } public Constructor [ ] getDeclaredConstructors ( ) throws SecurityException { if ( realclass != null && declaredconstructors == null ) { java . lang . reflect . Constructor [ ] realDC = realclass . getDeclaredConstructors ( ) ; declaredconstructors = new Constructor [ realDC . length ] ; for ( int i = 0 ; i < realDC . length ; ++ i ) { declaredconstructors [ i ] = new Constructor ( realDC [ i ] , this ) ; } } return declaredconstructors ; } public Field getDeclaredField ( String name ) throws NoSuchFieldException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Field declareField ( String name ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Field newfield = new Field ( name , this ) ; Field [ ] scratch = new Field [ declaredfields . length + 1 ] ; System . arraycopy ( declaredfields , 0 , scratch , 0 , declaredfields . length ) ; scratch [ declaredfields . length ] = newfield ; declaredfields = scratch ; scratch = new Field [ allfields . length + 1 ] ; System . arraycopy ( allfields , 0 , scratch , 0 , allfields . length ) ; scratch [ allfields . length ] = newfield ; allfields = scratch ; return newfield ; } public Field [ ] getDeclaredFields ( ) throws SecurityException { if ( realclass != null && declaredfields == null ) { java . lang . reflect . Field [ ] realDF = realclass . getDeclaredFields ( ) ; declaredfields = new Field [ realDF . length ] ; for ( int i = 0 ; i < realDF . length ; ++ i ) { declaredfields [ i ] = new Field ( realDF [ i ] , this ) ; } } return declaredfields ; } public Method getDeclaredMethod ( String name , Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Method declareMethod ( String name ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Method newMethod = new Method ( name , this ) ; Method [ ] scratch = new Method [ declaredmethods . length + 1 ] ; System . arraycopy ( declaredmethods , 0 , scratch , 0 , declaredmethods . length ) ; scratch [ declaredmethods . length ] = newMethod ; declaredmethods = scratch ; scratch = new Method [ allmethods . length + 1 ] ; System . arraycopy ( allmethods , 0 , scratch , 0 , allmethods . length ) ; scratch [ allmethods . length ] = newMethod ; allmethods = scratch ; return newMethod ; } public Method [ ] getDeclaredMethods ( ) throws SecurityException { if ( realclass != null && declaredmethods == null ) { java . lang . reflect . Method [ ] realDM = realclass . getDeclaredMethods ( ) ; declaredmethods = new Method [ realDM . length ] ; for ( int i = 0 ; i < realDM . length ; ++ i ) { declaredmethods [ i ] = new Method ( realDM [ i ] , this ) ; } } return declaredmethods ; } public Class getDeclaringClass ( ) { if ( realclass != null && declaringclass == null ) { java . lang . Class dc = realclass . getDeclaringClass ( ) ; if ( dc == null ) declaringclass = null ; else declaringclass = forClass ( dc ) ; } return declaringclass ; } private void addInnerClass ( Class newclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; if ( newclass . getDeclaringClass ( ) != this ) throw new SynthesisException ( SynthesisException . WRONG_OWNER ) ; Class [ ] scratch = new Class [ innerclasses . length + 1 ] ; System . arraycopy ( innerclasses , 0 , scratch , 0 , innerclasses . length ) ; scratch [ innerclasses . length ] = newclass ; innerclasses = scratch ; } public Class declareInnerClass ( String className ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; String relativeName = getName ( ) + "$" + className ; Class newclass = ( Class ) ( global_classtable . get ( relativeName ) ) ; if ( newclass != null ) throw new SynthesisException ( SynthesisException . SYNTAX , "Inner class " + name + " already exists" ) ; newclass = new Class ( className ) ; newclass . declaringclass = this ; Class [ ] scratch = new Class [ innerclasses . length + 1 ] ; System . arraycopy ( innerclasses , 0 , scratch , 0 , innerclasses . length ) ; scratch [ innerclasses . length ] = newclass ; innerclasses = scratch ; return newclass ; } public Class [ ] getInnerClasses ( ) { return innerclasses ; } public Field getField ( String name ) throws NoSuchFieldException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Field [ ] getFields ( ) throws SecurityException { if ( realclass != null && allfields == null ) { java . lang . reflect . Field [ ] realDF = realclass . getFields ( ) ; allfields = new Field [ realDF . length ] ; for ( int i = 0 ; i < realDF . length ; ++ i ) { allfields [ i ] = new Field ( realDF [ i ] , this ) ; } } return allfields ; } public Class [ ] getInterfaces ( ) { if ( realclass != null && interfaces == null ) { java . lang . Class [ ] realI = realclass . getInterfaces ( ) ; interfaces = new Class [ realI . length ] ; for ( int i = 0 ; i < realI . length ; ++ i ) { interfaces [ i ] = forClass ( realI [ i ] ) ; } } return interfaces ; } public void addImplements ( Class newclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Class [ ] scratch = new Class [ interfaces . length + 1 ] ; System . arraycopy ( interfaces , 0 , scratch , 0 , interfaces . length ) ; scratch [ interfaces . length ] = newclass ; interfaces = scratch ; } public Method getMethod ( String name , Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Method [ ] getMethods ( ) throws SecurityException { if ( realclass != null && allmethods == null ) { java . lang . reflect . Method [ ] realDM = realclass . getMethods ( ) ; allmethods = new Method [ realDM . length ] ; for ( int i = 0 ; i < realDM . length ; ++ i ) { allmethods [ i ] = new Method ( realDM [ i ] , this ) ; } } return allmethods ; } public int getModifiers ( ) { return modifiers ; } public void setModifiers ( int modifiers ) throws SynthesisException { if ( this . realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . modifiers = modifiers ; } public java . lang . String getName ( ) { return name ; } public java . lang . String getJavaName ( ) { if ( name . charAt ( 0 ) != '[' ) return name ; int count = name . lastIndexOf ( '[' ) ; StringBuffer jname = new StringBuffer ( name . substring ( count + 2 ) ) ; jname . setLength ( jname . length ( ) - 1 ) ; while ( count -- >= 0 ) { jname . append ( "[]" ) ; } return jname . toString ( ) ; } public java . lang . String getShortName ( ) { int start = name . lastIndexOf ( "." ) ; if ( start != 0 || name . charAt ( 0 ) == '.' ) ++ start ; if ( declaringclass != null ) { int d = name . lastIndexOf ( '$' , start ) ; if ( d != 0 ) start = d + 1 ; } return name . substring ( start ) ; } public java . lang . String getJavaShortName ( ) { String shortname = getShortName ( ) ; if ( shortname . charAt ( 0 ) != '[' ) return shortname ; int count = shortname . lastIndexOf ( '[' ) ; StringBuffer jname = new StringBuffer ( shortname . substring ( count + 2 ) ) ; jname . setLength ( jname . length ( ) - 1 ) ; while ( count -- >= 0 ) { jname . append ( "[]" ) ; } return jname . toString ( ) ; } public java . lang . String getPackageName ( ) { int start = name . lastIndexOf ( "." ) ; return name . substring ( 0 , start ) ; } public java . lang . Class getRealClass ( ) { return realclass ; } public void setRealClass ( java . lang . Class realclass ) throws SynthesisException { if ( this . realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . realclass = realclass ; this . modifiers = realclass . getModifiers ( ) ; this . isInterface = realclass . isInterface ( ) ; this . declaringclass = null ; this . interfaces = null ; this . declaredconstructors = null ; this . allconstructors = null ; this . declaredmethods = null ; this . allmethods = null ; this . declaredfields = null ; this . allfields = null ; this . declaredclasses = null ; this . allclasses = null ; this . superclass = null ; } public void setSuperClass ( Class superclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . superclass = superclass ; } public void setSuperClass ( java . lang . Class superclass ) throws ClassNotFoundException , SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . superclass = Class . forClass ( superclass ) ; } public java . net . URL getResource ( String name ) { throw new java . lang . IllegalStateException ( ) ; } public java . io . InputStream getResourceAsStream ( String name ) { throw new java . lang . IllegalStateException ( ) ; } public Object [ ] getSigners ( ) { throw new java . lang . IllegalStateException ( ) ; } public Class getSuperclass ( ) { if ( realclass != null && superclass == null ) { superclass = forClass ( realclass . getSuperclass ( ) ) ; } if ( superclass == null ) superclass = forClass ( Object . class ) ; return superclass ; } public boolean isArray ( ) { return realclass != null && realclass . isArray ( ) ; } public boolean isAssignableFrom ( Class cls ) { if ( realclass != null && cls . realclass != null ) return realclass . isAssignableFrom ( cls . realclass ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean isAssignableFrom ( java . lang . Class cls ) { if ( realclass != null ) return realclass . isAssignableFrom ( ( java . lang . Class ) cls ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean isInstance ( Object obj ) { if ( realclass != null ) return realclass . isInstance ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean isInterface ( ) { return ( realclass != null ) ? realclass . isInterface ( ) : isInterface ; } public void isInterface ( boolean isInterface ) throws SynthesisException { if ( realclass == null ) this . isInterface = isInterface ; else if ( realclass . isInterface ( ) != isInterface ) throw new SynthesisException ( SynthesisException . REIFIED ) ; } public boolean isPrimitive ( ) { return realclass != null && realclass . isPrimitive ( ) ; } public Object newInstance ( ) throws InstantiationException , IllegalAccessException { throw new java . lang . IllegalStateException ( ) ; } public String toString ( ) { if ( realclass != null ) return realclass . toString ( ) ; else if ( isInterface ( ) ) return "interface " + name ; else return "class " + name ; } public void toSource ( java . io . OutputStream out , int depth ) { java . io . PrintWriter writer = new java . io . PrintWriter ( out ) ; toSource ( writer , depth ) ; } public void toSource ( java . io . PrintWriter out , int depth ) { String tab = tabset ( depth ) ; if ( realclass != null ) out . println ( tab + "/** Code back-generated from a \"real\" Class; accuracy limited by reflection APIs. */" ) ; else out . println ( tab + "/** Code generated via org.apache.xml.utils.synthetic.Class */" ) ; if ( getDeclaringClass ( ) == null ) out . println ( tab + "package " + getPackageName ( ) + ";" ) ; out . print ( tab + Modifier . toString ( getModifiers ( ) ) ) ; if ( isInterface ( ) ) out . print ( " interface " ) ; else out . print ( " class " ) ; out . println ( getJavaShortName ( ) ) ; if ( superclass != null ) { out . print ( '\n' + tab + " extends " + superclass . getJavaName ( ) ) ; } Class [ ] ext = getInterfaces ( ) ; if ( ext != null & ext . length > 0 ) { out . print ( '\n' + tab + ( isInterface ? " extends " : " implements " ) + ext [ 0 ] . getName ( ) ) ; for ( int i = 1 ; i < ext . length ; ++ i ) { out . print ( ", " + ext [ i ] . getJavaName ( ) ) ; } out . print ( "\n" ) ; } out . print ( tab + "{\n" ) ; tab = tabset ( ++ depth ) ; Field [ ] fields = null ; try { fields = getDeclaredFields ( ) ; } catch ( SecurityException e ) { out . println ( tab + "//SecurityException retrieving fields" ) ; } if ( fields != null ) { for ( int i = 0 ; i < fields . length ; ++ i ) { out . println ( tab + fields [ i ] . toSource ( ) ) ; } } Constructor [ ] ctors = null ; try { ctors = getDeclaredConstructors ( ) ; } catch ( SecurityException e ) { out . println ( tab + "//SecurityException retrieving ctors" ) ; } if ( ctors != null ) { for ( int i = 0 ; i < ctors . length ; ++ i ) { out . print ( ctors [ i ] . toSource ( tab ) ) ; } } Method [ ] methods = null ; try { methods = getDeclaredMethods ( ) ; } catch ( SecurityException e ) { out . println ( tab + "//SecurityException retrieving methods" ) ; } if ( methods != null ) { for ( int i = 0 ; i < methods . length ; ++ i ) { out . print ( '\n' ) ; out . print ( methods [ i ] . toSource ( tab ) ) ; } } Class [ ] inners = getInnerClasses ( ) ; if ( inners != null ) { for ( int i = 0 ; i < inners . length ; ++ i ) { out . print ( '\n' ) ; inners [ i ] . toSource ( out , depth ) ; } } tab = tabset ( -- depth ) ; out . print ( tab + "}\n" ) ; out . flush ( ) ; } private String tabset ( int depth ) { StringBuffer t = new StringBuffer ( ) ; while ( depth -- > 0 ) { t . append ( "    " ) ; } return t . toString ( ) ; } static final int [ ] val = { Modifier . ABSTRACT , Modifier . FINAL , Modifier . INTERFACE , Modifier . NATIVE , Modifier . PRIVATE , Modifier . PROTECTED , Modifier . PUBLIC , Modifier . STATIC , Modifier . SYNCHRONIZED , Modifier . TRANSIENT , Modifier . VOLATILE } ; static final String [ ] kwd = { "abstract" , "final" , "interface" , "native" , "private" , "protected" , "public" , "static" , "synchronized" , "transient" , "volatile" } ; static public int modifierFromString ( String t ) { for ( int i = 0 ; i < kwd . length ; ++ i ) { if ( kwd [ i ] . equals ( t ) ) return val [ i ] ; } return 0 ; } static public int modifiersFromString ( String s ) { int mods = 0 ; java . util . StringTokenizer parts = new java . util . StringTokenizer ( s ) ; while ( parts . hasMoreTokens ( ) ) { String t = parts . nextToken ( ) ; mods |= modifierFromString ( t ) ; } return mods ; } } 	1	['65', '1', '0', '7', '135', '508', '6', '4', '59', '0.7375', '2297', '0.85', '12', '0', '0.1515625', '0', '0', '34.03076923', '18', '1.8462', '1']
package org . apache . xalan . processor ; import javax . xml . transform . SourceLocator ; import org . apache . xalan . templates . ElemApplyImport ; import org . apache . xalan . templates . ElemApplyTemplates ; import org . apache . xalan . templates . ElemAttribute ; import org . apache . xalan . templates . ElemCallTemplate ; import org . apache . xalan . templates . ElemComment ; import org . apache . xalan . templates . ElemCopy ; import org . apache . xalan . templates . ElemCopyOf ; import org . apache . xalan . templates . ElemElement ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemFallback ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xalan . templates . ElemPI ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemText ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xalan . templates . ElemValueOf ; import org . apache . xalan . templates . ElemVariable ; import org . apache . xalan . templates . Stylesheet ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ProcessorExsltFunction extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws SAXException { String msg = "" ; if ( ! ( handler . getElemTemplateElement ( ) instanceof Stylesheet ) ) { msg = "func:function element must be top level." ; handler . error ( msg , new SAXException ( msg ) ) ; } super . startElement ( handler , uri , localName , rawName , attributes ) ; String val = attributes . getValue ( "name" ) ; int indexOfColon = val . indexOf ( ":" ) ; if ( indexOfColon > 0 ) { String prefix = val . substring ( 0 , indexOfColon ) ; String localVal = val . substring ( indexOfColon + 1 ) ; String ns = handler . getNamespaceSupport ( ) . getURI ( prefix ) ; } else { msg = "func:function name must have namespace" ; handler . error ( msg , new SAXException ( msg ) ) ; } } protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws SAXException { super . appendAndPush ( handler , elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; handler . getStylesheet ( ) . setTemplate ( ( ElemTemplate ) elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws SAXException { ElemTemplateElement function = handler . getElemTemplateElement ( ) ; SourceLocator locator = handler . getLocator ( ) ; validate ( function , handler ) ; super . endElement ( handler , uri , localName , rawName ) ; } public void validate ( ElemTemplateElement elem , StylesheetHandler handler ) throws SAXException { String msg = "" ; while ( elem != null ) { if ( elem instanceof ElemExsltFuncResult && elem . getNextSiblingElem ( ) != null && ! ( elem . getNextSiblingElem ( ) instanceof ElemFallback ) ) { msg = "func:result has an illegal following sibling (only xsl:fallback allowed)" ; handler . error ( msg , new SAXException ( msg ) ) ; } if ( ( elem instanceof ElemApplyImport || elem instanceof ElemApplyTemplates || elem instanceof ElemAttribute || elem instanceof ElemCallTemplate || elem instanceof ElemComment || elem instanceof ElemCopy || elem instanceof ElemCopyOf || elem instanceof ElemElement || elem instanceof ElemLiteralResult || elem instanceof ElemNumber || elem instanceof ElemPI || elem instanceof ElemText || elem instanceof ElemTextLiteral || elem instanceof ElemValueOf ) && ! ( ancestorIsOk ( elem ) ) ) { msg = "misplaced literal result in a func:function container." ; handler . error ( msg , new SAXException ( msg ) ) ; } ElemTemplateElement nextElem = elem . getFirstChildElem ( ) ; while ( nextElem == null ) { nextElem = elem . getNextSiblingElem ( ) ; if ( nextElem == null ) elem = elem . getParentElem ( ) ; if ( elem == null || elem instanceof ElemExsltFunction ) return ; } elem = nextElem ; } } boolean ancestorIsOk ( ElemTemplateElement child ) { while ( child . getParentElem ( ) != null && ! ( child . getParentElem ( ) instanceof ElemExsltFunction ) ) { ElemTemplateElement parent = child . getParentElem ( ) ; if ( parent instanceof ElemExsltFuncResult || parent instanceof ElemVariable || parent instanceof ElemParam ) return true ; child = parent ; } return false ; } } 	1	['6', '5', '0', '26', '27', '15', '1', '25', '4', '2', '226', '0', '0', '0.97706422', '0.533333333', '2', '4', '36.66666667', '6', '1.6667', '2']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemChoose extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_CHOOSE ; } public String getNodeName ( ) { return Constants . ELEMNAME_CHOOSE_STRING ; } public ElemChoose ( ) { } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; boolean found = false ; for ( ElemTemplateElement childElem = getFirstChildElem ( ) ; childElem != null ; childElem = childElem . getNextSiblingElem ( ) ) { int type = childElem . getXSLToken ( ) ; if ( Constants . ELEMNAME_WHEN == type ) { found = true ; ElemWhen when = ( ElemWhen ) childElem ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; if ( TransformerImpl . S_DEBUG ) { XObject test = when . getTest ( ) . execute ( xctxt , sourceNode , when ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , when , "test" , when . getTest ( ) , test ) ; if ( test . bool ( ) ) { transformer . getTraceManager ( ) . fireTraceEvent ( when ) ; transformer . executeChildTemplates ( when , true ) ; transformer . getTraceManager ( ) . fireTraceEndEvent ( when ) ; return ; } } else if ( when . getTest ( ) . bool ( xctxt , sourceNode , when ) ) { transformer . executeChildTemplates ( when , true ) ; return ; } } else if ( Constants . ELEMNAME_OTHERWISE == type ) { found = true ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( childElem ) ; transformer . executeChildTemplates ( childElem , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( childElem ) ; return ; } } if ( ! found ) transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_CHOOSE_REQUIRES_WHEN ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_WHEN : case Constants . ELEMNAME_OTHERWISE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } public boolean canAcceptVariables ( ) { return false ; } } 	1	['6', '3', '0', '9', '26', '15', '0', '9', '6', '2', '160', '0', '0', '0.975124378', '0.444444444', '2', '6', '25.66666667', '4', '1.3333', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; final class ParameterRef extends VariableRefBase { public ParameterRef ( Param param ) { super ( param ) ; } public String toString ( ) { return "parameter-ref(" + _variable . getName ( ) + '/' + _variable . getType ( ) + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String name = _variable . getVariable ( ) ; final String signature = _type . toSignature ( ) ; if ( _variable . isLocal ( ) ) { if ( classGen . isExternal ( ) ) { Closure variableClosure = _closure ; while ( variableClosure != null ) { if ( variableClosure . inInnerClass ( ) ) break ; variableClosure = variableClosure . getParentClosure ( ) ; } if ( variableClosure != null ) { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( variableClosure . getInnerClassName ( ) , name , signature ) ) ) ; } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { final String className = classGen . getClassName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new GETFIELD ( cpg . addFieldref ( className , name , signature ) ) ) ; } if ( _variable . getType ( ) instanceof NodeSetType ) { final int clone = cpg . addInterfaceMethodref ( NODE_ITERATOR , "cloneIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( clone , 1 ) ) ; } } } 	1	['3', '4', '0', '18', '31', '1', '1', '17', '3', '2', '152', '0', '0', '0.974358974', '0.5', '2', '3', '49.66666667', '8', '3', '2']
package org . apache . xml . utils ; import org . w3c . dom . Attr ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; public class AttList implements Attributes { NamedNodeMap m_attrs ; int m_lastIndex ; DOMHelper m_dh ; public AttList ( NamedNodeMap attrs , DOMHelper dh ) { m_attrs = attrs ; m_lastIndex = m_attrs . getLength ( ) - 1 ; m_dh = dh ; } public int getLength ( ) { return m_attrs . getLength ( ) ; } public String getURI ( int index ) { String ns = m_dh . getNamespaceOfNode ( ( ( Attr ) m_attrs . item ( index ) ) ) ; if ( null == ns ) ns = "" ; return ns ; } public String getLocalName ( int index ) { return m_dh . getLocalNameOfNode ( ( ( Attr ) m_attrs . item ( index ) ) ) ; } public String getQName ( int i ) { return ( ( Attr ) m_attrs . item ( i ) ) . getName ( ) ; } public String getType ( int i ) { return "CDATA" ; } public String getValue ( int i ) { return ( ( Attr ) m_attrs . item ( i ) ) . getValue ( ) ; } public String getType ( String name ) { return "CDATA" ; } public String getType ( String uri , String localName ) { return "CDATA" ; } public String getValue ( String name ) { Attr attr = ( ( Attr ) m_attrs . getNamedItem ( name ) ) ; return ( null != attr ) ? attr . getValue ( ) : null ; } public String getValue ( String uri , String localName ) { Node a = m_attrs . getNamedItemNS ( uri , localName ) ; return ( a == null ) ? null : a . getNodeValue ( ) ; } public int getIndex ( String uri , String localPart ) { for ( int i = m_attrs . getLength ( ) - 1 ; i >= 0 ; -- i ) { Node a = m_attrs . item ( i ) ; String u = a . getNamespaceURI ( ) ; if ( ( u == null ? uri == null : u . equals ( uri ) ) && a . getLocalName ( ) . equals ( localPart ) ) return i ; } return - 1 ; } public int getIndex ( String qName ) { for ( int i = m_attrs . getLength ( ) - 1 ; i >= 0 ; -- i ) { Node a = m_attrs . item ( i ) ; if ( a . getNodeName ( ) . equals ( qName ) ) return i ; } return - 1 ; } } 	1	['13', '1', '0', '2', '27', '0', '1', '1', '13', '0.694444444', '168', '0', '1', '0', '0.4', '0', '0', '11.69230769', '6', '1.6923', '1']
package org . apache . xml . serializer ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; public class NamespaceMappings { private int count = 0 ; private java . util . Stack m_prefixStack ; private Hashtable m_namespaces ; private Stack m_nodeStack ; private static final String EMPTYSTRING = "" ; private static final String XML_PREFIX = "xml" ; public NamespaceMappings ( ) { initNamespaces ( ) ; } private void initNamespaces ( ) { m_namespaces = new Hashtable ( ) ; m_nodeStack = new Stack ( ) ; m_prefixStack = new Stack ( ) ; Stack stack ; m_namespaces . put ( EMPTYSTRING , stack = new Stack ( ) ) ; stack . push ( EMPTYSTRING ) ; m_prefixStack . push ( EMPTYSTRING ) ; m_namespaces . put ( XML_PREFIX , stack = new Stack ( ) ) ; stack . push ( "http://www.w3.org/XML/1998/namespace" ) ; m_prefixStack . push ( XML_PREFIX ) ; m_nodeStack . push ( new Integer ( - 1 ) ) ; } public String lookupNamespace ( String prefix ) { final Stack stack = ( Stack ) m_namespaces . get ( prefix ) ; return stack != null && ! stack . isEmpty ( ) ? ( String ) stack . peek ( ) : null ; } public String lookupPrefix ( String uri ) { String foundPrefix = null ; Enumeration prefixes = m_namespaces . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; String uri2 = lookupNamespace ( prefix ) ; if ( uri2 != null && uri2 . equals ( uri ) ) { foundPrefix = prefix ; break ; } } return foundPrefix ; } public boolean popNamespace ( String prefix ) { if ( prefix . startsWith ( XML_PREFIX ) ) { return false ; } Stack stack ; if ( ( stack = ( Stack ) m_namespaces . get ( prefix ) ) != null ) { stack . pop ( ) ; return true ; } return false ; } public boolean pushNamespace ( String prefix , String uri , int elemDepth ) { if ( prefix . startsWith ( XML_PREFIX ) ) { return false ; } Stack stack ; if ( ( stack = ( Stack ) m_namespaces . get ( prefix ) ) == null ) { m_namespaces . put ( prefix , stack = new Stack ( ) ) ; } if ( ! stack . empty ( ) && uri . equals ( stack . peek ( ) ) ) { return false ; } stack . push ( uri ) ; m_prefixStack . push ( prefix ) ; m_nodeStack . push ( new Integer ( elemDepth ) ) ; return true ; } public void popNamespaces ( int elemDepth ) { while ( true ) { if ( m_nodeStack . isEmpty ( ) ) return ; Integer i = ( Integer ) ( m_nodeStack . peek ( ) ) ; if ( i . intValue ( ) < elemDepth ) return ; m_nodeStack . pop ( ) ; popNamespace ( ( String ) m_prefixStack . pop ( ) ) ; } } public String generateNextPrefix ( ) { return "ns" + ( count ++ ) ; } public Object clone ( ) throws CloneNotSupportedException { NamespaceMappings clone = new NamespaceMappings ( ) ; clone . m_prefixStack = ( Stack ) m_prefixStack . clone ( ) ; clone . m_nodeStack = ( Stack ) m_nodeStack . clone ( ) ; clone . m_namespaces = ( Hashtable ) m_namespaces . clone ( ) ; clone . count = count ; return clone ; } } 	1	['9', '1', '0', '12', '32', '0', '12', '0', '8', '0.6875', '276', '1', '0', '0', '0.555555556', '0', '0', '29', '5', '2.1111', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class XslElement extends Instruction { private String _prefix ; private boolean _ignore = false ; private boolean _isLiteralName = true ; private AttributeValueTemplate _name ; private AttributeValueTemplate _namespace ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "Element " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public boolean declaresDefaultNS ( ) { return false ; } private boolean isLiteral ( String str ) { final int length = str . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( str . charAt ( i ) == '{' && str . charAt ( i + 1 ) != '{' ) { return false ; } } return true ; } private boolean isLegalName ( String str ) { if ( str . indexOf ( ' ' ) > - 1 ) { return false ; } final int colon = str . indexOf ( ':' ) ; if ( colon == 0 || colon == str . length ( ) - 1 ) { return false ; } final char first = str . charAt ( 0 ) ; if ( ! Character . isLetter ( first ) && first != '_' ) { return false ; } return true ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; String name = getAttribute ( "name" ) ; if ( name == EMPTYSTRING ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ELEM_NAME_ERR , name , this ) ; parser . reportError ( WARNING , msg ) ; parseChildren ( parser ) ; _ignore = true ; return ; } String namespace = getAttribute ( "namespace" ) ; _isLiteralName = isLiteral ( name ) ; if ( _isLiteralName ) { if ( ! isLegalName ( name ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ELEM_NAME_ERR , name , this ) ; parser . reportError ( WARNING , msg ) ; parseChildren ( parser ) ; _ignore = true ; return ; } final QName qname = parser . getQNameSafe ( name ) ; String prefix = qname . getPrefix ( ) ; String local = qname . getLocalPart ( ) ; if ( prefix == null ) { prefix = EMPTYSTRING ; } if ( ! hasAttribute ( "namespace" ) ) { namespace = lookupNamespace ( prefix ) ; if ( namespace == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NAMESPACE_UNDEF_ERR , prefix , this ) ; parser . reportError ( WARNING , err ) ; parseChildren ( parser ) ; _ignore = true ; return ; } _prefix = prefix ; _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } else { if ( prefix == EMPTYSTRING ) { if ( isLiteral ( namespace ) ) { prefix = lookupPrefix ( namespace ) ; if ( prefix == null ) { prefix = stable . generateNamespacePrefix ( ) ; } } final StringBuffer newName = new StringBuffer ( prefix ) ; if ( prefix != EMPTYSTRING ) { newName . append ( ':' ) ; } name = newName . append ( local ) . toString ( ) ; } _prefix = prefix ; _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } } else { _namespace = ( namespace == EMPTYSTRING ) ? null : new AttributeValueTemplate ( namespace , parser , this ) ; } _name = new AttributeValueTemplate ( name , parser , this ) ; final String useSets = getAttribute ( "use-attribute-sets" ) ; if ( useSets . length ( ) > 0 ) { setFirstElement ( new UseAttributeSets ( useSets , parser ) ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( ! _ignore ) { _name . typeCheck ( stable ) ; if ( _namespace != null ) { _namespace . typeCheck ( stable ) ; } } typeCheckContents ( stable ) ; return Type . Void ; } public void translateLiteral ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( ! _ignore ) { il . append ( methodGen . loadHandler ( ) ) ; _name . translate ( classGen , methodGen ) ; il . append ( DUP2 ) ; il . append ( methodGen . startElement ( ) ) ; if ( _namespace != null ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _prefix ) ) ; _namespace . translate ( classGen , methodGen ) ; il . append ( methodGen . namespace ( ) ) ; } } translateContents ( classGen , methodGen ) ; if ( ! _ignore ) { il . append ( methodGen . endElement ( ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { LocalVariableGen local = null ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _isLiteralName ) { translateLiteral ( classGen , methodGen ) ; return ; } if ( ! _ignore ) { il . append ( methodGen . loadHandler ( ) ) ; _name . translate ( classGen , methodGen ) ; if ( _namespace != null ) { _namespace . translate ( classGen , methodGen ) ; } else { il . append ( ACONST_NULL ) ; } il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "startXslElement" , "(" + STRING_SIG + STRING_SIG + TRANSLET_OUTPUT_SIG + DOM_INTF_SIG + "I)" + STRING_SIG ) ) ) ; } translateContents ( classGen , methodGen ) ; if ( ! _ignore ) { il . append ( methodGen . endElement ( ) ) ; } } public void translateContents ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) getContents ( ) . elementAt ( i ) ; if ( _ignore && item instanceof XslAttribute ) continue ; item . translate ( classGen , methodGen ) ; } } } 	1	['10', '3', '0', '23', '59', '7', '1', '22', '7', '0.644444444', '505', '1', '2', '0.861538462', '0.3', '1', '9', '49', '13', '3.9', '1']
package org . apache . xml . utils . res ; public class XResources_it extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "it" } , { "help_language" , "it" } , { "language" , "it" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xml . utils . res ; public class XResources_ko extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ko" } , { "help_language" , "ko" } , { "language" , "ko" } , { "alphabet" , new char [ ] { 0x3131 , 0x3134 , 0x3137 , 0x3139 , 0x3141 , 0x3142 , 0x3145 , 0x3147 , 0x3148 , 0x314a , 0x314b , 0x314c , 0x314d , 0x314e , 0x314f , 0x3151 , 0x3153 , 0x3155 , 0x3157 , 0x315b , 0x315c , 0x3160 , 0x3161 , 0x3163 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "zero" , new char [ 0 ] } , { "multiplier" , new int [ ] { 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0xc5b5 , 0xb9cc , 0xcc9c , 0xbc31 , 0xc2ed } } , { "digits" , new char [ ] { 0xc77c , 0xc774 , 0xc0bc , 0xc0ac , 0xc624 , 0xc721 , 0xce60 , 0xd314 , 0xad6c } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '487', '0', '0', '0.976190476', '1', '0', '0', '161', '1', '0.3333', '1']
package org . apache . xml . utils ; public class StringVector implements java . io . Serializable { protected int m_blocksize ; protected String m_map [ ] ; protected int m_firstFree = 0 ; protected int m_mapSize ; public StringVector ( ) { m_blocksize = 8 ; m_mapSize = m_blocksize ; m_map = new String [ m_blocksize ] ; } public StringVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new String [ blocksize ] ; } public int getLength ( ) { return m_firstFree ; } public final int size ( ) { return m_firstFree ; } public final void addElement ( String value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final String elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( String s ) { if ( null == s ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( s ) ) return true ; } return false ; } public final boolean containsIgnoreCase ( String s ) { if ( null == s ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equalsIgnoreCase ( s ) ) return true ; } return false ; } public final void push ( String s ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = s ; m_firstFree ++ ; } public final String pop ( ) { if ( m_firstFree <= 0 ) return null ; m_firstFree -- ; String s = m_map [ m_firstFree ] ; m_map [ m_firstFree ] = null ; return s ; } public final String peek ( ) { return ( m_firstFree <= 0 ) ? null : m_map [ m_firstFree - 1 ] ; } } 	1	['11', '1', '0', '8', '15', '0', '8', '0', '11', '0.425', '234', '1', '0', '0', '0.515151515', '0', '0', '19.90909091', '4', '1.7273', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMDefaultBase ; public final class DupFilterIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private IntegerArray _nodes = new IntegerArray ( ) ; private int _current = 0 ; private int _nodesSize = 0 ; private int _lastNext = END ; public DupFilterIterator ( DTMAxisIterator source ) { _source = source ; if ( source instanceof KeyIndex ) { setStartNode ( DTMDefaultBase . ROOTNODE ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( _source instanceof KeyIndex && _startNode == DTMDefaultBase . ROOTNODE ) { return this ; } if ( node != _startNode ) { _source . setStartNode ( _startNode = node ) ; _nodes . clear ( ) ; while ( ( node = _source . next ( ) ) != END ) { _nodes . add ( node ) ; } _nodes . sort ( ) ; _nodesSize = _nodes . cardinality ( ) ; _current = 0 ; _lastNext = END ; resetPosition ( ) ; } } return this ; } public int next ( ) { while ( _current < _nodesSize ) { final int next = _nodes . at ( _current ++ ) ; if ( next != _lastNext ) { return returnNode ( _lastNext = next ) ; } } return END ; } public DTMAxisIterator cloneIterator ( ) { try { final DupFilterIterator clone = ( DupFilterIterator ) super . clone ( ) ; clone . _nodes = ( IntegerArray ) _nodes . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public void setMark ( ) { _markedNode = _current ; } public void gotoMark ( ) { _current = _markedNode ; } public DTMAxisIterator reset ( ) { _current = 0 ; _lastNext = END ; return resetPosition ( ) ; } } 	1	['8', '2', '0', '6', '25', '0', '1', '5', '8', '0.485714286', '183', '1', '2', '0.65', '0.34375', '1', '5', '21.25', '6', '1.625', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncQname extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = getArg0AsNode ( xctxt ) ; XObject val ; if ( DTM . NULL != context ) { DTM dtm = xctxt . getDTM ( context ) ; String qname = dtm . getNodeNameX ( context ) ; val = ( null == qname ) ? XString . EMPTYSTRING : new XString ( qname ) ; } else { val = XString . EMPTYSTRING ; } return val ; } } 	1	['2', '5', '0', '5', '7', '1', '0', '5', '2', '2', '35', '0', '0', '0.982142857', '0.75', '2', '7', '16.5', '1', '0.5', '1']
package org . apache . xpath . axes ; import java . util . Vector ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . WrappedRuntimeException ; public class IteratorPool implements java . io . Serializable { private final DTMIterator m_orig ; private final Vector m_freeStack ; public IteratorPool ( DTMIterator original ) { m_orig = original ; m_freeStack = new Vector ( ) ; } public synchronized DTMIterator getInstanceOrThrow ( ) throws CloneNotSupportedException { if ( m_freeStack . isEmpty ( ) ) { return ( DTMIterator ) m_orig . clone ( ) ; } else { DTMIterator result = ( DTMIterator ) m_freeStack . lastElement ( ) ; m_freeStack . setSize ( m_freeStack . size ( ) - 1 ) ; return result ; } } public synchronized DTMIterator getInstance ( ) { if ( m_freeStack . isEmpty ( ) ) { try { return ( DTMIterator ) m_orig . clone ( ) ; } catch ( Exception ex ) { throw new WrappedRuntimeException ( ex ) ; } } else { DTMIterator result = ( DTMIterator ) m_freeStack . lastElement ( ) ; m_freeStack . setSize ( m_freeStack . size ( ) - 1 ) ; return result ; } } public synchronized void freeInstance ( DTMIterator obj ) { m_freeStack . addElement ( obj ) ; } } 	1	['4', '1', '0', '4', '13', '0', '2', '2', '4', '0.166666667', '76', '1', '1', '0', '0.75', '0', '0', '17.5', '2', '1', '1']
package org . apache . xalan . xsltc ; public interface DOMCache { public DOM retrieveDocument ( String uri , int mask , Translet translet ) ; } 	1	['1', '1', '0', '6', '1', '0', '4', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; public class DOM2TO implements XMLReader , Locator { private final static String EMPTYSTRING = "" ; private static final String XMLNS_PREFIX = "xmlns" ; private Node _dom ; private SerializationHandler _handler ; public DOM2TO ( Node root , SerializationHandler handler ) { _dom = root ; _handler = handler ; } public ContentHandler getContentHandler ( ) { return null ; } public void setContentHandler ( ContentHandler handler ) { } public void parse ( InputSource unused ) throws IOException , SAXException { parse ( _dom ) ; } public void parse ( ) throws IOException , SAXException { if ( _dom != null ) { boolean isIncomplete = ( _dom . getNodeType ( ) != org . w3c . dom . Node . DOCUMENT_NODE ) ; if ( isIncomplete ) { _handler . startDocument ( ) ; parse ( _dom ) ; _handler . endDocument ( ) ; } else { parse ( _dom ) ; } } } private void parse ( Node node ) throws IOException , SAXException { if ( node == null ) return ; switch ( node . getNodeType ( ) ) { case Node . ATTRIBUTE_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . ENTITY_NODE : case Node . ENTITY_REFERENCE_NODE : case Node . NOTATION_NODE : break ; case Node . CDATA_SECTION_NODE : _handler . startCDATA ( ) ; _handler . characters ( node . getNodeValue ( ) ) ; _handler . endCDATA ( ) ; break ; case Node . COMMENT_NODE : _handler . comment ( node . getNodeValue ( ) ) ; break ; case Node . DOCUMENT_NODE : _handler . startDocument ( ) ; Node next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _handler . endDocument ( ) ; break ; case Node . DOCUMENT_FRAGMENT_NODE : next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } break ; case Node . ELEMENT_NODE : final String qname = node . getNodeName ( ) ; _handler . startElement ( null , null , qname ) ; String prefix ; final NamedNodeMap map = node . getAttributes ( ) ; final int length = map . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int colon ; final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNodeValue ( ) ; colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( colon + 1 ) : EMPTYSTRING ; _handler . namespaceAfterStartElement ( prefix , uriAttr ) ; } else { final String uriAttr = attr . getNamespaceURI ( ) ; if ( uriAttr != null && ! uriAttr . equals ( EMPTYSTRING ) ) { colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( 0 , colon ) : EMPTYSTRING ; _handler . namespaceAfterStartElement ( prefix , uriAttr ) ; } _handler . addAttribute ( qnameAttr , attr . getNodeValue ( ) ) ; } } final String uri = node . getNamespaceURI ( ) ; if ( uri != null ) { final int colon = qname . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qname . substring ( 0 , colon ) : EMPTYSTRING ; _handler . namespaceAfterStartElement ( prefix , uri ) ; } next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _handler . endElement ( qname ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : _handler . processingInstruction ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; break ; case Node . TEXT_NODE : _handler . characters ( node . getNodeValue ( ) ) ; break ; } } public DTDHandler getDTDHandler ( ) { return null ; } public ErrorHandler getErrorHandler ( ) { return null ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return false ; } public void setFeature ( String name , boolean value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public void parse ( String sysId ) throws IOException , SAXException { throw new IOException ( "This method is not yet implemented." ) ; } public void setDTDHandler ( DTDHandler handler ) throws NullPointerException { } public void setEntityResolver ( EntityResolver resolver ) throws NullPointerException { } public EntityResolver getEntityResolver ( ) { return null ; } public void setErrorHandler ( ErrorHandler handler ) throws NullPointerException { } public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return null ; } public int getColumnNumber ( ) { return 0 ; } public int getLineNumber ( ) { return 0 ; } public String getPublicId ( ) { return null ; } public String getSystemId ( ) { return null ; } private String getNodeTypeFromCode ( short code ) { String retval = null ; switch ( code ) { case Node . ATTRIBUTE_NODE : retval = "ATTRIBUTE_NODE" ; break ; case Node . CDATA_SECTION_NODE : retval = "CDATA_SECTION_NODE" ; break ; case Node . COMMENT_NODE : retval = "COMMENT_NODE" ; break ; case Node . DOCUMENT_FRAGMENT_NODE : retval = "DOCUMENT_FRAGMENT_NODE" ; break ; case Node . DOCUMENT_NODE : retval = "DOCUMENT_NODE" ; break ; case Node . DOCUMENT_TYPE_NODE : retval = "DOCUMENT_TYPE_NODE" ; break ; case Node . ELEMENT_NODE : retval = "ELEMENT_NODE" ; break ; case Node . ENTITY_NODE : retval = "ENTITY_NODE" ; break ; case Node . ENTITY_REFERENCE_NODE : retval = "ENTITY_REFERENCE_NODE" ; break ; case Node . NOTATION_NODE : retval = "NOTATION_NODE" ; break ; case Node . PROCESSING_INSTRUCTION_NODE : retval = "PROCESSING_INSTRUCTION_NODE" ; break ; case Node . TEXT_NODE : retval = "TEXT_NODE" ; break ; } return retval ; } } 	1	['22', '1', '0', '2', '49', '221', '1', '1', '20', '0.964285714', '341', '1', '1', '0', '0.143939394', '0', '0', '14.31818182', '2', '1', '2']
package org . apache . xalan . trace ; public interface TraceListener extends java . util . EventListener { public void trace ( TracerEvent ev ) ; public void selected ( SelectionEvent ev ) throws javax . xml . transform . TransformerException ; public void generated ( GenerateEvent ev ) ; } 	1	['3', '1', '0', '8', '3', '3', '5', '3', '3', '2', '3', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '1']
package org . apache . xml . utils . res ; public class XResources_en extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemCallTemplate extends ElemForEach { public QName m_templateName = null ; public void setName ( QName name ) { m_templateName = name ; } public QName getName ( ) { return m_templateName ; } private ElemTemplate m_template = null ; public int getXSLToken ( ) { return Constants . ELEMNAME_CALLTEMPLATE ; } public String getNodeName ( ) { return Constants . ELEMNAME_CALLTEMPLATE_STRING ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; int length = getParamElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { ElemWithParam ewp = getParamElem ( i ) ; ewp . compose ( sroot ) ; } if ( ( null != m_templateName ) && ( null == m_template ) ) { m_template = this . getStylesheetRoot ( ) . getTemplateComposed ( m_templateName ) ; if ( null == m_template ) return ; length = getParamElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { ElemWithParam ewp = getParamElem ( i ) ; ewp . m_index = - 1 ; int etePos = 0 ; for ( ElemTemplateElement ete = m_template . getFirstChildElem ( ) ; null != ete ; ete = ete . getNextSiblingElem ( ) ) { if ( ete . getXSLToken ( ) == Constants . ELEMNAME_PARAMVARIABLE ) { ElemParam ep = ( ElemParam ) ete ; if ( ep . getName ( ) . equals ( ewp . getName ( ) ) ) { ewp . m_index = etePos ; } } else break ; etePos ++ ; } } } } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { int length = getParamElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { ElemWithParam ewp = getParamElem ( i ) ; ewp . endCompose ( sroot ) ; } super . endCompose ( sroot ) ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; if ( null != m_template ) { XPathContext xctxt = transformer . getXPathContext ( ) ; VariableStack vars = xctxt . getVarStack ( ) ; int thisframe = vars . getStackFrame ( ) ; int nextFrame = vars . link ( m_template . m_frameSize ) ; if ( m_template . m_inArgsSize > 0 ) { vars . clearLocalSlots ( 0 , m_template . m_inArgsSize ) ; if ( null != m_paramElems ) { int currentNode = xctxt . getCurrentNode ( ) ; vars . setStackFrame ( thisframe ) ; int size = m_paramElems . length ; for ( int i = 0 ; i < size ; i ++ ) { ElemWithParam ewp = m_paramElems [ i ] ; if ( ewp . m_index >= 0 ) { XObject obj = ewp . getValue ( transformer , currentNode ) ; vars . setLocalVariable ( ewp . m_index , obj , nextFrame ) ; } } vars . setStackFrame ( nextFrame ) ; } } SourceLocator savedLocator = xctxt . getSAXLocator ( ) ; try { xctxt . setSAXLocator ( m_template ) ; transformer . pushElemTemplateElement ( m_template ) ; m_template . execute ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; xctxt . setSAXLocator ( savedLocator ) ; vars . unlink ( thisframe ) ; } } else { transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_TEMPLATE_NOT_FOUND , new Object [ ] { m_templateName } ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } protected ElemWithParam [ ] m_paramElems = null ; public int getParamElemCount ( ) { return ( m_paramElems == null ) ? 0 : m_paramElems . length ; } public ElemWithParam getParamElem ( int i ) { return m_paramElems [ i ] ; } public void setParamElem ( ElemWithParam ParamElem ) { if ( null == m_paramElems ) { m_paramElems = new ElemWithParam [ 1 ] ; m_paramElems [ 0 ] = ParamElem ; } else { int length = m_paramElems . length ; ElemWithParam [ ] ewp = new ElemWithParam [ length + 1 ] ; System . arraycopy ( m_paramElems , 0 , ewp , 0 , length ) ; m_paramElems = ewp ; ewp [ length ] = ParamElem ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; if ( Constants . ELEMNAME_WITHPARAM == type ) { setParamElem ( ( ElemWithParam ) newChild ) ; } return super . appendChild ( newChild ) ; } public void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['13', '4', '1', '16', '49', '40', '2', '14', '13', '0.638888889', '352', '0.666666667', '3', '0.946902655', '0.188034188', '4', '11', '25.84615385', '2', '1.1538', '1']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Node ; public class XPathException extends TransformerException { Object m_styleNode = null ; public Object getStylesheetNode ( ) { return m_styleNode ; } public void setStylesheetNode ( Object styleNode ) { m_styleNode = styleNode ; } protected Exception m_exception ; public XPathException ( String message , ExpressionNode ex ) { super ( message ) ; this . setLocator ( ex ) ; setStylesheetNode ( getStylesheetNode ( ex ) ) ; } public XPathException ( String message ) { super ( message ) ; } public org . w3c . dom . Node getStylesheetNode ( ExpressionNode ex ) { ExpressionNode owner = getExpressionOwner ( ex ) ; if ( null != owner && owner instanceof org . w3c . dom . Node ) { return ( ( org . w3c . dom . Node ) owner ) ; } return null ; } protected ExpressionNode getExpressionOwner ( ExpressionNode ex ) { ExpressionNode parent = ex . exprGetParent ( ) ; while ( ( null != parent ) && ( parent instanceof Expression ) ) parent = parent . exprGetParent ( ) ; return parent ; } public XPathException ( String message , Object styleNode ) { super ( message ) ; m_styleNode = styleNode ; } public XPathException ( String message , Node styleNode , Exception e ) { super ( message ) ; m_styleNode = styleNode ; this . m_exception = e ; } public XPathException ( String message , Exception e ) { super ( message ) ; this . m_exception = e ; } public void printStackTrace ( java . io . PrintStream s ) { if ( s == null ) s = System . err ; try { super . printStackTrace ( s ) ; } catch ( Exception e ) { } Throwable exception = m_exception ; for ( int i = 0 ; ( i < 10 ) && ( null != exception ) ; i ++ ) { s . println ( "---------" ) ; exception . printStackTrace ( s ) ; if ( exception instanceof TransformerException ) { TransformerException se = ( TransformerException ) exception ; Throwable prev = exception ; exception = se . getException ( ) ; if ( prev == exception ) break ; } else { exception = null ; } } } public String getMessage ( ) { String lastMessage = super . getMessage ( ) ; Throwable exception = m_exception ; while ( null != exception ) { String nextMessage = exception . getMessage ( ) ; if ( null != nextMessage ) lastMessage = nextMessage ; if ( exception instanceof TransformerException ) { TransformerException se = ( TransformerException ) exception ; Throwable prev = exception ; exception = se . getException ( ) ; if ( prev == exception ) break ; } else { exception = null ; } } return ( null != lastMessage ) ? lastMessage : "" ; } public void printStackTrace ( java . io . PrintWriter s ) { if ( s == null ) s = new java . io . PrintWriter ( System . err ) ; try { super . printStackTrace ( s ) ; } catch ( Exception e ) { } Throwable exception = m_exception ; for ( int i = 0 ; ( i < 10 ) && ( null != exception ) ; i ++ ) { s . println ( "---------" ) ; try { exception . printStackTrace ( s ) ; } catch ( Exception e ) { s . println ( "Could not print stack trace..." ) ; } if ( exception instanceof TransformerException ) { TransformerException se = ( TransformerException ) exception ; Throwable prev = exception ; exception = se . getException ( ) ; if ( prev == exception ) { exception = null ; break ; } } else { exception = null ; } } } public Throwable getException ( ) { return m_exception ; } } 	1	['13', '4', '1', '4', '26', '8', '2', '2', '12', '0.541666667', '257', '0.5', '0', '0.771428571', '0.269230769', '2', '4', '18.61538462', '5', '1.8462', '1']
package org . apache . xml . utils . synthetic ; public class SynthesisException extends Exception { int code ; public static final int SYNTAX = 0 ; public static final int UNSUPPORTED = 1 ; public static final int REIFIED = 2 ; public static final int UNREIFIED = 3 ; public static final int WRONG_OWNER = 4 ; public static final String [ ] errToString = { "(Syntax error; specific message should be passed in)" , "Feature not yet supported" , "Can't change features of 'real' class" , "Can't yet instantiate/invoke without 'real' class" , "Can't add Member to an object other than its declarer" , } ; public SynthesisException ( int code ) { super ( errToString [ code ] ) ; this . code = code ; } public SynthesisException ( int code , String msg ) { super ( msg ) ; this . code = code ; } int getCode ( ) { return code ; } } 	1	['4', '3', '0', '6', '5', '0', '6', '0', '2', '1.095238095', '54', '0', '0', '0.944444444', '0.666666667', '0', '0', '10.75', '1', '0.25', '1']
package org . apache . xalan . res ; public class XSLTErrorResources_en extends XSLTErrorResources { } 	1	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . compiler . Compiler ; public class ChildTestIterator extends BasicTestIterator { transient protected DTMAxisTraverser m_traverser ; ChildTestIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; } public ChildTestIterator ( DTMAxisTraverser traverser ) { super ( null ) ; m_traverser = traverser ; } protected int getNextNode ( ) { if ( true ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; } return m_lastFetched ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { ChildTestIterator clone = ( ChildTestIterator ) super . cloneWithReset ( ) ; clone . m_traverser = m_traverser ; return clone ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( Axis . CHILD ) ; } public int getAxis ( ) { return org . apache . xml . dtm . Axis . CHILD ; } public void detach ( ) { if ( m_allowDetach ) { m_traverser = null ; super . detach ( ) ; } } } 	1	['7', '6', '5', '12', '15', '1', '7', '6', '5', '0.333333333', '75', '1', '1', '0.962406015', '0.342857143', '2', '5', '9.571428571', '2', '1', '1']
package org . apache . xml . utils . res ; import java . util . ListResourceBundle ; abstract public class XResourceBundleBase extends ListResourceBundle { abstract public String getMessageKey ( int errorCode ) ; abstract public String getWarningKey ( int errorCode ) ; } 	1	['3', '3', '0', '0', '4', '3', '0', '0', '3', '2', '6', '0', '0', '0.95', '0.833333333', '0', '0', '1', '1', '0.6667', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemIf extends ElemTemplateElement { private XPath m_test = null ; public void setTest ( XPath v ) { m_test = v ; } public XPath getTest ( ) { return m_test ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_test ) m_test . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_IF ; } public String getNodeName ( ) { return Constants . ELEMNAME_IF_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; if ( TransformerImpl . S_DEBUG ) { XObject test = m_test . execute ( xctxt , sourceNode , this ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "test" , m_test , test ) ; if ( test . bool ( ) ) { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } else if ( m_test . bool ( xctxt , sourceNode , this ) ) { transformer . executeChildTemplates ( this , true ) ; } } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_test . getExpression ( ) . callVisitors ( m_test , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['8', '3', '0', '13', '27', '0', '0', '13', '7', '0.285714286', '117', '1', '1', '0.965517241', '0.270833333', '2', '5', '13.5', '2', '1', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . serializer . SerializationHandler ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public final class DOMAdapter implements DOM { private SAXImpl _saxImpl ; private DOM _dom ; private String [ ] _namesArray ; private String [ ] _namespaceArray ; private short [ ] _mapping = null ; private int [ ] _reverse = null ; private short [ ] _NSmapping = null ; private short [ ] _NSreverse = null ; private StripFilter _filter = null ; private int _multiDOMMask ; public DOMAdapter ( DOM dom , String [ ] namesArray , String [ ] namespaceArray ) { if ( dom instanceof SAXImpl ) { _saxImpl = ( SAXImpl ) dom ; } _dom = dom ; _namesArray = namesArray ; _namespaceArray = namespaceArray ; } public void setupMapping ( String [ ] names , String [ ] namespaces ) { _namesArray = names ; _namespaceArray = namespaces ; } public String [ ] getNamesArray ( ) { return _namesArray ; } public String [ ] getNamespaceArray ( ) { return _namespaceArray ; } public DOM getDOMImpl ( ) { return _dom ; } private short [ ] getMapping ( ) { if ( _mapping == null ) { if ( _saxImpl != null ) { _mapping = _saxImpl . getMapping ( _namesArray ) ; } } return _mapping ; } private int [ ] getReverse ( ) { if ( _reverse == null ) { if ( _saxImpl != null ) { _reverse = _saxImpl . getReverseMapping ( _namesArray ) ; } } return _reverse ; } private short [ ] getNSMapping ( ) { if ( _NSmapping == null ) { if ( _saxImpl != null ) { _NSmapping = _saxImpl . getNamespaceMapping ( _namespaceArray ) ; } } return _NSmapping ; } private short [ ] getNSReverse ( ) { if ( _NSreverse == null ) { if ( _saxImpl != null ) { _NSreverse = _saxImpl . getReverseNamespaceMapping ( _namespaceArray ) ; } } return _NSreverse ; } public DTMAxisIterator getIterator ( ) { return _dom . getIterator ( ) ; } public String getStringValue ( ) { return _dom . getStringValue ( ) ; } public DTMAxisIterator getChildren ( final int node ) { if ( _saxImpl != null ) { return _saxImpl . getChildren ( node ) ; } else { DTMAxisIterator iterator = _dom . getChildren ( node ) ; return iterator . setStartNode ( node ) ; } } public void setFilter ( StripFilter filter ) { _filter = filter ; } public DTMAxisIterator getTypedChildren ( final int type ) { final int [ ] reverse = getReverse ( ) ; if ( _saxImpl != null ) { return _saxImpl . getTypedChildren ( reverse [ type ] ) ; } else { return _dom . getTypedChildren ( type ) ; } } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { return _dom . getNamespaceAxisIterator ( axis , getNSReverse ( ) [ ns ] ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { if ( _saxImpl != null ) { return _saxImpl . getAxisIterator ( axis ) ; } else { return _dom . getAxisIterator ( axis ) ; } } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { final int [ ] reverse = getReverse ( ) ; if ( axis == Axis . NAMESPACE ) { short [ ] NSReverse = getNSReverse ( ) ; if ( type == NO_TYPE || type > NSReverse . length ) { return _dom . getAxisIterator ( axis ) ; } else { return _dom . getTypedAxisIterator ( axis , NSReverse [ type ] ) ; } } else if ( _saxImpl != null ) { return _saxImpl . getTypedAxisIterator ( axis , reverse [ type ] ) ; } else { return _dom . getTypedAxisIterator ( axis , type ) ; } } public int getMultiDOMMask ( ) { return _multiDOMMask ; } public void setMultiDOMMask ( int mask ) { _multiDOMMask = mask ; } public DTMAxisIterator getNthDescendant ( int type , int n , boolean includeself ) { return _dom . getNthDescendant ( getReverse ( ) [ type ] , n , includeself ) ; } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iterator , int type , String value , boolean op ) { return _dom . getNodeValueIterator ( iterator , type , value , op ) ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return _dom . orderNodes ( source , node ) ; } public int getExpandedTypeID ( final int node ) { if ( _saxImpl != null ) { return getMapping ( ) [ _saxImpl . getExpandedTypeID2 ( node ) ] ; } else { return getMapping ( ) [ _dom . getExpandedTypeID ( node ) ] ; } } public int getNamespaceType ( final int node ) { return getNSMapping ( ) [ _dom . getNSType ( node ) ] ; } public int getNSType ( int node ) { return _dom . getNSType ( node ) ; } public int getParent ( final int node ) { return _dom . getParent ( node ) ; } public int getAttributeNode ( final int type , final int element ) { return _dom . getAttributeNode ( getReverse ( ) [ type ] , element ) ; } public String getNodeName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _dom . getNodeName ( node ) ; } public String getNodeNameX ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _dom . getNodeNameX ( node ) ; } public String getNamespaceName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _dom . getNamespaceName ( node ) ; } public String getStringValueX ( final int node ) { if ( _saxImpl != null ) { return _saxImpl . getStringValueX ( node ) ; } else { if ( node == DTM . NULL ) { return "" ; } return _dom . getStringValueX ( node ) ; } } public void copy ( final int node , SerializationHandler handler ) throws TransletException { _dom . copy ( node , handler ) ; } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { _dom . copy ( nodes , handler ) ; } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { if ( _saxImpl != null ) { return _saxImpl . shallowCopy ( node , handler ) ; } else { return _dom . shallowCopy ( node , handler ) ; } } public boolean lessThan ( final int node1 , final int node2 ) { return _dom . lessThan ( node1 , node2 ) ; } public void characters ( final int textNode , SerializationHandler handler ) throws TransletException { if ( _saxImpl != null ) { _saxImpl . characters ( textNode , handler ) ; } else { _dom . characters ( textNode , handler ) ; } } public Node makeNode ( int index ) { return _dom . makeNode ( index ) ; } public Node makeNode ( DTMAxisIterator iter ) { return _dom . makeNode ( iter ) ; } public NodeList makeNodeList ( int index ) { return _dom . makeNodeList ( index ) ; } public NodeList makeNodeList ( DTMAxisIterator iter ) { return _dom . makeNodeList ( iter ) ; } public String getLanguage ( int node ) { return _dom . getLanguage ( node ) ; } public int getSize ( ) { return _dom . getSize ( ) ; } public void setDocumentURI ( String uri ) { if ( _saxImpl != null ) { _saxImpl . setDocumentURI ( uri ) ; } } public String getDocumentURI ( ) { if ( _saxImpl != null ) { return _saxImpl . getDocumentURI ( ) ; } else { return "" ; } } public String getDocumentURI ( int node ) { return _dom . getDocumentURI ( node ) ; } public int getDocument ( ) { return _dom . getDocument ( ) ; } public boolean isElement ( final int node ) { return ( _dom . isElement ( node ) ) ; } public boolean isAttribute ( final int node ) { return ( _dom . isAttribute ( node ) ) ; } public int getNodeIdent ( int nodeHandle ) { return _dom . getNodeIdent ( nodeHandle ) ; } public int getNodeHandle ( int nodeId ) { return _dom . getNodeHandle ( nodeId ) ; } public DOM getResultTreeFrag ( int initSize , int rtfType ) { if ( _saxImpl != null ) { return _saxImpl . getResultTreeFrag ( initSize , rtfType ) ; } else { return _dom . getResultTreeFrag ( initSize , rtfType ) ; } } public SerializationHandler getOutputDomBuilder ( ) { return _dom . getOutputDomBuilder ( ) ; } public String lookupNamespace ( int node , String prefix ) throws TransletException { return _dom . lookupNamespace ( node , prefix ) ; } public String getUnparsedEntityURI ( String entity ) { return _dom . getUnparsedEntityURI ( entity ) ; } public Hashtable getElementsWithIDs ( ) { return _dom . getElementsWithIDs ( ) ; } } 	1	['55', '1', '0', '12', '112', '0', '5', '7', '51', '0.831481481', '576', '1', '3', '0', '0.214141414', '0', '0', '9.290909091', '5', '1.4182', '1']
package org . apache . xml . utils ; public class XMLCharacterRecognizer { public static boolean isWhiteSpace ( char ch ) { return ( ch == 0x20 ) || ( ch == 0x09 ) || ( ch == 0xD ) || ( ch == 0xA ) ; } public static boolean isWhiteSpace ( char ch [ ] , int start , int length ) { int end = start + length ; for ( int s = start ; s < end ; s ++ ) { if ( ! isWhiteSpace ( ch [ s ] ) ) return false ; } return true ; } public static boolean isWhiteSpace ( StringBuffer buf ) { int n = buf . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! isWhiteSpace ( buf . charAt ( i ) ) ) return false ; } return true ; } public static boolean isWhiteSpace ( String s ) { if ( null != s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! isWhiteSpace ( s . charAt ( i ) ) ) return false ; } } return true ; } } 	1	['5', '1', '0', '7', '10', '10', '7', '0', '5', '2', '85', '0', '0', '0', '0.2', '0', '0', '16', '5', '3', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . NodeConsumer ; import org . apache . xml . utils . XMLString ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; public class DTMTreeWalker { private ContentHandler m_contentHandler = null ; protected DTM m_dtm ; public void setDTM ( DTM dtm ) { m_dtm = dtm ; } public ContentHandler getcontentHandler ( ) { return m_contentHandler ; } public void setcontentHandler ( ContentHandler ch ) { m_contentHandler = ch ; } public DTMTreeWalker ( ) { } public DTMTreeWalker ( ContentHandler contentHandler , DTM dtm ) { this . m_contentHandler = contentHandler ; m_dtm = dtm ; } public void traverse ( int pos ) throws org . xml . sax . SAXException { int top = pos ; while ( DTM . NULL != pos ) { startNode ( pos ) ; int nextNode = m_dtm . getFirstChild ( pos ) ; while ( DTM . NULL == nextNode ) { endNode ( pos ) ; if ( top == pos ) break ; nextNode = m_dtm . getNextSibling ( pos ) ; if ( DTM . NULL == nextNode ) { pos = m_dtm . getParent ( pos ) ; if ( ( DTM . NULL == pos ) || ( top == pos ) ) { if ( DTM . NULL != pos ) endNode ( pos ) ; nextNode = DTM . NULL ; break ; } } } pos = nextNode ; } } public void traverse ( int pos , int top ) throws org . xml . sax . SAXException { while ( DTM . NULL != pos ) { startNode ( pos ) ; int nextNode = m_dtm . getFirstChild ( pos ) ; while ( DTM . NULL == nextNode ) { endNode ( pos ) ; if ( ( DTM . NULL != top ) && top == pos ) break ; nextNode = m_dtm . getNextSibling ( pos ) ; if ( DTM . NULL == nextNode ) { pos = m_dtm . getParent ( pos ) ; if ( ( DTM . NULL == pos ) || ( ( DTM . NULL != top ) && ( top == pos ) ) ) { nextNode = DTM . NULL ; break ; } } } pos = nextNode ; } } boolean nextIsRaw = false ; private final void dispatachChars ( int node ) throws org . xml . sax . SAXException { m_dtm . dispatchCharactersEvents ( node , m_contentHandler , false ) ; } protected void startNode ( int node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof NodeConsumer ) { } switch ( m_dtm . getNodeType ( node ) ) { case DTM . COMMENT_NODE : { XMLString data = m_dtm . getStringValue ( node ) ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; data . dispatchAsComment ( lh ) ; } } break ; case DTM . DOCUMENT_FRAGMENT_NODE : break ; case DTM . DOCUMENT_NODE : this . m_contentHandler . startDocument ( ) ; break ; case DTM . ELEMENT_NODE : DTM dtm = m_dtm ; for ( int nsn = dtm . getFirstNamespaceNode ( node , true ) ; DTM . NULL != nsn ; nsn = dtm . getNextNamespaceNode ( node , nsn , true ) ) { String prefix = dtm . getNodeNameX ( nsn ) ; this . m_contentHandler . startPrefixMapping ( prefix , dtm . getNodeValue ( nsn ) ) ; } String ns = dtm . getNamespaceURI ( node ) ; if ( null == ns ) ns = "" ; org . xml . sax . helpers . AttributesImpl attrs = new org . xml . sax . helpers . AttributesImpl ( ) ; for ( int i = dtm . getFirstAttribute ( node ) ; i != DTM . NULL ; i = dtm . getNextAttribute ( i ) ) { attrs . addAttribute ( dtm . getNamespaceURI ( i ) , dtm . getLocalName ( i ) , dtm . getNodeName ( i ) , "CDATA" , dtm . getNodeValue ( i ) ) ; } this . m_contentHandler . startElement ( ns , m_dtm . getLocalName ( node ) , m_dtm . getNodeName ( node ) , attrs ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : { String name = m_dtm . getNodeName ( node ) ; if ( name . equals ( "xslt-next-is-raw" ) ) { nextIsRaw = true ; } else { this . m_contentHandler . processingInstruction ( name , m_dtm . getNodeValue ( node ) ) ; } } break ; case DTM . CDATA_SECTION_NODE : { boolean isLexH = ( m_contentHandler instanceof LexicalHandler ) ; LexicalHandler lh = isLexH ? ( ( LexicalHandler ) this . m_contentHandler ) : null ; if ( isLexH ) { lh . startCDATA ( ) ; } dispatachChars ( node ) ; { if ( isLexH ) { lh . endCDATA ( ) ; } } } break ; case DTM . TEXT_NODE : { if ( nextIsRaw ) { nextIsRaw = false ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; dispatachChars ( node ) ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { dispatachChars ( node ) ; } } break ; case DTM . ENTITY_REFERENCE_NODE : { if ( m_contentHandler instanceof LexicalHandler ) { ( ( LexicalHandler ) this . m_contentHandler ) . startEntity ( m_dtm . getNodeName ( node ) ) ; } else { } } break ; default : } } protected void endNode ( int node ) throws org . xml . sax . SAXException { switch ( m_dtm . getNodeType ( node ) ) { case DTM . DOCUMENT_NODE : this . m_contentHandler . endDocument ( ) ; break ; case DTM . ELEMENT_NODE : String ns = m_dtm . getNamespaceURI ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . endElement ( ns , m_dtm . getLocalName ( node ) , m_dtm . getNodeName ( node ) ) ; for ( int nsn = m_dtm . getFirstNamespaceNode ( node , true ) ; DTM . NULL != nsn ; nsn = m_dtm . getNextNamespaceNode ( node , nsn , true ) ) { String prefix = m_dtm . getNodeNameX ( nsn ) ; this . m_contentHandler . endPrefixMapping ( prefix ) ; } break ; case DTM . CDATA_SECTION_NODE : break ; case DTM . ENTITY_REFERENCE_NODE : { if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . endEntity ( m_dtm . getNodeName ( node ) ) ; } } break ; default : } } } 	1	['10', '1', '1', '6', '41', '0', '3', '3', '7', '0.333333333', '437', '0.666666667', '1', '0', '0.475', '0', '0', '42.4', '1', '0.8', '1']
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . dtm . DTM ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . XMLString ; public class ClonerToResultTree { public static void cloneToResultTree ( int node , int nodeType , DTM dtm , SerializationHandler rth , boolean shouldCloneAttributes ) throws TransformerException { try { switch ( nodeType ) { case DTM . TEXT_NODE : dtm . dispatchCharactersEvents ( node , rth , false ) ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : case DTM . DOCUMENT_NODE : break ; case DTM . ELEMENT_NODE : { String ns = dtm . getNamespaceURI ( node ) ; if ( ns == null ) ns = "" ; String localName = dtm . getLocalName ( node ) ; rth . startElement ( ns , localName , dtm . getNodeNameX ( node ) ) ; if ( shouldCloneAttributes ) { SerializerUtils . addAttributes ( rth , node ) ; SerializerUtils . processNSDecls ( rth , node , nodeType , dtm ) ; } } break ; case DTM . CDATA_SECTION_NODE : rth . startCDATA ( ) ; dtm . dispatchCharactersEvents ( node , rth , false ) ; rth . endCDATA ( ) ; break ; case DTM . ATTRIBUTE_NODE : SerializerUtils . addAttribute ( rth , node ) ; break ; case DTM . NAMESPACE_NODE : SerializerUtils . processNSDecls ( rth , node , DTM . NAMESPACE_NODE , dtm ) ; break ; case DTM . COMMENT_NODE : XMLString xstr = dtm . getStringValue ( node ) ; xstr . dispatchAsComment ( rth ) ; break ; case DTM . ENTITY_REFERENCE_NODE : rth . entityReference ( dtm . getNodeNameX ( node ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : { rth . processingInstruction ( dtm . getNodeNameX ( node ) , dtm . getNodeValue ( node ) ) ; } break ; default : throw new TransformerException ( "Can't clone node: " + dtm . getNodeName ( node ) ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } } 	1	['2', '1', '0', '7', '24', '1', '3', '4', '2', '2', '109', '0', '0', '0', '0.5', '0', '0', '53.5', '1', '0.5', '1']
package org . apache . xml . utils ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; public class PrefixResolverDefault implements PrefixResolver { Node m_context ; public PrefixResolverDefault ( Node xpathExpressionContext ) { m_context = xpathExpressionContext ; } public String getNamespaceForPrefix ( String prefix ) { return getNamespaceForPrefix ( prefix , m_context ) ; } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node namespaceContext ) { Node parent = namespaceContext ; String namespace = null ; if ( prefix . equals ( "xml" ) ) { namespace = Constants . S_XMLNAMESPACEURI ; } else { int type ; while ( ( null != parent ) && ( null == namespace ) && ( ( ( type = parent . getNodeType ( ) ) == Node . ELEMENT_NODE ) || ( type == Node . ENTITY_REFERENCE_NODE ) ) ) { if ( type == Node . ELEMENT_NODE ) { NamedNodeMap nnm = parent . getAttributes ( ) ; for ( int i = 0 ; i < nnm . getLength ( ) ; i ++ ) { Node attr = nnm . item ( i ) ; String aname = attr . getNodeName ( ) ; boolean isPrefix = aname . startsWith ( "xmlns:" ) ; if ( isPrefix || aname . equals ( "xmlns" ) ) { int index = aname . indexOf ( ':' ) ; String p = isPrefix ? aname . substring ( index + 1 ) : "" ; if ( p . equals ( prefix ) ) { namespace = attr . getNodeValue ( ) ; break ; } } } } parent = parent . getParentNode ( ) ; } } return namespace ; } public String getBaseIdentifier ( ) { return null ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1	['5', '1', '1', '5', '17', '8', '4', '1', '5', '0.75', '107', '0', '0', '0', '0.6', '0', '0', '20.2', '12', '3', '2']
package org . apache . xalan . lib ; import java . util . StringTokenizer ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xpath . NodeSet ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; public class ExsltStrings extends ExsltBase { private static Document m_doc = null ; private static ExsltStrings m_instance = new ExsltStrings ( ) ; public static String align ( String targetStr , String paddingStr , String type ) { if ( targetStr . length ( ) >= paddingStr . length ( ) ) return targetStr . substring ( 0 , paddingStr . length ( ) ) ; if ( type . equals ( "right" ) ) { return paddingStr . substring ( 0 , paddingStr . length ( ) - targetStr . length ( ) ) + targetStr ; } else if ( type . equals ( "center" ) ) { int startIndex = ( paddingStr . length ( ) - targetStr . length ( ) ) / 2 ; return paddingStr . substring ( 0 , startIndex ) + targetStr + paddingStr . substring ( startIndex + targetStr . length ( ) ) ; } else { return targetStr + paddingStr . substring ( paddingStr . length ( ) - targetStr . length ( ) ) ; } } public static String align ( String targetStr , String paddingStr ) { return align ( targetStr , paddingStr , "left" ) ; } public static String concat ( NodeList nl ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node node = nl . item ( i ) ; String value = toString ( node ) ; if ( value != null && value . length ( ) > 0 ) sb . append ( value ) ; } return sb . toString ( ) ; } public static String padding ( double length , String pattern ) { if ( pattern == null || pattern . length ( ) == 0 ) return "" ; StringBuffer sb = new StringBuffer ( ) ; int len = ( int ) length ; int numAdded = 0 ; int index = 0 ; while ( numAdded < len ) { if ( index == pattern . length ( ) ) index = 0 ; sb . append ( pattern . charAt ( index ) ) ; index ++ ; numAdded ++ ; } return sb . toString ( ) ; } public static String padding ( double length ) { return padding ( length , " " ) ; } public static NodeList split ( String str , String pattern ) { try { if ( m_doc == null ) { synchronized ( m_instance ) { if ( m_doc == null ) m_doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } } } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } NodeSet resultSet = new NodeSet ( ) ; resultSet . setShouldCacheNodes ( true ) ; boolean done = false ; int fromIndex = 0 ; int matchIndex = 0 ; String token = null ; while ( ! done && fromIndex < str . length ( ) ) { matchIndex = str . indexOf ( pattern , fromIndex ) ; if ( matchIndex >= 0 ) { token = str . substring ( fromIndex , matchIndex ) ; fromIndex = matchIndex + pattern . length ( ) ; } else { done = true ; token = str . substring ( fromIndex ) ; } synchronized ( m_doc ) { Element element = m_doc . createElement ( "token" ) ; Text text = m_doc . createTextNode ( token ) ; element . appendChild ( text ) ; resultSet . addNode ( element ) ; } } return resultSet ; } public static NodeList split ( String str ) { return split ( str , " " ) ; } public static NodeList tokenize ( String toTokenize , String delims ) { try { if ( m_doc == null ) { synchronized ( m_instance ) { if ( m_doc == null ) m_doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } } } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } NodeSet resultSet = new NodeSet ( ) ; if ( delims != null && delims . length ( ) > 0 ) { StringTokenizer lTokenizer = new StringTokenizer ( toTokenize , delims ) ; synchronized ( m_doc ) { while ( lTokenizer . hasMoreTokens ( ) ) { Element element = m_doc . createElement ( "token" ) ; element . appendChild ( m_doc . createTextNode ( lTokenizer . nextToken ( ) ) ) ; resultSet . addNode ( element ) ; } } } else { synchronized ( m_doc ) { for ( int i = 0 ; i < toTokenize . length ( ) ; i ++ ) { Element element = m_doc . createElement ( "token" ) ; element . appendChild ( m_doc . createTextNode ( toTokenize . substring ( i , i + 1 ) ) ) ; resultSet . addNode ( element ) ; } } } return resultSet ; } public static NodeList tokenize ( String toTokenize ) { return tokenize ( toTokenize , " \t\n\r" ) ; } } 	1	['11', '2', '0', '3', '38', '49', '0', '3', '10', '0.6', '402', '1', '1', '0.181818182', '0.275', '0', '0', '35.36363636', '6', '2.5455', '2']
package org . apache . xml . utils ; public class SuballocatedByteVector { protected int m_blocksize ; protected int m_numblocks = 32 ; protected byte m_map [ ] [ ] ; protected int m_firstFree = 0 ; protected byte m_map0 [ ] ; public SuballocatedByteVector ( ) { this ( 2048 ) ; } public SuballocatedByteVector ( int blocksize ) { m_blocksize = blocksize ; m_map0 = new byte [ blocksize ] ; m_map = new byte [ m_numblocks ] [ ] ; m_map [ 0 ] = m_map0 ; } public SuballocatedByteVector ( int blocksize , int increaseSize ) { this ( blocksize ) ; } public int size ( ) { return m_firstFree ; } private void setSize ( int sz ) { if ( m_firstFree < sz ) m_firstFree = sz ; } public void addElement ( byte value ) { if ( m_firstFree < m_blocksize ) m_map0 [ m_firstFree ++ ] = value ; else { int index = m_firstFree / m_blocksize ; int offset = m_firstFree % m_blocksize ; ++ m_firstFree ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; block [ offset ] = value ; } } private void addElements ( byte value , int numberOfElements ) { if ( m_firstFree + numberOfElements < m_blocksize ) for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map0 [ m_firstFree ++ ] = value ; } else { int index = m_firstFree / m_blocksize ; int offset = m_firstFree % m_blocksize ; m_firstFree += numberOfElements ; while ( numberOfElements > 0 ) { if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; int copied = ( m_blocksize - offset < numberOfElements ) ? m_blocksize - offset : numberOfElements ; numberOfElements -= copied ; while ( copied -- > 0 ) block [ offset ++ ] = value ; ++ index ; offset = 0 ; } } } private void addElements ( int numberOfElements ) { int newlen = m_firstFree + numberOfElements ; if ( newlen > m_blocksize ) { int index = m_firstFree % m_blocksize ; int newindex = ( m_firstFree + numberOfElements ) % m_blocksize ; for ( int i = index + 1 ; i <= newindex ; ++ i ) m_map [ i ] = new byte [ m_blocksize ] ; } m_firstFree = newlen ; } private void insertElementAt ( byte value , int at ) { if ( at == m_firstFree ) addElement ( value ) ; else if ( at > m_firstFree ) { int index = at / m_blocksize ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; int offset = at % m_blocksize ; block [ offset ] = value ; m_firstFree = offset + 1 ; } else { int index = at / m_blocksize ; int maxindex = m_firstFree + 1 / m_blocksize ; ++ m_firstFree ; int offset = at % m_blocksize ; byte push ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; byte [ ] block = m_map [ index ] ; if ( null == block ) { push = 0 ; block = m_map [ index ] = new byte [ m_blocksize ] ; } else { push = block [ m_blocksize - 1 ] ; System . arraycopy ( block , offset , block , offset + 1 , copylen ) ; } block [ offset ] = value ; value = push ; offset = 0 ; ++ index ; } } } public void removeAllElements ( ) { m_firstFree = 0 ; } private boolean removeElement ( byte s ) { int at = indexOf ( s , 0 ) ; if ( at < 0 ) return false ; removeElementAt ( at ) ; return true ; } private void removeElementAt ( int at ) { if ( at < m_firstFree ) { int index = at / m_blocksize ; int maxindex = m_firstFree / m_blocksize ; int offset = at % m_blocksize ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; else System . arraycopy ( block , offset + 1 , block , offset , copylen ) ; if ( index < maxindex ) { byte [ ] next = m_map [ index + 1 ] ; if ( next != null ) block [ m_blocksize - 1 ] = ( next != null ) ? next [ 0 ] : 0 ; } else block [ m_blocksize - 1 ] = 0 ; offset = 0 ; ++ index ; } } -- m_firstFree ; } public void setElementAt ( byte value , int at ) { if ( at < m_blocksize ) { m_map0 [ at ] = value ; return ; } int index = at / m_blocksize ; int offset = at % m_blocksize ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; block [ offset ] = value ; if ( at >= m_firstFree ) m_firstFree = at + 1 ; } public byte elementAt ( int i ) { if ( i < m_blocksize ) return m_map0 [ i ] ; return m_map [ i / m_blocksize ] [ i % m_blocksize ] ; } private boolean contains ( byte s ) { return ( indexOf ( s , 0 ) >= 0 ) ; } public int indexOf ( byte elem , int index ) { if ( index >= m_firstFree ) return - 1 ; int bindex = index / m_blocksize ; int boffset = index % m_blocksize ; int maxindex = m_firstFree / m_blocksize ; byte [ ] block ; for ( ; bindex < maxindex ; ++ bindex ) { block = m_map [ bindex ] ; if ( block != null ) for ( int offset = boffset ; offset < m_blocksize ; ++ offset ) if ( block [ offset ] == elem ) return offset + bindex * m_blocksize ; boffset = 0 ; } int maxoffset = m_firstFree % m_blocksize ; block = m_map [ maxindex ] ; for ( int offset = boffset ; offset < maxoffset ; ++ offset ) if ( block [ offset ] == elem ) return offset + maxindex * m_blocksize ; return - 1 ; } public int indexOf ( byte elem ) { return indexOf ( elem , 0 ) ; } private int lastIndexOf ( byte elem ) { int boffset = m_firstFree % m_blocksize ; for ( int index = m_firstFree / m_blocksize ; index >= 0 ; -- index ) { byte [ ] block = m_map [ index ] ; if ( block != null ) for ( int offset = boffset ; offset >= 0 ; -- offset ) if ( block [ offset ] == elem ) return offset + index * m_blocksize ; boffset = 0 ; } return - 1 ; } } 	1	['18', '1', '0', '0', '20', '3', '0', '0', '10', '0.329411765', '830', '1', '0', '0', '0.685185185', '0', '0', '44.83333333', '8', '3.1111', '1']
package org . apache . xalan . templates ; public class Constants extends org . apache . xml . utils . Constants { public static final int ELEMNAME_UNDEFINED = - 1 , ELEMNAME_WITHPARAM = 2 , ELEMNAME_ADDATTRIBUTE = 4 , ELEMNAME_ANCHOR = 22 , ELEMNAME_APPLY_TEMPLATES = 50 , ELEMNAME_USE = 34 , ELEMNAME_CHILDREN = 6 , ELEMNAME_CHOOSE = 37 , ELEMNAME_COMMENT = 59 , ELEMNAME_CONSTRUCT = 7 , ELEMNAME_CONTENTS = 8 , ELEMNAME_COPY = 9 , ELEMNAME_COPY_OF = 74 , ELEMNAME_DECIMALFORMAT = 83 , ELEMNAME_DEFINEATTRIBUTESET = 40 , ELEMNAME_DEFINESCRIPT = 11 , ELEMNAME_DISPLAYIF = 12 , ELEMNAME_EMPTY = 14 , ELEMNAME_EVAL = 15 , ELEMNAME_EXPECTEDCHILDREN = 16 , ELEMNAME_EXTENSION = 54 , ELEMNAME_EXTENSIONHANDLER = 63 , ELEMNAME_FOREACH = 28 , ELEMNAME_KEY = 31 , ELEMNAME_IF = 36 , ELEMNAME_IMPORT = 26 , ELEMNAME_INCLUDE = 27 , ELEMNAME_CALLTEMPLATE = 17 , ELEMNAME_PARAMVARIABLE = 41 , ELEMNAME_NUMBER = 35 , ELEMNAME_NSALIAS = 84 , ELEMNAME_OTHERWISE = 39 , ELEMNAME_PI = 58 , ELEMNAME_PRESERVESPACE = 33 , ELEMNAME_REMOVEATTRIBUTE = 5 , ELEMNAME_TEMPLATE = 19 , ELEMNAME_SORT = 64 , ELEMNAME_STRIPSPACE = 32 , ELEMNAME_STYLESHEET = 25 , ELEMNAME_TEXT = 42 , ELEMNAME_VALUEOF = 30 , ELEMNAME_WHEN = 38 , ELEMNAME_ROOT = 44 , ELEMNAME_ANY = 45 , ELEMNAME_ELEMENT = 46 , ELEMNAME_TARGETELEMENT = 47 , ELEMNAME_ATTRIBUTE = 48 , ELEMNAME_TARGETATTRIBUTE = 49 , ELEMNAME_URL = 52 , ELEMNAME_CALL = 55 , ELEMNAME_FALLBACK = 57 , ELEMNAME_TARGETPI = 60 , ELEMNAME_TARGETCOMMENT = 61 , ELEMNAME_TARGETTEXT = 62 , ELEMNAME_CSSSTYLECONVERSION = 65 , ELEMNAME_COUNTER = 66 , ELEMNAME_COUNTERS = 67 , ELEMNAME_COUNTERINCREMENT = 68 , ELEMNAME_COUNTERRESET = 69 , ELEMNAME_COUNTERSCOPE = 71 , ELEMNAME_APPLY_IMPORTS = 72 , ELEMNAME_VARIABLE = 73 , ELEMNAME_MESSAGE = 75 , ELEMNAME_LOCALE = 76 , ELEMNAME_LITERALRESULT = 77 , ELEMNAME_TEXTLITERALRESULT = 78 , ELEMNAME_EXTENSIONCALL = 79 , ELEMNAME_EXTENSIONDECL = 85 , ELEMNAME_EXTENSIONSCRIPT = 86 , ELEMNAME_OUTPUT = 80 , ELEMNAME_COMPONENT = 81 , ELEMNAME_SCRIPT = 82 ; public static final String ELEMNAME_ANCHOR_STRING = "anchor" , ELEMNAME_ANY_STRING = "any" , ELEMNAME_APPLY_IMPORTS_STRING = "apply-imports" , ELEMNAME_APPLY_TEMPLATES_STRING = "apply-templates" , ELEMNAME_ARG_STRING = "arg" , ELEMNAME_ATTRIBUTESET_STRING = "attribute-set" , ELEMNAME_ATTRIBUTE_STRING = "attribute" , ELEMNAME_CALLTEMPLATEARG_STRING = "invoke-arg" , ELEMNAME_CALLTEMPLATE_STRING = "call-template" , ELEMNAME_CALL_STRING = "call" , ELEMNAME_CHILDREN_STRING = "children" , ELEMNAME_CHOOSE_STRING = "choose" , ELEMNAME_COMMENT_STRING = "comment" , ELEMNAME_COMPONENT_STRING = "component" , ELEMNAME_CONSTRUCT_STRING = "construct" , ELEMNAME_CONTENTS_STRING = "contents" , ELEMNAME_COPY_OF_STRING = "copy-of" , ELEMNAME_COPY_STRING = "copy" , ELEMNAME_COUNTERINCREMENT_STRING = "counter-increment" , ELEMNAME_COUNTERRESET_STRING = "counter-reset" , ELEMNAME_COUNTERSCOPE_STRING = "counter-scope" , ELEMNAME_COUNTERS_STRING = "counters" , ELEMNAME_COUNTER_STRING = "counter" , ELEMNAME_CSSSTYLECONVERSION_STRING = "css-style-conversion" , ELEMNAME_DECIMALFORMAT_STRING = "decimal-format" , ELEMNAME_DISPLAYIF_STRING = "display-if" , ELEMNAME_ELEMENT_STRING = "element" , ELEMNAME_EMPTY_STRING = "empty" , ELEMNAME_EVAL_STRING = "eval" , ELEMNAME_EXPECTEDCHILDREN_STRING = "expectedchildren" , ELEMNAME_EXTENSIONHANDLER_STRING = "code-dispatcher" , ELEMNAME_EXTENSION_STRING = "functions" , ELEMNAME_FALLBACK_STRING = "fallback" , ELEMNAME_FOREACH_STRING = "for-each" , ELEMNAME_IF_STRING = "if" , ELEMNAME_IMPORT_STRING = "import" , ELEMNAME_INCLUDE_STRING = "include" , ELEMNAME_KEY_STRING = "key" , ELEMNAME_LOCALE_STRING = "locale" , ELEMNAME_MESSAGE_STRING = "message" , ELEMNAME_NSALIAS_STRING = "namespace-alias" , ELEMNAME_NUMBER_STRING = "number" , ELEMNAME_OTHERWISE_STRING = "otherwise" , ELEMNAME_OUTPUT_STRING = "output" , ELEMNAME_PARAMVARIABLE_STRING = "param" , ELEMNAME_PI_OLD_STRING = "pi" , ELEMNAME_PI_STRING = "processing-instruction" , ELEMNAME_PRESERVESPACE_STRING = "preserve-space" , ELEMNAME_ROOT_STRING = "root" , ELEMNAME_SCRIPT_STRING = "script" , ELEMNAME_SORT_STRING = "sort" , ELEMNAME_STRIPSPACE_STRING = "strip-space" , ELEMNAME_STYLESHEET_STRING = "stylesheet" , ELEMNAME_TARGETATTRIBUTE_STRING = "target-attribute" , ELEMNAME_TARGETCOMMENT_STRING = "target-comment" , ELEMNAME_TARGETELEMENT_STRING = "target-element" , ELEMNAME_TARGETPI_STRING = "target-pi" , ELEMNAME_TARGETTEXT_STRING = "target-text" , ELEMNAME_TEMPLATE_STRING = "template" , ELEMNAME_TEXT_STRING = "text" , ELEMNAME_TRANSFORM_STRING = "transform" , ELEMNAME_URL_STRING = "uri" , ELEMNAME_USE_STRING = "use" , ELEMNAME_VALUEOF_STRING = "value-of" , ELEMNAME_VARIABLE_STRING = "variable" , ELEMNAME_WHEN_STRING = "when" , ELEMNAME_WITHPARAM_STRING = "with-param" ; public static final String EXSLT_ELEMNAME_FUNCTION_STRING = "function" , EXSLT_ELEMNAME_FUNCRESULT_STRING = "result" ; public static final int EXSLT_ELEMNAME_FUNCTION = 88 , EXSLT_ELEMNAME_FUNCRESULT = 89 ; public static final String ATTRNAME_AMOUNT = "amount" , ATTRNAME_ANCESTOR = "ancestor" , ATTRNAME_ARCHIVE = "archive" , ATTRNAME_ATTRIBUTE = "attribute" , ATTRNAME_ATTRIBUTE_SET = "attribute-set" , ATTRNAME_CASEORDER = "case-order" , ATTRNAME_CLASS = "class" , ATTRNAME_CLASSID = "classid" , ATTRNAME_CODEBASE = "codebase" , ATTRNAME_CODETYPE = "type" , ATTRNAME_CONDITION = "condition" , ATTRNAME_COPYTYPE = "copy-type" , ATTRNAME_COUNT = "count" , ATTRNAME_DATATYPE = "data-type" , ATTRNAME_DECIMALSEPARATOR = "decimal-separator" , ATTRNAME_DEFAULT = "default" , ATTRNAME_DEFAULTSPACE = "default-space" , ATTRNAME_DEPTH = "with-children" , ATTRNAME_DIGIT = "digit" , ATTRNAME_DIGITGROUPSEP = "digit-group-sep" , ATTRNAME_DISABLE_OUTPUT_ESCAPING = "disable-output-escaping" , ATTRNAME_ELEMENT = "element" , ATTRNAME_ELEMENTS = "elements" , ATTRNAME_EXCLUDE_RESULT_PREFIXES = "exclude-result-prefixes" , ATTRNAME_EXPR = "expr" , ATTRNAME_EXTENSIONELEMENTPREFIXES = "extension-element-prefixes" , ATTRNAME_FORMAT = "format" , ATTRNAME_FROM = "from" , ATTRNAME_GROUPINGSEPARATOR = "grouping-separator" , ATTRNAME_GROUPINGSIZE = "grouping-size" , ATTRNAME_HREF = "href" , ATTRNAME_ID = "id" , ATTRNAME_IMPORTANCE = "importance" , ATTRNAME_INDENTRESULT = "indent-result" , ATTRNAME_INFINITY = "infinity" , ATTRNAME_LANG = "lang" , ATTRNAME_LETTERVALUE = "letter-value" , ATTRNAME_LEVEL = "level" , ATTRNAME_MATCH = "match" , ATTRNAME_METHOD = "calls" , ATTRNAME_MINUSSIGN = "minus-sign" , ATTRNAME_MODE = "mode" , ATTRNAME_NAME = "name" , ATTRNAME_NAMESPACE = "namespace" , ATTRNAME_NAN = "NaN" , ATTRNAME_NDIGITSPERGROUP = "n-digits-per-group" , ATTRNAME_NS = "ns" , ATTRNAME_ONLY = "only" , ATTRNAME_ORDER = "order" , ATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = "cdata-section-elements" , ATTRNAME_OUTPUT_DOCTYPE_PUBLIC = "doctype-public" , ATTRNAME_OUTPUT_DOCTYPE_SYSTEM = "doctype-system" , ATTRNAME_OUTPUT_ENCODING = "encoding" , ATTRNAME_OUTPUT_INDENT = "indent" , ATTRNAME_OUTPUT_MEDIATYPE = "media-type" , ATTRNAME_OUTPUT_METHOD = "method" , ATTRNAME_OUTPUT_OMITXMLDECL = "omit-xml-declaration" , ATTRNAME_OUTPUT_STANDALONE = "standalone" , ATTRNAME_OUTPUT_VERSION = "version" , ATTRNAME_PATTERNSEPARATOR = "pattern-separator" , ATTRNAME_PERCENT = "percent" , ATTRNAME_PERMILLE = "per-mille" , ATTRNAME_PRIORITY = "priority" , ATTRNAME_REFID = "refID" , ATTRNAME_RESULTNS = "result-ns" , ATTRNAME_RESULT_PREFIX = "result-prefix" , ATTRNAME_SELECT = "select" , ATTRNAME_SEQUENCESRC = "sequence-src" , ATTRNAME_STYLE = "style" , ATTRNAME_STYLESHEET_PREFIX = "stylesheet-prefix" , ATTRNAME_TERMINATE = "terminate" , ATTRNAME_TEST = "test" , ATTRNAME_TOSTRING = "to-string" , ATTRNAME_TYPE = "type" , ATTRNAME_USE = "use" , ATTRNAME_USEATTRIBUTESETS = "use-attribute-sets" , ATTRNAME_VALUE = "value" , ATTRNAME_VERSION = "version" , ATTRNAME_XMLNS = "xmlns:" , ATTRNAME_XMLNSDEF = "xmlns" , ATTRNAME_XMLSPACE = "xml:space" , ATTRNAME_ZERODIGIT = "zero-digit" ; public static final int TATTRNAME_OUTPUT_METHOD = 1 , TATTRNAME_AMOUNT = 2 , TATTRNAME_ANCESTOR = 3 , TATTRNAME_ARCHIVE = 4 , TATTRNAME_ATTRIBUTE = 5 , TATTRNAME_ATTRIBUTE_SET = 6 , TATTRNAME_CASEORDER = 7 , TATTRNAME_CLASS = 8 , TATTRNAME_CLASSID = 9 , TATTRNAME_CODEBASE = 10 , TATTRNAME_CODETYPE = 11 , TATTRNAME_CONDITION = 12 , TATTRNAME_COPYTYPE = 13 , TATTRNAME_COUNT = 14 , TATTRNAME_DATATYPE = 15 , TATTRNAME_DEFAULT = 16 , TATTRNAME_DEFAULTSPACE = 17 , TATTRNAME_DEPTH = 18 , TATTRNAME_DIGITGROUPSEP = 19 , TATTRNAME_DISABLE_OUTPUT_ESCAPING = 20 , TATTRNAME_ELEMENT = 21 , TATTRNAME_ELEMENTS = 22 , TATTRNAME_EXPR = 23 , TATTRNAME_EXTENSIONELEMENTPREFIXES = 24 , TATTRNAME_FORMAT = 25 , TATTRNAME_FROM = 26 , TATTRNAME_GROUPINGSEPARATOR = 27 , TATTRNAME_GROUPINGSIZE = 28 , TATTRNAME_HREF = 29 , TATTRNAME_ID = 30 , TATTRNAME_IMPORTANCE = 31 , TATTRNAME_INDENTRESULT = 32 , TATTRNAME_LANG = 33 , TATTRNAME_LETTERVALUE = 34 , TATTRNAME_LEVEL = 35 , TATTRNAME_MATCH = 36 , TATTRNAME_METHOD = 37 , TATTRNAME_MODE = 38 , TATTRNAME_NAME = 39 , TATTRNAME_NAMESPACE = 40 , TATTRNAME_NDIGITSPERGROUP = 41 , TATTRNAME_NS = 42 , TATTRNAME_ONLY = 43 , TATTRNAME_ORDER = 44 , TATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = 45 , TATTRNAME_OUTPUT_DOCTYPE_PUBLIC = 46 , TATTRNAME_OUTPUT_DOCTYPE_SYSTEM = 47 , TATTRNAME_OUTPUT_ENCODING = 48 , TATTRNAME_OUTPUT_INDENT = 49 , TATTRNAME_OUTPUT_MEDIATYPE = 50 , TATTRNAME_OUTPUT_STANDALONE = 51 , TATTRNAME_OUTPUT_VERSION = 52 , TATTRNAME_OUTPUT_OMITXMLDECL = 53 , TATTRNAME_PRIORITY = 54 , TATTRNAME_REFID = 55 , TATTRNAME_RESULTNS = 56 , TATTRNAME_SELECT = 57 , TATTRNAME_SEQUENCESRC = 58 , TATTRNAME_STYLE = 59 , TATTRNAME_TEST = 60 , TATTRNAME_TOSTRING = 61 , TATTRNAME_TYPE = 62 , TATTRNAME_USE = 63 , TATTRNAME_USEATTRIBUTESETS = 64 , TATTRNAME_VALUE = 65 , TATTRNAME_XMLNSDEF = 66 , TATTRNAME_XMLNS = 67 , TATTRNAME_XMLSPACE = 68 , TATTRNAME_EXCLUDE_RESULT_PREFIXES = 69 ; public static final String ATTRVAL_OUTPUT_METHOD_HTML = "html" , ATTRVAL_OUTPUT_METHOD_XML = "xml" , ATTRVAL_OUTPUT_METHOD_TEXT = "text" ; public static final int ATTRVAL_PRESERVE = 1 , ATTRVAL_STRIP = 2 ; public static final boolean ATTRVAL_YES = true , ATTRVAL_NO = false ; public static final String ATTRVAL_ALPHABETIC = "alphabetic" , ATTRVAL_OTHER = "other" , ATTRVAL_TRADITIONAL = "traditional" ; public static final String ATTRVAL_SINGLE = "single" , ATTRVAL_MULTI = "multiple" , ATTRVAL_ANY = "any" ; public static final String ATTRVAL_DEFAULT_PREFIX = "#default" ; public static final int NUMBERLETTER_ALPHABETIC = 1 , NUMBERLETTER_TRADITIONAL = 2 ; public static final int NUMBERLEVEL_SINGLE = 1 , NUMBERLEVEL_MULTI = 2 , NUMBERLEVEL_ANY = 3 , MAX_MULTI_COUNTING_DEPTH = 32 ; public static final String ATTRVAL_THIS = "." , ATTRVAL_PARENT = ".." , ATTRVAL_ANCESTOR = "ancestor" , ATTRVAL_ID = "id" ; public static final String ATTRVAL_DATATYPE_TEXT = "text" , ATTRVAL_DATATYPE_NUMBER = "number" , ATTRVAL_ORDER_ASCENDING = "ascending" , ATTRVAL_ORDER_DESCENDING = "descending" , ATTRVAL_CASEORDER_UPPER = "upper-first" , ATTRVAL_CASEORDER_LOWER = "lower-first" ; public static final int SORTDATATYPE_TEXT = 1 , SORTDATATYPE_NUMBER = 2 ; public static final int SORTORDER_ASCENDING = 1 , SORTORDER_DESCENDING = 2 ; public static final int SORTCASEORDER_UPPERFIRST = 1 , SORTCASEORDER_LOWERFIRST = 2 ; public static final String ATTRVAL_INFINITY = "Infinity" , ATTRVAL_NAN = "NaN" , DEFAULT_DECIMAL_FORMAT = "#default" ; public static final String ATTRNAME_XXXX = "XXXX" ; } 	1	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '338', '0', '0', '0', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemFallback extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_FALLBACK ; } public String getNodeName ( ) { return Constants . ELEMNAME_FALLBACK_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { } public void executeFallback ( TransformerImpl transformer ) throws TransformerException { if ( Constants . ELEMNAME_EXTENSIONCALL == m_parentNode . getXSLToken ( ) ) { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } else { System . out . println ( "Error!  parent of xsl:fallback must be an extension element!" ) ; } } } 	1	['5', '3', '0', '5', '12', '10', '2', '3', '5', '2', '39', '0', '0', '0.98', '0.7', '2', '4', '6.8', '1', '0.8', '2']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . BitSet ; import java . util . Hashtable ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Transformer ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . WrappedRuntimeException ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; abstract public class ToStream extends SerializerBase { private static final String COMMENT_BEGIN = "<!--" ; private static final String COMMENT_END = "-->" ; protected BoolStack m_disableOutputEscapingStates = new BoolStack ( ) ; boolean m_triedToGetConverter = false ; java . lang . reflect . Method m_canConvertMeth ; Object m_charToByteConverter = null ; protected BoolStack m_preserves = new BoolStack ( ) ; protected boolean m_ispreserve = false ; protected boolean m_isprevtext = false ; private static CharInfo m_xmlcharInfo = CharInfo . getCharInfo ( CharInfo . XML_ENTITIES_RESOURCE ) ; protected int m_maxCharacter = Encodings . getLastPrintable ( ) ; protected final char [ ] m_lineSep = System . getProperty ( "line.separator" ) . toCharArray ( ) ; protected final int m_lineSepLen = m_lineSep . length ; protected CharInfo m_charInfo ; private static Hashtable m_charInfos = null ; boolean m_shouldFlush = true ; protected boolean m_spaceBeforeClose = false ; boolean m_startNewLine ; protected boolean m_inDoctype = false ; boolean m_isUTF8 = false ; protected Properties m_format ; protected boolean m_cdataStartCalled = false ; public ToStream ( ) { } protected void closeCDATA ( ) throws org . xml . sax . SAXException { try { m_writer . write ( CDATA_DELIMITER_CLOSE ) ; m_cdataTagOpen = false ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void serialize ( Node node ) throws IOException { try { TreeWalker walker = new TreeWalker ( this , new org . apache . xml . utils . DOM2Helper ( ) ) ; walker . traverse ( node ) ; } catch ( org . xml . sax . SAXException se ) { throw new WrappedRuntimeException ( se ) ; } } static final boolean isUTF16Surrogate ( char c ) { return ( c & 0xFC00 ) == 0xD800 ; } private boolean m_escaping = true ; protected final void flushWriter ( ) throws org . xml . sax . SAXException { if ( null != m_writer ) { try { if ( m_writer instanceof WriterToUTF8Buffered ) { if ( m_shouldFlush ) ( ( WriterToUTF8Buffered ) m_writer ) . flush ( ) ; else ( ( WriterToUTF8Buffered ) m_writer ) . flushBuffer ( ) ; } if ( m_writer instanceof WriterToUTF8 ) { if ( m_shouldFlush ) m_writer . flush ( ) ; } else if ( m_writer instanceof WriterToASCI ) { if ( m_shouldFlush ) m_writer . flush ( ) ; } else { m_writer . flush ( ) ; } } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( ioe ) ; } } } public OutputStream getOutputStream ( ) { if ( m_writer instanceof WriterToUTF8Buffered ) return ( ( WriterToUTF8Buffered ) m_writer ) . getOutputStream ( ) ; if ( m_writer instanceof WriterToUTF8 ) return ( ( WriterToUTF8 ) m_writer ) . getOutputStream ( ) ; else if ( m_writer instanceof WriterToASCI ) return ( ( WriterToASCI ) m_writer ) . getOutputStream ( ) ; else return null ; } public void elementDecl ( String name , String model ) throws SAXException { if ( m_inExternalDTD ) return ; try { if ( m_inDoctype ) { m_writer . write ( " [" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } m_writer . write ( "<!ELEMENT " ) ; m_writer . write ( name ) ; m_writer . write ( ' ' ) ; m_writer . write ( model ) ; m_writer . write ( '>' ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( m_inExternalDTD ) return ; try { if ( m_inDoctype ) { m_writer . write ( " [" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } outputEntityDecl ( name , value ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } void outputEntityDecl ( String name , String value ) throws IOException { m_writer . write ( "<!ENTITY " ) ; m_writer . write ( name ) ; m_writer . write ( " \"" ) ; m_writer . write ( value ) ; m_writer . write ( "\">" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } protected final void outputLineSep ( ) throws IOException { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } public void setOutputFormat ( Properties format ) { boolean shouldFlush = m_shouldFlush ; init ( m_writer , format , false , false ) ; m_shouldFlush = shouldFlush ; } private synchronized void init ( Writer writer , Properties format , boolean defaultProperties , boolean shouldFlush ) { m_shouldFlush = shouldFlush ; if ( m_tracer != null && ! ( writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( writer , m_tracer ) ; else m_writer = writer ; m_format = format ; setCdataSectionElements ( OutputKeys . CDATA_SECTION_ELEMENTS , format ) ; setIndentAmount ( OutputPropertyUtils . getIntProperty ( OutputPropertiesFactory . S_KEY_INDENT_AMOUNT , format ) ) ; setIndent ( OutputPropertyUtils . getBooleanProperty ( OutputKeys . INDENT , format ) ) ; boolean shouldNotWriteXMLHeader = OutputPropertyUtils . getBooleanProperty ( OutputKeys . OMIT_XML_DECLARATION , format ) ; setOmitXMLDeclaration ( shouldNotWriteXMLHeader ) ; setDoctypeSystem ( format . getProperty ( OutputKeys . DOCTYPE_SYSTEM ) ) ; String doctypePublic = format . getProperty ( OutputKeys . DOCTYPE_PUBLIC ) ; setDoctypePublic ( doctypePublic ) ; if ( format . get ( OutputKeys . STANDALONE ) != null ) { String val = format . getProperty ( OutputKeys . STANDALONE ) ; if ( defaultProperties ) setStandaloneInternal ( val ) ; else setStandalone ( val ) ; } setMediaType ( format . getProperty ( OutputKeys . MEDIA_TYPE ) ) ; if ( null != doctypePublic ) { if ( doctypePublic . startsWith ( "-//W3C//DTD XHTML" ) ) m_spaceBeforeClose = true ; } String encoding = getEncoding ( ) ; if ( null == encoding ) { encoding = Encodings . getMimeEncoding ( format . getProperty ( OutputKeys . ENCODING ) ) ; setEncoding ( encoding ) ; } m_isUTF8 = encoding . equals ( Encodings . DEFAULT_MIME_ENCODING ) ; m_maxCharacter = Encodings . getLastPrintable ( encoding ) ; String entitiesFileName = ( String ) format . get ( OutputPropertiesFactory . S_KEY_ENTITIES ) ; if ( null != entitiesFileName ) { m_charInfo = CharInfo . getCharInfo ( entitiesFileName ) ; } } private synchronized void init ( Writer writer , Properties format ) { init ( writer , format , false , false ) ; } protected synchronized void init ( OutputStream output , Properties format , boolean defaultProperties ) throws UnsupportedEncodingException { String encoding = getEncoding ( ) ; if ( encoding == null ) { encoding = Encodings . getMimeEncoding ( format . getProperty ( OutputKeys . ENCODING ) ) ; setEncoding ( encoding ) ; } if ( encoding . equalsIgnoreCase ( "UTF-8" ) ) { m_isUTF8 = true ; if ( output instanceof java . io . BufferedOutputStream ) { init ( new WriterToUTF8 ( output ) , format , defaultProperties , true ) ; } else { init ( new WriterToUTF8Buffered ( output ) , format , defaultProperties , true ) ; } } else if ( encoding . equals ( "WINDOWS-1250" ) || encoding . equals ( "US-ASCII" ) || encoding . equals ( "ASCII" ) ) { init ( new WriterToASCI ( output ) , format , defaultProperties , true ) ; } else { Writer osw ; try { osw = Encodings . getWriter ( output , encoding ) ; } catch ( UnsupportedEncodingException uee ) { System . out . println ( "Warning: encoding \"" + encoding + "\" not supported" + ", using " + Encodings . DEFAULT_MIME_ENCODING ) ; encoding = Encodings . DEFAULT_MIME_ENCODING ; setEncoding ( encoding ) ; osw = Encodings . getWriter ( output , encoding ) ; } m_maxCharacter = Encodings . getLastPrintable ( encoding ) ; init ( osw , format , defaultProperties , true ) ; } } public Properties getOutputFormat ( ) { return m_format ; } public void setWriter ( Writer writer ) { if ( m_tracer != null && ! ( writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( writer , m_tracer ) ; else m_writer = writer ; } public void setOutputStream ( OutputStream output ) { try { Properties format ; if ( null == m_format ) format = OutputPropertiesFactory . getDefaultMethodProperties ( Method . XML ) ; else format = m_format ; init ( output , format , true ) ; } catch ( UnsupportedEncodingException uee ) { } } public boolean setEscaping ( boolean escape ) { final boolean temp = m_escaping ; m_escaping = escape ; return temp ; } public boolean reset ( ) { m_needToCallStartDocument = true ; return false ; } protected void indent ( ) throws IOException { if ( m_startNewLine ) outputLineSep ( ) ; if ( m_indentAmount > 0 ) printSpace ( m_currentElemDepth * m_indentAmount ) ; } private void printSpace ( int n ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { m_writer . write ( ' ' ) ; } } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( m_inExternalDTD ) return ; try { if ( m_inDoctype ) { m_writer . write ( " [" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } m_writer . write ( "<!ATTLIST " ) ; m_writer . write ( eName ) ; m_writer . write ( " " ) ; m_writer . write ( aName ) ; m_writer . write ( " " ) ; m_writer . write ( type ) ; if ( valueDefault != null ) { m_writer . write ( " " ) ; m_writer . write ( valueDefault ) ; } m_writer . write ( ">" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public Writer getWriter ( ) { return m_writer ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { } protected boolean escapingNotNeeded ( char ch ) { if ( ch < 127 ) { if ( ch >= 0x20 || ( 0x0A == ch || 0x0D == ch || 0x09 == ch ) ) return true ; else return false ; } if ( null == m_charToByteConverter && false == m_triedToGetConverter ) { m_triedToGetConverter = true ; try { m_charToByteConverter = Encodings . getCharToByteConverter ( getEncoding ( ) ) ; if ( null != m_charToByteConverter ) { Class argsTypes [ ] = new Class [ 1 ] ; argsTypes [ 0 ] = Character . TYPE ; Class convClass = m_charToByteConverter . getClass ( ) ; m_canConvertMeth = convClass . getMethod ( "canConvert" , argsTypes ) ; } } catch ( Exception e ) { System . err . println ( "Warning: " + e . getMessage ( ) ) ; } } if ( null != m_charToByteConverter ) { try { Object args [ ] = new Object [ 1 ] ; args [ 0 ] = new Character ( ch ) ; Boolean bool = ( Boolean ) m_canConvertMeth . invoke ( m_charToByteConverter , args ) ; return bool . booleanValue ( ) ? ! Character . isISOControl ( ch ) : false ; } catch ( java . lang . reflect . InvocationTargetException ite ) { System . err . println ( "Warning: InvocationTargetException in canConvert!" ) ; } catch ( java . lang . IllegalAccessException iae ) { System . err . println ( "Warning: IllegalAccessException in canConvert!" ) ; } } return ( ch <= m_maxCharacter ) ; } protected int writeUTF16Surrogate ( char c , char ch [ ] , int i , int end ) throws IOException { int surrogateValue = getURF16SurrogateValue ( c , ch , i , end ) ; i ++ ; m_writer . write ( '&' ) ; m_writer . write ( '#' ) ; m_writer . write ( Integer . toString ( surrogateValue ) ) ; m_writer . write ( ';' ) ; return i ; } int getURF16SurrogateValue ( char c , char ch [ ] , int i , int end ) throws IOException { int next ; if ( i + 1 >= end ) { throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ( int ) c ) } ) ) ; } else { next = ch [ ++ i ] ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ( int ) c ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( c - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } return next ; } protected int accumDefaultEntity ( java . io . Writer writer , char ch , int i , char [ ] chars , int len , boolean escLF ) throws IOException { if ( ! escLF && CharInfo . S_LINEFEED == ch ) { writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else { if ( m_charInfo . isSpecial ( ch ) ) { String entityRef = m_charInfo . getEntityNameForChar ( ch ) ; if ( null != entityRef ) { writer . write ( '&' ) ; writer . write ( entityRef ) ; writer . write ( ';' ) ; } else return i ; } else return i ; } return i + 1 ; } void writeNormalizedChars ( char ch [ ] , int start , int length , boolean isCData ) throws IOException , org . xml . sax . SAXException { int end = start + length ; for ( int i = start ; i < end ; i ++ ) { char c = ch [ i ] ; if ( CharInfo . S_LINEFEED == c ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else if ( isCData && ( ! escapingNotNeeded ( c ) ) ) { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( isUTF16Surrogate ( c ) ) { i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { m_writer . write ( "&#" ) ; String intStr = Integer . toString ( ( int ) c ) ; m_writer . write ( intStr ) ; m_writer . write ( ';' ) ; } } else if ( isCData && ( ( i < ( end - 2 ) ) && ( ']' == c ) && ( ']' == ch [ i + 1 ] ) && ( '>' == ch [ i + 2 ] ) ) ) { m_writer . write ( CDATA_CONTINUE ) ; i += 2 ; } else { if ( escapingNotNeeded ( c ) ) { if ( isCData && ! m_cdataTagOpen ) { m_writer . write ( CDATA_DELIMITER_OPEN ) ; m_cdataTagOpen = true ; } m_writer . write ( c ) ; } else if ( isUTF16Surrogate ( c ) ) { if ( m_cdataTagOpen ) closeCDATA ( ) ; i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { if ( m_cdataTagOpen ) closeCDATA ( ) ; m_writer . write ( "&#" ) ; String intStr = Integer . toString ( ( int ) c ) ; m_writer . write ( intStr ) ; m_writer . write ( ';' ) ; } } } } public void endNonEscaping ( ) throws org . xml . sax . SAXException { m_disableOutputEscapingStates . pop ( ) ; } public void startNonEscaping ( ) throws org . xml . sax . SAXException { m_disableOutputEscapingStates . push ( true ) ; } protected void cdata ( char ch [ ] , int start , final int length ) throws org . xml . sax . SAXException { try { final int old_start = start ; if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } m_ispreserve = true ; if ( shouldIndent ( ) ) indent ( ) ; boolean writeCDataBrackets = ( ( ( length >= 1 ) && escapingNotNeeded ( ch [ start ] ) ) ) ; if ( writeCDataBrackets && ! m_cdataTagOpen ) { m_writer . write ( CDATA_DELIMITER_OPEN ) ; m_cdataTagOpen = true ; } if ( isEscapingDisabled ( ) ) { charactersRaw ( ch , start , length ) ; } else writeNormalizedChars ( ch , start , length , true ) ; if ( writeCDataBrackets ) { if ( ch [ start + length - 1 ] == ']' ) closeCDATA ( ) ; } super . fireCDATAEvent ( ch , old_start , length ) ; } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OIERROR , null ) , ioe ) ; } } private boolean isEscapingDisabled ( ) { return m_disableOutputEscapingStates . peekOrFalse ( ) ; } protected void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; try { if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } m_ispreserve = true ; m_writer . write ( ch , start , length ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void characters ( char chars [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( 0 == length ) { super . fireCharEvent ( chars , start , length ) ; return ; } if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; } if ( m_cdataStartCalled || m_cdataSectionStates . peekOrFalse ( ) ) { cdata ( chars , start , length ) ; return ; } if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( m_disableOutputEscapingStates . peekOrFalse ( ) || ( ! m_escaping ) ) { charactersRaw ( chars , start , length ) ; super . fireCharEvent ( chars , start , length ) ; return ; } if ( m_startTagOpen ) closeStartTag ( ) ; int startClean = start ; int lengthClean = 0 ; int end = start + length ; boolean checkWhite = true ; final int maxCharacter = m_maxCharacter ; final BitSet specialsMap = m_charInfo . m_specialsMap ; try { for ( int i = start ; i < end ; i ++ ) { char ch = chars [ i ] ; if ( checkWhite && ( ( ch > 0x20 ) || ! ( ( ch == 0x20 ) || ( ch == 0x09 ) || ( ch == 0xD ) || ( ch == 0xA ) ) ) ) { m_ispreserve = true ; checkWhite = false ; } if ( ( ( ( ch < 127 ) && ( 0x20 <= ch || ( 0x0A == ch || 0x0D == ch || 0x09 == ch ) ) ) && ( ! specialsMap . get ( ch ) ) ) || ( '"' == ch ) ) { lengthClean ++ ; } else if ( ( escapingNotNeeded ( ch ) && ( ! specialsMap . get ( ch ) ) ) || ( '"' == ch ) ) { lengthClean ++ ; } else { if ( lengthClean > 0 ) { m_writer . write ( chars , startClean , lengthClean ) ; lengthClean = 0 ; } if ( CharInfo . S_LINEFEED == ch ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; startClean = i + 1 ; } else { startClean = accumDefaultEscape ( m_writer , ch , i , chars , end , false ) ; i = startClean - 1 ; } } } if ( lengthClean > 0 ) { m_writer . write ( chars , startClean , lengthClean ) ; } m_isprevtext = true ; } catch ( IOException e ) { throw new SAXException ( e ) ; } super . fireCharEvent ( chars , start , length ) ; } public void characters ( String s ) throws org . xml . sax . SAXException { characters ( s . toCharArray ( ) , 0 , s . length ( ) ) ; } protected int accumDefaultEscape ( Writer writer , char ch , int i , char [ ] chars , int len , boolean escLF ) throws IOException { int pos = accumDefaultEntity ( writer , ch , i , chars , len , escLF ) ; if ( i == pos ) { pos ++ ; if ( 0xd800 <= ch && ch < 0xdc00 ) { int next ; if ( i + 1 >= len ) { throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) } ) ) ; } else { next = chars [ ++ i ] ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( ch - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } writer . write ( "&#" ) ; writer . write ( Integer . toString ( next ) ) ; writer . write ( ";" ) ; } else { if ( ! escapingNotNeeded ( ch ) || ( m_charInfo . isSpecial ( ch ) ) ) { writer . write ( "&#" ) ; writer . write ( Integer . toString ( ch ) ) ; writer . write ( ";" ) ; } else { writer . write ( ch ) ; } } } return pos ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } else if ( m_cdataTagOpen ) closeCDATA ( ) ; try { if ( ( true == m_needToOutputDocTypeDecl ) && ( null != getDoctypeSystem ( ) ) ) { outputDocTypeDecl ( name , true ) ; } m_needToOutputDocTypeDecl = false ; if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } if ( namespaceURI != null ) ensurePrefixIsDeclared ( namespaceURI , name ) ; m_elementLocalName = localName ; m_elementURI = namespaceURI ; m_elementName = name ; m_ispreserve = false ; if ( shouldIndent ( ) && m_startNewLine ) { indent ( ) ; } m_startNewLine = true ; m_writer . write ( '<' ) ; m_writer . write ( name ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( atts != null ) addAttributes ( atts ) ; m_startTagOpen = true ; m_currentElemDepth ++ ; m_isprevtext = false ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { startElement ( elementNamespaceURI , elementLocalName , elementName , null ) ; } public void startElement ( String elementName ) throws SAXException { startElement ( null , null , elementName , null ) ; } void outputDocTypeDecl ( String name , boolean closeDecl ) throws SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; try { m_writer . write ( "<!DOCTYPE " ) ; m_writer . write ( name ) ; String doctypePublic = getDoctypePublic ( ) ; if ( null != doctypePublic ) { m_writer . write ( " PUBLIC \"" ) ; m_writer . write ( doctypePublic ) ; m_writer . write ( '\"' ) ; } String doctypeSystem = getDoctypeSystem ( ) ; if ( null != doctypeSystem ) { if ( null == doctypePublic ) m_writer . write ( " SYSTEM \"" ) ; else m_writer . write ( " \"" ) ; m_writer . write ( doctypeSystem ) ; if ( closeDecl ) { m_writer . write ( "\">" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; closeDecl = false ; } else m_writer . write ( '\"' ) ; } boolean dothis = false ; if ( dothis ) { if ( closeDecl ) { m_writer . write ( ">" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } } } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void processAttributes ( ) throws IOException , SAXException { super . fireStartElem ( m_elementName ) ; int nAttrs = 0 ; if ( ( nAttrs = m_attributes . getLength ( ) ) > 0 ) { String encoding = getEncoding ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { final String name = m_attributes . getQName ( i ) ; final String value = m_attributes . getValue ( i ) ; m_writer . write ( ' ' ) ; m_writer . write ( name ) ; m_writer . write ( "=\"" ) ; writeAttrString ( m_writer , value , encoding ) ; m_writer . write ( '\"' ) ; } m_attributes . clear ( ) ; } } public void writeAttrString ( Writer writer , String string , String encoding ) throws IOException { final char [ ] stringChars = string . toCharArray ( ) ; final int len = stringChars . length ; for ( int i = 0 ; i < len ; i ++ ) { char ch = stringChars [ i ] ; if ( escapingNotNeeded ( ch ) && ( ! m_charInfo . isSpecial ( ch ) ) ) { writer . write ( ch ) ; } else { if ( ( CharInfo . S_CARRIAGERETURN == ch ) && ( ( i + 1 ) < len ) && ( CharInfo . S_LINEFEED == stringChars [ i + 1 ] ) ) { i ++ ; ch = CharInfo . S_LINEFEED ; } accumDefaultEscape ( writer , ch , i , stringChars , len , true ) ; } } } public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; m_prefixMap . popNamespaces ( m_currentElemDepth ) ; m_currentElemDepth -- ; try { if ( m_startTagOpen ) { processAttributes ( ) ; if ( m_spaceBeforeClose ) m_writer . write ( " />" ) ; else m_writer . write ( "/>" ) ; } else { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( shouldIndent ( ) ) indent ( ) ; m_writer . write ( '<' ) ; m_writer . write ( '/' ) ; m_writer . write ( name ) ; m_writer . write ( '>' ) ; m_cdataSectionStates . pop ( ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( ! m_startTagOpen ) { m_ispreserve = m_preserves . isEmpty ( ) ? false : m_preserves . pop ( ) ; } m_isprevtext = false ; m_startTagOpen = false ; super . fireEndElem ( name ) ; } public void endElement ( String name ) throws org . xml . sax . SAXException { endElement ( null , null , name ) ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { startPrefixMapping ( prefix , uri , true ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws org . xml . sax . SAXException { boolean pushed ; int pushDepth ; if ( shouldFlush ) { flushPending ( ) ; pushDepth = m_currentElemDepth + 1 ; } else { pushDepth = m_currentElemDepth ; } pushed = m_prefixMap . pushNamespace ( prefix , uri , pushDepth ) ; if ( pushed ) { String name ; if ( EMPTYSTRING . equals ( prefix ) ) { name = "xmlns" ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } else { if ( ! EMPTYSTRING . equals ( uri ) ) { name = "xmlns:" + prefix ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } } } return pushed ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { int start_old = start ; if ( m_inEntityRef ) return ; if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } try { if ( shouldIndent ( ) ) indent ( ) ; final int limit = start + length ; boolean wasDash = false ; if ( m_cdataTagOpen ) closeCDATA ( ) ; m_writer . write ( COMMENT_BEGIN ) ; for ( int i = start ; i < limit ; i ++ ) { if ( wasDash && ch [ i ] == '-' ) { m_writer . write ( ch , start , i - start ) ; m_writer . write ( " -" ) ; start = i + 1 ; } wasDash = ( ch [ i ] == '-' ) ; } if ( length > 0 ) { final int remainingChars = ( limit - start ) ; if ( remainingChars > 0 ) m_writer . write ( ch , start , remainingChars ) ; if ( ch [ limit - 1 ] == '-' ) m_writer . write ( ' ' ) ; } m_writer . write ( COMMENT_END ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } m_startNewLine = true ; super . fireCommentEvent ( ch , start_old , length ) ; } public void endCDATA ( ) throws org . xml . sax . SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; m_cdataStartCalled = false ; } public void endDTD ( ) throws org . xml . sax . SAXException { try { if ( m_needToOutputDocTypeDecl ) { outputDocTypeDecl ( m_elementName , false ) ; m_needToOutputDocTypeDecl = false ; } if ( ! m_inDoctype ) m_writer . write ( "]>" ) ; else { m_writer . write ( '>' ) ; } m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( 0 == length ) return ; characters ( ch , start , length ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { } public void startCDATA ( ) throws org . xml . sax . SAXException { m_cdataStartCalled = true ; } public void startEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( "[dtd]" ) ) m_inExternalDTD = true ; m_inEntityRef = true ; } protected void closeStartTag ( ) throws SAXException { if ( m_startTagOpen ) { try { processAttributes ( ) ; m_writer . write ( '>' ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } pushCdataSectionState ( ) ; m_isprevtext = false ; m_preserves . push ( m_ispreserve ) ; m_startTagOpen = false ; } } public void startDTD ( String name , String publicId , String systemId ) throws org . xml . sax . SAXException { setDoctypeSystem ( systemId ) ; setDoctypePublic ( publicId ) ; m_elementName = name ; m_inDoctype = true ; } public int getIndentAmount ( ) { return m_indentAmount ; } public void setIndentAmount ( int m_indentAmount ) { this . m_indentAmount = m_indentAmount ; } protected boolean shouldIndent ( ) { return m_doIndent && ( ! m_ispreserve && ! m_isprevtext ) ; } private void setCdataSectionElements ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null != s ) { Vector v = new Vector ( ) ; int l = s . length ( ) ; boolean inCurly = false ; FastStringBuffer buf = new FastStringBuffer ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char c = s . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! inCurly ) { if ( buf . length ( ) > 0 ) { addCdataSectionElement ( buf . toString ( ) , v ) ; buf . reset ( ) ; } continue ; } } else if ( '{' == c ) inCurly = true ; else if ( '}' == c ) inCurly = false ; buf . append ( c ) ; } if ( buf . length ( ) > 0 ) { addCdataSectionElement ( buf . toString ( ) , v ) ; buf . reset ( ) ; } setCdataSectionElements ( v ) ; } } private void addCdataSectionElement ( String URI_and_localName , Vector v ) { StringTokenizer tokenizer = new StringTokenizer ( URI_and_localName , "{}" , false ) ; QName qname ; String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == s2 ) { v . addElement ( null ) ; v . addElement ( s1 ) ; } else { v . addElement ( s1 ) ; v . addElement ( s2 ) ; } } public void setCdataSectionElements ( Vector URI_and_localNames ) { m_cdataSectionElements = URI_and_localNames ; } protected String ensureAttributesNamespaceIsDeclared ( String ns , String localName , String rawName ) throws org . xml . sax . SAXException { if ( ns != null && ns . length ( ) > 0 ) { int index = 0 ; String prefixFromRawName = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; if ( index > 0 ) { String uri = m_prefixMap . lookupNamespace ( prefixFromRawName ) ; if ( uri != null && uri . equals ( ns ) ) { return null ; } else { this . startPrefixMapping ( prefixFromRawName , ns , false ) ; this . addAttribute ( "http://www.w3.org/2000/xmlns/" , prefixFromRawName , "xmlns:" + prefixFromRawName , "CDATA" , ns ) ; return prefixFromRawName ; } } else { String prefix = m_prefixMap . lookupPrefix ( ns ) ; if ( prefix == null ) { prefix = m_prefixMap . generateNextPrefix ( ) ; this . startPrefixMapping ( prefix , ns , false ) ; this . addAttribute ( "http://www.w3.org/2000/xmlns/" , prefix , "xmlns:" + prefix , "CDATA" , ns ) ; } return prefix ; } } return null ; } private void ensurePrefixIsDeclared ( String ns , String rawName ) throws org . xml . sax . SAXException { if ( ns != null && ns . length ( ) > 0 ) { int index ; String prefix = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; if ( null != prefix ) { String foundURI = m_prefixMap . lookupNamespace ( prefix ) ; if ( ( null == foundURI ) || ! foundURI . equals ( ns ) ) { this . startPrefixMapping ( prefix , ns ) ; this . addAttributeAlways ( "http://www.w3.org/2000/xmlns/" , prefix , "xmlns" + ( prefix . length ( ) == 0 ? "" : ":" ) + prefix , "CDATA" , ns ) ; } } } } public void flushPending ( ) { try { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = false ; } } catch ( SAXException e ) { } } public void setContentHandler ( ContentHandler ch ) { } public void addAttributeAlways ( String uri , String localName , String rawName , String type , String value ) { int index ; index = m_attributes . getIndex ( rawName ) ; if ( index >= 0 ) { String old_value = null ; if ( m_tracer != null ) { old_value = m_attributes . getValue ( index ) ; if ( value . equals ( old_value ) ) old_value = null ; } m_attributes . setValue ( index , value ) ; if ( old_value != null ) firePseudoAttributes ( ) ; } else { m_attributes . addAttribute ( uri , localName , rawName , type , value ) ; if ( m_tracer != null ) firePseudoAttributes ( ) ; } } protected void firePseudoAttributes ( ) { int nAttrs ; if ( m_tracer != null && ( nAttrs = m_attributes . getLength ( ) ) > 0 ) { String encoding = getEncoding ( ) ; StringBuffer sb = new StringBuffer ( ) ; java . io . Writer writer = new ToStream . WritertoStringBuffer ( sb ) ; try { for ( int i = 0 ; i < nAttrs ; i ++ ) { final String name = m_attributes . getQName ( i ) ; final String value = m_attributes . getValue ( i ) ; sb . append ( ' ' ) ; sb . append ( name ) ; sb . append ( "=\"" ) ; writeAttrString ( writer , value , encoding ) ; sb . append ( '\"' ) ; } } catch ( IOException ioe ) { } char ch [ ] = sb . toString ( ) . toCharArray ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS , ch , 0 , ch . length ) ; } } private class WritertoStringBuffer extends java . io . Writer { final private StringBuffer m_stringbuf ; WritertoStringBuffer ( StringBuffer sb ) { m_stringbuf = sb ; } public void write ( char [ ] arg0 , int arg1 , int arg2 ) throws IOException { m_stringbuf . append ( arg0 , arg1 , arg2 ) ; } public void flush ( ) throws IOException { } public void close ( ) throws IOException { } public void write ( int i ) { m_stringbuf . append ( ( char ) i ) ; } public void write ( String s ) { m_stringbuf . append ( s ) ; } } public void setTransformer ( Transformer transformer ) { super . setTransformer ( transformer ) ; if ( m_tracer != null && ! ( m_writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( m_writer , m_tracer ) ; } } 	1	['71', '2', '3', '23', '181', '1581', '4', '20', '43', '0.878881988', '2909', '0.739130435', '4', '0.557692308', '0.151020408', '2', '11', '39.64788732', '12', '1.662', '6']
package org . apache . xml . utils ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; public abstract class Hashtree2Node { public static void appendHashToNode ( Hashtable hash , String name , Node container , Document factory ) { if ( ( null == container ) || ( null == factory ) || ( null == hash ) ) { return ; } String elemName = null ; if ( ( null == name ) || ( "" . equals ( name ) ) ) elemName = "appendHashToNode" ; else elemName = name ; try { Element hashNode = factory . createElement ( elemName ) ; container . appendChild ( hashNode ) ; Enumeration enum = hash . keys ( ) ; Vector v = new Vector ( ) ; while ( enum . hasMoreElements ( ) ) { Object key = enum . nextElement ( ) ; String keyStr = key . toString ( ) ; Object item = hash . get ( key ) ; if ( item instanceof Hashtable ) { v . addElement ( keyStr ) ; v . addElement ( ( Hashtable ) item ) ; } else { try { Element node = factory . createElement ( "item" ) ; node . setAttribute ( "key" , keyStr ) ; node . appendChild ( factory . createTextNode ( ( String ) item ) ) ; hashNode . appendChild ( node ) ; } catch ( Exception e ) { Element node = factory . createElement ( "item" ) ; node . setAttribute ( "key" , keyStr ) ; node . appendChild ( factory . createTextNode ( "ERROR: Reading " + key + " threw: " + e . toString ( ) ) ) ; hashNode . appendChild ( node ) ; } } } enum = v . elements ( ) ; while ( enum . hasMoreElements ( ) ) { String n = ( String ) enum . nextElement ( ) ; Hashtable h = ( Hashtable ) enum . nextElement ( ) ; appendHashToNode ( h , n , hashNode , factory ) ; } } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; } } } 	1	['2', '1', '0', '1', '23', '1', '1', '0', '2', '2', '145', '0', '0', '0', '0.5', '0', '0', '71.5', '8', '4', '2']
package org . apache . xalan . transformer ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Properties ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; import org . apache . xml . serializer . Method ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xml . utils . DOMBuilder ; import org . apache . xml . utils . TreeWalker ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . XMLReaderFactory ; public class TransformerIdentityImpl extends Transformer implements TransformerHandler , DeclHandler { public TransformerIdentityImpl ( ) { m_outputFormat = new OutputProperties ( Method . XML ) ; } public void setResult ( Result result ) throws IllegalArgumentException { if ( null == result ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_RESULT_NULL , null ) ) ; m_result = result ; } public void setSystemId ( String systemID ) { m_systemID = systemID ; } public String getSystemId ( ) { return m_systemID ; } public Transformer getTransformer ( ) { return this ; } private void createResultContentHandler ( Result outputTarget ) throws TransformerException { if ( outputTarget instanceof SAXResult ) { SAXResult saxResult = ( SAXResult ) outputTarget ; m_resultContentHandler = saxResult . getHandler ( ) ; m_resultLexicalHandler = saxResult . getLexicalHandler ( ) ; if ( m_resultContentHandler instanceof Serializer ) { m_serializer = ( Serializer ) m_resultContentHandler ; } } else if ( outputTarget instanceof DOMResult ) { DOMResult domResult = ( DOMResult ) outputTarget ; Node outputNode = domResult . getNode ( ) ; Document doc ; short type ; if ( null != outputNode ) { type = outputNode . getNodeType ( ) ; doc = ( Node . DOCUMENT_NODE == type ) ? ( Document ) outputNode : outputNode . getOwnerDocument ( ) ; } else { try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; doc = db . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new TransformerException ( pce ) ; } outputNode = doc ; type = outputNode . getNodeType ( ) ; ( ( DOMResult ) outputTarget ) . setNode ( outputNode ) ; } m_resultContentHandler = ( Node . DOCUMENT_FRAGMENT_NODE == type ) ? new DOMBuilder ( doc , ( DocumentFragment ) outputNode ) : new DOMBuilder ( doc , outputNode ) ; m_resultLexicalHandler = ( LexicalHandler ) m_resultContentHandler ; } else if ( outputTarget instanceof StreamResult ) { StreamResult sresult = ( StreamResult ) outputTarget ; String method = m_outputFormat . getProperty ( OutputKeys . METHOD ) ; try { Serializer serializer = SerializerFactory . getSerializer ( m_outputFormat . getProperties ( ) ) ; m_serializer = serializer ; if ( null != sresult . getWriter ( ) ) serializer . setWriter ( sresult . getWriter ( ) ) ; else if ( null != sresult . getOutputStream ( ) ) serializer . setOutputStream ( sresult . getOutputStream ( ) ) ; else if ( null != sresult . getSystemId ( ) ) { String fileURL = sresult . getSystemId ( ) ; if ( fileURL . startsWith ( "file:///" ) ) { if ( fileURL . substring ( 8 ) . indexOf ( ":" ) > 0 ) fileURL = fileURL . substring ( 8 ) ; else fileURL = fileURL . substring ( 7 ) ; } m_outputStream = new java . io . FileOutputStream ( fileURL ) ; serializer . setOutputStream ( m_outputStream ) ; } else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_OUTPUT_SPECIFIED , null ) ) ; m_resultContentHandler = serializer . asContentHandler ( ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , new Object [ ] { outputTarget . getClass ( ) . getName ( ) } ) ) ; } if ( m_resultContentHandler instanceof DTDHandler ) m_resultDTDHandler = ( DTDHandler ) m_resultContentHandler ; if ( m_resultContentHandler instanceof DeclHandler ) m_resultDeclHandler = ( DeclHandler ) m_resultContentHandler ; if ( m_resultContentHandler instanceof LexicalHandler ) m_resultLexicalHandler = ( LexicalHandler ) m_resultContentHandler ; } public void transform ( Source source , Result outputTarget ) throws TransformerException { createResultContentHandler ( outputTarget ) ; try { if ( source instanceof DOMSource ) { DOMSource dsource = ( DOMSource ) source ; m_systemID = dsource . getSystemId ( ) ; Node dNode = dsource . getNode ( ) ; if ( null != dNode ) { try { if ( dNode . getNodeType ( ) != Node . DOCUMENT_NODE ) this . startDocument ( ) ; try { if ( dNode . getNodeType ( ) == Node . ATTRIBUTE_NODE ) { String data = dNode . getNodeValue ( ) ; char [ ] chars = data . toCharArray ( ) ; characters ( chars , 0 , chars . length ) ; } else { TreeWalker walker = new TreeWalker ( this , new org . apache . xml . utils . DOM2Helper ( ) , m_systemID ) ; walker . traverse ( dNode ) ; } } finally { if ( dNode . getNodeType ( ) != Node . DOCUMENT_NODE ) this . endDocument ( ) ; } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } return ; } else { String messageStr = XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_DOMSOURCE_INPUT , null ) ; throw new IllegalArgumentException ( messageStr ) ; } } InputSource xmlSource = SAXSource . sourceToInputSource ( source ) ; if ( null == xmlSource ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_TRANSFORM_SOURCE_TYPE , new Object [ ] { source . getClass ( ) . getName ( ) } ) ) ; } if ( null != xmlSource . getSystemId ( ) ) m_systemID = xmlSource . getSystemId ( ) ; try { XMLReader reader = null ; if ( source instanceof SAXSource ) reader = ( ( SAXSource ) source ) . getXMLReader ( ) ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } ContentHandler inputHandler = this ; reader . setContentHandler ( inputHandler ) ; if ( inputHandler instanceof org . xml . sax . DTDHandler ) reader . setDTDHandler ( ( org . xml . sax . DTDHandler ) inputHandler ) ; try { if ( inputHandler instanceof org . xml . sax . ext . LexicalHandler ) reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , inputHandler ) ; if ( inputHandler instanceof org . xml . sax . ext . DeclHandler ) reader . setProperty ( "http://xml.org/sax/properties/declaration-handler" , inputHandler ) ; } catch ( org . xml . sax . SAXException se ) { } try { if ( inputHandler instanceof org . xml . sax . ext . LexicalHandler ) reader . setProperty ( "http://xml.org/sax/handlers/LexicalHandler" , inputHandler ) ; if ( inputHandler instanceof org . xml . sax . ext . DeclHandler ) reader . setProperty ( "http://xml.org/sax/handlers/DeclHandler" , inputHandler ) ; } catch ( org . xml . sax . SAXNotRecognizedException snre ) { } reader . parse ( xmlSource ) ; } catch ( org . apache . xml . utils . WrappedRuntimeException wre ) { Throwable throwable = wre . getException ( ) ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } throw new TransformerException ( wre . getException ( ) ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } finally { if ( null != m_outputStream ) { try { m_outputStream . close ( ) ; } catch ( IOException ioe ) { } m_outputStream = null ; } } } public void setParameter ( String name , Object value ) { if ( null == m_params ) { m_params = new Hashtable ( ) ; } m_params . put ( name , value ) ; } public Object getParameter ( String name ) { if ( null == m_params ) return null ; return m_params . get ( name ) ; } public void clearParameters ( ) { if ( null == m_params ) return ; m_params . clear ( ) ; } public void setURIResolver ( URIResolver resolver ) { m_URIResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_URIResolver ; } public void setOutputProperties ( Properties oformat ) throws IllegalArgumentException { if ( null != oformat ) { String method = ( String ) oformat . get ( OutputKeys . METHOD ) ; if ( null != method ) m_outputFormat = new OutputProperties ( method ) ; else m_outputFormat = new OutputProperties ( ) ; } if ( null != oformat ) { m_outputFormat . copyFrom ( oformat ) ; } } public Properties getOutputProperties ( ) { return ( Properties ) m_outputFormat . getProperties ( ) . clone ( ) ; } public void setOutputProperty ( String name , String value ) throws IllegalArgumentException { if ( ! m_outputFormat . isLegalPropertyKey ( name ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; m_outputFormat . setProperty ( name , value ) ; } public String getOutputProperty ( String name ) throws IllegalArgumentException { String value = null ; OutputProperties props = m_outputFormat ; value = props . getProperty ( name ) ; if ( null == value ) { if ( ! props . isLegalPropertyKey ( name ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; } return value ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NULL_ERROR_HANDLER , null ) ) ; else m_errorListener = listener ; } public ErrorListener getErrorListener ( ) { return m_errorListener ; } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( null != m_resultDTDHandler ) m_resultDTDHandler . notationDecl ( name , publicId , systemId ) ; } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( null != m_resultDTDHandler ) m_resultDTDHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } public void setDocumentLocator ( Locator locator ) { try { if ( null == m_resultContentHandler ) createResultContentHandler ( m_result ) ; } catch ( TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } m_resultContentHandler . setDocumentLocator ( locator ) ; } public void startDocument ( ) throws SAXException { try { if ( null == m_resultContentHandler ) createResultContentHandler ( m_result ) ; } catch ( TransformerException te ) { throw new SAXException ( te . getMessage ( ) , te ) ; } m_flushedStartDoc = false ; m_foundFirstElement = false ; } boolean m_flushedStartDoc = false ; protected final void flushStartDoc ( ) throws SAXException { if ( ! m_flushedStartDoc ) { if ( m_resultContentHandler == null ) { try { createResultContentHandler ( m_result ) ; } catch ( TransformerException te ) { throw new SAXException ( te ) ; } } m_resultContentHandler . startDocument ( ) ; m_flushedStartDoc = true ; } } public void endDocument ( ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . endDocument ( ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . endPrefixMapping ( prefix ) ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( ! m_foundFirstElement && null != m_serializer ) { m_foundFirstElement = true ; Serializer newSerializer ; try { newSerializer = SerializerSwitcher . switchSerializerIfHTML ( uri , localName , m_outputFormat . getProperties ( ) , m_serializer ) ; } catch ( TransformerException te ) { throw new SAXException ( te ) ; } if ( newSerializer != m_serializer ) { try { m_resultContentHandler = newSerializer . asContentHandler ( ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } if ( m_resultContentHandler instanceof DTDHandler ) m_resultDTDHandler = ( DTDHandler ) m_resultContentHandler ; if ( m_resultContentHandler instanceof LexicalHandler ) m_resultLexicalHandler = ( LexicalHandler ) m_resultContentHandler ; m_serializer = newSerializer ; } } flushStartDoc ( ) ; m_resultContentHandler . startElement ( uri , localName , qName , attributes ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { m_resultContentHandler . endElement ( uri , localName , qName ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . characters ( ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { m_resultContentHandler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . processingInstruction ( target , data ) ; } public void skippedEntity ( String name ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . skippedEntity ( name ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { flushStartDoc ( ) ; if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . startDTD ( name , publicId , systemId ) ; } public void endDTD ( ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . endDTD ( ) ; } public void startEntity ( String name ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . startEntity ( name ) ; } public void endEntity ( String name ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . endEntity ( name ) ; } public void startCDATA ( ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . startCDATA ( ) ; } public void endCDATA ( ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . endCDATA ( ) ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { flushStartDoc ( ) ; if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . comment ( ch , start , length ) ; } public void elementDecl ( String name , String model ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . elementDecl ( name , model ) ; } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . attributeDecl ( eName , aName , type , valueDefault , value ) ; } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . internalEntityDecl ( name , value ) ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . externalEntityDecl ( name , publicId , systemId ) ; } private java . io . FileOutputStream m_outputStream = null ; private ContentHandler m_resultContentHandler ; private LexicalHandler m_resultLexicalHandler ; private DTDHandler m_resultDTDHandler ; private DeclHandler m_resultDeclHandler ; private Serializer m_serializer ; private Result m_result ; private String m_systemID ; private Hashtable m_params ; private ErrorListener m_errorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; URIResolver m_URIResolver ; private OutputProperties m_outputFormat ; boolean m_foundFirstElement ; } 	1	['43', '2', '0', '12', '140', '573', '1', '11', '41', '0.755102041', '1105', '0.785714286', '2', '0.236363636', '0.153100775', '0', '0', '24.37209302', '2', '1.0465', '4']
package org . apache . xml . utils ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Attr ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . Entity ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; public class DOMHelper { public static Document createDocument ( ) { try { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setNamespaceAware ( true ) ; dfactory . setValidating ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Document outNode = docBuilder . newDocument ( ) ; return outNode ; } catch ( ParserConfigurationException pce ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CREATEDOCUMENT_NOT_SUPPORTED , null ) ) ; } } public boolean shouldStripSourceNode ( Node textNode ) throws javax . xml . transform . TransformerException { return false ; } public String getUniqueID ( Node node ) { return "N" + Integer . toHexString ( node . hashCode ( ) ) . toUpperCase ( ) ; } public static boolean isNodeAfter ( Node node1 , Node node2 ) { if ( node1 == node2 || isNodeTheSame ( node1 , node2 ) ) return true ; boolean isNodeAfter = true ; Node parent1 = getParentOfNode ( node1 ) ; Node parent2 = getParentOfNode ( node2 ) ; if ( parent1 == parent2 || isNodeTheSame ( parent1 , parent2 ) ) { if ( null != parent1 ) isNodeAfter = isNodeAfterSibling ( parent1 , node1 , node2 ) ; else { } } else { int nParents1 = 2 , nParents2 = 2 ; while ( parent1 != null ) { nParents1 ++ ; parent1 = getParentOfNode ( parent1 ) ; } while ( parent2 != null ) { nParents2 ++ ; parent2 = getParentOfNode ( parent2 ) ; } Node startNode1 = node1 , startNode2 = node2 ; if ( nParents1 < nParents2 ) { int adjust = nParents2 - nParents1 ; for ( int i = 0 ; i < adjust ; i ++ ) { startNode2 = getParentOfNode ( startNode2 ) ; } } else if ( nParents1 > nParents2 ) { int adjust = nParents1 - nParents2 ; for ( int i = 0 ; i < adjust ; i ++ ) { startNode1 = getParentOfNode ( startNode1 ) ; } } Node prevChild1 = null , prevChild2 = null ; while ( null != startNode1 ) { if ( startNode1 == startNode2 || isNodeTheSame ( startNode1 , startNode2 ) ) { if ( null == prevChild1 ) { isNodeAfter = ( nParents1 < nParents2 ) ? true : false ; break ; } else { isNodeAfter = isNodeAfterSibling ( startNode1 , prevChild1 , prevChild2 ) ; break ; } } prevChild1 = startNode1 ; startNode1 = getParentOfNode ( startNode1 ) ; prevChild2 = startNode2 ; startNode2 = getParentOfNode ( startNode2 ) ; } } return isNodeAfter ; } public static boolean isNodeTheSame ( Node node1 , Node node2 ) { if ( node1 instanceof DTMNodeProxy && node2 instanceof DTMNodeProxy ) return ( ( DTMNodeProxy ) node1 ) . equals ( ( DTMNodeProxy ) node2 ) ; else return ( node1 == node2 ) ; } private static boolean isNodeAfterSibling ( Node parent , Node child1 , Node child2 ) { boolean isNodeAfterSibling = false ; short child1type = child1 . getNodeType ( ) ; short child2type = child2 . getNodeType ( ) ; if ( ( Node . ATTRIBUTE_NODE != child1type ) && ( Node . ATTRIBUTE_NODE == child2type ) ) { isNodeAfterSibling = false ; } else if ( ( Node . ATTRIBUTE_NODE == child1type ) && ( Node . ATTRIBUTE_NODE != child2type ) ) { isNodeAfterSibling = true ; } else if ( Node . ATTRIBUTE_NODE == child1type ) { NamedNodeMap children = parent . getAttributes ( ) ; int nNodes = children . getLength ( ) ; boolean found1 = false , found2 = false ; for ( int i = 0 ; i < nNodes ; i ++ ) { Node child = children . item ( i ) ; if ( child1 == child || isNodeTheSame ( child1 , child ) ) { if ( found2 ) { isNodeAfterSibling = false ; break ; } found1 = true ; } else if ( child2 == child || isNodeTheSame ( child2 , child ) ) { if ( found1 ) { isNodeAfterSibling = true ; break ; } found2 = true ; } } } else { Node child = parent . getFirstChild ( ) ; boolean found1 = false , found2 = false ; while ( null != child ) { if ( child1 == child || isNodeTheSame ( child1 , child ) ) { if ( found2 ) { isNodeAfterSibling = false ; break ; } found1 = true ; } else if ( child2 == child || isNodeTheSame ( child2 , child ) ) { if ( found1 ) { isNodeAfterSibling = true ; break ; } found2 = true ; } child = child . getNextSibling ( ) ; } } return isNodeAfterSibling ; } public short getLevel ( Node n ) { short level = 1 ; while ( null != ( n = getParentOfNode ( n ) ) ) { level ++ ; } return level ; } public String getNamespaceForPrefix ( String prefix , Element namespaceContext ) { int type ; Node parent = namespaceContext ; String namespace = null ; if ( prefix . equals ( "xml" ) ) { namespace = QName . S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { namespace = "http://www.w3.org/2000/xmlns/" ; } else { String declname = ( prefix == "" ) ? "xmlns" : "xmlns:" + prefix ; while ( ( null != parent ) && ( null == namespace ) && ( ( ( type = parent . getNodeType ( ) ) == Node . ELEMENT_NODE ) || ( type == Node . ENTITY_REFERENCE_NODE ) ) ) { if ( type == Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) parent ) . getAttributeNode ( declname ) ; if ( attr != null ) { namespace = attr . getNodeValue ( ) ; break ; } } parent = getParentOfNode ( parent ) ; } } return namespace ; } Hashtable m_NSInfos = new Hashtable ( ) ; protected static final NSInfo m_NSInfoUnProcWithXMLNS = new NSInfo ( false , true ) ; protected static final NSInfo m_NSInfoUnProcWithoutXMLNS = new NSInfo ( false , false ) ; protected static final NSInfo m_NSInfoUnProcNoAncestorXMLNS = new NSInfo ( false , false , NSInfo . ANCESTORNOXMLNS ) ; protected static final NSInfo m_NSInfoNullWithXMLNS = new NSInfo ( true , true ) ; protected static final NSInfo m_NSInfoNullWithoutXMLNS = new NSInfo ( true , false ) ; protected static final NSInfo m_NSInfoNullNoAncestorXMLNS = new NSInfo ( true , false , NSInfo . ANCESTORNOXMLNS ) ; protected Vector m_candidateNoAncestorXMLNS = new Vector ( ) ; public String getNamespaceOfNode ( Node n ) { String namespaceOfPrefix ; boolean hasProcessedNS ; NSInfo nsInfo ; short ntype = n . getNodeType ( ) ; if ( Node . ATTRIBUTE_NODE != ntype ) { Object nsObj = m_NSInfos . get ( n ) ; nsInfo = ( nsObj == null ) ? null : ( NSInfo ) nsObj ; hasProcessedNS = ( nsInfo == null ) ? false : nsInfo . m_hasProcessedNS ; } else { hasProcessedNS = false ; nsInfo = null ; } if ( hasProcessedNS ) { namespaceOfPrefix = nsInfo . m_namespace ; } else { namespaceOfPrefix = null ; String nodeName = n . getNodeName ( ) ; int indexOfNSSep = nodeName . indexOf ( ':' ) ; String prefix ; if ( Node . ATTRIBUTE_NODE == ntype ) { if ( indexOfNSSep > 0 ) { prefix = nodeName . substring ( 0 , indexOfNSSep ) ; } else { return namespaceOfPrefix ; } } else { prefix = ( indexOfNSSep >= 0 ) ? nodeName . substring ( 0 , indexOfNSSep ) : "" ; } boolean ancestorsHaveXMLNS = false ; boolean nHasXMLNS = false ; if ( prefix . equals ( "xml" ) ) { namespaceOfPrefix = QName . S_XMLNAMESPACEURI ; } else { int parentType ; Node parent = n ; while ( ( null != parent ) && ( null == namespaceOfPrefix ) ) { if ( ( null != nsInfo ) && ( nsInfo . m_ancestorHasXMLNSAttrs == NSInfo . ANCESTORNOXMLNS ) ) { break ; } parentType = parent . getNodeType ( ) ; if ( ( null == nsInfo ) || nsInfo . m_hasXMLNSAttrs ) { boolean elementHasXMLNS = false ; if ( parentType == Node . ELEMENT_NODE ) { NamedNodeMap nnm = parent . getAttributes ( ) ; for ( int i = 0 ; i < nnm . getLength ( ) ; i ++ ) { Node attr = nnm . item ( i ) ; String aname = attr . getNodeName ( ) ; if ( aname . charAt ( 0 ) == 'x' ) { boolean isPrefix = aname . startsWith ( "xmlns:" ) ; if ( aname . equals ( "xmlns" ) || isPrefix ) { if ( n == parent ) nHasXMLNS = true ; elementHasXMLNS = true ; ancestorsHaveXMLNS = true ; String p = isPrefix ? aname . substring ( 6 ) : "" ; if ( p . equals ( prefix ) ) { namespaceOfPrefix = attr . getNodeValue ( ) ; break ; } } } } } if ( ( Node . ATTRIBUTE_NODE != parentType ) && ( null == nsInfo ) && ( n != parent ) ) { nsInfo = elementHasXMLNS ? m_NSInfoUnProcWithXMLNS : m_NSInfoUnProcWithoutXMLNS ; m_NSInfos . put ( parent , nsInfo ) ; } } if ( Node . ATTRIBUTE_NODE == parentType ) { parent = getParentOfNode ( parent ) ; } else { m_candidateNoAncestorXMLNS . addElement ( parent ) ; m_candidateNoAncestorXMLNS . addElement ( nsInfo ) ; parent = parent . getParentNode ( ) ; } if ( null != parent ) { Object nsObj = m_NSInfos . get ( parent ) ; nsInfo = ( nsObj == null ) ? null : ( NSInfo ) nsObj ; } } int nCandidates = m_candidateNoAncestorXMLNS . size ( ) ; if ( nCandidates > 0 ) { if ( ( false == ancestorsHaveXMLNS ) && ( null == parent ) ) { for ( int i = 0 ; i < nCandidates ; i += 2 ) { Object candidateInfo = m_candidateNoAncestorXMLNS . elementAt ( i + 1 ) ; if ( candidateInfo == m_NSInfoUnProcWithoutXMLNS ) { m_NSInfos . put ( m_candidateNoAncestorXMLNS . elementAt ( i ) , m_NSInfoUnProcNoAncestorXMLNS ) ; } else if ( candidateInfo == m_NSInfoNullWithoutXMLNS ) { m_NSInfos . put ( m_candidateNoAncestorXMLNS . elementAt ( i ) , m_NSInfoNullNoAncestorXMLNS ) ; } } } m_candidateNoAncestorXMLNS . removeAllElements ( ) ; } } if ( Node . ATTRIBUTE_NODE != ntype ) { if ( null == namespaceOfPrefix ) { if ( ancestorsHaveXMLNS ) { if ( nHasXMLNS ) m_NSInfos . put ( n , m_NSInfoNullWithXMLNS ) ; else m_NSInfos . put ( n , m_NSInfoNullWithoutXMLNS ) ; } else { m_NSInfos . put ( n , m_NSInfoNullNoAncestorXMLNS ) ; } } else { m_NSInfos . put ( n , new NSInfo ( namespaceOfPrefix , nHasXMLNS ) ) ; } } } return namespaceOfPrefix ; } public String getLocalNameOfNode ( Node n ) { String qname = n . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; return ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } public String getExpandedElementName ( Element elem ) { String namespace = getNamespaceOfNode ( elem ) ; return ( null != namespace ) ? namespace + ":" + getLocalNameOfNode ( elem ) : getLocalNameOfNode ( elem ) ; } public String getExpandedAttributeName ( Attr attr ) { String namespace = getNamespaceOfNode ( attr ) ; return ( null != namespace ) ? namespace + ":" + getLocalNameOfNode ( attr ) : getLocalNameOfNode ( attr ) ; } public boolean isIgnorableWhitespace ( Text node ) { boolean isIgnorable = false ; return isIgnorable ; } public Node getRoot ( Node node ) { Node root = null ; while ( node != null ) { root = node ; node = getParentOfNode ( node ) ; } return root ; } public Node getRootNode ( Node n ) { int nt = n . getNodeType ( ) ; return ( ( Node . DOCUMENT_NODE == nt ) || ( Node . DOCUMENT_FRAGMENT_NODE == nt ) ) ? n : n . getOwnerDocument ( ) ; } public boolean isNamespaceNode ( Node n ) { if ( Node . ATTRIBUTE_NODE == n . getNodeType ( ) ) { String attrName = n . getNodeName ( ) ; return ( attrName . startsWith ( "xmlns:" ) || attrName . equals ( "xmlns" ) ) ; } return false ; } public static Node getParentOfNode ( Node node ) throws RuntimeException { Node parent ; short nodeType = node . getNodeType ( ) ; if ( Node . ATTRIBUTE_NODE == nodeType ) { Document doc = node . getOwnerDocument ( ) ; DOMImplementation impl = doc . getImplementation ( ) ; if ( impl != null && impl . hasFeature ( "Core" , "2.0" ) ) { parent = ( ( Attr ) node ) . getOwnerElement ( ) ; return parent ; } Element rootElem = doc . getDocumentElement ( ) ; if ( null == rootElem ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , null ) ) ; } parent = locateAttrParent ( rootElem , node ) ; } else { parent = node . getParentNode ( ) ; } return parent ; } public Element getElementByID ( String id , Document doc ) { return null ; } public String getUnparsedEntityURI ( String name , Document doc ) { String url = "" ; DocumentType doctype = doc . getDoctype ( ) ; if ( null != doctype ) { NamedNodeMap entities = doctype . getEntities ( ) ; if ( null == entities ) return url ; Entity entity = ( Entity ) entities . getNamedItem ( name ) ; if ( null == entity ) return url ; String notationName = entity . getNotationName ( ) ; if ( null != notationName ) { url = entity . getSystemId ( ) ; if ( null == url ) { url = entity . getPublicId ( ) ; } else { } } } return url ; } private static Node locateAttrParent ( Element elem , Node attr ) { Node parent = null ; Attr check = elem . getAttributeNode ( attr . getNodeName ( ) ) ; if ( check == attr ) parent = elem ; if ( null == parent ) { for ( Node node = elem . getFirstChild ( ) ; null != node ; node = node . getNextSibling ( ) ) { if ( Node . ELEMENT_NODE == node . getNodeType ( ) ) { parent = locateAttrParent ( ( Element ) node , attr ) ; if ( null != parent ) break ; } } } return parent ; } protected Document m_DOMFactory = null ; public void setDOMFactory ( Document domFactory ) { this . m_DOMFactory = domFactory ; } public Document getDOMFactory ( ) { if ( null == this . m_DOMFactory ) { this . m_DOMFactory = createDocument ( ) ; } return this . m_DOMFactory ; } public static String getNodeData ( Node node ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { getNodeData ( node , buf ) ; s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; } finally { StringBufferPool . free ( buf ) ; } return s ; } public static void getNodeData ( Node node , FastStringBuffer buf ) { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { getNodeData ( child , buf ) ; } } break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : buf . append ( node . getNodeValue ( ) ) ; break ; case Node . ATTRIBUTE_NODE : buf . append ( node . getNodeValue ( ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : break ; default : break ; } } } 	1	['26', '1', '1', '14', '86', '315', '9', '5', '23', '0.884444444', '1122', '0.888888889', '6', '0', '0.22', '0', '0', '41.80769231', '40', '5', '1']
package org . apache . xpath . domapi ; import org . w3c . dom . Attr ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . xpath . XPathNamespace ; public class XPathNamespaceImpl implements XPathNamespace { Node m_attributeNode = null ; public XPathNamespaceImpl ( Node node ) { m_attributeNode = node ; } public Element getOwnerElement ( ) { return ( ( Attr ) m_attributeNode ) . getOwnerElement ( ) ; } public String getNodeName ( ) { return "#namespace" ; } public String getNodeValue ( ) throws DOMException { return m_attributeNode . getNodeValue ( ) ; } public void setNodeValue ( String arg0 ) throws DOMException { } public short getNodeType ( ) { return XPathNamespace . XPATH_NAMESPACE_NODE ; } public Node getParentNode ( ) { return m_attributeNode . getParentNode ( ) ; } public NodeList getChildNodes ( ) { return m_attributeNode . getChildNodes ( ) ; } public Node getFirstChild ( ) { return m_attributeNode . getFirstChild ( ) ; } public Node getLastChild ( ) { return m_attributeNode . getLastChild ( ) ; } public Node getPreviousSibling ( ) { return m_attributeNode . getPreviousSibling ( ) ; } public Node getNextSibling ( ) { return m_attributeNode . getNextSibling ( ) ; } public NamedNodeMap getAttributes ( ) { return m_attributeNode . getAttributes ( ) ; } public Document getOwnerDocument ( ) { return m_attributeNode . getOwnerDocument ( ) ; } public Node insertBefore ( Node arg0 , Node arg1 ) throws DOMException { return null ; } public Node replaceChild ( Node arg0 , Node arg1 ) throws DOMException { return null ; } public Node removeChild ( Node arg0 ) throws DOMException { return null ; } public Node appendChild ( Node arg0 ) throws DOMException { return null ; } public boolean hasChildNodes ( ) { return false ; } public Node cloneNode ( boolean arg0 ) { throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , null ) ; } public void normalize ( ) { m_attributeNode . normalize ( ) ; } public boolean isSupported ( String arg0 , String arg1 ) { return m_attributeNode . isSupported ( arg0 , arg1 ) ; } public String getNamespaceURI ( ) { return m_attributeNode . getNodeValue ( ) ; } public String getPrefix ( ) { return m_attributeNode . getPrefix ( ) ; } public void setPrefix ( String arg0 ) throws DOMException { } public String getLocalName ( ) { return m_attributeNode . getPrefix ( ) ; } public boolean hasAttributes ( ) { return m_attributeNode . hasAttributes ( ) ; } } 	1	['39', '1', '0', '1', '56', '469', '1', '0', '39', '0.578947368', '198', '0', '0', '0', '0.256410256', '0', '0', '4.051282051', '1', '0.9744', '1']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . Type ; import org . apache . xalan . xsltc . compiler . Constants ; public final class Util { static public char filesep ; static { String temp = System . getProperty ( "file.separator" , "/" ) ; filesep = temp . charAt ( 0 ) ; } public static String noExtName ( String name ) { final int index = name . lastIndexOf ( '.' ) ; return name . substring ( 0 , index >= 0 ? index : name . length ( ) ) ; } public static String baseName ( String name ) { int index = name . lastIndexOf ( '\\' ) ; if ( index < 0 ) { index = name . lastIndexOf ( '/' ) ; } if ( index >= 0 ) return name . substring ( index + 1 ) ; else { int lastColonIndex = name . lastIndexOf ( ':' ) ; if ( lastColonIndex > 0 ) return name . substring ( lastColonIndex + 1 ) ; else return name ; } } public static String pathName ( String name ) { int index = name . lastIndexOf ( '/' ) ; if ( index < 0 ) { index = name . lastIndexOf ( '\\' ) ; } return name . substring ( 0 , index + 1 ) ; } public static String toJavaName ( String name ) { if ( name . length ( ) > 0 ) { final StringBuffer result = new StringBuffer ( ) ; char ch = name . charAt ( 0 ) ; result . append ( Character . isJavaIdentifierStart ( ch ) ? ch : '_' ) ; final int n = name . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { ch = name . charAt ( i ) ; result . append ( Character . isJavaIdentifierPart ( ch ) ? ch : '_' ) ; } return result . toString ( ) ; } return name ; } public static Type getJCRefType ( String signature ) { return Type . getType ( signature ) ; } public static String internalName ( String cname ) { return cname . replace ( '.' , filesep ) ; } public static void println ( String s ) { System . out . println ( s ) ; } public static void println ( char ch ) { System . out . println ( ch ) ; } public static void TRACE1 ( ) { System . out . println ( "TRACE1" ) ; } public static void TRACE2 ( ) { System . out . println ( "TRACE2" ) ; } public static void TRACE3 ( ) { System . out . println ( "TRACE3" ) ; } public static String replace ( String base , char ch , String str ) { return ( base . indexOf ( ch ) < 0 ) ? base : replace ( base , String . valueOf ( ch ) , new String [ ] { str } ) ; } public static String replace ( String base , String delim , String [ ] str ) { final int len = base . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i ++ ) { final char ch = base . charAt ( i ) ; final int k = delim . indexOf ( ch ) ; if ( k >= 0 ) { result . append ( str [ k ] ) ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } public static String escape ( String input ) { return replace ( input , ".-/:" , new String [ ] { "$dot$" , "$dash$" , "$slash$" , "$colon$" } ) ; } public static String getLocalName ( String qname ) { final int index = qname . lastIndexOf ( ":" ) ; return ( index > 0 ) ? qname . substring ( index + 1 ) : qname ; } public static String getPrefix ( String qname ) { final int index = qname . lastIndexOf ( ":" ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : Constants . EMPTYSTRING ; } } 	1	['18', '1', '0', '44', '38', '151', '43', '1', '17', '0.941176471', '274', '0', '0', '0', '0.235294118', '0', '0', '14.16666667', '5', '1.6667', '1']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ClassGen ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; public final class AttributeSetMethodGenerator extends MethodGenerator { private static int HANDLER_INDEX = 1 ; private static int ITERATOR_INDEX = 2 ; private static final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 2 ] ; private static final String [ ] argNames = new String [ 2 ] ; static { argTypes [ 0 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; argNames [ 0 ] = TRANSLET_OUTPUT_PNAME ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argNames [ 1 ] = ITERATOR_PNAME ; } private final Instruction _astoreHandler ; private final Instruction _aloadHandler ; private final Instruction _astoreIterator ; private final Instruction _aloadIterator ; public AttributeSetMethodGenerator ( String methodName , ClassGen classGen ) { super ( org . apache . bcel . Constants . ACC_PRIVATE , org . apache . bcel . generic . Type . VOID , argTypes , argNames , methodName , classGen . getClassName ( ) , new InstructionList ( ) , classGen . getConstantPool ( ) ) ; _astoreHandler = new ASTORE ( HANDLER_INDEX ) ; _aloadHandler = new ALOAD ( HANDLER_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public int getIteratorIndex ( ) { return ITERATOR_INDEX ; } public Instruction storeHandler ( ) { return _astoreHandler ; } public Instruction loadHandler ( ) { return _aloadHandler ; } public int getLocalIndex ( String name ) { return INVALID_INDEX ; } } 	1	['8', '5', '0', '11', '15', '14', '1', '10', '7', '0.839285714', '100', '1', '0', '0.958333333', '0.476190476', '1', '2', '10.5', '1', '0.75', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . axes . PredicatedNodeTest ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class FuncCurrent extends Function { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { Object subContextList = xctxt . getSubContextList ( ) ; int currentNode ; if ( null != subContextList && subContextList instanceof PredicatedNodeTest ) { LocPathIterator lpi = xctxt . getCurrentNodeList ( ) ; currentNode = lpi . getCurrentContextNode ( ) ; } else if ( xctxt . getIteratorRoot ( ) != DTM . NULL ) { currentNode = xctxt . getIteratorRoot ( ) ; } else { DTMIterator cnl = xctxt . getContextNodeList ( ) ; if ( null != cnl ) { currentNode = cnl . getCurrentNode ( ) ; } else currentNode = DTM . NULL ; } return new XNodeSet ( currentNode , xctxt . getDTMManager ( ) ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	1	['3', '3', '0', '10', '12', '3', '1', '9', '3', '2', '50', '0', '0', '0.95', '0.5', '1', '6', '15.66666667', '1', '0.6667', '2']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . IntStack ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . helpers . AttributesImpl ; public class XSLTElementProcessor extends ElemTemplateElement { XSLTElementProcessor ( ) { } private IntStack m_savedLastOrder ; private XSLTElementDef m_elemDef ; XSLTElementDef getElemDef ( ) { return m_elemDef ; } void setElemDef ( XSLTElementDef def ) { m_elemDef = def ; } public InputSource resolveEntity ( StylesheetHandler handler , String publicId , String systemId ) throws org . xml . sax . SAXException { return null ; } public void notationDecl ( StylesheetHandler handler , String name , String publicId , String systemId ) { } public void unparsedEntityDecl ( StylesheetHandler handler , String name , String publicId , String systemId , String notationName ) { } public void startNonText ( StylesheetHandler handler ) throws org . xml . sax . SAXException { } public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { if ( m_savedLastOrder == null ) m_savedLastOrder = new IntStack ( ) ; m_savedLastOrder . push ( getElemDef ( ) . getLastOrder ( ) ) ; getElemDef ( ) . setLastOrder ( - 1 ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { if ( m_savedLastOrder != null && ! m_savedLastOrder . empty ( ) ) getElemDef ( ) . setLastOrder ( m_savedLastOrder . pop ( ) ) ; if ( ! getElemDef ( ) . getRequiredFound ( ) ) handler . error ( XSLTErrorResources . ER_REQUIRED_ELEM_NOT_FOUND , new Object [ ] { getElemDef ( ) . getRequiredElem ( ) } , null ) ; } public void characters ( StylesheetHandler handler , char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { handler . error ( XSLTErrorResources . ER_CHARS_NOT_ALLOWED , null , null ) ; } public void ignorableWhitespace ( StylesheetHandler handler , char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { } public void processingInstruction ( StylesheetHandler handler , String target , String data ) throws org . xml . sax . SAXException { } public void skippedEntity ( StylesheetHandler handler , String name ) throws org . xml . sax . SAXException { } void setPropertiesFromAttributes ( StylesheetHandler handler , String rawName , Attributes attributes , ElemTemplateElement target ) throws org . xml . sax . SAXException { setPropertiesFromAttributes ( handler , rawName , attributes , target , true ) ; } Attributes setPropertiesFromAttributes ( StylesheetHandler handler , String rawName , Attributes attributes , ElemTemplateElement target , boolean throwError ) throws org . xml . sax . SAXException { XSLTElementDef def = getElemDef ( ) ; AttributesImpl undefines = throwError ? null : new AttributesImpl ( ) ; Vector processedDefs = new Vector ( ) ; Vector errorDefs = new Vector ( ) ; int nAttrs = attributes . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { String attrUri = attributes . getURI ( i ) ; if ( ( null != attrUri ) && ( attrUri . length ( ) == 0 ) && ( attributes . getQName ( i ) . startsWith ( "xmlns:" ) || attributes . getQName ( i ) . equals ( "xmlns" ) ) ) { attrUri = org . apache . xalan . templates . Constants . S_XMLNAMESPACEURI ; } String attrLocalName = attributes . getLocalName ( i ) ; XSLTAttributeDef attrDef = def . getAttributeDef ( attrUri , attrLocalName ) ; if ( null == attrDef ) { if ( throwError ) { handler . error ( XSLTErrorResources . ER_ATTR_NOT_ALLOWED , new Object [ ] { attributes . getQName ( i ) , rawName } , null ) ; } else { undefines . addAttribute ( attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getType ( i ) , attributes . getValue ( i ) ) ; } } else { boolean success = attrDef . setAttrValue ( handler , attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getValue ( i ) , target ) ; if ( success ) processedDefs . addElement ( attrDef ) ; else errorDefs . addElement ( attrDef ) ; } } XSLTAttributeDef [ ] attrDefs = def . getAttributes ( ) ; int nAttrDefs = attrDefs . length ; for ( int i = 0 ; i < nAttrDefs ; i ++ ) { XSLTAttributeDef attrDef = attrDefs [ i ] ; String defVal = attrDef . getDefault ( ) ; if ( null != defVal ) { if ( ! processedDefs . contains ( attrDef ) ) { attrDef . setDefAttrValue ( handler , target ) ; } } if ( attrDef . getRequired ( ) ) { if ( ( ! processedDefs . contains ( attrDef ) ) && ( ! errorDefs . contains ( attrDef ) ) ) handler . error ( XSLMessages . createMessage ( XSLTErrorResources . ER_REQUIRES_ATTRIB , new Object [ ] { rawName , attrDef . getName ( ) } ) , null ) ; } } return undefines ; } } 	1	['15', '3', '11', '20', '48', '101', '16', '6', '10', '0.821428571', '280', '1', '2', '0.933333333', '0.348148148', '0', '0', '17.53333333', '1', '0.9333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; public class ElemPI extends ElemTemplateElement { private AVT m_name_atv = null ; public void setName ( AVT v ) { m_name_atv = v ; } public AVT getName ( ) { return m_name_atv ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_name_atv ) m_name_atv . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_PI ; } public String getNodeName ( ) { return Constants . ELEMNAME_PI_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; String piName = m_name_atv == null ? null : m_name_atv . evaluate ( xctxt , sourceNode , this ) ; if ( piName == null ) return ; if ( piName . equalsIgnoreCase ( "xml" ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , new Object [ ] { Constants . ATTRNAME_NAME , piName } ) ; return ; } else if ( ( ! m_name_atv . isSimple ( ) ) && ( ! isValidNCName ( piName ) ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , new Object [ ] { Constants . ATTRNAME_NAME , piName } ) ; return ; } String data = transformer . transformToString ( this ) ; try { transformer . getResultTreeHandler ( ) . processingInstruction ( piName , data ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } } 	1	['8', '3', '0', '11', '33', '8', '1', '10', '8', '0.428571429', '164', '1', '1', '0.965517241', '0.3', '2', '5', '19.375', '16', '2.75', '2']
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . net . URL ; import java . util . Enumeration ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; final class Import extends TopLevelElement { private Stylesheet _imported = null ; public Stylesheet getImportedStylesheet ( ) { return _imported ; } public void parseContents ( final Parser parser ) { final Stylesheet context = parser . getCurrentStylesheet ( ) ; try { String docToLoad = getAttribute ( "href" ) ; if ( context . checkForLoop ( docToLoad ) ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CIRCULAR_INCLUDE_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } String currLoadedDoc = context . getSystemId ( ) ; SourceLoader loader = context . getSourceLoader ( ) ; InputSource input = null ; XMLReader reader = null ; if ( loader != null ) { final XSLTC xsltc = parser . getXSLTC ( ) ; input = loader . loadSource ( docToLoad , currLoadedDoc , xsltc ) ; reader = xsltc . getXMLReader ( ) ; } else { File file = new File ( currLoadedDoc ) ; if ( file . exists ( ) ) currLoadedDoc = "file:" + currLoadedDoc ; final URL url = new URL ( new URL ( currLoadedDoc ) , docToLoad ) ; docToLoad = url . toString ( ) ; input = new InputSource ( docToLoad ) ; } if ( input == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . FILE_NOT_FOUND_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } final SyntaxTreeNode root ; if ( reader != null ) { root = parser . parse ( reader , input ) ; } else { root = parser . parse ( input ) ; } if ( root == null ) return ; _imported = parser . makeStylesheet ( root ) ; if ( _imported == null ) return ; _imported . setSourceLoader ( loader ) ; _imported . setSystemId ( docToLoad ) ; _imported . setParentStylesheet ( context ) ; _imported . setImportingStylesheet ( context ) ; final int currPrecedence = parser . getCurrentImportPrecedence ( ) ; final int nextPrecedence = parser . getNextImportPrecedence ( ) ; _imported . setImportPrecedence ( currPrecedence ) ; context . setImportPrecedence ( nextPrecedence ) ; parser . setCurrentStylesheet ( _imported ) ; _imported . parseContents ( parser ) ; final Enumeration elements = _imported . elements ( ) ; final Stylesheet topStylesheet = parser . getTopLevelStylesheet ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof TopLevelElement ) { if ( element instanceof Variable ) { topStylesheet . addVariable ( ( Variable ) element ) ; } else if ( element instanceof Param ) { topStylesheet . addParam ( ( Param ) element ) ; } else { topStylesheet . addElement ( ( TopLevelElement ) element ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { parser . setCurrentStylesheet ( context ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	1	['5', '3', '0', '14', '45', '4', '0', '14', '4', '0.5', '244', '1', '1', '0.9375', '0.36', '2', '5', '47.6', '11', '2.8', '2']
package org . apache . xml . utils ; import java . io . Serializable ; import org . apache . xml . dtm . DTM ; public class NodeVector implements Serializable , Cloneable { private int m_blocksize ; private int m_map [ ] ; protected int m_firstFree = 0 ; private int m_mapSize ; public NodeVector ( ) { m_blocksize = 32 ; m_mapSize = 0 ; } public NodeVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = 0 ; } public Object clone ( ) throws CloneNotSupportedException { NodeVector clone = ( NodeVector ) super . clone ( ) ; if ( ( null != this . m_map ) && ( this . m_map == clone . m_map ) ) { clone . m_map = new int [ this . m_map . length ] ; System . arraycopy ( this . m_map , 0 , clone . m_map , 0 , this . m_map . length ) ; } return clone ; } public int size ( ) { return m_firstFree ; } public void addElement ( int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void push ( int value ) { int ff = m_firstFree ; if ( ( ff + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , ff + 1 ) ; m_map = newMap ; } } m_map [ ff ] = value ; ff ++ ; m_firstFree = ff ; } public final int pop ( ) { m_firstFree -- ; int n = m_map [ m_firstFree ] ; m_map [ m_firstFree ] = DTM . NULL ; return n ; } public final int popAndTop ( ) { m_firstFree -- ; m_map [ m_firstFree ] = DTM . NULL ; return ( m_firstFree == 0 ) ? DTM . NULL : m_map [ m_firstFree - 1 ] ; } public final void popQuick ( ) { m_firstFree -- ; m_map [ m_firstFree ] = DTM . NULL ; } public final int peepOrNull ( ) { return ( ( null != m_map ) && ( m_firstFree > 0 ) ) ? m_map [ m_firstFree - 1 ] : DTM . NULL ; } public final void pushPair ( int v1 , int v2 ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { if ( ( m_firstFree + 2 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree ) ; m_map = newMap ; } } m_map [ m_firstFree ] = v1 ; m_map [ m_firstFree + 1 ] = v2 ; m_firstFree += 2 ; } public final void popPair ( ) { m_firstFree -= 2 ; m_map [ m_firstFree ] = DTM . NULL ; m_map [ m_firstFree + 1 ] = DTM . NULL ; } public final void setTail ( int n ) { m_map [ m_firstFree - 1 ] = n ; } public final void setTailSub1 ( int n ) { m_map [ m_firstFree - 2 ] = n ; } public final int peepTail ( ) { return m_map [ m_firstFree - 1 ] ; } public final int peepTailSub1 ( ) { return m_map [ m_firstFree - 2 ] ; } public void insertInOrder ( int value ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( value < m_map [ i ] ) { insertElementAt ( value , i ) ; return ; } } addElement ( value ) ; } public void insertElementAt ( int value , int at ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public void appendNodes ( NodeVector nodes ) { int nNodes = nodes . size ( ) ; if ( null == m_map ) { m_mapSize = nNodes + m_blocksize ; m_map = new int [ m_mapSize ] ; } else if ( ( m_firstFree + nNodes ) >= m_mapSize ) { m_mapSize += ( nNodes + m_blocksize ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + nNodes ) ; m_map = newMap ; } System . arraycopy ( nodes . m_map , 0 , m_map , m_firstFree , nNodes ) ; m_firstFree += nNodes ; } public void removeAllElements ( ) { if ( null == m_map ) return ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = DTM . NULL ; } m_firstFree = 0 ; } public void RemoveAllNoClear ( ) { if ( null == m_map ) return ; m_firstFree = 0 ; } public boolean removeElement ( int s ) { if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == s ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = DTM . NULL ; m_firstFree -- ; return true ; } } return false ; } public void removeElementAt ( int i ) { if ( null == m_map ) return ; if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = DTM . NULL ; } public void setElementAt ( int node , int index ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } if ( index == - 1 ) addElement ( node ) ; m_map [ index ] = node ; } public int elementAt ( int i ) { if ( null == m_map ) return DTM . NULL ; return m_map [ i ] ; } public boolean contains ( int s ) { if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == s ) return true ; } return false ; } public int indexOf ( int elem , int index ) { if ( null == m_map ) return - 1 ; for ( int i = index ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == elem ) return i ; } return - 1 ; } public int indexOf ( int elem ) { if ( null == m_map ) return - 1 ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == elem ) return i ; } return - 1 ; } public void sort ( int a [ ] , int lo0 , int hi0 ) throws Exception { int lo = lo0 ; int hi = hi0 ; if ( lo >= hi ) { return ; } else if ( lo == hi - 1 ) { if ( a [ lo ] > a [ hi ] ) { int T = a [ lo ] ; a [ lo ] = a [ hi ] ; a [ hi ] = T ; } return ; } int pivot = a [ ( lo + hi ) / 2 ] ; a [ ( lo + hi ) / 2 ] = a [ hi ] ; a [ hi ] = pivot ; while ( lo < hi ) { while ( a [ lo ] <= pivot && lo < hi ) { lo ++ ; } while ( pivot <= a [ hi ] && lo < hi ) { hi -- ; } if ( lo < hi ) { int T = a [ lo ] ; a [ lo ] = a [ hi ] ; a [ hi ] = T ; } } a [ hi0 ] = a [ hi ] ; a [ hi ] = pivot ; sort ( a , lo0 , lo - 1 ) ; sort ( a , hi + 1 , hi0 ) ; } public void sort ( ) throws Exception { sort ( m_map , 0 , m_firstFree - 1 ) ; } } 	1	['30', '1', '1', '9', '33', '0', '9', '0', '30', '0.422413793', '933', '1', '0', '0', '0.4', '0', '0', '29.96666667', '5', '2.1667', '1']
package org . apache . xalan . xsltc . compiler ; import java . io . BufferedOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Map ; import java . util . Properties ; import java . util . Vector ; import java . util . jar . JarEntry ; import java . util . jar . JarOutputStream ; import java . util . jar . Manifest ; import org . apache . bcel . classfile . JavaClass ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . dtm . DTM ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; public final class XSLTC { private Parser _parser ; private XMLReader _reader = null ; private SourceLoader _loader = null ; private Stylesheet _stylesheet = null ; private int _modeSerial = 1 ; private int _stylesheetSerial = 1 ; private int _stepPatternSerial = 1 ; private int _helperClassSerial = 0 ; private int _attributeSetSerial = 0 ; private int [ ] _numberFieldIndexes ; private int _nextGType ; private Vector _namesIndex ; private Hashtable _elements ; private Hashtable _attributes ; private int _nextNSType ; private Vector _namespaceIndex ; private Hashtable _namespaces ; public static final int FILE_OUTPUT = 0 ; public static final int JAR_OUTPUT = 1 ; public static final int BYTEARRAY_OUTPUT = 2 ; public static final int CLASSLOADER_OUTPUT = 3 ; public static final int BYTEARRAY_AND_FILE_OUTPUT = 4 ; public static final int BYTEARRAY_AND_JAR_OUTPUT = 5 ; private boolean _debug = false ; private String _jarFileName = null ; private String _className = null ; private String _packageName = null ; private File _destDir = null ; private int _outputType = FILE_OUTPUT ; private Vector _classes ; private Vector _bcelClasses ; private boolean _callsNodeset = false ; private boolean _multiDocument = false ; private boolean _hasIdCall = false ; private boolean _templateInlining = false ; public XSLTC ( ) { _parser = new Parser ( this ) ; } public Parser getParser ( ) { return _parser ; } public void setOutputType ( int type ) { _outputType = type ; } public Properties getOutputProperties ( ) { return _parser . getOutputProperties ( ) ; } public void init ( ) { reset ( ) ; _reader = null ; _classes = new Vector ( ) ; _bcelClasses = new Vector ( ) ; } private void reset ( ) { _nextGType = DTM . NTYPES ; _elements = new Hashtable ( ) ; _attributes = new Hashtable ( ) ; _namespaces = new Hashtable ( ) ; _namespaces . put ( "" , new Integer ( _nextNSType ) ) ; _namesIndex = new Vector ( 128 ) ; _namespaceIndex = new Vector ( 32 ) ; _parser . init ( ) ; _modeSerial = 1 ; _stylesheetSerial = 1 ; _stepPatternSerial = 1 ; _helperClassSerial = 0 ; _attributeSetSerial = 0 ; _multiDocument = false ; _hasIdCall = false ; _numberFieldIndexes = new int [ ] { - 1 , - 1 , - 1 } ; } public void setSourceLoader ( SourceLoader loader ) { _loader = loader ; } public void setTemplateInlining ( boolean templateInlining ) { _templateInlining = templateInlining ; } public void setPIParameters ( String media , String title , String charset ) { _parser . setPIParameters ( media , title , charset ) ; } public boolean compile ( URL url ) { try { final InputStream stream = url . openStream ( ) ; final InputSource input = new InputSource ( stream ) ; input . setSystemId ( url . toString ( ) ) ; return compile ( input , _className ) ; } catch ( IOException e ) { _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; return false ; } } public boolean compile ( URL url , String name ) { try { final InputStream stream = url . openStream ( ) ; final InputSource input = new InputSource ( stream ) ; input . setSystemId ( url . toString ( ) ) ; return compile ( input , name ) ; } catch ( IOException e ) { _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; return false ; } } public boolean compile ( InputStream stream , String name ) { final InputSource input = new InputSource ( stream ) ; input . setSystemId ( name ) ; return compile ( input , name ) ; } public boolean compile ( InputSource input , String name ) { try { reset ( ) ; String systemId = null ; if ( input != null ) { systemId = input . getSystemId ( ) ; } if ( _className == null ) { if ( name != null ) setClassName ( name ) ; else if ( ( systemId != null ) && ( ! systemId . equals ( "" ) ) ) setClassName ( Util . baseName ( systemId ) ) ; else setClassName ( "GregorSamsa" ) ; } SyntaxTreeNode element = null ; if ( _reader == null ) { element = _parser . parse ( input ) ; } else { element = _parser . parse ( _reader , input ) ; } if ( ( ! _parser . errorsFound ( ) ) && ( element != null ) ) { _stylesheet = _parser . makeStylesheet ( element ) ; _stylesheet . setSourceLoader ( _loader ) ; _stylesheet . setSystemId ( systemId ) ; _stylesheet . setParentStylesheet ( null ) ; _stylesheet . setTemplateInlining ( _templateInlining ) ; _parser . setCurrentStylesheet ( _stylesheet ) ; _parser . createAST ( _stylesheet ) ; } if ( ( ! _parser . errorsFound ( ) ) && ( _stylesheet != null ) ) { _stylesheet . setCallsNodeset ( _callsNodeset ) ; _stylesheet . setMultiDocument ( _multiDocument ) ; _stylesheet . setHasIdCall ( _hasIdCall ) ; synchronized ( getClass ( ) ) { _stylesheet . translate ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; } catch ( Error e ) { if ( _debug ) e . printStackTrace ( ) ; _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; } finally { _reader = null ; return ! _parser . errorsFound ( ) ; } } public boolean compile ( Vector stylesheets ) { final int count = stylesheets . size ( ) ; if ( count == 0 ) return true ; if ( count == 1 ) { final Object url = stylesheets . firstElement ( ) ; if ( url instanceof URL ) return compile ( ( URL ) url ) ; else return false ; } else { final Enumeration urls = stylesheets . elements ( ) ; while ( urls . hasMoreElements ( ) ) { _className = null ; final Object url = urls . nextElement ( ) ; if ( url instanceof URL ) { if ( ! compile ( ( URL ) url ) ) return false ; } } } return true ; } public byte [ ] [ ] getBytecodes ( ) { final int count = _classes . size ( ) ; final byte [ ] [ ] result = new byte [ count ] [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) result [ i ] = ( byte [ ] ) _classes . elementAt ( i ) ; return result ; } public byte [ ] [ ] compile ( String name , InputSource input , int outputType ) { _outputType = outputType ; if ( compile ( input , name ) ) return getBytecodes ( ) ; else return null ; } public byte [ ] [ ] compile ( String name , InputSource input ) { return compile ( name , input , BYTEARRAY_OUTPUT ) ; } public void setXMLReader ( XMLReader reader ) { _reader = reader ; } public XMLReader getXMLReader ( ) { return _reader ; } public Vector getErrors ( ) { return _parser . getErrors ( ) ; } public Vector getWarnings ( ) { return _parser . getWarnings ( ) ; } public void printErrors ( ) { _parser . printErrors ( ) ; } public void printWarnings ( ) { _parser . printWarnings ( ) ; } protected void setMultiDocument ( boolean flag ) { _multiDocument = flag ; } public boolean isMultiDocument ( ) { return _multiDocument ; } protected void setCallsNodeset ( boolean flag ) { if ( flag ) setMultiDocument ( flag ) ; _callsNodeset = flag ; } public boolean callsNodeset ( ) { return _callsNodeset ; } protected void setHasIdCall ( boolean flag ) { _hasIdCall = flag ; } public boolean hasIdCall ( ) { return _hasIdCall ; } public void setClassName ( String className ) { final String base = Util . baseName ( className ) ; final String noext = Util . noExtName ( base ) ; String name = Util . toJavaName ( noext ) ; if ( _packageName == null ) _className = name ; else _className = _packageName + '.' + name ; } public String getClassName ( ) { return _className ; } private String classFileName ( final String className ) { return className . replace ( '.' , File . separatorChar ) + ".class" ; } private File getOutputFile ( String className ) { if ( _destDir != null ) return new File ( _destDir , classFileName ( className ) ) ; else return new File ( classFileName ( className ) ) ; } public boolean setDestDirectory ( String dstDirName ) { final File dir = new File ( dstDirName ) ; if ( dir . exists ( ) || dir . mkdirs ( ) ) { _destDir = dir ; return true ; } else { _destDir = null ; return false ; } } public void setPackageName ( String packageName ) { _packageName = packageName ; if ( _className != null ) setClassName ( _className ) ; } public void setJarFileName ( String jarFileName ) { final String JAR_EXT = ".jar" ; if ( jarFileName . endsWith ( JAR_EXT ) ) _jarFileName = jarFileName ; else _jarFileName = jarFileName + JAR_EXT ; _outputType = JAR_OUTPUT ; } public String getJarFileName ( ) { return _jarFileName ; } public void setStylesheet ( Stylesheet stylesheet ) { if ( _stylesheet == null ) _stylesheet = stylesheet ; } public Stylesheet getStylesheet ( ) { return _stylesheet ; } public int registerAttribute ( QName name ) { Integer code = ( Integer ) _attributes . get ( name . toString ( ) ) ; if ( code == null ) { code = new Integer ( _nextGType ++ ) ; _attributes . put ( name . toString ( ) , code ) ; final String uri = name . getNamespace ( ) ; final String local = "@" + name . getLocalPart ( ) ; if ( ( uri != null ) && ( ! uri . equals ( "" ) ) ) _namesIndex . addElement ( uri + ":" + local ) ; else _namesIndex . addElement ( local ) ; if ( name . getLocalPart ( ) . equals ( "*" ) ) { registerNamespace ( name . getNamespace ( ) ) ; } } return code . intValue ( ) ; } public int registerElement ( QName name ) { Integer code = ( Integer ) _elements . get ( name . toString ( ) ) ; if ( code == null ) { _elements . put ( name . toString ( ) , code = new Integer ( _nextGType ++ ) ) ; _namesIndex . addElement ( name . toString ( ) ) ; } if ( name . getLocalPart ( ) . equals ( "*" ) ) { registerNamespace ( name . getNamespace ( ) ) ; } return code . intValue ( ) ; } public int registerNamespace ( QName name ) { final SymbolTable stable = _parser . getSymbolTable ( ) ; final String uri = stable . lookupNamespace ( name . toString ( ) ) ; final int code = registerNamespace ( uri ) ; return code ; } public int registerNamespace ( String namespaceURI ) { Integer code = ( Integer ) _namespaces . get ( namespaceURI ) ; if ( code == null ) { code = new Integer ( _nextNSType ++ ) ; _namespaces . put ( namespaceURI , code ) ; _namespaceIndex . addElement ( namespaceURI ) ; } return code . intValue ( ) ; } public int nextModeSerial ( ) { return _modeSerial ++ ; } public int nextStylesheetSerial ( ) { return _stylesheetSerial ++ ; } public int nextStepPatternSerial ( ) { return _stepPatternSerial ++ ; } public int [ ] getNumberFieldIndexes ( ) { return _numberFieldIndexes ; } public int nextHelperClassSerial ( ) { return _helperClassSerial ++ ; } public int nextAttributeSetSerial ( ) { return _attributeSetSerial ++ ; } public Vector getNamesIndex ( ) { return _namesIndex ; } public Vector getNamespaceIndex ( ) { return _namespaceIndex ; } public String getHelperClassName ( ) { return getClassName ( ) + '$' + _helperClassSerial ++ ; } public void dumpClass ( JavaClass clazz ) { if ( _outputType == FILE_OUTPUT || _outputType == BYTEARRAY_AND_FILE_OUTPUT ) { File outFile = getOutputFile ( clazz . getClassName ( ) ) ; String parentDir = outFile . getParent ( ) ; if ( parentDir != null ) { File parentFile = new File ( parentDir ) ; if ( ! parentFile . exists ( ) ) parentFile . mkdirs ( ) ; } } try { switch ( _outputType ) { case FILE_OUTPUT : clazz . dump ( new BufferedOutputStream ( new FileOutputStream ( getOutputFile ( clazz . getClassName ( ) ) ) ) ) ; break ; case JAR_OUTPUT : _bcelClasses . addElement ( clazz ) ; break ; case BYTEARRAY_OUTPUT : case BYTEARRAY_AND_FILE_OUTPUT : case BYTEARRAY_AND_JAR_OUTPUT : case CLASSLOADER_OUTPUT : ByteArrayOutputStream out = new ByteArrayOutputStream ( 2048 ) ; clazz . dump ( out ) ; _classes . addElement ( out . toByteArray ( ) ) ; if ( _outputType == BYTEARRAY_AND_FILE_OUTPUT ) clazz . dump ( new BufferedOutputStream ( new FileOutputStream ( getOutputFile ( clazz . getClassName ( ) ) ) ) ) ; else if ( _outputType == BYTEARRAY_AND_JAR_OUTPUT ) _bcelClasses . addElement ( clazz ) ; break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } private String entryName ( File f ) throws IOException { return f . getName ( ) . replace ( File . separatorChar , '/' ) ; } public void outputToJar ( ) throws IOException { final Manifest manifest = new Manifest ( ) ; final java . util . jar . Attributes atrs = manifest . getMainAttributes ( ) ; atrs . put ( java . util . jar . Attributes . Name . MANIFEST_VERSION , "1.2" ) ; final Map map = manifest . getEntries ( ) ; Enumeration classes = _bcelClasses . elements ( ) ; final String now = ( new Date ( ) ) . toString ( ) ; final java . util . jar . Attributes . Name dateAttr = new java . util . jar . Attributes . Name ( "Date" ) ; while ( classes . hasMoreElements ( ) ) { final JavaClass clazz = ( JavaClass ) classes . nextElement ( ) ; final String className = clazz . getClassName ( ) . replace ( '.' , '/' ) ; final java . util . jar . Attributes attr = new java . util . jar . Attributes ( ) ; attr . put ( dateAttr , now ) ; map . put ( className + ".class" , attr ) ; } final File jarFile = new File ( _destDir , _jarFileName ) ; final JarOutputStream jos = new JarOutputStream ( new FileOutputStream ( jarFile ) , manifest ) ; classes = _bcelClasses . elements ( ) ; while ( classes . hasMoreElements ( ) ) { final JavaClass clazz = ( JavaClass ) classes . nextElement ( ) ; final String className = clazz . getClassName ( ) . replace ( '.' , '/' ) ; jos . putNextEntry ( new JarEntry ( className + ".class" ) ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( 2048 ) ; clazz . dump ( out ) ; out . writeTo ( jos ) ; } jos . close ( ) ; } public void setDebug ( boolean debug ) { _debug = debug ; } public boolean debug ( ) { return _debug ; } } 	1	['57', '1', '0', '24', '146', '1224', '19', '9', '50', '0.895408163', '1289', '0.828571429', '3', '0', '0.115288221', '0', '0', '21', '16', '1.7018', '1']
package org . apache . xml . utils . synthetic . reflection ; public class Constructor extends EntryPoint implements Member { private org . apache . xml . utils . synthetic . Class declaringclass = null ; private java . lang . reflect . Constructor realconstructor = null ; private org . apache . xml . utils . synthetic . Class [ ] parametertypes ; private String [ ] parameternames ; private org . apache . xml . utils . synthetic . Class [ ] exceptiontypes ; private int modifiers ; public Constructor ( org . apache . xml . utils . synthetic . Class declaringclass ) { super ( declaringclass ) ; } public Constructor ( java . lang . reflect . Constructor ctor , org . apache . xml . utils . synthetic . Class declaringclass ) { super ( ctor , declaringclass ) ; } public Constructor ( java . lang . reflect . Constructor realconstructor ) { super ( realconstructor ) ; } public int hashCode ( ) { return getDeclaringClass ( ) . getName ( ) . hashCode ( ) ; } public Object newInstance ( Object initargs [ ] ) throws InstantiationException , IllegalAccessException , IllegalArgumentException , java . lang . reflect . InvocationTargetException { if ( realep != null ) return ( ( java . lang . reflect . Constructor ) realep ) . newInstance ( initargs ) ; else throw new InstantiationException ( "Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation" ) ; } } 	1	['5', '2', '0', '3', '13', '4', '2', '3', '5', '1', '61', '1', '3', '0.904761905', '0.5', '1', '1', '10', '1', '0.4', '1']
package org . apache . xpath . objects ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; public class XNumber extends XObject { double m_val ; public XNumber ( double d ) { super ( ) ; m_val = d ; } public XNumber ( Number num ) { super ( ) ; m_val = num . doubleValue ( ) ; m_obj = num ; } public int getType ( ) { return CLASS_NUMBER ; } public String getTypeString ( ) { return "#NUMBER" ; } public double num ( ) { return m_val ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_val ; } public boolean bool ( ) { return ( Double . isNaN ( m_val ) || ( m_val == 0.0 ) ) ? false : true ; } public String str ( ) { if ( Double . isNaN ( m_val ) ) { return "NaN" ; } else if ( Double . isInfinite ( m_val ) ) { if ( m_val > 0 ) return "Infinity" ; else return "-Infinity" ; } double num = m_val ; String s = Double . toString ( num ) ; int len = s . length ( ) ; if ( s . charAt ( len - 2 ) == '.' && s . charAt ( len - 1 ) == '0' ) { s = s . substring ( 0 , len - 2 ) ; if ( s . equals ( "-0" ) ) return "0" ; return s ; } int e = s . indexOf ( 'E' ) ; if ( e < 0 ) { if ( s . charAt ( len - 1 ) == '0' ) return s . substring ( 0 , len - 1 ) ; else return s ; } int exp = Integer . parseInt ( s . substring ( e + 1 ) ) ; String sign ; if ( s . charAt ( 0 ) == '-' ) { sign = "-" ; s = s . substring ( 1 ) ; -- e ; } else sign = "" ; int nDigits = e - 2 ; if ( exp >= nDigits ) return sign + s . substring ( 0 , 1 ) + s . substring ( 2 , e ) + zeros ( exp - nDigits ) ; while ( s . charAt ( e - 1 ) == '0' ) e -- ; if ( exp > 0 ) return sign + s . substring ( 0 , 1 ) + s . substring ( 2 , 2 + exp ) + "." + s . substring ( 2 + exp , e ) ; return sign + "0." + zeros ( - 1 - exp ) + s . substring ( 0 , 1 ) + s . substring ( 2 , e ) ; } static private String zeros ( int n ) { if ( n < 1 ) return "" ; char [ ] buf = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { buf [ i ] = '0' ; } return new String ( buf ) ; } public Object object ( ) { if ( null == m_obj ) m_obj = new Double ( m_val ) ; return m_obj ; } public boolean equals ( XObject obj2 ) { int t = obj2 . getType ( ) ; try { if ( t == XObject . CLASS_NODESET ) return obj2 . equals ( this ) ; else if ( t == XObject . CLASS_BOOLEAN ) return obj2 . bool ( ) == bool ( ) ; else return m_val == obj2 . num ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } public boolean isStableNumber ( ) { return true ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitNumberLiteral ( owner , this ) ; } } 	1	['13', '3', '0', '42', '36', '22', '38', '5', '12', '0.416666667', '330', '0', '0', '0.865853659', '0.182692308', '2', '22', '24.30769231', '13', '2.4615', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . NodeSetDTM ; public class RTFIterator extends NodeSetDTM { public RTFIterator ( int root , DTMManager manager ) { super ( root , manager ) ; } } 	1	['1', '3', '0', '4', '2', '0', '2', '2', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '1']
package org . apache . xalan . processor ; public class StopParseException extends org . xml . sax . SAXException { StopParseException ( ) { super ( "Stylesheet PIs found, stop the parse" ) ; } } 	1	['1', '4', '0', '2', '2', '0', '2', '0', '0', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . xml . utils . res ; public class XResources_he extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "he" } , { "help_language" , "he" } , { "language" , "he" } , { "alphabet" , new char [ ] { 0x05D0 , 0x05D1 , 0x05D2 , 0x05D3 , 0x05D4 , 0x05D5 , 0x05D6 , 0x05D7 , 0x05D8 , 0x05D9 , 0x05DA , 0x05DB , 0x05DC , 0x05DD , 0x05DE , 0x05DF , 0x05E0 , 0x05E1 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "RightToLeft" } , { "numbering" , "additive" } , { "numberGroups" , new int [ ] { 10 , 1 } } , { "digits" , new char [ ] { 0x05D0 , 0x05D1 , 0x05D2 , 0x05D3 , 0x05D4 , 0x05D5 , 0x05D6 , 0x05D7 , 0x05D8 } } , { "tens" , new char [ ] { 0x05D9 , 0x05DA , 0x05DB , 0x05DC , 0x05DD , 0x05DE , 0x05DF , 0x05E0 , 0x05E1 } } , { "tables" , new String [ ] { "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '426', '0', '0', '0.976190476', '1', '0', '0', '140.6666667', '1', '0.3333', '1']
package org . apache . xalan . processor ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . helpers . DefaultHandler ; public class StylesheetPIHandler extends DefaultHandler { String m_baseID ; String m_media ; String m_title ; String m_charset ; Vector m_stylesheets = new Vector ( ) ; URIResolver m_uriResolver ; public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_uriResolver ; } public StylesheetPIHandler ( String baseID , String media , String title , String charset ) { m_baseID = baseID ; m_media = media ; m_title = title ; m_charset = charset ; } public Source getAssociatedStylesheet ( ) { int sz = m_stylesheets . size ( ) ; if ( sz > 0 ) { Source source = ( Source ) m_stylesheets . elementAt ( sz - 1 ) ; return source ; } else return null ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( target . equals ( "xml-stylesheet" ) ) { String href = null ; String type = null ; String title = null ; String media = null ; String charset = null ; boolean alternate = false ; StringTokenizer tokenizer = new StringTokenizer ( data , " \t=\n" , true ) ; boolean lookedAhead = false ; Source source = null ; String token = "" ; while ( tokenizer . hasMoreTokens ( ) ) { if ( ! lookedAhead ) token = tokenizer . nextToken ( ) ; else lookedAhead = false ; if ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) continue ; String name = token ; if ( name . equals ( "type" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; type = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "href" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; href = token ; if ( tokenizer . hasMoreTokens ( ) ) { token = tokenizer . nextToken ( ) ; while ( token . equals ( "=" ) && tokenizer . hasMoreTokens ( ) ) { href = href + token + tokenizer . nextToken ( ) ; if ( tokenizer . hasMoreTokens ( ) ) { token = tokenizer . nextToken ( ) ; lookedAhead = true ; } else { break ; } } } href = href . substring ( 1 , href . length ( ) - 1 ) ; try { if ( m_uriResolver != null ) { source = m_uriResolver . resolve ( href , m_baseID ) ; } else { href = SystemIDResolver . getAbsoluteURI ( href , m_baseID ) ; source = new SAXSource ( new InputSource ( href ) ) ; } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else if ( name . equals ( "title" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; title = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "media" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; media = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "charset" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; charset = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "alternate" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; alternate = token . substring ( 1 , token . length ( ) - 1 ) . equals ( "yes" ) ; } } if ( ( null != type ) && ( type . equals ( "text/xsl" ) || type . equals ( "text/xml" ) || type . equals ( "application/xml+xslt" ) ) && ( null != href ) ) { if ( null != m_media ) { if ( null != media ) { if ( ! media . equals ( m_media ) ) return ; } else return ; } if ( null != m_charset ) { if ( null != charset ) { if ( ! charset . equals ( m_charset ) ) return ; } else return ; } if ( null != m_title ) { if ( null != title ) { if ( ! title . equals ( m_title ) ) return ; } else return ; } m_stylesheets . addElement ( source ) ; } } } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws org . xml . sax . SAXException { throw new StopParseException ( ) ; } } 	1	['6', '2', '0', '3', '26', '3', '1', '2', '6', '0.733333333', '462', '0', '0', '0.772727273', '0.458333333', '1', '1', '75', '2', '1', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Function not supported!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Cannot overwrite cause" } , { ER_NO_DEFAULT_IMPL , "No default implementation found " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) not currently supported" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset bigger than slot" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine not available, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager received co_exit() request" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() failed" } , { ER_COROUTINE_PARAM , "Coroutine parameter error ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: Parser doTerminate answers {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse may not be called while parsing" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: typed iterator for axis  {0} not implemented" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: iterator for axis {0} not implemented " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Iterator clone not supported" } , { ER_UNKNOWN_AXIS_TYPE , "Unknown axis traversal type: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Axis traverser not supported: {0}" } , { ER_NO_DTMIDS_AVAIL , "No more DTM IDs are available" } , { ER_NOT_SUPPORTED , "Not supported: {0}" } , { ER_NODE_NON_NULL , "Node must be non-null for getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Could not resolve the node to a handle" } , { ER_STARTPARSE_WHILE_PARSING , "startParse may not be called while parsing" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse needs a non-null SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "could not initialize parser with" } , { ER_EXCEPTION_CREATING_POOL , "exception creating new instance for pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Path contains invalid escape sequence" } , { ER_SCHEME_REQUIRED , "Scheme is required!" } , { ER_NO_SCHEME_IN_URI , "No scheme found in URI: {0}" } , { ER_NO_SCHEME_INURI , "No scheme found in URI" } , { ER_PATH_INVALID_CHAR , "Path contains invalid character: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Cannot set scheme from null string" } , { ER_SCHEME_NOT_CONFORMANT , "The scheme is not conformant." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Host is not a well formed address" } , { ER_PORT_WHEN_HOST_NULL , "Port cannot be set when host is null" } , { ER_INVALID_PORT , "Invalid port number" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment can only be set for a generic URI" } , { ER_FRAG_WHEN_PATH_NULL , "Fragment cannot be set when path is null" } , { ER_FRAG_INVALID_CHAR , "Fragment contains invalid character" } , { ER_PARSER_IN_USE , "Parser is already in use" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Cannot change {0} {1} while parsing" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Self-causation not permitted" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo may not be specified if host is not specified" } , { ER_NO_PORT_IF_NO_HOST , "Port may not be specified if host is not specified" } , { ER_NO_QUERY_STRING_IN_PATH , "Query string cannot be specified in path and query string" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment cannot be specified in both the path and fragment" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Cannot initialize URI with empty parameters" } , { ER_METHOD_NOT_SUPPORTED , "Method not yet supported " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter not currently restartable" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader not before startParse request" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Axis traverser not supported: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler created with null PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "SystemId Unknown" } , { ER_LOCATION_UNKNOWN , "Location of error unknown" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() not supported in XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Attribute child does not have an owner document!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Attribute child does not have an owner document element!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Warning: can't output text before document element!  Ignoring..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Can't have more than one root on a DOM!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' is null" } , { ER_ARG_LOCALNAME_INVALID , "Localname in QNAME should be a valid NCName" } , { ER_ARG_PREFIX_INVALID , "Prefix in QNAME should be a valid NCName" } , { "BAD_CODE" , "Parameter to createMessage was out of bounds" } , { "FORMAT_FAILED" , "Exception thrown during messageFormat call" } , { "line" , "Line #" } , { "column" , "Column #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "The serializer class ''{0}'' does not implement org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "The resource [ {0} ] could not be found.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "The resource [ {0} ] could not load: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Buffer size <=0" } , { ER_INVALID_UTF16_SURROGATE , "Invalid UTF-16 surrogate detected: {0} ?" } , { ER_OIERROR , "IO error" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Cannot add attribute {0} after child nodes or before an element is produced.  Attribute will be ignored." } , { ER_NAMESPACE_PREFIX , "Namespace for prefix ''{0}'' has not been declared." } , { ER_STRAY_ATTRIBUTE , "Attribute ''{0}'' outside of element." } , { ER_STRAY_NAMESPACE , "Namespace declaration ''{0}''=''{1}'' outside of element." } , { ER_COULD_NOT_LOAD_RESOURCE , "Could not load ''{0}'' (check CLASSPATH), now using just the defaults" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Could not load the propery file ''{0}'' for output method ''{1}'' (check CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '10', '10', '16', '8', '10', '0', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xml . utils . res ; public class XResources_ja_JP_I extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x30a4 , 0x30ed , 0x30cf , 0x30cb , 0x30db , 0x30d8 , 0x30c8 , 0x30c1 , 0x30ea , 0x30cc , 0x30eb , 0x30f2 , 0x30ef , 0x30ab , 0x30e8 , 0x30bf , 0x30ec , 0x30bd , 0x30c4 , 0x30cd , 0x30ca , 0x30e9 , 0x30e0 , 0x30a6 , 0x30f0 , 0x30ce , 0x30aa , 0x30af , 0x30e4 , 0x30de , 0x30b1 , 0x30d5 , 0x30b3 , 0x30a8 , 0x30c6 , 0x30a2 , 0x30b5 , 0x30ad , 0x30e6 , 0x30e1 , 0x30df , 0x30b7 , 0x30f1 , 0x30d2 , 0x30e2 , 0x30bb , 0x30b9 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '595', '0', '0', '0.976190476', '1', '0', '0', '197', '1', '0.3333', '1']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncContains extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String s1 = m_arg0 . execute ( xctxt ) . str ( ) ; String s2 = m_arg1 . execute ( xctxt ) . str ( ) ; if ( s1 . length ( ) == 0 && s2 . length ( ) == 0 ) return XBoolean . S_TRUE ; int index = s1 . indexOf ( s2 ) ; return ( index > - 1 ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	1	['2', '5', '0', '5', '7', '1', '0', '5', '2', '2', '36', '0', '0', '0.98245614', '0.75', '1', '6', '17', '1', '0.5', '1']
package org . apache . xml . serializer ; import java . util . Vector ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . ext . LexicalHandler ; abstract public class ToSAXHandler extends SerializerBase { public ToSAXHandler ( ) { } public ToSAXHandler ( ContentHandler hdlr , LexicalHandler lex , String encoding ) { setContentHandler ( hdlr ) ; setLexHandler ( lex ) ; setEncoding ( encoding ) ; } public ToSAXHandler ( ContentHandler handler , String encoding ) { setContentHandler ( handler ) ; setEncoding ( encoding ) ; } protected ContentHandler m_saxHandler ; protected LexicalHandler m_lexHandler ; protected TransformStateSetter m_state = null ; protected void startDocumentInternal ( ) throws SAXException { if ( m_needToCallStartDocument ) { super . startDocumentInternal ( ) ; m_saxHandler . startDocument ( ) ; m_needToCallStartDocument = false ; } } public void startDTD ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void characters ( String characters ) throws SAXException { characters ( characters . toCharArray ( ) , 0 , characters . length ( ) ) ; } public void comment ( String comment ) throws SAXException { if ( m_startTagOpen ) { closeStartTag ( ) ; } else if ( m_cdataTagOpen ) { closeCDATA ( ) ; } if ( m_lexHandler != null ) { m_lexHandler . comment ( comment . toCharArray ( ) , 0 , comment . length ( ) ) ; super . fireCommentEvent ( comment . toCharArray ( ) , 0 , comment . length ( ) ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { } protected void closeStartTag ( ) throws SAXException { } protected void closeCDATA ( ) throws SAXException { } public void startElement ( String arg0 , String arg1 , String arg2 , Attributes arg3 ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } super . fireStartElem ( arg2 ) ; } public void setLexHandler ( LexicalHandler _lexHandler ) { this . m_lexHandler = _lexHandler ; } public void setContentHandler ( ContentHandler _saxHandler ) { this . m_saxHandler = _saxHandler ; if ( m_lexHandler == null && _saxHandler instanceof LexicalHandler ) { m_lexHandler = ( LexicalHandler ) _saxHandler ; } } public void setCdataSectionElements ( Vector URI_and_localNames ) { } public void flushPending ( ) { try { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = false ; } } catch ( SAXException e ) { } } public void setTransformState ( TransformStateSetter ts ) { this . m_state = ts ; } public void startElement ( String uri , String localName , String qName ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } super . fireStartElem ( qName ) ; } public void startElement ( String qName ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } super . fireStartElem ( qName ) ; } public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { if ( m_state != null ) { m_state . setCurrentNode ( node ) ; } super . characters ( node ) ; } public void fatalError ( SAXParseException exc ) throws SAXException { super . fatalError ( exc ) ; m_needToCallStartDocument = false ; if ( m_saxHandler instanceof ErrorHandler ) { ( ( ErrorHandler ) m_saxHandler ) . fatalError ( exc ) ; } } public void error ( SAXParseException exc ) throws SAXException { super . error ( exc ) ; if ( m_saxHandler instanceof ErrorHandler ) ( ( ErrorHandler ) m_saxHandler ) . error ( exc ) ; } public void warning ( SAXParseException exc ) throws SAXException { super . warning ( exc ) ; if ( m_saxHandler instanceof ErrorHandler ) ( ( ErrorHandler ) m_saxHandler ) . warning ( exc ) ; } } 	1	['22', '2', '3', '6', '42', '143', '4', '2', '19', '0.714285714', '251', '1', '1', '0.820754717', '0.217171717', '1', '4', '10.27272727', '3', '1.0455', '2']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncSum extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator nodes = m_arg0 . asIterator ( xctxt , xctxt . getCurrentNode ( ) ) ; double sum = 0.0 ; int pos ; while ( DTM . NULL != ( pos = nodes . nextNode ( ) ) ) { DTM dtm = nodes . getDTM ( pos ) ; XMLString s = dtm . getStringValue ( pos ) ; if ( null != s ) sum += s . toDouble ( ) ; } nodes . detach ( ) ; return new XNumber ( sum ) ; } } 	1	['2', '4', '0', '8', '11', '1', '0', '8', '2', '2', '44', '0', '0', '0.979591837', '0.75', '1', '6', '21', '1', '0.5', '1']
package org . apache . xpath . domapi ; import org . apache . xml . utils . PrefixResolverDefault ; import org . w3c . dom . Node ; import org . w3c . dom . xpath . XPathNSResolver ; public class XPathNSResolverImpl extends PrefixResolverDefault implements XPathNSResolver { public XPathNSResolverImpl ( Node xpathExpressionContext ) { super ( xpathExpressionContext ) ; } public String lookupNamespaceURI ( String prefix ) { return super . getNamespaceForPrefix ( prefix ) ; } } 	1	['2', '2', '0', '2', '4', '1', '1', '1', '2', '2', '10', '0', '0', '0.8', '0.666666667', '0', '0', '4', '1', '0.5', '1']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncTranslate extends Function3Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String theFirstString = m_arg0 . execute ( xctxt ) . str ( ) ; String theSecondString = m_arg1 . execute ( xctxt ) . str ( ) ; String theThirdString = m_arg2 . execute ( xctxt ) . str ( ) ; int theFirstStringLength = theFirstString . length ( ) ; int theThirdStringLength = theThirdString . length ( ) ; StringBuffer sbuffer = new StringBuffer ( ) ; for ( int i = 0 ; i < theFirstStringLength ; i ++ ) { char theCurrentChar = theFirstString . charAt ( i ) ; int theIndex = theSecondString . indexOf ( theCurrentChar ) ; if ( theIndex < 0 ) { sbuffer . append ( theCurrentChar ) ; } else if ( theIndex < theThirdStringLength ) { sbuffer . append ( theThirdString . charAt ( theIndex ) ) ; } else { } } return new XString ( sbuffer . toString ( ) ) ; } } 	1	['2', '6', '0', '5', '12', '1', '0', '5', '2', '2', '70', '0', '0', '0.984615385', '0.75', '1', '6', '34', '1', '0.5', '1']
package org . apache . xalan . extensions ; import java . util . Vector ; import org . apache . xalan . templates . Constants ; public class ExtensionNamespacesManager { private Vector m_extensions = new Vector ( ) ; private Vector m_predefExtensions = new Vector ( 7 ) ; private Vector m_unregisteredExtensions = new Vector ( ) ; public ExtensionNamespacesManager ( ) { setPredefinedNamespaces ( ) ; } public void registerExtension ( String namespace ) { if ( namespaceIndex ( namespace , m_extensions ) == - 1 ) { int predef = namespaceIndex ( namespace , m_predefExtensions ) ; if ( predef != - 1 ) m_extensions . addElement ( m_predefExtensions . elementAt ( predef ) ) ; else if ( ! ( m_unregisteredExtensions . contains ( namespace ) ) ) m_unregisteredExtensions . addElement ( namespace ) ; } } public void registerExtension ( ExtensionNamespaceSupport extNsSpt ) { String namespace = extNsSpt . getNamespace ( ) ; if ( namespaceIndex ( namespace , m_extensions ) == - 1 ) { m_extensions . addElement ( extNsSpt ) ; if ( m_unregisteredExtensions . contains ( namespace ) ) m_unregisteredExtensions . removeElement ( namespace ) ; } } public int namespaceIndex ( String namespace , Vector extensions ) { for ( int i = 0 ; i < extensions . size ( ) ; i ++ ) { if ( ( ( ExtensionNamespaceSupport ) extensions . elementAt ( i ) ) . getNamespace ( ) . equals ( namespace ) ) return i ; } return - 1 ; } public Vector getExtensions ( ) { return m_extensions ; } public void registerUnregisteredNamespaces ( ) { for ( int i = 0 ; i < m_unregisteredExtensions . size ( ) ; i ++ ) { String ns = ( String ) m_unregisteredExtensions . elementAt ( i ) ; ExtensionNamespaceSupport extNsSpt = defineJavaNamespace ( ns ) ; if ( extNsSpt != null ) m_extensions . addElement ( extNsSpt ) ; } } public ExtensionNamespaceSupport defineJavaNamespace ( String ns ) { return defineJavaNamespace ( ns , ns ) ; } public ExtensionNamespaceSupport defineJavaNamespace ( String ns , String classOrPackage ) { if ( null == ns || ns . trim ( ) . length ( ) == 0 ) return null ; String className = classOrPackage ; if ( className . startsWith ( "class:" ) ) className = className . substring ( 6 ) ; int lastSlash = className . lastIndexOf ( "/" ) ; if ( - 1 != lastSlash ) className = className . substring ( lastSlash + 1 ) ; if ( null == className || className . trim ( ) . length ( ) == 0 ) return null ; try { ExtensionHandler . getClassForName ( className ) ; return new ExtensionNamespaceSupport ( ns , "org.apache.xalan.extensions.ExtensionHandlerJavaClass" , new Object [ ] { ns , "javaclass" , className } ) ; } catch ( ClassNotFoundException e ) { return new ExtensionNamespaceSupport ( ns , "org.apache.xalan.extensions.ExtensionHandlerJavaPackage" , new Object [ ] { ns , "javapackage" , className + "." } ) ; } } private void setPredefinedNamespaces ( ) { String uri = Constants . S_EXTENSIONS_JAVA_URL ; String handlerClassName = "org.apache.xalan.extensions.ExtensionHandlerJavaPackage" ; String lang = "javapackage" ; String lib = "" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_OLD_JAVA_URL ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_LOTUSXSL_JAVA_URL ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_XALANLIB_URL ; handlerClassName = "org.apache.xalan.extensions.ExtensionHandlerJavaClass" ; lang = "javaclass" ; lib = "org.apache.xalan.lib.Extensions" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_REDIRECT_URL ; lib = "org.apache.xalan.lib.Redirect" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_PIPE_URL ; lib = "org.apache.xalan.lib.PipeDocument" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_SQL_URL ; lib = "org.apache.xalan.lib.sql.XConnection" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_COMMON_URL ; lib = "org.apache.xalan.lib.ExsltCommon" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_MATH_URL ; lib = "org.apache.xalan.lib.ExsltMath" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_SETS_URL ; lib = "org.apache.xalan.lib.ExsltSets" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_DATETIME_URL ; lib = "org.apache.xalan.lib.ExsltDatetime" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_DYNAMIC_URL ; lib = "org.apache.xalan.lib.ExsltDynamic" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_STRINGS_URL ; lib = "org.apache.xalan.lib.ExsltStrings" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; } } 	1	['9', '1', '0', '7', '29', '12', '5', '2', '8', '0.625', '581', '1', '0', '0', '0.416666667', '0', '0', '63.22222222', '7', '2.5556', '1']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemVariable ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ProcessorExsltFuncResult extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws SAXException { String msg = "" ; super . startElement ( handler , uri , localName , rawName , attributes ) ; ElemTemplateElement ancestor = handler . getElemTemplateElement ( ) . getParentElem ( ) ; while ( ancestor != null && ! ( ancestor instanceof ElemExsltFunction ) ) { if ( ancestor instanceof ElemVariable || ancestor instanceof ElemParam || ancestor instanceof ElemExsltFuncResult ) { msg = "func:result cannot appear within a variable, parameter, or another func:result." ; handler . error ( msg , new SAXException ( msg ) ) ; } ancestor = ancestor . getParentElem ( ) ; } if ( ancestor == null ) { msg = "func:result must appear in a func:function element" ; handler . error ( msg , new SAXException ( msg ) ) ; } } } 	1	['2', '5', '0', '8', '8', '1', '1', '7', '2', '2', '57', '0', '0', '0.995327103', '0.625', '1', '1', '27.5', '1', '0.5', '1']
package org . apache . xalan . processor ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . xml . sax . Attributes ; public class ProcessorTemplateElem extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { super . startElement ( handler , uri , localName , rawName , attributes ) ; try { XSLTElementDef def = getElemDef ( ) ; Class classObject = def . getClassObject ( ) ; ElemTemplateElement elem = null ; try { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; elem . setPrefixes ( handler . getNamespaceSupport ( ) ) ; } catch ( InstantiationException ie ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMTMPL , null , ie ) ; } catch ( IllegalAccessException iae ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMTMPL , null , iae ) ; } setPropertiesFromAttributes ( handler , rawName , attributes , elem ) ; appendAndPush ( handler , elem ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; if ( null != parent ) { parent . appendChild ( elem ) ; handler . pushElemTemplateElement ( elem ) ; } } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { super . endElement ( handler , uri , localName , rawName ) ; handler . popElemTemplateElement ( ) ; } } 	1	['4', '4', '8', '14', '23', '6', '9', '5', '3', '2', '94', '0', '0', '0.985915493', '0.55', '1', '1', '22.5', '1', '0.75', '1']
package org . apache . xalan . lib . sql ; import java . lang . reflect . Method ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . Driver ; import java . sql . DriverManager ; import java . sql . SQLException ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class DefaultConnectionPool implements ConnectionPool { private Driver m_Driver = null ; private static final boolean DEBUG = false ; private String m_driver = new String ( "" ) ; private String m_url = new String ( "" ) ; private int m_PoolMinSize = 1 ; private Properties m_ConnectionProtocol = new Properties ( ) ; private Vector m_pool = new Vector ( ) ; private boolean m_IsActive = false ; public DefaultConnectionPool ( ) { } public boolean isEnabled ( ) { return m_IsActive ; } public void setDriver ( String d ) { m_driver = d ; } public void setURL ( String url ) { m_url = url ; } public void freeUnused ( ) { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { if ( DEBUG ) { System . err . println ( "Closing JDBC Connection " + x ) ; } pcon . close ( ) ; } } } public boolean hasActiveConnections ( ) { return ( m_pool . size ( ) > 0 ) ; } public void setPassword ( String p ) { m_ConnectionProtocol . put ( "password" , p ) ; } public void setUser ( String u ) { m_ConnectionProtocol . put ( "user" , u ) ; } public void setProtocol ( Properties p ) { Enumeration e = p . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; m_ConnectionProtocol . put ( key , p . getProperty ( key ) ) ; } } public void setMinConnections ( int n ) { m_PoolMinSize = n ; } public boolean testConnection ( ) { try { if ( DEBUG ) { System . out . println ( "Testing Connection" ) ; } Connection conn = getConnection ( ) ; if ( DEBUG ) { DatabaseMetaData dma = conn . getMetaData ( ) ; System . out . println ( "\nConnected to " + dma . getURL ( ) ) ; System . out . println ( "Driver   " + dma . getDriverName ( ) ) ; System . out . println ( "Version  " + dma . getDriverVersion ( ) ) ; System . out . println ( "" ) ; } if ( conn == null ) return false ; releaseConnection ( conn ) ; if ( DEBUG ) { System . out . println ( "Testing Connection, SUCCESS" ) ; } return true ; } catch ( Exception e ) { if ( DEBUG ) { System . out . println ( "Testing Connection, FAILED" ) ; e . printStackTrace ( ) ; } return false ; } } public synchronized Connection getConnection ( ) throws IllegalArgumentException , SQLException { PooledConnection pcon = null ; if ( m_pool . size ( ) < m_PoolMinSize ) { initializePool ( ) ; } for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { pcon . setInUse ( true ) ; return pcon . getConnection ( ) ; } } Connection con = createConnection ( ) ; pcon = new PooledConnection ( con ) ; pcon . setInUse ( true ) ; m_pool . addElement ( pcon ) ; return pcon . getConnection ( ) ; } public synchronized void releaseConnection ( Connection con ) throws SQLException { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . getConnection ( ) == con ) { if ( DEBUG ) { System . out . println ( "Releasing Connection " + x ) ; } if ( ! isEnabled ( ) ) { con . close ( ) ; m_pool . removeElementAt ( x ) ; if ( DEBUG ) { System . out . println ( "-->Inactive Pool, Closing connection" ) ; } } else { pcon . setInUse ( false ) ; } break ; } } } public synchronized void releaseConnectionOnError ( Connection con ) throws SQLException { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . getConnection ( ) == con ) { if ( DEBUG ) { System . out . println ( "Releasing Connection On Error" + x ) ; } con . close ( ) ; m_pool . removeElementAt ( x ) ; if ( DEBUG ) { System . out . println ( "-->Inactive Pool, Closing connection" ) ; } break ; } } } private Connection createConnection ( ) throws SQLException { Connection con = null ; con = m_Driver . connect ( m_url , m_ConnectionProtocol ) ; return con ; } public synchronized void initializePool ( ) throws IllegalArgumentException , SQLException { if ( m_driver == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_DRIVER_NAME_SPECIFIED , null ) ) ; } if ( m_url == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_URL_SPECIFIED , null ) ) ; } if ( m_PoolMinSize < 1 ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_POOLSIZE_LESS_THAN_ONE , null ) ) ; } try { Class cls = null ; try { Method m = Thread . class . getMethod ( "getContextClassLoader" , null ) ; ClassLoader classLoader = ( ClassLoader ) m . invoke ( Thread . currentThread ( ) , null ) ; cls = classLoader . loadClass ( m_driver ) ; } catch ( Exception e ) { cls = Class . forName ( m_driver ) ; } if ( cls == null ) cls = Class . forName ( m_driver ) ; m_Driver = ( Driver ) cls . newInstance ( ) ; DriverManager . registerDriver ( m_Driver ) ; } catch ( ClassNotFoundException e ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_DRIVER_NAME , null ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_DRIVER_NAME , null ) ) ; } if ( ! m_IsActive ) return ; do { Connection con = createConnection ( ) ; if ( con != null ) { PooledConnection pcon = new PooledConnection ( con ) ; addConnection ( pcon ) ; if ( DEBUG ) System . out . println ( "Adding DB Connection to the Pool" ) ; } } while ( m_pool . size ( ) < m_PoolMinSize ) ; } private void addConnection ( PooledConnection value ) { m_pool . addElement ( value ) ; } protected void finalize ( ) throws Throwable { if ( DEBUG ) { System . out . println ( "In Default Connection Pool, Finalize" ) ; } for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { if ( DEBUG ) { System . out . println ( "Closing JDBC Connection " + x ) ; } PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { pcon . close ( ) ; } else { if ( DEBUG ) { System . out . println ( "--> Force close" ) ; } try { java . lang . Thread . sleep ( 30000 ) ; pcon . close ( ) ; } catch ( InterruptedException ie ) { if ( DEBUG ) System . err . println ( ie . getMessage ( ) ) ; } } } if ( DEBUG ) { System . out . println ( "Exit Default Connection Pool, Finalize" ) ; } super . finalize ( ) ; } public void setPoolEnabled ( boolean flag ) { m_IsActive = flag ; if ( ! flag ) freeUnused ( ) ; } } 	1	['20', '1', '0', '4', '53', '70', '1', '3', '16', '0.795321637', '451', '0.888888889', '0', '0', '0.214285714', '0', '0', '21.1', '3', '1.25', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemExsltFuncResult extends ElemVariable { public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext context = transformer . getXPathContext ( ) ; ElemExsltFunction owner = getOwnerFunction ( ) ; if ( owner != null ) { if ( owner . isResultSet ( ) ) throw new TransformerException ( "An EXSLT function cannot set more than one result!" ) ; int sourceNode = context . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; owner . setResult ( var ) ; } } public int getXSLToken ( ) { return Constants . EXSLT_ELEMNAME_FUNCRESULT ; } public String getNodeName ( ) { return Constants . EXSLT_ELEMNAME_FUNCRESULT_STRING ; } public ElemExsltFunction getOwnerFunction ( ) { ElemTemplateElement elem = this ; while ( ( elem != null ) && ! ( elem instanceof ElemExsltFunction ) ) { elem = elem . getParentElem ( ) ; } return ( ElemExsltFunction ) elem ; } } 	1	['5', '4', '0', '9', '13', '10', '3', '6', '5', '2', '54', '0', '0', '0.981900452', '0.6', '3', '7', '9.8', '3', '1.2', '2']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . VariableStack ; import org . apache . xpath . objects . XObject ; public class ElemParam extends ElemVariable { int m_qnameID ; public ElemParam ( ) { } public int getXSLToken ( ) { return Constants . ELEMNAME_PARAMVARIABLE ; } public String getNodeName ( ) { return Constants . ELEMNAME_PARAMVARIABLE_STRING ; } public ElemParam ( ElemParam param ) throws TransformerException { super ( param ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; m_qnameID = sroot . getComposeState ( ) . getQNameID ( m_qname ) ; if ( m_parentNode . getXSLToken ( ) == Constants . ELEMNAME_TEMPLATE ) ( ( ElemTemplate ) m_parentNode ) . m_inArgsSize ++ ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; VariableStack vars = transformer . getXPathContext ( ) . getVarStack ( ) ; if ( ! vars . isLocalSet ( m_index ) ) { int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , var ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } 	1	['6', '4', '0', '18', '21', '15', '7', '11', '6', '1', '80', '0', '0', '0.981900452', '0.375', '3', '8', '12.16666667', '1', '0.6667', '2']
package org . apache . xpath . patterns ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FunctionPattern extends StepPattern { public FunctionPattern ( Expression expr , int axis , int predaxis ) { super ( 0 , null , null , axis , predaxis ) ; m_functionExpr = expr ; } public final void calcScore ( ) { m_score = SCORE_OTHER ; if ( null == m_targetString ) calcTargetString ( ) ; } Expression m_functionExpr ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_functionExpr . fixupVariables ( vars , globalsSize ) ; } public XObject execute ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { DTMIterator nl = m_functionExpr . asIterator ( xctxt , context ) ; XNumber score = SCORE_NONE ; if ( null != nl ) { int n ; while ( DTM . NULL != ( n = nl . nextNode ( ) ) ) { score = ( n == context ) ? SCORE_OTHER : SCORE_NONE ; if ( score == SCORE_OTHER ) { context = n ; break ; } } } nl . detach ( ) ; return score ; } public XObject execute ( XPathContext xctxt , int context , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { DTMIterator nl = m_functionExpr . asIterator ( xctxt , context ) ; XNumber score = SCORE_NONE ; if ( null != nl ) { int n ; while ( DTM . NULL != ( n = nl . nextNode ( ) ) ) { score = ( n == context ) ? SCORE_OTHER : SCORE_NONE ; if ( score == SCORE_OTHER ) { context = n ; break ; } } nl . detach ( ) ; } return score ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = xctxt . getCurrentNode ( ) ; DTMIterator nl = m_functionExpr . asIterator ( xctxt , context ) ; XNumber score = SCORE_NONE ; if ( null != nl ) { int n ; while ( DTM . NULL != ( n = nl . nextNode ( ) ) ) { score = ( n == context ) ? SCORE_OTHER : SCORE_NONE ; if ( score == SCORE_OTHER ) { context = n ; break ; } } nl . detach ( ) ; } return score ; } class FunctionOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_functionExpr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FunctionPattern . this ) ; m_functionExpr = exp ; } } protected void callSubtreeVisitors ( XPathVisitor visitor ) { m_functionExpr . callVisitors ( new FunctionOwner ( ) , visitor ) ; super . callSubtreeVisitors ( visitor ) ; } } 	1	['7', '4', '0', '12', '18', '0', '3', '10', '6', '0.166666667', '156', '0', '1', '0.931034483', '0.367346939', '3', '16', '21.14285714', '2', '1', '1']
package org . apache . xml . utils ; public class Constants { public static final String S_XMLNAMESPACEURI = "http://www.w3.org/XML/1998/namespace" , S_XSLNAMESPACEURL = "http://www.w3.org/1999/XSL/Transform" , S_OLDXSLNAMESPACEURL = "http://www.w3.org/XSL/Transform/1.0" ; public static final String S_VENDOR = "Apache Software Foundation" , S_VENDORURL = "http://xml.apache.org" ; public static final String S_BUILTIN_EXTENSIONS_URL = "http://xml.apache.org/xalan" ; public static final String S_BUILTIN_OLD_EXTENSIONS_URL = "http://xml.apache.org/xslt" ; public static final String S_EXTENSIONS_OLD_JAVA_URL = "http://xml.apache.org/xslt/java" , S_EXTENSIONS_JAVA_URL = "http://xml.apache.org/xalan/java" , S_EXTENSIONS_LOTUSXSL_JAVA_URL = "http://xsl.lotus.com/java" , S_EXTENSIONS_XALANLIB_URL = "http://xml.apache.org/xalan" , S_EXTENSIONS_REDIRECT_URL = "http://xml.apache.org/xalan/redirect" , S_EXTENSIONS_PIPE_URL = "http://xml.apache.org/xalan/PipeDocument" , S_EXTENSIONS_SQL_URL = "http://xml.apache.org/xalan/sql" ; public static final String S_EXSLT_COMMON_URL = "http://exslt.org/common" , S_EXSLT_MATH_URL = "http://exslt.org/math" , S_EXSLT_SETS_URL = "http://exslt.org/sets" , S_EXSLT_DATETIME_URL = "http://exslt.org/dates-and-times" , S_EXSLT_FUNCTIONS_URL = "http://exslt.org/functions" , S_EXSLT_DYNAMIC_URL = "http://exslt.org/dynamic" , S_EXSLT_STRINGS_URL = "http://exslt.org/strings" ; public static final double XSLTVERSUPPORTED = 1.0 ; } 	1	['1', '1', '1', '1', '2', '0', '1', '0', '1', '2', '26', '0', '0', '0', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xalan . processor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . AVT ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . StringToIntTable ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . XMLChar ; import org . apache . xpath . XPath ; public class XSLTAttributeDef { static final int FATAL = 0 ; static final int ERROR = 1 ; static final int WARNING = 2 ; XSLTAttributeDef ( String namespace , String name , int type , boolean required , boolean supportsAVT , int errorType ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = type ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; } XSLTAttributeDef ( String namespace , String name , int type , boolean supportsAVT , int errorType , String defaultVal ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = type ; this . m_required = false ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; this . m_default = defaultVal ; } XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 2 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; } XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 , String k3 , int v3 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 3 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; m_enums . put ( k3 , v3 ) ; } XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 , String k3 , int v3 , String k4 , int v4 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 4 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; m_enums . put ( k3 , v3 ) ; m_enums . put ( k4 , v4 ) ; } static final int T_CDATA = 1 , T_URL = 2 , T_AVT = 3 , T_PATTERN = 4 , T_EXPR = 5 , T_CHAR = 6 , T_NUMBER = 7 , T_YESNO = 8 , T_QNAME = 9 , T_QNAMES = 10 , T_ENUM = 11 , T_SIMPLEPATTERNLIST = 12 , T_NMTOKEN = 13 , T_STRINGLIST = 14 , T_PREFIX_URLLIST = 15 , T_ENUM_OR_PQNAME = 16 , T_NCNAME = 17 , T_AVT_QNAME = 18 , T_QNAMES_RESOLVE_NULL = 19 ; static XSLTAttributeDef m_foreignAttr = new XSLTAttributeDef ( "*" , "*" , XSLTAttributeDef . T_CDATA , false , false , WARNING ) ; static String S_FOREIGNATTR_SETTER = "setForeignAttr" ; private String m_namespace ; String getNamespace ( ) { return m_namespace ; } private String m_name ; String getName ( ) { return m_name ; } private int m_type ; int getType ( ) { return m_type ; } private StringToIntTable m_enums ; private int getEnum ( String key ) { return m_enums . get ( key ) ; } private String [ ] getEnumNames ( ) { return m_enums . keys ( ) ; } private String m_default ; String getDefault ( ) { return m_default ; } void setDefault ( String def ) { m_default = def ; } private boolean m_required ; boolean getRequired ( ) { return m_required ; } private boolean m_supportsAVT ; boolean getSupportsAVT ( ) { return m_supportsAVT ; } int m_errorType = this . WARNING ; int getErrorType ( ) { return m_errorType ; } String m_setterString = null ; public String getSetterMethodName ( ) { if ( null == m_setterString ) { if ( m_foreignAttr == this ) { return S_FOREIGNATTR_SETTER ; } else if ( m_name . equals ( "*" ) ) { m_setterString = "addLiteralResultAttribute" ; return m_setterString ; } StringBuffer outBuf = new StringBuffer ( ) ; outBuf . append ( "set" ) ; if ( ( m_namespace != null ) && m_namespace . equals ( Constants . S_XMLNAMESPACEURI ) ) { outBuf . append ( "Xml" ) ; } int n = m_name . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char c = m_name . charAt ( i ) ; if ( '-' == c ) { i ++ ; c = m_name . charAt ( i ) ; c = Character . toUpperCase ( c ) ; } else if ( 0 == i ) { c = Character . toUpperCase ( c ) ; } outBuf . append ( c ) ; } m_setterString = outBuf . toString ( ) ; } return m_setterString ; } AVT processAVT ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } Object processCDATA ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { return value ; } } Object processCHAR ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( value . length ( ) != 1 ) ) { handleError ( handler , XSLTErrorResources . INVALID_TCHAR , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( value . length ( ) != 1 ) { handleError ( handler , XSLTErrorResources . INVALID_TCHAR , new Object [ ] { name , value } , null ) ; return null ; } return new Character ( value . charAt ( 0 ) ) ; } } Object processENUM ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { AVT avt = null ; if ( getSupportsAVT ( ) ) { try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ! avt . isSimple ( ) ) return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } int retVal = this . getEnum ( value ) ; if ( retVal == StringToIntTable . INVALID_KEY ) { StringBuffer enumNamesList = getListOfEnums ( ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , null ) ; return null ; } if ( getSupportsAVT ( ) ) return avt ; else return new Integer ( retVal ) ; } Object processENUM_OR_PQNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { Object objToReturn = null ; if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ! avt . isSimple ( ) ) return avt ; else objToReturn = avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } int enum = this . getEnum ( value ) ; if ( enum != StringToIntTable . INVALID_KEY ) { if ( objToReturn == null ) objToReturn = new Integer ( enum ) ; } else { try { QName qname = new QName ( value , handler , true ) ; if ( objToReturn == null ) objToReturn = qname ; if ( qname . getPrefix ( ) == null ) { StringBuffer enumNamesList = getListOfEnums ( ) ; enumNamesList . append ( " <qname-but-not-ncname>" ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , null ) ; return null ; } } catch ( IllegalArgumentException ie ) { StringBuffer enumNamesList = getListOfEnums ( ) ; enumNamesList . append ( " <qname-but-not-ncname>" ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , ie ) ; return null ; } catch ( RuntimeException re ) { StringBuffer enumNamesList = getListOfEnums ( ) ; enumNamesList . append ( " <qname-but-not-ncname>" ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , re ) ; return null ; } } return objToReturn ; } Object processEXPR ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { XPath expr = handler . createXPath ( value , owner ) ; return expr ; } catch ( TransformerException te ) { org . xml . sax . SAXException se = new org . xml . sax . SAXException ( te ) ; throw new org . xml . sax . SAXException ( te ) ; } } Object processNMTOKEN ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( ! XMLChar . isValidNmtoken ( value ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_NMTOKEN , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( ! XMLChar . isValidNmtoken ( value ) ) { handleError ( handler , XSLTErrorResources . INVALID_NMTOKEN , new Object [ ] { name , value } , null ) ; return null ; } } return value ; } Object processPATTERN ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { XPath pattern = handler . createMatchPatternXPath ( value , owner ) ; return pattern ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } Object processNUMBER ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { Double val ; AVT avt = null ; try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( avt . isSimple ( ) ) { val = Double . valueOf ( value ) ; } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } catch ( NumberFormatException nfe ) { handleError ( handler , XSLTErrorResources . INVALID_NUMBER , new Object [ ] { name , value } , nfe ) ; return null ; } return avt ; } else { try { return Double . valueOf ( value ) ; } catch ( NumberFormatException nfe ) { handleError ( handler , XSLTErrorResources . INVALID_NUMBER , new Object [ ] { name , value } , nfe ) ; return null ; } } } Object processQNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { QName qname = new QName ( value , handler , true ) ; return qname ; } catch ( IllegalArgumentException ie ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , ie ) ; return null ; } catch ( RuntimeException re ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , re ) ; return null ; } } Object processAVT_QNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { AVT avt = null ; try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( avt . isSimple ( ) ) { int indexOfNSSep = value . indexOf ( ':' ) ; if ( indexOfNSSep >= 0 ) { String prefix = value . substring ( 0 , indexOfNSSep ) ; if ( ! XMLChar . isValidNCName ( prefix ) ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , null ) ; return null ; } } String localName = ( indexOfNSSep < 0 ) ? value : value . substring ( indexOfNSSep + 1 ) ; if ( ( localName == null ) || ( localName . length ( ) == 0 ) || ( ! XMLChar . isValidNCName ( localName ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , null ) ; return null ; } } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } return avt ; } Object processNCNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { AVT avt = null ; try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( ! XMLChar . isValidNCName ( value ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_NCNAME , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( ! XMLChar . isValidNCName ( value ) ) { handleError ( handler , XSLTErrorResources . INVALID_NCNAME , new Object [ ] { name , value } , null ) ; return null ; } return value ; } } Vector processQNAMES ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nQNames = tokenizer . countTokens ( ) ; Vector qnames = new Vector ( nQNames ) ; for ( int i = 0 ; i < nQNames ; i ++ ) { qnames . addElement ( new QName ( tokenizer . nextToken ( ) , handler ) ) ; } return qnames ; } final Vector processQNAMESRNU ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nQNames = tokenizer . countTokens ( ) ; Vector qnames = new Vector ( nQNames ) ; String defaultURI = handler . getNamespaceForPrefix ( "" ) ; for ( int i = 0 ; i < nQNames ; i ++ ) { String tok = tokenizer . nextToken ( ) ; if ( tok . indexOf ( ':' ) == - 1 ) { qnames . addElement ( new QName ( defaultURI , tok ) ) ; } else { qnames . addElement ( new QName ( tok , handler ) ) ; } } return qnames ; } Vector processSIMPLEPATTERNLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nPatterns = tokenizer . countTokens ( ) ; Vector patterns = new Vector ( nPatterns ) ; for ( int i = 0 ; i < nPatterns ; i ++ ) { XPath pattern = handler . createMatchPatternXPath ( tokenizer . nextToken ( ) , owner ) ; patterns . addElement ( pattern ) ; } return patterns ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } StringVector processSTRINGLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { strings . addElement ( tokenizer . nextToken ( ) ) ; } return strings ; } StringVector processPREFIX_URLLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { String prefix = tokenizer . nextToken ( ) ; String url = handler . getNamespaceForPrefix ( prefix ) ; if ( url != null ) strings . addElement ( url ) ; else throw new org . xml . sax . SAXException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANT_RESOLVE_NSPREFIX , new Object [ ] { prefix } ) ) ; } return strings ; } Object processURL ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { return value ; } } private Boolean processYESNO ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { if ( ! ( value . equals ( "yes" ) || value . equals ( "no" ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_BOOLEAN , new Object [ ] { name , value } , null ) ; return null ; } return new Boolean ( value . equals ( "yes" ) ? true : false ) ; } Object processValue ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { int type = getType ( ) ; Object processedValue = null ; switch ( type ) { case T_AVT : processedValue = processAVT ( handler , uri , name , rawName , value , owner ) ; break ; case T_CDATA : processedValue = processCDATA ( handler , uri , name , rawName , value , owner ) ; break ; case T_CHAR : processedValue = processCHAR ( handler , uri , name , rawName , value , owner ) ; break ; case T_ENUM : processedValue = processENUM ( handler , uri , name , rawName , value , owner ) ; break ; case T_EXPR : processedValue = processEXPR ( handler , uri , name , rawName , value , owner ) ; break ; case T_NMTOKEN : processedValue = processNMTOKEN ( handler , uri , name , rawName , value , owner ) ; break ; case T_PATTERN : processedValue = processPATTERN ( handler , uri , name , rawName , value , owner ) ; break ; case T_NUMBER : processedValue = processNUMBER ( handler , uri , name , rawName , value , owner ) ; break ; case T_QNAME : processedValue = processQNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_QNAMES : processedValue = processQNAMES ( handler , uri , name , rawName , value ) ; break ; case T_QNAMES_RESOLVE_NULL : processedValue = processQNAMESRNU ( handler , uri , name , rawName , value ) ; break ; case T_SIMPLEPATTERNLIST : processedValue = processSIMPLEPATTERNLIST ( handler , uri , name , rawName , value , owner ) ; break ; case T_URL : processedValue = processURL ( handler , uri , name , rawName , value , owner ) ; break ; case T_YESNO : processedValue = processYESNO ( handler , uri , name , rawName , value ) ; break ; case T_STRINGLIST : processedValue = processSTRINGLIST ( handler , uri , name , rawName , value ) ; break ; case T_PREFIX_URLLIST : processedValue = processPREFIX_URLLIST ( handler , uri , name , rawName , value ) ; break ; case T_ENUM_OR_PQNAME : processedValue = processENUM_OR_PQNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_NCNAME : processedValue = processNCNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_AVT_QNAME : processedValue = processAVT_QNAME ( handler , uri , name , rawName , value , owner ) ; break ; default : } return processedValue ; } void setDefAttrValue ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { setAttrValue ( handler , this . getNamespace ( ) , this . getName ( ) , this . getName ( ) , this . getDefault ( ) , elem ) ; } private Class getPrimativeClass ( Object obj ) { if ( obj instanceof XPath ) return XPath . class ; Class cl = obj . getClass ( ) ; if ( cl == Double . class ) { cl = double . class ; } if ( cl == Float . class ) { cl = float . class ; } else if ( cl == Boolean . class ) { cl = boolean . class ; } else if ( cl == Byte . class ) { cl = byte . class ; } else if ( cl == Character . class ) { cl = char . class ; } else if ( cl == Short . class ) { cl = short . class ; } else if ( cl == Integer . class ) { cl = int . class ; } else if ( cl == Long . class ) { cl = long . class ; } return cl ; } private StringBuffer getListOfEnums ( ) { StringBuffer enumNamesList = new StringBuffer ( ) ; String [ ] enumValues = this . getEnumNames ( ) ; for ( int i = 0 ; i < enumValues . length ; i ++ ) { if ( i > 0 ) { enumNamesList . append ( ' ' ) ; } enumNamesList . append ( enumValues [ i ] ) ; } return enumNamesList ; } boolean setAttrValue ( StylesheetHandler handler , String attrUri , String attrLocalName , String attrRawName , String attrValue , ElemTemplateElement elem ) throws org . xml . sax . SAXException { if ( attrRawName . equals ( "xmlns" ) || attrRawName . startsWith ( "xmlns:" ) ) return true ; String setterString = getSetterMethodName ( ) ; if ( null != setterString ) { try { Method meth ; Object [ ] args ; if ( setterString . equals ( S_FOREIGNATTR_SETTER ) ) { if ( attrUri == null ) attrUri = "" ; Class sclass = attrUri . getClass ( ) ; Class [ ] argTypes = new Class [ ] { sclass , sclass , sclass , sclass } ; meth = elem . getClass ( ) . getMethod ( setterString , argTypes ) ; args = new Object [ ] { attrUri , attrLocalName , attrRawName , attrValue } ; } else { Object value = processValue ( handler , attrUri , attrLocalName , attrRawName , attrValue , elem ) ; if ( null == value ) return false ; Class [ ] argTypes = new Class [ ] { getPrimativeClass ( value ) } ; try { meth = elem . getClass ( ) . getMethod ( setterString , argTypes ) ; } catch ( NoSuchMethodException nsme ) { Class cl = ( ( Object ) value ) . getClass ( ) ; argTypes [ 0 ] = cl ; meth = elem . getClass ( ) . getMethod ( setterString , argTypes ) ; } args = new Object [ ] { value } ; } meth . invoke ( elem , args ) ; } catch ( NoSuchMethodException nsme ) { if ( ! setterString . equals ( S_FOREIGNATTR_SETTER ) ) { handler . error ( XSLTErrorResources . ER_FAILED_CALLING_METHOD , new Object [ ] { setterString } , nsme ) ; return false ; } } catch ( IllegalAccessException iae ) { handler . error ( XSLTErrorResources . ER_FAILED_CALLING_METHOD , new Object [ ] { setterString } , iae ) ; return false ; } catch ( InvocationTargetException nsme ) { handleError ( handler , XSLTErrorResources . WG_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_NAME , getName ( ) } , nsme ) ; return false ; } } return true ; } private void handleError ( StylesheetHandler handler , String msg , Object [ ] args , Exception exc ) throws org . xml . sax . SAXException { switch ( getErrorType ( ) ) { case ( FATAL ) : case ( ERROR ) : handler . error ( msg , args , exc ) ; break ; case ( WARNING ) : handler . warn ( msg , args ) ; default : break ; } } } 	1	['43', '1', '0', '14', '93', '783', '4', '10', '1', '0.962585034', '1969', '0.166666667', '2', '0', '0.328042328', '0', '0', '43.81395349', '19', '1.5349', '2']
package org . apache . xml . utils ; public final class BoolStack implements Cloneable { private boolean m_values [ ] ; private int m_allocatedSize ; private int m_index ; public BoolStack ( ) { this ( 32 ) ; } public BoolStack ( int size ) { m_allocatedSize = size ; m_values = new boolean [ size ] ; m_index = - 1 ; } public final int size ( ) { return m_index + 1 ; } public final boolean push ( boolean val ) { if ( m_index == m_allocatedSize - 1 ) grow ( ) ; return ( m_values [ ++ m_index ] = val ) ; } public final boolean pop ( ) { return m_values [ m_index -- ] ; } public final boolean popAndTop ( ) { m_index -- ; return ( m_index >= 0 ) ? m_values [ m_index ] : false ; } public final void setTop ( boolean b ) { m_values [ m_index ] = b ; } public final boolean peek ( ) { return m_values [ m_index ] ; } public final boolean peekOrFalse ( ) { return ( m_index > - 1 ) ? m_values [ m_index ] : false ; } public final boolean peekOrTrue ( ) { return ( m_index > - 1 ) ? m_values [ m_index ] : true ; } public boolean isEmpty ( ) { return ( m_index == - 1 ) ; } private void grow ( ) { m_allocatedSize *= 2 ; boolean newVector [ ] = new boolean [ m_allocatedSize ] ; System . arraycopy ( m_values , 0 , newVector , 0 , m_index + 1 ) ; m_values = newVector ; } public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } } 	1	['13', '1', '0', '9', '16', '0', '9', '0', '12', '0.361111111', '160', '1', '0', '0', '0.41025641', '0', '0', '11.07692308', '2', '1.2308', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncDoclocation extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int whereNode = getArg0AsNode ( xctxt ) ; String fileLocation = null ; if ( DTM . NULL != whereNode ) { DTM dtm = xctxt . getDTM ( whereNode ) ; if ( DTM . DOCUMENT_FRAGMENT_NODE == dtm . getNodeType ( whereNode ) ) { whereNode = dtm . getFirstChild ( whereNode ) ; } if ( DTM . NULL != whereNode ) { fileLocation = dtm . getDocumentBaseURI ( ) ; } } return new XString ( ( null != fileLocation ) ? fileLocation : "" ) ; } } 	1	['2', '5', '0', '5', '9', '1', '0', '5', '2', '2', '43', '0', '0', '0.982142857', '0.75', '2', '7', '20.5', '1', '0.5', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemMessage extends ElemTemplateElement { private boolean m_terminate = Constants . ATTRVAL_NO ; public void setTerminate ( boolean v ) { m_terminate = v ; } public boolean getTerminate ( ) { return m_terminate ; } public int getXSLToken ( ) { return Constants . ELEMNAME_MESSAGE ; } public String getNodeName ( ) { return Constants . ELEMNAME_MESSAGE_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; String data = transformer . transformToString ( this ) ; transformer . getMsgMgr ( ) . message ( this , data , m_terminate ) ; if ( m_terminate ) transformer . getErrorListener ( ) . fatalError ( new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_STYLESHEET_DIRECTED_TERMINATION , null ) ) ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } 	1	['6', '3', '0', '5', '17', '3', '0', '5', '6', '0.4', '60', '1', '0', '0.975124378', '0.444444444', '2', '4', '8.833333333', '1', '0.8333', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class RoundCall extends FunctionCall { public RoundCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; argument ( ) . translate ( classGen , methodGen ) ; il . append ( DUP2 ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( "java.lang.Double" , "isNaN" , "(D)Z" ) ) ) ; final BranchHandle skip = il . append ( new IFNE ( null ) ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( MATH_CLASS , "round" , "(D)J" ) ) ) ; il . append ( L2D ) ; skip . setTarget ( il . append ( NOP ) ) ; } } 	1	['2', '4', '0', '15', '13', '1', '0', '15', '2', '2', '61', '0', '0', '0.989690722', '0.6', '2', '4', '29.5', '1', '0.5', '1']
package org . apache . xalan . transformer ; public class ResultNameSpace { public ResultNameSpace m_next = null ; public String m_prefix ; public String m_uri ; public ResultNameSpace ( String prefix , String uri ) { m_prefix = prefix ; m_uri = uri ; } } 	1	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '16', '0', '1', '0', '1', '0', '0', '12', '0', '0', '1']
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . Source ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . DOMBuilder ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public final class XSLTCSource implements Source { private String _systemId = null ; private DOM _dom = null ; private final static String LEXICAL_HANDLER_PROPERTY = "http://xml.org/sax/properties/lexical-handler" ; public XSLTCSource ( int size ) { XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; int dtmPos = dtmManager . getFirstFreeDTMID ( ) ; int documentID = dtmPos << DTMManager . IDENT_DTM_NODE_BITS ; _dom = ( DOM ) new SAXImpl ( dtmManager , this , documentID , null , null , false , size , true ) ; dtmManager . addDTM ( ( DTM ) _dom , dtmPos ) ; } public XSLTCSource ( ) { XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; int dtmPos = dtmManager . getFirstFreeDTMID ( ) ; int documentID = dtmPos << DTMManager . IDENT_DTM_NODE_BITS ; _dom = ( DOM ) new SAXImpl ( dtmManager , this , documentID , null , null , false , true ) ; dtmManager . addDTM ( ( DTM ) _dom , dtmPos ) ; } public void setSystemId ( String systemId ) { if ( ( new File ( systemId ) ) . exists ( ) ) _systemId = "file:" + systemId ; else _systemId = systemId ; ( ( SAXImpl ) _dom ) . setDocumentURI ( _systemId ) ; } public String getSystemId ( ) { return ( _systemId ) ; } public void build ( XMLReader reader , String systemId ) throws SAXException { try { if ( ( systemId == null ) && ( _systemId == null ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . XSLTC_SOURCE_ERR ) ; throw new SAXException ( err . toString ( ) ) ; } if ( systemId == null ) systemId = _systemId ; setSystemId ( systemId ) ; InputSource input = new InputSource ( systemId ) ; DOMBuilder builder ; builder = ( ( SAXImpl ) _dom ) . getBuilder ( ) ; reader . setContentHandler ( builder ) ; reader . setDTDHandler ( builder ) ; try { reader . setProperty ( LEXICAL_HANDLER_PROPERTY , builder ) ; } catch ( SAXException e ) { } reader . parse ( input ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void build ( String systemId ) throws SAXException { try { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; build ( reader , systemId ) ; } catch ( ParserConfigurationException e ) { throw new SAXException ( e ) ; } } public void build ( XMLReader reader ) throws SAXException { build ( reader , _systemId ) ; } public void build ( ) throws SAXException { build ( _systemId ) ; } protected DOM getDOM ( ) { return ( _dom ) ; } } 	1	['9', '1', '0', '9', '34', '0', '1', '8', '8', '0.458333333', '206', '1', '1', '0', '0.416666667', '0', '0', '21.55555556', '2', '0.8889', '1']
package org . apache . xml . serializer ; import java . io . BufferedReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . net . URL ; import java . net . MalformedURLException ; import java . util . BitSet ; import java . util . Hashtable ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . Enumeration ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . CharKey ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . SystemIDResolver ; public class CharInfo { BitSet m_specialsMap = new BitSet ( 65535 ) ; private Hashtable m_charToEntityRef = new Hashtable ( ) ; public static String HTML_ENTITIES_RESOURCE = "org.apache.xml.serializer.HTMLEntities" ; public static String XML_ENTITIES_RESOURCE = "org.apache.xml.serializer.XMLEntities" ; public static final char S_LINEFEED = 0x0A ; public static char S_CARRIAGERETURN = 0x0D ; public CharInfo ( String entitiesResource ) { PropertyResourceBundle entities ; InputStream is = null ; BufferedReader reader = null ; int index ; String name ; String value ; int code ; String line ; entities = loadEntitiesResource ( entitiesResource ) ; if ( null != entities ) { Enumeration enum = entities . getKeys ( ) ; while ( enum . hasMoreElements ( ) ) { name = ( String ) enum . nextElement ( ) ; value = entities . getString ( name ) ; code = Integer . parseInt ( value ) ; defineEntity ( name , ( char ) code ) ; } m_specialsMap . set ( S_LINEFEED ) ; m_specialsMap . set ( S_CARRIAGERETURN ) ; } else { try { try { ClassLoader cl = CharInfo . class . getClassLoader ( ) ; if ( cl == null ) { is = ClassLoader . getSystemResourceAsStream ( entitiesResource ) ; } else { is = cl . getResourceAsStream ( entitiesResource ) ; } } catch ( Exception e ) { } if ( is == null ) { is = CharInfo . class . getResourceAsStream ( entitiesResource ) ; } if ( is == null ) { URL url = new URL ( entitiesResource ) ; is = url . openStream ( ) ; } if ( is == null ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_RESOURCE_COULD_NOT_FIND , new Object [ ] { entitiesResource , entitiesResource } ) ) ; } try { reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { reader = new BufferedReader ( new InputStreamReader ( is ) ) ; } line = reader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 || line . charAt ( 0 ) == '#' ) { line = reader . readLine ( ) ; continue ; } index = line . indexOf ( ' ' ) ; if ( index > 1 ) { name = line . substring ( 0 , index ) ; ++ index ; if ( index < line . length ( ) ) { value = line . substring ( index ) ; index = value . indexOf ( ' ' ) ; if ( index > 0 ) { value = value . substring ( 0 , index ) ; } code = Integer . parseInt ( value ) ; defineEntity ( name , ( char ) code ) ; } } line = reader . readLine ( ) ; } is . close ( ) ; m_specialsMap . set ( S_LINEFEED ) ; m_specialsMap . set ( S_CARRIAGERETURN ) ; } catch ( Exception except ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_RESOURCE_COULD_NOT_LOAD , new Object [ ] { entitiesResource , except . toString ( ) , entitiesResource , except . toString ( ) } ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( Exception except ) { } } } } } protected void defineEntity ( String name , char value ) { CharKey character = new CharKey ( value ) ; m_charToEntityRef . put ( character , name ) ; m_specialsMap . set ( value ) ; } private CharKey m_charKey = new CharKey ( ) ; synchronized public String getEntityNameForChar ( char value ) { m_charKey . setChar ( value ) ; return ( String ) m_charToEntityRef . get ( m_charKey ) ; } public boolean isSpecial ( char value ) { return m_specialsMap . get ( value ) ; } private static Hashtable m_getCharInfo_cache = null ; public static CharInfo getCharInfo ( String entitiesFileName ) { CharInfo retobj = null ; if ( null == m_getCharInfo_cache ) { synchronized ( XML_ENTITIES_RESOURCE ) { if ( null == m_getCharInfo_cache ) m_getCharInfo_cache = new Hashtable ( ) ; } } else { retobj = ( CharInfo ) m_getCharInfo_cache . get ( entitiesFileName ) ; } if ( retobj == null ) { try { retobj = new CharInfo ( entitiesFileName ) ; m_getCharInfo_cache . put ( entitiesFileName , retobj ) ; } catch ( Exception e ) { retobj = null ; } } if ( null == retobj ) { String absoluteEntitiesFileName ; if ( entitiesFileName . indexOf ( ':' ) < 0 ) { absoluteEntitiesFileName = SystemIDResolver . getAbsoluteURIFromRelative ( entitiesFileName ) ; } else { try { absoluteEntitiesFileName = SystemIDResolver . getAbsoluteURI ( entitiesFileName , null ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } retobj = new CharInfo ( absoluteEntitiesFileName ) ; m_getCharInfo_cache . put ( entitiesFileName , retobj ) ; } return retobj ; } private PropertyResourceBundle loadEntitiesResource ( String baseName ) throws MissingResourceException { try { Locale locale = Locale . getDefault ( ) ; java . lang . ClassLoader loader = this . getClass ( ) . getClassLoader ( ) ; return ( PropertyResourceBundle ) PropertyResourceBundle . getBundle ( baseName ) ; } catch ( MissingResourceException e ) { return null ; } } } 	1	['8', '1', '0', '7', '51', '14', '3', '4', '4', '0.80952381', '419', '0.333333333', '1', '0', '0.619047619', '0', '0', '50.25', '6', '1.375', '2']
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; public class Counter { static final int MAXCOUNTNODES = 500 ; int m_countNodesStartCount = 0 ; NodeSetDTM m_countNodes ; int m_fromNode = DTM . NULL ; ElemNumber m_numberElem ; int m_countResult ; Counter ( ElemNumber numberElem , NodeSetDTM countNodes ) throws TransformerException { m_countNodes = countNodes ; m_numberElem = numberElem ; } int getPreviouslyCounted ( XPathContext support , int node ) { int n = m_countNodes . size ( ) ; m_countResult = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int countedNode = m_countNodes . elementAt ( i ) ; if ( node == countedNode ) { m_countResult = i + 1 + m_countNodesStartCount ; break ; } DTM dtm = support . getDTM ( countedNode ) ; if ( dtm . isNodeAfter ( countedNode , node ) ) break ; } return m_countResult ; } int getLast ( ) { int size = m_countNodes . size ( ) ; return ( size > 0 ) ? m_countNodes . elementAt ( size - 1 ) : DTM . NULL ; } } 	1	['3', '1', '0', '5', '8', '0', '1', '4', '0', '0.833333333', '84', '0', '2', '0', '0.466666667', '0', '0', '25', '4', '2', '1']
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; public class ElemUse extends ElemTemplateElement { private QName m_attributeSetsNames [ ] = null ; public void setUseAttributeSets ( Vector v ) { int n = v . size ( ) ; m_attributeSetsNames = new QName [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { m_attributeSetsNames [ i ] = ( QName ) v . elementAt ( i ) ; } } public void setUseAttributeSets ( QName [ ] v ) { m_attributeSetsNames = v ; } public QName [ ] getUseAttributeSets ( ) { return m_attributeSetsNames ; } public void applyAttrSets ( TransformerImpl transformer , StylesheetRoot stylesheet ) throws TransformerException { applyAttrSets ( transformer , stylesheet , m_attributeSetsNames ) ; } private void applyAttrSets ( TransformerImpl transformer , StylesheetRoot stylesheet , QName attributeSetsNames [ ] ) throws TransformerException { if ( null != attributeSetsNames ) { int nNames = attributeSetsNames . length ; for ( int i = 0 ; i < nNames ; i ++ ) { QName qname = attributeSetsNames [ i ] ; Vector attrSets = stylesheet . getAttributeSetComposed ( qname ) ; if ( null != attrSets ) { int nSets = attrSets . size ( ) ; for ( int k = nSets - 1 ; k >= 0 ; k -- ) { ElemAttributeSet attrSet = ( ElemAttributeSet ) attrSets . elementAt ( k ) ; attrSet . execute ( transformer ) ; } } } } } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; if ( null != m_attributeSetsNames ) { applyAttrSets ( transformer , getStylesheetRoot ( ) , m_attributeSetsNames ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } 	1	['7', '3', '4', '9', '16', '0', '4', '6', '6', '0.166666667', '119', '1', '1', '0.97029703', '0.428571429', '0', '0', '15.85714286', '2', '1', '2']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; public class Function3Args extends Function2Args { Expression m_arg2 ; public Expression getArg2 ( ) { return m_arg2 ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_arg2 ) m_arg2 . fixupVariables ( vars , globalsSize ) ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( argNum < 2 ) super . setArg ( arg , argNum ) ; else if ( 2 == argNum ) { m_arg2 = arg ; arg . exprSetParent ( this ) ; } else reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 3 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "three" , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return super . canTraverseOutsideSubtree ( ) ? true : m_arg2 . canTraverseOutsideSubtree ( ) ; } class Arg2Owner implements ExpressionOwner { public Expression getExpression ( ) { return m_arg2 ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( Function3Args . this ) ; m_arg2 = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { super . callArgVisitors ( visitor ) ; if ( null != m_arg2 ) m_arg2 . callVisitors ( new Arg2Owner ( ) , visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( null != m_arg2 ) { if ( null == ( ( Function3Args ) expr ) . m_arg2 ) return false ; if ( ! m_arg2 . deepEquals ( ( ( Function3Args ) expr ) . m_arg2 ) ) return false ; } else if ( null != ( ( Function3Args ) expr ) . m_arg2 ) return false ; return true ; } } 	1	['9', '5', '4', '12', '23', '6', '5', '8', '8', '0.375', '124', '0', '1', '0.875', '0.355555556', '4', '15', '12.66666667', '6', '1.7778', '1']
package org . apache . xalan . templates ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . QName ; import org . apache . xpath . Expression ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . PsuedoNames ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . patterns . UnionPattern ; public class TemplateList implements java . io . Serializable { public TemplateList ( ) { super ( ) ; } public void setTemplate ( ElemTemplate template ) { if ( null != template . getName ( ) ) { ElemTemplate existingTemplate = ( ElemTemplate ) m_namedTemplates . get ( template . getName ( ) ) ; if ( null == existingTemplate ) { m_namedTemplates . put ( template . getName ( ) , template ) ; } else { int existingPrecedence = existingTemplate . getStylesheetComposed ( ) . getImportCountComposed ( ) ; int newPrecedence = template . getStylesheetComposed ( ) . getImportCountComposed ( ) ; if ( newPrecedence > existingPrecedence ) { m_namedTemplates . put ( template . getName ( ) , template ) ; } else if ( newPrecedence == existingPrecedence ) template . error ( XSLTErrorResources . ER_DUPLICATE_NAMED_TEMPLATE , new Object [ ] { template . getName ( ) } ) ; } } XPath matchXPath = template . getMatch ( ) ; if ( null != matchXPath ) { Expression matchExpr = matchXPath . getExpression ( ) ; if ( matchExpr instanceof StepPattern ) { insertPatternInTable ( ( StepPattern ) matchExpr , template ) ; } else if ( matchExpr instanceof UnionPattern ) { UnionPattern upat = ( UnionPattern ) matchExpr ; StepPattern [ ] pats = upat . getPatterns ( ) ; int n = pats . length ; for ( int i = 0 ; i < n ; i ++ ) { insertPatternInTable ( pats [ i ] , template ) ; } } else { } } } static boolean DEBUG = false ; void dumpAssociationTables ( ) { Enumeration associations = m_patternTable . elements ( ) ; while ( associations . hasMoreElements ( ) ) { TemplateSubPatternAssociation head = ( TemplateSubPatternAssociation ) associations . nextElement ( ) ; while ( null != head ) { System . out . print ( "(" + head . getTargetString ( ) + ", " + head . getPattern ( ) + ")" ) ; head = head . getNext ( ) ; } System . out . println ( "\n....." ) ; } TemplateSubPatternAssociation head = m_wildCardPatterns ; System . out . print ( "wild card list: " ) ; while ( null != head ) { System . out . print ( "(" + head . getTargetString ( ) + ", " + head . getPattern ( ) + ")" ) ; head = head . getNext ( ) ; } System . out . println ( "\n....." ) ; } public void compose ( StylesheetRoot sroot ) { if ( DEBUG ) { System . out . println ( "Before wildcard insert..." ) ; dumpAssociationTables ( ) ; } if ( null != m_wildCardPatterns ) { Enumeration associations = m_patternTable . elements ( ) ; while ( associations . hasMoreElements ( ) ) { TemplateSubPatternAssociation head = ( TemplateSubPatternAssociation ) associations . nextElement ( ) ; TemplateSubPatternAssociation wild = m_wildCardPatterns ; while ( null != wild ) { try { head = insertAssociationIntoList ( head , ( TemplateSubPatternAssociation ) wild . clone ( ) , true ) ; } catch ( CloneNotSupportedException cnse ) { } wild = wild . getNext ( ) ; } } } if ( DEBUG ) { System . out . println ( "After wildcard insert..." ) ; dumpAssociationTables ( ) ; } } private TemplateSubPatternAssociation insertAssociationIntoList ( TemplateSubPatternAssociation head , TemplateSubPatternAssociation item , boolean isWildCardInsert ) { double priority = getPriorityOrScore ( item ) ; double workPriority ; int importLevel = item . getImportLevel ( ) ; int docOrder = item . getDocOrderPos ( ) ; TemplateSubPatternAssociation insertPoint = head ; TemplateSubPatternAssociation next ; boolean insertBefore ; while ( true ) { next = insertPoint . getNext ( ) ; if ( null == next ) break ; else { workPriority = getPriorityOrScore ( next ) ; if ( importLevel > next . getImportLevel ( ) ) break ; else if ( importLevel < next . getImportLevel ( ) ) insertPoint = next ; else if ( priority > workPriority ) break ; else if ( priority < workPriority ) insertPoint = next ; else if ( docOrder >= next . getDocOrderPos ( ) ) break ; else insertPoint = next ; } } if ( ( null == next ) || ( insertPoint == head ) ) { workPriority = getPriorityOrScore ( insertPoint ) ; if ( importLevel > insertPoint . getImportLevel ( ) ) insertBefore = true ; else if ( importLevel < insertPoint . getImportLevel ( ) ) insertBefore = false ; else if ( priority > workPriority ) insertBefore = true ; else if ( priority < workPriority ) insertBefore = false ; else if ( docOrder >= insertPoint . getDocOrderPos ( ) ) insertBefore = true ; else insertBefore = false ; } else insertBefore = false ; if ( isWildCardInsert ) { if ( insertBefore ) { item . setNext ( insertPoint ) ; String key = insertPoint . getTargetString ( ) ; item . setTargetString ( key ) ; putHead ( key , item ) ; return item ; } else { item . setNext ( next ) ; insertPoint . setNext ( item ) ; return head ; } } else { if ( insertBefore ) { item . setNext ( insertPoint ) ; if ( insertPoint . isWild ( ) || item . isWild ( ) ) m_wildCardPatterns = item ; else putHead ( item . getTargetString ( ) , item ) ; return item ; } else { item . setNext ( next ) ; insertPoint . setNext ( item ) ; return head ; } } } private void insertPatternInTable ( StepPattern pattern , ElemTemplate template ) { String target = pattern . getTargetString ( ) ; if ( null != target ) { String pstring = template . getMatch ( ) . getPatternString ( ) ; TemplateSubPatternAssociation association = new TemplateSubPatternAssociation ( template , pattern , pstring ) ; boolean isWildCard = association . isWild ( ) ; TemplateSubPatternAssociation head = isWildCard ? m_wildCardPatterns : getHead ( target ) ; if ( null == head ) { if ( isWildCard ) m_wildCardPatterns = association ; else putHead ( target , association ) ; } else { insertAssociationIntoList ( head , association , false ) ; } } } private double getPriorityOrScore ( TemplateSubPatternAssociation matchPat ) { double priority = matchPat . getTemplate ( ) . getPriority ( ) ; if ( priority == XPath . MATCH_SCORE_NONE ) { Expression ex = matchPat . getStepPattern ( ) ; if ( ex instanceof NodeTest ) { return ( ( NodeTest ) ex ) . getDefaultScore ( ) ; } } return priority ; } public ElemTemplate getTemplate ( QName qname ) { return ( ElemTemplate ) m_namedTemplates . get ( qname ) ; } public TemplateSubPatternAssociation getHead ( XPathContext xctxt , int targetNode , DTM dtm ) { short targetNodeType = dtm . getNodeType ( targetNode ) ; TemplateSubPatternAssociation head ; switch ( targetNodeType ) { case DTM . ELEMENT_NODE : case DTM . ATTRIBUTE_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalName ( targetNode ) ) ; break ; case DTM . TEXT_NODE : case DTM . CDATA_SECTION_NODE : head = m_textPatterns ; break ; case DTM . ENTITY_REFERENCE_NODE : case DTM . ENTITY_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalName ( targetNode ) ) ; break ; case DTM . COMMENT_NODE : head = m_commentPatterns ; break ; case DTM . DOCUMENT_NODE : case DTM . DOCUMENT_FRAGMENT_NODE : head = m_docPatterns ; break ; case DTM . NOTATION_NODE : default : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; } return ( null == head ) ? m_wildCardPatterns : head ; } public ElemTemplate getTemplateFast ( XPathContext xctxt , int targetNode , int expTypeID , QName mode , int maxImportLevel , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { TemplateSubPatternAssociation head ; switch ( dtm . getNodeType ( targetNode ) ) { case DTM . ELEMENT_NODE : case DTM . ATTRIBUTE_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalNameFromExpandedNameID ( expTypeID ) ) ; break ; case DTM . TEXT_NODE : case DTM . CDATA_SECTION_NODE : head = m_textPatterns ; break ; case DTM . ENTITY_REFERENCE_NODE : case DTM . ENTITY_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalName ( targetNode ) ) ; break ; case DTM . COMMENT_NODE : head = m_commentPatterns ; break ; case DTM . DOCUMENT_NODE : case DTM . DOCUMENT_FRAGMENT_NODE : head = m_docPatterns ; break ; case DTM . NOTATION_NODE : default : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; } if ( null == head ) { head = m_wildCardPatterns ; if ( null == head ) return null ; } xctxt . pushNamespaceContextNull ( ) ; try { do { if ( ( maxImportLevel > - 1 ) && ( head . getImportLevel ( ) > maxImportLevel ) ) { continue ; } ElemTemplate template = head . getTemplate ( ) ; xctxt . setNamespaceContext ( template ) ; if ( ( head . m_stepPattern . execute ( xctxt , targetNode , dtm , expTypeID ) != NodeTest . SCORE_NONE ) && head . matchMode ( mode ) ) { if ( quietConflictWarnings ) checkConflicts ( head , xctxt , targetNode , mode ) ; return template ; } } while ( null != ( head = head . getNext ( ) ) ) ; } finally { xctxt . popNamespaceContext ( ) ; } return null ; } public ElemTemplate getTemplate ( XPathContext xctxt , int targetNode , QName mode , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { TemplateSubPatternAssociation head = getHead ( xctxt , targetNode , dtm ) ; if ( null != head ) { xctxt . pushNamespaceContextNull ( ) ; xctxt . pushCurrentNodeAndExpression ( targetNode , targetNode ) ; try { do { ElemTemplate template = head . getTemplate ( ) ; xctxt . setNamespaceContext ( template ) ; if ( ( head . m_stepPattern . execute ( xctxt , targetNode ) != NodeTest . SCORE_NONE ) && head . matchMode ( mode ) ) { if ( quietConflictWarnings ) checkConflicts ( head , xctxt , targetNode , mode ) ; return template ; } } while ( null != ( head = head . getNext ( ) ) ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; xctxt . popNamespaceContext ( ) ; } } return null ; } public ElemTemplate getTemplate ( XPathContext xctxt , int targetNode , QName mode , int maxImportLevel , int endImportLevel , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { TemplateSubPatternAssociation head = getHead ( xctxt , targetNode , dtm ) ; if ( null != head ) { xctxt . pushNamespaceContextNull ( ) ; xctxt . pushCurrentNodeAndExpression ( targetNode , targetNode ) ; try { do { if ( ( maxImportLevel > - 1 ) && ( head . getImportLevel ( ) > maxImportLevel ) ) { continue ; } if ( head . getImportLevel ( ) <= maxImportLevel - endImportLevel ) return null ; ElemTemplate template = head . getTemplate ( ) ; xctxt . setNamespaceContext ( template ) ; if ( ( head . m_stepPattern . execute ( xctxt , targetNode ) != NodeTest . SCORE_NONE ) && head . matchMode ( mode ) ) { if ( quietConflictWarnings ) checkConflicts ( head , xctxt , targetNode , mode ) ; return template ; } } while ( null != ( head = head . getNext ( ) ) ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; xctxt . popNamespaceContext ( ) ; } } return null ; } public TemplateWalker getWalker ( ) { return new TemplateWalker ( ) ; } private void checkConflicts ( TemplateSubPatternAssociation head , XPathContext xctxt , int targetNode , QName mode ) { } private void addObjectIfNotFound ( Object obj , Vector v ) { int n = v . size ( ) ; boolean addIt = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( v . elementAt ( i ) == obj ) { addIt = false ; break ; } } if ( addIt ) { v . addElement ( obj ) ; } } private Hashtable m_namedTemplates = new Hashtable ( 89 ) ; private Hashtable m_patternTable = new Hashtable ( 89 ) ; private TemplateSubPatternAssociation m_wildCardPatterns = null ; private TemplateSubPatternAssociation m_textPatterns = null ; private TemplateSubPatternAssociation m_docPatterns = null ; private TemplateSubPatternAssociation m_commentPatterns = null ; private Hashtable getNamedTemplates ( ) { return m_namedTemplates ; } private void setNamedTemplates ( Hashtable v ) { m_namedTemplates = v ; } private TemplateSubPatternAssociation getHead ( String key ) { return ( TemplateSubPatternAssociation ) m_patternTable . get ( key ) ; } private void putHead ( String key , TemplateSubPatternAssociation assoc ) { if ( key . equals ( PsuedoNames . PSEUDONAME_TEXT ) ) m_textPatterns = assoc ; else if ( key . equals ( PsuedoNames . PSEUDONAME_ROOT ) ) m_docPatterns = assoc ; else if ( key . equals ( PsuedoNames . PSEUDONAME_COMMENT ) ) m_commentPatterns = assoc ; m_patternTable . put ( key , assoc ) ; } public class TemplateWalker { private Enumeration hashIterator ; private boolean inPatterns ; private TemplateSubPatternAssociation curPattern ; private Hashtable m_compilerCache = new Hashtable ( ) ; private TemplateWalker ( ) { hashIterator = m_patternTable . elements ( ) ; inPatterns = true ; curPattern = null ; } public ElemTemplate next ( ) { ElemTemplate retValue = null ; ElemTemplate ct ; while ( true ) { if ( inPatterns ) { if ( null != curPattern ) curPattern = curPattern . getNext ( ) ; if ( null != curPattern ) retValue = curPattern . getTemplate ( ) ; else { if ( hashIterator . hasMoreElements ( ) ) { curPattern = ( TemplateSubPatternAssociation ) hashIterator . nextElement ( ) ; retValue = curPattern . getTemplate ( ) ; } else { inPatterns = false ; hashIterator = m_namedTemplates . elements ( ) ; } } } if ( ! inPatterns ) { if ( hashIterator . hasMoreElements ( ) ) retValue = ( ElemTemplate ) hashIterator . nextElement ( ) ; else return null ; } ct = ( ElemTemplate ) m_compilerCache . get ( new Integer ( retValue . getUid ( ) ) ) ; if ( null == ct ) { m_compilerCache . put ( new Integer ( retValue . getUid ( ) ) , retValue ) ; return retValue ; } } } } } 	1	['22', '1', '0', '18', '74', '121', '3', '17', '9', '0.680272109', '943', '0.857142857', '4', '0', '0.180952381', '0', '0', '41.54545455', '19', '3.0455', '2']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncLast extends Function { private boolean m_isTopLevel ; public void postCompileStep ( Compiler compiler ) { m_isTopLevel = compiler . getLocationPathDepth ( ) == - 1 ; } public int getCountOfContextNodeList ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { SubContextList iter = m_isTopLevel ? null : xctxt . getSubContextList ( ) ; if ( null != iter ) return iter . getLastPos ( xctxt ) ; DTMIterator cnl = xctxt . getContextNodeList ( ) ; int count ; if ( null != cnl ) { count = cnl . getLength ( ) ; } else count = 0 ; return count ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XNumber xnum = new XNumber ( ( double ) getCountOfContextNodeList ( xctxt ) ) ; return xnum ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	1	['5', '3', '0', '8', '12', '8', '1', '7', '5', '0.5', '59', '1', '0', '0.904761905', '0.4', '1', '6', '10.6', '2', '1', '1']
package org . apache . xalan . transformer ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class KeyTable { private int m_docKey ; private Vector m_keyDeclarations ; private Hashtable m_refsTable = null ; public int getDocKey ( ) { return m_docKey ; } private XNodeSet m_keyNodes ; KeyIterator getKeyIterator ( ) { return ( KeyIterator ) ( m_keyNodes . getContainedIter ( ) ) ; } public KeyTable ( int doc , PrefixResolver nscontext , QName name , Vector keyDeclarations , XPathContext xctxt ) throws javax . xml . transform . TransformerException { m_docKey = doc ; m_keyDeclarations = keyDeclarations ; KeyIterator ki = new KeyIterator ( name , keyDeclarations ) ; m_keyNodes = new XNodeSet ( ki ) ; m_keyNodes . allowDetachToRelease ( false ) ; m_keyNodes . setRoot ( doc , xctxt ) ; } public XNodeSet getNodeSetDTMByKey ( QName name , XMLString ref ) { XNodeSet refNodes = ( XNodeSet ) getRefsTable ( ) . get ( ref ) ; try { if ( refNodes != null ) { refNodes = ( XNodeSet ) refNodes . cloneWithReset ( ) ; } } catch ( CloneNotSupportedException e ) { refNodes = null ; } if ( refNodes == null ) { KeyIterator ki = ( KeyIterator ) ( m_keyNodes ) . getContainedIter ( ) ; XPathContext xctxt = ki . getXPathContext ( ) ; refNodes = new XNodeSet ( xctxt . getDTMManager ( ) ) { public void setRoot ( int nodeHandle , Object environment ) { } } ; refNodes . reset ( ) ; } return refNodes ; } public QName getKeyTableName ( ) { return getKeyIterator ( ) . getName ( ) ; } private KeyDeclaration getKeyDeclaration ( ) { int nDeclarations = m_keyDeclarations . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) m_keyDeclarations . elementAt ( i ) ; if ( kd . getName ( ) . equals ( getKeyTableName ( ) ) ) { return kd ; } } return null ; } private Hashtable getRefsTable ( ) { if ( m_refsTable == null ) { m_refsTable = new Hashtable ( 89 ) ; KeyIterator ki = ( KeyIterator ) ( m_keyNodes ) . getContainedIter ( ) ; XPathContext xctxt = ki . getXPathContext ( ) ; KeyDeclaration keyDeclaration = getKeyDeclaration ( ) ; int currentNode ; m_keyNodes . reset ( ) ; while ( DTM . NULL != ( currentNode = m_keyNodes . nextNode ( ) ) ) { try { XObject xuse = keyDeclaration . getUse ( ) . execute ( xctxt , currentNode , ki . getPrefixResolver ( ) ) ; if ( xuse . getType ( ) != xuse . CLASS_NODESET ) { XMLString exprResult = xuse . xstr ( ) ; addValueInRefsTable ( xctxt , exprResult , currentNode ) ; } else { DTMIterator i = ( ( XNodeSet ) xuse ) . iterRaw ( ) ; int currentNodeInUseClause ; while ( DTM . NULL != ( currentNodeInUseClause = i . nextNode ( ) ) ) { DTM dtm = xctxt . getDTM ( currentNodeInUseClause ) ; XMLString exprResult = dtm . getStringValue ( currentNodeInUseClause ) ; addValueInRefsTable ( xctxt , exprResult , currentNode ) ; } } } catch ( TransformerException te ) { throw new WrappedRuntimeException ( te ) ; } } } return m_refsTable ; } private void addValueInRefsTable ( XPathContext xctxt , XMLString ref , int node ) { XNodeSet nodes = ( XNodeSet ) m_refsTable . get ( ref ) ; if ( nodes == null ) { nodes = new XNodeSet ( node , xctxt . getDTMManager ( ) ) ; nodes . nextNode ( ) ; m_refsTable . put ( ref , nodes ) ; } else { if ( nodes . getCurrentNode ( ) != node ) { nodes . mutableNodeset ( ) . addNode ( node ) ; nodes . nextNode ( ) ; } } } } 	1	['8', '1', '0', '16', '42', '8', '2', '15', '4', '0.607142857', '246', '1', '1', '0', '0.321428571', '0', '0', '29.25', '4', '1.875', '1']
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . Serializable ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . Properties ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . URIResolver ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; public final class TemplatesImpl implements Templates , Serializable { private static String ABSTRACT_TRANSLET = "org.apache.xalan.xsltc.runtime.AbstractTranslet" ; private String _name = null ; private byte [ ] [ ] _bytecodes = null ; private Translet _translet = null ; private Class [ ] _class = null ; private int _transletIndex = - 1 ; private Properties _outputProperties ; private int _indentNumber ; private URIResolver _uriResolver = null ; private transient TransformerFactoryImpl _tfactory = null ; private class TransletClassLoader extends ClassLoader { protected TransletClassLoader ( ClassLoader parent ) { super ( parent ) ; } public Class defineClass ( byte [ ] b ) { return super . defineClass ( null , b , 0 , b . length ) ; } } protected TemplatesImpl ( byte [ ] [ ] bytecodes , String transletName , Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { _bytecodes = bytecodes ; _name = transletName ; _outputProperties = outputProperties ; _indentNumber = indentNumber ; _tfactory = tfactory ; } protected TemplatesImpl ( Translet translet , String transletName , Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { _translet = translet ; _name = transletName ; _outputProperties = outputProperties ; _indentNumber = indentNumber ; _tfactory = tfactory ; } public TemplatesImpl ( ) { } private void readObject ( ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject ( ) ; _tfactory = new TransformerFactoryImpl ( ) ; } public synchronized void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } protected synchronized void setTransletBytecodes ( byte [ ] [ ] bytecodes ) { _bytecodes = bytecodes ; } public synchronized byte [ ] [ ] getTransletBytecodes ( ) { return _bytecodes ; } public synchronized Class [ ] getTransletClasses ( ) { try { if ( _class == null ) defineTransletClasses ( ) ; } catch ( TransformerConfigurationException e ) { } return _class ; } public synchronized int getTransletIndex ( ) { try { if ( _class == null ) defineTransletClasses ( ) ; } catch ( TransformerConfigurationException e ) { } return _transletIndex ; } protected synchronized void setTransletName ( String name ) { _name = name ; } protected synchronized String getTransletName ( ) { return _name ; } private void defineTransletClasses ( ) throws TransformerConfigurationException { if ( _bytecodes == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NO_TRANSLET_CLASS_ERR ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } TransletClassLoader loader = ( TransletClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new TransletClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } ) ; try { final int classCount = _bytecodes . length ; _class = new Class [ classCount ] ; for ( int i = 0 ; i < classCount ; i ++ ) { _class [ i ] = loader . defineClass ( _bytecodes [ i ] ) ; final Class superClass = _class [ i ] . getSuperclass ( ) ; if ( superClass . getName ( ) . equals ( ABSTRACT_TRANSLET ) ) { _transletIndex = i ; } } if ( _transletIndex < 0 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NO_MAIN_TRANSLET_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } catch ( ClassFormatError e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_CLASS_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( LinkageError e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } private Translet getTransletInstance ( ) throws TransformerConfigurationException { try { if ( _name == null ) return null ; if ( _class == null ) defineTransletClasses ( ) ; Translet translet = ( Translet ) _class [ _transletIndex ] . newInstance ( ) ; final int classCount = _bytecodes . length ; for ( int i = 0 ; i < classCount ; i ++ ) { if ( i != _transletIndex ) { translet . addAuxiliaryClass ( _class [ i ] ) ; } } return translet ; } catch ( InstantiationException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( IllegalAccessException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } public synchronized Transformer newTransformer ( ) throws TransformerConfigurationException { TransformerImpl transformer ; if ( _translet != null ) { transformer = new TransformerImpl ( _translet , _outputProperties , _indentNumber , _tfactory ) ; } else { transformer = new TransformerImpl ( getTransletInstance ( ) , _outputProperties , _indentNumber , _tfactory ) ; } if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return transformer ; } public synchronized Properties getOutputProperties ( ) { try { return newTransformer ( ) . getOutputProperties ( ) ; } catch ( TransformerConfigurationException e ) { return null ; } } } 	1	['16', '1', '0', '7', '34', '10', '4', '6', '7', '0.586666667', '399', '1', '2', '0', '0.214814815', '0', '0', '23.3125', '1', '0.75', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFGE ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; final class Key extends TopLevelElement { private QName _name ; private Pattern _match ; private Expression _use ; private Type _useType ; public void parseContents ( Parser parser ) { _name = parser . getQNameIgnoreDefaultNs ( getAttribute ( "name" ) ) ; _match = parser . parsePattern ( this , "match" , null ) ; _use = parser . parseExpression ( this , "use" , null ) ; if ( _name == null ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; return ; } if ( _match . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "match" ) ; return ; } if ( _use . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "use" ) ; return ; } } public String getName ( ) { return _name . toString ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _match . typeCheck ( stable ) ; _useType = _use . typeCheck ( stable ) ; if ( _useType instanceof StringType == false && _useType instanceof NodeSetType == false ) { _use = new CastExpr ( _use , Type . String ) ; } return Type . Void ; } public void traverseNodeSet ( ClassGenerator classGen , MethodGenerator methodGen , int buildKeyIndex ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeValue = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , "(I)" + STRING_SIG ) ; final int getNodeIdent = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeIdent" , "(I)" + NODE_SIG ) ; final int keyDom = cpg . addMethodref ( TRANSLET_CLASS , "setKeyIndexDom" , "(" + STRING_SIG + DOM_INTF_SIG + ")V" ) ; final LocalVariableGen parentNode = methodGen . addLocalVariable ( "parentNode" , Util . getJCRefType ( "I" ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( parentNode . getIndex ( ) ) ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( new ISTORE ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; _use . translate ( classGen , methodGen ) ; _use . startResetIterator ( classGen , methodGen ) ; il . append ( methodGen . storeIterator ( ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( new ILOAD ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( getNodeValue , 2 ) ) ; il . append ( new INVOKEVIRTUAL ( buildKeyIndex ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , getName ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( keyDom ) ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGE ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; final int key = cpg . addMethodref ( TRANSLET_CLASS , "buildKeyIndex" , "(" + STRING_SIG + "I" + OBJECT_SIG + ")V" ) ; final int keyDom = cpg . addMethodref ( TRANSLET_CLASS , "setKeyIndexDom" , "(" + STRING_SIG + DOM_INTF_SIG + ")V" ) ; final int getNodeIdent = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeIdent" , "(I)" + NODE_SIG ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . DESCENDANT ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . setStartNode ( ) ) ; il . append ( methodGen . storeIterator ( ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; _match . translate ( classGen , methodGen ) ; _match . synthesize ( classGen , methodGen ) ; final BranchHandle skipNode = il . append ( new IFEQ ( null ) ) ; if ( _useType instanceof NodeSetType ) { il . append ( methodGen . loadCurrentNode ( ) ) ; traverseNodeSet ( classGen , methodGen , key ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( DUP_X1 ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; _use . translate ( classGen , methodGen ) ; il . append ( SWAP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( key ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( keyDom ) ) ; } final InstructionHandle skip = il . append ( NOP ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGT ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; nextNode . setTarget ( skip ) ; skipNode . setTarget ( skip ) ; } } 	1	['6', '3', '0', '35', '53', '0', '1', '34', '5', '0.55', '570', '1', '4', '0.923076923', '0.361111111', '2', '5', '93.33333333', '4', '1.5', '1']
package org . apache . xalan . xsltc . runtime ; import java . io . FileWriter ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . dom . DOMAdapter ; import org . apache . xalan . xsltc . dom . KeyIndex ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . runtime . output . TransletOutputHandlerFactory ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . serializer . SerializationHandler ; public abstract class AbstractTranslet implements Translet { public String _version = "1.0" ; public String _method = null ; public String _encoding = "UTF-8" ; public boolean _omitHeader = false ; public String _standalone = null ; public String _doctypePublic = null ; public String _doctypeSystem = null ; public boolean _indent = false ; public String _mediaType = null ; public Vector _cdata = null ; protected String [ ] namesArray ; protected String [ ] namespaceArray ; protected boolean _hasIdCall = false ; protected StringValueHandler stringValueHandler = new StringValueHandler ( ) ; private final static String EMPTYSTRING = "" ; private final static String ID_INDEX_NAME = "##id" ; public void printInternalState ( ) { System . out . println ( "-------------------------------------" ) ; System . out . println ( "AbstractTranslet this = " + this ) ; System . out . println ( "pbase = " + pbase ) ; System . out . println ( "vframe = " + pframe ) ; System . out . println ( "paramsStack.size() = " + paramsStack . size ( ) ) ; System . out . println ( "namesArray.size = " + namesArray . length ) ; System . out . println ( "namespaceArray.size = " + namespaceArray . length ) ; System . out . println ( "" ) ; System . out . println ( "Total memory = " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; } public final DOMAdapter makeDOMAdapter ( DOM dom ) throws TransletException { return new DOMAdapter ( dom , namesArray , namespaceArray ) ; } protected int pbase = 0 , pframe = 0 ; protected ArrayList paramsStack = new ArrayList ( ) ; public final void pushParamFrame ( ) { paramsStack . add ( pframe , new Integer ( pbase ) ) ; pbase = ++ pframe ; } public final void popParamFrame ( ) { if ( pbase > 0 ) { final int oldpbase = ( ( Integer ) paramsStack . get ( -- pbase ) ) . intValue ( ) ; for ( int i = pframe - 1 ; i >= pbase ; i -- ) { paramsStack . remove ( i ) ; } pframe = pbase ; pbase = oldpbase ; } } public final Object addParameter ( String name , Object value ) { name = BasisLibrary . replace ( name , ".-" , new String [ ] { "$dot$" , "$dash$" } ) ; return addParameter ( name , value , false ) ; } public final Object addParameter ( String name , Object value , boolean isDefault ) { for ( int i = pframe - 1 ; i >= pbase ; i -- ) { final Parameter param = ( Parameter ) paramsStack . get ( i ) ; if ( param . _name . equals ( name ) ) { if ( param . _isDefault || ! isDefault ) { param . _value = value ; param . _isDefault = isDefault ; return value ; } return param . _value ; } } paramsStack . add ( pframe ++ , new Parameter ( name , value , isDefault ) ) ; return value ; } public void clearParameters ( ) { pbase = pframe = 0 ; paramsStack . clear ( ) ; } public final Object getParameter ( String name ) { for ( int i = pframe - 1 ; i >= pbase ; i -- ) { final Parameter param = ( Parameter ) paramsStack . get ( i ) ; if ( param . _name . equals ( name ) ) return param . _value ; } return null ; } private MessageHandler _msgHandler = null ; public final void setMessageHandler ( MessageHandler handler ) { _msgHandler = handler ; } public final void displayMessage ( String msg ) { if ( _msgHandler == null ) { System . err . println ( msg ) ; } else { _msgHandler . displayMessage ( msg ) ; } } public Hashtable _formatSymbols = null ; public void addDecimalFormat ( String name , DecimalFormatSymbols symbols ) { if ( _formatSymbols == null ) _formatSymbols = new Hashtable ( ) ; if ( name == null ) name = EMPTYSTRING ; final DecimalFormat df = new DecimalFormat ( ) ; if ( symbols != null ) { df . setDecimalFormatSymbols ( symbols ) ; } _formatSymbols . put ( name , df ) ; } public final DecimalFormat getDecimalFormat ( String name ) { if ( _formatSymbols != null ) { if ( name == null ) name = EMPTYSTRING ; DecimalFormat df = ( DecimalFormat ) _formatSymbols . get ( name ) ; if ( df == null ) df = ( DecimalFormat ) _formatSymbols . get ( EMPTYSTRING ) ; return df ; } return ( null ) ; } public final void prepassDocument ( DOM document ) { setIndexSize ( document . getSize ( ) ) ; buildIDIndex ( document ) ; } private final void buildIDIndex ( DOM document ) { if ( document instanceof SAXImpl ) { SAXImpl saxImpl = ( SAXImpl ) document ; if ( saxImpl . hasDOMSource ( ) ) { buildKeyIndex ( ID_INDEX_NAME , document ) ; return ; } else { final Hashtable elementsByID = saxImpl . getElementsWithIDs ( ) ; if ( elementsByID == null ) { return ; } final Enumeration idValues = elementsByID . keys ( ) ; boolean hasIDValues = false ; while ( idValues . hasMoreElements ( ) ) { final Object idValue = idValues . nextElement ( ) ; final int element = ( ( Integer ) elementsByID . get ( idValue ) ) . intValue ( ) ; buildKeyIndex ( ID_INDEX_NAME , element , idValue ) ; hasIDValues = true ; } if ( hasIDValues ) { setKeyIndexDom ( ID_INDEX_NAME , document ) ; } } } } private Hashtable _keyIndexes = null ; private KeyIndex _emptyKeyIndex = new KeyIndex ( 1 ) ; private int _indexSize = 0 ; public void setIndexSize ( int size ) { if ( size > _indexSize ) _indexSize = size ; } public KeyIndex createKeyIndex ( ) { return ( new KeyIndex ( _indexSize ) ) ; } public void buildKeyIndex ( String name , int node , Object value ) { if ( _keyIndexes == null ) _keyIndexes = new Hashtable ( ) ; KeyIndex index = ( KeyIndex ) _keyIndexes . get ( name ) ; if ( index == null ) { _keyIndexes . put ( name , index = new KeyIndex ( _indexSize ) ) ; } index . add ( value , node ) ; } public void buildKeyIndex ( String name , DOM dom ) { if ( _keyIndexes == null ) _keyIndexes = new Hashtable ( ) ; KeyIndex index = ( KeyIndex ) _keyIndexes . get ( name ) ; if ( index == null ) { _keyIndexes . put ( name , index = new KeyIndex ( _indexSize ) ) ; } index . setDom ( dom ) ; } public KeyIndex getKeyIndex ( String name ) { if ( _keyIndexes == null ) return ( _emptyKeyIndex ) ; final KeyIndex index = ( KeyIndex ) _keyIndexes . get ( name ) ; if ( index == null ) return ( _emptyKeyIndex ) ; return ( index ) ; } public void buildKeys ( DOM document , DTMAxisIterator iterator , SerializationHandler handler , int root ) throws TransletException { } public void setKeyIndexDom ( String name , DOM document ) { getKeyIndex ( name ) . setDom ( document ) ; } private DOMCache _domCache = null ; public void setDOMCache ( DOMCache cache ) { _domCache = cache ; } public DOMCache getDOMCache ( ) { return ( _domCache ) ; } public SerializationHandler openOutputHandler ( String filename , boolean append ) throws TransletException { try { final TransletOutputHandlerFactory factory = TransletOutputHandlerFactory . newInstance ( ) ; factory . setEncoding ( _encoding ) ; factory . setOutputMethod ( _method ) ; factory . setWriter ( new FileWriter ( filename , append ) ) ; factory . setOutputType ( TransletOutputHandlerFactory . STREAM ) ; final SerializationHandler handler = factory . getSerializationHandler ( ) ; transferOutputSettings ( handler ) ; handler . startDocument ( ) ; return handler ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } public SerializationHandler openOutputHandler ( String filename ) throws TransletException { return openOutputHandler ( filename , false ) ; } public void closeOutputHandler ( SerializationHandler handler ) { try { handler . endDocument ( ) ; handler . close ( ) ; } catch ( Exception e ) { } } public abstract void transform ( DOM document , DTMAxisIterator iterator , SerializationHandler handler ) throws TransletException ; public final void transform ( DOM document , SerializationHandler handler ) throws TransletException { transform ( document , document . getIterator ( ) , handler ) ; } public final void characters ( final String string , SerializationHandler handler ) throws TransletException { if ( string != null ) { try { handler . characters ( string ) ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } } public void addCdataElement ( String name ) { if ( _cdata == null ) { _cdata = new Vector ( ) ; } int lastColon = name . lastIndexOf ( ':' ) ; if ( lastColon > 0 ) { String uri = name . substring ( 0 , lastColon ) ; String localName = name . substring ( lastColon + 1 ) ; _cdata . addElement ( uri ) ; _cdata . addElement ( localName ) ; } else { _cdata . addElement ( null ) ; _cdata . addElement ( name ) ; } } protected void transferOutputSettings ( SerializationHandler handler ) { if ( _method != null ) { if ( _method . equals ( "xml" ) ) { if ( _standalone != null ) { handler . setStandalone ( _standalone ) ; } if ( _omitHeader ) { handler . setOmitXMLDeclaration ( true ) ; } handler . setCdataSectionElements ( _cdata ) ; if ( _version != null ) { handler . setVersion ( _version ) ; } handler . setIndent ( _indent ) ; if ( _doctypeSystem != null ) { handler . setDoctype ( _doctypeSystem , _doctypePublic ) ; } } else if ( _method . equals ( "html" ) ) { handler . setIndent ( _indent ) ; handler . setDoctype ( _doctypeSystem , _doctypePublic ) ; if ( _mediaType != null ) { handler . setMediaType ( _mediaType ) ; } } } else { handler . setCdataSectionElements ( _cdata ) ; if ( _version != null ) { handler . setVersion ( _version ) ; } if ( _standalone != null ) { handler . setStandalone ( _standalone ) ; } if ( _omitHeader ) { handler . setOmitXMLDeclaration ( true ) ; } handler . setIndent ( _indent ) ; handler . setDoctype ( _doctypeSystem , _doctypePublic ) ; } } private Hashtable _auxClasses = null ; public void addAuxiliaryClass ( Class auxClass ) { if ( _auxClasses == null ) _auxClasses = new Hashtable ( ) ; _auxClasses . put ( auxClass . getName ( ) , auxClass ) ; } public Class getAuxiliaryClass ( String className ) { if ( _auxClasses == null ) return null ; return ( ( Class ) _auxClasses . get ( className ) ) ; } public String [ ] getNamesArray ( ) { return namesArray ; } public String [ ] getNamespaceArray ( ) { return namespaceArray ; } public boolean hasIdCall ( ) { return _hasIdCall ; } } 	1	['37', '1', '0', '25', '101', '552', '10', '15', '35', '0.919871795', '899', '0.576923077', '7', '0', '0.18018018', '0', '0', '22.59459459', '12', '2.1081', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncGenerateId extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int which = getArg0AsNode ( xctxt ) ; if ( DTM . NULL != which ) { return new XString ( "N" + Integer . toHexString ( which ) . toUpperCase ( ) ) ; } else return XString . EMPTYSTRING ; } } 	1	['2', '5', '0', '4', '10', '1', '0', '4', '2', '2', '28', '0', '0', '0.982142857', '0.75', '2', '7', '13', '1', '0.5', '1']
package org . apache . xpath . objects ; public class XBooleanStatic extends XBoolean { boolean m_val ; public XBooleanStatic ( boolean b ) { super ( b ) ; m_val = b ; } public boolean equals ( XObject obj2 ) { try { return m_val == obj2 . bool ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } 	1	['2', '4', '0', '5', '5', '0', '3', '3', '2', '0', '25', '0', '0', '0.987341772', '0.666666667', '2', '3', '11', '2', '1', '1']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncStartsWith extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_arg0 . execute ( xctxt ) . xstr ( ) . startsWith ( m_arg1 . execute ( xctxt ) . xstr ( ) ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	1	['2', '5', '0', '6', '6', '1', '0', '6', '2', '2', '21', '0', '0', '0.98245614', '0.75', '1', '6', '9.5', '1', '0.5', '1']
package org . apache . xalan . lib . sql ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import javax . xml . transform . SourceLocator ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMDefaultBaseIterators ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . XMLString ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; public class DTMDocument extends DTMDefaultBaseIterators { public interface CharacterNodeHandler { public void characters ( Node node ) throws org . xml . sax . SAXException ; } private boolean DEBUG = false ; protected static final String S_NAMESPACE = "http://xml.apache.org/xalan/SQLExtension" ; protected static final String S_ATTRIB_NOT_SUPPORTED = "Not Supported" ; protected static final String S_ISTRUE = "true" ; protected static final String S_ISFALSE = "false" ; protected static final String S_DOCUMENT = "#root" ; protected static final String S_TEXT_NODE = "#text" ; protected static final String S_ELEMENT_NODE = "#element" ; protected int m_Document_TypeID = 0 ; protected int m_TextNode_TypeID = 0 ; protected ObjectArray m_ObjectArray = new ObjectArray ( ) ; protected SuballocatedIntVector m_attribute ; protected int m_DocumentIdx ; public DTMDocument ( DTMManager mgr , int ident ) { super ( mgr , null , ident , null , mgr . getXMLStringFactory ( ) , true ) ; m_attribute = new SuballocatedIntVector ( DEFAULT_BLOCKSIZE ) ; } private int allocateNodeObject ( Object o ) { m_size ++ ; return m_ObjectArray . append ( o ) ; } protected int addElementWithData ( Object o , int level , int extendedType , int parent , int prevsib ) { int elementIdx = addElement ( level , extendedType , parent , prevsib ) ; int data = allocateNodeObject ( o ) ; m_firstch . setElementAt ( data , elementIdx ) ; m_exptype . setElementAt ( m_TextNode_TypeID , data ) ; m_parent . setElementAt ( elementIdx , data ) ; m_prevsib . setElementAt ( DTM . NULL , data ) ; m_nextsib . setElementAt ( DTM . NULL , data ) ; m_attribute . setElementAt ( DTM . NULL , data ) ; m_firstch . setElementAt ( DTM . NULL , data ) ; return elementIdx ; } protected int addElement ( int level , int extendedType , int parent , int prevsib ) { int node = DTM . NULL ; try { node = allocateNodeObject ( S_ELEMENT_NODE ) ; m_exptype . setElementAt ( extendedType , node ) ; m_nextsib . setElementAt ( DTM . NULL , node ) ; m_prevsib . setElementAt ( prevsib , node ) ; m_parent . setElementAt ( parent , node ) ; m_firstch . setElementAt ( DTM . NULL , node ) ; m_attribute . setElementAt ( DTM . NULL , node ) ; if ( prevsib != DTM . NULL ) { if ( m_nextsib . elementAt ( prevsib ) != DTM . NULL ) m_nextsib . setElementAt ( m_nextsib . elementAt ( prevsib ) , node ) ; m_nextsib . setElementAt ( node , prevsib ) ; } if ( ( parent != DTM . NULL ) && ( m_prevsib . elementAt ( node ) == DTM . NULL ) ) { m_firstch . setElementAt ( node , parent ) ; } } catch ( Exception e ) { error ( "Error in addElement: " + e . getMessage ( ) ) ; } return node ; } protected int addAttributeToNode ( Object o , int extendedType , int pnode ) { int attrib = DTM . NULL ; int prevsib = DTM . NULL ; int lastattrib = DTM . NULL ; int value = DTM . NULL ; try { attrib = allocateNodeObject ( o ) ; m_attribute . setElementAt ( DTM . NULL , attrib ) ; m_exptype . setElementAt ( extendedType , attrib ) ; m_nextsib . setElementAt ( DTM . NULL , attrib ) ; m_prevsib . setElementAt ( DTM . NULL , attrib ) ; m_parent . setElementAt ( pnode , attrib ) ; m_firstch . setElementAt ( DTM . NULL , attrib ) ; if ( m_attribute . elementAt ( pnode ) != DTM . NULL ) { lastattrib = m_attribute . elementAt ( pnode ) ; m_nextsib . setElementAt ( lastattrib , attrib ) ; m_prevsib . setElementAt ( attrib , lastattrib ) ; } m_attribute . setElementAt ( attrib , pnode ) ; } catch ( Exception e ) { error ( "Error in addAttributeToNode: " + e . getMessage ( ) ) ; } return attrib ; } protected void cloneAttributeFromNode ( int toNode , int fromNode ) { try { if ( m_attribute . elementAt ( toNode ) != DTM . NULL ) { error ( "Cloneing Attributes, where from Node already had addtibures assigned" ) ; } m_attribute . setElementAt ( m_attribute . elementAt ( fromNode ) , toNode ) ; } catch ( Exception e ) { error ( "Cloning attributes" ) ; } } public int getFirstAttribute ( int parm1 ) { if ( DEBUG ) System . out . println ( "getFirstAttribute(" + parm1 + ")" ) ; int nodeIdx = makeNodeIdentity ( parm1 ) ; if ( nodeIdx != DTM . NULL ) { int attribIdx = m_attribute . elementAt ( nodeIdx ) ; return makeNodeHandle ( attribIdx ) ; } else return DTM . NULL ; } public String getNodeValue ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNodeValue(" + parm1 + ")" ) ; try { Object o = m_ObjectArray . getAt ( makeNodeIdentity ( parm1 ) ) ; if ( o != null && o != S_ELEMENT_NODE ) { return o . toString ( ) ; } else { return "" ; } } catch ( Exception e ) { error ( "Getting String Value" ) ; return null ; } } public XMLString getStringValue ( int nodeHandle ) { int nodeIdx = makeNodeIdentity ( nodeHandle ) ; if ( DEBUG ) System . out . println ( "getStringValue(" + nodeIdx + ")" ) ; Object o = m_ObjectArray . getAt ( nodeIdx ) ; if ( o == S_ELEMENT_NODE ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { getNodeData ( nodeIdx , buf ) ; s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; } finally { StringBufferPool . free ( buf ) ; } return m_xstrf . newstr ( s ) ; } else if ( o != null ) { return m_xstrf . newstr ( o . toString ( ) ) ; } else return ( m_xstrf . emptystr ( ) ) ; } protected void getNodeData ( int nodeIdx , FastStringBuffer buf ) { for ( int child = _firstch ( nodeIdx ) ; child != DTM . NULL ; child = _nextsib ( child ) ) { Object o = m_ObjectArray . getAt ( child ) ; if ( o == S_ELEMENT_NODE ) getNodeData ( child , buf ) ; else if ( o != null ) buf . append ( o . toString ( ) ) ; } } public int getNextAttribute ( int parm1 ) { int nodeIdx = makeNodeIdentity ( parm1 ) ; if ( DEBUG ) System . out . println ( "getNextAttribute(" + nodeIdx + ")" ) ; if ( nodeIdx != DTM . NULL ) return makeNodeHandle ( m_nextsib . elementAt ( nodeIdx ) ) ; else return DTM . NULL ; } protected int getNumberOfNodes ( ) { if ( DEBUG ) System . out . println ( "getNumberOfNodes()" ) ; return m_size ; } protected boolean nextNode ( ) { if ( DEBUG ) System . out . println ( "nextNode()" ) ; return false ; } protected void createExpandedNameTable ( ) { m_Document_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DOCUMENT , DTM . DOCUMENT_NODE ) ; m_TextNode_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_TEXT_NODE , DTM . TEXT_NODE ) ; } public void dumpDTM ( ) { try { File f = new File ( "DTMDump.txt" ) ; System . err . println ( "Dumping... " + f . getAbsolutePath ( ) ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( f ) ) ; while ( nextNode ( ) ) { } int nRecords = m_size ; ps . println ( "Total nodes: " + nRecords ) ; for ( int i = 0 ; i < nRecords ; i ++ ) { ps . println ( "=========== " + i + " ===========" ) ; ps . println ( "NodeName: " + getNodeName ( makeNodeHandle ( i ) ) ) ; ps . println ( "NodeNameX: " + getNodeNameX ( makeNodeHandle ( i ) ) ) ; ps . println ( "LocalName: " + getLocalName ( makeNodeHandle ( i ) ) ) ; ps . println ( "NamespaceURI: " + getNamespaceURI ( makeNodeHandle ( i ) ) ) ; ps . println ( "Prefix: " + getPrefix ( makeNodeHandle ( i ) ) ) ; int exTypeID = getExpandedTypeID ( makeNodeHandle ( i ) ) ; ps . println ( "Expanded Type ID: " + Integer . toHexString ( exTypeID ) ) ; int type = getNodeType ( makeNodeHandle ( i ) ) ; String typestring ; switch ( type ) { case DTM . ATTRIBUTE_NODE : typestring = "ATTRIBUTE_NODE" ; break ; case DTM . CDATA_SECTION_NODE : typestring = "CDATA_SECTION_NODE" ; break ; case DTM . COMMENT_NODE : typestring = "COMMENT_NODE" ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : typestring = "DOCUMENT_FRAGMENT_NODE" ; break ; case DTM . DOCUMENT_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . DOCUMENT_TYPE_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . ELEMENT_NODE : typestring = "ELEMENT_NODE" ; break ; case DTM . ENTITY_NODE : typestring = "ENTITY_NODE" ; break ; case DTM . ENTITY_REFERENCE_NODE : typestring = "ENTITY_REFERENCE_NODE" ; break ; case DTM . NAMESPACE_NODE : typestring = "NAMESPACE_NODE" ; break ; case DTM . NOTATION_NODE : typestring = "NOTATION_NODE" ; break ; case DTM . NULL : typestring = "NULL" ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : typestring = "PROCESSING_INSTRUCTION_NODE" ; break ; case DTM . TEXT_NODE : typestring = "TEXT_NODE" ; break ; default : typestring = "Unknown!" ; break ; } ps . println ( "Type: " + typestring ) ; int firstChild = _firstch ( i ) ; if ( DTM . NULL == firstChild ) ps . println ( "First child: DTM.NULL" ) ; else if ( NOTPROCESSED == firstChild ) ps . println ( "First child: NOTPROCESSED" ) ; else ps . println ( "First child: " + firstChild ) ; int prevSibling = _prevsib ( i ) ; if ( DTM . NULL == prevSibling ) ps . println ( "Prev sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == prevSibling ) ps . println ( "Prev sibling: NOTPROCESSED" ) ; else ps . println ( "Prev sibling: " + prevSibling ) ; int nextSibling = _nextsib ( i ) ; if ( DTM . NULL == nextSibling ) ps . println ( "Next sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == nextSibling ) ps . println ( "Next sibling: NOTPROCESSED" ) ; else ps . println ( "Next sibling: " + nextSibling ) ; int parent = _parent ( i ) ; if ( DTM . NULL == parent ) ps . println ( "Parent: DTM.NULL" ) ; else if ( NOTPROCESSED == parent ) ps . println ( "Parent: NOTPROCESSED" ) ; else ps . println ( "Parent: " + parent ) ; int level = _level ( i ) ; ps . println ( "Level: " + level ) ; ps . println ( "Node Value: " + getNodeValue ( i ) ) ; ps . println ( "String Value: " + getStringValue ( i ) ) ; ps . println ( "First Attribute Node: " + m_attribute . elementAt ( i ) ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( System . err ) ; System . exit ( - 1 ) ; } } protected static void dispatchNodeData ( Node node , ContentHandler ch , int depth ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { dispatchNodeData ( child , ch , depth + 1 ) ; } } break ; case Node . PROCESSING_INSTRUCTION_NODE : case Node . COMMENT_NODE : if ( 0 != depth ) break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : String str = node . getNodeValue ( ) ; if ( ch instanceof CharacterNodeHandler ) { ( ( CharacterNodeHandler ) ch ) . characters ( node ) ; } else { ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } break ; default : break ; } } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } protected int getNextNodeIdentity ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNextNodeIdenty(" + parm1 + ")" ) ; return DTM . NULL ; } public int getAttributeNode ( int parm1 , String parm2 , String parm3 ) { if ( DEBUG ) { System . out . println ( "getAttributeNode(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return DTM . NULL ; } public String getLocalName ( int parm1 ) { int exID = getExpandedTypeID ( parm1 ) ; if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalName(" + parm1 + ") -> " ) ; System . out . println ( "..." + getLocalNameFromExpandedNameID ( exID ) ) ; DEBUG = true ; } return getLocalNameFromExpandedNameID ( exID ) ; } public String getNodeName ( int parm1 ) { int exID = getExpandedTypeID ( parm1 ) ; if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalName(" + parm1 + ") -> " ) ; System . out . println ( "..." + getLocalNameFromExpandedNameID ( exID ) ) ; DEBUG = true ; } return getLocalNameFromExpandedNameID ( exID ) ; } public boolean isAttributeSpecified ( int parm1 ) { if ( DEBUG ) System . out . println ( "isAttributeSpecified(" + parm1 + ")" ) ; return false ; } public String getUnparsedEntityURI ( String parm1 ) { if ( DEBUG ) System . out . println ( "getUnparsedEntityURI(" + parm1 + ")" ) ; return "" ; } public DTDHandler getDTDHandler ( ) { if ( DEBUG ) System . out . println ( "getDTDHandler()" ) ; return null ; } public String getPrefix ( int parm1 ) { if ( DEBUG ) System . out . println ( "getPrefix(" + parm1 + ")" ) ; return "" ; } public EntityResolver getEntityResolver ( ) { if ( DEBUG ) System . out . println ( "getEntityResolver()" ) ; return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { if ( DEBUG ) System . out . println ( "get_DTD_PubId()" ) ; return "" ; } public LexicalHandler getLexicalHandler ( ) { if ( DEBUG ) System . out . println ( "getLexicalHandler()" ) ; return null ; } public boolean needsTwoThreads ( ) { if ( DEBUG ) System . out . println ( "needsTwoThreads()" ) ; return false ; } public ContentHandler getContentHandler ( ) { if ( DEBUG ) System . out . println ( "getContentHandler()" ) ; return null ; } public void dispatchToEvents ( int parm1 , ContentHandler parm2 ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . println ( "dispathcToEvents(" + parm1 + "," + parm2 + ")" ) ; } return ; } public String getNamespaceURI ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNamespaceURI(" + parm1 + ")" ) ; return "" ; } public void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . println ( "dispatchCharacterEvents(" + nodeHandle + "," + ch + "," + normalize + ")" ) ; } if ( normalize ) { XMLString str = getStringValue ( nodeHandle ) ; str = str . fixWhiteSpace ( true , true , false ) ; str . dispatchCharactersEvents ( ch ) ; } else { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; dispatchNodeData ( node , ch , 0 ) ; } } public boolean supportsPreStripping ( ) { if ( DEBUG ) System . out . println ( "supportsPreStripping()" ) ; return super . supportsPreStripping ( ) ; } protected int _exptype ( int parm1 ) { if ( DEBUG ) System . out . println ( "_exptype(" + parm1 + ")" ) ; return super . _exptype ( parm1 ) ; } protected SuballocatedIntVector findNamespaceContext ( int parm1 ) { if ( DEBUG ) System . out . println ( "SuballocatedIntVector(" + parm1 + ")" ) ; return super . findNamespaceContext ( parm1 ) ; } protected int _prevsib ( int parm1 ) { if ( DEBUG ) System . out . println ( "_prevsib(" + parm1 + ")" ) ; return super . _prevsib ( parm1 ) ; } protected short _type ( int parm1 ) { if ( DEBUG ) System . out . println ( "_type(" + parm1 + ")" ) ; return super . _type ( parm1 ) ; } public Node getNode ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNode(" + parm1 + ")" ) ; return super . getNode ( parm1 ) ; } public int getPreviousSibling ( int parm1 ) { if ( DEBUG ) System . out . println ( "getPrevSib(" + parm1 + ")" ) ; return super . getPreviousSibling ( parm1 ) ; } public String getDocumentStandalone ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDOcStandAlone(" + parm1 + ")" ) ; return super . getDocumentStandalone ( parm1 ) ; } public String getNodeNameX ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNodeNameX(" + parm1 + ")" ) ; return getNodeName ( parm1 ) ; } public void setFeature ( String parm1 , boolean parm2 ) { if ( DEBUG ) { System . out . println ( "setFeature(" + parm1 + "," + parm2 + ")" ) ; } super . setFeature ( parm1 , parm2 ) ; } protected int _parent ( int parm1 ) { if ( DEBUG ) System . out . println ( "_parent(" + parm1 + ")" ) ; return super . _parent ( parm1 ) ; } protected void indexNode ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "indexNode(" + parm1 + "," + parm2 + ")" ) ; super . indexNode ( parm1 , parm2 ) ; } protected boolean getShouldStripWhitespace ( ) { if ( DEBUG ) System . out . println ( "getShouldStripWS()" ) ; return super . getShouldStripWhitespace ( ) ; } protected void popShouldStripWhitespace ( ) { if ( DEBUG ) System . out . println ( "popShouldStripWS()" ) ; super . popShouldStripWhitespace ( ) ; } public boolean isNodeAfter ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "isNodeAfter(" + parm1 + "," + parm2 + ")" ) ; return super . isNodeAfter ( parm1 , parm2 ) ; } public int getNamespaceType ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNamespaceType(" + parm1 + ")" ) ; return super . getNamespaceType ( parm1 ) ; } protected int _level ( int parm1 ) { if ( DEBUG ) System . out . println ( "_level(" + parm1 + ")" ) ; return super . _level ( parm1 ) ; } protected void pushShouldStripWhitespace ( boolean parm1 ) { if ( DEBUG ) System . out . println ( "push_ShouldStripWS(" + parm1 + ")" ) ; super . pushShouldStripWhitespace ( parm1 ) ; } public String getDocumentVersion ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocVer(" + parm1 + ")" ) ; return super . getDocumentVersion ( parm1 ) ; } public boolean isSupported ( String parm1 , String parm2 ) { if ( DEBUG ) System . out . println ( "isSupported(" + parm1 + "," + parm2 + ")" ) ; return super . isSupported ( parm1 , parm2 ) ; } protected void setShouldStripWhitespace ( boolean parm1 ) { if ( DEBUG ) System . out . println ( "set_ShouldStripWS(" + parm1 + ")" ) ; super . setShouldStripWhitespace ( parm1 ) ; } protected void ensureSizeOfIndex ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "ensureSizeOfIndex(" + parm1 + "," + parm2 + ")" ) ; super . ensureSizeOfIndex ( parm1 , parm2 ) ; } protected void ensureSize ( int parm1 ) { if ( DEBUG ) System . out . println ( "ensureSize(" + parm1 + ")" ) ; } public String getDocumentEncoding ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocumentEncoding(" + parm1 + ")" ) ; return super . getDocumentEncoding ( parm1 ) ; } public void appendChild ( int parm1 , boolean parm2 , boolean parm3 ) { if ( DEBUG ) { System . out . println ( "appendChild(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } super . appendChild ( parm1 , parm2 , parm3 ) ; } public short getLevel ( int parm1 ) { if ( DEBUG ) System . out . println ( "getLevel(" + parm1 + ")" ) ; return super . getLevel ( parm1 ) ; } public String getDocumentBaseURI ( ) { if ( DEBUG ) System . out . println ( "getDocBaseURI()" ) ; return super . getDocumentBaseURI ( ) ; } public int getNextNamespaceNode ( int parm1 , int parm2 , boolean parm3 ) { if ( DEBUG ) { System . out . println ( "getNextNamesapceNode(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return super . getNextNamespaceNode ( parm1 , parm2 , parm3 ) ; } public void appendTextChild ( String parm1 ) { if ( DEBUG ) System . out . println ( "appendTextChild(" + parm1 + ")" ) ; super . appendTextChild ( parm1 ) ; } protected int findGTE ( int [ ] parm1 , int parm2 , int parm3 , int parm4 ) { if ( DEBUG ) { System . out . println ( "findGTE(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return super . findGTE ( parm1 , parm2 , parm3 , parm4 ) ; } public int getFirstNamespaceNode ( int parm1 , boolean parm2 ) { if ( DEBUG ) System . out . println ( "getFirstNamespaceNode()" ) ; return super . getFirstNamespaceNode ( parm1 , parm2 ) ; } public int getStringValueChunkCount ( int parm1 ) { if ( DEBUG ) System . out . println ( "getStringChunkCount(" + parm1 + ")" ) ; return super . getStringValueChunkCount ( parm1 ) ; } public int getLastChild ( int parm1 ) { if ( DEBUG ) System . out . println ( "getLastChild(" + parm1 + ")" ) ; return super . getLastChild ( parm1 ) ; } public boolean hasChildNodes ( int parm1 ) { if ( DEBUG ) System . out . println ( "hasChildNodes(" + parm1 + ")" ) ; return super . hasChildNodes ( parm1 ) ; } public short getNodeType ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getNodeType(" + parm1 + ") " ) ; int exID = getExpandedTypeID ( parm1 ) ; String name = getLocalNameFromExpandedNameID ( exID ) ; System . out . println ( ".. Node name [" + name + "]" + "[" + getNodeType ( parm1 ) + "]" ) ; DEBUG = true ; } return super . getNodeType ( parm1 ) ; } public boolean isCharacterElementContentWhitespace ( int parm1 ) { if ( DEBUG ) System . out . println ( "isCharacterElementContentWhitespace(" + parm1 + ")" ) ; return super . isCharacterElementContentWhitespace ( parm1 ) ; } public int getFirstChild ( int parm1 ) { if ( DEBUG ) System . out . println ( "getFirstChild(" + parm1 + ")" ) ; return super . getFirstChild ( parm1 ) ; } public String getDocumentSystemIdentifier ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocSysID(" + parm1 + ")" ) ; return super . getDocumentSystemIdentifier ( parm1 ) ; } protected void declareNamespaceInContext ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "declareNamespaceContext(" + parm1 + "," + parm2 + ")" ) ; super . declareNamespaceInContext ( parm1 , parm2 ) ; } public String getNamespaceFromExpandedNameID ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getNamespaceFromExpandedNameID(" + parm1 + ")" ) ; System . out . println ( "..." + super . getNamespaceFromExpandedNameID ( parm1 ) ) ; DEBUG = true ; } return super . getNamespaceFromExpandedNameID ( parm1 ) ; } public String getLocalNameFromExpandedNameID ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalNameFromExpandedNameID(" + parm1 + ")" ) ; System . out . println ( "..." + super . getLocalNameFromExpandedNameID ( parm1 ) ) ; DEBUG = true ; } return super . getLocalNameFromExpandedNameID ( parm1 ) ; } public int getExpandedTypeID ( int parm1 ) { if ( DEBUG ) System . out . println ( "getExpandedTypeID(" + parm1 + ")" ) ; return super . getExpandedTypeID ( parm1 ) ; } public int getDocument ( ) { if ( DEBUG ) System . out . println ( "getDocument()" ) ; return super . getDocument ( ) ; } protected int findInSortedSuballocatedIntVector ( SuballocatedIntVector parm1 , int parm2 ) { if ( DEBUG ) { System . out . println ( "findInSortedSubAlloctedVector(" + parm1 + "," + parm2 + ")" ) ; } return super . findInSortedSuballocatedIntVector ( parm1 , parm2 ) ; } public boolean isDocumentAllDeclarationsProcessed ( int parm1 ) { if ( DEBUG ) System . out . println ( "isDocumentAllDeclProc(" + parm1 + ")" ) ; return super . isDocumentAllDeclarationsProcessed ( parm1 ) ; } protected void error ( String parm1 ) { if ( DEBUG ) System . out . println ( "error(" + parm1 + ")" ) ; super . error ( parm1 ) ; } protected int _firstch ( int parm1 ) { if ( DEBUG ) System . out . println ( "_firstch(" + parm1 + ")" ) ; return super . _firstch ( parm1 ) ; } public int getOwnerDocument ( int parm1 ) { if ( DEBUG ) System . out . println ( "getOwnerDoc(" + parm1 + ")" ) ; return super . getOwnerDocument ( parm1 ) ; } protected int _nextsib ( int parm1 ) { if ( DEBUG ) System . out . println ( "_nextSib(" + parm1 + ")" ) ; return super . _nextsib ( parm1 ) ; } public int getNextSibling ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNextSibling(" + parm1 + ")" ) ; return super . getNextSibling ( parm1 ) ; } public boolean getDocumentAllDeclarationsProcessed ( ) { if ( DEBUG ) System . out . println ( "getDocAllDeclProc()" ) ; return super . getDocumentAllDeclarationsProcessed ( ) ; } public int getParent ( int parm1 ) { if ( DEBUG ) System . out . println ( "getParent(" + parm1 + ")" ) ; return super . getParent ( parm1 ) ; } public int getExpandedTypeID ( String parm1 , String parm2 , int parm3 ) { if ( DEBUG ) System . out . println ( "getExpandedTypeID()" ) ; return super . getExpandedTypeID ( parm1 , parm2 , parm3 ) ; } public void setDocumentBaseURI ( String parm1 ) { if ( DEBUG ) System . out . println ( "setDocBaseURI()" ) ; super . setDocumentBaseURI ( parm1 ) ; } public char [ ] getStringValueChunk ( int parm1 , int parm2 , int [ ] parm3 ) { if ( DEBUG ) { System . out . println ( "getStringChunkValue(" + parm1 + "," + parm2 + ")" ) ; } return super . getStringValueChunk ( parm1 , parm2 , parm3 ) ; } public DTMAxisTraverser getAxisTraverser ( int parm1 ) { if ( DEBUG ) System . out . println ( "getAxixTraverser(" + parm1 + ")" ) ; return super . getAxisTraverser ( parm1 ) ; } public DTMAxisIterator getTypedAxisIterator ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "getTypedAxisIterator(" + parm1 + "," + parm2 + ")" ) ; return super . getTypedAxisIterator ( parm1 , parm2 ) ; } public DTMAxisIterator getAxisIterator ( int parm1 ) { if ( DEBUG ) System . out . println ( "getAxisIterator(" + parm1 + ")" ) ; return super . getAxisIterator ( parm1 ) ; } public int getElementById ( String parm1 ) { if ( DEBUG ) System . out . println ( "getElementByID(" + parm1 + ")" ) ; return DTM . NULL ; } public DeclHandler getDeclHandler ( ) { if ( DEBUG ) System . out . println ( "getDeclHandler()" ) ; return null ; } public ErrorHandler getErrorHandler ( ) { if ( DEBUG ) System . out . println ( "getErrorHandler()" ) ; return null ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { if ( DEBUG ) System . out . println ( "get_DTD-SID()" ) ; return null ; } } 	1	['96', '4', '2', '15', '197', '0', '2', '13', '66', '0.919838057', '2568', '1', '2', '0.497354497', '0.180871212', '1', '26', '25.61458333', '11', '2.0938', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . ArrayList ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . FilterGenerator ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NumberType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . TestGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Predicate extends Expression implements Closure { private Expression _exp = null ; private boolean _nthPositionFilter = false ; private boolean _nthDescendant = false ; private boolean _canOptimize = true ; private int _ptype = - 1 ; private String _className = null ; private ArrayList _closureVars = null ; private Closure _parentClosure = null ; public Predicate ( Expression exp ) { ( _exp = exp ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _exp . setParser ( parser ) ; } public boolean isNthDescendant ( ) { return _nthDescendant ; } public boolean isNthPositionFilter ( ) { return _nthPositionFilter ; } public void dontOptimize ( ) { _canOptimize = false ; } public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { if ( _parentClosure == null ) { SyntaxTreeNode node = getParent ( ) ; do { if ( node instanceof Closure ) { _parentClosure = ( Closure ) node ; break ; } if ( node instanceof TopLevelElement ) { break ; } node = node . getParent ( ) ; } while ( node != null ) ; } return _parentClosure ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; Closure parentClosure = getParentClosure ( ) ; if ( parentClosure != null ) { parentClosure . addVariable ( variableRef ) ; } } } public int getPosType ( ) { if ( _ptype == - 1 ) { SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof StepPattern ) { _ptype = ( ( StepPattern ) parent ) . getNodeType ( ) ; } else if ( parent instanceof AbsoluteLocationPath ) { AbsoluteLocationPath path = ( AbsoluteLocationPath ) parent ; Expression exp = path . getPath ( ) ; if ( exp instanceof Step ) { _ptype = ( ( Step ) exp ) . getNodeType ( ) ; } } else if ( parent instanceof VariableRefBase ) { final VariableRefBase ref = ( VariableRefBase ) parent ; final VariableBase var = ref . getVariable ( ) ; final Expression exp = var . getExpression ( ) ; if ( exp instanceof Step ) { _ptype = ( ( Step ) exp ) . getNodeType ( ) ; } } else if ( parent instanceof Step ) { _ptype = ( ( Step ) parent ) . getNodeType ( ) ; } } return _ptype ; } public boolean parentIsPattern ( ) { return ( getParent ( ) instanceof Pattern ) ; } public Expression getExpr ( ) { return _exp ; } public String toString ( ) { if ( isNthPositionFilter ( ) ) return "pred([" + _exp + "]," + getPosType ( ) + ")" ; else return "pred(" + _exp + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type texp = _exp . typeCheck ( stable ) ; if ( texp instanceof ReferenceType ) { _exp = new CastExpr ( _exp , texp = Type . Real ) ; } if ( texp instanceof ResultTreeType ) { _exp = new CastExpr ( _exp , Type . Boolean ) ; _exp = new CastExpr ( _exp , Type . Real ) ; texp = _exp . typeCheck ( stable ) ; } if ( texp instanceof NumberType ) { if ( texp instanceof IntType == false ) { _exp = new CastExpr ( _exp , Type . Int ) ; } SyntaxTreeNode parent = getParent ( ) ; if ( ( _exp instanceof LastCall ) || ( parent instanceof Pattern ) || ( parent instanceof FilterExpr ) ) { if ( parent instanceof Pattern && ! ( _exp instanceof LastCall ) ) { _nthPositionFilter = _canOptimize ; } else if ( parent instanceof FilterExpr ) { FilterExpr filter = ( FilterExpr ) parent ; Expression fexp = filter . getExpr ( ) ; if ( fexp instanceof KeyCall ) _canOptimize = false ; else if ( fexp instanceof VariableRefBase ) _canOptimize = false ; else if ( fexp instanceof ParentLocationPath ) _canOptimize = false ; else if ( fexp instanceof UnionPathExpr ) _canOptimize = false ; else if ( _exp . hasPositionCall ( ) && _exp . hasLastCall ( ) ) _canOptimize = false ; else if ( filter . getParent ( ) instanceof FilterParentPath ) _canOptimize = false ; if ( _canOptimize ) _nthPositionFilter = true ; } if ( _nthPositionFilter ) { return _type = Type . NodeSet ; } else { final QName position = getParser ( ) . getQNameIgnoreDefaultNs ( "position" ) ; final PositionCall positionCall = new PositionCall ( position ) ; positionCall . setParser ( getParser ( ) ) ; positionCall . setParent ( this ) ; _exp = new EqualityExpr ( EqualityExpr . EQ , positionCall , _exp ) ; if ( _exp . typeCheck ( stable ) != Type . Boolean ) { _exp = new CastExpr ( _exp , Type . Boolean ) ; } return _type = Type . Boolean ; } } else { if ( ( parent != null ) && ( parent instanceof Step ) ) { parent = parent . getParent ( ) ; if ( ( parent != null ) && ( parent instanceof AbsoluteLocationPath ) ) { _nthDescendant = true ; return _type = Type . NodeSet ; } } _nthPositionFilter = true ; return _type = Type . NodeSet ; } } else if ( texp instanceof BooleanType ) { if ( _exp . hasPositionCall ( ) ) _nthPositionFilter = true ; } else { _exp = new CastExpr ( _exp , Type . Boolean ) ; } _nthPositionFilter = false ; return _type = Type . Boolean ; } private void compileFilter ( ClassGenerator classGen , MethodGenerator methodGen ) { TestGenerator testGen ; LocalVariableGen local ; FilterGenerator filterGen ; _className = getXSLTC ( ) . getHelperClassName ( ) ; filterGen = new FilterGenerator ( _className , "java.lang.Object" , toString ( ) , ACC_PUBLIC | ACC_SUPER , new String [ ] { CURRENT_NODE_LIST_FILTER } , classGen . getStylesheet ( ) ) ; final ConstantPoolGen cpg = filterGen . getConstantPool ( ) ; final int length = ( _closureVars == null ) ? 0 : _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableBase var = ( ( VariableRefBase ) _closureVars . get ( i ) ) . getVariable ( ) ; filterGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; } final InstructionList il = new InstructionList ( ) ; testGen = new TestGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , Util . getJCRefType ( TRANSLET_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) } , new String [ ] { "node" , "position" , "last" , "current" , "translet" , "iterator" } , "test" , _className , il , cpg ) ; local = testGen . addLocalVariable ( "document" , Util . getJCRefType ( DOM_INTF_SIG ) , null , null ) ; final String className = classGen . getClassName ( ) ; il . append ( filterGen . loadTranslet ( ) ) ; il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , DOM_FIELD , DOM_INTF_SIG ) ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; testGen . setDomIndex ( local . getIndex ( ) ) ; _exp . translate ( filterGen , testGen ) ; il . append ( IRETURN ) ; testGen . stripAttributes ( true ) ; testGen . setMaxLocals ( ) ; testGen . setMaxStack ( ) ; testGen . removeNOPs ( ) ; filterGen . addEmptyConstructor ( ACC_PUBLIC ) ; filterGen . addMethod ( testGen . getMethod ( ) ) ; getXSLTC ( ) . dumpClass ( filterGen . getJavaClass ( ) ) ; } public boolean isBooleanTest ( ) { return ( _exp instanceof BooleanExpr ) ; } public boolean isNodeValueTest ( ) { if ( ! _canOptimize ) return false ; return ( getStep ( ) != null && getCompareValue ( ) != null ) ; } private Expression _value = null ; private Step _step = null ; public Expression getCompareValue ( ) { if ( _value != null ) return _value ; if ( _exp == null ) return null ; if ( _exp instanceof EqualityExpr ) { EqualityExpr exp = ( EqualityExpr ) _exp ; Expression left = exp . getLeft ( ) ; Expression right = exp . getRight ( ) ; Type tleft = left . getType ( ) ; Type tright = right . getType ( ) ; if ( left instanceof CastExpr ) left = ( ( CastExpr ) left ) . getExpr ( ) ; if ( right instanceof CastExpr ) right = ( ( CastExpr ) right ) . getExpr ( ) ; try { if ( ( tleft == Type . String ) && ( ! ( left instanceof Step ) ) ) _value = exp . getLeft ( ) ; if ( left instanceof VariableRefBase ) _value = new CastExpr ( left , Type . String ) ; if ( _value != null ) return _value ; } catch ( TypeCheckError e ) { } try { if ( ( tright == Type . String ) && ( ! ( right instanceof Step ) ) ) _value = exp . getRight ( ) ; if ( right instanceof VariableRefBase ) _value = new CastExpr ( right , Type . String ) ; if ( _value != null ) return _value ; } catch ( TypeCheckError e ) { } } return null ; } public Step getStep ( ) { if ( _step != null ) return _step ; if ( _exp == null ) return null ; if ( _exp instanceof EqualityExpr ) { EqualityExpr exp = ( EqualityExpr ) _exp ; Expression left = exp . getLeft ( ) ; Expression right = exp . getRight ( ) ; if ( left instanceof CastExpr ) left = ( ( CastExpr ) left ) . getExpr ( ) ; if ( left instanceof Step ) _step = ( Step ) left ; if ( right instanceof CastExpr ) right = ( ( CastExpr ) right ) . getExpr ( ) ; if ( right instanceof Step ) _step = ( Step ) right ; } return _step ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _nthPositionFilter || _nthDescendant ) { _exp . translate ( classGen , methodGen ) ; } else if ( isNodeValueTest ( ) && ( getParent ( ) instanceof Step ) ) { _value . translate ( classGen , methodGen ) ; il . append ( new CHECKCAST ( cpg . addClass ( STRING_CLASS ) ) ) ; il . append ( new PUSH ( cpg , ( ( EqualityExpr ) _exp ) . getOp ( ) ) ) ; } else { translateFilter ( classGen , methodGen ) ; } } public void translateFilter ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; compileFilter ( classGen , methodGen ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( _className , "<init>" , "()V" ) ) ) ; final int length = ( _closureVars == null ) ? 0 : _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableRefBase varRef = ( VariableRefBase ) _closureVars . get ( i ) ; VariableBase var = varRef . getVariable ( ) ; Type varType = var . getType ( ) ; il . append ( DUP ) ; Closure variableClosure = _parentClosure ; while ( variableClosure != null ) { if ( variableClosure . inInnerClass ( ) ) break ; variableClosure = variableClosure . getParentClosure ( ) ; } if ( variableClosure != null ) { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( variableClosure . getInnerClassName ( ) , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; } else { il . append ( var . loadInstruction ( ) ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( _className , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; } } } 	1	['21', '3', '0', '61', '108', '68', '4', '60', '20', '0.765', '1079', '1', '4', '0.78021978', '0.210884354', '2', '8', '49.9047619', '12', '3.1429', '4']
package org . apache . xml . utils ; public class StringBufferPool { private static ObjectPool m_stringBufPool = new ObjectPool ( org . apache . xml . utils . FastStringBuffer . class ) ; public synchronized static FastStringBuffer get ( ) { return ( FastStringBuffer ) m_stringBufPool . getInstance ( ) ; } public synchronized static void free ( FastStringBuffer sb ) { sb . setLength ( 0 ) ; m_stringBufPool . freeInstance ( sb ) ; } } 	1	['5', '1', '0', '7', '13', '4', '5', '2', '3', '0.75', '44', '0.5', '1', '0', '0.25', '0', '0', '7.4', '1', '0.6', '1']
package org . apache . xalan . templates ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . XPathContext ; public class AVTPartSimple extends AVTPart { private String m_val ; public AVTPartSimple ( String val ) { m_val = val ; } public String getSimpleString ( ) { return m_val ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } public void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) { buf . append ( m_val ) ; } public void callVisitors ( XSLTVisitor visitor ) { } } 	1	['5', '2', '0', '6', '7', '4', '1', '5', '5', '0.5', '22', '1', '0', '0.555555556', '0.325', '0', '0', '3.2', '1', '0.8', '1']
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TemplatesHandler ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . compiler . SourceLoader ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . runtime . TransletLoader ; import org . xml . sax . InputSource ; import org . xml . sax . XMLFilter ; import org . xml . sax . XMLReader ; public class TransformerFactoryImpl extends SAXTransformerFactory implements SourceLoader , ErrorListener { public final static String TRANSLET_NAME = "translet-name" ; public final static String DESTINATION_DIRECTORY = "destination-directory" ; public final static String PACKAGE_NAME = "package-name" ; public final static String JAR_NAME = "jar-name" ; public final static String GENERATE_TRANSLET = "generate-translet" ; public final static String AUTO_TRANSLET = "auto-translet" ; public final static String USE_CLASSPATH = "use-classpath" ; public final static String DEBUG = "debug" ; public final static String ENABLE_INLINING = "enable-inlining" ; public final static String INDENT_NUMBER = "indent-number" ; private ErrorListener _errorListener = this ; private URIResolver _uriResolver = null ; protected static String DEFAULT_TRANSLET_NAME = "GregorSamsa" ; private String _transletName = DEFAULT_TRANSLET_NAME ; private String _destinationDirectory = null ; private String _packageName = null ; private String _jarFileName = null ; private Hashtable _piParams = null ; static ThreadLocal _xmlReader = new ThreadLocal ( ) ; private static class PIParamWrapper { public String _media = null ; public String _title = null ; public String _charset = null ; public PIParamWrapper ( String media , String title , String charset ) { _media = media ; _title = title ; _charset = charset ; } } private boolean _debug = false ; private boolean _enableInlining = false ; private boolean _generateTranslet = false ; private boolean _autoTranslet = false ; private boolean _useClasspath = false ; private int _indentNumber = - 1 ; private SAXParserFactory _parserFactory = null ; public TransformerFactoryImpl ( ) { } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ERROR_LISTENER_NULL_ERR , "TransformerFactory" ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } _errorListener = listener ; } public ErrorListener getErrorListener ( ) { return _errorListener ; } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( name . equals ( TRANSLET_NAME ) ) { return _transletName ; } else if ( name . equals ( GENERATE_TRANSLET ) ) { return new Boolean ( _generateTranslet ) ; } else if ( name . equals ( AUTO_TRANSLET ) ) { return new Boolean ( _autoTranslet ) ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_INVALID_ATTR_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( name . equals ( TRANSLET_NAME ) && value instanceof String ) { _transletName = ( String ) value ; return ; } else if ( name . equals ( DESTINATION_DIRECTORY ) && value instanceof String ) { _destinationDirectory = ( String ) value ; return ; } else if ( name . equals ( PACKAGE_NAME ) && value instanceof String ) { _packageName = ( String ) value ; return ; } else if ( name . equals ( JAR_NAME ) && value instanceof String ) { _jarFileName = ( String ) value ; return ; } else if ( name . equals ( GENERATE_TRANSLET ) ) { if ( value instanceof Boolean ) { _generateTranslet = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _generateTranslet = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( AUTO_TRANSLET ) ) { if ( value instanceof Boolean ) { _autoTranslet = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _autoTranslet = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( USE_CLASSPATH ) ) { if ( value instanceof Boolean ) { _useClasspath = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _useClasspath = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( DEBUG ) ) { if ( value instanceof Boolean ) { _debug = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _debug = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( ENABLE_INLINING ) ) { if ( value instanceof Boolean ) { _enableInlining = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _enableInlining = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( INDENT_NUMBER ) ) { if ( value instanceof String ) { try { _indentNumber = Integer . parseInt ( ( String ) value ) ; return ; } catch ( NumberFormatException e ) { } } else if ( value instanceof Integer ) { _indentNumber = ( ( Integer ) value ) . intValue ( ) ; return ; } } final ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_INVALID_ATTR_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } public boolean getFeature ( String name ) { String [ ] features = { DOMSource . FEATURE , DOMResult . FEATURE , SAXSource . FEATURE , SAXResult . FEATURE , StreamSource . FEATURE , StreamResult . FEATURE } ; for ( int i = 0 ; i < features . length ; i ++ ) { if ( name . equals ( features [ i ] ) ) { return true ; } } return false ; } public URIResolver getURIResolver ( ) { return _uriResolver ; } public void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { if ( _piParams == null ) { _piParams = new Hashtable ( ) ; } _piParams . put ( source , new PIParamWrapper ( media , title , charset ) ) ; return source ; } public Transformer newTransformer ( ) throws TransformerConfigurationException { TransformerImpl result = new TransformerImpl ( new Properties ( ) , _indentNumber , this ) ; if ( _uriResolver != null ) { result . setURIResolver ( _uriResolver ) ; } return result ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { final Templates templates = newTemplates ( source ) ; final Transformer transformer = templates . newTransformer ( ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return ( transformer ) ; } private void passWarningsToListener ( Vector messages ) throws TransformerException { if ( _errorListener == null || messages == null ) { return ; } final int count = messages . size ( ) ; for ( int pos = 0 ; pos < count ; pos ++ ) { String message = messages . elementAt ( pos ) . toString ( ) ; _errorListener . error ( new TransformerConfigurationException ( message ) ) ; } } private void passErrorsToListener ( Vector messages ) { try { if ( _errorListener == null || messages == null ) { return ; } final int count = messages . size ( ) ; for ( int pos = 0 ; pos < count ; pos ++ ) { String message = messages . elementAt ( pos ) . toString ( ) ; _errorListener . error ( new TransformerException ( message ) ) ; } } catch ( TransformerException e ) { } } private Class loadTranslet ( String name ) throws ClassNotFoundException { try { TransletLoader loader = new TransletLoader ( ) ; return loader . loadTranslet ( name ) ; } catch ( ClassNotFoundException e ) { return Class . forName ( name ) ; } } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { if ( _useClasspath ) { String transletName = getTransletBaseName ( source ) ; if ( _packageName != null ) transletName = _packageName + "." + transletName ; try { final Class clazz = loadTranslet ( transletName ) ; final Translet translet = ( Translet ) clazz . newInstance ( ) ; resetTransientAttributes ( ) ; return new TemplatesImpl ( translet , transletName , null , _indentNumber , this ) ; } catch ( ClassNotFoundException cnfe ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , transletName ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( Exception e ) { ErrorMsg err = new ErrorMsg ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + e . getMessage ( ) ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } if ( _autoTranslet ) { byte [ ] [ ] bytecodes = null ; String transletClassName = getTransletBaseName ( source ) ; if ( _packageName != null ) transletClassName = _packageName + "." + transletClassName ; if ( _jarFileName != null ) bytecodes = getBytecodesFromJar ( source , transletClassName ) ; else bytecodes = getBytecodesFromClasses ( source , transletClassName ) ; if ( bytecodes != null ) { if ( _debug ) { if ( _jarFileName != null ) System . err . println ( new ErrorMsg ( ErrorMsg . TRANSFORM_WITH_JAR_STR , transletClassName , _jarFileName ) ) ; else System . err . println ( new ErrorMsg ( ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , transletClassName ) ) ; } resetTransientAttributes ( ) ; return new TemplatesImpl ( bytecodes , transletClassName , null , _indentNumber , this ) ; } } final XSLTC xsltc = new XSLTC ( ) ; if ( _debug ) xsltc . setDebug ( true ) ; if ( _enableInlining ) xsltc . setTemplateInlining ( true ) ; xsltc . init ( ) ; if ( _uriResolver != null ) { xsltc . setSourceLoader ( this ) ; } if ( ( _piParams != null ) && ( _piParams . get ( source ) != null ) ) { PIParamWrapper p = ( PIParamWrapper ) _piParams . get ( source ) ; if ( p != null ) { xsltc . setPIParameters ( p . _media , p . _title , p . _charset ) ; } } int outputType = XSLTC . BYTEARRAY_OUTPUT ; if ( _generateTranslet || _autoTranslet ) { xsltc . setClassName ( getTransletBaseName ( source ) ) ; if ( _destinationDirectory != null ) xsltc . setDestDirectory ( _destinationDirectory ) ; else { String xslName = getStylesheetFileName ( source ) ; if ( xslName != null ) { File xslFile = new File ( xslName ) ; String xslDir = xslFile . getParent ( ) ; if ( xslDir != null ) xsltc . setDestDirectory ( xslDir ) ; } } if ( _packageName != null ) xsltc . setPackageName ( _packageName ) ; if ( _jarFileName != null ) { xsltc . setJarFileName ( _jarFileName ) ; outputType = XSLTC . BYTEARRAY_AND_JAR_OUTPUT ; } else outputType = XSLTC . BYTEARRAY_AND_FILE_OUTPUT ; } final InputSource input = Util . getInputSource ( xsltc , source ) ; byte [ ] [ ] bytecodes = xsltc . compile ( null , input , outputType ) ; final String transletName = xsltc . getClassName ( ) ; if ( ( _generateTranslet || _autoTranslet ) && bytecodes != null && _jarFileName != null ) { try { xsltc . outputToJar ( ) ; } catch ( java . io . IOException e ) { } } resetTransientAttributes ( ) ; if ( _errorListener != this ) { try { passWarningsToListener ( xsltc . getWarnings ( ) ) ; } catch ( TransformerException e ) { throw new TransformerConfigurationException ( e ) ; } } else { xsltc . printWarnings ( ) ; } if ( bytecodes == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_COMPILE_ERR ) ; TransformerConfigurationException exc = new TransformerConfigurationException ( err . toString ( ) ) ; if ( _errorListener != null ) { passErrorsToListener ( xsltc . getErrors ( ) ) ; try { _errorListener . fatalError ( exc ) ; } catch ( TransformerException te ) { } } else { xsltc . printErrors ( ) ; } throw exc ; } return new TemplatesImpl ( bytecodes , transletName , xsltc . getOutputProperties ( ) , _indentNumber , this ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { final TemplatesHandlerImpl handler = new TemplatesHandlerImpl ( _indentNumber , this ) ; if ( _uriResolver != null ) { handler . setURIResolver ( _uriResolver ) ; } return handler ; } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { final Transformer transformer = newTransformer ( ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return new TransformerHandlerImpl ( ( TransformerImpl ) transformer ) ; } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { final Transformer transformer = newTransformer ( src ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return new TransformerHandlerImpl ( ( TransformerImpl ) transformer ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { final Transformer transformer = templates . newTransformer ( ) ; final TransformerImpl internal = ( TransformerImpl ) transformer ; return new TransformerHandlerImpl ( internal ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new org . apache . xalan . xsltc . trax . TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException e1 ) { if ( _errorListener != null ) { try { _errorListener . fatalError ( e1 ) ; return null ; } catch ( TransformerException e2 ) { new TransformerConfigurationException ( e2 ) ; } } throw e1 ; } } public void error ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void fatalError ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void warning ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_MSG , e . getMessageAndLocation ( ) ) ) ; } } public InputSource loadSource ( String href , String context , XSLTC xsltc ) { try { if ( _uriResolver != null ) { final Source source = _uriResolver . resolve ( href , context ) ; if ( source != null ) { return Util . getInputSource ( xsltc , source ) ; } } } catch ( TransformerException e ) { } return null ; } public synchronized XMLReader getXMLReader ( ) throws Exception { if ( _parserFactory == null ) { _parserFactory = SAXParserFactory . newInstance ( ) ; _parserFactory . setNamespaceAware ( true ) ; } XMLReader result = ( XMLReader ) _xmlReader . get ( ) ; if ( result == null ) { _xmlReader . set ( result = _parserFactory . newSAXParser ( ) . getXMLReader ( ) ) ; } return result ; } private void resetTransientAttributes ( ) { _transletName = DEFAULT_TRANSLET_NAME ; _destinationDirectory = null ; _packageName = null ; _jarFileName = null ; } private byte [ ] [ ] getBytecodesFromClasses ( Source source , String fullClassName ) { if ( fullClassName == null ) return null ; String xslFileName = getStylesheetFileName ( source ) ; File xslFile = null ; if ( xslFileName != null ) xslFile = new File ( xslFileName ) ; final String transletName ; int lastDotIndex = fullClassName . lastIndexOf ( '.' ) ; if ( lastDotIndex > 0 ) transletName = fullClassName . substring ( lastDotIndex + 1 ) ; else transletName = fullClassName ; String transletPath = fullClassName . replace ( '.' , '/' ) ; if ( _destinationDirectory != null ) { transletPath = _destinationDirectory + "/" + transletPath + ".class" ; } else { if ( xslFile != null && xslFile . getParent ( ) != null ) transletPath = xslFile . getParent ( ) + "/" + transletPath + ".class" ; else transletPath = transletPath + ".class" ; } File transletFile = new File ( transletPath ) ; if ( ! transletFile . exists ( ) ) return null ; if ( xslFile != null && xslFile . exists ( ) ) { long xslTimestamp = xslFile . lastModified ( ) ; long transletTimestamp = transletFile . lastModified ( ) ; if ( transletTimestamp < xslTimestamp ) return null ; } Vector bytecodes = new Vector ( ) ; int fileLength = ( int ) transletFile . length ( ) ; if ( fileLength > 0 ) { FileInputStream input = null ; try { input = new FileInputStream ( transletFile ) ; } catch ( FileNotFoundException e ) { return null ; } byte [ ] bytes = new byte [ fileLength ] ; try { readFromInputStream ( bytes , input , fileLength ) ; input . close ( ) ; } catch ( IOException e ) { return null ; } bytecodes . addElement ( bytes ) ; } else return null ; String transletParentDir = transletFile . getParent ( ) ; if ( transletParentDir == null ) transletParentDir = System . getProperty ( "user.dir" ) ; File transletParentFile = new File ( transletParentDir ) ; final String transletAuxPrefix = transletName + "$" ; File [ ] auxfiles = transletParentFile . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return ( name . endsWith ( ".class" ) && name . startsWith ( transletAuxPrefix ) ) ; } } ) ; for ( int i = 0 ; i < auxfiles . length ; i ++ ) { File auxfile = auxfiles [ i ] ; int auxlength = ( int ) auxfile . length ( ) ; if ( auxlength > 0 ) { FileInputStream auxinput = null ; try { auxinput = new FileInputStream ( auxfile ) ; } catch ( FileNotFoundException e ) { continue ; } byte [ ] bytes = new byte [ auxlength ] ; try { readFromInputStream ( bytes , auxinput , auxlength ) ; auxinput . close ( ) ; } catch ( IOException e ) { continue ; } bytecodes . addElement ( bytes ) ; } } final int count = bytecodes . size ( ) ; if ( count > 0 ) { final byte [ ] [ ] result = new byte [ count ] [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = ( byte [ ] ) bytecodes . elementAt ( i ) ; } return result ; } else return null ; } private byte [ ] [ ] getBytecodesFromJar ( Source source , String fullClassName ) { String xslFileName = getStylesheetFileName ( source ) ; File xslFile = null ; if ( xslFileName != null ) xslFile = new File ( xslFileName ) ; String jarPath = null ; if ( _destinationDirectory != null ) jarPath = _destinationDirectory + "/" + _jarFileName ; else { if ( xslFile != null && xslFile . getParent ( ) != null ) jarPath = xslFile . getParent ( ) + "/" + _jarFileName ; else jarPath = _jarFileName ; } File file = new File ( jarPath ) ; if ( ! file . exists ( ) ) return null ; if ( xslFile != null && xslFile . exists ( ) ) { long xslTimestamp = xslFile . lastModified ( ) ; long transletTimestamp = file . lastModified ( ) ; if ( transletTimestamp < xslTimestamp ) return null ; } ZipFile jarFile = null ; try { jarFile = new ZipFile ( file ) ; } catch ( IOException e ) { return null ; } String transletPath = fullClassName . replace ( '.' , '/' ) ; String transletAuxPrefix = transletPath + "$" ; String transletFullName = transletPath + ".class" ; Vector bytecodes = new Vector ( ) ; Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entry . getSize ( ) > 0 && ( entryName . equals ( transletFullName ) || ( entryName . endsWith ( ".class" ) && entryName . startsWith ( transletAuxPrefix ) ) ) ) { try { InputStream input = jarFile . getInputStream ( entry ) ; int size = ( int ) entry . getSize ( ) ; byte [ ] bytes = new byte [ size ] ; readFromInputStream ( bytes , input , size ) ; input . close ( ) ; bytecodes . addElement ( bytes ) ; } catch ( IOException e ) { return null ; } } } final int count = bytecodes . size ( ) ; if ( count > 0 ) { final byte [ ] [ ] result = new byte [ count ] [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = ( byte [ ] ) bytecodes . elementAt ( i ) ; } return result ; } else return null ; } private void readFromInputStream ( byte [ ] bytes , InputStream input , int size ) throws IOException { int n = 0 ; int offset = 0 ; int length = size ; while ( length > 0 && ( n = input . read ( bytes , offset , length ) ) > 0 ) { offset = offset + n ; length = length - n ; } } private String getTransletBaseName ( Source source ) { String transletBaseName = null ; if ( ! _transletName . equals ( DEFAULT_TRANSLET_NAME ) ) return _transletName ; else { String systemId = source . getSystemId ( ) ; if ( systemId != null ) { String baseName = Util . baseName ( systemId ) ; if ( baseName != null ) { baseName = Util . noExtName ( baseName ) ; transletBaseName = Util . toJavaName ( baseName ) ; } } } return ( transletBaseName != null ) ? transletBaseName : DEFAULT_TRANSLET_NAME ; } private String getStylesheetFileName ( Source source ) { String systemId = source . getSystemId ( ) ; if ( systemId != null ) { File file = new File ( systemId ) ; if ( file . exists ( ) ) return systemId ; else { URL url = null ; try { url = new URL ( systemId ) ; } catch ( MalformedURLException e ) { return null ; } if ( "file" . equals ( url . getProtocol ( ) ) ) return url . getFile ( ) ; else return null ; } } else return null ; } } 	1	['34', '3', '0', '14', '143', '369', '5', '13', '24', '0.903263403', '1703', '0.576923077', '0', '0.384615385', '0.142857143', '1', '2', '48.32352941', '17', '2.0882', '5']
package org . apache . xml . utils ; public class SuballocatedIntVector { protected int m_blocksize ; protected int m_SHIFT , m_MASK ; protected static final int NUMBLOCKS_DEFAULT = 32 ; protected int m_numblocks = NUMBLOCKS_DEFAULT ; protected int m_map [ ] [ ] ; protected int m_firstFree = 0 ; protected int m_map0 [ ] ; protected int m_buildCache [ ] ; protected int m_buildCacheStartIndex ; public SuballocatedIntVector ( ) { this ( 2048 ) ; } public SuballocatedIntVector ( int blocksize , int numblocks ) { for ( m_SHIFT = 0 ; 0 != ( blocksize >>>= 1 ) ; ++ m_SHIFT ) ; m_blocksize = 1 << m_SHIFT ; m_MASK = m_blocksize - 1 ; m_numblocks = numblocks ; m_map0 = new int [ m_blocksize ] ; m_map = new int [ numblocks ] [ ] ; m_map [ 0 ] = m_map0 ; m_buildCache = m_map0 ; m_buildCacheStartIndex = 0 ; } public SuballocatedIntVector ( int blocksize ) { this ( blocksize , NUMBLOCKS_DEFAULT ) ; } public int size ( ) { return m_firstFree ; } public void setSize ( int sz ) { if ( m_firstFree > sz ) m_firstFree = sz ; } public void addElement ( int value ) { int indexRelativeToCache = m_firstFree - m_buildCacheStartIndex ; if ( indexRelativeToCache >= 0 && indexRelativeToCache < m_blocksize ) { m_buildCache [ indexRelativeToCache ] = value ; ++ m_firstFree ; } else { int index = m_firstFree > > > m_SHIFT ; int offset = m_firstFree & m_MASK ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; block [ offset ] = value ; m_buildCache = block ; m_buildCacheStartIndex = m_firstFree - offset ; ++ m_firstFree ; } } private void addElements ( int value , int numberOfElements ) { if ( m_firstFree + numberOfElements < m_blocksize ) for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map0 [ m_firstFree ++ ] = value ; } else { int index = m_firstFree > > > m_SHIFT ; int offset = m_firstFree & m_MASK ; m_firstFree += numberOfElements ; while ( numberOfElements > 0 ) { if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; int copied = ( m_blocksize - offset < numberOfElements ) ? m_blocksize - offset : numberOfElements ; numberOfElements -= copied ; while ( copied -- > 0 ) block [ offset ++ ] = value ; ++ index ; offset = 0 ; } } } private void addElements ( int numberOfElements ) { int newlen = m_firstFree + numberOfElements ; if ( newlen > m_blocksize ) { int index = m_firstFree > > > m_SHIFT ; int newindex = ( m_firstFree + numberOfElements ) > > > m_SHIFT ; for ( int i = index + 1 ; i <= newindex ; ++ i ) m_map [ i ] = new int [ m_blocksize ] ; } m_firstFree = newlen ; } private void insertElementAt ( int value , int at ) { if ( at == m_firstFree ) addElement ( value ) ; else if ( at > m_firstFree ) { int index = at > > > m_SHIFT ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; int offset = at & m_MASK ; block [ offset ] = value ; m_firstFree = offset + 1 ; } else { int index = at > > > m_SHIFT ; int maxindex = m_firstFree > > > m_SHIFT ; ++ m_firstFree ; int offset = at & m_MASK ; int push ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; int [ ] block = m_map [ index ] ; if ( null == block ) { push = 0 ; block = m_map [ index ] = new int [ m_blocksize ] ; } else { push = block [ m_blocksize - 1 ] ; System . arraycopy ( block , offset , block , offset + 1 , copylen ) ; } block [ offset ] = value ; value = push ; offset = 0 ; ++ index ; } } } public void removeAllElements ( ) { m_firstFree = 0 ; m_buildCache = m_map0 ; m_buildCacheStartIndex = 0 ; } private boolean removeElement ( int s ) { int at = indexOf ( s , 0 ) ; if ( at < 0 ) return false ; removeElementAt ( at ) ; return true ; } private void removeElementAt ( int at ) { if ( at < m_firstFree ) { int index = at > > > m_SHIFT ; int maxindex = m_firstFree > > > m_SHIFT ; int offset = at & m_MASK ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; else System . arraycopy ( block , offset + 1 , block , offset , copylen ) ; if ( index < maxindex ) { int [ ] next = m_map [ index + 1 ] ; if ( next != null ) block [ m_blocksize - 1 ] = ( next != null ) ? next [ 0 ] : 0 ; } else block [ m_blocksize - 1 ] = 0 ; offset = 0 ; ++ index ; } } -- m_firstFree ; } public void setElementAt ( int value , int at ) { if ( at < m_blocksize ) m_map0 [ at ] = value ; else { int index = at > > > m_SHIFT ; int offset = at & m_MASK ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; block [ offset ] = value ; } if ( at >= m_firstFree ) m_firstFree = at + 1 ; } public int elementAt ( int i ) { if ( i < m_blocksize ) return m_map0 [ i ] ; return m_map [ i > > > m_SHIFT ] [ i & m_MASK ] ; } private boolean contains ( int s ) { return ( indexOf ( s , 0 ) >= 0 ) ; } public int indexOf ( int elem , int index ) { if ( index >= m_firstFree ) return - 1 ; int bindex = index > > > m_SHIFT ; int boffset = index & m_MASK ; int maxindex = m_firstFree > > > m_SHIFT ; int [ ] block ; for ( ; bindex < maxindex ; ++ bindex ) { block = m_map [ bindex ] ; if ( block != null ) for ( int offset = boffset ; offset < m_blocksize ; ++ offset ) if ( block [ offset ] == elem ) return offset + bindex * m_blocksize ; boffset = 0 ; } int maxoffset = m_firstFree & m_MASK ; block = m_map [ maxindex ] ; for ( int offset = boffset ; offset < maxoffset ; ++ offset ) if ( block [ offset ] == elem ) return offset + maxindex * m_blocksize ; return - 1 ; } public int indexOf ( int elem ) { return indexOf ( elem , 0 ) ; } private int lastIndexOf ( int elem ) { int boffset = m_firstFree & m_MASK ; for ( int index = m_firstFree > > > m_SHIFT ; index >= 0 ; -- index ) { int [ ] block = m_map [ index ] ; if ( block != null ) for ( int offset = boffset ; offset >= 0 ; -- offset ) if ( block [ offset ] == elem ) return offset + index * m_blocksize ; boffset = 0 ; } return - 1 ; } public final int [ ] getMap0 ( ) { return m_map0 ; } public final int [ ] [ ] getMap ( ) { return m_map ; } } 	1	['20', '1', '0', '15', '22', '8', '15', '0', '13', '0.552631579', '901', '1', '0', '0', '0.875', '0', '0', '43.55', '8', '2.95', '1']
package org . apache . xml . utils ; public class NSInfo { public NSInfo ( boolean hasProcessedNS , boolean hasXMLNSAttrs ) { m_hasProcessedNS = hasProcessedNS ; m_hasXMLNSAttrs = hasXMLNSAttrs ; m_namespace = null ; m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED ; } public NSInfo ( boolean hasProcessedNS , boolean hasXMLNSAttrs , int ancestorHasXMLNSAttrs ) { m_hasProcessedNS = hasProcessedNS ; m_hasXMLNSAttrs = hasXMLNSAttrs ; m_ancestorHasXMLNSAttrs = ancestorHasXMLNSAttrs ; m_namespace = null ; } public NSInfo ( String namespace , boolean hasXMLNSAttrs ) { m_hasProcessedNS = true ; m_hasXMLNSAttrs = hasXMLNSAttrs ; m_namespace = namespace ; m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED ; } public String m_namespace ; public boolean m_hasXMLNSAttrs ; public boolean m_hasProcessedNS ; public int m_ancestorHasXMLNSAttrs ; public static final int ANCESTORXMLNSUNPROCESSED = 0 ; public static final int ANCESTORHASXMLNS = 1 ; public static final int ANCESTORNOXMLNS = 2 ; } 	1	['3', '1', '0', '1', '4', '0', '1', '0', '3', '0.642857143', '55', '0', '0', '0', '0.666666667', '0', '0', '15', '0', '0', '1']
package org . apache . xalan . xsltc . compiler ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionConstants ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . InvokeInstruction ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . MultiHashtable ; import org . apache . xalan . xsltc . compiler . util . ObjectType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . TransletLoader ; class FunctionCall extends Expression { private QName _fname ; private final Vector _arguments ; private final static Vector EMPTY_ARG_LIST = new Vector ( 0 ) ; protected final static String EXT_XSLTC = TRANSLET_URI ; protected final static String JAVA_EXT_XSLTC = EXT_XSLTC + "/java" ; protected final static String EXT_XALAN = "http://xml.apache.org/xalan" ; protected final static String JAVA_EXT_XALAN = "http://xml.apache.org/xalan/java" ; protected final static String JAVA_EXT_XALAN_OLD = "http://xml.apache.org/xslt/java" ; protected final static String EXSLT_COMMON = "http://exslt.org/common" ; protected final static String EXSLT_MATH = "http://exslt.org/math" ; protected final static String EXSLT_SETS = "http://exslt.org/sets" ; protected final static String EXSLT_DATETIME = "http://exslt.org/dates-and-times" ; protected final static String EXSLT_STRINGS = "http://exslt.org/strings" ; protected final static int NAMESPACE_FORMAT_JAVA = 0 ; protected final static int NAMESPACE_FORMAT_CLASS = 1 ; protected final static int NAMESPACE_FORMAT_PACKAGE = 2 ; protected final static int NAMESPACE_FORMAT_CLASS_OR_PACKAGE = 3 ; private int _namespace_format = NAMESPACE_FORMAT_JAVA ; Expression _thisArgument = null ; private String _className ; private Class _clazz ; private Method _chosenMethod ; private Constructor _chosenConstructor ; private MethodType _chosenMethodType ; private boolean unresolvedExternal ; private boolean _isExtConstructor = false ; private boolean _isStatic = false ; private static final MultiHashtable _internal2Java = new MultiHashtable ( ) ; private static final Hashtable _java2Internal = new Hashtable ( ) ; private static final Hashtable _extensionNamespaceTable = new Hashtable ( ) ; private static final Hashtable _extensionFunctionTable = new Hashtable ( ) ; static class JavaType { public Class type ; public int distance ; public JavaType ( Class type , int distance ) { this . type = type ; this . distance = distance ; } public boolean equals ( Object query ) { return query . equals ( type ) ; } } static { try { final Class objectClass = Class . forName ( "java.lang.Object" ) ; final Class stringClass = Class . forName ( "java.lang.String" ) ; final Class nodeClass = Class . forName ( "org.w3c.dom.Node" ) ; final Class nodeListClass = Class . forName ( "org.w3c.dom.NodeList" ) ; _internal2Java . put ( Type . Boolean , new JavaType ( objectClass , 2 ) ) ; _internal2Java . put ( Type . Boolean , new JavaType ( java . lang . Boolean . class , 1 ) ) ; _internal2Java . put ( Type . Boolean , new JavaType ( Boolean . TYPE , 0 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( objectClass , 8 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Character . TYPE , 7 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Byte . TYPE , 6 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Short . TYPE , 5 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Integer . TYPE , 0 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( java . lang . Integer . class , 1 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Long . TYPE , 2 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Float . TYPE , 3 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Double . TYPE , 4 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( objectClass , 8 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Character . TYPE , 7 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Byte . TYPE , 6 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Short . TYPE , 5 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Integer . TYPE , 4 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Long . TYPE , 3 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Float . TYPE , 2 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( java . lang . Double . class , 1 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Double . TYPE , 0 ) ) ; _internal2Java . put ( Type . String , new JavaType ( objectClass , 1 ) ) ; _internal2Java . put ( Type . String , new JavaType ( stringClass , 0 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( nodeClass , 0 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( nodeListClass , 1 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( objectClass , 2 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( stringClass , 3 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( Integer . TYPE , 10 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( stringClass , 3 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( objectClass , 2 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( nodeClass , 1 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( nodeListClass , 0 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( nodeClass , 1 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( nodeListClass , 0 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( objectClass , 2 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( stringClass , 3 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( Double . TYPE , 4 ) ) ; _internal2Java . put ( Type . Reference , new JavaType ( objectClass , 0 ) ) ; _java2Internal . put ( Boolean . TYPE , Type . Boolean ) ; _java2Internal . put ( Void . TYPE , Type . Void ) ; _java2Internal . put ( Character . TYPE , Type . Real ) ; _java2Internal . put ( Byte . TYPE , Type . Real ) ; _java2Internal . put ( Short . TYPE , Type . Real ) ; _java2Internal . put ( Integer . TYPE , Type . Real ) ; _java2Internal . put ( Long . TYPE , Type . Real ) ; _java2Internal . put ( Float . TYPE , Type . Real ) ; _java2Internal . put ( Double . TYPE , Type . Real ) ; _java2Internal . put ( stringClass , Type . String ) ; _java2Internal . put ( objectClass , Type . Reference ) ; _java2Internal . put ( nodeListClass , Type . NodeSet ) ; _java2Internal . put ( nodeClass , Type . NodeSet ) ; _extensionNamespaceTable . put ( EXT_XALAN , "org.apache.xalan.lib.Extensions" ) ; _extensionNamespaceTable . put ( EXSLT_COMMON , "org.apache.xalan.lib.ExsltCommon" ) ; _extensionNamespaceTable . put ( EXSLT_MATH , "org.apache.xalan.lib.ExsltMath" ) ; _extensionNamespaceTable . put ( EXSLT_SETS , "org.apache.xalan.lib.ExsltSets" ) ; _extensionNamespaceTable . put ( EXSLT_DATETIME , "org.apache.xalan.lib.ExsltDatetime" ) ; _extensionNamespaceTable . put ( EXSLT_STRINGS , "org.apache.xalan.lib.ExsltStrings" ) ; _extensionFunctionTable . put ( EXSLT_COMMON + ":nodeSet" , "nodeset" ) ; _extensionFunctionTable . put ( EXSLT_COMMON + ":objectType" , "objectType" ) ; _extensionFunctionTable . put ( EXT_XALAN + ":nodeset" , "nodeset" ) ; } catch ( ClassNotFoundException e ) { System . err . println ( e ) ; } } public FunctionCall ( QName fname , Vector arguments ) { _fname = fname ; _arguments = arguments ; _type = null ; } public FunctionCall ( QName fname ) { this ( fname , EMPTY_ARG_LIST ) ; } public String getName ( ) { return ( _fname . toString ( ) ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _arguments != null ) { final int n = _arguments . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) _arguments . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public String getClassNameFromUri ( String uri ) { String className = ( String ) _extensionNamespaceTable . get ( uri ) ; if ( className != null ) return className ; else { if ( uri . startsWith ( JAVA_EXT_XSLTC ) ) { int length = JAVA_EXT_XSLTC . length ( ) + 1 ; return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } else if ( uri . startsWith ( JAVA_EXT_XALAN ) ) { int length = JAVA_EXT_XALAN . length ( ) + 1 ; return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } else if ( uri . startsWith ( JAVA_EXT_XALAN_OLD ) ) { int length = JAVA_EXT_XALAN_OLD . length ( ) + 1 ; return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } else { int index = uri . lastIndexOf ( '/' ) ; return ( index > 0 ) ? uri . substring ( index + 1 ) : uri ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) return _type ; final String namespace = _fname . getNamespace ( ) ; String local = _fname . getLocalPart ( ) ; if ( isExtension ( ) ) { _fname = new QName ( null , null , local ) ; return typeCheckStandard ( stable ) ; } else if ( isStandard ( ) ) { return typeCheckStandard ( stable ) ; } else { try { _className = getClassNameFromUri ( namespace ) ; final int pos = local . lastIndexOf ( '.' ) ; if ( pos > 0 ) { _isStatic = true ; if ( _className != null && _className . length ( ) > 0 ) { _namespace_format = NAMESPACE_FORMAT_PACKAGE ; _className = _className + "." + local . substring ( 0 , pos ) ; } else { _namespace_format = NAMESPACE_FORMAT_JAVA ; _className = local . substring ( 0 , pos ) ; } _fname = new QName ( namespace , null , local . substring ( pos + 1 ) ) ; } else { if ( _className != null && _className . length ( ) > 0 ) { try { TransletLoader loader = new TransletLoader ( ) ; _clazz = loader . loadClass ( _className ) ; _namespace_format = NAMESPACE_FORMAT_CLASS ; } catch ( ClassNotFoundException e ) { _namespace_format = NAMESPACE_FORMAT_PACKAGE ; } } else _namespace_format = NAMESPACE_FORMAT_JAVA ; if ( local . indexOf ( '-' ) > 0 ) { local = replaceDash ( local ) ; } String extFunction = ( String ) _extensionFunctionTable . get ( namespace + ":" + local ) ; if ( extFunction != null ) { _fname = new QName ( null , null , extFunction ) ; return typeCheckStandard ( stable ) ; } else _fname = new QName ( namespace , null , local ) ; } return typeCheckExternal ( stable ) ; } catch ( TypeCheckError e ) { ErrorMsg errorMsg = e . getErrorMsg ( ) ; if ( errorMsg == null ) { final String name = _fname . getLocalPart ( ) ; errorMsg = new ErrorMsg ( ErrorMsg . METHOD_NOT_FOUND_ERR , name ) ; } getParser ( ) . reportError ( ERROR , errorMsg ) ; return _type = Type . Void ; } } } public Type typeCheckStandard ( SymbolTable stable ) throws TypeCheckError { _fname . clearNamespace ( ) ; final int n = _arguments . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; final MethodType args = new MethodType ( Type . Void , argsType ) ; final MethodType ptype = lookupPrimop ( stable , _fname . getLocalPart ( ) , args ) ; if ( ptype != null ) { for ( int i = 0 ; i < n ; i ++ ) { final Type argType = ( Type ) ptype . argsType ( ) . elementAt ( i ) ; final Expression exp = ( Expression ) _arguments . elementAt ( i ) ; if ( ! argType . identicalTo ( exp . getType ( ) ) ) { try { _arguments . setElementAt ( new CastExpr ( exp , argType ) , i ) ; } catch ( TypeCheckError e ) { throw new TypeCheckError ( this ) ; } } } _chosenMethodType = ptype ; return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public Type typeCheckConstructor ( SymbolTable stable ) throws TypeCheckError { final Vector constructors = findConstructors ( ) ; if ( constructors == null ) { throw new TypeCheckError ( ErrorMsg . CONSTRUCTOR_NOT_FOUND , _className ) ; } final int nConstructors = constructors . size ( ) ; final int nArgs = _arguments . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; int bestConstrDistance = Integer . MAX_VALUE ; _type = null ; for ( int j , i = 0 ; i < nConstructors ; i ++ ) { final Constructor constructor = ( Constructor ) constructors . elementAt ( i ) ; final Class [ ] paramTypes = constructor . getParameterTypes ( ) ; Class extType = null ; int currConstrDistance = 0 ; for ( j = 0 ; j < nArgs ; j ++ ) { extType = paramTypes [ j ] ; final Type intType = ( Type ) argsType . elementAt ( j ) ; Object match = _internal2Java . maps ( intType , extType ) ; if ( match != null ) { currConstrDistance += ( ( JavaType ) match ) . distance ; } else if ( intType instanceof ObjectType ) { ObjectType objectType = ( ObjectType ) intType ; if ( objectType . getJavaClass ( ) == extType ) continue ; else if ( extType . isAssignableFrom ( objectType . getJavaClass ( ) ) ) currConstrDistance += 1 ; else { currConstrDistance = Integer . MAX_VALUE ; break ; } } else { currConstrDistance = Integer . MAX_VALUE ; break ; } } if ( j == nArgs && currConstrDistance < bestConstrDistance ) { _chosenConstructor = constructor ; _isExtConstructor = true ; bestConstrDistance = currConstrDistance ; if ( _clazz != null ) _type = new ObjectType ( _clazz ) ; else _type = new ObjectType ( _className ) ; } } if ( _type != null ) { return _type ; } throw new TypeCheckError ( ErrorMsg . ARGUMENT_CONVERSION_ERR , getMethodSignature ( argsType ) ) ; } public Type typeCheckExternal ( SymbolTable stable ) throws TypeCheckError { int nArgs = _arguments . size ( ) ; final String name = _fname . getLocalPart ( ) ; if ( _fname . getLocalPart ( ) . equals ( "new" ) ) { return typeCheckConstructor ( stable ) ; } else { boolean hasThisArgument = false ; if ( nArgs == 0 ) _isStatic = true ; if ( ! _isStatic ) { if ( _namespace_format == NAMESPACE_FORMAT_JAVA || _namespace_format == NAMESPACE_FORMAT_PACKAGE ) hasThisArgument = true ; Expression firstArg = ( Expression ) _arguments . elementAt ( 0 ) ; Type firstArgType = ( Type ) firstArg . typeCheck ( stable ) ; if ( _namespace_format == NAMESPACE_FORMAT_CLASS && firstArgType instanceof ObjectType && _clazz != null && _clazz . isAssignableFrom ( ( ( ObjectType ) firstArgType ) . getJavaClass ( ) ) ) hasThisArgument = true ; if ( hasThisArgument ) { _thisArgument = ( Expression ) _arguments . elementAt ( 0 ) ; _arguments . remove ( 0 ) ; nArgs -- ; if ( firstArgType instanceof ObjectType ) { _className = ( ( ObjectType ) firstArgType ) . getJavaClassName ( ) ; } else throw new TypeCheckError ( ErrorMsg . NO_JAVA_FUNCT_THIS_REF , name ) ; } } else if ( _className . length ( ) == 0 ) { final Parser parser = getParser ( ) ; if ( parser != null ) { reportWarning ( this , parser , ErrorMsg . FUNCTION_RESOLVE_ERR , _fname . toString ( ) ) ; } unresolvedExternal = true ; return _type = Type . Int ; } } final Vector methods = findMethods ( ) ; if ( methods == null ) { throw new TypeCheckError ( ErrorMsg . METHOD_NOT_FOUND_ERR , _className + "." + name ) ; } Class extType = null ; final int nMethods = methods . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; int bestMethodDistance = Integer . MAX_VALUE ; _type = null ; for ( int j , i = 0 ; i < nMethods ; i ++ ) { final Method method = ( Method ) methods . elementAt ( i ) ; final Class [ ] paramTypes = method . getParameterTypes ( ) ; int currMethodDistance = 0 ; for ( j = 0 ; j < nArgs ; j ++ ) { extType = paramTypes [ j ] ; final Type intType = ( Type ) argsType . elementAt ( j ) ; Object match = _internal2Java . maps ( intType , extType ) ; if ( match != null ) { currMethodDistance += ( ( JavaType ) match ) . distance ; } else { if ( intType instanceof ReferenceType ) { currMethodDistance += 1 ; } else if ( intType instanceof ObjectType ) { ObjectType object = ( ObjectType ) intType ; if ( extType . getName ( ) . equals ( object . getJavaClassName ( ) ) ) currMethodDistance += 0 ; else if ( extType . isAssignableFrom ( object . getJavaClass ( ) ) ) currMethodDistance += 1 ; else { currMethodDistance = Integer . MAX_VALUE ; break ; } } else { currMethodDistance = Integer . MAX_VALUE ; break ; } } } if ( j == nArgs ) { extType = method . getReturnType ( ) ; _type = ( Type ) _java2Internal . get ( extType ) ; if ( _type == null ) { _type = new ObjectType ( extType ) ; } if ( _type != null && currMethodDistance < bestMethodDistance ) { _chosenMethod = method ; bestMethodDistance = currMethodDistance ; } } } if ( _chosenMethod != null && _thisArgument == null && ! Modifier . isStatic ( _chosenMethod . getModifiers ( ) ) ) { throw new TypeCheckError ( ErrorMsg . NO_JAVA_FUNCT_THIS_REF , getMethodSignature ( argsType ) ) ; } if ( _type != null ) { if ( _type == Type . NodeSet ) { getXSLTC ( ) . setMultiDocument ( true ) ; } return _type ; } throw new TypeCheckError ( ErrorMsg . ARGUMENT_CONVERSION_ERR , getMethodSignature ( argsType ) ) ; } public Vector typeCheckArgs ( SymbolTable stable ) throws TypeCheckError { final Vector result = new Vector ( ) ; final Enumeration e = _arguments . elements ( ) ; while ( e . hasMoreElements ( ) ) { final Expression exp = ( Expression ) e . nextElement ( ) ; result . addElement ( exp . typeCheck ( stable ) ) ; } return result ; } protected final Expression argument ( int i ) { return ( Expression ) _arguments . elementAt ( i ) ; } protected final Expression argument ( ) { return argument ( 0 ) ; } protected final int argumentCount ( ) { return _arguments . size ( ) ; } protected final void setArgument ( int i , Expression exp ) { _arguments . setElementAt ( exp , i ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { Type type = Type . Boolean ; if ( _chosenMethodType != null ) type = _chosenMethodType . resultType ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; translate ( classGen , methodGen ) ; if ( ( type instanceof BooleanType ) || ( type instanceof IntType ) ) { _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = argumentCount ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index ; if ( isStandard ( ) || isExtension ( ) ) { for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startResetIterator ( classGen , methodGen ) ; } final String name = _fname . toString ( ) . replace ( '-' , '_' ) + "F" ; String args = Constants . EMPTYSTRING ; if ( name . equals ( "sumF" ) ) { args = DOM_INTF_SIG ; il . append ( methodGen . loadDOM ( ) ) ; } else if ( name . equals ( "normalize_spaceF" ) ) { if ( _chosenMethodType . toSignature ( args ) . equals ( "()Ljava/lang/String;" ) ) { args = "I" + DOM_INTF_SIG ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; } } index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , name , _chosenMethodType . toSignature ( args ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( unresolvedExternal ) { index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "unresolved_externalF" , "(Ljava/lang/String;)V" ) ; il . append ( new PUSH ( cpg , _fname . toString ( ) ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( _isExtConstructor ) { final String clazz = _chosenConstructor . getDeclaringClass ( ) . getName ( ) ; Class [ ] paramTypes = _chosenConstructor . getParameterTypes ( ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( InstructionConstants . DUP ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startResetIterator ( classGen , methodGen ) ; exp . getType ( ) . translateTo ( classGen , methodGen , paramTypes [ i ] ) ; } final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; for ( int i = 0 ; i < paramTypes . length ; i ++ ) { buffer . append ( getSignature ( paramTypes [ i ] ) ) ; } buffer . append ( ')' ) ; buffer . append ( "V" ) ; index = cpg . addMethodref ( clazz , "<init>" , buffer . toString ( ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; ( Type . Object ) . translateFrom ( classGen , methodGen , _chosenConstructor . getDeclaringClass ( ) ) ; } else { final String clazz = _chosenMethod . getDeclaringClass ( ) . getName ( ) ; Class [ ] paramTypes = _chosenMethod . getParameterTypes ( ) ; if ( _thisArgument != null ) { _thisArgument . translate ( classGen , methodGen ) ; } for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startResetIterator ( classGen , methodGen ) ; exp . getType ( ) . translateTo ( classGen , methodGen , paramTypes [ i ] ) ; } final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; for ( int i = 0 ; i < paramTypes . length ; i ++ ) { buffer . append ( getSignature ( paramTypes [ i ] ) ) ; } buffer . append ( ')' ) ; buffer . append ( getSignature ( _chosenMethod . getReturnType ( ) ) ) ; index = cpg . addMethodref ( clazz , _fname . getLocalPart ( ) , buffer . toString ( ) ) ; il . append ( _thisArgument != null ? ( InvokeInstruction ) new INVOKEVIRTUAL ( index ) : ( InvokeInstruction ) new INVOKESTATIC ( index ) ) ; _type . translateFrom ( classGen , methodGen , _chosenMethod . getReturnType ( ) ) ; } } public String toString ( ) { return "funcall(" + _fname + ", " + _arguments + ')' ; } public boolean isStandard ( ) { final String namespace = _fname . getNamespace ( ) ; return ( namespace == null ) || ( namespace . equals ( Constants . EMPTYSTRING ) ) ; } public boolean isExtension ( ) { final String namespace = _fname . getNamespace ( ) ; return ( namespace != null ) && ( namespace . equals ( EXT_XSLTC ) ) ; } private Vector findMethods ( ) { Vector result = null ; final String namespace = _fname . getNamespace ( ) ; if ( _className != null && _className . length ( ) > 0 ) { final int nArgs = _arguments . size ( ) ; try { if ( _clazz == null ) { TransletLoader loader = new TransletLoader ( ) ; _clazz = loader . loadClass ( _className ) ; if ( _clazz == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } final String methodName = _fname . getLocalPart ( ) ; final Method [ ] methods = _clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final int mods = methods [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && methods [ i ] . getName ( ) . equals ( methodName ) && methods [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( result == null ) { result = new Vector ( ) ; } result . addElement ( methods [ i ] ) ; } } } catch ( ClassNotFoundException e ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } return result ; } private Vector findConstructors ( ) { Vector result = null ; final String namespace = _fname . getNamespace ( ) ; final int nArgs = _arguments . size ( ) ; try { if ( _clazz == null ) { TransletLoader loader = new TransletLoader ( ) ; _clazz = loader . loadClass ( _className ) ; if ( _clazz == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } final Constructor [ ] constructors = _clazz . getConstructors ( ) ; for ( int i = 0 ; i < constructors . length ; i ++ ) { final int mods = constructors [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && constructors [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( result == null ) { result = new Vector ( ) ; } result . addElement ( constructors [ i ] ) ; } } } catch ( ClassNotFoundException e ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } return result ; } static final String getSignature ( Class clazz ) { if ( clazz . isArray ( ) ) { final StringBuffer sb = new StringBuffer ( ) ; Class cl = clazz ; while ( cl . isArray ( ) ) { sb . append ( "[" ) ; cl = cl . getComponentType ( ) ; } sb . append ( getSignature ( cl ) ) ; return sb . toString ( ) ; } else if ( clazz . isPrimitive ( ) ) { if ( clazz == Integer . TYPE ) { return "I" ; } else if ( clazz == Byte . TYPE ) { return "B" ; } else if ( clazz == Long . TYPE ) { return "J" ; } else if ( clazz == Float . TYPE ) { return "F" ; } else if ( clazz == Double . TYPE ) { return "D" ; } else if ( clazz == Short . TYPE ) { return "S" ; } else if ( clazz == Character . TYPE ) { return "C" ; } else if ( clazz == Boolean . TYPE ) { return "Z" ; } else if ( clazz == Void . TYPE ) { return "V" ; } else { final String name = clazz . toString ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . UNKNOWN_SIG_TYPE_ERR , name ) ; throw new Error ( err . toString ( ) ) ; } } else { return "L" + clazz . getName ( ) . replace ( '.' , '/' ) + ';' ; } } static final String getSignature ( Method meth ) { final StringBuffer sb = new StringBuffer ( ) ; sb . append ( '(' ) ; final Class [ ] params = meth . getParameterTypes ( ) ; for ( int j = 0 ; j < params . length ; j ++ ) { sb . append ( getSignature ( params [ j ] ) ) ; } return sb . append ( ')' ) . append ( getSignature ( meth . getReturnType ( ) ) ) . toString ( ) ; } static final String getSignature ( Constructor cons ) { final StringBuffer sb = new StringBuffer ( ) ; sb . append ( '(' ) ; final Class [ ] params = cons . getParameterTypes ( ) ; for ( int j = 0 ; j < params . length ; j ++ ) { sb . append ( getSignature ( params [ j ] ) ) ; } return sb . append ( ")V" ) . toString ( ) ; } private String getMethodSignature ( Vector argsType ) { final StringBuffer buf = new StringBuffer ( _className ) ; buf . append ( '.' ) . append ( _fname . getLocalPart ( ) ) . append ( '(' ) ; int nArgs = argsType . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { final Type intType = ( Type ) argsType . elementAt ( i ) ; buf . append ( intType . toString ( ) ) ; if ( i < nArgs - 1 ) buf . append ( ", " ) ; } buf . append ( ')' ) ; return buf . toString ( ) ; } protected static String replaceDash ( String name ) { char dash = '-' ; StringBuffer buff = new StringBuffer ( "" ) ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { if ( i > 0 && name . charAt ( i - 1 ) == dash ) buff . append ( Character . toUpperCase ( name . charAt ( i ) ) ) ; else if ( name . charAt ( i ) != dash ) buff . append ( name . charAt ( i ) ) ; } return buff . toString ( ) ; } } 	1	['28', '3', '23', '60', '138', '124', '24', '36', '15', '0.931372549', '2406', '0.882352941', '4', '0.739583333', '0.128205128', '3', '10', '83.71428571', '15', '3.1786', '1']
package org . apache . xpath . axes ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public abstract class LocPathIterator extends PredicatedNodeTest implements Cloneable , DTMIterator , java . io . Serializable , PathComponent { protected LocPathIterator ( ) { } protected LocPathIterator ( PrefixResolver nscontext ) { setLocPathIterator ( this ) ; m_prefixResolver = nscontext ; } protected LocPathIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { this ( compiler , opPos , analysis , true ) ; } protected LocPathIterator ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { setLocPathIterator ( this ) ; } public int getAnalysisBits ( ) { int axis = getAxis ( ) ; int bit = WalkerFactory . getAnalysisBitFromAxes ( axis ) ; return bit ; } private void readObject ( java . io . ObjectInputStream stream ) throws java . io . IOException , javax . xml . transform . TransformerException { try { stream . defaultReadObject ( ) ; m_clones = new IteratorPool ( this ) ; } catch ( ClassNotFoundException cnfe ) { throw new javax . xml . transform . TransformerException ( cnfe ) ; } } public void setEnvironment ( Object environment ) { } public DTM getDTM ( int nodeHandle ) { return m_execContext . getDTM ( nodeHandle ) ; } public DTMManager getDTMManager ( ) { return m_execContext . getDTMManager ( ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XNodeSet iter = new XNodeSet ( ( LocPathIterator ) m_clones . getInstance ( ) ) ; iter . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; return iter ; } public void executeCharsToContentHandler ( XPathContext xctxt , org . xml . sax . ContentHandler handler ) throws javax . xml . transform . TransformerException , org . xml . sax . SAXException { LocPathIterator clone = ( LocPathIterator ) m_clones . getInstance ( ) ; int current = xctxt . getCurrentNode ( ) ; clone . setRoot ( current , xctxt ) ; int node = clone . nextNode ( ) ; DTM dtm = clone . getDTM ( node ) ; clone . detach ( ) ; if ( node != DTM . NULL ) { dtm . dispatchCharactersEvents ( node , handler , false ) ; } } public DTMIterator asIterator ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { XNodeSet iter = new XNodeSet ( ( LocPathIterator ) m_clones . getInstance ( ) ) ; iter . setRoot ( contextNode , xctxt ) ; return iter ; } public boolean isNodesetExpr ( ) { return true ; } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator iter = ( DTMIterator ) m_clones . getInstance ( ) ; int current = xctxt . getCurrentNode ( ) ; iter . setRoot ( current , xctxt ) ; int next = iter . nextNode ( ) ; iter . detach ( ) ; return next ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( asNode ( xctxt ) != DTM . NULL ) ; } public void setIsTopLevel ( boolean b ) { m_isTopLevel = b ; } public boolean getIsTopLevel ( ) { return m_isTopLevel ; } public void setRoot ( int context , Object environment ) { m_context = context ; XPathContext xctxt = ( XPathContext ) environment ; m_execContext = xctxt ; m_cdtm = xctxt . getDTM ( context ) ; m_currentContextNode = context ; if ( null == m_prefixResolver ) m_prefixResolver = xctxt . getNamespaceContext ( ) ; m_lastFetched = DTM . NULL ; m_foundLast = false ; m_pos = 0 ; m_length = - 1 ; if ( m_isTopLevel ) this . m_stackFrame = xctxt . getVarStack ( ) . getStackFrame ( ) ; } protected void setNextPosition ( int next ) { assertion ( false , "setNextPosition not supported in this iterator!" ) ; } public final int getCurrentPos ( ) { return m_pos ; } public void setShouldCacheNodes ( boolean b ) { assertion ( false , "setShouldCacheNodes not supported by this iterater!" ) ; } public boolean isMutable ( ) { return false ; } public void setCurrentPos ( int i ) { assertion ( false , "setCurrentPos not supported by this iterator!" ) ; } public void incrementCurrentPos ( ) { m_pos ++ ; } public int size ( ) { assertion ( false , "size() not supported by this iterator!" ) ; return 0 ; } public int item ( int index ) { assertion ( false , "item(int index) not supported by this iterator!" ) ; return 0 ; } public void setItem ( int node , int index ) { assertion ( false , "setItem not supported by this iterator!" ) ; } public int getLength ( ) { boolean isPredicateTest = ( this == m_execContext . getSubContextList ( ) ) ; int predCount = getPredicateCount ( ) ; if ( - 1 != m_length && isPredicateTest && m_predicateIndex < 1 ) return m_length ; if ( m_foundLast ) return m_pos ; int pos = ( m_predicateIndex >= 0 ) ? getProximityPosition ( ) : m_pos ; LocPathIterator clone ; try { clone = ( LocPathIterator ) clone ( ) ; } catch ( CloneNotSupportedException cnse ) { return - 1 ; } if ( predCount > 0 && isPredicateTest ) { clone . m_predCount = m_predicateIndex ; } int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { pos ++ ; } if ( isPredicateTest && m_predicateIndex < 1 ) m_length = pos ; return pos ; } public boolean isFresh ( ) { return ( m_pos == 0 ) ; } public int previousNode ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_ITERATE , null ) ) ; } public int getWhatToShow ( ) { return DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ; } public DTMFilter getFilter ( ) { return null ; } public int getRoot ( ) { return m_context ; } public boolean getExpandEntityReferences ( ) { return true ; } protected boolean m_allowDetach = true ; public void allowDetachToRelease ( boolean allowRelease ) { m_allowDetach = allowRelease ; } public void detach ( ) { if ( m_allowDetach ) { m_execContext = null ; m_cdtm = null ; m_length = - 1 ; m_pos = 0 ; m_lastFetched = DTM . NULL ; m_context = DTM . NULL ; m_currentContextNode = DTM . NULL ; m_clones . freeInstance ( this ) ; } } public void reset ( ) { assertion ( false , "This iterator can not reset!" ) ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { LocPathIterator clone ; clone = ( LocPathIterator ) m_clones . getInstanceOrThrow ( ) ; clone . m_execContext = m_execContext ; clone . m_cdtm = m_cdtm ; clone . m_context = m_context ; clone . m_currentContextNode = m_currentContextNode ; clone . m_stackFrame = m_stackFrame ; return clone ; } public abstract int nextNode ( ) ; protected int returnNextNode ( int nextNode ) { if ( DTM . NULL != nextNode ) { m_pos ++ ; } m_lastFetched = nextNode ; if ( DTM . NULL == nextNode ) m_foundLast = true ; return nextNode ; } public int getCurrentNode ( ) { return m_lastFetched ; } public void runTo ( int index ) { if ( m_foundLast || ( ( index >= 0 ) && ( index <= getCurrentPos ( ) ) ) ) return ; int n ; if ( - 1 == index ) { while ( DTM . NULL != ( n = nextNode ( ) ) ) ; } else { while ( DTM . NULL != ( n = nextNode ( ) ) ) { if ( getCurrentPos ( ) >= index ) break ; } } } public final boolean getFoundLast ( ) { return m_foundLast ; } public final XPathContext getXPathContext ( ) { return m_execContext ; } public final int getContext ( ) { return m_context ; } public final int getCurrentContextNode ( ) { return m_currentContextNode ; } public final void setCurrentContextNode ( int n ) { m_currentContextNode = n ; } public final PrefixResolver getPrefixResolver ( ) { if ( null == m_prefixResolver ) { m_prefixResolver = ( PrefixResolver ) getExpressionOwner ( ) ; } return m_prefixResolver ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitLocationPath ( owner , this ) ) { visitor . visitStep ( owner , this ) ; callPredicateVisitors ( visitor ) ; } } transient protected IteratorPool m_clones = new IteratorPool ( this ) ; transient protected DTM m_cdtm ; transient int m_stackFrame = - 1 ; private boolean m_isTopLevel = false ; transient public int m_lastFetched = DTM . NULL ; transient protected int m_context = DTM . NULL ; transient protected int m_currentContextNode = DTM . NULL ; transient protected int m_pos = 0 ; transient protected int m_length = - 1 ; private PrefixResolver m_prefixResolver ; transient protected XPathContext m_execContext ; public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } public int getLastPos ( XPathContext xctxt ) { return getLength ( ) ; } } 	1	['52', '4', '8', '37', '84', '1016', '21', '20', '45', '0.85130719', '665', '0.833333333', '4', '0.616', '0.145104895', '2', '9', '11.55769231', '12', '1.4231', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class DTMAxisIteratorBase implements DTMAxisIterator { protected int _last = - 1 ; protected int _position = 0 ; protected int _markedNode ; protected int _startNode = DTMAxisIterator . END ; protected boolean _includeSelf = false ; protected boolean _isRestartable = true ; public int getStartNode ( ) { return _startNode ; } public DTMAxisIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _startNode ) ; _isRestartable = temp ; return this ; } public DTMAxisIterator includeSelf ( ) { _includeSelf = true ; return this ; } public int getLast ( ) { if ( _last == - 1 ) { final int temp = _position ; setMark ( ) ; reset ( ) ; do { _last ++ ; } while ( next ( ) != END ) ; gotoMark ( ) ; _position = temp ; } return _last ; } public int getPosition ( ) { return _position == 0 ? 1 : _position ; } public boolean isReverse ( ) { return false ; } public DTMAxisIterator cloneIterator ( ) { try { final DTMAxisIteratorBase clone = ( DTMAxisIteratorBase ) super . clone ( ) ; return clone ; } catch ( CloneNotSupportedException e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } protected final int returnNode ( final int node ) { _position ++ ; return node ; } protected final DTMAxisIterator resetPosition ( ) { _position = 0 ; return this ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; } public int getNodeByPosition ( int position ) { if ( position > 0 ) { final int pos = isReverse ( ) ? getLast ( ) - position + 1 : position ; int node ; while ( ( node = next ( ) ) != DTMAxisIterator . END ) { if ( pos == getPosition ( ) ) { return node ; } } } return END ; } } 	1	['14', '1', '19', '21', '21', '59', '19', '2', '12', '0.807692308', '163', '1', '0', '0', '0.404761905', '0', '0', '10.21428571', '5', '1.4286', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMDOMException ; import org . w3c . dom . Attr ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Comment ; import org . w3c . dom . DOMException ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . EntityReference ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; public class DTMNodeProxy implements Node , Document , Text , Element , Attr , ProcessingInstruction , Comment , DocumentFragment { public DTM dtm ; int node ; static final DOMImplementation implementation = new DTMNodeProxyImplementation ( ) ; public DTMNodeProxy ( DTM dtm , int node ) { this . dtm = dtm ; this . node = node ; } public final DTM getDTM ( ) { return dtm ; } public final int getDTMNodeNumber ( ) { return node ; } public final boolean equals ( Node node ) { try { DTMNodeProxy dtmp = ( DTMNodeProxy ) node ; return ( dtmp . node == this . node ) && ( dtmp . dtm == this . dtm ) ; } catch ( ClassCastException cce ) { return false ; } } public final boolean equals ( Object node ) { try { return equals ( ( Node ) node ) ; } catch ( ClassCastException cce ) { return false ; } } public final boolean sameNodeAs ( Node other ) { if ( ! ( other instanceof DTMNodeProxy ) ) return false ; DTMNodeProxy that = ( DTMNodeProxy ) other ; return this . dtm == that . dtm && this . node == that . node ; } public final String getNodeName ( ) { return dtm . getNodeName ( node ) ; } public final String getTarget ( ) { return dtm . getNodeName ( node ) ; } public final String getLocalName ( ) { return dtm . getLocalName ( node ) ; } public final String getPrefix ( ) { return dtm . getPrefix ( node ) ; } public final void setPrefix ( String prefix ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final String getNamespaceURI ( ) { return dtm . getNamespaceURI ( node ) ; } public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; } public final boolean isSupported ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; } public final String getNodeValue ( ) throws DOMException { return dtm . getNodeValue ( node ) ; } public final String getStringValue ( ) throws DOMException { return dtm . getStringValue ( node ) . toString ( ) ; } public final void setNodeValue ( String nodeValue ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final short getNodeType ( ) { return ( short ) dtm . getNodeType ( node ) ; } public final Node getParentNode ( ) { if ( getNodeType ( ) == Node . ATTRIBUTE_NODE ) return null ; int newnode = dtm . getParent ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getOwnerNode ( ) { int newnode = dtm . getParent ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final NodeList getChildNodes ( ) { return new DTMChildIterNodeList ( dtm , node ) ; } public final Node getFirstChild ( ) { int newnode = dtm . getFirstChild ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getLastChild ( ) { int newnode = dtm . getLastChild ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getPreviousSibling ( ) { int newnode = dtm . getPreviousSibling ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getNextSibling ( ) { if ( dtm . getNodeType ( node ) == Node . ATTRIBUTE_NODE ) return null ; int newnode = dtm . getNextSibling ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final NamedNodeMap getAttributes ( ) { return new DTMNamedNodeMap ( dtm , node ) ; } public boolean hasAttribute ( String name ) { return DTM . NULL != dtm . getAttributeNode ( node , null , name ) ; } public boolean hasAttributeNS ( String name , String x ) { return DTM . NULL != dtm . getAttributeNode ( node , x , name ) ; } public final Document getOwnerDocument ( ) { return ( Document ) ( dtm . getNode ( dtm . getOwnerDocument ( node ) ) ) ; } public final Node insertBefore ( Node newChild , Node refChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Node removeChild ( Node oldChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Node appendChild ( Node newChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final boolean hasChildNodes ( ) { return ( DTM . NULL != dtm . getFirstChild ( node ) ) ; } public final Node cloneNode ( boolean deep ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final DocumentType getDoctype ( ) { return null ; } public final DOMImplementation getImplementation ( ) { return implementation ; } public final Element getDocumentElement ( ) { int dochandle = dtm . getDocument ( ) ; int elementhandle = DTM . NULL ; for ( int kidhandle = dtm . getFirstChild ( dochandle ) ; kidhandle != DTM . NULL ; kidhandle = dtm . getNextSibling ( kidhandle ) ) { switch ( dtm . getNodeType ( kidhandle ) ) { case Node . ELEMENT_NODE : if ( elementhandle != DTM . NULL ) { elementhandle = DTM . NULL ; kidhandle = dtm . getLastChild ( dochandle ) ; } else elementhandle = kidhandle ; break ; case Node . COMMENT_NODE : case Node . PROCESSING_INSTRUCTION_NODE : case Node . DOCUMENT_TYPE_NODE : break ; default : elementhandle = DTM . NULL ; kidhandle = dtm . getLastChild ( dochandle ) ; break ; } } if ( elementhandle == DTM . NULL ) throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; else return ( Element ) ( dtm . getNode ( elementhandle ) ) ; } public final Element createElement ( String tagName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final DocumentFragment createDocumentFragment ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Text createTextNode ( String data ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Comment createComment ( String data ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final CDATASection createCDATASection ( String data ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr createAttribute ( String name ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final EntityReference createEntityReference ( String name ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final NodeList getElementsByTagName ( String tagname ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Node importNode ( Node importedNode , boolean deep ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Element getElementById ( String elementId ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Text splitText ( int offset ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getData ( ) throws DOMException { return dtm . getNodeValue ( node ) ; } public final void setData ( String data ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final int getLength ( ) { return dtm . getNodeValue ( node ) . length ( ) ; } public final String substringData ( int offset , int count ) throws DOMException { return getData ( ) . substring ( offset , offset + count ) ; } public final void appendData ( String arg ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void insertData ( int offset , String arg ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void deleteData ( int offset , int count ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void replaceData ( int offset , int count , String arg ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getTagName ( ) { return dtm . getNodeName ( node ) ; } public final String getAttribute ( String name ) { DTMNamedNodeMap map = new DTMNamedNodeMap ( dtm , node ) ; Node node = map . getNamedItem ( name ) ; return ( null == node ) ? null : node . getNodeValue ( ) ; } public final void setAttribute ( String name , String value ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void removeAttribute ( String name ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr getAttributeNode ( String name ) { DTMNamedNodeMap map = new DTMNamedNodeMap ( dtm , node ) ; return ( Attr ) map . getNamedItem ( name ) ; } public final Attr setAttributeNode ( Attr newAttr ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean hasAttributes ( ) { return DTM . NULL != dtm . getFirstAttribute ( node ) ; } public final void normalize ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getAttributeNS ( String namespaceURI , String localName ) { DTMNamedNodeMap map = new DTMNamedNodeMap ( dtm , node ) ; Node node = map . getNamedItemNS ( namespaceURI , localName ) ; return ( null == node ) ? null : node . getNodeValue ( ) ; } public final void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr getAttributeNodeNS ( String namespaceURI , String localName ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getName ( ) { return dtm . getNodeName ( node ) ; } public final boolean getSpecified ( ) { return true ; } public final String getValue ( ) { return dtm . getNodeValue ( node ) ; } public final void setValue ( String value ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Element getOwnerElement ( ) { if ( getNodeType ( ) != Node . ATTRIBUTE_NODE ) return null ; int newnode = dtm . getParent ( node ) ; return ( newnode == DTM . NULL ) ? null : ( Element ) ( dtm . getNode ( newnode ) ) ; } public Node adoptNode ( Node source ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public String getEncoding ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setEncoding ( String encoding ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean getStandalone ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setStandalone ( boolean standalone ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean getStrictErrorChecking ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setStrictErrorChecking ( boolean strictErrorChecking ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public String getVersion ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setVersion ( String version ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } static class DTMNodeProxyImplementation implements DOMImplementation { public DocumentType createDocumentType ( String qualifiedName , String publicId , String systemId ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public Document createDocument ( String namespaceURI , String qualfiedName , DocumentType doctype ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean hasFeature ( String feature , String version ) { if ( ( "CORE" . equals ( feature . toUpperCase ( ) ) || "XML" . equals ( feature . toUpperCase ( ) ) ) && ( "1.0" . equals ( version ) || "2.0" . equals ( version ) ) ) return true ; return false ; } } } 	1	['121', '1', '0', '13', '151', '5992', '7', '6', '120', '0.794444444', '1009', '0', '1', '0', '0.185185185', '0', '0', '7.314049587', '4', '1.1818', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . FieldGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . bcel . generic . TargetLostException ; import org . apache . bcel . util . InstructionFinder ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . dtm . DTM ; public final class Stylesheet extends SyntaxTreeNode { private String _version ; private QName _name ; private String _systemId ; private Stylesheet _parentStylesheet ; private Vector _globals = new Vector ( ) ; private Boolean _hasLocalParams = null ; private String _className ; private final Vector _templates = new Vector ( ) ; private int _nextModeSerial = 1 ; private final Hashtable _modes = new Hashtable ( ) ; private final Hashtable _extensions = new Hashtable ( ) ; public Stylesheet _importedFrom = null ; public Stylesheet _includedFrom = null ; private int _importPrecedence = 1 ; private Mode _defaultMode ; private boolean _multiDocument = false ; private boolean _callsNodeset = false ; private Hashtable _keys = new Hashtable ( ) ; private boolean _numberFormattingUsed = false ; private boolean _simplified = false ; private SourceLoader _loader = null ; private boolean _templateInlining = true ; private boolean _forwardReference = false ; private boolean _hasIdCall = false ; private Properties _outputProperties = null ; public void setForwardReference ( ) { _forwardReference = true ; } public boolean getTemplateInlining ( ) { return _templateInlining ; } public void setTemplateInlining ( boolean flag ) { _templateInlining = flag ; } public boolean isSimplified ( ) { return ( _simplified ) ; } public void setSimplified ( ) { _simplified = true ; } public void setHasIdCall ( boolean flag ) { _hasIdCall = flag ; } public void setOutputProperty ( String key , String value ) { if ( _outputProperties == null ) { _outputProperties = new Properties ( ) ; } _outputProperties . setProperty ( key , value ) ; } public void setOutputProperties ( Properties props ) { _outputProperties = props ; } public Properties getOutputProperties ( ) { return _outputProperties ; } public void setMultiDocument ( boolean flag ) { _multiDocument = flag ; } public boolean isMultiDocument ( ) { return _multiDocument ; } public void setCallsNodeset ( boolean flag ) { if ( flag ) setMultiDocument ( flag ) ; _callsNodeset = flag ; } public boolean callsNodeset ( ) { return _callsNodeset ; } public void numberFormattingUsed ( ) { _numberFormattingUsed = true ; } public void setImportPrecedence ( final int precedence ) { _importPrecedence = precedence ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { SyntaxTreeNode child = ( SyntaxTreeNode ) elements . nextElement ( ) ; if ( child instanceof Include ) { Stylesheet included = ( ( Include ) child ) . getIncludedStylesheet ( ) ; if ( included != null && included . _includedFrom == this ) { included . setImportPrecedence ( precedence ) ; } } } if ( _importedFrom != null ) { if ( _importedFrom . getImportPrecedence ( ) < precedence ) { final Parser parser = getParser ( ) ; final int nextPrecedence = parser . getNextImportPrecedence ( ) ; _importedFrom . setImportPrecedence ( nextPrecedence ) ; } } else if ( _includedFrom != null ) { if ( _includedFrom . getImportPrecedence ( ) != precedence ) _includedFrom . setImportPrecedence ( precedence ) ; } } public int getImportPrecedence ( ) { return _importPrecedence ; } public boolean checkForLoop ( String systemId ) { if ( _systemId != null && _systemId . equals ( systemId ) ) { return true ; } if ( _parentStylesheet != null ) return _parentStylesheet . checkForLoop ( systemId ) ; return false ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _name = makeStylesheetName ( "__stylesheet_" ) ; } public void setParentStylesheet ( Stylesheet parent ) { _parentStylesheet = parent ; } public Stylesheet getParentStylesheet ( ) { return _parentStylesheet ; } public void setImportingStylesheet ( Stylesheet parent ) { _importedFrom = parent ; } public void setIncludingStylesheet ( Stylesheet parent ) { _includedFrom = parent ; } public void setSystemId ( String systemId ) { _systemId = systemId ; } public String getSystemId ( ) { return _systemId ; } public void setSourceLoader ( SourceLoader loader ) { _loader = loader ; } public SourceLoader getSourceLoader ( ) { return _loader ; } private QName makeStylesheetName ( String prefix ) { return getParser ( ) . getQName ( prefix + getXSLTC ( ) . nextStylesheetSerial ( ) ) ; } public boolean hasGlobals ( ) { return _globals . size ( ) > 0 ; } public boolean hasLocalParams ( ) { if ( _hasLocalParams == null ) { final int n = _templates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Template template = ( Template ) _templates . elementAt ( i ) ; if ( template . hasParams ( ) ) { _hasLocalParams = new Boolean ( true ) ; return true ; } } _hasLocalParams = new Boolean ( false ) ; return false ; } else { return _hasLocalParams . booleanValue ( ) ; } } protected void addPrefixMapping ( String prefix , String uri ) { if ( prefix . equals ( EMPTYSTRING ) && uri . equals ( XHTML_URI ) ) return ; super . addPrefixMapping ( prefix , uri ) ; } private void extensionURI ( String prefixes , SymbolTable stable ) { if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri = lookupNamespace ( prefix ) ; if ( uri != null ) { _extensions . put ( uri , prefix ) ; } } } } public boolean isExtension ( String uri ) { return ( _extensions . get ( uri ) != null ) ; } public void excludeExtensionPrefixes ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; final String excludePrefixes = getAttribute ( "exclude-result-prefixes" ) ; final String extensionPrefixes = getAttribute ( "extension-element-prefixes" ) ; stable . excludeURI ( Constants . XSLT_URI ) ; stable . excludeNamespaces ( excludePrefixes ) ; stable . excludeNamespaces ( extensionPrefixes ) ; extensionURI ( extensionPrefixes , stable ) ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; addPrefixMapping ( "xml" , "http://www.w3.org/XML/1998/namespace" ) ; final Stylesheet sheet = stable . addStylesheet ( _name , this ) ; if ( sheet != null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . MULTIPLE_STYLESHEET_ERR , this ) ; parser . reportError ( Constants . ERROR , err ) ; } if ( _simplified ) { stable . excludeURI ( XSLT_URI ) ; Template template = new Template ( ) ; template . parseSimplified ( this , parser ) ; } else { parseOwnChildren ( parser ) ; } } public final void parseOwnChildren ( Parser parser ) { final Vector contents = getContents ( ) ; final int count = contents . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ( child instanceof VariableBase ) || ( child instanceof NamespaceAlias ) ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } } for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! ( child instanceof VariableBase ) && ! ( child instanceof NamespaceAlias ) ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } if ( ! _templateInlining && ( child instanceof Template ) ) { Template template = ( Template ) child ; String name = "template$dot$" + template . getPosition ( ) ; template . setName ( parser . getQName ( name ) ) ; } } } public void processModes ( ) { if ( _defaultMode == null ) _defaultMode = new Mode ( null , this , Constants . EMPTYSTRING ) ; _defaultMode . processPatterns ( _keys ) ; final Enumeration modes = _modes . elements ( ) ; while ( modes . hasMoreElements ( ) ) { final Mode mode = ( Mode ) modes . nextElement ( ) ; mode . processPatterns ( _keys ) ; } } private void compileModes ( ClassGenerator classGen ) { _defaultMode . compileApplyTemplates ( classGen ) ; final Enumeration modes = _modes . elements ( ) ; while ( modes . hasMoreElements ( ) ) { final Mode mode = ( Mode ) modes . nextElement ( ) ; mode . compileApplyTemplates ( classGen ) ; } } public Mode getMode ( QName modeName ) { if ( modeName == null ) { if ( _defaultMode == null ) { _defaultMode = new Mode ( null , this , Constants . EMPTYSTRING ) ; } return _defaultMode ; } else { Mode mode = ( Mode ) _modes . get ( modeName ) ; if ( mode == null ) { final String suffix = Integer . toString ( _nextModeSerial ++ ) ; _modes . put ( modeName , mode = new Mode ( modeName , this , suffix ) ) ; } return mode ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int count = _globals . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final VariableBase var = ( VariableBase ) _globals . elementAt ( i ) ; var . typeCheck ( stable ) ; } return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { translate ( ) ; } private void addDOMField ( ClassGenerator classGen ) { final FieldGen fgen = new FieldGen ( ACC_PUBLIC , Util . getJCRefType ( DOM_INTF_SIG ) , DOM_FIELD , classGen . getConstantPool ( ) ) ; classGen . addField ( fgen . getField ( ) ) ; } public void translate ( ) { Output lastOutputElement = null ; _className = getXSLTC ( ) . getClassName ( ) ; final ClassGenerator classGen = new ClassGenerator ( _className , TRANSLET_CLASS , Constants . EMPTYSTRING , ACC_PUBLIC | ACC_SUPER , null , this ) ; addDOMField ( classGen ) ; compileTransform ( classGen ) ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { Object element = elements . nextElement ( ) ; if ( element instanceof Template ) { final Template template = ( Template ) element ; _templates . addElement ( template ) ; getMode ( template . getModeName ( ) ) . addTemplate ( template ) ; } else if ( element instanceof AttributeSet ) { ( ( AttributeSet ) element ) . translate ( classGen , null ) ; } else if ( element instanceof Output ) { Output output = ( Output ) element ; if ( output . enabled ( ) ) lastOutputElement = output ; } else { } } processModes ( ) ; compileModes ( classGen ) ; compileConstructor ( classGen , lastOutputElement ) ; if ( ! getParser ( ) . errorsFound ( ) ) { getXSLTC ( ) . dumpClass ( classGen . getJavaClass ( ) ) ; } } private void compileConstructor ( ClassGenerator classGen , Output output ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator constructor = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , null , null , "<init>" , _className , il , cpg ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( TRANSLET_CLASS , "<init>" , "()V" ) ) ) ; final Vector names = getXSLTC ( ) . getNamesIndex ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , names . size ( ) ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { final String name = ( String ) names . elementAt ( i ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , name ) ) ; il . append ( AASTORE ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; final Vector namespaces = getXSLTC ( ) . getNamespaceIndex ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , namespaces . size ( ) ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int i = 0 ; i < namespaces . size ( ) ; i ++ ) { final String ns = ( String ) namespaces . elementAt ( i ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , ns ) ) ; il . append ( AASTORE ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; if ( _hasIdCall ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , Boolean . TRUE ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , HASIDCALL_INDEX , HASIDCALL_INDEX_SIG ) ) ) ; } if ( output != null ) { output . translate ( classGen , constructor ) ; } if ( _numberFormattingUsed ) DecimalFormatting . translateDefaultDFS ( classGen , constructor ) ; il . append ( RETURN ) ; constructor . stripAttributes ( true ) ; constructor . setMaxLocals ( ) ; constructor . setMaxStack ( ) ; classGen . addMethod ( constructor . getMethod ( ) ) ; } private String compileTopLevel ( ClassGenerator classGen , Enumeration elements ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) } ; final String [ ] argNames = { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME } ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator toplevel = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "topLevel" , _className , il , classGen . getConstantPool ( ) ) ; toplevel . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current = toplevel . addLocalVariable ( "current" , org . apache . bcel . generic . Type . INT , il . getEnd ( ) , null ) ; final int setFilter = cpg . addInterfaceMethodref ( DOM_INTF , "setFilter" , "(Lorg/apache/xalan/xsltc/StripFilter;)V" ) ; il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; il . append ( new ISTORE ( current . getIndex ( ) ) ) ; _globals = resolveReferences ( _globals ) ; final int count = _globals . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final VariableBase var = ( VariableBase ) _globals . elementAt ( i ) ; var . translate ( classGen , toplevel ) ; } Vector whitespaceRules = new Vector ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof DecimalFormatting ) { ( ( DecimalFormatting ) element ) . translate ( classGen , toplevel ) ; } else if ( element instanceof Whitespace ) { whitespaceRules . addAll ( ( ( Whitespace ) element ) . getRules ( ) ) ; } } if ( whitespaceRules . size ( ) > 0 ) { Whitespace . translateRules ( whitespaceRules , classGen ) ; } if ( classGen . containsMethod ( STRIP_SPACE , STRIP_SPACE_PARAMS ) != null ) { il . append ( toplevel . loadDOM ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEINTERFACE ( setFilter , 2 ) ) ; } il . append ( RETURN ) ; toplevel . stripAttributes ( true ) ; toplevel . setMaxLocals ( ) ; toplevel . setMaxStack ( ) ; toplevel . removeNOPs ( ) ; classGen . addMethod ( toplevel . getMethod ( ) ) ; return ( "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; } private Vector resolveReferences ( Vector input ) { for ( int i = 0 ; i < input . size ( ) ; i ++ ) { final VariableBase var = ( VariableBase ) input . elementAt ( i ) ; final Vector dep = var . getDependencies ( ) ; final int depSize = ( dep != null ) ? dep . size ( ) : 0 ; for ( int j = 0 ; j < depSize ; j ++ ) { final VariableBase depVar = ( VariableBase ) dep . elementAt ( j ) ; if ( ! input . contains ( depVar ) ) { input . addElement ( depVar ) ; } } } Vector result = new Vector ( ) ; while ( input . size ( ) > 0 ) { boolean changed = false ; for ( int i = 0 ; i < input . size ( ) ; ) { final VariableBase var = ( VariableBase ) input . elementAt ( i ) ; final Vector dep = var . getDependencies ( ) ; if ( dep == null || result . containsAll ( dep ) ) { result . addElement ( var ) ; input . remove ( i ) ; changed = true ; } else { i ++ ; } } if ( ! changed ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CIRCULAR_VARIABLE_ERR , input . toString ( ) , this ) ; getParser ( ) . reportError ( Constants . ERROR , err ) ; return ( result ) ; } } return result ; } private String compileBuildKeys ( ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) , org . apache . bcel . generic . Type . INT } ; final String [ ] argNames = { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME , "current" } ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator buildKeys = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "buildKeys" , _className , il , classGen . getConstantPool ( ) ) ; buildKeys . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof Key ) { final Key key = ( Key ) element ; key . translate ( classGen , buildKeys ) ; _keys . put ( key . getName ( ) , key ) ; } } il . append ( RETURN ) ; buildKeys . stripAttributes ( true ) ; buildKeys . setMaxLocals ( ) ; buildKeys . setMaxStack ( ) ; buildKeys . removeNOPs ( ) ; classGen . addMethod ( buildKeys . getMethod ( ) ) ; return ( "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + "I)V" ) ; } private void compileTransform ( ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator transf = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "transform" , _className , il , classGen . getConstantPool ( ) ) ; transf . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current = transf . addLocalVariable ( "current" , org . apache . bcel . generic . Type . INT , il . getEnd ( ) , null ) ; final String applyTemplatesSig = classGen . getApplyTemplatesSig ( ) ; final int applyTemplates = cpg . addMethodref ( getClassName ( ) , "applyTemplates" , applyTemplatesSig ) ; final int domField = cpg . addFieldref ( getClassName ( ) , DOM_FIELD , DOM_INTF_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( isMultiDocument ( ) ) { il . append ( new NEW ( cpg . addClass ( MULTI_DOM_CLASS ) ) ) ; il . append ( DUP ) ; } il . append ( classGen . loadTranslet ( ) ) ; il . append ( transf . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , "makeDOMAdapter" , "(" + DOM_INTF_SIG + ")" + DOM_ADAPTER_SIG ) ) ) ; if ( isMultiDocument ( ) ) { final int init = cpg . addMethodref ( MULTI_DOM_CLASS , "<init>" , "(" + DOM_INTF_SIG + ")V" ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } il . append ( new PUTFIELD ( domField ) ) ; il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; il . append ( new ISTORE ( current . getIndex ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( transf . loadHandler ( ) ) ; final int index = cpg . addMethodref ( TRANSLET_CLASS , "transferOutputSettings" , "(" + OUTPUT_HANDLER_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; final Enumeration toplevel = elements ( ) ; if ( ( _globals . size ( ) > 0 ) || ( toplevel . hasMoreElements ( ) ) ) { final String topLevelSig = compileTopLevel ( classGen , toplevel ) ; final int topLevelIdx = cpg . addMethodref ( getClassName ( ) , "topLevel" , topLevelSig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( topLevelIdx ) ) ; } final String keySig = compileBuildKeys ( classGen ) ; final int keyIdx = cpg . addMethodref ( getClassName ( ) , "buildKeys" , keySig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; il . append ( new INVOKEVIRTUAL ( keyIdx ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( transf . startDocument ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( transf . endDocument ( ) ) ; il . append ( RETURN ) ; transf . stripAttributes ( true ) ; transf . setMaxLocals ( ) ; transf . setMaxStack ( ) ; transf . removeNOPs ( ) ; classGen . addMethod ( transf . getMethod ( ) ) ; } private void peepHoleOptimization ( MethodGenerator methodGen ) { final String pattern = "`ALOAD'`POP'`Instruction'" ; final InstructionList il = methodGen . getInstructionList ( ) ; final InstructionFinder find = new InstructionFinder ( il ) ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { il . delete ( match [ 0 ] , match [ 1 ] ) ; } catch ( TargetLostException e ) { } } } public int addParam ( Param param ) { _globals . addElement ( param ) ; return _globals . size ( ) - 1 ; } public int addVariable ( Variable global ) { _globals . addElement ( global ) ; return _globals . size ( ) - 1 ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Stylesheet" ) ; displayContents ( indent + IndentIncrement ) ; } public String getNamespace ( String prefix ) { return lookupNamespace ( prefix ) ; } public String getClassName ( ) { return _className ; } public Vector getTemplates ( ) { return _templates ; } } 	1	['55', '2', '0', '65', '186', '1287', '27', '50', '44', '0.948888889', '1928', '0.92', '6', '0.5', '0.101604278', '2', '6', '33.6', '9', '2.1273', '4']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncNumber extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( getArg0AsNumber ( xctxt ) ) ; } } 	1	['2', '5', '0', '4', '5', '1', '0', '4', '2', '2', '12', '0', '0', '0.982142857', '0.75', '2', '7', '5', '1', '0.5', '1']
package org . apache . xpath . patterns ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public class UnionPattern extends Expression { private StepPattern [ ] m_patterns ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { for ( int i = 0 ; i < m_patterns . length ; i ++ ) { m_patterns [ i ] . fixupVariables ( vars , globalsSize ) ; } } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_patterns ) { int n = m_patterns . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( m_patterns [ i ] . canTraverseOutsideSubtree ( ) ) return true ; } } return false ; } public void setPatterns ( StepPattern [ ] patterns ) { m_patterns = patterns ; if ( null != patterns ) { for ( int i = 0 ; i < patterns . length ; i ++ ) { patterns [ i ] . exprSetParent ( this ) ; } } } public StepPattern [ ] getPatterns ( ) { return m_patterns ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject bestScore = null ; int n = m_patterns . length ; for ( int i = 0 ; i < n ; i ++ ) { XObject score = m_patterns [ i ] . execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) { if ( null == bestScore ) bestScore = score ; else if ( score . num ( ) > bestScore . num ( ) ) bestScore = score ; } } if ( null == bestScore ) { bestScore = NodeTest . SCORE_NONE ; } return bestScore ; } class UnionPathPartOwner implements ExpressionOwner { int m_index ; UnionPathPartOwner ( int index ) { m_index = index ; } public Expression getExpression ( ) { return m_patterns [ m_index ] ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( UnionPattern . this ) ; m_patterns [ m_index ] = ( StepPattern ) exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitUnionPattern ( owner , this ) ; if ( null != m_patterns ) { int n = m_patterns . length ; for ( int i = 0 ; i < n ; i ++ ) { m_patterns [ i ] . callVisitors ( new UnionPathPartOwner ( i ) , visitor ) ; } } } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; UnionPattern up = ( UnionPattern ) expr ; if ( null != m_patterns ) { int n = m_patterns . length ; if ( ( null == up . m_patterns ) || ( up . m_patterns . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_patterns [ i ] . deepEquals ( up . m_patterns [ i ] ) ) return false ; } } else if ( up . m_patterns != null ) return false ; return true ; } } 	1	['9', '2', '0', '12', '20', '0', '4', '10', '8', '0.125', '212', '1', '1', '0.789473684', '0.197530864', '1', '7', '22.44444444', '7', '2.4444', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class FilterExpr extends Expression { private Expression _primary ; private final Vector _predicates ; public FilterExpr ( Expression primary , Vector predicates ) { _primary = primary ; _predicates = predicates ; primary . setParent ( this ) ; } protected Expression getExpr ( ) { if ( _primary instanceof CastExpr ) return ( ( CastExpr ) _primary ) . getExpr ( ) ; else return _primary ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _primary . setParser ( parser ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) _predicates . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public String toString ( ) { return "filter-expr(" + _primary + ", " + _predicates + ")" ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type ptype = _primary . typeCheck ( stable ) ; if ( ptype instanceof NodeSetType == false ) { if ( ptype instanceof ReferenceType ) { _primary = new CastExpr ( _primary , Type . NodeSet ) ; } else { throw new TypeCheckError ( this ) ; } } int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Expression pred = ( Expression ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _predicates . size ( ) > 0 ) { translatePredicates ( classGen , methodGen ) ; } else { _primary . translate ( classGen , methodGen ) ; _primary . startResetIterator ( classGen , methodGen ) ; } } public void translatePredicates ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _predicates . size ( ) == 0 ) { translate ( classGen , methodGen ) ; } else { final int initCNLI = cpg . addMethodref ( CURRENT_NODE_LIST_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + "Z" + CURRENT_NODE_LIST_FILTER_SIG + NODE_SIG + TRANSLET_SIG + ")V" ) ; Predicate predicate = ( Predicate ) _predicates . lastElement ( ) ; _predicates . remove ( predicate ) ; if ( predicate . isNthPositionFilter ( ) ) { final int start = cpg . addInterfaceMethodref ( NODE_ITERATOR , "setStartNode" , "(I)" + NODE_ITERATOR_SIG ) ; final int reset = cpg . addInterfaceMethodref ( NODE_ITERATOR , "reset" , "()" + NODE_ITERATOR_SIG ) ; translatePredicates ( classGen , methodGen ) ; predicate . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( start , 2 ) ) ; il . append ( new INVOKEINTERFACE ( reset , 1 ) ) ; final int sngl = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "getSingleNode" , "(" + NODE_ITERATOR_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( sngl ) ) ; } else { il . append ( new NEW ( cpg . addClass ( CURRENT_NODE_LIST_ITERATOR ) ) ) ; il . append ( DUP ) ; translatePredicates ( classGen , methodGen ) ; il . append ( ICONST_1 ) ; predicate . translate ( classGen , methodGen ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKESPECIAL ( initCNLI ) ) ; } } } } 	1	['7', '3', '0', '21', '38', '0', '1', '21', '6', '0.083333333', '282', '1', '1', '0.922077922', '0.306122449', '2', '9', '39', '3', '1.7143', '1']
package org . apache . xalan . xsltc . runtime ; import java . text . DecimalFormat ; import java . text . FieldPosition ; import java . text . MessageFormat ; import java . text . NumberFormat ; import java . util . Locale ; import java . util . ResourceBundle ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . dom . DOMSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . dom . AbsoluteIterator ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xalan . xsltc . dom . DOMAdapter ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . MultiDOM ; import org . apache . xalan . xsltc . dom . SingletonIterator ; import org . apache . xalan . xsltc . dom . StepIterator ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import org . apache . xml . serializer . SerializationHandler ; public final class BasisLibrary implements Operators { private final static String EMPTYSTRING = "" ; public static int countF ( DTMAxisIterator iterator ) { return ( iterator . getLast ( ) ) ; } public static int positionF ( DTMAxisIterator iterator ) { return iterator . isReverse ( ) ? iterator . getLast ( ) - iterator . getPosition ( ) + 1 : iterator . getPosition ( ) ; } public static double sumF ( DTMAxisIterator iterator , DOM dom ) { try { double result = 0.0 ; int node ; while ( ( node = iterator . next ( ) ) != DTMAxisIterator . END ) { result += Double . parseDouble ( dom . getStringValueX ( node ) ) ; } return result ; } catch ( NumberFormatException e ) { return Double . NaN ; } } public static String stringF ( int node , DOM dom ) { return dom . getStringValueX ( node ) ; } public static String stringF ( Object obj , DOM dom ) { if ( obj instanceof DTMAxisIterator ) { return dom . getStringValueX ( ( ( DTMAxisIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getStringValueX ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else { return obj . toString ( ) ; } } public static String stringF ( Object obj , int node , DOM dom ) { if ( obj instanceof DTMAxisIterator ) { return dom . getStringValueX ( ( ( DTMAxisIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getStringValueX ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else if ( obj instanceof Double ) { Double d = ( Double ) obj ; final String result = d . toString ( ) ; final int length = result . length ( ) ; if ( ( result . charAt ( length - 2 ) == '.' ) && ( result . charAt ( length - 1 ) == '0' ) ) return result . substring ( 0 , length - 2 ) ; else return result ; } else { if ( obj != null ) return obj . toString ( ) ; else return stringF ( node , dom ) ; } } public static double numberF ( int node , DOM dom ) { return stringToReal ( dom . getStringValueX ( node ) ) ; } public static double numberF ( Object obj , DOM dom ) { if ( obj instanceof Double ) { return ( ( Double ) obj ) . doubleValue ( ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . doubleValue ( ) ; } else if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ? 1.0 : 0.0 ; } else if ( obj instanceof String ) { return stringToReal ( ( String ) obj ) ; } else if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; return stringToReal ( dom . getStringValueX ( iter . reset ( ) . next ( ) ) ) ; } else if ( obj instanceof Node ) { return stringToReal ( dom . getStringValueX ( ( ( Node ) obj ) . node ) ) ; } else if ( obj instanceof DOM ) { return stringToReal ( ( ( DOM ) obj ) . getStringValue ( ) ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "number()" ) ; return 0.0 ; } } public static boolean booleanF ( Object obj ) { if ( obj instanceof Double ) { final double temp = ( ( Double ) obj ) . doubleValue ( ) ; return temp != 0.0 && ! Double . isNaN ( temp ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . doubleValue ( ) != 0 ; } else if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ; } else if ( obj instanceof String ) { return ! ( ( String ) obj ) . equals ( EMPTYSTRING ) ; } else if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; return iter . reset ( ) . next ( ) != DTMAxisIterator . END ; } else if ( obj instanceof Node ) { return true ; } else if ( obj instanceof DOM ) { String temp = ( ( DOM ) obj ) . getStringValue ( ) ; return ! temp . equals ( EMPTYSTRING ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "number()" ) ; } return false ; } public static String substringF ( String value , double start ) { try { final int strlen = value . length ( ) ; int istart = ( int ) Math . round ( start ) - 1 ; if ( Double . isNaN ( start ) ) return ( EMPTYSTRING ) ; if ( istart > strlen ) return ( EMPTYSTRING ) ; if ( istart < 1 ) istart = 0 ; return value . substring ( istart ) ; } catch ( IndexOutOfBoundsException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , "substring()" ) ; return null ; } } public static String substringF ( String value , double start , double length ) { try { final int strlen = value . length ( ) ; int istart = ( int ) Math . round ( start ) - 1 ; int isum = istart + ( int ) Math . round ( length ) ; if ( Double . isInfinite ( length ) ) isum = Integer . MAX_VALUE ; if ( Double . isNaN ( start ) || Double . isNaN ( length ) ) return ( EMPTYSTRING ) ; if ( Double . isInfinite ( start ) ) return ( EMPTYSTRING ) ; if ( istart > strlen ) return ( EMPTYSTRING ) ; if ( isum < 0 ) return ( EMPTYSTRING ) ; if ( istart < 0 ) istart = 0 ; if ( isum > strlen ) return value . substring ( istart ) ; else return value . substring ( istart , isum ) ; } catch ( IndexOutOfBoundsException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , "substring()" ) ; return null ; } } public static String substring_afterF ( String value , String substring ) { final int index = value . indexOf ( substring ) ; if ( index >= 0 ) return value . substring ( index + substring . length ( ) ) ; else return EMPTYSTRING ; } public static String substring_beforeF ( String value , String substring ) { final int index = value . indexOf ( substring ) ; if ( index >= 0 ) return value . substring ( 0 , index ) ; else return EMPTYSTRING ; } public static String translateF ( String value , String from , String to ) { final int tol = to . length ( ) ; final int froml = from . length ( ) ; final int valuel = value . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int j , i = 0 ; i < valuel ; i ++ ) { final char ch = value . charAt ( i ) ; for ( j = 0 ; j < froml ; j ++ ) { if ( ch == from . charAt ( j ) ) { if ( j < tol ) result . append ( to . charAt ( j ) ) ; break ; } } if ( j == froml ) result . append ( ch ) ; } return result . toString ( ) ; } public static String normalize_spaceF ( int node , DOM dom ) { return normalize_spaceF ( dom . getStringValueX ( node ) ) ; } public static String normalize_spaceF ( String value ) { int i = 0 , n = value . length ( ) ; StringBuffer result = new StringBuffer ( ) ; while ( i < n && isWhiteSpace ( value . charAt ( i ) ) ) i ++ ; while ( true ) { while ( i < n && ! isWhiteSpace ( value . charAt ( i ) ) ) { result . append ( value . charAt ( i ++ ) ) ; } if ( i == n ) break ; while ( i < n && isWhiteSpace ( value . charAt ( i ) ) ) { i ++ ; } if ( i < n ) result . append ( ' ' ) ; } return result . toString ( ) ; } public static String generate_idF ( int node ) { if ( node > 0 ) return "N" + node ; else return EMPTYSTRING ; } public static String getLocalName ( String value ) { int idx = value . lastIndexOf ( ':' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; idx = value . lastIndexOf ( '@' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; return ( value ) ; } public static void unresolved_externalF ( String name ) { runTimeError ( EXTERNAL_FUNC_ERR , name ) ; } public static String namespace_uriF ( DTMAxisIterator iter , DOM dom ) { return namespace_uriF ( iter . next ( ) , dom ) ; } public static String system_propertyF ( String name ) { if ( name . equals ( "xsl:version" ) ) return ( "1.0" ) ; if ( name . equals ( "xsl:vendor" ) ) return ( "Apache Software Foundation (Xalan XSLTC)" ) ; if ( name . equals ( "xsl:vendor-url" ) ) return ( "http://xml.apache.org/xalan-j" ) ; runTimeError ( INVALID_ARGUMENT_ERR , name , "system-property()" ) ; return ( EMPTYSTRING ) ; } public static String namespace_uriF ( int node , DOM dom ) { final String value = dom . getNodeName ( node ) ; final int colon = value . lastIndexOf ( ':' ) ; if ( colon >= 0 ) return value . substring ( 0 , colon ) ; else return EMPTYSTRING ; } public static String objectTypeF ( Object obj ) { if ( obj instanceof String ) return "string" ; else if ( obj instanceof Boolean ) return "boolean" ; else if ( obj instanceof Number ) return "number" ; else if ( obj instanceof DOM ) return "RTF" ; else if ( obj instanceof DTMAxisIterator ) return "node-set" ; else return "unknown" ; } public static DTMAxisIterator nodesetF ( Object obj ) { if ( obj instanceof DOM ) { final DOM dom = ( DOM ) obj ; return new SingletonIterator ( dom . getDocument ( ) , true ) ; } else if ( obj instanceof DTMAxisIterator ) { return ( DTMAxisIterator ) obj ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "node-set" , className ) ; return null ; } } private static boolean isWhiteSpace ( char ch ) { return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' ; } private static boolean compareStrings ( String lstring , String rstring , int op , DOM dom ) { switch ( op ) { case EQ : return lstring . equals ( rstring ) ; case NE : return ! lstring . equals ( rstring ) ; case GT : return numberF ( lstring , dom ) > numberF ( rstring , dom ) ; case LT : return numberF ( lstring , dom ) < numberF ( rstring , dom ) ; case GE : return numberF ( lstring , dom ) >= numberF ( rstring , dom ) ; case LE : return numberF ( lstring , dom ) <= numberF ( rstring , dom ) ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; return false ; } } public static boolean compare ( DTMAxisIterator left , DTMAxisIterator right , int op , DOM dom ) { int lnode ; left . reset ( ) ; while ( ( lnode = left . next ( ) ) != DTMAxisIterator . END ) { final String lvalue = dom . getStringValueX ( lnode ) ; int rnode ; right . reset ( ) ; while ( ( rnode = right . next ( ) ) != DTMAxisIterator . END ) { if ( lnode == rnode ) { if ( op == EQ ) { return true ; } else if ( op == NE ) { continue ; } } if ( compareStrings ( lvalue , dom . getStringValueX ( rnode ) , op , dom ) ) { return true ; } } } return false ; } public static boolean compare ( int node , DTMAxisIterator iterator , int op , DOM dom ) { int rnode ; String value ; switch ( op ) { case EQ : rnode = iterator . next ( ) ; if ( rnode != DTMAxisIterator . END ) { value = dom . getStringValueX ( node ) ; do { if ( node == rnode || value . equals ( dom . getStringValueX ( rnode ) ) ) { return true ; } } while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) ; } break ; case NE : rnode = iterator . next ( ) ; if ( rnode != DTMAxisIterator . END ) { value = dom . getStringValueX ( node ) ; do { if ( node != rnode && ! value . equals ( dom . getStringValueX ( rnode ) ) ) { return true ; } } while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) ; } break ; case LT : while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) { if ( rnode > node ) return true ; } break ; case GT : while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) { if ( rnode < node ) return true ; } break ; } return ( false ) ; } public static boolean compare ( DTMAxisIterator left , final double rnumber , final int op , DOM dom ) { int node ; switch ( op ) { case EQ : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) == rnumber ) return true ; } break ; case NE : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) != rnumber ) return true ; } break ; case GT : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) > rnumber ) return true ; } break ; case LT : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) < rnumber ) return true ; } break ; case GE : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) >= rnumber ) return true ; } break ; case LE : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) <= rnumber ) return true ; } break ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; } return false ; } public static boolean compare ( DTMAxisIterator left , final String rstring , int op , DOM dom ) { int node ; while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( compareStrings ( dom . getStringValueX ( node ) , rstring , op , dom ) ) { return true ; } } return false ; } public static boolean compare ( Object left , Object right , int op , DOM dom ) { boolean result = false ; boolean hasSimpleArgs = hasSimpleType ( left ) && hasSimpleType ( right ) ; if ( op != EQ && op != NE ) { if ( left instanceof Node || right instanceof Node ) { if ( left instanceof Boolean ) { right = new Boolean ( booleanF ( right ) ) ; hasSimpleArgs = true ; } if ( right instanceof Boolean ) { left = new Boolean ( booleanF ( left ) ) ; hasSimpleArgs = true ; } } if ( hasSimpleArgs ) { switch ( op ) { case GT : return numberF ( left , dom ) > numberF ( right , dom ) ; case LT : return numberF ( left , dom ) < numberF ( right , dom ) ; case GE : return numberF ( left , dom ) >= numberF ( right , dom ) ; case LE : return numberF ( left , dom ) <= numberF ( right , dom ) ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; } } } if ( hasSimpleArgs ) { if ( left instanceof Boolean || right instanceof Boolean ) { result = booleanF ( left ) == booleanF ( right ) ; } else if ( left instanceof Double || right instanceof Double || left instanceof Integer || right instanceof Integer ) { result = numberF ( left , dom ) == numberF ( right , dom ) ; } else { result = stringF ( left , dom ) . equals ( stringF ( right , dom ) ) ; } if ( op == Operators . NE ) { result = ! result ; } } else { if ( left instanceof Node ) { left = new SingletonIterator ( ( ( Node ) left ) . node ) ; } if ( right instanceof Node ) { right = new SingletonIterator ( ( ( Node ) right ) . node ) ; } if ( hasSimpleType ( left ) || left instanceof DOM && right instanceof DTMAxisIterator ) { final Object temp = right ; right = left ; left = temp ; } if ( left instanceof DOM ) { if ( right instanceof Boolean ) { result = ( ( Boolean ) right ) . booleanValue ( ) ; return result == ( op == Operators . EQ ) ; } final String sleft = ( ( DOM ) left ) . getStringValue ( ) ; if ( right instanceof Number ) { result = ( ( Number ) right ) . doubleValue ( ) == stringToReal ( sleft ) ; } else if ( right instanceof String ) { result = sleft . equals ( ( String ) right ) ; } else if ( right instanceof DOM ) { result = sleft . equals ( ( ( DOM ) right ) . getStringValue ( ) ) ; } if ( op == Operators . NE ) { result = ! result ; } return result ; } DTMAxisIterator iter = ( ( DTMAxisIterator ) left ) . reset ( ) ; if ( right instanceof DTMAxisIterator ) { result = compare ( iter , ( DTMAxisIterator ) right , op , dom ) ; } else if ( right instanceof String ) { result = compare ( iter , ( String ) right , op , dom ) ; } else if ( right instanceof Number ) { final double temp = ( ( Number ) right ) . doubleValue ( ) ; result = compare ( iter , temp , op , dom ) ; } else if ( right instanceof Boolean ) { boolean temp = ( ( Boolean ) right ) . booleanValue ( ) ; result = ( iter . reset ( ) . next ( ) != DTMAxisIterator . END ) == temp ; } else if ( right instanceof DOM ) { result = compare ( iter , ( ( DOM ) right ) . getStringValue ( ) , op , dom ) ; } else if ( right == null ) { return ( false ) ; } else { final String className = right . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "compare()" ) ; } } return result ; } public static boolean testLanguage ( String testLang , DOM dom , int node ) { String nodeLang = dom . getLanguage ( node ) ; if ( nodeLang == null ) return ( false ) ; else nodeLang = nodeLang . toLowerCase ( ) ; testLang = testLang . toLowerCase ( ) ; if ( testLang . length ( ) == 2 ) { return ( nodeLang . startsWith ( testLang ) ) ; } else { return ( nodeLang . equals ( testLang ) ) ; } } private static boolean hasSimpleType ( Object obj ) { return obj instanceof Boolean || obj instanceof Double || obj instanceof Integer || obj instanceof String || obj instanceof Node || obj instanceof DOM ; } public static double stringToReal ( String s ) { try { return Double . valueOf ( s ) . doubleValue ( ) ; } catch ( NumberFormatException e ) { return Double . NaN ; } } public static int stringToInt ( String s ) { try { return Integer . parseInt ( s ) ; } catch ( NumberFormatException e ) { return ( - 1 ) ; } } private static double lowerBounds = 0.001 ; private static double upperBounds = 10000000 ; private static DecimalFormat defaultFormatter ; private static String defaultPattern = "" ; static { NumberFormat f = NumberFormat . getInstance ( Locale . getDefault ( ) ) ; f . setMaximumFractionDigits ( Integer . MAX_VALUE ) ; defaultFormatter = ( f instanceof DecimalFormat ) ? ( DecimalFormat ) f : new DecimalFormat ( ) ; defaultFormatter . setGroupingUsed ( false ) ; } public static String realToString ( double d ) { final double m = Math . abs ( d ) ; if ( ( m >= lowerBounds ) && ( m < upperBounds ) ) { final String result = Double . toString ( d ) ; final int length = result . length ( ) ; if ( ( result . charAt ( length - 2 ) == '.' ) && ( result . charAt ( length - 1 ) == '0' ) ) return result . substring ( 0 , length - 2 ) ; else return result ; } else { if ( Double . isNaN ( d ) || Double . isInfinite ( d ) ) return ( Double . toString ( d ) ) ; return formatNumber ( d , defaultPattern , defaultFormatter ) ; } } public static int realToInt ( double d ) { return ( int ) d ; } private static FieldPosition _fieldPosition = new FieldPosition ( 0 ) ; public static String formatNumber ( double number , String pattern , DecimalFormat formatter ) { if ( formatter == null ) { formatter = defaultFormatter ; } try { StringBuffer result = new StringBuffer ( ) ; if ( pattern != defaultPattern ) { formatter . applyLocalizedPattern ( pattern ) ; } String localizedPattern = formatter . toPattern ( ) ; int index = localizedPattern . indexOf ( '.' ) ; if ( index >= 1 && localizedPattern . charAt ( index - 1 ) == '#' ) { StringBuffer newpattern = new StringBuffer ( ) ; newpattern . append ( localizedPattern . substring ( 0 , index - 1 ) ) ; newpattern . append ( "0" ) ; newpattern . append ( localizedPattern . substring ( index ) ) ; formatter . applyLocalizedPattern ( newpattern . toString ( ) ) ; } else if ( index == 0 ) { StringBuffer newpattern = new StringBuffer ( ) ; newpattern . append ( "0" ) ; newpattern . append ( localizedPattern ) ; formatter . applyLocalizedPattern ( newpattern . toString ( ) ) ; } formatter . format ( number , result , _fieldPosition ) ; return ( result . toString ( ) ) ; } catch ( IllegalArgumentException e ) { runTimeError ( FORMAT_NUMBER_ERR , Double . toString ( number ) , pattern ) ; return ( EMPTYSTRING ) ; } } public static DTMAxisIterator referenceToNodeSet ( Object obj ) { if ( obj instanceof Node ) { return ( new SingletonIterator ( ( ( Node ) obj ) . node ) ) ; } else if ( obj instanceof DTMAxisIterator ) { return ( ( ( DTMAxisIterator ) obj ) . cloneIterator ( ) ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static NodeList referenceToNodeList ( Object obj , DOM dom ) { if ( obj instanceof Node || obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = referenceToNodeSet ( obj ) ; return dom . makeNodeList ( iter ) ; } else if ( obj instanceof DOM ) { dom = ( DOM ) obj ; return dom . makeNodeList ( DTMDefaultBase . ROOTNODE ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static org . w3c . dom . Node referenceToNode ( Object obj , DOM dom ) { if ( obj instanceof Node || obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = referenceToNodeSet ( obj ) ; return dom . makeNode ( iter ) ; } else if ( obj instanceof DOM ) { dom = ( DOM ) obj ; DTMAxisIterator iter = dom . getChildren ( DTMDefaultBase . ROOTNODE ) ; return dom . makeNode ( iter ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static DTMAxisIterator node2Iterator ( org . w3c . dom . Node node , Translet translet , DOM dom ) { final org . w3c . dom . Node inNode = node ; org . w3c . dom . NodeList nodelist = new org . w3c . dom . NodeList ( ) { public int getLength ( ) { return 1 ; } public org . w3c . dom . Node item ( int index ) { if ( index == 0 ) return inNode ; else return null ; } } ; return nodeList2Iterator ( nodelist , translet , dom ) ; } private static void copyNodes ( org . w3c . dom . NodeList nodeList , org . w3c . dom . Document doc , org . w3c . dom . Node parent ) { final int size = nodeList . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { org . w3c . dom . Node curr = nodeList . item ( i ) ; int nodeType = curr . getNodeType ( ) ; String value = null ; try { value = curr . getNodeValue ( ) ; } catch ( DOMException ex ) { runTimeError ( RUN_TIME_INTERNAL_ERR , ex . getMessage ( ) ) ; return ; } String nodeName = curr . getNodeName ( ) ; org . w3c . dom . Node newNode = null ; switch ( nodeType ) { case org . w3c . dom . Node . ATTRIBUTE_NODE : newNode = doc . createAttributeNS ( curr . getNamespaceURI ( ) , nodeName ) ; break ; case org . w3c . dom . Node . CDATA_SECTION_NODE : newNode = doc . createCDATASection ( value ) ; break ; case org . w3c . dom . Node . COMMENT_NODE : newNode = doc . createComment ( value ) ; break ; case org . w3c . dom . Node . DOCUMENT_FRAGMENT_NODE : newNode = doc . createDocumentFragment ( ) ; break ; case org . w3c . dom . Node . DOCUMENT_NODE : newNode = doc . createElementNS ( null , "__document__" ) ; copyNodes ( curr . getChildNodes ( ) , doc , newNode ) ; break ; case org . w3c . dom . Node . DOCUMENT_TYPE_NODE : break ; case org . w3c . dom . Node . ELEMENT_NODE : org . w3c . dom . Element element = doc . createElementNS ( curr . getNamespaceURI ( ) , nodeName ) ; if ( curr . hasAttributes ( ) ) { org . w3c . dom . NamedNodeMap attributes = curr . getAttributes ( ) ; for ( int k = 0 ; k < attributes . getLength ( ) ; k ++ ) { org . w3c . dom . Node attr = attributes . item ( k ) ; element . setAttribute ( attr . getNodeName ( ) , attr . getNodeValue ( ) ) ; } } copyNodes ( curr . getChildNodes ( ) , doc , element ) ; newNode = element ; break ; case org . w3c . dom . Node . ENTITY_NODE : break ; case org . w3c . dom . Node . ENTITY_REFERENCE_NODE : newNode = doc . createEntityReference ( nodeName ) ; break ; case org . w3c . dom . Node . NOTATION_NODE : break ; case org . w3c . dom . Node . PROCESSING_INSTRUCTION_NODE : newNode = doc . createProcessingInstruction ( nodeName , value ) ; break ; case org . w3c . dom . Node . TEXT_NODE : newNode = doc . createTextNode ( value ) ; break ; } try { parent . appendChild ( newNode ) ; } catch ( DOMException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return ; } } } public static DTMAxisIterator nodeList2Iterator ( org . w3c . dom . NodeList nodeList , Translet translet , DOM dom ) { DocumentBuilderFactory dfac = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docbldr = null ; try { docbldr = dfac . newDocumentBuilder ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return null ; } Document doc = docbldr . newDocument ( ) ; org . w3c . dom . Node topElementNode = doc . appendChild ( doc . createElementNS ( "" , "__top__" ) ) ; copyNodes ( nodeList , doc , topElementNode ) ; if ( dom instanceof MultiDOM ) { final MultiDOM multiDOM = ( MultiDOM ) dom ; DTMDefaultBase dtm = ( DTMDefaultBase ) ( ( DOMAdapter ) multiDOM . getMain ( ) ) . getDOMImpl ( ) ; DTMManager dtmManager = dtm . getManager ( ) ; SAXImpl idom = ( SAXImpl ) dtmManager . getDTM ( new DOMSource ( doc ) , false , null , true , false ) ; DOMAdapter domAdapter = new DOMAdapter ( idom , translet . getNamesArray ( ) , translet . getNamespaceArray ( ) ) ; multiDOM . addDOMAdapter ( domAdapter ) ; DTMAxisIterator iter1 = idom . getAxisIterator ( Axis . CHILD ) ; DTMAxisIterator iter2 = idom . getAxisIterator ( Axis . CHILD ) ; DTMAxisIterator iter = new AbsoluteIterator ( new StepIterator ( iter1 , iter2 ) ) ; iter . setStartNode ( DTMDefaultBase . ROOTNODE ) ; return iter ; } else { runTimeError ( RUN_TIME_INTERNAL_ERR , "nodeList2Iterator()" ) ; return null ; } } public static DOM referenceToResultTree ( Object obj ) { try { return ( ( DOM ) obj ) ; } catch ( IllegalArgumentException e ) { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static DTMAxisIterator getSingleNode ( DTMAxisIterator iterator ) { int node = iterator . next ( ) ; return ( new SingletonIterator ( node ) ) ; } private static char [ ] _characterArray = new char [ 32 ] ; public static void copy ( Object obj , SerializationHandler handler , int node , DOM dom ) { try { if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; dom . copy ( iter . reset ( ) , handler ) ; } else if ( obj instanceof Node ) { dom . copy ( ( ( Node ) obj ) . node , handler ) ; } else if ( obj instanceof DOM ) { DOM newDom = ( DOM ) obj ; newDom . copy ( newDom . getDocument ( ) , handler ) ; } else { String string = obj . toString ( ) ; final int length = string . length ( ) ; if ( length > _characterArray . length ) _characterArray = new char [ length ] ; string . getChars ( 0 , length , _characterArray , 0 ) ; handler . characters ( _characterArray , 0 , length ) ; } } catch ( SAXException e ) { runTimeError ( RUN_TIME_COPY_ERR ) ; } } public static String startXslElement ( String qname , String namespace , SerializationHandler handler , DOM dom , int node ) { try { String prefix ; final int index = qname . indexOf ( ':' ) ; if ( index > 0 ) { prefix = qname . substring ( 0 , index ) ; if ( namespace == null || namespace . length ( ) == 0 ) { namespace = dom . lookupNamespace ( node , prefix ) ; } handler . startElement ( namespace , qname . substring ( index + 1 ) , qname ) ; handler . namespaceAfterStartElement ( prefix , namespace ) ; } else { if ( namespace != null && namespace . length ( ) > 0 ) { prefix = generatePrefix ( ) ; qname = prefix + ':' + qname ; handler . startElement ( namespace , qname , qname ) ; handler . namespaceAfterStartElement ( prefix , namespace ) ; } else { handler . startElement ( null , null , qname ) ; } } } catch ( SAXException e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } return qname ; } public static String getPrefix ( String qname ) { final int index = qname . indexOf ( ':' ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : null ; } private static int prefixIndex = 0 ; public static String generatePrefix ( ) { return ( "ns" + prefixIndex ++ ) ; } public static final String RUN_TIME_INTERNAL_ERR = "RUN_TIME_INTERNAL_ERR" ; public static final String RUN_TIME_COPY_ERR = "RUN_TIME_COPY_ERR" ; public static final String DATA_CONVERSION_ERR = "DATA_CONVERSION_ERR" ; public static final String EXTERNAL_FUNC_ERR = "EXTERNAL_FUNC_ERR" ; public static final String EQUALITY_EXPR_ERR = "EQUALITY_EXPR_ERR" ; public static final String INVALID_ARGUMENT_ERR = "INVALID_ARGUMENT_ERR" ; public static final String FORMAT_NUMBER_ERR = "FORMAT_NUMBER_ERR" ; public static final String ITERATOR_CLONE_ERR = "ITERATOR_CLONE_ERR" ; public static final String AXIS_SUPPORT_ERR = "AXIS_SUPPORT_ERR" ; public static final String TYPED_AXIS_SUPPORT_ERR = "TYPED_AXIS_SUPPORT_ERR" ; public static final String STRAY_ATTRIBUTE_ERR = "STRAY_ATTRIBUTE_ERR" ; public static final String STRAY_NAMESPACE_ERR = "STRAY_NAMESPACE_ERR" ; public static final String NAMESPACE_PREFIX_ERR = "NAMESPACE_PREFIX_ERR" ; public static final String DOM_ADAPTER_INIT_ERR = "DOM_ADAPTER_INIT_ERR" ; public static final String PARSER_DTD_SUPPORT_ERR = "PARSER_DTD_SUPPORT_ERR" ; public static final String NAMESPACES_SUPPORT_ERR = "NAMESPACES_SUPPORT_ERR" ; public static final String CANT_RESOLVE_RELATIVE_URI_ERR = "CANT_RESOLVE_RELATIVE_URI_ERR" ; protected static ResourceBundle m_bundle ; public final static String ERROR_MESSAGES_KEY = "error-messages" ; static { String resource = "org.apache.xalan.xsltc.runtime.ErrorMessages" ; m_bundle = ResourceBundle . getBundle ( resource ) ; } public static void runTimeError ( String code ) { throw new RuntimeException ( m_bundle . getString ( code ) ) ; } public static void runTimeError ( String code , Object [ ] args ) { final String message = MessageFormat . format ( m_bundle . getString ( code ) , args ) ; throw new RuntimeException ( message ) ; } public static void runTimeError ( String code , Object arg0 ) { runTimeError ( code , new Object [ ] { arg0 } ) ; } public static void runTimeError ( String code , Object arg0 , Object arg1 ) { runTimeError ( code , new Object [ ] { arg0 , arg1 } ) ; } public static void consoleOutput ( String msg ) { System . out . println ( msg ) ; } public static String replace ( String base , char ch , String str ) { return ( base . indexOf ( ch ) < 0 ) ? base : replace ( base , String . valueOf ( ch ) , new String [ ] { str } ) ; } public static String replace ( String base , String delim , String [ ] str ) { final int len = base . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i ++ ) { final char ch = base . charAt ( i ) ; final int k = delim . indexOf ( ch ) ; if ( k >= 0 ) { result . append ( str [ k ] ) ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } } 	1	['59', '1', '0', '31', '173', '1695', '17', '17', '54', '1.001915709', '2363', '0.333333333', '0', '0', '0.114224138', '0', '0', '38.59322034', '49', '4.4915', '6']
package org . apache . xml . utils ; import java . util . Stack ; import java . util . StringTokenizer ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Element ; public class QName implements java . io . Serializable { protected String _localName ; protected String _namespaceURI ; protected String _prefix ; public static final String S_XMLNAMESPACEURI = "http://www.w3.org/XML/1998/namespace" ; private int m_hashCode ; public QName ( ) { } public QName ( String namespaceURI , String localName ) { this ( namespaceURI , localName , false ) ; } public QName ( String namespaceURI , String localName , boolean validate ) { if ( localName == null ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_NULL , null ) ) ; if ( validate ) { if ( ! XMLChar . isValidNCName ( localName ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } _namespaceURI = namespaceURI ; _localName = localName ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String namespaceURI , String prefix , String localName ) { this ( namespaceURI , prefix , localName , false ) ; } public QName ( String namespaceURI , String prefix , String localName , boolean validate ) { if ( localName == null ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_NULL , null ) ) ; if ( validate ) { if ( ! XMLChar . isValidNCName ( localName ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } if ( ( null != prefix ) && ( ! XMLChar . isValidNCName ( prefix ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_PREFIX_INVALID , null ) ) ; } } _namespaceURI = namespaceURI ; _prefix = prefix ; _localName = localName ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String localName ) { this ( localName , false ) ; } public QName ( String localName , boolean validate ) { if ( localName == null ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_NULL , null ) ) ; if ( validate ) { if ( ! XMLChar . isValidNCName ( localName ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } _namespaceURI = null ; _localName = localName ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String qname , Stack namespaces ) { this ( qname , namespaces , false ) ; } public QName ( String qname , Stack namespaces , boolean validate ) { String namespace = null ; String prefix = null ; int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { prefix = qname . substring ( 0 , indexOfNSSep ) ; if ( prefix . equals ( "xml" ) ) { namespace = S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { return ; } else { int depth = namespaces . size ( ) ; for ( int i = depth - 1 ; i >= 0 ; i -- ) { NameSpace ns = ( NameSpace ) namespaces . elementAt ( i ) ; while ( null != ns ) { if ( ( null != ns . m_prefix ) && prefix . equals ( ns . m_prefix ) ) { namespace = ns . m_uri ; i = - 1 ; break ; } ns = ns . m_next ; } } } if ( null == namespace ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PREFIX_MUST_RESOLVE , new Object [ ] { prefix } ) ) ; } } _localName = ( indexOfNSSep < 0 ) ? qname : qname . substring ( indexOfNSSep + 1 ) ; if ( validate ) { if ( ( _localName == null ) || ( ! XMLChar . isValidNCName ( _localName ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } _namespaceURI = namespace ; _prefix = prefix ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String qname , Element namespaceContext , PrefixResolver resolver ) { this ( qname , namespaceContext , resolver , false ) ; } public QName ( String qname , Element namespaceContext , PrefixResolver resolver , boolean validate ) { _namespaceURI = null ; int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { if ( null != namespaceContext ) { String prefix = qname . substring ( 0 , indexOfNSSep ) ; _prefix = prefix ; if ( prefix . equals ( "xml" ) ) { _namespaceURI = S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { return ; } else { _namespaceURI = resolver . getNamespaceForPrefix ( prefix , namespaceContext ) ; } if ( null == _namespaceURI ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PREFIX_MUST_RESOLVE , new Object [ ] { prefix } ) ) ; } } else { } } _localName = ( indexOfNSSep < 0 ) ? qname : qname . substring ( indexOfNSSep + 1 ) ; if ( validate ) { if ( ( _localName == null ) || ( ! XMLChar . isValidNCName ( _localName ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String qname , PrefixResolver resolver ) { this ( qname , resolver , false ) ; } public QName ( String qname , PrefixResolver resolver , boolean validate ) { String prefix = null ; _namespaceURI = null ; int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { prefix = qname . substring ( 0 , indexOfNSSep ) ; if ( prefix . equals ( "xml" ) ) { _namespaceURI = S_XMLNAMESPACEURI ; } else { _namespaceURI = resolver . getNamespaceForPrefix ( prefix ) ; } if ( null == _namespaceURI ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PREFIX_MUST_RESOLVE , new Object [ ] { prefix } ) ) ; } } _localName = ( indexOfNSSep < 0 ) ? qname : qname . substring ( indexOfNSSep + 1 ) ; if ( validate ) { if ( ( _localName == null ) || ( ! XMLChar . isValidNCName ( _localName ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } m_hashCode = toString ( ) . hashCode ( ) ; _prefix = prefix ; } public String getNamespaceURI ( ) { return _namespaceURI ; } public String getPrefix ( ) { return _prefix ; } public String getLocalName ( ) { return _localName ; } public String toString ( ) { return _prefix != null ? ( _prefix + ":" + _localName ) : ( _namespaceURI != null ? ( "{" + _namespaceURI + "}" + _localName ) : _localName ) ; } public String toNamespacedString ( ) { return ( _namespaceURI != null ? ( "{" + _namespaceURI + "}" + _localName ) : _localName ) ; } public String getNamespace ( ) { return getNamespaceURI ( ) ; } public String getLocalPart ( ) { return getLocalName ( ) ; } public int hashCode ( ) { return m_hashCode ; } public boolean equals ( String ns , String localPart ) { String thisnamespace = getNamespaceURI ( ) ; return getLocalName ( ) . equals ( localPart ) && ( ( ( null != thisnamespace ) && ( null != ns ) ) ? thisnamespace . equals ( ns ) : ( ( null == thisnamespace ) && ( null == ns ) ) ) ; } public boolean equals ( Object object ) { if ( object == this ) return true ; if ( object instanceof QName ) { QName qname = ( QName ) object ; String thisnamespace = getNamespaceURI ( ) ; String thatnamespace = qname . getNamespaceURI ( ) ; return getLocalName ( ) . equals ( qname . getLocalName ( ) ) && ( ( ( null != thisnamespace ) && ( null != thatnamespace ) ) ? thisnamespace . equals ( thatnamespace ) : ( ( null == thisnamespace ) && ( null == thatnamespace ) ) ) ; } else return false ; } public static QName getQNameFromString ( String name ) { StringTokenizer tokenizer = new StringTokenizer ( name , "{}" , false ) ; QName qname ; String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == s2 ) qname = new QName ( null , s1 ) ; else qname = new QName ( s1 , s2 ) ; return qname ; } public static boolean isXMLNSDecl ( String attRawName ) { return ( attRawName . startsWith ( "xmlns" ) && ( attRawName . equals ( "xmlns" ) || attRawName . startsWith ( "xmlns:" ) ) ) ; } public static String getPrefixFromXMLNSDecl ( String attRawName ) { int index = attRawName . indexOf ( ':' ) ; return ( index >= 0 ) ? attRawName . substring ( index + 1 ) : "" ; } public static String getLocalPart ( String qname ) { int index = qname . indexOf ( ':' ) ; return ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } public static String getPrefixPart ( String qname ) { int index = qname . indexOf ( ':' ) ; return ( index >= 0 ) ? qname . substring ( 0 , index ) : "" ; } } 	1	['28', '1', '0', '53', '49', '268', '49', '4', '28', '0.562962963', '732', '0.8', '0', '0', '0.285714286', '1', '1', '24.96428571', '9', '1.4286', '2']
package org . apache . xml . serializer ; import java . util . Hashtable ; import java . util . Properties ; import javax . xml . transform . OutputKeys ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . ContentHandler ; public abstract class SerializerFactory { private static Hashtable m_formats = new Hashtable ( ) ; public static Serializer getSerializer ( Properties format ) { Serializer ser = null ; try { Class cls ; String method = format . getProperty ( OutputKeys . METHOD ) ; if ( method == null ) throw new IllegalArgumentException ( "The output format has a null method name" ) ; String className ; className = format . getProperty ( OutputPropertiesFactory . S_KEY_CONTENT_HANDLER ) ; if ( null == className ) { throw new IllegalArgumentException ( "The output format must have a '" + OutputPropertiesFactory . S_KEY_CONTENT_HANDLER + "' property!" ) ; } cls = Class . forName ( className ) ; Object obj = cls . newInstance ( ) ; if ( obj instanceof SerializationHandler ) { ser = ( Serializer ) cls . newInstance ( ) ; ser . setOutputFormat ( format ) ; } else { if ( obj instanceof ContentHandler ) { className = SerializerConstants . DEFAULT_SAX_SERIALIZER ; cls = Class . forName ( className ) ; SerializationHandler sh = ( SerializationHandler ) cls . newInstance ( ) ; sh . setContentHandler ( ( ContentHandler ) obj ) ; sh . setOutputFormat ( format ) ; ser = sh ; } else { throw new Exception ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SERIALIZER_NOT_CONTENTHANDLER , new Object [ ] { className } ) ) ; } } } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } return ser ; } } 	1	['3', '1', '0', '10', '15', '3', '6', '4', '2', '1', '97', '1', '0', '0', '0.5', '0', '0', '31', '5', '1.6667', '1']
package org . apache . xml . utils . synthetic ; import java . io . IOException ; public class JavaUtils { private static boolean cantLoadCompiler = false ; private static boolean debug = false ; public static void setDebug ( boolean newDebug ) { debug = newDebug ; } public static boolean JDKcompile ( String fileName , String classPath ) { String moreClassPath = System . getProperty ( "org.apache.xml.utils.synthetic.moreclasspath" , "" ) . trim ( ) ; if ( moreClassPath . length ( ) > 0 ) classPath = moreClassPath + ';' + classPath ; if ( debug ) { System . err . println ( "JavaEngine: Compiling " + fileName ) ; System . err . println ( "JavaEngine: Classpath is " + classPath ) ; } String code_option = debug ? "-g" : "-O" ; if ( ! cantLoadCompiler ) { String args [ ] = { code_option , "-classpath" , classPath , fileName } ; } String javac_command = System . getProperty ( "org.apache.xml.utils.synthetic.javac" , "javac" ) ; String args [ ] = { javac_command , code_option , "-classpath" , classPath , fileName } ; try { Process p = java . lang . Runtime . getRuntime ( ) . exec ( args ) ; int compileOK = waitHardFor ( p ) ; return compileOK == 0 ; } catch ( IOException e ) { System . err . println ( "ERROR: IO exception during exec(javac)." ) ; } catch ( SecurityException e ) { System . err . println ( "ERROR: Unable to create subprocess to exec(javac)." ) ; } return false ; } static int waitHardFor ( java . lang . Process p ) { boolean done = false ; while ( ! done ) try { p . waitFor ( ) ; done = true ; } catch ( InterruptedException e ) { System . err . println ( "(Compiler process wait interrupted and resumed)" ) ; } int ev = p . exitValue ( ) ; return ev ; } } 	1	['5', '1', '0', '0', '18', '4', '0', '0', '3', '0.625', '157', '1', '0', '0', '0.25', '0', '0', '30', '6', '1.8', '1']
package org . apache . xalan ; public class Version { public static String getVersion ( ) { return getProduct ( ) + " " + getImplementationLanguage ( ) + " " + getMajorVersionNum ( ) + "." + getReleaseVersionNum ( ) + "." + ( ( getDevelopmentVersionNum ( ) > 0 ) ? ( "D" + getDevelopmentVersionNum ( ) ) : ( "" + getMaintenanceVersionNum ( ) ) ) ; } public static void main ( String argv [ ] ) { System . out . println ( getVersion ( ) ) ; } public static String getProduct ( ) { return "Xalan" ; } public static String getImplementationLanguage ( ) { return "Java" ; } public static int getMajorVersionNum ( ) { return org . apache . xalan . processor . XSLProcessorVersion . VERSION ; } public static int getReleaseVersionNum ( ) { return org . apache . xalan . processor . XSLProcessorVersion . RELEASE ; } public static int getMaintenanceVersionNum ( ) { return org . apache . xalan . processor . XSLProcessorVersion . MAINTENANCE ; } public static int getDevelopmentVersionNum ( ) { return org . apache . xalan . processor . XSLProcessorVersion . DEVELOPMENT ; } } 	1	['9', '1', '0', '1', '15', '36', '0', '1', '9', '2', '69', '0', '0', '0', '0.111111111', '0', '0', '6.666666667', '2', '1', '1']
package org . apache . xpath . objects ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; public class XMLStringFactoryImpl extends XMLStringFactory { private static XMLStringFactory m_xstringfactory = new XMLStringFactoryImpl ( ) ; public static XMLStringFactory getFactory ( ) { return m_xstringfactory ; } public XMLString newstr ( String string ) { return new XString ( string ) ; } public XMLString newstr ( FastStringBuffer fsb , int start , int length ) { return new XStringForFSB ( fsb , start , length ) ; } public XMLString newstr ( char [ ] string , int start , int length ) { return new XStringForChars ( string , start , length ) ; } public XMLString emptystr ( ) { return XString . EMPTYSTRING ; } } 	1	['7', '2', '0', '8', '11', '19', '4', '6', '6', '0.833333333', '39', '1', '1', '0.444444444', '0.333333333', '0', '0', '4.428571429', '1', '0.7143', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; public class ElemAttributeSet extends ElemUse { public QName m_qname = null ; public void setName ( QName name ) { m_qname = name ; } public QName getName ( ) { return m_qname ; } public int getXSLToken ( ) { return Constants . ELEMNAME_DEFINEATTRIBUTESET ; } public String getNodeName ( ) { return Constants . ELEMNAME_ATTRIBUTESET_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( transformer . isRecursiveAttrSet ( this ) ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_XSLATTRSET_USED_ITSELF , new Object [ ] { m_qname . getLocalPart ( ) } ) ) ; } transformer . pushElemAttributeSet ( this ) ; super . execute ( transformer ) ; ElemAttribute attr = ( ElemAttribute ) getFirstChildElem ( ) ; while ( null != attr ) { attr . execute ( transformer ) ; attr = ( ElemAttribute ) attr . getNextSiblingElem ( ) ; } transformer . popElemAttributeSet ( ) ; } public ElemTemplateElement appendChildElem ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_ATTRIBUTE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeAttributeSets ( this ) ; } } 	1	['8', '4', '0', '10', '24', '16', '6', '7', '8', '0.571428571', '97', '0', '1', '0.966507177', '0.3', '2', '4', '11', '3', '1.125', '2']
package org . apache . xml . utils ; public interface PrefixResolver { String getNamespaceForPrefix ( String prefix ) ; String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) ; public String getBaseIdentifier ( ) ; public boolean handlesNullPrefixes ( ) ; } 	1	['4', '1', '0', '69', '4', '6', '69', '0', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . transformer ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; public class CountersTable extends Hashtable { public CountersTable ( ) { } Vector getCounters ( ElemNumber numberElem ) { Vector counters = ( Vector ) this . get ( numberElem ) ; return ( null == counters ) ? putElemNumber ( numberElem ) : counters ; } Vector putElemNumber ( ElemNumber numberElem ) { Vector counters = new Vector ( ) ; this . put ( numberElem , counters ) ; return counters ; } transient private NodeSetDTM m_newFound ; void appendBtoFList ( NodeSetDTM flist , NodeSetDTM blist ) { int n = blist . size ( ) ; for ( int i = ( n - 1 ) ; i >= 0 ; i -- ) { flist . addElement ( blist . item ( i ) ) ; } } transient int m_countersMade = 0 ; public int countNode ( XPathContext support , ElemNumber numberElem , int node ) throws TransformerException { int count = 0 ; Vector counters = getCounters ( numberElem ) ; int nCounters = counters . size ( ) ; int target = numberElem . getTargetNode ( support , node ) ; if ( DTM . NULL != target ) { for ( int i = 0 ; i < nCounters ; i ++ ) { Counter counter = ( Counter ) counters . elementAt ( i ) ; count = counter . getPreviouslyCounted ( support , target ) ; if ( count > 0 ) return count ; } count = 0 ; if ( m_newFound == null ) m_newFound = new NodeSetDTM ( support . getDTMManager ( ) ) ; for ( ; DTM . NULL != target ; target = numberElem . getPreviousNode ( support , target ) ) { if ( 0 != count ) { for ( int i = 0 ; i < nCounters ; i ++ ) { Counter counter = ( Counter ) counters . elementAt ( i ) ; int cacheLen = counter . m_countNodes . size ( ) ; if ( ( cacheLen > 0 ) && ( counter . m_countNodes . elementAt ( cacheLen - 1 ) == target ) ) { count += ( cacheLen + counter . m_countNodesStartCount ) ; if ( cacheLen > 0 ) appendBtoFList ( counter . m_countNodes , m_newFound ) ; m_newFound . removeAllElements ( ) ; return count ; } } } m_newFound . addElement ( target ) ; count ++ ; } Counter counter = new Counter ( numberElem , new NodeSetDTM ( support . getDTMManager ( ) ) ) ; m_countersMade ++ ; appendBtoFList ( counter . m_countNodes , m_newFound ) ; m_newFound . removeAllElements ( ) ; counters . addElement ( counter ) ; } return count ; } } 	1	['5', '3', '0', '7', '23', '8', '3', '5', '2', '0.875', '198', '0.5', '1', '0.904761905', '0.44', '0', '0', '38.2', '2', '1.2', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class CallTemplate extends Instruction { private QName _name ; public void display ( int indent ) { indent ( indent ) ; System . out . print ( "CallTemplate" ) ; Util . println ( " name " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public boolean hasWithParams ( ) { return elementCount ( ) > 0 ; } public void parseContents ( Parser parser ) { _name = parser . getQNameIgnoreDefaultNs ( getAttribute ( "name" ) ) ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Template template = stable . lookupTemplate ( _name ) ; if ( template != null ) { typeCheckContents ( stable ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . TEMPLATE_UNDEF_ERR , _name , this ) ; throw new TypeCheckError ( err ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Stylesheet stylesheet = classGen . getStylesheet ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) { final int push = cpg . addMethodref ( TRANSLET_CLASS , PUSH_PARAM_FRAME , PUSH_PARAM_FRAME_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEVIRTUAL ( push ) ) ; translateContents ( classGen , methodGen ) ; } final String className = stylesheet . getClassName ( ) ; String methodName = Util . escape ( _name . toString ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( className , methodName , "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + NODE_SIG + ")V" ) ) ) ; if ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) { final int pop = cpg . addMethodref ( TRANSLET_CLASS , POP_PARAM_FRAME , POP_PARAM_FRAME_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEVIRTUAL ( pop ) ) ; } } } 	1	['6', '3', '0', '18', '40', '3', '1', '18', '5', '0.4', '183', '1', '1', '0.918032787', '0.305555556', '1', '6', '29.33333333', '5', '1.6667', '4']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionConstants ; public interface Constants extends InstructionConstants { public final int INTERNAL = 0 ; public final int UNSUPPORTED = 1 ; public final int FATAL = 2 ; public final int ERROR = 3 ; public final int WARNING = 4 ; public static final String EMPTYSTRING = "" ; public static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static final String TRANSLET_INTF = "org.apache.xalan.xsltc.Translet" ; public static final String TRANSLET_INTF_SIG = "Lorg/apache/xalan/xsltc/Translet;" ; public static final String ATTRIBUTES_SIG = "Lorg/apache/xalan/xsltc/runtime/Attributes;" ; public static final String NODE_ITERATOR_SIG = "Lorg/apache/xml/dtm/DTMAxisIterator;" ; public static final String DOM_INTF_SIG = "Lorg/apache/xalan/xsltc/DOM;" ; public static final String DOM_IMPL_CLASS = "org/apache/xalan/xsltc/DOM" ; public static final String SAX_IMPL_CLASS = "org/apache/xalan/xsltc/DOM/SAXImpl" ; public static final String DOM_IMPL_SIG = "Lorg/apache/xalan/xsltc/dom/SAXImpl;" ; public static final String SAX_IMPL_SIG = "Lorg/apache/xalan/xsltc/dom/SAXImpl;" ; public static final String DOM_ADAPTER_CLASS = "org/apache/xalan/xsltc/dom/DOMAdapter" ; public static final String DOM_ADAPTER_SIG = "Lorg/apache/xalan/xsltc/dom/DOMAdapter;" ; public static final String MULTI_DOM_CLASS = "org.apache.xalan.xsltc.dom.MultiDOM" ; public static final String MULTI_DOM_SIG = "Lorg/apache/xalan/xsltc/dom/MultiDOM;" ; public static final String STRING = "java.lang.String" ; public static final int ACC_PUBLIC = org . apache . bcel . Constants . ACC_PUBLIC ; public static final int ACC_SUPER = org . apache . bcel . Constants . ACC_SUPER ; public static final int ACC_FINAL = org . apache . bcel . Constants . ACC_FINAL ; public static final int ACC_PRIVATE = org . apache . bcel . Constants . ACC_PRIVATE ; public static final int ACC_PROTECTED = org . apache . bcel . Constants . ACC_PROTECTED ; public static final int ACC_STATIC = org . apache . bcel . Constants . ACC_STATIC ; public static final String STRING_SIG = "Ljava/lang/String;" ; public static final String STRING_BUFFER_SIG = "Ljava/lang/StringBuffer;" ; public static final String OBJECT_SIG = "Ljava/lang/Object;" ; public static final String DOUBLE_SIG = "Ljava/lang/Double;" ; public static final String INTEGER_SIG = "Ljava/lang/Integer;" ; public static final String COLLATOR_CLASS = "java/text/Collator" ; public static final String COLLATOR_SIG = "Ljava/text/Collator;" ; public static final String NODE = "int" ; public static final String NODE_ITERATOR = "org.apache.xml.dtm.DTMAxisIterator" ; public static final String NODE_ITERATOR_BASE = "org.apache.xml.dtm.ref.DTMAxisIteratorBase" ; public static final String SORT_ITERATOR = "org.apache.xalan.xsltc.dom.SortingIterator" ; public static final String SORT_ITERATOR_SIG = "Lorg.apache.xalan.xsltc.dom.SortingIterator;" ; public static final String FORWARD_POSITION_ITERATOR = "org.apache.xalan.xsltc.dom.ForwardPositionIterator" ; public static final String NODE_SORT_RECORD = "org.apache.xalan.xsltc.dom.NodeSortRecord" ; public static final String NODE_SORT_FACTORY = "org/apache/xalan/xsltc/dom/NodeSortRecordFactory" ; public static final String NODE_SORT_RECORD_SIG = "Lorg/apache/xalan/xsltc/dom/NodeSortRecord;" ; public static final String NODE_SORT_FACTORY_SIG = "Lorg/apache/xalan/xsltc/dom/NodeSortRecordFactory;" ; public static final String LOCALE_CLASS = "java.util.Locale" ; public static final String LOCALE_SIG = "Ljava/util/Locale;" ; public static final String STRING_VALUE_HANDLER = "org.apache.xalan.xsltc.runtime.StringValueHandler" ; public static final String STRING_VALUE_HANDLER_SIG = "Lorg/apache/xalan/xsltc/runtime/StringValueHandler;" ; public static final String OUTPUT_HANDLER = "org/apache/xml/serializer/SerializationHandler" ; public static final String OUTPUT_HANDLER_SIG = "Lorg/apache/xml/serializer/SerializationHandler;" ; public static final String FILTER_INTERFACE = "org.apache.xalan.xsltc.dom.Filter" ; public static final String FILTER_INTERFACE_SIG = "Lorg/apache/xalan/xsltc/dom/Filter;" ; public static final String UNION_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.UnionIterator" ; public static final String STEP_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.StepIterator" ; public static final String NTH_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.NthIterator" ; public static final String ABSOLUTE_ITERATOR = "org.apache.xalan.xsltc.dom.AbsoluteIterator" ; public static final String DUP_FILTERED_ITERATOR = "org.apache.xalan.xsltc.dom.DupFilterIterator" ; public static final String CURRENT_NODE_LIST_ITERATOR = "org.apache.xalan.xsltc.dom.CurrentNodeListIterator" ; public static final String CURRENT_NODE_LIST_FILTER = "org.apache.xalan.xsltc.dom.CurrentNodeListFilter" ; public static final String CURRENT_NODE_LIST_ITERATOR_SIG = "Lorg/apache/xalan/xsltc/dom/CurrentNodeListIterator;" ; public static final String CURRENT_NODE_LIST_FILTER_SIG = "Lorg/apache/xalan/xsltc/dom/CurrentNodeListFilter;" ; public static final String FILTER_STEP_ITERATOR = "org.apache.xalan.xsltc.dom.FilteredStepIterator" ; public static final String FILTER_ITERATOR = "org.apache.xalan.xsltc.dom.FilterIterator" ; public static final String SINGLETON_ITERATOR = "org.apache.xalan.xsltc.dom.SingletonIterator" ; public static final String MATCHING_ITERATOR = "org.apache.xalan.xsltc.dom.MatchingIterator" ; public static final String NODE_SIG = "I" ; public static final String GET_PARENT = "getParent" ; public static final String GET_PARENT_SIG = "(" + NODE_SIG + ")" + NODE_SIG ; public static final String NEXT_SIG = "()" + NODE_SIG ; public static final String NEXT = "next" ; public static final String NEXTID = "nextNodeID" ; public static final String MAKE_NODE = "makeNode" ; public static final String MAKE_NODE_LIST = "makeNodeList" ; public static final String GET_UNPARSED_ENTITY_URI = "getUnparsedEntityURI" ; public static final String STRING_TO_REAL = "stringToReal" ; public static final String STRING_TO_REAL_SIG = "(" + STRING_SIG + ")D" ; public static final String STRING_TO_INT = "stringToInt" ; public static final String STRING_TO_INT_SIG = "(" + STRING_SIG + ")I" ; public static final String XSLT_PACKAGE = "org.apache.xalan.xsltc" ; public static final String COMPILER_PACKAGE = XSLT_PACKAGE + ".compiler" ; public static final String RUNTIME_PACKAGE = XSLT_PACKAGE + ".runtime" ; public static final String TRANSLET_CLASS = RUNTIME_PACKAGE + ".AbstractTranslet" ; public static final String TRANSLET_SIG = "Lorg/apache/xalan/xsltc/runtime/AbstractTranslet;" ; public static final String UNION_ITERATOR_SIG = "Lorg/apache/xalan/xsltc/dom/UnionIterator;" ; public static final String TRANSLET_OUTPUT_SIG = "Lorg/apache/xml/serializer/SerializationHandler;" ; public static final String MAKE_NODE_SIG = "(I)Lorg/w3c/dom/Node;" ; public static final String MAKE_NODE_SIG2 = "(" + NODE_ITERATOR_SIG + ")Lorg/w3c/dom/Node;" ; public static final String MAKE_NODE_LIST_SIG = "(I)Lorg/w3c/dom/NodeList;" ; public static final String MAKE_NODE_LIST_SIG2 = "(" + NODE_ITERATOR_SIG + ")Lorg/w3c/dom/NodeList;" ; public static final String STREAM_XML_OUTPUT = "org.apache.xml.serializer.ToXMLStream" ; public static final String OUTPUT_BASE = "org.apache.xml.serializer.SerializerBase" ; public static final String LOAD_DOCUMENT_CLASS = "org.apache.xalan.xsltc.dom.LoadDocument" ; public static final String KEY_INDEX_CLASS = "org/apache/xalan/xsltc/dom/KeyIndex" ; public static final String KEY_INDEX_SIG = "Lorg/apache/xalan/xsltc/dom/KeyIndex;" ; public static final String DOM_INTF = "org.apache.xalan.xsltc.DOM" ; public static final String DOM_IMPL = "org.apache.xalan.xsltc.dom.SAXImpl" ; public static final String SAX_IMPL = "org.apache.xalan.xsltc.dom.SAXImpl" ; public static final String STRING_CLASS = "java.lang.String" ; public static final String OBJECT_CLASS = "java.lang.Object" ; public static final String BOOLEAN_CLASS = "java.lang.Boolean" ; public static final String STRING_BUFFER_CLASS = "java.lang.StringBuffer" ; public static final String STRING_WRITER = "java.io.StringWriter" ; public static final String WRITER_SIG = "Ljava/io/Writer;" ; public static final String TRANSLET_OUTPUT_BASE = "org.apache.xalan.xsltc.TransletOutputBase" ; public static final String TRANSLET_OUTPUT_INTERFACE = "org.apache.xml.serializer.SerializationHandler" ; public static final String BASIS_LIBRARY_CLASS = "org.apache.xalan.xsltc.runtime.BasisLibrary" ; public static final String ATTRIBUTE_LIST_IMPL_CLASS = "org.apache.xalan.xsltc.runtime.AttributeListImpl" ; public static final String DOUBLE_CLASS = "java.lang.Double" ; public static final String INTEGER_CLASS = "java.lang.Integer" ; public static final String RUNTIME_NODE_CLASS = "org.apache.xalan.xsltc.runtime.Node" ; public static final String MATH_CLASS = "java.lang.Math" ; public static final String BOOLEAN_VALUE = "booleanValue" ; public static final String BOOLEAN_VALUE_SIG = "()Z" ; public static final String INT_VALUE = "intValue" ; public static final String INT_VALUE_SIG = "()I" ; public static final String DOUBLE_VALUE = "doubleValue" ; public static final String DOUBLE_VALUE_SIG = "()D" ; public static final String NODE_PNAME = "node" ; public static final String TRANSLET_OUTPUT_PNAME = "handler" ; public static final String ITERATOR_PNAME = "iterator" ; public static final String DOCUMENT_PNAME = "document" ; public static final String TRANSLET_PNAME = "translet" ; public static final String GET_NODE_NAME = "getNodeNameX" ; public static final String CHARACTERSW = "characters" ; public static final String GET_CHILDREN = "getChildren" ; public static final String GET_TYPED_CHILDREN = "getTypedChildren" ; public static final String CHARACTERS = "characters" ; public static final String APPLY_TEMPLATES = "applyTemplates" ; public static final String GET_NODE_TYPE = "getNodeType" ; public static final String GET_NODE_VALUE = "getStringValueX" ; public static final String GET_ELEMENT_VALUE = "getElementValue" ; public static final String GET_ATTRIBUTE_VALUE = "getAttributeValue" ; public static final String HAS_ATTRIBUTE = "hasAttribute" ; public static final String ADD_ITERATOR = "addIterator" ; public static final String SET_START_NODE = "setStartNode" ; public static final String RESET = "reset" ; public static final String ATTR_SET_SIG = "(" + TRANSLET_OUTPUT_SIG + NODE_ITERATOR_SIG + ")V" ; public static final String GET_NODE_NAME_SIG = "(" + NODE_SIG + ")" + STRING_SIG ; public static final String CHARACTERSW_SIG = "(" + STRING_SIG + TRANSLET_OUTPUT_SIG + ")V" ; public static final String CHARACTERS_SIG = "(" + NODE_SIG + TRANSLET_OUTPUT_SIG + ")V" ; public static final String GET_CHILDREN_SIG = "(" + NODE_SIG + ")" + NODE_ITERATOR_SIG ; public static final String GET_TYPED_CHILDREN_SIG = "(I)" + NODE_ITERATOR_SIG ; public static final String GET_NODE_TYPE_SIG = "()S" ; public static final String GET_NODE_VALUE_SIG = "(I)" + STRING_SIG ; public static final String GET_ELEMENT_VALUE_SIG = "(I)" + STRING_SIG ; public static final String GET_ATTRIBUTE_VALUE_SIG = "(II)" + STRING_SIG ; public static final String HAS_ATTRIBUTE_SIG = "(II)Z" ; public static final String GET_ITERATOR_SIG = "()" + NODE_ITERATOR_SIG ; public static final String NAMES_INDEX = "namesArray" ; public static final String NAMES_INDEX_SIG = "[" + STRING_SIG ; public static final String NAMESPACE_INDEX = "namespaceArray" ; public static final String NAMESPACE_INDEX_SIG = "[" + STRING_SIG ; public static final String HASIDCALL_INDEX = "_hasIdCall" ; public static final String HASIDCALL_INDEX_SIG = "Z" ; public static final String DOM_FIELD = "_dom" ; public static final String FORMAT_SYMBOLS_FIELD = "format_symbols" ; public static final String ITERATOR_FIELD_SIG = NODE_ITERATOR_SIG ; public static final String NODE_FIELD = "node" ; public static final String NODE_FIELD_SIG = "I" ; public static final String EMPTYATTR_FIELD = "EmptyAttributes" ; public static final String ATTRIBUTE_LIST_FIELD = "attributeList" ; public static final String CLEAR_ATTRIBUTES = "clear" ; public static final String ADD_ATTRIBUTE = "addAttribute" ; public static final String ATTRIBUTE_LIST_IMPL_SIG = "Lorg/apache/xalan/xsltc/runtime/AttributeListImpl;" ; public static final String CLEAR_ATTRIBUTES_SIG = "()" + ATTRIBUTE_LIST_IMPL_SIG ; public static final String ADD_ATTRIBUTE_SIG = "(" + STRING_SIG + STRING_SIG + ")" + ATTRIBUTE_LIST_IMPL_SIG ; public static final String ADD_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + ")" + UNION_ITERATOR_SIG ; public static final String ORDER_ITERATOR = "orderNodes" ; public static final String ORDER_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + "I)" + NODE_ITERATOR_SIG ; public static final String SET_START_NODE_SIG = "(" + NODE_SIG + ")" + NODE_ITERATOR_SIG ; public static final String NODE_COUNTER = "org.apache.xalan.xsltc.dom.NodeCounter" ; public static final String NODE_COUNTER_SIG = "Lorg/apache/xalan/xsltc/dom/NodeCounter;" ; public static final String DEFAULT_NODE_COUNTER = "org.apache.xalan.xsltc.dom.DefaultNodeCounter" ; public static final String DEFAULT_NODE_COUNTER_SIG = "Lorg/apache/xalan/xsltc/dom/DefaultNodeCounter;" ; public static final String TRANSLET_FIELD = "translet" ; public static final String TRANSLET_FIELD_SIG = TRANSLET_SIG ; public static final String RESET_SIG = "()" + NODE_ITERATOR_SIG ; public static final String GET_PARAMETER = "getParameter" ; public static final String ADD_PARAMETER = "addParameter" ; public static final String PUSH_PARAM_FRAME = "pushParamFrame" ; public static final String PUSH_PARAM_FRAME_SIG = "()V" ; public static final String POP_PARAM_FRAME = "popParamFrame" ; public static final String POP_PARAM_FRAME_SIG = "()V" ; public static final String GET_PARAMETER_SIG = "(" + STRING_SIG + ")" + OBJECT_SIG ; public static final String ADD_PARAMETER_SIG = "(" + STRING_SIG + OBJECT_SIG + "Z)" + OBJECT_SIG ; public static final String STRIP_SPACE = "stripSpace" ; public static final String STRIP_SPACE_INTF = "org/apache/xalan/xsltc/StripFilter" ; public static final String STRIP_SPACE_SIG = "Lorg/apache/xalan/xsltc/StripFilter;" ; public static final String STRIP_SPACE_PARAMS = "(Lorg/apache/xalan/xsltc/DOM;II)Z" ; public static final String GET_NODE_VALUE_ITERATOR = "getNodeValueIterator" ; public static final String GET_NODE_VALUE_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + "I" + STRING_SIG + "Z)" + NODE_ITERATOR_SIG ; public static final String GET_UNPARSED_ENTITY_URI_SIG = "(" + STRING_SIG + ")" + STRING_SIG ; public static final int POSITION_INDEX = 2 ; public static final int LAST_INDEX = 3 ; public static final String XMLNS_PREFIX = "xmlns" ; public static final String XMLNS_STRING = "xmlns:" ; public static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/" ; public static final String XSLT_URI = "http://www.w3.org/1999/XSL/Transform" ; public static final String XHTML_URI = "http://www.w3.org/1999/xhtml" ; public static final String TRANSLET_URI = "http://xml.apache.org/xalan/xsltc" ; public static final String REDIRECT_URI = "http://xml.apache.org/xalan/redirect" ; public static final String FALLBACK_CLASS = "org.apache.xalan.xsltc.compiler.Fallback" ; public static final int RTF_INITIAL_SIZE = 32 ; } 	1	['0', '1', '0', '6', '0', '0', '5', '1', '0', '2', '203', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1']
package org . apache . xml . utils . synthetic ; import org . apache . xml . utils . synthetic . reflection . Method ; public class TestDriver { public static int sampleField = 32 ; private boolean inTest = false ; public static void main ( String [ ] args ) { try { System . out . println ( "Proxying java.awt.Frame..." ) ; Class myC = Class . forName ( "java.awt.Frame" ) ; myC . toSource ( System . out , 0 ) ; System . out . println ( "\nProxying org.apache.xml.utils.synthetic.TestDriver..." ) ; myC = Class . forName ( "com.ibm.org.apache.xml.utils.synthetic.TestDriver" ) ; myC . toSource ( System . out , 0 ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "Couldn't proxy: " ) ; e . printStackTrace ( ) ; } try { System . out . println ( "\nBuild a new beast..." ) ; Class myC = Class . declareClass ( "com.ibm.org.apache.xml.utils.synthetic.BuildMe" ) ; Class inner = myC . declareInnerClass ( "island" ) ; inner . addExtends ( Class . forName ( "java.lang.String" ) ) ; Method m = inner . declareMethod ( "getValue" ) ; m . setReturnType ( Class . forName ( "java.lang.String" ) ) ; m . getBody ( ) . append ( "return toString();" ) ; myC . toSource ( System . out , 0 ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( SynthesisException e ) { e . printStackTrace ( ) ; } catch ( IllegalStateException e ) { System . out . println ( "Unwritten function: " + e ) ; e . printStackTrace ( ) ; } } public static void dumpClass ( Class C ) { System . out . println ( "toString(): " + C ) ; System . out . println ( "\tisPrimitive(): " + C . isPrimitive ( ) ) ; System . out . println ( "\tisInterface(): " + C . isInterface ( ) ) ; System . out . println ( "\tisInstance(\"foo\"): " + C . isInstance ( "foo" ) ) ; System . out . println ( "\tisArray(): " + C . isArray ( ) ) ; System . out . println ( "\tgetRealClass(): " + C . getRealClass ( ) ) ; } public void quickcheck ( ) { Inner a = new Inner ( ) ; a . setTest ( ! a . getTest ( ) ) ; } private class Inner { public boolean getTest ( ) { return inTest ; } public void setTest ( boolean test ) { inTest = test ; } } } 	1	['7', '1', '0', '5', '33', '15', '1', '5', '4', '0.833333333', '189', '0.5', '0', '0', '0.233333333', '0', '0', '25.71428571', '2', '0.8571', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionHandler ; import org . apache . xalan . extensions . ExtensionsTable ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; public class ElemExtensionCall extends ElemLiteralResult { String m_extns ; String m_lang ; String m_srcURL ; String m_scriptSrc ; ElemExtensionDecl m_decl = null ; public int getXSLToken ( ) { return Constants . ELEMNAME_EXTENSIONCALL ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; m_extns = this . getNamespace ( ) ; m_decl = getElemExtensionDecl ( sroot , m_extns ) ; if ( m_decl == null ) sroot . getExtensionNamespacesManager ( ) . registerExtension ( m_extns ) ; } private ElemExtensionDecl getElemExtensionDecl ( StylesheetRoot stylesheet , String namespace ) { ElemExtensionDecl decl = null ; int n = stylesheet . getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Stylesheet imported = stylesheet . getGlobalImport ( i ) ; for ( ElemTemplateElement child = imported . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { if ( Constants . ELEMNAME_EXTENSIONDECL == child . getXSLToken ( ) ) { decl = ( ElemExtensionDecl ) child ; String prefix = decl . getPrefix ( ) ; String declNamespace = child . getNamespaceForPrefix ( prefix ) ; if ( namespace . equals ( declNamespace ) ) { return decl ; } } } } return null ; } public void executeFallbacks ( TransformerImpl transformer ) throws TransformerException { for ( ElemTemplateElement child = m_firstChild ; child != null ; child = child . m_nextSibling ) { if ( child . getXSLToken ( ) == Constants . ELEMNAME_FALLBACK ) { try { transformer . pushElemTemplateElement ( child ) ; ( ( ElemFallback ) child ) . executeFallback ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; } } } } public boolean hasFallbackChildren ( ) { for ( ElemTemplateElement child = m_firstChild ; child != null ; child = child . m_nextSibling ) { if ( child . getXSLToken ( ) == Constants . ELEMNAME_FALLBACK ) return true ; } return false ; } public void execute ( TransformerImpl transformer ) throws TransformerException { try { transformer . getResultTreeHandler ( ) . flushPending ( ) ; ExtensionsTable etable = transformer . getExtensionsTable ( ) ; ExtensionHandler nsh = etable . get ( m_extns ) ; if ( null == nsh ) { if ( hasFallbackChildren ( ) ) { executeFallbacks ( transformer ) ; } else { TransformerException te = new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CALL_TO_EXT_FAILED , new Object [ ] { getNodeName ( ) } ) ) ; transformer . getErrorListener ( ) . fatalError ( te ) ; } return ; } try { nsh . processElement ( this . getLocalName ( ) , this , transformer , getStylesheet ( ) , this ) ; } catch ( Exception e ) { if ( hasFallbackChildren ( ) ) executeFallbacks ( transformer ) ; else { if ( e instanceof TransformerException ) { TransformerException te = ( TransformerException ) e ; if ( null == te . getLocator ( ) ) te . setLocator ( this ) ; transformer . getErrorListener ( ) . fatalError ( te ) ; } else if ( e instanceof RuntimeException ) { transformer . getErrorListener ( ) . fatalError ( new TransformerException ( e ) ) ; } else { transformer . getErrorListener ( ) . warning ( new TransformerException ( e ) ) ; } } } } catch ( TransformerException e ) { transformer . getErrorListener ( ) . fatalError ( e ) ; } } public String getAttribute ( String rawName ) { AVT avt = getLiteralResultAttribute ( rawName ) ; if ( ( null != avt ) && avt . getRawName ( ) . equals ( rawName ) ) { return avt . getSimpleString ( ) ; } return null ; } public String getAttribute ( String rawName , org . w3c . dom . Node sourceNode , TransformerImpl transformer ) throws TransformerException { AVT avt = getLiteralResultAttribute ( rawName ) ; if ( ( null != avt ) && avt . getRawName ( ) . equals ( rawName ) ) { XPathContext xctxt = transformer . getXPathContext ( ) ; return avt . evaluate ( xctxt , xctxt . getDTMHandleFromNode ( sourceNode ) , this ) ; } return null ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitExtensionElement ( this ) ; } } 	1	['10', '5', '0', '20', '49', '39', '4', '17', '8', '1.022222222', '285', '0', '1', '0.963709677', '0.333333333', '3', '7', '27', '5', '1.7', '2']
package org . apache . xml . utils . res ; public class XResources_zh_TW extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "alphabet" , new char [ ] { 0xff21 , 0xff22 , 0xff23 , 0xff24 , 0xff25 , 0xff26 , 0xff27 , 0xff28 , 0xff29 , 0xff2a , 0xff2b , 0xff2c , 0xff2d , 0xff2e , 0xff2f , 0xff30 , 0xff31 , 0xff32 , 0xff33 , 0xff34 , 0xff35 , 0xff36 , 0xff37 , 0xff38 , 0xff39 , 0xff3a } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "zero" , new char [ ] { 0x96f6 } } , { "multiplier" , new long [ ] { 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x5104 , 0x842c , 0x4edf , 0x4f70 , 0x62fe } } , { "digits" , new char [ ] { 0x58f9 , 0x8cb3 , 0x53c3 , 0x8086 , 0x4f0d , 0x9678 , 0x67d2 , 0x634c , 0x7396 } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '499', '0', '0', '0.976190476', '1', '0', '0', '165', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class ProcessingInstruction extends Instruction { private AttributeValue _name ; public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; _name = AttributeValue . create ( this , name , parser ) ; if ( name . equals ( "xml" ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_PI_ERR , "xml" ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _name . typeCheck ( stable ) ; typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; _name . translate ( classGen , methodGen ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , "stringValueHandler" , STRING_VALUE_HANDLER_SIG ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_VALUE_HANDLER , "getValueOfPI" , "()" + STRING_SIG ) ) ) ; final int processingInstruction = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "processingInstruction" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( processingInstruction , 3 ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	1	['4', '3', '0', '17', '26', '0', '0', '17', '3', '0.333333333', '123', '1', '1', '0.949152542', '0.4', '2', '6', '29.5', '2', '1', '1']
package org . apache . xml . utils ; public class StringToIntTable { public static final int INVALID_KEY = - 10000 ; private int m_blocksize ; private String m_map [ ] ; private int m_values [ ] ; private int m_firstFree = 0 ; private int m_mapSize ; public StringToIntTable ( ) { m_blocksize = 8 ; m_mapSize = m_blocksize ; m_map = new String [ m_blocksize ] ; m_values = new int [ m_blocksize ] ; } public StringToIntTable ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new String [ blocksize ] ; m_values = new int [ m_blocksize ] ; } public final int getLength ( ) { return m_firstFree ; } public final void put ( String key , int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; int newValues [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_values , 0 , newValues , 0 , m_firstFree + 1 ) ; m_values = newValues ; } m_map [ m_firstFree ] = key ; m_values [ m_firstFree ] = value ; m_firstFree ++ ; } public final int get ( String key ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( key ) ) return m_values [ i ] ; } return INVALID_KEY ; } public final int getIgnoreCase ( String key ) { if ( null == key ) return INVALID_KEY ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equalsIgnoreCase ( key ) ) return m_values [ i ] ; } return INVALID_KEY ; } public final boolean contains ( String key ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( key ) ) return true ; } return false ; } public final String [ ] keys ( ) { String [ ] keysArr = new String [ m_firstFree ] ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { keysArr [ i ] = m_map [ i ] ; } return keysArr ; } } 	1	['8', '1', '0', '2', '12', '0', '2', '0', '8', '0.523809524', '217', '0.833333333', '0', '0', '0.583333333', '0', '0', '25.375', '4', '1.875', '1']
package org . apache . xml . dtm . ref ; import java . util . BitSet ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class CoroutineManager { BitSet m_activeIDs = new BitSet ( ) ; static final int m_unreasonableId = 1024 ; Object m_yield = null ; final static int NOBODY = - 1 ; final static int ANYBODY = - 1 ; int m_nextCoroutine = NOBODY ; public synchronized int co_joinCoroutineSet ( int coroutineID ) { if ( coroutineID >= 0 ) { if ( coroutineID >= m_unreasonableId || m_activeIDs . get ( coroutineID ) ) return - 1 ; } else { coroutineID = 0 ; while ( coroutineID < m_unreasonableId ) { if ( m_activeIDs . get ( coroutineID ) ) ++ coroutineID ; else break ; } if ( coroutineID >= m_unreasonableId ) return - 1 ; } m_activeIDs . set ( coroutineID ) ; return coroutineID ; } public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; } public synchronized Object co_resume ( Object arg_object , int thisCoroutine , int toCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( toCoroutine ) ) throw new java . lang . NoSuchMethodException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COROUTINE_NOT_AVAIL , new Object [ ] { Integer . toString ( toCoroutine ) } ) ) ; m_yield = arg_object ; m_nextCoroutine = toCoroutine ; notify ( ) ; while ( m_nextCoroutine != thisCoroutine || m_nextCoroutine == ANYBODY || m_nextCoroutine == NOBODY ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } if ( m_nextCoroutine == NOBODY ) { co_exit ( thisCoroutine ) ; throw new java . lang . NoSuchMethodException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COROUTINE_CO_EXIT , null ) ) ; } return m_yield ; } public synchronized void co_exit ( int thisCoroutine ) { m_activeIDs . clear ( thisCoroutine ) ; m_nextCoroutine = NOBODY ; notify ( ) ; } public synchronized void co_exit_to ( Object arg_object , int thisCoroutine , int toCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( toCoroutine ) ) throw new java . lang . NoSuchMethodException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COROUTINE_NOT_AVAIL , new Object [ ] { Integer . toString ( toCoroutine ) } ) ) ; m_yield = arg_object ; m_nextCoroutine = toCoroutine ; m_activeIDs . clear ( thisCoroutine ) ; notify ( ) ; } } 	1	['6', '1', '0', '4', '17', '0', '3', '1', '6', '0.7', '183', '0', '0', '0', '0.722222222', '0', '0', '28.5', '7', '1.8333', '1']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncStringLength extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( getArg0AsString ( xctxt ) . length ( ) ) ; } } 	1	['2', '5', '0', '5', '6', '1', '0', '5', '2', '2', '14', '0', '0', '0.982142857', '0.75', '2', '7', '6', '1', '0.5', '1']
package org . apache . xalan . xsltc . dom ; import java . text . CollationKey ; import java . text . Collator ; import java . util . Locale ; import org . apache . xalan . xsltc . CollatorFactory ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; public abstract class NodeSortRecord { public static int COMPARE_STRING = 0 ; public static int COMPARE_NUMERIC = 1 ; public static int COMPARE_ASCENDING = 0 ; public static int COMPARE_DESCENDING = 1 ; protected static final Locale DEFAULT_LOCALE = Locale . getDefault ( ) ; protected Locale _locale = Locale . getDefault ( ) ; protected static final Collator DEFAULT_COLLATOR = Collator . getInstance ( ) ; protected Collator _collator = DEFAULT_COLLATOR ; protected CollatorFactory _collatorFactory ; protected int _levels = 1 ; protected int [ ] _compareType ; protected int [ ] _sortOrder ; private AbstractTranslet _translet = null ; private DOM _dom = null ; private int _node ; private int _last = 0 ; private int _scanned = 0 ; private Object [ ] _values ; public NodeSortRecord ( int node ) { _node = node ; if ( _locale != DEFAULT_LOCALE ) { _collator = Collator . getInstance ( _locale ) ; } } public NodeSortRecord ( ) { this ( 0 ) ; } public final void initialize ( int node , int last , DOM dom , AbstractTranslet translet , int [ ] order , int [ ] type , NodeSortRecordFactory nsrFactory ) throws TransletException { _dom = dom ; _node = node ; _last = last ; _translet = translet ; _scanned = 0 ; _levels = order . length ; _sortOrder = order ; _compareType = type ; _values = new Object [ _levels ] ; String colFactClassname = System . getProperty ( "org.apache.xalan.xsltc.COLLATOR_FACTORY" ) ; if ( colFactClassname != null ) { try { Object candObj = nsrFactory . loadTranslet ( colFactClassname ) ; _collatorFactory = ( CollatorFactory ) candObj ; } catch ( ClassNotFoundException e ) { throw new TransletException ( e ) ; } } else { _collatorFactory = new CollatorFactoryBase ( ) ; } _collator = _collatorFactory . getCollator ( _locale ) ; } public final int getNode ( ) { return _node ; } public final int compareDocOrder ( NodeSortRecord other ) { return _node - other . _node ; } private final CollationKey stringValue ( int level ) { if ( _scanned <= level ) { final String str = extractValueFromDOM ( _dom , _node , level , _translet , _last ) ; final CollationKey key = _collator . getCollationKey ( str ) ; _values [ _scanned ++ ] = key ; return ( key ) ; } return ( ( CollationKey ) _values [ level ] ) ; } private final Double numericValue ( int level ) { if ( _scanned <= level ) { final String str = extractValueFromDOM ( _dom , _node , level , _translet , _last ) ; Double num ; try { num = new Double ( str ) ; } catch ( NumberFormatException e ) { num = new Double ( Double . NEGATIVE_INFINITY ) ; } _values [ _scanned ++ ] = num ; return ( num ) ; } return ( ( Double ) _values [ level ] ) ; } public int compareTo ( NodeSortRecord other ) { int cmp , level ; for ( level = 0 ; level < _levels ; level ++ ) { if ( _compareType [ level ] == COMPARE_NUMERIC ) { final Double our = numericValue ( level ) ; final Double their = other . numericValue ( level ) ; cmp = our . compareTo ( their ) ; } else { final CollationKey our = stringValue ( level ) ; final CollationKey their = other . stringValue ( level ) ; cmp = our . compareTo ( their ) ; } if ( cmp != 0 ) { return _sortOrder [ level ] == COMPARE_DESCENDING ? 0 - cmp : cmp ; } } return ( _node - other . _node ) ; } public Collator getCollator ( ) { return _collator ; } public abstract String extractValueFromDOM ( DOM dom , int current , int level , AbstractTranslet translet , int last ) ; } 	1	['11', '1', '0', '7', '25', '3', '2', '6', '8', '0.733333333', '303', '0.777777778', '3', '0', '0.328571429', '0', '0', '24.90909091', '5', '1.2727', '2']
package org . apache . xml . utils ; public class IntVector implements Cloneable { protected int m_blocksize ; protected int m_map [ ] ; protected int m_firstFree = 0 ; protected int m_mapSize ; public IntVector ( ) { m_blocksize = 32 ; m_mapSize = m_blocksize ; m_map = new int [ m_blocksize ] ; } public IntVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new int [ blocksize ] ; } public IntVector ( int blocksize , int increaseSize ) { m_blocksize = increaseSize ; m_mapSize = blocksize ; m_map = new int [ blocksize ] ; } public IntVector ( IntVector v ) { m_map = new int [ v . m_mapSize ] ; m_mapSize = v . m_mapSize ; m_firstFree = v . m_firstFree ; m_blocksize = v . m_blocksize ; System . arraycopy ( v . m_map , 0 , m_map , 0 , m_firstFree ) ; } public final int size ( ) { return m_firstFree ; } public final void setSize ( int sz ) { m_firstFree = sz ; } public final void addElement ( int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void addElements ( int value , int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map [ m_firstFree ] = value ; m_firstFree ++ ; } } public final void addElements ( int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_firstFree += numberOfElements ; } public final void insertElementAt ( int value , int at ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public final void removeAllElements ( ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = java . lang . Integer . MIN_VALUE ; } m_firstFree = 0 ; } public final boolean removeElement ( int s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + 1 ) < m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return true ; } } return false ; } public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i , m_firstFree ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; } public final void setElementAt ( int value , int index ) { m_map [ index ] = value ; } public final int elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( int s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) return true ; } return false ; } public final int indexOf ( int elem , int index ) { for ( int i = index ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int indexOf ( int elem ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int lastIndexOf ( int elem ) { for ( int i = ( m_firstFree - 1 ) ; i >= 0 ; i -- ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public Object clone ( ) throws CloneNotSupportedException { return new IntVector ( this ) ; } } 	1	['20', '1', '1', '5', '22', '0', '5', '0', '20', '0.342105263', '497', '1', '0', '0', '0.6', '0', '0', '23.65', '4', '1.75', '1']
package org . apache . xalan . lib ; import org . apache . xpath . NodeSet ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class ExsltMath extends ExsltBase { private static String PI = "3.1415926535897932384626433832795028841971693993751" ; private static String E = "2.71828182845904523536028747135266249775724709369996" ; private static String SQRRT2 = "1.41421356237309504880168872420969807856967187537694" ; private static String LN2 = "0.69314718055994530941723212145817656807550013436025" ; private static String LN10 = "2.302585092994046" ; private static String LOG2E = "1.4426950408889633" ; private static String SQRT1_2 = "0.7071067811865476" ; public static double max ( NodeList nl ) { if ( nl == null || nl . getLength ( ) == 0 ) return Double . NaN ; double m = - Double . MAX_VALUE ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( Double . isNaN ( d ) ) return Double . NaN ; else if ( d > m ) m = d ; } return m ; } public static double min ( NodeList nl ) { if ( nl == null || nl . getLength ( ) == 0 ) return Double . NaN ; double m = Double . MAX_VALUE ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( Double . isNaN ( d ) ) return Double . NaN ; else if ( d < m ) m = d ; } return m ; } public static NodeList highest ( NodeList nl ) { double maxValue = max ( nl ) ; NodeSet highNodes = new NodeSet ( ) ; highNodes . setShouldCacheNodes ( true ) ; if ( Double . isNaN ( maxValue ) ) return highNodes ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( d == maxValue ) highNodes . addElement ( n ) ; } return highNodes ; } public static NodeList lowest ( NodeList nl ) { double minValue = min ( nl ) ; NodeSet lowNodes = new NodeSet ( ) ; lowNodes . setShouldCacheNodes ( true ) ; if ( Double . isNaN ( minValue ) ) return lowNodes ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( d == minValue ) lowNodes . addElement ( n ) ; } return lowNodes ; } public static double abs ( double num ) { return Math . abs ( num ) ; } public static double acos ( double num ) { return Math . acos ( num ) ; } public static double asin ( double num ) { return Math . asin ( num ) ; } public static double atan ( double num ) { return Math . atan ( num ) ; } public static double atan2 ( double num1 , double num2 ) { return Math . atan2 ( num1 , num2 ) ; } public static double cos ( double num ) { return Math . cos ( num ) ; } public static double exp ( double num ) { return Math . exp ( num ) ; } public static double log ( double num ) { return Math . log ( num ) ; } public static double power ( double num1 , double num2 ) { return Math . pow ( num1 , num2 ) ; } public static double random ( ) { return Math . random ( ) ; } public static double sin ( double num ) { return Math . sin ( num ) ; } public static double sqrt ( double num ) { return Math . sqrt ( num ) ; } public static double tan ( double num ) { return Math . tan ( num ) ; } public static double constant ( String name , double precision ) { String value = null ; if ( name . equals ( "PI" ) ) value = PI ; else if ( name . equals ( "E" ) ) value = E ; else if ( name . equals ( "SQRRT2" ) ) value = SQRRT2 ; else if ( name . equals ( "LN2" ) ) value = LN2 ; else if ( name . equals ( "LN10" ) ) value = LN10 ; else if ( name . equals ( "LOG2E" ) ) value = LOG2E ; else if ( name . equals ( "SQRT1_2" ) ) value = SQRT1_2 ; if ( value != null ) { int bits = new Double ( precision ) . intValue ( ) ; if ( bits <= value . length ( ) ) value = value . substring ( 0 , bits ) ; return new Double ( value ) . doubleValue ( ) ; } else return Double . NaN ; } } 	1	['20', '2', '0', '2', '48', '188', '0', '2', '19', '0.947368421', '312', '1', '0', '0.1', '0.25', '0', '0', '14.25', '10', '2.15', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "More than one stylesheet defined in the same file." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Template ''{0}'' already defined in this stylesheet." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Template ''{0}'' not defined in this stylesheet." } , { ErrorMsg . VARIABLE_REDEF_ERR , "Variable ''{0}'' is multiply defined in the same scope." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Variable or parameter ''{0}'' is undefined." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Cannot find class ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Cannot find external method ''{0}'' (must be public)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Cannot convert argument/return type in call to method ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "File or URI ''{0}'' not found." } , { ErrorMsg . INVALID_URI_ERR , "Invalid URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Cannot open file or URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "<xsl:stylesheet> or <xsl:transform> element expected." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Namespace prefix ''{0}'' is undeclared." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Unable to resolve call to function ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "Argument to ''{0}'' must be a literal string." } , { ErrorMsg . XPATH_PARSER_ERR , "Error parsing XPath expression ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Required attribute ''{0}'' is missing." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Illegal character ''{0}'' in XPath expression." } , { ErrorMsg . ILLEGAL_PI_ERR , "Illegal name ''{0}'' for processing instruction." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Attribute ''{0}'' outside of element." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Illegal attribute ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Circular import/include. Stylesheet ''{0}'' already loaded." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Result-tree fragments cannot be sorted (<xsl:sort> elements are " + "ignored). You must sort the nodes when creating the result tree." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Decimal formatting ''{0}'' is already defined." } , { ErrorMsg . XSL_VERSION_ERR , "XSL version ''{0}'' is not supported by XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Circular variable/parameter reference in ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Unknown operator for binary expression." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Illegal argument(s) for function call." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Second argument to document() function must be a node-set." } , { ErrorMsg . MISSING_WHEN_ERR , "At least one <xsl:when> element required in <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Only one <xsl:otherwise> element allowed in <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> can only be used within <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> can only be used within <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Only <xsl:when> and <xsl:otherwise> elements allowed in <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> is missing the 'name' attribute." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Illegal child element." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "You cannot call an element ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "You cannot call an attribute ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Text data outside of top-level <xsl:stylesheet> element." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP parser not configured correctly" } , { ErrorMsg . INTERNAL_ERR , "Unrecoverable XSLTC-internal error: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Unsupported XSL element ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Unrecognised XSLTC extension ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "The input document is not a stylesheet (the XSL namespace is not " + "declared in the root element)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Could not find stylesheet target ''{0}''." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Not implemented: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "The input document does not contain an XSL stylesheet." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Could not parse element ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "The use attribute of <key> must be node, node-set, string or number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Output XML document version should be 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Unknown operator for relational expression" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Attempting to use non-existing attribute set ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Cannot parse attribute value template ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Unknown data-type in signature for class ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Cannot convert data-type ''{0}'' to ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "This Templates does not contain a valid translet class definition." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "This Templates does not contain a class with the name ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Could not load the translet class ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Translet class loaded, but unable to create translet instance." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Attempting to set ErrorListener for ''{0}'' to null" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Only StreamSource, SAXSource and DOMSource are supported by XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "Source object passed to ''{0}'' has no contents." } , { ErrorMsg . JAXP_COMPILE_ERR , "Could not compile stylesheet" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory does not recognise attribute ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() must be called prior to startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "The Transformer has no encapsulated translet object." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "No defined output handler for transformation result." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Result object passed to ''{0}'' is invalid." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Attempting to access invalid Transformer property ''{0}''." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Could not create SAX2DOM adapter: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() called without systemId being set." } , { ErrorMsg . COMPILE_STDIN_ERR , "The -i option must be used with the -o option." } , { ErrorMsg . COMPILE_USAGE_STR , "SYNOPSIS\n" + "   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n" + "      [-d <directory>] [-j <jarfile>] [-p <package>]\n" + "      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\n" + "OPTIONS\n" + "   -o <output>    assigns the name <output> to the generated\n" + "                  translet. By default the translet name\n" + "                  is taken from the <stylesheet> name. This option\n" + "                  is ignored if compiling multiple stylesheets.\n" + "   -d <directory> specifies a destination directory for translet\n" + "   -j <jarfile>   packages translet classes into a jar file of the\n" + "                  name specified as <jarfile>\n" + "   -p <package>   specifies a package name prefix for all generated\n" + "                  translet classes.\n" + "   -n             enables template inlining (default behavior better\n" + "                  on average).\n" + "   -x             turns on additional debugging message output\n" + "   -s             disables calling System.exit\n" + "   -u             interprets <stylesheet> arguments as URLs\n" + "   -i             forces compiler to read stylesheet from stdin\n" + "   -v             prints the version of the compiler\n" + "   -h             prints this usage statement\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SYNOPSIS \n" + "   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n" + "      [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}\n" + "      <class> [<param1>=<value1> ...]\n\n" + "   uses the translet <class> to transform an XML document \n" + "   specified as <document>. The translet <class> is either in\n" + "   the user's CLASSPATH or in the optionally specified <jarfile>.\n" + "OPTIONS\n" + "   -j <jarfile>    specifies a jarfile from which to load translet\n" + "   -x              turns on additional debugging message output\n" + "   -s              disables calling System.exit\n" + "   -n <iterations> runs the transformation <iterations> times and\n" + "                   displays profiling information\n" + "   -u <document_url> specifies XML input document as a URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> can only be used within <xsl:for-each> or <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Output encoding ''{0}'' is not supported on this JVM." } , { ErrorMsg . SYNTAX_ERR , "Syntax error in ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Cannot find external constructor ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "The first argument to the non-static Java function ''{0}'' is not a " + "valid object reference." } , { ErrorMsg . TYPE_CHECK_ERR , "Error checking type of the expression ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Error checking type of an expression at an unknown location." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "The command-line option ''{0}'' is not valid." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "The command-line option ''{0}'' is missing a required argument." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "WARNING:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "WARNING:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "FATAL ERROR:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "FATAL ERROR:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "ERROR:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "ERROR:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Transform using translet ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Transform using translet ''{0}'' from jar file ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Could not create an instance of the TransformerFactory class ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Compiler errors:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Compiler warnings:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Translet errors:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '1', '1', '4', '1', '1', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xpath . objects ; import java . io . Serializable ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathException ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XObject extends Expression implements Serializable , Cloneable { protected Object m_obj ; public XObject ( ) { } public XObject ( Object obj ) { m_obj = obj ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return this ; } public void allowDetachToRelease ( boolean allowRelease ) { } public void detach ( ) { } public void destruct ( ) { if ( null != m_obj ) { allowDetachToRelease ( true ) ; detach ( ) ; m_obj = null ; } } public void reset ( ) { } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { xstr ( ) . dispatchCharactersEvents ( ch ) ; } static public XObject create ( Object val ) { return XObjectFactory . create ( val ) ; } static public XObject create ( Object val , XPathContext xctxt ) { return XObjectFactory . create ( val , xctxt ) ; } public static final int CLASS_NULL = - 1 ; public static final int CLASS_UNKNOWN = 0 ; public static final int CLASS_BOOLEAN = 1 ; public static final int CLASS_NUMBER = 2 ; public static final int CLASS_STRING = 3 ; public static final int CLASS_NODESET = 4 ; public static final int CLASS_RTREEFRAG = 5 ; public static final int CLASS_UNRESOLVEDVARIABLE = 600 ; public int getType ( ) { return CLASS_UNKNOWN ; } public String getTypeString ( ) { return "#UNKNOWN (" + object ( ) . getClass ( ) . getName ( ) + ")" ; } public double num ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NUMBER , new Object [ ] { getTypeString ( ) } ) ; return 0.0 ; } public double numWithSideEffects ( ) throws javax . xml . transform . TransformerException { return num ( ) ; } public boolean bool ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NUMBER , new Object [ ] { getTypeString ( ) } ) ; return false ; } public boolean boolWithSideEffects ( ) throws javax . xml . transform . TransformerException { return bool ( ) ; } public XMLString xstr ( ) { return XMLStringFactoryImpl . getFactory ( ) . newstr ( str ( ) ) ; } public String str ( ) { return ( m_obj != null ) ? m_obj . toString ( ) : "" ; } public String toString ( ) { return str ( ) ; } public int rtf ( XPathContext support ) { int result = rtf ( ) ; if ( DTM . NULL == result ) { DTM frag = support . createDocumentFragment ( ) ; frag . appendTextChild ( str ( ) ) ; result = frag . getDocument ( ) ; } return result ; } public DocumentFragment rtree ( XPathContext support ) { DocumentFragment docFrag = null ; int result = rtf ( ) ; if ( DTM . NULL == result ) { DTM frag = support . createDocumentFragment ( ) ; frag . appendTextChild ( str ( ) ) ; docFrag = ( DocumentFragment ) frag . getNode ( frag . getDocument ( ) ) ; } else { DTM frag = support . getDTM ( result ) ; docFrag = ( DocumentFragment ) frag . getNode ( frag . getDocument ( ) ) ; } return docFrag ; } public DocumentFragment rtree ( ) { return null ; } public int rtf ( ) { return DTM . NULL ; } public Object object ( ) { return m_obj ; } public DTMIterator iter ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NODELIST , new Object [ ] { getTypeString ( ) } ) ; return null ; } public XObject getFresh ( ) { return this ; } public NodeIterator nodeset ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NODELIST , new Object [ ] { getTypeString ( ) } ) ; return null ; } public NodeList nodelist ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NODELIST , new Object [ ] { getTypeString ( ) } ) ; return null ; } public NodeSetDTM mutableNodeset ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_MUTABLENODELIST , new Object [ ] { getTypeString ( ) } ) ; return ( NodeSetDTM ) m_obj ; } public Object castToType ( int t , XPathContext support ) throws javax . xml . transform . TransformerException { Object result ; switch ( t ) { case CLASS_STRING : result = str ( ) ; break ; case CLASS_NUMBER : result = new Double ( num ( ) ) ; break ; case CLASS_NODESET : result = iter ( ) ; break ; case CLASS_BOOLEAN : result = new Boolean ( bool ( ) ) ; break ; case CLASS_UNKNOWN : result = m_obj ; break ; default : error ( XPATHErrorResources . ER_CANT_CONVERT_TO_TYPE , new Object [ ] { getTypeString ( ) , Integer . toString ( t ) } ) ; result = null ; } return result ; } public boolean lessThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . greaterThan ( this ) ; return this . num ( ) < obj2 . num ( ) ; } public boolean lessThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . greaterThanOrEqual ( this ) ; return this . num ( ) <= obj2 . num ( ) ; } public boolean greaterThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . lessThan ( this ) ; return this . num ( ) > obj2 . num ( ) ; } public boolean greaterThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . lessThanOrEqual ( this ) ; return this . num ( ) >= obj2 . num ( ) ; } public boolean equals ( XObject obj2 ) { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . equals ( this ) ; if ( null != m_obj ) { return m_obj . equals ( obj2 . m_obj ) ; } else { return obj2 . m_obj == null ; } } public boolean notEquals ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . notEquals ( this ) ; return ! equals ( obj2 ) ; } protected void error ( String msg ) throws javax . xml . transform . TransformerException { error ( msg , null ) ; } protected void error ( String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; { throw new XPathException ( fmsg , this ) ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { fsb . append ( str ( ) ) ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { assertion ( false , "callVisitors should not be called for this object!!!" ) ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! this . equals ( ( XObject ) expr ) ) return false ; return true ; } } 	1	['42', '2', '7', '145', '68', '819', '132', '15', '40', '0.953929539', '465', '0.111111111', '0', '0.428571429', '0.112244898', '2', '8', '9.857142857', '4', '1.1667', '1']
package org . apache . xml . utils ; import java . io . File ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . URI . MalformedURIException ; public class SystemIDResolver { public static String getAbsoluteURIFromRelative ( String localPath ) { if ( localPath == null || localPath . length ( ) == 0 ) return "" ; String absolutePath = localPath ; if ( ! isAbsolutePath ( localPath ) ) { try { absolutePath = getAbsolutePathFromRelativePath ( localPath ) ; } catch ( SecurityException se ) { return "file:" + localPath ; } } String urlString ; if ( null != absolutePath ) { if ( absolutePath . startsWith ( File . separator ) ) urlString = "file://" + absolutePath ; else urlString = "file:///" + absolutePath ; } else urlString = "file:" + localPath ; return replaceChars ( urlString ) ; } private static String getAbsolutePathFromRelativePath ( String relativePath ) { return new File ( relativePath ) . getAbsolutePath ( ) ; } public static boolean isAbsoluteURI ( String systemId ) { int colonIndex = systemId . indexOf ( ':' ) ; if ( colonIndex > 1 ) return true ; else return false ; } public static boolean isAbsolutePath ( String systemId ) { if ( systemId . startsWith ( File . separator ) ) return true ; if ( systemId . length ( ) > 2 && systemId . charAt ( 1 ) == ':' && Character . isLetter ( systemId . charAt ( 0 ) ) && ( systemId . charAt ( 2 ) == '\\' || systemId . charAt ( 2 ) == '/' ) ) return true ; else return false ; } private static String replaceChars ( String str ) { StringBuffer buf = new StringBuffer ( str ) ; int length = buf . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char currentChar = buf . charAt ( i ) ; if ( currentChar == ' ' ) { buf . setCharAt ( i , '%' ) ; buf . insert ( i + 1 , "20" ) ; length = length + 2 ; i = i + 2 ; } else if ( currentChar == '\\' ) { buf . setCharAt ( i , '/' ) ; } } return buf . toString ( ) ; } public static String getAbsoluteURI ( String systemId ) { String absoluteURI = systemId ; if ( isAbsoluteURI ( systemId ) ) { if ( systemId . startsWith ( "file:" ) ) { String str = systemId . substring ( 5 ) ; if ( str != null && str . startsWith ( "/" ) ) { if ( str . startsWith ( "///" ) || ! str . startsWith ( "//" ) ) { int secondColonIndex = systemId . indexOf ( ':' , 5 ) ; if ( secondColonIndex > 0 ) { String localPath = systemId . substring ( secondColonIndex - 1 ) ; try { if ( ! isAbsolutePath ( localPath ) ) absoluteURI = systemId . substring ( 0 , secondColonIndex - 1 ) + getAbsolutePathFromRelativePath ( localPath ) ; } catch ( SecurityException se ) { return systemId ; } } } } else { return getAbsoluteURIFromRelative ( systemId . substring ( 5 ) ) ; } return replaceChars ( absoluteURI ) ; } else return systemId ; } else return getAbsoluteURIFromRelative ( systemId ) ; } public static String getAbsoluteURI ( String urlString , String base ) throws TransformerException { if ( base == null ) return getAbsoluteURI ( urlString ) ; String absoluteBase = getAbsoluteURI ( base ) ; URI uri = null ; try { URI baseURI = new URI ( absoluteBase ) ; uri = new URI ( baseURI , urlString ) ; } catch ( MalformedURIException mue ) { throw new TransformerException ( mue ) ; } return replaceChars ( uri . toString ( ) ) ; } } 	1	['8', '1', '0', '15', '31', '28', '13', '2', '6', '2', '287', '0', '0', '0', '0.5', '0', '0', '34.875', '7', '3.5', '3']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncNot extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_arg0 . execute ( xctxt ) . bool ( ) ? XBoolean . S_FALSE : XBoolean . S_TRUE ; } } 	1	['2', '4', '0', '5', '5', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '1']
package org . apache . xpath . functions ; import java . io . BufferedInputStream ; import java . io . InputStream ; import java . util . Properties ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; public class FuncSystemProperty extends FunctionOneArg { static String XSLT_PROPERTIES = "org/apache/xalan/res/XSLTInfo.properties" ; private static final Class [ ] NO_CLASSES = new Class [ 0 ] ; private static final Object [ ] NO_OBJS = new Object [ 0 ] ; public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String fullName = m_arg0 . execute ( xctxt ) . str ( ) ; int indexOfNSSep = fullName . indexOf ( ':' ) ; String result ; String propName = "" ; Properties xsltInfo = new Properties ( ) ; loadPropertyFile ( XSLT_PROPERTIES , xsltInfo ) ; if ( indexOfNSSep > 0 ) { String prefix = ( indexOfNSSep >= 0 ) ? fullName . substring ( 0 , indexOfNSSep ) : "" ; String namespace ; namespace = xctxt . getNamespaceContext ( ) . getNamespaceForPrefix ( prefix ) ; propName = ( indexOfNSSep < 0 ) ? fullName : fullName . substring ( indexOfNSSep + 1 ) ; if ( namespace . startsWith ( "http://www.w3.org/XSL/Transform" ) || namespace . equals ( "http://www.w3.org/1999/XSL/Transform" ) ) { result = xsltInfo . getProperty ( propName ) ; if ( null == result ) { warn ( xctxt , XPATHErrorResources . WG_PROPERTY_NOT_SUPPORTED , new Object [ ] { fullName } ) ; return XString . EMPTYSTRING ; } } else { warn ( xctxt , XPATHErrorResources . WG_DONT_DO_ANYTHING_WITH_NS , new Object [ ] { namespace , fullName } ) ; try { result = System . getProperty ( propName ) ; if ( null == result ) { return XString . EMPTYSTRING ; } } catch ( SecurityException se ) { warn ( xctxt , XPATHErrorResources . WG_SECURITY_EXCEPTION , new Object [ ] { fullName } ) ; return XString . EMPTYSTRING ; } } } else { try { result = System . getProperty ( fullName ) ; if ( null == result ) { return XString . EMPTYSTRING ; } } catch ( SecurityException se ) { warn ( xctxt , XPATHErrorResources . WG_SECURITY_EXCEPTION , new Object [ ] { fullName } ) ; return XString . EMPTYSTRING ; } } if ( propName . equals ( "version" ) && result . length ( ) > 0 ) { try { return new XNumber ( 1.0 ) ; } catch ( Exception ex ) { return new XString ( result ) ; } } else return new XString ( result ) ; } public void loadPropertyFile ( String file , Properties target ) { InputStream is = null ; try { try { java . lang . reflect . Method getCCL = Thread . class . getMethod ( "getContextClassLoader" , NO_CLASSES ) ; if ( getCCL != null ) { ClassLoader contextClassLoader = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; is = contextClassLoader . getResourceAsStream ( file ) ; } } catch ( Exception e ) { } if ( is == null ) { is = FuncSystemProperty . class . getResourceAsStream ( "/" + file ) ; } BufferedInputStream bis = new BufferedInputStream ( is ) ; target . load ( bis ) ; bis . close ( ) ; } catch ( Exception ex ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ex ) ; } } } 	1	['5', '4', '0', '8', '37', '6', '0', '8', '3', '0.65', '253', '0.4', '0', '0.941176471', '0.4375', '2', '8', '48.6', '4', '1.2', '1']
package org . apache . xalan . transformer ; class XSLInfiniteLoopException { XSLInfiniteLoopException ( ) { super ( ) ; } public String getMessage ( ) { return "Processing Terminated." ; } } 	1	['2', '1', '0', '0', '3', '1', '0', '0', '1', '2', '7', '0', '0', '0', '1', '0', '0', '2.5', '1', '0.5', '1']
package org . apache . xml . utils ; public class CharKey extends Object { private char m_char ; public CharKey ( char key ) { m_char = key ; } public CharKey ( ) { } public final void setChar ( char c ) { m_char = c ; } public final int hashCode ( ) { return ( int ) m_char ; } public final boolean equals ( Object obj ) { return ( ( CharKey ) obj ) . m_char == m_char ; } } 	1	['5', '1', '0', '1', '6', '0', '1', '0', '5', '0.25', '32', '1', '0', '0', '0.533333333', '1', '1', '5.2', '2', '0.8', '1']
package org . apache . xml . utils ; import java . util . Stack ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . ext . LexicalHandler ; public class DOMBuilder implements ContentHandler , LexicalHandler { public Document m_doc ; protected Node m_currentNode = null ; public DocumentFragment m_docFrag = null ; protected Stack m_elemStack = new Stack ( ) ; public DOMBuilder ( Document doc , Node node ) { m_doc = doc ; m_currentNode = node ; } public DOMBuilder ( Document doc , DocumentFragment docFrag ) { m_doc = doc ; m_docFrag = docFrag ; } public DOMBuilder ( Document doc ) { m_doc = doc ; } public Node getRootNode ( ) { return ( null != m_docFrag ) ? ( Node ) m_docFrag : ( Node ) m_doc ; } public Node getCurrentNode ( ) { return m_currentNode ; } public java . io . Writer getWriter ( ) { return null ; } protected void append ( Node newNode ) throws org . xml . sax . SAXException { Node currentNode = m_currentNode ; if ( null != currentNode ) { currentNode . appendChild ( newNode ) ; } else if ( null != m_docFrag ) { m_docFrag . appendChild ( newNode ) ; } else { boolean ok = true ; short type = newNode . getNodeType ( ) ; if ( type == Node . TEXT_NODE ) { String data = newNode . getNodeValue ( ) ; if ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CANT_OUTPUT_TEXT_BEFORE_DOC , null ) ) ; } ok = false ; } else if ( type == Node . ELEMENT_NODE ) { if ( m_doc . getDocumentElement ( ) != null ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CANT_HAVE_MORE_THAN_ONE_ROOT , null ) ) ; } } if ( ok ) m_doc . appendChild ( newNode ) ; } } public void setDocumentLocator ( Locator locator ) { } public void startDocument ( ) throws org . xml . sax . SAXException { } public void endDocument ( ) throws org . xml . sax . SAXException { } public void startElement ( String ns , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { Element elem ; if ( ( null == ns ) || ( ns . length ( ) == 0 ) ) elem = m_doc . createElementNS ( null , name ) ; else elem = m_doc . createElementNS ( ns , name ) ; append ( elem ) ; try { int nAtts = atts . getLength ( ) ; if ( 0 != nAtts ) { for ( int i = 0 ; i < nAtts ; i ++ ) { if ( atts . getType ( i ) . equalsIgnoreCase ( "ID" ) ) setIDAttribute ( atts . getValue ( i ) , elem ) ; String attrNS = atts . getURI ( i ) ; if ( "" . equals ( attrNS ) ) attrNS = null ; String attrQName = atts . getQName ( i ) ; elem . setAttributeNS ( attrNS , attrQName , atts . getValue ( i ) ) ; } } m_elemStack . push ( elem ) ; m_currentNode = elem ; } catch ( java . lang . Exception de ) { throw new org . xml . sax . SAXException ( de ) ; } } public void endElement ( String ns , String localName , String name ) throws org . xml . sax . SAXException { m_elemStack . pop ( ) ; m_currentNode = m_elemStack . isEmpty ( ) ? null : ( Node ) m_elemStack . peek ( ) ; } public void setIDAttribute ( String id , Element elem ) { } public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; if ( m_inCData ) { cdata ( ch , start , length ) ; return ; } String s = new String ( ch , start , length ) ; Text text = m_doc . createTextNode ( s ) ; append ( text ) ; } public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m_doc . createProcessingInstruction ( "xslt-next-is-raw" , "formatter-to-dom" ) ) ; append ( m_doc . createTextNode ( s ) ) ; } public void startEntity ( String name ) throws org . xml . sax . SAXException { } public void endEntity ( String name ) throws org . xml . sax . SAXException { } public void entityReference ( String name ) throws org . xml . sax . SAXException { append ( m_doc . createEntityReference ( name ) ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) ) return ; String s = new String ( ch , start , length ) ; append ( m_doc . createTextNode ( s ) ) ; } private boolean isOutsideDocElem ( ) { return ( null == m_docFrag ) && m_elemStack . size ( ) == 0 && ( null == m_currentNode || m_currentNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { append ( m_doc . createProcessingInstruction ( target , data ) ) ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { append ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; } protected boolean m_inCData = false ; public void startCDATA ( ) throws org . xml . sax . SAXException { m_inCData = true ; } public void endCDATA ( ) throws org . xml . sax . SAXException { m_inCData = false ; } public void cdata ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m_doc . createCDATASection ( s ) ) ; } public void startDTD ( String name , String publicId , String systemId ) throws org . xml . sax . SAXException { } public void endDTD ( ) throws org . xml . sax . SAXException { } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { } } 	1	['30', '1', '0', '4', '64', '223', '2', '2', '28', '0.634482759', '460', '0.6', '0', '0', '0.2', '0', '0', '14.16666667', '5', '1.0667', '3']
package org . apache . xml . utils ; public class WrongParserException extends RuntimeException { public WrongParserException ( String message ) { super ( message ) ; } } 	1	['1', '4', '0', '0', '2', '0', '0', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . xpath . res ; import java . util . Locale ; public class XPATHErrorResources_it extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "La funzione current() non è consentita in un criterio di corrispondenza." } , { ER_CURRENT_TAKES_NO_ARGS , "La funzione current() non accetta argomenti." } , { ER_DOCUMENT_REPLACED , "L'implementazione della funzione document() è stata sostituita da org.apache.xalan.xslt.FuncDocument." } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Il contesto non ha un documento proprietario." } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() ha troppi argomenti." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() ha troppi argomenti." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() ha troppi argomenti." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() ha troppi argomenti." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() ha troppi argomenti." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() ha troppi argomenti." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() ha troppi argomenti." } , { ER_TRANSLATE_TAKES_3_ARGS , "La funzione translate() richiede tre argomenti." } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "La funzione unparsed-entity-uri richiede un argomento." } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Asse namespace non ancora implementato." } , { ER_UNKNOWN_AXIS , "Asse sconosciuto: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "Operazione di corrispondenza sconosciuta." } , { ER_INCORRECT_ARG_LENGTH , "La lunghezza argomento del test di nodo di processing-instruction() non è corretta." } , { ER_CANT_CONVERT_TO_NUMBER , "Impossibile convertire {0} in un numero." } , { ER_CANT_CONVERT_TO_NODELIST , "Impossibile convertire {0} in NodeList." } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Impossibile convertire {0} in NodeSetDTM." } , { ER_CANT_CONVERT_TO_TYPE , "Impossibile convertire {0} in tipo//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Previsto criterio di corrispondenza in getMatchScore." } , { ER_COULDNOT_GET_VAR_NAMED , "Impossibile trovare la variabile denominata {0}" } , { ER_UNKNOWN_OPCODE , "ERRORE. Codice operativo sconosciuto: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Altri token non validi: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Letterale non corretto... previste le doppie virgolette." } , { ER_EXPECTED_SINGLE_QUOTE , "Letterale non corretto... previste le virgolette singole." } , { ER_EMPTY_EXPRESSION , "Espressione vuota." } , { ER_EXPECTED_BUT_FOUND , "Previsto {0}, trovato: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "L''asserzione di programmazione non è corretta. - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "L'argomento booleano(...) non è più opzionale con 19990709 XPath draft." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Trovato ',' ma senza argomento precedente." } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Trovato ',' ma senza argomento successivo." } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'.. la sintassi [predicato]' o '.[predicato]' non è valida. Utilizzare 'self::node()[predicato]'." } , { ER_ILLEGAL_AXIS_NAME , "Nome di asse non valido: {0}" } , { ER_UNKNOWN_NODETYPE , "Tipo di nodo sconosciuto: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Il criterio letterale ({0}) deve essere tra virgolette." } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "Impossibile formattare {0} in un numero." } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Impossibile creare il collegamento XML TransformerFactory: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Errore. Impossibile trovare l'espressione di selezione xpath (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERRORE. Impossibile trovare ENDOP dopo OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Errore" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference fornito per la variabile è esterno al contesto o senza definizione.  Nome = {0}" } , { ER_AXES_NOT_ALLOWED , "Nei criteri di corrispondenza sono consentiti solo gli assi child:: e attribute::. Assi non validi = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() ha un numero di argomenti non valido." } , { ER_COUNT_TAKES_1_ARG , "La funzione di conteggio deve prendere un argomento." } , { ER_COULDNOT_FIND_FUNCTION , "Impossibile trovare la funzione: {0}" } , { ER_UNSUPPORTED_ENCODING , "Codifica non supportata: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Problema in DTM in getNextSibling... Tentativo di recupero in corso." } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Errore di programmazione: impossibile scrivere in EmptyNodeList." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory non è supportato da XPathContext." } , { ER_PREFIX_MUST_RESOLVE , "Il prefisso deve risolvere in namespace: {0}" } , { ER_PARSE_NOT_SUPPORTED , "analisi (sorgente InputSource) non supportata in XPathContext. Impossibile aprire {0}" } , { ER_SAX_API_NOT_HANDLED , "Caratteri SAX API (char ch[]... non gestiti da DTM." } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... non è gestito da DTM." } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison non può gestire nodi di tipo {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper non può gestire nodi di tipo {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Errore DOM2Helper.parse: SystemID - {0} linea - {1}" } , { ER_XERCES_PARSE_ERROR , "Errore DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Rilevato surrogato di UTF-16 non valido: {0} ?" } , { ER_OIERROR , "Errore IO" } , { ER_CANNOT_CREATE_URL , "Impossibile creare URL per: {0}" } , { ER_XPATH_READOBJECT , "In XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "token di funzione non trovato." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Impossibile gestire il tipo XPath: {0}" } , { ER_NODESET_NOT_MUTABLE , "Questo NodeSet non è mutabile" } , { ER_NODESETDTM_NOT_MUTABLE , "Questo NodeSetDTM non è mutabile" } , { ER_VAR_NOT_RESOLVABLE , "Variabile non risolvibile: {0}" } , { ER_NULL_ERROR_HANDLER , "Errore gestore nullo" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Asserzione di programmazione: codice operativo sconosciuto: {0}" } , { ER_ZERO_OR_ONE , "0 o 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() non supportato da XRTreeFragSelectWrapper" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() non supportato da XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() non supportato per XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Impossibile trovare la variabile denominata {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars non può prendere una stringa per un argomento" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "L'argomento FastStringBuffer non può essere nullo" } , { ER_TWO_OR_THREE , "2 o 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Accesso alla variabile prima della delimitazione." } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB non può avere una stringa per argomento." } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Errore! Impostazione radice walker a zero." } , { ER_NODESETDTM_CANNOT_ITERATE , "Questo NodeSetDTM non è in grado di eseguire iterazione in un nodo precedente." } , { ER_NODESET_CANNOT_ITERATE , "Questo NodeSet non è in grado di eseguire iterazione in un nodo precedente." } , { ER_NODESETDTM_CANNOT_INDEX , "Questo NodeSetDTM non è in grado di indicizzare o calcolare le funzioni." } , { ER_NODESET_CANNOT_INDEX , "Questo NodeSet non è in grado di indicizzare o calcolare le funzioni." } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Impossibile richiamare setShouldCacheNodes dopo aver richiamato nextNode." } , { ER_ONLY_ALLOWS , "{0} consente solo argomenti {1}" } , { ER_UNKNOWN_STEP , "Conferma del programmatore in getNextStepPos: stepType sconosciuto: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Atteso percorso ubicazione relativo dopo il token '/' o '//'." } , { ER_EXPECTED_LOC_PATH , "Atteso percorso ubicazione, ma è stato incontrato il token seguente:  {0}" } , { ER_EXPECTED_LOC_STEP , "Atteso step ubicazione dopo il token '/' o '//'." } , { ER_EXPECTED_NODE_TEST , "Atteso test nodo corrispondente a NCName:* o QName." } , { ER_EXPECTED_STEP_PATTERN , "Atteso pattern step, ma è stato incontrato '/'." } , { ER_EXPECTED_REL_PATH_PATTERN , "Atteso pattern percorso relativo." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Impossibile convertire {0} in booleano." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Impossibile convertire {0} in nodo singolo. Questo getter si applica ai tipi ANY_UNORDERED_NODE_TYPE e FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Impossibile recuperare lunghezza snapshot in tipo: {0}. Questo getter si applica ai tipi UNORDERED_NODE_SNAPSHOT_TYPE e ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Impossibile eseguire iterazione su tipo non iterativo: {0}" } , { ER_DOC_MUTATED , "Documento modificato dalla restituzione del risultato. Iteratore non valido." } , { ER_INVALID_XPATH_TYPE , "Argomento tipo XPath non valido: {0}" } , { ER_EMPTY_XPATH_RESULT , "Oggetto risultato XPath vuoto" } , { ER_INCOMPATIBLE_TYPES , "Il tipo restituito: {0} non può essere forzato nel tipo specificato: {1}" } , { ER_NULL_RESOLVER , "Impossibile risolvere il prefisso con risolutore prefisso nullo." } , { ER_CANT_CONVERT_TO_STRING , "Impossibile convertire {0} in stringa." } , { ER_NON_SNAPSHOT_TYPE , "Impossibile richiamare snapshotItem su tipo: {0}. Questo metodo è valido per i tipi UNORDERED_NODE_SNAPSHOT_TYPE e ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Il nodo contesto non appartiene al documento collegato a questo XPathEvaluator." } , { ER_WRONG_NODETYPE , "Il tipo di nodo contesto non è supportato." } , { ER_XPATH_ERROR , "Errore sconosciuto in XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "Il nome locale nella funzione format-number non è ancora gestito." } , { WG_PROPERTY_NOT_SUPPORTED , "Proprietà XSL non supportata: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Nulla da fare correntemente con namespace {0} in proprietà: {1}" } , { WG_SECURITY_EXCEPTION , "Generata SecurityException al tentativo di accedere alle proprietà di sistema XSL: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Sintassi precedente: quo(...) non è più definita in XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath deve avere un oggetto derivato per implementare nodeTest." } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Token di funzione non trovato." } , { WG_COULDNOT_FIND_FUNCTION , "Impossibile trovare la funzione: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossibile creare un URL da: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "L'opzione -E non è supportata per il parser DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference fornita per la variabile è esterna al contesto o senza definizione.  Nome = {0}" } , { WG_UNSUPPORTED_ENCODING , "Codifica non supportata: {0}" } , { "ui_language" , "it" } , { "help_language" , "it" } , { "language" , "it" } , { "BAD_CODE" , "Il parametro di createMessage è esterno ai limiti" } , { "FORMAT_FAILED" , "Eccezione generata durante la chiamata di messageFormat" } , { "version" , ">>>>>>> Xalan Versione " } , { "version2" , "<<<<<<<" } , { "yes" , "sì" } , { "line" , "Linea //" } , { "column" , "Colonna //" } , { "xsldone" , "XSLProcessor: done" } , { "xpath_option" , "xpath options: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select espressione xpath]" } , { "optionMatch" , "   [-match match pattern (per la diagnostica di corrispondenza)]" } , { "optionAnyExpr" , "O solo un'espressione xpath per eseguire un dump di diagnostica" } , { "noParsermsg1" , "Processo XSL non riuscito." } , { "noParsermsg2" , "** Impossibile trovare il parser **" } , { "noParsermsg3" , "Verificare il classpath." } , { "noParsermsg4" , "Se non si dispone del parser XML IBM per Java, scaricarlo da" } , { "noParsermsg5" , "AlphaWorks IBM: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//errore" ; public static final String ERROR_HEADER = "Errore: " ; public static final String WARNING_HEADER = "Avvertenza: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['4', '4', '0', '1', '11', '4', '0', '1', '2', '1.285714286', '1903', '0', '0', '0.953488372', '0.5', '2', '2', '471.25', '2', '0.75', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . ArrayList ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFNONNULL ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . L2I ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MatchGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeCounterGenerator ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Number extends Instruction implements Closure { private static final int LEVEL_SINGLE = 0 ; private static final int LEVEL_MULTIPLE = 1 ; private static final int LEVEL_ANY = 2 ; static final private String [ ] ClassNames = { "org.apache.xalan.xsltc.dom.SingleNodeCounter" , "org.apache.xalan.xsltc.dom.MultipleNodeCounter" , "org.apache.xalan.xsltc.dom.AnyNodeCounter" } ; static final private String [ ] FieldNames = { "___single_node_counter" , "___multiple_node_counter" , "___any_node_counter" } ; private Pattern _from = null ; private Pattern _count = null ; private Expression _value = null ; private AttributeValueTemplate _lang = null ; private AttributeValueTemplate _format = null ; private AttributeValueTemplate _letterValue = null ; private AttributeValueTemplate _groupingSeparator = null ; private AttributeValueTemplate _groupingSize = null ; private int _level = LEVEL_SINGLE ; private boolean _formatNeeded = false ; private String _className = null ; private ArrayList _closureVars = null ; public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { return null ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; } } public void parseContents ( Parser parser ) { final int count = _attributes . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final String name = _attributes . getQName ( i ) ; final String value = _attributes . getValue ( i ) ; if ( name . equals ( "value" ) ) { _value = parser . parseExpression ( this , name , null ) ; } else if ( name . equals ( "count" ) ) { _count = parser . parsePattern ( this , name , null ) ; } else if ( name . equals ( "from" ) ) { _from = parser . parsePattern ( this , name , null ) ; } else if ( name . equals ( "level" ) ) { if ( value . equals ( "single" ) ) { _level = LEVEL_SINGLE ; } else if ( value . equals ( "multiple" ) ) { _level = LEVEL_MULTIPLE ; } else if ( value . equals ( "any" ) ) { _level = LEVEL_ANY ; } } else if ( name . equals ( "format" ) ) { _format = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "lang" ) ) { _lang = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "letter-value" ) ) { _letterValue = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "grouping-separator" ) ) { _groupingSeparator = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "grouping-size" ) ) { _groupingSize = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _value != null ) { Type tvalue = _value . typeCheck ( stable ) ; if ( tvalue instanceof RealType == false ) { _value = new CastExpr ( _value , Type . Real ) ; } } if ( _count != null ) { _count . typeCheck ( stable ) ; } if ( _from != null ) { _from . typeCheck ( stable ) ; } if ( _format != null ) { _format . typeCheck ( stable ) ; } if ( _lang != null ) { _lang . typeCheck ( stable ) ; } if ( _letterValue != null ) { _letterValue . typeCheck ( stable ) ; } if ( _groupingSeparator != null ) { _groupingSeparator . typeCheck ( stable ) ; } if ( _groupingSize != null ) { _groupingSize . typeCheck ( stable ) ; } return Type . Void ; } public boolean hasValue ( ) { return _value != null ; } public boolean isDefault ( ) { return _from == null && _count == null ; } private void compileDefault ( ClassGenerator classGen , MethodGenerator methodGen ) { int index ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; int [ ] fieldIndexes = getXSLTC ( ) . getNumberFieldIndexes ( ) ; if ( fieldIndexes [ _level ] == - 1 ) { Field defaultNode = new Field ( ACC_PRIVATE , cpg . addUtf8 ( FieldNames [ _level ] ) , cpg . addUtf8 ( NODE_COUNTER_SIG ) , null , cpg . getConstantPool ( ) ) ; classGen . addField ( defaultNode ) ; fieldIndexes [ _level ] = cpg . addFieldref ( classGen . getClassName ( ) , FieldNames [ _level ] , NODE_COUNTER_SIG ) ; } il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( fieldIndexes [ _level ] ) ) ; final BranchHandle ifBlock1 = il . append ( new IFNONNULL ( null ) ) ; index = cpg . addMethodref ( ClassNames [ _level ] , "getDefaultNodeCounter" , "(" + TRANSLET_INTF_SIG + DOM_INTF_SIG + NODE_ITERATOR_SIG + ")" + NODE_COUNTER_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( SWAP ) ; il . append ( new PUTFIELD ( fieldIndexes [ _level ] ) ) ; final BranchHandle ifBlock2 = il . append ( new GOTO ( null ) ) ; ifBlock1 . setTarget ( il . append ( classGen . loadTranslet ( ) ) ) ; il . append ( new GETFIELD ( fieldIndexes [ _level ] ) ) ; ifBlock2 . setTarget ( il . append ( NOP ) ) ; } private void compileConstructor ( ClassGenerator classGen ) { MethodGenerator cons ; final InstructionList il = new InstructionList ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; cons = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( TRANSLET_INTF_SIG ) , Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) } , new String [ ] { "dom" , "translet" , "iterator" } , "<init>" , _className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ALOAD_1 ) ; il . append ( ALOAD_2 ) ; il . append ( new ALOAD ( 3 ) ) ; int index = cpg . addMethodref ( ClassNames [ _level ] , "<init>" , "(" + TRANSLET_INTF_SIG + DOM_INTF_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new INVOKESPECIAL ( index ) ) ; il . append ( RETURN ) ; cons . stripAttributes ( true ) ; cons . setMaxLocals ( ) ; cons . setMaxStack ( ) ; classGen . addMethod ( cons . getMethod ( ) ) ; } private void compileLocals ( NodeCounterGenerator nodeCounterGen , MatchGenerator matchGen , InstructionList il ) { int field ; LocalVariableGen local ; ConstantPoolGen cpg = nodeCounterGen . getConstantPool ( ) ; local = matchGen . addLocalVariable ( "iterator" , Util . getJCRefType ( NODE_ITERATOR_SIG ) , null , null ) ; field = cpg . addFieldref ( NODE_COUNTER , "_iterator" , ITERATOR_FIELD_SIG ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( field ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; matchGen . setIteratorIndex ( local . getIndex ( ) ) ; local = matchGen . addLocalVariable ( "translet" , Util . getJCRefType ( TRANSLET_SIG ) , null , null ) ; field = cpg . addFieldref ( NODE_COUNTER , "_translet" , "Lorg/apache/xalan/xsltc/Translet;" ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( field ) ) ; il . append ( new CHECKCAST ( cpg . addClass ( TRANSLET_CLASS ) ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; nodeCounterGen . setTransletIndex ( local . getIndex ( ) ) ; local = matchGen . addLocalVariable ( "document" , Util . getJCRefType ( DOM_INTF_SIG ) , null , null ) ; field = cpg . addFieldref ( _className , "_document" , DOM_INTF_SIG ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( field ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; matchGen . setDomIndex ( local . getIndex ( ) ) ; } private void compilePatterns ( ClassGenerator classGen , MethodGenerator methodGen ) { int current ; int field ; LocalVariableGen local ; MatchGenerator matchGen ; NodeCounterGenerator nodeCounterGen ; _className = getXSLTC ( ) . getHelperClassName ( ) ; nodeCounterGen = new NodeCounterGenerator ( _className , ClassNames [ _level ] , toString ( ) , ACC_PUBLIC | ACC_SUPER , null , classGen . getStylesheet ( ) ) ; InstructionList il = null ; ConstantPoolGen cpg = nodeCounterGen . getConstantPool ( ) ; final int closureLen = ( _closureVars == null ) ? 0 : _closureVars . size ( ) ; for ( int i = 0 ; i < closureLen ; i ++ ) { VariableBase var = ( ( VariableRefBase ) _closureVars . get ( i ) ) . getVariable ( ) ; nodeCounterGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; } compileConstructor ( nodeCounterGen ) ; if ( _from != null ) { il = new InstructionList ( ) ; matchGen = new MatchGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , } , new String [ ] { "node" , } , "matchesFrom" , _className , il , cpg ) ; compileLocals ( nodeCounterGen , matchGen , il ) ; il . append ( matchGen . loadContextNode ( ) ) ; _from . translate ( nodeCounterGen , matchGen ) ; _from . synthesize ( nodeCounterGen , matchGen ) ; il . append ( IRETURN ) ; matchGen . stripAttributes ( true ) ; matchGen . setMaxLocals ( ) ; matchGen . setMaxStack ( ) ; matchGen . removeNOPs ( ) ; nodeCounterGen . addMethod ( matchGen . getMethod ( ) ) ; } if ( _count != null ) { il = new InstructionList ( ) ; matchGen = new MatchGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , } , new String [ ] { "node" , } , "matchesCount" , _className , il , cpg ) ; compileLocals ( nodeCounterGen , matchGen , il ) ; il . append ( matchGen . loadContextNode ( ) ) ; _count . translate ( nodeCounterGen , matchGen ) ; _count . synthesize ( nodeCounterGen , matchGen ) ; il . append ( IRETURN ) ; matchGen . stripAttributes ( true ) ; matchGen . setMaxLocals ( ) ; matchGen . setMaxStack ( ) ; matchGen . removeNOPs ( ) ; nodeCounterGen . addMethod ( matchGen . getMethod ( ) ) ; } getXSLTC ( ) . dumpClass ( nodeCounterGen . getJavaClass ( ) ) ; cpg = classGen . getConstantPool ( ) ; il = methodGen . getInstructionList ( ) ; final int index = cpg . addMethodref ( _className , "<init>" , "(" + TRANSLET_INTF_SIG + DOM_INTF_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; for ( int i = 0 ; i < closureLen ; i ++ ) { final VariableRefBase varRef = ( VariableRefBase ) _closureVars . get ( i ) ; final VariableBase var = varRef . getVariable ( ) ; final Type varType = var . getType ( ) ; il . append ( DUP ) ; il . append ( var . loadInstruction ( ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( _className , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { int index ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( hasValue ( ) ) { compileDefault ( classGen , methodGen ) ; _value . translate ( classGen , methodGen ) ; index = cpg . addMethodref ( MATH_CLASS , "round" , "(D)J" ) ; il . append ( new INVOKESTATIC ( index ) ) ; il . append ( new L2I ( ) ) ; index = cpg . addMethodref ( NODE_COUNTER , "setValue" , "(I)" + NODE_COUNTER_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } else if ( isDefault ( ) ) { compileDefault ( classGen , methodGen ) ; } else { compilePatterns ( classGen , methodGen ) ; } if ( ! hasValue ( ) ) { il . append ( methodGen . loadContextNode ( ) ) ; index = cpg . addMethodref ( NODE_COUNTER , SET_START_NODE , "(I)" + NODE_COUNTER_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } if ( _formatNeeded ) { if ( _format != null ) { _format . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , "1" ) ) ; } if ( _lang != null ) { _lang . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , "en" ) ) ; } if ( _letterValue != null ) { _letterValue . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } if ( _groupingSeparator != null ) { _groupingSeparator . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } if ( _groupingSize != null ) { _groupingSize . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , "0" ) ) ; } index = cpg . addMethodref ( NODE_COUNTER , "getCounter" , "(" + STRING_SIG + STRING_SIG + STRING_SIG + STRING_SIG + STRING_SIG + ")" + STRING_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } else { index = cpg . addMethodref ( NODE_COUNTER , "setDefaultFormatting" , "()" + NODE_COUNTER_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; index = cpg . addMethodref ( NODE_COUNTER , "getCounter" , "()" + STRING_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } il . append ( methodGen . loadHandler ( ) ) ; index = cpg . addMethodref ( TRANSLET_CLASS , CHARACTERSW , CHARACTERSW_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } } 	1	['15', '3', '0', '52', '104', '23', '1', '52', '9', '0.798319328', '1308', '1', '8', '0.811594203', '0.214285714', '2', '3', '85.06666667', '14', '3.1333', '1']
package org . apache . xpath . res ; public class XPATHErrorResources_ko extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "current() 함수는 일치 패턴에 허용되지 않습니다." } , { ER_CURRENT_TAKES_NO_ARGS , "current() 함수에는 인자가 없습니다!" } , { ER_DOCUMENT_REPLACED , "document() 함수 구현은 org.apache.xalan.xslt.FuncDocument로 대체되었습니다!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "컨텍스트에 소유자 문서가 없습니다." } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name()의 인자가 너무 많습니다." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri()의 인자가 너무 많습니다." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space()의 인자가 너무 많습니다." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number()의 인자가 너무 많습니다." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name()의 인자가 너무 많습니다." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string()의 인자가 너무 많습니다." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length()의 인자가 너무 많습니다." } , { ER_TRANSLATE_TAKES_3_ARGS , "translate() 함수에는 세 개의 인자를 사용합니다!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri 함수는 하나의 인자만을 사용합니다!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "이름 공간 축이 아직 구현되지 않았습니다!" } , { ER_UNKNOWN_AXIS , "{0}은(는) 알 수 없는 축입니다." } , { ER_UNKNOWN_MATCH_OPERATION , "알 수 없는 일치 연산입니다!" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() 노드 검사의 인자 길이가 올바르지 않습니다!" } , { ER_CANT_CONVERT_TO_NUMBER , "{0}을(를) 숫자로 변환할 수 없습니다." } , { ER_CANT_CONVERT_TO_NODELIST , "{0}을(를) NodeList로 변환할 수 없습니다!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0}을(를) NodeSetDTM으로 변환할 수 없습니다!" } , { ER_CANT_CONVERT_TO_TYPE , "{0}을(를) type//{1}(으)로 변환할 수 없습니다. " } , { ER_EXPECTED_MATCH_PATTERN , "getMatchScore에 일치 패턴이 있어야 합니다!" } , { ER_COULDNOT_GET_VAR_NAMED , "{0} 변수를 가져올 수 없습니다. " } , { ER_UNKNOWN_OPCODE , "오류! 알 수 없는 연산 코드: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "잘못된 토큰: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "리터럴의 인용부호가 잘못되었습니다... 큰따옴표가 나와야 합니다!" } , { ER_EXPECTED_SINGLE_QUOTE , "리터럴의 인용부호가 잘못되었습니다... 단일 인용부호가 나와야 합니다!" } , { ER_EMPTY_EXPRESSION , "표현식이 비어 있습니다!" } , { ER_EXPECTED_BUT_FOUND , "{0}을(를) 예상했지만 {1}을(를) 찾았습니다." } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "프로그래머 명제가 올바르지 않습니다! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "부울(...) 인자는 19990709 XPath 드래프트와 함께 더 이상 선택 인자가 아닙니다." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "','를 찾았으나 선행 인자가 아닙니다!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "','를 찾았으나 후미 인자가 아닙니다!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' 또는 '.[predicate]'는 잘못된 구문입니다. 대신 'self::node()[predicate]'을 사용하십시오. " } , { ER_ILLEGAL_AXIS_NAME , "잘못된 축 이름: {0}" } , { ER_UNKNOWN_NODETYPE , "알 수 없는 노드 유형: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "패턴 리터럴({0})에 인용부호가 있어야 합니다!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0}을(를) 숫자로 포맷할 수 없습니다!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "XML TransformerFactory Liaison {0}을(를) 작성할 수 없습니다." } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "오류! xpath 선택 표현식(-select)을 찾을 수 없습니다." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "오류! OP_LOCATIONPATH 다음에 ENDOP를 찾을 수 없습니다.   " } , { ER_ERROR_OCCURED , "오류가 발생했습니다!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference가 컨텍스트를 벗어났거나 정의되지 않은 변수에 지정되었습니다! 이름 = {0}" } , { ER_AXES_NOT_ALLOWED , "일치 패턴에서는 하나의 child:: 및 attribute:: 축이 허용됩니다. 위반 축 = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key()의 인자 수가 잘못되었습니다." } , { ER_COUNT_TAKES_1_ARG , "카운트 함수는 하나의 인자만을 사용합니다!" } , { ER_COULDNOT_FIND_FUNCTION , "함수 {0}을(를) 찾을 수 없습니다." } , { ER_UNSUPPORTED_ENCODING , "지원되지 않는 코드화: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling의 DTM에 문제가 발생했습니다... 복구를 시도 중입니다." } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "프로그래머 오류: EmptyNodeList에는 쓸 수 없습니다." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory는 XPathContext에서 지원되지 않습니다!" } , { ER_PREFIX_MUST_RESOLVE , "접두어가 이름 공간 {0}으로(로) 결정되어야 합니다." } , { ER_PARSE_NOT_SUPPORTED , "구문 분석(InputSource 소스)은 XPathContext에서 지원되지 않습니다! {0}을(를) 열 수 없습니다.  " } , { ER_SAX_API_NOT_HANDLED , "SAX API 문자(char ch[]...는 DTM에 의해 처리되지 않습니다!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]...는 DTM에 의해 처리되지 않습니다!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison은 {0} 유형의 노드를 처리할 수 없습니다. " } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper는 {0} 유형의 노드를 처리할 수 없습니다.   " } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse 오류: SystemID - {0} 행 - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse 오류" } , { ER_INVALID_UTF16_SURROGATE , "잘못된 UTF-16 대리가 감지되었습니다: {0} ?" } , { ER_OIERROR , "IO 오류" } , { ER_CANNOT_CREATE_URL , "{0}에 대한 url을 작성할 수 없습니다.     " } , { ER_XPATH_READOBJECT , "XPath.readObject에: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "기능 토큰을 찾을 수 없습니다." } , { ER_CANNOT_DEAL_XPATH_TYPE , "XPath 유형을 처리할 수 없습니다: {0}    " } , { ER_NODESET_NOT_MUTABLE , "NodeSet은 변경할 수 없습니다" } , { ER_NODESETDTM_NOT_MUTABLE , "NodeSetDTM은 변경할 수 없습니다" } , { ER_VAR_NOT_RESOLVABLE , "변수를 결정할 수 없습니다: {0}" } , { ER_NULL_ERROR_HANDLER , "오류 처리기가 널입니다" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "프로그래머 명제: 알 수 없는 opcode: {0}" } , { ER_ZERO_OR_ONE , "0 또는 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper가 rtf()를 지원하지 않습니다" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper가 asNodeIterator()를 지원하지 않습니다" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb()가 XStringForChars에 대해 지원되지 않습니다" } , { ER_COULD_NOT_FIND_VAR , "이름이 {0}인 변수를 찾을 수 없습니다.   " } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars가 인자에 대한 문자열을 가져올 수 없습니다." } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer 인자는 널이 될 수 없습니다." } , { ER_TWO_OR_THREE , "2 또는 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "변수가 바운딩되기 전에 액세스되었습니다." } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB가 인자에 대한 문자열을 가져올 수 없습니다." } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! 오류! walker의 루트를 널로 설정했습니다!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "이 NodeSetDTM이 이전 노드로 반복할 수 없습니다!" } , { ER_NODESET_CANNOT_ITERATE , "이 NodeSet이 이전 노드로 반복할 수 없습니다!" } , { ER_NODESETDTM_CANNOT_INDEX , "이 NodeSetDTM이 인덱스 또는 카운팅 기능을 수행할 수 없습니다!" } , { ER_NODESET_CANNOT_INDEX , "이 NodeSet이 인덱스 또는 카운팅 기능을 수행할 수 없습니다!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "nextNode가 호출된 다음에 setShouldCacheNodeshas를 호출할 수 없습니다!" } , { ER_ONLY_ALLOWS , "{0}은(는) {1} 인자만 허용합니다." } , { ER_UNKNOWN_STEP , "getNextStepPos에서 프로그래머 명제: 알 수 없는 stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "상대 위치 경로는 '/' 또는 '//' 뒤에 나와야 합니다." } , { ER_EXPECTED_LOC_PATH , "상대 위치 경로가 와야 하지만 대신 다음 토큰이 발견되었습니다.:  {0}" } , { ER_EXPECTED_LOC_STEP , "위치 단계는 '/' 또는 '//' 다음에 나와야 합니다." } , { ER_EXPECTED_NODE_TEST , "NCName:* 또는 QName과 일치하는 노드 테스트가 와야 합니다." } , { ER_EXPECTED_STEP_PATTERN , "단계 패턴이 와야 하지만 대신 '/'를 발견했습니다." } , { ER_EXPECTED_REL_PATH_PATTERN , "상대 경로 패턴이 와야 합니다." } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0}을(를) 부울로 변환할 수 없습니다." } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0}을(를) 단일 노드로 변환할 수 없습니다. 이 getter는 ANY_UNORDERED_NODE_TYPE 유형과 FIRST_ORDERED_NODE_TYPE 유형에 적용됩니다." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "유형 {0}에서 스냅샷 길이를 가져올 수 없습니다. 이 getter는 UNORDERED_NODE_SNAPSHOT_TYPE 유형과 ORDERED_NODE_SNAPSHOT_TYPE 유형에 적용됩니다." } , { ER_NON_ITERATOR_TYPE , "비반복 유형 {0}에 대해 반복할 수 없습니다." } , { ER_DOC_MUTATED , "결과 이후로 변경된 문서가 반환되었습니다. 반복자가 잘못되었습니다." } , { ER_INVALID_XPATH_TYPE , "잘못된 XPath 유형 인자: {0}" } , { ER_EMPTY_XPATH_RESULT , "빈 XPath 결과 객체" } , { ER_INCOMPATIBLE_TYPES , "반환된 유형: {0}을(를) 지정한 유형으로 강제 변환할 수 없습니다: {1}" } , { ER_NULL_RESOLVER , "널 접두어 해결자로 접두어를 해결할 수 없습니다." } , { ER_CANT_CONVERT_TO_STRING , "{0}을(를) 문자열로 변환할 수 없습니다." } , { ER_NON_SNAPSHOT_TYPE , "유형 {0}에서 snapshotItem을 호출할 수 없습니다. 이 메소드는 UNORDERED_NODE_SNAPSHOT_TYPE 유형과 ORDERED_NODE_SNAPSHOT_TYPE 유형에 적용됩니다." } , { ER_WRONG_DOCUMENT , "컨텍스트 노드가 이 XPathEvaluator에 바운딩된 문서에 속하지 않습니다." } , { ER_WRONG_NODETYPE , "컨텍스트 노드 유형이 지원되지 않습니다." } , { ER_XPATH_ERROR , "XPath에 알 수 없는 오류가 발생했습니다." } , { WG_LOCALE_NAME_NOT_HANDLED , "format-number 기능의 로케일 이름이 아직 처리되지 않았습니다." } , { WG_PROPERTY_NOT_SUPPORTED , "XSL 특성이 지원되지 않습니다: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "특성 {1}의 이름 공간 {0}에 아무 것도 수행하지 마십시오." } , { WG_SECURITY_EXCEPTION , "XSL 시스템 특성 {0}에 액세스하려고 할 때 SecurityException이 발생했습니다. " } , { WG_QUO_NO_LONGER_DEFINED , "이전 구문: quo(...)는 더 이상 XPath에서 정의되지 않습니다." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath는 nodeTest 구현을 위해 파생된 객체가 필요합니다!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "기능 토큰을 찾을 수 없습니다." } , { WG_COULDNOT_FIND_FUNCTION , "함수 {0}을(를) 찾을 수 없습니다." } , { WG_CANNOT_MAKE_URL_FROM , "{0}에서 URL을 작성할 수 없습니다." } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "-E 옵션은 DTM 구문 분석기에 대해 지원되지 않습니다." } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference가 컨텍스트를 벗어났거나 정의되지 않은 변수에 지정되었습니다! 이름 = {0}" } , { WG_UNSUPPORTED_ENCODING , "지원되지 않는 코드화: {0}" } , { "ui_language" , "ko" } , { "help_language" , "ko" } , { "language" , "ko" } , { "BAD_CODE" , "createMessage의 매개변수가 바운드를 벗어났습니다." } , { "FORMAT_FAILED" , "messageFormat 호출 시 예외 발생" } , { "version" , ">>>>>>> Xalan 버전 " } , { "version2" , "<<<<<<<" } , { "yes" , "예" } , { "line" , "행 //" } , { "column" , "열 //" } , { "xsldone" , "XSLProcessor: 완료" } , { "xpath_option" , "xpath 옵션: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath expression]" } , { "optionMatch" , "   [-match 일치 패턴 (일치 진단에 대한)]" } , { "optionAnyExpr" , "또는 xpath 표현식이 진단 덤프를 수행합니다." } , { "noParsermsg1" , "XSL 프로세스가 성공하지 못했습니다." } , { "noParsermsg2" , "** 구문 분석기를 찾을 수 없습니다 **" } , { "noParsermsg3" , "클래스 경로를 확인하십시오." } , { "noParsermsg4" , "Java용 IBM XML 구문 분석기가 없는 경우 다음에서 다운로드할 수 있습니다." } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "오류: " ; public static final String WARNING_HEADER = "경고: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.428571429', '1872', '0', '0', '0.976190476', '1', '0', '0', '618.3333333', '1', '0.3333', '1']
package org . apache . xalan . templates ; import java . text . DecimalFormatSymbols ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionNamespacesManager ; import org . apache . xalan . processor . XSLTSchema ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . ref . ExpandedNameTable ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; public class StylesheetRoot extends StylesheetComposed implements java . io . Serializable , Templates { public StylesheetRoot ( ErrorListener errorListener ) throws TransformerConfigurationException { super ( null ) ; setStylesheetRoot ( this ) ; try { m_selectDefault = new XPath ( "node()" , this , this , XPath . SELECT , errorListener ) ; initDefaultRule ( errorListener ) ; } catch ( TransformerException se ) { throw new TransformerConfigurationException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_INIT_DEFAULT_TEMPLATES , null ) , se ) ; } } private Hashtable m_availElems ; public StylesheetRoot ( XSLTSchema schema , ErrorListener listener ) throws TransformerConfigurationException { this ( listener ) ; m_availElems = schema . getElemsAvailable ( ) ; } public boolean isRoot ( ) { return true ; } public Hashtable getAvailableElements ( ) { return m_availElems ; } private ExtensionNamespacesManager m_extNsMgr = null ; public ExtensionNamespacesManager getExtensionNamespacesManager ( ) { if ( m_extNsMgr == null ) m_extNsMgr = new ExtensionNamespacesManager ( ) ; return m_extNsMgr ; } public Vector getExtensions ( ) { return m_extNsMgr != null ? m_extNsMgr . getExtensions ( ) : null ; } public Transformer newTransformer ( ) { return new TransformerImpl ( this ) ; } public Properties getDefaultOutputProps ( ) { return m_outputProperties . getProperties ( ) ; } public Properties getOutputProperties ( ) { return ( Properties ) getDefaultOutputProps ( ) . clone ( ) ; } public void recompose ( ) throws TransformerException { Vector recomposableElements = new Vector ( ) ; if ( null == m_globalImportList ) { Vector importList = new Vector ( ) ; addImports ( this , true , importList ) ; m_globalImportList = new StylesheetComposed [ importList . size ( ) ] ; for ( int i = 0 , j = importList . size ( ) - 1 ; i < importList . size ( ) ; i ++ ) { m_globalImportList [ j ] = ( StylesheetComposed ) importList . elementAt ( i ) ; m_globalImportList [ j ] . recomposeIncludes ( m_globalImportList [ j ] ) ; m_globalImportList [ j -- ] . recomposeImports ( ) ; } } int n = getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { StylesheetComposed imported = getGlobalImport ( i ) ; imported . recompose ( recomposableElements ) ; } QuickSort2 ( recomposableElements , 0 , recomposableElements . size ( ) - 1 ) ; m_outputProperties = new OutputProperties ( org . apache . xml . serializer . Method . UNKNOWN ) ; m_attrSets = new Hashtable ( ) ; m_decimalFormatSymbols = new Hashtable ( ) ; m_keyDecls = new Vector ( ) ; m_namespaceAliasComposed = new Hashtable ( ) ; m_templateList = new TemplateList ( ) ; m_variables = new Vector ( ) ; for ( int i = recomposableElements . size ( ) - 1 ; i >= 0 ; i -- ) ( ( ElemTemplateElement ) recomposableElements . elementAt ( i ) ) . recompose ( this ) ; initComposeState ( ) ; m_templateList . compose ( this ) ; m_outputProperties . compose ( this ) ; m_outputProperties . endCompose ( this ) ; n = getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { StylesheetComposed imported = this . getGlobalImport ( i ) ; int includedCount = imported . getIncludeCountComposed ( ) ; for ( int j = - 1 ; j < includedCount ; j ++ ) { Stylesheet included = imported . getIncludeComposed ( j ) ; composeTemplates ( included ) ; } } if ( m_extNsMgr != null ) m_extNsMgr . registerUnregisteredNamespaces ( ) ; clearComposeState ( ) ; } void composeTemplates ( ElemTemplateElement templ ) throws TransformerException { templ . compose ( this ) ; for ( ElemTemplateElement child = templ . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { composeTemplates ( child ) ; } templ . endCompose ( this ) ; } private StylesheetComposed [ ] m_globalImportList ; protected void addImports ( Stylesheet stylesheet , boolean addToList , Vector importList ) { int n = stylesheet . getImportCount ( ) ; if ( n > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { Stylesheet imported = stylesheet . getImport ( i ) ; addImports ( imported , true , importList ) ; } } n = stylesheet . getIncludeCount ( ) ; if ( n > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { Stylesheet included = stylesheet . getInclude ( i ) ; addImports ( included , false , importList ) ; } } if ( addToList ) importList . addElement ( stylesheet ) ; } public StylesheetComposed getGlobalImport ( int i ) { return m_globalImportList [ i ] ; } public int getGlobalImportCount ( ) { return ( m_globalImportList != null ) ? m_globalImportList . length : 1 ; } public int getImportNumber ( StylesheetComposed sheet ) { if ( this == sheet ) return 0 ; int n = getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( sheet == getGlobalImport ( i ) ) return i ; } return - 1 ; } private OutputProperties m_outputProperties ; void recomposeOutput ( OutputProperties oprops ) throws TransformerException { m_outputProperties . copyFrom ( oprops ) ; } public OutputProperties getOutputComposed ( ) { return m_outputProperties ; } private boolean m_outputMethodSet = false ; public boolean isOutputMethodSet ( ) { return m_outputMethodSet ; } private Hashtable m_attrSets ; void recomposeAttributeSets ( ElemAttributeSet attrSet ) { Vector attrSetList = ( Vector ) m_attrSets . get ( attrSet . getName ( ) ) ; if ( null == attrSetList ) { attrSetList = new Vector ( ) ; m_attrSets . put ( attrSet . getName ( ) , attrSetList ) ; } attrSetList . addElement ( attrSet ) ; } public Vector getAttributeSetComposed ( QName name ) throws ArrayIndexOutOfBoundsException { return ( Vector ) m_attrSets . get ( name ) ; } private Hashtable m_decimalFormatSymbols ; void recomposeDecimalFormats ( DecimalFormatProperties dfp ) { DecimalFormatSymbols oldDfs = ( DecimalFormatSymbols ) m_decimalFormatSymbols . get ( dfp . getName ( ) ) ; if ( null == oldDfs ) { m_decimalFormatSymbols . put ( dfp . getName ( ) , dfp . getDecimalFormatSymbols ( ) ) ; } else if ( ! dfp . getDecimalFormatSymbols ( ) . equals ( oldDfs ) ) { String themsg ; if ( dfp . getName ( ) . equals ( new QName ( "" ) ) ) { themsg = XSLMessages . createWarning ( XSLTErrorResources . WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , new Object [ 0 ] ) ; } else { themsg = XSLMessages . createWarning ( XSLTErrorResources . WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , new Object [ ] { dfp . getName ( ) } ) ; } error ( themsg ) ; } } public DecimalFormatSymbols getDecimalFormatComposed ( QName name ) { return ( DecimalFormatSymbols ) m_decimalFormatSymbols . get ( name ) ; } private Vector m_keyDecls ; void recomposeKeys ( KeyDeclaration keyDecl ) { m_keyDecls . addElement ( keyDecl ) ; } public Vector getKeysComposed ( ) { return m_keyDecls ; } private Hashtable m_namespaceAliasComposed ; void recomposeNamespaceAliases ( NamespaceAlias nsAlias ) { m_namespaceAliasComposed . put ( nsAlias . getStylesheetNamespace ( ) , nsAlias ) ; } public NamespaceAlias getNamespaceAliasComposed ( String uri ) { return ( NamespaceAlias ) ( ( null == m_namespaceAliasComposed ) ? null : m_namespaceAliasComposed . get ( uri ) ) ; } private TemplateList m_templateList ; void recomposeTemplates ( ElemTemplate template ) { m_templateList . setTemplate ( template ) ; } public final TemplateList getTemplateListComposed ( ) { return m_templateList ; } public final void setTemplateListComposed ( TemplateList templateList ) { m_templateList = templateList ; } public ElemTemplate getTemplateComposed ( XPathContext xctxt , int targetNode , QName mode , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { return m_templateList . getTemplate ( xctxt , targetNode , mode , quietConflictWarnings , dtm ) ; } public ElemTemplate getTemplateComposed ( XPathContext xctxt , int targetNode , QName mode , int maxImportLevel , int endImportLevel , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { return m_templateList . getTemplate ( xctxt , targetNode , mode , maxImportLevel , endImportLevel , quietConflictWarnings , dtm ) ; } public ElemTemplate getTemplateComposed ( QName qname ) { return m_templateList . getTemplate ( qname ) ; } private Vector m_variables ; void recomposeVariables ( ElemVariable elemVar ) { if ( getVariableOrParamComposed ( elemVar . getName ( ) ) == null ) { elemVar . setIsTopLevel ( true ) ; elemVar . setIndex ( m_variables . size ( ) ) ; m_variables . addElement ( elemVar ) ; } } public ElemVariable getVariableOrParamComposed ( QName qname ) { if ( null != m_variables ) { int n = m_variables . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ElemVariable var = ( ElemVariable ) m_variables . elementAt ( i ) ; if ( var . getName ( ) . equals ( qname ) ) return var ; } } return null ; } public Vector getVariablesAndParamsComposed ( ) { return m_variables ; } private TemplateList m_whiteSpaceInfoList ; void recomposeWhiteSpaceInfo ( WhiteSpaceInfo wsi ) { if ( null == m_whiteSpaceInfoList ) m_whiteSpaceInfoList = new TemplateList ( ) ; m_whiteSpaceInfoList . setTemplate ( wsi ) ; } public boolean shouldCheckWhitespace ( ) { return null != m_whiteSpaceInfoList ; } public WhiteSpaceInfo getWhiteSpaceInfo ( XPathContext support , int targetElement , DTM dtm ) throws TransformerException { if ( null != m_whiteSpaceInfoList ) return ( WhiteSpaceInfo ) m_whiteSpaceInfoList . getTemplate ( support , targetElement , null , false , dtm ) ; else return null ; } public boolean shouldStripWhiteSpace ( XPathContext support , int targetElement ) throws TransformerException { if ( null != m_whiteSpaceInfoList ) { while ( DTM . NULL != targetElement ) { DTM dtm = support . getDTM ( targetElement ) ; WhiteSpaceInfo info = ( WhiteSpaceInfo ) m_whiteSpaceInfoList . getTemplate ( support , targetElement , null , false , dtm ) ; if ( null != info ) return info . getShouldStripSpace ( ) ; int parent = dtm . getParent ( targetElement ) ; if ( DTM . NULL != parent && DTM . ELEMENT_NODE == dtm . getNodeType ( parent ) ) targetElement = parent ; else targetElement = DTM . NULL ; } } return false ; } public boolean canStripWhiteSpace ( ) { return ( null != m_whiteSpaceInfoList ) ; } private ElemTemplate m_defaultTextRule ; public final ElemTemplate getDefaultTextRule ( ) { return m_defaultTextRule ; } private ElemTemplate m_defaultRule ; public final ElemTemplate getDefaultRule ( ) { return m_defaultRule ; } private ElemTemplate m_defaultRootRule ; public final ElemTemplate getDefaultRootRule ( ) { return m_defaultRootRule ; } private ElemTemplate m_startRule ; public final ElemTemplate getStartRule ( ) { return m_startRule ; } XPath m_selectDefault ; private void initDefaultRule ( ErrorListener errorListener ) throws TransformerException { m_defaultRule = new ElemTemplate ( ) ; m_defaultRule . setStylesheet ( this ) ; XPath defMatch = new XPath ( "*" , this , this , XPath . MATCH , errorListener ) ; m_defaultRule . setMatch ( defMatch ) ; ElemApplyTemplates childrenElement = new ElemApplyTemplates ( ) ; childrenElement . setIsDefaultTemplate ( true ) ; childrenElement . setSelect ( m_selectDefault ) ; m_defaultRule . appendChild ( childrenElement ) ; m_startRule = m_defaultRule ; m_defaultTextRule = new ElemTemplate ( ) ; m_defaultTextRule . setStylesheet ( this ) ; defMatch = new XPath ( "text() | @*" , this , this , XPath . MATCH , errorListener ) ; m_defaultTextRule . setMatch ( defMatch ) ; ElemValueOf elemValueOf = new ElemValueOf ( ) ; m_defaultTextRule . appendChild ( elemValueOf ) ; XPath selectPattern = new XPath ( "." , this , this , XPath . SELECT , errorListener ) ; elemValueOf . setSelect ( selectPattern ) ; m_defaultRootRule = new ElemTemplate ( ) ; m_defaultRootRule . setStylesheet ( this ) ; defMatch = new XPath ( "/" , this , this , XPath . MATCH , errorListener ) ; m_defaultRootRule . setMatch ( defMatch ) ; childrenElement = new ElemApplyTemplates ( ) ; childrenElement . setIsDefaultTemplate ( true ) ; m_defaultRootRule . appendChild ( childrenElement ) ; childrenElement . setSelect ( m_selectDefault ) ; } private void QuickSort2 ( Vector v , int lo0 , int hi0 ) { int lo = lo0 ; int hi = hi0 ; if ( hi0 > lo0 ) { ElemTemplateElement midNode = ( ElemTemplateElement ) v . elementAt ( ( lo0 + hi0 ) / 2 ) ; while ( lo <= hi ) { while ( ( lo < hi0 ) && ( ( ( ElemTemplateElement ) v . elementAt ( lo ) ) . compareTo ( midNode ) < 0 ) ) { ++ lo ; } while ( ( hi > lo0 ) && ( ( ( ElemTemplateElement ) v . elementAt ( hi ) ) . compareTo ( midNode ) > 0 ) ) { -- hi ; } if ( lo <= hi ) { ElemTemplateElement node = ( ElemTemplateElement ) v . elementAt ( lo ) ; v . setElementAt ( v . elementAt ( hi ) , lo ) ; v . setElementAt ( node , hi ) ; ++ lo ; -- hi ; } } if ( lo0 < hi ) { QuickSort2 ( v , lo0 , hi ) ; } if ( lo < hi0 ) { QuickSort2 ( v , lo , hi0 ) ; } } } private ComposeState m_composeState ; void initComposeState ( ) { m_composeState = new ComposeState ( ) ; } ComposeState getComposeState ( ) { return m_composeState ; } private void clearComposeState ( ) { m_composeState = null ; } class ComposeState { ComposeState ( ) { int size = m_variables . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { ElemVariable ev = ( ElemVariable ) m_variables . elementAt ( i ) ; m_variableNames . addElement ( ev . getName ( ) ) ; } } private ExpandedNameTable m_ent = new ExpandedNameTable ( ) ; public int getQNameID ( QName qname ) { return m_ent . getExpandedTypeID ( qname . getNamespace ( ) , qname . getLocalName ( ) , org . apache . xml . dtm . DTM . ELEMENT_NODE ) ; } private java . util . Vector m_variableNames = new java . util . Vector ( ) ; int addVariableName ( final org . apache . xml . utils . QName qname ) { int pos = m_variableNames . size ( ) ; m_variableNames . addElement ( qname ) ; int frameSize = m_variableNames . size ( ) - getGlobalsSize ( ) ; if ( frameSize > m_maxStackFrameSize ) m_maxStackFrameSize ++ ; return pos ; } void resetStackFrameSize ( ) { m_maxStackFrameSize = 0 ; } int getFrameSize ( ) { return m_maxStackFrameSize ; } int getCurrentStackFrameSize ( ) { return m_variableNames . size ( ) ; } void setCurrentStackFrameSize ( int sz ) { m_variableNames . setSize ( sz ) ; } int getGlobalsSize ( ) { return m_variables . size ( ) ; } IntStack m_marks = new IntStack ( ) ; void pushStackMark ( ) { m_marks . push ( getCurrentStackFrameSize ( ) ) ; } void popStackMark ( ) { int mark = m_marks . pop ( ) ; setCurrentStackFrameSize ( mark ) ; } java . util . Vector getVariableNames ( ) { return m_variableNames ; } private int m_maxStackFrameSize ; } } 	1	['50', '5', '0', '57', '121', '1069', '49', '24', '34', '0.939909297', '987', '0.944444444', '11', '0.853658537', '0.079130435', '3', '6', '18.38', '10', '1.6', '1']
package org . apache . xpath . axes ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public interface ContextNodeList { public Node getCurrentNode ( ) ; public int getCurrentPos ( ) ; public void reset ( ) ; public void setShouldCacheNodes ( boolean b ) ; public void runTo ( int index ) ; public void setCurrentPos ( int i ) ; public int size ( ) ; public boolean isFresh ( ) ; public NodeIterator cloneWithReset ( ) throws CloneNotSupportedException ; public Object clone ( ) throws CloneNotSupportedException ; public int getLast ( ) ; public void setLast ( int last ) ; } 	1	['12', '1', '0', '1', '12', '66', '1', '0', '12', '2', '12', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '1']
package org . apache . xml . utils ; import java . util . EmptyStackException ; public class ObjectStack extends ObjectVector { public ObjectStack ( ) { super ( ) ; } public ObjectStack ( int blocksize ) { super ( blocksize ) ; } public ObjectStack ( ObjectStack v ) { super ( v ) ; } public Object push ( Object i ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = i ; m_firstFree ++ ; return i ; } public Object pop ( ) { Object val = m_map [ -- m_firstFree ] ; m_map [ m_firstFree ] = null ; return val ; } public void quickPop ( int n ) { m_firstFree -= n ; } public Object peek ( ) { try { return m_map [ m_firstFree - 1 ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public Object peek ( int n ) { try { return m_map [ m_firstFree - ( 1 + n ) ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public void setTop ( Object val ) { try { m_map [ m_firstFree - 1 ] = val ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public boolean empty ( ) { return m_firstFree == 0 ; } public int search ( Object o ) { int i = lastIndexOf ( o ) ; if ( i >= 0 ) { return size ( ) - i ; } return - 1 ; } public Object clone ( ) throws CloneNotSupportedException { return ( ObjectStack ) super . clone ( ) ; } } 	1	['12', '2', '0', '5', '20', '24', '4', '1', '12', '2', '161', '0', '0', '0.653846154', '0.395833333', '1', '14', '12.41666667', '2', '1', '1']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncTrue extends Function { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return XBoolean . S_TRUE ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	1	['3', '3', '0', '4', '4', '3', '0', '4', '3', '2', '9', '0', '0', '0.95', '0.5', '1', '6', '2', '1', '0.6667', '1']
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . NodeSorter ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . IntStack ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; public class ElemForEach extends ElemTemplateElement implements ExpressionOwner { static final boolean DEBUG = false ; public boolean m_doc_cache_off = false ; public ElemForEach ( ) { } protected Expression m_selectExpression = null ; public void setSelect ( XPath xpath ) { m_selectExpression = xpath . getExpression ( ) ; } public Expression getSelect ( ) { return m_selectExpression ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; int length = getSortElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { getSortElem ( i ) . compose ( sroot ) ; } java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_selectExpression ) m_selectExpression . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; else { m_selectExpression = getStylesheetRoot ( ) . m_selectDefault . getExpression ( ) ; } } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { int length = getSortElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { getSortElem ( i ) . endCompose ( sroot ) ; } super . endCompose ( sroot ) ; } protected Vector m_sortElems = null ; public int getSortElemCount ( ) { return ( m_sortElems == null ) ? 0 : m_sortElems . size ( ) ; } public ElemSort getSortElem ( int i ) { return ( ElemSort ) m_sortElems . elementAt ( i ) ; } public void setSortElem ( ElemSort sortElem ) { if ( null == m_sortElems ) m_sortElems = new Vector ( ) ; m_sortElems . addElement ( sortElem ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_FOREACH ; } public String getNodeName ( ) { return Constants . ELEMNAME_FOREACH_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { transformer . pushCurrentTemplateRuleIsNull ( true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { transformSelectedNodes ( transformer ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; transformer . popCurrentTemplateRuleIsNull ( ) ; } } protected ElemTemplateElement getTemplateMatch ( ) { return this ; } public DTMIterator sortNodes ( XPathContext xctxt , Vector keys , DTMIterator sourceNodes ) throws TransformerException { NodeSorter sorter = new NodeSorter ( xctxt ) ; sourceNodes . setShouldCacheNodes ( true ) ; sourceNodes . runTo ( - 1 ) ; xctxt . pushContextNodeList ( sourceNodes ) ; try { sorter . sort ( sourceNodes , keys , xctxt ) ; sourceNodes . setCurrentPos ( 0 ) ; } finally { xctxt . popContextNodeList ( ) ; } return sourceNodes ; } public void transformSelectedNodes ( TransformerImpl transformer ) throws TransformerException { final XPathContext xctxt = transformer . getXPathContext ( ) ; final int sourceNode = xctxt . getCurrentNode ( ) ; DTMIterator sourceNodes = m_selectExpression . asIterator ( xctxt , sourceNode ) ; try { final Vector keys = ( m_sortElems == null ) ? null : transformer . processSortKeys ( this , sourceNode ) ; if ( null != keys ) sourceNodes = sortNodes ( xctxt , keys , sourceNodes ) ; if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; } xctxt . pushCurrentNode ( DTM . NULL ) ; IntStack currentNodes = xctxt . getCurrentNodeStack ( ) ; xctxt . pushCurrentExpressionNode ( DTM . NULL ) ; IntStack currentExpressionNodes = xctxt . getCurrentExpressionNodeStack ( ) ; xctxt . pushSAXLocatorNull ( ) ; xctxt . pushContextNodeList ( sourceNodes ) ; transformer . pushElemTemplateElement ( null ) ; DTM dtm = xctxt . getDTM ( sourceNode ) ; int docID = sourceNode & DTMManager . IDENT_DTM_DEFAULT ; int child ; while ( DTM . NULL != ( child = sourceNodes . nextNode ( ) ) ) { currentNodes . setTop ( child ) ; currentExpressionNodes . setTop ( child ) ; if ( ( child & DTMManager . IDENT_DTM_DEFAULT ) != docID ) { dtm = xctxt . getDTM ( child ) ; docID = child & DTMManager . IDENT_DTM_DEFAULT ; } final int nodeType = dtm . getNodeType ( child ) ; if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; } for ( ElemTemplateElement t = this . m_firstChild ; t != null ; t = t . m_nextSibling ) { xctxt . setSAXLocator ( t ) ; transformer . setCurrentElement ( t ) ; t . execute ( transformer ) ; } if ( TransformerImpl . S_DEBUG ) { transformer . setCurrentElement ( null ) ; transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } if ( m_doc_cache_off ) { if ( DEBUG ) System . out . println ( "JJK***** CACHE RELEASE *****\n" + "\tdtm=" + dtm . getDocumentBaseURI ( ) ) ; xctxt . getSourceTreeManager ( ) . removeDocumentFromCache ( dtm . getDocument ( ) ) ; xctxt . release ( dtm , false ) ; } } } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEndEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; xctxt . popSAXLocator ( ) ; xctxt . popContextNodeList ( ) ; transformer . popElemTemplateElement ( ) ; xctxt . popCurrentExpressionNode ( ) ; xctxt . popCurrentNode ( ) ; sourceNodes . detach ( ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; if ( Constants . ELEMNAME_SORT == type ) { setSortElem ( ( ElemSort ) newChild ) ; return newChild ; } else return super . appendChild ( newChild ) ; } public void callChildVisitors ( XSLTVisitor visitor , boolean callAttributes ) { if ( callAttributes && ( null != m_selectExpression ) ) m_selectExpression . callVisitors ( this , visitor ) ; int length = getSortElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { getSortElem ( i ) . callVisitors ( visitor ) ; } super . callChildVisitors ( visitor , callAttributes ) ; } public Expression getExpression ( ) { return m_selectExpression ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_selectExpression = exp ; } } 	1	['18', '3', '1', '24', '81', '79', '5', '20', '17', '0.735294118', '474', '0.5', '1', '0.920187793', '0.136752137', '2', '6', '25.11111111', '4', '1.2778', '2']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; public class ExtensionHandlerJavaClass extends ExtensionHandlerJava { private Class m_classObj = null ; private Object m_defaultInstance = null ; public ExtensionHandlerJavaClass ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang , className ) ; try { m_classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { } } public boolean isFunctionAvailable ( String function ) { Method [ ] methods = m_classObj . getMethods ( ) ; int nMethods = methods . length ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( function ) ) return true ; } return false ; } public boolean isElementAvailable ( String element ) { Method [ ] methods = m_classObj . getMethods ( ) ; int nMethods = methods . length ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( element ) ) { Class [ ] paramTypes = methods [ i ] . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) ) { return true ; } } } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { Object [ ] methodArgs ; Object [ ] [ ] convertedArgs ; Class [ ] paramTypes ; try { if ( funcName . equals ( "new" ) ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Constructor c = ( Constructor ) getFromCache ( methodKey , null , methodArgs ) ; if ( c != null ) { try { paramTypes = c . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } c = MethodResolver . getConstructor ( m_classObj , methodArgs , convertedArgs , exprContext ) ; putToCache ( methodKey , null , methodArgs , c ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } else { int resolveType ; Object targetObject = null ; methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Method m = ( Method ) getFromCache ( methodKey , null , methodArgs ) ; if ( m != null ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; if ( Modifier . isStatic ( m . getModifiers ( ) ) ) return m . invoke ( null , convertedArgs [ 0 ] ) ; else { int nTargetArgs = convertedArgs [ 0 ] . length ; if ( ExpressionContext . class . isAssignableFrom ( paramTypes [ 0 ] ) ) nTargetArgs -- ; if ( methodArgs . length <= nTargetArgs ) return m . invoke ( m_defaultInstance , convertedArgs [ 0 ] ) ; else { targetObject = methodArgs [ 0 ] ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } } } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } if ( args . size ( ) > 0 ) { targetObject = methodArgs [ 0 ] ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; if ( m_classObj . isAssignableFrom ( targetObject . getClass ( ) ) ) resolveType = MethodResolver . DYNAMIC ; else resolveType = MethodResolver . STATIC_AND_INSTANCE ; } else { targetObject = null ; resolveType = MethodResolver . STATIC_AND_INSTANCE ; } m = MethodResolver . getMethod ( m_classObj , funcName , methodArgs , convertedArgs , exprContext , resolveType ) ; putToCache ( methodKey , null , methodArgs , m ) ; if ( MethodResolver . DYNAMIC == resolveType ) return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; else { if ( Modifier . isStatic ( m . getModifiers ( ) ) ) return m . invoke ( null , convertedArgs [ 0 ] ) ; else { if ( null == m_defaultInstance ) { m_defaultInstance = m_classObj . newInstance ( ) ; } return m . invoke ( m_defaultInstance , convertedArgs [ 0 ] ) ; } } } } catch ( InvocationTargetException ite ) { Throwable resultException = ite ; Throwable targetException = ite . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( ( TransformerException ) targetException ) ; else if ( targetException != null ) resultException = targetException ; throw new TransformerException ( resultException ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { return callFunction ( extFunction . getFunctionName ( ) , args , extFunction . getMethodKey ( ) , exprContext ) ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; Method m = ( Method ) getFromCache ( methodKey , null , null ) ; if ( null == m ) { try { m = MethodResolver . getElementMethod ( m_classObj , localPart ) ; if ( ( null == m_defaultInstance ) && ! Modifier . isStatic ( m . getModifiers ( ) ) ) m_defaultInstance = m_classObj . newInstance ( ) ; } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , e ) ; } putToCache ( methodKey , null , null , m ) ; } XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { result = m . invoke ( m_defaultInstance , new Object [ ] { xpc , element } ) ; } catch ( InvocationTargetException e ) { Throwable targetException = e . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( TransformerException ) targetException ; else if ( targetException != null ) throw new TransformerException ( targetException . getMessage ( ) , targetException ) ; else throw new TransformerException ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1	['7', '3', '0', '9', '43', '1', '0', '9', '6', '0.7', '530', '0.4', '0', '0.571428571', '0.349206349', '2', '6', '74', '8', '2.1429', '1']
package org . apache . xml . dtm ; import javax . xml . transform . SourceLocator ; import org . apache . xml . utils . XMLString ; public interface DTM { public static final int NULL = - 1 ; public static final short ROOT_NODE = 0 ; public static final short ELEMENT_NODE = 1 ; public static final short ATTRIBUTE_NODE = 2 ; public static final short TEXT_NODE = 3 ; public static final short CDATA_SECTION_NODE = 4 ; public static final short ENTITY_REFERENCE_NODE = 5 ; public static final short ENTITY_NODE = 6 ; public static final short PROCESSING_INSTRUCTION_NODE = 7 ; public static final short COMMENT_NODE = 8 ; public static final short DOCUMENT_NODE = 9 ; public static final short DOCUMENT_TYPE_NODE = 10 ; public static final short DOCUMENT_FRAGMENT_NODE = 11 ; public static final short NOTATION_NODE = 12 ; public static final short NAMESPACE_NODE = 13 ; public static final short NTYPES = 14 ; public void setFeature ( String featureId , boolean state ) ; public void setProperty ( String property , Object value ) ; public DTMAxisTraverser getAxisTraverser ( final int axis ) ; public DTMAxisIterator getAxisIterator ( final int axis ) ; public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) ; public boolean hasChildNodes ( int nodeHandle ) ; public int getFirstChild ( int nodeHandle ) ; public int getLastChild ( int nodeHandle ) ; public int getAttributeNode ( int elementHandle , String namespaceURI , String name ) ; public int getFirstAttribute ( int nodeHandle ) ; public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) ; public int getNextSibling ( int nodeHandle ) ; public int getPreviousSibling ( int nodeHandle ) ; public int getNextAttribute ( int nodeHandle ) ; public int getNextNamespaceNode ( int baseHandle , int namespaceHandle , boolean inScope ) ; public int getParent ( int nodeHandle ) ; public int getDocument ( ) ; public int getOwnerDocument ( int nodeHandle ) ; public int getDocumentRoot ( int nodeHandle ) ; public XMLString getStringValue ( int nodeHandle ) ; public int getStringValueChunkCount ( int nodeHandle ) ; public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) ; public int getExpandedTypeID ( int nodeHandle ) ; public int getExpandedTypeID ( String namespace , String localName , int type ) ; public String getLocalNameFromExpandedNameID ( int ExpandedNameID ) ; public String getNamespaceFromExpandedNameID ( int ExpandedNameID ) ; public String getNodeName ( int nodeHandle ) ; public String getNodeNameX ( int nodeHandle ) ; public String getLocalName ( int nodeHandle ) ; public String getPrefix ( int nodeHandle ) ; public String getNamespaceURI ( int nodeHandle ) ; public String getNodeValue ( int nodeHandle ) ; public short getNodeType ( int nodeHandle ) ; public short getLevel ( int nodeHandle ) ; public boolean isSupported ( String feature , String version ) ; public String getDocumentBaseURI ( ) ; public void setDocumentBaseURI ( String baseURI ) ; public String getDocumentSystemIdentifier ( int nodeHandle ) ; public String getDocumentEncoding ( int nodeHandle ) ; public String getDocumentStandalone ( int nodeHandle ) ; public String getDocumentVersion ( int documentHandle ) ; public boolean getDocumentAllDeclarationsProcessed ( ) ; public String getDocumentTypeDeclarationSystemIdentifier ( ) ; public String getDocumentTypeDeclarationPublicIdentifier ( ) ; public int getElementById ( String elementId ) ; public String getUnparsedEntityURI ( String name ) ; public boolean supportsPreStripping ( ) ; public boolean isNodeAfter ( int firstNodeHandle , int secondNodeHandle ) ; public boolean isCharacterElementContentWhitespace ( int nodeHandle ) ; public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) ; public boolean isAttributeSpecified ( int attributeHandle ) ; public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException ; public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException ; public org . w3c . dom . Node getNode ( int nodeHandle ) ; public boolean needsTwoThreads ( ) ; public org . xml . sax . ContentHandler getContentHandler ( ) ; public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) ; public org . xml . sax . EntityResolver getEntityResolver ( ) ; public org . xml . sax . DTDHandler getDTDHandler ( ) ; public org . xml . sax . ErrorHandler getErrorHandler ( ) ; public org . xml . sax . ext . DeclHandler getDeclHandler ( ) ; public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) ; public void appendTextChild ( String str ) ; public SourceLocator getSourceLocatorFor ( int node ) ; public void documentRegistration ( ) ; public void documentRelease ( ) ; } 	1	['66', '1', '0', '94', '66', '2145', '91', '3', '66', '1.015384615', '82', '0', '0', '0', '0.277056277', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . ClonerToResultTree ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . XPathContext ; public class ElemCopy extends ElemUse { public int getXSLToken ( ) { return Constants . ELEMNAME_COPY ; } public String getNodeName ( ) { return Constants . ELEMNAME_COPY_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; try { int sourceNode = xctxt . getCurrentNode ( ) ; xctxt . pushCurrentNode ( sourceNode ) ; DTM dtm = xctxt . getDTM ( sourceNode ) ; short nodeType = dtm . getNodeType ( sourceNode ) ; if ( ( DTM . DOCUMENT_NODE != nodeType ) && ( DTM . DOCUMENT_FRAGMENT_NODE != nodeType ) ) { SerializationHandler rthandler = transformer . getSerializationHandler ( ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; ClonerToResultTree . cloneToResultTree ( sourceNode , nodeType , dtm , rthandler , false ) ; if ( DTM . ELEMENT_NODE == nodeType ) { super . execute ( transformer ) ; SerializerUtils . processNSDecls ( rthandler , sourceNode , nodeType , dtm ) ; transformer . executeChildTemplates ( this , true ) ; String ns = dtm . getNamespaceURI ( sourceNode ) ; String localName = dtm . getLocalName ( sourceNode ) ; transformer . getResultTreeHandler ( ) . endElement ( ns , localName , dtm . getNodeName ( sourceNode ) ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } else { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; super . execute ( transformer ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { xctxt . popCurrentNode ( ) ; } } } 	1	['4', '4', '0', '10', '25', '6', '1', '9', '4', '2', '121', '0', '0', '0.985365854', '0.625', '2', '4', '29.25', '1', '0.75', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . IFNONNULL ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . IF_ICMPLT ; import org . apache . bcel . generic . IF_ICMPNE ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; class StepPattern extends RelativePathPattern { private static final int NO_CONTEXT = 0 ; private static final int SIMPLE_CONTEXT = 1 ; private static final int GENERAL_CONTEXT = 2 ; protected final int _axis ; protected final int _nodeType ; protected Vector _predicates ; private Step _step = null ; private boolean _isEpsilon = false ; private int _contextCase ; private double _priority = Double . MAX_VALUE ; public StepPattern ( int axis , int nodeType , Vector predicates ) { _axis = axis ; _nodeType = nodeType ; _predicates = predicates ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate exp = ( Predicate ) _predicates . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public int getNodeType ( ) { return _nodeType ; } public void setPriority ( double priority ) { _priority = priority ; } public StepPattern getKernelPattern ( ) { return this ; } public boolean isWildcard ( ) { return _isEpsilon && hasPredicates ( ) == false ; } public StepPattern setPredicates ( Vector predicates ) { _predicates = predicates ; return ( this ) ; } protected boolean hasPredicates ( ) { return _predicates != null && _predicates . size ( ) > 0 ; } public double getDefaultPriority ( ) { if ( _priority != Double . MAX_VALUE ) { return _priority ; } if ( hasPredicates ( ) ) { return 0.5 ; } else { switch ( _nodeType ) { case - 1 : return - 0.5 ; case 0 : return 0.0 ; default : return ( _nodeType >= NodeTest . GTYPE ) ? 0.0 : - 0.5 ; } } } public int getAxis ( ) { return _axis ; } public void reduceKernelPattern ( ) { _isEpsilon = true ; } public String toString ( ) { final StringBuffer buffer = new StringBuffer ( "stepPattern(\"" ) ; buffer . append ( Axis . names [ _axis ] ) . append ( "\", " ) . append ( _isEpsilon ? ( "epsilon{" + Integer . toString ( _nodeType ) + "}" ) : Integer . toString ( _nodeType ) ) ; if ( _predicates != null ) buffer . append ( ", " ) . append ( _predicates . toString ( ) ) ; return buffer . append ( ')' ) . toString ( ) ; } private int analyzeCases ( ) { boolean noContext = true ; final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n && noContext ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; if ( pred . getExpr ( ) . hasPositionCall ( ) || pred . isNthPositionFilter ( ) ) { noContext = false ; } } if ( noContext ) { return NO_CONTEXT ; } else if ( n == 1 ) { return SIMPLE_CONTEXT ; } return GENERAL_CONTEXT ; } private String getNextFieldName ( ) { return "__step_pattern_iter_" + getXSLTC ( ) . nextStepPatternSerial ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( hasPredicates ( ) ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } _contextCase = analyzeCases ( ) ; Step step = null ; if ( _contextCase == SIMPLE_CONTEXT ) { Predicate pred = ( Predicate ) _predicates . elementAt ( 0 ) ; if ( pred . isNthPositionFilter ( ) ) { _contextCase = GENERAL_CONTEXT ; step = new Step ( _axis , _nodeType , _predicates ) ; } else { step = new Step ( _axis , _nodeType , null ) ; } } else if ( _contextCase == GENERAL_CONTEXT ) { final int len = _predicates . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { ( ( Predicate ) _predicates . elementAt ( i ) ) . dontOptimize ( ) ; } step = new Step ( _axis , _nodeType , _predicates ) ; } if ( step != null ) { step . setParser ( getParser ( ) ) ; step . typeCheck ( stable ) ; _step = step ; } } return _axis == Axis . CHILD ? Type . Element : Type . Attribute ; } private void translateKernel ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _nodeType == DTM . ELEMENT_NODE ) { final int check = cpg . addInterfaceMethodref ( DOM_INTF , "isElement" , "(I)Z" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( check , 2 ) ) ; final BranchHandle icmp = il . append ( new IFNE ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; icmp . setTarget ( il . append ( NOP ) ) ; } else if ( _nodeType == DTM . ATTRIBUTE_NODE ) { final int check = cpg . addInterfaceMethodref ( DOM_INTF , "isAttribute" , "(I)Z" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( check , 2 ) ) ; final BranchHandle icmp = il . append ( new IFNE ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; icmp . setTarget ( il . append ( NOP ) ) ; } else { final int getEType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getEType , 2 ) ) ; il . append ( new PUSH ( cpg , _nodeType ) ) ; final BranchHandle icmp = il . append ( new IF_ICMPEQ ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; icmp . setTarget ( il . append ( NOP ) ) ; } } private void translateNoContext ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; if ( ! _isEpsilon ) { il . append ( methodGen . loadCurrentNode ( ) ) ; translateKernel ( classGen , methodGen ) ; } final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; Expression exp = pred . getExpr ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; _trueList . append ( exp . _trueList ) ; _falseList . append ( exp . _falseList ) ; } InstructionHandle restore ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchTrueList ( restore ) ; BranchHandle skipFalse = il . append ( new GOTO ( null ) ) ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchFalseList ( restore ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; skipFalse . setTarget ( il . append ( NOP ) ) ; } private void translateSimpleContext ( ClassGenerator classGen , MethodGenerator methodGen ) { int index ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; LocalVariableGen match ; match = methodGen . addLocalVariable ( "step_pattern_tmp1" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( match . getIndex ( ) ) ) ; if ( ! _isEpsilon ) { il . append ( new ILOAD ( match . getIndex ( ) ) ) ; translateKernel ( classGen , methodGen ) ; } il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; index = cpg . addMethodref ( MATCHING_ITERATOR , "<init>" , "(I" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( MATCHING_ITERATOR ) ) ) ; il . append ( DUP ) ; il . append ( new ILOAD ( match . getIndex ( ) ) ) ; _step . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( index ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( match . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; il . append ( methodGen . setStartNode ( ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( new ILOAD ( match . getIndex ( ) ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; Predicate pred = ( Predicate ) _predicates . elementAt ( 0 ) ; Expression exp = pred . getExpr ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; InstructionHandle restore = il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; exp . backPatchTrueList ( restore ) ; BranchHandle skipFalse = il . append ( new GOTO ( null ) ) ; restore = il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; exp . backPatchFalseList ( restore ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; skipFalse . setTarget ( il . append ( NOP ) ) ; } private void translateGeneralContext ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int iteratorIndex = 0 ; BranchHandle ifBlock = null ; LocalVariableGen iter , node , node2 ; final String iteratorName = getNextFieldName ( ) ; node = methodGen . addLocalVariable ( "step_pattern_tmp1" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( node . getIndex ( ) ) ) ; iter = methodGen . addLocalVariable ( "step_pattern_tmp2" , Util . getJCRefType ( NODE_ITERATOR_SIG ) , il . getEnd ( ) , null ) ; if ( ! classGen . isExternal ( ) ) { final Field iterator = new Field ( ACC_PRIVATE , cpg . addUtf8 ( iteratorName ) , cpg . addUtf8 ( NODE_ITERATOR_SIG ) , null , cpg . getConstantPool ( ) ) ; classGen . addField ( iterator ) ; iteratorIndex = cpg . addFieldref ( classGen . getClassName ( ) , iteratorName , NODE_ITERATOR_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( iteratorIndex ) ) ; il . append ( DUP ) ; il . append ( new ASTORE ( iter . getIndex ( ) ) ) ; ifBlock = il . append ( new IFNONNULL ( null ) ) ; il . append ( classGen . loadTranslet ( ) ) ; } _step . translate ( classGen , methodGen ) ; il . append ( new ASTORE ( iter . getIndex ( ) ) ) ; if ( ! classGen . isExternal ( ) ) { il . append ( new ALOAD ( iter . getIndex ( ) ) ) ; il . append ( new PUTFIELD ( iteratorIndex ) ) ; ifBlock . setTarget ( il . append ( NOP ) ) ; } il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( node . getIndex ( ) ) ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; il . append ( new ALOAD ( iter . getIndex ( ) ) ) ; il . append ( SWAP ) ; il . append ( methodGen . setStartNode ( ) ) ; BranchHandle skipNext ; InstructionHandle begin , next ; node2 = methodGen . addLocalVariable ( "step_pattern_tmp3" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) , null ) ; skipNext = il . append ( new GOTO ( null ) ) ; next = il . append ( new ALOAD ( iter . getIndex ( ) ) ) ; begin = il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( new ISTORE ( node2 . getIndex ( ) ) ) ; _falseList . add ( il . append ( new IFLT ( null ) ) ) ; il . append ( new ILOAD ( node2 . getIndex ( ) ) ) ; il . append ( new ILOAD ( node . getIndex ( ) ) ) ; il . append ( new IF_ICMPLT ( next ) ) ; il . append ( new ILOAD ( node2 . getIndex ( ) ) ) ; il . append ( new ILOAD ( node . getIndex ( ) ) ) ; _falseList . add ( il . append ( new IF_ICMPNE ( null ) ) ) ; skipNext . setTarget ( begin ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( hasPredicates ( ) ) { switch ( _contextCase ) { case NO_CONTEXT : translateNoContext ( classGen , methodGen ) ; break ; case SIMPLE_CONTEXT : translateSimpleContext ( classGen , methodGen ) ; break ; default : translateGeneralContext ( classGen , methodGen ) ; break ; } } else if ( isWildcard ( ) ) { il . append ( POP ) ; } else { translateKernel ( classGen , methodGen ) ; } } } 	1	['20', '6', '1', '53', '99', '50', '8', '46', '13', '0.831578947', '1165', '1', '1', '0.838983051', '0.225', '3', '8', '56.75', '7', '2.55', '1']
package org . apache . xpath . domapi ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . XPath ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . xpath . XPathEvaluator ; import org . w3c . dom . xpath . XPathException ; import org . w3c . dom . xpath . XPathExpression ; import org . w3c . dom . xpath . XPathNSResolver ; public class XPathEvaluatorImpl implements XPathEvaluator { class DummyPrefixResolver implements PrefixResolver { public DummyPrefixResolver ( ) { } public String getNamespaceForPrefix ( String prefix , Node context ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_RESOLVER , null ) ; throw new DOMException ( DOMException . NAMESPACE_ERR , fmsg ) ; } public String getNamespaceForPrefix ( String prefix ) { return getNamespaceForPrefix ( prefix , null ) ; } public boolean handlesNullPrefixes ( ) { return false ; } public String getBaseIdentifier ( ) { return null ; } } private Document m_doc = null ; public XPathEvaluatorImpl ( ) { super ( ) ; } public XPathEvaluatorImpl ( Document doc ) { m_doc = doc ; } public XPathExpression createExpression ( String expression , XPathNSResolver resolver ) throws XPathException , DOMException { try { XPath xpath = new XPath ( expression , null , ( ( null == resolver ) ? new DummyPrefixResolver ( ) : ( ( PrefixResolver ) resolver ) ) , XPath . SELECT ) ; return new XPathExpressionImpl ( xpath , m_doc ) ; } catch ( TransformerException e ) { throw new DOMException ( XPathException . INVALID_EXPRESSION_ERR , e . getMessageAndLocation ( ) ) ; } } public XPathNSResolver createNSResolver ( Node nodeResolver ) { return new XPathNSResolverImpl ( ( nodeResolver . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( ( Document ) nodeResolver ) . getDocumentElement ( ) : nodeResolver ) ; } public Object evaluate ( String expression , Node contextNode , XPathNSResolver resolver , short type , Object result ) throws XPathException , DOMException { XPathExpression xpathExpression = createExpression ( expression , resolver ) ; return xpathExpression . evaluate ( contextNode , type , result ) ; } } 	1	['5', '1', '0', '5', '15', '4', '1', '5', '5', '0.25', '77', '1', '0', '0', '0.4', '0', '0', '14.2', '2', '0.8', '1']
package org . apache . xalan . transformer ; import java . text . Collator ; import java . util . Locale ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xpath . XPath ; class NodeSortKey { XPath m_selectPat ; boolean m_treatAsNumbers ; boolean m_descending ; boolean m_caseOrderUpper ; Collator m_col ; Locale m_locale ; org . apache . xml . utils . PrefixResolver m_namespaceContext ; TransformerImpl m_processor ; NodeSortKey ( TransformerImpl transformer , XPath selectPat , boolean treatAsNumbers , boolean descending , String langValue , boolean caseOrderUpper , org . apache . xml . utils . PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { m_processor = transformer ; m_namespaceContext = namespaceContext ; m_selectPat = selectPat ; m_treatAsNumbers = treatAsNumbers ; m_descending = descending ; m_caseOrderUpper = caseOrderUpper ; if ( null != langValue && m_treatAsNumbers == false ) { m_locale = new Locale ( langValue . toLowerCase ( ) , Locale . getDefault ( ) . getCountry ( ) ) ; if ( null == m_locale ) { m_locale = Locale . getDefault ( ) ; } } else { m_locale = Locale . getDefault ( ) ; } m_col = Collator . getInstance ( m_locale ) ; if ( null == m_col ) { m_processor . getMsgMgr ( ) . warn ( null , XSLTErrorResources . WG_CANNOT_FIND_COLLATOR , new Object [ ] { langValue } ) ; m_col = Collator . getInstance ( ) ; } } } 	1	['1', '1', '0', '6', '10', '0', '3', '4', '0', '2', '80', '0', '3', '0', '1', '0', '0', '71', '0', '0', '1']
package org . apache . xalan . lib ; import java . util . Hashtable ; import org . apache . xml . utils . DOMHelper ; import org . apache . xpath . NodeSet ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class ExsltSets extends ExsltBase { public static NodeList leading ( NodeList nl1 , NodeList nl2 ) { if ( nl2 . getLength ( ) == 0 ) return nl1 ; NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet leadNodes = new NodeSet ( ) ; Node endNode = nl2 . item ( 0 ) ; if ( ! ns1 . contains ( endNode ) ) return leadNodes ; for ( int i = 0 ; i < nl1 . getLength ( ) ; i ++ ) { Node testNode = nl1 . item ( i ) ; if ( DOMHelper . isNodeAfter ( testNode , endNode ) && ! DOMHelper . isNodeTheSame ( testNode , endNode ) ) leadNodes . addElement ( testNode ) ; } return leadNodes ; } public static NodeList trailing ( NodeList nl1 , NodeList nl2 ) { if ( nl2 . getLength ( ) == 0 ) return nl1 ; NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet trailNodes = new NodeSet ( ) ; Node startNode = nl2 . item ( 0 ) ; if ( ! ns1 . contains ( startNode ) ) return trailNodes ; for ( int i = 0 ; i < nl1 . getLength ( ) ; i ++ ) { Node testNode = nl1 . item ( i ) ; if ( DOMHelper . isNodeAfter ( startNode , testNode ) && ! DOMHelper . isNodeTheSame ( startNode , testNode ) ) trailNodes . addElement ( testNode ) ; } return trailNodes ; } public static NodeList intersection ( NodeList nl1 , NodeList nl2 ) { NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet ns2 = new NodeSet ( nl2 ) ; NodeSet inter = new NodeSet ( ) ; inter . setShouldCacheNodes ( true ) ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ns2 . contains ( n ) ) inter . addElement ( n ) ; } return inter ; } public static NodeList difference ( NodeList nl1 , NodeList nl2 ) { NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet ns2 = new NodeSet ( nl2 ) ; NodeSet diff = new NodeSet ( ) ; diff . setShouldCacheNodes ( true ) ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ! ns2 . contains ( n ) ) diff . addElement ( n ) ; } return diff ; } public static NodeList distinct ( NodeList nl ) { NodeSet dist = new NodeSet ( ) ; dist . setShouldCacheNodes ( true ) ; Hashtable stringTable = new Hashtable ( ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node currNode = nl . item ( i ) ; String key = toString ( currNode ) ; if ( key == null ) dist . addElement ( currNode ) ; else if ( ! stringTable . containsKey ( key ) ) { stringTable . put ( key , currNode ) ; dist . addElement ( currNode ) ; } } return dist ; } public static boolean hasSameNode ( NodeList nl1 , NodeList nl2 ) { NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet ns2 = new NodeSet ( nl2 ) ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { if ( ns2 . contains ( ns1 . elementAt ( i ) ) ) return true ; } return false ; } } 	1	['7', '2', '0', '4', '23', '21', '1', '3', '7', '2', '258', '0', '0', '0.25', '0.5', '0', '0', '35.85714286', '6', '3.5714', '1']
package org . apache . xml . utils ; import java . io . BufferedReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . net . URL ; import java . net . URLConnection ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class ListingErrorHandler implements ErrorHandler , ErrorListener { protected PrintWriter m_pw = null ; public ListingErrorHandler ( PrintWriter pw ) { if ( null == pw ) throw new NullPointerException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , null ) ) ; m_pw = pw ; } public ListingErrorHandler ( ) { m_pw = new PrintWriter ( System . err , true ) ; } public void warning ( SAXParseException exception ) throws SAXException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "warning: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnWarning ( ) ) throw exception ; } public void error ( SAXParseException exception ) throws SAXException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "error: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnError ( ) ) throw exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "fatalError: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnFatalError ( ) ) throw exception ; } public void warning ( TransformerException exception ) throws TransformerException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "warning: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnWarning ( ) ) throw exception ; } public void error ( TransformerException exception ) throws TransformerException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "error: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnError ( ) ) throw exception ; } public void fatalError ( TransformerException exception ) throws TransformerException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "error: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnError ( ) ) throw exception ; } public static void logExceptionLocation ( PrintWriter pw , Throwable exception ) { if ( null == pw ) pw = new PrintWriter ( System . err , true ) ; SourceLocator locator = null ; Throwable cause = exception ; do { if ( cause instanceof SAXParseException ) { locator = new SAXSourceLocator ( ( SAXParseException ) cause ) ; } else if ( cause instanceof TransformerException ) { SourceLocator causeLocator = ( ( TransformerException ) cause ) . getLocator ( ) ; if ( null != causeLocator ) { locator = causeLocator ; } } if ( cause instanceof TransformerException ) cause = ( ( TransformerException ) cause ) . getCause ( ) ; else if ( cause instanceof WrappedRuntimeException ) cause = ( ( WrappedRuntimeException ) cause ) . getException ( ) ; else if ( cause instanceof SAXException ) cause = ( ( SAXException ) cause ) . getException ( ) ; else cause = null ; } while ( null != cause ) ; if ( null != locator ) { String id = ( locator . getPublicId ( ) != locator . getPublicId ( ) ) ? locator . getPublicId ( ) : ( null != locator . getSystemId ( ) ) ? locator . getSystemId ( ) : "SystemId-Unknown" ; pw . print ( id + ":Line=" + locator . getLineNumber ( ) + ";Column=" + locator . getColumnNumber ( ) + ": " ) ; pw . println ( "exception:" + exception . getMessage ( ) ) ; pw . println ( "root-cause:" + ( ( null != cause ) ? cause . getMessage ( ) : "null" ) ) ; logSourceLine ( pw , locator ) ; } else { pw . print ( "SystemId-Unknown:locator-unavailable: " ) ; pw . println ( "exception:" + exception . getMessage ( ) ) ; pw . println ( "root-cause:" + ( ( null != cause ) ? cause . getMessage ( ) : "null" ) ) ; } } public static void logSourceLine ( PrintWriter pw , SourceLocator locator ) { if ( null == locator ) return ; if ( null == pw ) pw = new PrintWriter ( System . err , true ) ; String url = locator . getSystemId ( ) ; if ( null == url ) { pw . println ( "line: (No systemId; cannot read file)" ) ; pw . println ( ) ; return ; } try { int line = locator . getLineNumber ( ) ; int column = locator . getColumnNumber ( ) ; pw . println ( "line: " + getSourceLine ( url , line ) ) ; StringBuffer buf = new StringBuffer ( "line: " ) ; for ( int i = 1 ; i < column ; i ++ ) { buf . append ( ' ' ) ; } buf . append ( '^' ) ; pw . println ( buf . toString ( ) ) ; } catch ( Exception e ) { pw . println ( "line: logSourceLine unavailable due to: " + e . getMessage ( ) ) ; pw . println ( ) ; } } protected static String getSourceLine ( String sourceUrl , int lineNum ) throws Exception { URL url = null ; try { url = new URL ( sourceUrl ) ; } catch ( java . net . MalformedURLException mue ) { int indexOfColon = sourceUrl . indexOf ( ':' ) ; int indexOfSlash = sourceUrl . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { throw mue ; } else { url = new URL ( SystemIDResolver . getAbsoluteURI ( sourceUrl ) ) ; } } String line = null ; InputStream is = null ; BufferedReader br = null ; try { URLConnection uc = url . openConnection ( ) ; is = uc . getInputStream ( ) ; br = new BufferedReader ( new InputStreamReader ( is ) ) ; for ( int i = 1 ; i <= lineNum ; i ++ ) { line = br . readLine ( ) ; } } finally { br . close ( ) ; is . close ( ) ; } return line ; } public void setThrowOnWarning ( boolean b ) { throwOnWarning = b ; } public boolean getThrowOnWarning ( ) { return throwOnWarning ; } protected boolean throwOnWarning = false ; public void setThrowOnError ( boolean b ) { throwOnError = b ; } public boolean getThrowOnError ( ) { return throwOnError ; } protected boolean throwOnError = true ; public void setThrowOnFatalError ( boolean b ) { throwOnFatalError = b ; } public boolean getThrowOnFatalError ( ) { return throwOnFatalError ; } protected boolean throwOnFatalError = true ; } 	1	['17', '1', '0', '4', '54', '50', '0', '4', '16', '0.65625', '569', '1', '0', '0', '0.196078431', '0', '0', '32.23529412', '14', '1.8824', '1']
package org . apache . xalan . extensions ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xpath . XPathProcessorException ; import org . apache . xpath . functions . FuncExtFunction ; public class ExtensionsTable { public Hashtable m_extensionFunctionNamespaces = new Hashtable ( ) ; private StylesheetRoot m_sroot ; public ExtensionsTable ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { m_sroot = sroot ; Vector extensions = m_sroot . getExtensions ( ) ; for ( int i = 0 ; i < extensions . size ( ) ; i ++ ) { ExtensionNamespaceSupport extNamespaceSpt = ( ExtensionNamespaceSupport ) extensions . elementAt ( i ) ; ExtensionHandler extHandler = extNamespaceSpt . launch ( ) ; if ( extHandler != null ) addExtensionNamespace ( extNamespaceSpt . getNamespace ( ) , extHandler ) ; } } public ExtensionHandler get ( String extns ) { return ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( extns ) ; } public void addExtensionNamespace ( String uri , ExtensionHandler extNS ) { m_extensionFunctionNamespaces . put ( uri , extNS ) ; } public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException { boolean isAvailable = false ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( extNS != null ) isAvailable = extNS . isFunctionAvailable ( funcName ) ; } return isAvailable ; } public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException { boolean isAvailable = false ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( extNS != null ) isAvailable = extNS . isElementAvailable ( elemName ) ; } return isAvailable ; } public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { Object result = null ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( null != extNS ) { try { result = extNS . callFunction ( funcName , argVec , methodKey , exprContext ) ; } catch ( javax . xml . transform . TransformerException e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } else { throw new XPathProcessorException ( XSLMessages . createMessage ( XSLTErrorResources . ER_EXTENSION_FUNC_UNKNOWN , new Object [ ] { ns , funcName } ) ) ; } } return result ; } public Object extFunction ( FuncExtFunction extFunction , Vector argVec , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { Object result = null ; String ns = extFunction . getNamespace ( ) ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( null != extNS ) { try { result = extNS . callFunction ( extFunction , argVec , exprContext ) ; } catch ( javax . xml . transform . TransformerException e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } else { throw new XPathProcessorException ( XSLMessages . createMessage ( XSLTErrorResources . ER_EXTENSION_FUNC_UNKNOWN , new Object [ ] { ns , extFunction . getFunctionName ( ) } ) ) ; } } return result ; } } 	1	['7', '1', '0', '9', '25', '0', '2', '7', '7', '0.5', '199', '0.5', '1', '0', '0.357142857', '0', '0', '27.14285714', '1', '0.8571', '1']
package org . apache . xml . utils ; public class StringToStringTable { private int m_blocksize ; private String m_map [ ] ; private int m_firstFree = 0 ; private int m_mapSize ; public StringToStringTable ( ) { m_blocksize = 16 ; m_mapSize = m_blocksize ; m_map = new String [ m_blocksize ] ; } public StringToStringTable ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new String [ blocksize ] ; } public final int getLength ( ) { return m_firstFree ; } public final void put ( String key , String value ) { if ( ( m_firstFree + 2 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = key ; m_firstFree ++ ; m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final String get ( String key ) { for ( int i = 0 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( key ) ) return m_map [ i + 1 ] ; } return null ; } public final void remove ( String key ) { for ( int i = 0 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( key ) ) { if ( ( i + 2 ) < m_firstFree ) System . arraycopy ( m_map , i + 2 , m_map , i , m_firstFree - ( i + 2 ) ) ; m_firstFree -= 2 ; m_map [ m_firstFree ] = null ; m_map [ m_firstFree + 1 ] = null ; break ; } } } public final String getIgnoreCase ( String key ) { if ( null == key ) return null ; for ( int i = 0 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equalsIgnoreCase ( key ) ) return m_map [ i + 1 ] ; } return null ; } public final String getByValue ( String val ) { for ( int i = 1 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( val ) ) return m_map [ i - 1 ] ; } return null ; } public final String elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( String key ) { for ( int i = 0 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( key ) ) return true ; } return false ; } public final boolean containsValue ( String val ) { for ( int i = 1 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( val ) ) return true ; } return false ; } } 	1	['11', '1', '0', '1', '15', '0', '1', '0', '11', '0.45', '286', '1', '0', '0', '0.606060606', '0', '0', '24.63636364', '4', '2.1818', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETSTATIC ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class DecimalFormatting extends TopLevelElement { private static final String DFS_CLASS = "java.text.DecimalFormatSymbols" ; private static final String DFS_SIG = "Ljava/text/DecimalFormatSymbols;" ; private QName _name = null ; public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void parseContents ( Parser parser ) { _name = parser . getQNameIgnoreDefaultNs ( getAttribute ( "name" ) ) ; if ( _name == null ) { _name = parser . getQNameIgnoreDefaultNs ( EMPTYSTRING ) ; } SymbolTable stable = parser . getSymbolTable ( ) ; if ( stable . getDecimalFormatting ( _name ) != null ) { reportWarning ( this , parser , ErrorMsg . SYMBOLS_REDEF_ERR , _name . toString ( ) ) ; } else { stable . addDecimalFormatting ( _name , this ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( DFS_CLASS , "<init>" , "(" + LOCALE_SIG + ")V" ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( new NEW ( cpg . addClass ( DFS_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( new GETSTATIC ( cpg . addFieldref ( LOCALE_CLASS , "US" , LOCALE_SIG ) ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; String tmp = getAttribute ( "NaN" ) ; if ( ( tmp == null ) || ( tmp . equals ( EMPTYSTRING ) ) ) { int nan = cpg . addMethodref ( DFS_CLASS , "setNaN" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "NaN" ) ) ; il . append ( new INVOKEVIRTUAL ( nan ) ) ; } tmp = getAttribute ( "infinity" ) ; if ( ( tmp == null ) || ( tmp . equals ( EMPTYSTRING ) ) ) { int inf = cpg . addMethodref ( DFS_CLASS , "setInfinity" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "Infinity" ) ) ; il . append ( new INVOKEVIRTUAL ( inf ) ) ; } final int nAttributes = _attributes . getLength ( ) ; for ( int i = 0 ; i < nAttributes ; i ++ ) { final String name = _attributes . getQName ( i ) ; final String value = _attributes . getValue ( i ) ; boolean valid = true ; int method = 0 ; if ( name . equals ( "decimal-separator" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setDecimalSeparator" , "(C)V" ) ; } else if ( name . equals ( "grouping-separator" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setGroupingSeparator" , "(C)V" ) ; } else if ( name . equals ( "minus-sign" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setMinusSign" , "(C)V" ) ; } else if ( name . equals ( "percent" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setPercent" , "(C)V" ) ; } else if ( name . equals ( "per-mille" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setPerMill" , "(C)V" ) ; } else if ( name . equals ( "zero-digit" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setZeroDigit" , "(C)V" ) ; } else if ( name . equals ( "digit" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setDigit" , "(C)V" ) ; } else if ( name . equals ( "pattern-separator" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setPatternSeparator" , "(C)V" ) ; } else if ( name . equals ( "NaN" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setNaN" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , value ) ) ; il . append ( new INVOKEVIRTUAL ( method ) ) ; valid = false ; } else if ( name . equals ( "infinity" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setInfinity" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , value ) ) ; il . append ( new INVOKEVIRTUAL ( method ) ) ; valid = false ; } else { valid = false ; } if ( valid ) { il . append ( DUP ) ; il . append ( new PUSH ( cpg , value . charAt ( 0 ) ) ) ; il . append ( new INVOKEVIRTUAL ( method ) ) ; } } final int put = cpg . addMethodref ( TRANSLET_CLASS , "addDecimalFormat" , "(" + STRING_SIG + DFS_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( put ) ) ; } public static void translateDefaultDFS ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( DFS_CLASS , "<init>" , "(" + LOCALE_SIG + ")V" ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; il . append ( new NEW ( cpg . addClass ( DFS_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( new GETSTATIC ( cpg . addFieldref ( LOCALE_CLASS , "US" , LOCALE_SIG ) ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; int nan = cpg . addMethodref ( DFS_CLASS , "setNaN" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "NaN" ) ) ; il . append ( new INVOKEVIRTUAL ( nan ) ) ; int inf = cpg . addMethodref ( DFS_CLASS , "setInfinity" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "Infinity" ) ) ; il . append ( new INVOKEVIRTUAL ( inf ) ) ; final int put = cpg . addMethodref ( TRANSLET_CLASS , "addDecimalFormat" , "(" + STRING_SIG + DFS_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( put ) ) ; } } 	1	['5', '3', '0', '21', '32', '2', '2', '20', '4', '1', '518', '1', '1', '0.9375', '0.4', '3', '7', '102', '17', '4.4', '1']
package org . apache . xalan . lib . sql ; import java . math . BigDecimal ; import java . sql . Connection ; import java . sql . Date ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Statement ; import java . sql . Time ; import java . sql . Timestamp ; import java . util . Enumeration ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBooleanStatic ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class XConnection { private static final boolean DEBUG = false ; private ConnectionPool m_ConnectionPool = null ; private boolean m_DefaultPoolingEnabled = false ; private Vector m_OpenSQLDocuments = new Vector ( ) ; private ConnectionPoolManager m_PoolMgr = new ConnectionPoolManager ( ) ; private Vector m_ParameterList = new Vector ( ) ; private SQLErrorDocument m_Error = null ; private boolean m_IsDefaultPool = false ; private boolean m_IsStreamingEnabled = true ; public XConnection ( ) { } public XConnection ( ExpressionContext exprContext , String ConnPoolName ) { connect ( exprContext , ConnPoolName ) ; } public XConnection ( ExpressionContext exprContext , String driver , String dbURL ) { connect ( exprContext , driver , dbURL ) ; } public XConnection ( ExpressionContext exprContext , NodeList list ) { connect ( exprContext , list ) ; } public XConnection ( ExpressionContext exprContext , String driver , String dbURL , String user , String password ) { connect ( exprContext , driver , dbURL , user , password ) ; } public XConnection ( ExpressionContext exprContext , String driver , String dbURL , Element protocolElem ) { connect ( exprContext , driver , dbURL , protocolElem ) ; } public XBooleanStatic connect ( ExpressionContext exprContext , String ConnPoolName ) { try { m_ConnectionPool = m_PoolMgr . getPool ( ConnPoolName ) ; if ( m_ConnectionPool == null ) throw new java . lang . IllegalArgumentException ( "Invalid Pool Name" ) ; m_IsDefaultPool = false ; return new XBooleanStatic ( true ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , String driver , String dbURL ) { try { init ( driver , dbURL , new Properties ( ) ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , Element protocolElem ) { try { initFromElement ( protocolElem ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , NodeList list ) { try { initFromElement ( ( Element ) list . item ( 0 ) ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , String driver , String dbURL , String user , String password ) { try { Properties prop = new Properties ( ) ; prop . put ( "user" , user ) ; prop . put ( "password" , password ) ; init ( driver , dbURL , prop ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , String driver , String dbURL , Element protocolElem ) { try { Properties prop = new Properties ( ) ; NamedNodeMap atts = protocolElem . getAttributes ( ) ; for ( int i = 0 ; i < atts . getLength ( ) ; i ++ ) { prop . put ( atts . item ( i ) . getNodeName ( ) , atts . item ( i ) . getNodeValue ( ) ) ; } init ( driver , dbURL , prop ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return new XBooleanStatic ( false ) ; } } private void initFromElement ( Element e ) throws SQLException { Properties prop = new Properties ( ) ; String driver = "" ; String dbURL = "" ; Node n = e . getFirstChild ( ) ; if ( null == n ) return ; do { String nName = n . getNodeName ( ) ; if ( nName . equalsIgnoreCase ( "dbdriver" ) ) { driver = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { driver = n1 . getNodeValue ( ) ; } } if ( nName . equalsIgnoreCase ( "dburl" ) ) { dbURL = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { dbURL = n1 . getNodeValue ( ) ; } } if ( nName . equalsIgnoreCase ( "password" ) ) { String s = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { s = n1 . getNodeValue ( ) ; } prop . put ( "password" , s ) ; } if ( nName . equalsIgnoreCase ( "user" ) ) { String s = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { s = n1 . getNodeValue ( ) ; } prop . put ( "user" , s ) ; } if ( nName . equalsIgnoreCase ( "protocol" ) ) { String Name = "" ; NamedNodeMap attrs = n . getAttributes ( ) ; Node n1 = attrs . getNamedItem ( "name" ) ; if ( null != n1 ) { String s = "" ; Name = n1 . getNodeValue ( ) ; Node n2 = n . getFirstChild ( ) ; if ( null != n2 ) s = n2 . getNodeValue ( ) ; prop . put ( Name , s ) ; } } } while ( ( n = n . getNextSibling ( ) ) != null ) ; init ( driver , dbURL , prop ) ; } private void init ( String driver , String dbURL , Properties prop ) throws SQLException { Connection con = null ; if ( DEBUG ) System . out . println ( "XConnection, Connection Init" ) ; String user = prop . getProperty ( "user" ) ; if ( user == null ) user = "" ; String passwd = prop . getProperty ( "password" ) ; if ( passwd == null ) passwd = "" ; String poolName = driver + dbURL + user + passwd ; ConnectionPool cpool = m_PoolMgr . getPool ( poolName ) ; if ( cpool == null ) { if ( DEBUG ) { System . out . println ( "XConnection, Creating Connection" ) ; System . out . println ( " Driver  :" + driver ) ; System . out . println ( " URL     :" + dbURL ) ; System . out . println ( " user    :" + user ) ; System . out . println ( " passwd  :" + passwd ) ; } DefaultConnectionPool defpool = new DefaultConnectionPool ( ) ; if ( ( DEBUG ) && ( defpool == null ) ) System . out . println ( "Failed to Create a Default Connection Pool" ) ; defpool . setDriver ( driver ) ; defpool . setURL ( dbURL ) ; defpool . setProtocol ( prop ) ; if ( m_DefaultPoolingEnabled ) defpool . setPoolEnabled ( true ) ; m_PoolMgr . registerPool ( poolName , defpool ) ; m_ConnectionPool = defpool ; } else { m_ConnectionPool = cpool ; } m_IsDefaultPool = true ; try { con = m_ConnectionPool . getConnection ( ) ; } catch ( SQLException e ) { if ( con != null ) { m_ConnectionPool . releaseConnectionOnError ( con ) ; con = null ; } throw e ; } finally { m_ConnectionPool . releaseConnection ( con ) ; } } public DTM query ( ExpressionContext exprContext , String queryString ) { Connection con = null ; Statement stmt = null ; ResultSet rs = null ; DTMManagerDefault mgrDefault = null ; SQLDocument doc = null ; try { if ( DEBUG ) System . out . println ( "query()" ) ; if ( null == m_ConnectionPool ) { return null ; } try { con = m_ConnectionPool . getConnection ( ) ; stmt = con . createStatement ( ) ; rs = stmt . executeQuery ( queryString ) ; } catch ( SQLException e ) { try { if ( null != rs ) rs . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } buildErrorDocument ( exprContext , e ) ; return null ; } if ( DEBUG ) System . out . println ( "..creatingSQLDocument" ) ; DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; doc = new SQLDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , m_ConnectionPool , con , stmt , rs , m_IsStreamingEnabled ) ; if ( null != doc ) { if ( DEBUG ) System . out . println ( "..returning Document" ) ; mgrDefault . addDTM ( doc , dtmIdent ) ; m_OpenSQLDocuments . addElement ( doc ) ; return doc ; } else { return null ; } } catch ( SQLException e ) { if ( ( doc != null ) && ( mgrDefault != null ) ) { doc . closeOnError ( ) ; mgrDefault . release ( doc , true ) ; } buildErrorDocument ( exprContext , e ) ; return null ; } catch ( Exception e ) { if ( ( doc != null ) && ( mgrDefault != null ) ) { doc . closeOnError ( ) ; mgrDefault . release ( doc , true ) ; } if ( DEBUG ) System . out . println ( "exception in query()" ) ; buildErrorDocument ( exprContext , e ) ; return null ; } finally { if ( DEBUG ) System . out . println ( "leaving query()" ) ; } } public DTM pquery ( ExpressionContext exprContext , String queryString ) { Connection con = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { int indx ; try { con = m_ConnectionPool . getConnection ( ) ; stmt = con . prepareStatement ( queryString ) ; } catch ( SQLException e ) { try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } throw e ; } if ( DEBUG ) System . out . println ( "..building Prepared Statement" ) ; try { Enumeration enum = m_ParameterList . elements ( ) ; indx = 1 ; while ( enum . hasMoreElements ( ) ) { QueryParameter qp = ( QueryParameter ) enum . nextElement ( ) ; setParameter ( indx , stmt , qp ) ; indx ++ ; } rs = stmt . executeQuery ( ) ; } catch ( SQLException e ) { try { if ( null != rs ) rs . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } throw e ; } if ( DEBUG ) System . out . println ( "..creatingSQLDocument" ) ; DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; SQLDocument doc = new SQLDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , m_ConnectionPool , con , stmt , rs , m_IsStreamingEnabled ) ; if ( null != doc ) { if ( DEBUG ) System . out . println ( "..returning Document" ) ; mgrDefault . addDTM ( doc , dtmIdent ) ; m_OpenSQLDocuments . addElement ( doc ) ; return doc ; } else { return null ; } } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return null ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return null ; } } public DTM pquery ( ExpressionContext exprContext , String queryString , String typeInfo ) { Connection con = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { int indx ; StringTokenizer plist = new StringTokenizer ( typeInfo ) ; indx = 0 ; while ( plist . hasMoreTokens ( ) ) { String value = plist . nextToken ( ) ; QueryParameter qp = ( QueryParameter ) m_ParameterList . elementAt ( indx ) ; if ( null != qp ) { qp . setType ( value ) ; } indx ++ ; } try { con = m_ConnectionPool . getConnection ( ) ; stmt = con . prepareStatement ( queryString ) ; } catch ( SQLException e ) { try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } throw e ; } if ( DEBUG ) System . out . println ( "..building Prepared Statement" ) ; try { Enumeration enum = m_ParameterList . elements ( ) ; indx = 1 ; while ( enum . hasMoreElements ( ) ) { QueryParameter qp = ( QueryParameter ) enum . nextElement ( ) ; setParameter ( indx , stmt , qp ) ; indx ++ ; } rs = stmt . executeQuery ( ) ; } catch ( SQLException e ) { try { if ( null != rs ) rs . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != stmt ) stmt . close ( ) ; } catch ( Exception e1 ) { } try { if ( null != con ) m_ConnectionPool . releaseConnectionOnError ( con ) ; } catch ( Exception e1 ) { } throw e ; } if ( DEBUG ) System . out . println ( "..creatingSQLDocument" ) ; DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; SQLDocument doc = new SQLDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , m_ConnectionPool , con , stmt , rs , m_IsStreamingEnabled ) ; if ( null != doc ) { if ( DEBUG ) System . out . println ( "..returning Document" ) ; mgrDefault . addDTM ( doc , dtmIdent ) ; m_OpenSQLDocuments . addElement ( doc ) ; return doc ; } else { return null ; } } catch ( SQLException e ) { buildErrorDocument ( exprContext , e ) ; return null ; } catch ( Exception e ) { buildErrorDocument ( exprContext , e ) ; return null ; } } public void addParameter ( String value ) { addParameterWithType ( value , null ) ; } public void addParameterWithType ( String value , String Type ) { m_ParameterList . addElement ( new QueryParameter ( value , Type ) ) ; } public void addParameterFromElement ( Element e ) { NamedNodeMap attrs = e . getAttributes ( ) ; Node Type = attrs . getNamedItem ( "type" ) ; Node n1 = e . getFirstChild ( ) ; if ( null != n1 ) { String value = n1 . getNodeValue ( ) ; if ( value == null ) value = "" ; m_ParameterList . addElement ( new QueryParameter ( value , Type . getNodeValue ( ) ) ) ; } } public void addParameterFromElement ( NodeList nl ) { int count = nl . getLength ( ) ; for ( int x = 0 ; x < count ; x ++ ) { addParameters ( ( Element ) nl . item ( x ) ) ; } } private void addParameters ( Element elem ) { Node n = elem . getFirstChild ( ) ; if ( null == n ) return ; do { if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap attrs = n . getAttributes ( ) ; Node Type = attrs . getNamedItem ( "type" ) ; String TypeStr ; if ( Type == null ) TypeStr = "string" ; else TypeStr = Type . getNodeValue ( ) ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { String value = n1 . getNodeValue ( ) ; if ( value == null ) value = "" ; m_ParameterList . addElement ( new QueryParameter ( value , TypeStr ) ) ; } } } while ( ( n = n . getNextSibling ( ) ) != null ) ; } public void clearParameters ( ) { m_ParameterList . removeAllElements ( ) ; } public void enableDefaultConnectionPool ( ) { if ( DEBUG ) System . out . println ( "Enabling Default Connection Pool" ) ; m_DefaultPoolingEnabled = true ; if ( m_ConnectionPool == null ) return ; if ( m_IsDefaultPool ) return ; m_ConnectionPool . setPoolEnabled ( true ) ; } public void disableDefaultConnectionPool ( ) { if ( DEBUG ) System . out . println ( "Disabling Default Connection Pool" ) ; m_DefaultPoolingEnabled = false ; if ( m_ConnectionPool == null ) return ; if ( ! m_IsDefaultPool ) return ; m_ConnectionPool . setPoolEnabled ( false ) ; } public void enableStreamingMode ( ) { if ( DEBUG ) System . out . println ( "Enabling Streaming Mode" ) ; m_IsStreamingEnabled = true ; } public void disableStreamingMode ( ) { if ( DEBUG ) System . out . println ( "Disable Streaming Mode" ) ; m_IsStreamingEnabled = false ; } public DTM getError ( ) { return m_Error ; } public void close ( ) throws SQLException { if ( DEBUG ) System . out . println ( "Entering XConnection.close" ) ; while ( m_OpenSQLDocuments . size ( ) != 0 ) { SQLDocument d = ( SQLDocument ) m_OpenSQLDocuments . elementAt ( 0 ) ; d . close ( ) ; m_OpenSQLDocuments . removeElementAt ( 0 ) ; } if ( DEBUG ) System . out . println ( "Exiting XConnection.close" ) ; } public void close ( SQLDocument sqldoc ) throws SQLException { if ( DEBUG ) System . out . println ( "Entering XConnection.close" ) ; int size = m_OpenSQLDocuments . size ( ) ; for ( int x = 0 ; x < size ; x ++ ) { SQLDocument d = ( SQLDocument ) m_OpenSQLDocuments . elementAt ( x ) ; if ( d == sqldoc ) { d . close ( ) ; m_OpenSQLDocuments . removeElementAt ( x ) ; } } } public void setParameter ( int pos , PreparedStatement stmt , QueryParameter p ) throws SQLException { String type = p . getType ( ) ; if ( type . equalsIgnoreCase ( "string" ) ) { stmt . setString ( pos , p . getValue ( ) ) ; } if ( type . equalsIgnoreCase ( "bigdecimal" ) ) { stmt . setBigDecimal ( pos , new BigDecimal ( p . getValue ( ) ) ) ; } if ( type . equalsIgnoreCase ( "boolean" ) ) { Integer i = new Integer ( p . getValue ( ) ) ; boolean b = ( ( i . intValue ( ) != 0 ) ? false : true ) ; stmt . setBoolean ( pos , b ) ; } if ( type . equalsIgnoreCase ( "bytes" ) ) { stmt . setBytes ( pos , p . getValue ( ) . getBytes ( ) ) ; } if ( type . equalsIgnoreCase ( "date" ) ) { stmt . setDate ( pos , Date . valueOf ( p . getValue ( ) ) ) ; } if ( type . equalsIgnoreCase ( "double" ) ) { Double d = new Double ( p . getValue ( ) ) ; stmt . setDouble ( pos , d . doubleValue ( ) ) ; } if ( type . equalsIgnoreCase ( "float" ) ) { Float f = new Float ( p . getValue ( ) ) ; stmt . setFloat ( pos , f . floatValue ( ) ) ; } if ( type . equalsIgnoreCase ( "long" ) ) { Long l = new Long ( p . getValue ( ) ) ; stmt . setLong ( pos , l . longValue ( ) ) ; } if ( type . equalsIgnoreCase ( "short" ) ) { Short s = new Short ( p . getValue ( ) ) ; stmt . setShort ( pos , s . shortValue ( ) ) ; } if ( type . equalsIgnoreCase ( "time" ) ) { stmt . setTime ( pos , Time . valueOf ( p . getValue ( ) ) ) ; } if ( type . equalsIgnoreCase ( "timestamp" ) ) { stmt . setTimestamp ( pos , Timestamp . valueOf ( p . getValue ( ) ) ) ; } } private void buildErrorDocument ( ExpressionContext exprContext , SQLException excp ) { try { DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; m_Error = new SQLErrorDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , excp ) ; mgrDefault . addDTM ( m_Error , dtmIdent ) ; } catch ( Exception e ) { m_Error = null ; } } private void buildErrorDocument ( ExpressionContext exprContext , Exception excp ) { try { DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; m_Error = new SQLErrorDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , excp ) ; mgrDefault . addDTM ( m_Error , dtmIdent ) ; } catch ( Exception e ) { m_Error = null ; } } protected void finalize ( ) { if ( DEBUG ) System . out . println ( "In XConnection, finalize" ) ; try { close ( ) ; } catch ( Exception e ) { } } } 	1	['34', '1', '0', '12', '127', '211', '0', '12', '28', '0.656565657', '1600', '1', '3', '0', '0.196078431', '0', '0', '45.79411765', '7', '1.6176', '1']
package org . apache . xml . utils ; public class ObjectVector implements Cloneable { protected int m_blocksize ; protected Object m_map [ ] ; protected int m_firstFree = 0 ; protected int m_mapSize ; public ObjectVector ( ) { m_blocksize = 32 ; m_mapSize = m_blocksize ; m_map = new Object [ m_blocksize ] ; } public ObjectVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new Object [ blocksize ] ; } public ObjectVector ( int blocksize , int increaseSize ) { m_blocksize = increaseSize ; m_mapSize = blocksize ; m_map = new Object [ blocksize ] ; } public ObjectVector ( ObjectVector v ) { m_map = new Object [ v . m_mapSize ] ; m_mapSize = v . m_mapSize ; m_firstFree = v . m_firstFree ; m_blocksize = v . m_blocksize ; System . arraycopy ( v . m_map , 0 , m_map , 0 , m_firstFree ) ; } public final int size ( ) { return m_firstFree ; } public final void setSize ( int sz ) { m_firstFree = sz ; } public final void addElement ( Object value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void addElements ( Object value , int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map [ m_firstFree ] = value ; m_firstFree ++ ; } } public final void addElements ( int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_firstFree += numberOfElements ; } public final void insertElementAt ( Object value , int at ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public final void removeAllElements ( ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = null ; } m_firstFree = 0 ; } public final boolean removeElement ( Object s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + 1 ) < m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = null ; m_firstFree -- ; return true ; } } return false ; } public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i , m_firstFree ) ; else m_map [ i ] = null ; m_firstFree -- ; } public final void setElementAt ( Object value , int index ) { m_map [ index ] = value ; } public final Object elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( Object s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) return true ; } return false ; } public final int indexOf ( Object elem , int index ) { for ( int i = index ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int indexOf ( Object elem ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int lastIndexOf ( Object elem ) { for ( int i = ( m_firstFree - 1 ) ; i >= 0 ; i -- ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final void setToSize ( int size ) { Object newMap [ ] = new Object [ size ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree ) ; m_mapSize = size ; m_map = newMap ; } public Object clone ( ) throws CloneNotSupportedException { return new ObjectVector ( this ) ; } } 	1	['21', '1', '1', '5', '23', '0', '5', '0', '21', '0.3375', '516', '1', '0', '0', '0.5', '0', '0', '23.38095238', '4', '1.7143', '1']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; public class FuncSubstring extends Function3Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XMLString s1 = m_arg0 . execute ( xctxt ) . xstr ( ) ; double start = m_arg1 . execute ( xctxt ) . num ( ) ; int lenOfS1 = s1 . length ( ) ; XMLString substr ; if ( lenOfS1 <= 0 ) return XString . EMPTYSTRING ; else { int startIndex ; if ( Double . isNaN ( start ) ) { start = - 1000000 ; startIndex = 0 ; } else { start = Math . round ( start ) ; startIndex = ( start > 0 ) ? ( int ) start - 1 : 0 ; } if ( null != m_arg2 ) { double len = m_arg2 . num ( xctxt ) ; int end = ( int ) ( Math . round ( len ) + start ) - 1 ; if ( end < 0 ) end = 0 ; else if ( end > lenOfS1 ) end = lenOfS1 ; if ( startIndex > lenOfS1 ) startIndex = lenOfS1 ; substr = s1 . substring ( startIndex , end ) ; } else { if ( startIndex > lenOfS1 ) startIndex = lenOfS1 ; substr = s1 . substring ( startIndex ) ; } } return ( XString ) substr ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum < 2 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_TWO_OR_THREE , null ) ) ; } } 	1	['4', '6', '0', '8', '16', '6', '0', '8', '3', '2', '113', '0', '0', '0.955223881', '0.5', '2', '8', '27.25', '1', '0.75', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class AttributeValueTemplate extends AttributeValue { public AttributeValueTemplate ( String value , Parser parser , SyntaxTreeNode parent ) { setParent ( parent ) ; setParser ( parser ) ; if ( check ( value , parser ) ) { parseAVTemplate ( 0 , value , parser ) ; } } private void parseAVTemplate ( final int start , String text , Parser parser ) { String str ; if ( text == null ) return ; int open = start - 2 ; do { open = text . indexOf ( '{' , open + 2 ) ; } while ( ( open != - 1 ) && ( open < ( text . length ( ) - 1 ) ) && ( text . charAt ( open + 1 ) == '{' ) ) ; if ( open != - 1 ) { int close = open - 2 ; do { close = text . indexOf ( '}' , close + 2 ) ; } while ( ( close != - 1 ) && ( close < ( text . length ( ) - 1 ) ) && ( text . charAt ( close + 1 ) == '}' ) ) ; if ( open > start ) { str = removeDuplicateBraces ( text . substring ( start , open ) ) ; addElement ( new LiteralExpr ( str ) ) ; } if ( close > open + 1 ) { str = text . substring ( open + 1 , close ) ; str = removeDuplicateBraces ( text . substring ( open + 1 , close ) ) ; addElement ( parser . parseExpression ( this , str ) ) ; } parseAVTemplate ( close + 1 , text , parser ) ; } else if ( start < text . length ( ) ) { str = removeDuplicateBraces ( text . substring ( start ) ) ; addElement ( new LiteralExpr ( str ) ) ; } } public String removeDuplicateBraces ( String orig ) { String result = orig ; int index ; while ( ( index = result . indexOf ( "{{" ) ) != - 1 ) { result = result . substring ( 0 , index ) + result . substring ( index + 1 , result . length ( ) ) ; } while ( ( index = result . indexOf ( "}}" ) ) != - 1 ) { result = result . substring ( 0 , index ) + result . substring ( index + 1 , result . length ( ) ) ; } return ( result ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Vector contents = getContents ( ) ; final int n = contents . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) contents . elementAt ( i ) ; if ( ! exp . typeCheck ( stable ) . identicalTo ( Type . String ) ) { contents . setElementAt ( new CastExpr ( exp , Type . String ) , i ) ; } } return _type = Type . String ; } public String toString ( ) { final StringBuffer buffer = new StringBuffer ( "AVT:[" ) ; final int count = elementCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { buffer . append ( elementAt ( i ) . toString ( ) ) ; if ( i < count - 1 ) buffer . append ( ' ' ) ; } return buffer . append ( ']' ) . toString ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( elementCount ( ) == 1 ) { final Expression exp = ( Expression ) elementAt ( 0 ) ; exp . translate ( classGen , methodGen ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initBuffer = cpg . addMethodref ( STRING_BUFFER_CLASS , "<init>" , "()V" ) ; final Instruction append = new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_BUFFER_CLASS , "append" , "(" + STRING_SIG + ")" + STRING_BUFFER_SIG ) ) ; final int toString = cpg . addMethodref ( STRING_BUFFER_CLASS , "toString" , "()" + STRING_SIG ) ; il . append ( new NEW ( cpg . addClass ( STRING_BUFFER_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( initBuffer ) ) ; final Enumeration enum = elements ( ) ; while ( enum . hasMoreElements ( ) ) { final Expression exp = ( Expression ) enum . nextElement ( ) ; exp . translate ( classGen , methodGen ) ; il . append ( append ) ; } il . append ( new INVOKEVIRTUAL ( toString ) ) ; } } private boolean check ( String value , Parser parser ) { if ( value == null ) return true ; final char [ ] chars = value . toCharArray ( ) ; int level = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '{' : if ( ( ( i + 1 ) == ( chars . length ) ) || ( chars [ i + 1 ] != '{' ) ) ++ level ; else i ++ ; break ; case '}' : if ( ( ( i + 1 ) == ( chars . length ) ) || ( chars [ i + 1 ] != '}' ) ) -- level ; else i ++ ; break ; default : continue ; } switch ( level ) { case 0 : case 1 : continue ; default : reportError ( getParent ( ) , parser , ErrorMsg . ATTR_VAL_TEMPLATE_ERR , value ) ; return false ; } } if ( level != 0 ) { reportError ( getParent ( ) , parser , ErrorMsg . ATTR_VAL_TEMPLATE_ERR , value ) ; return false ; } return true ; } } 	1	['7', '4', '0', '22', '49', '21', '4', '19', '5', '2', '452', '0', '0', '0.923076923', '0.339285714', '2', '7', '63.57142857', '14', '5.1429', '1']
package org . apache . xml . utils . synthetic . reflection ; import org . apache . xml . utils . synthetic . Class ; import org . apache . xml . utils . synthetic . SynthesisException ; public class Field extends Object implements Member { public String name , initializer = null ; int modifiers ; java . lang . reflect . Field realfield = null ; Class declaringClass , type ; public Field ( java . lang . reflect . Field realfield , org . apache . xml . utils . synthetic . Class declaringClass ) { this ( realfield . getName ( ) , declaringClass ) ; this . realfield = realfield ; this . type = org . apache . xml . utils . synthetic . Class . forClass ( realfield . getType ( ) ) ; } public Field ( String name , org . apache . xml . utils . synthetic . Class declaringClass ) { this . name = name ; this . declaringClass = declaringClass ; } public boolean equals ( Object obj ) { if ( realfield != null ) return realfield . equals ( obj ) ; else if ( obj instanceof Field ) { Field objf = ( Field ) obj ; return ( declaringClass . equals ( objf . declaringClass ) && name . equals ( objf . name ) && type . equals ( objf . type ) ) ; } else return false ; } public Object get ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . get ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean getBoolean ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getBoolean ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public byte getByte ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getByte ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public char getChar ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getChar ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public org . apache . xml . utils . synthetic . Class getDeclaringClass ( ) { if ( realfield != null ) return org . apache . xml . utils . synthetic . Class . forClass ( realfield . getDeclaringClass ( ) ) ; throw new java . lang . IllegalStateException ( ) ; } public double getDouble ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getDouble ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public float getFloat ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getFloat ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public int getInt ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getInt ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public long getLong ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getLong ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public int getModifiers ( ) { if ( realfield != null ) modifiers = realfield . getModifiers ( ) ; return modifiers ; } public String getInitializer ( ) { return initializer ; } public void setInitializer ( String i ) throws SynthesisException { if ( realfield != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; initializer = i ; } public java . lang . String getName ( ) { return name ; } public short getShort ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getShort ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public Class getType ( ) { if ( realfield != null ) type = Class . forClass ( realfield . getType ( ) ) ; return type ; } public void setType ( org . apache . xml . utils . synthetic . Class type ) throws SynthesisException { if ( realfield != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . type = type ; } public int hashCode ( ) { if ( realfield != null ) return realfield . hashCode ( ) ; else return declaringClass . getName ( ) . hashCode ( ) ^ name . hashCode ( ) ; } public void set ( Object obj , Object value ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . set ( obj , value ) ; throw new java . lang . IllegalStateException ( ) ; } public void setBoolean ( Object obj , boolean z ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setBoolean ( obj , z ) ; throw new java . lang . IllegalStateException ( ) ; } public void setByte ( Object obj , byte b ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setByte ( obj , b ) ; throw new java . lang . IllegalStateException ( ) ; } public void setChar ( Object obj , char c ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setChar ( obj , c ) ; throw new java . lang . IllegalStateException ( ) ; } public void setDeclaringClass ( org . apache . xml . utils . synthetic . Class declaringClass ) { this . declaringClass = declaringClass ; } public void setDouble ( Object obj , double d ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setDouble ( obj , d ) ; throw new java . lang . IllegalStateException ( ) ; } public void setFloat ( Object obj , float f ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setFloat ( obj , f ) ; throw new java . lang . IllegalStateException ( ) ; } public void setInt ( Object obj , int i ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setInt ( obj , i ) ; throw new java . lang . IllegalStateException ( ) ; } public void setLong ( Object obj , long l ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setLong ( obj , l ) ; throw new java . lang . IllegalStateException ( ) ; } public void setModifiers ( int modifiers ) throws SynthesisException { if ( realfield != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . modifiers = modifiers ; } public void setShort ( Object obj , short s ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setShort ( obj , s ) ; throw new java . lang . IllegalStateException ( ) ; } public String toString ( ) { if ( realfield != null ) return realfield . toString ( ) ; throw new java . lang . IllegalStateException ( ) ; } public String toSource ( ) { StringBuffer sb = new StringBuffer ( java . lang . reflect . Modifier . toString ( getModifiers ( ) ) ) . append ( ' ' ) . append ( getType ( ) . getJavaName ( ) ) . append ( ' ' ) . append ( getName ( ) ) ; String i = getInitializer ( ) ; if ( i != null && i . length ( ) > 0 ) sb . append ( '=' ) . append ( i ) ; sb . append ( ';' ) ; return sb . toString ( ) ; } } 	1	['33', '1', '0', '3', '73', '0', '1', '3', '33', '0.75', '469', '0', '2', '0', '0.158508159', '1', '1', '13.03030303', '6', '1.303', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncLocalPart extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = getArg0AsNode ( xctxt ) ; if ( DTM . NULL == context ) return XString . EMPTYSTRING ; DTM dtm = xctxt . getDTM ( context ) ; String s = ( context != DTM . NULL ) ? dtm . getLocalName ( context ) : "" ; if ( s . startsWith ( "#" ) || s . equals ( "xmlns" ) ) return XString . EMPTYSTRING ; return new XString ( s ) ; } } 	1	['2', '5', '0', '5', '9', '1', '0', '5', '2', '2', '42', '0', '0', '0.982142857', '0.75', '3', '8', '20', '1', '0.5', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncCount extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator nl = m_arg0 . asIterator ( xctxt , xctxt . getCurrentNode ( ) ) ; int i = nl . getLength ( ) ; nl . detach ( ) ; return new XNumber ( ( double ) i ) ; } } 	1	['2', '4', '0', '6', '8', '1', '0', '6', '2', '2', '23', '0', '0', '0.979591837', '0.75', '1', '6', '10.5', '1', '0.5', '1']
package org . apache . xalan . lib ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . TimeZone ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class ExsltDatetime { static final String dt = "yyyy-MM-dd'T'HH:mm:ss" ; static final String d = "yyyy-MM-dd" ; static final String gym = "yyyy-MM" ; static final String gy = "yyyy" ; static final String gmd = "--MM-dd" ; static final String gm = "--MM--" ; static final String gd = "---dd" ; static final String t = "HH:mm:ss" ; static final String EMPTY_STR = "" ; public static String dateTime ( ) { Calendar cal = Calendar . getInstance ( ) ; Date datetime = cal . getTime ( ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( dt ) ; StringBuffer buff = new StringBuffer ( dateFormat . format ( datetime ) ) ; int offset = cal . get ( Calendar . ZONE_OFFSET ) + cal . get ( Calendar . DST_OFFSET ) ; if ( offset == 0 ) buff . append ( "Z" ) ; else { int hrs = offset / ( 60 * 60 * 1000 ) ; int min = offset % ( 60 * 60 * 1000 ) ; char posneg = hrs < 0 ? '-' : '+' ; buff . append ( posneg + formatDigits ( hrs ) + ':' + formatDigits ( min ) ) ; } return buff . toString ( ) ; } private static String formatDigits ( int q ) { String dd = String . valueOf ( Math . abs ( q ) ) ; return dd . length ( ) == 1 ? '0' + dd : dd ; } public static String date ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String leader = edz [ 0 ] ; String datetime = edz [ 1 ] ; String zone = edz [ 2 ] ; if ( datetime == null || zone == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d } ; String formatOut = d ; Date date = testFormats ( datetime , formatsIn ) ; if ( date == null ) return EMPTY_STR ; SimpleDateFormat dateFormat = new SimpleDateFormat ( formatOut ) ; dateFormat . setLenient ( false ) ; String dateOut = dateFormat . format ( date ) ; if ( dateOut . length ( ) == 0 ) return EMPTY_STR ; else return ( leader + dateOut + zone ) ; } public static String date ( ) { String datetime = dateTime ( ) . toString ( ) ; String date = datetime . substring ( 0 , datetime . indexOf ( "T" ) ) ; String zone = datetime . substring ( getZoneStart ( datetime ) ) ; return ( date + zone ) ; } public static String time ( String timeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( timeIn ) ; String time = edz [ 1 ] ; String zone = edz [ 2 ] ; if ( time == null || zone == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d } ; String formatOut = t ; Date date = testFormats ( time , formatsIn ) ; if ( date == null ) return EMPTY_STR ; SimpleDateFormat dateFormat = new SimpleDateFormat ( formatOut ) ; String out = dateFormat . format ( date ) ; return ( out + zone ) ; } public static String time ( ) { String datetime = dateTime ( ) . toString ( ) ; String time = datetime . substring ( datetime . indexOf ( "T" ) + 1 ) ; String zone = datetime . substring ( getZoneStart ( datetime ) ) ; return ( time + zone ) ; } public static double year ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; boolean ad = edz [ 0 ] . length ( ) == 0 ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d , gym , gy } ; double yr = getNumber ( datetime , formats , Calendar . YEAR ) ; if ( ad || yr == Double . NaN ) return yr ; else return - yr ; } public static double year ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . YEAR ) ; } public static double monthInYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d , gym , gm , gmd } ; return getNumber ( datetime , formats , Calendar . MONTH ) ; } public static double monthInYear ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . MONTH ) ; } public static double weekInYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d } ; return getNumber ( datetime , formats , Calendar . WEEK_OF_YEAR ) ; } public static double weekInYear ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . WEEK_OF_YEAR ) ; } public static double dayInYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d } ; return getNumber ( datetime , formats , Calendar . DAY_OF_YEAR ) ; } public static double dayInYear ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . DAY_OF_YEAR ) ; } public static double dayInMonth ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; String [ ] formats = { dt , d , gmd , gd } ; double day = getNumber ( datetime , formats , Calendar . DAY_OF_MONTH ) ; return day ; } public static double dayInMonth ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . DAY_OF_MONTH ) ; } public static double dayOfWeekInMonth ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d } ; return getNumber ( datetime , formats , Calendar . DAY_OF_WEEK_IN_MONTH ) ; } public static double dayOfWeekInMonth ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . DAY_OF_WEEK_IN_MONTH ) ; } public static double dayInWeek ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d } ; return getNumber ( datetime , formats , Calendar . DAY_OF_WEEK ) ; } public static double dayInWeek ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . DAY_OF_WEEK ) ; } public static double hourInDay ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , t } ; return getNumber ( datetime , formats , Calendar . HOUR_OF_DAY ) ; } public static double hourInDay ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . HOUR_OF_DAY ) ; } public static double minuteInHour ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , t } ; return getNumber ( datetime , formats , Calendar . MINUTE ) ; } public static double minuteInHour ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . MINUTE ) ; } public static double secondInMinute ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , t } ; return getNumber ( datetime , formats , Calendar . SECOND ) ; } public static double secondInMinute ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . SECOND ) ; } public static XObject leapYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , d , gym , gy } ; double dbl = getNumber ( datetime , formats , Calendar . YEAR ) ; if ( dbl == Double . NaN ) return new XNumber ( Double . NaN ) ; int yr = ( int ) dbl ; return new XBoolean ( yr % 400 == 0 || ( yr % 100 != 0 && yr % 4 == 0 ) ) ; } public static boolean leapYear ( ) { Calendar cal = Calendar . getInstance ( ) ; int yr = ( int ) cal . get ( Calendar . YEAR ) ; return ( yr % 400 == 0 || ( yr % 100 != 0 && yr % 4 == 0 ) ) ; } public static String monthName ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d , gym , gm } ; String formatOut = "MMMM" ; return getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ; } public static String monthName ( ) { Calendar cal = Calendar . getInstance ( ) ; String format = "MMMM" ; return getNameOrAbbrev ( format ) ; } public static String monthAbbreviation ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d , gym , gm } ; String formatOut = "MMM" ; return getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ; } public static String monthAbbreviation ( ) { String format = "MMM" ; return getNameOrAbbrev ( format ) ; } public static String dayName ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d } ; String formatOut = "EEEE" ; return getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ; } public static String dayName ( ) { String format = "EEEE" ; return getNameOrAbbrev ( format ) ; } public static String dayAbbreviation ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d } ; String formatOut = "EEE" ; return getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ; } public static String dayAbbreviation ( ) { String format = "EEE" ; return getNameOrAbbrev ( format ) ; } private static String [ ] getEraDatetimeZone ( String in ) { String leader = "" ; String datetime = in ; String zone = "" ; if ( in . charAt ( 0 ) == '-' && ! in . startsWith ( "--" ) ) { leader = "-" ; datetime = in . substring ( 1 ) ; } int z = getZoneStart ( datetime ) ; if ( z > 0 ) { zone = datetime . substring ( z ) ; datetime = datetime . substring ( 0 , z ) ; } else if ( z == - 2 ) zone = null ; return new String [ ] { leader , datetime , zone } ; } private static int getZoneStart ( String datetime ) { if ( datetime . indexOf ( "Z" ) == datetime . length ( ) - 1 ) return datetime . length ( ) - 1 ; else if ( datetime . length ( ) >= 6 && datetime . charAt ( datetime . length ( ) - 3 ) == ':' && ( datetime . charAt ( datetime . length ( ) - 6 ) == '+' || datetime . charAt ( datetime . length ( ) - 6 ) == '-' ) ) { try { SimpleDateFormat dateFormat = new SimpleDateFormat ( "HH:mm" ) ; dateFormat . setLenient ( false ) ; Date d = dateFormat . parse ( datetime . substring ( datetime . length ( ) - 5 ) ) ; return datetime . length ( ) - 6 ; } catch ( ParseException pe ) { System . out . println ( "ParseException " + pe . getErrorOffset ( ) ) ; return - 2 ; } } return - 1 ; } private static Date testFormats ( String in , String [ ] formats ) throws ParseException { for ( int i = 0 ; i < formats . length ; i ++ ) { try { SimpleDateFormat dateFormat = new SimpleDateFormat ( formats [ i ] ) ; dateFormat . setLenient ( false ) ; return dateFormat . parse ( in ) ; } catch ( ParseException pe ) { } } return null ; } private static double getNumber ( String in , String [ ] formats , int calField ) throws ParseException { Calendar cal = Calendar . getInstance ( ) ; cal . setLenient ( false ) ; Date date = testFormats ( in , formats ) ; if ( date == null ) return Double . NaN ; cal . setTime ( date ) ; return cal . get ( calField ) ; } private static String getNameOrAbbrev ( String in , String [ ] formatsIn , String formatOut ) throws ParseException { for ( int i = 0 ; i < formatsIn . length ; i ++ ) { try { SimpleDateFormat dateFormat = new SimpleDateFormat ( formatsIn [ i ] ) ; dateFormat . setLenient ( false ) ; Date dt = dateFormat . parse ( in ) ; dateFormat . applyPattern ( formatOut ) ; return dateFormat . format ( dt ) ; } catch ( ParseException pe ) { } } return "" ; } private static String getNameOrAbbrev ( String format ) { Calendar cal = Calendar . getInstance ( ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; return dateFormat . format ( cal . getTime ( ) ) ; } public static String formatDate ( String dateTime , String pattern ) { final String yearSymbols = "Gy" ; final String monthSymbols = "M" ; final String daySymbols = "dDEFwW" ; TimeZone timeZone ; String zone ; if ( dateTime . endsWith ( "Z" ) || dateTime . endsWith ( "z" ) ) { timeZone = TimeZone . getTimeZone ( "GMT" ) ; dateTime = dateTime . substring ( 0 , dateTime . length ( ) - 1 ) + "GMT" ; zone = "z" ; } else if ( ( dateTime . length ( ) >= 6 ) && ( dateTime . charAt ( dateTime . length ( ) - 3 ) == ':' ) && ( ( dateTime . charAt ( dateTime . length ( ) - 6 ) == '+' ) || ( dateTime . charAt ( dateTime . length ( ) - 6 ) == '-' ) ) ) { String offset = dateTime . substring ( dateTime . length ( ) - 6 ) ; if ( "+00:00" . equals ( offset ) || "-00:00" . equals ( offset ) ) { timeZone = TimeZone . getTimeZone ( "GMT" ) ; } else { timeZone = TimeZone . getTimeZone ( "GMT" + offset ) ; } zone = "z" ; dateTime = dateTime . substring ( 0 , dateTime . length ( ) - 6 ) + "GMT" + offset ; } else { timeZone = TimeZone . getDefault ( ) ; zone = "" ; } String [ ] formats = { dt + zone , d , gym , gy } ; try { SimpleDateFormat inFormat = new SimpleDateFormat ( t + zone ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( strip ( yearSymbols + monthSymbols + daySymbols , pattern ) ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } for ( int i = 0 ; i < formats . length ; i ++ ) { try { SimpleDateFormat inFormat = new SimpleDateFormat ( formats [ i ] ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( pattern ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } } try { SimpleDateFormat inFormat = new SimpleDateFormat ( gmd ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( strip ( yearSymbols , pattern ) ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } try { SimpleDateFormat inFormat = new SimpleDateFormat ( gm ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( strip ( yearSymbols , pattern ) ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } try { SimpleDateFormat inFormat = new SimpleDateFormat ( gd ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( strip ( yearSymbols + monthSymbols , pattern ) ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } return EMPTY_STR ; } private static String strip ( String symbols , String pattern ) { int quoteSemaphore = 0 ; int i = 0 ; StringBuffer result = new StringBuffer ( pattern . length ( ) ) ; while ( i < pattern . length ( ) ) { char ch = pattern . charAt ( i ) ; if ( ch == '\'' ) { int endQuote = pattern . indexOf ( '\'' , i + 1 ) ; if ( endQuote == - 1 ) { endQuote = pattern . length ( ) ; } result . append ( pattern . substring ( i , endQuote ) ) ; i = endQuote ++ ; } else if ( symbols . indexOf ( ch ) > - 1 ) { i ++ ; } else { result . append ( ch ) ; i ++ ; } } return result . toString ( ) ; } } 	1	['45', '1', '0', '3', '83', '990', '0', '3', '37', '1.022727273', '1528', '0', '0', '0', '0.172222222', '0', '0', '32.75555556', '10', '1.6', '2']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . SAXException ; public class ElemTextLiteral extends ElemTemplateElement { private boolean m_preserveSpace ; public void setPreserveSpace ( boolean v ) { m_preserveSpace = v ; } public boolean getPreserveSpace ( ) { return m_preserveSpace ; } private char m_ch [ ] ; private String m_str ; public void setChars ( char [ ] v ) { m_ch = v ; } public char [ ] getChars ( ) { return m_ch ; } public synchronized String getNodeValue ( ) { if ( null == m_str ) { m_str = new String ( m_ch ) ; } return m_str ; } private boolean m_disableOutputEscaping = false ; public void setDisableOutputEscaping ( boolean v ) { m_disableOutputEscaping = v ; } public boolean getDisableOutputEscaping ( ) { return m_disableOutputEscaping ; } public int getXSLToken ( ) { return Constants . ELEMNAME_TEXTLITERALRESULT ; } public String getNodeName ( ) { return "#Text" ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { SerializationHandler rth = transformer . getResultTreeHandler ( ) ; if ( m_disableOutputEscaping ) { rth . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; } rth . characters ( m_ch , 0 , m_ch . length ) ; if ( m_disableOutputEscaping ) { rth . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } } 	1	['11', '3', '0', '9', '20', '29', '6', '4', '11', '0.825', '114', '1', '0', '0.951456311', '0.340909091', '2', '5', '9', '2', '1', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . apache . xml . utils . SuballocatedIntVector ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public final class MultiDOM implements DOM { private static final int NO_TYPE = DOM . FIRST_TYPE - 2 ; private static final int INITIAL_SIZE = 4 ; private DOM [ ] _adapters ; private DOMAdapter _main ; private int _free ; private int _size ; private Hashtable _documents = new Hashtable ( ) ; private final class AxisIterator extends DTMAxisIteratorBase { private final int _axis ; private final int _type ; private DTMAxisIterator _source ; private int _dtmId = - 1 ; public AxisIterator ( final int axis , final int type ) { _axis = axis ; _type = type ; } public int next ( ) { if ( _source == null ) { return ( END ) ; } return _source . next ( ) ; } public void setRestartable ( boolean flag ) { if ( _source != null ) { _source . setRestartable ( flag ) ; } } public DTMAxisIterator setStartNode ( final int node ) { if ( node == DTM . NULL ) { return this ; } int dom = node > > > DTMManager . IDENT_DTM_NODE_BITS ; if ( _source == null || _dtmId != dom ) { if ( _type == NO_TYPE ) { _source = _adapters [ dom ] . getAxisIterator ( _axis ) ; } else if ( _axis == Axis . CHILD ) { _source = _adapters [ dom ] . getTypedChildren ( _type ) ; } else { _source = _adapters [ dom ] . getTypedAxisIterator ( _axis , _type ) ; } } _dtmId = dom ; _source . setStartNode ( node ) ; return this ; } public DTMAxisIterator reset ( ) { if ( _source != null ) { _source . reset ( ) ; } return this ; } public int getLast ( ) { if ( _source != null ) { return _source . getLast ( ) ; } else { return END ; } } public int getPosition ( ) { if ( _source != null ) { return _source . getPosition ( ) ; } else { return END ; } } public boolean isReverse ( ) { return Axis . isReverse [ _axis ] ; } public void setMark ( ) { if ( _source != null ) { _source . setMark ( ) ; } } public void gotoMark ( ) { if ( _source != null ) { _source . gotoMark ( ) ; } } public DTMAxisIterator cloneIterator ( ) { final AxisIterator clone = new AxisIterator ( _axis , _type ) ; if ( _source != null ) { clone . _source = _source . cloneIterator ( ) ; } clone . _dtmId = _dtmId ; return clone ; } } private final class NodeValueIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private String _value ; private boolean _op ; private final boolean _isReverse ; private int _returnType = RETURN_PARENT ; public NodeValueIterator ( DTMAxisIterator source , int returnType , String value , boolean op ) { _source = source ; _returnType = returnType ; _value = value ; _op = op ; _isReverse = source . isReverse ( ) ; } public boolean isReverse ( ) { return _isReverse ; } public DTMAxisIterator cloneIterator ( ) { try { NodeValueIterator clone = ( NodeValueIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . setRestartable ( false ) ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { String val = getStringValueX ( node ) ; if ( _value . equals ( val ) == _op ) { if ( _returnType == RETURN_CURRENT ) return returnNode ( node ) ; else return returnNode ( getParent ( node ) ) ; } } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; return resetPosition ( ) ; } return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } public MultiDOM ( DOM main ) { _size = INITIAL_SIZE ; _free = 1 ; _adapters = new DOM [ INITIAL_SIZE ] ; DOMAdapter adapter = ( DOMAdapter ) main ; _adapters [ 0 ] = adapter ; _main = adapter ; addDOMAdapter ( adapter , false ) ; } public int nextMask ( ) { return _free ; } public void setupMapping ( String [ ] names , String [ ] namespaces ) { } public int addDOMAdapter ( DOMAdapter adapter ) { return addDOMAdapter ( adapter , true ) ; } private int addDOMAdapter ( DOMAdapter adapter , boolean indexByURI ) { DOM dom = adapter . getDOMImpl ( ) ; int domNo = 1 ; int dtmSize = 1 ; SuballocatedIntVector dtmIds = null ; if ( dom instanceof DTMDefaultBase ) { DTMDefaultBase dtmdb = ( DTMDefaultBase ) dom ; dtmIds = dtmdb . getDTMIDs ( ) ; dtmSize = dtmIds . size ( ) ; domNo = dtmIds . elementAt ( dtmSize - 1 ) > > > DTMManager . IDENT_DTM_NODE_BITS ; } else if ( dom instanceof SimpleResultTreeImpl ) { SimpleResultTreeImpl simpleRTF = ( SimpleResultTreeImpl ) dom ; domNo = simpleRTF . getDocument ( ) > > > DTMManager . IDENT_DTM_NODE_BITS ; } if ( domNo >= _size ) { int oldSize = _size ; do { _size *= 2 ; } while ( _size <= domNo ) ; final DOMAdapter [ ] newArray = new DOMAdapter [ _size ] ; System . arraycopy ( _adapters , 0 , newArray , 0 , oldSize ) ; _adapters = newArray ; } _free = domNo + 1 ; if ( dtmSize == 1 ) { _adapters [ domNo ] = adapter ; } else if ( dtmIds != null ) { int domPos = 0 ; for ( int i = dtmSize - 1 ; i >= 0 ; i ++ ) { domPos = dtmIds . elementAt ( i ) > > > DTMManager . IDENT_DTM_NODE_BITS ; _adapters [ domPos ] = adapter ; } domNo = domPos ; } if ( indexByURI ) { String uri = adapter . getDocumentURI ( 0 ) ; _documents . put ( uri , new Integer ( domNo ) ) ; } if ( dom instanceof AdaptiveResultTreeImpl ) { AdaptiveResultTreeImpl adaptiveRTF = ( AdaptiveResultTreeImpl ) dom ; DOM nestedDom = adaptiveRTF . getNestedDOM ( ) ; if ( nestedDom != null ) { DOMAdapter newAdapter = new DOMAdapter ( nestedDom , adapter . getNamesArray ( ) , adapter . getNamespaceArray ( ) ) ; addDOMAdapter ( newAdapter ) ; } } return domNo ; } public int getDocumentMask ( String uri ) { Integer domIdx = ( Integer ) _documents . get ( uri ) ; if ( domIdx == null ) { return ( - 1 ) ; } else { return domIdx . intValue ( ) ; } } public DOM getDOMAdapter ( String uri ) { Integer domIdx = ( Integer ) _documents . get ( uri ) ; if ( domIdx == null ) { return ( null ) ; } else { return ( _adapters [ domIdx . intValue ( ) ] ) ; } } public int getDocument ( ) { return _main . getDocument ( ) ; } public DTMAxisIterator getIterator ( ) { return _main . getIterator ( ) ; } public String getStringValue ( ) { return _main . getStringValue ( ) ; } public DTMAxisIterator getChildren ( final int node ) { return _adapters [ getDTMId ( node ) ] . getChildren ( node ) ; } public DTMAxisIterator getTypedChildren ( final int type ) { return new AxisIterator ( Axis . CHILD , type ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { return new AxisIterator ( axis , NO_TYPE ) ; } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { return new AxisIterator ( axis , type ) ; } public DTMAxisIterator getNthDescendant ( int node , int n , boolean includeself ) { return _adapters [ getDTMId ( node ) ] . getNthDescendant ( node , n , includeself ) ; } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iterator , int type , String value , boolean op ) { return ( new NodeValueIterator ( iterator , type , value , op ) ) ; } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { DTMAxisIterator iterator = _main . getNamespaceAxisIterator ( axis , ns ) ; return ( iterator ) ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return _adapters [ getDTMId ( node ) ] . orderNodes ( source , node ) ; } public int getExpandedTypeID ( final int node ) { if ( node != DTM . NULL ) { return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getExpandedTypeID ( node ) ; } else { return DTM . NULL ; } } public int getNamespaceType ( final int node ) { return _adapters [ getDTMId ( node ) ] . getNamespaceType ( node ) ; } public int getNSType ( int node ) { return _adapters [ getDTMId ( node ) ] . getNSType ( node ) ; } public int getParent ( final int node ) { if ( node == DTM . NULL ) { return DTM . NULL ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getParent ( node ) ; } public int getAttributeNode ( final int type , final int el ) { if ( el == DTM . NULL ) { return DTM . NULL ; } return _adapters [ el > > > DTMManager . IDENT_DTM_NODE_BITS ] . getAttributeNode ( type , el ) ; } public String getNodeName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getNodeName ( node ) ; } public String getNodeNameX ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getNodeNameX ( node ) ; } public String getNamespaceName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getNamespaceName ( node ) ; } public String getStringValueX ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getStringValueX ( node ) ; } public void copy ( final int node , SerializationHandler handler ) throws TransletException { if ( node != DTM . NULL ) { _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . copy ( node , handler ) ; } } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { int node ; while ( ( node = nodes . next ( ) ) != DTM . NULL ) { _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . copy ( node , handler ) ; } } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . shallowCopy ( node , handler ) ; } public boolean lessThan ( final int node1 , final int node2 ) { if ( node1 == DTM . NULL ) { return true ; } if ( node2 == DTM . NULL ) { return false ; } final int dom1 = getDTMId ( node1 ) ; final int dom2 = getDTMId ( node2 ) ; return dom1 == dom2 ? _adapters [ dom1 ] . lessThan ( node1 , node2 ) : dom1 < dom2 ; } public void characters ( final int textNode , SerializationHandler handler ) throws TransletException { if ( textNode != DTM . NULL ) { _adapters [ textNode > > > DTMManager . IDENT_DTM_NODE_BITS ] . characters ( textNode , handler ) ; } } public void setFilter ( StripFilter filter ) { for ( int dom = 0 ; dom < _free ; dom ++ ) { if ( _adapters [ dom ] != null ) { _adapters [ dom ] . setFilter ( filter ) ; } } } public Node makeNode ( int index ) { if ( index == DTM . NULL ) { return null ; } return _adapters [ getDTMId ( index ) ] . makeNode ( index ) ; } public Node makeNode ( DTMAxisIterator iter ) { return _main . makeNode ( iter ) ; } public NodeList makeNodeList ( int index ) { if ( index == DTM . NULL ) { return null ; } return _adapters [ getDTMId ( index ) ] . makeNodeList ( index ) ; } public NodeList makeNodeList ( DTMAxisIterator iter ) { return _main . makeNodeList ( iter ) ; } public String getLanguage ( int node ) { return _adapters [ getDTMId ( node ) ] . getLanguage ( node ) ; } public int getSize ( ) { int size = 0 ; for ( int i = 0 ; i < _size ; i ++ ) { size += _adapters [ i ] . getSize ( ) ; } return ( size ) ; } public String getDocumentURI ( int node ) { if ( node == DTM . NULL ) { node = DOM . NULL ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getDocumentURI ( 0 ) ; } public boolean isElement ( final int node ) { if ( node == DTM . NULL ) { return false ; } return ( _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . isElement ( node ) ) ; } public boolean isAttribute ( final int node ) { if ( node == DTM . NULL ) { return false ; } return ( _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . isAttribute ( node ) ) ; } public int getDTMId ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return 0 ; int id = nodeHandle > > > DTMManager . IDENT_DTM_NODE_BITS ; while ( id >= 2 && _adapters [ id ] == _adapters [ id - 1 ] ) { id -- ; } return id ; } public int getNodeIdent ( int nodeHandle ) { return _adapters [ nodeHandle > > > DTMManager . IDENT_DTM_NODE_BITS ] . getNodeIdent ( nodeHandle ) ; } public int getNodeHandle ( int nodeId ) { return _main . getNodeHandle ( nodeId ) ; } public DOM getResultTreeFrag ( int initSize , int rtfType ) { return _main . getResultTreeFrag ( initSize , rtfType ) ; } public DOM getMain ( ) { return _main ; } public SerializationHandler getOutputDomBuilder ( ) { return _main . getOutputDomBuilder ( ) ; } public String lookupNamespace ( int node , String prefix ) throws TransletException { return _main . lookupNamespace ( node , prefix ) ; } public String getUnparsedEntityURI ( String entity ) { return _main . getUnparsedEntityURI ( entity ) ; } public Hashtable getElementsWithIDs ( ) { return _main . getElementsWithIDs ( ) ; } } 	1	['52', '1', '0', '15', '109', '202', '4', '13', '50', '0.851540616', '775', '1', '3', '0', '0.185314685', '0', '0', '13.76923077', '11', '1.6346', '1']
package org . apache . xml . utils ; public interface RawCharacterHandler { public void charactersRaw ( char ch [ ] , int start , int length ) throws javax . xml . transform . TransformerException ; } 	1	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . transformer ; public class DecimalToRoman { public DecimalToRoman ( long postValue , String postLetter , long preValue , String preLetter ) { this . m_postValue = postValue ; this . m_postLetter = postLetter ; this . m_preValue = preValue ; this . m_preLetter = preLetter ; } public long m_postValue ; public String m_postLetter ; public long m_preValue ; public String m_preLetter ; } 	1	['1', '1', '0', '2', '2', '0', '2', '0', '1', '2', '20', '0', '0', '0', '1', '0', '0', '15', '0', '0', '1']
package org . apache . xpath . res ; public class XPATHErrorResources_zh_CN extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "匹配模式中不允许使用 current() 函数！" } , { ER_CURRENT_TAKES_NO_ARGS , "current() 函数不接受变量！" } , { ER_DOCUMENT_REPLACED , "document() 函数工具已被 org.apache.xalan.xslt.FuncDocument 替代！" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "上下文没有属主文档！" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() 的变量太多。" } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() 的变量太多。" } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() 的变量太多。" } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() 的变量太多。" } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() 的变量太多。" } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() 的变量太多。" } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() 的变量太多。" } , { ER_TRANSLATE_TAKES_3_ARGS , "translate() 函数使用三个变量！" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri 函数应使用一个变量！" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "仍未实现名称空间轴！" } , { ER_UNKNOWN_AXIS , "未知轴：{0}" } , { ER_UNKNOWN_MATCH_OPERATION , "匹配操作未知！" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() 节点的变量长度测试不正确！" } , { ER_CANT_CONVERT_TO_NUMBER , "不能将 {0} 转换为一个数字" } , { ER_CANT_CONVERT_TO_NODELIST , "不能将 {0} 转换为一个 NodeList！" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "不能将 {0} 转换为一个 NodeSetDTM！" } , { ER_CANT_CONVERT_TO_TYPE , "不能将 {0} 转换为一个 type//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "getMatchScore 中预期的匹配模式！" } , { ER_COULDNOT_GET_VAR_NAMED , "无法获得命名的变量 {0}" } , { ER_UNKNOWN_OPCODE , "错误！op 代码未知：{0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "额外的非法标记：{0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "错误引用文字... 预期的双引用！" } , { ER_EXPECTED_SINGLE_QUOTE , "错误引用文字... 预期的单引用！" } , { ER_EMPTY_EXPRESSION , "空表达式！" } , { ER_EXPECTED_BUT_FOUND , "预期的 {0}，但发现：{1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "程序员断言是错误的！- {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "19990709 XPath 草稿不再可选用 boolean(...) 变量。" } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "已找到 ','，但未找到前述变量！" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "已找到 ','，但未找到以下变量！" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' 或 '.[predicate]' 是非法语法。请改用 'self::node()[predicate]'。" } , { ER_ILLEGAL_AXIS_NAME , "非法的轴名称：{0}" } , { ER_UNKNOWN_NODETYPE , "未知的节点类型：{0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "需要引用模式文字 ({0})！" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "不能将 {0} 格式化为一个数字！" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "不能创建 XML TransformerFactory Liaison：{0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "错误！未找到 xpath select 表达式 (-select)。" } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "错误！未在 OP_LOCATIONPATH 后找到 ENDOP" } , { ER_ERROR_OCCURED , "出错！" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "为变量给出的 VariableReference 超出了上下文范围或没有定义！名称 = {0}" } , { ER_AXES_NOT_ALLOWED , "匹配模式中仅允许使用 child:: 和 attribute:: 轴！违例轴 = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() 有许多不正确的变量。" } , { ER_COUNT_TAKES_1_ARG , "count 函数应使用一个变量！" } , { ER_COULDNOT_FIND_FUNCTION , "未找到函数：{0}" } , { ER_UNSUPPORTED_ENCODING , "不受支持的编码：{0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling 中的 DTM 出现问题 ... 正在尝试恢复" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "程序员出错：不能将 EmptyNodeList 写入。" } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory 不受 XPathContext 支持！" } , { ER_PREFIX_MUST_RESOLVE , "必须解决名称空间的前缀：{0}" } , { ER_PARSE_NOT_SUPPORTED , "XPathContext 中不支持（语法）分析器（InputSource 源）！无法打开 {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... 不由 DTM 处理！" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... 不由 DTM 处理！" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison 无法处理节点类型 {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper 无法处理节点类型 {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse 错误：SystemID - {0} line - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse 错误" } , { ER_INVALID_UTF16_SURROGATE , "检测到无效的 UTF-16 surrogate：{0} ?" } , { ER_OIERROR , "IO 错误" } , { ER_CANNOT_CREATE_URL , "无法创建 url 为：{0}" } , { ER_XPATH_READOBJECT , "在 XPath.readObject 中：{0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "未找到函数标记。" } , { ER_CANNOT_DEAL_XPATH_TYPE , "无法处理 XPath 类型：{0}" } , { ER_NODESET_NOT_MUTABLE , "此 NodeSet 不易变" } , { ER_NODESETDTM_NOT_MUTABLE , "此 NodeSetDTM 不易变" } , { ER_VAR_NOT_RESOLVABLE , "变量不可分解：{0}" } , { ER_NULL_ERROR_HANDLER , "错误处理器无效" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "程序员断言：opcode 未知：{0}" } , { ER_ZERO_OR_ONE , "0 或 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() 不受 XRTreeFragSelectWrapper 支持" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() 不受 XRTreeFragSelectWrapper 支持" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() 不支持 XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "无法找到名称为 {0} 的变量" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars 无法使用变量的一个字符串" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer 变量不能为空" } , { ER_TWO_OR_THREE , "2 或 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "绑定之前访问了变量！" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB 无法接受字符串类型的变量！" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! 错误！遍历程序的根设置为空!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "此 NodeSetDTM 无法迭代到前一个节点！" } , { ER_NODESET_CANNOT_ITERATE , "此 NodeSet 无法迭代到前一个节点！" } , { ER_NODESETDTM_CANNOT_INDEX , "此 NodeSetDTM 无法为函数建立索引或计算个数！" } , { ER_NODESET_CANNOT_INDEX , "此 NodeSet 无法为函数建立索引或计算个数！" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "调用 nextNode 后无法调用 setShouldCacheNodes！" } , { ER_ONLY_ALLOWS , "{0} 仅允许 {1} 变量" } , { ER_UNKNOWN_STEP , "getNextStepPos 中的程序员声明：未知的 stepType：{0}" } , { ER_EXPECTED_REL_LOC_PATH , "“/”或“//”标记后需要采用相对位置路径。" } , { ER_EXPECTED_LOC_PATH , "需要位置路径，但遇到以下标记:  {0}" } , { ER_EXPECTED_LOC_STEP , "“/”或“//”标记后需要采用位置步骤。" } , { ER_EXPECTED_NODE_TEST , "需要与 NCName:* 或 QName 匹配的节点测试。" } , { ER_EXPECTED_STEP_PATTERN , "需要步骤模式，但遇到“/”。" } , { ER_EXPECTED_REL_PATH_PATTERN , "需要相对路径模式。" } , { ER_CANT_CONVERT_TO_BOOLEAN , "无法将 {0} 转换成布尔值。" } , { ER_CANT_CONVERT_TO_SINGLENODE , "无法将 {0} 转换成单节点。此获取程序适用于 ANY_UNORDERED_NODE_TYPE 和 FIRST_ORDERED_NODE_TYPE 类型。" } , { ER_CANT_GET_SNAPSHOT_LENGTH , "无法获取类型 {0} 上的快照长度。此获取程序适用于 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 类型。" } , { ER_NON_ITERATOR_TYPE , "无法迭代非叠代器类型：{0}" } , { ER_DOC_MUTATED , "由于结果的返回使文档发生改变。叠代器无效。" } , { ER_INVALID_XPATH_TYPE , "无效 XPath 类型变量：{0}" } , { ER_EMPTY_XPATH_RESULT , "空的 XPath 结果对象" } , { ER_INCOMPATIBLE_TYPES , "返回类型：{0} 无法强制转换成指定的类型：{1}" } , { ER_NULL_RESOLVER , "无法用空的前缀解决器来解决前缀。" } , { ER_CANT_CONVERT_TO_STRING , "无法将 {0} 转换成字符串。" } , { ER_NON_SNAPSHOT_TYPE , "无法对类型 {0} 调用 snapshotItem。此方法适用于 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 类型。" } , { ER_WRONG_DOCUMENT , "上下文节点不属于绑定到此 XPathEvaluator 的文档。" } , { ER_WRONG_NODETYPE , "上下文节点类型不受支持。" } , { ER_XPATH_ERROR , "XPath 中出现未知错误。" } , { WG_LOCALE_NAME_NOT_HANDLED , "仍未处理 format-number 函数中的语言环境名称！" } , { WG_PROPERTY_NOT_SUPPORTED , "不受支持的 XSL Property：{0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "当前不要对属性中的名称空间 {0} 执行任何操作：{1}" } , { WG_SECURITY_EXCEPTION , "尝试访问 XSL 系统属性时，SecurityException：{0}" } , { WG_QUO_NO_LONGER_DEFINED , "旧语法：XPath 中不再定义 quo(...)。" } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath 需要由一个派生对象来执行 nodeTest！" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "未找到函数标记。" } , { WG_COULDNOT_FIND_FUNCTION , "无法找到函数：{0}" } , { WG_CANNOT_MAKE_URL_FROM , "无法得到 URL 自：{0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "-E 选项不支持 DTM（语法）分析器" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "为变量给出的 VariableReference 超出了上下文范围或没有定义！名称 = {0}" } , { WG_UNSUPPORTED_ENCODING , "不受支持的编码：{0}" } , { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "BAD_CODE" , "createMessage 参数超出了范围" } , { "FORMAT_FAILED" , "messageFormat 调用期间提出了例外" } , { "version" , ">>>>>>> Xalan 版本" } , { "version2" , "<<<<<<<" } , { "yes" , "是" } , { "line" , "行 //" } , { "column" , "列 //" } , { "xsldone" , "XSLProcessor：已完成" } , { "xpath_option" , "xpath 选项：" } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath expression]" } , { "optionMatch" , "   [-match match pattern (for match diagnostics)]" } , { "optionAnyExpr" , "或者只有 xpath 表达式将执行诊断转储" } , { "noParsermsg1" , "XSL Process 未成功。" } , { "noParsermsg2" , "** 无法找到（语法）分析器 **" } , { "noParsermsg3" , "请检查您的类路径。" } , { "noParsermsg4" , "如果您没有 IBM 的 XML Parser for Java，则可以下载其自" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "错误：" ; public static final String WARNING_HEADER = "警告：" ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.428571429', '1872', '0', '0', '0.976190476', '1', '0', '0', '618.3333333', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XString ; public class ElemWithParam extends ElemTemplateElement { int m_index ; private XPath m_selectPattern = null ; public void setSelect ( XPath v ) { m_selectPattern = v ; } public XPath getSelect ( ) { return m_selectPattern ; } private QName m_qname = null ; int m_qnameID ; public void setName ( QName v ) { m_qname = v ; } public QName getName ( ) { return m_qname ; } public int getXSLToken ( ) { return Constants . ELEMNAME_WITHPARAM ; } public String getNodeName ( ) { return Constants . ELEMNAME_WITHPARAM_STRING ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { if ( null == m_selectPattern && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { XPath newSelect = ElemVariable . rewriteChildToExpression ( this ) ; if ( null != newSelect ) m_selectPattern = newSelect ; } m_qnameID = sroot . getComposeState ( ) . getQNameID ( m_qname ) ; super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_selectPattern ) m_selectPattern . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public void setParentElem ( ElemTemplateElement p ) { super . setParentElem ( p ) ; p . m_hasVariableDecl = true ; } public XObject getValue ( TransformerImpl transformer , int sourceNode ) throws TransformerException { XObject var ; XPathContext xctxt = transformer . getXPathContext ( ) ; xctxt . pushCurrentNode ( sourceNode ) ; try { if ( null != m_selectPattern ) { var = m_selectPattern . execute ( xctxt , sourceNode , this ) ; var . allowDetachToRelease ( false ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , m_selectPattern , var ) ; } else if ( null == getFirstChildElem ( ) ) { var = XString . EMPTYSTRING ; } else { int df = transformer . transformToRTF ( this ) ; var = new XRTreeFrag ( df , xctxt , this ) ; } } finally { xctxt . popCurrentNode ( ) ; } return var ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs && ( null != m_selectPattern ) ) m_selectPattern . getExpression ( ) . callVisitors ( m_selectPattern , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['11', '3', '0', '21', '33', '15', '2', '19', '10', '0.825', '168', '0.5', '2', '0.951456311', '0.191919192', '2', '9', '13.90909091', '3', '1.0909', '2']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncString extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( XString ) getArg0AsString ( xctxt ) ; } } 	1	['2', '5', '0', '5', '4', '1', '0', '5', '2', '2', '10', '0', '0', '0.982142857', '0.75', '2', '7', '4', '1', '0.5', '1']
package org . apache . xalan . lib . sql ; import java . util . Vector ; public class ObjectArray { private int m_minArraySize = 10 ; private Vector m_Arrays = new Vector ( 200 ) ; private _ObjectArray m_currentArray ; private int m_nextSlot ; public ObjectArray ( ) { init ( 10 ) ; } public ObjectArray ( final int minArraySize ) { init ( minArraySize ) ; } private void init ( int size ) { m_minArraySize = size ; m_currentArray = new _ObjectArray ( m_minArraySize ) ; } public Object getAt ( final int idx ) { int arrayIndx = idx / m_minArraySize ; int arrayOffset = idx - ( arrayIndx * m_minArraySize ) ; if ( arrayIndx < m_Arrays . size ( ) ) { _ObjectArray a = ( _ObjectArray ) m_Arrays . elementAt ( arrayIndx ) ; return a . objects [ arrayOffset ] ; } else { return m_currentArray . objects [ arrayOffset ] ; } } public void setAt ( final int idx , final Object obj ) { int arrayIndx = idx / m_minArraySize ; int arrayOffset = idx - ( arrayIndx * m_minArraySize ) ; if ( arrayIndx < m_Arrays . size ( ) ) { _ObjectArray a = ( _ObjectArray ) m_Arrays . elementAt ( arrayIndx ) ; a . objects [ arrayOffset ] = obj ; } else { m_currentArray . objects [ arrayOffset ] = obj ; } } public int append ( Object o ) { if ( m_nextSlot >= m_minArraySize ) { m_Arrays . addElement ( m_currentArray ) ; m_nextSlot = 0 ; m_currentArray = new _ObjectArray ( m_minArraySize ) ; } m_currentArray . objects [ m_nextSlot ] = o ; int pos = ( m_Arrays . size ( ) * m_minArraySize ) + m_nextSlot ; m_nextSlot ++ ; return pos ; } class _ObjectArray { public Object [ ] objects ; public _ObjectArray ( int size ) { objects = new Object [ size ] ; } } public static void main ( String [ ] args ) { String [ ] word = { "Zero" , "One" , "Two" , "Three" , "Four" , "Five" , "Six" , "Seven" , "Eight" , "Nine" , "Ten" , "Eleven" , "Twelve" , "Thirteen" , "Fourteen" , "Fifteen" , "Sixteen" , "Seventeen" , "Eighteen" , "Nineteen" , "Twenty" , "Twenty-One" , "Twenty-Two" , "Twenty-Three" , "Twenty-Four" , "Twenty-Five" , "Twenty-Six" , "Twenty-Seven" , "Twenty-Eight" , "Twenty-Nine" , "Thirty" , "Thirty-One" , "Thirty-Two" , "Thirty-Three" , "Thirty-Four" , "Thirty-Five" , "Thirty-Six" , "Thirty-Seven" , "Thirty-Eight" , "Thirty-Nine" } ; ObjectArray m_ObjectArray = new ObjectArray ( ) ; for ( int x = 0 ; x < word . length ; x ++ ) { System . out . print ( " - " + m_ObjectArray . append ( word [ x ] ) ) ; } System . out . println ( "\n" ) ; for ( int x = 0 ; x < word . length ; x ++ ) { String s = ( String ) m_ObjectArray . getAt ( x ) ; System . out . println ( s ) ; } System . out . println ( ( String ) m_ObjectArray . getAt ( 5 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 10 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 20 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 2 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 15 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 30 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 6 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 8 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 40 ) ) ; } } 	1	['7', '1', '0', '3', '19', '0', '3', '1', '6', '0.25', '432', '1', '1', '0', '0.464285714', '0', '0', '60.14285714', '3', '1.4286', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class XslAttribute extends Instruction { private String _prefix ; private AttributeValue _name ; private AttributeValueTemplate _namespace = null ; private boolean _ignore = false ; public AttributeValue getName ( ) { return _name ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Attribute " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { boolean generated = false ; final SymbolTable stable = parser . getSymbolTable ( ) ; String name = getAttribute ( "name" ) ; String namespace = getAttribute ( "namespace" ) ; QName qname = parser . getQName ( name , false ) ; final String prefix = qname . getPrefix ( ) ; if ( ( prefix != null ) && ( prefix . equals ( XMLNS_PREFIX ) ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_ATTR_NAME_ERR , name ) ; return ; } final SyntaxTreeNode parent = getParent ( ) ; final Vector siblings = parent . getContents ( ) ; for ( int i = 0 ; i < parent . elementCount ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) siblings . elementAt ( i ) ; if ( item == this ) break ; if ( item instanceof XslAttribute ) continue ; if ( item instanceof UseAttributeSets ) continue ; if ( item instanceof LiteralAttribute ) continue ; if ( item instanceof Text ) continue ; if ( item instanceof If ) continue ; if ( item instanceof Choose ) continue ; if ( item instanceof CopyOf ) continue ; if ( item instanceof VariableBase ) continue ; reportWarning ( this , parser , ErrorMsg . STRAY_ATTRIBUTE_ERR , name ) ; } if ( namespace != null && namespace != Constants . EMPTYSTRING ) { _prefix = lookupPrefix ( namespace ) ; _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } else if ( prefix != null && prefix != Constants . EMPTYSTRING ) { _prefix = prefix ; namespace = lookupNamespace ( prefix ) ; if ( namespace != null ) { _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } } if ( _namespace != null ) { if ( _prefix == null || _prefix == Constants . EMPTYSTRING ) { if ( prefix != null ) { _prefix = prefix ; } else { _prefix = stable . generateNamespacePrefix ( ) ; generated = true ; } } else if ( prefix != null && ! prefix . equals ( _prefix ) ) { _prefix = prefix ; } name = _prefix + ":" + qname . getLocalPart ( ) ; if ( ( parent instanceof LiteralElement ) && ( ! generated ) ) { ( ( LiteralElement ) parent ) . registerNamespace ( _prefix , namespace , stable , false ) ; } } if ( name . equals ( XMLNS_PREFIX ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_ATTR_NAME_ERR , name ) ; return ; } if ( parent instanceof LiteralElement ) { ( ( LiteralElement ) parent ) . addAttribute ( this ) ; } _name = AttributeValue . create ( this , name , parser ) ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( ! _ignore ) { _name . typeCheck ( stable ) ; if ( _namespace != null ) { _namespace . typeCheck ( stable ) ; } typeCheckContents ( stable ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _ignore ) return ; _ignore = true ; if ( _namespace != null ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _prefix ) ) ; _namespace . translate ( classGen , methodGen ) ; il . append ( methodGen . namespace ( ) ) ; } il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; _name . translate ( classGen , methodGen ) ; if ( ( elementCount ( ) == 1 ) && ( elementAt ( 0 ) instanceof Text ) ) { il . append ( new PUSH ( cpg , ( ( Text ) elementAt ( 0 ) ) . getText ( ) ) ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , "stringValueHandler" , STRING_VALUE_HANDLER_SIG ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_VALUE_HANDLER , "getValue" , "()" + STRING_SIG ) ) ) ; } il . append ( methodGen . attribute ( ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	1	['6', '3', '0', '31', '57', '0', '2', '29', '5', '0.5', '413', '1', '2', '0.918032787', '0.305555556', '2', '10', '67.16666667', '28', '6', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . BoolStack ; import java . util . Vector ; import javax . xml . transform . Source ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . res . XMLErrorResources ; import java . io . * ; public abstract class DTMDefaultBase implements DTM { static boolean JJK_DEBUG = false ; public static final int ROOTNODE = 0 ; protected int m_size = 0 ; protected SuballocatedIntVector m_exptype ; protected SuballocatedIntVector m_firstch ; protected SuballocatedIntVector m_nextsib ; protected SuballocatedIntVector m_prevsib ; protected SuballocatedIntVector m_parent ; protected Vector m_namespaceDeclSets = null ; protected SuballocatedIntVector m_namespaceDeclSetElements = null ; protected int [ ] [ ] [ ] m_elemIndexes ; public static final int DEFAULT_BLOCKSIZE = 512 ; public static final int DEFAULT_NUMBLOCKS = 32 ; public static final int DEFAULT_NUMBLOCKS_SMALL = 4 ; protected static final int NOTPROCESSED = DTM . NULL - 1 ; public DTMManager m_mgr ; protected DTMManagerDefault m_mgrDefault = null ; protected SuballocatedIntVector m_dtmIdent ; protected String m_documentBaseURI ; protected DTMWSFilter m_wsfilter ; protected boolean m_shouldStripWS = false ; protected BoolStack m_shouldStripWhitespaceStack ; protected XMLStringFactory m_xstrf ; protected ExpandedNameTable m_expandedNameTable ; protected boolean m_indexing ; public DTMDefaultBase ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , true ) ; } public DTMDefaultBase ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib ) { int numblocks ; if ( blocksize <= 64 ) { numblocks = DEFAULT_NUMBLOCKS_SMALL ; m_dtmIdent = new SuballocatedIntVector ( 4 , 1 ) ; } else { numblocks = DEFAULT_NUMBLOCKS ; m_dtmIdent = new SuballocatedIntVector ( 32 ) ; } m_exptype = new SuballocatedIntVector ( blocksize , numblocks ) ; m_firstch = new SuballocatedIntVector ( blocksize , numblocks ) ; m_nextsib = new SuballocatedIntVector ( blocksize , numblocks ) ; m_parent = new SuballocatedIntVector ( blocksize , numblocks ) ; if ( usePrevsib ) m_prevsib = new SuballocatedIntVector ( blocksize , numblocks ) ; m_mgr = mgr ; if ( mgr instanceof DTMManagerDefault ) m_mgrDefault = ( DTMManagerDefault ) mgr ; m_documentBaseURI = ( null != source ) ? source . getSystemId ( ) : null ; m_dtmIdent . setElementAt ( dtmIdentity , 0 ) ; m_wsfilter = whiteSpaceFilter ; m_xstrf = xstringfactory ; m_indexing = doIndexing ; if ( doIndexing ) { m_expandedNameTable = new ExpandedNameTable ( ) ; } else { m_expandedNameTable = m_mgrDefault . getExpandedNameTable ( this ) ; } if ( null != whiteSpaceFilter ) { m_shouldStripWhitespaceStack = new BoolStack ( ) ; pushShouldStripWhitespace ( false ) ; } } protected void ensureSizeOfIndex ( int namespaceID , int LocalNameID ) { if ( null == m_elemIndexes ) { m_elemIndexes = new int [ namespaceID + 20 ] [ ] [ ] ; } else if ( m_elemIndexes . length <= namespaceID ) { int [ ] [ ] [ ] indexes = m_elemIndexes ; m_elemIndexes = new int [ namespaceID + 20 ] [ ] [ ] ; System . arraycopy ( indexes , 0 , m_elemIndexes , 0 , indexes . length ) ; } int [ ] [ ] localNameIndex = m_elemIndexes [ namespaceID ] ; if ( null == localNameIndex ) { localNameIndex = new int [ LocalNameID + 100 ] [ ] ; m_elemIndexes [ namespaceID ] = localNameIndex ; } else if ( localNameIndex . length <= LocalNameID ) { int [ ] [ ] indexes = localNameIndex ; localNameIndex = new int [ LocalNameID + 100 ] [ ] ; System . arraycopy ( indexes , 0 , localNameIndex , 0 , indexes . length ) ; m_elemIndexes [ namespaceID ] = localNameIndex ; } int [ ] elemHandles = localNameIndex [ LocalNameID ] ; if ( null == elemHandles ) { elemHandles = new int [ 128 ] ; localNameIndex [ LocalNameID ] = elemHandles ; elemHandles [ 0 ] = 1 ; } else if ( elemHandles . length <= elemHandles [ 0 ] + 1 ) { int [ ] indexes = elemHandles ; elemHandles = new int [ elemHandles [ 0 ] + 1024 ] ; System . arraycopy ( indexes , 0 , elemHandles , 0 , indexes . length ) ; localNameIndex [ LocalNameID ] = elemHandles ; } } protected void indexNode ( int expandedTypeID , int identity ) { ExpandedNameTable ent = m_expandedNameTable ; short type = ent . getType ( expandedTypeID ) ; if ( DTM . ELEMENT_NODE == type ) { int namespaceID = ent . getNamespaceID ( expandedTypeID ) ; int localNameID = ent . getLocalNameID ( expandedTypeID ) ; ensureSizeOfIndex ( namespaceID , localNameID ) ; int [ ] index = m_elemIndexes [ namespaceID ] [ localNameID ] ; index [ index [ 0 ] ] = identity ; index [ 0 ] ++ ; } } protected int findGTE ( int [ ] list , int start , int len , int value ) { int low = start ; int high = start + ( len - 1 ) ; int end = high ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int c = list [ mid ] ; if ( c > value ) high = mid - 1 ; else if ( c < value ) low = mid + 1 ; else return mid ; } return ( low <= end && list [ low ] > value ) ? low : - 1 ; } int findElementFromIndex ( int nsIndex , int lnIndex , int firstPotential ) { int [ ] [ ] [ ] indexes = m_elemIndexes ; if ( null != indexes && nsIndex < indexes . length ) { int [ ] [ ] lnIndexs = indexes [ nsIndex ] ; if ( null != lnIndexs && lnIndex < lnIndexs . length ) { int [ ] elems = lnIndexs [ lnIndex ] ; if ( null != elems ) { int pos = findGTE ( elems , 1 , elems [ 0 ] , firstPotential ) ; if ( pos > - 1 ) { return elems [ pos ] ; } } } } return NOTPROCESSED ; } protected abstract int getNextNodeIdentity ( int identity ) ; protected abstract boolean nextNode ( ) ; protected abstract int getNumberOfNodes ( ) ; protected DTMAxisTraverser [ ] m_traversers ; protected short _type ( int identity ) { int info = _exptype ( identity ) ; if ( NULL != info ) return m_expandedNameTable . getType ( info ) ; else return NULL ; } protected int _exptype ( int identity ) { if ( identity == DTM . NULL ) return NULL ; while ( identity >= m_size ) { if ( ! nextNode ( ) && identity >= m_size ) return NULL ; } return m_exptype . elementAt ( identity ) ; } protected int _level ( int identity ) { while ( identity >= m_size ) { boolean isMore = nextNode ( ) ; if ( ! isMore && identity >= m_size ) return NULL ; } int i = 0 ; while ( NULL != ( identity = _parent ( identity ) ) ) ++ i ; return i ; } protected int _firstch ( int identity ) { int info = ( identity >= m_size ) ? NOTPROCESSED : m_firstch . elementAt ( identity ) ; while ( info == NOTPROCESSED ) { boolean isMore = nextNode ( ) ; if ( identity >= m_size && ! isMore ) return NULL ; else { info = m_firstch . elementAt ( identity ) ; if ( info == NOTPROCESSED && ! isMore ) return NULL ; } } return info ; } protected int _nextsib ( int identity ) { int info = ( identity >= m_size ) ? NOTPROCESSED : m_nextsib . elementAt ( identity ) ; while ( info == NOTPROCESSED ) { boolean isMore = nextNode ( ) ; if ( identity >= m_size && ! isMore ) return NULL ; else { info = m_nextsib . elementAt ( identity ) ; if ( info == NOTPROCESSED && ! isMore ) return NULL ; } } return info ; } protected int _prevsib ( int identity ) { if ( identity < m_size ) return m_prevsib . elementAt ( identity ) ; while ( true ) { boolean isMore = nextNode ( ) ; if ( identity >= m_size && ! isMore ) return NULL ; else if ( identity < m_size ) return m_prevsib . elementAt ( identity ) ; } } protected int _parent ( int identity ) { if ( identity < m_size ) return m_parent . elementAt ( identity ) ; while ( true ) { boolean isMore = nextNode ( ) ; if ( identity >= m_size && ! isMore ) return NULL ; else if ( identity < m_size ) return m_parent . elementAt ( identity ) ; } } public void dumpDTM ( OutputStream os ) { try { if ( os == null ) { File f = new File ( "DTMDump" + ( ( Object ) this ) . hashCode ( ) + ".txt" ) ; System . err . println ( "Dumping... " + f . getAbsolutePath ( ) ) ; os = new FileOutputStream ( f ) ; } PrintStream ps = new PrintStream ( os ) ; while ( nextNode ( ) ) { } int nRecords = m_size ; ps . println ( "Total nodes: " + nRecords ) ; for ( int index = 0 ; index < nRecords ; ++ index ) { int i = makeNodeHandle ( index ) ; ps . println ( "=========== index=" + index + " handle=" + i + " ===========" ) ; ps . println ( "NodeName: " + getNodeName ( i ) ) ; ps . println ( "NodeNameX: " + getNodeNameX ( i ) ) ; ps . println ( "LocalName: " + getLocalName ( i ) ) ; ps . println ( "NamespaceURI: " + getNamespaceURI ( i ) ) ; ps . println ( "Prefix: " + getPrefix ( i ) ) ; int exTypeID = _exptype ( index ) ; ps . println ( "Expanded Type ID: " + Integer . toHexString ( exTypeID ) ) ; int type = _type ( index ) ; String typestring ; switch ( type ) { case DTM . ATTRIBUTE_NODE : typestring = "ATTRIBUTE_NODE" ; break ; case DTM . CDATA_SECTION_NODE : typestring = "CDATA_SECTION_NODE" ; break ; case DTM . COMMENT_NODE : typestring = "COMMENT_NODE" ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : typestring = "DOCUMENT_FRAGMENT_NODE" ; break ; case DTM . DOCUMENT_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . DOCUMENT_TYPE_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . ELEMENT_NODE : typestring = "ELEMENT_NODE" ; break ; case DTM . ENTITY_NODE : typestring = "ENTITY_NODE" ; break ; case DTM . ENTITY_REFERENCE_NODE : typestring = "ENTITY_REFERENCE_NODE" ; break ; case DTM . NAMESPACE_NODE : typestring = "NAMESPACE_NODE" ; break ; case DTM . NOTATION_NODE : typestring = "NOTATION_NODE" ; break ; case DTM . NULL : typestring = "NULL" ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : typestring = "PROCESSING_INSTRUCTION_NODE" ; break ; case DTM . TEXT_NODE : typestring = "TEXT_NODE" ; break ; default : typestring = "Unknown!" ; break ; } ps . println ( "Type: " + typestring ) ; int firstChild = _firstch ( index ) ; if ( DTM . NULL == firstChild ) ps . println ( "First child: DTM.NULL" ) ; else if ( NOTPROCESSED == firstChild ) ps . println ( "First child: NOTPROCESSED" ) ; else ps . println ( "First child: " + firstChild ) ; if ( m_prevsib != null ) { int prevSibling = _prevsib ( index ) ; if ( DTM . NULL == prevSibling ) ps . println ( "Prev sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == prevSibling ) ps . println ( "Prev sibling: NOTPROCESSED" ) ; else ps . println ( "Prev sibling: " + prevSibling ) ; } int nextSibling = _nextsib ( index ) ; if ( DTM . NULL == nextSibling ) ps . println ( "Next sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == nextSibling ) ps . println ( "Next sibling: NOTPROCESSED" ) ; else ps . println ( "Next sibling: " + nextSibling ) ; int parent = _parent ( index ) ; if ( DTM . NULL == parent ) ps . println ( "Parent: DTM.NULL" ) ; else if ( NOTPROCESSED == parent ) ps . println ( "Parent: NOTPROCESSED" ) ; else ps . println ( "Parent: " + parent ) ; int level = _level ( index ) ; ps . println ( "Level: " + level ) ; ps . println ( "Node Value: " + getNodeValue ( i ) ) ; ps . println ( "String Value: " + getStringValue ( i ) ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( System . err ) ; System . exit ( - 1 ) ; } } public String dumpNode ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return "[null]" ; String typestring ; switch ( getNodeType ( nodeHandle ) ) { case DTM . ATTRIBUTE_NODE : typestring = "ATTR" ; break ; case DTM . CDATA_SECTION_NODE : typestring = "CDATA" ; break ; case DTM . COMMENT_NODE : typestring = "COMMENT" ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : typestring = "DOC_FRAG" ; break ; case DTM . DOCUMENT_NODE : typestring = "DOC" ; break ; case DTM . DOCUMENT_TYPE_NODE : typestring = "DOC_TYPE" ; break ; case DTM . ELEMENT_NODE : typestring = "ELEMENT" ; break ; case DTM . ENTITY_NODE : typestring = "ENTITY" ; break ; case DTM . ENTITY_REFERENCE_NODE : typestring = "ENT_REF" ; break ; case DTM . NAMESPACE_NODE : typestring = "NAMESPACE" ; break ; case DTM . NOTATION_NODE : typestring = "NOTATION" ; break ; case DTM . NULL : typestring = "null" ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : typestring = "PI" ; break ; case DTM . TEXT_NODE : typestring = "TEXT" ; break ; default : typestring = "Unknown!" ; break ; } StringBuffer sb = new StringBuffer ( ) ; sb . append ( "[" + nodeHandle + ": " + typestring + "(0x" + Integer . toHexString ( getExpandedTypeID ( nodeHandle ) ) + ") " + getNodeNameX ( nodeHandle ) + " {" + getNamespaceURI ( nodeHandle ) + "}" + "=\"" + getNodeValue ( nodeHandle ) + "\"]" ) ; return sb . toString ( ) ; } public void setFeature ( String featureId , boolean state ) { } public boolean hasChildNodes ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int firstChild = _firstch ( identity ) ; return firstChild != DTM . NULL ; } final public int makeNodeHandle ( int nodeIdentity ) { if ( NULL == nodeIdentity ) return NULL ; if ( JJK_DEBUG && nodeIdentity > DTMManager . IDENT_NODE_DEFAULT ) System . err . println ( "GONK! (only useful in limited situations)" ) ; return m_dtmIdent . elementAt ( nodeIdentity > > > DTMManager . IDENT_DTM_NODE_BITS ) + ( nodeIdentity & DTMManager . IDENT_NODE_DEFAULT ) ; } final public int makeNodeIdentity ( int nodeHandle ) { if ( NULL == nodeHandle ) return NULL ; if ( m_mgrDefault != null ) { int whichDTMindex = nodeHandle > > > DTMManager . IDENT_DTM_NODE_BITS ; if ( m_mgrDefault . m_dtms [ whichDTMindex ] != this ) return NULL ; else return m_mgrDefault . m_dtm_offsets [ whichDTMindex ] | ( nodeHandle & DTMManager . IDENT_NODE_DEFAULT ) ; } int whichDTMid = m_dtmIdent . indexOf ( nodeHandle & DTMManager . IDENT_DTM_DEFAULT ) ; return ( whichDTMid == NULL ) ? NULL : ( whichDTMid << DTMManager . IDENT_DTM_NODE_BITS ) + ( nodeHandle & DTMManager . IDENT_NODE_DEFAULT ) ; } public int getFirstChild ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int firstChild = _firstch ( identity ) ; return makeNodeHandle ( firstChild ) ; } public int getTypedFirstChild ( int nodeHandle , int nodeType ) { int firstChild , eType ; if ( nodeType < DTM . NTYPES ) { for ( firstChild = _firstch ( makeNodeIdentity ( nodeHandle ) ) ; firstChild != DTM . NULL ; firstChild = _nextsib ( firstChild ) ) { eType = _exptype ( firstChild ) ; if ( eType == nodeType || ( eType >= DTM . NTYPES && m_expandedNameTable . getType ( eType ) == nodeType ) ) { return makeNodeHandle ( firstChild ) ; } } } else { for ( firstChild = _firstch ( makeNodeIdentity ( nodeHandle ) ) ; firstChild != DTM . NULL ; firstChild = _nextsib ( firstChild ) ) { if ( _exptype ( firstChild ) == nodeType ) { return makeNodeHandle ( firstChild ) ; } } } return DTM . NULL ; } public int getLastChild ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int child = _firstch ( identity ) ; int lastChild = DTM . NULL ; while ( child != DTM . NULL ) { lastChild = child ; child = _nextsib ( child ) ; } return makeNodeHandle ( lastChild ) ; } public abstract int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) ; public int getFirstAttribute ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; return makeNodeHandle ( getFirstAttributeIdentity ( nodeID ) ) ; } protected int getFirstAttributeIdentity ( int identity ) { int type = _type ( identity ) ; if ( DTM . ELEMENT_NODE == type ) { while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { type = _type ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } protected int getTypedAttribute ( int nodeHandle , int attType ) { int type = getNodeType ( nodeHandle ) ; if ( DTM . ELEMENT_NODE == type ) { int identity = makeNodeIdentity ( nodeHandle ) ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { type = _type ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { if ( _exptype ( identity ) == attType ) return makeNodeHandle ( identity ) ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } public int getNextSibling ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return DTM . NULL ; return makeNodeHandle ( _nextsib ( makeNodeIdentity ( nodeHandle ) ) ) ; } public int getTypedNextSibling ( int nodeHandle , int nodeType ) { if ( nodeHandle == DTM . NULL ) return DTM . NULL ; int node = makeNodeIdentity ( nodeHandle ) ; int eType ; while ( ( node = _nextsib ( node ) ) != DTM . NULL && ( ( eType = _exptype ( node ) ) != nodeType && m_expandedNameTable . getType ( eType ) != nodeType ) ) ; return ( node == DTM . NULL ? DTM . NULL : makeNodeHandle ( node ) ) ; } public int getPreviousSibling ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return DTM . NULL ; if ( m_prevsib != null ) return makeNodeHandle ( _prevsib ( makeNodeIdentity ( nodeHandle ) ) ) ; else { int nodeID = makeNodeIdentity ( nodeHandle ) ; int parent = _parent ( nodeID ) ; int node = _firstch ( parent ) ; int result = DTM . NULL ; while ( node != nodeID ) { result = node ; node = _nextsib ( node ) ; } return makeNodeHandle ( result ) ; } } public int getNextAttribute ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( _type ( nodeID ) == DTM . ATTRIBUTE_NODE ) { return makeNodeHandle ( getNextAttributeIdentity ( nodeID ) ) ; } return DTM . NULL ; } protected int getNextAttributeIdentity ( int identity ) { while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { int type = _type ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( type != DTM . NAMESPACE_NODE ) { break ; } } return DTM . NULL ; } private Vector m_namespaceLists = null ; protected void declareNamespaceInContext ( int elementNodeIndex , int namespaceNodeIndex ) { SuballocatedIntVector nsList = null ; if ( m_namespaceDeclSets == null ) { m_namespaceDeclSetElements = new SuballocatedIntVector ( 32 ) ; m_namespaceDeclSetElements . addElement ( elementNodeIndex ) ; m_namespaceDeclSets = new Vector ( ) ; nsList = new SuballocatedIntVector ( 32 ) ; m_namespaceDeclSets . addElement ( nsList ) ; } else { int last = m_namespaceDeclSetElements . size ( ) - 1 ; if ( last >= 0 && elementNodeIndex == m_namespaceDeclSetElements . elementAt ( last ) ) { nsList = ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( last ) ; } } if ( nsList == null ) { m_namespaceDeclSetElements . addElement ( elementNodeIndex ) ; SuballocatedIntVector inherited = findNamespaceContext ( _parent ( elementNodeIndex ) ) ; if ( inherited != null ) { int isize = inherited . size ( ) ; nsList = new SuballocatedIntVector ( Math . max ( Math . min ( isize + 16 , 2048 ) , 32 ) ) ; for ( int i = 0 ; i < isize ; ++ i ) { nsList . addElement ( inherited . elementAt ( i ) ) ; } } else { nsList = new SuballocatedIntVector ( 32 ) ; } m_namespaceDeclSets . addElement ( nsList ) ; } int newEType = _exptype ( namespaceNodeIndex ) ; for ( int i = nsList . size ( ) - 1 ; i >= 0 ; -- i ) { if ( newEType == getExpandedTypeID ( nsList . elementAt ( i ) ) ) { nsList . setElementAt ( makeNodeHandle ( namespaceNodeIndex ) , i ) ; return ; } } nsList . addElement ( makeNodeHandle ( namespaceNodeIndex ) ) ; } protected SuballocatedIntVector findNamespaceContext ( int elementNodeIndex ) { if ( null != m_namespaceDeclSetElements ) { int wouldBeAt = findInSortedSuballocatedIntVector ( m_namespaceDeclSetElements , elementNodeIndex ) ; if ( wouldBeAt >= 0 ) return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; if ( wouldBeAt == - 1 ) return null ; wouldBeAt = - 1 - wouldBeAt ; int candidate = m_namespaceDeclSetElements . elementAt ( -- wouldBeAt ) ; int ancestor = _parent ( elementNodeIndex ) ; if ( wouldBeAt == 0 && candidate < ancestor ) { int rootHandle = getDocumentRoot ( makeNodeHandle ( elementNodeIndex ) ) ; int rootID = makeNodeIdentity ( rootHandle ) ; int uppermostNSCandidateID ; if ( getNodeType ( rootHandle ) == DTM . DOCUMENT_NODE ) { int ch = _firstch ( rootID ) ; uppermostNSCandidateID = ( ch != DTM . NULL ) ? ch : rootID ; } else { uppermostNSCandidateID = rootID ; } if ( candidate == uppermostNSCandidateID ) { return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; } } while ( wouldBeAt >= 0 && ancestor > 0 ) { if ( candidate == ancestor ) { return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; } else if ( candidate < ancestor ) { do { ancestor = _parent ( ancestor ) ; } while ( candidate < ancestor ) ; } else { candidate = m_namespaceDeclSetElements . elementAt ( -- wouldBeAt ) ; } } } return null ; } protected int findInSortedSuballocatedIntVector ( SuballocatedIntVector vector , int lookfor ) { int i = 0 ; if ( vector != null ) { int first = 0 ; int last = vector . size ( ) - 1 ; while ( first <= last ) { i = ( first + last ) / 2 ; int test = lookfor - vector . elementAt ( i ) ; if ( test == 0 ) { return i ; } else if ( test < 0 ) { last = i - 1 ; } else { first = i + 1 ; } } if ( first > i ) { i = first ; } } return - 1 - i ; } public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) { if ( inScope ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( _type ( identity ) == DTM . ELEMENT_NODE ) { SuballocatedIntVector nsContext = findNamespaceContext ( identity ) ; if ( nsContext == null || nsContext . size ( ) < 1 ) return NULL ; return nsContext . elementAt ( 0 ) ; } else return NULL ; } else { int identity = makeNodeIdentity ( nodeHandle ) ; if ( _type ( identity ) == DTM . ELEMENT_NODE ) { while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { int type = _type ( identity ) ; if ( type == DTM . NAMESPACE_NODE ) return makeNodeHandle ( identity ) ; else if ( DTM . ATTRIBUTE_NODE != type ) break ; } return NULL ; } else return NULL ; } } public int getNextNamespaceNode ( int baseHandle , int nodeHandle , boolean inScope ) { if ( inScope ) { SuballocatedIntVector nsContext = findNamespaceContext ( makeNodeIdentity ( baseHandle ) ) ; if ( nsContext == null ) return NULL ; int i = 1 + nsContext . indexOf ( nodeHandle ) ; if ( i <= 0 || i == nsContext . size ( ) ) return NULL ; return nsContext . elementAt ( i ) ; } else { int identity = makeNodeIdentity ( nodeHandle ) ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { int type = _type ( identity ) ; if ( type == DTM . NAMESPACE_NODE ) { return makeNodeHandle ( identity ) ; } else if ( type != DTM . ATTRIBUTE_NODE ) { break ; } } } return DTM . NULL ; } public int getParent ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity > 0 ) return makeNodeHandle ( _parent ( identity ) ) ; else return DTM . NULL ; } public int getDocument ( ) { return m_dtmIdent . elementAt ( 0 ) ; } public int getOwnerDocument ( int nodeHandle ) { if ( DTM . DOCUMENT_NODE == getNodeType ( nodeHandle ) ) return DTM . NULL ; return getDocumentRoot ( nodeHandle ) ; } public int getDocumentRoot ( int nodeHandle ) { return getDocument ( ) ; } public abstract XMLString getStringValue ( int nodeHandle ) ; public int getStringValueChunkCount ( int nodeHandle ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return 0 ; } public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } public int getExpandedTypeID ( int nodeHandle ) { int id = makeNodeIdentity ( nodeHandle ) ; if ( id == NULL ) return NULL ; return _exptype ( id ) ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { ExpandedNameTable ent = m_expandedNameTable ; return ent . getExpandedTypeID ( namespace , localName , type ) ; } public String getLocalNameFromExpandedNameID ( int expandedNameID ) { return m_expandedNameTable . getLocalName ( expandedNameID ) ; } public String getNamespaceFromExpandedNameID ( int expandedNameID ) { return m_expandedNameTable . getNamespace ( expandedNameID ) ; } public int getNamespaceType ( final int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int expandedNameID = _exptype ( identity ) ; return m_expandedNameTable . getNamespaceID ( expandedNameID ) ; } public abstract String getNodeName ( int nodeHandle ) ; public String getNodeNameX ( int nodeHandle ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } public abstract String getLocalName ( int nodeHandle ) ; public abstract String getPrefix ( int nodeHandle ) ; public abstract String getNamespaceURI ( int nodeHandle ) ; public abstract String getNodeValue ( int nodeHandle ) ; public short getNodeType ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return DTM . NULL ; return m_expandedNameTable . getType ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public short getLevel ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; return ( short ) ( _level ( identity ) + 1 ) ; } public int getNodeIdent ( int nodeHandle ) { return makeNodeIdentity ( nodeHandle ) ; } public int getNodeHandle ( int nodeId ) { return makeNodeHandle ( nodeId ) ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getDocumentBaseURI ( ) { return m_documentBaseURI ; } public void setDocumentBaseURI ( String baseURI ) { m_documentBaseURI = baseURI ; } public String getDocumentSystemIdentifier ( int nodeHandle ) { return m_documentBaseURI ; } public String getDocumentEncoding ( int nodeHandle ) { return "UTF-8" ; } public String getDocumentStandalone ( int nodeHandle ) { return null ; } public String getDocumentVersion ( int documentHandle ) { return null ; } public boolean getDocumentAllDeclarationsProcessed ( ) { return true ; } public abstract String getDocumentTypeDeclarationSystemIdentifier ( ) ; public abstract String getDocumentTypeDeclarationPublicIdentifier ( ) ; public abstract int getElementById ( String elementId ) ; public abstract String getUnparsedEntityURI ( String name ) ; public boolean supportsPreStripping ( ) { return true ; } public boolean isNodeAfter ( int nodeHandle1 , int nodeHandle2 ) { int index1 = makeNodeIdentity ( nodeHandle1 ) ; int index2 = makeNodeIdentity ( nodeHandle2 ) ; return index1 != NULL & index2 != NULL & index1 <= index2 ; } public boolean isCharacterElementContentWhitespace ( int nodeHandle ) { return false ; } public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) { return true ; } public abstract boolean isAttributeSpecified ( int attributeHandle ) ; public abstract void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException ; public abstract void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException ; public org . w3c . dom . Node getNode ( int nodeHandle ) { return new DTMNodeProxy ( this , nodeHandle ) ; } public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; } public void appendTextChild ( String str ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; } protected void error ( String msg ) { throw new DTMException ( msg ) ; } protected boolean getShouldStripWhitespace ( ) { return m_shouldStripWS ; } protected void pushShouldStripWhitespace ( boolean shouldStrip ) { m_shouldStripWS = shouldStrip ; if ( null != m_shouldStripWhitespaceStack ) m_shouldStripWhitespaceStack . push ( shouldStrip ) ; } protected void popShouldStripWhitespace ( ) { if ( null != m_shouldStripWhitespaceStack ) m_shouldStripWS = m_shouldStripWhitespaceStack . popAndTop ( ) ; } protected void setShouldStripWhitespace ( boolean shouldStrip ) { m_shouldStripWS = shouldStrip ; if ( null != m_shouldStripWhitespaceStack ) m_shouldStripWhitespaceStack . setTop ( shouldStrip ) ; } public void documentRegistration ( ) { } public void documentRelease ( ) { } public DTMManager getManager ( ) { return m_mgr ; } public SuballocatedIntVector getDTMIDs ( ) { if ( m_mgr == null ) return null ; return m_dtmIdent ; } } 	1	['93', '1', '1', '17', '137', '4056', '5', '13', '67', '0.922302738', '2311', '0.777777778', '14', '0', '0.173913043', '0', '0', '23.55913978', '14', '2.4624', '2']
package org . apache . xalan . templates ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . Function3Args ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncFormatNumb extends Function3Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { ElemTemplateElement templElem = ( ElemTemplateElement ) xctxt . getNamespaceContext ( ) ; StylesheetRoot ss = templElem . getStylesheetRoot ( ) ; java . text . DecimalFormat formatter = null ; java . text . DecimalFormatSymbols dfs = null ; double num = getArg0 ( ) . execute ( xctxt ) . num ( ) ; String patternStr = getArg1 ( ) . execute ( xctxt ) . str ( ) ; if ( patternStr . indexOf ( 0x00A4 ) > 0 ) ss . error ( XSLTErrorResources . ER_CURRENCY_SIGN_ILLEGAL ) ; try { Expression arg2Expr = getArg2 ( ) ; if ( null != arg2Expr ) { String dfName = arg2Expr . execute ( xctxt ) . str ( ) ; QName qname = new QName ( dfName , xctxt . getNamespaceContext ( ) ) ; dfs = ss . getDecimalFormatComposed ( qname ) ; if ( null == dfs ) { warn ( xctxt , XSLTErrorResources . WG_NO_DECIMALFORMAT_DECLARATION , new Object [ ] { dfName } ) ; } else { formatter = new java . text . DecimalFormat ( ) ; formatter . setDecimalFormatSymbols ( dfs ) ; formatter . applyLocalizedPattern ( patternStr ) ; } } if ( null == formatter ) { if ( ss . getDecimalFormatCount ( ) > 0 ) dfs = ss . getDecimalFormatComposed ( new QName ( "" ) ) ; if ( dfs != null ) { formatter = new java . text . DecimalFormat ( ) ; formatter . setDecimalFormatSymbols ( dfs ) ; formatter . applyLocalizedPattern ( patternStr ) ; } else { dfs = new java . text . DecimalFormatSymbols ( java . util . Locale . US ) ; dfs . setInfinity ( Constants . ATTRVAL_INFINITY ) ; dfs . setNaN ( Constants . ATTRVAL_NAN ) ; formatter = new java . text . DecimalFormat ( ) ; formatter . setDecimalFormatSymbols ( dfs ) ; if ( null != patternStr ) formatter . applyLocalizedPattern ( patternStr ) ; } } return new XString ( formatter . format ( num ) ) ; } catch ( Exception iae ) { templElem . error ( XSLTErrorResources . ER_MALFORMED_FORMAT_STRING , new Object [ ] { patternStr } ) ; return XString . EMPTYSTRING ; } } public void warn ( XPathContext xctxt , String msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; errHandler . warning ( new TransformerException ( formattedMsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( ( argNum > 3 ) || ( argNum < 2 ) ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createMessage ( XSLTErrorResources . ER_TWO_OR_THREE , null ) ) ; } } 	1	['5', '6', '0', '13', '36', '10', '1', '12', '4', '2', '186', '0', '0', '0.941176471', '0.4', '2', '8', '36.2', '1', '0.8', '2']
package org . apache . xpath . functions ; import org . apache . xalan . templates . Constants ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Keywords ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncExtFunctionAvailable extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String prefix ; String namespace ; String methName ; String fullName = m_arg0 . execute ( xctxt ) . str ( ) ; int indexOfNSSep = fullName . indexOf ( ':' ) ; if ( indexOfNSSep < 0 ) { prefix = "" ; namespace = Constants . S_XSLNAMESPACEURL ; methName = fullName ; } else { prefix = fullName . substring ( 0 , indexOfNSSep ) ; namespace = xctxt . getNamespaceContext ( ) . getNamespaceForPrefix ( prefix ) ; if ( null == namespace ) return XBoolean . S_FALSE ; methName = fullName . substring ( indexOfNSSep + 1 ) ; } if ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) ) { try { return Keywords . functionAvailable ( methName ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } catch ( Exception e ) { return XBoolean . S_FALSE ; } } else { ExtensionsProvider extProvider = ( ExtensionsProvider ) xctxt . getOwnerObject ( ) ; return extProvider . functionAvailable ( namespace , methName ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } } 	1	['2', '4', '0', '8', '14', '1', '0', '8', '2', '2', '72', '0', '0', '0.979591837', '0.75', '2', '7', '35', '1', '0.5', '1']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . res . XPATHErrorResources ; public class FunctionMultiArgs extends Function3Args { Expression [ ] m_args ; public Expression [ ] getArgs ( ) { return m_args ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( argNum < 3 ) super . setArg ( arg , argNum ) ; else { if ( null == m_args ) { m_args = new Expression [ 1 ] ; m_args [ 0 ] = arg ; } else { Expression [ ] args = new Expression [ m_args . length + 1 ] ; System . arraycopy ( m_args , 0 , args , 0 , m_args . length ) ; args [ m_args . length ] = arg ; m_args = args ; } arg . exprSetParent ( this ) ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_args ) { for ( int i = 0 ; i < m_args . length ; i ++ ) { m_args [ i ] . fixupVariables ( vars , globalsSize ) ; } } } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { "Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called." } ) ; throw new RuntimeException ( fMsg ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( super . canTraverseOutsideSubtree ( ) ) return true ; else { int n = m_args . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( m_args [ i ] . canTraverseOutsideSubtree ( ) ) return true ; } return false ; } } class ArgMultiOwner implements ExpressionOwner { int m_argIndex ; ArgMultiOwner ( int index ) { m_argIndex = index ; } public Expression getExpression ( ) { return m_args [ m_argIndex ] ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FunctionMultiArgs . this ) ; m_args [ m_argIndex ] = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { super . callArgVisitors ( visitor ) ; if ( null != m_args ) { int n = m_args . length ; for ( int i = 0 ; i < n ; i ++ ) { m_args [ i ] . callVisitors ( new ArgMultiOwner ( i ) , visitor ) ; } } } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FunctionMultiArgs fma = ( FunctionMultiArgs ) expr ; if ( null != m_args ) { int n = m_args . length ; if ( ( null == fma ) || ( fma . m_args . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_args [ i ] . deepEquals ( fma . m_args [ i ] ) ) return false ; } } else if ( null != fma . m_args ) { return false ; } return true ; } } 	1	['9', '6', '1', '9', '24', '6', '2', '8', '8', '0.375', '218', '0', '1', '0.888888889', '0.355555556', '5', '22', '23.11111111', '7', '2.3333', '1']
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Writer ; import java . net . URL ; import java . net . URLConnection ; import java . net . UnknownServiceException ; import java . util . Enumeration ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . DOMWSFilter ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xalan . xsltc . runtime . output . TransletOutputHandlerFactory ; import org . apache . xml . dtm . DTMWSFilter ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; public final class TransformerImpl extends Transformer implements DOMCache , ErrorListener { private final static String EMPTY_STRING = "" ; private final static String NO_STRING = "no" ; private final static String YES_STRING = "yes" ; private final static String XML_STRING = "xml" ; private final static String LEXICAL_HANDLER_PROPERTY = "http://xml.org/sax/properties/lexical-handler" ; private static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; private AbstractTranslet _translet = null ; private String _method = null ; private String _encoding = null ; private String _sourceSystemId = null ; private ErrorListener _errorListener = this ; private URIResolver _uriResolver = null ; private Properties _properties , _propertiesClone ; private TransletOutputHandlerFactory _tohFactory = null ; private DOM _dom = null ; private int _indentNumber ; private TransformerFactoryImpl _tfactory = null ; private boolean _isIdentity = false ; private Hashtable _parameters = null ; static class MessageHandler extends org . apache . xalan . xsltc . runtime . MessageHandler { private ErrorListener _errorListener ; public MessageHandler ( ErrorListener errorListener ) { _errorListener = errorListener ; } public void displayMessage ( String msg ) { if ( _errorListener == null ) { System . err . println ( msg ) ; } else { try { _errorListener . warning ( new TransformerException ( msg ) ) ; } catch ( TransformerException e ) { } } } } protected TransformerImpl ( Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { this ( null , outputProperties , indentNumber , tfactory ) ; _isIdentity = true ; } protected TransformerImpl ( Translet translet , Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { _translet = ( AbstractTranslet ) translet ; _properties = createOutputProperties ( outputProperties ) ; _propertiesClone = ( Properties ) _properties . clone ( ) ; _indentNumber = indentNumber ; _tfactory = tfactory ; } protected AbstractTranslet getTranslet ( ) { return _translet ; } public boolean isIdentity ( ) { return _isIdentity ; } public void transform ( Source source , Result result ) throws TransformerException { if ( ! _isIdentity ) { if ( _translet == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_TRANSLET_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } transferOutputProperties ( _translet ) ; } final SerializationHandler toHandler = getOutputHandler ( result ) ; if ( toHandler == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_HANDLER_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } if ( _uriResolver != null && ! _isIdentity ) { _translet . setDOMCache ( this ) ; } if ( _isIdentity ) { transferOutputProperties ( toHandler ) ; } transform ( source , toHandler , _encoding ) ; if ( result instanceof DOMResult ) { ( ( DOMResult ) result ) . setNode ( _tohFactory . getNode ( ) ) ; } } public SerializationHandler getOutputHandler ( Result result ) throws TransformerException { _method = ( String ) _properties . get ( OutputKeys . METHOD ) ; _encoding = ( String ) _properties . getProperty ( OutputKeys . ENCODING ) ; _tohFactory = TransletOutputHandlerFactory . newInstance ( ) ; _tohFactory . setEncoding ( _encoding ) ; if ( _method != null ) { _tohFactory . setOutputMethod ( _method ) ; } if ( _indentNumber >= 0 ) { _tohFactory . setIndentNumber ( _indentNumber ) ; } try { if ( result instanceof SAXResult ) { final SAXResult target = ( SAXResult ) result ; final ContentHandler handler = target . getHandler ( ) ; _tohFactory . setHandler ( handler ) ; if ( handler instanceof LexicalHandler ) { _tohFactory . setLexicalHandler ( ( LexicalHandler ) handler ) ; } _tohFactory . setOutputType ( TransletOutputHandlerFactory . SAX ) ; return _tohFactory . getSerializationHandler ( ) ; } else if ( result instanceof DOMResult ) { _tohFactory . setNode ( ( ( DOMResult ) result ) . getNode ( ) ) ; _tohFactory . setOutputType ( TransletOutputHandlerFactory . DOM ) ; return _tohFactory . getSerializationHandler ( ) ; } else if ( result instanceof StreamResult ) { final StreamResult target = ( StreamResult ) result ; _tohFactory . setOutputType ( TransletOutputHandlerFactory . STREAM ) ; final Writer writer = target . getWriter ( ) ; if ( writer != null ) { _tohFactory . setWriter ( writer ) ; return _tohFactory . getSerializationHandler ( ) ; } final OutputStream ostream = target . getOutputStream ( ) ; if ( ostream != null ) { _tohFactory . setOutputStream ( ostream ) ; return _tohFactory . getSerializationHandler ( ) ; } String systemId = result . getSystemId ( ) ; if ( systemId == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_RESULT_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } URL url = null ; if ( systemId . startsWith ( "file:" ) ) { url = new URL ( systemId ) ; _tohFactory . setOutputStream ( new FileOutputStream ( url . getFile ( ) ) ) ; return _tohFactory . getSerializationHandler ( ) ; } else if ( systemId . startsWith ( "http:" ) ) { url = new URL ( systemId ) ; final URLConnection connection = url . openConnection ( ) ; _tohFactory . setOutputStream ( connection . getOutputStream ( ) ) ; return _tohFactory . getSerializationHandler ( ) ; } else { url = new File ( systemId ) . toURL ( ) ; _tohFactory . setOutputStream ( new FileOutputStream ( url . getFile ( ) ) ) ; return _tohFactory . getSerializationHandler ( ) ; } } } catch ( UnknownServiceException e ) { throw new TransformerException ( e ) ; } catch ( ParserConfigurationException e ) { throw new TransformerException ( e ) ; } catch ( IOException e ) { throw new TransformerException ( e ) ; } return null ; } protected void setDOM ( DOM dom ) { _dom = dom ; } private DOM getDOM ( Source source , int mask ) throws TransformerException { try { DOM dom = null ; SAXImpl saxImpl = null ; DTMWSFilter wsfilter ; if ( _translet != null && _translet instanceof StripFilter ) { wsfilter = new DOMWSFilter ( _translet ) ; } else { wsfilter = null ; } boolean hasIdCall = ( _translet != null ) ? _translet . hasIdCall ( ) : false ; if ( source != null ) { _sourceSystemId = source . getSystemId ( ) ; } if ( source instanceof SAXSource ) { final SAXSource sax = ( SAXSource ) source ; XMLReader reader = sax . getXMLReader ( ) ; final InputSource input = sax . getInputSource ( ) ; final boolean hasUserReader = reader != null ; if ( reader == null ) { reader = _tfactory . getXMLReader ( ) ; } XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; saxImpl = ( SAXImpl ) dtmManager . getDTM ( sax , false , wsfilter , true , false , hasUserReader , 0 , hasIdCall ) ; try { reader . setProperty ( LEXICAL_HANDLER_PROPERTY , saxImpl ) ; } catch ( SAXException e ) { } reader . setContentHandler ( saxImpl ) ; reader . setDTDHandler ( saxImpl ) ; saxImpl . setDocumentURI ( _sourceSystemId ) ; } else if ( source instanceof DOMSource ) { XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; saxImpl = ( SAXImpl ) dtmManager . getDTM ( source , false , wsfilter , true , false , hasIdCall ) ; saxImpl . setDocumentURI ( _sourceSystemId ) ; } else if ( source instanceof StreamSource ) { final StreamSource stream = ( StreamSource ) source ; final InputStream streamInput = stream . getInputStream ( ) ; final Reader streamReader = stream . getReader ( ) ; final XMLReader reader = _tfactory . getXMLReader ( ) ; XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; InputSource input ; if ( streamInput != null ) { input = new InputSource ( streamInput ) ; input . setSystemId ( _sourceSystemId ) ; } else if ( streamReader != null ) { input = new InputSource ( streamReader ) ; input . setSystemId ( _sourceSystemId ) ; } else if ( _sourceSystemId != null ) input = new InputSource ( _sourceSystemId ) ; else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_SOURCE_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } saxImpl = ( SAXImpl ) dtmManager . getDTM ( new SAXSource ( reader , input ) , false , wsfilter , true , false , hasIdCall ) ; saxImpl . setDocumentURI ( _sourceSystemId ) ; } else if ( source instanceof XSLTCSource ) { final XSLTCSource xsltcsrc = ( XSLTCSource ) source ; dom = xsltcsrc . getDOM ( ) ; } else if ( _dom != null ) { dom = _dom ; _dom = null ; } else { return null ; } if ( saxImpl != null ) { dom = saxImpl ; } if ( ! _isIdentity ) { _translet . prepassDocument ( dom ) ; } return dom ; } catch ( Exception e ) { if ( _errorListener != null ) postErrorToListener ( e . getMessage ( ) ) ; throw new TransformerException ( e ) ; } } private void transformIdentity ( Source source , SerializationHandler handler ) throws Exception { if ( source != null ) { _sourceSystemId = source . getSystemId ( ) ; } if ( source instanceof StreamSource ) { final StreamSource stream = ( StreamSource ) source ; final InputStream streamInput = stream . getInputStream ( ) ; final Reader streamReader = stream . getReader ( ) ; final XMLReader reader = _tfactory . getXMLReader ( ) ; try { reader . setProperty ( LEXICAL_HANDLER_PROPERTY , handler ) ; } catch ( SAXException e ) { } reader . setContentHandler ( handler ) ; InputSource input ; if ( streamInput != null ) { input = new InputSource ( streamInput ) ; input . setSystemId ( _sourceSystemId ) ; } else if ( streamReader != null ) { input = new InputSource ( streamReader ) ; input . setSystemId ( _sourceSystemId ) ; } else if ( _sourceSystemId != null ) { input = new InputSource ( _sourceSystemId ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_SOURCE_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } reader . parse ( input ) ; } else if ( source instanceof SAXSource ) { final SAXSource sax = ( SAXSource ) source ; XMLReader reader = sax . getXMLReader ( ) ; final InputSource input = sax . getInputSource ( ) ; if ( reader == null ) { reader = _tfactory . getXMLReader ( ) ; } try { reader . setProperty ( LEXICAL_HANDLER_PROPERTY , handler ) ; } catch ( SAXException e ) { } reader . setContentHandler ( handler ) ; reader . parse ( input ) ; } else if ( source instanceof DOMSource ) { final DOMSource domsrc = ( DOMSource ) source ; new DOM2TO ( domsrc . getNode ( ) , handler ) . parse ( ) ; } else if ( source instanceof XSLTCSource ) { final DOM dom = ( ( XSLTCSource ) source ) . getDOM ( ) ; ( ( SAXImpl ) dom ) . copy ( handler ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_SOURCE_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } } private void transform ( Source source , SerializationHandler handler , String encoding ) throws TransformerException { try { if ( _isIdentity ) { transformIdentity ( source , handler ) ; } else { _translet . transform ( getDOM ( source , 0 ) , handler ) ; } } catch ( TransletException e ) { if ( _errorListener != null ) postErrorToListener ( e . getMessage ( ) ) ; throw new TransformerException ( e ) ; } catch ( RuntimeException e ) { if ( _errorListener != null ) postErrorToListener ( e . getMessage ( ) ) ; throw new TransformerException ( e ) ; } catch ( Exception e ) { if ( _errorListener != null ) postErrorToListener ( e . getMessage ( ) ) ; throw new TransformerException ( e ) ; } } public ErrorListener getErrorListener ( ) { return _errorListener ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ERROR_LISTENER_NULL_ERR , "Transformer" ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } _errorListener = listener ; if ( _translet != null ) _translet . setMessageHandler ( new MessageHandler ( _errorListener ) ) ; } private void postErrorToListener ( String message ) { try { _errorListener . error ( new TransformerException ( message ) ) ; } catch ( TransformerException e ) { } } private void postWarningToListener ( String message ) { try { _errorListener . warning ( new TransformerException ( message ) ) ; } catch ( TransformerException e ) { } } private String makeCDATAString ( Hashtable cdata ) { if ( cdata == null ) return null ; StringBuffer result = new StringBuffer ( ) ; Enumeration elements = cdata . keys ( ) ; if ( elements . hasMoreElements ( ) ) { result . append ( ( String ) elements . nextElement ( ) ) ; while ( elements . hasMoreElements ( ) ) { String element = ( String ) elements . nextElement ( ) ; result . append ( ' ' ) ; result . append ( element ) ; } } return ( result . toString ( ) ) ; } public Properties getOutputProperties ( ) { return ( Properties ) _properties . clone ( ) ; } public String getOutputProperty ( String name ) throws IllegalArgumentException { if ( ! validOutputProperty ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_PROP_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } return _properties . getProperty ( name ) ; } public void setOutputProperties ( Properties properties ) throws IllegalArgumentException { if ( properties != null ) { final Enumeration names = properties . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { final String name = ( String ) names . nextElement ( ) ; if ( isDefaultProperty ( name , properties ) ) continue ; if ( validOutputProperty ( name ) ) { _properties . setProperty ( name , properties . getProperty ( name ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_PROP_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } } } else { _properties = _propertiesClone ; } } public void setOutputProperty ( String name , String value ) throws IllegalArgumentException { if ( ! validOutputProperty ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_PROP_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } _properties . setProperty ( name , value ) ; } private void transferOutputProperties ( AbstractTranslet translet ) { if ( _properties == null ) return ; Enumeration names = _properties . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; String value = ( String ) _properties . get ( name ) ; if ( value == null ) continue ; if ( name . equals ( OutputKeys . ENCODING ) ) { translet . _encoding = value ; } else if ( name . equals ( OutputKeys . METHOD ) ) { translet . _method = value ; } else if ( name . equals ( OutputKeys . DOCTYPE_PUBLIC ) ) { translet . _doctypePublic = value ; } else if ( name . equals ( OutputKeys . DOCTYPE_SYSTEM ) ) { translet . _doctypeSystem = value ; } else if ( name . equals ( OutputKeys . MEDIA_TYPE ) ) { translet . _mediaType = value ; } else if ( name . equals ( OutputKeys . STANDALONE ) ) { translet . _standalone = value ; } else if ( name . equals ( OutputKeys . VERSION ) ) { translet . _version = value ; } else if ( name . equals ( OutputKeys . OMIT_XML_DECLARATION ) ) { translet . _omitHeader = ( value != null && value . toLowerCase ( ) . equals ( "yes" ) ) ; } else if ( name . equals ( OutputKeys . INDENT ) ) { translet . _indent = ( value != null && value . toLowerCase ( ) . equals ( "yes" ) ) ; } else if ( name . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) ) { if ( value != null ) { translet . _cdata = null ; StringTokenizer e = new StringTokenizer ( value ) ; while ( e . hasMoreTokens ( ) ) { translet . addCdataElement ( e . nextToken ( ) ) ; } } } } } public void transferOutputProperties ( SerializationHandler handler ) { if ( _properties == null ) return ; String doctypePublic = null ; String doctypeSystem = null ; Enumeration names = _properties . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; String value = ( String ) _properties . get ( name ) ; if ( value == null ) continue ; if ( name . equals ( OutputKeys . DOCTYPE_PUBLIC ) ) { doctypePublic = value ; } else if ( name . equals ( OutputKeys . DOCTYPE_SYSTEM ) ) { doctypeSystem = value ; } else if ( name . equals ( OutputKeys . MEDIA_TYPE ) ) { handler . setMediaType ( value ) ; } else if ( name . equals ( OutputKeys . STANDALONE ) ) { handler . setStandalone ( value ) ; } else if ( name . equals ( OutputKeys . VERSION ) ) { handler . setVersion ( value ) ; } else if ( name . equals ( OutputKeys . OMIT_XML_DECLARATION ) ) { handler . setOmitXMLDeclaration ( value != null && value . toLowerCase ( ) . equals ( "yes" ) ) ; } else if ( name . equals ( OutputKeys . INDENT ) ) { handler . setIndent ( value != null && value . toLowerCase ( ) . equals ( "yes" ) ) ; } else if ( name . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) ) { if ( value != null ) { StringTokenizer e = new StringTokenizer ( value ) ; Vector uriAndLocalNames = null ; while ( e . hasMoreTokens ( ) ) { final String token = e . nextToken ( ) ; int lastcolon = token . lastIndexOf ( ':' ) ; String uri ; String localName ; if ( lastcolon > 0 ) { uri = token . substring ( 0 , lastcolon ) ; localName = token . substring ( lastcolon + 1 ) ; } else { uri = null ; localName = token ; } if ( uriAndLocalNames == null ) { uriAndLocalNames = new Vector ( ) ; } uriAndLocalNames . addElement ( uri ) ; uriAndLocalNames . addElement ( localName ) ; } handler . setCdataSectionElements ( uriAndLocalNames ) ; } } } if ( doctypePublic != null || doctypeSystem != null ) { handler . setDoctype ( doctypeSystem , doctypePublic ) ; } } private Properties createOutputProperties ( Properties outputProperties ) { final Properties defaults = new Properties ( ) ; defaults . setProperty ( OutputKeys . ENCODING , "UTF-8" ) ; defaults . setProperty ( OutputKeys . METHOD , XML_STRING ) ; defaults . setProperty ( OutputKeys . INDENT , NO_STRING ) ; defaults . setProperty ( OutputKeys . MEDIA_TYPE , "text/xml" ) ; defaults . setProperty ( OutputKeys . OMIT_XML_DECLARATION , NO_STRING ) ; defaults . setProperty ( OutputKeys . STANDALONE , NO_STRING ) ; defaults . setProperty ( OutputKeys . VERSION , "1.0" ) ; final Properties base = new Properties ( defaults ) ; if ( outputProperties != null ) { final Enumeration names = outputProperties . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { final String name = ( String ) names . nextElement ( ) ; base . setProperty ( name , outputProperties . getProperty ( name ) ) ; } } else { base . setProperty ( OutputKeys . ENCODING , _translet . _encoding ) ; if ( _translet . _method != null ) base . setProperty ( OutputKeys . METHOD , _translet . _method ) ; } final String method = base . getProperty ( OutputKeys . METHOD ) ; if ( method != null ) { if ( method . equals ( "html" ) ) { defaults . setProperty ( OutputKeys . INDENT , "yes" ) ; defaults . setProperty ( OutputKeys . VERSION , "4.0" ) ; defaults . setProperty ( OutputKeys . MEDIA_TYPE , "text/html" ) ; } else if ( method . equals ( "text" ) ) { defaults . setProperty ( OutputKeys . MEDIA_TYPE , "text/plain" ) ; } } return base ; } private boolean validOutputProperty ( String name ) { return ( name . equals ( OutputKeys . ENCODING ) || name . equals ( OutputKeys . METHOD ) || name . equals ( OutputKeys . INDENT ) || name . equals ( OutputKeys . DOCTYPE_PUBLIC ) || name . equals ( OutputKeys . DOCTYPE_SYSTEM ) || name . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) || name . equals ( OutputKeys . MEDIA_TYPE ) || name . equals ( OutputKeys . OMIT_XML_DECLARATION ) || name . equals ( OutputKeys . STANDALONE ) || name . equals ( OutputKeys . VERSION ) || name . charAt ( 0 ) == '{' ) ; } private boolean isDefaultProperty ( String name , Properties properties ) { return ( properties . get ( name ) == null ) ; } public void setParameter ( String name , Object value ) { if ( _isIdentity ) { if ( _parameters == null ) { _parameters = new Hashtable ( ) ; } _parameters . put ( name , value ) ; } else { _translet . addParameter ( name , value ) ; } } public void clearParameters ( ) { if ( _isIdentity && _parameters != null ) { _parameters . clear ( ) ; } else { _translet . clearParameters ( ) ; } } public final Object getParameter ( String name ) { if ( _isIdentity ) { return ( _parameters != null ) ? _parameters . get ( name ) : null ; } else { return _translet . getParameter ( name ) ; } } public URIResolver getURIResolver ( ) { return _uriResolver ; } public void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } public DOM retrieveDocument ( String uri , int mask , Translet translet ) { try { return getDOM ( _uriResolver . resolve ( uri , _sourceSystemId ) , mask ) ; } catch ( TransformerException e ) { if ( _errorListener != null ) postErrorToListener ( "File not found: " + e . getMessage ( ) ) ; return ( null ) ; } } public void error ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void fatalError ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void warning ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_MSG , e . getMessageAndLocation ( ) ) ) ; } } } 	1	['33', '2', '0', '23', '149', '280', '4', '20', '19', '0.890625', '1704', '1', '5', '0.295454545', '0.140151515', '0', '0', '50.03030303', '20', '2.8182', '8']
package org . apache . xpath . functions ; import java . util . StringTokenizer ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . StringVector ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class FuncId extends FunctionOneArg { private StringVector getNodesByID ( XPathContext xctxt , int docContext , String refval , StringVector usedrefs , NodeSetDTM nodeSet , boolean mayBeMore ) { if ( null != refval ) { String ref = null ; StringTokenizer tokenizer = new StringTokenizer ( refval ) ; boolean hasMore = tokenizer . hasMoreTokens ( ) ; DTM dtm = xctxt . getDTM ( docContext ) ; while ( hasMore ) { ref = tokenizer . nextToken ( ) ; hasMore = tokenizer . hasMoreTokens ( ) ; if ( ( null != usedrefs ) && usedrefs . contains ( ref ) ) { ref = null ; continue ; } int node = dtm . getElementById ( ref ) ; if ( DTM . NULL != node ) nodeSet . addNodeInDocOrder ( node , xctxt ) ; if ( ( null != ref ) && ( hasMore || mayBeMore ) ) { if ( null == usedrefs ) usedrefs = new StringVector ( ) ; usedrefs . addElement ( ref ) ; } } } return usedrefs ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocument ( ) ; if ( DTM . NULL == docContext ) error ( xctxt , XPATHErrorResources . ER_CONTEXT_HAS_NO_OWNERDOC , null ) ; XObject arg = m_arg0 . execute ( xctxt ) ; int argType = arg . getType ( ) ; XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; NodeSetDTM nodeSet = nodes . mutableNodeset ( ) ; if ( XObject . CLASS_NODESET == argType ) { DTMIterator ni = arg . iter ( ) ; StringVector usedrefs = null ; int pos = ni . nextNode ( ) ; while ( DTM . NULL != pos ) { DTM ndtm = ni . getDTM ( pos ) ; String refval = ndtm . getStringValue ( pos ) . toString ( ) ; pos = ni . nextNode ( ) ; usedrefs = getNodesByID ( xctxt , docContext , refval , usedrefs , nodeSet , DTM . NULL != pos ) ; } } else if ( XObject . CLASS_NULL == argType ) { return nodes ; } else { String refval = arg . str ( ) ; getNodesByID ( xctxt , docContext , refval , null , nodeSet , false ) ; } return nodes ; } } 	1	['3', '4', '0', '11', '27', '3', '0', '11', '2', '2', '169', '0', '0', '0.96', '0.476190476', '1', '7', '55.33333333', '8', '3', '1']
package org . apache . xml . dtm . ref . sax2dtm ; import javax . xml . transform . Source ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . IntVector ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . XMLStringFactory ; import org . xml . sax . SAXException ; public class SAX2RTFDTM extends SAX2DTM { private static final boolean DEBUG = false ; private int m_currentDocumentNode = NULL ; IntStack mark_size = new IntStack ( ) ; IntStack mark_data_size = new IntStack ( ) ; IntStack mark_char_size = new IntStack ( ) ; IntStack mark_doq_size = new IntStack ( ) ; IntStack mark_nsdeclset_size = new IntStack ( ) ; IntStack mark_nsdeclelem_size = new IntStack ( ) ; public SAX2RTFDTM ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; m_useSourceLocationProperty = false ; m_sourceSystemId = ( m_useSourceLocationProperty ) ? new StringVector ( ) : null ; m_sourceLine = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; m_sourceColumn = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; } public int getDocument ( ) { return makeNodeHandle ( m_currentDocumentNode ) ; } public int getDocumentRoot ( int nodeHandle ) { for ( int id = makeNodeIdentity ( nodeHandle ) ; id != NULL ; id = _parent ( id ) ) if ( _type ( id ) == DTM . DOCUMENT_NODE ) return makeNodeHandle ( id ) ; return DTM . NULL ; } protected int _documentRoot ( int nodeIdentifier ) { if ( nodeIdentifier == NULL ) return NULL ; for ( int parent = _parent ( nodeIdentifier ) ; parent != NULL ; nodeIdentifier = parent , parent = _parent ( nodeIdentifier ) ) ; return nodeIdentifier ; } public void startDocument ( ) throws SAXException { m_endDocumentOccured = false ; m_prefixMappings = new java . util . Vector ( ) ; m_contextIndexes = new IntStack ( ) ; m_parents = new IntStack ( ) ; m_currentDocumentNode = m_size ; super . startDocument ( ) ; } public void endDocument ( ) throws SAXException { charactersFlush ( ) ; m_nextsib . setElementAt ( NULL , m_currentDocumentNode ) ; if ( m_firstch . elementAt ( m_currentDocumentNode ) == NOTPROCESSED ) m_firstch . setElementAt ( NULL , m_currentDocumentNode ) ; if ( DTM . NULL != m_previous ) m_nextsib . setElementAt ( DTM . NULL , m_previous ) ; m_parents = null ; m_prefixMappings = null ; m_contextIndexes = null ; m_currentDocumentNode = NULL ; m_endDocumentOccured = true ; } public void pushRewindMark ( ) { if ( m_indexing || m_elemIndexes != null ) throw new java . lang . NullPointerException ( "Coding error; Don't try to mark/rewind an indexed DTM" ) ; mark_size . push ( m_size ) ; mark_nsdeclset_size . push ( ( m_namespaceDeclSets == null ) ? 0 : m_namespaceDeclSets . size ( ) ) ; mark_nsdeclelem_size . push ( ( m_namespaceDeclSetElements == null ) ? 0 : m_namespaceDeclSetElements . size ( ) ) ; mark_data_size . push ( m_data . size ( ) ) ; mark_char_size . push ( m_chars . size ( ) ) ; mark_doq_size . push ( m_dataOrQName . size ( ) ) ; } public boolean popRewindMark ( ) { boolean top = mark_size . empty ( ) ; m_size = top ? 0 : mark_size . pop ( ) ; m_exptype . setSize ( m_size ) ; m_firstch . setSize ( m_size ) ; m_nextsib . setSize ( m_size ) ; m_prevsib . setSize ( m_size ) ; m_parent . setSize ( m_size ) ; m_elemIndexes = null ; int ds = top ? 0 : mark_nsdeclset_size . pop ( ) ; if ( m_namespaceDeclSets != null ) m_namespaceDeclSets . setSize ( ds ) ; int ds1 = top ? 0 : mark_nsdeclelem_size . pop ( ) ; if ( m_namespaceDeclSetElements != null ) m_namespaceDeclSetElements . setSize ( ds1 ) ; m_data . setSize ( top ? 0 : mark_data_size . pop ( ) ) ; m_chars . setLength ( top ? 0 : mark_char_size . pop ( ) ) ; m_dataOrQName . setSize ( top ? 0 : mark_doq_size . pop ( ) ) ; return m_size == 0 ; } public boolean isTreeIncomplete ( ) { return ! m_endDocumentOccured ; } } 	1	['9', '5', '0', '11', '32', '8', '2', '9', '8', '0.78125', '392', '0.25', '6', '0.954285714', '0.26984127', '2', '20', '41.66666667', '10', '2.8889', '1']
package org . apache . xalan . processor ; public class XSLProcessorVersion { public static void main ( String argv [ ] ) { System . out . println ( S_VERSION ) ; } public static final String PRODUCT = "Xalan" ; public static String LANGUAGE = "Java" ; public static int VERSION = 2 ; public static int RELEASE = 5 ; public static int MAINTENANCE = 0 ; public static int DEVELOPMENT = 0 ; public static String S_VERSION = PRODUCT + " " + LANGUAGE + " " + VERSION + "." + RELEASE + "." + ( DEVELOPMENT > 0 ? ( "D" + DEVELOPMENT ) : ( "" + MAINTENANCE ) ) ; } 	1	['3', '1', '0', '2', '9', '1', '2', '0', '2', '1', '67', '0', '0', '0', '0.5', '0', '0', '19', '1', '0.3333', '1']
package org . apache . xalan . templates ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xpath . XPath ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public class ElemSort extends ElemTemplateElement { private XPath m_selectExpression = null ; public void setSelect ( XPath v ) { if ( v . getPatternString ( ) . indexOf ( "{" ) < 0 ) m_selectExpression = v ; else error ( XSLTErrorResources . ER_NO_CURLYBRACE , null ) ; } public XPath getSelect ( ) { return m_selectExpression ; } private AVT m_lang_avt = null ; public void setLang ( AVT v ) { m_lang_avt = v ; } public AVT getLang ( ) { return m_lang_avt ; } private AVT m_dataType_avt = null ; public void setDataType ( AVT v ) { m_dataType_avt = v ; } public AVT getDataType ( ) { return m_dataType_avt ; } private AVT m_order_avt = null ; public void setOrder ( AVT v ) { m_order_avt = v ; } public AVT getOrder ( ) { return m_order_avt ; } private AVT m_caseorder_avt = null ; public void setCaseOrder ( AVT v ) { m_caseorder_avt = v ; } public AVT getCaseOrder ( ) { return m_caseorder_avt ; } public int getXSLToken ( ) { return Constants . ELEMNAME_SORT ; } public String getNodeName ( ) { return Constants . ELEMNAME_SORT_STRING ; } public Node appendChild ( Node newChild ) throws DOMException { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } public void compose ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_caseorder_avt ) m_caseorder_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_dataType_avt ) m_dataType_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_lang_avt ) m_lang_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_order_avt ) m_order_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_selectExpression ) m_selectExpression . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; } } 	1	['15', '3', '0', '7', '26', '53', '2', '5', '15', '0.785714286', '164', '1', '5', '0.933333333', '0.293333333', '2', '6', '9.6', '2', '1', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionNamespaceSupport ; import org . apache . xalan . extensions . ExtensionNamespacesManager ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . StringVector ; public class ElemExtensionDecl extends ElemTemplateElement { public ElemExtensionDecl ( ) { } private String m_prefix = null ; public void setPrefix ( String v ) { m_prefix = v ; } public String getPrefix ( ) { return m_prefix ; } private StringVector m_functions = new StringVector ( ) ; public void setFunctions ( StringVector v ) { m_functions = v ; } public StringVector getFunctions ( ) { return m_functions ; } public String getFunction ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_functions ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( String ) m_functions . elementAt ( i ) ; } public int getFunctionCount ( ) { return ( null != m_functions ) ? m_functions . size ( ) : 0 ; } private StringVector m_elements = null ; public void setElements ( StringVector v ) { m_elements = v ; } public StringVector getElements ( ) { return m_elements ; } public String getElement ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_elements ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( String ) m_elements . elementAt ( i ) ; } public int getElementCount ( ) { return ( null != m_elements ) ? m_elements . size ( ) : 0 ; } public int getXSLToken ( ) { return Constants . ELEMNAME_EXTENSIONDECL ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; String prefix = getPrefix ( ) ; String declNamespace = getNamespaceForPrefix ( prefix ) ; String lang = null ; String srcURL = null ; String scriptSrc = null ; if ( null == declNamespace ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_NAMESPACE_DECL , new Object [ ] { prefix } ) ) ; for ( ElemTemplateElement child = getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { if ( Constants . ELEMNAME_EXTENSIONSCRIPT == child . getXSLToken ( ) ) { ElemExtensionScript sdecl = ( ElemExtensionScript ) child ; lang = sdecl . getLang ( ) ; srcURL = sdecl . getSrc ( ) ; ElemTemplateElement childOfSDecl = sdecl . getFirstChildElem ( ) ; if ( null != childOfSDecl ) { if ( Constants . ELEMNAME_TEXTLITERALRESULT == childOfSDecl . getXSLToken ( ) ) { ElemTextLiteral tl = ( ElemTextLiteral ) childOfSDecl ; char [ ] chars = tl . getChars ( ) ; scriptSrc = new String ( chars ) ; if ( scriptSrc . trim ( ) . length ( ) == 0 ) scriptSrc = null ; } } } } if ( null == lang ) lang = "javaclass" ; if ( lang . equals ( "javaclass" ) && ( scriptSrc != null ) ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEM_CONTENT_NOT_ALLOWED , new Object [ ] { scriptSrc } ) ) ; ExtensionNamespaceSupport extNsSpt = null ; ExtensionNamespacesManager extNsMgr = sroot . getExtensionNamespacesManager ( ) ; if ( extNsMgr . namespaceIndex ( declNamespace , extNsMgr . getExtensions ( ) ) == - 1 ) { if ( lang . equals ( "javaclass" ) ) { if ( null == srcURL ) { extNsSpt = extNsMgr . defineJavaNamespace ( declNamespace ) ; } else if ( extNsMgr . namespaceIndex ( srcURL , extNsMgr . getExtensions ( ) ) == - 1 ) { extNsSpt = extNsMgr . defineJavaNamespace ( declNamespace , srcURL ) ; } } else { String handler = "org.apache.xalan.extensions.ExtensionHandlerGeneral" ; Object [ ] args = { declNamespace , this . m_elements , this . m_functions , lang , srcURL , scriptSrc , getSystemId ( ) } ; extNsSpt = new ExtensionNamespaceSupport ( declNamespace , handler , args ) ; } } if ( extNsSpt != null ) extNsMgr . registerExtension ( extNsSpt ) ; } public void runtimeInit ( TransformerImpl transformer ) throws TransformerException { } } 	1	['14', '3', '0', '10', '42', '27', '1', '9', '14', '0.666666667', '290', '1', '2', '0.937799043', '0.25', '3', '4', '19.5', '2', '1.0714', '1']
package org . apache . xml . utils ; public class XMLChar { public static final byte [ ] CHARS = new byte [ 1 << 16 ] ; public static final int MASK_VALID = 0x01 ; public static final int MASK_SPACE = 0x02 ; public static final int MASK_NAME_START = 0x04 ; public static final int MASK_NAME = 0x08 ; public static final int MASK_PUBID = 0x10 ; public static final int MASK_CONTENT = 0x20 ; public static final int MASK_NCNAME_START = 0x40 ; public static final int MASK_NCNAME = 0x80 ; static { int charRange [ ] = { 0x0009 , 0x000A , 0x000D , 0x000D , 0x0020 , 0xD7FF , 0xE000 , 0xFFFD , } ; int spaceChar [ ] = { 0x0020 , 0x0009 , 0x000D , 0x000A , } ; int nameChar [ ] = { 0x002D , 0x002E , } ; int nameStartChar [ ] = { 0x003A , 0x005F , } ; int pubidChar [ ] = { 0x000A , 0x000D , 0x0020 , 0x0021 , 0x0023 , 0x0024 , 0x0025 , 0x003D , 0x005F } ; int pubidRange [ ] = { 0x0027 , 0x003B , 0x003F , 0x005A , 0x0061 , 0x007A } ; int letterRange [ ] = { 0x0041 , 0x005A , 0x0061 , 0x007A , 0x00C0 , 0x00D6 , 0x00D8 , 0x00F6 , 0x00F8 , 0x0131 , 0x0134 , 0x013E , 0x0141 , 0x0148 , 0x014A , 0x017E , 0x0180 , 0x01C3 , 0x01CD , 0x01F0 , 0x01F4 , 0x01F5 , 0x01FA , 0x0217 , 0x0250 , 0x02A8 , 0x02BB , 0x02C1 , 0x0388 , 0x038A , 0x038E , 0x03A1 , 0x03A3 , 0x03CE , 0x03D0 , 0x03D6 , 0x03E2 , 0x03F3 , 0x0401 , 0x040C , 0x040E , 0x044F , 0x0451 , 0x045C , 0x045E , 0x0481 , 0x0490 , 0x04C4 , 0x04C7 , 0x04C8 , 0x04CB , 0x04CC , 0x04D0 , 0x04EB , 0x04EE , 0x04F5 , 0x04F8 , 0x04F9 , 0x0531 , 0x0556 , 0x0561 , 0x0586 , 0x05D0 , 0x05EA , 0x05F0 , 0x05F2 , 0x0621 , 0x063A , 0x0641 , 0x064A , 0x0671 , 0x06B7 , 0x06BA , 0x06BE , 0x06C0 , 0x06CE , 0x06D0 , 0x06D3 , 0x06E5 , 0x06E6 , 0x0905 , 0x0939 , 0x0958 , 0x0961 , 0x0985 , 0x098C , 0x098F , 0x0990 , 0x0993 , 0x09A8 , 0x09AA , 0x09B0 , 0x09B6 , 0x09B9 , 0x09DC , 0x09DD , 0x09DF , 0x09E1 , 0x09F0 , 0x09F1 , 0x0A05 , 0x0A0A , 0x0A0F , 0x0A10 , 0x0A13 , 0x0A28 , 0x0A2A , 0x0A30 , 0x0A32 , 0x0A33 , 0x0A35 , 0x0A36 , 0x0A38 , 0x0A39 , 0x0A59 , 0x0A5C , 0x0A72 , 0x0A74 , 0x0A85 , 0x0A8B , 0x0A8F , 0x0A91 , 0x0A93 , 0x0AA8 , 0x0AAA , 0x0AB0 , 0x0AB2 , 0x0AB3 , 0x0AB5 , 0x0AB9 , 0x0B05 , 0x0B0C , 0x0B0F , 0x0B10 , 0x0B13 , 0x0B28 , 0x0B2A , 0x0B30 , 0x0B32 , 0x0B33 , 0x0B36 , 0x0B39 , 0x0B5C , 0x0B5D , 0x0B5F , 0x0B61 , 0x0B85 , 0x0B8A , 0x0B8E , 0x0B90 , 0x0B92 , 0x0B95 , 0x0B99 , 0x0B9A , 0x0B9E , 0x0B9F , 0x0BA3 , 0x0BA4 , 0x0BA8 , 0x0BAA , 0x0BAE , 0x0BB5 , 0x0BB7 , 0x0BB9 , 0x0C05 , 0x0C0C , 0x0C0E , 0x0C10 , 0x0C12 , 0x0C28 , 0x0C2A , 0x0C33 , 0x0C35 , 0x0C39 , 0x0C60 , 0x0C61 , 0x0C85 , 0x0C8C , 0x0C8E , 0x0C90 , 0x0C92 , 0x0CA8 , 0x0CAA , 0x0CB3 , 0x0CB5 , 0x0CB9 , 0x0CE0 , 0x0CE1 , 0x0D05 , 0x0D0C , 0x0D0E , 0x0D10 , 0x0D12 , 0x0D28 , 0x0D2A , 0x0D39 , 0x0D60 , 0x0D61 , 0x0E01 , 0x0E2E , 0x0E32 , 0x0E33 , 0x0E40 , 0x0E45 , 0x0E81 , 0x0E82 , 0x0E87 , 0x0E88 , 0x0E94 , 0x0E97 , 0x0E99 , 0x0E9F , 0x0EA1 , 0x0EA3 , 0x0EAA , 0x0EAB , 0x0EAD , 0x0EAE , 0x0EB2 , 0x0EB3 , 0x0EC0 , 0x0EC4 , 0x0F40 , 0x0F47 , 0x0F49 , 0x0F69 , 0x10A0 , 0x10C5 , 0x10D0 , 0x10F6 , 0x1102 , 0x1103 , 0x1105 , 0x1107 , 0x110B , 0x110C , 0x110E , 0x1112 , 0x1154 , 0x1155 , 0x115F , 0x1161 , 0x116D , 0x116E , 0x1172 , 0x1173 , 0x11AE , 0x11AF , 0x11B7 , 0x11B8 , 0x11BC , 0x11C2 , 0x1E00 , 0x1E9B , 0x1EA0 , 0x1EF9 , 0x1F00 , 0x1F15 , 0x1F18 , 0x1F1D , 0x1F20 , 0x1F45 , 0x1F48 , 0x1F4D , 0x1F50 , 0x1F57 , 0x1F5F , 0x1F7D , 0x1F80 , 0x1FB4 , 0x1FB6 , 0x1FBC , 0x1FC2 , 0x1FC4 , 0x1FC6 , 0x1FCC , 0x1FD0 , 0x1FD3 , 0x1FD6 , 0x1FDB , 0x1FE0 , 0x1FEC , 0x1FF2 , 0x1FF4 , 0x1FF6 , 0x1FFC , 0x212A , 0x212B , 0x2180 , 0x2182 , 0x3041 , 0x3094 , 0x30A1 , 0x30FA , 0x3105 , 0x312C , 0xAC00 , 0xD7A3 , 0x3021 , 0x3029 , 0x4E00 , 0x9FA5 , } ; int letterChar [ ] = { 0x0386 , 0x038C , 0x03DA , 0x03DC , 0x03DE , 0x03E0 , 0x0559 , 0x06D5 , 0x093D , 0x09B2 , 0x0A5E , 0x0A8D , 0x0ABD , 0x0AE0 , 0x0B3D , 0x0B9C , 0x0CDE , 0x0E30 , 0x0E84 , 0x0E8A , 0x0E8D , 0x0EA5 , 0x0EA7 , 0x0EB0 , 0x0EBD , 0x1100 , 0x1109 , 0x113C , 0x113E , 0x1140 , 0x114C , 0x114E , 0x1150 , 0x1159 , 0x1163 , 0x1165 , 0x1167 , 0x1169 , 0x1175 , 0x119E , 0x11A8 , 0x11AB , 0x11BA , 0x11EB , 0x11F0 , 0x11F9 , 0x1F59 , 0x1F5B , 0x1F5D , 0x1FBE , 0x2126 , 0x212E , 0x3007 , } ; int combiningCharRange [ ] = { 0x0300 , 0x0345 , 0x0360 , 0x0361 , 0x0483 , 0x0486 , 0x0591 , 0x05A1 , 0x05A3 , 0x05B9 , 0x05BB , 0x05BD , 0x05C1 , 0x05C2 , 0x064B , 0x0652 , 0x06D6 , 0x06DC , 0x06DD , 0x06DF , 0x06E0 , 0x06E4 , 0x06E7 , 0x06E8 , 0x06EA , 0x06ED , 0x0901 , 0x0903 , 0x093E , 0x094C , 0x0951 , 0x0954 , 0x0962 , 0x0963 , 0x0981 , 0x0983 , 0x09C0 , 0x09C4 , 0x09C7 , 0x09C8 , 0x09CB , 0x09CD , 0x09E2 , 0x09E3 , 0x0A40 , 0x0A42 , 0x0A47 , 0x0A48 , 0x0A4B , 0x0A4D , 0x0A70 , 0x0A71 , 0x0A81 , 0x0A83 , 0x0ABE , 0x0AC5 , 0x0AC7 , 0x0AC9 , 0x0ACB , 0x0ACD , 0x0B01 , 0x0B03 , 0x0B3E , 0x0B43 , 0x0B47 , 0x0B48 , 0x0B4B , 0x0B4D , 0x0B56 , 0x0B57 , 0x0B82 , 0x0B83 , 0x0BBE , 0x0BC2 , 0x0BC6 , 0x0BC8 , 0x0BCA , 0x0BCD , 0x0C01 , 0x0C03 , 0x0C3E , 0x0C44 , 0x0C46 , 0x0C48 , 0x0C4A , 0x0C4D , 0x0C55 , 0x0C56 , 0x0C82 , 0x0C83 , 0x0CBE , 0x0CC4 , 0x0CC6 , 0x0CC8 , 0x0CCA , 0x0CCD , 0x0CD5 , 0x0CD6 , 0x0D02 , 0x0D03 , 0x0D3E , 0x0D43 , 0x0D46 , 0x0D48 , 0x0D4A , 0x0D4D , 0x0E34 , 0x0E3A , 0x0E47 , 0x0E4E , 0x0EB4 , 0x0EB9 , 0x0EBB , 0x0EBC , 0x0EC8 , 0x0ECD , 0x0F18 , 0x0F19 , 0x0F71 , 0x0F84 , 0x0F86 , 0x0F8B , 0x0F90 , 0x0F95 , 0x0F99 , 0x0FAD , 0x0FB1 , 0x0FB7 , 0x20D0 , 0x20DC , 0x302A , 0x302F , } ; int combiningCharChar [ ] = { 0x05BF , 0x05C4 , 0x0670 , 0x093C , 0x094D , 0x09BC , 0x09BE , 0x09BF , 0x09D7 , 0x0A02 , 0x0A3C , 0x0A3E , 0x0A3F , 0x0ABC , 0x0B3C , 0x0BD7 , 0x0D57 , 0x0E31 , 0x0EB1 , 0x0F35 , 0x0F37 , 0x0F39 , 0x0F3E , 0x0F3F , 0x0F97 , 0x0FB9 , 0x20E1 , 0x3099 , 0x309A , } ; int digitRange [ ] = { 0x0030 , 0x0039 , 0x0660 , 0x0669 , 0x06F0 , 0x06F9 , 0x0966 , 0x096F , 0x09E6 , 0x09EF , 0x0A66 , 0x0A6F , 0x0AE6 , 0x0AEF , 0x0B66 , 0x0B6F , 0x0BE7 , 0x0BEF , 0x0C66 , 0x0C6F , 0x0CE6 , 0x0CEF , 0x0D66 , 0x0D6F , 0x0E50 , 0x0E59 , 0x0ED0 , 0x0ED9 , 0x0F20 , 0x0F29 , } ; int extenderRange [ ] = { 0x3031 , 0x3035 , 0x309D , 0x309E , 0x30FC , 0x30FE , } ; int extenderChar [ ] = { 0x00B7 , 0x02D0 , 0x02D1 , 0x0387 , 0x0640 , 0x0E46 , 0x0EC6 , 0x3005 , } ; int specialChar [ ] = { '<' , '&' , '\n' , '\r' , ']' , } ; for ( int i = 0 ; i < charRange . length ; i += 2 ) { for ( int j = charRange [ i ] ; j <= charRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_VALID | MASK_CONTENT ; } } for ( int i = 0 ; i < specialChar . length ; i ++ ) { CHARS [ specialChar [ i ] ] = ( byte ) ( CHARS [ specialChar [ i ] ] & ~ MASK_CONTENT ) ; } for ( int i = 0 ; i < spaceChar . length ; i ++ ) { CHARS [ spaceChar [ i ] ] |= MASK_SPACE ; } for ( int i = 0 ; i < nameStartChar . length ; i ++ ) { CHARS [ nameStartChar [ i ] ] |= MASK_NAME_START | MASK_NAME | MASK_NCNAME_START | MASK_NCNAME ; } for ( int i = 0 ; i < letterRange . length ; i += 2 ) { for ( int j = letterRange [ i ] ; j <= letterRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_NAME_START | MASK_NAME | MASK_NCNAME_START | MASK_NCNAME ; } } for ( int i = 0 ; i < letterChar . length ; i ++ ) { CHARS [ letterChar [ i ] ] |= MASK_NAME_START | MASK_NAME | MASK_NCNAME_START | MASK_NCNAME ; } for ( int i = 0 ; i < nameChar . length ; i ++ ) { CHARS [ nameChar [ i ] ] |= MASK_NAME | MASK_NCNAME ; } for ( int i = 0 ; i < digitRange . length ; i += 2 ) { for ( int j = digitRange [ i ] ; j <= digitRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_NAME | MASK_NCNAME ; } } for ( int i = 0 ; i < combiningCharRange . length ; i += 2 ) { for ( int j = combiningCharRange [ i ] ; j <= combiningCharRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_NAME | MASK_NCNAME ; } } for ( int i = 0 ; i < combiningCharChar . length ; i ++ ) { CHARS [ combiningCharChar [ i ] ] |= MASK_NAME | MASK_NCNAME ; } for ( int i = 0 ; i < extenderRange . length ; i += 2 ) { for ( int j = extenderRange [ i ] ; j <= extenderRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_NAME | MASK_NCNAME ; } } for ( int i = 0 ; i < extenderChar . length ; i ++ ) { CHARS [ extenderChar [ i ] ] |= MASK_NAME | MASK_NCNAME ; } CHARS [ ':' ] &= ~ ( MASK_NCNAME_START | MASK_NCNAME ) ; for ( int i = 0 ; i < pubidChar . length ; i ++ ) { CHARS [ pubidChar [ i ] ] |= MASK_PUBID ; } for ( int i = 0 ; i < pubidRange . length ; i += 2 ) { for ( int j = pubidRange [ i ] ; j <= pubidRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_PUBID ; } } } public static boolean isSupplemental ( int c ) { return ( c >= 0x10000 && c <= 0x10FFFF ) ; } public static int supplemental ( char h , char l ) { return ( h - 0xD800 ) * 0x400 + ( l - 0xDC00 ) + 0x10000 ; } public static char highSurrogate ( int c ) { return ( char ) ( ( ( c - 0x00010000 ) > > 10 ) + 0xD800 ) ; } public static char lowSurrogate ( int c ) { return ( char ) ( ( ( c - 0x00010000 ) & 0x3FF ) + 0xDC00 ) ; } public static boolean isHighSurrogate ( int c ) { return ( 0xD800 <= c && c <= 0xDBFF ) ; } public static boolean isLowSurrogate ( int c ) { return ( 0xDC00 <= c && c <= 0xDFFF ) ; } public static boolean isValid ( int c ) { return ( c < 0x10000 && ( CHARS [ c ] & MASK_VALID ) != 0 ) || ( 0x10000 <= c && c <= 0x10FFFF ) ; } public static boolean isInvalid ( int c ) { return ! isValid ( c ) ; } public static boolean isContent ( int c ) { return ( c < 0x10000 && ( CHARS [ c ] & MASK_CONTENT ) != 0 ) || ( 0x10000 <= c && c <= 0x10FFFF ) ; } public static boolean isMarkup ( int c ) { return c == '<' || c == '&' || c == '%' ; } public static boolean isSpace ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_SPACE ) != 0 ; } public static boolean isNameStart ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_NAME_START ) != 0 ; } public static boolean isName ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_NAME ) != 0 ; } public static boolean isNCNameStart ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_NCNAME_START ) != 0 ; } public static boolean isNCName ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_NCNAME ) != 0 ; } public static boolean isPubid ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_PUBID ) != 0 ; } public static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) return false ; char ch = name . charAt ( 0 ) ; if ( isNameStart ( ch ) == false ) return false ; for ( int i = 1 ; i < name . length ( ) ; i ++ ) { ch = name . charAt ( i ) ; if ( isName ( ch ) == false ) { return false ; } } return true ; } public static boolean isValidNCName ( String ncName ) { if ( ncName . length ( ) == 0 ) return false ; char ch = ncName . charAt ( 0 ) ; if ( isNCNameStart ( ch ) == false ) return false ; for ( int i = 1 ; i < ncName . length ( ) ; i ++ ) { ch = ncName . charAt ( i ) ; if ( isNCName ( ch ) == false ) { return false ; } } return true ; } public static boolean isValidNmtoken ( String nmtoken ) { if ( nmtoken . length ( ) == 0 ) return false ; for ( int i = 0 ; i < nmtoken . length ( ) ; i ++ ) { char ch = nmtoken . charAt ( i ) ; if ( ! isName ( ch ) ) { return false ; } } return true ; } public static boolean isValidIANAEncoding ( String ianaEncoding ) { if ( ianaEncoding != null ) { int length = ianaEncoding . length ( ) ; if ( length > 0 ) { char c = ianaEncoding . charAt ( 0 ) ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) ) { for ( int i = 1 ; i < length ; i ++ ) { c = ianaEncoding . charAt ( i ) ; if ( ( c < 'A' || c > 'Z' ) && ( c < 'a' || c > 'z' ) && ( c < '0' || c > '9' ) && c != '.' && c != '_' && c != '-' ) { return false ; } } return true ; } } } return false ; } public static boolean isValidJavaEncoding ( String javaEncoding ) { if ( javaEncoding != null ) { int length = javaEncoding . length ( ) ; if ( length > 0 ) { for ( int i = 1 ; i < length ; i ++ ) { char c = javaEncoding . charAt ( i ) ; if ( ( c < 'A' || c > 'Z' ) && ( c < 'a' || c > 'z' ) && ( c < '0' || c > '9' ) && c != '.' && c != '_' && c != '-' ) { return false ; } } return true ; } } return false ; } } 	1	['23', '1', '0', '2', '26', '181', '2', '0', '22', '0.97979798', '3198', '0', '0', '0', '0.25', '0', '0', '137.6521739', '17', '3.913', '1']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . net . URL ; import java . net . URLConnection ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMNodeList ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xpath . XPathProcessorException ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; public class ExtensionHandlerGeneral extends ExtensionHandler { private String m_scriptSrc ; private String m_scriptSrcURL ; private Hashtable m_functions = new Hashtable ( ) ; private Hashtable m_elements = new Hashtable ( ) ; private Object m_mgr ; private Object m_engine ; private static final String BSF_MANAGER = "com.ibm.bsf.BSFManager" ; private static Class managerClass ; private static Method mgrLoadScriptingEngine ; private static final String BSF_ENGINE = "com.ibm.bsf.BSFEngine" ; private static Method engineExec ; private static Method engineCall ; private static final Integer NEG1INT = new Integer ( - 1 ) ; static { try { managerClass = ExtensionHandler . getClassForName ( BSF_MANAGER ) ; mgrLoadScriptingEngine = managerClass . getMethod ( "loadScriptingEngine" , new Class [ ] { String . class } ) ; Class engineClass = ExtensionHandler . getClassForName ( BSF_ENGINE ) ; engineExec = engineClass . getMethod ( "exec" , new Class [ ] { String . class , Integer . TYPE , Integer . TYPE , Object . class } ) ; engineCall = engineClass . getMethod ( "call" , new Class [ ] { Object . class , String . class , Class . forName ( "[Ljava.lang.Object;" ) } ) ; } catch ( Exception e ) { managerClass = null ; mgrLoadScriptingEngine = null ; engineExec = null ; engineCall = null ; e . printStackTrace ( ) ; } } public ExtensionHandlerGeneral ( String namespaceUri , StringVector elemNames , StringVector funcNames , String scriptLang , String scriptSrcURL , String scriptSrc , String systemId ) throws TransformerException { super ( namespaceUri , scriptLang ) ; if ( elemNames != null ) { Object junk = new Object ( ) ; int n = elemNames . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String tok = elemNames . elementAt ( i ) ; m_elements . put ( tok , junk ) ; } } if ( funcNames != null ) { Object junk = new Object ( ) ; int n = funcNames . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String tok = funcNames . elementAt ( i ) ; m_functions . put ( tok , junk ) ; } } m_scriptSrcURL = scriptSrcURL ; m_scriptSrc = scriptSrc ; if ( m_scriptSrcURL != null ) { URL url = null ; try { url = new URL ( m_scriptSrcURL ) ; } catch ( java . net . MalformedURLException mue ) { int indexOfColon = m_scriptSrcURL . indexOf ( ':' ) ; int indexOfSlash = m_scriptSrcURL . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { url = null ; throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_FIND_EXTERN_SCRIPT , new Object [ ] { m_scriptSrcURL } ) , mue ) ; } else { try { url = new URL ( new URL ( SystemIDResolver . getAbsoluteURI ( systemId ) ) , m_scriptSrcURL ) ; } catch ( java . net . MalformedURLException mue2 ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_FIND_EXTERN_SCRIPT , new Object [ ] { m_scriptSrcURL } ) , mue2 ) ; } } } if ( url != null ) { try { URLConnection uc = url . openConnection ( ) ; InputStream is = uc . getInputStream ( ) ; byte [ ] bArray = new byte [ uc . getContentLength ( ) ] ; is . read ( bArray ) ; m_scriptSrc = new String ( bArray ) ; } catch ( IOException ioe ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_FIND_EXTERN_SCRIPT , new Object [ ] { m_scriptSrcURL } ) , ioe ) ; } } } if ( null == managerClass ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_INIT_BSFMGR , null ) ) ; try { m_mgr = managerClass . newInstance ( ) ; m_engine = mgrLoadScriptingEngine . invoke ( m_mgr , new Object [ ] { scriptLang } ) ; engineExec . invoke ( m_engine , new Object [ ] { "XalanScript" , NEG1INT , NEG1INT , m_scriptSrc } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_CMPL_EXTENSN , null ) , e ) ; } } public boolean isFunctionAvailable ( String function ) { return ( m_functions . get ( function ) != null ) ; } public boolean isElementAvailable ( String element ) { return ( m_elements . get ( element ) != null ) ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { Object [ ] argArray ; try { argArray = new Object [ args . size ( ) ] ; for ( int i = 0 ; i < argArray . length ; i ++ ) { Object o = args . elementAt ( i ) ; argArray [ i ] = ( o instanceof XObject ) ? ( ( XObject ) o ) . object ( ) : o ; o = argArray [ i ] ; if ( null != o && o instanceof DTMIterator ) { argArray [ i ] = new DTMNodeList ( ( DTMIterator ) o ) ; } } return engineCall . invoke ( m_engine , new Object [ ] { null , funcName , argArray } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; String msg = e . getMessage ( ) ; if ( null != msg ) { if ( msg . startsWith ( "Stopping after fatal error:" ) ) { msg = msg . substring ( "Stopping after fatal error:" . length ( ) ) ; } throw new TransformerException ( e ) ; } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_CREATE_EXTENSN , new Object [ ] { funcName , e } ) ) ; } } } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { return callFunction ( extFunction . getFunctionName ( ) , args , extFunction . getMethodKey ( ) , exprContext ) ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { Vector argv = new Vector ( 2 ) ; argv . addElement ( xpc ) ; argv . addElement ( element ) ; result = callFunction ( localPart , argv , methodKey , transformer . getXPathContext ( ) . getExpressionContext ( ) ) ; } catch ( XPathProcessorException e ) { throw new TransformerException ( e . getMessage ( ) , e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1	['8', '2', '0', '15', '54', '18', '0', '15', '6', '0.904761905', '565', '0.866666667', '0', '0.5', '0.328571429', '0', '0', '67.75', '2', '1', '2']
package org . apache . xalan . templates ; public class ElemExtensionScript extends ElemTemplateElement { public ElemExtensionScript ( ) { } private String m_lang = null ; public void setLang ( String v ) { m_lang = v ; } public String getLang ( ) { return m_lang ; } private String m_src = null ; public void setSrc ( String v ) { m_src = v ; } public String getSrc ( ) { return m_src ; } public int getXSLToken ( ) { return Constants . ELEMNAME_EXTENSIONSCRIPT ; } } 	1	['6', '3', '0', '2', '7', '3', '1', '1', '6', '0.6', '33', '1', '0', '0.975124378', '0.666666667', '1', '2', '4.166666667', '1', '0.8333', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; public class WalkingIterator extends LocPathIterator implements ExpressionOwner { WalkingIterator ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , shouldLoadWalkers ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; if ( shouldLoadWalkers ) { m_firstWalker = WalkerFactory . loadWalkers ( this , compiler , firstStepPos , 0 ) ; m_lastUsedWalker = m_firstWalker ; } } public WalkingIterator ( PrefixResolver nscontext ) { super ( nscontext ) ; } public int getAnalysisBits ( ) { int bits = 0 ; if ( null != m_firstWalker ) { AxesWalker walker = m_firstWalker ; while ( null != walker ) { int bit = walker . getAnalysisBits ( ) ; bits |= bit ; walker = walker . getNextWalker ( ) ; } } return bits ; } public Object clone ( ) throws CloneNotSupportedException { WalkingIterator clone = ( WalkingIterator ) super . clone ( ) ; if ( null != m_firstWalker ) { clone . m_firstWalker = m_firstWalker . cloneDeep ( clone , null ) ; } return clone ; } public void reset ( ) { super . reset ( ) ; if ( null != m_firstWalker ) { m_lastUsedWalker = m_firstWalker ; m_firstWalker . setRoot ( m_context ) ; } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; if ( null != m_firstWalker ) { m_firstWalker . setRoot ( context ) ; m_lastUsedWalker = m_firstWalker ; } } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( - 1 == m_stackFrame ) { return returnNextNode ( m_firstWalker . nextNode ( ) ) ; } else { VariableStack vars = m_execContext . getVarStack ( ) ; int savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; int n = returnNextNode ( m_firstWalker . nextNode ( ) ) ; vars . setStackFrame ( savedStart ) ; return n ; } } public final AxesWalker getFirstWalker ( ) { return m_firstWalker ; } public final void setFirstWalker ( AxesWalker walker ) { m_firstWalker = walker ; } public final void setLastUsedWalker ( AxesWalker walker ) { m_lastUsedWalker = walker ; } public final AxesWalker getLastUsedWalker ( ) { return m_lastUsedWalker ; } public void detach ( ) { if ( m_allowDetach ) { AxesWalker walker = m_firstWalker ; while ( null != walker ) { walker . detach ( ) ; walker = walker . getNextWalker ( ) ; } m_lastUsedWalker = null ; super . detach ( ) ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_predicateIndex = - 1 ; AxesWalker walker = m_firstWalker ; while ( null != walker ) { walker . fixupVariables ( vars , globalsSize ) ; walker = walker . getNextWalker ( ) ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitLocationPath ( owner , this ) ) { if ( null != m_firstWalker ) { m_firstWalker . callVisitors ( this , visitor ) ; } } } protected AxesWalker m_lastUsedWalker ; protected AxesWalker m_firstWalker ; public Expression getExpression ( ) { return m_firstWalker ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_firstWalker = ( AxesWalker ) exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; AxesWalker walker1 = m_firstWalker ; AxesWalker walker2 = ( ( WalkingIterator ) expr ) . m_firstWalker ; while ( ( null != walker1 ) && ( null != walker2 ) ) { if ( ! walker1 . deepEquals ( walker2 ) ) return false ; walker1 = walker1 . getNextWalker ( ) ; walker2 = walker2 . getNextWalker ( ) ; } if ( ( null != walker1 ) || ( null != walker2 ) ) return false ; return true ; } } 	1	['17', '5', '1', '17', '41', '0', '8', '11', '16', '0.4375', '281', '1', '2', '0.892857143', '0.165775401', '2', '9', '15.41176471', '7', '1.8824', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; public final class Template extends TopLevelElement { private QName _name ; private QName _mode ; private Pattern _pattern ; private double _priority ; private int _position ; private boolean _disabled = false ; private boolean _compiled = false ; private boolean _hasParams = false ; private boolean _simplified = false ; public boolean hasParams ( ) { return _hasParams ; } public void hasParams ( boolean hasParams ) { _hasParams = hasParams ; } public boolean isSimplified ( ) { return ( _simplified ) ; } public void setSimplified ( ) { _simplified = true ; } public void disable ( ) { _disabled = true ; } public boolean disabled ( ) { return ( _disabled ) ; } public double getPriority ( ) { return _priority ; } public int getPosition ( ) { return ( _position ) ; } public boolean isNamed ( ) { return _name != null ; } public Pattern getPattern ( ) { return _pattern ; } public QName getName ( ) { return _name ; } public void setName ( QName qname ) { if ( _name == null ) _name = qname ; } public QName getModeName ( ) { return _mode ; } public int compareTo ( Object template ) { Template other = ( Template ) template ; if ( _priority > other . _priority ) return 1 ; else if ( _priority < other . _priority ) return - 1 ; else if ( _position > other . _position ) return 1 ; else if ( _position < other . _position ) return - 1 ; else return 0 ; } public void display ( int indent ) { Util . println ( '\n' ) ; indent ( indent ) ; if ( _name != null ) { indent ( indent ) ; Util . println ( "name = " + _name ) ; } else if ( _pattern != null ) { indent ( indent ) ; Util . println ( "match = " + _pattern . toString ( ) ) ; } if ( _mode != null ) { indent ( indent ) ; Util . println ( "mode = " + _mode ) ; } displayContents ( indent + IndentIncrement ) ; } private boolean resolveNamedTemplates ( Template other , Parser parser ) { if ( other == null ) return true ; SymbolTable stable = parser . getSymbolTable ( ) ; final int us = this . getImportPrecedence ( ) ; final int them = other . getImportPrecedence ( ) ; if ( us > them ) { other . disable ( ) ; return true ; } else if ( us < them ) { stable . addTemplate ( other ) ; this . disable ( ) ; return true ; } else { return false ; } } private Stylesheet _stylesheet = null ; public Stylesheet getStylesheet ( ) { return _stylesheet ; } public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; final String mode = getAttribute ( "mode" ) ; final String match = getAttribute ( "match" ) ; final String priority = getAttribute ( "priority" ) ; _stylesheet = super . getStylesheet ( ) ; if ( name . length ( ) > 0 ) { _name = parser . getQNameIgnoreDefaultNs ( name ) ; } if ( mode . length ( ) > 0 ) { _mode = parser . getQNameIgnoreDefaultNs ( mode ) ; } if ( match . length ( ) > 0 ) { _pattern = parser . parsePattern ( this , "match" , null ) ; } if ( priority . length ( ) > 0 ) { _priority = Double . parseDouble ( priority ) ; } else { if ( _pattern != null ) _priority = _pattern . getPriority ( ) ; else _priority = Double . NaN ; } _position = parser . getTemplateIndex ( ) ; if ( _name != null ) { Template other = parser . getSymbolTable ( ) . addTemplate ( this ) ; if ( ! resolveNamedTemplates ( other , parser ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TEMPLATE_REDEF_ERR , _name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } } parser . setTemplate ( this ) ; parseChildren ( parser ) ; parser . setTemplate ( null ) ; } public void parseSimplified ( Stylesheet stylesheet , Parser parser ) { _stylesheet = stylesheet ; setParent ( stylesheet ) ; _name = null ; _mode = null ; _priority = Double . NaN ; _pattern = parser . parsePattern ( this , "/" ) ; final Vector contents = _stylesheet . getContents ( ) ; final SyntaxTreeNode root = ( SyntaxTreeNode ) contents . elementAt ( 0 ) ; if ( root instanceof LiteralElement ) { addElement ( root ) ; root . setParent ( this ) ; contents . set ( 0 , this ) ; parser . setTemplate ( this ) ; root . parseContents ( parser ) ; parser . setTemplate ( null ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _pattern != null ) { _pattern . typeCheck ( stable ) ; } return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _disabled ) return ; String className = classGen . getClassName ( ) ; if ( _compiled && isNamed ( ) ) { String methodName = Util . escape ( _name . toString ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( className , methodName , "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + "I)V" ) ) ) ; return ; } if ( _compiled ) return ; _compiled = true ; final InstructionHandle start = il . getEnd ( ) ; translateContents ( classGen , methodGen ) ; final InstructionHandle end = il . getEnd ( ) ; il . setPositions ( true ) ; } } 	1	['22', '3', '0', '25', '73', '121', '10', '19', '21', '0.852380952', '485', '1', '4', '0.740740741', '0.140495868', '2', '7', '20.59090909', '8', '2.0455', '3']
package org . apache . xml . utils . res ; public class XResources_sv extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "sv" } , { "help_language" , "sv" } , { "language" , "sv" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xalan . trace ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; public class SelectionEvent implements java . util . EventListener { public final ElemTemplateElement m_styleNode ; public final TransformerImpl m_processor ; public final Node m_sourceNode ; public final String m_attributeName ; public final XPath m_xpath ; public final XObject m_selection ; public SelectionEvent ( TransformerImpl processor , Node sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) { this . m_processor = processor ; this . m_sourceNode = sourceNode ; this . m_styleNode = styleNode ; this . m_attributeName = attributeName ; this . m_xpath = xpath ; this . m_selection = selection ; } } 	1	['1', '1', '1', '8', '2', '0', '4', '4', '1', '2', '28', '0', '4', '0', '1', '0', '0', '21', '0', '0', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncNamespace extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = getArg0AsNode ( xctxt ) ; String s ; if ( context != DTM . NULL ) { DTM dtm = xctxt . getDTM ( context ) ; int t = dtm . getNodeType ( context ) ; if ( t == DTM . ELEMENT_NODE ) { s = dtm . getNamespaceURI ( context ) ; } else if ( t == DTM . ATTRIBUTE_NODE ) { s = dtm . getNodeName ( context ) ; if ( s . startsWith ( "xmlns:" ) || s . equals ( "xmlns" ) ) return XString . EMPTYSTRING ; s = dtm . getNamespaceURI ( context ) ; } else return XString . EMPTYSTRING ; } else return XString . EMPTYSTRING ; return ( ( null == s ) ? XString . EMPTYSTRING : new XString ( s ) ) ; } } 	1	['2', '5', '0', '5', '11', '1', '0', '5', '2', '2', '65', '0', '0', '0.982142857', '0.75', '3', '8', '31.5', '1', '0.5', '1']
package org . apache . xpath . axes ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . patterns . ContextMatchStepPattern ; import org . apache . xpath . patterns . FunctionPattern ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . res . XPATHErrorResources ; public class WalkerFactory { static AxesWalker loadOneWalker ( WalkingIterator lpi , Compiler compiler , int stepOpCodePos ) throws javax . xml . transform . TransformerException { AxesWalker firstWalker = null ; int stepType = compiler . getOp ( stepOpCodePos ) ; if ( stepType != OpCodes . ENDOP ) { firstWalker = createDefaultWalker ( compiler , stepType , lpi , 0 ) ; firstWalker . init ( compiler , stepOpCodePos , stepType ) ; } return firstWalker ; } static AxesWalker loadWalkers ( WalkingIterator lpi , Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; AxesWalker firstWalker = null ; AxesWalker walker , prevWalker = null ; int analysis = analyze ( compiler , stepOpCodePos , stepIndex ) ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { walker = createDefaultWalker ( compiler , stepOpCodePos , lpi , analysis ) ; walker . init ( compiler , stepOpCodePos , stepType ) ; walker . exprSetParent ( lpi ) ; if ( null == firstWalker ) { firstWalker = walker ; } else { prevWalker . setNextWalker ( walker ) ; walker . setPrevWalker ( prevWalker ) ; } prevWalker = walker ; stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } return firstWalker ; } public static boolean isSet ( int analysis , int bits ) { return ( 0 != ( analysis & bits ) ) ; } public static void diagnoseIterator ( String name , int analysis , Compiler compiler ) { System . out . println ( compiler . toString ( ) + ", " + name + ", " + Integer . toBinaryString ( analysis ) + ", " + getAnalysisString ( analysis ) ) ; } public static DTMIterator newDTMIterator ( Compiler compiler , int opPos , boolean isTopLevel ) throws javax . xml . transform . TransformerException { int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int analysis = analyze ( compiler , firstStepPos , 0 ) ; boolean isOneStep = isOneStep ( analysis ) ; DTMIterator iter ; if ( isOneStep && walksSelfOnly ( analysis ) && isWild ( analysis ) && ! hasPredicate ( analysis ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "SelfIteratorNoPredicate" , analysis , compiler ) ; iter = new SelfIteratorNoPredicate ( compiler , opPos , analysis ) ; } else if ( walksChildrenOnly ( analysis ) && isOneStep ) { if ( isWild ( analysis ) && ! hasPredicate ( analysis ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "ChildIterator" , analysis , compiler ) ; iter = new ChildIterator ( compiler , opPos , analysis ) ; } else { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "ChildTestIterator" , analysis , compiler ) ; iter = new ChildTestIterator ( compiler , opPos , analysis ) ; } } else if ( isOneStep && walksAttributes ( analysis ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "AttributeIterator" , analysis , compiler ) ; iter = new AttributeIterator ( compiler , opPos , analysis ) ; } else if ( isOneStep && ! walksFilteredList ( analysis ) ) { if ( ! walksNamespaces ( analysis ) && ( walksInDocOrder ( analysis ) || isSet ( analysis , BIT_PARENT ) ) ) { if ( false || DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "OneStepIteratorForward" , analysis , compiler ) ; iter = new OneStepIteratorForward ( compiler , opPos , analysis ) ; } else { if ( false || DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "OneStepIterator" , analysis , compiler ) ; iter = new OneStepIterator ( compiler , opPos , analysis ) ; } } else if ( isOptimizableForDescendantIterator ( compiler , firstStepPos , 0 ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "DescendantIterator" , analysis , compiler ) ; iter = new DescendantIterator ( compiler , opPos , analysis ) ; } else { if ( isNaturalDocOrder ( compiler , firstStepPos , 0 , analysis ) ) { if ( false || DEBUG_ITERATOR_CREATION ) { diagnoseIterator ( "WalkingIterator" , analysis , compiler ) ; } iter = new WalkingIterator ( compiler , opPos , analysis , true ) ; } else { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "WalkingIteratorSorted" , analysis , compiler ) ; iter = new WalkingIteratorSorted ( compiler , opPos , analysis , true ) ; } } if ( iter instanceof LocPathIterator ) ( ( LocPathIterator ) iter ) . setIsTopLevel ( isTopLevel ) ; return iter ; } public static int getAxisFromStep ( Compiler compiler , int stepOpCodePos ) throws javax . xml . transform . TransformerException { int stepType = compiler . getOp ( stepOpCodePos ) ; switch ( stepType ) { case OpCodes . FROM_FOLLOWING : return Axis . FOLLOWING ; case OpCodes . FROM_FOLLOWING_SIBLINGS : return Axis . FOLLOWINGSIBLING ; case OpCodes . FROM_PRECEDING : return Axis . PRECEDING ; case OpCodes . FROM_PRECEDING_SIBLINGS : return Axis . PRECEDINGSIBLING ; case OpCodes . FROM_PARENT : return Axis . PARENT ; case OpCodes . FROM_NAMESPACE : return Axis . NAMESPACE ; case OpCodes . FROM_ANCESTORS : return Axis . ANCESTOR ; case OpCodes . FROM_ANCESTORS_OR_SELF : return Axis . ANCESTORORSELF ; case OpCodes . FROM_ATTRIBUTES : return Axis . ATTRIBUTE ; case OpCodes . FROM_ROOT : return Axis . ROOT ; case OpCodes . FROM_CHILDREN : return Axis . CHILD ; case OpCodes . FROM_DESCENDANTS_OR_SELF : return Axis . DESCENDANTORSELF ; case OpCodes . FROM_DESCENDANTS : return Axis . DESCENDANT ; case OpCodes . FROM_SELF : return Axis . SELF ; case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . OP_VARIABLE : return Axis . FILTEREDLIST ; } throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } static public int getAnalysisBitFromAxes ( int axis ) { switch ( axis ) { case Axis . ANCESTOR : return BIT_ANCESTOR ; case Axis . ANCESTORORSELF : return BIT_ANCESTOR_OR_SELF ; case Axis . ATTRIBUTE : return BIT_ATTRIBUTE ; case Axis . CHILD : return BIT_CHILD ; case Axis . DESCENDANT : return BIT_DESCENDANT ; case Axis . DESCENDANTORSELF : return BIT_DESCENDANT_OR_SELF ; case Axis . FOLLOWING : return BIT_FOLLOWING ; case Axis . FOLLOWINGSIBLING : return BIT_FOLLOWING_SIBLING ; case Axis . NAMESPACE : case Axis . NAMESPACEDECLS : return BIT_NAMESPACE ; case Axis . PARENT : return BIT_PARENT ; case Axis . PRECEDING : return BIT_PRECEDING ; case Axis . PRECEDINGSIBLING : return BIT_PRECEDING_SIBLING ; case Axis . SELF : return BIT_SELF ; case Axis . ALLFROMNODE : return BIT_DESCENDANT_OR_SELF ; case Axis . DESCENDANTSFROMROOT : case Axis . ALL : case Axis . DESCENDANTSORSELFFROMROOT : return BIT_ANY_DESCENDANT_FROM_ROOT ; case Axis . ROOT : return BIT_ROOT ; case Axis . FILTEREDLIST : return BIT_FILTER ; default : return BIT_FILTER ; } } static boolean functionProximateOrContainsProximate ( Compiler compiler , int opPos ) { int endFunc = opPos + compiler . getOp ( opPos + 1 ) - 1 ; opPos = compiler . getFirstChildPos ( opPos ) ; int funcID = compiler . getOp ( opPos ) ; switch ( funcID ) { case FunctionTable . FUNC_LAST : case FunctionTable . FUNC_POSITION : return true ; default : opPos ++ ; int i = 0 ; for ( int p = opPos ; p < endFunc ; p = compiler . getNextOpPos ( p ) , i ++ ) { int innerExprOpPos = p + 2 ; int argOp = compiler . getOp ( innerExprOpPos ) ; boolean prox = isProximateInnerExpr ( compiler , innerExprOpPos ) ; if ( prox ) return true ; } } return false ; } static boolean isProximateInnerExpr ( Compiler compiler , int opPos ) { int op = compiler . getOp ( opPos ) ; int innerExprOpPos = opPos + 2 ; switch ( op ) { case OpCodes . OP_ARGUMENT : if ( isProximateInnerExpr ( compiler , innerExprOpPos ) ) return true ; break ; case OpCodes . OP_VARIABLE : case OpCodes . OP_NUMBERLIT : case OpCodes . OP_LITERAL : case OpCodes . OP_LOCATIONPATH : break ; case OpCodes . OP_FUNCTION : boolean isProx = functionProximateOrContainsProximate ( compiler , opPos ) ; if ( isProx ) return true ; break ; case OpCodes . OP_GT : case OpCodes . OP_GTE : case OpCodes . OP_LT : case OpCodes . OP_LTE : case OpCodes . OP_EQUALS : int leftPos = compiler . getFirstChildPos ( op ) ; int rightPos = compiler . getNextOpPos ( leftPos ) ; isProx = isProximateInnerExpr ( compiler , leftPos ) ; if ( isProx ) return true ; isProx = isProximateInnerExpr ( compiler , rightPos ) ; if ( isProx ) return true ; break ; default : return true ; } return false ; } public static boolean mightBeProximate ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { boolean mightBeProximate = false ; int argLen ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : argLen = compiler . getArgLength ( opPos ) ; break ; default : argLen = compiler . getArgLengthOfStep ( opPos ) ; } int predPos = compiler . getFirstPredicateOpPos ( opPos ) ; int count = 0 ; while ( OpCodes . OP_PREDICATE == compiler . getOp ( predPos ) ) { count ++ ; int innerExprOpPos = predPos + 2 ; int predOp = compiler . getOp ( innerExprOpPos ) ; switch ( predOp ) { case OpCodes . OP_VARIABLE : return true ; case OpCodes . OP_LOCATIONPATH : break ; case OpCodes . OP_NUMBER : case OpCodes . OP_NUMBERLIT : return true ; case OpCodes . OP_FUNCTION : boolean isProx = functionProximateOrContainsProximate ( compiler , innerExprOpPos ) ; if ( isProx ) return true ; break ; case OpCodes . OP_GT : case OpCodes . OP_GTE : case OpCodes . OP_LT : case OpCodes . OP_LTE : case OpCodes . OP_EQUALS : int leftPos = compiler . getFirstChildPos ( innerExprOpPos ) ; int rightPos = compiler . getNextOpPos ( leftPos ) ; isProx = isProximateInnerExpr ( compiler , leftPos ) ; if ( isProx ) return true ; isProx = isProximateInnerExpr ( compiler , rightPos ) ; if ( isProx ) return true ; break ; default : return true ; } predPos = compiler . getNextOpPos ( predPos ) ; } return mightBeProximate ; } private static boolean isOptimizableForDescendantIterator ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int stepCount = 0 ; boolean foundDorDS = false ; boolean foundSelf = false ; boolean foundDS = false ; int nodeTestType = OpCodes . NODETYPE_NODE ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { if ( nodeTestType != OpCodes . NODETYPE_NODE && nodeTestType != OpCodes . NODETYPE_ROOT ) return false ; stepCount ++ ; if ( stepCount > 3 ) return false ; boolean mightBeProximate = mightBeProximate ( compiler , stepOpCodePos , stepType ) ; if ( mightBeProximate ) return false ; switch ( stepType ) { case OpCodes . FROM_FOLLOWING : case OpCodes . FROM_FOLLOWING_SIBLINGS : case OpCodes . FROM_PRECEDING : case OpCodes . FROM_PRECEDING_SIBLINGS : case OpCodes . FROM_PARENT : case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . FROM_NAMESPACE : case OpCodes . FROM_ANCESTORS : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : return false ; case OpCodes . FROM_ROOT : if ( 1 != stepCount ) return false ; break ; case OpCodes . FROM_CHILDREN : if ( ! foundDS && ! ( foundDorDS && foundSelf ) ) return false ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : foundDS = true ; case OpCodes . FROM_DESCENDANTS : if ( 3 == stepCount ) return false ; foundDorDS = true ; break ; case OpCodes . FROM_SELF : if ( 1 != stepCount ) return false ; foundSelf = true ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } nodeTestType = compiler . getStepTestType ( stepOpCodePos ) ; int nextStepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( nextStepOpCodePos < 0 ) break ; if ( OpCodes . ENDOP != compiler . getOp ( nextStepOpCodePos ) ) { if ( compiler . countPredicates ( stepOpCodePos ) > 0 ) { return false ; } } stepOpCodePos = nextStepOpCodePos ; } return true ; } private static int analyze ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int stepCount = 0 ; int analysisResult = 0x00000000 ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { stepCount ++ ; boolean predAnalysis = analyzePredicate ( compiler , stepOpCodePos , stepType ) ; if ( predAnalysis ) analysisResult |= BIT_PREDICATE ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : analysisResult |= BIT_FILTER ; break ; case OpCodes . FROM_ROOT : analysisResult |= BIT_ROOT ; break ; case OpCodes . FROM_ANCESTORS : analysisResult |= BIT_ANCESTOR ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : analysisResult |= BIT_ANCESTOR_OR_SELF ; break ; case OpCodes . FROM_ATTRIBUTES : analysisResult |= BIT_ATTRIBUTE ; break ; case OpCodes . FROM_NAMESPACE : analysisResult |= BIT_NAMESPACE ; break ; case OpCodes . FROM_CHILDREN : analysisResult |= BIT_CHILD ; break ; case OpCodes . FROM_DESCENDANTS : analysisResult |= BIT_DESCENDANT ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : if ( 2 == stepCount && BIT_ROOT == analysisResult ) { analysisResult |= BIT_ANY_DESCENDANT_FROM_ROOT ; } analysisResult |= BIT_DESCENDANT_OR_SELF ; break ; case OpCodes . FROM_FOLLOWING : analysisResult |= BIT_FOLLOWING ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : analysisResult |= BIT_FOLLOWING_SIBLING ; break ; case OpCodes . FROM_PRECEDING : analysisResult |= BIT_PRECEDING ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : analysisResult |= BIT_PRECEDING_SIBLING ; break ; case OpCodes . FROM_PARENT : analysisResult |= BIT_PARENT ; break ; case OpCodes . FROM_SELF : analysisResult |= BIT_SELF ; break ; case OpCodes . MATCH_ATTRIBUTE : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ATTRIBUTE ) ; break ; case OpCodes . MATCH_ANY_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ANCESTOR ) ; break ; case OpCodes . MATCH_IMMEDIATE_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_PARENT ) ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( OpCodes . NODETYPE_NODE == compiler . getOp ( stepOpCodePos + 3 ) ) { analysisResult |= BIT_NODETEST_ANY ; } stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } analysisResult |= ( stepCount & BITS_COUNT ) ; return analysisResult ; } public static boolean isDownwardAxisOfMany ( int axis ) { return ( ( Axis . DESCENDANTORSELF == axis ) || ( Axis . DESCENDANT == axis ) || ( Axis . FOLLOWING == axis ) || ( Axis . PRECEDING == axis ) ) ; } static StepPattern loadSteps ( MatchPatternIterator mpi , Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { if ( DEBUG_PATTERN_CREATION ) { System . out . println ( "================" ) ; System . out . println ( "loadSteps for: " + compiler . getPatternString ( ) ) ; } int stepType ; StepPattern step = null ; StepPattern firstStep = null , prevStep = null ; int analysis = analyze ( compiler , stepOpCodePos , stepIndex ) ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { step = createDefaultStepPattern ( compiler , stepOpCodePos , mpi , analysis , firstStep , prevStep ) ; if ( null == firstStep ) { firstStep = step ; } else { step . setRelativePathPattern ( prevStep ) ; } prevStep = step ; stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } int axis = Axis . SELF ; int paxis = Axis . SELF ; StepPattern tail = step ; for ( StepPattern pat = step ; null != pat ; pat = pat . getRelativePathPattern ( ) ) { int nextAxis = pat . getAxis ( ) ; pat . setAxis ( axis ) ; int whatToShow = pat . getWhatToShow ( ) ; if ( whatToShow == DTMFilter . SHOW_ATTRIBUTE || whatToShow == DTMFilter . SHOW_NAMESPACE ) { int newAxis = ( whatToShow == DTMFilter . SHOW_ATTRIBUTE ) ? Axis . ATTRIBUTE : Axis . NAMESPACE ; if ( isDownwardAxisOfMany ( axis ) ) { StepPattern attrPat = new StepPattern ( whatToShow , pat . getNamespace ( ) , pat . getLocalName ( ) , newAxis , 0 ) ; XNumber score = pat . getStaticScore ( ) ; pat . setNamespace ( null ) ; pat . setLocalName ( NodeTest . WILD ) ; attrPat . setPredicates ( pat . getPredicates ( ) ) ; pat . setPredicates ( null ) ; pat . setWhatToShow ( DTMFilter . SHOW_ELEMENT ) ; StepPattern rel = pat . getRelativePathPattern ( ) ; pat . setRelativePathPattern ( attrPat ) ; attrPat . setRelativePathPattern ( rel ) ; attrPat . setStaticScore ( score ) ; if ( Axis . PRECEDING == pat . getAxis ( ) ) pat . setAxis ( Axis . PRECEDINGANDANCESTOR ) ; else if ( Axis . DESCENDANT == pat . getAxis ( ) ) pat . setAxis ( Axis . DESCENDANTORSELF ) ; pat = attrPat ; } else if ( Axis . CHILD == pat . getAxis ( ) ) { pat . setAxis ( Axis . ATTRIBUTE ) ; } } axis = nextAxis ; tail = pat ; } if ( axis < Axis . ALL ) { StepPattern selfPattern = new ContextMatchStepPattern ( axis , paxis ) ; XNumber score = tail . getStaticScore ( ) ; tail . setRelativePathPattern ( selfPattern ) ; tail . setStaticScore ( score ) ; selfPattern . setStaticScore ( score ) ; } if ( DEBUG_PATTERN_CREATION ) { System . out . println ( "Done loading steps: " + step . toString ( ) ) ; System . out . println ( "" ) ; } return step ; } private static StepPattern createDefaultStepPattern ( Compiler compiler , int opPos , MatchPatternIterator mpi , int analysis , StepPattern tail , StepPattern head ) throws javax . xml . transform . TransformerException { int stepType = compiler . getOp ( opPos ) ; boolean simpleInit = false ; int totalNumberWalkers = ( analysis & BITS_COUNT ) ; boolean prevIsOneStepDown = true ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int whatToShow = compiler . getWhatToShow ( opPos ) ; StepPattern ai = null ; int axis , predicateAxis ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : prevIsOneStepDown = false ; Expression expr ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : expr = compiler . compile ( opPos ) ; break ; default : expr = compiler . compile ( opPos + 2 ) ; } axis = Axis . FILTEREDLIST ; predicateAxis = Axis . FILTEREDLIST ; ai = new FunctionPattern ( expr , axis , predicateAxis ) ; simpleInit = true ; break ; case OpCodes . FROM_ROOT : whatToShow = DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ; axis = Axis . ROOT ; predicateAxis = Axis . ROOT ; ai = new StepPattern ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT , axis , predicateAxis ) ; break ; case OpCodes . FROM_ATTRIBUTES : whatToShow = DTMFilter . SHOW_ATTRIBUTE ; axis = Axis . PARENT ; predicateAxis = Axis . ATTRIBUTE ; break ; case OpCodes . FROM_NAMESPACE : whatToShow = DTMFilter . SHOW_NAMESPACE ; axis = Axis . PARENT ; predicateAxis = Axis . NAMESPACE ; break ; case OpCodes . FROM_ANCESTORS : axis = Axis . DESCENDANT ; predicateAxis = Axis . ANCESTOR ; break ; case OpCodes . FROM_CHILDREN : axis = Axis . PARENT ; predicateAxis = Axis . CHILD ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : axis = Axis . DESCENDANTORSELF ; predicateAxis = Axis . ANCESTORORSELF ; break ; case OpCodes . FROM_SELF : axis = Axis . SELF ; predicateAxis = Axis . SELF ; break ; case OpCodes . FROM_PARENT : axis = Axis . CHILD ; predicateAxis = Axis . PARENT ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : axis = Axis . FOLLOWINGSIBLING ; predicateAxis = Axis . PRECEDINGSIBLING ; break ; case OpCodes . FROM_PRECEDING : axis = Axis . FOLLOWING ; predicateAxis = Axis . PRECEDING ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : axis = Axis . PRECEDINGSIBLING ; predicateAxis = Axis . FOLLOWINGSIBLING ; break ; case OpCodes . FROM_FOLLOWING : axis = Axis . PRECEDING ; predicateAxis = Axis . FOLLOWING ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : axis = Axis . ANCESTORORSELF ; predicateAxis = Axis . DESCENDANTORSELF ; break ; case OpCodes . FROM_DESCENDANTS : axis = Axis . ANCESTOR ; predicateAxis = Axis . DESCENDANT ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( null == ai ) { whatToShow = compiler . getWhatToShow ( opPos ) ; ai = new StepPattern ( whatToShow , compiler . getStepNS ( opPos ) , compiler . getStepLocalName ( opPos ) , axis , predicateAxis ) ; } if ( false || DEBUG_PATTERN_CREATION ) { System . out . print ( "new step: " + ai ) ; System . out . print ( ", axis: " + Axis . names [ ai . getAxis ( ) ] ) ; System . out . print ( ", predAxis: " + Axis . names [ ai . getAxis ( ) ] ) ; System . out . print ( ", what: " ) ; System . out . print ( "    " ) ; ai . debugWhatToShow ( ai . getWhatToShow ( ) ) ; } int argLen = compiler . getFirstPredicateOpPos ( opPos ) ; ai . setPredicates ( compiler . getCompiledPredicates ( argLen ) ) ; return ai ; } static boolean analyzePredicate ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { int argLen ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : argLen = compiler . getArgLength ( opPos ) ; break ; default : argLen = compiler . getArgLengthOfStep ( opPos ) ; } int pos = compiler . getFirstPredicateOpPos ( opPos ) ; int nPredicates = compiler . countPredicates ( pos ) ; return ( nPredicates > 0 ) ? true : false ; } private static AxesWalker createDefaultWalker ( Compiler compiler , int opPos , WalkingIterator lpi , int analysis ) { AxesWalker ai = null ; int stepType = compiler . getOp ( opPos ) ; boolean simpleInit = false ; int totalNumberWalkers = ( analysis & BITS_COUNT ) ; boolean prevIsOneStepDown = true ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : prevIsOneStepDown = false ; if ( DEBUG_WALKER_CREATION ) System . out . println ( "new walker:  FilterExprWalker: " + analysis + ", " + compiler . toString ( ) ) ; ai = new FilterExprWalker ( lpi ) ; simpleInit = true ; break ; case OpCodes . FROM_ROOT : ai = new AxesWalker ( lpi , Axis . ROOT ) ; break ; case OpCodes . FROM_ANCESTORS : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . ANCESTOR ) ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . ANCESTORORSELF ) ; break ; case OpCodes . FROM_ATTRIBUTES : ai = new AxesWalker ( lpi , Axis . ATTRIBUTE ) ; break ; case OpCodes . FROM_NAMESPACE : ai = new AxesWalker ( lpi , Axis . NAMESPACE ) ; break ; case OpCodes . FROM_CHILDREN : ai = new AxesWalker ( lpi , Axis . CHILD ) ; break ; case OpCodes . FROM_DESCENDANTS : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . DESCENDANT ) ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . DESCENDANTORSELF ) ; break ; case OpCodes . FROM_FOLLOWING : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . FOLLOWING ) ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . FOLLOWINGSIBLING ) ; break ; case OpCodes . FROM_PRECEDING : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . PRECEDING ) ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . PRECEDINGSIBLING ) ; break ; case OpCodes . FROM_PARENT : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . PARENT ) ; break ; case OpCodes . FROM_SELF : ai = new AxesWalker ( lpi , Axis . SELF ) ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( simpleInit ) { ai . initNodeTest ( DTMFilter . SHOW_ALL ) ; } else { int whatToShow = compiler . getWhatToShow ( opPos ) ; if ( ( 0 == ( whatToShow & ( DTMFilter . SHOW_ATTRIBUTE | DTMFilter . SHOW_NAMESPACE | DTMFilter . SHOW_ELEMENT | DTMFilter . SHOW_PROCESSING_INSTRUCTION ) ) ) || ( whatToShow == DTMFilter . SHOW_ALL ) ) ai . initNodeTest ( whatToShow ) ; else { ai . initNodeTest ( whatToShow , compiler . getStepNS ( opPos ) , compiler . getStepLocalName ( opPos ) ) ; } } return ai ; } public static String getAnalysisString ( int analysis ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "count: " + getStepCount ( analysis ) + " " ) ; if ( ( analysis & BIT_NODETEST_ANY ) != 0 ) { buf . append ( "NTANY|" ) ; } if ( ( analysis & BIT_PREDICATE ) != 0 ) { buf . append ( "PRED|" ) ; } if ( ( analysis & BIT_ANCESTOR ) != 0 ) { buf . append ( "ANC|" ) ; } if ( ( analysis & BIT_ANCESTOR_OR_SELF ) != 0 ) { buf . append ( "ANCOS|" ) ; } if ( ( analysis & BIT_ATTRIBUTE ) != 0 ) { buf . append ( "ATTR|" ) ; } if ( ( analysis & BIT_CHILD ) != 0 ) { buf . append ( "CH|" ) ; } if ( ( analysis & BIT_DESCENDANT ) != 0 ) { buf . append ( "DESC|" ) ; } if ( ( analysis & BIT_DESCENDANT_OR_SELF ) != 0 ) { buf . append ( "DESCOS|" ) ; } if ( ( analysis & BIT_FOLLOWING ) != 0 ) { buf . append ( "FOL|" ) ; } if ( ( analysis & BIT_FOLLOWING_SIBLING ) != 0 ) { buf . append ( "FOLS|" ) ; } if ( ( analysis & BIT_NAMESPACE ) != 0 ) { buf . append ( "NS|" ) ; } if ( ( analysis & BIT_PARENT ) != 0 ) { buf . append ( "P|" ) ; } if ( ( analysis & BIT_PRECEDING ) != 0 ) { buf . append ( "PREC|" ) ; } if ( ( analysis & BIT_PRECEDING_SIBLING ) != 0 ) { buf . append ( "PRECS|" ) ; } if ( ( analysis & BIT_SELF ) != 0 ) { buf . append ( ".|" ) ; } if ( ( analysis & BIT_FILTER ) != 0 ) { buf . append ( "FLT|" ) ; } if ( ( analysis & BIT_ROOT ) != 0 ) { buf . append ( "R|" ) ; } return buf . toString ( ) ; } static final boolean DEBUG_PATTERN_CREATION = false ; static final boolean DEBUG_WALKER_CREATION = false ; static final boolean DEBUG_ITERATOR_CREATION = false ; public static boolean hasPredicate ( int analysis ) { return ( 0 != ( analysis & BIT_PREDICATE ) ) ; } public static boolean isWild ( int analysis ) { return ( 0 != ( analysis & BIT_NODETEST_ANY ) ) ; } public static boolean walksAncestors ( int analysis ) { return isSet ( analysis , BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF ) ; } public static boolean walksAttributes ( int analysis ) { return ( 0 != ( analysis & BIT_ATTRIBUTE ) ) ; } public static boolean walksNamespaces ( int analysis ) { return ( 0 != ( analysis & BIT_NAMESPACE ) ) ; } public static boolean walksChildren ( int analysis ) { return ( 0 != ( analysis & BIT_CHILD ) ) ; } public static boolean walksDescendants ( int analysis ) { return isSet ( analysis , BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF ) ; } public static boolean walksSubtree ( int analysis ) { return isSet ( analysis , BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF | BIT_CHILD ) ; } public static boolean walksSubtreeOnlyMaybeAbsolute ( int analysis ) { return walksSubtree ( analysis ) && ! walksExtraNodes ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) ; } public static boolean walksSubtreeOnly ( int analysis ) { return walksSubtreeOnlyMaybeAbsolute ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksFilteredList ( int analysis ) { return isSet ( analysis , BIT_FILTER ) ; } public static boolean walksSubtreeOnlyFromRootOrContext ( int analysis ) { return walksSubtree ( analysis ) && ! walksExtraNodes ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isSet ( analysis , BIT_FILTER ) ; } public static boolean walksInDocOrder ( int analysis ) { return ( walksSubtreeOnlyMaybeAbsolute ( analysis ) || walksExtraNodesOnly ( analysis ) || walksFollowingOnlyMaybeAbsolute ( analysis ) ) && ! isSet ( analysis , BIT_FILTER ) ; } public static boolean walksFollowingOnlyMaybeAbsolute ( int analysis ) { return isSet ( analysis , BIT_SELF | BIT_FOLLOWING_SIBLING | BIT_FOLLOWING ) && ! walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) ; } public static boolean walksUp ( int analysis ) { return isSet ( analysis , BIT_PARENT | BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF ) ; } public static boolean walksSideways ( int analysis ) { return isSet ( analysis , BIT_FOLLOWING | BIT_FOLLOWING_SIBLING | BIT_PRECEDING | BIT_PRECEDING_SIBLING ) ; } public static boolean walksExtraNodes ( int analysis ) { return isSet ( analysis , BIT_NAMESPACE | BIT_ATTRIBUTE ) ; } public static boolean walksExtraNodesOnly ( int analysis ) { return walksExtraNodes ( analysis ) && ! isSet ( analysis , BIT_SELF ) && ! walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean isAbsolute ( int analysis ) { return isSet ( analysis , BIT_ROOT | BIT_FILTER ) ; } public static boolean walksChildrenOnly ( int analysis ) { return walksChildren ( analysis ) && ! isSet ( analysis , BIT_SELF ) && ! walksExtraNodes ( analysis ) && ! walksDescendants ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ( ! isAbsolute ( analysis ) || isSet ( analysis , BIT_ROOT ) ) ; } public static boolean walksChildrenAndExtraAndSelfOnly ( int analysis ) { return walksChildren ( analysis ) && ! walksDescendants ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ( ! isAbsolute ( analysis ) || isSet ( analysis , BIT_ROOT ) ) ; } public static boolean walksDescendantsAndExtraAndSelfOnly ( int analysis ) { return ! walksChildren ( analysis ) && walksDescendants ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ( ! isAbsolute ( analysis ) || isSet ( analysis , BIT_ROOT ) ) ; } public static boolean walksSelfOnly ( int analysis ) { return isSet ( analysis , BIT_SELF ) && ! walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksUpOnly ( int analysis ) { return ! walksSubtree ( analysis ) && walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksDownOnly ( int analysis ) { return walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksDownExtraOnly ( int analysis ) { return walksSubtree ( analysis ) && walksExtraNodes ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean canSkipSubtrees ( int analysis ) { return isSet ( analysis , BIT_CHILD ) | walksSideways ( analysis ) ; } public static boolean canCrissCross ( int analysis ) { if ( walksSelfOnly ( analysis ) ) return false ; else if ( walksDownOnly ( analysis ) && ! canSkipSubtrees ( analysis ) ) return false ; else if ( walksChildrenAndExtraAndSelfOnly ( analysis ) ) return false ; else if ( walksDescendantsAndExtraAndSelfOnly ( analysis ) ) return false ; else if ( walksUpOnly ( analysis ) ) return false ; else if ( walksExtraNodesOnly ( analysis ) ) return false ; else if ( walksSubtree ( analysis ) && ( walksSideways ( analysis ) || walksUp ( analysis ) || canSkipSubtrees ( analysis ) ) ) return true ; else return false ; } static public boolean isNaturalDocOrder ( int analysis ) { if ( canCrissCross ( analysis ) || isSet ( analysis , BIT_NAMESPACE ) || walksFilteredList ( analysis ) ) return false ; if ( walksInDocOrder ( analysis ) ) return true ; return false ; } private static boolean isNaturalDocOrder ( Compiler compiler , int stepOpCodePos , int stepIndex , int analysis ) throws javax . xml . transform . TransformerException { if ( canCrissCross ( analysis ) ) return false ; if ( isSet ( analysis , BIT_NAMESPACE ) ) return false ; if ( isSet ( analysis , BIT_FOLLOWING | BIT_FOLLOWING_SIBLING ) && isSet ( analysis , BIT_PRECEDING | BIT_PRECEDING_SIBLING ) ) return false ; int stepType ; int stepCount = 0 ; boolean foundWildAttribute = false ; int potentialDuplicateMakingStepCount = 0 ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { stepCount ++ ; switch ( stepType ) { case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : if ( foundWildAttribute ) return false ; String localName = compiler . getStepLocalName ( stepOpCodePos ) ; if ( localName . equals ( "*" ) ) { foundWildAttribute = true ; } break ; case OpCodes . FROM_FOLLOWING : case OpCodes . FROM_FOLLOWING_SIBLINGS : case OpCodes . FROM_PRECEDING : case OpCodes . FROM_PRECEDING_SIBLINGS : case OpCodes . FROM_PARENT : case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . FROM_NAMESPACE : case OpCodes . FROM_ANCESTORS : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : case OpCodes . FROM_DESCENDANTS_OR_SELF : case OpCodes . FROM_DESCENDANTS : if ( potentialDuplicateMakingStepCount > 0 ) return false ; potentialDuplicateMakingStepCount ++ ; case OpCodes . FROM_ROOT : case OpCodes . FROM_CHILDREN : case OpCodes . FROM_SELF : if ( foundWildAttribute ) return false ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } int nextStepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( nextStepOpCodePos < 0 ) break ; stepOpCodePos = nextStepOpCodePos ; } return true ; } public static boolean isOneStep ( int analysis ) { return ( analysis & BITS_COUNT ) == 0x00000001 ; } public static int getStepCount ( int analysis ) { return ( analysis & BITS_COUNT ) ; } public static final int BITS_COUNT = 0x000000FF ; public static final int BITS_RESERVED = 0x00000F00 ; public static final int BIT_PREDICATE = ( 0x00001000 ) ; public static final int BIT_ANCESTOR = ( 0x00001000 << 1 ) ; public static final int BIT_ANCESTOR_OR_SELF = ( 0x00001000 << 2 ) ; public static final int BIT_ATTRIBUTE = ( 0x00001000 << 3 ) ; public static final int BIT_CHILD = ( 0x00001000 << 4 ) ; public static final int BIT_DESCENDANT = ( 0x00001000 << 5 ) ; public static final int BIT_DESCENDANT_OR_SELF = ( 0x00001000 << 6 ) ; public static final int BIT_FOLLOWING = ( 0x00001000 << 7 ) ; public static final int BIT_FOLLOWING_SIBLING = ( 0x00001000 << 8 ) ; public static final int BIT_NAMESPACE = ( 0x00001000 << 9 ) ; public static final int BIT_PARENT = ( 0x00001000 << 10 ) ; public static final int BIT_PRECEDING = ( 0x00001000 << 11 ) ; public static final int BIT_PRECEDING_SIBLING = ( 0x00001000 << 12 ) ; public static final int BIT_SELF = ( 0x00001000 << 13 ) ; public static final int BIT_FILTER = ( 0x00001000 << 14 ) ; public static final int BIT_ROOT = ( 0x00001000 << 15 ) ; public static final int BITMASK_TRAVERSES_OUTSIDE_SUBTREE = ( BIT_NAMESPACE | BIT_PRECEDING_SIBLING | BIT_PRECEDING | BIT_FOLLOWING_SIBLING | BIT_FOLLOWING | BIT_PARENT | BIT_ANCESTOR_OR_SELF | BIT_ANCESTOR | BIT_FILTER | BIT_ROOT ) ; public static final int BIT_BACKWARDS_SELF = ( 0x00001000 << 16 ) ; public static final int BIT_ANY_DESCENDANT_FROM_ROOT = ( 0x00001000 << 17 ) ; public static final int BIT_NODETEST_ANY = ( 0x00001000 << 18 ) ; public static final int BIT_MATCH_PATTERN = ( 0x00001000 << 19 ) ; } 	1	['51', '1', '0', '25', '114', '1275', '11', '23', '40', '1.02', '2140', '0', '0', '0', '0.181372549', '0', '0', '40.45098039', '18', '3.3333', '1']
package org . apache . xpath . axes ; import org . apache . xpath . XPathContext ; public interface SubContextList { public int getLastPos ( XPathContext xctxt ) ; public int getProximityPosition ( XPathContext xctxt ) ; } 	1	['2', '1', '0', '7', '2', '1', '7', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . axes . NodeSequence ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XNodeSet extends NodeSequence { protected XNodeSet ( ) { } public XNodeSet ( DTMIterator val ) { super ( ) ; if ( val instanceof XNodeSet ) { setIter ( ( ( XNodeSet ) val ) . m_iter ) ; m_dtmMgr = ( ( XNodeSet ) val ) . m_dtmMgr ; m_last = ( ( XNodeSet ) val ) . m_last ; if ( ! ( ( XNodeSet ) val ) . hasCache ( ) ) ( ( XNodeSet ) val ) . setShouldCacheNodes ( true ) ; m_obj = ( ( XNodeSet ) val ) . m_obj ; } else setIter ( val ) ; } public XNodeSet ( XNodeSet val ) { super ( ) ; setIter ( val . m_iter ) ; m_dtmMgr = val . m_dtmMgr ; m_last = val . m_last ; if ( ! val . hasCache ( ) ) val . setShouldCacheNodes ( true ) ; m_obj = val . m_obj ; } public XNodeSet ( DTMManager dtmMgr ) { this ( DTM . NULL , dtmMgr ) ; } public XNodeSet ( int n , DTMManager dtmMgr ) { super ( new NodeSetDTM ( dtmMgr ) ) ; m_dtmMgr = dtmMgr ; if ( DTM . NULL != n ) { ( ( NodeSetDTM ) m_obj ) . addNode ( n ) ; m_last = 1 ; } else m_last = 0 ; } public int getType ( ) { return CLASS_NODESET ; } public String getTypeString ( ) { return "#NODESET" ; } public double getNumberFromNode ( int n ) { XMLString xstr = m_dtmMgr . getDTM ( n ) . getStringValue ( n ) ; return xstr . toDouble ( ) ; } public double num ( ) { int node = item ( 0 ) ; return ( node != DTM . NULL ) ? getNumberFromNode ( node ) : Double . NaN ; } public double numWithSideEffects ( ) { int node = nextNode ( ) ; return ( node != DTM . NULL ) ? getNumberFromNode ( node ) : Double . NaN ; } public boolean bool ( ) { return ( item ( 0 ) != DTM . NULL ) ; } public boolean boolWithSideEffects ( ) { return ( nextNode ( ) != DTM . NULL ) ; } public XMLString getStringFromNode ( int n ) { if ( DTM . NULL != n ) { return m_dtmMgr . getDTM ( n ) . getStringValue ( n ) ; } else { return org . apache . xpath . objects . XString . EMPTYSTRING ; } } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { int node = item ( 0 ) ; if ( node != DTM . NULL ) { m_dtmMgr . getDTM ( node ) . dispatchCharactersEvents ( node , ch , false ) ; } } public XMLString xstr ( ) { int node = item ( 0 ) ; return ( node != DTM . NULL ) ? getStringFromNode ( node ) : XString . EMPTYSTRING ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { XString xstring = ( XString ) xstr ( ) ; xstring . appendToFsb ( fsb ) ; } public String str ( ) { int node = item ( 0 ) ; return ( node != DTM . NULL ) ? getStringFromNode ( node ) . toString ( ) : "" ; } public Object object ( ) { if ( null == m_obj ) return this ; else return m_obj ; } public NodeIterator nodeset ( ) throws javax . xml . transform . TransformerException { return new org . apache . xml . dtm . ref . DTMNodeIterator ( iter ( ) ) ; } public NodeList nodelist ( ) throws javax . xml . transform . TransformerException { org . apache . xml . dtm . ref . DTMNodeList nodelist = new org . apache . xml . dtm . ref . DTMNodeList ( this ) ; XNodeSet clone = ( XNodeSet ) nodelist . getDTMIterator ( ) ; SetVector ( clone . getVector ( ) ) ; return nodelist ; } public DTMIterator iterRaw ( ) { return this ; } public void release ( DTMIterator iter ) { } public DTMIterator iter ( ) { try { if ( hasCache ( ) ) return cloneWithReset ( ) ; else return this ; } catch ( CloneNotSupportedException cnse ) { throw new RuntimeException ( cnse . getMessage ( ) ) ; } } public XObject getFresh ( ) { try { if ( hasCache ( ) ) return ( XObject ) cloneWithReset ( ) ; else return this ; } catch ( CloneNotSupportedException cnse ) { throw new RuntimeException ( cnse . getMessage ( ) ) ; } } public NodeSetDTM mutableNodeset ( ) { NodeSetDTM mnl ; if ( m_obj instanceof NodeSetDTM ) { mnl = ( NodeSetDTM ) m_obj ; } else { mnl = new NodeSetDTM ( iter ( ) ) ; m_obj = mnl ; setCurrentPos ( 0 ) ; } return mnl ; } static LessThanComparator S_LT = new LessThanComparator ( ) ; static LessThanOrEqualComparator S_LTE = new LessThanOrEqualComparator ( ) ; static GreaterThanComparator S_GT = new GreaterThanComparator ( ) ; static GreaterThanOrEqualComparator S_GTE = new GreaterThanOrEqualComparator ( ) ; static EqualComparator S_EQ = new EqualComparator ( ) ; static NotEqualComparator S_NEQ = new NotEqualComparator ( ) ; public boolean compare ( XObject obj2 , Comparator comparator ) throws javax . xml . transform . TransformerException { boolean result = false ; int type = obj2 . getType ( ) ; if ( XObject . CLASS_NODESET == type ) { DTMIterator list1 = iterRaw ( ) ; DTMIterator list2 = ( ( XNodeSet ) obj2 ) . iterRaw ( ) ; int node1 ; java . util . Vector node2Strings = null ; while ( DTM . NULL != ( node1 = list1 . nextNode ( ) ) ) { XMLString s1 = getStringFromNode ( node1 ) ; if ( null == node2Strings ) { int node2 ; while ( DTM . NULL != ( node2 = list2 . nextNode ( ) ) ) { XMLString s2 = getStringFromNode ( node2 ) ; if ( comparator . compareStrings ( s1 , s2 ) ) { result = true ; break ; } if ( null == node2Strings ) node2Strings = new java . util . Vector ( ) ; node2Strings . addElement ( s2 ) ; } } else { int n = node2Strings . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( comparator . compareStrings ( s1 , ( XMLString ) node2Strings . elementAt ( i ) ) ) { result = true ; break ; } } } } list1 . reset ( ) ; list2 . reset ( ) ; } else if ( XObject . CLASS_BOOLEAN == type ) { double num1 = bool ( ) ? 1.0 : 0.0 ; double num2 = obj2 . num ( ) ; result = comparator . compareNumbers ( num1 , num2 ) ; } else if ( XObject . CLASS_NUMBER == type ) { DTMIterator list1 = iterRaw ( ) ; double num2 = obj2 . num ( ) ; int node ; while ( DTM . NULL != ( node = list1 . nextNode ( ) ) ) { double num1 = getNumberFromNode ( node ) ; if ( comparator . compareNumbers ( num1 , num2 ) ) { result = true ; break ; } } list1 . reset ( ) ; } else if ( XObject . CLASS_RTREEFRAG == type ) { XMLString s2 = obj2 . xstr ( ) ; DTMIterator list1 = iterRaw ( ) ; int node ; while ( DTM . NULL != ( node = list1 . nextNode ( ) ) ) { XMLString s1 = getStringFromNode ( node ) ; if ( comparator . compareStrings ( s1 , s2 ) ) { result = true ; break ; } } list1 . reset ( ) ; } else if ( XObject . CLASS_STRING == type ) { XMLString s2 = obj2 . xstr ( ) ; DTMIterator list1 = iterRaw ( ) ; int node ; while ( DTM . NULL != ( node = list1 . nextNode ( ) ) ) { XMLString s1 = getStringFromNode ( node ) ; if ( comparator . compareStrings ( s1 , s2 ) ) { result = true ; break ; } } list1 . reset ( ) ; } else { result = comparator . compareNumbers ( this . num ( ) , obj2 . num ( ) ) ; } return result ; } public boolean lessThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_LT ) ; } public boolean lessThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_LTE ) ; } public boolean greaterThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_GT ) ; } public boolean greaterThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_GTE ) ; } public boolean equals ( XObject obj2 ) { try { return compare ( obj2 , S_EQ ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } public boolean notEquals ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_NEQ ) ; } } abstract class Comparator { abstract boolean compareStrings ( XMLString s1 , XMLString s2 ) ; abstract boolean compareNumbers ( double n1 , double n2 ) ; } class LessThanComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) < s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 < n2 ; } } class LessThanOrEqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) <= s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 <= n2 ; } } class GreaterThanComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) > s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 > n2 ; } } class GreaterThanOrEqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) >= s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 >= n2 ; } } class EqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return s1 . equals ( s2 ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 == n2 ; } } class NotEqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ! s1 . equals ( s2 ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 != n2 ; } } 	1	['33', '4', '3', '45', '76', '472', '26', '20', '31', '0.96875', '610', '0', '6', '0.801470588', '0.173611111', '3', '30', '17.3030303', '2', '1.1515', '1']
package org . apache . xalan . templates ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . text . NumberFormat ; import java . util . Locale ; import java . util . NoSuchElementException ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . CountersTable ; import org . apache . xalan . transformer . DecimalToRoman ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xml . utils . res . XResourceBundle ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; import org . xml . sax . SAXException ; public class ElemNumber extends ElemTemplateElement { private class MyPrefixResolver implements PrefixResolver { DTM dtm ; int handle ; boolean handleNullPrefix ; public MyPrefixResolver ( Node xpathExpressionContext , DTM dtm , int handle , boolean handleNullPrefix ) { this . dtm = dtm ; this . handle = handle ; this . handleNullPrefix = handleNullPrefix ; } public String getNamespaceForPrefix ( String prefix ) { return dtm . getNamespaceURI ( handle ) ; } public String getNamespaceForPrefix ( String prefix , Node context ) { return getNamespaceForPrefix ( prefix ) ; } public String getBaseIdentifier ( ) { return ElemNumber . this . getBaseIdentifier ( ) ; } public boolean handlesNullPrefixes ( ) { return handleNullPrefix ; } } private XPath m_countMatchPattern = null ; public void setCount ( XPath v ) { m_countMatchPattern = v ; } public XPath getCount ( ) { return m_countMatchPattern ; } private XPath m_fromMatchPattern = null ; public void setFrom ( XPath v ) { m_fromMatchPattern = v ; } public XPath getFrom ( ) { return m_fromMatchPattern ; } private int m_level = Constants . NUMBERLEVEL_SINGLE ; public void setLevel ( int v ) { m_level = v ; } public int getLevel ( ) { return m_level ; } private XPath m_valueExpr = null ; public void setValue ( XPath v ) { m_valueExpr = v ; } public XPath getValue ( ) { return m_valueExpr ; } private AVT m_format_avt = null ; public void setFormat ( AVT v ) { m_format_avt = v ; } public AVT getFormat ( ) { return m_format_avt ; } private AVT m_lang_avt = null ; public void setLang ( AVT v ) { m_lang_avt = v ; } public AVT getLang ( ) { return m_lang_avt ; } private AVT m_lettervalue_avt = null ; public void setLetterValue ( AVT v ) { m_lettervalue_avt = v ; } public AVT getLetterValue ( ) { return m_lettervalue_avt ; } private AVT m_groupingSeparator_avt = null ; public void setGroupingSeparator ( AVT v ) { m_groupingSeparator_avt = v ; } public AVT getGroupingSeparator ( ) { return m_groupingSeparator_avt ; } private AVT m_groupingSize_avt = null ; public void setGroupingSize ( AVT v ) { m_groupingSize_avt = v ; } public AVT getGroupingSize ( ) { return m_groupingSize_avt ; } private final static DecimalToRoman m_romanConvertTable [ ] = { new DecimalToRoman ( 1000 , "M" , 900 , "CM" ) , new DecimalToRoman ( 500 , "D" , 400 , "CD" ) , new DecimalToRoman ( 100L , "C" , 90L , "XC" ) , new DecimalToRoman ( 50L , "L" , 40L , "XL" ) , new DecimalToRoman ( 10L , "X" , 9L , "IX" ) , new DecimalToRoman ( 5L , "V" , 4L , "IV" ) , new DecimalToRoman ( 1L , "I" , 1L , "I" ) } ; private static char [ ] m_alphaCountTable = null ; public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_countMatchPattern ) m_countMatchPattern . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_format_avt ) m_format_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_fromMatchPattern ) m_fromMatchPattern . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_groupingSeparator_avt ) m_groupingSeparator_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_groupingSize_avt ) m_groupingSize_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_lang_avt ) m_lang_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_lettervalue_avt ) m_lettervalue_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_valueExpr ) m_valueExpr . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_NUMBER ; } public String getNodeName ( ) { return Constants . ELEMNAME_NUMBER_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; String countString = getCountString ( transformer , sourceNode ) ; try { transformer . getResultTreeHandler ( ) . characters ( countString . toCharArray ( ) , 0 , countString . length ( ) ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } int findAncestor ( XPathContext xctxt , XPath fromMatchPattern , XPath countMatchPattern , int context , ElemNumber namespaceContext ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( context ) ; while ( DTM . NULL != context ) { if ( null != fromMatchPattern ) { if ( fromMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { break ; } } if ( null != countMatchPattern ) { if ( countMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { break ; } } context = dtm . getParent ( context ) ; } return context ; } private int findPrecedingOrAncestorOrSelf ( XPathContext xctxt , XPath fromMatchPattern , XPath countMatchPattern , int context , ElemNumber namespaceContext ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( context ) ; while ( DTM . NULL != context ) { if ( null != fromMatchPattern ) { if ( fromMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { context = DTM . NULL ; break ; } } if ( null != countMatchPattern ) { if ( countMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { break ; } } int prevSibling = dtm . getPreviousSibling ( context ) ; if ( DTM . NULL == prevSibling ) { context = dtm . getParent ( context ) ; } else { context = dtm . getLastChild ( prevSibling ) ; if ( context == DTM . NULL ) context = prevSibling ; } } return context ; } XPath getCountMatchPattern ( XPathContext support , int contextNode ) throws javax . xml . transform . TransformerException { XPath countMatchPattern = m_countMatchPattern ; DTM dtm = support . getDTM ( contextNode ) ; if ( null == countMatchPattern ) { switch ( dtm . getNodeType ( contextNode ) ) { case DTM . ELEMENT_NODE : MyPrefixResolver resolver ; if ( dtm . getNamespaceURI ( contextNode ) == null ) { resolver = new MyPrefixResolver ( dtm . getNode ( contextNode ) , dtm , contextNode , false ) ; } else { resolver = new MyPrefixResolver ( dtm . getNode ( contextNode ) , dtm , contextNode , true ) ; } countMatchPattern = new XPath ( dtm . getNodeName ( contextNode ) , this , resolver , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . ATTRIBUTE_NODE : countMatchPattern = new XPath ( "@" + dtm . getNodeName ( contextNode ) , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : countMatchPattern = new XPath ( "text()" , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . COMMENT_NODE : countMatchPattern = new XPath ( "comment()" , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . DOCUMENT_NODE : countMatchPattern = new XPath ( "/" , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : countMatchPattern = new XPath ( "pi(" + dtm . getNodeName ( contextNode ) + ")" , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; default : countMatchPattern = null ; } } return countMatchPattern ; } String getCountString ( TransformerImpl transformer , int sourceNode ) throws TransformerException { long [ ] list = null ; XPathContext xctxt = transformer . getXPathContext ( ) ; CountersTable ctable = transformer . getCountersTable ( ) ; if ( null != m_valueExpr ) { XObject countObj = m_valueExpr . execute ( xctxt , sourceNode , this ) ; long count = ( long ) java . lang . Math . floor ( countObj . num ( ) + 0.5 ) ; list = new long [ 1 ] ; list [ 0 ] = count ; } else { if ( Constants . NUMBERLEVEL_ANY == m_level ) { list = new long [ 1 ] ; list [ 0 ] = ctable . countNode ( xctxt , this , sourceNode ) ; } else { NodeVector ancestors = getMatchingAncestors ( xctxt , sourceNode , Constants . NUMBERLEVEL_SINGLE == m_level ) ; int lastIndex = ancestors . size ( ) - 1 ; if ( lastIndex >= 0 ) { list = new long [ lastIndex + 1 ] ; for ( int i = lastIndex ; i >= 0 ; i -- ) { int target = ancestors . elementAt ( i ) ; list [ lastIndex - i ] = ctable . countNode ( xctxt , this , target ) ; } } } } return ( null != list ) ? formatNumberList ( transformer , list , sourceNode ) : "" ; } public int getPreviousNode ( XPathContext xctxt , int pos ) throws TransformerException { XPath countMatchPattern = getCountMatchPattern ( xctxt , pos ) ; DTM dtm = xctxt . getDTM ( pos ) ; if ( Constants . NUMBERLEVEL_ANY == m_level ) { XPath fromMatchPattern = m_fromMatchPattern ; while ( DTM . NULL != pos ) { int next = dtm . getPreviousSibling ( pos ) ; if ( DTM . NULL == next ) { next = dtm . getParent ( pos ) ; if ( ( DTM . NULL != next ) && ( ( ( ( null != fromMatchPattern ) && ( fromMatchPattern . getMatchScore ( xctxt , next ) != XPath . MATCH_SCORE_NONE ) ) ) || ( dtm . getNodeType ( next ) == DTM . DOCUMENT_NODE ) ) ) { pos = DTM . NULL ; break ; } } else { int child = next ; while ( DTM . NULL != child ) { child = dtm . getLastChild ( next ) ; if ( DTM . NULL != child ) next = child ; } } pos = next ; if ( ( DTM . NULL != pos ) && ( ( null == countMatchPattern ) || ( countMatchPattern . getMatchScore ( xctxt , pos ) != XPath . MATCH_SCORE_NONE ) ) ) { break ; } } } else { while ( DTM . NULL != pos ) { pos = dtm . getPreviousSibling ( pos ) ; if ( ( DTM . NULL != pos ) && ( ( null == countMatchPattern ) || ( countMatchPattern . getMatchScore ( xctxt , pos ) != XPath . MATCH_SCORE_NONE ) ) ) { break ; } } } return pos ; } public int getTargetNode ( XPathContext xctxt , int sourceNode ) throws TransformerException { int target = DTM . NULL ; XPath countMatchPattern = getCountMatchPattern ( xctxt , sourceNode ) ; if ( Constants . NUMBERLEVEL_ANY == m_level ) { target = findPrecedingOrAncestorOrSelf ( xctxt , m_fromMatchPattern , countMatchPattern , sourceNode , this ) ; } else { target = findAncestor ( xctxt , m_fromMatchPattern , countMatchPattern , sourceNode , this ) ; } return target ; } NodeVector getMatchingAncestors ( XPathContext xctxt , int node , boolean stopAtFirstFound ) throws javax . xml . transform . TransformerException { NodeSetDTM ancestors = new NodeSetDTM ( xctxt . getDTMManager ( ) ) ; XPath countMatchPattern = getCountMatchPattern ( xctxt , node ) ; DTM dtm = xctxt . getDTM ( node ) ; while ( DTM . NULL != node ) { if ( ( null != m_fromMatchPattern ) && ( m_fromMatchPattern . getMatchScore ( xctxt , node ) != XPath . MATCH_SCORE_NONE ) ) { if ( ! stopAtFirstFound ) break ; } if ( null == countMatchPattern ) System . out . println ( "Programmers error! countMatchPattern should never be null!" ) ; if ( countMatchPattern . getMatchScore ( xctxt , node ) != XPath . MATCH_SCORE_NONE ) { ancestors . addElement ( node ) ; if ( stopAtFirstFound ) break ; } node = dtm . getParent ( node ) ; } return ancestors ; } Locale getLocale ( TransformerImpl transformer , int contextNode ) throws TransformerException { Locale locale = null ; if ( null != m_lang_avt ) { XPathContext xctxt = transformer . getXPathContext ( ) ; String langValue = m_lang_avt . evaluate ( xctxt , contextNode , this ) ; if ( null != langValue ) { locale = new Locale ( langValue . toUpperCase ( ) , "" ) ; if ( null == locale ) { transformer . getMsgMgr ( ) . warn ( this , null , xctxt . getDTM ( contextNode ) . getNode ( contextNode ) , XSLTErrorResources . WG_LOCALE_NOT_FOUND , new Object [ ] { langValue } ) ; locale = Locale . getDefault ( ) ; } } } else { locale = Locale . getDefault ( ) ; } return locale ; } private DecimalFormat getNumberFormatter ( TransformerImpl transformer , int contextNode ) throws TransformerException { Locale locale = ( Locale ) getLocale ( transformer , contextNode ) . clone ( ) ; DecimalFormat formatter = null ; String digitGroupSepValue = ( null != m_groupingSeparator_avt ) ? m_groupingSeparator_avt . evaluate ( transformer . getXPathContext ( ) , contextNode , this ) : null ; if ( ( digitGroupSepValue != null ) && ( ! m_groupingSeparator_avt . isSimple ( ) ) && ( digitGroupSepValue . length ( ) != 1 ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_NAME , m_groupingSeparator_avt . getName ( ) } ) ; } String nDigitsPerGroupValue = ( null != m_groupingSize_avt ) ? m_groupingSize_avt . evaluate ( transformer . getXPathContext ( ) , contextNode , this ) : null ; if ( ( null != digitGroupSepValue ) && ( null != nDigitsPerGroupValue ) && ( digitGroupSepValue . length ( ) > 0 ) ) { try { formatter = ( DecimalFormat ) NumberFormat . getNumberInstance ( locale ) ; formatter . setGroupingSize ( Integer . valueOf ( nDigitsPerGroupValue ) . intValue ( ) ) ; DecimalFormatSymbols symbols = formatter . getDecimalFormatSymbols ( ) ; symbols . setGroupingSeparator ( digitGroupSepValue . charAt ( 0 ) ) ; formatter . setDecimalFormatSymbols ( symbols ) ; formatter . setGroupingUsed ( true ) ; } catch ( NumberFormatException ex ) { formatter . setGroupingUsed ( false ) ; } } return formatter ; } String formatNumberList ( TransformerImpl transformer , long [ ] list , int contextNode ) throws TransformerException { String numStr ; FastStringBuffer formattedNumber = StringBufferPool . get ( ) ; try { int nNumbers = list . length , numberWidth = 1 ; char numberType = '1' ; String formatToken , lastSepString = null , formatTokenString = null ; String lastSep = "." ; boolean isFirstToken = true ; String formatValue = ( null != m_format_avt ) ? m_format_avt . evaluate ( transformer . getXPathContext ( ) , contextNode , this ) : null ; if ( null == formatValue ) formatValue = "1" ; NumberFormatStringTokenizer formatTokenizer = new NumberFormatStringTokenizer ( formatValue ) ; for ( int i = 0 ; i < nNumbers ; i ++ ) { if ( formatTokenizer . hasMoreTokens ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; if ( Character . isLetterOrDigit ( formatToken . charAt ( formatToken . length ( ) - 1 ) ) ) { numberWidth = formatToken . length ( ) ; numberType = formatToken . charAt ( numberWidth - 1 ) ; } else if ( formatTokenizer . isLetterOrDigitAhead ( ) ) { formatTokenString = formatToken ; while ( formatTokenizer . nextIsSep ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; formatTokenString += formatToken ; } if ( ! isFirstToken ) lastSep = formatTokenString ; formatToken = formatTokenizer . nextToken ( ) ; numberWidth = formatToken . length ( ) ; numberType = formatToken . charAt ( numberWidth - 1 ) ; } else { lastSepString = formatToken ; while ( formatTokenizer . hasMoreTokens ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; lastSepString += formatToken ; } } } if ( null != formatTokenString && isFirstToken ) { formattedNumber . append ( formatTokenString ) ; } else if ( null != lastSep && ! isFirstToken ) formattedNumber . append ( lastSep ) ; getFormattedNumber ( transformer , contextNode , numberType , numberWidth , list [ i ] , formattedNumber ) ; isFirstToken = false ; } while ( formatTokenizer . isLetterOrDigitAhead ( ) ) { formatTokenizer . nextToken ( ) ; } if ( lastSepString != null ) formattedNumber . append ( lastSepString ) ; while ( formatTokenizer . hasMoreTokens ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; formattedNumber . append ( formatToken ) ; } numStr = formattedNumber . toString ( ) ; } finally { StringBufferPool . free ( formattedNumber ) ; } return numStr ; } private void getFormattedNumber ( TransformerImpl transformer , int contextNode , char numberType , int numberWidth , long listElement , FastStringBuffer formattedNumber ) throws javax . xml . transform . TransformerException { String letterVal = ( m_lettervalue_avt != null ) ? m_lettervalue_avt . evaluate ( transformer . getXPathContext ( ) , contextNode , this ) : null ; switch ( numberType ) { case 'A' : if ( m_alphaCountTable == null ) { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , getLocale ( transformer , contextNode ) ) ; char [ ] alphabet ; alphabet = ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ; m_alphaCountTable = alphabet ; } int2alphaCount ( listElement , m_alphaCountTable , formattedNumber ) ; break ; case 'a' : if ( m_alphaCountTable == null ) { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , getLocale ( transformer , contextNode ) ) ; char [ ] alphabet ; alphabet = ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ; m_alphaCountTable = alphabet ; } FastStringBuffer stringBuf = StringBufferPool . get ( ) ; try { int2alphaCount ( listElement , m_alphaCountTable , stringBuf ) ; formattedNumber . append ( stringBuf . toString ( ) . toLowerCase ( getLocale ( transformer , contextNode ) ) ) ; } finally { StringBufferPool . free ( stringBuf ) ; } break ; case 'I' : formattedNumber . append ( long2roman ( listElement , true ) ) ; break ; case 'i' : formattedNumber . append ( long2roman ( listElement , true ) . toLowerCase ( getLocale ( transformer , contextNode ) ) ) ; break ; case 0x3042 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ja" , "JP" , "HA" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else formattedNumber . append ( int2singlealphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ) ) ; break ; } case 0x3044 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ja" , "JP" , "HI" ) ) ; if ( ( letterVal != null ) && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else formattedNumber . append ( int2singlealphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ) ) ; break ; } case 0x30A2 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ja" , "JP" , "A" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else formattedNumber . append ( int2singlealphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ) ) ; break ; } case 0x30A4 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ja" , "JP" , "I" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else formattedNumber . append ( int2singlealphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ) ) ; break ; } case 0x4E00 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "zh" , "CN" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) { formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; } else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x58F9 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "zh" , "TW" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x0E51 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "th" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x05D0 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "he" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x10D0 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ka" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x03B1 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "el" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x0430 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "cy" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } default : DecimalFormat formatter = getNumberFormatter ( transformer , contextNode ) ; String padString = formatter == null ? String . valueOf ( 0 ) : formatter . format ( 0 ) ; String numString = formatter == null ? String . valueOf ( listElement ) : formatter . format ( listElement ) ; int nPadding = numberWidth - numString . length ( ) ; for ( int k = 0 ; k < nPadding ; k ++ ) { formattedNumber . append ( padString ) ; } formattedNumber . append ( numString ) ; } } String getZeroString ( ) { return "" + 0 ; } protected String int2singlealphaCount ( long val , char [ ] table ) { int radix = table . length ; if ( val > radix ) { return getZeroString ( ) ; } else return ( new Character ( table [ ( int ) val - 1 ] ) ) . toString ( ) ; } protected void int2alphaCount ( long val , char [ ] aTable , FastStringBuffer stringBuf ) { int radix = aTable . length ; char [ ] table = new char [ aTable . length ] ; int i ; for ( i = 0 ; i < aTable . length - 1 ; i ++ ) { table [ i + 1 ] = aTable [ i ] ; } table [ 0 ] = aTable [ i ] ; char buf [ ] = new char [ 100 ] ; int charPos ; charPos = buf . length - 1 ; int lookupIndex = 1 ; long correction = 0 ; do { correction = ( ( lookupIndex == 0 ) || ( correction != 0 && lookupIndex == radix - 1 ) ) ? ( radix - 1 ) : 0 ; lookupIndex = ( int ) ( val + correction ) % radix ; val = ( val / radix ) ; if ( lookupIndex == 0 && val == 0 ) break ; buf [ charPos -- ] = table [ lookupIndex ] ; } while ( val > 0 ) ; stringBuf . append ( buf , charPos + 1 , ( buf . length - charPos - 1 ) ) ; } protected String tradAlphaCount ( long val , XResourceBundle thisBundle ) { if ( val > Long . MAX_VALUE ) { this . error ( XSLTErrorResources . ER_NUMBER_TOO_BIG ) ; return XSLTErrorResources . ERROR_STRING ; } char [ ] table = null ; int lookupIndex = 1 ; char buf [ ] = new char [ 100 ] ; int charPos ; charPos = 0 ; int [ ] groups = ( int [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_NUMBERGROUPS ) ; String [ ] tables = ( String [ ] ) ( thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_NUM_TABLES ) ) ; String numbering = thisBundle . getString ( org . apache . xml . utils . res . XResourceBundle . LANG_NUMBERING ) ; if ( numbering . equals ( org . apache . xml . utils . res . XResourceBundle . LANG_MULT_ADD ) ) { String mult_order = thisBundle . getString ( org . apache . xml . utils . res . XResourceBundle . MULT_ORDER ) ; long [ ] multiplier = ( long [ ] ) ( thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_MULTIPLIER ) ) ; char [ ] zeroChar = ( char [ ] ) thisBundle . getObject ( "zero" ) ; int i = 0 ; while ( i < multiplier . length && val < multiplier [ i ] ) { i ++ ; } do { if ( i >= multiplier . length ) break ; if ( val < multiplier [ i ] ) { if ( zeroChar . length == 0 ) { i ++ ; } else { if ( buf [ charPos - 1 ] != zeroChar [ 0 ] ) buf [ charPos ++ ] = zeroChar [ 0 ] ; i ++ ; } } else if ( val >= multiplier [ i ] ) { long mult = val / multiplier [ i ] ; val = val % multiplier [ i ] ; int k = 0 ; while ( k < groups . length ) { lookupIndex = 1 ; if ( mult / groups [ k ] <= 0 ) k ++ ; else { char [ ] THEletters = ( char [ ] ) thisBundle . getObject ( tables [ k ] ) ; table = new char [ THEletters . length + 1 ] ; int j ; for ( j = 0 ; j < THEletters . length ; j ++ ) { table [ j + 1 ] = THEletters [ j ] ; } table [ 0 ] = THEletters [ j - 1 ] ; lookupIndex = ( int ) mult / groups [ k ] ; if ( lookupIndex == 0 && mult == 0 ) break ; char multiplierChar = ( ( char [ ] ) ( thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_MULTIPLIER_CHAR ) ) ) [ i ] ; if ( lookupIndex < table . length ) { if ( mult_order . equals ( org . apache . xml . utils . res . XResourceBundle . MULT_PRECEDES ) ) { buf [ charPos ++ ] = multiplierChar ; buf [ charPos ++ ] = table [ lookupIndex ] ; } else { if ( lookupIndex == 1 && i == multiplier . length - 1 ) { } else buf [ charPos ++ ] = table [ lookupIndex ] ; buf [ charPos ++ ] = multiplierChar ; } break ; } else return XSLTErrorResources . ERROR_STRING ; } } i ++ ; } } while ( i < multiplier . length ) ; } int count = 0 ; String tableName ; while ( count < groups . length ) { if ( val / groups [ count ] <= 0 ) count ++ ; else { char [ ] theletters = ( char [ ] ) thisBundle . getObject ( tables [ count ] ) ; table = new char [ theletters . length + 1 ] ; int j ; for ( j = 0 ; j < theletters . length ; j ++ ) { table [ j + 1 ] = theletters [ j ] ; } table [ 0 ] = theletters [ j - 1 ] ; lookupIndex = ( int ) val / groups [ count ] ; val = val % groups [ count ] ; if ( lookupIndex == 0 && val == 0 ) break ; if ( lookupIndex < table . length ) { buf [ charPos ++ ] = table [ lookupIndex ] ; } else return XSLTErrorResources . ERROR_STRING ; count ++ ; } } return new String ( buf , 0 , charPos ) ; } protected String long2roman ( long val , boolean prefixesAreOK ) { if ( val <= 0 ) { return getZeroString ( ) ; } String roman = "" ; int place = 0 ; if ( val <= 3999L ) { do { while ( val >= m_romanConvertTable [ place ] . m_postValue ) { roman += m_romanConvertTable [ place ] . m_postLetter ; val -= m_romanConvertTable [ place ] . m_postValue ; } if ( prefixesAreOK ) { if ( val >= m_romanConvertTable [ place ] . m_preValue ) { roman += m_romanConvertTable [ place ] . m_preLetter ; val -= m_romanConvertTable [ place ] . m_preValue ; } } place ++ ; } while ( val > 0 ) ; } else { roman = XSLTErrorResources . ERROR_STRING ; } return roman ; } public void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) { if ( null != m_countMatchPattern ) m_countMatchPattern . getExpression ( ) . callVisitors ( m_countMatchPattern , visitor ) ; if ( null != m_fromMatchPattern ) m_fromMatchPattern . getExpression ( ) . callVisitors ( m_fromMatchPattern , visitor ) ; if ( null != m_valueExpr ) m_valueExpr . getExpression ( ) . callVisitors ( m_valueExpr , visitor ) ; if ( null != m_format_avt ) m_format_avt . callVisitors ( visitor ) ; if ( null != m_groupingSeparator_avt ) m_groupingSeparator_avt . callVisitors ( visitor ) ; if ( null != m_groupingSize_avt ) m_groupingSize_avt . callVisitors ( visitor ) ; if ( null != m_lang_avt ) m_lang_avt . callVisitors ( visitor ) ; if ( null != m_lettervalue_avt ) m_lettervalue_avt . callVisitors ( visitor ) ; } super . callChildVisitors ( visitor , callAttrs ) ; } class NumberFormatStringTokenizer { private int currentPosition ; private int maxPosition ; private String str ; public NumberFormatStringTokenizer ( String str ) { this . str = str ; maxPosition = str . length ( ) ; } public void reset ( ) { currentPosition = 0 ; } public String nextToken ( ) { if ( currentPosition >= maxPosition ) { throw new NoSuchElementException ( ) ; } int start = currentPosition ; while ( ( currentPosition < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) { currentPosition ++ ; } if ( ( start == currentPosition ) && ( ! Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) ) { currentPosition ++ ; } return str . substring ( start , currentPosition ) ; } public boolean isLetterOrDigitAhead ( ) { int pos = currentPosition ; while ( pos < maxPosition ) { if ( Character . isLetterOrDigit ( str . charAt ( pos ) ) ) return true ; pos ++ ; } return false ; } public boolean nextIsSep ( ) { if ( Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) return false ; else return true ; } public boolean hasMoreTokens ( ) { return ( currentPosition >= maxPosition ) ? false : true ; } public int countTokens ( ) { int count = 0 ; int currpos = currentPosition ; while ( currpos < maxPosition ) { int start = currpos ; while ( ( currpos < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currpos ) ) ) { currpos ++ ; } if ( ( start == currpos ) && ( Character . isLetterOrDigit ( str . charAt ( currpos ) ) == false ) ) { currpos ++ ; } count ++ ; } return count ; } } } 	1	['42', '3', '0', '29', '135', '617', '5', '27', '27', '0.860310421', '2384', '1', '9', '0.830508475', '0.136298422', '2', '7', '55.5', '26', '2.0952', '1']
package org . apache . xpath . compiler ; public class OpCodes { public static final int ENDOP = - 1 ; public static final int EMPTY = - 2 ; public static final int ELEMWILDCARD = - 3 ; public static final int OP_XPATH = 1 ; public static final int OP_OR = 2 ; public static final int OP_AND = 3 ; public static final int OP_NOTEQUALS = 4 ; public static final int OP_EQUALS = 5 ; public static final int OP_LTE = 6 ; public static final int OP_LT = 7 ; public static final int OP_GTE = 8 ; public static final int OP_GT = 9 ; public static final int OP_PLUS = 10 ; public static final int OP_MINUS = 11 ; public static final int OP_MULT = 12 ; public static final int OP_DIV = 13 ; public static final int OP_MOD = 14 ; public static final int OP_QUO = 15 ; public static final int OP_NEG = 16 ; public static final int OP_STRING = 17 ; public static final int OP_BOOL = 18 ; public static final int OP_NUMBER = 19 ; public static final int OP_UNION = 20 ; public static final int OP_LITERAL = 21 ; static final int FIRST_NODESET_OP = 22 ; public static final int OP_VARIABLE = 22 ; public static final int OP_GROUP = 23 ; public static final int OP_EXTFUNCTION = 24 ; public static final int OP_FUNCTION = 25 ; static final int LAST_NODESET_OP = 25 ; public static final int OP_ARGUMENT = 26 ; public static final int OP_NUMBERLIT = 27 ; public static final int OP_LOCATIONPATH = 28 ; public static final int OP_PREDICATE = 29 ; public static final int OP_MATCHPATTERN = 30 ; public static final int OP_LOCATIONPATHPATTERN = 31 ; public static final int NODETYPE_COMMENT = 1030 ; public static final int NODETYPE_TEXT = 1031 ; public static final int NODETYPE_PI = 1032 ; public static final int NODETYPE_NODE = 1033 ; public static final int NODENAME = 34 ; public static final int NODETYPE_ROOT = 35 ; public static final int NODETYPE_ANYELEMENT = 36 ; public static final int NODETYPE_FUNCTEST = 1034 ; public static final int AXES_START_TYPES = 37 ; public static final int FROM_ANCESTORS = 37 ; public static final int FROM_ANCESTORS_OR_SELF = 38 ; public static final int FROM_ATTRIBUTES = 39 ; public static final int FROM_CHILDREN = 40 ; public static final int FROM_DESCENDANTS = 41 ; public static final int FROM_DESCENDANTS_OR_SELF = 42 ; public static final int FROM_FOLLOWING = 43 ; public static final int FROM_FOLLOWING_SIBLINGS = 44 ; public static final int FROM_PARENT = 45 ; public static final int FROM_PRECEDING = 46 ; public static final int FROM_PRECEDING_SIBLINGS = 47 ; public static final int FROM_SELF = 48 ; public static final int FROM_NAMESPACE = 49 ; public static final int FROM_ROOT = 50 ; public static final int MATCH_ATTRIBUTE = 51 ; public static final int MATCH_ANY_ANCESTOR = 52 ; public static final int MATCH_IMMEDIATE_ANCESTOR = 53 ; public static final int AXES_END_TYPES = 53 ; private static final int NEXT_FREE_ID = 99 ; } 	1	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '68', '0.015625', '0', '0', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ApplyTemplates extends Instruction { private Expression _select ; private Type _type = null ; private QName _modeName ; private String _functionName ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ApplyTemplates" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; if ( _modeName != null ) { indent ( indent + IndentIncrement ) ; Util . println ( "mode " + _modeName ) ; } } public boolean hasWithParams ( ) { return hasContents ( ) ; } public void parseContents ( Parser parser ) { final String select = getAttribute ( "select" ) ; final String mode = getAttribute ( "mode" ) ; if ( select . length ( ) > 0 ) { _select = parser . parseExpression ( this , "select" , null ) ; final Expression fpe = new ForwardPositionExpr ( _select ) ; _select . setParent ( fpe ) ; fpe . setParser ( _select . getParser ( ) ) ; _select = fpe ; } if ( mode . length ( ) > 0 ) { _modeName = parser . getQNameIgnoreDefaultNs ( mode ) ; } _functionName = parser . getTopLevelStylesheet ( ) . getMode ( _modeName ) . functionName ( ) ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { _type = _select . typeCheck ( stable ) ; if ( _type instanceof NodeType || _type instanceof ReferenceType ) { _select = new CastExpr ( _select , Type . NodeSet ) ; _type = Type . NodeSet ; } if ( _type instanceof NodeSetType || _type instanceof ResultTreeType ) { typeCheckContents ( stable ) ; return Type . Void ; } throw new TypeCheckError ( this ) ; } else { typeCheckContents ( stable ) ; return Type . Void ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { boolean setStartNodeCalled = false ; final Stylesheet stylesheet = classGen . getStylesheet ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; final Vector sortObjects = new Vector ( ) ; final Enumeration children = elements ( ) ; while ( children . hasMoreElements ( ) ) { final Object child = children . nextElement ( ) ; if ( child instanceof Sort ) { sortObjects . addElement ( child ) ; } } if ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) { il . append ( classGen . loadTranslet ( ) ) ; final int pushFrame = cpg . addMethodref ( TRANSLET_CLASS , PUSH_PARAM_FRAME , PUSH_PARAM_FRAME_SIG ) ; il . append ( new INVOKEVIRTUAL ( pushFrame ) ) ; translateContents ( classGen , methodGen ) ; } il . append ( classGen . loadTranslet ( ) ) ; if ( ( _type != null ) && ( _type instanceof ResultTreeType ) ) { if ( sortObjects . size ( ) > 0 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . RESULT_TREE_SORT_ERR , this ) ; getParser ( ) . reportError ( WARNING , err ) ; } _select . translate ( classGen , methodGen ) ; _type . translateTo ( classGen , methodGen , Type . NodeSet ) ; } else { il . append ( methodGen . loadDOM ( ) ) ; if ( sortObjects . size ( ) > 0 ) { Sort . translateSortIterator ( classGen , methodGen , _select , sortObjects ) ; int setStartNode = cpg . addInterfaceMethodref ( NODE_ITERATOR , SET_START_NODE , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( setStartNode , 2 ) ) ; setStartNodeCalled = true ; } else { if ( _select == null ) Mode . compileGetChildren ( classGen , methodGen , current ) ; else _select . translate ( classGen , methodGen ) ; } } if ( _select != null && ! setStartNodeCalled ) { _select . startResetIterator ( classGen , methodGen ) ; } final String className = classGen . getStylesheet ( ) . getClassName ( ) ; il . append ( methodGen . loadHandler ( ) ) ; final String applyTemplatesSig = classGen . getApplyTemplatesSig ( ) ; final int applyTemplates = cpg . addMethodref ( className , _functionName , applyTemplatesSig ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; if ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) { il . append ( classGen . loadTranslet ( ) ) ; final int popFrame = cpg . addMethodref ( TRANSLET_CLASS , POP_PARAM_FRAME , POP_PARAM_FRAME_SIG ) ; il . append ( new INVOKEVIRTUAL ( popFrame ) ) ; } } } 	1	['6', '3', '0', '27', '62', '0', '2', '27', '5', '0.65', '379', '1', '3', '0.918032787', '0.305555556', '1', '6', '61.5', '13', '3.3333', '1']
package org . apache . xpath . compiler ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . XPathProcessorException ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; public class XPathParser { static public final String CONTINUE_AFTER_FATAL_ERROR = "CONTINUE_AFTER_FATAL_ERROR" ; private OpMap m_ops ; transient String m_token ; transient char m_tokenChar = 0 ; int m_queueMark = 0 ; protected final static int FILTER_MATCH_FAILED = 0 ; protected final static int FILTER_MATCH_PRIMARY = 1 ; protected final static int FILTER_MATCH_PREDICATES = 2 ; public XPathParser ( ErrorListener errorListener , javax . xml . transform . SourceLocator sourceLocator ) { m_errorListener = errorListener ; m_sourceLocator = sourceLocator ; } PrefixResolver m_namespaceContext ; public void initXPath ( Compiler compiler , String expression , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { m_ops = compiler ; m_namespaceContext = namespaceContext ; Lexer lexer = new Lexer ( compiler , namespaceContext , this ) ; lexer . tokenize ( expression ) ; m_ops . setOp ( 0 , OpCodes . OP_XPATH ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , 2 ) ; try { nextToken ( ) ; Expr ( ) ; if ( null != m_token ) { String extraTokens = "" ; while ( null != m_token ) { extraTokens += "'" + m_token + "'" ; nextToken ( ) ; if ( null != m_token ) extraTokens += ", " ; } error ( XPATHErrorResources . ER_EXTRA_ILLEGAL_TOKENS , new Object [ ] { extraTokens } ) ; } } catch ( org . apache . xpath . XPathProcessorException e ) { if ( CONTINUE_AFTER_FATAL_ERROR . equals ( e . getMessage ( ) ) ) { initXPath ( compiler , "/.." , namespaceContext ) ; } else throw e ; } compiler . shrink ( ) ; } public void initMatchPattern ( Compiler compiler , String expression , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { m_ops = compiler ; m_namespaceContext = namespaceContext ; Lexer lexer = new Lexer ( compiler , namespaceContext , this ) ; lexer . tokenize ( expression ) ; m_ops . setOp ( 0 , OpCodes . OP_MATCHPATTERN ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , 2 ) ; nextToken ( ) ; Pattern ( ) ; if ( null != m_token ) { String extraTokens = "" ; while ( null != m_token ) { extraTokens += "'" + m_token + "'" ; nextToken ( ) ; if ( null != m_token ) extraTokens += ", " ; } error ( XPATHErrorResources . ER_EXTRA_ILLEGAL_TOKENS , new Object [ ] { extraTokens } ) ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . shrink ( ) ; } private ErrorListener m_errorListener ; javax . xml . transform . SourceLocator m_sourceLocator ; public void setErrorHandler ( ErrorListener handler ) { m_errorListener = handler ; } public ErrorListener getErrorListener ( ) { return m_errorListener ; } final boolean tokenIs ( String s ) { return ( m_token != null ) ? ( m_token . equals ( s ) ) : ( s == null ) ; } final boolean tokenIs ( char c ) { return ( m_token != null ) ? ( m_tokenChar == c ) : false ; } final boolean lookahead ( char c , int n ) { int pos = ( m_queueMark + n ) ; boolean b ; if ( ( pos <= m_ops . getTokenQueueSize ( ) ) && ( pos > 0 ) && ( m_ops . getTokenQueueSize ( ) != 0 ) ) { String tok = ( ( String ) m_ops . m_tokenQueue . elementAt ( pos - 1 ) ) ; b = ( tok . length ( ) == 1 ) ? ( tok . charAt ( 0 ) == c ) : false ; } else { b = false ; } return b ; } private final boolean lookbehind ( char c , int n ) { boolean isToken ; int lookBehindPos = m_queueMark - ( n + 1 ) ; if ( lookBehindPos >= 0 ) { String lookbehind = ( String ) m_ops . m_tokenQueue . elementAt ( lookBehindPos ) ; if ( lookbehind . length ( ) == 1 ) { char c0 = ( lookbehind == null ) ? '|' : lookbehind . charAt ( 0 ) ; isToken = ( c0 == '|' ) ? false : ( c0 == c ) ; } else { isToken = false ; } } else { isToken = false ; } return isToken ; } private final boolean lookbehindHasToken ( int n ) { boolean hasToken ; if ( ( m_queueMark - n ) > 0 ) { String lookbehind = ( String ) m_ops . m_tokenQueue . elementAt ( m_queueMark - ( n - 1 ) ) ; char c0 = ( lookbehind == null ) ? '|' : lookbehind . charAt ( 0 ) ; hasToken = ( c0 == '|' ) ? false : true ; } else { hasToken = false ; } return hasToken ; } private final boolean lookahead ( String s , int n ) { boolean isToken ; if ( ( m_queueMark + n ) <= m_ops . getTokenQueueSize ( ) ) { String lookahead = ( String ) m_ops . m_tokenQueue . elementAt ( m_queueMark + ( n - 1 ) ) ; isToken = ( lookahead != null ) ? lookahead . equals ( s ) : ( s == null ) ; } else { isToken = ( null == s ) ; } return isToken ; } private final void nextToken ( ) { if ( m_queueMark < m_ops . getTokenQueueSize ( ) ) { m_token = ( String ) m_ops . m_tokenQueue . elementAt ( m_queueMark ++ ) ; m_tokenChar = m_token . charAt ( 0 ) ; } else { m_token = null ; m_tokenChar = 0 ; } } private final String getTokenRelative ( int i ) { String tok ; int relative = m_queueMark + i ; if ( ( relative > 0 ) && ( relative < m_ops . getTokenQueueSize ( ) ) ) { tok = ( String ) m_ops . m_tokenQueue . elementAt ( relative ) ; } else { tok = null ; } return tok ; } private final void prevToken ( ) { if ( m_queueMark > 0 ) { m_queueMark -- ; m_token = ( String ) m_ops . m_tokenQueue . elementAt ( m_queueMark ) ; m_tokenChar = m_token . charAt ( 0 ) ; } else { m_token = null ; m_tokenChar = 0 ; } } private final void consumeExpected ( String expected ) throws javax . xml . transform . TransformerException { if ( tokenIs ( expected ) ) { nextToken ( ) ; } else { error ( XPATHErrorResources . ER_EXPECTED_BUT_FOUND , new Object [ ] { expected , m_token } ) ; throw new XPathProcessorException ( CONTINUE_AFTER_FATAL_ERROR ) ; } } private final void consumeExpected ( char expected ) throws javax . xml . transform . TransformerException { if ( tokenIs ( expected ) ) { nextToken ( ) ; } else { error ( XPATHErrorResources . ER_EXPECTED_BUT_FOUND , new Object [ ] { String . valueOf ( expected ) , m_token } ) ; throw new XPathProcessorException ( CONTINUE_AFTER_FATAL_ERROR ) ; } } void warn ( String msg , Object [ ] args ) throws TransformerException { String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; ErrorListener ehandler = this . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . warning ( new TransformerException ( fmsg , m_sourceLocator ) ) ; } else { System . err . println ( fmsg ) ; } } private void assertion ( boolean b , String msg ) { if ( ! b ) { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } void error ( String msg , Object [ ] args ) throws TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; ErrorListener ehandler = this . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , m_sourceLocator ) ; if ( null != ehandler ) { ehandler . fatalError ( te ) ; } else { throw te ; } } protected String dumpRemainingTokenQueue ( ) { int q = m_queueMark ; String returnMsg ; if ( q < m_ops . getTokenQueueSize ( ) ) { String msg = "\n Remaining tokens: (" ; while ( q < m_ops . getTokenQueueSize ( ) ) { String t = ( String ) m_ops . m_tokenQueue . elementAt ( q ++ ) ; msg += ( " '" + t + "'" ) ; } returnMsg = msg + ")" ; } else { returnMsg = "" ; } return returnMsg ; } final int getFunctionToken ( String key ) { int tok ; try { tok = ( ( Integer ) ( Keywords . m_functions . get ( key ) ) ) . intValue ( ) ; } catch ( NullPointerException npe ) { tok = - 1 ; } catch ( ClassCastException cce ) { tok = - 1 ; } return tok ; } void insertOp ( int pos , int length , int op ) { int totalLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; for ( int i = totalLen - 1 ; i >= pos ; i -- ) { m_ops . setOp ( i + length , m_ops . getOp ( i ) ) ; } m_ops . setOp ( pos , op ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , totalLen + length ) ; } void appendOp ( int length , int op ) { int totalLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; m_ops . setOp ( totalLen , op ) ; m_ops . setOp ( totalLen + OpMap . MAPINDEX_LENGTH , length ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , totalLen + length ) ; } protected void Expr ( ) throws javax . xml . transform . TransformerException { OrExpr ( ) ; } protected void OrExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; AndExpr ( ) ; if ( ( null != m_token ) && tokenIs ( "or" ) ) { nextToken ( ) ; insertOp ( opPos , 2 , OpCodes . OP_OR ) ; OrExpr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } } protected void AndExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; EqualityExpr ( - 1 ) ; if ( ( null != m_token ) && tokenIs ( "and" ) ) { nextToken ( ) ; insertOp ( opPos , 2 , OpCodes . OP_AND ) ; AndExpr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } } protected int EqualityExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( - 1 == addPos ) addPos = opPos ; RelationalExpr ( - 1 ) ; if ( null != m_token ) { if ( tokenIs ( '!' ) && lookahead ( '=' , 1 ) ) { nextToken ( ) ; nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_NOTEQUALS ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = EqualityExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( '=' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_EQUALS ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = EqualityExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } } return addPos ; } protected int RelationalExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( - 1 == addPos ) addPos = opPos ; AdditiveExpr ( - 1 ) ; if ( null != m_token ) { if ( tokenIs ( '<' ) ) { nextToken ( ) ; if ( tokenIs ( '=' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_LTE ) ; } else { insertOp ( addPos , 2 , OpCodes . OP_LT ) ; } int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = RelationalExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( '>' ) ) { nextToken ( ) ; if ( tokenIs ( '=' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_GTE ) ; } else { insertOp ( addPos , 2 , OpCodes . OP_GT ) ; } int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = RelationalExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } } return addPos ; } protected int AdditiveExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( - 1 == addPos ) addPos = opPos ; MultiplicativeExpr ( - 1 ) ; if ( null != m_token ) { if ( tokenIs ( '+' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_PLUS ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = AdditiveExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( '-' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_MINUS ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = AdditiveExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } } return addPos ; } protected int MultiplicativeExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( - 1 == addPos ) addPos = opPos ; UnaryExpr ( ) ; if ( null != m_token ) { if ( tokenIs ( '*' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_MULT ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( "div" ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_DIV ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( "mod" ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_MOD ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( "quo" ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_QUO ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } } return addPos ; } protected void UnaryExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; boolean isNeg = false ; if ( m_tokenChar == '-' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_NEG ) ; isNeg = true ; } UnionExpr ( ) ; if ( isNeg ) m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void StringExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_STRING ) ; Expr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void BooleanExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_BOOL ) ; Expr ( ) ; int opLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ; if ( opLen == 2 ) { error ( XPATHErrorResources . ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , null ) ; } m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , opLen ) ; } protected void NumberExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_NUMBER ) ; Expr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void UnionExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; boolean continueOrLoop = true ; boolean foundUnion = false ; do { PathExpr ( ) ; if ( tokenIs ( '|' ) ) { if ( false == foundUnion ) { foundUnion = true ; insertOp ( opPos , 2 , OpCodes . OP_UNION ) ; } nextToken ( ) ; } else { break ; } } while ( continueOrLoop ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void PathExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; int filterExprMatch = FilterExpr ( ) ; if ( filterExprMatch != FILTER_MATCH_FAILED ) { boolean locationPathStarted = ( filterExprMatch == FILTER_MATCH_PREDICATES ) ; if ( tokenIs ( '/' ) ) { nextToken ( ) ; if ( ! locationPathStarted ) { insertOp ( opPos , 2 , OpCodes . OP_LOCATIONPATH ) ; locationPathStarted = true ; } if ( ! RelativeLocationPath ( ) ) { error ( XPATHErrorResources . ER_EXPECTED_REL_LOC_PATH , null ) ; } } if ( locationPathStarted ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } } else { LocationPath ( ) ; } } protected int FilterExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; int filterMatch ; if ( PrimaryExpr ( ) ) { if ( tokenIs ( '[' ) ) { insertOp ( opPos , 2 , OpCodes . OP_LOCATIONPATH ) ; while ( tokenIs ( '[' ) ) { Predicate ( ) ; } filterMatch = FILTER_MATCH_PREDICATES ; } else { filterMatch = FILTER_MATCH_PRIMARY ; } } else { filterMatch = FILTER_MATCH_FAILED ; } return filterMatch ; } protected boolean PrimaryExpr ( ) throws javax . xml . transform . TransformerException { boolean matchFound ; int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( ( m_tokenChar == '\'' ) || ( m_tokenChar == '"' ) ) { appendOp ( 2 , OpCodes . OP_LITERAL ) ; Literal ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; matchFound = true ; } else if ( m_tokenChar == '$' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_VARIABLE ) ; QName ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; matchFound = true ; } else if ( m_tokenChar == '(' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_GROUP ) ; Expr ( ) ; consumeExpected ( ')' ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; matchFound = true ; } else if ( ( null != m_token ) && ( ( ( '.' == m_tokenChar ) && ( m_token . length ( ) > 1 ) && Character . isDigit ( m_token . charAt ( 1 ) ) ) || Character . isDigit ( m_tokenChar ) ) ) { appendOp ( 2 , OpCodes . OP_NUMBERLIT ) ; Number ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; matchFound = true ; } else if ( lookahead ( '(' , 1 ) || ( lookahead ( ':' , 1 ) && lookahead ( '(' , 3 ) ) ) { matchFound = FunctionCall ( ) ; } else { matchFound = false ; } return matchFound ; } protected void Argument ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_ARGUMENT ) ; Expr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected boolean FunctionCall ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( lookahead ( ':' , 1 ) ) { appendOp ( 4 , OpCodes . OP_EXTFUNCTION ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , m_queueMark - 1 ) ; nextToken ( ) ; consumeExpected ( ':' ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 2 , m_queueMark - 1 ) ; nextToken ( ) ; } else { int funcTok = getFunctionToken ( m_token ) ; if ( - 1 == funcTok ) { error ( XPATHErrorResources . ER_COULDNOT_FIND_FUNCTION , new Object [ ] { m_token } ) ; } switch ( funcTok ) { case OpCodes . NODETYPE_PI : case OpCodes . NODETYPE_COMMENT : case OpCodes . NODETYPE_TEXT : case OpCodes . NODETYPE_NODE : return false ; default : appendOp ( 3 , OpCodes . OP_FUNCTION ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , funcTok ) ; } nextToken ( ) ; } consumeExpected ( '(' ) ; while ( ! tokenIs ( ')' ) && m_token != null ) { if ( tokenIs ( ',' ) ) { error ( XPATHErrorResources . ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , null ) ; } Argument ( ) ; if ( ! tokenIs ( ')' ) ) { consumeExpected ( ',' ) ; if ( tokenIs ( ')' ) ) { error ( XPATHErrorResources . ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , null ) ; } } } consumeExpected ( ')' ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; return true ; } protected void LocationPath ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_LOCATIONPATH ) ; boolean seenSlash = tokenIs ( '/' ) ; if ( seenSlash ) { appendOp ( 4 , OpCodes . FROM_ROOT ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_ROOT ) ; nextToken ( ) ; } if ( m_token != null ) { if ( ! RelativeLocationPath ( ) && ! seenSlash ) { error ( XPATHErrorResources . ER_EXPECTED_LOC_PATH , new Object [ ] { m_token } ) ; } } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected boolean RelativeLocationPath ( ) throws javax . xml . transform . TransformerException { if ( ! Step ( ) ) { return false ; } while ( tokenIs ( '/' ) ) { nextToken ( ) ; if ( ! Step ( ) ) { error ( XPATHErrorResources . ER_EXPECTED_LOC_STEP , null ) ; } } return true ; } protected boolean Step ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; boolean doubleSlash = tokenIs ( '/' ) ; if ( doubleSlash ) { nextToken ( ) ; appendOp ( 2 , OpCodes . FROM_DESCENDANTS_OR_SELF ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . NODETYPE_NODE ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; } if ( tokenIs ( "." ) ) { nextToken ( ) ; if ( tokenIs ( '[' ) ) { error ( XPATHErrorResources . ER_PREDICATE_ILLEGAL_SYNTAX , null ) ; } appendOp ( 4 , OpCodes . FROM_SELF ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_NODE ) ; } else if ( tokenIs ( ".." ) ) { nextToken ( ) ; appendOp ( 4 , OpCodes . FROM_PARENT ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_NODE ) ; } else if ( tokenIs ( '*' ) || tokenIs ( '@' ) || tokenIs ( '_' ) || ( m_token != null && Character . isLetter ( m_token . charAt ( 0 ) ) ) ) { Basis ( ) ; while ( tokenIs ( '[' ) ) { Predicate ( ) ; } m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } else { if ( doubleSlash ) { error ( XPATHErrorResources . ER_EXPECTED_LOC_STEP , null ) ; } return false ; } return true ; } protected void Basis ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; int axesType ; if ( lookahead ( "::" , 1 ) ) { axesType = AxisName ( ) ; nextToken ( ) ; nextToken ( ) ; } else if ( tokenIs ( '@' ) ) { axesType = OpCodes . FROM_ATTRIBUTES ; appendOp ( 2 , axesType ) ; nextToken ( ) ; } else { axesType = OpCodes . FROM_CHILDREN ; appendOp ( 2 , axesType ) ; } m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; NodeTest ( axesType ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected int AxisName ( ) throws javax . xml . transform . TransformerException { Object val = Keywords . m_axisnames . get ( m_token ) ; if ( null == val ) { error ( XPATHErrorResources . ER_ILLEGAL_AXIS_NAME , new Object [ ] { m_token } ) ; } int axesType = ( ( Integer ) val ) . intValue ( ) ; appendOp ( 2 , axesType ) ; return axesType ; } protected void NodeTest ( int axesType ) throws javax . xml . transform . TransformerException { if ( lookahead ( '(' , 1 ) ) { Object nodeTestOp = Keywords . m_nodetypes . get ( m_token ) ; if ( null == nodeTestOp ) { error ( XPATHErrorResources . ER_UNKNOWN_NODETYPE , new Object [ ] { m_token } ) ; } else { nextToken ( ) ; int nt = ( ( Integer ) nodeTestOp ) . intValue ( ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , nt ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; consumeExpected ( '(' ) ; if ( OpCodes . NODETYPE_PI == nt ) { if ( ! tokenIs ( ')' ) ) { Literal ( ) ; } } consumeExpected ( ')' ) ; } } else { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . NODENAME ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; if ( lookahead ( ':' , 1 ) ) { if ( tokenIs ( '*' ) ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ELEMWILDCARD ) ; } else { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; if ( ! Character . isLetter ( m_tokenChar ) && ! tokenIs ( '_' ) ) { error ( XPATHErrorResources . ER_EXPECTED_NODE_TEST , null ) ; } } nextToken ( ) ; consumeExpected ( ':' ) ; } else { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . EMPTY ) ; } m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; if ( tokenIs ( '*' ) ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ELEMWILDCARD ) ; } else { if ( OpCodes . FROM_NAMESPACE == axesType ) { String prefix = ( String ) this . m_ops . m_tokenQueue . elementAt ( m_queueMark - 1 ) ; String namespace = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; this . m_ops . m_tokenQueue . setElementAt ( namespace , m_queueMark - 1 ) ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; if ( ! Character . isLetter ( m_tokenChar ) && ! tokenIs ( '_' ) ) { error ( XPATHErrorResources . ER_EXPECTED_NODE_TEST , null ) ; } } m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } } protected void Predicate ( ) throws javax . xml . transform . TransformerException { if ( tokenIs ( '[' ) ) { nextToken ( ) ; PredicateExpr ( ) ; consumeExpected ( ']' ) ; } } protected void PredicateExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_PREDICATE ) ; Expr ( ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void QName ( ) throws javax . xml . transform . TransformerException { if ( lookahead ( ':' , 1 ) ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; consumeExpected ( ':' ) ; } else { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . EMPTY ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } protected void NCName ( ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } protected void Literal ( ) throws javax . xml . transform . TransformerException { int last = m_token . length ( ) - 1 ; char c0 = m_tokenChar ; char cX = m_token . charAt ( last ) ; if ( ( ( c0 == '\"' ) && ( cX == '\"' ) ) || ( ( c0 == '\'' ) && ( cX == '\'' ) ) ) { int tokenQueuePos = m_queueMark - 1 ; m_ops . m_tokenQueue . setElementAt ( null , tokenQueuePos ) ; Object obj = new XString ( m_token . substring ( 1 , last ) ) ; m_ops . m_tokenQueue . setElementAt ( obj , tokenQueuePos ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , tokenQueuePos ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } else { error ( XPATHErrorResources . ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , new Object [ ] { m_token } ) ; } } protected void Number ( ) throws javax . xml . transform . TransformerException { if ( null != m_token ) { double num ; try { num = Double . valueOf ( m_token ) . doubleValue ( ) ; } catch ( NumberFormatException nfe ) { num = 0.0 ; error ( XPATHErrorResources . ER_COULDNOT_BE_FORMATTED_TO_NUMBER , new Object [ ] { m_token } ) ; } m_ops . m_tokenQueue . setElementAt ( new XNumber ( num ) , m_queueMark - 1 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } } protected void Pattern ( ) throws javax . xml . transform . TransformerException { while ( true ) { LocationPathPattern ( ) ; if ( tokenIs ( '|' ) ) { nextToken ( ) ; } else { break ; } } } protected void LocationPathPattern ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; final int RELATIVE_PATH_NOT_PERMITTED = 0 ; final int RELATIVE_PATH_PERMITTED = 1 ; final int RELATIVE_PATH_REQUIRED = 2 ; int relativePathStatus = RELATIVE_PATH_NOT_PERMITTED ; appendOp ( 2 , OpCodes . OP_LOCATIONPATHPATTERN ) ; if ( lookahead ( '(' , 1 ) && ( tokenIs ( Keywords . FUNC_ID_STRING ) || tokenIs ( Keywords . FUNC_KEY_STRING ) ) ) { IdKeyPattern ( ) ; if ( tokenIs ( '/' ) ) { nextToken ( ) ; if ( tokenIs ( '/' ) ) { appendOp ( 4 , OpCodes . MATCH_ANY_ANCESTOR ) ; nextToken ( ) ; } else { appendOp ( 4 , OpCodes . MATCH_IMMEDIATE_ANCESTOR ) ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_FUNCTEST ) ; relativePathStatus = RELATIVE_PATH_REQUIRED ; } } else if ( tokenIs ( '/' ) ) { if ( lookahead ( '/' , 1 ) ) { appendOp ( 4 , OpCodes . MATCH_ANY_ANCESTOR ) ; nextToken ( ) ; relativePathStatus = RELATIVE_PATH_REQUIRED ; } else { appendOp ( 4 , OpCodes . FROM_ROOT ) ; relativePathStatus = RELATIVE_PATH_PERMITTED ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_ROOT ) ; nextToken ( ) ; } else { relativePathStatus = RELATIVE_PATH_REQUIRED ; } if ( relativePathStatus != RELATIVE_PATH_NOT_PERMITTED ) { if ( ! tokenIs ( '|' ) && ( null != m_token ) ) { RelativePathPattern ( ) ; } else if ( relativePathStatus == RELATIVE_PATH_REQUIRED ) { error ( XPATHErrorResources . ER_EXPECTED_REL_PATH_PATTERN , null ) ; } } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void IdKeyPattern ( ) throws javax . xml . transform . TransformerException { FunctionCall ( ) ; } protected void RelativePathPattern ( ) throws javax . xml . transform . TransformerException { boolean trailingSlashConsumed = StepPattern ( false ) ; while ( tokenIs ( '/' ) ) { nextToken ( ) ; trailingSlashConsumed = StepPattern ( ! trailingSlashConsumed ) ; } } protected boolean StepPattern ( boolean isLeadingSlashPermitted ) throws javax . xml . transform . TransformerException { return AbbreviatedNodeTestStep ( isLeadingSlashPermitted ) ; } protected boolean AbbreviatedNodeTestStep ( boolean isLeadingSlashPermitted ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; int axesType ; int matchTypePos = - 1 ; if ( tokenIs ( '@' ) ) { axesType = OpCodes . MATCH_ATTRIBUTE ; appendOp ( 2 , axesType ) ; nextToken ( ) ; } else if ( this . lookahead ( "::" , 1 ) ) { if ( tokenIs ( "attribute" ) ) { axesType = OpCodes . MATCH_ATTRIBUTE ; appendOp ( 2 , axesType ) ; } else if ( tokenIs ( "child" ) ) { matchTypePos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; axesType = OpCodes . MATCH_IMMEDIATE_ANCESTOR ; appendOp ( 2 , axesType ) ; } else { axesType = - 1 ; this . error ( XPATHErrorResources . ER_AXES_NOT_ALLOWED , new Object [ ] { this . m_token } ) ; } nextToken ( ) ; nextToken ( ) ; } else if ( tokenIs ( '/' ) ) { if ( ! isLeadingSlashPermitted ) { error ( XPATHErrorResources . ER_EXPECTED_STEP_PATTERN , null ) ; } axesType = OpCodes . MATCH_ANY_ANCESTOR ; appendOp ( 2 , axesType ) ; nextToken ( ) ; } else { matchTypePos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; axesType = OpCodes . MATCH_IMMEDIATE_ANCESTOR ; appendOp ( 2 , axesType ) ; } m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; NodeTest ( axesType ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; while ( tokenIs ( '[' ) ) { Predicate ( ) ; } boolean trailingSlashConsumed ; if ( ( matchTypePos > - 1 ) && tokenIs ( '/' ) && lookahead ( '/' , 1 ) ) { m_ops . setOp ( matchTypePos , OpCodes . MATCH_ANY_ANCESTOR ) ; nextToken ( ) ; trailingSlashConsumed = true ; } else { trailingSlashConsumed = false ; } m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; return trailingSlashConsumed ; } } 	1	['58', '1', '0', '13', '94', '0', '4', '10', '5', '0.679425837', '3321', '0.454545455', '2', '0', '0.163793103', '0', '0', '56.06896552', '6', '1.4828', '2']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; public class FunctionOneArg extends Function implements ExpressionOwner { Expression m_arg0 ; public Expression getArg0 ( ) { return m_arg0 ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( 0 == argNum ) { m_arg0 = arg ; arg . exprSetParent ( this ) ; } else reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 1 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "one" , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return m_arg0 . canTraverseOutsideSubtree ( ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { if ( null != m_arg0 ) m_arg0 . fixupVariables ( vars , globalsSize ) ; } public void callArgVisitors ( XPathVisitor visitor ) { if ( null != m_arg0 ) m_arg0 . callVisitors ( this , visitor ) ; } public Expression getExpression ( ) { return m_arg0 ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_arg0 = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( null != m_arg0 ) { if ( null == ( ( FunctionOneArg ) expr ) . m_arg0 ) return false ; if ( ! m_arg0 . deepEquals ( ( ( FunctionOneArg ) expr ) . m_arg0 ) ) return false ; } else if ( null != ( ( FunctionOneArg ) expr ) . m_arg0 ) return false ; return true ; } } 	1	['11', '3', '15', '22', '20', '0', '15', '7', '10', '0.3', '113', '0', '1', '0.791666667', '0.345454545', '2', '4', '9.181818182', '6', '1.5455', '1']
package org . apache . xalan . transformer ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . ref . DTMTreeWalker ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . XPathContext ; public class TreeWalker2Result extends DTMTreeWalker { TransformerImpl m_transformer ; SerializationHandler m_handler ; int m_startNode ; public TreeWalker2Result ( TransformerImpl transformer , SerializationHandler handler ) { super ( handler , null ) ; m_transformer = transformer ; m_handler = handler ; } public void traverse ( int pos ) throws org . xml . sax . SAXException { m_dtm = m_transformer . getXPathContext ( ) . getDTM ( pos ) ; m_startNode = pos ; super . traverse ( pos ) ; } protected void endNode ( int node ) throws org . xml . sax . SAXException { super . endNode ( node ) ; if ( DTM . ELEMENT_NODE == m_dtm . getNodeType ( node ) ) { m_transformer . getXPathContext ( ) . popCurrentNode ( ) ; } } protected void startNode ( int node ) throws org . xml . sax . SAXException { XPathContext xcntxt = m_transformer . getXPathContext ( ) ; try { if ( DTM . ELEMENT_NODE == m_dtm . getNodeType ( node ) ) { xcntxt . pushCurrentNode ( node ) ; if ( m_startNode != node ) { super . startNode ( node ) ; } else { String elemName = m_dtm . getNodeName ( node ) ; String localName = m_dtm . getLocalName ( node ) ; String namespace = m_dtm . getNamespaceURI ( node ) ; m_handler . startElement ( namespace , localName , elemName ) ; boolean hasNSDecls = false ; DTM dtm = m_dtm ; for ( int ns = dtm . getFirstNamespaceNode ( node , true ) ; DTM . NULL != ns ; ns = dtm . getNextNamespaceNode ( node , ns , true ) ) { SerializerUtils . ensureNamespaceDeclDeclared ( m_handler , dtm , ns ) ; } for ( int attr = dtm . getFirstAttribute ( node ) ; DTM . NULL != attr ; attr = dtm . getNextAttribute ( attr ) ) { SerializerUtils . addAttribute ( m_handler , attr ) ; } } } else { xcntxt . pushCurrentNode ( node ) ; super . startNode ( node ) ; xcntxt . popCurrentNode ( ) ; } } catch ( javax . xml . transform . TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } } 	1	['4', '2', '0', '7', '24', '0', '1', '6', '2', '0.444444444', '146', '0', '2', '0.727272727', '0.5625', '1', '4', '34.75', '1', '0.75', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . AttributeList ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . utils . XMLString ; import org . apache . xml . serializer . SerializationHandler ; import javax . xml . transform . SourceLocator ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class AdaptiveResultTreeImpl extends SimpleResultTreeImpl { private static int _documentURIIndex = 0 ; private SAXImpl _dom ; private DTMWSFilter _wsfilter ; private int _initSize ; private boolean _buildIdIndex ; private final AttributeList _attributes = new AttributeList ( ) ; private String _openElementName ; public AdaptiveResultTreeImpl ( XSLTCDTMManager dtmManager , int documentID , DTMWSFilter wsfilter , int initSize , boolean buildIdIndex ) { super ( dtmManager , documentID ) ; _wsfilter = wsfilter ; _initSize = initSize ; _buildIdIndex = buildIdIndex ; } public DOM getNestedDOM ( ) { return _dom ; } public int getDocument ( ) { if ( _dom != null ) { return _dom . getDocument ( ) ; } else { return super . getDocument ( ) ; } } public String getStringValue ( ) { if ( _dom != null ) { return _dom . getStringValue ( ) ; } else { return super . getStringValue ( ) ; } } public DTMAxisIterator getIterator ( ) { if ( _dom != null ) { return _dom . getIterator ( ) ; } else { return super . getIterator ( ) ; } } public DTMAxisIterator getChildren ( final int node ) { if ( _dom != null ) { return _dom . getChildren ( node ) ; } else { return super . getChildren ( node ) ; } } public DTMAxisIterator getTypedChildren ( final int type ) { if ( _dom != null ) { return _dom . getTypedChildren ( type ) ; } else { return super . getTypedChildren ( type ) ; } } public DTMAxisIterator getAxisIterator ( final int axis ) { if ( _dom != null ) { return _dom . getAxisIterator ( axis ) ; } else { return super . getAxisIterator ( axis ) ; } } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { if ( _dom != null ) { return _dom . getTypedAxisIterator ( axis , type ) ; } else { return super . getTypedAxisIterator ( axis , type ) ; } } public DTMAxisIterator getNthDescendant ( int node , int n , boolean includeself ) { if ( _dom != null ) { return _dom . getNthDescendant ( node , n , includeself ) ; } else { return super . getNthDescendant ( node , n , includeself ) ; } } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { if ( _dom != null ) { return _dom . getNamespaceAxisIterator ( axis , ns ) ; } else { return super . getNamespaceAxisIterator ( axis , ns ) ; } } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iter , int returnType , String value , boolean op ) { if ( _dom != null ) { return _dom . getNodeValueIterator ( iter , returnType , value , op ) ; } else { return super . getNodeValueIterator ( iter , returnType , value , op ) ; } } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { if ( _dom != null ) { return _dom . orderNodes ( source , node ) ; } else { return super . orderNodes ( source , node ) ; } } public String getNodeName ( final int node ) { if ( _dom != null ) { return _dom . getNodeName ( node ) ; } else { return super . getNodeName ( node ) ; } } public String getNodeNameX ( final int node ) { if ( _dom != null ) { return _dom . getNodeNameX ( node ) ; } else { return super . getNodeNameX ( node ) ; } } public String getNamespaceName ( final int node ) { if ( _dom != null ) { return _dom . getNamespaceName ( node ) ; } else { return super . getNamespaceName ( node ) ; } } public int getExpandedTypeID ( final int nodeHandle ) { if ( _dom != null ) { return _dom . getExpandedTypeID ( nodeHandle ) ; } else { return super . getExpandedTypeID ( nodeHandle ) ; } } public int getNamespaceType ( final int node ) { if ( _dom != null ) { return _dom . getNamespaceType ( node ) ; } else { return super . getNamespaceType ( node ) ; } } public int getParent ( final int nodeHandle ) { if ( _dom != null ) { return _dom . getParent ( nodeHandle ) ; } else { return super . getParent ( nodeHandle ) ; } } public int getAttributeNode ( final int gType , final int element ) { if ( _dom != null ) { return _dom . getAttributeNode ( gType , element ) ; } else { return super . getAttributeNode ( gType , element ) ; } } public String getStringValueX ( final int nodeHandle ) { if ( _dom != null ) { return _dom . getStringValueX ( nodeHandle ) ; } else { return super . getStringValueX ( nodeHandle ) ; } } public void copy ( final int node , SerializationHandler handler ) throws TransletException { if ( _dom != null ) { _dom . copy ( node , handler ) ; } else { super . copy ( node , handler ) ; } } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { if ( _dom != null ) { _dom . copy ( nodes , handler ) ; } else { super . copy ( nodes , handler ) ; } } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { if ( _dom != null ) { return _dom . shallowCopy ( node , handler ) ; } else { return super . shallowCopy ( node , handler ) ; } } public boolean lessThan ( final int node1 , final int node2 ) { if ( _dom != null ) { return _dom . lessThan ( node1 , node2 ) ; } else { return super . lessThan ( node1 , node2 ) ; } } public void characters ( final int node , SerializationHandler handler ) throws TransletException { if ( _dom != null ) { _dom . characters ( node , handler ) ; } else { super . characters ( node , handler ) ; } } public Node makeNode ( int index ) { if ( _dom != null ) { return _dom . makeNode ( index ) ; } else { return super . makeNode ( index ) ; } } public Node makeNode ( DTMAxisIterator iter ) { if ( _dom != null ) { return _dom . makeNode ( iter ) ; } else { return super . makeNode ( iter ) ; } } public NodeList makeNodeList ( int index ) { if ( _dom != null ) { return _dom . makeNodeList ( index ) ; } else { return super . makeNodeList ( index ) ; } } public NodeList makeNodeList ( DTMAxisIterator iter ) { if ( _dom != null ) { return _dom . makeNodeList ( iter ) ; } else { return super . makeNodeList ( iter ) ; } } public String getLanguage ( int node ) { if ( _dom != null ) { return _dom . getLanguage ( node ) ; } else { return super . getLanguage ( node ) ; } } public int getSize ( ) { if ( _dom != null ) { return _dom . getSize ( ) ; } else { return super . getSize ( ) ; } } public String getDocumentURI ( int node ) { if ( _dom != null ) { return _dom . getDocumentURI ( node ) ; } else { return "adaptive_rtf" + _documentURIIndex ++ ; } } public void setFilter ( StripFilter filter ) { if ( _dom != null ) { _dom . setFilter ( filter ) ; } else { super . setFilter ( filter ) ; } } public void setupMapping ( String [ ] names , String [ ] namespaces ) { if ( _dom != null ) { _dom . setupMapping ( names , namespaces ) ; } else { super . setupMapping ( names , namespaces ) ; } } public boolean isElement ( final int node ) { if ( _dom != null ) { return _dom . isElement ( node ) ; } else { return super . isElement ( node ) ; } } public boolean isAttribute ( final int node ) { if ( _dom != null ) { return _dom . isAttribute ( node ) ; } else { return super . isAttribute ( node ) ; } } public String lookupNamespace ( int node , String prefix ) throws TransletException { if ( _dom != null ) { return _dom . lookupNamespace ( node , prefix ) ; } else { return super . lookupNamespace ( node , prefix ) ; } } public final int getNodeIdent ( final int nodehandle ) { if ( _dom != null ) { return _dom . getNodeIdent ( nodehandle ) ; } else { return super . getNodeIdent ( nodehandle ) ; } } public final int getNodeHandle ( final int nodeId ) { if ( _dom != null ) { return _dom . getNodeHandle ( nodeId ) ; } else { return super . getNodeHandle ( nodeId ) ; } } public DOM getResultTreeFrag ( int initialSize , int rtfType ) { if ( _dom != null ) { return _dom . getResultTreeFrag ( initialSize , rtfType ) ; } else { return super . getResultTreeFrag ( initialSize , rtfType ) ; } } public SerializationHandler getOutputDomBuilder ( ) { return this ; } public int getNSType ( int node ) { if ( _dom != null ) { return _dom . getNSType ( node ) ; } else { return super . getNSType ( node ) ; } } public String getUnparsedEntityURI ( String name ) { if ( _dom != null ) { return _dom . getUnparsedEntityURI ( name ) ; } else { return super . getUnparsedEntityURI ( name ) ; } } public Hashtable getElementsWithIDs ( ) { if ( _dom != null ) { return _dom . getElementsWithIDs ( ) ; } else { return super . getElementsWithIDs ( ) ; } } private void maybeEmitStartElement ( ) throws SAXException { if ( _openElementName != null ) { int index ; if ( ( index = _openElementName . indexOf ( ":" ) ) < 0 ) _dom . startElement ( null , _openElementName , _openElementName , _attributes ) ; else _dom . startElement ( null , _openElementName . substring ( index + 1 ) , _openElementName , _attributes ) ; _openElementName = null ; } } private void prepareNewDOM ( ) throws SAXException { _dom = ( SAXImpl ) _dtmManager . getDTM ( null , true , _wsfilter , true , false , false , _initSize , _buildIdIndex ) ; _dom . startDocument ( ) ; for ( int i = 0 ; i < _size ; i ++ ) { String str = _textArray [ i ] ; _dom . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } _size = 0 ; } public void startDocument ( ) throws SAXException { } public void endDocument ( ) throws SAXException { if ( _dom != null ) { _dom . endDocument ( ) ; } else { super . endDocument ( ) ; } } public void characters ( String str ) throws SAXException { if ( _dom != null ) { characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } else { super . characters ( str ) ; } } public void characters ( char [ ] ch , int offset , int length ) throws SAXException { if ( _dom != null ) { maybeEmitStartElement ( ) ; _dom . characters ( ch , offset , length ) ; } else { super . characters ( ch , offset , length ) ; } } public boolean setEscaping ( boolean escape ) throws SAXException { if ( _dom != null ) { return _dom . setEscaping ( escape ) ; } else { return super . setEscaping ( escape ) ; } } public void startElement ( String elementName ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } maybeEmitStartElement ( ) ; _openElementName = elementName ; _attributes . clear ( ) ; } public void startElement ( String uri , String localName , String qName ) throws SAXException { startElement ( qName ) ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { startElement ( qName ) ; } public void endElement ( String elementName ) throws SAXException { maybeEmitStartElement ( ) ; _dom . endElement ( null , null , elementName ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { endElement ( qName ) ; } public void addAttribute ( String name , String value ) { if ( _openElementName != null ) { _attributes . add ( name , value ) ; } else { BasisLibrary . runTimeError ( BasisLibrary . STRAY_ATTRIBUTE_ERR , name ) ; } } public void namespaceAfterStartElement ( String prefix , String uri ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } _dom . startPrefixMapping ( prefix , uri ) ; } public void comment ( String comment ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } maybeEmitStartElement ( ) ; char [ ] chars = comment . toCharArray ( ) ; _dom . comment ( chars , 0 , chars . length ) ; } public void comment ( char [ ] chars , int offset , int length ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } maybeEmitStartElement ( ) ; _dom . comment ( chars , offset , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } maybeEmitStartElement ( ) ; _dom . processingInstruction ( target , data ) ; } public void setFeature ( String featureId , boolean state ) { if ( _dom != null ) { _dom . setFeature ( featureId , state ) ; } } public void setProperty ( String property , Object value ) { if ( _dom != null ) { _dom . setProperty ( property , value ) ; } } public DTMAxisTraverser getAxisTraverser ( final int axis ) { if ( _dom != null ) { return _dom . getAxisTraverser ( axis ) ; } else { return super . getAxisTraverser ( axis ) ; } } public boolean hasChildNodes ( int nodeHandle ) { if ( _dom != null ) { return _dom . hasChildNodes ( nodeHandle ) ; } else { return super . hasChildNodes ( nodeHandle ) ; } } public int getFirstChild ( int nodeHandle ) { if ( _dom != null ) { return _dom . getFirstChild ( nodeHandle ) ; } else { return super . getFirstChild ( nodeHandle ) ; } } public int getLastChild ( int nodeHandle ) { if ( _dom != null ) { return _dom . getLastChild ( nodeHandle ) ; } else { return super . getLastChild ( nodeHandle ) ; } } public int getAttributeNode ( int elementHandle , String namespaceURI , String name ) { if ( _dom != null ) { return _dom . getAttributeNode ( elementHandle , namespaceURI , name ) ; } else { return super . getAttributeNode ( elementHandle , namespaceURI , name ) ; } } public int getFirstAttribute ( int nodeHandle ) { if ( _dom != null ) { return _dom . getFirstAttribute ( nodeHandle ) ; } else { return super . getFirstAttribute ( nodeHandle ) ; } } public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) { if ( _dom != null ) { return _dom . getFirstNamespaceNode ( nodeHandle , inScope ) ; } else { return super . getFirstNamespaceNode ( nodeHandle , inScope ) ; } } public int getNextSibling ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNextSibling ( nodeHandle ) ; } else { return super . getNextSibling ( nodeHandle ) ; } } public int getPreviousSibling ( int nodeHandle ) { if ( _dom != null ) { return _dom . getPreviousSibling ( nodeHandle ) ; } else { return super . getPreviousSibling ( nodeHandle ) ; } } public int getNextAttribute ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNextAttribute ( nodeHandle ) ; } else { return super . getNextAttribute ( nodeHandle ) ; } } public int getNextNamespaceNode ( int baseHandle , int namespaceHandle , boolean inScope ) { if ( _dom != null ) { return _dom . getNextNamespaceNode ( baseHandle , namespaceHandle , inScope ) ; } else { return super . getNextNamespaceNode ( baseHandle , namespaceHandle , inScope ) ; } } public int getOwnerDocument ( int nodeHandle ) { if ( _dom != null ) { return _dom . getOwnerDocument ( nodeHandle ) ; } else { return super . getOwnerDocument ( nodeHandle ) ; } } public int getDocumentRoot ( int nodeHandle ) { if ( _dom != null ) { return _dom . getDocumentRoot ( nodeHandle ) ; } else { return super . getDocumentRoot ( nodeHandle ) ; } } public XMLString getStringValue ( int nodeHandle ) { if ( _dom != null ) { return _dom . getStringValue ( nodeHandle ) ; } else { return super . getStringValue ( nodeHandle ) ; } } public int getStringValueChunkCount ( int nodeHandle ) { if ( _dom != null ) { return _dom . getStringValueChunkCount ( nodeHandle ) ; } else { return super . getStringValueChunkCount ( nodeHandle ) ; } } public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) { if ( _dom != null ) { return _dom . getStringValueChunk ( nodeHandle , chunkIndex , startAndLen ) ; } else { return super . getStringValueChunk ( nodeHandle , chunkIndex , startAndLen ) ; } } public int getExpandedTypeID ( String namespace , String localName , int type ) { if ( _dom != null ) { return _dom . getExpandedTypeID ( namespace , localName , type ) ; } else { return super . getExpandedTypeID ( namespace , localName , type ) ; } } public String getLocalNameFromExpandedNameID ( int ExpandedNameID ) { if ( _dom != null ) { return _dom . getLocalNameFromExpandedNameID ( ExpandedNameID ) ; } else { return super . getLocalNameFromExpandedNameID ( ExpandedNameID ) ; } } public String getNamespaceFromExpandedNameID ( int ExpandedNameID ) { if ( _dom != null ) { return _dom . getNamespaceFromExpandedNameID ( ExpandedNameID ) ; } else { return super . getNamespaceFromExpandedNameID ( ExpandedNameID ) ; } } public String getLocalName ( int nodeHandle ) { if ( _dom != null ) { return _dom . getLocalName ( nodeHandle ) ; } else { return super . getLocalName ( nodeHandle ) ; } } public String getPrefix ( int nodeHandle ) { if ( _dom != null ) { return _dom . getPrefix ( nodeHandle ) ; } else { return super . getPrefix ( nodeHandle ) ; } } public String getNamespaceURI ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNamespaceURI ( nodeHandle ) ; } else { return super . getNamespaceURI ( nodeHandle ) ; } } public String getNodeValue ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNodeValue ( nodeHandle ) ; } else { return super . getNodeValue ( nodeHandle ) ; } } public short getNodeType ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNodeType ( nodeHandle ) ; } else { return super . getNodeType ( nodeHandle ) ; } } public short getLevel ( int nodeHandle ) { if ( _dom != null ) { return _dom . getLevel ( nodeHandle ) ; } else { return super . getLevel ( nodeHandle ) ; } } public boolean isSupported ( String feature , String version ) { if ( _dom != null ) { return _dom . isSupported ( feature , version ) ; } else { return super . isSupported ( feature , version ) ; } } public String getDocumentBaseURI ( ) { if ( _dom != null ) { return _dom . getDocumentBaseURI ( ) ; } else { return super . getDocumentBaseURI ( ) ; } } public void setDocumentBaseURI ( String baseURI ) { if ( _dom != null ) { _dom . setDocumentBaseURI ( baseURI ) ; } else { super . setDocumentBaseURI ( baseURI ) ; } } public String getDocumentSystemIdentifier ( int nodeHandle ) { if ( _dom != null ) { return _dom . getDocumentSystemIdentifier ( nodeHandle ) ; } else { return super . getDocumentSystemIdentifier ( nodeHandle ) ; } } public String getDocumentEncoding ( int nodeHandle ) { if ( _dom != null ) { return _dom . getDocumentEncoding ( nodeHandle ) ; } else { return super . getDocumentEncoding ( nodeHandle ) ; } } public String getDocumentStandalone ( int nodeHandle ) { if ( _dom != null ) { return _dom . getDocumentStandalone ( nodeHandle ) ; } else { return super . getDocumentStandalone ( nodeHandle ) ; } } public String getDocumentVersion ( int documentHandle ) { if ( _dom != null ) { return _dom . getDocumentVersion ( documentHandle ) ; } else { return super . getDocumentVersion ( documentHandle ) ; } } public boolean getDocumentAllDeclarationsProcessed ( ) { if ( _dom != null ) { return _dom . getDocumentAllDeclarationsProcessed ( ) ; } else { return super . getDocumentAllDeclarationsProcessed ( ) ; } } public String getDocumentTypeDeclarationSystemIdentifier ( ) { if ( _dom != null ) { return _dom . getDocumentTypeDeclarationSystemIdentifier ( ) ; } else { return super . getDocumentTypeDeclarationSystemIdentifier ( ) ; } } public String getDocumentTypeDeclarationPublicIdentifier ( ) { if ( _dom != null ) { return _dom . getDocumentTypeDeclarationPublicIdentifier ( ) ; } else { return super . getDocumentTypeDeclarationPublicIdentifier ( ) ; } } public int getElementById ( String elementId ) { if ( _dom != null ) { return _dom . getElementById ( elementId ) ; } else { return super . getElementById ( elementId ) ; } } public boolean supportsPreStripping ( ) { if ( _dom != null ) { return _dom . supportsPreStripping ( ) ; } else { return super . supportsPreStripping ( ) ; } } public boolean isNodeAfter ( int firstNodeHandle , int secondNodeHandle ) { if ( _dom != null ) { return _dom . isNodeAfter ( firstNodeHandle , secondNodeHandle ) ; } else { return super . isNodeAfter ( firstNodeHandle , secondNodeHandle ) ; } } public boolean isCharacterElementContentWhitespace ( int nodeHandle ) { if ( _dom != null ) { return _dom . isCharacterElementContentWhitespace ( nodeHandle ) ; } else { return super . isCharacterElementContentWhitespace ( nodeHandle ) ; } } public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) { if ( _dom != null ) { return _dom . isDocumentAllDeclarationsProcessed ( documentHandle ) ; } else { return super . isDocumentAllDeclarationsProcessed ( documentHandle ) ; } } public boolean isAttributeSpecified ( int attributeHandle ) { if ( _dom != null ) { return _dom . isAttributeSpecified ( attributeHandle ) ; } else { return super . isAttributeSpecified ( attributeHandle ) ; } } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { if ( _dom != null ) { _dom . dispatchCharactersEvents ( nodeHandle , ch , normalize ) ; } else { super . dispatchCharactersEvents ( nodeHandle , ch , normalize ) ; } } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { if ( _dom != null ) { _dom . dispatchToEvents ( nodeHandle , ch ) ; } else { super . dispatchToEvents ( nodeHandle , ch ) ; } } public org . w3c . dom . Node getNode ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNode ( nodeHandle ) ; } else { return super . getNode ( nodeHandle ) ; } } public boolean needsTwoThreads ( ) { if ( _dom != null ) { return _dom . needsTwoThreads ( ) ; } else { return super . needsTwoThreads ( ) ; } } public org . xml . sax . ContentHandler getContentHandler ( ) { if ( _dom != null ) { return _dom . getContentHandler ( ) ; } else { return super . getContentHandler ( ) ; } } public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) { if ( _dom != null ) { return _dom . getLexicalHandler ( ) ; } else { return super . getLexicalHandler ( ) ; } } public org . xml . sax . EntityResolver getEntityResolver ( ) { if ( _dom != null ) { return _dom . getEntityResolver ( ) ; } else { return super . getEntityResolver ( ) ; } } public org . xml . sax . DTDHandler getDTDHandler ( ) { if ( _dom != null ) { return _dom . getDTDHandler ( ) ; } else { return super . getDTDHandler ( ) ; } } public org . xml . sax . ErrorHandler getErrorHandler ( ) { if ( _dom != null ) { return _dom . getErrorHandler ( ) ; } else { return super . getErrorHandler ( ) ; } } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { if ( _dom != null ) { return _dom . getDeclHandler ( ) ; } else { return super . getDeclHandler ( ) ; } } public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) { if ( _dom != null ) { _dom . appendChild ( newChild , clone , cloneDepth ) ; } else { super . appendChild ( newChild , clone , cloneDepth ) ; } } public void appendTextChild ( String str ) { if ( _dom != null ) { _dom . appendTextChild ( str ) ; } else { super . appendTextChild ( str ) ; } } public SourceLocator getSourceLocatorFor ( int node ) { if ( _dom != null ) { return _dom . getSourceLocatorFor ( node ) ; } else { return super . getSourceLocatorFor ( node ) ; } } public void documentRegistration ( ) { if ( _dom != null ) { _dom . documentRegistration ( ) ; } else { super . documentRegistration ( ) ; } } public void documentRelease ( ) { if ( _dom != null ) { _dom . documentRelease ( ) ; } else { super . documentRelease ( ) ; } } } 	1	['121', '3', '0', '16', '345', '0', '2', '15', '118', '0.808333333', '1630', '1', '3', '0.633846154', '0.134444444', '1', '18', '12.41322314', '2', '1.7603', '1']
package org . apache . xml . utils ; public class StringToStringTableVector { private int m_blocksize ; private StringToStringTable m_map [ ] ; private int m_firstFree = 0 ; private int m_mapSize ; public StringToStringTableVector ( ) { m_blocksize = 8 ; m_mapSize = m_blocksize ; m_map = new StringToStringTable [ m_blocksize ] ; } public StringToStringTableVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new StringToStringTable [ blocksize ] ; } public final int getLength ( ) { return m_firstFree ; } public final int size ( ) { return m_firstFree ; } public final void addElement ( StringToStringTable value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; StringToStringTable newMap [ ] = new StringToStringTable [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final String get ( String key ) { for ( int i = m_firstFree - 1 ; i >= 0 ; -- i ) { String nsuri = m_map [ i ] . get ( key ) ; if ( nsuri != null ) return nsuri ; } return null ; } public final boolean containsKey ( String key ) { for ( int i = m_firstFree - 1 ; i >= 0 ; -- i ) { if ( m_map [ i ] . get ( key ) != null ) return true ; } return false ; } public final void removeLastElem ( ) { if ( m_firstFree > 0 ) { m_map [ m_firstFree ] = null ; m_firstFree -- ; } } public final StringToStringTable elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( StringToStringTable s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( s ) ) return true ; } return false ; } } 	1	['10', '1', '0', '1', '14', '0', '0', '1', '10', '0.472222222', '180', '1', '1', '0', '0.4', '0', '0', '16.6', '3', '1.6', '1']
package org . apache . xpath . compiler ; import java . util . Hashtable ; public class Keywords { static Hashtable m_keywords = new Hashtable ( ) ; static Hashtable m_axisnames = new Hashtable ( ) ; static Hashtable m_functions = new Hashtable ( ) ; static Hashtable m_nodetypes = new Hashtable ( ) ; private static final String FROM_ANCESTORS_STRING = "ancestor" ; private static final String FROM_ANCESTORS_OR_SELF_STRING = "ancestor-or-self" ; private static final String FROM_ATTRIBUTES_STRING = "attribute" ; private static final String FROM_CHILDREN_STRING = "child" ; private static final String FROM_DESCENDANTS_STRING = "descendant" ; private static final String FROM_DESCENDANTS_OR_SELF_STRING = "descendant-or-self" ; private static final String FROM_FOLLOWING_STRING = "following" ; private static final String FROM_FOLLOWING_SIBLINGS_STRING = "following-sibling" ; private static final String FROM_PARENT_STRING = "parent" ; private static final String FROM_PRECEDING_STRING = "preceding" ; private static final String FROM_PRECEDING_SIBLINGS_STRING = "preceding-sibling" ; private static final String FROM_SELF_STRING = "self" ; private static final String FROM_NAMESPACE_STRING = "namespace" ; private static final String FROM_SELF_ABBREVIATED_STRING = "." ; private static final String NODETYPE_COMMENT_STRING = "comment" ; private static final String NODETYPE_TEXT_STRING = "text" ; private static final String NODETYPE_PI_STRING = "processing-instruction" ; private static final String NODETYPE_NODE_STRING = "node" ; private static final String NODETYPE_ANYELEMENT_STRING = "*" ; private static final String FUNC_CURRENT_STRING = "current" ; private static final String FUNC_LAST_STRING = "last" ; private static final String FUNC_POSITION_STRING = "position" ; private static final String FUNC_COUNT_STRING = "count" ; static final String FUNC_ID_STRING = "id" ; public static final String FUNC_KEY_STRING = "key" ; private static final String FUNC_LOCAL_PART_STRING = "local-name" ; private static final String FUNC_NAMESPACE_STRING = "namespace-uri" ; private static final String FUNC_NAME_STRING = "name" ; private static final String FUNC_GENERATE_ID_STRING = "generate-id" ; private static final String FUNC_NOT_STRING = "not" ; private static final String FUNC_TRUE_STRING = "true" ; private static final String FUNC_FALSE_STRING = "false" ; private static final String FUNC_BOOLEAN_STRING = "boolean" ; private static final String FUNC_LANG_STRING = "lang" ; private static final String FUNC_NUMBER_STRING = "number" ; private static final String FUNC_FLOOR_STRING = "floor" ; private static final String FUNC_CEILING_STRING = "ceiling" ; private static final String FUNC_ROUND_STRING = "round" ; private static final String FUNC_SUM_STRING = "sum" ; private static final String FUNC_STRING_STRING = "string" ; private static final String FUNC_STARTS_WITH_STRING = "starts-with" ; private static final String FUNC_CONTAINS_STRING = "contains" ; private static final String FUNC_SUBSTRING_BEFORE_STRING = "substring-before" ; private static final String FUNC_SUBSTRING_AFTER_STRING = "substring-after" ; private static final String FUNC_NORMALIZE_SPACE_STRING = "normalize-space" ; private static final String FUNC_TRANSLATE_STRING = "translate" ; private static final String FUNC_CONCAT_STRING = "concat" ; private static final String FUNC_SYSTEM_PROPERTY_STRING = "system-property" ; private static final String FUNC_EXT_FUNCTION_AVAILABLE_STRING = "function-available" ; private static final String FUNC_EXT_ELEM_AVAILABLE_STRING = "element-available" ; private static final String FUNC_SUBSTRING_STRING = "substring" ; private static final String FUNC_STRING_LENGTH_STRING = "string-length" ; private static final String FUNC_UNPARSED_ENTITY_URI_STRING = "unparsed-entity-uri" ; private static final String FUNC_DOCLOCATION_STRING = "document-location" ; static { m_axisnames . put ( FROM_ANCESTORS_STRING , new Integer ( OpCodes . FROM_ANCESTORS ) ) ; m_axisnames . put ( FROM_ANCESTORS_OR_SELF_STRING , new Integer ( OpCodes . FROM_ANCESTORS_OR_SELF ) ) ; m_axisnames . put ( FROM_ATTRIBUTES_STRING , new Integer ( OpCodes . FROM_ATTRIBUTES ) ) ; m_axisnames . put ( FROM_CHILDREN_STRING , new Integer ( OpCodes . FROM_CHILDREN ) ) ; m_axisnames . put ( FROM_DESCENDANTS_STRING , new Integer ( OpCodes . FROM_DESCENDANTS ) ) ; m_axisnames . put ( FROM_DESCENDANTS_OR_SELF_STRING , new Integer ( OpCodes . FROM_DESCENDANTS_OR_SELF ) ) ; m_axisnames . put ( FROM_FOLLOWING_STRING , new Integer ( OpCodes . FROM_FOLLOWING ) ) ; m_axisnames . put ( FROM_FOLLOWING_SIBLINGS_STRING , new Integer ( OpCodes . FROM_FOLLOWING_SIBLINGS ) ) ; m_axisnames . put ( FROM_PARENT_STRING , new Integer ( OpCodes . FROM_PARENT ) ) ; m_axisnames . put ( FROM_PRECEDING_STRING , new Integer ( OpCodes . FROM_PRECEDING ) ) ; m_axisnames . put ( FROM_PRECEDING_SIBLINGS_STRING , new Integer ( OpCodes . FROM_PRECEDING_SIBLINGS ) ) ; m_axisnames . put ( FROM_SELF_STRING , new Integer ( OpCodes . FROM_SELF ) ) ; m_axisnames . put ( FROM_NAMESPACE_STRING , new Integer ( OpCodes . FROM_NAMESPACE ) ) ; m_nodetypes . put ( NODETYPE_COMMENT_STRING , new Integer ( OpCodes . NODETYPE_COMMENT ) ) ; m_nodetypes . put ( NODETYPE_TEXT_STRING , new Integer ( OpCodes . NODETYPE_TEXT ) ) ; m_nodetypes . put ( NODETYPE_PI_STRING , new Integer ( OpCodes . NODETYPE_PI ) ) ; m_nodetypes . put ( NODETYPE_NODE_STRING , new Integer ( OpCodes . NODETYPE_NODE ) ) ; m_nodetypes . put ( NODETYPE_ANYELEMENT_STRING , new Integer ( OpCodes . NODETYPE_ANYELEMENT ) ) ; m_keywords . put ( FROM_SELF_ABBREVIATED_STRING , new Integer ( OpCodes . FROM_SELF ) ) ; m_keywords . put ( FUNC_ID_STRING , new Integer ( FunctionTable . FUNC_ID ) ) ; m_keywords . put ( FUNC_KEY_STRING , new Integer ( FunctionTable . FUNC_KEY ) ) ; m_functions . put ( FUNC_CURRENT_STRING , new Integer ( FunctionTable . FUNC_CURRENT ) ) ; m_functions . put ( FUNC_LAST_STRING , new Integer ( FunctionTable . FUNC_LAST ) ) ; m_functions . put ( FUNC_POSITION_STRING , new Integer ( FunctionTable . FUNC_POSITION ) ) ; m_functions . put ( FUNC_COUNT_STRING , new Integer ( FunctionTable . FUNC_COUNT ) ) ; m_functions . put ( FUNC_ID_STRING , new Integer ( FunctionTable . FUNC_ID ) ) ; m_functions . put ( FUNC_KEY_STRING , new Integer ( FunctionTable . FUNC_KEY ) ) ; m_functions . put ( FUNC_LOCAL_PART_STRING , new Integer ( FunctionTable . FUNC_LOCAL_PART ) ) ; m_functions . put ( FUNC_NAMESPACE_STRING , new Integer ( FunctionTable . FUNC_NAMESPACE ) ) ; m_functions . put ( FUNC_NAME_STRING , new Integer ( FunctionTable . FUNC_QNAME ) ) ; m_functions . put ( FUNC_GENERATE_ID_STRING , new Integer ( FunctionTable . FUNC_GENERATE_ID ) ) ; m_functions . put ( FUNC_NOT_STRING , new Integer ( FunctionTable . FUNC_NOT ) ) ; m_functions . put ( FUNC_TRUE_STRING , new Integer ( FunctionTable . FUNC_TRUE ) ) ; m_functions . put ( FUNC_FALSE_STRING , new Integer ( FunctionTable . FUNC_FALSE ) ) ; m_functions . put ( FUNC_BOOLEAN_STRING , new Integer ( FunctionTable . FUNC_BOOLEAN ) ) ; m_functions . put ( FUNC_LANG_STRING , new Integer ( FunctionTable . FUNC_LANG ) ) ; m_functions . put ( FUNC_NUMBER_STRING , new Integer ( FunctionTable . FUNC_NUMBER ) ) ; m_functions . put ( FUNC_FLOOR_STRING , new Integer ( FunctionTable . FUNC_FLOOR ) ) ; m_functions . put ( FUNC_CEILING_STRING , new Integer ( FunctionTable . FUNC_CEILING ) ) ; m_functions . put ( FUNC_ROUND_STRING , new Integer ( FunctionTable . FUNC_ROUND ) ) ; m_functions . put ( FUNC_SUM_STRING , new Integer ( FunctionTable . FUNC_SUM ) ) ; m_functions . put ( FUNC_STRING_STRING , new Integer ( FunctionTable . FUNC_STRING ) ) ; m_functions . put ( FUNC_STARTS_WITH_STRING , new Integer ( FunctionTable . FUNC_STARTS_WITH ) ) ; m_functions . put ( FUNC_CONTAINS_STRING , new Integer ( FunctionTable . FUNC_CONTAINS ) ) ; m_functions . put ( FUNC_SUBSTRING_BEFORE_STRING , new Integer ( FunctionTable . FUNC_SUBSTRING_BEFORE ) ) ; m_functions . put ( FUNC_SUBSTRING_AFTER_STRING , new Integer ( FunctionTable . FUNC_SUBSTRING_AFTER ) ) ; m_functions . put ( FUNC_NORMALIZE_SPACE_STRING , new Integer ( FunctionTable . FUNC_NORMALIZE_SPACE ) ) ; m_functions . put ( FUNC_TRANSLATE_STRING , new Integer ( FunctionTable . FUNC_TRANSLATE ) ) ; m_functions . put ( FUNC_CONCAT_STRING , new Integer ( FunctionTable . FUNC_CONCAT ) ) ; m_functions . put ( FUNC_SYSTEM_PROPERTY_STRING , new Integer ( FunctionTable . FUNC_SYSTEM_PROPERTY ) ) ; m_functions . put ( FUNC_EXT_FUNCTION_AVAILABLE_STRING , new Integer ( FunctionTable . FUNC_EXT_FUNCTION_AVAILABLE ) ) ; m_functions . put ( FUNC_EXT_ELEM_AVAILABLE_STRING , new Integer ( FunctionTable . FUNC_EXT_ELEM_AVAILABLE ) ) ; m_functions . put ( FUNC_SUBSTRING_STRING , new Integer ( FunctionTable . FUNC_SUBSTRING ) ) ; m_functions . put ( FUNC_STRING_LENGTH_STRING , new Integer ( FunctionTable . FUNC_STRING_LENGTH ) ) ; m_functions . put ( FUNC_UNPARSED_ENTITY_URI_STRING , new Integer ( FunctionTable . FUNC_UNPARSED_ENTITY_URI ) ) ; m_functions . put ( NODETYPE_COMMENT_STRING , new Integer ( OpCodes . NODETYPE_COMMENT ) ) ; m_functions . put ( NODETYPE_TEXT_STRING , new Integer ( OpCodes . NODETYPE_TEXT ) ) ; m_functions . put ( NODETYPE_PI_STRING , new Integer ( OpCodes . NODETYPE_PI ) ) ; m_functions . put ( NODETYPE_NODE_STRING , new Integer ( OpCodes . NODETYPE_NODE ) ) ; m_functions . put ( FUNC_DOCLOCATION_STRING , new Integer ( FunctionTable . FUNC_DOCLOCATION ) ) ; } public static boolean functionAvailable ( String methName ) { try { Object tblEntry = m_functions . get ( methName ) ; if ( null == tblEntry ) return false ; int funcType = ( ( Integer ) tblEntry ) . intValue ( ) ; switch ( funcType ) { case OpCodes . NODETYPE_COMMENT : case OpCodes . NODETYPE_TEXT : case OpCodes . NODETYPE_PI : case OpCodes . NODETYPE_NODE : return false ; default : return true ; } } catch ( Exception e ) { return false ; } } } 	1	['3', '1', '0', '4', '9', '1', '4', '0', '2', '1.456896552', '583', '0.896551724', '0', '0', '0.5', '0', '0', '174', '3', '1', '1']
package org . apache . xalan . transformer ; import java . io . IOException ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . stream . StreamResult ; import org . apache . xalan . extensions . ExtensionsTable ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . serializer . Method ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; import org . apache . xalan . templates . AVT ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemAttributeSet ; import org . apache . xalan . templates . ElemForEach ; import org . apache . xalan . templates . ElemSort ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xalan . templates . ElemVariable ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetComposed ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . templates . XUnresolvedVariable ; import org . apache . xalan . trace . TraceManager ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . serializer . ToHTMLSAXHandler ; import org . apache . xml . serializer . ToSAXHandler ; import org . apache . xml . serializer . ToTextSAXHandler ; import org . apache . xml . serializer . ToTextStream ; import org . apache . xml . serializer . ToXMLSAXHandler ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . DOMBuilder ; import org . apache . xml . utils . DOMHelper ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . ObjectPool ; import org . apache . xml . utils . ObjectStack ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . ThreadControllerWrapper ; import org . apache . xpath . Arg ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . apache . xalan . trace . GenerateEvent ; public class TransformerImpl extends Transformer implements Runnable , DTMWSFilter , ExtensionsProvider , org . apache . xml . serializer . SerializerTrace { private Boolean m_reentryGuard = new Boolean ( true ) ; private java . io . FileOutputStream m_outputStream = null ; private boolean m_parserEventsOnMain = true ; private Thread m_transformThread ; private String m_urlOfSource = null ; private Result m_outputTarget = null ; private OutputProperties m_outputFormat ; ContentHandler m_inputContentHandler ; private ContentHandler m_outputContentHandler = null ; DocumentBuilder m_docBuilder = null ; private ObjectPool m_textResultHandlerObjectPool = new ObjectPool ( "org.apache.xml.serializer.ToTextStream" ) ; private ObjectPool m_stringWriterObjectPool = new ObjectPool ( "java.io.StringWriter" ) ; private OutputProperties m_textformat = new OutputProperties ( Method . TEXT ) ; ObjectStack m_currentTemplateElements = new ObjectStack ( XPathContext . RECURSIONLIMIT ) ; Stack m_currentMatchTemplates = new Stack ( ) ; NodeVector m_currentMatchedNodes = new NodeVector ( ) ; private StylesheetRoot m_stylesheetRoot = null ; private boolean m_quietConflictWarnings = true ; private XPathContext m_xcontext ; private StackGuard m_stackGuard ; private SerializationHandler m_serializationHandler ; private KeyManager m_keyManager = new KeyManager ( ) ; Stack m_attrSetStack = null ; CountersTable m_countersTable = null ; BoolStack m_currentTemplateRuleIsNull = new BoolStack ( ) ; private MsgMgr m_msgMgr ; public static boolean S_DEBUG = false ; private ErrorListener m_errorHandler = new org . apache . xml . utils . DefaultErrorHandler ( ) ; private TraceManager m_traceManager = new TraceManager ( this ) ; private Exception m_exceptionThrown = null ; private Source m_xmlSource ; private int m_doc ; private boolean m_isTransformDone = false ; private boolean m_hasBeenReset = false ; private boolean m_shouldReset = true ; public void setShouldReset ( boolean shouldReset ) { m_shouldReset = shouldReset ; } private Stack m_modes = new Stack ( ) ; public TransformerImpl ( StylesheetRoot stylesheet ) { setStylesheet ( stylesheet ) ; setXPathContext ( new XPathContext ( this ) ) ; getXPathContext ( ) . setNamespaceContext ( stylesheet ) ; m_stackGuard = new StackGuard ( this ) ; } private ExtensionsTable m_extensionsTable = null ; public ExtensionsTable getExtensionsTable ( ) { return m_extensionsTable ; } void setExtensionsTable ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { try { if ( sroot . getExtensions ( ) != null ) m_extensionsTable = new ExtensionsTable ( sroot ) ; } catch ( javax . xml . transform . TransformerException te ) { te . printStackTrace ( ) ; } } public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . functionAvailable ( ns , funcName ) ; } public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . elementAvailable ( ns , elemName ) ; } public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . extFunction ( ns , funcName , argVec , methodKey , getXPathContext ( ) . getExpressionContext ( ) ) ; } public Object extFunction ( FuncExtFunction extFunction , Vector argVec ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . extFunction ( extFunction , argVec , getXPathContext ( ) . getExpressionContext ( ) ) ; } public void reset ( ) { if ( ! m_hasBeenReset && m_shouldReset ) { m_hasBeenReset = true ; if ( this . m_outputStream != null ) { try { m_outputStream . close ( ) ; } catch ( java . io . IOException ioe ) { } } m_outputStream = null ; m_countersTable = null ; m_xcontext . reset ( ) ; m_xcontext . getVarStack ( ) . reset ( ) ; resetUserParameters ( ) ; m_currentTemplateElements . removeAllElements ( ) ; m_currentMatchTemplates . removeAllElements ( ) ; m_currentMatchedNodes . removeAllElements ( ) ; m_serializationHandler = null ; m_outputTarget = null ; m_keyManager = new KeyManager ( ) ; m_attrSetStack = null ; m_countersTable = null ; m_currentTemplateRuleIsNull = new BoolStack ( ) ; m_xmlSource = null ; m_doc = DTM . NULL ; m_isTransformDone = false ; m_transformThread = null ; m_xcontext . getSourceTreeManager ( ) . reset ( ) ; } } public boolean getProperty ( String property ) { return false ; } public void setProperty ( String property , Object value ) { } public boolean isParserEventsOnMain ( ) { return m_parserEventsOnMain ; } public Thread getTransformThread ( ) { return m_transformThread ; } public void setTransformThread ( Thread t ) { m_transformThread = t ; } private boolean m_hasTransformThreadErrorCatcher = false ; public boolean hasTransformThreadErrorCatcher ( ) { return m_hasTransformThreadErrorCatcher ; } public void transform ( Source source ) throws TransformerException { transform ( source , true ) ; } public void transform ( Source source , boolean shouldRelease ) throws TransformerException { try { if ( getXPathContext ( ) . getNamespaceContext ( ) == null ) { getXPathContext ( ) . setNamespaceContext ( getStylesheet ( ) ) ; } String base = source . getSystemId ( ) ; if ( null == base ) { base = m_stylesheetRoot . getBaseIdentifier ( ) ; } if ( null == base ) { String currentDir = "" ; try { currentDir = System . getProperty ( "user.dir" ) ; } catch ( SecurityException se ) { } if ( currentDir . startsWith ( java . io . File . separator ) ) base = "file://" + currentDir ; else base = "file:///" + currentDir ; base = base + java . io . File . separatorChar + source . getClass ( ) . getName ( ) ; } setBaseURLOfSource ( base ) ; DTMManager mgr = m_xcontext . getDTMManager ( ) ; DTM dtm = mgr . getDTM ( source , false , this , true , true ) ; dtm . setDocumentBaseURI ( base ) ; boolean hardDelete = true ; try { this . transformNode ( dtm . getDocument ( ) ) ; } finally { if ( shouldRelease ) mgr . release ( dtm , hardDelete ) ; } Exception e = getExceptionThrown ( ) ; if ( null != e ) { if ( e instanceof javax . xml . transform . TransformerException ) { throw ( javax . xml . transform . TransformerException ) e ; } else if ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { fatalError ( ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ) ; } else { throw new javax . xml . transform . TransformerException ( e ) ; } } else if ( null != m_serializationHandler ) { m_serializationHandler . endDocument ( ) ; } } catch ( org . apache . xml . utils . WrappedRuntimeException wre ) { Throwable throwable = wre . getException ( ) ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } fatalError ( throwable ) ; } catch ( org . xml . sax . SAXParseException spe ) { fatalError ( spe ) ; } catch ( org . xml . sax . SAXException se ) { m_errorHandler . fatalError ( new TransformerException ( se ) ) ; } finally { m_hasTransformThreadErrorCatcher = false ; reset ( ) ; } } private void fatalError ( Throwable throwable ) throws TransformerException { if ( throwable instanceof org . xml . sax . SAXParseException ) m_errorHandler . fatalError ( new TransformerException ( throwable . getMessage ( ) , new SAXSourceLocator ( ( org . xml . sax . SAXParseException ) throwable ) ) ) ; else m_errorHandler . fatalError ( new TransformerException ( throwable ) ) ; } public String getBaseURLOfSource ( ) { return m_urlOfSource ; } public void setBaseURLOfSource ( String base ) { m_urlOfSource = base ; } public Result getOutputTarget ( ) { return m_outputTarget ; } public void setOutputTarget ( Result outputTarget ) { m_outputTarget = outputTarget ; } public String getOutputProperty ( String qnameString ) throws IllegalArgumentException { String value = null ; OutputProperties props = getOutputFormat ( ) ; value = props . getProperty ( qnameString ) ; if ( null == value ) { if ( ! props . isLegalPropertyKey ( qnameString ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { qnameString } ) ) ; } return value ; } public String getOutputPropertyNoDefault ( String qnameString ) throws IllegalArgumentException { String value = null ; OutputProperties props = getOutputFormat ( ) ; value = ( String ) props . getProperties ( ) . get ( qnameString ) ; if ( null == value ) { if ( ! props . isLegalPropertyKey ( qnameString ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { qnameString } ) ) ; } return value ; } public void setOutputProperty ( String name , String value ) throws IllegalArgumentException { synchronized ( m_reentryGuard ) { if ( null == m_outputFormat ) { m_outputFormat = ( OutputProperties ) getStylesheet ( ) . getOutputComposed ( ) . clone ( ) ; } if ( ! m_outputFormat . isLegalPropertyKey ( name ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; m_outputFormat . setProperty ( name , value ) ; } } public void setOutputProperties ( Properties oformat ) throws IllegalArgumentException { synchronized ( m_reentryGuard ) { if ( null != oformat ) { String method = ( String ) oformat . get ( OutputKeys . METHOD ) ; if ( null != method ) m_outputFormat = new OutputProperties ( method ) ; else if ( m_outputFormat == null ) m_outputFormat = new OutputProperties ( ) ; } if ( null != oformat ) { m_outputFormat . copyFrom ( oformat ) ; } m_outputFormat . copyFrom ( m_stylesheetRoot . getOutputProperties ( ) ) ; } } public Properties getOutputProperties ( ) { return ( Properties ) getOutputFormat ( ) . getProperties ( ) . clone ( ) ; } public SerializationHandler createSerializationHandler ( Result outputTarget ) throws TransformerException { SerializationHandler xoh = createSerializationHandler ( outputTarget , getOutputFormat ( ) ) ; return xoh ; } public SerializationHandler createSerializationHandler ( Result outputTarget , OutputProperties format ) throws TransformerException { SerializationHandler xoh ; org . w3c . dom . Node outputNode = null ; if ( outputTarget instanceof DOMResult ) { outputNode = ( ( DOMResult ) outputTarget ) . getNode ( ) ; org . w3c . dom . Document doc ; short type ; if ( null != outputNode ) { type = outputNode . getNodeType ( ) ; doc = ( org . w3c . dom . Node . DOCUMENT_NODE == type ) ? ( org . w3c . dom . Document ) outputNode : outputNode . getOwnerDocument ( ) ; } else { doc = org . apache . xml . utils . DOMHelper . createDocument ( ) ; outputNode = doc ; type = outputNode . getNodeType ( ) ; ( ( DOMResult ) outputTarget ) . setNode ( outputNode ) ; } ContentHandler handler = ( org . w3c . dom . Node . DOCUMENT_FRAGMENT_NODE == type ) ? new DOMBuilder ( doc , ( org . w3c . dom . DocumentFragment ) outputNode ) : new DOMBuilder ( doc , outputNode ) ; String encoding = format . getProperty ( OutputKeys . ENCODING ) ; xoh = new ToXMLSAXHandler ( handler , ( LexicalHandler ) handler , encoding ) ; } else if ( outputTarget instanceof SAXResult ) { ContentHandler handler = ( ( SAXResult ) outputTarget ) . getHandler ( ) ; if ( null == handler ) throw new IllegalArgumentException ( "handler can not be null for a SAXResult" ) ; LexicalHandler lexHandler ; if ( handler instanceof LexicalHandler ) lexHandler = ( LexicalHandler ) handler ; else lexHandler = null ; String encoding = format . getProperty ( OutputKeys . ENCODING ) ; String method = format . getProperty ( OutputKeys . METHOD ) ; if ( org . apache . xml . serializer . Method . HTML . equals ( method ) ) { xoh = new ToHTMLSAXHandler ( handler , lexHandler , encoding ) ; } else if ( org . apache . xml . serializer . Method . TEXT . equals ( method ) ) { xoh = new ToTextSAXHandler ( handler , lexHandler , encoding ) ; } else { xoh = new ToXMLSAXHandler ( handler , lexHandler , encoding ) ; } if ( handler instanceof TransformerClient ) { XalanTransformState state = new XalanTransformState ( ) ; ( ( TransformerClient ) handler ) . setTransformState ( state ) ; ( ( ToSAXHandler ) xoh ) . setTransformState ( state ) ; } } else if ( outputTarget instanceof StreamResult ) { StreamResult sresult = ( StreamResult ) outputTarget ; String method = format . getProperty ( OutputKeys . METHOD ) ; try { SerializationHandler serializer = ( SerializationHandler ) SerializerFactory . getSerializer ( format . getProperties ( ) ) ; if ( null != sresult . getWriter ( ) ) serializer . setWriter ( sresult . getWriter ( ) ) ; else if ( null != sresult . getOutputStream ( ) ) serializer . setOutputStream ( sresult . getOutputStream ( ) ) ; else if ( null != sresult . getSystemId ( ) ) { String fileURL = sresult . getSystemId ( ) ; if ( fileURL . startsWith ( "file:///" ) ) { if ( fileURL . substring ( 8 ) . indexOf ( ":" ) > 0 ) fileURL = fileURL . substring ( 8 ) ; else fileURL = fileURL . substring ( 7 ) ; } m_outputStream = new java . io . FileOutputStream ( fileURL ) ; serializer . setOutputStream ( m_outputStream ) ; xoh = serializer ; } else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_OUTPUT_SPECIFIED , null ) ) ; xoh = serializer ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , new Object [ ] { outputTarget . getClass ( ) . getName ( ) } ) ) ; } xoh . setTransformer ( this ) ; SourceLocator srcLocator = getStylesheet ( ) ; xoh . setSourceLocator ( srcLocator ) ; return xoh ; } public void transform ( Source xmlSource , Result outputTarget ) throws TransformerException { transform ( xmlSource , outputTarget , true ) ; } public void transform ( Source xmlSource , Result outputTarget , boolean shouldRelease ) throws TransformerException { synchronized ( m_reentryGuard ) { SerializationHandler xoh = createSerializationHandler ( outputTarget ) ; this . setSerializationHandler ( xoh ) ; m_outputTarget = outputTarget ; transform ( xmlSource , shouldRelease ) ; } } public void transformNode ( int node , Result outputTarget ) throws TransformerException { SerializationHandler xoh = createSerializationHandler ( outputTarget ) ; this . setSerializationHandler ( xoh ) ; m_outputTarget = outputTarget ; transformNode ( node ) ; } public void transformNode ( int node ) throws TransformerException { setExtensionsTable ( getStylesheet ( ) ) ; synchronized ( m_serializationHandler ) { m_hasBeenReset = false ; XPathContext xctxt = getXPathContext ( ) ; DTM dtm = xctxt . getDTM ( node ) ; try { pushGlobalVars ( node ) ; StylesheetRoot stylesheet = this . getStylesheet ( ) ; int n = stylesheet . getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { StylesheetComposed imported = stylesheet . getGlobalImport ( i ) ; int includedCount = imported . getIncludeCountComposed ( ) ; for ( int j = - 1 ; j < includedCount ; j ++ ) { Stylesheet included = imported . getIncludeComposed ( j ) ; included . runtimeInit ( this ) ; for ( ElemTemplateElement child = included . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { child . runtimeInit ( this ) ; } } } DTMIterator dtmIter = new org . apache . xpath . axes . SelfIteratorNoPredicate ( ) ; dtmIter . setRoot ( node , xctxt ) ; xctxt . pushContextNodeList ( dtmIter ) ; try { this . applyTemplateToNode ( null , null , node ) ; } finally { xctxt . popContextNodeList ( ) ; } if ( null != m_serializationHandler ) { m_serializationHandler . endDocument ( ) ; } } catch ( Exception se ) { while ( se instanceof org . apache . xml . utils . WrappedRuntimeException ) { Exception e = ( ( org . apache . xml . utils . WrappedRuntimeException ) se ) . getException ( ) ; if ( null != e ) se = e ; } if ( null != m_serializationHandler ) { try { if ( se instanceof org . xml . sax . SAXParseException ) m_serializationHandler . fatalError ( ( org . xml . sax . SAXParseException ) se ) ; else if ( se instanceof TransformerException ) { TransformerException te = ( ( TransformerException ) se ) ; SAXSourceLocator sl = new SAXSourceLocator ( te . getLocator ( ) ) ; m_serializationHandler . fatalError ( new org . xml . sax . SAXParseException ( te . getMessage ( ) , sl , te ) ) ; } else { m_serializationHandler . fatalError ( new org . xml . sax . SAXParseException ( se . getMessage ( ) , new SAXSourceLocator ( ) , se ) ) ; } } catch ( Exception e ) { } } if ( se instanceof TransformerException ) { m_errorHandler . fatalError ( ( TransformerException ) se ) ; } else if ( se instanceof org . xml . sax . SAXParseException ) { m_errorHandler . fatalError ( new TransformerException ( se . getMessage ( ) , new SAXSourceLocator ( ( org . xml . sax . SAXParseException ) se ) , se ) ) ; } else { m_errorHandler . fatalError ( new TransformerException ( se ) ) ; } } finally { this . reset ( ) ; } } } public ContentHandler getInputContentHandler ( ) { return getInputContentHandler ( false ) ; } public ContentHandler getInputContentHandler ( boolean doDocFrag ) { if ( null == m_inputContentHandler ) { m_inputContentHandler = new TransformerHandlerImpl ( this , doDocFrag , m_urlOfSource ) ; } return m_inputContentHandler ; } public DeclHandler getInputDeclHandler ( ) { if ( m_inputContentHandler instanceof DeclHandler ) return ( DeclHandler ) m_inputContentHandler ; else return null ; } public LexicalHandler getInputLexicalHandler ( ) { if ( m_inputContentHandler instanceof LexicalHandler ) return ( LexicalHandler ) m_inputContentHandler ; else return null ; } public void setOutputFormat ( OutputProperties oformat ) { m_outputFormat = oformat ; } public OutputProperties getOutputFormat ( ) { OutputProperties format = ( null == m_outputFormat ) ? getStylesheet ( ) . getOutputComposed ( ) : m_outputFormat ; return format ; } public void setParameter ( String name , String namespace , Object value ) { VariableStack varstack = getXPathContext ( ) . getVarStack ( ) ; QName qname = new QName ( namespace , name ) ; XObject xobject = XObject . create ( value , getXPathContext ( ) ) ; StylesheetRoot sroot = m_stylesheetRoot ; Vector vars = sroot . getVariablesAndParamsComposed ( ) ; int i = vars . size ( ) ; while ( -- i >= 0 ) { ElemVariable variable = ( ElemVariable ) vars . elementAt ( i ) ; if ( variable . getXSLToken ( ) == Constants . ELEMNAME_PARAMVARIABLE && variable . getName ( ) . equals ( qname ) ) { varstack . setGlobalVariable ( i , xobject ) ; } } } Vector m_userParams ; public void setParameter ( String name , Object value ) { StringTokenizer tokenizer = new StringTokenizer ( name , "{}" , false ) ; try { String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == m_userParams ) m_userParams = new Vector ( ) ; if ( null == s2 ) { replaceOrPushUserParam ( new QName ( s1 ) , XObject . create ( value , getXPathContext ( ) ) ) ; setParameter ( s1 , null , value ) ; } else { replaceOrPushUserParam ( new QName ( s1 , s2 ) , XObject . create ( value , getXPathContext ( ) ) ) ; setParameter ( s2 , s1 , value ) ; } } catch ( java . util . NoSuchElementException nsee ) { } } private void replaceOrPushUserParam ( QName qname , XObject xval ) { int n = m_userParams . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Arg arg = ( Arg ) m_userParams . elementAt ( i ) ; if ( arg . getQName ( ) . equals ( qname ) ) { m_userParams . setElementAt ( new Arg ( qname , xval , true ) , i ) ; return ; } } m_userParams . addElement ( new Arg ( qname , xval , true ) ) ; } public Object getParameter ( String name ) { try { QName qname = QName . getQNameFromString ( name ) ; if ( null == m_userParams ) return null ; int n = m_userParams . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Arg arg = ( Arg ) m_userParams . elementAt ( i ) ; if ( arg . getQName ( ) . equals ( qname ) ) { return arg . getVal ( ) . object ( ) ; } } return null ; } catch ( java . util . NoSuchElementException nsee ) { return null ; } } private void resetUserParameters ( ) { try { if ( null == m_userParams ) return ; int n = m_userParams . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Arg arg = ( Arg ) m_userParams . elementAt ( i ) ; QName name = arg . getQName ( ) ; String s1 = name . getNamespace ( ) ; String s2 = name . getLocalPart ( ) ; setParameter ( s2 , s1 , arg . getVal ( ) . object ( ) ) ; } } catch ( java . util . NoSuchElementException nsee ) { } } public void setParameters ( Properties params ) { clearParameters ( ) ; Enumeration names = params . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = params . getProperty ( ( String ) names . nextElement ( ) ) ; StringTokenizer tokenizer = new StringTokenizer ( name , "{}" , false ) ; try { String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == s2 ) setParameter ( s1 , null , params . getProperty ( name ) ) ; else setParameter ( s2 , s1 , params . getProperty ( name ) ) ; } catch ( java . util . NoSuchElementException nsee ) { } } } public void clearParameters ( ) { synchronized ( m_reentryGuard ) { VariableStack varstack = new VariableStack ( ) ; m_xcontext . setVarStack ( varstack ) ; m_userParams = null ; } } protected void pushGlobalVars ( int contextNode ) throws TransformerException { XPathContext xctxt = m_xcontext ; VariableStack vs = xctxt . getVarStack ( ) ; StylesheetRoot sr = getStylesheet ( ) ; Vector vars = sr . getVariablesAndParamsComposed ( ) ; int i = vars . size ( ) ; vs . link ( i ) ; while ( -- i >= 0 ) { ElemVariable v = ( ElemVariable ) vars . elementAt ( i ) ; XObject xobj = new XUnresolvedVariable ( v , contextNode , this , vs . getStackFrame ( ) , 0 , true ) ; if ( null == vs . elementAt ( i ) ) vs . setGlobalVariable ( i , xobj ) ; } } public void setURIResolver ( URIResolver resolver ) { synchronized ( m_reentryGuard ) { m_xcontext . getSourceTreeManager ( ) . setURIResolver ( resolver ) ; } } public URIResolver getURIResolver ( ) { return m_xcontext . getSourceTreeManager ( ) . getURIResolver ( ) ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NULL_CONTENT_HANDLER , null ) ) ; } else { m_outputContentHandler = handler ; if ( null == m_serializationHandler ) { ToXMLSAXHandler h = new ToXMLSAXHandler ( ) ; h . setContentHandler ( handler ) ; h . setTransformer ( this ) ; m_serializationHandler = h ; } else m_serializationHandler . setContentHandler ( handler ) ; } } public ContentHandler getContentHandler ( ) { return m_outputContentHandler ; } public int transformToRTF ( ElemTemplateElement templateParent ) throws TransformerException { DTM dtmFrag = m_xcontext . getRTFDTM ( ) ; return transformToRTF ( templateParent , dtmFrag ) ; } public int transformToGlobalRTF ( ElemTemplateElement templateParent ) throws TransformerException { DTM dtmFrag = m_xcontext . getGlobalRTFDTM ( ) ; return transformToRTF ( templateParent , dtmFrag ) ; } private int transformToRTF ( ElemTemplateElement templateParent , DTM dtmFrag ) throws TransformerException { XPathContext xctxt = m_xcontext ; ContentHandler rtfHandler = dtmFrag . getContentHandler ( ) ; int resultFragment ; SerializationHandler savedRTreeHandler = this . m_serializationHandler ; ToSAXHandler h = new ToXMLSAXHandler ( ) ; h . setContentHandler ( rtfHandler ) ; h . setTransformer ( this ) ; m_serializationHandler = h ; SerializationHandler rth = m_serializationHandler ; try { rth . startDocument ( ) ; rth . flushPending ( ) ; try { executeChildTemplates ( templateParent , true ) ; rth . flushPending ( ) ; resultFragment = dtmFrag . getDocument ( ) ; } finally { rth . endDocument ( ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { this . m_serializationHandler = savedRTreeHandler ; } return resultFragment ; } public ObjectPool getStringWriterPool ( ) { return m_stringWriterObjectPool ; } public String transformToString ( ElemTemplateElement elem ) throws TransformerException { ElemTemplateElement firstChild = elem . getFirstChildElem ( ) ; if ( null == firstChild ) return "" ; if ( elem . hasTextLitOnly ( ) && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { return ( ( ElemTextLiteral ) firstChild ) . getNodeValue ( ) ; } SerializationHandler savedRTreeHandler = this . m_serializationHandler ; StringWriter sw = ( StringWriter ) m_stringWriterObjectPool . getInstance ( ) ; m_serializationHandler = ( ToTextStream ) m_textResultHandlerObjectPool . getInstance ( ) ; if ( null == m_serializationHandler ) { Serializer serializer = org . apache . xml . serializer . SerializerFactory . getSerializer ( m_textformat . getProperties ( ) ) ; m_serializationHandler = ( SerializationHandler ) serializer ; } m_serializationHandler . setTransformer ( this ) ; m_serializationHandler . setWriter ( sw ) ; String result ; try { executeChildTemplates ( elem , true ) ; this . m_serializationHandler . endDocument ( ) ; result = sw . toString ( ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { sw . getBuffer ( ) . setLength ( 0 ) ; try { sw . close ( ) ; } catch ( Exception ioe ) { } m_stringWriterObjectPool . freeInstance ( sw ) ; m_serializationHandler . reset ( ) ; m_textResultHandlerObjectPool . freeInstance ( m_serializationHandler ) ; m_serializationHandler = savedRTreeHandler ; } return result ; } public boolean applyTemplateToNode ( ElemTemplateElement xslInstruction , ElemTemplate template , int child ) throws TransformerException { DTM dtm = m_xcontext . getDTM ( child ) ; short nodeType = dtm . getNodeType ( child ) ; boolean isDefaultTextRule = false ; boolean isApplyImports = false ; if ( null == template ) { int maxImportLevel , endImportLevel = 0 ; isApplyImports = ( ( xslInstruction == null ) ? false : xslInstruction . getXSLToken ( ) == Constants . ELEMNAME_APPLY_IMPORTS ) ; if ( isApplyImports ) { maxImportLevel = xslInstruction . getStylesheetComposed ( ) . getImportCountComposed ( ) - 1 ; endImportLevel = xslInstruction . getStylesheetComposed ( ) . getEndImportCountComposed ( ) ; } else { maxImportLevel = - 1 ; } if ( isApplyImports && ( maxImportLevel == - 1 ) ) { template = null ; } else { XPathContext xctxt = m_xcontext ; try { xctxt . pushNamespaceContext ( xslInstruction ) ; QName mode = this . getMode ( ) ; if ( isApplyImports ) template = m_stylesheetRoot . getTemplateComposed ( xctxt , child , mode , maxImportLevel , endImportLevel , m_quietConflictWarnings , dtm ) ; else template = m_stylesheetRoot . getTemplateComposed ( xctxt , child , mode , m_quietConflictWarnings , dtm ) ; } finally { xctxt . popNamespaceContext ( ) ; } } if ( null == template ) { switch ( nodeType ) { case DTM . DOCUMENT_FRAGMENT_NODE : case DTM . ELEMENT_NODE : template = m_stylesheetRoot . getDefaultRule ( ) ; break ; case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : case DTM . ATTRIBUTE_NODE : template = m_stylesheetRoot . getDefaultTextRule ( ) ; isDefaultTextRule = true ; break ; case DTM . DOCUMENT_NODE : template = m_stylesheetRoot . getDefaultRootRule ( ) ; break ; default : return false ; } } } try { pushElemTemplateElement ( template ) ; m_xcontext . pushCurrentNode ( child ) ; pushPairCurrentMatched ( template , child ) ; if ( ! isApplyImports ) { DTMIterator cnl = new org . apache . xpath . NodeSetDTM ( child , m_xcontext . getDTMManager ( ) ) ; m_xcontext . pushContextNodeList ( cnl ) ; } if ( isDefaultTextRule ) { switch ( nodeType ) { case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : ClonerToResultTree . cloneToResultTree ( child , nodeType , dtm , getResultTreeHandler ( ) , false ) ; break ; case DTM . ATTRIBUTE_NODE : dtm . dispatchCharactersEvents ( child , getResultTreeHandler ( ) , false ) ; break ; } } else { if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEvent ( template ) ; m_xcontext . setSAXLocator ( template ) ; m_xcontext . getVarStack ( ) . link ( template . m_frameSize ) ; executeChildTemplates ( template , true ) ; if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEndEvent ( template ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { m_xcontext . getVarStack ( ) . unlink ( ) ; m_xcontext . popCurrentNode ( ) ; if ( ! isApplyImports ) { m_xcontext . popContextNodeList ( ) ; popCurrentMatched ( ) ; } popElemTemplateElement ( ) ; } return true ; } public void executeChildTemplates ( ElemTemplateElement elem , org . w3c . dom . Node context , QName mode , ContentHandler handler ) throws TransformerException { XPathContext xctxt = m_xcontext ; try { if ( null != mode ) pushMode ( mode ) ; xctxt . pushCurrentNode ( xctxt . getDTMHandleFromNode ( context ) ) ; executeChildTemplates ( elem , handler ) ; } finally { xctxt . popCurrentNode ( ) ; if ( null != mode ) popMode ( ) ; } } public void executeChildTemplates ( ElemTemplateElement elem , boolean shouldAddAttrs ) throws TransformerException { ElemTemplateElement t = elem . getFirstChildElem ( ) ; if ( null == t ) return ; if ( elem . hasTextLitOnly ( ) && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { char [ ] chars = ( ( ElemTextLiteral ) t ) . getChars ( ) ; try { this . pushElemTemplateElement ( t ) ; m_serializationHandler . characters ( chars , 0 , chars . length ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } finally { this . popElemTemplateElement ( ) ; } return ; } XPathContext xctxt = m_xcontext ; xctxt . pushSAXLocatorNull ( ) ; int currentTemplateElementsTop = m_currentTemplateElements . size ( ) ; m_currentTemplateElements . push ( null ) ; try { for ( ; t != null ; t = t . getNextSiblingElem ( ) ) { if ( ! shouldAddAttrs && t . getXSLToken ( ) == Constants . ELEMNAME_ATTRIBUTE ) continue ; xctxt . setSAXLocator ( t ) ; m_currentTemplateElements . setElementAt ( t , currentTemplateElementsTop ) ; t . execute ( this ) ; } } catch ( RuntimeException re ) { TransformerException te = new TransformerException ( re ) ; te . setLocator ( t ) ; throw te ; } finally { m_currentTemplateElements . pop ( ) ; xctxt . popSAXLocator ( ) ; } } public void executeChildTemplates ( ElemTemplateElement elem , ContentHandler handler ) throws TransformerException { SerializationHandler xoh = this . getSerializationHandler ( ) ; SerializationHandler savedHandler = xoh ; try { xoh . flushPending ( ) ; LexicalHandler lex = null ; if ( handler instanceof LexicalHandler ) { lex = ( LexicalHandler ) lex ; } m_serializationHandler = new ToXMLSAXHandler ( handler , lex , savedHandler . getEncoding ( ) ) ; executeChildTemplates ( elem , true ) ; } catch ( TransformerException e ) { throw e ; } finally { m_serializationHandler = savedHandler ; } } public Vector processSortKeys ( ElemForEach foreach , int sourceNodeContext ) throws TransformerException { Vector keys = null ; XPathContext xctxt = m_xcontext ; int nElems = foreach . getSortElemCount ( ) ; if ( nElems > 0 ) keys = new Vector ( ) ; for ( int i = 0 ; i < nElems ; i ++ ) { ElemSort sort = foreach . getSortElem ( i ) ; if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEvent ( sort ) ; String langString = ( null != sort . getLang ( ) ) ? sort . getLang ( ) . evaluate ( xctxt , sourceNodeContext , foreach ) : null ; String dataTypeString = sort . getDataType ( ) . evaluate ( xctxt , sourceNodeContext , foreach ) ; if ( dataTypeString . indexOf ( ":" ) >= 0 ) System . out . println ( "TODO: Need to write the hooks for QNAME sort data type" ) ; else if ( ! ( dataTypeString . equalsIgnoreCase ( Constants . ATTRVAL_DATATYPE_TEXT ) ) && ! ( dataTypeString . equalsIgnoreCase ( Constants . ATTRVAL_DATATYPE_NUMBER ) ) ) foreach . error ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_DATATYPE , dataTypeString } ) ; boolean treatAsNumbers = ( ( null != dataTypeString ) && dataTypeString . equals ( Constants . ATTRVAL_DATATYPE_NUMBER ) ) ? true : false ; String orderString = sort . getOrder ( ) . evaluate ( xctxt , sourceNodeContext , foreach ) ; if ( ! ( orderString . equalsIgnoreCase ( Constants . ATTRVAL_ORDER_ASCENDING ) ) && ! ( orderString . equalsIgnoreCase ( Constants . ATTRVAL_ORDER_DESCENDING ) ) ) foreach . error ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_ORDER , orderString } ) ; boolean descending = ( ( null != orderString ) && orderString . equals ( Constants . ATTRVAL_ORDER_DESCENDING ) ) ? true : false ; AVT caseOrder = sort . getCaseOrder ( ) ; boolean caseOrderUpper ; if ( null != caseOrder ) { String caseOrderString = caseOrder . evaluate ( xctxt , sourceNodeContext , foreach ) ; if ( ! ( caseOrderString . equalsIgnoreCase ( Constants . ATTRVAL_CASEORDER_UPPER ) ) && ! ( caseOrderString . equalsIgnoreCase ( Constants . ATTRVAL_CASEORDER_LOWER ) ) ) foreach . error ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_CASEORDER , caseOrderString } ) ; caseOrderUpper = ( ( null != caseOrderString ) && caseOrderString . equals ( Constants . ATTRVAL_CASEORDER_UPPER ) ) ? true : false ; } else { caseOrderUpper = false ; } keys . addElement ( new NodeSortKey ( this , sort . getSelect ( ) , treatAsNumbers , descending , langString , caseOrderUpper , foreach ) ) ; if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEndEvent ( sort ) ; } return keys ; } public Vector getElementCallstack ( ) { Vector elems = new Vector ( ) ; int nStackSize = m_currentTemplateElements . size ( ) ; for ( int i = 0 ; i < nStackSize ; i ++ ) { ElemTemplateElement elem = ( ElemTemplateElement ) m_currentTemplateElements . elementAt ( i ) ; if ( null != elem ) { elems . addElement ( elem ) ; } } return elems ; } public int getCurrentTemplateElementsCount ( ) { return m_currentTemplateElements . size ( ) ; } public ObjectStack getCurrentTemplateElements ( ) { return m_currentTemplateElements ; } public void pushElemTemplateElement ( ElemTemplateElement elem ) { m_currentTemplateElements . push ( elem ) ; } public void popElemTemplateElement ( ) { m_currentTemplateElements . pop ( ) ; } public void setCurrentElement ( ElemTemplateElement e ) { m_currentTemplateElements . setTop ( e ) ; } public ElemTemplateElement getCurrentElement ( ) { return ( m_currentTemplateElements . size ( ) > 0 ) ? ( ElemTemplateElement ) m_currentTemplateElements . peek ( ) : null ; } public int getCurrentNode ( ) { return m_xcontext . getCurrentNode ( ) ; } public Vector getTemplateCallstack ( ) { Vector elems = new Vector ( ) ; int nStackSize = m_currentTemplateElements . size ( ) ; for ( int i = 0 ; i < nStackSize ; i ++ ) { ElemTemplateElement elem = ( ElemTemplateElement ) m_currentTemplateElements . elementAt ( i ) ; if ( null != elem && ( elem . getXSLToken ( ) != Constants . ELEMNAME_TEMPLATE ) ) { elems . addElement ( elem ) ; } } return elems ; } public ElemTemplate getCurrentTemplate ( ) { ElemTemplateElement elem = getCurrentElement ( ) ; while ( ( null != elem ) && ( elem . getXSLToken ( ) != Constants . ELEMNAME_TEMPLATE ) ) { elem = elem . getParentElem ( ) ; } return ( ElemTemplate ) elem ; } public void pushPairCurrentMatched ( ElemTemplateElement template , int child ) { m_currentMatchTemplates . push ( template ) ; m_currentMatchedNodes . push ( child ) ; } public void popCurrentMatched ( ) { m_currentMatchTemplates . pop ( ) ; m_currentMatchedNodes . pop ( ) ; } public ElemTemplate getMatchedTemplate ( ) { return ( ElemTemplate ) m_currentMatchTemplates . peek ( ) ; } public int getMatchedNode ( ) { return m_currentMatchedNodes . peepTail ( ) ; } public DTMIterator getContextNodeList ( ) { try { DTMIterator cnl = m_xcontext . getContextNodeList ( ) ; return ( cnl == null ) ? null : ( DTMIterator ) cnl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { return null ; } } public Transformer getTransformer ( ) { return this ; } public void setStylesheet ( StylesheetRoot stylesheetRoot ) { m_stylesheetRoot = stylesheetRoot ; } public final StylesheetRoot getStylesheet ( ) { return m_stylesheetRoot ; } public boolean getQuietConflictWarnings ( ) { return m_quietConflictWarnings ; } public void setQuietConflictWarnings ( boolean b ) { m_quietConflictWarnings = b ; } public void setXPathContext ( XPathContext xcontext ) { m_xcontext = xcontext ; } public final XPathContext getXPathContext ( ) { return m_xcontext ; } public StackGuard getStackGuard ( ) { return m_stackGuard ; } public int getRecursionLimit ( ) { return m_stackGuard . getRecursionLimit ( ) ; } public void setRecursionLimit ( int limit ) { m_stackGuard . setRecursionLimit ( limit ) ; } public SerializationHandler getResultTreeHandler ( ) { return m_serializationHandler ; } public SerializationHandler getSerializationHandler ( ) { return m_serializationHandler ; } public KeyManager getKeyManager ( ) { return m_keyManager ; } public boolean isRecursiveAttrSet ( ElemAttributeSet attrSet ) { if ( null == m_attrSetStack ) { m_attrSetStack = new Stack ( ) ; } if ( ! m_attrSetStack . empty ( ) ) { int loc = m_attrSetStack . search ( attrSet ) ; if ( loc > - 1 ) { return true ; } } return false ; } public void pushElemAttributeSet ( ElemAttributeSet attrSet ) { m_attrSetStack . push ( attrSet ) ; } public void popElemAttributeSet ( ) { m_attrSetStack . pop ( ) ; } public CountersTable getCountersTable ( ) { if ( null == m_countersTable ) m_countersTable = new CountersTable ( ) ; return m_countersTable ; } public boolean currentTemplateRuleIsNull ( ) { return ( ( ! m_currentTemplateRuleIsNull . isEmpty ( ) ) && ( m_currentTemplateRuleIsNull . peek ( ) == true ) ) ; } public void pushCurrentTemplateRuleIsNull ( boolean b ) { m_currentTemplateRuleIsNull . push ( b ) ; } public void popCurrentTemplateRuleIsNull ( ) { m_currentTemplateRuleIsNull . pop ( ) ; } public MsgMgr getMsgMgr ( ) { if ( null == m_msgMgr ) m_msgMgr = new MsgMgr ( this ) ; return m_msgMgr ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { synchronized ( m_reentryGuard ) { if ( listener == null ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NULL_ERROR_HANDLER , null ) ) ; m_errorHandler = listener ; } } public ErrorListener getErrorListener ( ) { return m_errorHandler ; } public TraceManager getTraceManager ( ) { return m_traceManager ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( "http://xml.org/trax/features/sax/input" . equals ( name ) ) return true ; else if ( "http://xml.org/trax/features/dom/input" . equals ( name ) ) return true ; throw new SAXNotRecognizedException ( name ) ; } public QName getMode ( ) { return m_modes . isEmpty ( ) ? null : ( QName ) m_modes . peek ( ) ; } public void pushMode ( QName mode ) { m_modes . push ( mode ) ; } public void popMode ( ) { m_modes . pop ( ) ; } public void runTransformThread ( int priority ) { Thread t = ThreadControllerWrapper . runThread ( this , priority ) ; this . setTransformThread ( t ) ; } public void runTransformThread ( ) { ThreadControllerWrapper . runThread ( this , - 1 ) ; } public static void runTransformThread ( Runnable runnable ) { ThreadControllerWrapper . runThread ( runnable , - 1 ) ; } public void waitTransformThread ( ) throws SAXException { Thread transformThread = this . getTransformThread ( ) ; if ( null != transformThread ) { try { ThreadControllerWrapper . waitThread ( transformThread , this ) ; if ( ! this . hasTransformThreadErrorCatcher ( ) ) { Exception e = this . getExceptionThrown ( ) ; if ( null != e ) { e . printStackTrace ( ) ; throw new org . xml . sax . SAXException ( e ) ; } } this . setTransformThread ( null ) ; } catch ( InterruptedException ie ) { } } } public Exception getExceptionThrown ( ) { return m_exceptionThrown ; } public void setExceptionThrown ( Exception e ) { m_exceptionThrown = e ; } public void setSourceTreeDocForThread ( int doc ) { m_doc = doc ; } public void setXMLSource ( Source source ) { m_xmlSource = source ; } public boolean isTransformDone ( ) { synchronized ( this ) { return m_isTransformDone ; } } public void setIsTransformDone ( boolean done ) { synchronized ( this ) { m_isTransformDone = done ; } } void postExceptionFromThread ( Exception e ) { m_isTransformDone = true ; m_exceptionThrown = e ; ; synchronized ( this ) { notifyAll ( ) ; } } public void run ( ) { m_hasBeenReset = false ; try { try { m_isTransformDone = false ; transformNode ( m_doc ) ; } catch ( Exception e ) { if ( null != m_transformThread ) postExceptionFromThread ( e ) ; else throw new RuntimeException ( e . getMessage ( ) ) ; } finally { m_isTransformDone = true ; if ( m_inputContentHandler instanceof TransformerHandlerImpl ) { ( ( TransformerHandlerImpl ) m_inputContentHandler ) . clearCoRoutine ( ) ; } } } catch ( Exception e ) { if ( null != m_transformThread ) postExceptionFromThread ( e ) ; else throw new RuntimeException ( e . getMessage ( ) ) ; } } public TransformSnapshot getSnapshot ( ) { return new TransformSnapshotImpl ( this ) ; } public void executeFromSnapshot ( TransformSnapshot ts ) throws TransformerException { ElemTemplateElement template = getMatchedTemplate ( ) ; int child = getMatchedNode ( ) ; pushElemTemplateElement ( template ) ; m_xcontext . pushCurrentNode ( child ) ; this . executeChildTemplates ( template , true ) ; } public void resetToStylesheet ( TransformSnapshot ts ) { ( ( TransformSnapshotImpl ) ts ) . apply ( this ) ; } public void stopTransformation ( ) { } public short getShouldStripSpace ( int elementHandle , DTM dtm ) { try { org . apache . xalan . templates . WhiteSpaceInfo info = m_stylesheetRoot . getWhiteSpaceInfo ( m_xcontext , elementHandle , dtm ) ; if ( null == info ) { return DTMWSFilter . INHERIT ; } else { return info . getShouldStripSpace ( ) ? DTMWSFilter . STRIP : DTMWSFilter . NOTSTRIP ; } } catch ( TransformerException se ) { return DTMWSFilter . INHERIT ; } } public void init ( ToXMLSAXHandler h , Transformer transformer , ContentHandler realHandler ) { h . setTransformer ( transformer ) ; h . setContentHandler ( realHandler ) ; } public void setSerializationHandler ( SerializationHandler xoh ) { m_serializationHandler = xoh ; } public void fireGenerateEvent ( int eventType , char [ ] ch , int start , int length ) { GenerateEvent ge = new GenerateEvent ( this , eventType , ch , start , length ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public void fireGenerateEvent ( int eventType , String name , Attributes atts ) { GenerateEvent ge = new GenerateEvent ( this , eventType , name , atts ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public void fireGenerateEvent ( int eventType , String name , String data ) { GenerateEvent ge = new GenerateEvent ( this , eventType , name , data ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public void fireGenerateEvent ( int eventType , String data ) { GenerateEvent ge = new GenerateEvent ( this , eventType , data ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public void fireGenerateEvent ( int eventType ) { GenerateEvent ge = new GenerateEvent ( this , eventType ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public boolean hasTraceListeners ( ) { return m_traceManager . hasTraceListeners ( ) ; } } 	1	['130', '2', '0', '117', '391', '7393', '66', '68', '122', '0.942357384', '3398', '0.743589744', '16', '0.092198582', '0.053123575', '1', '2', '24.83846154', '4', '1.3231', '9']
package org . apache . xalan . xsltc . trax ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . TemplatesHandler ; import org . apache . xalan . xsltc . compiler . CompilerException ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . SourceLoader ; import org . apache . xalan . xsltc . compiler . Stylesheet ; import org . apache . xalan . xsltc . compiler . SyntaxTreeNode ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . Attributes ; public class TemplatesHandlerImpl implements ContentHandler , TemplatesHandler , SourceLoader { private String _systemId ; private int _indentNumber ; private URIResolver _uriResolver = null ; private TransformerFactoryImpl _tfactory = null ; private Parser _parser = null ; protected TemplatesHandlerImpl ( int indentNumber , TransformerFactoryImpl tfactory ) { _indentNumber = indentNumber ; _tfactory = tfactory ; XSLTC xsltc = new XSLTC ( ) ; xsltc . init ( ) ; xsltc . setOutputType ( XSLTC . BYTEARRAY_OUTPUT ) ; _parser = xsltc . getParser ( ) ; } public String getSystemId ( ) { return _systemId ; } public void setSystemId ( String id ) { _systemId = id ; } public void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } public Templates getTemplates ( ) { try { XSLTC xsltc = _parser . getXSLTC ( ) ; if ( _uriResolver != null ) { xsltc . setSourceLoader ( this ) ; } String transletName = null ; if ( _systemId != null ) { transletName = Util . baseName ( _systemId ) ; } else { transletName = ( String ) _tfactory . getAttribute ( "translet-name" ) ; } xsltc . setClassName ( transletName ) ; transletName = xsltc . getClassName ( ) ; Stylesheet stylesheet = null ; SyntaxTreeNode root = _parser . getDocumentRoot ( ) ; if ( ! _parser . errorsFound ( ) && root != null ) { stylesheet = _parser . makeStylesheet ( root ) ; stylesheet . setSystemId ( _systemId ) ; stylesheet . setParentStylesheet ( null ) ; _parser . setCurrentStylesheet ( stylesheet ) ; xsltc . setStylesheet ( stylesheet ) ; _parser . createAST ( stylesheet ) ; } if ( ! _parser . errorsFound ( ) && stylesheet != null ) { stylesheet . setMultiDocument ( xsltc . isMultiDocument ( ) ) ; stylesheet . setHasIdCall ( xsltc . hasIdCall ( ) ) ; synchronized ( xsltc . getClass ( ) ) { stylesheet . translate ( ) ; } } if ( ! _parser . errorsFound ( ) ) { final byte [ ] [ ] bytecodes = xsltc . getBytecodes ( ) ; if ( bytecodes != null ) { final TemplatesImpl templates = new TemplatesImpl ( xsltc . getBytecodes ( ) , transletName , _parser . getOutputProperties ( ) , _indentNumber , _tfactory ) ; if ( _uriResolver != null ) { templates . setURIResolver ( _uriResolver ) ; } return templates ; } } } catch ( CompilerException e ) { } return null ; } public InputSource loadSource ( String href , String context , XSLTC xsltc ) { try { final Source source = _uriResolver . resolve ( href , context ) ; if ( source != null ) { return Util . getInputSource ( xsltc , source ) ; } } catch ( TransformerException e ) { } return null ; } public void startDocument ( ) { _parser . init ( ) ; _parser . startDocument ( ) ; } public void endDocument ( ) { _parser . endDocument ( ) ; } public void startPrefixMapping ( String prefix , String uri ) { _parser . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) { _parser . endPrefixMapping ( prefix ) ; } public void startElement ( String uri , String localname , String qname , Attributes attributes ) throws SAXException { _parser . startElement ( uri , localname , qname , attributes ) ; } public void endElement ( String uri , String localname , String qname ) { _parser . endElement ( uri , localname , qname ) ; } public void characters ( char [ ] ch , int start , int length ) { _parser . characters ( ch , start , length ) ; } public void processingInstruction ( String name , String value ) { _parser . processingInstruction ( name , value ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { _parser . ignorableWhitespace ( ch , start , length ) ; } public void skippedEntity ( String name ) { _parser . skippedEntity ( name ) ; } public void setDocumentLocator ( Locator locator ) { setSystemId ( locator . getSystemId ( ) ) ; _parser . setDocumentLocator ( locator ) ; } } 	1	['17', '1', '0', '9', '61', '0', '1', '9', '16', '0.75', '283', '1', '2', '0', '0.22875817', '0', '0', '15.35294118', '8', '1.3529', '1']
package org . apache . xalan . templates ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; public class ElemTemplate extends ElemTemplateElement { private String m_publicId ; private String m_systemId ; public String getPublicId ( ) { return m_publicId ; } public String getSystemId ( ) { return m_systemId ; } public void setLocaterInfo ( SourceLocator locator ) { m_publicId = locator . getPublicId ( ) ; m_systemId = locator . getSystemId ( ) ; super . setLocaterInfo ( locator ) ; } private Stylesheet m_stylesheet ; public StylesheetComposed getStylesheetComposed ( ) { return m_stylesheet . getStylesheetComposed ( ) ; } public Stylesheet getStylesheet ( ) { return m_stylesheet ; } public void setStylesheet ( Stylesheet sheet ) { m_stylesheet = sheet ; } public StylesheetRoot getStylesheetRoot ( ) { return m_stylesheet . getStylesheetRoot ( ) ; } private XPath m_matchPattern = null ; public void setMatch ( XPath v ) { m_matchPattern = v ; } public XPath getMatch ( ) { return m_matchPattern ; } private QName m_name = null ; public void setName ( QName v ) { m_name = v ; } public QName getName ( ) { return m_name ; } private QName m_mode ; public void setMode ( QName v ) { m_mode = v ; } public QName getMode ( ) { return m_mode ; } private double m_priority = XPath . MATCH_SCORE_NONE ; public void setPriority ( double v ) { m_priority = v ; } public double getPriority ( ) { return m_priority ; } public int getXSLToken ( ) { return Constants . ELEMNAME_TEMPLATE ; } public String getNodeName ( ) { return Constants . ELEMNAME_TEMPLATE_STRING ; } public int m_frameSize ; int m_inArgsSize ; private int [ ] m_argsQNameIDs ; public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_matchPattern ) m_matchPattern . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; cstate . resetStackFrameSize ( ) ; m_inArgsSize = 0 ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; super . endCompose ( sroot ) ; m_frameSize = cstate . getFrameSize ( ) ; cstate . resetStackFrameSize ( ) ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; transformer . getStackGuard ( ) . checkForInfinateLoop ( ) ; xctxt . pushRTFContext ( ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; xctxt . popRTFContext ( ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeTemplates ( this ) ; } } 	1	['22', '3', '2', '27', '46', '189', '22', '11', '22', '0.942857143', '179', '0.8', '4', '0.903225806', '0.181818182', '2', '14', '6.681818182', '1', '0.9545', '1']
package org . apache . xml . utils ; import java . util . Vector ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class ObjectPool implements java . io . Serializable { private final Class objectType ; private final Vector freeStack ; public ObjectPool ( Class type ) { objectType = type ; freeStack = new Vector ( ) ; } public ObjectPool ( String className ) { try { objectType = Class . forName ( className ) ; } catch ( ClassNotFoundException cnfe ) { throw new WrappedRuntimeException ( cnfe ) ; } freeStack = new Vector ( ) ; } public ObjectPool ( Class type , int size ) { objectType = type ; freeStack = new Vector ( size ) ; } public ObjectPool ( ) { objectType = null ; freeStack = new Vector ( ) ; } public synchronized Object getInstanceIfFree ( ) { if ( ! freeStack . isEmpty ( ) ) { Object result = freeStack . lastElement ( ) ; freeStack . setSize ( freeStack . size ( ) - 1 ) ; return result ; } return null ; } public synchronized Object getInstance ( ) { if ( freeStack . isEmpty ( ) ) { try { return objectType . newInstance ( ) ; } catch ( InstantiationException ex ) { } catch ( IllegalAccessException ex ) { } throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_EXCEPTION_CREATING_POOL , null ) ) ; } else { Object result = freeStack . lastElement ( ) ; freeStack . setSize ( freeStack . size ( ) - 1 ) ; return result ; } } public synchronized void freeInstance ( Object obj ) { freeStack . addElement ( obj ) ; } } 	1	['7', '1', '0', '4', '20', '0', '2', '2', '7', '0.166666667', '119', '1', '0', '0', '0.342857143', '0', '0', '15.71428571', '2', '0.7143', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; abstract class Expression extends SyntaxTreeNode { protected Type _type ; protected boolean _startReset = false ; protected FlowList _trueList = new FlowList ( ) ; protected FlowList _falseList = new FlowList ( ) ; public Type getType ( ) { return _type ; } public abstract String toString ( ) ; public boolean hasPositionCall ( ) { return false ; } public boolean hasLastCall ( ) { return false ; } public Object evaluateAtCompileTime ( ) { return null ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . NOT_IMPLEMENTED_ERR , getClass ( ) , this ) ; getParser ( ) . reportError ( FATAL , msg ) ; } public final InstructionList compile ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList result , save = methodGen . getInstructionList ( ) ; methodGen . setInstructionList ( result = new InstructionList ( ) ) ; translate ( classGen , methodGen ) ; methodGen . setInstructionList ( save ) ; return result ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { translate ( classGen , methodGen ) ; if ( _type instanceof BooleanType ) { desynthesize ( classGen , methodGen ) ; } } public void startResetIterator ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _startReset ) { return ; } _startReset = true ; if ( _type instanceof NodeSetType == false ) { return ; } if ( ( this instanceof VariableRefBase ) == false ) { il . append ( methodGen . loadContextNode ( ) ) ; il . append ( methodGen . setStartNode ( ) ) ; } } public void synthesize ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _trueList . backPatch ( il . append ( ICONST_1 ) ) ; final BranchHandle truec = il . append ( new GOTO_W ( null ) ) ; _falseList . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void desynthesize ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; } public FlowList getFalseList ( ) { return _falseList ; } public FlowList getTrueList ( ) { return _trueList ; } public void backPatchFalseList ( InstructionHandle ih ) { _falseList . backPatch ( ih ) ; } public void backPatchTrueList ( InstructionHandle ih ) { _trueList . backPatch ( ih ) ; } public MethodType lookupPrimop ( SymbolTable stable , String op , MethodType ctype ) { MethodType result = null ; final Vector primop = stable . lookupPrimop ( op ) ; if ( primop != null ) { final int n = primop . size ( ) ; int minDistance = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { final MethodType ptype = ( MethodType ) primop . elementAt ( i ) ; if ( ptype . argsCount ( ) != ctype . argsCount ( ) ) { continue ; } if ( result == null ) { result = ptype ; } final int distance = ctype . distanceTo ( ptype ) ; if ( distance < minDistance ) { minDistance = distance ; result = ptype ; } } } return result ; } } 	1	['18', '2', '22', '83', '43', '115', '64', '21', '17', '0.838235294', '238', '1', '3', '0.76056338', '0.285714286', '1', '2', '12', '6', '1.4444', '1']
package org . apache . xml . utils . res ; public class XResources_ka extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ka" } , { "help_language" , "ka" } , { "language" , "ka" } , { "alphabet" , new char [ ] { 0x10D0 , 0x10D1 , 0x10D2 , 0x10D3 , 0x10D4 , 0x10D5 , 0x10D6 , 0x10f1 , 0x10D7 , 0x10D8 , 0x10D9 , 0x10DA , 0x10DB , 0x10DC , 0x10f2 , 0x10DD , 0x10DE , 0x10DF , 0x10E0 , 0x10E1 , 0x10E2 , 0x10E3 , 0x10E4 , 0x10E5 , 0x10E6 , 0x10E7 , 0x10E8 , 0x10E9 , 0x10EA , 0x10EB , 0x10EC , 0x10ED , 0x10EE , 0x10F4 , 0x10EF , 0x10F0 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , { "numberGroups" , new int [ ] { 1000 , 100 , 10 , 1 } } , { "digits" , new char [ ] { 0x10D0 , 0x10D1 , 0x10D2 , 0x10D3 , 0x10D4 , 0x10D5 , 0x10D6 , 0x10f1 , 0x10D7 } } , { "tens" , new char [ ] { 0x10D8 , 0x10D9 , 0x10DA , 0x10DB , 0x10DC , 0x10f2 , 0x10DD , 0x10DE , 0x10DF } } , { "hundreds" , new char [ ] { 0x10E0 , 0x10E1 , 0x10E2 , 0x10E3 , 0x10E4 , 0x10E5 , 0x10E6 , 0x10E7 , 0x10E8 } } , { "thousands" , new char [ ] { 0x10E9 , 0x10EA , 0x10EB , 0x10EC , 0x10ED , 0x10EE , 0x10F4 , 0x10EF , 0x10F0 } } , { "tables" , new String [ ] { "thousands" , "hundreds" , "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '614', '0', '0', '0.976190476', '1', '0', '0', '203.3333333', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . NamespaceMappings ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . QName ; import org . xml . sax . SAXException ; public class ElemAttribute extends ElemElement { public int getXSLToken ( ) { return Constants . ELEMNAME_ATTRIBUTE ; } public String getNodeName ( ) { return Constants . ELEMNAME_ATTRIBUTE_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { SerializationHandler rhandler = transformer . getSerializationHandler ( ) ; super . execute ( transformer ) ; } protected String resolvePrefix ( SerializationHandler rhandler , String prefix , String nodeNamespace ) throws TransformerException { if ( null != prefix && ( prefix . length ( ) == 0 || prefix . equals ( "xmlns" ) ) ) { prefix = rhandler . getPrefix ( nodeNamespace ) ; if ( null == prefix || prefix . length ( ) == 0 || prefix . equals ( "xmlns" ) ) { if ( nodeNamespace . length ( ) > 0 ) { NamespaceMappings prefixMapping = rhandler . getNamespaceMappings ( ) ; prefix = prefixMapping . generateNextPrefix ( ) ; } else prefix = "" ; } } return prefix ; } protected boolean validateNodeName ( String nodeName ) { if ( null == nodeName ) return false ; if ( nodeName . equals ( "xmlns" ) ) return false ; return super . validateNodeName ( nodeName ) ; } void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { if ( null != nodeName && nodeName . length ( ) > 0 ) { SerializationHandler rhandler = transformer . getSerializationHandler ( ) ; if ( prefix != null && prefix . length ( ) > 0 ) { try { rhandler . startPrefixMapping ( prefix , nodeNamespace , false ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } } String val = transformer . transformToString ( this ) ; String localName = QName . getLocalPart ( nodeName ) ; try { rhandler . addAttribute ( nodeNamespace , localName , nodeName , "CDATA" , val ) ; } catch ( SAXException e ) { } } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } public void setName ( AVT v ) { if ( v . isSimple ( ) ) { if ( v . getSimpleString ( ) . equals ( "xmlns" ) ) { throw new IllegalArgumentException ( ) ; } } super . setName ( v ) ; } } 	1	['9', '5', '0', '9', '31', '36', '2', '7', '6', '2', '161', '0', '0', '0.963800905', '0.314814815', '4', '10', '16.88888889', '16', '3', '3']
package org . apache . xalan . serialize ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . serializer . NamespaceMappings ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . xml . sax . SAXException ; public class SerializerUtils { public static void addAttribute ( SerializationHandler handler , int attr ) throws TransformerException { TransformerImpl transformer = ( TransformerImpl ) handler . getTransformer ( ) ; DTM dtm = transformer . getXPathContext ( ) . getDTM ( attr ) ; if ( SerializerUtils . isDefinedNSDecl ( handler , attr , dtm ) ) return ; String ns = dtm . getNamespaceURI ( attr ) ; if ( ns == null ) ns = "" ; try { handler . addAttribute ( ns , dtm . getLocalName ( attr ) , dtm . getNodeName ( attr ) , "CDATA" , dtm . getNodeValue ( attr ) ) ; } catch ( SAXException e ) { } } public static void addAttributes ( SerializationHandler handler , int src ) throws TransformerException { TransformerImpl transformer = ( TransformerImpl ) handler . getTransformer ( ) ; DTM dtm = transformer . getXPathContext ( ) . getDTM ( src ) ; for ( int node = dtm . getFirstAttribute ( src ) ; DTM . NULL != node ; node = dtm . getNextAttribute ( node ) ) { addAttribute ( handler , node ) ; } } public static void outputResultTreeFragment ( SerializationHandler handler , XObject obj , XPathContext support ) throws org . xml . sax . SAXException { int doc = obj . rtf ( ) ; DTM dtm = support . getDTM ( doc ) ; if ( null != dtm ) { for ( int n = dtm . getFirstChild ( doc ) ; DTM . NULL != n ; n = dtm . getNextSibling ( n ) ) { handler . flushPending ( ) ; if ( dtm . getNamespaceURI ( n ) == null ) handler . startPrefixMapping ( "" , "" ) ; dtm . dispatchToEvents ( n , handler ) ; } } } public static void processNSDecls ( SerializationHandler handler , int src , int type , DTM dtm ) throws TransformerException { try { if ( type == DTM . ELEMENT_NODE ) { for ( int namespace = dtm . getFirstNamespaceNode ( src , true ) ; DTM . NULL != namespace ; namespace = dtm . getNextNamespaceNode ( src , namespace , true ) ) { String prefix = dtm . getNodeNameX ( namespace ) ; String desturi = handler . getNamespaceURIFromPrefix ( prefix ) ; String srcURI = dtm . getNodeValue ( namespace ) ; if ( ! srcURI . equalsIgnoreCase ( desturi ) ) { handler . startPrefixMapping ( prefix , srcURI , false ) ; } } } else if ( type == DTM . NAMESPACE_NODE ) { String prefix = dtm . getNodeNameX ( src ) ; String desturi = handler . getNamespaceURIFromPrefix ( prefix ) ; String srcURI = dtm . getNodeValue ( src ) ; if ( ! srcURI . equalsIgnoreCase ( desturi ) ) { handler . startPrefixMapping ( prefix , srcURI , false ) ; } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } public static boolean isDefinedNSDecl ( SerializationHandler serializer , int attr , DTM dtm ) { if ( DTM . NAMESPACE_NODE == dtm . getNodeType ( attr ) ) { String prefix = dtm . getNodeNameX ( attr ) ; String uri = serializer . getNamespaceURIFromPrefix ( prefix ) ; if ( ( null != uri ) && uri . equals ( dtm . getStringValue ( attr ) ) ) return true ; } return false ; } public static void ensureNamespaceDeclDeclared ( SerializationHandler handler , DTM dtm , int namespace ) throws org . xml . sax . SAXException { String uri = dtm . getNodeValue ( namespace ) ; String prefix = dtm . getNodeNameX ( namespace ) ; if ( ( uri != null && uri . length ( ) > 0 ) && ( null != prefix ) ) { String foundURI ; NamespaceMappings ns = handler . getNamespaceMappings ( ) ; if ( ns != null ) { foundURI = ns . lookupNamespace ( prefix ) ; if ( ( null == foundURI ) || ! foundURI . equals ( uri ) ) { handler . startPrefixMapping ( prefix , uri , false ) ; } } } } } 	1	['7', '1', '0', '12', '37', '21', '5', '7', '7', '2', '250', '0', '0', '0', '0.404761905', '0', '0', '34.71428571', '4', '1.2857', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import org . apache . xml . serializer . CharInfo ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ToTextStream extends ToStream { public ToTextStream ( ) { super ( ) ; } protected void startDocumentInternal ( ) throws org . xml . sax . SAXException { super . startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } public void endDocument ( ) throws org . xml . sax . SAXException { flushPending ( ) ; flushWriter ( ) ; super . fireEndDoc ( ) ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { m_currentElemDepth ++ ; super . fireStartElem ( name ) ; return ; } public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { m_currentElemDepth -- ; super . fireEndElem ( name ) ; } public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { flushPending ( ) ; try { writeNormalizedChars ( ch , start , length , false ) ; super . fireCharEvent ( ch , start , length ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } void writeNormalizedChars ( final char ch [ ] , final int start , final int length , final boolean isCData ) throws IOException , org . xml . sax . SAXException { final int end = start + length ; final char S_LINEFEED = CharInfo . S_LINEFEED ; final int M_MAXCHARACTER = this . m_maxCharacter ; if ( isCData ) { for ( int i = start ; i < end ; i ++ ) { final char c = ch [ i ] ; if ( S_LINEFEED == c ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else if ( c > M_MAXCHARACTER ) { if ( i != 0 ) closeCDATA ( ) ; if ( isUTF16Surrogate ( c ) ) { i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { m_writer . write ( c ) ; } if ( ( i != 0 ) && ( i < ( end - 1 ) ) ) { m_writer . write ( CDATA_DELIMITER_OPEN ) ; m_cdataTagOpen = true ; } } else if ( ( ( i < ( end - 2 ) ) && ( ']' == c ) && ( ']' == ch [ i + 1 ] ) && ( '>' == ch [ i + 2 ] ) ) ) { m_writer . write ( CDATA_CONTINUE ) ; i += 2 ; } else { if ( c <= M_MAXCHARACTER ) { m_writer . write ( c ) ; } else if ( isUTF16Surrogate ( c ) ) { i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { m_writer . write ( c ) ; } } } } else { for ( int i = start ; i < end ; i ++ ) { final char c = ch [ i ] ; if ( S_LINEFEED == c ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else if ( c <= M_MAXCHARACTER ) { m_writer . write ( c ) ; } else if ( isUTF16Surrogate ( c ) ) { i = writeUTF16Surrogate ( c , ch , i , end ) ; } else { m_writer . write ( c ) ; } } } } public void cdata ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false ) ; super . fireCDATAEvent ( ch , start , length ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { flushPending ( ) ; super . fireEscapingEvent ( target , data ) ; } public void comment ( String data ) throws org . xml . sax . SAXException { comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { flushPending ( ) ; super . fireCommentEvent ( ch , start , length ) ; } public void entityReference ( String name ) throws org . xml . sax . SAXException { super . fireEntityReference ( name ) ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) { } public void endCDATA ( ) throws SAXException { } public void endElement ( String elemName ) throws SAXException { m_currentElemDepth -- ; super . fireEndElem ( elemName ) ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { m_currentElemDepth ++ ; if ( m_needToCallStartDocument ) startDocumentInternal ( ) ; super . fireStartElem ( elementName ) ; return ; } public void characters ( String characters ) throws SAXException { characters ( characters . toCharArray ( ) , 0 , characters . length ( ) ) ; } public void addAttribute ( String name , String value ) { } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { return false ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { } public void flushPending ( ) { try { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } } catch ( SAXException e ) { } } } 	1	['24', '3', '0', '3', '44', '258', '2', '1', '22', '2', '376', '0', '0', '0.880208333', '0.361111111', '2', '14', '14.66666667', '1', '0.9583', '1']
package org . apache . xalan . processor ; import org . apache . xalan . templates . DecimalFormatProperties ; import org . xml . sax . Attributes ; class ProcessorDecimalFormat extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { DecimalFormatProperties dfp = new DecimalFormatProperties ( handler . nextUid ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , dfp ) ; handler . getStylesheet ( ) . setDecimalFormat ( dfp ) ; handler . getStylesheet ( ) . appendChild ( dfp ) ; } } 	1	['2', '4', '0', '6', '9', '1', '1', '5', '1', '2', '27', '0', '0', '0.995260664', '0.625', '2', '2', '12.5', '1', '0.5', '2']
package org . apache . xml . utils . res ; public class XResources_el extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "el" } , { "help_language" , "el" } , { "language" , "el" } , { "alphabet" , new char [ ] { 0x03b1 , 0x03b2 , 0x03b3 , 0x03b4 , 0x03b5 , 0x03b6 , 0x03b7 , 0x03b8 , 0x03b9 , 0x03ba , 0x03bb , 0x03bc , 0x03bd , 0x03be , 0x03bf , 0x03c0 , 0x03c1 , 0x03c2 , 0x03c3 , 0x03c4 , 0x03c5 , 0x03c6 , 0x03c7 , 0x03c8 , 0x03c9 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "precedes" } , { "numberGroups" , new int [ ] { 100 , 10 , 1 } } , { "multiplier" , new long [ ] { 1000 } } , { "multiplierChar" , new char [ ] { 0x03d9 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x03b1 , 0x03b2 , 0x03b3 , 0x03b4 , 0x03b5 , 0x03db , 0x03b6 , 0x03b7 , 0x03b8 } } , { "tens" , new char [ ] { 0x03b9 , 0x03ba , 0x03bb , 0x03bc , 0x03bd , 0x03be , 0x03bf , 0x03c0 , 0x03df } } , { "hundreds" , new char [ ] { 0x03c1 , 0x03c2 , 0x03c4 , 0x03c5 , 0x03c6 , 0x03c7 , 0x03c8 , 0x03c9 , 0x03e1 } } , { "tables" , new String [ ] { "hundreds" , "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '575', '0', '0', '0.976190476', '1', '0', '0', '190.3333333', '1', '0.3333', '1']
package org . apache . xml . dtm ; public class DTMDOMException extends org . w3c . dom . DOMException { public DTMDOMException ( short code , String message ) { super ( code , message ) ; } public DTMDOMException ( short code ) { super ( code , "" ) ; } } 	1	['2', '5', '0', '3', '3', '1', '3', '0', '2', '2', '12', '0', '0', '1', '0.833333333', '0', '0', '5', '0', '0', '1']
package org . apache . xml . utils . res ; public class XResources_es extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "es" } , { "help_language" , "es" } , { "language" , "es" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . compiler . Compiler ; public class WalkingIteratorSorted extends WalkingIterator { protected boolean m_inNaturalOrderStatic = false ; public WalkingIteratorSorted ( PrefixResolver nscontext ) { super ( nscontext ) ; } WalkingIteratorSorted ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , shouldLoadWalkers ) ; } public boolean isDocOrdered ( ) { return m_inNaturalOrderStatic ; } boolean canBeWalkedInNaturalDocOrderStatic ( ) { if ( null != m_firstWalker ) { AxesWalker walker = m_firstWalker ; int prevAxis = - 1 ; boolean prevIsSimpleDownAxis = true ; for ( int i = 0 ; null != walker ; i ++ ) { int axis = walker . getAxis ( ) ; if ( walker . isDocOrdered ( ) ) { boolean isSimpleDownAxis = ( ( axis == Axis . CHILD ) || ( axis == Axis . SELF ) || ( axis == Axis . ROOT ) ) ; if ( isSimpleDownAxis || ( axis == - 1 ) ) walker = walker . getNextWalker ( ) ; else { boolean isLastWalker = ( null == walker . getNextWalker ( ) ) ; if ( isLastWalker ) { if ( walker . isDocOrdered ( ) && ( axis == Axis . DESCENDANT || axis == Axis . DESCENDANTORSELF || axis == Axis . DESCENDANTSFROMROOT || axis == Axis . DESCENDANTSORSELFFROMROOT ) || ( axis == Axis . ATTRIBUTE ) ) return true ; } return false ; } } else return false ; } return true ; } return false ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; int analysis = getAnalysisBits ( ) ; if ( WalkerFactory . isNaturalDocOrder ( analysis ) ) { m_inNaturalOrderStatic = true ; } else { m_inNaturalOrderStatic = false ; } } } 	1	['5', '6', '0', '5', '13', '0', '1', '5', '3', '0.25', '129', '1', '0', '0.979020979', '0.366666667', '1', '1', '24.6', '17', '4', '1']
package org . apache . xml . utils . res ; public class XResources_fr extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "fr" } , { "help_language" , "fr" } , { "language" , "fr" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . text . MessageFormat ; import java . util . Locale ; import java . util . ResourceBundle ; import org . apache . xalan . xsltc . compiler . Stylesheet ; import org . apache . xalan . xsltc . compiler . SyntaxTreeNode ; public final class ErrorMsg { private String _code ; private int _line ; private String _message = null ; private String _url = null ; Object [ ] _params = null ; public static final String MULTIPLE_STYLESHEET_ERR = "MULTIPLE_STYLESHEET_ERR" ; public static final String TEMPLATE_REDEF_ERR = "TEMPLATE_REDEF_ERR" ; public static final String TEMPLATE_UNDEF_ERR = "TEMPLATE_UNDEF_ERR" ; public static final String VARIABLE_REDEF_ERR = "VARIABLE_REDEF_ERR" ; public static final String VARIABLE_UNDEF_ERR = "VARIABLE_UNDEF_ERR" ; public static final String CLASS_NOT_FOUND_ERR = "CLASS_NOT_FOUND_ERR" ; public static final String METHOD_NOT_FOUND_ERR = "METHOD_NOT_FOUND_ERR" ; public static final String ARGUMENT_CONVERSION_ERR = "ARGUMENT_CONVERSION_ERR" ; public static final String FILE_NOT_FOUND_ERR = "FILE_NOT_FOUND_ERR" ; public static final String INVALID_URI_ERR = "INVALID_URI_ERR" ; public static final String FILE_ACCESS_ERR = "FILE_ACCESS_ERR" ; public static final String MISSING_ROOT_ERR = "MISSING_ROOT_ERR" ; public static final String NAMESPACE_UNDEF_ERR = "NAMESPACE_UNDEF_ERR" ; public static final String FUNCTION_RESOLVE_ERR = "FUNCTION_RESOLVE_ERR" ; public static final String NEED_LITERAL_ERR = "NEED_LITERAL_ERR" ; public static final String XPATH_PARSER_ERR = "XPATH_PARSER_ERR" ; public static final String REQUIRED_ATTR_ERR = "REQUIRED_ATTR_ERR" ; public static final String ILLEGAL_CHAR_ERR = "ILLEGAL_CHAR_ERR" ; public static final String ILLEGAL_PI_ERR = "ILLEGAL_PI_ERR" ; public static final String STRAY_ATTRIBUTE_ERR = "STRAY_ATTRIBUTE_ERR" ; public static final String ILLEGAL_ATTRIBUTE_ERR = "ILLEGAL_ATTRIBUTE_ERR" ; public static final String CIRCULAR_INCLUDE_ERR = "CIRCULAR_INCLUDE_ERR" ; public static final String RESULT_TREE_SORT_ERR = "RESULT_TREE_SORT_ERR" ; public static final String SYMBOLS_REDEF_ERR = "SYMBOLS_REDEF_ERR" ; public static final String XSL_VERSION_ERR = "XSL_VERSION_ERR" ; public static final String CIRCULAR_VARIABLE_ERR = "CIRCULAR_VARIABLE_ERR" ; public static final String ILLEGAL_BINARY_OP_ERR = "ILLEGAL_BINARY_OP_ERR" ; public static final String ILLEGAL_ARG_ERR = "ILLEGAL_ARG_ERR" ; public static final String DOCUMENT_ARG_ERR = "DOCUMENT_ARG_ERR" ; public static final String MISSING_WHEN_ERR = "MISSING_WHEN_ERR" ; public static final String MULTIPLE_OTHERWISE_ERR = "MULTIPLE_OTHERWISE_ERR" ; public static final String STRAY_OTHERWISE_ERR = "STRAY_OTHERWISE_ERR" ; public static final String STRAY_WHEN_ERR = "STRAY_WHEN_ERR" ; public static final String WHEN_ELEMENT_ERR = "WHEN_ELEMENT_ERR" ; public static final String UNNAMED_ATTRIBSET_ERR = "UNNAMED_ATTRIBSET_ERR" ; public static final String ILLEGAL_CHILD_ERR = "ILLEGAL_CHILD_ERR" ; public static final String ILLEGAL_ELEM_NAME_ERR = "ILLEGAL_ELEM_NAME_ERR" ; public static final String ILLEGAL_ATTR_NAME_ERR = "ILLEGAL_ATTR_NAME_ERR" ; public static final String ILLEGAL_TEXT_NODE_ERR = "ILLEGAL_TEXT_NODE_ERR" ; public static final String SAX_PARSER_CONFIG_ERR = "SAX_PARSER_CONFIG_ERR" ; public static final String INTERNAL_ERR = "INTERNAL_ERR" ; public static final String UNSUPPORTED_XSL_ERR = "UNSUPPORTED_XSL_ERR" ; public static final String UNSUPPORTED_EXT_ERR = "UNSUPPORTED_EXT_ERR" ; public static final String MISSING_XSLT_URI_ERR = "MISSING_XSLT_URI_ERR" ; public static final String MISSING_XSLT_TARGET_ERR = "MISSING_XSLT_TARGET_ERR" ; public static final String NOT_IMPLEMENTED_ERR = "NOT_IMPLEMENTED_ERR" ; public static final String NOT_STYLESHEET_ERR = "NOT_STYLESHEET_ERR" ; public static final String ELEMENT_PARSE_ERR = "ELEMENT_PARSE_ERR" ; public static final String KEY_USE_ATTR_ERR = "KEY_USE_ATTR_ERR" ; public static final String OUTPUT_VERSION_ERR = "OUTPUT_VERSION_ERR" ; public static final String ILLEGAL_RELAT_OP_ERR = "ILLEGAL_RELAT_OP_ERR" ; public static final String ATTRIBSET_UNDEF_ERR = "ATTRIBSET_UNDEF_ERR" ; public static final String ATTR_VAL_TEMPLATE_ERR = "ATTR_VAL_TEMPLATE_ERR" ; public static final String UNKNOWN_SIG_TYPE_ERR = "UNKNOWN_SIG_TYPE_ERR" ; public static final String DATA_CONVERSION_ERR = "DATA_CONVERSION_ERR" ; public static final String NO_TRANSLET_CLASS_ERR = "NO_TRANSLET_CLASS_ERR" ; public static final String NO_MAIN_TRANSLET_ERR = "NO_MAIN_TRANSLET_ERR" ; public static final String TRANSLET_CLASS_ERR = "TRANSLET_CLASS_ERR" ; public static final String TRANSLET_OBJECT_ERR = "TRANSLET_OBJECT_ERR" ; public static final String ERROR_LISTENER_NULL_ERR = "ERROR_LISTENER_NULL_ERR" ; public static final String JAXP_UNKNOWN_SOURCE_ERR = "JAXP_UNKNOWN_SOURCE_ERR" ; public static final String JAXP_NO_SOURCE_ERR = "JAXP_NO_SOURCE_ERR" ; public static final String JAXP_COMPILE_ERR = "JAXP_COMPILE_ERR" ; public static final String JAXP_INVALID_ATTR_ERR = "JAXP_INVALID_ATTR_ERR" ; public static final String JAXP_SET_RESULT_ERR = "JAXP_SET_RESULT_ERR" ; public static final String JAXP_NO_TRANSLET_ERR = "JAXP_NO_TRANSLET_ERR" ; public static final String JAXP_NO_HANDLER_ERR = "JAXP_NO_HANDLER_ERR" ; public static final String JAXP_NO_RESULT_ERR = "JAXP_NO_RESULT_ERR" ; public static final String JAXP_UNKNOWN_PROP_ERR = "JAXP_UNKNOWN_PROP_ERR" ; public static final String SAX2DOM_ADAPTER_ERR = "SAX2DOM_ADAPTER_ERR" ; public static final String XSLTC_SOURCE_ERR = "XSLTC_SOURCE_ERR" ; public static final String COMPILE_STDIN_ERR = "COMPILE_STDIN_ERR" ; public static final String COMPILE_USAGE_STR = "COMPILE_USAGE_STR" ; public static final String TRANSFORM_USAGE_STR = "TRANSFORM_USAGE_STR" ; public static final String STRAY_SORT_ERR = "STRAY_SORT_ERR" ; public static final String UNSUPPORTED_ENCODING = "UNSUPPORTED_ENCODING" ; public static final String SYNTAX_ERR = "SYNTAX_ERR" ; public static final String CONSTRUCTOR_NOT_FOUND = "CONSTRUCTOR_NOT_FOUND" ; public static final String NO_JAVA_FUNCT_THIS_REF = "NO_JAVA_FUNCT_THIS_REF" ; public static final String TYPE_CHECK_ERR = "TYPE_CHECK_ERR" ; public static final String TYPE_CHECK_UNK_LOC_ERR = "TYPE_CHECK_UNK_LOC_ERR" ; public static final String ILLEGAL_CMDLINE_OPTION_ERR = "ILLEGAL_CMDLINE_OPTION_ERR" ; public static final String CMDLINE_OPT_MISSING_ARG_ERR = "CMDLINE_OPT_MISSING_ARG_ERR" ; public static final String WARNING_PLUS_WRAPPED_MSG = "WARNING_PLUS_WRAPPED_MSG" ; public static final String WARNING_MSG = "WARNING_MSG" ; public static final String FATAL_ERR_PLUS_WRAPPED_MSG = "FATAL_ERR_PLUS_WRAPPED_MSG" ; public static final String FATAL_ERR_MSG = "FATAL_ERR_MSG" ; public static final String ERROR_PLUS_WRAPPED_MSG = "ERROR_PLUS_WRAPPED_MSG" ; public static final String ERROR_MSG = "ERROR_MSG" ; public static final String TRANSFORM_WITH_TRANSLET_STR = "TRANSFORM_WITH_TRANSLET_STR" ; public static final String TRANSFORM_WITH_JAR_STR = "TRANSFORM_WITH_JAR_STR" ; public static final String COULD_NOT_CREATE_TRANS_FACT = "COULD_NOT_CREATE_TRANS_FACT" ; private static ResourceBundle _bundle ; public final static String ERROR_MESSAGES_KEY = "ERROR_MESSAGES_KEY" ; public final static String COMPILER_ERROR_KEY = "COMPILER_ERROR_KEY" ; public final static String COMPILER_WARNING_KEY = "COMPILER_WARNING_KEY" ; public final static String RUNTIME_ERROR_KEY = "RUNTIME_ERROR_KEY" ; static { _bundle = ResourceBundle . getBundle ( "org.apache.xalan.xsltc.compiler.util.ErrorMessages" , Locale . getDefault ( ) ) ; } public ErrorMsg ( String code ) { _code = code ; _line = 0 ; } public ErrorMsg ( Throwable e ) { _code = null ; _message = e . getMessage ( ) ; _line = 0 ; } public ErrorMsg ( String message , int line ) { _code = null ; _message = message ; _line = line ; } public ErrorMsg ( String code , int line , Object param ) { _code = code ; _line = line ; _params = new Object [ ] { param } ; } public ErrorMsg ( String code , Object param ) { this ( code ) ; _params = new Object [ 1 ] ; _params [ 0 ] = param ; } public ErrorMsg ( String code , Object param1 , Object param2 ) { this ( code ) ; _params = new Object [ 2 ] ; _params [ 0 ] = param1 ; _params [ 1 ] = param2 ; } public ErrorMsg ( String code , SyntaxTreeNode node ) { _code = code ; _url = getFileName ( node ) ; _line = node . getLineNumber ( ) ; } public ErrorMsg ( String code , Object param1 , SyntaxTreeNode node ) { _code = code ; _url = getFileName ( node ) ; _line = node . getLineNumber ( ) ; _params = new Object [ 1 ] ; _params [ 0 ] = param1 ; } public ErrorMsg ( String code , Object param1 , Object param2 , SyntaxTreeNode node ) { _code = code ; _url = getFileName ( node ) ; _line = node . getLineNumber ( ) ; _params = new Object [ 2 ] ; _params [ 0 ] = param1 ; _params [ 1 ] = param2 ; } private String getFileName ( SyntaxTreeNode node ) { Stylesheet stylesheet = node . getStylesheet ( ) ; if ( stylesheet != null ) return stylesheet . getSystemId ( ) ; else return null ; } private String formatLine ( ) { StringBuffer result = new StringBuffer ( ) ; if ( _url != null ) { result . append ( _url ) ; result . append ( ": " ) ; } if ( _line > 0 ) { result . append ( "line " ) ; result . append ( Integer . toString ( _line ) ) ; result . append ( ": " ) ; } return result . toString ( ) ; } public String toString ( ) { String suffix = ( _params == null ) ? ( null != _code ? new String ( getErrorMessage ( ) ) : _message ) : MessageFormat . format ( getErrorMessage ( ) , _params ) ; return formatLine ( ) + suffix ; } public String toString ( Object obj ) { Object params [ ] = new Object [ 1 ] ; params [ 0 ] = obj . toString ( ) ; String suffix = MessageFormat . format ( getErrorMessage ( ) , params ) ; return formatLine ( ) + suffix ; } public String toString ( Object obj0 , Object obj1 ) { Object params [ ] = new Object [ 2 ] ; params [ 0 ] = obj0 . toString ( ) ; params [ 1 ] = obj1 . toString ( ) ; String suffix = MessageFormat . format ( getErrorMessage ( ) , params ) ; return formatLine ( ) + suffix ; } private String getErrorMessage ( ) { return _bundle . getString ( _code ) ; } } 	1	['16', '1', '0', '52', '31', '0', '52', '2', '12', '1.024836601', '470', '0.049019608', '0', '0', '0.411111111', '0', '0', '22', '3', '0.6875', '2']
package org . apache . xalan . transformer ; import java . io . IOException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Templates ; import javax . xml . transform . TransformerConfigurationException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLFilterImpl ; import org . xml . sax . helpers . XMLReaderFactory ; public class TrAXFilter extends XMLFilterImpl { private Templates m_templates ; private TransformerImpl m_transformer ; public TrAXFilter ( Templates templates ) throws TransformerConfigurationException { m_templates = templates ; m_transformer = ( TransformerImpl ) templates . newTransformer ( ) ; } public TransformerImpl getTransformer ( ) { return m_transformer ; } public void setParent ( XMLReader parent ) { super . setParent ( parent ) ; if ( null != parent . getContentHandler ( ) ) this . setContentHandler ( parent . getContentHandler ( ) ) ; setupParse ( ) ; } public void parse ( InputSource input ) throws org . xml . sax . SAXException , IOException { if ( null == getParent ( ) ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } XMLReader parent ; if ( reader == null ) parent = XMLReaderFactory . createXMLReader ( ) ; else parent = reader ; try { parent . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } setParent ( parent ) ; } else { setupParse ( ) ; } if ( null == m_transformer . getContentHandler ( ) ) { throw new org . xml . sax . SAXException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_CALL_PARSE , null ) ) ; } getParent ( ) . parse ( input ) ; Exception e = m_transformer . getExceptionThrown ( ) ; if ( null != e ) { if ( e instanceof org . xml . sax . SAXException ) throw ( org . xml . sax . SAXException ) e ; else throw new org . xml . sax . SAXException ( e ) ; } } public void parse ( String systemId ) throws org . xml . sax . SAXException , IOException { parse ( new InputSource ( systemId ) ) ; } private void setupParse ( ) { XMLReader p = getParent ( ) ; if ( p == null ) { throw new NullPointerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_PARENT_FOR_FILTER , null ) ) ; } ContentHandler ch = m_transformer . getInputContentHandler ( ) ; p . setContentHandler ( ch ) ; if ( ch instanceof EntityResolver ) p . setEntityResolver ( ( EntityResolver ) ch ) ; else p . setEntityResolver ( this ) ; if ( ch instanceof DTDHandler ) p . setDTDHandler ( ( DTDHandler ) ch ) ; else p . setDTDHandler ( this ) ; ErrorListener elistener = m_transformer . getErrorListener ( ) ; if ( ( null != elistener ) && ( elistener instanceof org . xml . sax . ErrorHandler ) ) p . setErrorHandler ( ( org . xml . sax . ErrorHandler ) elistener ) ; else p . setErrorHandler ( this ) ; } public void setContentHandler ( ContentHandler handler ) { m_transformer . setContentHandler ( handler ) ; } public void setErrorListener ( ErrorListener handler ) { m_transformer . setErrorListener ( handler ) ; } } 	1	['8', '2', '0', '3', '36', '0', '1', '2', '7', '0.5', '203', '1', '1', '0.829268293', '0.25', '1', '6', '24.125', '6', '1.625', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLMessages { protected Locale fLocale = Locale . getDefault ( ) ; private static ListResourceBundle XMLBundle = null ; private static final String XML_ERROR_RESOURCES = "org.apache.xml.res.XMLErrorResources" ; protected static String BAD_CODE = "BAD_CODE" ; protected static String FORMAT_FAILED = "FORMAT_FAILED" ; public void setLocale ( Locale locale ) { fLocale = locale ; } public Locale getLocale ( ) { return fLocale ; } public static final String createXMLMessage ( String msgKey , Object args [ ] ) { if ( XMLBundle == null ) XMLBundle = loadResourceBundle ( XML_ERROR_RESOURCES ) ; if ( XMLBundle != null ) { return createMsg ( XMLBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } public static final String createMsg ( ListResourceBundle fResourceBundle , String msgKey , Object args [ ] ) { String fmsg = null ; boolean throwex = false ; String msg = null ; if ( msgKey != null ) msg = fResourceBundle . getString ( msgKey ) ; if ( msg == null ) { msg = fResourceBundle . getString ( BAD_CODE ) ; throwex = true ; } if ( args != null ) { try { int n = args . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( null == args [ i ] ) args [ i ] = "" ; } fmsg = java . text . MessageFormat . format ( msg , args ) ; } catch ( Exception e ) { fmsg = fResourceBundle . getString ( FORMAT_FAILED ) ; fmsg += " " + msg ; } } else fmsg = msg ; if ( throwex ) { throw new RuntimeException ( fmsg ) ; } return fmsg ; } public static ListResourceBundle loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; try { return ( ListResourceBundle ) ResourceBundle . getBundle ( className , locale ) ; } catch ( MissingResourceException e ) { try { return ( ListResourceBundle ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." + className , className , "" ) ; } } } protected static String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['8', '1', '1', '33', '22', '18', '33', '0', '6', '0.828571429', '183', '1', '0', '0', '0.314285714', '0', '0', '21.25', '7', '1.875', '1']
package org . apache . xml . utils ; import java . io . Serializable ; public class NameSpace implements Serializable { public NameSpace m_next = null ; public String m_prefix ; public String m_uri ; public NameSpace ( String prefix , String uri ) { m_prefix = prefix ; m_uri = uri ; } } 	1	['1', '1', '0', '1', '2', '0', '1', '0', '1', '2', '16', '0', '1', '0', '1', '0', '0', '12', '0', '0', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Result ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . SAXException ; public class ToXMLStream extends ToStream { private boolean m_cdataTagOpen = false ; protected static CharInfo m_xmlcharInfo = CharInfo . getCharInfo ( CharInfo . XML_ENTITIES_RESOURCE ) ; public ToXMLStream ( ) { m_charInfo = m_xmlcharInfo ; initCDATA ( ) ; m_prefixMap = new NamespaceMappings ( ) ; } public void CopyFrom ( ToXMLStream xmlListener ) { m_writer = xmlListener . m_writer ; String encoding = xmlListener . getEncoding ( ) ; setEncoding ( encoding ) ; setOmitXMLDeclaration ( xmlListener . getOmitXMLDeclaration ( ) ) ; m_startTagOpen = xmlListener . m_startTagOpen ; m_ispreserve = xmlListener . m_ispreserve ; m_preserves = xmlListener . m_preserves ; m_isprevtext = xmlListener . m_isprevtext ; m_doIndent = xmlListener . m_doIndent ; m_currentElemDepth = xmlListener . m_currentElemDepth ; setIndentAmount ( xmlListener . getIndentAmount ( ) ) ; m_startNewLine = xmlListener . m_startNewLine ; m_needToOutputDocTypeDecl = xmlListener . m_needToOutputDocTypeDecl ; setDoctypeSystem ( xmlListener . getDoctypeSystem ( ) ) ; setDoctypePublic ( xmlListener . getDoctypePublic ( ) ) ; setStandalone ( xmlListener . getStandalone ( ) ) ; setMediaType ( xmlListener . getMediaType ( ) ) ; m_maxCharacter = xmlListener . m_maxCharacter ; m_spaceBeforeClose = xmlListener . m_spaceBeforeClose ; m_cdataStartCalled = xmlListener . m_cdataStartCalled ; } public void startDocumentInternal ( ) throws org . xml . sax . SAXException { if ( m_needToCallStartDocument ) { super . startDocumentInternal ( ) ; m_needToCallStartDocument = false ; if ( m_inEntityRef ) return ; m_needToOutputDocTypeDecl = true ; m_startNewLine = false ; if ( getOmitXMLDeclaration ( ) == false ) { String encoding = Encodings . getMimeEncoding ( getEncoding ( ) ) ; String version = getVersion ( ) ; if ( version == null ) version = "1.0" ; String standalone ; if ( m_standaloneWasSpecified ) { standalone = " standalone=\"" + getStandalone ( ) + "\"" ; } else { standalone = "" ; } try { m_writer . write ( "<?xml version=\"" ) ; m_writer . write ( version ) ; m_writer . write ( "\" encoding=\"" ) ; m_writer . write ( encoding ) ; m_writer . write ( '\"' ) ; m_writer . write ( standalone ) ; m_writer . write ( "?>" ) ; m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } } } public void endDocument ( ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( m_doIndent && ! m_isprevtext ) { try { outputLineSep ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } flushWriter ( ) ; super . fireEndDoc ( ) ; } public void startPreserving ( ) throws org . xml . sax . SAXException { m_preserves . push ( true ) ; m_ispreserve = true ; } public void endPreserving ( ) throws org . xml . sax . SAXException { m_ispreserve = m_preserves . isEmpty ( ) ? false : m_preserves . pop ( ) ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; flushPending ( ) ; if ( target . equals ( Result . PI_DISABLE_OUTPUT_ESCAPING ) ) { startNonEscaping ( ) ; } else if ( target . equals ( Result . PI_ENABLE_OUTPUT_ESCAPING ) ) { endNonEscaping ( ) ; } else { try { if ( m_startTagOpen ) closeStartTag ( ) ; if ( shouldIndent ( ) ) indent ( ) ; m_writer . write ( '<' ) ; m_writer . write ( '?' ) ; m_writer . write ( target ) ; if ( data . length ( ) > 0 && ! Character . isSpaceChar ( data . charAt ( 0 ) ) ) m_writer . write ( ' ' ) ; int indexOfQLT = data . indexOf ( "?>" ) ; if ( indexOfQLT >= 0 ) { if ( indexOfQLT > 0 ) { m_writer . write ( data . substring ( 0 , indexOfQLT ) ) ; } m_writer . write ( "? >" ) ; if ( ( indexOfQLT + 2 ) < data . length ( ) ) { m_writer . write ( data . substring ( indexOfQLT + 2 ) ) ; } } else { m_writer . write ( data ) ; } m_writer . write ( '?' ) ; m_writer . write ( '>' ) ; if ( m_currentElemDepth <= 0 ) m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_startNewLine = true ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } super . fireEscapingEvent ( target , data ) ; } public void entityReference ( String name ) throws org . xml . sax . SAXException { if ( m_startTagOpen ) { closeStartTag ( ) ; m_startTagOpen = false ; } try { if ( shouldIndent ( ) ) indent ( ) ; m_writer . write ( "&" ) ; m_writer . write ( name ) ; m_writer . write ( ";" ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } super . fireEntityReference ( name ) ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_startTagOpen ) { if ( ! rawName . startsWith ( "xmlns" ) ) { String prefixUsed = ensureAttributesNamespaceIsDeclared ( uri , localName , rawName ) ; if ( prefixUsed != null && rawName != null && ! rawName . startsWith ( prefixUsed ) ) { rawName = prefixUsed + ":" + localName ; } } addAttributeAlways ( uri , localName , rawName , type , value ) ; } else { String msg = XMLMessages . createXMLMessage ( XMLErrorResources . ER_ILLEGAL_ATTRIBUTE_POSITION , new Object [ ] { localName } ) ; try { Transformer tran = super . getTransformer ( ) ; ErrorListener errHandler = tran . getErrorListener ( ) ; if ( null != errHandler && m_sourceLocator != null ) errHandler . warning ( new TransformerException ( msg , m_sourceLocator ) ) ; else System . out . println ( msg ) ; } catch ( Exception e ) { } } } private String escapeString ( String value ) { final char [ ] ch = value . toCharArray ( ) ; final int limit = ch . length ; StringBuffer result = new StringBuffer ( ) ; int offset = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { switch ( ch [ i ] ) { case '&' : result . append ( ch , offset , i - offset ) . append ( ENTITY_AMP ) ; offset = i + 1 ; break ; case '"' : result . append ( ch , offset , i - offset ) . append ( ENTITY_QUOT ) ; offset = i + 1 ; break ; case '<' : result . append ( ch , offset , i - offset ) . append ( ENTITY_LT ) ; offset = i + 1 ; break ; case '>' : result . append ( ch , offset , i - offset ) . append ( ENTITY_GT ) ; offset = i + 1 ; break ; case '\n' : result . append ( ch , offset , i - offset ) . append ( ENTITY_CRLF ) ; offset = i + 1 ; break ; } } if ( offset < limit ) { result . append ( ch , offset , limit - offset ) ; } return result . toString ( ) ; } public void endElement ( String elemName ) throws SAXException { endElement ( null , null , elemName ) ; } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { if ( m_elementURI == null ) { String prefix1 = getPrefixPart ( m_elementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_elementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; return ; } protected boolean pushNamespace ( String prefix , String uri ) { try { if ( m_prefixMap . pushNamespace ( prefix , uri , m_currentElemDepth ) ) { startPrefixMapping ( prefix , uri ) ; return true ; } } catch ( SAXException e ) { } return false ; } } 	1	['14', '3', '0', '8', '79', '57', '2', '6', '11', '0.961538462', '648', '1', '1', '0.933701657', '0.538461538', '3', '29', '45.14285714', '9', '1.4286', '1']
package org . apache . xalan . trace ; import javax . xml . transform . SourceLocator ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . apache . xml . serializer . SerializerTrace ; import org . w3c . dom . Node ; public class PrintTraceListener implements TraceListenerEx2 { public PrintTraceListener ( java . io . PrintWriter pw ) { m_pw = pw ; } java . io . PrintWriter m_pw ; public boolean m_traceTemplates = false ; public boolean m_traceElements = false ; public boolean m_traceGeneration = false ; public boolean m_traceSelection = false ; public void _trace ( TracerEvent ev ) { switch ( ev . m_styleNode . getXSLToken ( ) ) { case Constants . ELEMNAME_TEXTLITERALRESULT : if ( m_traceElements ) { m_pw . print ( ev . m_styleNode . getSystemId ( ) + " Line #" + ev . m_styleNode . getLineNumber ( ) + ", " + "Column #" + ev . m_styleNode . getColumnNumber ( ) + " -- " + ev . m_styleNode . getNodeName ( ) + ": " ) ; ElemTextLiteral etl = ( ElemTextLiteral ) ev . m_styleNode ; String chars = new String ( etl . getChars ( ) , 0 , etl . getChars ( ) . length ) ; m_pw . println ( "    " + chars . trim ( ) ) ; } break ; case Constants . ELEMNAME_TEMPLATE : if ( m_traceTemplates || m_traceElements ) { ElemTemplate et = ( ElemTemplate ) ev . m_styleNode ; m_pw . print ( et . getSystemId ( ) + " Line #" + et . getLineNumber ( ) + ", " + "Column #" + et . getColumnNumber ( ) + ": " + et . getNodeName ( ) + " " ) ; if ( null != et . getMatch ( ) ) { m_pw . print ( "match='" + et . getMatch ( ) . getPatternString ( ) + "' " ) ; } if ( null != et . getName ( ) ) { m_pw . print ( "name='" + et . getName ( ) + "' " ) ; } m_pw . println ( ) ; } break ; default : if ( m_traceElements ) { m_pw . println ( ev . m_styleNode . getSystemId ( ) + " Line #" + ev . m_styleNode . getLineNumber ( ) + ", " + "Column #" + ev . m_styleNode . getColumnNumber ( ) + ": " + ev . m_styleNode . getNodeName ( ) ) ; } } } int m_indent = 0 ; public void trace ( TracerEvent ev ) { _trace ( ev ) ; } public void traceEnd ( TracerEvent ev ) { } public void selected ( SelectionEvent ev ) throws javax . xml . transform . TransformerException { if ( m_traceSelection ) { ElemTemplateElement ete = ( ElemTemplateElement ) ev . m_styleNode ; Node sourceNode = ev . m_sourceNode ; SourceLocator locator = null ; if ( sourceNode instanceof DTMNodeProxy ) { int nodeHandler = ( ( DTMNodeProxy ) sourceNode ) . getDTMNodeNumber ( ) ; locator = ( ( DTMNodeProxy ) sourceNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; } if ( locator != null ) m_pw . println ( "Selected source node '" + sourceNode . getNodeName ( ) + "', at " + locator ) ; else m_pw . println ( "Selected source node '" + sourceNode . getNodeName ( ) + "'" ) ; if ( ev . m_styleNode . getLineNumber ( ) == 0 ) { ElemTemplateElement parent = ( ElemTemplateElement ) ete . getParentElem ( ) ; if ( parent == ete . getStylesheetRoot ( ) . getDefaultRootRule ( ) ) { m_pw . print ( "(default root rule) " ) ; } else if ( parent == ete . getStylesheetRoot ( ) . getDefaultTextRule ( ) ) { m_pw . print ( "(default text rule) " ) ; } else if ( parent == ete . getStylesheetRoot ( ) . getDefaultRule ( ) ) { m_pw . print ( "(default rule) " ) ; } m_pw . print ( ete . getNodeName ( ) + ", " + ev . m_attributeName + "='" + ev . m_xpath . getPatternString ( ) + "': " ) ; } else { m_pw . print ( ev . m_styleNode . getSystemId ( ) + " Line #" + ev . m_styleNode . getLineNumber ( ) + ", " + "Column #" + ev . m_styleNode . getColumnNumber ( ) + ": " + ete . getNodeName ( ) + ", " + ev . m_attributeName + "='" + ev . m_xpath . getPatternString ( ) + "': " ) ; } if ( ev . m_selection . getType ( ) == ev . m_selection . CLASS_NODESET ) { m_pw . println ( ) ; org . apache . xml . dtm . DTMIterator nl = ev . m_selection . iter ( ) ; int currentPos = DTM . NULL ; currentPos = nl . getCurrentPos ( ) ; nl . setShouldCacheNodes ( true ) ; org . apache . xml . dtm . DTMIterator clone = null ; try { clone = nl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { m_pw . println ( "     [Can't trace nodelist because it it threw a CloneNotSupportedException]" ) ; return ; } int pos = clone . nextNode ( ) ; if ( DTM . NULL == pos ) { m_pw . println ( "     [empty node list]" ) ; } else { while ( DTM . NULL != pos ) { DTM dtm = ev . m_processor . getXPathContext ( ) . getDTM ( pos ) ; m_pw . print ( "     " ) ; m_pw . print ( Integer . toHexString ( pos ) ) ; m_pw . print ( ": " ) ; m_pw . println ( dtm . getNodeName ( pos ) ) ; pos = clone . nextNode ( ) ; } } nl . runTo ( - 1 ) ; nl . setCurrentPos ( currentPos ) ; } else { m_pw . println ( ev . m_selection . str ( ) ) ; } } } public void selectEnd ( EndSelectionEvent ev ) throws javax . xml . transform . TransformerException { } public void generated ( GenerateEvent ev ) { if ( m_traceGeneration ) { switch ( ev . m_eventtype ) { case SerializerTrace . EVENTTYPE_STARTDOCUMENT : m_pw . println ( "STARTDOCUMENT" ) ; break ; case SerializerTrace . EVENTTYPE_ENDDOCUMENT : m_pw . println ( "ENDDOCUMENT" ) ; break ; case SerializerTrace . EVENTTYPE_STARTELEMENT : m_pw . println ( "STARTELEMENT: " + ev . m_name ) ; break ; case SerializerTrace . EVENTTYPE_ENDELEMENT : m_pw . println ( "ENDELEMENT: " + ev . m_name ) ; break ; case SerializerTrace . EVENTTYPE_CHARACTERS : { String chars = new String ( ev . m_characters , ev . m_start , ev . m_length ) ; m_pw . println ( "CHARACTERS: " + chars ) ; } break ; case SerializerTrace . EVENTTYPE_CDATA : { String chars = new String ( ev . m_characters , ev . m_start , ev . m_length ) ; m_pw . println ( "CDATA: " + chars ) ; } break ; case SerializerTrace . EVENTTYPE_COMMENT : m_pw . println ( "COMMENT: " + ev . m_data ) ; break ; case SerializerTrace . EVENTTYPE_PI : m_pw . println ( "PI: " + ev . m_name + ", " + ev . m_data ) ; break ; case SerializerTrace . EVENTTYPE_ENTITYREF : m_pw . println ( "ENTITYREF: " + ev . m_name ) ; break ; case SerializerTrace . EVENTTYPE_IGNORABLEWHITESPACE : m_pw . println ( "IGNORABLEWHITESPACE" ) ; break ; } } } } 	1	['7', '1', '0', '18', '53', '9', '1', '17', '7', '0.722222222', '609', '0', '0', '0', '0.333333333', '0', '0', '85.14285714', '10', '2.4286', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . Util ; class VariableBase extends TopLevelElement { protected QName _name ; protected String _variable ; protected Type _type ; protected boolean _isLocal ; protected LocalVariableGen _local ; protected Instruction _loadInstruction ; protected Expression _select ; protected String select ; protected Vector _refs = new Vector ( 2 ) ; protected Vector _dependencies = null ; protected boolean _ignore = false ; protected int _weight = 0 ; public void disable ( ) { _ignore = true ; } public void addReference ( VariableRefBase vref ) { _refs . addElement ( vref ) ; } public void removeReference ( VariableRefBase vref ) { _refs . remove ( vref ) ; } public void addDependency ( VariableBase other ) { if ( _dependencies == null ) { _dependencies = new Vector ( ) ; } if ( ! _dependencies . contains ( other ) ) { _dependencies . addElement ( other ) ; } } public Vector getDependencies ( ) { return _dependencies ; } public void mapRegister ( MethodGenerator methodGen ) { if ( _local == null ) { final InstructionList il = methodGen . getInstructionList ( ) ; final String name = _name . getLocalPart ( ) ; final org . apache . bcel . generic . Type varType = _type . toJCType ( ) ; _local = methodGen . addLocalVariable2 ( name , varType , il . getEnd ( ) ) ; } } public void unmapRegister ( MethodGenerator methodGen ) { if ( _refs . isEmpty ( ) && ( _local != null ) ) { _local . setEnd ( methodGen . getInstructionList ( ) . getEnd ( ) ) ; methodGen . removeLocalVariable ( _local ) ; _refs = null ; _local = null ; } } public Instruction loadInstruction ( ) { final Instruction instr = _loadInstruction ; if ( _loadInstruction == null ) _loadInstruction = _type . LOAD ( _local . getIndex ( ) ) ; return _loadInstruction ; } public Expression getExpression ( ) { return ( _select ) ; } public String toString ( ) { return ( "variable(" + _name + ")" ) ; } public void display ( int indent ) { indent ( indent ) ; System . out . println ( "Variable " + _name ) ; if ( _select != null ) { indent ( indent + IndentIncrement ) ; System . out . println ( "select " + _select . toString ( ) ) ; } displayContents ( indent + IndentIncrement ) ; } public Type getType ( ) { return _type ; } public QName getName ( ) { return _name ; } public String getVariable ( ) { return _variable ; } public void setName ( QName name ) { _name = name ; _variable = Util . escape ( name . getLocalPart ( ) ) ; } public boolean isLocal ( ) { return _isLocal ; } public void parseContents ( Parser parser ) { String name = getAttribute ( "name" ) ; if ( name == null ) name = EMPTYSTRING ; if ( name . length ( ) > 0 ) setName ( parser . getQNameIgnoreDefaultNs ( name ) ) ; else reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; VariableBase other = parser . lookupVariable ( _name ) ; if ( ( other != null ) && ( other . getParent ( ) == getParent ( ) ) ) { reportError ( this , parser , ErrorMsg . VARIABLE_REDEF_ERR , name ) ; } select = getAttribute ( "select" ) ; if ( select . length ( ) > 0 ) { _select = getParser ( ) . parseExpression ( this , "select" , null ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; return ; } } parseChildren ( parser ) ; } public void translateValue ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _select != null ) { _select . translate ( classGen , methodGen ) ; _select . startResetIterator ( classGen , methodGen ) ; } else if ( hasContents ( ) ) { compileResultTree ( classGen , methodGen ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } } } 	1	['19', '3', '2', '29', '61', '99', '14', '18', '18', '0.907407407', '335', '1', '3', '0.769230769', '0.190789474', '1', '5', '16', '7', '1.7368', '2']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class Step extends RelativeLocationPath { private int _axis ; private Vector _predicates ; private boolean _hadPredicates = false ; private int _nodeType ; public Step ( int axis , int nodeType , Vector predicates ) { _axis = axis ; _nodeType = nodeType ; _predicates = predicates ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate exp = ( Predicate ) _predicates . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public int getAxis ( ) { return _axis ; } public void setAxis ( int axis ) { _axis = axis ; } public int getNodeType ( ) { return _nodeType ; } public Vector getPredicates ( ) { return _predicates ; } public void addPredicates ( Vector predicates ) { if ( _predicates == null ) { _predicates = predicates ; } else { _predicates . addAll ( predicates ) ; } } private boolean hasParentPattern ( ) { final SyntaxTreeNode parent = getParent ( ) ; return ( parent instanceof ParentPattern || parent instanceof ParentLocationPath || parent instanceof UnionPathExpr || parent instanceof FilterParentPath ) ; } private boolean hasPredicates ( ) { return _predicates != null && _predicates . size ( ) > 0 ; } private boolean isPredicate ( ) { SyntaxTreeNode parent = this ; while ( parent != null ) { parent = parent . getParent ( ) ; if ( parent instanceof Predicate ) return true ; } return false ; } public boolean isAbbreviatedDot ( ) { return _nodeType == NodeTest . ANODE && _axis == Axis . SELF ; } public boolean isAbbreviatedDDot ( ) { return _nodeType == NodeTest . ANODE && _axis == Axis . PARENT ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _hadPredicates = hasPredicates ( ) ; if ( isAbbreviatedDot ( ) ) { _type = ( hasParentPattern ( ) || hasPredicates ( ) ) ? Type . NodeSet : Type . Node ; } else { _type = Type . NodeSet ; } if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression pred = ( Expression ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } } return _type ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( hasPredicates ( ) ) { translatePredicates ( classGen , methodGen ) ; } else { if ( _axis == Axis . ATTRIBUTE && _nodeType != NodeTest . ATTRIBUTE && _nodeType != NodeTest . ANODE && ! hasParentPattern ( ) ) { int iter = cpg . addInterfaceMethodref ( DOM_INTF , "getTypedAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . ATTRIBUTE ) ) ; il . append ( new PUSH ( cpg , _nodeType ) ) ; il . append ( new INVOKEINTERFACE ( iter , 3 ) ) ; return ; } if ( isAbbreviatedDot ( ) ) { if ( _type == Type . Node ) { il . append ( methodGen . loadContextNode ( ) ) ; } else { int init = cpg . addMethodref ( SINGLETON_ITERATOR , "<init>" , "(" + NODE_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( SINGLETON_ITERATOR ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } return ; } SyntaxTreeNode parent = getParent ( ) ; if ( ( parent instanceof ParentLocationPath ) && ( parent . getParent ( ) instanceof ParentLocationPath ) ) { if ( ( _nodeType == NodeTest . ELEMENT ) && ( ! _hadPredicates ) ) { _nodeType = NodeTest . ANODE ; } } switch ( _nodeType ) { case NodeTest . ATTRIBUTE : _axis = Axis . ATTRIBUTE ; case NodeTest . ANODE : int git = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _axis ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; break ; default : final XSLTC xsltc = getParser ( ) . getXSLTC ( ) ; final Vector ni = xsltc . getNamesIndex ( ) ; String name = null ; int star = 0 ; if ( _nodeType >= DTM . NTYPES ) { name = ( String ) ni . elementAt ( _nodeType - DTM . NTYPES ) ; star = name . lastIndexOf ( '*' ) ; } if ( star > 1 ) { final String namespace ; if ( _axis == Axis . ATTRIBUTE ) namespace = name . substring ( 0 , star - 2 ) ; else namespace = name . substring ( 0 , star - 1 ) ; final int nsType = xsltc . registerNamespace ( namespace ) ; final int ns = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _axis ) ) ; il . append ( new PUSH ( cpg , nsType ) ) ; il . append ( new INVOKEINTERFACE ( ns , 3 ) ) ; break ; } case NodeTest . ELEMENT : final int ty = cpg . addInterfaceMethodref ( DOM_INTF , "getTypedAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _axis ) ) ; il . append ( new PUSH ( cpg , _nodeType ) ) ; il . append ( new INVOKEINTERFACE ( ty , 3 ) ) ; break ; } } } public void translatePredicates ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int idx = 0 ; if ( _predicates . size ( ) == 0 ) { translate ( classGen , methodGen ) ; } else { final Predicate predicate = ( Predicate ) _predicates . lastElement ( ) ; _predicates . remove ( predicate ) ; if ( predicate . isNodeValueTest ( ) ) { Step step = predicate . getStep ( ) ; il . append ( methodGen . loadDOM ( ) ) ; if ( step . isAbbreviatedDot ( ) ) { translate ( classGen , methodGen ) ; il . append ( new ICONST ( DOM . RETURN_CURRENT ) ) ; } else { ParentLocationPath path = new ParentLocationPath ( this , step ) ; try { path . typeCheck ( getParser ( ) . getSymbolTable ( ) ) ; } catch ( TypeCheckError e ) { } path . translate ( classGen , methodGen ) ; il . append ( new ICONST ( DOM . RETURN_PARENT ) ) ; } predicate . translate ( classGen , methodGen ) ; idx = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE_ITERATOR , GET_NODE_VALUE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( idx , 5 ) ) ; } else if ( predicate . isNthDescendant ( ) ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ICONST ( NodeTest . ELEMENT ) ) ; predicate . translate ( classGen , methodGen ) ; il . append ( new ICONST ( 0 ) ) ; idx = cpg . addInterfaceMethodref ( DOM_INTF , "getNthDescendant" , "(IIZ)" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( idx , 4 ) ) ; } else if ( predicate . isNthPositionFilter ( ) ) { idx = cpg . addMethodref ( NTH_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + "I)V" ) ; il . append ( new NEW ( cpg . addClass ( NTH_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; translatePredicates ( classGen , methodGen ) ; predicate . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( idx ) ) ; } else { idx = cpg . addMethodref ( CURRENT_NODE_LIST_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + CURRENT_NODE_LIST_FILTER_SIG + NODE_SIG + TRANSLET_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( CURRENT_NODE_LIST_ITERATOR ) ) ) ; il . append ( DUP ) ; translatePredicates ( classGen , methodGen ) ; predicate . translateFilter ( classGen , methodGen ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { final String className = classGen . getClassName ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new INVOKESPECIAL ( idx ) ) ; } } } public String toString ( ) { final StringBuffer buffer = new StringBuffer ( "step(\"" ) ; buffer . append ( Axis . names [ _axis ] ) . append ( "\", " ) . append ( _nodeType ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; buffer . append ( ", " ) . append ( pred . toString ( ) ) ; } } return buffer . append ( ')' ) . toString ( ) ; } } 	1	['16', '4', '0', '30', '69', '10', '5', '28', '13', '0.566666667', '787', '1', '0', '0.829545455', '0.232142857', '2', '9', '47.9375', '16', '3.3125', '2']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncSubstringBefore extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String s1 = m_arg0 . execute ( xctxt ) . str ( ) ; String s2 = m_arg1 . execute ( xctxt ) . str ( ) ; int index = s1 . indexOf ( s2 ) ; return ( - 1 == index ) ? XString . EMPTYSTRING : new XString ( s1 . substring ( 0 , index ) ) ; } } 	1	['2', '5', '0', '5', '8', '1', '0', '5', '2', '2', '34', '0', '0', '0.98245614', '0.75', '1', '6', '16', '1', '0.5', '1']
package org . apache . xalan . templates ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . serializer . OutputPropertiesFactory ; import org . apache . xml . serializer . OutputPropertyUtils ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . QName ; public class OutputProperties extends ElemTemplateElement implements Cloneable { public OutputProperties ( ) { this ( org . apache . xml . serializer . Method . XML ) ; } public OutputProperties ( Properties defaults ) { m_properties = new Properties ( defaults ) ; } public OutputProperties ( String method ) { m_properties = new Properties ( OutputPropertiesFactory . getDefaultMethodProperties ( method ) ) ; } public Object clone ( ) { try { OutputProperties cloned = ( OutputProperties ) super . clone ( ) ; cloned . m_properties = ( Properties ) cloned . m_properties . clone ( ) ; return cloned ; } catch ( CloneNotSupportedException e ) { return null ; } } public void setProperty ( QName key , String value ) { setProperty ( key . toNamespacedString ( ) , value ) ; } public void setProperty ( String key , String value ) { if ( key . equals ( OutputKeys . METHOD ) ) { setMethodDefaults ( value ) ; } if ( key . startsWith ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL ) ) key = OutputPropertiesFactory . S_BUILTIN_EXTENSIONS_UNIVERSAL + key . substring ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN ) ; m_properties . put ( key , value ) ; } public String getProperty ( QName key ) { return m_properties . getProperty ( key . toNamespacedString ( ) ) ; } public String getProperty ( String key ) { if ( key . startsWith ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL ) ) key = OutputPropertiesFactory . S_BUILTIN_EXTENSIONS_UNIVERSAL + key . substring ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN ) ; return m_properties . getProperty ( key ) ; } public void setBooleanProperty ( QName key , boolean value ) { m_properties . put ( key . toNamespacedString ( ) , value ? "yes" : "no" ) ; } public void setBooleanProperty ( String key , boolean value ) { m_properties . put ( key , value ? "yes" : "no" ) ; } public boolean getBooleanProperty ( QName key ) { return getBooleanProperty ( key . toNamespacedString ( ) ) ; } public boolean getBooleanProperty ( String key ) { return OutputPropertyUtils . getBooleanProperty ( key , m_properties ) ; } public void setIntProperty ( QName key , int value ) { setIntProperty ( key . toNamespacedString ( ) , value ) ; } public void setIntProperty ( String key , int value ) { m_properties . put ( key , Integer . toString ( value ) ) ; } public int getIntProperty ( QName key ) { return getIntProperty ( key . toNamespacedString ( ) ) ; } public int getIntProperty ( String key ) { return OutputPropertyUtils . getIntProperty ( key , m_properties ) ; } public void setQNameProperty ( QName key , QName value ) { setQNameProperty ( key . toNamespacedString ( ) , value ) ; } public void setMethodDefaults ( String method ) { String defaultMethod = m_properties . getProperty ( OutputKeys . METHOD ) ; if ( ( null == defaultMethod ) || ! defaultMethod . equals ( method ) || defaultMethod . equals ( "xml" ) ) { Properties savedProps = m_properties ; Properties newDefaults = OutputPropertiesFactory . getDefaultMethodProperties ( method ) ; m_properties = new Properties ( newDefaults ) ; copyFrom ( savedProps , false ) ; } } public void setQNameProperty ( String key , QName value ) { setProperty ( key , value . toNamespacedString ( ) ) ; } public QName getQNameProperty ( QName key ) { return getQNameProperty ( key . toNamespacedString ( ) ) ; } public QName getQNameProperty ( String key ) { return getQNameProperty ( key , m_properties ) ; } public static QName getQNameProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null != s ) return QName . getQNameFromString ( s ) ; else return null ; } public void setQNameProperties ( QName key , Vector v ) { setQNameProperties ( key . toNamespacedString ( ) , v ) ; } public void setQNameProperties ( String key , Vector v ) { int s = v . size ( ) ; FastStringBuffer fsb = new FastStringBuffer ( 9 , 9 ) ; for ( int i = 0 ; i < s ; i ++ ) { QName qname = ( QName ) v . elementAt ( i ) ; fsb . append ( qname . toNamespacedString ( ) ) ; if ( i < s - 1 ) fsb . append ( ' ' ) ; } m_properties . put ( key , fsb . toString ( ) ) ; } public Vector getQNameProperties ( QName key ) { return getQNameProperties ( key . toNamespacedString ( ) ) ; } public Vector getQNameProperties ( String key ) { return getQNameProperties ( key , m_properties ) ; } public static Vector getQNameProperties ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null != s ) { Vector v = new Vector ( ) ; int l = s . length ( ) ; boolean inCurly = false ; FastStringBuffer buf = new FastStringBuffer ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char c = s . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! inCurly ) { if ( buf . length ( ) > 0 ) { QName qname = QName . getQNameFromString ( buf . toString ( ) ) ; v . addElement ( qname ) ; buf . reset ( ) ; } continue ; } } else if ( '{' == c ) inCurly = true ; else if ( '}' == c ) inCurly = false ; buf . append ( c ) ; } if ( buf . length ( ) > 0 ) { QName qname = QName . getQNameFromString ( buf . toString ( ) ) ; v . addElement ( qname ) ; buf . reset ( ) ; } return v ; } else return null ; } public void recompose ( StylesheetRoot root ) throws TransformerException { root . recomposeOutput ( this ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; } public Properties getProperties ( ) { return m_properties ; } public void copyFrom ( Properties src ) { copyFrom ( src , true ) ; } public void copyFrom ( Properties src , boolean shouldResetDefaults ) { Enumeration enum = src . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; if ( ! isLegalPropertyKey ( key ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { key } ) ) ; Object oldValue = m_properties . get ( key ) ; if ( null == oldValue ) { String val = ( String ) src . get ( key ) ; if ( shouldResetDefaults && key . equals ( OutputKeys . METHOD ) ) { setMethodDefaults ( val ) ; } m_properties . put ( key , val ) ; } else if ( key . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) ) { m_properties . put ( key , ( String ) oldValue + " " + ( String ) src . get ( key ) ) ; } } } public void copyFrom ( OutputProperties opsrc ) throws TransformerException { copyFrom ( opsrc . getProperties ( ) ) ; } public static boolean isLegalPropertyKey ( String key ) { return ( key . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) || key . equals ( OutputKeys . DOCTYPE_PUBLIC ) || key . equals ( OutputKeys . DOCTYPE_SYSTEM ) || key . equals ( OutputKeys . ENCODING ) || key . equals ( OutputKeys . INDENT ) || key . equals ( OutputKeys . MEDIA_TYPE ) || key . equals ( OutputKeys . METHOD ) || key . equals ( OutputKeys . OMIT_XML_DECLARATION ) || key . equals ( OutputKeys . STANDALONE ) || key . equals ( OutputKeys . VERSION ) || ( key . length ( ) > 0 ) && ( key . charAt ( 0 ) == '{' ) ) ; } private Properties m_properties = null ; static public Properties getDefaultMethodProperties ( String method ) { return org . apache . xml . serializer . OutputPropertiesFactory . getDefaultMethodProperties ( method ) ; } } 	1	['35', '3', '0', '15', '75', '323', '9', '7', '35', '0.205882353', '556', '1', '0', '0.859649123', '0.234920635', '0', '0', '14.85714286', '13', '1.9429', '2']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import javax . xml . transform . Result ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class ToXMLSAXHandler extends ToSAXHandler { protected boolean m_escapeSetting = false ; public ToXMLSAXHandler ( ) { m_prefixMap = new NamespaceMappings ( ) ; initCDATA ( ) ; } public Properties getOutputFormat ( ) { return null ; } public OutputStream getOutputStream ( ) { return null ; } public Writer getWriter ( ) { return null ; } public void indent ( int n ) throws SAXException { } public boolean reset ( ) { return false ; } public void serialize ( Node node ) throws IOException { } public boolean setEscaping ( boolean escape ) throws SAXException { boolean oldEscapeSetting = m_escapeSetting ; m_escapeSetting = escape ; if ( escape ) { processingInstruction ( Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { processingInstruction ( Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; } return oldEscapeSetting ; } public void setOutputFormat ( Properties format ) { } public void setOutputStream ( OutputStream output ) { } public void setWriter ( Writer writer ) { } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { } public void endDocument ( ) throws SAXException { flushPending ( ) ; m_saxHandler . endDocument ( ) ; super . fireEndDoc ( ) ; } protected void closeStartTag ( ) throws SAXException { m_startTagOpen = false ; final String localName = getLocalName ( m_elementName ) ; final String uri = getNamespaceURI ( m_elementName , true ) ; if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; } m_saxHandler . startElement ( uri , localName , m_elementName , m_attributes ) ; m_attributes . clear ( ) ; if ( m_state != null ) m_state . setCurrentNode ( null ) ; pushCdataSectionState ( ) ; } public void closeCDATA ( ) throws SAXException { m_saxHandler . characters ( ENDCDATA , 0 , ENDCDATA . length ) ; m_cdataTagOpen = false ; } public void endElement ( String namespaceURI , String localName , String qName ) throws SAXException { flushPending ( ) ; if ( namespaceURI == null ) { if ( m_elementURI != null ) namespaceURI = m_elementURI ; else namespaceURI = getNamespaceURI ( qName , true ) ; } if ( localName == null ) { if ( m_elementLocalName != null ) localName = m_elementLocalName ; else localName = getLocalName ( qName ) ; } m_saxHandler . endElement ( namespaceURI , localName , qName ) ; super . fireEndElem ( qName ) ; m_prefixMap . popNamespaces ( m_currentElemDepth ) ; m_currentElemDepth -- ; m_startTagOpen = false ; m_cdataSectionStates . pop ( ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { return ; } public void ignorableWhitespace ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { m_saxHandler . ignorableWhitespace ( arg0 , arg1 , arg2 ) ; } public void setDocumentLocator ( Locator arg0 ) { m_saxHandler . setDocumentLocator ( arg0 ) ; } public void skippedEntity ( String arg0 ) throws SAXException { m_saxHandler . skippedEntity ( arg0 ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { startPrefixMapping ( prefix , uri , true ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws org . xml . sax . SAXException { boolean pushed ; int pushDepth ; if ( shouldFlush ) { flushPending ( ) ; pushDepth = m_currentElemDepth + 1 ; } else { pushDepth = m_currentElemDepth ; } pushed = m_prefixMap . pushNamespace ( prefix , uri , pushDepth ) ; if ( pushed ) { m_saxHandler . startPrefixMapping ( prefix , uri ) ; String name ; if ( EMPTYSTRING . equals ( prefix ) ) { name = "xmlns" ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } else { if ( ! EMPTYSTRING . equals ( uri ) ) { name = "xmlns:" + prefix ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } } } return pushed ; } public void comment ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { flushPending ( ) ; if ( m_lexHandler != null ) m_lexHandler . comment ( arg0 , arg1 , arg2 ) ; super . fireCommentEvent ( arg0 , arg1 , arg2 ) ; } public void endCDATA ( ) throws SAXException { if ( m_lexHandler != null ) m_lexHandler . endCDATA ( ) ; } public void endDTD ( ) throws SAXException { if ( m_lexHandler != null ) m_lexHandler . endDTD ( ) ; } public void startEntity ( String arg0 ) throws SAXException { if ( m_lexHandler != null ) m_lexHandler . startEntity ( arg0 ) ; } public void characters ( String chars ) throws SAXException { final char [ ] arr = chars . toCharArray ( ) ; this . characters ( arr , 0 , arr . length ) ; } public ToXMLSAXHandler ( ContentHandler handler , String encoding ) { super ( handler , encoding ) ; initCDATA ( ) ; m_prefixMap = new NamespaceMappings ( ) ; } public ToXMLSAXHandler ( ContentHandler handler , LexicalHandler lex , String encoding ) { super ( handler , lex , encoding ) ; initCDATA ( ) ; m_prefixMap = new NamespaceMappings ( ) ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { startElement ( elementNamespaceURI , elementLocalName , elementName , null ) ; } public void startElement ( String elementName ) throws SAXException { startElement ( null , null , elementName , null ) ; } public void characters ( char [ ] ch , int off , int len ) throws SAXException { flushPending ( ) ; if ( m_cdataSectionStates . peekOrFalse ( ) ) { startCDATA ( ch , off , len ) ; } else { m_saxHandler . characters ( ch , off , len ) ; } fireCharEvent ( ch , off , len ) ; } public void endElement ( String elemName ) throws SAXException { endElement ( null , null , elemName ) ; } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { startPrefixMapping ( prefix , uri , false ) ; } public void processingInstruction ( String target , String data ) throws SAXException { flushPending ( ) ; m_saxHandler . processingInstruction ( target , data ) ; super . fireEscapingEvent ( target , data ) ; } protected boolean popNamespace ( String prefix ) { try { if ( m_prefixMap . popNamespace ( prefix ) ) { m_saxHandler . endPrefixMapping ( prefix ) ; return true ; } } catch ( SAXException e ) { } return false ; } public void startCDATA ( ) throws SAXException { m_saxHandler . characters ( BEGCDATA , 0 , BEGCDATA . length ) ; m_cdataTagOpen = true ; } private void startCDATA ( char [ ] ch , int off , int len ) throws SAXException { final int limit = off + len ; int offset = off ; m_saxHandler . characters ( BEGCDATA , 0 , BEGCDATA . length ) ; for ( int i = offset ; i < limit - 2 ; i ++ ) { if ( ch [ i ] == ']' && ch [ i + 1 ] == ']' && ch [ i + 2 ] == '>' ) { m_saxHandler . characters ( ch , offset , i - offset ) ; m_saxHandler . characters ( CNTCDATA , 0 , CNTCDATA . length ) ; offset = i + 3 ; i += 2 ; } } if ( offset < limit ) { m_saxHandler . characters ( ch , offset , limit - offset ) ; } m_cdataTagOpen = true ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws SAXException { flushPending ( ) ; super . startElement ( namespaceURI , localName , name , atts ) ; if ( m_needToOutputDocTypeDecl ) { String doctypeSystem = getDoctypeSystem ( ) ; if ( doctypeSystem != null && m_lexHandler != null ) { String doctypePublic = getDoctypePublic ( ) ; if ( doctypeSystem != null ) m_lexHandler . startDTD ( name , doctypePublic , doctypeSystem ) ; } m_needToOutputDocTypeDecl = false ; } m_currentElemDepth ++ ; if ( namespaceURI != null ) ensurePrefixIsDeclared ( namespaceURI , name ) ; m_elementLocalName = localName ; m_elementURI = namespaceURI ; m_elementName = name ; if ( atts != null ) addAttributes ( atts ) ; m_startTagOpen = true ; pushCdataSectionState ( ) ; } private void ensurePrefixIsDeclared ( String ns , String rawName ) throws org . xml . sax . SAXException { if ( ns != null && ns . length ( ) > 0 ) { int index ; String prefix = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; if ( null != prefix ) { String foundURI = m_prefixMap . lookupNamespace ( prefix ) ; if ( ( null == foundURI ) || ! foundURI . equals ( ns ) ) { this . startPrefixMapping ( prefix , ns , false ) ; this . addAttributeAlways ( "http://www.w3.org/2000/xmlns/" , prefix , "xmlns" + ( prefix . length ( ) == 0 ? "" : ":" ) + prefix , "CDATA" , ns ) ; } } } } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_startTagOpen ) { ensurePrefixIsDeclared ( uri , rawName ) ; addAttributeAlways ( uri , localName , rawName , type , value ) ; } } } 	1	['44', '3', '0', '8', '95', '716', '3', '5', '40', '0.930232558', '683', '1', '0', '0.730263158', '0.15034965', '2', '13', '14.5', '1', '0.9318', '4']
package org . apache . xalan . templates ; public class ElemEmpty extends ElemTemplateElement { public ElemEmpty ( ) { } } 	1	['1', '3', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Error: Can not have '{' within expression" } , { ER_ILLEGAL_ATTRIBUTE , "{0} has an illegal attribute: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode is null in xsl:apply-imports!" } , { ER_CANNOT_ADD , "Can not add {0} to {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode is null in handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} must have a name attribute." } , { ER_TEMPLATE_NOT_FOUND , "Could not find template named: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Could not resolve name AVT in xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} requires attribute: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} must have a ''test'' attribute." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Bad value on level attribute: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction name can not be 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction name must be a valid NCName: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} must have a match attribute if it has a mode." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} requires either a name or a match attribute." } , { ER_CANT_RESOLVE_NSPREFIX , "Can not resolve namespace prefix: {0}" } , { ER_ILLEGAL_VALUE , "xml:space has an illegal value: {0}" } , { ER_NO_OWNERDOC , "Child node does not have an owner document!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement error: {0}" } , { ER_NULL_CHILD , "Trying to add a null child!" } , { ER_NEED_SELECT_ATTRIB , "{0} requires a select attribute." } , { ER_NEED_TEST_ATTRIB , "xsl:when must have a 'test' attribute." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param must have a 'name' attribute." } , { ER_NO_CONTEXT_OWNERDOC , "context does not have an owner document!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Could not create XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Process was not successful." } , { ER_NOT_SUCCESSFUL , "Xalan: was not successful." } , { ER_ENCODING_NOT_SUPPORTED , "Encoding not supported: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Could not create TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key requires a 'name' attribute!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key requires a 'match' attribute!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key requires a 'use' attribute!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} requires an ''elements'' attribute!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} attribute ''prefix'' is missing" } , { ER_BAD_STYLESHEET_URL , "Stylesheet URL is bad: {0}" } , { ER_FILE_NOT_FOUND , "Stylesheet file was not found: {0}" } , { ER_IOEXCEPTION , "Had IO Exception with stylesheet file: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Could not find href attribute for {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} is directly or indirectly including itself!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude error, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} attribute ''lang'' is missing" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) misplaced {0} element?? Missing container element ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Can only output to an Element, DocumentFragment, Document, or PrintWriter." } , { ER_PROCESS_ERROR , "StylesheetRoot.process error" } , { ER_UNIMPLNODE_ERROR , "UnImplNode error: {0}" } , { ER_NO_SELECT_EXPRESSION , "Error! Did not find xpath select expression (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Can not serialize an XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Stylesheet input was not specified!" } , { ER_FAILED_PROCESS_STYLESHEET , "Failed to process stylesheet!" } , { ER_COULDNT_PARSE_DOC , "Could not parse {0} document!" } , { ER_COULDNT_FIND_FRAGMENT , "Could not find fragment: {0}" } , { ER_NODE_NOT_ELEMENT , "Node pointed to by fragment identifier was not an element: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each must have either a match or name attribute" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates must have either a match or name attribute" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "No clone of a document fragment!" } , { ER_CANT_CREATE_ITEM , "Can not create item in result tree: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space in the source XML has an illegal value: {0}" } , { ER_NO_XSLKEY_DECLARATION , "There is no xsl:key declaration for {0}!" } , { ER_CANT_CREATE_URL , "Error! Cannot create url for: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions is unsupported" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory Error" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} not allowed inside a stylesheet!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns no longer supported!  Use xsl:output instead." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space no longer supported!  Use xsl:strip-space or xsl:preserve-space instead." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result no longer supported!  Use xsl:output instead." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} has an illegal attribute: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Unknown XSL element: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort can only be used with xsl:apply-templates or xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) misplaced xsl:when!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when not parented by xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) misplaced xsl:otherwise!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise not parented by xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} is not allowed inside a template!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} extension namespace prefix {1} unknown" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Imports can only occur as the first elements in the stylesheet!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} is directly or indirectly importing itself!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space has an illegal value: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet not succesfull!" } , { ER_SAX_EXCEPTION , "SAX Exception" } , { ER_XSLT_ERROR , "XSLT Error" } , { ER_CURRENCY_SIGN_ILLEGAL , "currency sign is not allowed in format pattern string" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Document function not supported in Stylesheet DOM!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Can't resolve prefix of non-Prefix resolver!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect extension: Could not get filename - file or select attribute must return vald string." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Can not build FormatterListener in Redirect extension!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Prefix in exclude-result-prefixes is not valid: {0}" } , { ER_MISSING_NS_URI , "Missing namespace URI for specified prefix" } , { ER_MISSING_ARG_FOR_OPTION , "Missing argument for option: {0}" } , { ER_INVALID_OPTION , "Invalid option: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Malformed format string: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requires a 'version' attribute!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Attribute: {0} has an illegal value: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose requires an xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports not allowed in a xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Cannot use a DTMLiaison for an output DOM node... pass a org.apache.xpath.DOM2Helper instead!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Cannot use a DTMLiaison for a input DOM node... pass a org.apache.xpath.DOM2Helper instead!" } , { ER_CALL_TO_EXT_FAILED , "Call to extension element failed: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Invalid UTF-16 surrogate detected: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} used itself, which will cause an infinite loop." } , { ER_CANNOT_MIX_XERCESDOM , "Can not mix non Xerces-DOM input with Xerces-DOM output!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "In ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Found more than one template named: {0}" } , { ER_INVALID_KEY_CALL , "Invalid function call: recursive key() calls are not allowed" } , { ER_REFERENCING_ITSELF , "Variable {0} is directly or indirectly referencing itself!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "The input node can not be null for a DOMSource for newTemplates!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Class file not found for option {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Required Element not found: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream cannot be null" } , { ER_URI_CANNOT_BE_NULL , "URI cannot be null" } , { ER_FILE_CANNOT_BE_NULL , "File cannot be null" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource cannot be null" } , { ER_CANNOT_INIT_BSFMGR , "Could not initialize BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "Could not compile extension" } , { ER_CANNOT_CREATE_EXTENSN , "Could not create extension: {0} because of: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Instance method call to method {0} requires an Object instance as first argument" } , { ER_INVALID_ELEMENT_NAME , "Invalid element name specified {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Element name method must be static {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Extension function {0} : {1} is unknown" } , { ER_MORE_MATCH_CONSTRUCTOR , "More than one best match for constructor for {0}" } , { ER_MORE_MATCH_METHOD , "More than one best match for method {0}" } , { ER_MORE_MATCH_ELEMENT , "More than one best match for element method {0}" } , { ER_INVALID_CONTEXT_PASSED , "Invalid context passed to evaluate {0}" } , { ER_POOL_EXISTS , "Pool already exists" } , { ER_NO_DRIVER_NAME , "No driver Name specified" } , { ER_NO_URL , "No URL specified" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Pool size is less than one!" } , { ER_INVALID_DRIVER , "Invalid driver name specified!" } , { ER_NO_STYLESHEETROOT , "Did not find the stylesheet root!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Illegal value for xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode failed" } , { ER_RESOURCE_COULD_NOT_LOAD , "The resource [ {0} ] could not load: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Buffer size <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Unknown error when calling extension" } , { ER_NO_NAMESPACE_DECL , "Prefix {0} does not have a corresponding namespace declaration" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Element content not allowed for lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Stylesheet directed termination" } , { ER_ONE_OR_TWO , "1 or 2" } , { ER_TWO_OR_THREE , "2 or 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Could not load {0} (check CLASSPATH), now using just the defaults" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Cannot initialize default templates" } , { ER_RESULT_NULL , "Result should not be null" } , { ER_RESULT_COULD_NOT_BE_SET , "Result could not be set" } , { ER_NO_OUTPUT_SPECIFIED , "No output specified" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Can''t transform to a Result of type {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Can''t transform a Source of type {0}" } , { ER_NULL_CONTENT_HANDLER , "Null content handler" } , { ER_NULL_ERROR_HANDLER , "Null error handler" } , { ER_CANNOT_CALL_PARSE , "parse can not be called if the ContentHandler has not been set" } , { ER_NO_PARENT_FOR_FILTER , "No parent for filter" } , { ER_NO_STYLESHEET_IN_MEDIA , "No stylesheet found in: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "No xml-stylesheet PI found in: {0}" } , { ER_NOT_SUPPORTED , "Not supported: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Value for property {0} should be a Boolean instance" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Could not get to external script at {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "The resource [ {0} ] could not be found.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Output property not recognized: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Failed creating ElemLiteralResult instance" } , { ER_VALUE_SHOULD_BE_NUMBER , "Value for {0} should contain a parsable number" } , { ER_VALUE_SHOULD_EQUAL , "Value for {0} should equal yes or no" } , { ER_FAILED_CALLING_METHOD , "Failed calling {0} method" } , { ER_FAILED_CREATING_ELEMTMPL , "Failed creating ElemTemplateElement instance" } , { ER_CHARS_NOT_ALLOWED , "Characters are not allowed at this point in the document" } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" attribute is not allowed on the {1} element!" } , { ER_BAD_VALUE , "{0} bad value {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} attribute value not found " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} attribute value not recognized " } , { ER_NULL_URI_NAMESPACE , "Attempting to generate a namespace prefix with a null URI" } , { ER_NUMBER_TOO_BIG , "Attempting to format a number bigger than the largest Long integer" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Cannot find SAX1 driver class {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1 driver class {0} found but cannot be loaded" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1 driver class {0} loaded but cannot be instantiated" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 driver class {0} does not implement org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "System property org.xml.sax.parser not specified" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Parser argument must not be null" } , { ER_FEATURE , "Feature: {0}" } , { ER_PROPERTY , "Property: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Null entity resolver" } , { ER_NULL_DTD_HANDLER , "Null DTD handler" } , { ER_NO_DRIVER_NAME_SPECIFIED , "No Driver Name Specified!" } , { ER_NO_URL_SPECIFIED , "No URL Specified!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Pool size is less than 1!" } , { ER_INVALID_DRIVER_NAME , "Invalid Driver Name Specified!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programmer's error! The expression has no ElemTemplateElement parent!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Programmer''s assertion in RedundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} is not allowed in this position in the stylesheet!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Non-whitespace text is not allowed in this position in the stylesheet!" } , { INVALID_TCHAR , "Illegal value: {1} used for CHAR attribute: {0}.  An attribute of type CHAR must be only 1 character!" } , { INVALID_QNAME , "Illegal value: {1} used for QNAME attribute: {0}" } , { INVALID_ENUM , "Illegal value: {1} used for ENUM attribute: {0}.  Valid values are: {2}." } , { INVALID_NMTOKEN , "Illegal value: {1} used for NMTOKEN attribute: {0} " } , { INVALID_NCNAME , "Illegal value: {1} used for NCNAME attribute: {0} " } , { INVALID_BOOLEAN , "Illegal value: {1} used for boolean attribute: {0} " } , { INVALID_NUMBER , "Illegal value: {1} used for number attribute: {0} " } , { ER_ARG_LITERAL , "Argument to {0} in match pattern must be a literal." } , { ER_DUPLICATE_GLOBAL_VAR , "Duplicate global variable declaration." } , { ER_DUPLICATE_VAR , "Duplicate variable declaration." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template must have a name or match attribute (or both)" } , { ER_INVALID_PREFIX , "Prefix in exclude-result-prefixes is not valid: {0}" } , { ER_NO_ATTRIB_SET , "attribute-set named {0} does not exist" } , { WG_FOUND_CURLYBRACE , "Found '}' but no attribute template open!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Warning: count attribute does not match an ancestor in xsl:number! Target = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Old syntax: The name of the 'expr' attribute has been changed to 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan doesn't yet handle the locale name in the format-number function." } , { WG_LOCALE_NOT_FOUND , "Warning: Could not find locale for xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Can not make URL from: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Can not load requested doc: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Could not find Collator for <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Old syntax: the functions instruction should use a url of {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "encoding not supported: {0}, using UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "encoding not supported: {0}, using Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Specificity conflicts found: {0} Last found in stylesheet will be used." } , { WG_PARSING_AND_PREPARING , "========= Parsing and preparing {0} ==========" } , { WG_ATTR_TEMPLATE , "Attr Template, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Match conflict between xsl:strip-space and xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan does not yet handle the {0} attribute!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "No declaration found for decimal format: {0}" } , { WG_OLD_XSLT_NS , "Missing or incorrect XSLT Namespace. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Only one default xsl:decimal-format declaration is allowed." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format names must be unique. Name \"{0}\" has been duplicated." } , { WG_ILLEGAL_ATTRIBUTE , "{0} has an illegal attribute: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Could not resolve namespace prefix: {0}. The node will be ignored." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requires a 'version' attribute!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Illegal attribute name: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Illegal value used for attribute {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Resulting nodeset from second argument of document function is empty. Return an empty node-set." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "The value of the 'name' attribute of xsl:processing-instruction name must not be 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "The value of the 'name' attribute of xsl:processing-instruction must be a valid NCName: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Cannot add attribute {0} after child nodes or before an element is produced.  Attribute will be ignored." } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Parameter to createMessage was out of bounds" } , { "FORMAT_FAILED" , "Exception thrown during messageFormat call" } , { "version" , ">>>>>>> Xalan Version " } , { "version2" , "<<<<<<<" } , { "yes" , "yes" } , { "line" , "Line #" } , { "column" , "Column #" } , { "xsldone" , "XSLProcessor: done" } , { "xslProc_option" , "Xalan-J command line Process class options:" } , { "xslProc_option" , "Xalan-J command line Process class options:" } , { "xslProc_invalid_xsltc_option" , "The option {0} is not supported in XSLTC mode." } , { "xslProc_invalid_xalan_option" , "The option {0} can only be used with -XSLTC." } , { "xslProc_no_input" , "Error: No stylesheet or input xml is specified. Run this command without any option for usage instructions." } , { "xslProc_common_options" , "-Common Options-" } , { "xslProc_xalan_options" , "-Options for Xalan-" } , { "xslProc_xsltc_options" , "-Options for XSLTC-" } , { "xslProc_return_to_continue" , "(press <return> to continue)" } , { "optionXSLTC" , "   [-XSLTC (use XSLTC for transformation)]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER fully qualified class name of parser liaison]" } , { "optionE" , "   [-E (Do not expand entity refs)]" } , { "optionV" , "   [-E (Do not expand entity refs)]" } , { "optionQC" , "   [-QC (Quiet Pattern Conflicts Warnings)]" } , { "optionQ" , "   [-Q  (Quiet Mode)]" } , { "optionLF" , "   [-LF (Use linefeeds only on output {default is CR/LF})]" } , { "optionCR" , "   [-CR (Use carriage returns only on output {default is CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Which characters to escape {default is <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Control how many spaces to indent {default is 0})]" } , { "optionTT" , "   [-TT (Trace the templates as they are being called.)]" } , { "optionTG" , "   [-TG (Trace each generation event.)]" } , { "optionTS" , "   [-TS (Trace each selection event.)]" } , { "optionTTC" , "   [-TTC (Trace the template children as they are being processed.)]" } , { "optionTCLASS" , "   [-TCLASS (TraceListener class for trace extensions.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Set whether validation occurs.  Validation is off by default.)]" } , { "optionEDUMP" , "   [-EDUMP {optional filename} (Do stackdump on error.)]" } , { "optionXML" , "   [-XML (Use XML formatter and add XML header.)]" } , { "optionTEXT" , "   [-TEXT (Use simple Text formatter.)]" } , { "optionHTML" , "   [-HTML (Use HTML formatter.)]" } , { "optionPARAM" , "   [-PARAM name expression (Set a stylesheet parameter)]" } , { "noParsermsg1" , "XSL Process was not successful." } , { "noParsermsg2" , "** Could not find parser **" } , { "noParsermsg3" , "Please check your classpath." } , { "noParsermsg4" , "If you don't have IBM's XML Parser for Java, you can download it from" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER full class name (URIResolver to be used to resolve URIs)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER full class name (EntityResolver to be used to resolve entities)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER full class name (ContentHandler to be used to serialize output)]" } , { "optionLINENUMBERS" , "   [-L use line numbers for source document]" } , { "optionMEDIA" , "   [-MEDIA mediaType (use media attribute to find stylesheet associated with a document.)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName (Explicitly use s2s=SAX or d2d=DOM to do transform.)] " } , { "optionDIAG" , "   [-DIAG (Print overall milliseconds transform took.)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (request incremental DTM construction by setting http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (request no stylesheet optimization proccessing by setting http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , "   [-RL recursionlimit (assert numeric limit on stylesheet recursion depth.)]" } , { "optionXO" , "   [-XO [transletName] (assign the name to the generated translet)]" } , { "optionXD" , "   [-XD destinationDirectory (specify a destination directory for translet)]" } , { "optionXJ" , "   [-XJ jarfile (packages translet classes into a jar file of name <jarfile>)]" } , { "optionXP" , "   [-XP package (specifies a package name prefix for all generated translet classes)]" } , { "optionXN" , "   [-XN (enables template inlining)]" } , { "optionXX" , "   [-XX (turns on additional debugging message output)]" } , { "optionXT" , "   [-XT (use translet to transform if possible)]" } , { "diagTiming" , " --------- Transform of {0} via {1} took {2} ms" } , { "recursionTooDeep" , "Template nesting too deep. nesting = {0}, template {1} {2}" } , { "nameIs" , "name is" } , { "matchPatternIs" , "match pattern is" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '10', '10', '16', '8', '10', '0', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '2']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class UnsupportedElement extends SyntaxTreeNode { private Fallback _fallback = null ; private ErrorMsg _message = null ; public UnsupportedElement ( String uri , String prefix , String local ) { super ( uri , prefix , local ) ; } public void setErrorMessage ( ErrorMsg message ) { _message = message ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Unsupported element = " + _qname . getNamespace ( ) + ":" + _qname . getLocalPart ( ) ) ; displayContents ( indent + IndentIncrement ) ; } private SyntaxTreeNode findFallback ( SyntaxTreeNode root ) { if ( root == null ) return null ; if ( root instanceof Fallback ) return ( ( Fallback ) root ) ; Vector children = root . getContents ( ) ; if ( children != null ) { final int count = children . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) children . elementAt ( i ) ; SyntaxTreeNode node = findFallback ( child ) ; if ( node != null ) return node ; } } return null ; } public void parseContents ( Parser parser ) { _fallback = ( Fallback ) findFallback ( this ) ; if ( _fallback != null ) { _fallback . activate ( ) ; _fallback . parseContents ( parser ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _fallback == null ) { throw new TypeCheckError ( _message ) ; } return ( _fallback . typeCheck ( stable ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _fallback != null ) _fallback . translate ( classGen , methodGen ) ; } } 	1	['7', '2', '0', '11', '24', '5', '1', '11', '6', '0.583333333', '131', '1', '2', '0.9', '0.238095238', '1', '5', '17.42857143', '6', '1.8571', '1']
package org . apache . xalan . templates ; import org . apache . xalan . res . XSLTErrorResources ; public class ElemText extends ElemTemplateElement { private boolean m_disableOutputEscaping = false ; public void setDisableOutputEscaping ( boolean v ) { m_disableOutputEscaping = v ; } public boolean getDisableOutputEscaping ( ) { return m_disableOutputEscaping ; } public int getXSLToken ( ) { return Constants . ELEMNAME_TEXT ; } public String getNodeName ( ) { return Constants . ELEMNAME_TEXT_STRING ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } } 	1	['6', '3', '0', '4', '11', '9', '3', '1', '6', '0.6', '49', '1', '0', '0.975124378', '0.444444444', '2', '6', '7', '3', '1.1667', '1']
package org . apache . xpath ; public class XPathProcessorException extends XPathException { public XPathProcessorException ( String message ) { super ( message ) ; } public XPathProcessorException ( String message , Exception e ) { super ( message , e ) ; } } 	1	['2', '5', '0', '4', '4', '1', '3', '1', '2', '2', '11', '0', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '1']
package org . apache . xalan . xsltc . dom ; import java . util . Enumeration ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . DTMAxisIterNodeList ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM2 ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . serializer . ToXMLSAXHandler ; import org . apache . xml . utils . XMLStringFactory ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Entity ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public final class SAXImpl extends SAX2DTM2 implements DOM , DOMBuilder { private int _uriCount = 0 ; private int _prefixCount = 0 ; private int [ ] _xmlSpaceStack ; private int _idx = 1 ; private boolean _preserve = false ; private static final String XML_STRING = "xml:" ; private static final String XML_PREFIX = "xml" ; private static final String XMLSPACE_STRING = "xml:space" ; private static final String PRESERVE_STRING = "preserve" ; private static final String XMLNS_PREFIX = "xmlns" ; private static final String XML_URI = "http://www.w3.org/XML/1998/namespace" ; private boolean _escaping = true ; private boolean _disableEscaping = false ; private int _textNodeToProcess = DTM . NULL ; private final static String EMPTYSTRING = "" ; private final static DTMAxisIterator EMPTYITERATOR = new DTMAxisIteratorBase ( ) { public DTMAxisIterator reset ( ) { return this ; } public DTMAxisIterator setStartNode ( int node ) { return this ; } public int next ( ) { return DTM . NULL ; } public void setMark ( ) { } public void gotoMark ( ) { } public int getLast ( ) { return 0 ; } public int getPosition ( ) { return 0 ; } public DTMAxisIterator cloneIterator ( ) { return this ; } public void setRestartable ( boolean isRestartable ) { } } ; private int _namesSize = 0 ; private Hashtable _nsIndex = new Hashtable ( ) ; private int _size = 0 ; private BitArray _dontEscape = null ; private String _documentURI = null ; static private int _documentURIIndex = 0 ; private Document _document ; private Hashtable _node2Ids = null ; private boolean _hasDOMSource = false ; private XSLTCDTMManager _dtmManager ; private Node [ ] _nodes ; private NodeList [ ] _nodeLists ; private final static String XML_LANG_ATTRIBUTE = "http://www.w3.org/XML/1998/namespace:@lang" ; public void setDocumentURI ( String uri ) { setDocumentBaseURI ( uri ) ; _documentURI = uri ; } public String getDocumentURI ( ) { String baseURI = getDocumentBaseURI ( ) ; return ( baseURI != null ) ? baseURI : "rtf" + _documentURIIndex ++ ; } public String getDocumentURI ( int node ) { return getDocumentURI ( ) ; } public void setupMapping ( String [ ] names , String [ ] namespaces ) { } public String lookupNamespace ( int node , String prefix ) throws TransletException { int anode , nsnode ; final AncestorIterator ancestors = new AncestorIterator ( ) ; if ( isElement ( node ) ) { ancestors . includeSelf ( ) ; } ancestors . setStartNode ( node ) ; while ( ( anode = ancestors . next ( ) ) != DTM . NULL ) { final NamespaceIterator namespaces = new NamespaceIterator ( ) ; namespaces . setStartNode ( anode ) ; while ( ( nsnode = namespaces . next ( ) ) != DTM . NULL ) { if ( getLocalName ( nsnode ) . equals ( prefix ) ) { return getNodeValue ( nsnode ) ; } } } BasisLibrary . runTimeError ( BasisLibrary . NAMESPACE_PREFIX_ERR , prefix ) ; return null ; } public boolean isElement ( final int node ) { return getNodeType ( node ) == DTM . ELEMENT_NODE ; } public boolean isAttribute ( final int node ) { return getNodeType ( node ) == DTM . ATTRIBUTE_NODE ; } public int getSize ( ) { return getNumberOfNodes ( ) ; } public void setFilter ( StripFilter filter ) { } public boolean lessThan ( int node1 , int node2 ) { if ( node1 == DTM . NULL ) { return false ; } if ( node2 == DTM . NULL ) { return true ; } return ( node1 < node2 ) ; } public Node makeNode ( int index ) { if ( _nodes == null ) { _nodes = new Node [ _namesSize ] ; } return ( _nodes [ index ] != null ) ? _nodes [ index ] : ( _nodes [ index ] = new DTMNodeProxy ( ( DTM ) this , index ) ) ; } public Node makeNode ( DTMAxisIterator iter ) { return makeNode ( iter . next ( ) ) ; } public NodeList makeNodeList ( int index ) { if ( _nodeLists == null ) { _nodeLists = new NodeList [ _namesSize ] ; } return ( _nodeLists [ index ] != null ) ? _nodeLists [ index ] : ( _nodeLists [ index ] = new DTMAxisIterNodeList ( this , new SingletonIterator ( index ) ) ) ; } public NodeList makeNodeList ( DTMAxisIterator iter ) { return new DTMAxisIterNodeList ( this , iter ) ; } public class TypedNamespaceIterator extends NamespaceIterator { private final int _nodeType ; public TypedNamespaceIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { int node ; for ( node = super . next ( ) ; node != END ; node = super . next ( ) ) { if ( getExpandedTypeID ( node ) == _nodeType || getNodeType ( node ) == _nodeType || getIdForNamespace ( getStringValueX ( node ) ) == _nodeType ) { return returnNode ( node ) ; } } return ( END ) ; } } private final class NodeValueIterator extends InternalAxisIteratorBase { private DTMAxisIterator _source ; private String _value ; private boolean _op ; private final boolean _isReverse ; private int _returnType = RETURN_PARENT ; public NodeValueIterator ( DTMAxisIterator source , int returnType , String value , boolean op ) { _source = source ; _returnType = returnType ; _value = value ; _op = op ; _isReverse = source . isReverse ( ) ; } public boolean isReverse ( ) { return _isReverse ; } public DTMAxisIterator cloneIterator ( ) { try { NodeValueIterator clone = ( NodeValueIterator ) super . clone ( ) ; clone . _isRestartable = false ; clone . _source = _source . cloneIterator ( ) ; clone . _value = _value ; clone . _op = _op ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { String val = getStringValueX ( node ) ; if ( _value . equals ( val ) == _op ) { if ( _returnType == RETURN_CURRENT ) { return returnNode ( node ) ; } else { return returnNode ( getParent ( node ) ) ; } } } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; return resetPosition ( ) ; } return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iterator , int type , String value , boolean op ) { return ( DTMAxisIterator ) ( new NodeValueIterator ( iterator , type , value , op ) ) ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return new DupFilterIterator ( source ) ; } public DTMAxisIterator getIterator ( ) { return new SingletonIterator ( getDocument ( ) ) ; } public int getNSType ( int node ) { String s = getNamespaceURI ( node ) ; if ( s == null ) { return 0 ; } int eType = getIdForNamespace ( s ) ; return ( ( Integer ) _nsIndex . get ( new Integer ( eType ) ) ) . intValue ( ) ; } public int getNamespaceType ( final int node ) { return super . getNamespaceType ( node ) ; } private int [ ] setupMapping ( String [ ] namesArray , int nNames ) { final int [ ] types = new int [ m_expandedNameTable . getSize ( ) ] ; for ( int i = 0 ; i < nNames ; i ++ ) { int type = getGeneralizedType ( namesArray [ i ] ) ; types [ type ] = type ; } return types ; } public int getGeneralizedType ( final String name ) { String lName , ns = null ; int index = - 1 ; int code ; if ( ( index = name . lastIndexOf ( ":" ) ) > - 1 ) { ns = name . substring ( 0 , index ) ; } int lNameStartIdx = index + 1 ; if ( name . charAt ( lNameStartIdx ) == '@' ) { code = DTM . ATTRIBUTE_NODE ; lNameStartIdx ++ ; } else { code = DTM . ELEMENT_NODE ; } lName = ( lNameStartIdx == 0 ) ? name : name . substring ( lNameStartIdx ) ; return this . getExpandedTypeID ( ns , lName , code ) ; } public short [ ] getMapping ( String [ ] names ) { int i ; final int namesLength = names . length ; final int exLength = m_expandedNameTable . getSize ( ) ; int [ ] generalizedTypes = null ; if ( namesLength > 0 ) { generalizedTypes = new int [ namesLength ] ; } int resultLength = exLength ; for ( i = 0 ; i < namesLength ; i ++ ) { generalizedTypes [ i ] = getGeneralizedType ( names [ i ] ) ; if ( _namesSize == 0 && generalizedTypes [ i ] >= resultLength ) { resultLength = generalizedTypes [ i ] + 1 ; } } final short [ ] result = new short [ resultLength ] ; for ( i = 0 ; i < DTM . NTYPES ; i ++ ) { result [ i ] = ( short ) i ; } for ( i = NTYPES ; i < exLength ; i ++ ) { result [ i ] = m_expandedNameTable . getType ( i ) ; } for ( i = 0 ; i < namesLength ; i ++ ) { int genType = generalizedTypes [ i ] ; if ( _namesSize > 0 ) { if ( genType < result . length ) { result [ genType ] = ( short ) ( i + DTM . NTYPES ) ; } } else { result [ genType ] = ( short ) ( i + DTM . NTYPES ) ; } } return ( result ) ; } public int [ ] getReverseMapping ( String [ ] names ) { int i ; final int [ ] result = new int [ names . length + DTM . NTYPES ] ; for ( i = 0 ; i < DTM . NTYPES ; i ++ ) { result [ i ] = i ; } for ( i = 0 ; i < names . length ; i ++ ) { int type = getGeneralizedType ( names [ i ] ) ; result [ i + DTM . NTYPES ] = type ; } return ( result ) ; } public short [ ] getNamespaceMapping ( String [ ] namespaces ) { int i ; final int nsLength = namespaces . length ; final int mappingLength = _uriCount ; final short [ ] result = new short [ mappingLength ] ; for ( i = 0 ; i < mappingLength ; i ++ ) { result [ i ] = ( short ) ( - 1 ) ; } for ( i = 0 ; i < nsLength ; i ++ ) { int eType = getIdForNamespace ( namespaces [ i ] ) ; Integer type = ( Integer ) _nsIndex . get ( new Integer ( eType ) ) ; if ( type != null ) { result [ type . intValue ( ) ] = ( short ) i ; } } return ( result ) ; } public short [ ] getReverseNamespaceMapping ( String [ ] namespaces ) { int i ; final int length = namespaces . length ; final short [ ] result = new short [ length ] ; for ( i = 0 ; i < length ; i ++ ) { int eType = getIdForNamespace ( namespaces [ i ] ) ; Integer type = ( Integer ) _nsIndex . get ( new Integer ( eType ) ) ; result [ i ] = ( type == null ) ? - 1 : type . shortValue ( ) ; } return result ; } public SAXImpl ( XSLTCDTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , boolean buildIdIndex ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , buildIdIndex ) ; } public SAXImpl ( XSLTCDTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean buildIdIndex ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , false , buildIdIndex ) ; _dtmManager = mgr ; _size = blocksize ; _xmlSpaceStack = new int [ blocksize <= 64 ? 4 : 64 ] ; _xmlSpaceStack [ 0 ] = DTMDefaultBase . ROOTNODE ; if ( source instanceof DOMSource ) { _hasDOMSource = true ; DOMSource domsrc = ( DOMSource ) source ; Node node = domsrc . getNode ( ) ; if ( node instanceof Document ) { _document = ( Document ) node ; } else { _document = node . getOwnerDocument ( ) ; } _node2Ids = new Hashtable ( ) ; } } public int getElementById ( String idString ) { Node node = _document . getElementById ( idString ) ; if ( node != null ) { Integer id = ( Integer ) _node2Ids . get ( node ) ; return ( id != null ) ? id . intValue ( ) : DTM . NULL ; } else { return DTM . NULL ; } } public boolean hasDOMSource ( ) { return _hasDOMSource ; } private void xmlSpaceDefine ( String val , final int node ) { final boolean setting = val . equals ( PRESERVE_STRING ) ; if ( setting != _preserve ) { _xmlSpaceStack [ _idx ++ ] = node ; _preserve = setting ; } } private void xmlSpaceRevert ( final int node ) { if ( node == _xmlSpaceStack [ _idx - 1 ] ) { _idx -- ; _preserve = ! _preserve ; } } protected boolean getShouldStripWhitespace ( ) { return _preserve ? false : super . getShouldStripWhitespace ( ) ; } private void handleTextEscaping ( ) { if ( _disableEscaping && _textNodeToProcess != DTM . NULL && _type ( _textNodeToProcess ) == DTM . TEXT_NODE ) { if ( _dontEscape == null ) { _dontEscape = new BitArray ( _size ) ; } if ( _textNodeToProcess >= _dontEscape . size ( ) ) { _dontEscape . resize ( _dontEscape . size ( ) * 2 ) ; } _dontEscape . setBit ( _textNodeToProcess ) ; _disableEscaping = false ; } _textNodeToProcess = DTM . NULL ; } public void characters ( char [ ] ch , int start , int length ) throws SAXException { super . characters ( ch , start , length ) ; _disableEscaping = ! _escaping ; _textNodeToProcess = getNumberOfNodes ( ) ; } public void startDocument ( ) throws SAXException { super . startDocument ( ) ; _nsIndex . put ( new Integer ( 0 ) , new Integer ( _uriCount ++ ) ) ; super . startPrefixMapping ( XML_PREFIX , XML_URI ) ; Integer eType = new Integer ( getIdForNamespace ( XML_URI ) ) ; _nsIndex . put ( eType , new Integer ( _uriCount ++ ) ) ; } public void endDocument ( ) throws SAXException { super . endDocument ( ) ; handleTextEscaping ( ) ; _namesSize = m_expandedNameTable . getSize ( ) ; } public void startElement ( String uri , String localName , String qname , Attributes attributes , Node node ) throws SAXException { this . startElement ( uri , localName , qname , attributes ) ; if ( m_buildIdIndex ) { _node2Ids . put ( node , new Integer ( m_parents . peek ( ) ) ) ; } } public void startElement ( String uri , String localName , String qname , Attributes attributes ) throws SAXException { super . startElement ( uri , localName , qname , attributes ) ; handleTextEscaping ( ) ; if ( m_wsfilter != null ) { final int index = attributes . getIndex ( XMLSPACE_STRING ) ; if ( index >= 0 ) { xmlSpaceDefine ( attributes . getValue ( index ) , m_parents . peek ( ) ) ; } } } public void endElement ( String namespaceURI , String localName , String qname ) throws SAXException { super . endElement ( namespaceURI , localName , qname ) ; handleTextEscaping ( ) ; if ( m_wsfilter != null ) { xmlSpaceRevert ( m_previous ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { super . processingInstruction ( target , data ) ; handleTextEscaping ( ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { super . ignorableWhitespace ( ch , start , length ) ; _textNodeToProcess = getNumberOfNodes ( ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { super . startPrefixMapping ( prefix , uri ) ; handleTextEscaping ( ) ; definePrefixAndUri ( prefix , uri ) ; } private void definePrefixAndUri ( String prefix , String uri ) throws SAXException { Integer eType = new Integer ( getIdForNamespace ( uri ) ) ; if ( ( Integer ) _nsIndex . get ( eType ) == null ) { _nsIndex . put ( eType , new Integer ( _uriCount ++ ) ) ; } } public void comment ( char [ ] ch , int start , int length ) throws SAXException { super . comment ( ch , start , length ) ; handleTextEscaping ( ) ; } public boolean setEscaping ( boolean value ) { final boolean temp = _escaping ; _escaping = value ; return temp ; } public void print ( int node , int level ) { switch ( getNodeType ( node ) ) { case DTM . ROOT_NODE : case DTM . DOCUMENT_NODE : print ( getFirstChild ( node ) , level ) ; break ; case DTM . TEXT_NODE : case DTM . COMMENT_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : System . out . print ( getStringValueX ( node ) ) ; break ; default : final String name = getNodeName ( node ) ; System . out . print ( "<" + name ) ; for ( int a = getFirstAttribute ( node ) ; a != DTM . NULL ; a = getNextAttribute ( a ) ) { System . out . print ( "\n" + getNodeName ( a ) + "=\"" + getStringValueX ( a ) + "\"" ) ; } System . out . print ( '>' ) ; for ( int child = getFirstChild ( node ) ; child != DTM . NULL ; child = getNextSibling ( child ) ) { print ( child , level + 1 ) ; } System . out . println ( "</" + name + '>' ) ; break ; } } public String getNodeName ( final int node ) { int nodeh = node ; final short type = getNodeType ( nodeh ) ; switch ( type ) { case DTM . ROOT_NODE : case DTM . DOCUMENT_NODE : case DTM . TEXT_NODE : case DTM . COMMENT_NODE : return EMPTYSTRING ; case DTM . NAMESPACE_NODE : return this . getLocalName ( nodeh ) ; default : return super . getNodeName ( nodeh ) ; } } public String getNamespaceName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } String s ; return ( s = getNamespaceURI ( node ) ) == null ? EMPTYSTRING : s ; } public int getAttributeNode ( final int type , final int element ) { for ( int attr = getFirstAttribute ( element ) ; attr != DTM . NULL ; attr = getNextAttribute ( attr ) ) { if ( getExpandedTypeID ( attr ) == type ) return attr ; } return DTM . NULL ; } public String getAttributeValue ( final int type , final int element ) { final int attr = getAttributeNode ( type , element ) ; return ( attr != DTM . NULL ) ? getStringValueX ( attr ) : EMPTYSTRING ; } public String getAttributeValue ( final String name , final int element ) { return getAttributeValue ( getGeneralizedType ( name ) , element ) ; } public DTMAxisIterator getChildren ( final int node ) { return ( new ChildrenIterator ( ) ) . setStartNode ( node ) ; } public DTMAxisIterator getTypedChildren ( final int type ) { return ( new TypedChildrenIterator ( type ) ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { switch ( axis ) { case Axis . SELF : return new SingletonIterator ( ) ; case Axis . CHILD : return new ChildrenIterator ( ) ; case Axis . PARENT : return new ParentIterator ( ) ; case Axis . ANCESTOR : return new AncestorIterator ( ) ; case Axis . ANCESTORORSELF : return ( new AncestorIterator ( ) ) . includeSelf ( ) ; case Axis . ATTRIBUTE : return new AttributeIterator ( ) ; case Axis . DESCENDANT : return new DescendantIterator ( ) ; case Axis . DESCENDANTORSELF : return ( new DescendantIterator ( ) ) . includeSelf ( ) ; case Axis . FOLLOWING : return new FollowingIterator ( ) ; case Axis . PRECEDING : return new PrecedingIterator ( ) ; case Axis . FOLLOWINGSIBLING : return new FollowingSiblingIterator ( ) ; case Axis . PRECEDINGSIBLING : return new PrecedingSiblingIterator ( ) ; case Axis . NAMESPACE : return new NamespaceIterator ( ) ; default : BasisLibrary . runTimeError ( BasisLibrary . AXIS_SUPPORT_ERR , Axis . names [ axis ] ) ; } return null ; } public DTMAxisIterator getTypedAxisIterator ( int axis , int type ) { if ( axis == Axis . CHILD ) { return new TypedChildrenIterator ( type ) ; } if ( type == NO_TYPE ) { return ( EMPTYITERATOR ) ; } switch ( axis ) { case Axis . SELF : return new TypedSingletonIterator ( type ) ; case Axis . CHILD : return new TypedChildrenIterator ( type ) ; case Axis . PARENT : return new ParentIterator ( ) . setNodeType ( type ) ; case Axis . ANCESTOR : return new TypedAncestorIterator ( type ) ; case Axis . ANCESTORORSELF : return ( new TypedAncestorIterator ( type ) ) . includeSelf ( ) ; case Axis . ATTRIBUTE : return new TypedAttributeIterator ( type ) ; case Axis . DESCENDANT : return new TypedDescendantIterator ( type ) ; case Axis . DESCENDANTORSELF : return ( new TypedDescendantIterator ( type ) ) . includeSelf ( ) ; case Axis . FOLLOWING : return new TypedFollowingIterator ( type ) ; case Axis . PRECEDING : return new TypedPrecedingIterator ( type ) ; case Axis . FOLLOWINGSIBLING : return new TypedFollowingSiblingIterator ( type ) ; case Axis . PRECEDINGSIBLING : return new TypedPrecedingSiblingIterator ( type ) ; case Axis . NAMESPACE : return ( type == DTM . ELEMENT_NODE ) ? new NamespaceIterator ( ) : new TypedNamespaceIterator ( type ) ; default : BasisLibrary . runTimeError ( BasisLibrary . TYPED_AXIS_SUPPORT_ERR , Axis . names [ axis ] ) ; } return null ; } public DTMAxisIterator getNamespaceAxisIterator ( int axis , int ns ) { DTMAxisIterator iterator = null ; if ( ns == NO_TYPE ) { return EMPTYITERATOR ; } else { switch ( axis ) { case Axis . CHILD : return new NamespaceChildrenIterator ( ns ) ; case Axis . ATTRIBUTE : return new NamespaceAttributeIterator ( ns ) ; default : BasisLibrary . runTimeError ( BasisLibrary . TYPED_AXIS_SUPPORT_ERR , Axis . names [ axis ] ) ; } } return null ; } public DTMAxisIterator getTypedDescendantIterator ( int type ) { return new TypedDescendantIterator ( type ) ; } public DTMAxisIterator getNthDescendant ( int type , int n , boolean includeself ) { DTMAxisIterator source = ( DTMAxisIterator ) new TypedDescendantIterator ( type ) ; return new NthDescendantIterator ( n ) ; } public void characters ( final int node , SerializationHandler handler ) throws TransletException { if ( node != DTM . NULL ) { try { dispatchCharactersEvents ( node , handler , false ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { int node ; while ( ( node = nodes . next ( ) ) != DTM . NULL ) { copy ( node , handler ) ; } } public void copy ( SerializationHandler handler ) throws TransletException { copy ( getDocument ( ) , handler ) ; } public void copy ( final int node , SerializationHandler handler ) throws TransletException { int nodeID = makeNodeIdentity ( node ) ; int eType = _exptype2 ( nodeID ) ; int type = _exptype2Type ( eType ) ; try { switch ( type ) { case DTM . ROOT_NODE : case DTM . DOCUMENT_NODE : for ( int c = _firstch2 ( nodeID ) ; c != DTM . NULL ; c = _nextsib2 ( c ) ) { copy ( makeNodeHandle ( c ) , handler ) ; } break ; case DTM . PROCESSING_INSTRUCTION_NODE : copyPI ( node , handler ) ; break ; case DTM . COMMENT_NODE : handler . comment ( getStringValueX ( node ) ) ; break ; case DTM . TEXT_NODE : boolean oldEscapeSetting = false ; boolean escapeBit = false ; if ( _dontEscape != null ) { escapeBit = _dontEscape . getBit ( getNodeIdent ( node ) ) ; if ( escapeBit ) { oldEscapeSetting = handler . setEscaping ( false ) ; } } copyTextNode ( nodeID , handler ) ; if ( escapeBit ) { handler . setEscaping ( oldEscapeSetting ) ; } break ; case DTM . ATTRIBUTE_NODE : copyAttribute ( nodeID , eType , handler ) ; break ; case DTM . NAMESPACE_NODE : handler . namespaceAfterStartElement ( getNodeNameX ( node ) , getNodeValue ( node ) ) ; break ; default : if ( type == DTM . ELEMENT_NODE ) { final String name = copyElement ( nodeID , eType , handler ) ; int current = nodeID ; while ( true ) { current ++ ; eType = _exptype2 ( current ) ; type = _exptype2Type ( eType ) ; if ( type == DTM . ATTRIBUTE_NODE ) { copyAttribute ( current , eType , handler ) ; } else if ( type == DTM . NAMESPACE_NODE ) { handler . namespaceAfterStartElement ( getNodeNameX ( makeNodeHandle ( current ) ) , getNodeValue ( makeNodeHandle ( current ) ) ) ; } else break ; } for ( int c = _firstch2 ( nodeID ) ; c != DTM . NULL ; c = _nextsib2 ( c ) ) { copy ( makeNodeHandle ( c ) , handler ) ; } handler . endElement ( name ) ; } else { final String uri = getNamespaceName ( node ) ; if ( uri . length ( ) != 0 ) { final String prefix = getPrefix ( node ) ; handler . namespaceAfterStartElement ( prefix , uri ) ; } handler . addAttribute ( getNodeName ( node ) , getNodeValue ( node ) ) ; } break ; } } catch ( Exception e ) { throw new TransletException ( e ) ; } } private void copyPI ( final int node , SerializationHandler handler ) throws TransletException { final String target = getNodeName ( node ) ; final String value = getStringValueX ( node ) ; try { handler . processingInstruction ( target , value ) ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { int nodeID = makeNodeIdentity ( node ) ; int exptype = _exptype2 ( nodeID ) ; int type = _exptype2Type ( exptype ) ; try { switch ( type ) { case DTM . ELEMENT_NODE : return ( copyElement ( nodeID , exptype , handler ) ) ; case DTM . ROOT_NODE : case DTM . DOCUMENT_NODE : return EMPTYSTRING ; case DTM . TEXT_NODE : copyTextNode ( nodeID , handler ) ; return null ; case DTM . PROCESSING_INSTRUCTION_NODE : copyPI ( node , handler ) ; return null ; case DTM . COMMENT_NODE : handler . comment ( getStringValueX ( node ) ) ; return null ; case DTM . NAMESPACE_NODE : handler . namespaceAfterStartElement ( getNodeNameX ( node ) , getNodeValue ( node ) ) ; return null ; case DTM . ATTRIBUTE_NODE : copyAttribute ( nodeID , exptype , handler ) ; return null ; default : final String uri1 = getNamespaceName ( node ) ; if ( uri1 . length ( ) != 0 ) { final String prefix = getPrefix ( node ) ; handler . namespaceAfterStartElement ( prefix , uri1 ) ; } handler . addAttribute ( getNodeName ( node ) , getNodeValue ( node ) ) ; return null ; } } catch ( Exception e ) { throw new TransletException ( e ) ; } } public String getLanguage ( int node ) { int parent = node ; while ( DTM . NULL != parent ) { if ( DTM . ELEMENT_NODE == getNodeType ( parent ) ) { int langAttr = getAttributeNode ( parent , "http://www.w3.org/XML/1998/namespace" , "lang" ) ; if ( DTM . NULL != langAttr ) { return getNodeValue ( langAttr ) ; } } parent = getParent ( parent ) ; } return ( null ) ; } public DOMBuilder getBuilder ( ) { return this ; } public SerializationHandler getOutputDomBuilder ( ) { return new ToXMLSAXHandler ( this , "UTF-8" ) ; } public DOM getResultTreeFrag ( int initSize , int rtfType ) { if ( rtfType == DOM . SIMPLE_RTF ) { int dtmPos = _dtmManager . getFirstFreeDTMID ( ) ; SimpleResultTreeImpl rtf = new SimpleResultTreeImpl ( _dtmManager , dtmPos << DTMManager . IDENT_DTM_NODE_BITS ) ; _dtmManager . addDTM ( rtf , dtmPos , 0 ) ; return rtf ; } else if ( rtfType == DOM . ADAPTIVE_RTF ) { int dtmPos = _dtmManager . getFirstFreeDTMID ( ) ; AdaptiveResultTreeImpl rtf = new AdaptiveResultTreeImpl ( _dtmManager , dtmPos << DTMManager . IDENT_DTM_NODE_BITS , m_wsfilter , initSize , m_buildIdIndex ) ; _dtmManager . addDTM ( rtf , dtmPos , 0 ) ; return rtf ; } else { return ( SAXImpl ) _dtmManager . getDTM ( null , true , m_wsfilter , true , false , false , initSize , m_buildIdIndex ) ; } } public Hashtable getElementsWithIDs ( ) { if ( m_idAttributes == null ) { return null ; } Enumeration idValues = m_idAttributes . keys ( ) ; if ( ! idValues . hasMoreElements ( ) ) { return null ; } Hashtable idAttrsTable = new Hashtable ( ) ; while ( idValues . hasMoreElements ( ) ) { Object idValue = idValues . nextElement ( ) ; idAttrsTable . put ( idValue , m_idAttributes . get ( idValue ) ) ; } return idAttrsTable ; } public String getUnparsedEntityURI ( String name ) { if ( _document != null ) { String uri = "" ; DocumentType doctype = _document . getDoctype ( ) ; if ( doctype != null ) { NamedNodeMap entities = doctype . getEntities ( ) ; if ( entities == null ) { return uri ; } Entity entity = ( Entity ) entities . getNamedItem ( name ) ; if ( entity == null ) { return uri ; } String notationName = entity . getNotationName ( ) ; if ( notationName != null ) { uri = entity . getSystemId ( ) ; if ( uri == null ) { uri = entity . getPublicId ( ) ; } } } return uri ; } else { return super . getUnparsedEntityURI ( name ) ; } } } 	1	['71', '6', '0', '62', '215', '2365', '16', '51', '63', '0.958128079', '2049', '1', '5', '0.748148148', '0.151428571', '3', '8', '27.45070423', '10', '2', '4']
package org . apache . xml . utils . res ; public class XResources_de extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "de" } , { "help_language" , "de" } , { "language" , "de" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xml . utils . res ; public class XResources_cy extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "cy" } , { "help_language" , "cy" } , { "language" , "cy" } , { "alphabet" , new char [ ] { 0x0430 , 0x0432 , 0x0433 , 0x0434 , 0x0435 , 0x0437 , 0x0438 , 0x0439 , 0x04A9 , 0x0457 , 0x043A , 0x043B , 0x043C , 0x043D , 0x046F , 0x043E , 0x043F , 0x0447 , 0x0440 , 0x0441 , 0x0442 , 0x0443 , 0x0444 , 0x0445 , 0x0470 , 0x0460 , 0x0446 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "precedes" } , { "numberGroups" , new int [ ] { 100 , 10 , 1 } } , { "multiplier" , new long [ ] { 1000 } } , { "multiplierChar" , new char [ ] { 0x03D9 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x0430 , 0x0432 , 0x0433 , 0x0434 , 0x0435 , 0x0437 , 0x0438 , 0x0439 , 0x04A9 } } , { "tens" , new char [ ] { 0x0457 , 0x043A , 0x043B , 0x043C , 0x043D , 0x046F , 0x043E , 0x043F , 0x0447 } } , { "hundreds" , new char [ ] { 0x0440 , 0x0441 , 0x0442 , 0x0443 , 0x0444 , 0x0445 , 0x0470 , 0x0460 , 0x0446 } } , { "tables" , new String [ ] { "hundreds" , "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '583', '0', '0', '0.976190476', '1', '0', '0', '193', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . TreeWalker2Result ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMTreeWalker ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemCopyOf extends ElemTemplateElement { public XPath m_selectExpression = null ; public void setSelect ( XPath expr ) { m_selectExpression = expr ; } public XPath getSelect ( ) { return m_selectExpression ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; m_selectExpression . fixupVariables ( cstate . getVariableNames ( ) , cstate . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_COPY_OF ; } public String getNodeName ( ) { return Constants . ELEMNAME_COPY_OF_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; XObject value = m_selectExpression . execute ( xctxt , sourceNode , this ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , m_selectExpression , value ) ; SerializationHandler handler = transformer . getSerializationHandler ( ) ; if ( null != value ) { int type = value . getType ( ) ; String s ; switch ( type ) { case XObject . CLASS_BOOLEAN : case XObject . CLASS_NUMBER : case XObject . CLASS_STRING : s = value . str ( ) ; handler . characters ( s . toCharArray ( ) , 0 , s . length ( ) ) ; break ; case XObject . CLASS_NODESET : DTMIterator nl = value . iter ( ) ; DTMTreeWalker tw = new TreeWalker2Result ( transformer , handler ) ; int pos ; while ( DTM . NULL != ( pos = nl . nextNode ( ) ) ) { DTM dtm = xctxt . getDTMManager ( ) . getDTM ( pos ) ; short t = dtm . getNodeType ( pos ) ; if ( t == DTM . DOCUMENT_NODE ) { for ( int child = dtm . getFirstChild ( pos ) ; child != DTM . NULL ; child = dtm . getNextSibling ( child ) ) { tw . traverse ( child ) ; } } else if ( t == DTM . ATTRIBUTE_NODE ) { SerializerUtils . addAttribute ( handler , pos ) ; } else { tw . traverse ( pos ) ; } } break ; case XObject . CLASS_RTREEFRAG : SerializerUtils . outputResultTreeFragment ( handler , value , transformer . getXPathContext ( ) ) ; break ; default : s = value . str ( ) ; handler . characters ( s . toCharArray ( ) , 0 , s . length ( ) ) ; break ; } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_selectExpression . getExpression ( ) . callVisitors ( m_selectExpression , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['9', '3', '0', '21', '45', '6', '1', '20', '8', '0.375', '217', '0', '1', '0.960784314', '0.238095238', '2', '6', '23', '2', '1', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class UseAttributeSets extends Instruction { private final static String ATTR_SET_NOT_FOUND = "" ; private final Vector _sets = new Vector ( 2 ) ; public UseAttributeSets ( String setNames , Parser parser ) { setParser ( parser ) ; addAttributeSets ( setNames ) ; } public void addAttributeSets ( String setNames ) { if ( ( setNames != null ) && ( ! setNames . equals ( Constants . EMPTYSTRING ) ) ) { final StringTokenizer tokens = new StringTokenizer ( setNames ) ; while ( tokens . hasMoreTokens ( ) ) { final QName qname = getParser ( ) . getQNameIgnoreDefaultNs ( tokens . nextToken ( ) ) ; _sets . add ( qname ) ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final SymbolTable symbolTable = getParser ( ) . getSymbolTable ( ) ; for ( int i = 0 ; i < _sets . size ( ) ; i ++ ) { final QName name = ( QName ) _sets . elementAt ( i ) ; final AttributeSet attrs = symbolTable . lookupAttributeSet ( name ) ; if ( attrs != null ) { final String methodName = attrs . getMethodName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; final int method = cpg . addMethodref ( classGen . getClassName ( ) , methodName , ATTR_SET_SIG ) ; il . append ( new INVOKESPECIAL ( method ) ) ; } else { final Parser parser = getParser ( ) ; final String atrs = name . toString ( ) ; reportError ( this , parser , ErrorMsg . ATTRIBSET_UNDEF_ERR , atrs ) ; } } } } 	1	['4', '3', '0', '19', '30', '0', '5', '15', '4', '0.833333333', '127', '1', '0', '0.949152542', '0.416666667', '1', '4', '30.25', '4', '2', '1']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; public class Function2Args extends FunctionOneArg { Expression m_arg1 ; public Expression getArg1 ( ) { return m_arg1 ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_arg1 ) m_arg1 . fixupVariables ( vars , globalsSize ) ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( argNum == 0 ) super . setArg ( arg , argNum ) ; else if ( 1 == argNum ) { m_arg1 = arg ; arg . exprSetParent ( this ) ; } else reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 2 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "two" , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return super . canTraverseOutsideSubtree ( ) ? true : m_arg1 . canTraverseOutsideSubtree ( ) ; } class Arg1Owner implements ExpressionOwner { public Expression getExpression ( ) { return m_arg1 ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( Function2Args . this ) ; m_arg1 = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { super . callArgVisitors ( visitor ) ; if ( null != m_arg1 ) m_arg1 . callVisitors ( new Arg1Owner ( ) , visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( null != m_arg1 ) { if ( null == ( ( Function2Args ) expr ) . m_arg1 ) return false ; if ( ! m_arg1 . deepEquals ( ( ( Function2Args ) expr ) . m_arg1 ) ) return false ; } else if ( null != ( ( Function2Args ) expr ) . m_arg1 ) return false ; return true ; } } 	1	['9', '4', '7', '15', '23', '6', '8', '8', '8', '0.375', '123', '0', '1', '0.857142857', '0.355555556', '3', '9', '12.55555556', '6', '1.7778', '1']
package org . apache . xpath . objects ; public class XBoolean extends XObject { public static XBoolean S_TRUE = new XBooleanStatic ( true ) ; public static XBoolean S_FALSE = new XBooleanStatic ( false ) ; boolean m_val ; public XBoolean ( boolean b ) { super ( ) ; m_val = b ; } public XBoolean ( Boolean b ) { super ( ) ; m_val = b . booleanValue ( ) ; m_obj = b ; } public int getType ( ) { return CLASS_BOOLEAN ; } public String getTypeString ( ) { return "#BOOLEAN" ; } public double num ( ) { return m_val ? 1.0 : 0.0 ; } public boolean bool ( ) { return m_val ; } public String str ( ) { return m_val ? "true" : "false" ; } public Object object ( ) { if ( null == m_obj ) m_obj = new Boolean ( m_val ) ; return m_obj ; } public boolean equals ( XObject obj2 ) { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . equals ( this ) ; try { return m_val == obj2 . bool ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } 	1	['10', '3', '1', '27', '18', '3', '25', '3', '9', '0.777777778', '98', '0', '2', '0.91025641', '0.333333333', '2', '22', '8.5', '3', '1.2', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; public class UnionPathIterator extends LocPathIterator implements Cloneable , DTMIterator , java . io . Serializable , PathComponent { public UnionPathIterator ( ) { super ( ) ; m_iterators = null ; m_exprs = null ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; try { if ( null != m_exprs ) { int n = m_exprs . length ; DTMIterator newIters [ ] = new DTMIterator [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { DTMIterator iter = m_exprs [ i ] . asIterator ( m_execContext , context ) ; newIters [ i ] = iter ; iter . nextNode ( ) ; } m_iterators = newIters ; } } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } public void addIterator ( DTMIterator expr ) { if ( null == m_iterators ) { m_iterators = new DTMIterator [ 1 ] ; m_iterators [ 0 ] = expr ; } else { DTMIterator [ ] exprs = m_iterators ; int len = m_iterators . length ; m_iterators = new DTMIterator [ len + 1 ] ; System . arraycopy ( exprs , 0 , m_iterators , 0 , len ) ; m_iterators [ len ] = expr ; } expr . nextNode ( ) ; if ( expr instanceof Expression ) ( ( Expression ) expr ) . exprSetParent ( this ) ; } public void detach ( ) { if ( null != m_iterators ) { int n = m_iterators . length ; for ( int i = 0 ; i < n ; i ++ ) { m_iterators [ i ] . detach ( ) ; } m_iterators = null ; } } public UnionPathIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { super ( ) ; opPos = compiler . getFirstChildPos ( opPos ) ; loadLocationPaths ( compiler , opPos , 0 ) ; } public static LocPathIterator createUnionIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { UnionPathIterator upi = new UnionPathIterator ( compiler , opPos ) ; int nPaths = upi . m_exprs . length ; boolean isAllChildIterators = true ; for ( int i = 0 ; i < nPaths ; i ++ ) { LocPathIterator lpi = upi . m_exprs [ i ] ; if ( lpi . getAxis ( ) != Axis . CHILD ) { isAllChildIterators = false ; break ; } else { if ( HasPositionalPredChecker . check ( lpi ) ) { isAllChildIterators = false ; break ; } } } if ( isAllChildIterators ) { UnionChildIterator uci = new UnionChildIterator ( ) ; for ( int i = 0 ; i < nPaths ; i ++ ) { PredicatedNodeTest lpi = upi . m_exprs [ i ] ; uci . addNodeTest ( lpi ) ; } return uci ; } else return upi ; } public int getAnalysisBits ( ) { int bits = 0 ; if ( m_exprs != null ) { int n = m_exprs . length ; for ( int i = 0 ; i < n ; i ++ ) { int bit = m_exprs [ i ] . getAnalysisBits ( ) ; bits |= bit ; } } return bits ; } private void readObject ( java . io . ObjectInputStream stream ) throws java . io . IOException , javax . xml . transform . TransformerException { try { stream . defaultReadObject ( ) ; m_clones = new IteratorPool ( this ) ; } catch ( ClassNotFoundException cnfe ) { throw new javax . xml . transform . TransformerException ( cnfe ) ; } } public Object clone ( ) throws CloneNotSupportedException { UnionPathIterator clone = ( UnionPathIterator ) super . clone ( ) ; return clone ; } protected LocPathIterator createDTMIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { LocPathIterator lpi = ( LocPathIterator ) WalkerFactory . newDTMIterator ( compiler , opPos , ( compiler . getLocationPathDepth ( ) <= 0 ) ) ; return lpi ; } protected void loadLocationPaths ( Compiler compiler , int opPos , int count ) throws javax . xml . transform . TransformerException { int steptype = compiler . getOp ( opPos ) ; if ( steptype == OpCodes . OP_LOCATIONPATH ) { loadLocationPaths ( compiler , compiler . getNextOpPos ( opPos ) , count + 1 ) ; m_exprs [ count ] = createDTMIterator ( compiler , opPos ) ; m_exprs [ count ] . exprSetParent ( this ) ; } else { switch ( steptype ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : loadLocationPaths ( compiler , compiler . getNextOpPos ( opPos ) , count + 1 ) ; WalkingIterator iter = new WalkingIterator ( compiler . getNamespaceContext ( ) ) ; iter . exprSetParent ( this ) ; if ( compiler . getLocationPathDepth ( ) <= 0 ) iter . setIsTopLevel ( true ) ; iter . m_firstWalker = new org . apache . xpath . axes . FilterExprWalker ( iter ) ; iter . m_firstWalker . init ( compiler , opPos , steptype ) ; m_exprs [ count ] = iter ; break ; default : m_exprs = new LocPathIterator [ count ] ; } } } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int earliestNode = DTM . NULL ; if ( null != m_iterators ) { int n = m_iterators . length ; int iteratorUsed = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int node = m_iterators [ i ] . getCurrentNode ( ) ; if ( DTM . NULL == node ) continue ; else if ( DTM . NULL == earliestNode ) { iteratorUsed = i ; earliestNode = node ; } else { if ( node == earliestNode ) { m_iterators [ i ] . nextNode ( ) ; } else { DTM dtm = getDTM ( node ) ; if ( dtm . isNodeAfter ( node , earliestNode ) ) { iteratorUsed = i ; earliestNode = node ; } } } } if ( DTM . NULL != earliestNode ) { m_iterators [ iteratorUsed ] . nextNode ( ) ; incrementCurrentPos ( ) ; } else m_foundLast = true ; } m_lastFetched = earliestNode ; return earliestNode ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { for ( int i = 0 ; i < m_exprs . length ; i ++ ) { m_exprs [ i ] . fixupVariables ( vars , globalsSize ) ; } } protected LocPathIterator [ ] m_exprs ; protected DTMIterator [ ] m_iterators ; public int getAxis ( ) { return - 1 ; } class iterOwner implements ExpressionOwner { int m_index ; iterOwner ( int index ) { m_index = index ; } public Expression getExpression ( ) { return m_exprs [ m_index ] ; } public void setExpression ( Expression exp ) { if ( ! ( exp instanceof LocPathIterator ) ) { WalkingIterator wi = new WalkingIterator ( getPrefixResolver ( ) ) ; FilterExprWalker few = new FilterExprWalker ( wi ) ; wi . setFirstWalker ( few ) ; few . setInnerExpression ( exp ) ; wi . exprSetParent ( UnionPathIterator . this ) ; few . exprSetParent ( wi ) ; exp . exprSetParent ( few ) ; exp = wi ; } else exp . exprSetParent ( UnionPathIterator . this ) ; m_exprs [ m_index ] = ( LocPathIterator ) exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitUnionPath ( owner , this ) ) { if ( null != m_exprs ) { int n = m_exprs . length ; for ( int i = 0 ; i < n ; i ++ ) { m_exprs [ i ] . callVisitors ( new iterOwner ( i ) , visitor ) ; } } } } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; UnionPathIterator upi = ( UnionPathIterator ) expr ; if ( null != m_exprs ) { int n = m_exprs . length ; if ( ( null == upi . m_exprs ) || ( upi . m_exprs . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_exprs [ i ] . deepEquals ( upi . m_exprs [ i ] ) ) return false ; } } else if ( null != upi . m_exprs ) { return false ; } return true ; } } 	1	['16', '5', '0', '22', '54', '46', '4', '21', '13', '0.6', '560', '1', '2', '0.899280576', '0.2', '2', '13', '33.875', '9', '2.4375', '2']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; public class ExpandedNameTable { private ExtendedType [ ] m_extendedTypes ; private static int m_initialSize = 128 ; private int m_nextType ; public static final int ELEMENT = ( ( int ) DTM . ELEMENT_NODE ) ; public static final int ATTRIBUTE = ( ( int ) DTM . ATTRIBUTE_NODE ) ; public static final int TEXT = ( ( int ) DTM . TEXT_NODE ) ; public static final int CDATA_SECTION = ( ( int ) DTM . CDATA_SECTION_NODE ) ; public static final int ENTITY_REFERENCE = ( ( int ) DTM . ENTITY_REFERENCE_NODE ) ; public static final int ENTITY = ( ( int ) DTM . ENTITY_NODE ) ; public static final int PROCESSING_INSTRUCTION = ( ( int ) DTM . PROCESSING_INSTRUCTION_NODE ) ; public static final int COMMENT = ( ( int ) DTM . COMMENT_NODE ) ; public static final int DOCUMENT = ( ( int ) DTM . DOCUMENT_NODE ) ; public static final int DOCUMENT_TYPE = ( ( int ) DTM . DOCUMENT_TYPE_NODE ) ; public static final int DOCUMENT_FRAGMENT = ( ( int ) DTM . DOCUMENT_FRAGMENT_NODE ) ; public static final int NOTATION = ( ( int ) DTM . NOTATION_NODE ) ; public static final int NAMESPACE = ( ( int ) DTM . NAMESPACE_NODE ) ; ExtendedType hashET = new ExtendedType ( - 1 , "" , "" ) ; private static ExtendedType [ ] m_defaultExtendedTypes ; private static float m_loadFactor = 0.75f ; private static int m_initialCapacity = 203 ; private int m_capacity ; private int m_threshold ; private HashEntry [ ] m_table ; static { m_defaultExtendedTypes = new ExtendedType [ DTM . NTYPES ] ; for ( int i = 0 ; i < DTM . NTYPES ; i ++ ) { m_defaultExtendedTypes [ i ] = new ExtendedType ( i , "" , "" ) ; } } public ExpandedNameTable ( ) { m_capacity = m_initialCapacity ; m_threshold = ( int ) ( m_capacity * m_loadFactor ) ; m_table = new HashEntry [ m_capacity ] ; initExtendedTypes ( ) ; } private void initExtendedTypes ( ) { m_extendedTypes = new ExtendedType [ m_initialSize ] ; for ( int i = 0 ; i < DTM . NTYPES ; i ++ ) { m_extendedTypes [ i ] = m_defaultExtendedTypes [ i ] ; m_table [ i ] = new HashEntry ( m_defaultExtendedTypes [ i ] , i , i , null ) ; } m_nextType = DTM . NTYPES ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { if ( null == namespace ) namespace = "" ; if ( null == localName ) localName = "" ; int hash = type + namespace . hashCode ( ) + localName . hashCode ( ) ; hashET . redefine ( type , namespace , localName , hash ) ; int index = hash % m_capacity ; if ( index < 0 ) index = - index ; for ( HashEntry e = m_table [ index ] ; e != null ; e = e . next ) { if ( e . hash == hash && e . key . equals ( hashET ) ) return e . value ; } if ( m_nextType > m_threshold ) rehash ( ) ; ExtendedType newET = new ExtendedType ( type , namespace , localName , hash ) ; if ( m_extendedTypes . length == m_nextType ) { ExtendedType [ ] newArray = new ExtendedType [ m_extendedTypes . length * 2 ] ; System . arraycopy ( m_extendedTypes , 0 , newArray , 0 , m_extendedTypes . length ) ; m_extendedTypes = newArray ; } m_extendedTypes [ m_nextType ] = newET ; HashEntry entry = new HashEntry ( newET , m_nextType , hash , m_table [ index ] ) ; m_table [ index ] = entry ; return m_nextType ++ ; } private void rehash ( ) { int oldCapacity = m_capacity ; HashEntry [ ] oldTable = m_table ; int newCapacity = 2 * oldCapacity + 1 ; m_capacity = newCapacity ; m_threshold = ( int ) ( newCapacity * m_loadFactor ) ; m_table = new HashEntry [ newCapacity ] ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { for ( HashEntry old = oldTable [ i ] ; old != null ; ) { HashEntry e = old ; old = old . next ; int newIndex = e . hash % newCapacity ; if ( newIndex < 0 ) newIndex = - newIndex ; e . next = m_table [ newIndex ] ; m_table [ newIndex ] = e ; } } } public int getExpandedTypeID ( int type ) { return type ; } public String getLocalName ( int ExpandedNameID ) { return m_extendedTypes [ ExpandedNameID ] . getLocalName ( ) ; } public final int getLocalNameID ( int ExpandedNameID ) { if ( m_extendedTypes [ ExpandedNameID ] . getLocalName ( ) . equals ( "" ) ) return 0 ; else return ExpandedNameID ; } public String getNamespace ( int ExpandedNameID ) { String namespace = m_extendedTypes [ ExpandedNameID ] . getNamespace ( ) ; return ( namespace . equals ( "" ) ? null : namespace ) ; } public final int getNamespaceID ( int ExpandedNameID ) { if ( m_extendedTypes [ ExpandedNameID ] . getNamespace ( ) . equals ( "" ) ) return 0 ; else return ExpandedNameID ; } public final short getType ( int ExpandedNameID ) { return ( short ) m_extendedTypes [ ExpandedNameID ] . getNodeType ( ) ; } public int getSize ( ) { return m_nextType ; } public ExtendedType [ ] getExtendedTypes ( ) { return m_extendedTypes ; } private static final class HashEntry { ExtendedType key ; int value ; int hash ; HashEntry next ; protected HashEntry ( ExtendedType key , int value , int hash , HashEntry next ) { this . key = key ; this . value = value ; this . hash = hash ; this . next = next ; } } } 	1	['13', '1', '0', '23', '25', '2', '21', '2', '10', '0.949275362', '383', '0.391304348', '4', '0', '0.555555556', '0', '0', '26.69230769', '9', '2', '1']
package org . apache . xpath ; public class FoundIndex extends RuntimeException { public FoundIndex ( ) { } } 	1	['1', '4', '0', '0', '2', '0', '0', '0', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . io . FileNotFoundException ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; final class Include extends TopLevelElement { private Stylesheet _included = null ; public Stylesheet getIncludedStylesheet ( ) { return _included ; } public void parseContents ( final Parser parser ) { final Stylesheet context = parser . getCurrentStylesheet ( ) ; String docToLoad = getAttribute ( "href" ) ; try { if ( context . checkForLoop ( docToLoad ) ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CIRCULAR_INCLUDE_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } String currLoadedDoc = context . getSystemId ( ) ; SourceLoader loader = context . getSourceLoader ( ) ; InputSource input = null ; XMLReader reader = null ; if ( loader != null ) { final XSLTC xsltc = parser . getXSLTC ( ) ; input = loader . loadSource ( docToLoad , currLoadedDoc , xsltc ) ; reader = xsltc . getXMLReader ( ) ; } else { if ( ( currLoadedDoc != null ) && ( currLoadedDoc . length ( ) > 0 ) ) { File file = new File ( currLoadedDoc ) ; if ( file . exists ( ) ) { currLoadedDoc = "file:" + file . getCanonicalPath ( ) ; } final URL url = new URL ( new URL ( currLoadedDoc ) , docToLoad ) ; docToLoad = url . toString ( ) ; input = new InputSource ( docToLoad ) ; } else { File file = new File ( System . getProperty ( "user.dir" ) , docToLoad ) ; if ( file . exists ( ) ) { docToLoad = "file:" + file . getCanonicalPath ( ) ; } else { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . FILE_ACCESS_ERR , docToLoad ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } input = new InputSource ( docToLoad ) ; } } if ( input == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . FILE_NOT_FOUND_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } final SyntaxTreeNode root ; if ( reader != null ) { root = parser . parse ( reader , input ) ; } else { root = parser . parse ( input ) ; } if ( root == null ) return ; _included = parser . makeStylesheet ( root ) ; if ( _included == null ) return ; _included . setSourceLoader ( loader ) ; _included . setSystemId ( docToLoad ) ; _included . setParentStylesheet ( context ) ; _included . setIncludingStylesheet ( context ) ; _included . setTemplateInlining ( context . getTemplateInlining ( ) ) ; final int precedence = context . getImportPrecedence ( ) ; _included . setImportPrecedence ( precedence ) ; parser . setCurrentStylesheet ( _included ) ; _included . parseContents ( parser ) ; final Enumeration elements = _included . elements ( ) ; final Stylesheet topStylesheet = parser . getTopLevelStylesheet ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof TopLevelElement ) { if ( element instanceof Variable ) { topStylesheet . addVariable ( ( Variable ) element ) ; } else if ( element instanceof Param ) { topStylesheet . addParam ( ( Param ) element ) ; } else { topStylesheet . addElement ( ( TopLevelElement ) element ) ; } } } } catch ( FileNotFoundException e ) { context . setSystemId ( getAttribute ( "href" ) ) ; final ErrorMsg msg = new ErrorMsg ( ErrorMsg . FILE_NOT_FOUND_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; } catch ( MalformedURLException e ) { context . setSystemId ( getAttribute ( "href" ) ) ; final ErrorMsg msg = new ErrorMsg ( ErrorMsg . FILE_NOT_FOUND_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { parser . setCurrentStylesheet ( context ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	1	['5', '3', '0', '14', '51', '4', '1', '14', '4', '0.5', '332', '1', '1', '0.9375', '0.36', '2', '5', '65.2', '14', '3.4', '2']
package org . apache . xalan . processor ; import java . util . Stack ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Templates ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . sax . TemplatesHandler ; import org . apache . xalan . extensions . ExpressionVisitor ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemForEach ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . NamespaceSupport2 ; import org . apache . xml . utils . NodeConsumer ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xpath . XPath ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . functions . Function ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . helpers . DefaultHandler ; import org . xml . sax . helpers . NamespaceSupport ; public class StylesheetHandler extends DefaultHandler implements TemplatesHandler , PrefixResolver , NodeConsumer { static { Function func = new org . apache . xalan . templates . FuncDocument ( ) ; FunctionTable . installFunction ( "document" , func ) ; func = new org . apache . xalan . templates . FuncFormatNumb ( ) ; FunctionTable . installFunction ( "format-number" , func ) ; } public StylesheetHandler ( TransformerFactoryImpl processor ) throws TransformerConfigurationException { init ( processor ) ; } void init ( TransformerFactoryImpl processor ) { m_stylesheetProcessor = processor ; m_processors . push ( m_schema . getElementProcessor ( ) ) ; this . pushNewNamespaceSupport ( ) ; } public XPath createXPath ( String str , ElemTemplateElement owningTemplate ) throws javax . xml . transform . TransformerException { ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; XPath xpath = new XPath ( str , owningTemplate , this , XPath . SELECT , handler ) ; xpath . callVisitors ( xpath , new ExpressionVisitor ( getStylesheetRoot ( ) ) ) ; return xpath ; } XPath createMatchPatternXPath ( String str , ElemTemplateElement owningTemplate ) throws javax . xml . transform . TransformerException { ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; XPath xpath = new XPath ( str , owningTemplate , this , XPath . MATCH , handler ) ; xpath . callVisitors ( xpath , new ExpressionVisitor ( getStylesheetRoot ( ) ) ) ; return xpath ; } public String getNamespaceForPrefix ( String prefix ) { return this . getNamespaceSupport ( ) . getURI ( prefix ) ; } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) { assertion ( true , "can't process a context node in StylesheetHandler!" ) ; return null ; } private boolean stackContains ( Stack stack , String url ) { int n = stack . size ( ) ; boolean contains = false ; for ( int i = 0 ; i < n ; i ++ ) { String url2 = ( String ) stack . elementAt ( i ) ; if ( url2 . equals ( url ) ) { contains = true ; break ; } } return contains ; } public Templates getTemplates ( ) { return getStylesheetRoot ( ) ; } public void setSystemId ( String baseID ) { pushBaseIndentifier ( baseID ) ; } public String getSystemId ( ) { return this . getBaseIdentifier ( ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws org . xml . sax . SAXException { return getCurrentProcessor ( ) . resolveEntity ( this , publicId , systemId ) ; } public void notationDecl ( String name , String publicId , String systemId ) { getCurrentProcessor ( ) . notationDecl ( this , name , publicId , systemId ) ; } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) { getCurrentProcessor ( ) . unparsedEntityDecl ( this , name , publicId , systemId , notationName ) ; } XSLTElementProcessor getProcessorFor ( String uri , String localName , String rawName ) throws org . xml . sax . SAXException { XSLTElementProcessor currentProcessor = getCurrentProcessor ( ) ; XSLTElementDef def = currentProcessor . getElemDef ( ) ; XSLTElementProcessor elemProcessor = def . getProcessorFor ( uri , localName ) ; if ( null == elemProcessor && ( ( null == getStylesheet ( ) || Double . valueOf ( getStylesheet ( ) . getVersion ( ) ) . doubleValue ( ) > Constants . XSLTVERSUPPORTED ) || ( ! uri . equals ( Constants . S_XSLNAMESPACEURL ) && currentProcessor instanceof ProcessorStylesheetElement ) || getElemVersion ( ) > Constants . XSLTVERSUPPORTED ) ) { elemProcessor = def . getProcessorForUnknown ( uri , localName ) ; } if ( null == elemProcessor ) error ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_ALLOWED_IN_POSITION , new Object [ ] { rawName } ) , null ) ; return elemProcessor ; } public void setDocumentLocator ( Locator locator ) { m_stylesheetLocatorStack . push ( new SAXSourceLocator ( locator ) ) ; } private int m_stylesheetLevel = - 1 ; public void startDocument ( ) throws org . xml . sax . SAXException { m_stylesheetLevel ++ ; pushSpaceHandling ( false ) ; } private boolean m_parsingComplete = false ; public boolean isStylesheetParsingComplete ( ) { return m_parsingComplete ; } public void endDocument ( ) throws org . xml . sax . SAXException { try { if ( null != getStylesheetRoot ( ) ) { if ( 0 == m_stylesheetLevel ) getStylesheetRoot ( ) . recompose ( ) ; } else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEETROOT , null ) ) ; XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; if ( null != elemProcessor ) elemProcessor . startNonText ( this ) ; m_stylesheetLevel -- ; popSpaceHandling ( ) ; m_parsingComplete = ( m_stylesheetLevel < 0 ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } private java . util . Vector m_prefixMappings = new java . util . Vector ( ) ; public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { m_prefixMappings . addElement ( prefix ) ; m_prefixMappings . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } private void flushCharacters ( ) throws org . xml . sax . SAXException { XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; if ( null != elemProcessor ) elemProcessor . startNonText ( this ) ; } public void startElement ( String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { NamespaceSupport nssupport = this . getNamespaceSupport ( ) ; nssupport . pushContext ( ) ; int n = m_prefixMappings . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String prefix = ( String ) m_prefixMappings . elementAt ( i ++ ) ; String nsURI = ( String ) m_prefixMappings . elementAt ( i ) ; nssupport . declarePrefix ( prefix , nsURI ) ; } m_prefixMappings . removeAllElements ( ) ; m_elementID ++ ; checkForFragmentID ( attributes ) ; if ( ! m_shouldProcess ) return ; flushCharacters ( ) ; pushSpaceHandling ( attributes ) ; XSLTElementProcessor elemProcessor = getProcessorFor ( uri , localName , rawName ) ; if ( null != elemProcessor ) { this . pushProcessor ( elemProcessor ) ; elemProcessor . startElement ( this , uri , localName , rawName , attributes ) ; } else { m_shouldProcess = false ; popSpaceHandling ( ) ; } } public void endElement ( String uri , String localName , String rawName ) throws org . xml . sax . SAXException { m_elementID -- ; if ( ! m_shouldProcess ) return ; if ( ( m_elementID + 1 ) == m_fragmentID ) m_shouldProcess = false ; flushCharacters ( ) ; popSpaceHandling ( ) ; XSLTElementProcessor p = getCurrentProcessor ( ) ; p . endElement ( this , uri , localName , rawName ) ; this . popProcessor ( ) ; this . getNamespaceSupport ( ) . popContext ( ) ; } public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; XSLTElementDef def = elemProcessor . getElemDef ( ) ; if ( def . getType ( ) != XSLTElementDef . T_PCDATA ) elemProcessor = def . getProcessorFor ( null , "text()" ) ; if ( null == elemProcessor ) { if ( ! XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) error ( XSLMessages . createMessage ( XSLTErrorResources . ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , null ) , null ) ; } else elemProcessor . characters ( this , ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; getCurrentProcessor ( ) . ignorableWhitespace ( this , ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; String prefix = "" , ns = "" , localName = target ; int colon = target . indexOf ( ':' ) ; if ( colon >= 0 ) { ns = getNamespaceForPrefix ( prefix = target . substring ( 0 , colon ) ) ; localName = target . substring ( colon + 1 ) ; } try { if ( "xalan:doc-cache-off" . equals ( target ) || ( "doc-cache-off" . equals ( localName ) && ns . equals ( "org.apache.xalan.xslt.extensions.Redirect" ) ) ) { if ( ! ( m_elems . peek ( ) instanceof ElemForEach ) ) throw new TransformerException ( "xalan:doc-cache-off not allowed here!" , getLocator ( ) ) ; ElemForEach elem = ( ElemForEach ) m_elems . peek ( ) ; elem . m_doc_cache_off = true ; } } catch ( Exception e ) { } flushCharacters ( ) ; getCurrentProcessor ( ) . processingInstruction ( this , target , data ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; getCurrentProcessor ( ) . skippedEntity ( this , name ) ; } public void warn ( String msg , Object args [ ] ) throws org . xml . sax . SAXException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { if ( null != handler ) handler . warning ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } private void assertion ( boolean condition , String msg ) throws RuntimeException { if ( ! condition ) throw new RuntimeException ( msg ) ; } protected void error ( String msg , Exception e ) throws org . xml . sax . SAXException { SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; TransformerException pe ; if ( ! ( e instanceof TransformerException ) ) { pe = ( null == e ) ? new TransformerException ( msg , locator ) : new TransformerException ( msg , locator , e ) ; } else pe = ( TransformerException ) e ; if ( null != handler ) { try { handler . error ( pe ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else throw new org . xml . sax . SAXException ( pe ) ; } protected void error ( String msg , Object args [ ] , Exception e ) throws org . xml . sax . SAXException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; error ( formattedMsg , e ) ; } public void warning ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . warning ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void error ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . error ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void fatalError ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . fatalError ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } private boolean m_shouldProcess = true ; private String m_fragmentIDString ; private int m_elementID = 0 ; private int m_fragmentID = 0 ; private void checkForFragmentID ( Attributes attributes ) { if ( ! m_shouldProcess ) { if ( ( null != attributes ) && ( null != m_fragmentIDString ) ) { int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String name = attributes . getQName ( i ) ; if ( name . equals ( Constants . ATTRNAME_ID ) ) { String val = attributes . getValue ( i ) ; if ( val . equalsIgnoreCase ( m_fragmentIDString ) ) { m_shouldProcess = true ; m_fragmentID = m_elementID ; } } } } } } private TransformerFactoryImpl m_stylesheetProcessor ; TransformerFactoryImpl getStylesheetProcessor ( ) { return m_stylesheetProcessor ; } static final int STYPE_ROOT = 1 ; static final int STYPE_INCLUDE = 2 ; static final int STYPE_IMPORT = 3 ; private int m_stylesheetType = STYPE_ROOT ; int getStylesheetType ( ) { return m_stylesheetType ; } void setStylesheetType ( int type ) { m_stylesheetType = type ; } private Stack m_stylesheets = new Stack ( ) ; Stylesheet getStylesheet ( ) { return ( m_stylesheets . size ( ) == 0 ) ? null : ( Stylesheet ) m_stylesheets . peek ( ) ; } Stylesheet getLastPoppedStylesheet ( ) { return m_lastPoppedStylesheet ; } public StylesheetRoot getStylesheetRoot ( ) { return m_stylesheetRoot ; } StylesheetRoot m_stylesheetRoot ; Stylesheet m_lastPoppedStylesheet ; public void pushStylesheet ( Stylesheet s ) { if ( m_stylesheets . size ( ) == 0 ) m_stylesheetRoot = ( StylesheetRoot ) s ; m_stylesheets . push ( s ) ; } Stylesheet popStylesheet ( ) { if ( ! m_stylesheetLocatorStack . isEmpty ( ) ) m_stylesheetLocatorStack . pop ( ) ; if ( ! m_stylesheets . isEmpty ( ) ) m_lastPoppedStylesheet = ( Stylesheet ) m_stylesheets . pop ( ) ; return m_lastPoppedStylesheet ; } private Stack m_processors = new Stack ( ) ; XSLTElementProcessor getCurrentProcessor ( ) { return ( XSLTElementProcessor ) m_processors . peek ( ) ; } void pushProcessor ( XSLTElementProcessor processor ) { m_processors . push ( processor ) ; } XSLTElementProcessor popProcessor ( ) { return ( XSLTElementProcessor ) m_processors . pop ( ) ; } private XSLTSchema m_schema = new XSLTSchema ( ) ; XSLTSchema getSchema ( ) { return m_schema ; } private Stack m_elems = new Stack ( ) ; ElemTemplateElement getElemTemplateElement ( ) { try { return ( ElemTemplateElement ) m_elems . peek ( ) ; } catch ( java . util . EmptyStackException ese ) { return null ; } } private int m_docOrderCount = 0 ; int nextUid ( ) { return m_docOrderCount ++ ; } void pushElemTemplateElement ( ElemTemplateElement elem ) { if ( elem . getUid ( ) == - 1 ) elem . setUid ( nextUid ( ) ) ; m_elems . push ( elem ) ; } ElemTemplateElement popElemTemplateElement ( ) { return ( ElemTemplateElement ) m_elems . pop ( ) ; } Stack m_baseIdentifiers = new Stack ( ) ; void pushBaseIndentifier ( String baseID ) { if ( null != baseID ) { int posOfHash = baseID . indexOf ( '#' ) ; if ( posOfHash > - 1 ) { m_fragmentIDString = baseID . substring ( posOfHash + 1 ) ; m_shouldProcess = false ; } else m_shouldProcess = true ; } else m_shouldProcess = true ; m_baseIdentifiers . push ( baseID ) ; } String popBaseIndentifier ( ) { return ( String ) m_baseIdentifiers . pop ( ) ; } public String getBaseIdentifier ( ) { String base = ( String ) ( m_baseIdentifiers . isEmpty ( ) ? null : m_baseIdentifiers . peek ( ) ) ; if ( null == base ) { SourceLocator locator = getLocator ( ) ; base = ( null == locator ) ? "" : locator . getSystemId ( ) ; } return base ; } private Stack m_stylesheetLocatorStack = new Stack ( ) ; public SAXSourceLocator getLocator ( ) { if ( m_stylesheetLocatorStack . isEmpty ( ) ) { SAXSourceLocator locator = new SAXSourceLocator ( ) ; locator . setSystemId ( this . getStylesheetProcessor ( ) . getDOMsystemID ( ) ) ; return locator ; } return ( ( SAXSourceLocator ) m_stylesheetLocatorStack . peek ( ) ) ; } private Stack m_importStack = new Stack ( ) ; void pushImportURL ( String hrefUrl ) { m_importStack . push ( hrefUrl ) ; } boolean importStackContains ( String hrefUrl ) { return stackContains ( m_importStack , hrefUrl ) ; } String popImportURL ( ) { return ( String ) m_importStack . pop ( ) ; } private boolean warnedAboutOldXSLTNamespace = false ; Stack m_nsSupportStack = new Stack ( ) ; void pushNewNamespaceSupport ( ) { m_nsSupportStack . push ( new NamespaceSupport2 ( ) ) ; } void popNamespaceSupport ( ) { m_nsSupportStack . pop ( ) ; } NamespaceSupport getNamespaceSupport ( ) { return ( NamespaceSupport ) m_nsSupportStack . peek ( ) ; } private Node m_originatingNode ; public void setOriginatingNode ( Node n ) { m_originatingNode = n ; } public Node getOriginatingNode ( ) { return m_originatingNode ; } private BoolStack m_spacePreserveStack = new BoolStack ( ) ; boolean isSpacePreserve ( ) { return m_spacePreserveStack . peek ( ) ; } void popSpaceHandling ( ) { m_spacePreserveStack . pop ( ) ; } void pushSpaceHandling ( boolean b ) throws org . xml . sax . SAXParseException { m_spacePreserveStack . push ( b ) ; } void pushSpaceHandling ( Attributes attrs ) throws org . xml . sax . SAXParseException { String value = attrs . getValue ( "xml:space" ) ; if ( null == value ) { m_spacePreserveStack . push ( m_spacePreserveStack . peekOrFalse ( ) ) ; } else if ( value . equals ( "preserve" ) ) { m_spacePreserveStack . push ( true ) ; } else if ( value . equals ( "default" ) ) { m_spacePreserveStack . push ( false ) ; } else { SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . error ( new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_XMLSPACE_VALUE , null ) , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXParseException ( te . getMessage ( ) , locator , te ) ; } m_spacePreserveStack . push ( m_spacePreserveStack . peek ( ) ) ; } } private double getElemVersion ( ) { ElemTemplateElement elem = getElemTemplateElement ( ) ; double version = - 1 ; while ( ( version == - 1 || version == Constants . XSLTVERSUPPORTED ) && elem != null ) { try { version = Double . valueOf ( elem . getVersion ( ) ) . doubleValue ( ) ; } catch ( Exception ex ) { version = - 1 ; } elem = elem . getParentElem ( ) ; } return ( version == - 1 ) ? Constants . XSLTVERSUPPORTED : version ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1	['70', '2', '0', '46', '152', '2107', '25', '24', '33', '0.93812709', '1315', '0.730769231', '5', '0.2', '0.108695652', '1', '1', '17.41428571', '7', '1.3', '4']
package org . apache . xalan . xsltc . dom ; import java . io . File ; import java . io . PrintWriter ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLDecoder ; import java . util . Date ; import java . util . Hashtable ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . sax . SAXSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . Constants ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public final class DocumentCache implements DOMCache { private int _size ; private Hashtable _references ; private String [ ] _URIs ; private int _count ; private int _current ; private SAXParser _parser ; private XMLReader _reader ; private XSLTCDTMManager _dtmManager ; private static final int REFRESH_INTERVAL = 1000 ; public final class CachedDocument { private long _firstReferenced ; private long _lastReferenced ; private long _accessCount ; private long _lastModified ; private long _lastChecked ; private long _buildTime ; private SAXImpl _dom = null ; public CachedDocument ( String uri ) { final long stamp = System . currentTimeMillis ( ) ; _firstReferenced = stamp ; _lastReferenced = stamp ; _accessCount = 0 ; loadDocument ( uri ) ; _buildTime = System . currentTimeMillis ( ) - stamp ; } public void loadDocument ( String uri ) { try { final long stamp = System . currentTimeMillis ( ) ; _dom = ( SAXImpl ) _dtmManager . getDTM ( new SAXSource ( _reader , new InputSource ( uri ) ) , false , null , true , false ) ; _dom . setDocumentURI ( uri ) ; final long thisTime = System . currentTimeMillis ( ) - stamp ; if ( _buildTime > 0 ) _buildTime = ( _buildTime + thisTime ) > > > 1 ; else _buildTime = thisTime ; } catch ( Exception e ) { _dom = null ; } } public DOM getDocument ( ) { return ( _dom ) ; } public long getFirstReferenced ( ) { return ( _firstReferenced ) ; } public long getLastReferenced ( ) { return ( _lastReferenced ) ; } public long getAccessCount ( ) { return ( _accessCount ) ; } public void incAccessCount ( ) { _accessCount ++ ; } public long getLastModified ( ) { return ( _lastModified ) ; } public void setLastModified ( long t ) { _lastModified = t ; } public long getLatency ( ) { return ( _buildTime ) ; } public long getLastChecked ( ) { return ( _lastChecked ) ; } public void setLastChecked ( long t ) { _lastChecked = t ; } public long getEstimatedSize ( ) { if ( _dom != null ) return ( _dom . getSize ( ) << 5 ) ; else return ( 0 ) ; } } public DocumentCache ( int size ) throws SAXException { this ( size , null ) ; _dtmManager = XSLTCDTMManager . newInstance ( ) ; } public DocumentCache ( int size , XSLTCDTMManager dtmManager ) throws SAXException { _dtmManager = dtmManager ; _count = 0 ; _current = 0 ; _size = size ; _references = new Hashtable ( _size + 2 ) ; _URIs = new String [ _size ] ; try { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { factory . setFeature ( Constants . NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { factory . setNamespaceAware ( true ) ; } _parser = factory . newSAXParser ( ) ; _reader = _parser . getXMLReader ( ) ; } catch ( ParserConfigurationException e ) { BasisLibrary . runTimeError ( BasisLibrary . NAMESPACES_SUPPORT_ERR ) ; System . exit ( - 1 ) ; } } private final long getLastModified ( String uri ) { try { URL url = new URL ( uri ) ; URLConnection connection = url . openConnection ( ) ; long timestamp = connection . getLastModified ( ) ; if ( timestamp == 0 ) { if ( "file" . equals ( url . getProtocol ( ) ) ) { File localfile = new File ( URLDecoder . decode ( url . getFile ( ) ) ) ; timestamp = localfile . lastModified ( ) ; } } return ( timestamp ) ; } catch ( Exception e ) { return ( System . currentTimeMillis ( ) ) ; } } private CachedDocument lookupDocument ( String uri ) { return ( ( CachedDocument ) _references . get ( uri ) ) ; } private synchronized void insertDocument ( String uri , CachedDocument doc ) { if ( _count < _size ) { _URIs [ _count ++ ] = uri ; _current = 0 ; } else { _references . remove ( _URIs [ _current ] ) ; _URIs [ _current ] = uri ; if ( ++ _current >= _size ) _current = 0 ; } _references . put ( uri , doc ) ; } private synchronized void replaceDocument ( String uri , CachedDocument doc ) { CachedDocument old = ( CachedDocument ) _references . get ( uri ) ; if ( doc == null ) insertDocument ( uri , doc ) ; else _references . put ( uri , doc ) ; } public final DOM retrieveDocument ( String uri , int mask , Translet trs ) { CachedDocument doc ; if ( ( doc = lookupDocument ( uri ) ) == null ) { doc = new CachedDocument ( uri ) ; if ( doc == null ) return null ; doc . setLastModified ( getLastModified ( uri ) ) ; insertDocument ( uri , doc ) ; } else { long now = System . currentTimeMillis ( ) ; long chk = doc . getLastChecked ( ) ; doc . setLastChecked ( now ) ; if ( now > ( chk + REFRESH_INTERVAL ) ) { doc . setLastChecked ( now ) ; long last = getLastModified ( uri ) ; if ( last > doc . getLastModified ( ) ) { doc = new CachedDocument ( uri ) ; if ( doc == null ) return null ; doc . setLastModified ( getLastModified ( uri ) ) ; replaceDocument ( uri , doc ) ; } } } final DOM dom = doc . getDocument ( ) ; if ( dom == null ) return null ; doc . incAccessCount ( ) ; final AbstractTranslet translet = ( AbstractTranslet ) trs ; translet . prepassDocument ( dom ) ; return ( doc . getDocument ( ) ) ; } public void getStatistics ( PrintWriter out ) { out . println ( "<h2>DOM cache statistics</h2><center><table border=\"2\">" + "<tr><td><b>Document URI</b></td>" + "<td><center><b>Build time</b></center></td>" + "<td><center><b>Access count</b></center></td>" + "<td><center><b>Last accessed</b></center></td>" + "<td><center><b>Last modified</b></center></td></tr>" ) ; for ( int i = 0 ; i < _count ; i ++ ) { CachedDocument doc = ( CachedDocument ) _references . get ( _URIs [ i ] ) ; out . print ( "<tr><td><a href=\"" + _URIs [ i ] + "\">" + "<font size=-1>" + _URIs [ i ] + "</font></a></td>" ) ; out . print ( "<td><center>" + doc . getLatency ( ) + "ms</center></td>" ) ; out . print ( "<td><center>" + doc . getAccessCount ( ) + "</center></td>" ) ; out . print ( "<td><center>" + ( new Date ( doc . getLastReferenced ( ) ) ) + "</center></td>" ) ; out . print ( "<td><center>" + ( new Date ( doc . getLastModified ( ) ) ) + "</center></td>" ) ; out . println ( "</tr>" ) ; } out . println ( "</table></center>" ) ; } } 	1	['10', '1', '0', '7', '52', '17', '1', '7', '4', '0.654320988', '402', '1', '1', '0', '0.2875', '0', '0', '38.3', '7', '2', '1']
package org . apache . xalan . lib . sql ; public class QueryParameter { private String value ; private String type ; public QueryParameter ( String v , String t ) { value = v ; type = t ; } public String getValue ( ) { return value ; } public void setValue ( String newValue ) { value = newValue ; } public void setType ( String newType ) { type = newType ; } public String getType ( ) { return type ; } } 	1	['5', '1', '0', '1', '6', '0', '1', '0', '5', '0.5', '30', '1', '0', '0', '0.8', '0', '0', '4.6', '1', '0.8', '1']
package org . apache . xml . utils . res ; public class XResources_ja_JP_A extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x30a2 , 0x30a4 , 0x30a6 , 0x30a8 , 0x30aa , 0x30ab , 0x30ad , 0x30af , 0x30b1 , 0x30b3 , 0x30b5 , 0x30b7 , 0x30b9 , 0x30bb , 0x30bd , 0x30bf , 0x30c1 , 0x30c4 , 0x30c6 , 0x30c8 , 0x30ca , 0x30cb , 0x30cc , 0x30cd , 0x30ce , 0x30cf , 0x30d2 , 0x30d5 , 0x30d8 , 0x30db , 0x30de , 0x30df , 0x30e0 , 0x30e1 , 0x30e2 , 0x30e4 , 0x30e6 , 0x30e8 , 0x30e9 , 0x30ea , 0x30eb , 0x30ec , 0x30ed , 0x30ef , 0x30f0 , 0x30f1 , 0x30f2 , 0x30f3 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '599', '0', '0', '0.976190476', '1', '0', '0', '198.3333333', '1', '0.3333', '1']
package org . apache . xml . utils . res ; public class XResources_hy extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "hy" } , { "help_language" , "hy" } , { "language" , "hy" } , { "alphabet" , new char [ ] { 0x0561 , 0x0562 , 0x0563 , 0x0564 , 0x0565 , 0x0566 , 0x0567 , 0x0568 , 0x0569 , 0x056A , 0x056B , 0x056C , 0x056D , 0x056E , 0x056F , 0x0567 , 0x0568 , 0x0572 , 0x0573 , 0x0574 , 0x0575 , 0x0576 , 0x0577 , 0x0578 , 0x0579 , 0x057A , 0x057B , 0x057C , 0x057D , 0x057E , 0x057F , 0x0580 , 0x0581 , 0x0582 , 0x0583 , 0x0584 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , { "numberGroups" , new int [ ] { 1000 , 100 , 10 , 1 } } , { "digits" , new char [ ] { 0x0561 , 0x0562 , 0x0563 , 0x0564 , 0x0565 , 0x0566 , 0x0567 , 0x0568 , 0x0569 } } , { "tens" , new char [ ] { 0x056A , 0x056B , 0x056C , 0x056D , 0x056E , 0x056F , 0x0567 , 0x0568 , 0x0572 } } , { "hundreds" , new char [ ] { 0x0573 , 0x0574 , 0x0575 , 0x0576 , 0x0577 , 0x0578 , 0x0579 , 0x057A , 0x057B } } , { "thousands" , new char [ ] { 0x057C , 0x057D , 0x057E , 0x057F , 0x0580 , 0x0581 , 0x0582 , 0x0583 , 0x0584 } } , { "tables" , new String [ ] { "thousands" , "hundreds" , "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '614', '0', '0', '0.976190476', '1', '0', '0', '203.3333333', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . Expression ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . xml . sax . SAXException ; public class ElemValueOf extends ElemTemplateElement { private XPath m_selectExpression = null ; private boolean m_isDot = false ; public void setSelect ( XPath v ) { if ( null != v ) { String s = v . getPatternString ( ) ; m_isDot = ( null != s ) && s . equals ( "." ) ; } m_selectExpression = v ; } public XPath getSelect ( ) { return m_selectExpression ; } private boolean m_disableOutputEscaping = false ; public void setDisableOutputEscaping ( boolean v ) { m_disableOutputEscaping = v ; } public boolean getDisableOutputEscaping ( ) { return m_disableOutputEscaping ; } public int getXSLToken ( ) { return Constants . ELEMNAME_VALUEOF ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_selectExpression ) m_selectExpression . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_VALUEOF_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; SerializationHandler rth = transformer . getResultTreeHandler ( ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { if ( false && m_isDot && ! TransformerImpl . S_DEBUG ) { int child = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( child ) ; xctxt . pushCurrentNode ( child ) ; if ( m_disableOutputEscaping ) rth . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; try { dtm . dispatchCharactersEvents ( child , rth , false ) ; } finally { if ( m_disableOutputEscaping ) rth . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; xctxt . popCurrentNode ( ) ; } } else { xctxt . pushNamespaceContext ( this ) ; int current = xctxt . getCurrentNode ( ) ; xctxt . pushCurrentNodeAndExpression ( current , current ) ; if ( m_disableOutputEscaping ) rth . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; try { Expression expr = m_selectExpression . getExpression ( ) ; if ( TransformerImpl . S_DEBUG ) { XObject obj = expr . execute ( xctxt ) ; transformer . getTraceManager ( ) . fireSelectedEvent ( current , this , "select" , m_selectExpression , obj ) ; obj . dispatchCharactersEvents ( rth ) ; } else { expr . executeCharsToContentHandler ( xctxt , rth ) ; } } finally { if ( m_disableOutputEscaping ) rth . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } catch ( RuntimeException re ) { TransformerException te = new TransformerException ( re ) ; te . setLocator ( this ) ; throw te ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_selectExpression . getExpression ( ) . callVisitors ( m_selectExpression , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['11', '3', '0', '16', '41', '15', '3', '14', '10', '0.7', '228', '1', '1', '0.951456311', '0.233766234', '2', '6', '19.45454545', '4', '1.2727', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . patterns . NodeTest ; public class UnionChildIterator extends ChildTestIterator { private PredicatedNodeTest [ ] m_nodeTests = null ; public UnionChildIterator ( ) { super ( null ) ; } public void addNodeTest ( PredicatedNodeTest test ) { if ( null == m_nodeTests ) { m_nodeTests = new PredicatedNodeTest [ 1 ] ; m_nodeTests [ 0 ] = test ; } else { PredicatedNodeTest [ ] tests = m_nodeTests ; int len = m_nodeTests . length ; m_nodeTests = new PredicatedNodeTest [ len + 1 ] ; System . arraycopy ( tests , 0 , m_nodeTests , 0 , len ) ; m_nodeTests [ len ] = test ; } test . exprSetParent ( this ) ; } public short acceptNode ( int n ) { XPathContext xctxt = getXPathContext ( ) ; try { xctxt . pushCurrentNode ( n ) ; for ( int i = 0 ; i < m_nodeTests . length ; i ++ ) { PredicatedNodeTest pnt = m_nodeTests [ i ] ; XObject score = pnt . execute ( xctxt , n ) ; if ( score != NodeTest . SCORE_NONE ) { if ( pnt . getPredicateCount ( ) > 0 ) { if ( pnt . executePredicates ( n , xctxt ) ) return DTMIterator . FILTER_ACCEPT ; } else return DTMIterator . FILTER_ACCEPT ; } } } catch ( javax . xml . transform . TransformerException se ) { throw new RuntimeException ( se . getMessage ( ) ) ; } finally { xctxt . popCurrentNode ( ) ; } return DTMIterator . FILTER_SKIP ; } } 	1	['3', '7', '0', '9', '14', '0', '1', '8', '3', '0', '119', '1', '0', '0.985185185', '0.555555556', '3', '3', '38.33333333', '5', '2.3333', '1']
package org . apache . xpath . functions ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNull ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class FuncExtFunction extends Function { String m_namespace ; String m_extensionName ; Object m_methodKey ; Vector m_argVec = new Vector ( ) ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { if ( null != m_argVec ) { int nArgs = m_argVec . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; arg . fixupVariables ( vars , globalsSize ) ; } } } public String getNamespace ( ) { return m_namespace ; } public String getFunctionName ( ) { return m_extensionName ; } public Object getMethodKey ( ) { return m_methodKey ; } public Expression getArg ( int n ) { if ( n >= 0 && n < m_argVec . size ( ) ) return ( Expression ) m_argVec . elementAt ( n ) ; else return null ; } public int getArgCount ( ) { return m_argVec . size ( ) ; } public FuncExtFunction ( java . lang . String namespace , java . lang . String extensionName , Object methodKey ) { m_namespace = namespace ; m_extensionName = extensionName ; m_methodKey = methodKey ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject result ; Vector argVec = new Vector ( ) ; int nArgs = m_argVec . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; XObject xobj = arg . execute ( xctxt ) ; argVec . addElement ( xobj ) ; } ExtensionsProvider extProvider = ( ExtensionsProvider ) xctxt . getOwnerObject ( ) ; Object val = extProvider . extFunction ( this , argVec ) ; if ( null != val ) { result = XObject . create ( val , xctxt ) ; } else { result = new XNull ( ) ; } return result ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { m_argVec . addElement ( arg ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { } class ArgExtOwner implements ExpressionOwner { Expression m_exp ; ArgExtOwner ( Expression exp ) { m_exp = exp ; } public Expression getExpression ( ) { return m_exp ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FuncExtFunction . this ) ; m_exp = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { for ( int i = 0 ; i < m_argVec . size ( ) ; i ++ ) { Expression exp = ( Expression ) m_argVec . elementAt ( i ) ; exp . callVisitors ( new ArgExtOwner ( exp ) , visitor ) ; } } public void exprSetParent ( ExpressionNode n ) { super . exprSetParent ( n ) ; int nArgs = m_argVec . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; arg . exprSetParent ( n ) ; } } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { "Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called." } ) ; throw new RuntimeException ( fMsg ) ; } } 	1	['13', '3', '0', '22', '30', '16', '12', '12', '12', '0.791666667', '207', '0', '0', '0.76', '0.205128205', '2', '9', '14.61538462', '3', '1.3846', '2']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . xml . sax . ContentHandler ; public class FuncNormalizeSpace extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XMLString s1 = getArg0AsString ( xctxt ) ; return ( XString ) s1 . fixWhiteSpace ( true , true , false ) ; } public void executeCharsToContentHandler ( XPathContext xctxt , ContentHandler handler ) throws javax . xml . transform . TransformerException , org . xml . sax . SAXException { if ( Arg0IsNodesetExpr ( ) ) { int node = getArg0AsNode ( xctxt ) ; if ( DTM . NULL != node ) { DTM dtm = xctxt . getDTM ( node ) ; dtm . dispatchCharactersEvents ( node , handler , true ) ; } } else { XObject obj = execute ( xctxt ) ; obj . dispatchCharactersEvents ( handler ) ; } } } 	1	['3', '5', '0', '6', '11', '3', '0', '6', '3', '2', '45', '0', '0', '0.964912281', '0.666666667', '2', '7', '14', '1', '0.6667', '1']
package org . apache . xalan . templates ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; public class KeyDeclaration extends ElemTemplateElement { public KeyDeclaration ( Stylesheet parentNode , int docOrderNumber ) { m_parentNode = parentNode ; setUid ( docOrderNumber ) ; } private QName m_name ; public void setName ( QName name ) { m_name = name ; } public QName getName ( ) { return m_name ; } private XPath m_matchPattern = null ; public void setMatch ( XPath v ) { m_matchPattern = v ; } public XPath getMatch ( ) { return m_matchPattern ; } private XPath m_use ; public void setUse ( XPath v ) { m_use = v ; } public XPath getUse ( ) { return m_use ; } public void compose ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_matchPattern ) m_matchPattern . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; if ( null != m_use ) m_use . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeKeys ( this ) ; } } 	1	['9', '3', '0', '11', '17', '16', '7', '6', '9', '0.75', '79', '1', '3', '0.960784314', '0.296296296', '1', '2', '7.444444444', '1', '0.8889', '2']
package org . apache . xml . utils . res ; public class XResources_zh_CN extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "alphabet" , new char [ ] { 0xff21 , 0xff22 , 0xff23 , 0xff24 , 0xff25 , 0xff26 , 0xff27 , 0xff28 , 0xff29 , 0xff2a , 0xff2b , 0xff2c , 0xff2d , 0xff2e , 0xff2f , 0xff30 , 0xff31 , 0xff32 , 0xff33 , 0xff34 , 0xff35 , 0xff36 , 0xff37 , 0xff38 , 0xff39 , 0xff3a } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "zero" , new char [ ] { 0x96f6 } } , { "multiplier" , new long [ ] { 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4ebf , 0x4e07 , 0x5343 , 0x767e , 0x5341 } } , { "digits" , new char [ ] { 0x4e00 , 0x4e8c , 0x4e09 , 0x56db , 0x4e94 , 0x516d , 0x4e03 , 0x516b , 0x4e5d } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '499', '0', '0', '0.976190476', '1', '0', '0', '165', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; public class ElemApplyImport extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_APPLY_IMPORTS ; } public String getNodeName ( ) { return Constants . ELEMNAME_APPLY_IMPORTS_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( transformer . currentTemplateRuleIsNull ( ) ) { transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_NO_APPLY_IMPORT_IN_FOR_EACH ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; if ( DTM . NULL != sourceNode ) { transformer . applyTemplateToNode ( this , null , sourceNode ) ; } else { transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_NULL_SOURCENODE_APPLYIMPORTS ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } } 	1	['5', '3', '0', '7', '17', '10', '1', '6', '5', '2', '69', '0', '0', '0.98', '0.466666667', '2', '6', '12.8', '1', '0.8', '1']
package org . apache . xpath ; import java . lang . reflect . Method ; import java . util . Stack ; import java . util . Vector ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . sax2dtm . SAX2RTFDTM ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . ObjectStack ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; import org . xml . sax . XMLReader ; public class XPathContext extends DTMManager { IntStack m_last_pushed_rtfdtm = new IntStack ( ) ; private Vector m_rtfdtm_stack = null ; private int m_which_rtfdtm = - 1 ; private SAX2RTFDTM m_global_rtfdtm = null ; protected DTMManager m_dtmManager = DTMManager . newInstance ( org . apache . xpath . objects . XMLStringFactoryImpl . getFactory ( ) ) ; public DTMManager getDTMManager ( ) { return m_dtmManager ; } public DTM getDTM ( javax . xml . transform . Source source , boolean unique , DTMWSFilter wsfilter , boolean incremental , boolean doIndexing ) { return m_dtmManager . getDTM ( source , unique , wsfilter , incremental , doIndexing ) ; } public DTM getDTM ( int nodeHandle ) { return m_dtmManager . getDTM ( nodeHandle ) ; } public int getDTMHandleFromNode ( org . w3c . dom . Node node ) { return m_dtmManager . getDTMHandleFromNode ( node ) ; } public int getDTMIdentity ( DTM dtm ) { return m_dtmManager . getDTMIdentity ( dtm ) ; } public DTM createDocumentFragment ( ) { return m_dtmManager . createDocumentFragment ( ) ; } public boolean release ( DTM dtm , boolean shouldHardDelete ) { if ( m_rtfdtm_stack != null && m_rtfdtm_stack . contains ( dtm ) ) { return false ; } return m_dtmManager . release ( dtm , shouldHardDelete ) ; } public DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) { return m_dtmManager . createDTMIterator ( xpathCompiler , pos ) ; } public DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) { return m_dtmManager . createDTMIterator ( xpathString , presolver ) ; } public DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) { return m_dtmManager . createDTMIterator ( whatToShow , filter , entityReferenceExpansion ) ; } public DTMIterator createDTMIterator ( int node ) { DTMIterator iter = new org . apache . xpath . axes . OneStepIteratorForward ( Axis . SELF ) ; iter . setRoot ( node , this ) ; return iter ; } public XPathContext ( ) { m_prefixResolvers . push ( null ) ; m_currentNodes . push ( DTM . NULL ) ; m_currentExpressionNodes . push ( DTM . NULL ) ; m_saxLocations . push ( null ) ; } public XPathContext ( Object owner ) { m_owner = owner ; try { m_ownerGetErrorListener = m_owner . getClass ( ) . getMethod ( "getErrorListener" , new Class [ ] { } ) ; } catch ( NoSuchMethodException nsme ) { } m_prefixResolvers . push ( null ) ; m_currentNodes . push ( DTM . NULL ) ; m_currentExpressionNodes . push ( DTM . NULL ) ; m_saxLocations . push ( null ) ; } public void reset ( ) { if ( m_rtfdtm_stack != null ) for ( java . util . Enumeration e = m_rtfdtm_stack . elements ( ) ; e . hasMoreElements ( ) ; ) m_dtmManager . release ( ( DTM ) e . nextElement ( ) , true ) ; m_rtfdtm_stack = null ; m_which_rtfdtm = - 1 ; if ( m_global_rtfdtm != null ) m_dtmManager . release ( m_global_rtfdtm , true ) ; m_global_rtfdtm = null ; m_dtmManager = DTMManager . newInstance ( org . apache . xpath . objects . XMLStringFactoryImpl . getFactory ( ) ) ; m_saxLocations . removeAllElements ( ) ; m_axesIteratorStack . removeAllElements ( ) ; m_contextNodeLists . removeAllElements ( ) ; m_currentExpressionNodes . removeAllElements ( ) ; m_currentNodes . removeAllElements ( ) ; m_iteratorRoots . RemoveAllNoClear ( ) ; m_predicatePos . removeAllElements ( ) ; m_predicateRoots . RemoveAllNoClear ( ) ; m_prefixResolvers . removeAllElements ( ) ; m_prefixResolvers . push ( null ) ; m_currentNodes . push ( DTM . NULL ) ; m_currentExpressionNodes . push ( DTM . NULL ) ; m_saxLocations . push ( null ) ; } ObjectStack m_saxLocations = new ObjectStack ( RECURSIONLIMIT ) ; public void setSAXLocator ( SourceLocator location ) { m_saxLocations . setTop ( location ) ; } public void pushSAXLocator ( SourceLocator location ) { m_saxLocations . push ( location ) ; } public void pushSAXLocatorNull ( ) { m_saxLocations . push ( null ) ; } public void popSAXLocator ( ) { m_saxLocations . pop ( ) ; } public SourceLocator getSAXLocator ( ) { return ( SourceLocator ) m_saxLocations . peek ( ) ; } private Object m_owner ; private Method m_ownerGetErrorListener ; public Object getOwnerObject ( ) { return m_owner ; } private VariableStack m_variableStacks = new VariableStack ( ) ; public final VariableStack getVarStack ( ) { return m_variableStacks ; } public final void setVarStack ( VariableStack varStack ) { m_variableStacks = varStack ; } private SourceTreeManager m_sourceTreeManager = new SourceTreeManager ( ) ; public final SourceTreeManager getSourceTreeManager ( ) { return m_sourceTreeManager ; } public void setSourceTreeManager ( SourceTreeManager mgr ) { m_sourceTreeManager = mgr ; } private ErrorListener m_errorListener ; private ErrorListener m_defaultErrorListener ; public final ErrorListener getErrorListener ( ) { if ( null != m_errorListener ) return m_errorListener ; ErrorListener retval = null ; try { if ( null != m_ownerGetErrorListener ) retval = ( ErrorListener ) m_ownerGetErrorListener . invoke ( m_owner , new Object [ ] { } ) ; } catch ( Exception e ) { } if ( null == retval ) { if ( null == m_defaultErrorListener ) m_defaultErrorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; retval = m_defaultErrorListener ; } return retval ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , null ) ) ; m_errorListener = listener ; } private URIResolver m_uriResolver ; public final URIResolver getURIResolver ( ) { return m_uriResolver ; } public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public XMLReader m_primaryReader ; public final XMLReader getPrimaryReader ( ) { return m_primaryReader ; } public void setPrimaryReader ( XMLReader reader ) { m_primaryReader = reader ; } private void assertion ( boolean b , String msg ) throws javax . xml . transform . TransformerException { ErrorListener errorHandler = getErrorListener ( ) ; if ( errorHandler != null ) { errorHandler . fatalError ( new TransformerException ( XSLMessages . createMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) , ( SAXSourceLocator ) this . getSAXLocator ( ) ) ) ; } } private Stack m_contextNodeLists = new Stack ( ) ; public Stack getContextNodeListsStack ( ) { return m_contextNodeLists ; } public void setContextNodeListsStack ( Stack s ) { m_contextNodeLists = s ; } public final DTMIterator getContextNodeList ( ) { if ( m_contextNodeLists . size ( ) > 0 ) return ( DTMIterator ) m_contextNodeLists . peek ( ) ; else return null ; } public final void pushContextNodeList ( DTMIterator nl ) { m_contextNodeLists . push ( nl ) ; } public final void popContextNodeList ( ) { if ( m_contextNodeLists . isEmpty ( ) ) System . err . println ( "Warning: popContextNodeList when stack is empty!" ) ; else m_contextNodeLists . pop ( ) ; } public static final int RECURSIONLIMIT = ( 1024 * 4 ) ; private IntStack m_currentNodes = new IntStack ( RECURSIONLIMIT ) ; public IntStack getCurrentNodeStack ( ) { return m_currentNodes ; } public void setCurrentNodeStack ( IntStack nv ) { m_currentNodes = nv ; } public final int getCurrentNode ( ) { return m_currentNodes . peek ( ) ; } public final void pushCurrentNodeAndExpression ( int cn , int en ) { m_currentNodes . push ( cn ) ; m_currentExpressionNodes . push ( cn ) ; } public final void popCurrentNodeAndExpression ( ) { m_currentNodes . quickPop ( 1 ) ; m_currentExpressionNodes . quickPop ( 1 ) ; } public final void pushExpressionState ( int cn , int en , PrefixResolver nc ) { m_currentNodes . push ( cn ) ; m_currentExpressionNodes . push ( cn ) ; m_prefixResolvers . push ( nc ) ; } public final void popExpressionState ( ) { m_currentNodes . quickPop ( 1 ) ; m_currentExpressionNodes . quickPop ( 1 ) ; m_prefixResolvers . pop ( ) ; } public final void pushCurrentNode ( int n ) { m_currentNodes . push ( n ) ; } public final void popCurrentNode ( ) { m_currentNodes . quickPop ( 1 ) ; } public final void pushPredicateRoot ( int n ) { m_predicateRoots . push ( n ) ; } public final void popPredicateRoot ( ) { m_predicateRoots . popQuick ( ) ; } public final int getPredicateRoot ( ) { return m_predicateRoots . peepOrNull ( ) ; } public final void pushIteratorRoot ( int n ) { m_iteratorRoots . push ( n ) ; } public final void popIteratorRoot ( ) { m_iteratorRoots . popQuick ( ) ; } public final int getIteratorRoot ( ) { return m_iteratorRoots . peepOrNull ( ) ; } private NodeVector m_iteratorRoots = new NodeVector ( ) ; private NodeVector m_predicateRoots = new NodeVector ( ) ; private IntStack m_currentExpressionNodes = new IntStack ( RECURSIONLIMIT ) ; public IntStack getCurrentExpressionNodeStack ( ) { return m_currentExpressionNodes ; } public void setCurrentExpressionNodeStack ( IntStack nv ) { m_currentExpressionNodes = nv ; } private IntStack m_predicatePos = new IntStack ( ) ; public final int getPredicatePos ( ) { return m_predicatePos . peek ( ) ; } public final void pushPredicatePos ( int n ) { m_predicatePos . push ( n ) ; } public final void popPredicatePos ( ) { m_predicatePos . pop ( ) ; } public final int getCurrentExpressionNode ( ) { return m_currentExpressionNodes . peek ( ) ; } public final void pushCurrentExpressionNode ( int n ) { m_currentExpressionNodes . push ( n ) ; } public final void popCurrentExpressionNode ( ) { m_currentExpressionNodes . quickPop ( 1 ) ; } private ObjectStack m_prefixResolvers = new ObjectStack ( RECURSIONLIMIT ) ; public final PrefixResolver getNamespaceContext ( ) { return ( PrefixResolver ) m_prefixResolvers . peek ( ) ; } public final void setNamespaceContext ( PrefixResolver pr ) { m_prefixResolvers . setTop ( pr ) ; } public final void pushNamespaceContext ( PrefixResolver pr ) { m_prefixResolvers . push ( pr ) ; } public final void pushNamespaceContextNull ( ) { m_prefixResolvers . push ( null ) ; } public final void popNamespaceContext ( ) { m_prefixResolvers . pop ( ) ; } private Stack m_axesIteratorStack = new Stack ( ) ; public Stack getAxesIteratorStackStacks ( ) { return m_axesIteratorStack ; } public void setAxesIteratorStackStacks ( Stack s ) { m_axesIteratorStack = s ; } public final void pushSubContextList ( SubContextList iter ) { m_axesIteratorStack . push ( iter ) ; } public final void popSubContextList ( ) { m_axesIteratorStack . pop ( ) ; } public SubContextList getSubContextList ( ) { return m_axesIteratorStack . isEmpty ( ) ? null : ( SubContextList ) m_axesIteratorStack . peek ( ) ; } public org . apache . xpath . axes . LocPathIterator getCurrentNodeList ( ) { for ( int i = m_axesIteratorStack . size ( ) - 1 ; i >= 0 ; i -- ) { org . apache . xpath . axes . PredicatedNodeTest iter = ( org . apache . xpath . axes . PredicatedNodeTest ) m_axesIteratorStack . elementAt ( i ) ; org . apache . xpath . axes . LocPathIterator lpi = iter . getLocPathIterator ( ) ; if ( lpi . getIsTopLevel ( ) ) return lpi ; } return null ; } public final int getContextNode ( ) { return this . getCurrentNode ( ) ; } public final DTMIterator getContextNodes ( ) { try { DTMIterator cnl = getContextNodeList ( ) ; if ( null != cnl ) return cnl . cloneWithReset ( ) ; else return null ; } catch ( CloneNotSupportedException cnse ) { return null ; } } XPathExpressionContext expressionContext = new XPathExpressionContext ( ) ; public ExpressionContext getExpressionContext ( ) { return expressionContext ; } public class XPathExpressionContext implements ExpressionContext { public XPathContext getXPathContext ( ) { return XPathContext . this ; } public DTMManager getDTMManager ( ) { return m_dtmManager ; } public org . w3c . dom . Node getContextNode ( ) { int context = getCurrentNode ( ) ; return getDTM ( context ) . getNode ( context ) ; } public org . w3c . dom . traversal . NodeIterator getContextNodes ( ) { return new org . apache . xml . dtm . ref . DTMNodeIterator ( getContextNodeList ( ) ) ; } public ErrorListener getErrorListener ( ) { return XPathContext . this . getErrorListener ( ) ; } public double toNumber ( org . w3c . dom . Node n ) { int nodeHandle = getDTMHandleFromNode ( n ) ; DTM dtm = getDTM ( nodeHandle ) ; XString xobj = ( XString ) dtm . getStringValue ( nodeHandle ) ; return xobj . num ( ) ; } public String toString ( org . w3c . dom . Node n ) { int nodeHandle = getDTMHandleFromNode ( n ) ; DTM dtm = getDTM ( nodeHandle ) ; XMLString strVal = dtm . getStringValue ( nodeHandle ) ; return strVal . toString ( ) ; } public final XObject getVariableOrParam ( org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException { return m_variableStacks . getVariableOrParam ( XPathContext . this , qname ) ; } } public DTM getGlobalRTFDTM ( ) { if ( m_global_rtfdtm == null || m_global_rtfdtm . isTreeIncomplete ( ) ) { m_global_rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; } return m_global_rtfdtm ; } public DTM getRTFDTM ( ) { SAX2RTFDTM rtfdtm ; if ( m_rtfdtm_stack == null ) { m_rtfdtm_stack = new Vector ( ) ; rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; m_rtfdtm_stack . addElement ( rtfdtm ) ; ++ m_which_rtfdtm ; } else if ( m_which_rtfdtm < 0 ) { rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( ++ m_which_rtfdtm ) ; } else { rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ; if ( rtfdtm . isTreeIncomplete ( ) ) { if ( ++ m_which_rtfdtm < m_rtfdtm_stack . size ( ) ) rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ; else { rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; m_rtfdtm_stack . addElement ( rtfdtm ) ; } } } return rtfdtm ; } public void pushRTFContext ( ) { m_last_pushed_rtfdtm . push ( m_which_rtfdtm ) ; if ( null != m_rtfdtm_stack ) ( ( SAX2RTFDTM ) ( getRTFDTM ( ) ) ) . pushRewindMark ( ) ; } public void popRTFContext ( ) { int previous = m_last_pushed_rtfdtm . pop ( ) ; if ( null == m_rtfdtm_stack ) return ; if ( m_which_rtfdtm == previous ) { if ( previous >= 0 ) { boolean isEmpty = ( ( SAX2RTFDTM ) ( m_rtfdtm_stack . elementAt ( previous ) ) ) . popRewindMark ( ) ; } } else while ( m_which_rtfdtm != previous ) { boolean isEmpty = ( ( SAX2RTFDTM ) ( m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ) ) . popRewindMark ( ) ; -- m_which_rtfdtm ; } } } 	1	['78', '2', '1', '173', '145', '2203', '156', '23', '76', '0.93452381', '1077', '0.791666667', '13', '0.2', '0.06993007', '0', '0', '12.5', '5', '1.2949', '3']
package org . apache . xalan . lib . sql ; import java . util . Hashtable ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class ConnectionPoolManager { static Hashtable m_poolTable = null ; static boolean m_isInit = false ; public ConnectionPoolManager ( ) { init ( ) ; } public synchronized void init ( ) { if ( m_isInit == true ) return ; m_poolTable = new Hashtable ( ) ; m_isInit = true ; } public synchronized void registerPool ( String name , ConnectionPool pool ) { if ( m_poolTable . containsKey ( name ) ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_POOL_EXISTS , null ) ) ; } m_poolTable . put ( name , pool ) ; } public synchronized void removePool ( String name ) { ConnectionPool pool = getPool ( name ) ; if ( null != pool ) { pool . setPoolEnabled ( false ) ; if ( ! pool . hasActiveConnections ( ) ) m_poolTable . remove ( name ) ; } } public synchronized ConnectionPool getPool ( String name ) { return ( ConnectionPool ) m_poolTable . get ( name ) ; } } 	1	['6', '1', '0', '3', '16', '0', '1', '2', '5', '0.3', '69', '0', '0', '0', '0.6', '0', '0', '10.16666667', '3', '1.3333', '1']
package org . apache . xalan . processor ; import java . util . Hashtable ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemApplyImport ; import org . apache . xalan . templates . ElemApplyTemplates ; import org . apache . xalan . templates . ElemAttribute ; import org . apache . xalan . templates . ElemCallTemplate ; import org . apache . xalan . templates . ElemChoose ; import org . apache . xalan . templates . ElemComment ; import org . apache . xalan . templates . ElemCopy ; import org . apache . xalan . templates . ElemCopyOf ; import org . apache . xalan . templates . ElemElement ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemExtensionDecl ; import org . apache . xalan . templates . ElemExtensionScript ; import org . apache . xalan . templates . ElemFallback ; import org . apache . xalan . templates . ElemForEach ; import org . apache . xalan . templates . ElemIf ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemMessage ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xalan . templates . ElemOtherwise ; import org . apache . xalan . templates . ElemPI ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemSort ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemText ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xalan . templates . ElemUnknown ; import org . apache . xalan . templates . ElemValueOf ; import org . apache . xalan . templates . ElemVariable ; import org . apache . xalan . templates . ElemWhen ; import org . apache . xalan . templates . ElemWithParam ; import org . apache . xml . utils . QName ; public class XSLTSchema extends XSLTElementDef { XSLTSchema ( ) { build ( ) ; } void build ( ) { XSLTAttributeDef hrefAttr = new XSLTAttributeDef ( null , "href" , XSLTAttributeDef . T_URL , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef elementsAttr = new XSLTAttributeDef ( null , "elements" , XSLTAttributeDef . T_SIMPLEPATTERNLIST , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef methodAttr = new XSLTAttributeDef ( null , "method" , XSLTAttributeDef . T_QNAME , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef versionAttr = new XSLTAttributeDef ( null , "version" , XSLTAttributeDef . T_NMTOKEN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef encodingAttr = new XSLTAttributeDef ( null , "encoding" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef omitXmlDeclarationAttr = new XSLTAttributeDef ( null , "omit-xml-declaration" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef standaloneAttr = new XSLTAttributeDef ( null , "standalone" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef doctypePublicAttr = new XSLTAttributeDef ( null , "doctype-public" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef doctypeSystemAttr = new XSLTAttributeDef ( null , "doctype-system" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef cdataSectionElementsAttr = new XSLTAttributeDef ( null , "cdata-section-elements" , XSLTAttributeDef . T_QNAMES_RESOLVE_NULL , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef indentAttr = new XSLTAttributeDef ( null , "indent" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef mediaTypeAttr = new XSLTAttributeDef ( null , "media-type" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef nameAttrRequired = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_QNAME , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef nameAVTRequired = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_AVT_QNAME , true , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef nameAVT_NCNAMERequired = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_NCNAME , true , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef nameAttrOpt_ERROR = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_QNAME , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef useAttr = new XSLTAttributeDef ( null , "use" , XSLTAttributeDef . T_EXPR , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef namespaceAVTOpt = new XSLTAttributeDef ( null , "namespace" , XSLTAttributeDef . T_URL , false , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef decimalSeparatorAttr = new XSLTAttributeDef ( null , "decimal-separator" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "." ) ; XSLTAttributeDef infinityAttr = new XSLTAttributeDef ( null , "infinity" , XSLTAttributeDef . T_CDATA , false , XSLTAttributeDef . ERROR , "Infinity" ) ; XSLTAttributeDef minusSignAttr = new XSLTAttributeDef ( null , "minus-sign" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "-" ) ; XSLTAttributeDef NaNAttr = new XSLTAttributeDef ( null , "NaN" , XSLTAttributeDef . T_CDATA , false , XSLTAttributeDef . ERROR , "NaN" ) ; XSLTAttributeDef percentAttr = new XSLTAttributeDef ( null , "percent" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "%" ) ; XSLTAttributeDef perMilleAttr = new XSLTAttributeDef ( null , "per-mille" , XSLTAttributeDef . T_CHAR , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef zeroDigitAttr = new XSLTAttributeDef ( null , "zero-digit" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "0" ) ; XSLTAttributeDef digitAttr = new XSLTAttributeDef ( null , "digit" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "#" ) ; XSLTAttributeDef patternSeparatorAttr = new XSLTAttributeDef ( null , "pattern-separator" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , ";" ) ; XSLTAttributeDef groupingSeparatorAttr = new XSLTAttributeDef ( null , "grouping-separator" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "," ) ; XSLTAttributeDef useAttributeSetsAttr = new XSLTAttributeDef ( null , "use-attribute-sets" , XSLTAttributeDef . T_QNAMES , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef testAttrRequired = new XSLTAttributeDef ( null , "test" , XSLTAttributeDef . T_EXPR , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef selectAttrRequired = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef selectAttrOpt = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef selectAttrDefNode = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , false , XSLTAttributeDef . ERROR , "node()" ) ; XSLTAttributeDef selectAttrDefDot = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , false , XSLTAttributeDef . ERROR , "." ) ; XSLTAttributeDef matchAttrRequired = new XSLTAttributeDef ( null , "match" , XSLTAttributeDef . T_PATTERN , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef matchAttrOpt = new XSLTAttributeDef ( null , "match" , XSLTAttributeDef . T_PATTERN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef priorityAttr = new XSLTAttributeDef ( null , "priority" , XSLTAttributeDef . T_NUMBER , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef modeAttr = new XSLTAttributeDef ( null , "mode" , XSLTAttributeDef . T_QNAME , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef spaceAttr = new XSLTAttributeDef ( Constants . S_XMLNAMESPACEURI , "space" , false , false , false , XSLTAttributeDef . WARNING , "default" , Constants . ATTRVAL_STRIP , "preserve" , Constants . ATTRVAL_PRESERVE ) ; XSLTAttributeDef spaceAttrLiteral = new XSLTAttributeDef ( Constants . S_XMLNAMESPACEURI , "space" , XSLTAttributeDef . T_URL , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef stylesheetPrefixAttr = new XSLTAttributeDef ( null , "stylesheet-prefix" , XSLTAttributeDef . T_CDATA , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef resultPrefixAttr = new XSLTAttributeDef ( null , "result-prefix" , XSLTAttributeDef . T_CDATA , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef disableOutputEscapingAttr = new XSLTAttributeDef ( null , "disable-output-escaping" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef levelAttr = new XSLTAttributeDef ( null , "level" , false , false , false , XSLTAttributeDef . ERROR , "single" , Constants . NUMBERLEVEL_SINGLE , "multiple" , Constants . NUMBERLEVEL_MULTI , "any" , Constants . NUMBERLEVEL_ANY ) ; levelAttr . setDefault ( "single" ) ; XSLTAttributeDef countAttr = new XSLTAttributeDef ( null , "count" , XSLTAttributeDef . T_PATTERN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef fromAttr = new XSLTAttributeDef ( null , "from" , XSLTAttributeDef . T_PATTERN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef valueAttr = new XSLTAttributeDef ( null , "value" , XSLTAttributeDef . T_EXPR , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef formatAttr = new XSLTAttributeDef ( null , "format" , XSLTAttributeDef . T_CDATA , false , true , XSLTAttributeDef . ERROR ) ; formatAttr . setDefault ( "1" ) ; XSLTAttributeDef langAttr = new XSLTAttributeDef ( null , "lang" , XSLTAttributeDef . T_NMTOKEN , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef letterValueAttr = new XSLTAttributeDef ( null , "letter-value" , false , true , false , XSLTAttributeDef . ERROR , "alphabetic" , Constants . NUMBERLETTER_ALPHABETIC , "traditional" , Constants . NUMBERLETTER_TRADITIONAL ) ; XSLTAttributeDef groupingSeparatorAVT = new XSLTAttributeDef ( null , "grouping-separator" , XSLTAttributeDef . T_CHAR , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef groupingSizeAttr = new XSLTAttributeDef ( null , "grouping-size" , XSLTAttributeDef . T_NUMBER , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef dataTypeAttr = new XSLTAttributeDef ( null , "data-type" , false , true , true , XSLTAttributeDef . ERROR , "text" , Constants . SORTDATATYPE_TEXT , "number" , Constants . SORTDATATYPE_TEXT ) ; dataTypeAttr . setDefault ( "text" ) ; XSLTAttributeDef orderAttr = new XSLTAttributeDef ( null , "order" , false , true , false , XSLTAttributeDef . ERROR , "ascending" , Constants . SORTORDER_ASCENDING , "descending" , Constants . SORTORDER_DESCENDING ) ; orderAttr . setDefault ( "ascending" ) ; XSLTAttributeDef caseOrderAttr = new XSLTAttributeDef ( null , "case-order" , false , true , false , XSLTAttributeDef . ERROR , "upper-first" , Constants . SORTCASEORDER_UPPERFIRST , "lower-first" , Constants . SORTCASEORDER_LOWERFIRST ) ; XSLTAttributeDef terminateAttr = new XSLTAttributeDef ( null , "terminate" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; terminateAttr . setDefault ( "no" ) ; XSLTAttributeDef xslExcludeResultPrefixesAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "exclude-result-prefixes" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef xslExtensionElementPrefixesAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "extension-element-prefixes" , XSLTAttributeDef . T_PREFIX_URLLIST , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef xslUseAttributeSetsAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "use-attribute-sets" , XSLTAttributeDef . T_QNAMES , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef xslVersionAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "version" , XSLTAttributeDef . T_NMTOKEN , false , false , XSLTAttributeDef . ERROR ) ; XSLTElementDef charData = new XSLTElementDef ( this , null , "text()" , null , null , null , new ProcessorCharacters ( ) , ElemTextLiteral . class ) ; charData . setType ( XSLTElementDef . T_PCDATA ) ; XSLTElementDef whiteSpaceOnly = new XSLTElementDef ( this , null , "text()" , null , null , null , null , ElemTextLiteral . class ) ; charData . setType ( XSLTElementDef . T_PCDATA ) ; XSLTAttributeDef resultAttr = new XSLTAttributeDef ( null , "*" , XSLTAttributeDef . T_AVT , false , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef xslResultAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "*" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . WARNING ) ; XSLTElementDef [ ] templateElements = new XSLTElementDef [ 23 ] ; XSLTElementDef [ ] templateElementsAndParams = new XSLTElementDef [ 24 ] ; XSLTElementDef [ ] templateElementsAndSort = new XSLTElementDef [ 24 ] ; XSLTElementDef [ ] exsltFunctionElements = new XSLTElementDef [ 24 ] ; XSLTElementDef [ ] charTemplateElements = new XSLTElementDef [ 15 ] ; XSLTElementDef resultElement = new XSLTElementDef ( this , null , "*" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttrLiteral , xslExcludeResultPrefixesAttr , xslExtensionElementPrefixesAttr , xslUseAttributeSetsAttr , xslVersionAttr , xslResultAttr , resultAttr } , new ProcessorLRE ( ) , ElemLiteralResult . class , 20 , true ) ; XSLTElementDef unknownElement = new XSLTElementDef ( this , "*" , "unknown" , null , templateElementsAndParams , new XSLTAttributeDef [ ] { xslExcludeResultPrefixesAttr , xslExtensionElementPrefixesAttr , xslUseAttributeSetsAttr , xslVersionAttr , xslResultAttr , resultAttr } , new ProcessorUnknown ( ) , ElemUnknown . class , 20 , true ) ; XSLTElementDef xslValueOf = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "value-of" , null , null , new XSLTAttributeDef [ ] { selectAttrRequired , disableOutputEscapingAttr } , new ProcessorTemplateElem ( ) , ElemValueOf . class , 20 , true ) ; XSLTElementDef xslCopyOf = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "copy-of" , null , null , new XSLTAttributeDef [ ] { selectAttrRequired } , new ProcessorTemplateElem ( ) , ElemCopyOf . class , 20 , true ) ; XSLTElementDef xslNumber = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "number" , null , null , new XSLTAttributeDef [ ] { levelAttr , countAttr , fromAttr , valueAttr , formatAttr , langAttr , letterValueAttr , groupingSeparatorAVT , groupingSizeAttr } , new ProcessorTemplateElem ( ) , ElemNumber . class , 20 , true ) ; XSLTElementDef xslSort = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "sort" , null , null , new XSLTAttributeDef [ ] { selectAttrDefDot , langAttr , dataTypeAttr , orderAttr , caseOrderAttr } , new ProcessorTemplateElem ( ) , ElemSort . class , 19 , true ) ; XSLTElementDef xslWithParam = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "with-param" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorTemplateElem ( ) , ElemWithParam . class , 19 , true ) ; XSLTElementDef xslApplyTemplates = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "apply-templates" , null , new XSLTElementDef [ ] { xslSort , xslWithParam } , new XSLTAttributeDef [ ] { selectAttrDefNode , modeAttr } , new ProcessorTemplateElem ( ) , ElemApplyTemplates . class , 20 , true ) ; XSLTElementDef xslApplyImports = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "apply-imports" , null , null , new XSLTAttributeDef [ ] { } , new ProcessorTemplateElem ( ) , ElemApplyImport . class ) ; XSLTElementDef xslForEach = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "for-each" , null , templateElementsAndSort , new XSLTAttributeDef [ ] { selectAttrRequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemForEach . class , true , false , true , 20 , true ) ; XSLTElementDef xslIf = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "if" , null , templateElements , new XSLTAttributeDef [ ] { testAttrRequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemIf . class , 20 , true ) ; XSLTElementDef xslWhen = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "when" , null , templateElements , new XSLTAttributeDef [ ] { testAttrRequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemWhen . class , false , true , 1 , true ) ; XSLTElementDef xslOtherwise = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "otherwise" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemOtherwise . class , false , false , 2 , false ) ; XSLTElementDef xslChoose = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "choose" , null , new XSLTElementDef [ ] { xslWhen , xslOtherwise } , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemChoose . class , true , false , true , 20 , true ) ; XSLTElementDef xslAttribute = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "attribute" , null , charTemplateElements , new XSLTAttributeDef [ ] { nameAVTRequired , namespaceAVTOpt , spaceAttr } , new ProcessorTemplateElem ( ) , ElemAttribute . class , 20 , true ) ; XSLTElementDef xslCallTemplate = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "call-template" , null , new XSLTElementDef [ ] { xslWithParam } , new XSLTAttributeDef [ ] { nameAttrRequired } , new ProcessorTemplateElem ( ) , ElemCallTemplate . class , 20 , true ) ; XSLTElementDef xslVariable = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "variable" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorTemplateElem ( ) , ElemVariable . class , 20 , true ) ; XSLTElementDef xslParam = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "param" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorTemplateElem ( ) , ElemParam . class , 19 , true ) ; XSLTElementDef xslText = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "text" , null , new XSLTElementDef [ ] { charData } , new XSLTAttributeDef [ ] { disableOutputEscapingAttr } , new ProcessorText ( ) , ElemText . class , 20 , true ) ; XSLTElementDef xslProcessingInstruction = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "processing-instruction" , null , charTemplateElements , new XSLTAttributeDef [ ] { nameAVT_NCNAMERequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemPI . class , 20 , true ) ; XSLTElementDef xslElement = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "element" , null , templateElements , new XSLTAttributeDef [ ] { nameAVTRequired , namespaceAVTOpt , useAttributeSetsAttr , spaceAttr } , new ProcessorTemplateElem ( ) , ElemElement . class , 20 , true ) ; XSLTElementDef xslComment = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "comment" , null , charTemplateElements , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemComment . class , 20 , true ) ; XSLTElementDef xslCopy = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "copy" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttr , useAttributeSetsAttr } , new ProcessorTemplateElem ( ) , ElemCopy . class , 20 , true ) ; XSLTElementDef xslMessage = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "message" , null , templateElements , new XSLTAttributeDef [ ] { terminateAttr } , new ProcessorTemplateElem ( ) , ElemMessage . class , 20 , true ) ; XSLTElementDef xslFallback = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "fallback" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemFallback . class , 20 , true ) ; XSLTElementDef exsltFunction = new XSLTElementDef ( this , Constants . S_EXSLT_FUNCTIONS_URL , "function" , null , exsltFunctionElements , new XSLTAttributeDef [ ] { nameAttrRequired } , new ProcessorExsltFunction ( ) , ElemExsltFunction . class ) ; XSLTElementDef exsltResult = new XSLTElementDef ( this , Constants . S_EXSLT_FUNCTIONS_URL , "result" , null , templateElements , new XSLTAttributeDef [ ] { selectAttrOpt } , new ProcessorExsltFuncResult ( ) , ElemExsltFuncResult . class ) ; int i = 0 ; templateElements [ i ++ ] = charData ; templateElements [ i ++ ] = xslApplyTemplates ; templateElements [ i ++ ] = xslCallTemplate ; templateElements [ i ++ ] = xslApplyImports ; templateElements [ i ++ ] = xslForEach ; templateElements [ i ++ ] = xslValueOf ; templateElements [ i ++ ] = xslCopyOf ; templateElements [ i ++ ] = xslNumber ; templateElements [ i ++ ] = xslChoose ; templateElements [ i ++ ] = xslIf ; templateElements [ i ++ ] = xslText ; templateElements [ i ++ ] = xslCopy ; templateElements [ i ++ ] = xslVariable ; templateElements [ i ++ ] = xslMessage ; templateElements [ i ++ ] = xslFallback ; templateElements [ i ++ ] = xslProcessingInstruction ; templateElements [ i ++ ] = xslComment ; templateElements [ i ++ ] = xslElement ; templateElements [ i ++ ] = xslAttribute ; templateElements [ i ++ ] = resultElement ; templateElements [ i ++ ] = unknownElement ; templateElements [ i ++ ] = exsltFunction ; templateElements [ i ++ ] = exsltResult ; int k ; for ( k = 0 ; k < i ; k ++ ) { templateElementsAndParams [ k ] = templateElements [ k ] ; templateElementsAndSort [ k ] = templateElements [ k ] ; exsltFunctionElements [ k ] = templateElements [ k ] ; } templateElementsAndParams [ k ] = xslParam ; templateElementsAndSort [ k ] = xslSort ; exsltFunctionElements [ k ] = xslParam ; i = 0 ; charTemplateElements [ i ++ ] = charData ; charTemplateElements [ i ++ ] = xslApplyTemplates ; charTemplateElements [ i ++ ] = xslCallTemplate ; charTemplateElements [ i ++ ] = xslApplyImports ; charTemplateElements [ i ++ ] = xslForEach ; charTemplateElements [ i ++ ] = xslValueOf ; charTemplateElements [ i ++ ] = xslCopyOf ; charTemplateElements [ i ++ ] = xslNumber ; charTemplateElements [ i ++ ] = xslChoose ; charTemplateElements [ i ++ ] = xslIf ; charTemplateElements [ i ++ ] = xslText ; charTemplateElements [ i ++ ] = xslCopy ; charTemplateElements [ i ++ ] = xslVariable ; charTemplateElements [ i ++ ] = xslMessage ; charTemplateElements [ i ++ ] = xslFallback ; XSLTElementDef importDef = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "import" , null , null , new XSLTAttributeDef [ ] { hrefAttr } , new ProcessorImport ( ) , null , 1 , true ) ; XSLTElementDef includeDef = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "include" , null , null , new XSLTAttributeDef [ ] { hrefAttr } , new ProcessorInclude ( ) , null , 20 , true ) ; XSLTAttributeDef [ ] scriptAttrs = new XSLTAttributeDef [ ] { new XSLTAttributeDef ( null , "lang" , XSLTAttributeDef . T_NMTOKEN , true , false , XSLTAttributeDef . WARNING ) , new XSLTAttributeDef ( null , "src" , XSLTAttributeDef . T_URL , false , false , XSLTAttributeDef . WARNING ) } ; XSLTAttributeDef [ ] componentAttrs = new XSLTAttributeDef [ ] { new XSLTAttributeDef ( null , "prefix" , XSLTAttributeDef . T_NMTOKEN , true , false , XSLTAttributeDef . WARNING ) , new XSLTAttributeDef ( null , "elements" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . WARNING ) , new XSLTAttributeDef ( null , "functions" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . WARNING ) } ; XSLTElementDef [ ] topLevelElements = new XSLTElementDef [ ] { includeDef , importDef , whiteSpaceOnly , unknownElement , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "strip-space" , null , null , new XSLTAttributeDef [ ] { elementsAttr } , new ProcessorStripSpace ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "preserve-space" , null , null , new XSLTAttributeDef [ ] { elementsAttr } , new ProcessorPreserveSpace ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "output" , null , null , new XSLTAttributeDef [ ] { methodAttr , versionAttr , encodingAttr , omitXmlDeclarationAttr , standaloneAttr , doctypePublicAttr , doctypeSystemAttr , cdataSectionElementsAttr , indentAttr , mediaTypeAttr , XSLTAttributeDef . m_foreignAttr } , new ProcessorOutputElem ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "key" , null , null , new XSLTAttributeDef [ ] { nameAttrRequired , matchAttrRequired , useAttr } , new ProcessorKey ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "decimal-format" , null , null , new XSLTAttributeDef [ ] { nameAttrOpt_ERROR , decimalSeparatorAttr , groupingSeparatorAttr , infinityAttr , minusSignAttr , NaNAttr , percentAttr , perMilleAttr , zeroDigitAttr , digitAttr , patternSeparatorAttr } , new ProcessorDecimalFormat ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "attribute-set" , null , new XSLTElementDef [ ] { xslAttribute } , new XSLTAttributeDef [ ] { nameAttrRequired , useAttributeSetsAttr } , new ProcessorAttributeSet ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "variable" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorGlobalVariableDecl ( ) , ElemVariable . class , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "param" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorGlobalParamDecl ( ) , ElemParam . class , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "template" , null , templateElementsAndParams , new XSLTAttributeDef [ ] { matchAttrOpt , nameAttrOpt_ERROR , priorityAttr , modeAttr , spaceAttr } , new ProcessorTemplate ( ) , ElemTemplate . class , true , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "namespace-alias" , null , null , new XSLTAttributeDef [ ] { stylesheetPrefixAttr , resultPrefixAttr } , new ProcessorNamespaceAlias ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_BUILTIN_EXTENSIONS_URL , "component" , null , new XSLTElementDef [ ] { new XSLTElementDef ( this , Constants . S_BUILTIN_EXTENSIONS_URL , "script" , null , new XSLTElementDef [ ] { charData } , scriptAttrs , new ProcessorLRE ( ) , ElemExtensionScript . class , 20 , true ) } , componentAttrs , new ProcessorLRE ( ) , ElemExtensionDecl . class ) , new XSLTElementDef ( this , Constants . S_BUILTIN_OLD_EXTENSIONS_URL , "component" , null , new XSLTElementDef [ ] { new XSLTElementDef ( this , Constants . S_BUILTIN_OLD_EXTENSIONS_URL , "script" , null , new XSLTElementDef [ ] { charData } , scriptAttrs , new ProcessorLRE ( ) , ElemExtensionScript . class , 20 , true ) } , componentAttrs , new ProcessorLRE ( ) , ElemExtensionDecl . class ) , exsltFunction } ; XSLTAttributeDef excludeResultPrefixesAttr = new XSLTAttributeDef ( null , "exclude-result-prefixes" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef extensionElementPrefixesAttr = new XSLTAttributeDef ( null , "extension-element-prefixes" , XSLTAttributeDef . T_PREFIX_URLLIST , false , false , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef idAttr = new XSLTAttributeDef ( null , "id" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef versionAttrRequired = new XSLTAttributeDef ( null , "version" , XSLTAttributeDef . T_NMTOKEN , true , false , XSLTAttributeDef . WARNING ) ; XSLTElementDef stylesheetElemDef = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "stylesheet" , "transform" , topLevelElements , new XSLTAttributeDef [ ] { extensionElementPrefixesAttr , excludeResultPrefixesAttr , idAttr , versionAttrRequired , spaceAttr } , new ProcessorStylesheetElement ( ) , null , true , - 1 , false ) ; importDef . setElements ( new XSLTElementDef [ ] { stylesheetElemDef , resultElement , unknownElement } ) ; includeDef . setElements ( new XSLTElementDef [ ] { stylesheetElemDef , resultElement , unknownElement } ) ; build ( null , null , null , new XSLTElementDef [ ] { stylesheetElemDef , whiteSpaceOnly , resultElement , unknownElement } , null , new ProcessorStylesheetDoc ( ) , null ) ; } private Hashtable m_availElems = new Hashtable ( ) ; public Hashtable getElemsAvailable ( ) { return m_availElems ; } void addAvailableElement ( QName elemName ) { m_availElems . put ( elemName , elemName ) ; } public boolean elementAvailable ( QName elemName ) { return m_availElems . containsKey ( elemName ) ; } } 	1	['6', '2', '0', '27', '47', '3', '5', '25', '2', '0.7875', '2717', '0.03125', '0', '0.848484848', '0.444444444', '1', '1', '446.5', '38', '7', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . TransletLoader ; public class NodeSortRecordFactory { private static int DESCENDING = "descending" . length ( ) ; private static int NUMBER = "number" . length ( ) ; private final DOM _dom ; private final String _className ; private Class _class ; private int _order [ ] ; private int _type [ ] ; private final AbstractTranslet _translet ; public Class loadTranslet ( String name ) throws ClassNotFoundException { try { return Class . forName ( name ) ; } catch ( ClassNotFoundException e ) { } return new TransletLoader ( ) . loadTranslet ( name ) ; } public NodeSortRecordFactory ( DOM dom , String className , Translet translet , String order [ ] , String type [ ] ) throws TransletException { try { _dom = dom ; _className = className ; _class = translet . getAuxiliaryClass ( className ) ; if ( _class == null ) _class = loadTranslet ( className ) ; _translet = ( AbstractTranslet ) translet ; int levels = order . length ; _order = new int [ levels ] ; _type = new int [ levels ] ; for ( int i = 0 ; i < levels ; i ++ ) { if ( order [ i ] . length ( ) == DESCENDING ) _order [ i ] = NodeSortRecord . COMPARE_DESCENDING ; if ( type [ i ] . length ( ) == NUMBER ) _type [ i ] = NodeSortRecord . COMPARE_NUMERIC ; } } catch ( ClassNotFoundException e ) { throw new TransletException ( e ) ; } } public NodeSortRecord makeNodeSortRecord ( int node , int last ) throws ExceptionInInitializerError , LinkageError , IllegalAccessException , InstantiationException , SecurityException , TransletException { final NodeSortRecord sortRecord = ( NodeSortRecord ) _class . newInstance ( ) ; sortRecord . initialize ( node , last , _dom , _translet , _order , _type , this ) ; return sortRecord ; } public String getClassName ( ) { return _className ; } } 	1	['5', '1', '0', '7', '14', '4', '2', '6', '4', '0.75', '126', '1', '2', '0', '0.416666667', '0', '0', '22.6', '1', '0.6', '1']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . RTFIterator ; import org . w3c . dom . NodeList ; public class XRTreeFrag extends XObject implements Cloneable { DTM m_dtm ; int m_dtmRoot ; XPathContext m_xctxt ; boolean m_allowRelease = false ; public XRTreeFrag ( int root , XPathContext xctxt , ExpressionNode parent ) { super ( null ) ; exprSetParent ( parent ) ; m_dtmRoot = root ; m_xctxt = xctxt ; m_dtm = xctxt . getDTM ( root ) ; } public XRTreeFrag ( int root , XPathContext xctxt ) { super ( null ) ; m_dtmRoot = root ; m_xctxt = xctxt ; m_dtm = xctxt . getDTM ( root ) ; } public Object object ( ) { if ( m_xctxt != null ) return new org . apache . xml . dtm . ref . DTMNodeIterator ( ( DTMIterator ) ( new org . apache . xpath . NodeSetDTM ( m_dtmRoot , m_xctxt . getDTMManager ( ) ) ) ) ; else return super . object ( ) ; } public XRTreeFrag ( Expression expr ) { super ( expr ) ; } protected void finalize ( ) throws Throwable { try { destruct ( ) ; } finally { super . finalize ( ) ; } } public void allowDetachToRelease ( boolean allowRelease ) { m_allowRelease = allowRelease ; } public void detach ( ) { if ( m_allowRelease ) { int ident = m_xctxt . getDTMIdentity ( m_dtm ) ; DTM foundDTM = m_xctxt . getDTM ( ident ) ; if ( foundDTM == m_dtm ) { m_xctxt . release ( m_dtm , true ) ; m_dtm = null ; m_xctxt = null ; } m_obj = null ; } } public void destruct ( ) { if ( null != m_dtm ) { int ident = m_xctxt . getDTMIdentity ( m_dtm ) ; DTM foundDTM = m_xctxt . getDTM ( ident ) ; if ( foundDTM == m_dtm ) { m_xctxt . release ( m_dtm , true ) ; m_dtm = null ; m_xctxt = null ; } } m_obj = null ; } public int getType ( ) { return CLASS_RTREEFRAG ; } public String getTypeString ( ) { return "#RTREEFRAG" ; } public double num ( ) throws javax . xml . transform . TransformerException { XMLString s = xstr ( ) ; return s . toDouble ( ) ; } public boolean bool ( ) { return true ; } private XMLString m_xmlStr = null ; public XMLString xstr ( ) { if ( null == m_xmlStr ) m_xmlStr = m_dtm . getStringValue ( m_dtmRoot ) ; return m_xmlStr ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { XString xstring = ( XString ) xstr ( ) ; xstring . appendToFsb ( fsb ) ; } public String str ( ) { String str = m_dtm . getStringValue ( m_dtmRoot ) . toString ( ) ; return ( null == str ) ? "" : str ; } public int rtf ( ) { return m_dtmRoot ; } public DTMIterator asNodeIterator ( ) { return new RTFIterator ( m_dtmRoot , m_xctxt . getDTMManager ( ) ) ; } public NodeList convertToNodeset ( ) { if ( m_obj instanceof NodeList ) return ( NodeList ) m_obj ; else return new org . apache . xml . dtm . ref . DTMNodeList ( asNodeIterator ( ) ) ; } public boolean equals ( XObject obj2 ) { try { if ( XObject . CLASS_NODESET == obj2 . getType ( ) ) { return obj2 . equals ( this ) ; } else if ( XObject . CLASS_BOOLEAN == obj2 . getType ( ) ) { return bool ( ) == obj2 . bool ( ) ; } else if ( XObject . CLASS_NUMBER == obj2 . getType ( ) ) { return num ( ) == obj2 . num ( ) ; } else if ( XObject . CLASS_NODESET == obj2 . getType ( ) ) { return xstr ( ) . equals ( obj2 . xstr ( ) ) ; } else if ( XObject . CLASS_STRING == obj2 . getType ( ) ) { return xstr ( ) . equals ( obj2 . xstr ( ) ) ; } else if ( XObject . CLASS_RTREEFRAG == obj2 . getType ( ) ) { return xstr ( ) . equals ( obj2 . xstr ( ) ) ; } else { return super . equals ( obj2 ) ; } } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } 	1	['19', '3', '1', '21', '42', '83', '6', '15', '18', '0.6', '332', '0.2', '3', '0.816091954', '0.184210526', '2', '24', '16.21052632', '9', '1.6842', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncLang extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String lang = m_arg0 . execute ( xctxt ) . str ( ) ; int parent = xctxt . getCurrentNode ( ) ; boolean isLang = false ; DTM dtm = xctxt . getDTM ( parent ) ; while ( DTM . NULL != parent ) { if ( DTM . ELEMENT_NODE == dtm . getNodeType ( parent ) ) { int langAttr = dtm . getAttributeNode ( parent , "http://www.w3.org/XML/1998/namespace" , "lang" ) ; if ( DTM . NULL != langAttr ) { String langVal = dtm . getNodeValue ( langAttr ) ; if ( langVal . toLowerCase ( ) . startsWith ( lang . toLowerCase ( ) ) ) { int valLen = lang . length ( ) ; if ( ( langVal . length ( ) == valLen ) || ( langVal . charAt ( valLen ) == '-' ) ) { isLang = true ; } } break ; } } parent = dtm . getParent ( parent ) ; } return isLang ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	1	['2', '4', '0', '6', '15', '1', '0', '6', '2', '2', '73', '0', '0', '0.979591837', '0.75', '1', '6', '35.5', '1', '0.5', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncUnparsedEntityURI extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String name = m_arg0 . execute ( xctxt ) . str ( ) ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int doc = dtm . getDocument ( ) ; String uri = dtm . getUnparsedEntityURI ( name ) ; return new XString ( uri ) ; } } 	1	['2', '4', '0', '6', '10', '1', '0', '6', '2', '2', '30', '0', '0', '0.979591837', '0.75', '1', '6', '14', '1', '0.5', '1']
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . StackGuard ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . QName ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . xml . sax . SAXException ; public class ElemApplyTemplates extends ElemCallTemplate { private QName m_mode = null ; public void setMode ( QName mode ) { m_mode = mode ; } public QName getMode ( ) { return m_mode ; } private boolean m_isDefaultTemplate = false ; public void setIsDefaultTemplate ( boolean b ) { m_isDefaultTemplate = b ; } public int getXSLToken ( ) { return Constants . ELEMNAME_APPLY_TEMPLATES ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_APPLY_TEMPLATES_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { transformer . pushCurrentTemplateRuleIsNull ( false ) ; boolean pushMode = false ; try { QName mode = transformer . getMode ( ) ; if ( ! m_isDefaultTemplate ) { if ( ( ( null == mode ) && ( null != m_mode ) ) || ( ( null != mode ) && ! mode . equals ( m_mode ) ) ) { pushMode = true ; transformer . pushMode ( m_mode ) ; } } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformSelectedNodes ( transformer ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; if ( pushMode ) transformer . popMode ( ) ; transformer . popCurrentTemplateRuleIsNull ( ) ; } } public void transformSelectedNodes ( TransformerImpl transformer ) throws TransformerException { final XPathContext xctxt = transformer . getXPathContext ( ) ; final int sourceNode = xctxt . getCurrentNode ( ) ; DTMIterator sourceNodes = m_selectExpression . asIterator ( xctxt , sourceNode ) ; VariableStack vars = xctxt . getVarStack ( ) ; int nParams = getParamElemCount ( ) ; int thisframe = vars . getStackFrame ( ) ; StackGuard guard = transformer . getStackGuard ( ) ; boolean check = ( guard . getRecursionLimit ( ) > - 1 ) ? true : false ; try { final Vector keys = ( m_sortElems == null ) ? null : transformer . processSortKeys ( this , sourceNode ) ; if ( null != keys ) sourceNodes = sortNodes ( xctxt , keys , sourceNodes ) ; if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; } final SerializationHandler rth = transformer . getSerializationHandler ( ) ; final StylesheetRoot sroot = transformer . getStylesheet ( ) ; final TemplateList tl = sroot . getTemplateListComposed ( ) ; final boolean quiet = transformer . getQuietConflictWarnings ( ) ; DTM dtm = xctxt . getDTM ( sourceNode ) ; int argsFrame = - 1 ; if ( nParams > 0 ) { argsFrame = vars . link ( nParams ) ; vars . setStackFrame ( thisframe ) ; for ( int i = 0 ; i < nParams ; i ++ ) { ElemWithParam ewp = m_paramElems [ i ] ; XObject obj = ewp . getValue ( transformer , sourceNode ) ; vars . setLocalVariable ( i , obj , argsFrame ) ; } vars . setStackFrame ( argsFrame ) ; } xctxt . pushCurrentNode ( DTM . NULL ) ; IntStack currentNodes = xctxt . getCurrentNodeStack ( ) ; xctxt . pushCurrentExpressionNode ( DTM . NULL ) ; IntStack currentExpressionNodes = xctxt . getCurrentExpressionNodeStack ( ) ; xctxt . pushSAXLocatorNull ( ) ; xctxt . pushContextNodeList ( sourceNodes ) ; transformer . pushElemTemplateElement ( null ) ; int child ; while ( DTM . NULL != ( child = sourceNodes . nextNode ( ) ) ) { currentNodes . setTop ( child ) ; currentExpressionNodes . setTop ( child ) ; if ( xctxt . getDTM ( child ) != dtm ) { dtm = xctxt . getDTM ( child ) ; } final int exNodeType = dtm . getExpandedTypeID ( child ) ; final int nodeType = dtm . getNodeType ( child ) ; final QName mode = transformer . getMode ( ) ; ElemTemplate template = tl . getTemplateFast ( xctxt , child , exNodeType , mode , - 1 , quiet , dtm ) ; if ( null == template ) { switch ( nodeType ) { case DTM . DOCUMENT_FRAGMENT_NODE : case DTM . ELEMENT_NODE : template = sroot . getDefaultRule ( ) ; break ; case DTM . ATTRIBUTE_NODE : case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : transformer . pushPairCurrentMatched ( sroot . getDefaultTextRule ( ) , child ) ; transformer . setCurrentElement ( sroot . getDefaultTextRule ( ) ) ; dtm . dispatchCharactersEvents ( child , rth , false ) ; transformer . popCurrentMatched ( ) ; continue ; case DTM . DOCUMENT_NODE : template = sroot . getDefaultRootRule ( ) ; break ; default : continue ; } } else { transformer . setCurrentElement ( template ) ; } transformer . pushPairCurrentMatched ( template , child ) ; if ( check ) guard . checkForInfinateLoop ( ) ; int currentFrameBottom ; if ( template . m_frameSize > 0 ) { xctxt . pushRTFContext ( ) ; currentFrameBottom = vars . getStackFrame ( ) ; vars . link ( template . m_frameSize ) ; if ( template . m_inArgsSize > 0 ) { int paramIndex = 0 ; for ( ElemTemplateElement elem = template . getFirstChildElem ( ) ; null != elem ; elem = elem . getNextSiblingElem ( ) ) { if ( Constants . ELEMNAME_PARAMVARIABLE == elem . getXSLToken ( ) ) { ElemParam ep = ( ElemParam ) elem ; int i ; for ( i = 0 ; i < nParams ; i ++ ) { ElemWithParam ewp = m_paramElems [ i ] ; if ( ewp . m_qnameID == ep . m_qnameID ) { XObject obj = vars . getLocalVariable ( i , argsFrame ) ; vars . setLocalVariable ( paramIndex , obj ) ; break ; } } if ( i == nParams ) vars . setLocalVariable ( paramIndex , null ) ; } else break ; paramIndex ++ ; } } } else currentFrameBottom = 0 ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( template ) ; for ( ElemTemplateElement t = template . m_firstChild ; t != null ; t = t . m_nextSibling ) { xctxt . setSAXLocator ( t ) ; try { transformer . pushElemTemplateElement ( t ) ; t . execute ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; } } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( template ) ; if ( template . m_frameSize > 0 ) { vars . unlink ( currentFrameBottom ) ; xctxt . popRTFContext ( ) ; } transformer . popCurrentMatched ( ) ; } } catch ( SAXException se ) { transformer . getErrorListener ( ) . fatalError ( new TransformerException ( se ) ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEndEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; if ( nParams > 0 ) vars . unlink ( thisframe ) ; xctxt . popSAXLocator ( ) ; xctxt . popContextNodeList ( ) ; transformer . popElemTemplateElement ( ) ; xctxt . popCurrentExpressionNode ( ) ; xctxt . popCurrentNode ( ) ; sourceNodes . detach ( ) ; } } } 	1	['9', '5', '0', '23', '82', '20', '2', '22', '9', '0.6875', '571', '1', '1', '0.965811966', '0.311111111', '5', '10', '62.22222222', '1', '0.8889', '2']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class UnionIterator extends DTMAxisIteratorBase { final private DOM _dom ; private final static class LookAheadIterator { public int node , markedNode ; public DTMAxisIterator iterator ; public LookAheadIterator ( DTMAxisIterator iterator ) { this . iterator = iterator ; } public int step ( ) { node = iterator . next ( ) ; return node ; } public LookAheadIterator cloneIterator ( ) { final LookAheadIterator clone = new LookAheadIterator ( iterator . cloneIterator ( ) ) ; clone . node = node ; clone . markedNode = node ; return clone ; } public void setMark ( ) { markedNode = node ; iterator . setMark ( ) ; } public void gotoMark ( ) { node = markedNode ; iterator . gotoMark ( ) ; } } private static final int InitSize = 8 ; private int _heapSize = 0 ; private int _size = InitSize ; private LookAheadIterator [ ] _heap = new LookAheadIterator [ InitSize ] ; private int _free = 0 ; private int _returnedLast ; public UnionIterator ( DOM dom ) { _dom = dom ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; final LookAheadIterator [ ] heapCopy = new LookAheadIterator [ _heap . length ] ; try { final UnionIterator clone = ( UnionIterator ) super . clone ( ) ; for ( int i = 0 ; i < _free ; i ++ ) { heapCopy [ i ] = _heap [ i ] . cloneIterator ( ) ; } clone . setRestartable ( false ) ; clone . _heap = heapCopy ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public UnionIterator addIterator ( DTMAxisIterator iterator ) { if ( _free == _size ) { LookAheadIterator [ ] newArray = new LookAheadIterator [ _size *= 2 ] ; System . arraycopy ( _heap , 0 , newArray , 0 , _free ) ; _heap = newArray ; } _heapSize ++ ; _heap [ _free ++ ] = new LookAheadIterator ( iterator ) ; return this ; } public int next ( ) { while ( _heapSize > 0 ) { final int smallest = _heap [ 0 ] . node ; if ( smallest == END ) { if ( _heapSize > 1 ) { final LookAheadIterator temp = _heap [ 0 ] ; _heap [ 0 ] = _heap [ -- _heapSize ] ; _heap [ _heapSize ] = temp ; } else { return END ; } } else if ( smallest == _returnedLast ) { _heap [ 0 ] . step ( ) ; } else { _heap [ 0 ] . step ( ) ; heapify ( 0 ) ; return returnNode ( _returnedLast = smallest ) ; } heapify ( 0 ) ; } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . iterator . setStartNode ( node ) ; _heap [ i ] . step ( ) ; } for ( int i = ( _heapSize = _free ) / 2 ; i >= 0 ; i -- ) { heapify ( i ) ; } _returnedLast = END ; return resetPosition ( ) ; } return this ; } private void heapify ( int i ) { for ( int r , l , smallest ; ; ) { r = ( i + 1 ) << 1 ; l = r - 1 ; smallest = l < _heapSize && _dom . lessThan ( _heap [ l ] . node , _heap [ i ] . node ) ? l : i ; if ( r < _heapSize && _dom . lessThan ( _heap [ r ] . node , _heap [ smallest ] . node ) ) { smallest = r ; } if ( smallest != i ) { final LookAheadIterator temp = _heap [ smallest ] ; _heap [ smallest ] = _heap [ i ] ; _heap [ i ] = temp ; i = smallest ; } else break ; } } public void setMark ( ) { for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . setMark ( ) ; } } public void gotoMark ( ) { for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . gotoMark ( ) ; } } public DTMAxisIterator reset ( ) { for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . iterator . reset ( ) ; _heap [ i ] . step ( ) ; } for ( int i = ( _heapSize = _free ) / 2 ; i >= 0 ; i -- ) { heapify ( i ) ; } _returnedLast = END ; return resetPosition ( ) ; } } 	1	['9', '2', '0', '6', '25', '0', '1', '5', '8', '0.517857143', '401', '1', '2', '0.619047619', '0.361111111', '1', '6', '42.77777778', '6', '2.8889', '2']
package org . apache . xml . dtm . ref ; import javax . xml . transform . SourceLocator ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . ext . LexicalHandler ; public class DTMDocumentImpl implements DTM , org . xml . sax . ContentHandler , org . xml . sax . ext . LexicalHandler { protected static final byte DOCHANDLE_SHIFT = 22 ; protected static final int NODEHANDLE_MASK = ( 1 << ( DOCHANDLE_SHIFT + 1 ) ) - 1 ; protected static final int DOCHANDLE_MASK = - 1 - NODEHANDLE_MASK ; int m_docHandle = NULL ; int m_docElement = NULL ; int currentParent = 0 ; int previousSibling = 0 ; protected int m_currentNode = - 1 ; private boolean previousSiblingWasParent = false ; int gotslot [ ] = new int [ 4 ] ; private boolean done = false ; boolean m_isError = false ; private final boolean DEBUG = false ; protected String m_documentBaseURI ; private IncrementalSAXSource m_incrSAXSource = null ; ChunkedIntArray nodes = new ChunkedIntArray ( 4 ) ; private FastStringBuffer m_char = new FastStringBuffer ( ) ; private int m_char_current_start = 0 ; private DTMStringPool m_localNames = new DTMStringPool ( ) ; private DTMStringPool m_nsNames = new DTMStringPool ( ) ; private DTMStringPool m_prefixNames = new DTMStringPool ( ) ; private ExpandedNameTable m_expandedNames = new ExpandedNameTable ( ) ; private XMLStringFactory m_xsf ; public DTMDocumentImpl ( DTMManager mgr , int documentNumber , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory ) { initDocument ( documentNumber ) ; m_xsf = xstringfactory ; } public void setIncrementalSAXSource ( IncrementalSAXSource source ) { m_incrSAXSource = source ; source . setContentHandler ( this ) ; source . setLexicalHandler ( this ) ; } private final int appendNode ( int w0 , int w1 , int w2 , int w3 ) { int slotnumber = nodes . appendSlot ( w0 , w1 , w2 , w3 ) ; if ( DEBUG ) System . out . println ( slotnumber + ": " + w0 + " " + w1 + " " + w2 + " " + w3 ) ; if ( previousSiblingWasParent ) nodes . writeEntry ( previousSibling , 2 , slotnumber ) ; previousSiblingWasParent = false ; return slotnumber ; } public void setFeature ( String featureId , boolean state ) { } ; public void setLocalNameTable ( DTMStringPool poolRef ) { m_localNames = poolRef ; } public DTMStringPool getLocalNameTable ( ) { return m_localNames ; } public void setNsNameTable ( DTMStringPool poolRef ) { m_nsNames = poolRef ; } public DTMStringPool getNsNameTable ( ) { return m_nsNames ; } public void setPrefixNameTable ( DTMStringPool poolRef ) { m_prefixNames = poolRef ; } public DTMStringPool getPrefixNameTable ( ) { return m_prefixNames ; } void setContentBuffer ( FastStringBuffer buffer ) { m_char = buffer ; } FastStringBuffer getContentBuffer ( ) { return m_char ; } public org . xml . sax . ContentHandler getContentHandler ( ) { if ( m_incrSAXSource instanceof IncrementalSAXSource_Filter ) return ( ContentHandler ) m_incrSAXSource ; else return this ; } public LexicalHandler getLexicalHandler ( ) { if ( m_incrSAXSource instanceof IncrementalSAXSource_Filter ) return ( LexicalHandler ) m_incrSAXSource ; else return this ; } public org . xml . sax . EntityResolver getEntityResolver ( ) { return null ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return null ; } public org . xml . sax . ErrorHandler getErrorHandler ( ) { return null ; } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { return null ; } public boolean needsTwoThreads ( ) { return null != m_incrSAXSource ; } public void characters ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { m_char . append ( ch , start , length ) ; } private void processAccumulatedText ( ) { int len = m_char . length ( ) ; if ( len != m_char_current_start ) { appendTextChild ( m_char_current_start , len - m_char_current_start ) ; m_char_current_start = len ; } } public void endDocument ( ) throws org . xml . sax . SAXException { appendEndDocument ( ) ; } public void endElement ( java . lang . String namespaceURI , java . lang . String localName , java . lang . String qName ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; appendEndElement ( ) ; } public void endPrefixMapping ( java . lang . String prefix ) throws org . xml . sax . SAXException { } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { } public void processingInstruction ( java . lang . String target , java . lang . String data ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; } public void setDocumentLocator ( Locator locator ) { } public void skippedEntity ( java . lang . String name ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { appendStartDocument ( ) ; } public void startElement ( java . lang . String namespaceURI , java . lang . String localName , java . lang . String qName , Attributes atts ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; String prefix = null ; int colon = qName . indexOf ( ':' ) ; if ( colon > 0 ) prefix = qName . substring ( 0 , colon ) ; System . out . println ( "Prefix=" + prefix + " index=" + m_prefixNames . stringToIndex ( prefix ) ) ; appendStartElement ( m_nsNames . stringToIndex ( namespaceURI ) , m_localNames . stringToIndex ( localName ) , m_prefixNames . stringToIndex ( prefix ) ) ; int nAtts = ( atts == null ) ? 0 : atts . getLength ( ) ; for ( int i = nAtts - 1 ; i >= 0 ; -- i ) { qName = atts . getQName ( i ) ; if ( qName . startsWith ( "xmlns:" ) || "xmlns" . equals ( qName ) ) { prefix = null ; colon = qName . indexOf ( ':' ) ; if ( colon > 0 ) { prefix = qName . substring ( 0 , colon ) ; } else { prefix = null ; } appendNSDeclaration ( m_prefixNames . stringToIndex ( prefix ) , m_nsNames . stringToIndex ( atts . getValue ( i ) ) , atts . getType ( i ) . equalsIgnoreCase ( "ID" ) ) ; } } for ( int i = nAtts - 1 ; i >= 0 ; -- i ) { qName = atts . getQName ( i ) ; if ( ! ( qName . startsWith ( "xmlns:" ) || "xmlns" . equals ( qName ) ) ) { prefix = null ; colon = qName . indexOf ( ':' ) ; if ( colon > 0 ) { prefix = qName . substring ( 0 , colon ) ; localName = qName . substring ( colon + 1 ) ; } else { prefix = "" ; localName = qName ; } m_char . append ( atts . getValue ( i ) ) ; int contentEnd = m_char . length ( ) ; if ( ! ( "xmlns" . equals ( prefix ) || "xmlns" . equals ( qName ) ) ) appendAttribute ( m_nsNames . stringToIndex ( atts . getURI ( i ) ) , m_localNames . stringToIndex ( localName ) , m_prefixNames . stringToIndex ( prefix ) , atts . getType ( i ) . equalsIgnoreCase ( "ID" ) , m_char_current_start , contentEnd - m_char_current_start ) ; m_char_current_start = contentEnd ; } } } public void startPrefixMapping ( java . lang . String prefix , java . lang . String uri ) throws org . xml . sax . SAXException { } public void comment ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; m_char . append ( ch , start , length ) ; appendComment ( m_char_current_start , length ) ; m_char_current_start += length ; } public void endCDATA ( ) throws org . xml . sax . SAXException { } public void endDTD ( ) throws org . xml . sax . SAXException { } public void endEntity ( java . lang . String name ) throws org . xml . sax . SAXException { } public void startCDATA ( ) throws org . xml . sax . SAXException { } public void startDTD ( java . lang . String name , java . lang . String publicId , java . lang . String systemId ) throws org . xml . sax . SAXException { } public void startEntity ( java . lang . String name ) throws org . xml . sax . SAXException { } final void initDocument ( int documentNumber ) { m_docHandle = documentNumber << DOCHANDLE_SHIFT ; nodes . writeSlot ( 0 , DOCUMENT_NODE , - 1 , - 1 , 0 ) ; done = false ; } public boolean hasChildNodes ( int nodeHandle ) { return ( getFirstChild ( nodeHandle ) != NULL ) ; } public int getFirstChild ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; if ( ( type == ELEMENT_NODE ) || ( type == DOCUMENT_NODE ) || ( type == ENTITY_REFERENCE_NODE ) ) { int kid = nodeHandle + 1 ; nodes . readSlot ( kid , gotslot ) ; while ( ATTRIBUTE_NODE == ( gotslot [ 0 ] & 0xFFFF ) ) { kid = gotslot [ 2 ] ; if ( kid == NULL ) return NULL ; nodes . readSlot ( kid , gotslot ) ; } if ( gotslot [ 1 ] == nodeHandle ) { int firstChild = kid | m_docHandle ; return firstChild ; } } return NULL ; } public int getLastChild ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; int lastChild = NULL ; for ( int nextkid = getFirstChild ( nodeHandle ) ; nextkid != NULL ; nextkid = getNextSibling ( nextkid ) ) { lastChild = nextkid ; } return lastChild | m_docHandle ; } public int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) { int nsIndex = m_nsNames . stringToIndex ( namespaceURI ) , nameIndex = m_localNames . stringToIndex ( name ) ; nodeHandle &= NODEHANDLE_MASK ; nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; if ( type == ELEMENT_NODE ) nodeHandle ++ ; while ( type == ATTRIBUTE_NODE ) { if ( ( nsIndex == ( gotslot [ 0 ] << 16 ) ) && ( gotslot [ 3 ] == nameIndex ) ) return nodeHandle | m_docHandle ; nodeHandle = gotslot [ 2 ] ; nodes . readSlot ( nodeHandle , gotslot ) ; } return NULL ; } public int getFirstAttribute ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; if ( ELEMENT_NODE != ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ) return NULL ; nodeHandle ++ ; return ( ATTRIBUTE_NODE == ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ) ? nodeHandle | m_docHandle : NULL ; } public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) { return NULL ; } public int getNextSibling ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; if ( nodeHandle == 0 ) return NULL ; short type = ( short ) ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ; if ( ( type == ELEMENT_NODE ) || ( type == ATTRIBUTE_NODE ) || ( type == ENTITY_REFERENCE_NODE ) ) { int nextSib = nodes . readEntry ( nodeHandle , 2 ) ; if ( nextSib == NULL ) return NULL ; if ( nextSib != 0 ) return ( m_docHandle | nextSib ) ; } int thisParent = nodes . readEntry ( nodeHandle , 1 ) ; if ( nodes . readEntry ( ++ nodeHandle , 1 ) == thisParent ) return ( m_docHandle | nodeHandle ) ; return NULL ; } public int getPreviousSibling ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; if ( nodeHandle == 0 ) return NULL ; int parent = nodes . readEntry ( nodeHandle , 1 ) ; int kid = NULL ; for ( int nextkid = getFirstChild ( parent ) ; nextkid != nodeHandle ; nextkid = getNextSibling ( nextkid ) ) { kid = nextkid ; } return kid | m_docHandle ; } public int getNextAttribute ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; if ( type == ELEMENT_NODE ) { return getFirstAttribute ( nodeHandle ) ; } else if ( type == ATTRIBUTE_NODE ) { if ( gotslot [ 2 ] != NULL ) return ( m_docHandle | gotslot [ 2 ] ) ; } return NULL ; } public int getNextNamespaceNode ( int baseHandle , int namespaceHandle , boolean inScope ) { return NULL ; } public int getNextDescendant ( int subtreeRootHandle , int nodeHandle ) { subtreeRootHandle &= NODEHANDLE_MASK ; nodeHandle &= NODEHANDLE_MASK ; if ( nodeHandle == 0 ) return NULL ; while ( ! m_isError ) { if ( done && ( nodeHandle > nodes . slotsUsed ( ) ) ) break ; if ( nodeHandle > subtreeRootHandle ) { nodes . readSlot ( nodeHandle + 1 , gotslot ) ; if ( gotslot [ 2 ] != 0 ) { short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; if ( type == ATTRIBUTE_NODE ) { nodeHandle += 2 ; } else { int nextParentPos = gotslot [ 1 ] ; if ( nextParentPos >= subtreeRootHandle ) return ( m_docHandle | ( nodeHandle + 1 ) ) ; else break ; } } else if ( ! done ) { } else break ; } else { nodeHandle ++ ; } } return NULL ; } public int getNextFollowing ( int axisContextHandle , int nodeHandle ) { return NULL ; } public int getNextPreceding ( int axisContextHandle , int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; while ( nodeHandle > 1 ) { nodeHandle -- ; if ( ATTRIBUTE_NODE == ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ) continue ; return ( m_docHandle | nodes . specialFind ( axisContextHandle , nodeHandle ) ) ; } return NULL ; } public int getParent ( int nodeHandle ) { return ( m_docHandle | nodes . readEntry ( nodeHandle , 1 ) ) ; } public int getDocumentRoot ( ) { return ( m_docHandle | m_docElement ) ; } public int getDocument ( ) { return m_docHandle ; } public int getOwnerDocument ( int nodeHandle ) { if ( ( nodeHandle & NODEHANDLE_MASK ) == 0 ) return NULL ; return ( nodeHandle & DOCHANDLE_MASK ) ; } public int getDocumentRoot ( int nodeHandle ) { if ( ( nodeHandle & NODEHANDLE_MASK ) == 0 ) return NULL ; return ( nodeHandle & DOCHANDLE_MASK ) ; } public XMLString getStringValue ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; int nodetype = gotslot [ 0 ] & 0xFF ; String value = null ; switch ( nodetype ) { case TEXT_NODE : case COMMENT_NODE : case CDATA_SECTION_NODE : value = m_char . getString ( gotslot [ 2 ] , gotslot [ 3 ] ) ; break ; case PROCESSING_INSTRUCTION_NODE : case ATTRIBUTE_NODE : case ELEMENT_NODE : case ENTITY_REFERENCE_NODE : default : break ; } return m_xsf . newstr ( value ) ; } public int getStringValueChunkCount ( int nodeHandle ) { return 0 ; } public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) { return new char [ 0 ] ; } public int getExpandedTypeID ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; String qName = m_localNames . indexToString ( gotslot [ 3 ] ) ; int colonpos = qName . indexOf ( ":" ) ; String localName = qName . substring ( colonpos + 1 ) ; String namespace = m_nsNames . indexToString ( gotslot [ 0 ] << 16 ) ; String expandedName = namespace + ":" + localName ; int expandedNameID = m_nsNames . stringToIndex ( expandedName ) ; return expandedNameID ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { String expandedName = namespace + ":" + localName ; int expandedNameID = m_nsNames . stringToIndex ( expandedName ) ; return expandedNameID ; } public String getLocalNameFromExpandedNameID ( int ExpandedNameID ) { String expandedName = m_localNames . indexToString ( ExpandedNameID ) ; int colonpos = expandedName . indexOf ( ":" ) ; String localName = expandedName . substring ( colonpos + 1 ) ; return localName ; } public String getNamespaceFromExpandedNameID ( int ExpandedNameID ) { String expandedName = m_localNames . indexToString ( ExpandedNameID ) ; int colonpos = expandedName . indexOf ( ":" ) ; String nsName = expandedName . substring ( 0 , colonpos ) ; return nsName ; } static final String [ ] fixednames = { null , null , null , "#text" , "#cdata_section" , null , null , null , "#comment" , "#document" , null , "#document-fragment" , null } ; public String getNodeName ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; String name = fixednames [ type ] ; if ( null == name ) { int i = gotslot [ 3 ] ; System . out . println ( "got i=" + i + " " + ( i > > 16 ) + "/" + ( i & 0xffff ) ) ; name = m_localNames . indexToString ( i & 0xFFFF ) ; String prefix = m_prefixNames . indexToString ( i > > 16 ) ; if ( prefix != null && prefix . length ( ) > 0 ) name = prefix + ":" + name ; } return name ; } public String getNodeNameX ( int nodeHandle ) { return null ; } public String getLocalName ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; String name = "" ; if ( ( type == ELEMENT_NODE ) || ( type == ATTRIBUTE_NODE ) ) { int i = gotslot [ 3 ] ; name = m_localNames . indexToString ( i & 0xFFFF ) ; if ( name == null ) name = "" ; } return name ; } public String getPrefix ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; String name = "" ; if ( ( type == ELEMENT_NODE ) || ( type == ATTRIBUTE_NODE ) ) { int i = gotslot [ 3 ] ; name = m_prefixNames . indexToString ( i > > 16 ) ; if ( name == null ) name = "" ; } return name ; } public String getNamespaceURI ( int nodeHandle ) { return null ; } public String getNodeValue ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; int nodetype = gotslot [ 0 ] & 0xFF ; String value = null ; switch ( nodetype ) { case ATTRIBUTE_NODE : nodes . readSlot ( nodeHandle + 1 , gotslot ) ; case TEXT_NODE : case COMMENT_NODE : case CDATA_SECTION_NODE : value = m_char . getString ( gotslot [ 2 ] , gotslot [ 3 ] ) ; break ; case PROCESSING_INSTRUCTION_NODE : case ELEMENT_NODE : case ENTITY_REFERENCE_NODE : default : break ; } return value ; } public short getNodeType ( int nodeHandle ) { return ( short ) ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ; } public short getLevel ( int nodeHandle ) { short count = 0 ; while ( nodeHandle != 0 ) { count ++ ; nodeHandle = nodes . readEntry ( nodeHandle , 1 ) ; } return count ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getDocumentBaseURI ( ) { return m_documentBaseURI ; } public void setDocumentBaseURI ( String baseURI ) { m_documentBaseURI = baseURI ; } public String getDocumentSystemIdentifier ( int nodeHandle ) { return null ; } public String getDocumentEncoding ( int nodeHandle ) { return null ; } public String getDocumentStandalone ( int nodeHandle ) { return null ; } public String getDocumentVersion ( int documentHandle ) { return null ; } public boolean getDocumentAllDeclarationsProcessed ( ) { return false ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { return null ; } public int getElementById ( String elementId ) { return 0 ; } public String getUnparsedEntityURI ( String name ) { return null ; } public boolean supportsPreStripping ( ) { return false ; } public boolean isNodeAfter ( int nodeHandle1 , int nodeHandle2 ) { return false ; } public boolean isCharacterElementContentWhitespace ( int nodeHandle ) { return false ; } public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) { return false ; } public boolean isAttributeSpecified ( int attributeHandle ) { return false ; } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { } public org . w3c . dom . Node getNode ( int nodeHandle ) { return null ; } public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) { boolean sameDoc = ( ( newChild & DOCHANDLE_MASK ) == m_docHandle ) ; if ( clone || ! sameDoc ) { } else { } } public void appendTextChild ( String str ) { } void appendTextChild ( int m_char_current_start , int contentLength ) { int w0 = TEXT_NODE ; int w1 = currentParent ; int w2 = m_char_current_start ; int w3 = contentLength ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; previousSibling = ourslot ; } void appendComment ( int m_char_current_start , int contentLength ) { int w0 = COMMENT_NODE ; int w1 = currentParent ; int w2 = m_char_current_start ; int w3 = contentLength ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; previousSibling = ourslot ; } void appendStartElement ( int namespaceIndex , int localNameIndex , int prefixIndex ) { int w0 = ( namespaceIndex << 16 ) | ELEMENT_NODE ; int w1 = currentParent ; int w2 = 0 ; int w3 = localNameIndex | prefixIndex << 16 ; System . out . println ( "set w3=" + w3 + " " + ( w3 > > 16 ) + "/" + ( w3 & 0xffff ) ) ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; currentParent = ourslot ; previousSibling = 0 ; if ( m_docElement == NULL ) m_docElement = ourslot ; } void appendNSDeclaration ( int prefixIndex , int namespaceIndex , boolean isID ) { final int namespaceForNamespaces = m_nsNames . stringToIndex ( "http://www.w3.org/2000/xmlns/" ) ; int w0 = NAMESPACE_NODE | ( m_nsNames . stringToIndex ( "http://www.w3.org/2000/xmlns/" ) << 16 ) ; int w1 = currentParent ; int w2 = 0 ; int w3 = namespaceIndex ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; previousSibling = ourslot ; previousSiblingWasParent = false ; return ; } void appendAttribute ( int namespaceIndex , int localNameIndex , int prefixIndex , boolean isID , int m_char_current_start , int contentLength ) { int w0 = ATTRIBUTE_NODE | namespaceIndex << 16 ; int w1 = currentParent ; int w2 = 0 ; int w3 = localNameIndex | prefixIndex << 16 ; System . out . println ( "set w3=" + w3 + " " + ( w3 > > 16 ) + "/" + ( w3 & 0xffff ) ) ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; previousSibling = ourslot ; w0 = TEXT_NODE ; w1 = ourslot ; w2 = m_char_current_start ; w3 = contentLength ; appendNode ( w0 , w1 , w2 , w3 ) ; previousSiblingWasParent = true ; return ; } public DTMAxisTraverser getAxisTraverser ( final int axis ) { return null ; } public DTMAxisIterator getAxisIterator ( final int axis ) { return null ; } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { return null ; } void appendEndElement ( ) { if ( previousSiblingWasParent ) nodes . writeEntry ( previousSibling , 2 , NULL ) ; previousSibling = currentParent ; nodes . readSlot ( currentParent , gotslot ) ; currentParent = gotslot [ 1 ] & 0xFFFF ; previousSiblingWasParent = true ; } void appendStartDocument ( ) { m_docElement = NULL ; initDocument ( 0 ) ; } void appendEndDocument ( ) { done = true ; } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } public void documentRegistration ( ) { } public void documentRelease ( ) { } } 	1	['110', '1', '0', '13', '149', '5191', '0', '13', '96', '0.943807339', '1849', '0.666666667', '8', '0', '0.11983945', '0', '0', '15.59090909', '10', '1.5364', '1']
package org . apache . xml . utils . synthetic . reflection ; import org . apache . xml . utils . synthetic . SynthesisException ; public interface Member { public abstract org . apache . xml . utils . synthetic . Class getDeclaringClass ( ) ; public abstract int getModifiers ( ) ; public abstract void setDeclaringClass ( org . apache . xml . utils . synthetic . Class declaringClass ) throws SynthesisException ; public abstract void setModifiers ( int modifiers ) throws SynthesisException ; } 	1	['4', '1', '0', '6', '4', '6', '4', '2', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . lib . sql ; import java . sql . Connection ; import java . sql . SQLException ; public class PooledConnection { private Connection connection = null ; private boolean inuse = false ; public PooledConnection ( Connection value ) { if ( value != null ) { connection = value ; } } public Connection getConnection ( ) { return connection ; } public void setInUse ( boolean value ) { inuse = value ; } public boolean inUse ( ) { return inuse ; } public void close ( ) { try { connection . close ( ) ; } catch ( SQLException sqle ) { System . err . println ( sqle . getMessage ( ) ) ; } } } 	1	['5', '1', '0', '1', '9', '0', '1', '0', '5', '0.5', '41', '1', '0', '0', '0.466666667', '0', '0', '6.8', '1', '0.8', '1']
package org . apache . xalan . trace ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; public class EndSelectionEvent extends SelectionEvent { public EndSelectionEvent ( TransformerImpl processor , Node sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) { super ( processor , sourceNode , styleNode , attributeName , xpath , selection ) ; } } 	1	['1', '2', '0', '8', '2', '0', '3', '5', '1', '2', '10', '0', '0', '0', '1', '0', '0', '9', '0', '0', '1']
package org . apache . xml . utils ; import java . io . Serializable ; import org . xml . sax . Attributes ; import org . xml . sax . helpers . AttributesImpl ; public class MutableAttrListImpl extends AttributesImpl implements Serializable { public MutableAttrListImpl ( ) { super ( ) ; } public MutableAttrListImpl ( Attributes atts ) { super ( atts ) ; } public void addAttribute ( String uri , String localName , String qName , String type , String value ) { if ( null == uri ) uri = "" ; int index = this . getIndex ( qName ) ; if ( index >= 0 ) this . setAttribute ( index , uri , localName , qName , type , value ) ; else super . addAttribute ( uri , localName , qName , type , value ) ; } public void addAttributes ( Attributes atts ) { int nAtts = atts . getLength ( ) ; for ( int i = 0 ; i < nAtts ; i ++ ) { String uri = atts . getURI ( i ) ; if ( null == uri ) uri = "" ; String localName = atts . getLocalName ( i ) ; String qname = atts . getQName ( i ) ; int index = this . getIndex ( uri , localName ) ; if ( index >= 0 ) this . setAttribute ( index , uri , localName , qname , atts . getType ( i ) , atts . getValue ( i ) ) ; else addAttribute ( uri , localName , qname , atts . getType ( i ) , atts . getValue ( i ) ) ; } } public boolean contains ( String name ) { return getValue ( name ) != null ; } } 	1	['5', '2', '0', '1', '18', '10', '1', '0', '5', '2', '107', '0', '0', '0.888888889', '0.6', '1', '2', '20.4', '4', '1.8', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . AttributeSetMethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class AttributeSet extends TopLevelElement { private static final String AttributeSetPrefix = "$as$" ; private QName _name ; private UseAttributeSets _useSets ; private AttributeSet _mergeSet ; private String _method ; private boolean _ignore = false ; public QName getName ( ) { return _name ; } public String getMethodName ( ) { return _method ; } public void ignore ( ) { _ignore = true ; } public void parseContents ( Parser parser ) { _name = parser . getQNameIgnoreDefaultNs ( getAttribute ( "name" ) ) ; if ( ( _name == null ) || ( _name . equals ( EMPTYSTRING ) ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNNAMED_ATTRIBSET_ERR , this ) ; parser . reportError ( Constants . ERROR , msg ) ; } final String useSets = getAttribute ( "use-attribute-sets" ) ; if ( useSets . length ( ) > 0 ) { _useSets = new UseAttributeSets ( useSets , parser ) ; } final Vector contents = getContents ( ) ; final int count = contents . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( child instanceof XslAttribute ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } else if ( child instanceof Text ) { } else { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_CHILD_ERR , this ) ; parser . reportError ( Constants . ERROR , msg ) ; } } parser . getSymbolTable ( ) . setCurrentNode ( this ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _ignore ) return ( Type . Void ) ; _mergeSet = stable . addAttributeSet ( this ) ; _method = AttributeSetPrefix + getXSLTC ( ) . nextAttributeSetSerial ( ) ; if ( _useSets != null ) _useSets . typeCheck ( stable ) ; typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _ignore ) return ; methodGen = new AttributeSetMethodGenerator ( _method , classGen ) ; if ( _mergeSet != null ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String methodName = _mergeSet . getMethodName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; final int method = cpg . addMethodref ( classGen . getClassName ( ) , methodName , ATTR_SET_SIG ) ; il . append ( new INVOKESPECIAL ( method ) ) ; } if ( _useSets != null ) _useSets . translate ( classGen , methodGen ) ; final Enumeration attributes = elements ( ) ; while ( attributes . hasMoreElements ( ) ) { SyntaxTreeNode element = ( SyntaxTreeNode ) attributes . nextElement ( ) ; if ( element instanceof XslAttribute ) { final XslAttribute attribute = ( XslAttribute ) element ; attribute . translate ( classGen , methodGen ) ; } } final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( RETURN ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( "attribute-set: " ) ; final Enumeration attributes = elements ( ) ; while ( attributes . hasMoreElements ( ) ) { final XslAttribute attribute = ( XslAttribute ) attributes . nextElement ( ) ; buf . append ( attribute ) ; } return ( buf . toString ( ) ) ; } } 	1	['8', '3', '0', '24', '54', '6', '3', '23', '7', '0.80952381', '279', '1', '3', '0.895522388', '0.3', '2', '5', '33.125', '7', '2.25', '2']
package org . apache . xalan . extensions ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . functions . Function ; public class ExpressionVisitor extends XPathVisitor { private StylesheetRoot m_sroot ; public ExpressionVisitor ( StylesheetRoot sroot ) { m_sroot = sroot ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { if ( func instanceof FuncExtFunction ) { String namespace = ( ( FuncExtFunction ) func ) . getNamespace ( ) ; m_sroot . getExtensionNamespacesManager ( ) . registerExtension ( namespace ) ; } return true ; } } 	1	['2', '2', '0', '7', '6', '0', '1', '6', '2', '0', '23', '1', '1', '0.923076923', '0.625', '0', '0', '10', '2', '1', '2']
package org . apache . xml . utils . synthetic . reflection ; import org . apache . xml . utils . synthetic . SynthesisException ; abstract public class EntryPoint implements Member { protected Object realep ; private org . apache . xml . utils . synthetic . Class declaringclass = null ; protected org . apache . xml . utils . synthetic . Class returntype = null ; private String [ ] parameternames = new String [ 0 ] ; private org . apache . xml . utils . synthetic . Class [ ] parametertypes = new org . apache . xml . utils . synthetic . Class [ 0 ] ; private org . apache . xml . utils . synthetic . Class [ ] exceptiontypes = new org . apache . xml . utils . synthetic . Class [ 0 ] ; ; private int modifiers ; protected String name = null ; private StringBuffer body = null ; private String language = null ; Class [ ] realE , realP ; public EntryPoint ( org . apache . xml . utils . synthetic . Class declaringclass ) { this . declaringclass = declaringclass ; } protected EntryPoint ( Object ep , org . apache . xml . utils . synthetic . Class declaringclass ) throws IllegalArgumentException { realep = ep ; this . declaringclass = declaringclass ; if ( ep instanceof java . lang . reflect . Method ) { java . lang . reflect . Method m = ( java . lang . reflect . Method ) ep ; if ( declaringclass == null ) { declaringclass = org . apache . xml . utils . synthetic . Class . forClass ( m . getDeclaringClass ( ) ) ; } name = m . getName ( ) ; modifiers = m . getModifiers ( ) ; returntype = org . apache . xml . utils . synthetic . Class . forClass ( m . getReturnType ( ) ) ; realP = m . getParameterTypes ( ) ; realE = m . getExceptionTypes ( ) ; } else if ( ep instanceof java . lang . reflect . Constructor ) { java . lang . reflect . Constructor c = ( java . lang . reflect . Constructor ) ep ; if ( declaringclass == null ) { declaringclass = org . apache . xml . utils . synthetic . Class . forClass ( c . getDeclaringClass ( ) ) ; } name = declaringclass . getShortName ( ) ; modifiers = c . getModifiers ( ) ; returntype = declaringclass ; realP = c . getParameterTypes ( ) ; realE = c . getExceptionTypes ( ) ; } else throw new IllegalArgumentException ( ) ; } protected EntryPoint ( Object ep ) throws IllegalArgumentException { this ( ep , null ) ; } public boolean equals ( Object obj ) { EntryPoint otherep = null ; if ( obj instanceof EntryPoint ) otherep = ( EntryPoint ) obj ; else if ( obj instanceof java . lang . reflect . Constructor || obj instanceof java . lang . reflect . Method ) otherep = ( EntryPoint ) obj ; return ( otherep != null && ( ( this instanceof Constructor && otherep instanceof Constructor ) || ( this instanceof Method && otherep instanceof Method && this . getName ( ) . equals ( otherep . getName ( ) ) ) ) && otherep . getDeclaringClass ( ) . equals ( declaringclass ) && otherep . getParameterTypes ( ) . equals ( parametertypes ) ) ; } public org . apache . xml . utils . synthetic . Class getDeclaringClass ( ) { return declaringclass ; } public org . apache . xml . utils . synthetic . Class getReturnType ( ) { return returntype ; } public org . apache . xml . utils . synthetic . Class [ ] getExceptionTypes ( ) { if ( realep != null && exceptiontypes == null ) { exceptiontypes = new org . apache . xml . utils . synthetic . Class [ realE . length ] ; for ( int i = 0 ; i < realE . length ; ++ i ) { exceptiontypes [ i ] = org . apache . xml . utils . synthetic . Class . forClass ( realE [ i ] ) ; } realE = null ; } return exceptiontypes ; } public void addExceptionType ( org . apache . xml . utils . synthetic . Class exception ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; org . apache . xml . utils . synthetic . Class [ ] e = new org . apache . xml . utils . synthetic . Class [ exceptiontypes . length + 1 ] ; System . arraycopy ( exceptiontypes , 0 , e , 0 , exceptiontypes . length ) ; e [ exceptiontypes . length ] = exception ; exceptiontypes = e ; } public int getModifiers ( ) { return modifiers ; } public java . lang . String getName ( ) { if ( this instanceof Constructor ) return declaringclass . getShortName ( ) ; return name ; } public void setName ( String name ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . name = name ; } public org . apache . xml . utils . synthetic . Class [ ] getParameterTypes ( ) { if ( realep != null && parametertypes == null ) { parametertypes = new org . apache . xml . utils . synthetic . Class [ realP . length ] ; for ( int i = 0 ; i < realP . length ; ++ i ) { parametertypes [ i ] = org . apache . xml . utils . synthetic . Class . forClass ( realP [ i ] ) ; } realP = null ; } return parametertypes ; } public String [ ] getParameterNames ( ) { return parameternames ; } public void addParameter ( org . apache . xml . utils . synthetic . Class type , String name ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; org . apache . xml . utils . synthetic . Class [ ] types = new org . apache . xml . utils . synthetic . Class [ parametertypes . length + 1 ] ; System . arraycopy ( parametertypes , 0 , types , 0 , parametertypes . length ) ; types [ parametertypes . length ] = type ; parametertypes = types ; String [ ] names = new String [ parameternames . length + 1 ] ; System . arraycopy ( parameternames , 0 , names , 0 , parameternames . length ) ; names [ parameternames . length ] = name ; parameternames = names ; } abstract public int hashCode ( ) ; public void setDeclaringClass ( org . apache . xml . utils . synthetic . Class declaringClass ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . declaringclass = declaringClass ; } public void setModifiers ( int modifiers ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . modifiers = modifiers ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( java . lang . reflect . Modifier . toString ( getModifiers ( ) ) ) ; if ( this instanceof org . apache . xml . utils . synthetic . reflection . Method ) sb . append ( ' ' ) . append ( getReturnType ( ) ) . append ( getDeclaringClass ( ) . getName ( ) ) . append ( '.' ) . append ( getName ( ) ) ; else sb . append ( getDeclaringClass ( ) . getName ( ) ) ; sb . append ( '(' ) ; org . apache . xml . utils . synthetic . Class [ ] p = getParameterTypes ( ) ; if ( p != null && p . length > 0 ) { sb . append ( p [ 0 ] . getName ( ) ) ; for ( int i = 1 ; i < p . length ; ++ i ) { sb . append ( ',' ) . append ( p [ i ] . getName ( ) ) ; } } sb . append ( ')' ) ; if ( this instanceof org . apache . xml . utils . synthetic . reflection . Method ) { p = getExceptionTypes ( ) ; if ( p != null && p . length > 0 ) { sb . append ( " throws " ) . append ( p [ 0 ] . getName ( ) ) ; for ( int i = 1 ; i < p . length ; ++ i ) { sb . append ( ',' ) . append ( p [ i ] . getName ( ) ) ; } } } return sb . toString ( ) ; } public void setBody ( String language , StringBuffer body ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . language = language ; this . body = body ; } public StringBuffer getBody ( ) { if ( body == null ) body = new StringBuffer ( ) ; return body ; } public String getLanguage ( ) { return language ; } public String toSource ( String basetab ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( basetab ) . append ( java . lang . reflect . Modifier . toString ( getModifiers ( ) ) ) ; if ( this instanceof org . apache . xml . utils . synthetic . reflection . Method ) { if ( returntype != null ) sb . append ( " " ) . append ( getReturnType ( ) . getJavaName ( ) ) ; else sb . append ( " void" ) ; } sb . append ( " " ) . append ( getName ( ) ) . append ( "(" ) ; org . apache . xml . utils . synthetic . Class [ ] types = getParameterTypes ( ) ; if ( types != null & types . length > 0 ) { sb . append ( types [ 0 ] . getJavaName ( ) ) ; if ( parameternames != null ) sb . append ( ' ' ) . append ( parameternames [ 0 ] ) ; for ( int i = 1 ; i < types . length ; ++ i ) { sb . append ( ',' ) . append ( types [ i ] . getJavaName ( ) ) ; if ( parameternames != null ) sb . append ( ' ' ) . append ( parameternames [ i ] ) ; } } sb . append ( ')' ) ; types = getExceptionTypes ( ) ; if ( types != null & types . length > 0 ) { sb . append ( " throws " ) . append ( types [ 0 ] . getJavaName ( ) ) ; for ( int i = 1 ; i < types . length ; ++ i ) { sb . append ( ',' ) . append ( types [ i ] . getJavaName ( ) ) ; } } if ( body == null ) sb . append ( "; // No method body available\n" ) ; else { sb . append ( "\n" + basetab + "{\n" ) ; if ( language == null || "java" . equals ( language ) ) { sb . append ( basetab + "// ***** Should prettyprint this code...\n" ) ; sb . append ( basetab + body + "\n" ) ; } else { sb . append ( basetab + "// ***** Generate BSF invocation!?\n" ) ; } sb . append ( basetab + "}\n" ) ; } return sb . toString ( ) ; } } 	1	['22', '1', '2', '5', '49', '71', '2', '5', '20', '0.706349206', '827', '0.833333333', '4', '0', '0.272727273', '1', '1', '36.04545455', '16', '2.7727', '1']
package org . apache . xalan . extensions ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . ClonerToResultTree ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . DescendantIterator ; import org . apache . xpath . axes . OneStepIterator ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XString ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . traversal . NodeIterator ; public class XSLProcessorContext { public XSLProcessorContext ( TransformerImpl transformer , Stylesheet stylesheetTree ) { this . transformer = transformer ; this . stylesheetTree = stylesheetTree ; org . apache . xpath . XPathContext xctxt = transformer . getXPathContext ( ) ; this . mode = transformer . getMode ( ) ; this . sourceNode = xctxt . getCurrentNode ( ) ; this . sourceTree = xctxt . getDTM ( this . sourceNode ) ; } private TransformerImpl transformer ; public TransformerImpl getTransformer ( ) { return transformer ; } private Stylesheet stylesheetTree ; public Stylesheet getStylesheet ( ) { return stylesheetTree ; } private org . apache . xml . dtm . DTM sourceTree ; public org . w3c . dom . Node getSourceTree ( ) { return sourceTree . getNode ( sourceTree . getDocumentRoot ( sourceNode ) ) ; } private int sourceNode ; public org . w3c . dom . Node getContextNode ( ) { return sourceTree . getNode ( sourceNode ) ; } private QName mode ; public QName getMode ( ) { return mode ; } public void outputToResultTree ( Stylesheet stylesheetTree , Object obj ) throws TransformerException , java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException { try { SerializationHandler rtreeHandler = transformer . getResultTreeHandler ( ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; XObject value ; if ( obj instanceof XObject ) { value = ( XObject ) obj ; } else if ( obj instanceof String ) { value = new XString ( ( String ) obj ) ; } else if ( obj instanceof Boolean ) { value = new XBoolean ( ( ( Boolean ) obj ) . booleanValue ( ) ) ; } else if ( obj instanceof Double ) { value = new XNumber ( ( ( Double ) obj ) . doubleValue ( ) ) ; } else if ( obj instanceof DocumentFragment ) { int handle = xctxt . getDTMHandleFromNode ( ( DocumentFragment ) obj ) ; value = new XRTreeFrag ( handle , xctxt ) ; } else if ( obj instanceof DTM ) { DTM dtm = ( DTM ) obj ; DTMIterator iterator = new DescendantIterator ( ) ; iterator . setRoot ( dtm . getDocument ( ) , xctxt ) ; value = new XNodeSet ( iterator ) ; } else if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; DTMIterator iterator = new OneStepIterator ( iter , - 1 ) ; value = new XNodeSet ( iterator ) ; } else if ( obj instanceof DTMIterator ) { value = new XNodeSet ( ( DTMIterator ) obj ) ; } else if ( obj instanceof NodeIterator ) { value = new XNodeSet ( new org . apache . xpath . NodeSetDTM ( ( ( NodeIterator ) obj ) , xctxt ) ) ; } else if ( obj instanceof org . w3c . dom . Node ) { value = new XNodeSet ( xctxt . getDTMHandleFromNode ( ( org . w3c . dom . Node ) obj ) , xctxt . getDTMManager ( ) ) ; } else { value = new XString ( obj . toString ( ) ) ; } int type = value . getType ( ) ; String s ; switch ( type ) { case XObject . CLASS_BOOLEAN : case XObject . CLASS_NUMBER : case XObject . CLASS_STRING : s = value . str ( ) ; rtreeHandler . characters ( s . toCharArray ( ) , 0 , s . length ( ) ) ; break ; case XObject . CLASS_NODESET : DTMIterator nl = value . iter ( ) ; int pos ; while ( DTM . NULL != ( pos = nl . nextNode ( ) ) ) { DTM dtm = nl . getDTM ( pos ) ; int top = pos ; while ( DTM . NULL != pos ) { rtreeHandler . flushPending ( ) ; ClonerToResultTree . cloneToResultTree ( pos , dtm . getNodeType ( pos ) , dtm , rtreeHandler , true ) ; int nextNode = dtm . getFirstChild ( pos ) ; while ( DTM . NULL == nextNode ) { if ( DTM . ELEMENT_NODE == dtm . getNodeType ( pos ) ) { rtreeHandler . endElement ( "" , "" , dtm . getNodeName ( pos ) ) ; } if ( top == pos ) break ; nextNode = dtm . getNextSibling ( pos ) ; if ( DTM . NULL == nextNode ) { pos = dtm . getParent ( pos ) ; if ( top == pos ) { if ( DTM . ELEMENT_NODE == dtm . getNodeType ( pos ) ) { rtreeHandler . endElement ( "" , "" , dtm . getNodeName ( pos ) ) ; } nextNode = DTM . NULL ; break ; } } } pos = nextNode ; } } break ; case XObject . CLASS_RTREEFRAG : SerializerUtils . outputResultTreeFragment ( rtreeHandler , value , transformer . getXPathContext ( ) ) ; break ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } } 	1	['7', '1', '1', '26', '49', '5', '6', '20', '7', '0.733333333', '321', '1', '4', '0', '0.392857143', '0', '0', '44.14285714', '1', '0.8571', '1']
package org . apache . xpath . functions ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncExtElementAvailable extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String prefix ; String namespace ; String methName ; String fullName = m_arg0 . execute ( xctxt ) . str ( ) ; int indexOfNSSep = fullName . indexOf ( ':' ) ; if ( indexOfNSSep < 0 ) { prefix = "" ; namespace = Constants . S_XSLNAMESPACEURL ; methName = fullName ; } else { prefix = fullName . substring ( 0 , indexOfNSSep ) ; namespace = xctxt . getNamespaceContext ( ) . getNamespaceForPrefix ( prefix ) ; if ( null == namespace ) return XBoolean . S_FALSE ; methName = fullName . substring ( indexOfNSSep + 1 ) ; } if ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) || namespace . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) ) { try { TransformerImpl transformer = ( TransformerImpl ) xctxt . getOwnerObject ( ) ; return transformer . getStylesheet ( ) . getAvailableElements ( ) . containsKey ( new QName ( namespace , methName ) ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } catch ( Exception e ) { return XBoolean . S_FALSE ; } } else { ExtensionsProvider extProvider = ( ExtensionsProvider ) xctxt . getOwnerObject ( ) ; return extProvider . elementAvailable ( namespace , methName ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } } 	1	['2', '4', '0', '10', '17', '1', '0', '10', '2', '2', '87', '0', '0', '0.979591837', '0.75', '2', '7', '42.5', '1', '0.5', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . compiler . Compiler ; public class AttributeIterator extends ChildTestIterator { AttributeIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_cdtm . getFirstAttribute ( m_context ) : m_cdtm . getNextAttribute ( m_lastFetched ) ; return m_lastFetched ; } public int getAxis ( ) { return org . apache . xml . dtm . Axis . ATTRIBUTE ; } } 	1	['3', '7', '0', '4', '6', '3', '1', '3', '1', '2', '31', '0', '0', '0.985185185', '0.555555556', '3', '5', '9.333333333', '2', '1', '1']
package org . apache . xalan . xsltc . compiler ; import java . io . OutputStreamWriter ; import java . util . Properties ; import java . util . StringTokenizer ; import javax . xml . transform . OutputKeys ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . serializer . Encodings ; final class Output extends TopLevelElement { private String _version ; private String _method ; private String _encoding ; private boolean _omitHeader = false ; private String _standalone ; private String _doctypePublic ; private String _doctypeSystem ; private String _cdata ; private boolean _indent = false ; private String _mediaType ; private String _cdataToMerge ; private boolean _disabled = false ; private final static String STRING_SIG = "Ljava/lang/String;" ; private final static String XML_VERSION = "1.0" ; private final static String HTML_VERSION = "4.0" ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "Output " + _method ) ; } public void disable ( ) { _disabled = true ; } public boolean enabled ( ) { return ! _disabled ; } public String getCdata ( ) { return _cdata ; } public void mergeCdata ( String cdata ) { _cdataToMerge = cdata ; } public void parseContents ( Parser parser ) { final Properties outputProperties = new Properties ( ) ; parser . setOutput ( this ) ; if ( _disabled ) return ; String attrib = null ; _version = getAttribute ( "version" ) ; if ( _version == null || _version . equals ( Constants . EMPTYSTRING ) ) { _version = null ; } else { outputProperties . setProperty ( OutputKeys . VERSION , _version ) ; } _method = getAttribute ( "method" ) ; if ( _method . equals ( Constants . EMPTYSTRING ) ) { _method = null ; } if ( _method != null ) { _method = _method . toLowerCase ( ) ; outputProperties . setProperty ( OutputKeys . METHOD , _method ) ; } _encoding = getAttribute ( "encoding" ) ; if ( _encoding . equals ( Constants . EMPTYSTRING ) ) { _encoding = null ; } else { try { String canonicalEncoding ; canonicalEncoding = Encodings . convertMime2JavaEncoding ( _encoding ) ; OutputStreamWriter writer = new OutputStreamWriter ( System . out , canonicalEncoding ) ; } catch ( java . io . UnsupportedEncodingException e ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_ENCODING , _encoding , this ) ; parser . reportError ( Constants . WARNING , msg ) ; } outputProperties . setProperty ( OutputKeys . ENCODING , _encoding ) ; } attrib = getAttribute ( "omit-xml-declaration" ) ; if ( attrib != null && ! attrib . equals ( Constants . EMPTYSTRING ) ) { if ( attrib . equals ( "yes" ) ) { _omitHeader = true ; } outputProperties . setProperty ( OutputKeys . OMIT_XML_DECLARATION , attrib ) ; } _standalone = getAttribute ( "standalone" ) ; if ( _standalone . equals ( Constants . EMPTYSTRING ) ) { _standalone = null ; } else { outputProperties . setProperty ( OutputKeys . STANDALONE , _standalone ) ; } _doctypeSystem = getAttribute ( "doctype-system" ) ; if ( _doctypeSystem . equals ( Constants . EMPTYSTRING ) ) { _doctypeSystem = null ; } else { outputProperties . setProperty ( OutputKeys . DOCTYPE_SYSTEM , _doctypeSystem ) ; } _doctypePublic = getAttribute ( "doctype-public" ) ; if ( _doctypePublic . equals ( Constants . EMPTYSTRING ) ) { _doctypePublic = null ; } else { outputProperties . setProperty ( OutputKeys . DOCTYPE_PUBLIC , _doctypePublic ) ; } _cdata = getAttribute ( "cdata-section-elements" ) ; if ( _cdata != null && _cdata . equals ( Constants . EMPTYSTRING ) ) { _cdata = null ; } else { StringBuffer expandedNames = new StringBuffer ( ) ; StringTokenizer tokens = new StringTokenizer ( _cdata ) ; while ( tokens . hasMoreTokens ( ) ) { expandedNames . append ( parser . getQName ( tokens . nextToken ( ) ) . toString ( ) ) . append ( ' ' ) ; } _cdata = expandedNames . toString ( ) ; if ( _cdataToMerge != null ) { _cdata = _cdata + _cdataToMerge ; } outputProperties . setProperty ( OutputKeys . CDATA_SECTION_ELEMENTS , _cdata ) ; } attrib = getAttribute ( "indent" ) ; if ( attrib != null && ! attrib . equals ( EMPTYSTRING ) ) { if ( attrib . equals ( "yes" ) ) { _indent = true ; } outputProperties . setProperty ( OutputKeys . INDENT , attrib ) ; } else if ( _method != null && _method . equals ( "html" ) ) { _indent = true ; } _mediaType = getAttribute ( "media-type" ) ; if ( _mediaType . equals ( Constants . EMPTYSTRING ) ) { _mediaType = null ; } else { outputProperties . setProperty ( OutputKeys . MEDIA_TYPE , _mediaType ) ; } if ( _method != null ) { if ( _method . equals ( "html" ) ) { if ( _version == null ) { _version = HTML_VERSION ; } if ( _mediaType == null ) { _mediaType = "text/html" ; } } else if ( _method . equals ( "text" ) ) { if ( _mediaType == null ) { _mediaType = "text/plain" ; } } } parser . getCurrentStylesheet ( ) . setOutputProperties ( outputProperties ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _disabled ) return ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; int field = 0 ; il . append ( classGen . loadTranslet ( ) ) ; if ( ( _version != null ) && ( ! _version . equals ( XML_VERSION ) ) ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_version" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _version ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _method != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_method" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _method ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _encoding != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_encoding" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _encoding ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _omitHeader ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_omitHeader" , "Z" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _omitHeader ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _standalone != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_standalone" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _standalone ) ) ; il . append ( new PUTFIELD ( field ) ) ; } field = cpg . addFieldref ( TRANSLET_CLASS , "_doctypeSystem" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _doctypeSystem ) ) ; il . append ( new PUTFIELD ( field ) ) ; field = cpg . addFieldref ( TRANSLET_CLASS , "_doctypePublic" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _doctypePublic ) ) ; il . append ( new PUTFIELD ( field ) ) ; if ( _mediaType != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_mediaType" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _mediaType ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _indent ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_indent" , "Z" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _indent ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _cdata != null ) { int index = cpg . addMethodref ( TRANSLET_CLASS , "addCdataElement" , "(Ljava/lang/String;)V" ) ; StringTokenizer tokens = new StringTokenizer ( _cdata ) ; while ( tokens . hasMoreTokens ( ) ) { il . append ( DUP ) ; il . append ( new PUSH ( cpg , tokens . nextToken ( ) ) ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } } il . append ( POP ) ; } } 	1	['8', '3', '0', '19', '43', '0', '2', '19', '7', '0.847619048', '734', '1', '0', '0.895522388', '0.270833333', '3', '7', '88.875', '29', '5.875', '1']
package org . apache . xpath ; public class SourceTree { public SourceTree ( int root , String url ) { m_root = root ; m_url = url ; } public String m_url ; public int m_root ; } 	1	['1', '1', '0', '1', '2', '0', '1', '0', '1', '2', '12', '0', '0', '0', '1', '0', '0', '9', '0', '0', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; public class ChildIterator extends LocPathIterator { ChildIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int current = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( current ) ; return dtm . getFirstChild ( current ) ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; m_lastFetched = next = ( DTM . NULL == m_lastFetched ) ? m_cdtm . getFirstChild ( m_context ) : m_cdtm . getNextSibling ( m_lastFetched ) ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } public int getAxis ( ) { return org . apache . xml . dtm . Axis . CHILD ; } } 	1	['4', '5', '0', '5', '9', '6', '1', '4', '3', '2', '64', '0', '0', '0.9765625', '0.4375', '1', '6', '15', '4', '1.5', '1']
package org . apache . xml . utils ; public class Trie { public static final int ALPHA_SIZE = 128 ; Node m_Root ; public Trie ( ) { m_Root = new Node ( ) ; } public Object put ( String key , Object value ) { final int len = key . length ( ) ; Node node = m_Root ; for ( int i = 0 ; i < len ; i ++ ) { Node nextNode = node . m_nextChar [ Character . toUpperCase ( key . charAt ( i ) ) ] ; if ( nextNode != null ) { node = nextNode ; } else { for ( ; i < len ; i ++ ) { Node newNode = new Node ( ) ; node . m_nextChar [ Character . toUpperCase ( key . charAt ( i ) ) ] = newNode ; node = newNode ; } break ; } } Object ret = node . m_Value ; node . m_Value = value ; return ret ; } public Object get ( String key ) { final int len = key . length ( ) ; Node node = m_Root ; for ( int i = 0 ; i < len ; i ++ ) { try { node = node . m_nextChar [ Character . toUpperCase ( key . charAt ( i ) ) ] ; } catch ( ArrayIndexOutOfBoundsException e ) { node = null ; } if ( node == null ) return null ; } return node . m_Value ; } class Node { Node ( ) { m_nextChar = new Node [ ALPHA_SIZE ] ; m_Value = null ; } Node m_nextChar [ ] ; Object m_Value ; } } 	1	['3', '1', '0', '2', '8', '0', '2', '1', '3', '0.75', '100', '0', '1', '0', '0.666666667', '0', '0', '31.66666667', '4', '2.3333', '1']
package org . apache . xpath ; import org . apache . xml . utils . QName ; import org . apache . xpath . objects . XObject ; public class Arg { private QName m_qname ; public final QName getQName ( ) { return m_qname ; } public final void setQName ( QName name ) { m_qname = name ; } private XObject m_val ; public final XObject getVal ( ) { return m_val ; } public final void setVal ( XObject val ) { m_val = val ; } public void detach ( ) { if ( null != m_val ) { m_val . allowDetachToRelease ( true ) ; m_val . detach ( ) ; } } private String m_expression ; public String getExpression ( ) { return m_expression ; } public void setExpression ( String expr ) { m_expression = expr ; } private boolean m_isFromWithParam ; public boolean isFromWithParam ( ) { return m_isFromWithParam ; } private boolean m_isVisible ; public boolean isVisible ( ) { return m_isVisible ; } public void setIsVisible ( boolean b ) { m_isVisible = b ; } public Arg ( ) { m_qname = new QName ( "" ) ; ; m_val = null ; m_expression = null ; m_isVisible = true ; m_isFromWithParam = false ; } public Arg ( QName qname , String expression , boolean isFromWithParam ) { m_qname = qname ; m_val = null ; m_expression = expression ; m_isFromWithParam = isFromWithParam ; m_isVisible = ! isFromWithParam ; } public Arg ( QName qname , XObject val ) { m_qname = qname ; m_val = val ; m_isVisible = true ; m_isFromWithParam = false ; m_expression = null ; } public boolean equals ( Object obj ) { if ( obj instanceof QName ) { return m_qname . equals ( obj ) ; } else return super . equals ( obj ) ; } public Arg ( QName qname , XObject val , boolean isFromWithParam ) { m_qname = qname ; m_val = val ; m_isFromWithParam = isFromWithParam ; m_isVisible = ! isFromWithParam ; m_expression = null ; } } 	1	['15', '1', '0', '3', '21', '0', '1', '2', '15', '0.628571429', '158', '1', '2', '0', '0.311111111', '0', '0', '9.2', '2', '0.8667', '1']
package org . apache . xalan . trace ; import org . apache . xalan . transformer . TransformerImpl ; import org . xml . sax . Attributes ; public class GenerateEvent implements java . util . EventListener { public TransformerImpl m_processor ; public int m_eventtype ; public char m_characters [ ] ; public int m_start ; public int m_length ; public String m_name ; public String m_data ; public Attributes m_atts ; public GenerateEvent ( TransformerImpl processor , int eventType ) { m_processor = processor ; m_eventtype = eventType ; } public GenerateEvent ( TransformerImpl processor , int eventType , String name , Attributes atts ) { m_name = name ; m_atts = atts ; m_processor = processor ; m_eventtype = eventType ; } public GenerateEvent ( TransformerImpl processor , int eventType , char ch [ ] , int start , int length ) { m_characters = ch ; m_start = start ; m_length = length ; m_processor = processor ; m_eventtype = eventType ; } public GenerateEvent ( TransformerImpl processor , int eventType , String name , String data ) { m_name = name ; m_data = data ; m_processor = processor ; m_eventtype = eventType ; } public GenerateEvent ( TransformerImpl processor , int eventType , String data ) { m_data = data ; m_processor = processor ; m_eventtype = eventType ; } } 	1	['5', '1', '0', '4', '6', '0', '4', '1', '5', '0.6875', '82', '0', '1', '0', '0.666666667', '0', '0', '13.8', '0', '0', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . w3c . dom . DOMException ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; public class DTMNamedNodeMap implements NamedNodeMap { DTM dtm ; int element ; short m_count = - 1 ; public DTMNamedNodeMap ( DTM dtm , int element ) { this . dtm = dtm ; this . element = element ; } public int getLength ( ) { if ( m_count == - 1 ) { short count = 0 ; for ( int n = dtm . getFirstAttribute ( element ) ; n != - 1 ; n = dtm . getNextAttribute ( n ) ) { ++ count ; } m_count = count ; } return ( int ) m_count ; } public Node getNamedItem ( String name ) { for ( int n = dtm . getFirstAttribute ( element ) ; n != - 1 ; n = dtm . getNextAttribute ( n ) ) { if ( dtm . getNodeName ( n ) . equals ( name ) ) return dtm . getNode ( n ) ; } return null ; } public Node item ( int i ) { int count = 0 ; for ( int n = dtm . getFirstAttribute ( element ) ; n != - 1 ; n = dtm . getNextAttribute ( n ) ) { if ( count == i ) return dtm . getNode ( n ) ; else ++ count ; } return null ; } public Node setNamedItem ( Node newNode ) { throw new DTMException ( DTMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public Node removeNamedItem ( String name ) { throw new DTMException ( DTMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public Node getNamedItemNS ( String namespaceURI , String localName ) { throw new DTMException ( DTMException . NOT_SUPPORTED_ERR ) ; } public Node setNamedItemNS ( Node arg ) throws DOMException { throw new DTMException ( DTMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException { throw new DTMException ( DTMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public class DTMException extends org . w3c . dom . DOMException { public DTMException ( short code , String message ) { super ( code , message ) ; } public DTMException ( short code ) { super ( code , "" ) ; } } } 	1	['9', '1', '0', '3', '16', '24', '2', '2', '9', '0.708333333', '143', '0', '1', '0', '0.4', '0', '0', '14.55555556', '3', '1.5556', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . BoolStack ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; abstract public class SerializerBase implements SerializationHandler , SerializerConstants , org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler { protected void fireEndElem ( String name ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENDELEMENT , name , ( Attributes ) null ) ; } protected void fireCharEvent ( char [ ] chars , int start , int length ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_CHARACTERS , chars , start , length ) ; } protected boolean m_needToCallStartDocument = true ; protected boolean m_startTagOpen = false ; int m_currentElemDepth = 0 ; protected String m_elementName = null ; protected String m_elementLocalName = null ; protected String m_elementURI = null ; protected boolean m_cdataTagOpen = false ; protected AttributesImplSerializer m_attributes = new AttributesImplSerializer ( ) ; protected boolean m_inEntityRef = false ; protected boolean m_inExternalDTD = false ; protected BoolStack m_cdataSectionStates = new BoolStack ( ) ; private String m_doctypeSystem ; private String m_doctypePublic ; boolean m_needToOutputDocTypeDecl = true ; private String m_encoding = null ; protected Stack m_nodeStack ; protected Stack m_prefixStack ; private boolean m_shouldNotWriteXMLHeader = false ; private String m_standalone ; protected boolean m_standaloneWasSpecified = false ; protected boolean m_doIndent = false ; protected int m_indentAmount = 0 ; private String m_version = null ; private String m_mediatype ; private Transformer m_transformer ; protected Vector m_cdataSectionElements = null ; protected NamespaceMappings m_prefixMap ; protected SerializerTrace m_tracer ; protected SourceLocator m_sourceLocator ; protected java . io . Writer m_writer = null ; public void comment ( String data ) throws SAXException { this . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } protected String patchName ( String qname ) { final int lastColon = qname . lastIndexOf ( ':' ) ; if ( lastColon > 0 ) { final int firstColon = qname . indexOf ( ':' ) ; final String prefix = qname . substring ( 0 , firstColon ) ; final String localName = qname . substring ( lastColon + 1 ) ; final String uri = m_prefixMap . lookupNamespace ( prefix ) ; if ( uri != null && uri . length ( ) == 0 ) { return localName ; } else if ( firstColon != lastColon ) { return prefix + ':' + localName ; } } return qname ; } protected static String getLocalName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( col + 1 ) : qname ; } public void setDocumentLocator ( Locator locator ) { return ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_startTagOpen ) { addAttributeAlways ( uri , localName , rawName , type , value ) ; } } public void addAttributeAlways ( String uri , String localName , String rawName , String type , String value ) { int index ; index = m_attributes . getIndex ( rawName ) ; if ( index >= 0 ) { m_attributes . setValue ( index , value ) ; } else { m_attributes . addAttribute ( uri , localName , rawName , type , value ) ; } } public void addAttribute ( String name , final String value ) { if ( m_startTagOpen ) { final String patchedName = patchName ( name ) ; final String localName = getLocalName ( patchedName ) ; final String uri = getNamespaceURI ( patchedName , false ) ; addAttributeAlways ( uri , localName , patchedName , "CDATA" , value ) ; } } public void addAttributes ( Attributes atts ) throws SAXException { int nAtts = atts . getLength ( ) ; for ( int i = 0 ; i < nAtts ; i ++ ) { String uri = atts . getURI ( i ) ; if ( null == uri ) uri = "" ; addAttributeAlways ( uri , atts . getLocalName ( i ) , atts . getQName ( i ) , atts . getType ( i ) , atts . getValue ( i ) ) ; } } public ContentHandler asContentHandler ( ) throws IOException { return this ; } public void endEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( "[dtd]" ) ) m_inExternalDTD = false ; m_inEntityRef = false ; this . fireEndEntity ( name ) ; } public void close ( ) { } protected void initCDATA ( ) { } public String getEncoding ( ) { return m_encoding ; } public void setEncoding ( String m_encoding ) { this . m_encoding = m_encoding ; } public void setOmitXMLDeclaration ( boolean b ) { this . m_shouldNotWriteXMLHeader = b ; } public boolean getOmitXMLDeclaration ( ) { return m_shouldNotWriteXMLHeader ; } public String getDoctypePublic ( ) { return m_doctypePublic ; } public void setDoctypePublic ( String doctypePublic ) { this . m_doctypePublic = doctypePublic ; } public String getDoctypeSystem ( ) { return m_doctypeSystem ; } public void setDoctypeSystem ( String doctypeSystem ) { this . m_doctypeSystem = doctypeSystem ; } public void setDoctype ( String doctypeSystem , String doctypePublic ) { this . m_doctypeSystem = doctypeSystem ; this . m_doctypePublic = doctypePublic ; } public void setStandalone ( String standalone ) { if ( standalone != null ) { m_standaloneWasSpecified = true ; setStandaloneInternal ( standalone ) ; } } protected void setStandaloneInternal ( String standalone ) { if ( "yes" . equals ( standalone ) ) m_standalone = "yes" ; else m_standalone = "no" ; } public String getStandalone ( ) { return m_standalone ; } public boolean getIndent ( ) { return m_doIndent ; } public String getMediaType ( ) { return m_mediatype ; } public String getVersion ( ) { return m_version ; } public void setVersion ( String version ) { m_version = version ; } public void setMediaType ( String mediaType ) { m_mediatype = mediaType ; } public int getIndentAmount ( ) { return m_indentAmount ; } public void setIndentAmount ( int m_indentAmount ) { this . m_indentAmount = m_indentAmount ; } public void setIndent ( boolean doIndent ) { m_doIndent = doIndent ; } public void namespaceAfterStartElement ( String uri , String prefix ) throws SAXException { } public DOMSerializer asDOMSerializer ( ) throws IOException { return this ; } protected void pushCdataSectionState ( ) { boolean b ; if ( null != m_cdataSectionElements ) { b = false ; if ( m_elementLocalName == null ) m_elementLocalName = getLocalName ( m_elementName ) ; if ( m_elementURI == null ) { String prefix = getPrefixPart ( m_elementName ) ; if ( prefix != null ) m_elementURI = m_prefixMap . lookupNamespace ( prefix ) ; } if ( ( null != m_elementURI ) && m_elementURI . length ( ) == 0 ) m_elementURI = null ; int nElems = m_cdataSectionElements . size ( ) ; for ( int i = 0 ; i < nElems ; i += 2 ) { String uri = ( String ) m_cdataSectionElements . elementAt ( i ) ; String loc = ( String ) m_cdataSectionElements . elementAt ( i + 1 ) ; if ( loc . equals ( m_elementLocalName ) && subPartMatch ( m_elementURI , uri ) ) { b = true ; break ; } } } else { b = m_cdataSectionStates . peekOrFalse ( ) ; } m_cdataSectionStates . push ( b ) ; } private static final boolean subPartMatch ( String p , String t ) { return ( p == t ) || ( ( null != p ) && ( p . equals ( t ) ) ) ; } protected static final String getPrefixPart ( String qname ) { final int col = qname . indexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( 0 , col ) : null ; } public NamespaceMappings getNamespaceMappings ( ) { return m_prefixMap ; } public String getPrefix ( String namespaceURI ) { String prefix = m_prefixMap . lookupPrefix ( namespaceURI ) ; return prefix ; } public String getNamespaceURI ( String qname , boolean isElement ) { String uri = EMPTYSTRING ; int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col > 0 ) ? qname . substring ( 0 , col ) : EMPTYSTRING ; if ( ! EMPTYSTRING . equals ( prefix ) || isElement ) { if ( m_prefixMap != null ) { uri = m_prefixMap . lookupNamespace ( prefix ) ; if ( uri == null && ! prefix . equals ( XMLNS_PREFIX ) ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NAMESPACE_PREFIX , new Object [ ] { qname . substring ( 0 , col ) } ) ) ; } } } return uri ; } public String getNamespaceURIFromPrefix ( String prefix ) { String uri = null ; if ( m_prefixMap != null ) uri = m_prefixMap . lookupNamespace ( prefix ) ; return uri ; } public void entityReference ( String name ) throws org . xml . sax . SAXException { flushPending ( ) ; startEntity ( name ) ; endEntity ( name ) ; fireEntityReference ( name ) ; } public void setTransformer ( Transformer t ) { m_transformer = t ; if ( ( m_transformer instanceof SerializerTrace ) && ( ( ( SerializerTrace ) m_transformer ) . hasTraceListeners ( ) ) ) { m_tracer = ( SerializerTrace ) m_transformer ; } else { m_tracer = null ; } } public Transformer getTransformer ( ) { return m_transformer ; } public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { flushPending ( ) ; String data = node . getNodeValue ( ) ; char [ ] ch = null ; int length = 0 ; if ( data != null ) { ch = data . toCharArray ( ) ; length = data . length ( ) ; characters ( ch , 0 , length ) ; } } public void error ( SAXParseException exc ) throws SAXException { } public void fatalError ( SAXParseException exc ) throws SAXException { m_startTagOpen = false ; } public void warning ( SAXParseException exc ) throws SAXException { } protected void fireStartEntity ( String name ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENTITYREF , name ) ; } private void flushMyWriter ( ) { if ( m_writer != null ) { try { m_writer . flush ( ) ; } catch ( IOException ioe ) { } } } protected void fireCDATAEvent ( char [ ] chars , int start , int length ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_CDATA , chars , start , length ) ; } protected void fireCommentEvent ( char [ ] chars , int start , int length ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_COMMENT , new String ( chars , start , length ) ) ; } public void fireEndEntity ( String name ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; } protected void fireStartDoc ( ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_STARTDOCUMENT ) ; } protected void fireEndDoc ( ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENDDOCUMENT ) ; } protected void fireStartElem ( String elemName ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_STARTELEMENT , elemName , m_attributes ) ; } protected void fireEscapingEvent ( String name , String data ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_PI , name , data ) ; } protected void fireEntityReference ( String name ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENTITYREF , name , ( Attributes ) null ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; return ; } protected void startDocumentInternal ( ) throws org . xml . sax . SAXException { this . fireStartDoc ( ) ; } public void setSourceLocator ( SourceLocator locator ) { m_sourceLocator = locator ; } public void setNamespaceMappings ( NamespaceMappings mappings ) { m_prefixMap = mappings ; } } 	1	['65', '1', '3', '12', '109', '1852', '3', '9', '46', '0.965104167', '842', '0.933333333', '4', '0', '0.13974359', '0', '0', '11.49230769', '9', '1.4615', '2']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; public class SelfIteratorNoPredicate extends LocPathIterator { SelfIteratorNoPredicate ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; } public SelfIteratorNoPredicate ( ) throws javax . xml . transform . TransformerException { super ( null ) ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; DTM dtm = m_cdtm ; m_lastFetched = next = ( DTM . NULL == m_lastFetched ) ? m_context : DTM . NULL ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return xctxt . getCurrentNode ( ) ; } public int getLastPos ( XPathContext xctxt ) { return 1 ; } } 	1	['5', '5', '0', '8', '8', '10', '3', '5', '4', '2', '57', '0', '0', '0.9765625', '0.45', '1', '4', '10.4', '4', '1.2', '1']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . MethodGen ; import org . apache . bcel . generic . Type ; public class MethodGenerator extends MethodGen implements org . apache . xalan . xsltc . compiler . Constants { protected static final int INVALID_INDEX = - 1 ; private static final String START_ELEMENT_SIG = "(" + STRING_SIG + ")V" ; private static final String END_ELEMENT_SIG = START_ELEMENT_SIG ; private InstructionList _mapTypeSub ; private static final int DOM_INDEX = 1 ; private static final int ITERATOR_INDEX = 2 ; private static final int HANDLER_INDEX = 3 ; private Instruction _iloadCurrent ; private Instruction _istoreCurrent ; private final Instruction _astoreHandler ; private final Instruction _aloadHandler ; private final Instruction _astoreIterator ; private final Instruction _aloadIterator ; private final Instruction _aloadDom ; private final Instruction _astoreDom ; private final Instruction _startElement ; private final Instruction _endElement ; private final Instruction _startDocument ; private final Instruction _endDocument ; private final Instruction _attribute ; private final Instruction _namespace ; private final Instruction _setStartNode ; private final Instruction _reset ; private final Instruction _nextNode ; private final Instruction _nextNodeId ; private SlotAllocator _slotAllocator ; private boolean _allocatorInit = false ; public MethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cpg ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cpg ) ; _astoreHandler = new ASTORE ( HANDLER_INDEX ) ; _aloadHandler = new ALOAD ( HANDLER_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; _aloadDom = new ALOAD ( DOM_INDEX ) ; _astoreDom = new ASTORE ( DOM_INDEX ) ; final int startElement = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "startElement" , START_ELEMENT_SIG ) ; _startElement = new INVOKEINTERFACE ( startElement , 2 ) ; final int endElement = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "endElement" , END_ELEMENT_SIG ) ; _endElement = new INVOKEINTERFACE ( endElement , 2 ) ; final int attribute = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "addAttribute" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; _attribute = new INVOKEINTERFACE ( attribute , 3 ) ; final int namespace = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "namespaceAfterStartElement" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; _namespace = new INVOKEINTERFACE ( namespace , 3 ) ; int index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "startDocument" , "()V" ) ; _startDocument = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "endDocument" , "()V" ) ; _endDocument = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , SET_START_NODE , SET_START_NODE_SIG ) ; _setStartNode = new INVOKEINTERFACE ( index , 2 ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , "reset" , "()" + NODE_ITERATOR_SIG ) ; _reset = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , NEXT , NEXT_SIG ) ; _nextNode = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( "org.apache.xalan.xsltc.dom.SAXImpl$SingletonNodeIDIterator" , NEXTID , NEXT_SIG ) ; _nextNodeId = new INVOKEINTERFACE ( index , 1 ) ; _slotAllocator = new SlotAllocator ( ) ; _slotAllocator . initialize ( getLocalVariables ( ) ) ; _allocatorInit = true ; } public LocalVariableGen addLocalVariable ( String name , Type type , InstructionHandle start , InstructionHandle end ) { return ( _allocatorInit ) ? addLocalVariable2 ( name , type , start ) : super . addLocalVariable ( name , type , start , end ) ; } public LocalVariableGen addLocalVariable2 ( String name , Type type , InstructionHandle start ) { return super . addLocalVariable ( name , type , _slotAllocator . allocateSlot ( type ) , start , null ) ; } public void removeLocalVariable ( LocalVariableGen lvg ) { _slotAllocator . releaseSlot ( lvg ) ; super . removeLocalVariable ( lvg ) ; } public Instruction loadDOM ( ) { return _aloadDom ; } public Instruction storeDOM ( ) { return _astoreDom ; } public Instruction storeHandler ( ) { return _astoreHandler ; } public Instruction loadHandler ( ) { return _aloadHandler ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public final Instruction setStartNode ( ) { return _setStartNode ; } public final Instruction reset ( ) { return _reset ; } public final Instruction nextNode ( ) { return _nextNode ; } public final Instruction nextNodeId ( ) { return _nextNodeId ; } public final Instruction startElement ( ) { return _startElement ; } public final Instruction endElement ( ) { return _endElement ; } public final Instruction startDocument ( ) { return _startDocument ; } public final Instruction endDocument ( ) { return _endDocument ; } public final Instruction attribute ( ) { return _attribute ; } public final Instruction namespace ( ) { return _namespace ; } public Instruction loadCurrentNode ( ) { if ( _iloadCurrent == null ) { int idx = getLocalIndex ( "current" ) ; if ( idx > 0 ) _iloadCurrent = new ILOAD ( idx ) ; else _iloadCurrent = new ICONST ( 0 ) ; } return _iloadCurrent ; } public Instruction storeCurrentNode ( ) { return _istoreCurrent != null ? _istoreCurrent : ( _istoreCurrent = new ISTORE ( getLocalIndex ( "current" ) ) ) ; } public Instruction loadContextNode ( ) { return loadCurrentNode ( ) ; } public Instruction storeContextNode ( ) { return storeCurrentNode ( ) ; } public int getLocalIndex ( String name ) { return getLocalVariable ( name ) . getIndex ( ) ; } public LocalVariableGen getLocalVariable ( String name ) { final LocalVariableGen [ ] vars = getLocalVariables ( ) ; for ( int i = 0 ; i < vars . length ; i ++ ) if ( vars [ i ] . getName ( ) . equals ( name ) ) return vars [ i ] ; return null ; } public void setMaxLocals ( ) { int maxLocals = super . getMaxLocals ( ) ; int prevLocals = maxLocals ; final LocalVariableGen [ ] localVars = super . getLocalVariables ( ) ; if ( localVars != null ) { if ( localVars . length > maxLocals ) maxLocals = localVars . length ; } if ( maxLocals < 5 ) maxLocals = 5 ; super . setMaxLocals ( maxLocals ) ; } } 	1	['27', '4', '6', '137', '49', '311', '122', '15', '27', '0.978632479', '432', '1', '1', '0.788617886', '0.159259259', '1', '2', '14', '4', '1.2963', '1']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncBoolean extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_arg0 . execute ( xctxt ) . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	1	['2', '4', '0', '5', '5', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; final class VariableRef extends VariableRefBase { public VariableRef ( Variable variable ) { super ( variable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _type . implementedAsMethod ( ) ) return ; final String name = _variable . getVariable ( ) ; final String signature = _type . toSignature ( ) ; if ( _variable . isLocal ( ) ) { if ( classGen . isExternal ( ) ) { Closure variableClosure = _closure ; while ( variableClosure != null ) { if ( variableClosure . inInnerClass ( ) ) break ; variableClosure = variableClosure . getParentClosure ( ) ; } if ( variableClosure != null ) { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( variableClosure . getInnerClassName ( ) , name , signature ) ) ) ; } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { final String className = classGen . getClassName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new GETFIELD ( cpg . addFieldref ( className , name , signature ) ) ) ; } if ( _variable . getType ( ) instanceof NodeSetType ) { final int clone = cpg . addInterfaceMethodref ( NODE_ITERATOR , "cloneIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( clone , 1 ) ) ; } } } 	1	['2', '4', '0', '18', '25', '1', '2', '16', '2', '2', '137', '0', '0', '0.987012987', '0.625', '2', '3', '67.5', '9', '4.5', '1']
package org . apache . xalan . templates ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . processor . StylesheetHandler ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; public class AVT implements java . io . Serializable , XSLTVisitable { private String m_simpleString = null ; private Vector m_parts = null ; private String m_rawName ; public String getRawName ( ) { return m_rawName ; } public void setRawName ( String rawName ) { m_rawName = rawName ; } private String m_name ; public String getName ( ) { return m_name ; } public void setName ( String name ) { m_name = name ; } private String m_uri ; public String getURI ( ) { return m_uri ; } public void setURI ( String uri ) { m_uri = uri ; } public AVT ( StylesheetHandler handler , String uri , String name , String rawName , String stringedValue , ElemTemplateElement owner ) throws javax . xml . transform . TransformerException { m_uri = uri ; m_name = name ; m_rawName = rawName ; StringTokenizer tokenizer = new StringTokenizer ( stringedValue , "{}\"\'" , true ) ; int nTokens = tokenizer . countTokens ( ) ; if ( nTokens < 2 ) { m_simpleString = stringedValue ; } else { FastStringBuffer buffer = StringBufferPool . get ( ) ; FastStringBuffer exprBuffer = StringBufferPool . get ( ) ; try { m_parts = new Vector ( nTokens + 1 ) ; String t = null ; String lookahead = null ; String error = null ; while ( tokenizer . hasMoreTokens ( ) ) { if ( lookahead != null ) { t = lookahead ; lookahead = null ; } else t = tokenizer . nextToken ( ) ; if ( t . length ( ) == 1 ) { switch ( t . charAt ( 0 ) ) { case ( '\"' ) : case ( '\'' ) : { buffer . append ( t ) ; break ; } case ( '{' ) : { try { lookahead = tokenizer . nextToken ( ) ; if ( lookahead . equals ( "{" ) ) { buffer . append ( lookahead ) ; lookahead = null ; break ; } else { if ( buffer . length ( ) > 0 ) { m_parts . addElement ( new AVTPartSimple ( buffer . toString ( ) ) ) ; buffer . setLength ( 0 ) ; } exprBuffer . setLength ( 0 ) ; while ( null != lookahead ) { if ( lookahead . length ( ) == 1 ) { switch ( lookahead . charAt ( 0 ) ) { case '\'' : case '\"' : { exprBuffer . append ( lookahead ) ; String quote = lookahead ; lookahead = tokenizer . nextToken ( ) ; while ( ! lookahead . equals ( quote ) ) { exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; } exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; break ; } case '{' : { error = XSLMessages . createMessage ( XSLTErrorResources . ER_NO_CURLYBRACE , null ) ; lookahead = null ; break ; } case '}' : { buffer . setLength ( 0 ) ; XPath xpath = handler . createXPath ( exprBuffer . toString ( ) , owner ) ; m_parts . addElement ( new AVTPartXPath ( xpath ) ) ; lookahead = null ; break ; } default : { exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; } } } else { exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; } } if ( error != null ) { break ; } } break ; } catch ( java . util . NoSuchElementException ex ) { error = XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { name , stringedValue } ) ; break ; } } case ( '}' ) : { lookahead = tokenizer . nextToken ( ) ; if ( lookahead . equals ( "}" ) ) { buffer . append ( lookahead ) ; lookahead = null ; } else { try { handler . warn ( XSLTErrorResources . WG_FOUND_CURLYBRACE , null ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } buffer . append ( "}" ) ; } break ; } default : { buffer . append ( t ) ; } } } else { buffer . append ( t ) ; } if ( null != error ) { try { handler . warn ( XSLTErrorResources . WG_ATTR_TEMPLATE , new Object [ ] { error } ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } break ; } } if ( buffer . length ( ) > 0 ) { m_parts . addElement ( new AVTPartSimple ( buffer . toString ( ) ) ) ; buffer . setLength ( 0 ) ; } } finally { StringBufferPool . free ( buffer ) ; StringBufferPool . free ( exprBuffer ) ; } } if ( null == m_parts && ( null == m_simpleString ) ) { m_simpleString = "" ; } } public String getSimpleString ( ) { if ( null != m_simpleString ) { return m_simpleString ; } else if ( null != m_parts ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { buf . setLength ( 0 ) ; int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; buf . append ( part . getSimpleString ( ) ) ; } s = buf . toString ( ) ; } finally { StringBufferPool . free ( buf ) ; } return s ; } else { return "" ; } } public String evaluate ( XPathContext xctxt , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException { FastStringBuffer buf = StringBufferPool . get ( ) ; try { if ( null != m_simpleString ) { return m_simpleString ; } else if ( null != m_parts ) { buf . setLength ( 0 ) ; int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . evaluate ( xctxt , buf , context , nsNode ) ; } return buf . toString ( ) ; } else { return "" ; } } finally { StringBufferPool . free ( buf ) ; } } public boolean isContextInsensitive ( ) { return null != m_simpleString ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_parts ) { int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; if ( part . canTraverseOutsideSubtree ( ) ) return true ; } } return false ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { if ( null != m_parts ) { int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . fixupVariables ( vars , globalsSize ) ; } } } public void callVisitors ( XSLTVisitor visitor ) { if ( visitor . visitAVT ( this ) && ( null != m_parts ) ) { int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . callVisitors ( visitor ) ; } } } public boolean isSimple ( ) { return m_simpleString != null ; } } 	1	['14', '1', '0', '23', '44', '29', '11', '13', '14', '0.769230769', '546', '1', '0', '0', '0.206349206', '0', '0', '37.64285714', '4', '1.8571', '1']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncFalse extends Function { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return XBoolean . S_FALSE ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	1	['3', '3', '0', '4', '4', '3', '0', '4', '3', '2', '9', '0', '0', '0.95', '0.5', '1', '6', '2', '1', '0.6667', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class LiteralElement extends Instruction { private String _name ; private LiteralElement _literalElemParent ; private Vector _attributeElements = null ; private Hashtable _accessedPrefixes = null ; private final static String XMLNS_STRING = "xmlns" ; public QName getName ( ) { return _qname ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "LiteralElement name = " + _name ) ; displayContents ( indent + IndentIncrement ) ; } private String accessedNamespace ( String prefix ) { if ( _accessedPrefixes == null ) return ( null ) ; else return ( ( String ) _accessedPrefixes . get ( prefix ) ) ; } public void registerNamespace ( String prefix , String uri , SymbolTable stable , boolean declared ) { if ( _literalElemParent != null ) { final String parentUri = _literalElemParent . accessedNamespace ( prefix ) ; if ( parentUri == null ) { _literalElemParent . registerNamespace ( prefix , uri , stable , declared ) ; return ; } if ( parentUri . equals ( uri ) ) return ; } if ( _accessedPrefixes == null ) { _accessedPrefixes = new Hashtable ( ) ; } else { if ( ! declared ) { final String old = ( String ) _accessedPrefixes . get ( prefix ) ; if ( old != null ) { if ( old . equals ( uri ) ) return ; else prefix = stable . generateNamespacePrefix ( ) ; } } } if ( ! prefix . equals ( "xml" ) ) { _accessedPrefixes . put ( prefix , uri ) ; } } private String translateQName ( QName qname , SymbolTable stable ) { String localname = qname . getLocalPart ( ) ; String prefix = qname . getPrefix ( ) ; if ( prefix == null ) prefix = Constants . EMPTYSTRING ; else if ( prefix . equals ( XMLNS_STRING ) ) return ( XMLNS_STRING ) ; final String alternative = stable . lookupPrefixAlias ( prefix ) ; if ( alternative != null ) { stable . excludeNamespaces ( prefix ) ; prefix = alternative ; } String uri = lookupNamespace ( prefix ) ; if ( uri == null ) return ( localname ) ; registerNamespace ( prefix , uri , stable , false ) ; if ( prefix != Constants . EMPTYSTRING ) return ( prefix + ":" + localname ) ; else return ( localname ) ; } public void addAttribute ( SyntaxTreeNode attribute ) { if ( _attributeElements == null ) { _attributeElements = new Vector ( 2 ) ; } _attributeElements . add ( attribute ) ; } public void setFirstAttribute ( SyntaxTreeNode attribute ) { if ( _attributeElements == null ) { _attributeElements = new Vector ( 2 ) ; } _attributeElements . insertElementAt ( attribute , 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _attributeElements != null ) { final int count = _attributeElements . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode node = ( SyntaxTreeNode ) _attributeElements . elementAt ( i ) ; node . typeCheck ( stable ) ; } } typeCheckContents ( stable ) ; return Type . Void ; } public Enumeration getNamespaceScope ( SyntaxTreeNode node ) { Hashtable all = new Hashtable ( ) ; while ( node != null ) { Hashtable mapping = node . getPrefixMapping ( ) ; if ( mapping != null ) { Enumeration prefixes = mapping . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; if ( ! all . containsKey ( prefix ) ) { all . put ( prefix , mapping . get ( prefix ) ) ; } } } node = node . getParent ( ) ; } return ( all . keys ( ) ) ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; stable . setCurrentNode ( this ) ; SyntaxTreeNode _literalElemParent = getParent ( ) ; while ( _literalElemParent != null && ! ( _literalElemParent instanceof LiteralElement ) ) { _literalElemParent = _literalElemParent . getParent ( ) ; } if ( ! ( _literalElemParent instanceof LiteralElement ) ) { _literalElemParent = null ; } _name = translateQName ( _qname , stable ) ; final int count = _attributes . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final QName qname = parser . getQName ( _attributes . getQName ( i ) ) ; final String uri = qname . getNamespace ( ) ; final String val = _attributes . getValue ( i ) ; if ( qname == parser . getUseAttributeSets ( ) ) { setFirstAttribute ( new UseAttributeSets ( val , parser ) ) ; } else if ( qname == parser . getExtensionElementPrefixes ( ) ) { stable . excludeNamespaces ( val ) ; } else if ( qname == parser . getExcludeResultPrefixes ( ) ) { stable . excludeNamespaces ( val ) ; } else { final String prefix = qname . getPrefix ( ) ; if ( prefix != null && prefix . equals ( XMLNS_PREFIX ) || prefix == null && qname . getLocalPart ( ) . equals ( "xmlns" ) || uri != null && uri . equals ( XSLT_URI ) ) { continue ; } final String name = translateQName ( qname , stable ) ; LiteralAttribute attr = new LiteralAttribute ( name , val , parser ) ; addAttribute ( attr ) ; attr . setParent ( this ) ; attr . parseContents ( parser ) ; } } final Enumeration include = getNamespaceScope ( this ) ; while ( include . hasMoreElements ( ) ) { final String prefix = ( String ) include . nextElement ( ) ; if ( ! prefix . equals ( "xml" ) ) { final String uri = lookupNamespace ( prefix ) ; if ( uri != null && ! stable . isExcludedNamespace ( uri ) ) { registerNamespace ( prefix , uri , stable , true ) ; } } } parseChildren ( parser ) ; for ( int i = 0 ; i < count ; i ++ ) { final QName qname = parser . getQName ( _attributes . getQName ( i ) ) ; final String val = _attributes . getValue ( i ) ; if ( qname == parser . getExtensionElementPrefixes ( ) ) { stable . unExcludeNamespaces ( val ) ; } else if ( qname == parser . getExcludeResultPrefixes ( ) ) { stable . unExcludeNamespaces ( val ) ; } } } protected boolean contextDependent ( ) { return dependentContents ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _name ) ) ; il . append ( DUP2 ) ; il . append ( methodGen . startElement ( ) ) ; for ( int i = 0 ; i < elementCount ( ) ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) elementAt ( i ) ; if ( item instanceof Variable ) { item . translate ( classGen , methodGen ) ; removeElement ( item ) ; } } if ( _accessedPrefixes != null ) { boolean declaresDefaultNS = false ; Enumeration e = _accessedPrefixes . keys ( ) ; while ( e . hasMoreElements ( ) ) { final String prefix = ( String ) e . nextElement ( ) ; final String uri = ( String ) _accessedPrefixes . get ( prefix ) ; if ( uri != Constants . EMPTYSTRING || prefix != Constants . EMPTYSTRING ) { if ( prefix == Constants . EMPTYSTRING ) { declaresDefaultNS = true ; } il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , prefix ) ) ; il . append ( new PUSH ( cpg , uri ) ) ; il . append ( methodGen . namespace ( ) ) ; } } if ( ! declaresDefaultNS && ( _parent instanceof XslElement ) && ( ( XslElement ) _parent ) . declaresDefaultNS ( ) ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; il . append ( methodGen . namespace ( ) ) ; } } if ( _attributeElements != null ) { final int count = _attributeElements . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode node = ( SyntaxTreeNode ) _attributeElements . elementAt ( i ) ; node . translate ( classGen , methodGen ) ; } } translateContents ( classGen , methodGen ) ; il . append ( methodGen . endElement ( ) ) ; } } 	1	['13', '3', '0', '25', '77', '40', '5', '21', '9', '0.783333333', '663', '1', '1', '0.823529412', '0.207692308', '2', '10', '49.61538462', '18', '4.5385', '2']
package org . apache . xpath ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . NodeVector ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class NodeSetDTM extends NodeVector implements DTMIterator , Cloneable { public NodeSetDTM ( DTMManager dtmManager ) { super ( ) ; m_manager = dtmManager ; } public NodeSetDTM ( int blocksize , int dummy , DTMManager dtmManager ) { super ( blocksize ) ; m_manager = dtmManager ; } public NodeSetDTM ( NodeSetDTM nodelist ) { super ( ) ; m_manager = nodelist . getDTMManager ( ) ; m_root = nodelist . getRoot ( ) ; addNodes ( ( DTMIterator ) nodelist ) ; } public NodeSetDTM ( DTMIterator ni ) { super ( ) ; m_manager = ni . getDTMManager ( ) ; m_root = ni . getRoot ( ) ; addNodes ( ni ) ; } public NodeSetDTM ( NodeIterator iterator , XPathContext xctxt ) { super ( ) ; Node node ; m_manager = xctxt . getDTMManager ( ) ; while ( null != ( node = iterator . nextNode ( ) ) ) { int handle = xctxt . getDTMHandleFromNode ( node ) ; addNodeInDocOrder ( handle , xctxt ) ; } } public NodeSetDTM ( NodeList nodeList , XPathContext xctxt ) { super ( ) ; m_manager = xctxt . getDTMManager ( ) ; int n = nodeList . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Node node = nodeList . item ( i ) ; int handle = xctxt . getDTMHandleFromNode ( node ) ; addNode ( handle ) ; } } public NodeSetDTM ( int node , DTMManager dtmManager ) { super ( ) ; m_manager = dtmManager ; addNode ( node ) ; } public void setEnvironment ( Object environment ) { } public int getRoot ( ) { if ( DTM . NULL == m_root ) { if ( size ( ) > 0 ) return item ( 0 ) ; else return DTM . NULL ; } else return m_root ; } public void setRoot ( int context , Object environment ) { } public Object clone ( ) throws CloneNotSupportedException { NodeSetDTM clone = ( NodeSetDTM ) super . clone ( ) ; return clone ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { NodeSetDTM clone = ( NodeSetDTM ) clone ( ) ; clone . reset ( ) ; return clone ; } public void reset ( ) { m_next = 0 ; } public int getWhatToShow ( ) { return DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ; } public DTMFilter getFilter ( ) { return null ; } public boolean getExpandEntityReferences ( ) { return true ; } public DTM getDTM ( int nodeHandle ) { return m_manager . getDTM ( nodeHandle ) ; } DTMManager m_manager ; public DTMManager getDTMManager ( ) { return m_manager ; } public int nextNode ( ) { if ( ( m_next ) < this . size ( ) ) { int next = this . elementAt ( m_next ) ; m_next ++ ; return next ; } else return DTM . NULL ; } public int previousNode ( ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_ITERATE , null ) ) ; if ( ( m_next - 1 ) > 0 ) { m_next -- ; return this . elementAt ( m_next ) ; } else return DTM . NULL ; } public void detach ( ) { } public void allowDetachToRelease ( boolean allowRelease ) { } public boolean isFresh ( ) { return ( m_next == 0 ) ; } public void runTo ( int index ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_INDEX , null ) ) ; if ( ( index >= 0 ) && ( m_next < m_firstFree ) ) m_next = index ; else m_next = m_firstFree - 1 ; } public int item ( int index ) { runTo ( index ) ; return this . elementAt ( index ) ; } public int getLength ( ) { runTo ( - 1 ) ; return this . size ( ) ; } public void addNode ( int n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; this . addElement ( n ) ; } public void insertNode ( int n , int pos ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; insertElementAt ( n , pos ) ; } public void removeNode ( int n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; this . removeElement ( n ) ; } public void addNodes ( DTMIterator iterator ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; if ( null != iterator ) { int obj ; while ( DTM . NULL != ( obj = iterator . nextNode ( ) ) ) { addElement ( obj ) ; } } } public void addNodesInDocOrder ( DTMIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int node ; while ( DTM . NULL != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } } public int addNodeInDocOrder ( int node , boolean test , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int insertIndex = - 1 ; if ( test ) { int size = size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { int child = elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } DTM dtm = support . getDTM ( node ) ; if ( ! dtm . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; insertElementAt ( node , insertIndex ) ; } } else { insertIndex = this . size ( ) ; boolean foundit = false ; for ( int i = 0 ; i < insertIndex ; i ++ ) { if ( i == node ) { foundit = true ; break ; } } if ( ! foundit ) addElement ( node ) ; } return insertIndex ; } public int addNodeInDocOrder ( int node , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; return addNodeInDocOrder ( node , true , support ) ; } public int size ( ) { return super . size ( ) ; } public void addElement ( int value ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . addElement ( value ) ; } public void insertElementAt ( int value , int at ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . insertElementAt ( value , at ) ; } public void appendNodes ( NodeVector nodes ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . appendNodes ( nodes ) ; } public void removeAllElements ( ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . removeAllElements ( ) ; } public boolean removeElement ( int s ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; return super . removeElement ( s ) ; } public void removeElementAt ( int i ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . removeElementAt ( i ) ; } public void setElementAt ( int node , int index ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . setElementAt ( node , index ) ; } public void setItem ( int node , int index ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . setElementAt ( node , index ) ; } public int elementAt ( int i ) { runTo ( i ) ; return super . elementAt ( i ) ; } public boolean contains ( int s ) { runTo ( - 1 ) ; return super . contains ( s ) ; } public int indexOf ( int elem , int index ) { runTo ( - 1 ) ; return super . indexOf ( elem , index ) ; } public int indexOf ( int elem ) { runTo ( - 1 ) ; return super . indexOf ( elem ) ; } transient protected int m_next = 0 ; public int getCurrentPos ( ) { return m_next ; } public void setCurrentPos ( int i ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_INDEX , null ) ) ; m_next = i ; } public int getCurrentNode ( ) { if ( ! m_cacheNodes ) throw new RuntimeException ( "This NodeSetDTM can not do indexing or counting functions!" ) ; int saved = m_next ; int current = ( m_next > 0 ) ? m_next - 1 : m_next ; int n = ( current < m_firstFree ) ? elementAt ( current ) : DTM . NULL ; m_next = saved ; return n ; } transient protected boolean m_mutable = true ; transient protected boolean m_cacheNodes = true ; protected int m_root = DTM . NULL ; public boolean getShouldCacheNodes ( ) { return m_cacheNodes ; } public void setShouldCacheNodes ( boolean b ) { if ( ! isFresh ( ) ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_CALL_SETSHOULDCACHENODE , null ) ) ; m_cacheNodes = b ; m_mutable = true ; } public boolean isMutable ( ) { return m_mutable ; } transient private int m_last = 0 ; public int getLast ( ) { return m_last ; } public void setLast ( int last ) { m_last = last ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } } 	1	['56', '2', '2', '25', '84', '714', '18', '7', '56', '0.739393939', '839', '0.833333333', '1', '0.363636364', '0.160714286', '1', '4', '13.875', '9', '1.5714', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionNamespaceSupport ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class ElemExsltFunction extends ElemTemplate { private boolean m_isResultSet = false ; private XObject m_result ; private int m_callerFrameSize = 0 ; public int getXSLToken ( ) { return Constants . EXSLT_ELEMNAME_FUNCTION ; } public String getNodeName ( ) { return Constants . EXSLT_ELEMNAME_FUNCTION_STRING ; } public void execute ( TransformerImpl transformer , XObject [ ] args ) throws TransformerException { m_isResultSet = false ; m_result = null ; XPathContext xctxt = transformer . getXPathContext ( ) ; VariableStack vars = xctxt . getVarStack ( ) ; int oldStackFrame = vars . getStackFrame ( ) ; vars . setStackFrame ( m_callerFrameSize + oldStackFrame ) ; NodeList children = this . getChildNodes ( ) ; int numparams = 0 ; for ( int i = 0 ; i < args . length ; i ++ ) { Node child = children . item ( i ) ; if ( children . item ( i ) instanceof ElemParam ) { numparams ++ ; ElemParam param = ( ElemParam ) children . item ( i ) ; vars . setLocalVariable ( param . getIndex ( ) , args [ i ] ) ; } } if ( numparams < args . length ) throw new TransformerException ( "function called with too many args" ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformer . executeChildTemplates ( this , true ) ; vars . setStackFrame ( oldStackFrame ) ; m_callerFrameSize = 0 ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; String namespace = getName ( ) . getNamespace ( ) ; String handlerClass = "org.apache.xalan.extensions.ExtensionHandlerExsltFunction" ; Object [ ] args = { namespace , sroot } ; ExtensionNamespaceSupport extNsSpt = new ExtensionNamespaceSupport ( namespace , handlerClass , args ) ; sroot . getExtensionNamespacesManager ( ) . registerExtension ( extNsSpt ) ; if ( ! ( namespace . equals ( Constants . S_EXSLT_FUNCTIONS_URL ) ) ) { namespace = Constants . S_EXSLT_FUNCTIONS_URL ; args = new Object [ ] { namespace , sroot } ; extNsSpt = new ExtensionNamespaceSupport ( namespace , handlerClass , args ) ; sroot . getExtensionNamespacesManager ( ) . registerExtension ( extNsSpt ) ; } } public XObject getResult ( ) { return m_result ; } public void setResult ( XObject result ) { m_isResultSet = true ; m_result = result ; } public boolean isResultSet ( ) { return m_isResultSet ; } public void clearResult ( ) { m_isResultSet = false ; m_result = null ; } public void setCallerFrameSize ( int callerFrameSize ) { m_callerFrameSize = callerFrameSize ; } } 	1	['10', '4', '0', '16', '31', '15', '4', '12', '10', '0.666666667', '198', '1', '1', '0.960176991', '0.25', '4', '7', '18.5', '1', '0.9', '3']
package org . apache . xpath . operations ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . QName ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . axes . PathComponent ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class Variable extends Expression implements PathComponent { private boolean m_fixUpWasCalled = false ; protected QName m_qname ; protected int m_index ; public void setIndex ( int index ) { m_index = index ; } public int getIndex ( ) { return m_index ; } public void setIsGlobal ( boolean isGlobal ) { m_isGlobal = isGlobal ; } public boolean getGlobal ( ) { return m_isGlobal ; } protected boolean m_isGlobal = false ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_fixUpWasCalled = true ; int sz = vars . size ( ) ; for ( int i = vars . size ( ) - 1 ; i >= 0 ; i -- ) { QName qn = ( QName ) vars . elementAt ( i ) ; if ( qn . equals ( m_qname ) ) { if ( i < globalsSize ) { m_isGlobal = true ; m_index = i ; } else { m_index = i - globalsSize ; } return ; } } java . lang . String msg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_COULD_NOT_FIND_VAR , new Object [ ] { m_qname . toString ( ) } ) ; TransformerException te = new TransformerException ( msg , this ) ; throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } public void setQName ( QName qname ) { m_qname = qname ; } public QName getQName ( ) { return m_qname ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt , false ) ; } public XObject execute ( XPathContext xctxt , boolean destructiveOK ) throws javax . xml . transform . TransformerException { org . apache . xml . utils . PrefixResolver xprefixResolver = xctxt . getNamespaceContext ( ) ; if ( m_fixUpWasCalled ) { XObject result ; if ( m_isGlobal ) result = xctxt . getVarStack ( ) . getGlobalVariable ( xctxt , m_index , destructiveOK ) ; else result = xctxt . getVarStack ( ) . getLocalVariable ( xctxt , m_index , destructiveOK ) ; if ( null == result ) { warn ( xctxt , XPATHErrorResources . WG_ILLEGAL_VARIABLE_REFERENCE , new Object [ ] { m_qname . getLocalPart ( ) } ) ; result = new XNodeSet ( xctxt . getDTMManager ( ) ) ; } return result ; } else { synchronized ( this ) { org . apache . xalan . templates . ElemVariable vvar = getElemVariable ( ) ; if ( null != vvar ) { m_index = vvar . getIndex ( ) ; m_isGlobal = vvar . getIsTopLevel ( ) ; m_fixUpWasCalled = true ; return execute ( xctxt ) ; } } throw new javax . xml . transform . TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VAR_NOT_RESOLVABLE , new Object [ ] { m_qname . toString ( ) } ) ) ; } } public org . apache . xalan . templates . ElemVariable getElemVariable ( ) { org . apache . xpath . ExpressionNode owner = getExpressionOwner ( ) ; if ( null != owner && owner instanceof org . apache . xalan . templates . ElemTemplateElement ) { org . apache . xalan . templates . ElemVariable vvar ; org . apache . xalan . templates . ElemTemplateElement prev = ( org . apache . xalan . templates . ElemTemplateElement ) owner ; if ( ! ( prev instanceof org . apache . xalan . templates . Stylesheet ) ) { while ( ! ( prev . getParentNode ( ) instanceof org . apache . xalan . templates . Stylesheet ) ) { org . apache . xalan . templates . ElemTemplateElement savedprev = prev ; while ( null != ( prev = prev . getPreviousSiblingElem ( ) ) ) { if ( prev instanceof org . apache . xalan . templates . ElemVariable ) { vvar = ( org . apache . xalan . templates . ElemVariable ) prev ; if ( vvar . getName ( ) . equals ( m_qname ) ) { return vvar ; } } } prev = savedprev . getParentElem ( ) ; } } vvar = prev . getStylesheetRoot ( ) . getVariableOrParamComposed ( m_qname ) ; if ( null != vvar ) { return vvar ; } } return null ; } public boolean isStableNumber ( ) { return true ; } public int getAnalysisBits ( ) { org . apache . xalan . templates . ElemVariable vvar = getElemVariable ( ) ; if ( null != vvar ) { XPath xpath = vvar . getSelect ( ) ; if ( null != xpath ) { Expression expr = xpath . getExpression ( ) ; if ( null != expr && expr instanceof PathComponent ) { return ( ( PathComponent ) expr ) . getAnalysisBits ( ) ; } } } return WalkerFactory . BIT_FILTER ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitVariableRef ( owner , this ) ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_qname . equals ( ( ( Variable ) expr ) . m_qname ) ) return false ; if ( getElemVariable ( ) != ( ( Variable ) expr ) . getElemVariable ( ) ) return false ; return true ; } static final java . lang . String PSUEDOVARNAMESPACE = "http://xml.apache.org/xalan/psuedovar" ; public boolean isPsuedoVarRef ( ) { java . lang . String ns = m_qname . getNamespaceURI ( ) ; if ( ( null != ns ) && ns . equals ( PSUEDOVARNAMESPACE ) ) { if ( m_qname . getLocalName ( ) . startsWith ( "#" ) ) return true ; } return false ; } } 	1	['16', '2', '1', '26', '51', '50', '8', '19', '16', '0.746666667', '356', '0.8', '1', '0.666666667', '0.1875', '2', '10', '20.9375', '9', '2.25', '1']
package org . apache . xalan . processor ; import org . xml . sax . Attributes ; public class ProcessorUnknown extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { } } 	1	['3', '5', '0', '3', '4', '3', '1', '2', '3', '2', '8', '0', '0', '0.990697674', '0.666666667', '1', '2', '1.666666667', '1', '0.6667', '2']
package org . apache . xml . utils ; import java . util . Hashtable ; class ElemDesc { Hashtable m_attrs = null ; int m_flags ; static final int EMPTY = ( 1 << 1 ) ; static final int FLOW = ( 1 << 2 ) ; static final int BLOCK = ( 1 << 3 ) ; static final int BLOCKFORM = ( 1 << 4 ) ; static final int BLOCKFORMFIELDSET = ( 1 << 5 ) ; static final int CDATA = ( 1 << 6 ) ; static final int PCDATA = ( 1 << 7 ) ; static final int RAW = ( 1 << 8 ) ; static final int INLINE = ( 1 << 9 ) ; static final int INLINEA = ( 1 << 10 ) ; static final int INLINELABEL = ( 1 << 11 ) ; static final int FONTSTYLE = ( 1 << 12 ) ; static final int PHRASE = ( 1 << 13 ) ; static final int FORMCTRL = ( 1 << 14 ) ; static final int SPECIAL = ( 1 << 15 ) ; static final int ASPECIAL = ( 1 << 16 ) ; static final int HEADMISC = ( 1 << 17 ) ; static final int HEAD = ( 1 << 18 ) ; static final int LIST = ( 1 << 19 ) ; static final int PREFORMATTED = ( 1 << 20 ) ; static final int WHITESPACESENSITIVE = ( 1 << 21 ) ; static final int ATTRURL = ( 1 << 1 ) ; static final int ATTREMPTY = ( 1 << 2 ) ; ElemDesc ( int flags ) { m_flags = flags ; } boolean is ( int flags ) { return ( m_flags & flags ) != 0 ; } void setAttr ( String name , int flags ) { if ( null == m_attrs ) m_attrs = new Hashtable ( ) ; m_attrs . put ( name , new Integer ( flags ) ) ; } boolean isAttrFlagSet ( String name , int flags ) { if ( null != m_attrs ) { Integer _flags = ( Integer ) m_attrs . get ( name ) ; if ( null != _flags ) { return ( _flags . intValue ( ) & flags ) != 0 ; } } return false ; } } 	1	['4', '1', '0', '0', '10', '0', '0', '0', '0', '1.266666667', '90', '0', '0', '0', '0.833333333', '0', '0', '15.25', '4', '2', '1']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XObject ; public abstract class Function extends Expression { public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 0 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "zero" , null ) ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { System . out . println ( "Error! Function.execute should not be called!" ) ; return null ; } public void callArgVisitors ( XPathVisitor visitor ) { } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitFunction ( owner , this ) ) { callArgVisitors ( visitor ) ; } } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; return true ; } public void postCompileStep ( Compiler compiler ) { } } 	1	['9', '2', '7', '21', '15', '36', '15', '8', '8', '2', '51', '0', '0', '0.789473684', '0.285714286', '1', '7', '4.666666667', '2', '1.1111', '1']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; public class ExtensionHandlerJavaPackage extends ExtensionHandlerJava { public ExtensionHandlerJavaPackage ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang , className ) ; } public boolean isFunctionAvailable ( String function ) { try { String fullName = m_className + function ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot >= 0 ) { Class myClass = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; Method [ ] methods = myClass . getMethods ( ) ; int nMethods = methods . length ; function = fullName . substring ( lastDot + 1 ) ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( function ) ) return true ; } } } catch ( ClassNotFoundException cnfe ) { } return false ; } public boolean isElementAvailable ( String element ) { try { String fullName = m_className + element ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot >= 0 ) { Class myClass = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; Method [ ] methods = myClass . getMethods ( ) ; int nMethods = methods . length ; element = fullName . substring ( lastDot + 1 ) ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( element ) ) { Class [ ] paramTypes = methods [ i ] . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) ) { return true ; } } } } } catch ( ClassNotFoundException cnfe ) { } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { String className ; String methodName ; Class classObj ; Object targetObject ; int lastDot = funcName . lastIndexOf ( "." ) ; Object [ ] methodArgs ; Object [ ] [ ] convertedArgs ; Class [ ] paramTypes ; try { if ( funcName . endsWith ( ".new" ) ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Constructor c = ( Constructor ) getFromCache ( methodKey , null , methodArgs ) ; if ( c != null ) { try { paramTypes = c . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } className = m_className + funcName . substring ( 0 , lastDot ) ; try { classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } c = MethodResolver . getConstructor ( classObj , methodArgs , convertedArgs , exprContext ) ; putToCache ( methodKey , null , methodArgs , c ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } else if ( - 1 != lastDot ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Method m = ( Method ) getFromCache ( methodKey , null , methodArgs ) ; if ( m != null ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return m . invoke ( null , convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } className = m_className + funcName . substring ( 0 , lastDot ) ; methodName = funcName . substring ( lastDot + 1 ) ; try { classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } m = MethodResolver . getMethod ( classObj , methodName , methodArgs , convertedArgs , exprContext , MethodResolver . STATIC_ONLY ) ; putToCache ( methodKey , null , methodArgs , m ) ; return m . invoke ( null , convertedArgs [ 0 ] ) ; } else { if ( args . size ( ) < 1 ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INSTANCE_MTHD_CALL_REQUIRES , new Object [ ] { funcName } ) ) ; } targetObject = args . elementAt ( 0 ) ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; methodArgs = new Object [ args . size ( ) - 1 ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i + 1 ) ; } Method m = ( Method ) getFromCache ( methodKey , targetObject , methodArgs ) ; if ( m != null ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } classObj = targetObject . getClass ( ) ; m = MethodResolver . getMethod ( classObj , funcName , methodArgs , convertedArgs , exprContext , MethodResolver . INSTANCE_ONLY ) ; putToCache ( methodKey , targetObject , methodArgs , m ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } } catch ( InvocationTargetException ite ) { Throwable resultException = ite ; Throwable targetException = ite . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( ( TransformerException ) targetException ) ; else if ( targetException != null ) resultException = targetException ; throw new TransformerException ( resultException ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { return callFunction ( extFunction . getFunctionName ( ) , args , extFunction . getMethodKey ( ) , exprContext ) ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; Class classObj ; Method m = ( Method ) getFromCache ( methodKey , null , null ) ; if ( null == m ) { try { String fullName = m_className + localPart ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot < 0 ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_ELEMENT_NAME , new Object [ ] { fullName } ) ) ; try { classObj = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } localPart = fullName . substring ( lastDot + 1 ) ; m = MethodResolver . getElementMethod ( classObj , localPart ) ; if ( ! Modifier . isStatic ( m . getModifiers ( ) ) ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEMENT_NAME_METHOD_STATIC , new Object [ ] { fullName } ) ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } putToCache ( methodKey , null , null , m ) ; } XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { result = m . invoke ( null , new Object [ ] { xpc , element } ) ; } catch ( InvocationTargetException ite ) { Throwable resultException = ite ; Throwable targetException = ite . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( ( TransformerException ) targetException ) ; else if ( targetException != null ) resultException = targetException ; throw new TransformerException ( resultException ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1	['7', '3', '0', '10', '47', '9', '0', '10', '6', '1', '658', '0', '0', '0.571428571', '0.349206349', '2', '5', '92.71428571', '7', '1.8571', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemComment extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_COMMENT ; } public String getNodeName ( ) { return Constants . ELEMNAME_COMMENT_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { String data = transformer . transformToString ( this ) ; transformer . getResultTreeHandler ( ) . comment ( data ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } } 	1	['5', '3', '0', '5', '17', '10', '1', '4', '5', '2', '74', '0', '0', '0.98', '0.466666667', '2', '6', '13.8', '16', '3.8', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "The current() function is not allowed in a match pattern!" } , { ER_CURRENT_TAKES_NO_ARGS , "The current() function does not accept arguments!" } , { ER_DOCUMENT_REPLACED , "document() function implementation has been replaced by org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "context does not have an owner document!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() has too many arguments." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() has too many arguments." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() has too many arguments." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() has too many arguments." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() has too many arguments." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() has too many arguments." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() has too many arguments." } , { ER_TRANSLATE_TAKES_3_ARGS , "The translate() function takes three arguments!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "The unparsed-entity-uri function should take one argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace axis not implemented yet!" } , { ER_UNKNOWN_AXIS , "unknown axis: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "unknown match operation!" } , { ER_INCORRECT_ARG_LENGTH , "Arg length of processing-instruction() node test is incorrect!" } , { ER_CANT_CONVERT_TO_NUMBER , "Can not convert {0} to a number" } , { ER_CANT_CONVERT_TO_NODELIST , "Can not convert {0} to a NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Can not convert {0} to a NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Can not convert {0} to a type#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Expected match pattern in getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "Could not get variable named {0}" } , { ER_UNKNOWN_OPCODE , "ERROR! Unknown op code: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Extra illegal tokens: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "misquoted literal... expected double quote!" } , { ER_EXPECTED_SINGLE_QUOTE , "misquoted literal... expected single quote!" } , { ER_EMPTY_EXPRESSION , "Empty expression!" } , { ER_EXPECTED_BUT_FOUND , "Expected {0}, but found: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programmer assertion is incorrect! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...) argument is no longer optional with 19990709 XPath draft." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Found ',' but no preceding argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Found ',' but no following argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' or '.[predicate]' is illegal syntax.  Use 'self::node()[predicate]' instead." } , { ER_ILLEGAL_AXIS_NAME , "illegal axis name: {0}" } , { ER_UNKNOWN_NODETYPE , "Unknown nodetype: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Pattern literal ({0}) needs to be quoted!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} could not be formatted to a number!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Could not create XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Error! Did not find xpath select expression (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERROR! Could not find ENDOP after OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Error occured!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference given for variable out of context or without definition!  Name = {0}" } , { ER_AXES_NOT_ALLOWED , "Only child:: and attribute:: axes are allowed in match patterns!  Offending axes = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() has an incorrect number of arguments." } , { ER_COUNT_TAKES_1_ARG , "The count function should take one argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Could not find function: {0}" } , { ER_UNSUPPORTED_ENCODING , "Unsupported encoding: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Problem occured in DTM in getNextSibling... trying to recover" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programmer error: EmptyNodeList can not be written to." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory is not supported by XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource source) not supported in XPathContext! Can not open {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... not handled by the DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... not handled by the DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison can not handle nodes of type {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper can not handle nodes of type {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse error: SystemID - {0} line - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse error" } , { ER_INVALID_UTF16_SURROGATE , "Invalid UTF-16 surrogate detected: {0} ?" } , { ER_OIERROR , "IO error" } , { ER_CANNOT_CREATE_URL , "Cannot create url for: {0}" } , { ER_XPATH_READOBJECT , "In XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "function token not found." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Can not deal with XPath type: {0}" } , { ER_NODESET_NOT_MUTABLE , "This NodeSet is not mutable" } , { ER_NODESETDTM_NOT_MUTABLE , "This NodeSetDTM is not mutable" } , { ER_VAR_NOT_RESOLVABLE , "Variable not resolvable: {0}" } , { ER_NULL_ERROR_HANDLER , "Null error handler" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programmer''s assertion: unknown opcode: {0}" } , { ER_ZERO_OR_ONE , "0 or 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() not supported by XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() not supported by XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() not supported for XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Could not find variable with the name of {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars can not take a string for an argument" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "The FastStringBuffer argument can not be null" } , { ER_TWO_OR_THREE , "2 or 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variable accessed before it is bound!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB can not take a string for an argument!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Error! Setting the root of a walker to null!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "This NodeSetDTM can not iterate to a previous node!" } , { ER_NODESET_CANNOT_ITERATE , "This NodeSet can not iterate to a previous node!" } , { ER_NODESETDTM_CANNOT_INDEX , "This NodeSetDTM can not do indexing or counting functions!" } , { ER_NODESET_CANNOT_INDEX , "This NodeSet can not do indexing or counting functions!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Can not call setShouldCacheNodes after nextNode has been called!" } , { ER_ONLY_ALLOWS , "{0} only allows {1} arguments" } , { ER_UNKNOWN_STEP , "Programmer''s assertion in getNextStepPos: unknown stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "A relative location path was expected following the '/' or '//' token." } , { ER_EXPECTED_LOC_PATH , "A location path was expected, but the following token was encountered:  {0}" } , { ER_EXPECTED_LOC_STEP , "A location step was expected following the '/' or '//' token." } , { ER_EXPECTED_NODE_TEST , "A node test that matches either NCName:* or QName was expected." } , { ER_EXPECTED_STEP_PATTERN , "A step pattern was expected, but '/' was encountered." } , { ER_EXPECTED_REL_PATH_PATTERN , "A relative path pattern was expected." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Cannot convert {0} to a boolean." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Cannot convert {0} to a single node. This getter applies to types ANY_UNORDERED_NODE_TYPE and FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Cannot get snapshot length on type: {0}. This getter applies to types UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Cannot iterate over non-iterator type: {0}" } , { ER_DOC_MUTATED , "Document mutated since result was returned. Iterator is invalid." } , { ER_INVALID_XPATH_TYPE , "Invalid XPath type argument: {0}" } , { ER_EMPTY_XPATH_RESULT , "Empty XPath result object" } , { ER_INCOMPATIBLE_TYPES , "The returned type: {0} cannot be coerced into the specified type: {1}" } , { ER_NULL_RESOLVER , "Unable to resolve prefix with null prefix resolver." } , { ER_CANT_CONVERT_TO_STRING , "Cannot convert {0} to a string." } , { ER_NON_SNAPSHOT_TYPE , "Cannot call snapshotItem on type: {0}. This method applies to types UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Context node does not belong to the document that is bound to this XPathEvaluator." } , { ER_WRONG_NODETYPE , "The context node type is not supported." } , { ER_XPATH_ERROR , "Unknown error in XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "locale name in the format-number function not yet handled!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL Property not supported: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Do not currently do anything with namespace {0} in property: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException when trying to access XSL system property: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Old syntax: quo(...) is no longer defined in XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath needs a derived object to implement nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "function token not found." } , { WG_COULDNOT_FIND_FUNCTION , "Could not find function: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Can not make URL from: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "-E option not supported for DTM parser" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference given for variable out of context or without definition!  Name = {0}" } , { WG_UNSUPPORTED_ENCODING , "Unsupported encoding: {0}" } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Parameter to createMessage was out of bounds" } , { "FORMAT_FAILED" , "Exception thrown during messageFormat call" } , { "version" , ">>>>>>> Xalan Version " } , { "version2" , "<<<<<<<" } , { "yes" , "yes" } , { "line" , "Line #" } , { "column" , "Column #" } , { "xsldone" , "XSLProcessor: done" } , { "xpath_option" , "xpath options: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath expression]" } , { "optionMatch" , "   [-match match pattern (for match diagnostics)]" } , { "optionAnyExpr" , "Or just an xpath expression will do a diagnostic dump" } , { "noParsermsg1" , "XSL Process was not successful." } , { "noParsermsg2" , "** Could not find parser **" } , { "noParsermsg3" , "Please check your classpath." } , { "noParsermsg4" , "If you don't have IBM's XML Parser for Java, you can download it from" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '10', '10', '16', '8', '10', '0', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '1']
package org . apache . xpath . res ; public class XPATHErrorResources_zh_TW extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "在符合型樣中不允許使用 current() 函式！" } , { ER_CURRENT_TAKES_NO_ARGS , "current() 函式不接受引數！" } , { ER_DOCUMENT_REPLACED , "org.apache.xalan.xslt.FuncDocument 已取代執行 document() 函式！" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "上下文不含擁有者文件！" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() 有太多引數。" } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() 有太多引數。" } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() 有太多引數。" } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() 有太多引數。" } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() 有太多引數。" } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() 有太多引數。" } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() 有太多引數。" } , { ER_TRANSLATE_TAKES_3_ARGS , "translate() 函式需要 3 個引數！" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri 函式需要 1 個引數！" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace 軸尚未建置！" } , { ER_UNKNOWN_AXIS , "未知軸：{0}" } , { ER_UNKNOWN_MATCH_OPERATION , "未知的符合作業！" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() 節點測試的引數長度不正確！" } , { ER_CANT_CONVERT_TO_NUMBER , "{0} 無法轉換為數字" } , { ER_CANT_CONVERT_TO_NODELIST , "{0} 無法轉換為 NodeList！" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0} 無法轉換為 NodeSetDTM！" } , { ER_CANT_CONVERT_TO_TYPE , "{0} 無法轉換為 type//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "在 getMatchScore 中預期的符合型樣！" } , { ER_COULDNOT_GET_VAR_NAMED , "無法取得叫作 {0} 的變數" } , { ER_UNKNOWN_OPCODE , "錯誤！未知的作業碼：{0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "額外不合規則的記號：{0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "文字列引號括錯... 預期出現雙引號！" } , { ER_EXPECTED_SINGLE_QUOTE , "文字列引號括錯... 預期出現單引號！" } , { ER_EMPTY_EXPRESSION , "空的表示式！" } , { ER_EXPECTED_BUT_FOUND , "預期 {0}，卻找到：{1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "程式設計師假設不正確！- {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...) 引數在 19990709 XPath 初稿中不再是可選用的。" } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "找到 ','，但之前沒有引數！" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "找到 ','，但之後沒有引數！" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' 或 '.[predicate]' 是不合規則的語法。請使用 'self::node()[predicate]' 來代替。" } , { ER_ILLEGAL_AXIS_NAME , "不合規則的軸名稱：{0}" } , { ER_UNKNOWN_NODETYPE , "未知節點類型：{0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "型樣文字列 ({0}) 需要用引號括住！" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} 無法格式化為數字！" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "無法建立 XML TransformerFactory Liaison：{0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "錯誤！未找到 xpath select 表示式 (-select)。" } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "錯誤！在 OP_LOCATIONPATH 之後找不到 ENDOP" } , { ER_ERROR_OCCURED , "發生錯誤！" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "提供給變數的 VariableReference 超出上下文或沒有定義！名稱 = {0}" } , { ER_AXES_NOT_ALLOWED , "在符合型樣中僅允許 child:: 及 attribute:: 軸！ 違例軸 = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() 含有不正確的引數數目。" } , { ER_COUNT_TAKES_1_ARG , "count 函式只接受一個引數！" } , { ER_COULDNOT_FIND_FUNCTION , "找不到函式：{0}" } , { ER_UNSUPPORTED_ENCODING , "未支援的編碼：{0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling 中的 DTM 發生問題... 嘗試回復" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "程式設計師錯誤：無法寫入 EmptyNodeList 中。" } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory 不受 XPathContext 支援！" } , { ER_PREFIX_MUST_RESOLVE , "前置必須解譯為名稱空間：{0}" } , { ER_PARSE_NOT_SUPPORTED , "在 XPathContext 中不支援剖析（InputSource 來源）！無法開啟 {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API 字元(char ch[]... DTM 未處理！" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... DTM 未處理！" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison 無法處理類型 {0} 的節點" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper 無法處理類型 {0} 的節點" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse 錯誤：SystemID - {0} 行 - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse 錯誤" } , { ER_INVALID_UTF16_SURROGATE , "偵測到無效的 UTF-16 代用品：{0} ?" } , { ER_OIERROR , "輸入/輸出 (I/O) 錯誤" } , { ER_CANNOT_CREATE_URL , "無法建立 URL 給： {0}" } , { ER_XPATH_READOBJECT , "在 XPath.readObject：{0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "找不到函式記號。" } , { ER_CANNOT_DEAL_XPATH_TYPE , "無法處理 XPath 類型：{0}" } , { ER_NODESET_NOT_MUTABLE , "此類 NodeSet 不易變" } , { ER_NODESETDTM_NOT_MUTABLE , "此類 NodeSetDTM 不易變" } , { ER_VAR_NOT_RESOLVABLE , "變數無法解譯：{0}" } , { ER_NULL_ERROR_HANDLER , "空的錯誤處理器" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "程式設計師的假設：未知作業碼：{0}" } , { ER_ZERO_OR_ONE , "0 或 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper 不支援 rtf()" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper 不支援 asNodeIterator()" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "XStringForChars 不支援 fsb()" } , { ER_COULD_NOT_FIND_VAR , "找不到名稱為 {0} 的變數" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars 不接受字串引數" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer 引數不得為空值" } , { ER_TWO_OR_THREE , "2 或 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "連結前已存取變數！" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB 不會將字串看作引數！" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n ！！！！錯誤！將 walker 的根設定為空！！！" } , { ER_NODESETDTM_CANNOT_ITERATE , "無法對前一個節點重複此 NodeSetDTM！" } , { ER_NODESET_CANNOT_ITERATE , "無法對前一個節點重複此 NodeSet！" } , { ER_NODESETDTM_CANNOT_INDEX , "此 NodeSetDTM 無法對函式進行索引或計數！" } , { ER_NODESET_CANNOT_INDEX , "此 NodeSet 無法對函式進行索引或計數！" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "呼叫 nextNode 之後，不能呼叫 setShouldCacheNodes！" } , { ER_ONLY_ALLOWS , "{0} 僅允許使用 {1} 引數" } , { ER_UNKNOWN_STEP , "程式設計師在 getNextStepPos 中的判斷：未知的 stepType：{0}" } , { ER_EXPECTED_REL_LOC_PATH , "'/' 或 '//' 記號之後應跟隨相對位置的路徑。" } , { ER_EXPECTED_LOC_PATH , "應為位置路徑，卻遇到以下記號 :  {0}" } , { ER_EXPECTED_LOC_STEP , "'/' 或 '//' 記號之後應跟隨位置步驟。" } , { ER_EXPECTED_NODE_TEST , "應為符合 NCName:* 或 QName 的節點測試。" } , { ER_EXPECTED_STEP_PATTERN , "應為步驟型樣，卻遇到 '/'。" } , { ER_EXPECTED_REL_PATH_PATTERN , "應為相對路徑型樣。" } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0} 無法轉換為布林值。" } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0} 無法轉換為單一節點。此 getter 適用於 ANY_UNORDERED_NODE_TYPE 和 FIRST_ORDERED_NODE_TYPE 類型。" } , { ER_CANT_GET_SNAPSHOT_LENGTH , "無法取得類型 {0} 的快照長度。此 getter 適用於 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 類型。" } , { ER_NON_ITERATOR_TYPE , "無法重複非疊代器類型：{0}" } , { ER_DOC_MUTATED , "傳回結果後文件發生變更。疊代器無效。" } , { ER_INVALID_XPATH_TYPE , "無效的 XPath 類型引數：{0}" } , { ER_EMPTY_XPATH_RESULT , "空的 XPath 結果物件" } , { ER_INCOMPATIBLE_TYPES , "傳回的類型：{0} 無法強行轉換為指定的類型：{1}" } , { ER_NULL_RESOLVER , "無法使用空前置解析器解析前置。" } , { ER_CANT_CONVERT_TO_STRING , "{0} 無法轉換為字串。" } , { ER_NON_SNAPSHOT_TYPE , "無法呼叫類型 {0} 的 snapshotItem。 此方法適用於 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 類型。" } , { ER_WRONG_DOCUMENT , "上下文節點不屬於連結至此 XPathEvaluator 的文件。" } , { ER_WRONG_NODETYPE , "不支援上下文節點。" } , { ER_XPATH_ERROR , "XPath 中出現未知錯誤。" } , { WG_LOCALE_NAME_NOT_HANDLED , "format-number 函式中的語言環境名稱尚未處理！" } , { WG_PROPERTY_NOT_SUPPORTED , "不支援 XSL 內容：{0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "目前請勿處理內容 {1} 中的名稱空間 {0}" } , { WG_SECURITY_EXCEPTION , "嘗試存取 XSL 系統內容 {0} 時發生 SecurityException" } , { WG_QUO_NO_LONGER_DEFINED , "舊語法：quo(...) 不再定義於 XPath 中。" } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath 需要衍生物件來執行 nodeTest！" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "找不到函式記號。" } , { WG_COULDNOT_FIND_FUNCTION , "找不到函式：{0}" } , { WG_CANNOT_MAKE_URL_FROM , "無法從 {0} 產生 URL" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "DTM 剖析器不支援 -E 選項" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "提供給變數的 VariableReference 超出上下文或沒有定義！名稱 = {0}" } , { WG_UNSUPPORTED_ENCODING , "未支援的編碼：{0}" } , { "ui_language" , "zh_TW" } , { "help_language" , "zh_TW" } , { "language" , "zh_TW" } , { "BAD_CODE" , "createMessage 的參數超出界限" } , { "FORMAT_FAILED" , "在 messageFormat 呼叫期間異常丟出" } , { "version" , ">>>>>>> Xalan 版本" } , { "version2" , "<<<<<<<" } , { "yes" , "是" } , { "line" , "列 //" } , { "column" , "行 //" } , { "xsldone" , "XSLProcessor: done" } , { "xpath_option" , "xpath 選項： " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath expression]" } , { "optionMatch" , "   [-match match pattern (用於符合診斷)]" } , { "optionAnyExpr" , "或只有一個 xpath 表示式會執行診斷傾印" } , { "noParsermsg1" , "XSL 程序不成功。" } , { "noParsermsg2" , "** 找不到剖析器 **" } , { "noParsermsg3" , "請檢查類別路徑。" } , { "noParsermsg4" , "如果您沒有 IBM 的 XML Parser for Java，可下載自 " } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "錯誤：" ; public static final String WARNING_HEADER = "警告：" ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.428571429', '1872', '0', '0', '0.976190476', '1', '0', '0', '618.3333333', '1', '0.3333', '1']
package org . apache . xml . utils . synthetic . reflection ; import org . apache . xml . utils . synthetic . SynthesisException ; public class Method extends EntryPoint implements Member { public Method ( String name , org . apache . xml . utils . synthetic . Class declaringclass ) { super ( declaringclass ) ; this . name = name ; } public Method ( java . lang . reflect . Method ctor , org . apache . xml . utils . synthetic . Class declaringclass ) { super ( ctor , declaringclass ) ; } public Method ( java . lang . reflect . Method realmethod ) { super ( realmethod ) ; } public int hashCode ( ) { return getDeclaringClass ( ) . getName ( ) . hashCode ( ) ^ getName ( ) . hashCode ( ) ; } public Object invoke ( Object obj , Object args [ ] ) throws IllegalAccessException , IllegalArgumentException , java . lang . reflect . InvocationTargetException { if ( realep != null ) return ( ( java . lang . reflect . Method ) realep ) . invoke ( obj , args ) ; else throw new IllegalAccessException ( "Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation" ) ; } public void setReturnType ( org . apache . xml . utils . synthetic . Class returntype ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . returntype = returntype ; } } 	1	['6', '2', '0', '5', '16', '13', '3', '4', '6', '2', '58', '0', '0', '0.863636364', '0.388888889', '2', '3', '8.666666667', '1', '0.5', '1']
package org . apache . xml . utils ; import java . io . File ; import org . w3c . dom . Comment ; import org . w3c . dom . Element ; import org . w3c . dom . EntityReference ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . LocatorImpl ; public class TreeWalker { private ContentHandler m_contentHandler = null ; protected DOMHelper m_dh ; private LocatorImpl m_locator = new LocatorImpl ( ) ; public ContentHandler getContentHandler ( ) { return m_contentHandler ; } public void setContentHandler ( ContentHandler ch ) { m_contentHandler = ch ; } public TreeWalker ( ContentHandler contentHandler , DOMHelper dh , String systemId ) { this . m_contentHandler = contentHandler ; m_contentHandler . setDocumentLocator ( m_locator ) ; if ( systemId != null ) m_locator . setSystemId ( systemId ) ; else { try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) + File . separator + "dummy.xsl" ) ; } catch ( SecurityException se ) { m_locator . setSystemId ( "" ) ; } } m_dh = dh ; } public TreeWalker ( ContentHandler contentHandler , DOMHelper dh ) { this . m_contentHandler = contentHandler ; m_contentHandler . setDocumentLocator ( m_locator ) ; try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) + File . separator + "dummy.xsl" ) ; } catch ( SecurityException se ) { m_locator . setSystemId ( "" ) ; } m_dh = dh ; } public TreeWalker ( ContentHandler contentHandler ) { this . m_contentHandler = contentHandler ; if ( m_contentHandler != null ) m_contentHandler . setDocumentLocator ( m_locator ) ; try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) + File . separator + "dummy.xsl" ) ; } catch ( SecurityException se ) { m_locator . setSystemId ( "" ) ; } m_dh = new DOM2Helper ( ) ; } public void traverse ( Node pos ) throws org . xml . sax . SAXException { this . m_contentHandler . startDocument ( ) ; Node top = pos ; while ( null != pos ) { startNode ( pos ) ; Node nextNode = pos . getFirstChild ( ) ; while ( null == nextNode ) { endNode ( pos ) ; if ( top . equals ( pos ) ) break ; nextNode = pos . getNextSibling ( ) ; if ( null == nextNode ) { pos = pos . getParentNode ( ) ; if ( ( null == pos ) || ( top . equals ( pos ) ) ) { if ( null != pos ) endNode ( pos ) ; nextNode = null ; break ; } } } pos = nextNode ; } this . m_contentHandler . endDocument ( ) ; } public void traverse ( Node pos , Node top ) throws org . xml . sax . SAXException { this . m_contentHandler . startDocument ( ) ; while ( null != pos ) { startNode ( pos ) ; Node nextNode = pos . getFirstChild ( ) ; while ( null == nextNode ) { endNode ( pos ) ; if ( ( null != top ) && top . equals ( pos ) ) break ; nextNode = pos . getNextSibling ( ) ; if ( null == nextNode ) { pos = pos . getParentNode ( ) ; if ( ( null == pos ) || ( ( null != top ) && top . equals ( pos ) ) ) { nextNode = null ; break ; } } } pos = nextNode ; } this . m_contentHandler . endDocument ( ) ; } boolean nextIsRaw = false ; private final void dispatachChars ( Node node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler ) { ( ( org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler ) m_contentHandler ) . characters ( node ) ; } else { String data = ( ( Text ) node ) . getData ( ) ; this . m_contentHandler . characters ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } protected void startNode ( Node node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof NodeConsumer ) { ( ( NodeConsumer ) m_contentHandler ) . setOriginatingNode ( node ) ; } if ( node instanceof Locator ) { Locator loc = ( Locator ) node ; m_locator . setColumnNumber ( loc . getColumnNumber ( ) ) ; m_locator . setLineNumber ( loc . getLineNumber ( ) ) ; m_locator . setPublicId ( loc . getPublicId ( ) ) ; m_locator . setSystemId ( loc . getSystemId ( ) ) ; } else { m_locator . setColumnNumber ( 0 ) ; m_locator . setLineNumber ( 0 ) ; } switch ( node . getNodeType ( ) ) { case Node . COMMENT_NODE : { String data = ( ( Comment ) node ) . getData ( ) ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } break ; case Node . DOCUMENT_FRAGMENT_NODE : break ; case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : NamedNodeMap atts = ( ( Element ) node ) . getAttributes ( ) ; int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { Node attr = atts . item ( i ) ; String attrName = attr . getNodeName ( ) ; if ( attrName . equals ( "xmlns" ) || attrName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = attrName . indexOf ( ":" ) ) < 0 ? "" : attrName . substring ( index + 1 ) ; this . m_contentHandler . startPrefixMapping ( prefix , attr . getNodeValue ( ) ) ; } } String ns = m_dh . getNamespaceOfNode ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . startElement ( ns , m_dh . getLocalNameOfNode ( node ) , node . getNodeName ( ) , new AttList ( atts , m_dh ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : { ProcessingInstruction pi = ( ProcessingInstruction ) node ; String name = pi . getNodeName ( ) ; if ( name . equals ( "xslt-next-is-raw" ) ) { nextIsRaw = true ; } else { this . m_contentHandler . processingInstruction ( pi . getNodeName ( ) , pi . getData ( ) ) ; } } break ; case Node . CDATA_SECTION_NODE : { boolean isLexH = ( m_contentHandler instanceof LexicalHandler ) ; LexicalHandler lh = isLexH ? ( ( LexicalHandler ) this . m_contentHandler ) : null ; if ( isLexH ) { lh . startCDATA ( ) ; } dispatachChars ( node ) ; { if ( isLexH ) { lh . endCDATA ( ) ; } } } break ; case Node . TEXT_NODE : { if ( nextIsRaw ) { nextIsRaw = false ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; dispatachChars ( node ) ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { dispatachChars ( node ) ; } } break ; case Node . ENTITY_REFERENCE_NODE : { EntityReference eref = ( EntityReference ) node ; if ( m_contentHandler instanceof LexicalHandler ) { ( ( LexicalHandler ) this . m_contentHandler ) . startEntity ( eref . getNodeName ( ) ) ; } else { } } break ; default : } } protected void endNode ( Node node ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : String ns = m_dh . getNamespaceOfNode ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . endElement ( ns , m_dh . getLocalNameOfNode ( node ) , node . getNodeName ( ) ) ; NamedNodeMap atts = ( ( Element ) node ) . getAttributes ( ) ; int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { Node attr = atts . item ( i ) ; String attrName = attr . getNodeName ( ) ; if ( attrName . equals ( "xmlns" ) || attrName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = attrName . indexOf ( ":" ) ) < 0 ? "" : attrName . substring ( index + 1 ) ; this . m_contentHandler . endPrefixMapping ( prefix ) ; } } break ; case Node . CDATA_SECTION_NODE : break ; case Node . ENTITY_REFERENCE_NODE : { EntityReference eref = ( EntityReference ) node ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . endEntity ( eref . getNodeName ( ) ) ; } } break ; default : } } } 	1	['10', '1', '0', '12', '65', '0', '7', '5', '7', '0.305555556', '623', '0.75', '1', '0', '0.44', '0', '0', '60.9', '1', '0.7', '2']
package org . apache . xalan . processor ; public class ProcessorStylesheetDoc extends XSLTElementProcessor { } 	1	['1', '4', '0', '2', '2', '0', '1', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xalan . templates ; import java . io . Serializable ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . UnImplNode ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . WhitespaceStrippingElementMatcher ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . helpers . NamespaceSupport ; public class ElemTemplateElement extends UnImplNode implements PrefixResolver , Serializable , ExpressionNode , WhitespaceStrippingElementMatcher , XSLTVisitable { public ElemTemplateElement ( ) { } public boolean isCompiledTemplate ( ) { return false ; } public int getXSLToken ( ) { return Constants . ELEMNAME_UNDEFINED ; } public String getNodeName ( ) { return "Unknown XSLT Element" ; } public String getLocalName ( ) { return getNodeName ( ) ; } public void runtimeInit ( TransformerImpl transformer ) throws TransformerException { } public void execute ( TransformerImpl transformer ) throws TransformerException { } public StylesheetComposed getStylesheetComposed ( ) { return m_parentNode . getStylesheetComposed ( ) ; } public Stylesheet getStylesheet ( ) { return ( null == m_parentNode ) ? null : m_parentNode . getStylesheet ( ) ; } public StylesheetRoot getStylesheetRoot ( ) { return m_parentNode . getStylesheetRoot ( ) ; } public void recompose ( StylesheetRoot root ) throws TransformerException { } public void compose ( StylesheetRoot sroot ) throws TransformerException { resolvePrefixTables ( ) ; ElemTemplateElement t = getFirstChildElem ( ) ; m_hasTextLitOnly = ( ( t != null ) && ( t . getXSLToken ( ) == Constants . ELEMNAME_TEXTLITERALRESULT ) && ( t . getNextSiblingElem ( ) == null ) ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; cstate . pushStackMark ( ) ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; cstate . popStackMark ( ) ; } protected boolean isValidNCName ( String s ) { int len = s . length ( ) ; char c = s . charAt ( 0 ) ; if ( ! ( Character . isLetter ( c ) || ( c == '_' ) ) ) return false ; if ( len > 0 ) { for ( int i = 1 ; i < len ; i ++ ) { c = s . charAt ( i ) ; if ( ! ( Character . isLetterOrDigit ( c ) || ( c == '_' ) || ( c == '-' ) || ( c == '.' ) ) ) return false ; } } return true ; } public void error ( String msg , Object [ ] args ) { String themsg = XSLMessages . createMessage ( msg , args ) ; throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEMTEMPLATEELEM_ERR , new Object [ ] { themsg } ) ) ; } public void error ( String msg ) { error ( msg , null ) ; } public Node appendChild ( Node newChild ) throws DOMException { if ( null == newChild ) { error ( XSLTErrorResources . ER_NULL_CHILD , null ) ; } ElemTemplateElement elem = ( ElemTemplateElement ) newChild ; if ( null == m_firstChild ) { m_firstChild = elem ; } else { ElemTemplateElement last = ( ElemTemplateElement ) getLastChild ( ) ; last . m_nextSibling = elem ; } elem . m_parentNode = this ; return newChild ; } public ElemTemplateElement appendChild ( ElemTemplateElement elem ) { if ( null == elem ) { error ( XSLTErrorResources . ER_NULL_CHILD , null ) ; } if ( null == m_firstChild ) { m_firstChild = elem ; } else { ElemTemplateElement last = getLastChildElem ( ) ; last . m_nextSibling = elem ; } elem . setParentElem ( this ) ; return elem ; } public boolean hasChildNodes ( ) { return ( null != m_firstChild ) ; } public short getNodeType ( ) { return org . w3c . dom . Node . ELEMENT_NODE ; } public NodeList getChildNodes ( ) { return this ; } public ElemTemplateElement removeChild ( ElemTemplateElement childETE ) { if ( childETE == null || childETE . m_parentNode != this ) return null ; if ( childETE == m_firstChild ) m_firstChild = childETE . m_nextSibling ; else { ElemTemplateElement prev = childETE . getPreviousSiblingElem ( ) ; prev . m_nextSibling = childETE . m_nextSibling ; } childETE . m_parentNode = null ; childETE . m_nextSibling = null ; return childETE ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { if ( oldChild == null || oldChild . getParentNode ( ) != this ) return null ; ElemTemplateElement newChildElem = ( ( ElemTemplateElement ) newChild ) ; ElemTemplateElement oldChildElem = ( ( ElemTemplateElement ) oldChild ) ; ElemTemplateElement prev = ( ElemTemplateElement ) oldChildElem . getPreviousSibling ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { if ( null == refChild ) { appendChild ( newChild ) ; return newChild ; } if ( newChild == refChild ) { return newChild ; } Node node = m_firstChild ; Node prev = null ; boolean foundit = false ; while ( null != node ) { if ( newChild == node ) { if ( null != prev ) ( ( ElemTemplateElement ) prev ) . m_nextSibling = ( ElemTemplateElement ) node . getNextSibling ( ) ; else m_firstChild = ( ElemTemplateElement ) node . getNextSibling ( ) ; node = node . getNextSibling ( ) ; continue ; } if ( refChild == node ) { if ( null != prev ) { ( ( ElemTemplateElement ) prev ) . m_nextSibling = ( ElemTemplateElement ) newChild ; } else { m_firstChild = ( ElemTemplateElement ) newChild ; } ( ( ElemTemplateElement ) newChild ) . m_nextSibling = ( ElemTemplateElement ) refChild ; ( ( ElemTemplateElement ) newChild ) . setParentElem ( this ) ; prev = newChild ; node = node . getNextSibling ( ) ; foundit = true ; continue ; } prev = node ; node = node . getNextSibling ( ) ; } if ( ! foundit ) throw new DOMException ( DOMException . NOT_FOUND_ERR , "refChild was not found in insertBefore method!" ) ; else return newChild ; } public ElemTemplateElement replaceChild ( ElemTemplateElement newChildElem , ElemTemplateElement oldChildElem ) { if ( oldChildElem == null || oldChildElem . getParentElem ( ) != this ) return null ; ElemTemplateElement prev = oldChildElem . getPreviousSiblingElem ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; } public int getLength ( ) { int count = 0 ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { count ++ ; } return count ; } public Node item ( int index ) { ElemTemplateElement node = m_firstChild ; for ( int i = 0 ; i < index && node != null ; i ++ ) { node = node . m_nextSibling ; } return node ; } public Document getOwnerDocument ( ) { return getStylesheet ( ) ; } public ElemTemplate getOwnerXSLTemplate ( ) { ElemTemplateElement el = this ; int type = el . getXSLToken ( ) ; while ( ( null != el ) && ( type != Constants . ELEMNAME_TEMPLATE ) ) { el = el . getParentElem ( ) ; if ( null != el ) type = el . getXSLToken ( ) ; } return ( ElemTemplate ) el ; } public String getTagName ( ) { return getNodeName ( ) ; } public boolean hasTextLitOnly ( ) { return m_hasTextLitOnly ; } public String getBaseIdentifier ( ) { return this . getSystemId ( ) ; } private int m_lineNumber ; public int getLineNumber ( ) { return m_lineNumber ; } private int m_columnNumber ; public int getColumnNumber ( ) { return m_columnNumber ; } public String getPublicId ( ) { return ( null != m_parentNode ) ? m_parentNode . getPublicId ( ) : null ; } public String getSystemId ( ) { Stylesheet sheet = getStylesheet ( ) ; return ( sheet == null ) ? null : sheet . getHref ( ) ; } public void setLocaterInfo ( SourceLocator locator ) { m_lineNumber = locator . getLineNumber ( ) ; m_columnNumber = locator . getColumnNumber ( ) ; } private boolean m_defaultSpace = true ; private boolean m_hasTextLitOnly = false ; protected boolean m_hasVariableDecl = false ; public boolean hasVariableDecl ( ) { return m_hasVariableDecl ; } public void setXmlSpace ( int v ) { m_defaultSpace = ( ( Constants . ATTRVAL_STRIP == v ) ? true : false ) ; } public boolean getXmlSpace ( ) { return m_defaultSpace ; } private Vector m_declaredPrefixes ; public Vector getDeclaredPrefixes ( ) { return m_declaredPrefixes ; } public void setPrefixes ( NamespaceSupport nsSupport ) throws TransformerException { setPrefixes ( nsSupport , false ) ; } public void setPrefixes ( NamespaceSupport nsSupport , boolean excludeXSLDecl ) throws TransformerException { Enumeration decls = nsSupport . getDeclaredPrefixes ( ) ; while ( decls . hasMoreElements ( ) ) { String prefix = ( String ) decls . nextElement ( ) ; if ( null == m_declaredPrefixes ) m_declaredPrefixes = new Vector ( ) ; String uri = nsSupport . getURI ( prefix ) ; if ( excludeXSLDecl && uri . equals ( Constants . S_XSLNAMESPACEURL ) ) continue ; XMLNSDecl decl = new XMLNSDecl ( prefix , uri , false ) ; m_declaredPrefixes . addElement ( decl ) ; } } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) { this . error ( XSLTErrorResources . ER_CANT_RESOLVE_NSPREFIX , null ) ; return null ; } public String getNamespaceForPrefix ( String prefix ) { Vector nsDecls = m_declaredPrefixes ; if ( null != nsDecls ) { int n = nsDecls . size ( ) ; if ( prefix . equals ( Constants . ATTRVAL_DEFAULT_PREFIX ) ) { prefix = "" ; } for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) nsDecls . elementAt ( i ) ; if ( prefix . equals ( decl . getPrefix ( ) ) ) return decl . getURI ( ) ; } } if ( null != m_parentNode ) return m_parentNode . getNamespaceForPrefix ( prefix ) ; if ( "xml" . equals ( prefix ) ) return "http://www.w3.org/XML/1998/namespace" ; return null ; } Vector m_prefixTable ; public Vector getPrefixes ( ) { return m_prefixTable ; } public boolean containsExcludeResultPrefix ( String prefix , String uri ) { ElemTemplateElement parent = this . getParentElem ( ) ; if ( null != parent ) return parent . containsExcludeResultPrefix ( prefix , uri ) ; return false ; } private boolean excludeResultNSDecl ( String prefix , String uri ) throws TransformerException { if ( uri != null ) { if ( uri . equals ( Constants . S_XSLNAMESPACEURL ) || getStylesheet ( ) . containsExtensionElementURI ( uri ) || uri . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) || uri . equals ( Constants . S_BUILTIN_OLD_EXTENSIONS_URL ) ) return true ; if ( containsExcludeResultPrefix ( prefix , uri ) ) return true ; } return false ; } public void resolvePrefixTables ( ) throws TransformerException { m_prefixTable = null ; if ( null != this . m_declaredPrefixes ) { StylesheetRoot stylesheet = this . getStylesheetRoot ( ) ; int n = m_declaredPrefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) m_declaredPrefixes . elementAt ( i ) ; String prefix = decl . getPrefix ( ) ; String uri = decl . getURI ( ) ; if ( null == uri ) uri = "" ; boolean shouldExclude = excludeResultNSDecl ( prefix , uri ) ; if ( null == m_prefixTable ) m_prefixTable = new Vector ( ) ; NamespaceAlias nsAlias = stylesheet . getNamespaceAliasComposed ( uri ) ; if ( null != nsAlias ) { decl = new XMLNSDecl ( nsAlias . getStylesheetPrefix ( ) , nsAlias . getResultNamespace ( ) , shouldExclude ) ; } else decl = new XMLNSDecl ( prefix , uri , shouldExclude ) ; m_prefixTable . addElement ( decl ) ; } } ElemTemplateElement parent = this . getParentNodeElem ( ) ; if ( null != parent ) { Vector prefixes = parent . m_prefixTable ; if ( null == m_prefixTable && ! needToCheckExclude ( ) ) { this . m_prefixTable = parent . m_prefixTable ; } else { int n = prefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) prefixes . elementAt ( i ) ; boolean shouldExclude = excludeResultNSDecl ( decl . getPrefix ( ) , decl . getURI ( ) ) ; if ( shouldExclude != decl . getIsExcluded ( ) ) { decl = new XMLNSDecl ( decl . getPrefix ( ) , decl . getURI ( ) , shouldExclude ) ; } addOrReplaceDecls ( decl ) ; } } } else if ( null == m_prefixTable ) { m_prefixTable = new Vector ( ) ; } } void addOrReplaceDecls ( XMLNSDecl newDecl ) { int n = m_prefixTable . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( decl . getPrefix ( ) . equals ( newDecl . getPrefix ( ) ) ) { return ; } } m_prefixTable . addElement ( newDecl ) ; } boolean needToCheckExclude ( ) { return false ; } void executeNSDecls ( TransformerImpl transformer ) throws TransformerException { executeNSDecls ( transformer , null ) ; } void executeNSDecls ( TransformerImpl transformer , String ignorePrefix ) throws TransformerException { try { if ( null != m_prefixTable ) { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; int n = m_prefixTable . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( ! decl . getIsExcluded ( ) && ! ( null != ignorePrefix && decl . getPrefix ( ) . equals ( ignorePrefix ) ) ) { rhandler . startPrefixMapping ( decl . getPrefix ( ) , decl . getURI ( ) , true ) ; } } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } void unexecuteNSDecls ( TransformerImpl transformer ) throws TransformerException { unexecuteNSDecls ( transformer , null ) ; } void unexecuteNSDecls ( TransformerImpl transformer , String ignorePrefix ) throws TransformerException { try { if ( null != m_prefixTable ) { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; int n = m_prefixTable . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( ! decl . getIsExcluded ( ) && ! ( null != ignorePrefix && decl . getPrefix ( ) . equals ( ignorePrefix ) ) ) { rhandler . endPrefixMapping ( decl . getPrefix ( ) ) ; } } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } protected int m_docOrderNumber = - 1 ; public void setUid ( int i ) { m_docOrderNumber = i ; } public int getUid ( ) { return m_docOrderNumber ; } protected ElemTemplateElement m_parentNode ; public Node getParentNode ( ) { return m_parentNode ; } public ElemTemplateElement getParentElem ( ) { return m_parentNode ; } public void setParentElem ( ElemTemplateElement p ) { m_parentNode = p ; } ElemTemplateElement m_nextSibling ; public Node getNextSibling ( ) { return m_nextSibling ; } public Node getPreviousSibling ( ) { Node walker = getParentNode ( ) , prev = null ; if ( walker != null ) for ( walker = walker . getFirstChild ( ) ; walker != null ; prev = walker , walker = walker . getNextSibling ( ) ) { if ( walker == this ) return prev ; } return null ; } public ElemTemplateElement getPreviousSiblingElem ( ) { ElemTemplateElement walker = getParentNodeElem ( ) ; ElemTemplateElement prev = null ; if ( walker != null ) for ( walker = walker . getFirstChildElem ( ) ; walker != null ; prev = walker , walker = walker . getNextSiblingElem ( ) ) { if ( walker == this ) return prev ; } return null ; } public ElemTemplateElement getNextSiblingElem ( ) { return m_nextSibling ; } public ElemTemplateElement getParentNodeElem ( ) { return m_parentNode ; } ElemTemplateElement m_firstChild ; public Node getFirstChild ( ) { return m_firstChild ; } public ElemTemplateElement getFirstChildElem ( ) { return m_firstChild ; } public Node getLastChild ( ) { ElemTemplateElement lastChild = null ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { lastChild = node ; } return lastChild ; } public ElemTemplateElement getLastChildElem ( ) { ElemTemplateElement lastChild = null ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { lastChild = node ; } return lastChild ; } transient private org . w3c . dom . Node m_DOMBackPointer ; public org . w3c . dom . Node getDOMBackPointer ( ) { return m_DOMBackPointer ; } public void setDOMBackPointer ( org . w3c . dom . Node n ) { m_DOMBackPointer = n ; } public int compareTo ( Object o ) throws ClassCastException { ElemTemplateElement ro = ( ElemTemplateElement ) o ; int roPrecedence = ro . getStylesheetComposed ( ) . getImportCountComposed ( ) ; int myPrecedence = this . getStylesheetComposed ( ) . getImportCountComposed ( ) ; if ( myPrecedence < roPrecedence ) return - 1 ; else if ( myPrecedence > roPrecedence ) return 1 ; else return this . getUid ( ) - ro . getUid ( ) ; } public boolean shouldStripWhiteSpace ( org . apache . xpath . XPathContext support , org . w3c . dom . Element targetElement ) throws TransformerException { StylesheetRoot sroot = this . getStylesheetRoot ( ) ; return ( null != sroot ) ? sroot . shouldStripWhiteSpace ( support , targetElement ) : false ; } public boolean canStripWhiteSpace ( ) { StylesheetRoot sroot = this . getStylesheetRoot ( ) ; return ( null != sroot ) ? sroot . canStripWhiteSpace ( ) : false ; } public boolean canAcceptVariables ( ) { return true ; } public void exprSetParent ( ExpressionNode n ) { setParentElem ( ( ElemTemplateElement ) n ) ; } public ExpressionNode exprGetParent ( ) { return getParentElem ( ) ; } public void exprAddChild ( ExpressionNode n , int i ) { appendChild ( ( ElemTemplateElement ) n ) ; } public ExpressionNode exprGetChild ( int i ) { return ( ExpressionNode ) item ( i ) ; } public int exprGetNumChildren ( ) { return getLength ( ) ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitInstruction ( this ) ; } public void callVisitors ( XSLTVisitor visitor ) { if ( accept ( visitor ) ) { callChildVisitors ( visitor ) ; } } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttributes ) { for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { node . callVisitors ( visitor ) ; } } protected void callChildVisitors ( XSLTVisitor visitor ) { callChildVisitors ( visitor , true ) ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1	['85', '2', '29', '94', '127', '3140', '83', '17', '74', '0.912698413', '1307', '0.75', '3', '0.564766839', '0.092041522', '1', '12', '14.23529412', '9', '1.5529', '4']
package org . apache . xml . utils ; import java . util . EmptyStackException ; public class IntStack extends IntVector { public IntStack ( ) { super ( ) ; } public IntStack ( int blocksize ) { super ( blocksize ) ; } public IntStack ( IntStack v ) { super ( v ) ; } public int push ( int i ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = i ; m_firstFree ++ ; return i ; } public final int pop ( ) { return m_map [ -- m_firstFree ] ; } public final void quickPop ( int n ) { m_firstFree -= n ; } public final int peek ( ) { try { return m_map [ m_firstFree - 1 ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public int peek ( int n ) { try { return m_map [ m_firstFree - ( 1 + n ) ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public void setTop ( int val ) { try { m_map [ m_firstFree - 1 ] = val ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public boolean empty ( ) { return m_firstFree == 0 ; } public int search ( int o ) { int i = lastIndexOf ( o ) ; if ( i >= 0 ) { return size ( ) - i ; } return - 1 ; } public Object clone ( ) throws CloneNotSupportedException { return ( IntStack ) super . clone ( ) ; } } 	1	['12', '2', '0', '11', '20', '24', '10', '1', '12', '2', '153', '0', '0', '0.64', '0.527777778', '1', '14', '11.75', '2', '1', '1']
package org . apache . xalan . lib . sql ; import java . sql . Connection ; import java . sql . SQLException ; import java . util . Properties ; public interface ConnectionPool { public boolean isEnabled ( ) ; public void setDriver ( String d ) ; public void setURL ( String url ) ; public void freeUnused ( ) ; public boolean hasActiveConnections ( ) ; public void setPassword ( String p ) ; public void setUser ( String u ) ; public void setMinConnections ( int n ) ; public boolean testConnection ( ) ; public Connection getConnection ( ) throws SQLException ; public void releaseConnection ( Connection con ) throws SQLException ; public void releaseConnectionOnError ( Connection con ) throws SQLException ; public void setPoolEnabled ( final boolean flag ) ; public void setProtocol ( Properties p ) ; } 	1	['14', '1', '0', '4', '14', '91', '4', '0', '14', '2', '14', '0', '0', '0', '0.273809524', '0', '0', '0', '1', '1', '1']
package org . apache . xpath ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . DOM2Helper ; import org . apache . xpath . axes . ContextNodeList ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeFilter ; import org . w3c . dom . traversal . NodeIterator ; public class NodeSet implements NodeList , NodeIterator , Cloneable , ContextNodeList { public NodeSet ( ) { m_blocksize = 32 ; m_mapSize = 0 ; } public NodeSet ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = 0 ; } public NodeSet ( NodeList nodelist ) { this ( 32 ) ; addNodes ( nodelist ) ; } public NodeSet ( NodeSet nodelist ) { this ( 32 ) ; addNodes ( ( NodeIterator ) nodelist ) ; } public NodeSet ( NodeIterator ni ) { this ( 32 ) ; addNodes ( ni ) ; } public NodeSet ( Node node ) { this ( 32 ) ; addNode ( node ) ; } public Node getRoot ( ) { return null ; } public NodeIterator cloneWithReset ( ) throws CloneNotSupportedException { NodeSet clone = ( NodeSet ) clone ( ) ; clone . reset ( ) ; return clone ; } public void reset ( ) { m_next = 0 ; } public int getWhatToShow ( ) { return NodeFilter . SHOW_ALL & ~ NodeFilter . SHOW_ENTITY_REFERENCE ; } public NodeFilter getFilter ( ) { return null ; } public boolean getExpandEntityReferences ( ) { return true ; } public Node nextNode ( ) throws DOMException { if ( ( m_next ) < this . size ( ) ) { Node next = this . elementAt ( m_next ) ; m_next ++ ; return next ; } else return null ; } public Node previousNode ( ) throws DOMException { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_ITERATE , null ) ) ; if ( ( m_next - 1 ) > 0 ) { m_next -- ; return this . elementAt ( m_next ) ; } else return null ; } public void detach ( ) { } public boolean isFresh ( ) { return ( m_next == 0 ) ; } public void runTo ( int index ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_INDEX , null ) ) ; if ( ( index >= 0 ) && ( m_next < m_firstFree ) ) m_next = index ; else m_next = m_firstFree - 1 ; } public Node item ( int index ) { runTo ( index ) ; return ( Node ) this . elementAt ( index ) ; } public int getLength ( ) { runTo ( - 1 ) ; return this . size ( ) ; } public void addNode ( Node n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; this . addElement ( n ) ; } public void insertNode ( Node n , int pos ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; insertElementAt ( n , pos ) ; } public void removeNode ( Node n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; this . removeElement ( n ) ; } public void addNodes ( NodeList nodelist ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null != nodelist ) { int nChildren = nodelist . getLength ( ) ; for ( int i = 0 ; i < nChildren ; i ++ ) { Node obj = nodelist . item ( i ) ; if ( null != obj ) { addElement ( obj ) ; } } } } public void addNodes ( NodeSet ns ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; addNodes ( ( NodeIterator ) ns ) ; } public void addNodes ( NodeIterator iterator ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null != iterator ) { Node obj ; while ( null != ( obj = iterator . nextNode ( ) ) ) { addElement ( obj ) ; } } } public void addNodesInDocOrder ( NodeList nodelist , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; int nChildren = nodelist . getLength ( ) ; for ( int i = 0 ; i < nChildren ; i ++ ) { Node node = nodelist . item ( i ) ; if ( null != node ) { addNodeInDocOrder ( node , support ) ; } } } public void addNodesInDocOrder ( NodeIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; Node node ; while ( null != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } } private boolean addNodesInDocOrder ( int start , int end , int testIndex , NodeList nodelist , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; boolean foundit = false ; int i ; Node node = nodelist . item ( testIndex ) ; for ( i = end ; i >= start ; i -- ) { Node child = ( Node ) elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } if ( ! DOM2Helper . isNodeAfter ( node , child ) ) { insertElementAt ( node , i + 1 ) ; testIndex -- ; if ( testIndex > 0 ) { boolean foundPrev = addNodesInDocOrder ( 0 , i , testIndex , nodelist , support ) ; if ( ! foundPrev ) { addNodesInDocOrder ( i , size ( ) - 1 , testIndex , nodelist , support ) ; } } break ; } } if ( i == - 1 ) { insertElementAt ( node , 0 ) ; } return foundit ; } public int addNodeInDocOrder ( Node node , boolean test , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; int insertIndex = - 1 ; if ( test ) { int size = size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { Node child = ( Node ) elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } if ( ! DOM2Helper . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; insertElementAt ( node , insertIndex ) ; } } else { insertIndex = this . size ( ) ; boolean foundit = false ; for ( int i = 0 ; i < insertIndex ; i ++ ) { if ( this . item ( i ) . equals ( node ) ) { foundit = true ; break ; } } if ( ! foundit ) addElement ( node ) ; } return insertIndex ; } public int addNodeInDocOrder ( Node node , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; return addNodeInDocOrder ( node , true , support ) ; } transient protected int m_next = 0 ; public int getCurrentPos ( ) { return m_next ; } public void setCurrentPos ( int i ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_INDEX , null ) ) ; m_next = i ; } public Node getCurrentNode ( ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_INDEX , null ) ) ; int saved = m_next ; Node n = ( m_next < m_firstFree ) ? elementAt ( m_next ) : null ; m_next = saved ; return n ; } transient protected boolean m_mutable = true ; transient protected boolean m_cacheNodes = true ; public boolean getShouldCacheNodes ( ) { return m_cacheNodes ; } public void setShouldCacheNodes ( boolean b ) { if ( ! isFresh ( ) ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_CALL_SETSHOULDCACHENODE , null ) ) ; m_cacheNodes = b ; m_mutable = true ; } transient private int m_last = 0 ; public int getLast ( ) { return m_last ; } public void setLast ( int last ) { m_last = last ; } private int m_blocksize ; Node m_map [ ] ; protected int m_firstFree = 0 ; private int m_mapSize ; public Object clone ( ) throws CloneNotSupportedException { NodeSet clone = ( NodeSet ) super . clone ( ) ; if ( ( null != this . m_map ) && ( this . m_map == clone . m_map ) ) { clone . m_map = new Node [ this . m_map . length ] ; System . arraycopy ( this . m_map , 0 , clone . m_map , 0 , this . m_map . length ) ; } return clone ; } public int size ( ) { return m_firstFree ; } public void addElement ( Node value ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( ( m_firstFree + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void push ( Node value ) { int ff = m_firstFree ; if ( ( ff + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , ff + 1 ) ; m_map = newMap ; } } m_map [ ff ] = value ; ff ++ ; m_firstFree = ff ; } public final Node pop ( ) { m_firstFree -- ; Node n = m_map [ m_firstFree ] ; m_map [ m_firstFree ] = null ; return n ; } public final Node popAndTop ( ) { m_firstFree -- ; m_map [ m_firstFree ] = null ; return ( m_firstFree == 0 ) ? null : m_map [ m_firstFree - 1 ] ; } public final void popQuick ( ) { m_firstFree -- ; m_map [ m_firstFree ] = null ; } public final Node peepOrNull ( ) { return ( ( null != m_map ) && ( m_firstFree > 0 ) ) ? m_map [ m_firstFree - 1 ] : null ; } public final void pushPair ( Node v1 , Node v2 ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { if ( ( m_firstFree + 2 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree ) ; m_map = newMap ; } } m_map [ m_firstFree ] = v1 ; m_map [ m_firstFree + 1 ] = v2 ; m_firstFree += 2 ; } public final void popPair ( ) { m_firstFree -= 2 ; m_map [ m_firstFree ] = null ; m_map [ m_firstFree + 1 ] = null ; } public final void setTail ( Node n ) { m_map [ m_firstFree - 1 ] = n ; } public final void setTailSub1 ( Node n ) { m_map [ m_firstFree - 2 ] = n ; } public final Node peepTail ( ) { return m_map [ m_firstFree - 1 ] ; } public final Node peepTailSub1 ( ) { return m_map [ m_firstFree - 2 ] ; } public void insertElementAt ( Node value , int at ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public void appendNodes ( NodeSet nodes ) { int nNodes = nodes . size ( ) ; if ( null == m_map ) { m_mapSize = nNodes + m_blocksize ; m_map = new Node [ m_mapSize ] ; } else if ( ( m_firstFree + nNodes ) >= m_mapSize ) { m_mapSize += ( nNodes + m_blocksize ) ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + nNodes ) ; m_map = newMap ; } System . arraycopy ( nodes . m_map , 0 , m_map , m_firstFree , nNodes ) ; m_firstFree += nNodes ; } public void removeAllElements ( ) { if ( null == m_map ) return ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = null ; } m_firstFree = 0 ; } public boolean removeElement ( Node s ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = null ; m_firstFree -- ; return true ; } } return false ; } public void removeElementAt ( int i ) { if ( null == m_map ) return ; if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = null ; } public void setElementAt ( Node node , int index ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } m_map [ index ] = node ; } public Node elementAt ( int i ) { if ( null == m_map ) return null ; return m_map [ i ] ; } public boolean contains ( Node s ) { runTo ( - 1 ) ; if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) return true ; } return false ; } public int indexOf ( Node elem , int index ) { runTo ( - 1 ) ; if ( null == m_map ) return - 1 ; for ( int i = index ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( elem ) ) return i ; } return - 1 ; } public int indexOf ( Node elem ) { runTo ( - 1 ) ; if ( null == m_map ) return - 1 ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( elem ) ) return i ; } return - 1 ; } } 	1	['61', '1', '0', '10', '71', '714', '6', '4', '60', '0.629166667', '1450', '0.875', '0', '0', '0.219262295', '0', '0', '22.63934426', '9', '2.2131', '2']
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . io . IOException ; import java . io . StringReader ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import java_cup . runtime . Symbol ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . AttributeList ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; public class Parser implements Constants , ContentHandler { private static final String XSL = "xsl" ; private static final String TRANSLET = "translet" ; private Locator _locator = null ; private XSLTC _xsltc ; private XPathParser _xpathParser ; private Vector _errors ; private Vector _warnings ; private Hashtable _instructionClasses ; private Hashtable _instructionAttrs ; ; private Hashtable _qNames ; private Hashtable _namespaces ; private QName _useAttributeSets ; private QName _excludeResultPrefixes ; private QName _extensionElementPrefixes ; private Hashtable _variableScope ; private Stylesheet _currentStylesheet ; private SymbolTable _symbolTable ; private Output _output ; private Template _template ; private boolean _rootNamespaceDef ; private SyntaxTreeNode _root ; private String _target ; private int _currentImportPrecedence ; public Parser ( XSLTC xsltc ) { _xsltc = xsltc ; } public void init ( ) { _qNames = new Hashtable ( 512 ) ; _namespaces = new Hashtable ( ) ; _instructionClasses = new Hashtable ( ) ; _instructionAttrs = new Hashtable ( ) ; _variableScope = new Hashtable ( ) ; _template = null ; _errors = new Vector ( ) ; _warnings = new Vector ( ) ; _symbolTable = new SymbolTable ( ) ; _xpathParser = new XPathParser ( this ) ; _currentStylesheet = null ; _output = null ; _root = null ; _rootNamespaceDef = false ; _currentImportPrecedence = 1 ; initStdClasses ( ) ; initInstructionAttrs ( ) ; initExtClasses ( ) ; initSymbolTable ( ) ; _useAttributeSets = getQName ( XSLT_URI , XSL , "use-attribute-sets" ) ; _excludeResultPrefixes = getQName ( XSLT_URI , XSL , "exclude-result-prefixes" ) ; _extensionElementPrefixes = getQName ( XSLT_URI , XSL , "extension-element-prefixes" ) ; } public void setOutput ( Output output ) { if ( _output != null ) { if ( _output . getImportPrecedence ( ) <= output . getImportPrecedence ( ) ) { String cdata = _output . getCdata ( ) ; output . mergeCdata ( cdata ) ; _output . disable ( ) ; _output = output ; } else { output . disable ( ) ; } } else { _output = output ; } } public Output getOutput ( ) { return _output ; } public Properties getOutputProperties ( ) { return getTopLevelStylesheet ( ) . getOutputProperties ( ) ; } public void addVariable ( Variable var ) { addVariableOrParam ( var ) ; } public void addParameter ( Param param ) { addVariableOrParam ( param ) ; } private void addVariableOrParam ( VariableBase var ) { Object existing = _variableScope . get ( var . getName ( ) ) ; if ( existing != null ) { if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; stack . push ( var ) ; } else if ( existing instanceof VariableBase ) { Stack stack = new Stack ( ) ; stack . push ( existing ) ; stack . push ( var ) ; _variableScope . put ( var . getName ( ) , stack ) ; } } else { _variableScope . put ( var . getName ( ) , var ) ; } } public void removeVariable ( QName name ) { Object existing = _variableScope . get ( name ) ; if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; if ( ! stack . isEmpty ( ) ) stack . pop ( ) ; if ( ! stack . isEmpty ( ) ) return ; } _variableScope . remove ( name ) ; } public VariableBase lookupVariable ( QName name ) { Object existing = _variableScope . get ( name ) ; if ( existing instanceof VariableBase ) { return ( ( VariableBase ) existing ) ; } else if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; return ( ( VariableBase ) stack . peek ( ) ) ; } return ( null ) ; } public void setXSLTC ( XSLTC xsltc ) { _xsltc = xsltc ; } public XSLTC getXSLTC ( ) { return _xsltc ; } public int getCurrentImportPrecedence ( ) { return _currentImportPrecedence ; } public int getNextImportPrecedence ( ) { return ++ _currentImportPrecedence ; } public void setCurrentStylesheet ( Stylesheet stylesheet ) { _currentStylesheet = stylesheet ; } public Stylesheet getCurrentStylesheet ( ) { return _currentStylesheet ; } public Stylesheet getTopLevelStylesheet ( ) { return _xsltc . getStylesheet ( ) ; } public QName getQNameSafe ( final String stringRep ) { final int colon = stringRep . lastIndexOf ( ':' ) ; if ( colon != - 1 ) { final String prefix = stringRep . substring ( 0 , colon ) ; final String localname = stringRep . substring ( colon + 1 ) ; String namespace = null ; if ( prefix . equals ( XMLNS_PREFIX ) == false ) { namespace = _symbolTable . lookupNamespace ( prefix ) ; if ( namespace == null ) namespace = EMPTYSTRING ; } return getQName ( namespace , prefix , localname ) ; } else { final String uri = stringRep . equals ( XMLNS_PREFIX ) ? null : _symbolTable . lookupNamespace ( EMPTYSTRING ) ; return getQName ( uri , null , stringRep ) ; } } public QName getQName ( final String stringRep ) { return getQName ( stringRep , true , false ) ; } public QName getQNameIgnoreDefaultNs ( final String stringRep ) { return getQName ( stringRep , true , true ) ; } public QName getQName ( final String stringRep , boolean reportError ) { return getQName ( stringRep , reportError , false ) ; } private QName getQName ( final String stringRep , boolean reportError , boolean ignoreDefaultNs ) { final int colon = stringRep . lastIndexOf ( ':' ) ; if ( colon != - 1 ) { final String prefix = stringRep . substring ( 0 , colon ) ; final String localname = stringRep . substring ( colon + 1 ) ; String namespace = null ; if ( prefix . equals ( XMLNS_PREFIX ) == false ) { namespace = _symbolTable . lookupNamespace ( prefix ) ; if ( namespace == null && reportError ) { final int line = _locator . getLineNumber ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . NAMESPACE_UNDEF_ERR , line , prefix ) ; reportError ( ERROR , err ) ; } } return getQName ( namespace , prefix , localname ) ; } else { if ( stringRep . equals ( XMLNS_PREFIX ) ) { ignoreDefaultNs = true ; } final String defURI = ignoreDefaultNs ? null : _symbolTable . lookupNamespace ( EMPTYSTRING ) ; return getQName ( defURI , null , stringRep ) ; } } public QName getQName ( String namespace , String prefix , String localname ) { if ( namespace == null || namespace . equals ( EMPTYSTRING ) ) { QName name = ( QName ) _qNames . get ( localname ) ; if ( name == null ) { name = new QName ( null , prefix , localname ) ; _qNames . put ( localname , name ) ; } return name ; } else { Dictionary space = ( Dictionary ) _namespaces . get ( namespace ) ; if ( space == null ) { final QName name = new QName ( namespace , prefix , localname ) ; _namespaces . put ( namespace , space = new Hashtable ( ) ) ; space . put ( localname , name ) ; return name ; } else { QName name = ( QName ) space . get ( localname ) ; if ( name == null ) { name = new QName ( namespace , prefix , localname ) ; space . put ( localname , name ) ; } return name ; } } } public QName getQName ( String scope , String name ) { return getQName ( scope + name ) ; } public QName getQName ( QName scope , QName name ) { return getQName ( scope . toString ( ) + name . toString ( ) ) ; } public QName getUseAttributeSets ( ) { return _useAttributeSets ; } public QName getExtensionElementPrefixes ( ) { return _extensionElementPrefixes ; } public QName getExcludeResultPrefixes ( ) { return _excludeResultPrefixes ; } public Stylesheet makeStylesheet ( SyntaxTreeNode element ) throws CompilerException { try { Stylesheet stylesheet ; if ( element instanceof Stylesheet ) { stylesheet = ( Stylesheet ) element ; } else { stylesheet = new Stylesheet ( ) ; stylesheet . setSimplified ( ) ; stylesheet . addElement ( element ) ; stylesheet . setAttributes ( element . getAttributes ( ) ) ; if ( element . lookupNamespace ( EMPTYSTRING ) == null ) { element . addPrefixMapping ( EMPTYSTRING , EMPTYSTRING ) ; } } stylesheet . setParser ( this ) ; return stylesheet ; } catch ( ClassCastException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NOT_STYLESHEET_ERR , element ) ; throw new CompilerException ( err . toString ( ) ) ; } } public void createAST ( Stylesheet stylesheet ) { try { if ( stylesheet != null ) { stylesheet . parseContents ( this ) ; final int precedence = stylesheet . getImportPrecedence ( ) ; final Enumeration elements = stylesheet . elements ( ) ; while ( elements . hasMoreElements ( ) ) { Object child = elements . nextElement ( ) ; if ( child instanceof Text ) { final int l = _locator . getLineNumber ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_TEXT_NODE_ERR , l , null ) ; reportError ( ERROR , err ) ; } } if ( ! errorsFound ( ) ) { stylesheet . typeCheck ( _symbolTable ) ; } } } catch ( TypeCheckError e ) { reportError ( ERROR , new ErrorMsg ( e ) ) ; } } public SyntaxTreeNode parse ( XMLReader reader , InputSource input ) { try { reader . setContentHandler ( this ) ; reader . parse ( input ) ; return ( SyntaxTreeNode ) getStylesheet ( _root ) ; } catch ( IOException e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e ) ) ; } catch ( SAXException e ) { Throwable ex = e . getException ( ) ; if ( _xsltc . debug ( ) ) { e . printStackTrace ( ) ; if ( ex != null ) ex . printStackTrace ( ) ; } reportError ( ERROR , new ErrorMsg ( e ) ) ; } catch ( CompilerException e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e ) ) ; } catch ( Exception e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e ) ) ; } return null ; } public SyntaxTreeNode parse ( InputSource input ) { try { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { factory . setFeature ( Constants . NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { factory . setNamespaceAware ( true ) ; } final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; return ( parse ( reader , input ) ) ; } catch ( ParserConfigurationException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . SAX_PARSER_CONFIG_ERR ) ; reportError ( ERROR , err ) ; } catch ( SAXParseException e ) { reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) , e . getLineNumber ( ) ) ) ; } catch ( SAXException e ) { reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) ) ) ; } return null ; } public SyntaxTreeNode getDocumentRoot ( ) { return _root ; } private String _PImedia = null ; private String _PItitle = null ; private String _PIcharset = null ; protected void setPIParameters ( String media , String title , String charset ) { _PImedia = media ; _PItitle = title ; _PIcharset = charset ; } private SyntaxTreeNode getStylesheet ( SyntaxTreeNode root ) throws CompilerException { if ( _target == null ) { if ( ! _rootNamespaceDef ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . MISSING_XSLT_URI_ERR ) ; throw new CompilerException ( msg . toString ( ) ) ; } return ( root ) ; } if ( _target . charAt ( 0 ) == '#' ) { SyntaxTreeNode element = findStylesheet ( root , _target . substring ( 1 ) ) ; if ( element == null ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . MISSING_XSLT_TARGET_ERR , _target , root ) ; throw new CompilerException ( msg . toString ( ) ) ; } return ( element ) ; } else { return ( loadExternalStylesheet ( _target ) ) ; } } private SyntaxTreeNode findStylesheet ( SyntaxTreeNode root , String href ) { if ( root == null ) return null ; if ( root instanceof Stylesheet ) { String id = root . getAttribute ( "id" ) ; if ( id . equals ( href ) ) return root ; } Vector children = root . getContents ( ) ; if ( children != null ) { final int count = children . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) children . elementAt ( i ) ; SyntaxTreeNode node = findStylesheet ( child , href ) ; if ( node != null ) return node ; } } return null ; } private SyntaxTreeNode loadExternalStylesheet ( String location ) throws CompilerException { InputSource source ; if ( ( new File ( location ) ) . exists ( ) ) source = new InputSource ( "file:" + location ) ; else source = new InputSource ( location ) ; SyntaxTreeNode external = ( SyntaxTreeNode ) parse ( source ) ; return ( external ) ; } private void initAttrTable ( String elementName , String [ ] attrs ) { _instructionAttrs . put ( getQName ( XSLT_URI , XSL , elementName ) , attrs ) ; } private void initInstructionAttrs ( ) { initAttrTable ( "template" , new String [ ] { "match" , "name" , "priority" , "mode" } ) ; initAttrTable ( "stylesheet" , new String [ ] { "id" , "version" , "extension-element-prefixes" , "exclude-result-prefixes" } ) ; initAttrTable ( "transform" , new String [ ] { "id" , "version" , "extension-element-prefixes" , "exclude-result-prefixes" } ) ; initAttrTable ( "text" , new String [ ] { "disable-output-escaping" } ) ; initAttrTable ( "if" , new String [ ] { "test" } ) ; initAttrTable ( "choose" , new String [ ] { } ) ; initAttrTable ( "when" , new String [ ] { "test" } ) ; initAttrTable ( "otherwise" , new String [ ] { } ) ; initAttrTable ( "for-each" , new String [ ] { "select" } ) ; initAttrTable ( "message" , new String [ ] { "terminate" } ) ; initAttrTable ( "number" , new String [ ] { "level" , "count" , "from" , "value" , "format" , "lang" , "letter-value" , "grouping-separator" , "grouping-size" } ) ; initAttrTable ( "comment" , new String [ ] { } ) ; initAttrTable ( "copy" , new String [ ] { "use-attribute-sets" } ) ; initAttrTable ( "copy-of" , new String [ ] { "select" } ) ; initAttrTable ( "param" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "with-param" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "variable" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "output" , new String [ ] { "method" , "version" , "encoding" , "omit-xml-declaration" , "standalone" , "doctype-public" , "doctype-system" , "cdata-section-elements" , "indent" , "media-type" } ) ; initAttrTable ( "sort" , new String [ ] { "select" , "order" , "case-order" , "lang" , "data-type" } ) ; initAttrTable ( "key" , new String [ ] { "name" , "match" , "use" } ) ; initAttrTable ( "fallback" , new String [ ] { } ) ; initAttrTable ( "attribute" , new String [ ] { "name" , "namespace" } ) ; initAttrTable ( "attribute-set" , new String [ ] { "name" , "use-attribute-sets" } ) ; initAttrTable ( "value-of" , new String [ ] { "select" , "disable-output-escaping" } ) ; initAttrTable ( "element" , new String [ ] { "name" , "namespace" , "use-attribute-sets" } ) ; initAttrTable ( "call-template" , new String [ ] { "name" } ) ; initAttrTable ( "apply-templates" , new String [ ] { "select" , "mode" } ) ; initAttrTable ( "apply-imports" , new String [ ] { } ) ; initAttrTable ( "decimal-format" , new String [ ] { "name" , "decimal-separator" , "grouping-separator" , "infinity" , "minus-sign" , "NaN" , "percent" , "per-mille" , "zero-digit" , "digit" , "pattern-separator" } ) ; initAttrTable ( "import" , new String [ ] { "href" } ) ; initAttrTable ( "include" , new String [ ] { "href" } ) ; initAttrTable ( "strip-space" , new String [ ] { "elements" } ) ; initAttrTable ( "preserve-space" , new String [ ] { "elements" } ) ; initAttrTable ( "processing-instruction" , new String [ ] { "name" } ) ; initAttrTable ( "namespace-alias" , new String [ ] { "stylesheet-prefix" , "result-prefix" } ) ; } private void initStdClasses ( ) { initStdClass ( "template" , "Template" ) ; initStdClass ( "stylesheet" , "Stylesheet" ) ; initStdClass ( "transform" , "Stylesheet" ) ; initStdClass ( "text" , "Text" ) ; initStdClass ( "if" , "If" ) ; initStdClass ( "choose" , "Choose" ) ; initStdClass ( "when" , "When" ) ; initStdClass ( "otherwise" , "Otherwise" ) ; initStdClass ( "for-each" , "ForEach" ) ; initStdClass ( "message" , "Message" ) ; initStdClass ( "number" , "Number" ) ; initStdClass ( "comment" , "Comment" ) ; initStdClass ( "copy" , "Copy" ) ; initStdClass ( "copy-of" , "CopyOf" ) ; initStdClass ( "param" , "Param" ) ; initStdClass ( "with-param" , "WithParam" ) ; initStdClass ( "variable" , "Variable" ) ; initStdClass ( "output" , "Output" ) ; initStdClass ( "sort" , "Sort" ) ; initStdClass ( "key" , "Key" ) ; initStdClass ( "fallback" , "Fallback" ) ; initStdClass ( "attribute" , "XslAttribute" ) ; initStdClass ( "attribute-set" , "AttributeSet" ) ; initStdClass ( "value-of" , "ValueOf" ) ; initStdClass ( "element" , "XslElement" ) ; initStdClass ( "call-template" , "CallTemplate" ) ; initStdClass ( "apply-templates" , "ApplyTemplates" ) ; initStdClass ( "apply-imports" , "ApplyImports" ) ; initStdClass ( "decimal-format" , "DecimalFormatting" ) ; initStdClass ( "import" , "Import" ) ; initStdClass ( "include" , "Include" ) ; initStdClass ( "strip-space" , "Whitespace" ) ; initStdClass ( "preserve-space" , "Whitespace" ) ; initStdClass ( "processing-instruction" , "ProcessingInstruction" ) ; initStdClass ( "namespace-alias" , "NamespaceAlias" ) ; } private void initStdClass ( String elementName , String className ) { _instructionClasses . put ( getQName ( XSLT_URI , XSL , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } public boolean elementSupported ( String namespace , String localName ) { return ( _instructionClasses . get ( getQName ( namespace , XSL , localName ) ) != null ) ; } public boolean functionSupported ( String fname ) { return ( _symbolTable . lookupPrimop ( fname ) != null ) ; } private void initExtClasses ( ) { initExtClass ( "output" , "TransletOutput" ) ; initExtClass ( REDIRECT_URI , "write" , "TransletOutput" ) ; } private void initExtClass ( String elementName , String className ) { _instructionClasses . put ( getQName ( TRANSLET_URI , TRANSLET , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } private void initExtClass ( String namespace , String elementName , String className ) { _instructionClasses . put ( getQName ( namespace , TRANSLET , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } private void initSymbolTable ( ) { MethodType I_V = new MethodType ( Type . Int , Type . Void ) ; MethodType I_R = new MethodType ( Type . Int , Type . Real ) ; MethodType I_S = new MethodType ( Type . Int , Type . String ) ; MethodType I_D = new MethodType ( Type . Int , Type . NodeSet ) ; MethodType R_I = new MethodType ( Type . Real , Type . Int ) ; MethodType R_V = new MethodType ( Type . Real , Type . Void ) ; MethodType R_R = new MethodType ( Type . Real , Type . Real ) ; MethodType R_D = new MethodType ( Type . Real , Type . NodeSet ) ; MethodType R_O = new MethodType ( Type . Real , Type . Reference ) ; MethodType I_I = new MethodType ( Type . Int , Type . Int ) ; MethodType D_O = new MethodType ( Type . NodeSet , Type . Reference ) ; MethodType D_V = new MethodType ( Type . NodeSet , Type . Void ) ; MethodType D_S = new MethodType ( Type . NodeSet , Type . String ) ; MethodType D_D = new MethodType ( Type . NodeSet , Type . NodeSet ) ; MethodType A_V = new MethodType ( Type . Node , Type . Void ) ; MethodType S_V = new MethodType ( Type . String , Type . Void ) ; MethodType S_S = new MethodType ( Type . String , Type . String ) ; MethodType S_A = new MethodType ( Type . String , Type . Node ) ; MethodType S_D = new MethodType ( Type . String , Type . NodeSet ) ; MethodType S_O = new MethodType ( Type . String , Type . Reference ) ; MethodType B_O = new MethodType ( Type . Boolean , Type . Reference ) ; MethodType B_V = new MethodType ( Type . Boolean , Type . Void ) ; MethodType B_B = new MethodType ( Type . Boolean , Type . Boolean ) ; MethodType B_S = new MethodType ( Type . Boolean , Type . String ) ; MethodType D_X = new MethodType ( Type . NodeSet , Type . Object ) ; MethodType R_RR = new MethodType ( Type . Real , Type . Real , Type . Real ) ; MethodType I_II = new MethodType ( Type . Int , Type . Int , Type . Int ) ; MethodType B_RR = new MethodType ( Type . Boolean , Type . Real , Type . Real ) ; MethodType B_II = new MethodType ( Type . Boolean , Type . Int , Type . Int ) ; MethodType S_SS = new MethodType ( Type . String , Type . String , Type . String ) ; MethodType S_DS = new MethodType ( Type . String , Type . Real , Type . String ) ; MethodType S_SR = new MethodType ( Type . String , Type . String , Type . Real ) ; MethodType D_SS = new MethodType ( Type . NodeSet , Type . String , Type . String ) ; MethodType D_SD = new MethodType ( Type . NodeSet , Type . String , Type . NodeSet ) ; MethodType B_BB = new MethodType ( Type . Boolean , Type . Boolean , Type . Boolean ) ; MethodType B_SS = new MethodType ( Type . Boolean , Type . String , Type . String ) ; MethodType S_SD = new MethodType ( Type . String , Type . String , Type . NodeSet ) ; MethodType S_DSS = new MethodType ( Type . String , Type . Real , Type . String , Type . String ) ; MethodType S_SRR = new MethodType ( Type . String , Type . String , Type . Real , Type . Real ) ; MethodType S_SSS = new MethodType ( Type . String , Type . String , Type . String , Type . String ) ; _symbolTable . addPrimop ( "current" , A_V ) ; _symbolTable . addPrimop ( "last" , I_V ) ; _symbolTable . addPrimop ( "position" , I_V ) ; _symbolTable . addPrimop ( "true" , B_V ) ; _symbolTable . addPrimop ( "false" , B_V ) ; _symbolTable . addPrimop ( "not" , B_B ) ; _symbolTable . addPrimop ( "name" , S_V ) ; _symbolTable . addPrimop ( "name" , S_A ) ; _symbolTable . addPrimop ( "generate-id" , S_V ) ; _symbolTable . addPrimop ( "generate-id" , S_A ) ; _symbolTable . addPrimop ( "ceiling" , R_R ) ; _symbolTable . addPrimop ( "floor" , R_R ) ; _symbolTable . addPrimop ( "round" , R_R ) ; _symbolTable . addPrimop ( "contains" , B_SS ) ; _symbolTable . addPrimop ( "number" , R_O ) ; _symbolTable . addPrimop ( "number" , R_V ) ; _symbolTable . addPrimop ( "boolean" , B_O ) ; _symbolTable . addPrimop ( "string" , S_O ) ; _symbolTable . addPrimop ( "string" , S_V ) ; _symbolTable . addPrimop ( "translate" , S_SSS ) ; _symbolTable . addPrimop ( "string-length" , I_V ) ; _symbolTable . addPrimop ( "string-length" , I_S ) ; _symbolTable . addPrimop ( "starts-with" , B_SS ) ; _symbolTable . addPrimop ( "format-number" , S_DS ) ; _symbolTable . addPrimop ( "format-number" , S_DSS ) ; _symbolTable . addPrimop ( "unparsed-entity-uri" , S_S ) ; _symbolTable . addPrimop ( "key" , D_SS ) ; _symbolTable . addPrimop ( "key" , D_SD ) ; _symbolTable . addPrimop ( "id" , D_S ) ; _symbolTable . addPrimop ( "id" , D_D ) ; _symbolTable . addPrimop ( "namespace-uri" , S_V ) ; _symbolTable . addPrimop ( "function-available" , B_S ) ; _symbolTable . addPrimop ( "element-available" , B_S ) ; _symbolTable . addPrimop ( "document" , D_S ) ; _symbolTable . addPrimop ( "document" , D_V ) ; _symbolTable . addPrimop ( "count" , I_D ) ; _symbolTable . addPrimop ( "sum" , R_D ) ; _symbolTable . addPrimop ( "local-name" , S_V ) ; _symbolTable . addPrimop ( "local-name" , S_D ) ; _symbolTable . addPrimop ( "namespace-uri" , S_V ) ; _symbolTable . addPrimop ( "namespace-uri" , S_D ) ; _symbolTable . addPrimop ( "substring" , S_SR ) ; _symbolTable . addPrimop ( "substring" , S_SRR ) ; _symbolTable . addPrimop ( "substring-after" , S_SS ) ; _symbolTable . addPrimop ( "substring-before" , S_SS ) ; _symbolTable . addPrimop ( "normalize-space" , S_V ) ; _symbolTable . addPrimop ( "normalize-space" , S_S ) ; _symbolTable . addPrimop ( "system-property" , S_S ) ; _symbolTable . addPrimop ( "nodeset" , D_O ) ; _symbolTable . addPrimop ( "objectType" , S_O ) ; _symbolTable . addPrimop ( "+" , R_RR ) ; _symbolTable . addPrimop ( "-" , R_RR ) ; _symbolTable . addPrimop ( "*" , R_RR ) ; _symbolTable . addPrimop ( "/" , R_RR ) ; _symbolTable . addPrimop ( "%" , R_RR ) ; _symbolTable . addPrimop ( "+" , I_II ) ; _symbolTable . addPrimop ( "-" , I_II ) ; _symbolTable . addPrimop ( "*" , I_II ) ; _symbolTable . addPrimop ( "<" , B_RR ) ; _symbolTable . addPrimop ( "<=" , B_RR ) ; _symbolTable . addPrimop ( ">" , B_RR ) ; _symbolTable . addPrimop ( ">=" , B_RR ) ; _symbolTable . addPrimop ( "<" , B_II ) ; _symbolTable . addPrimop ( "<=" , B_II ) ; _symbolTable . addPrimop ( ">" , B_II ) ; _symbolTable . addPrimop ( ">=" , B_II ) ; _symbolTable . addPrimop ( "<" , B_BB ) ; _symbolTable . addPrimop ( "<=" , B_BB ) ; _symbolTable . addPrimop ( ">" , B_BB ) ; _symbolTable . addPrimop ( ">=" , B_BB ) ; _symbolTable . addPrimop ( "or" , B_BB ) ; _symbolTable . addPrimop ( "and" , B_BB ) ; _symbolTable . addPrimop ( "u-" , R_R ) ; _symbolTable . addPrimop ( "u-" , I_I ) ; } public SymbolTable getSymbolTable ( ) { return _symbolTable ; } public Template getTemplate ( ) { return _template ; } public void setTemplate ( Template template ) { _template = template ; } private int _templateIndex = 0 ; public int getTemplateIndex ( ) { return ( _templateIndex ++ ) ; } private boolean versionIsOne = true ; public SyntaxTreeNode makeInstance ( String uri , String prefix , String local , Attributes attributes ) { SyntaxTreeNode node = null ; QName qname = getQName ( uri , prefix , local ) ; String className = ( String ) _instructionClasses . get ( qname ) ; if ( className != null ) { try { final Class clazz = Class . forName ( className ) ; node = ( SyntaxTreeNode ) clazz . newInstance ( ) ; node . setQName ( qname ) ; node . setParser ( this ) ; if ( _locator != null ) { node . setLineNumber ( _locator . getLineNumber ( ) ) ; } if ( node instanceof Stylesheet ) { _xsltc . setStylesheet ( ( Stylesheet ) node ) ; } checkForSuperfluousAttributes ( node , attributes ) ; } catch ( ClassNotFoundException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , node ) ; reportError ( ERROR , err ) ; } catch ( Exception e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , e . getMessage ( ) , node ) ; reportError ( FATAL , err ) ; } } else { if ( uri != null ) { if ( uri . equals ( XSLT_URI ) ) { node = new UnsupportedElement ( uri , prefix , local ) ; UnsupportedElement element = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_XSL_ERR , _locator . getLineNumber ( ) , local ) ; element . setErrorMessage ( msg ) ; } else if ( uri . equals ( TRANSLET_URI ) ) { node = new UnsupportedElement ( uri , prefix , local ) ; UnsupportedElement element = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_EXT_ERR , _locator . getLineNumber ( ) , local ) ; element . setErrorMessage ( msg ) ; } else { Stylesheet sheet = _xsltc . getStylesheet ( ) ; if ( ( sheet != null ) && ( sheet . isExtension ( uri ) ) ) { if ( sheet != ( SyntaxTreeNode ) _parentStack . peek ( ) ) { node = new UnsupportedElement ( uri , prefix , local ) ; UnsupportedElement elem = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_EXT_ERR , _locator . getLineNumber ( ) , prefix + ":" + local ) ; elem . setErrorMessage ( msg ) ; } } } } if ( node == null ) node = new LiteralElement ( ) ; } if ( ( node != null ) && ( node instanceof LiteralElement ) ) { ( ( LiteralElement ) node ) . setQName ( qname ) ; } return ( node ) ; } private void checkForSuperfluousAttributes ( SyntaxTreeNode node , Attributes attrs ) { QName qname = node . getQName ( ) ; boolean isStylesheet = ( node instanceof Stylesheet ) ; String [ ] legal = ( String [ ] ) _instructionAttrs . get ( qname ) ; if ( versionIsOne && legal != null ) { int j ; final int n = attrs . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final String attrQName = attrs . getQName ( i ) ; if ( isStylesheet && attrQName . equals ( "version" ) ) { versionIsOne = attrs . getValue ( i ) . equals ( "1.0" ) ; } if ( attrQName . startsWith ( "xml" ) || attrQName . indexOf ( ':' ) > 0 ) continue ; for ( j = 0 ; j < legal . length ; j ++ ) { if ( attrQName . equalsIgnoreCase ( legal [ j ] ) ) { break ; } } if ( j == legal . length ) { final ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , attrQName , node ) ; reportError ( WARNING , err ) ; } } } } public Expression parseExpression ( SyntaxTreeNode parent , String exp ) { return ( Expression ) parseTopLevel ( parent , "<EXPRESSION>" + exp , null ) ; } public Expression parseExpression ( SyntaxTreeNode parent , String attr , String def ) { String exp = parent . getAttribute ( attr ) ; if ( ( exp . length ( ) == 0 ) && ( def != null ) ) exp = def ; return ( Expression ) parseTopLevel ( parent , "<EXPRESSION>" + exp , exp ) ; } public Pattern parsePattern ( SyntaxTreeNode parent , String pattern ) { return ( Pattern ) parseTopLevel ( parent , "<PATTERN>" + pattern , pattern ) ; } public Pattern parsePattern ( SyntaxTreeNode parent , String attr , String def ) { String pattern = parent . getAttribute ( attr ) ; if ( ( pattern . length ( ) == 0 ) && ( def != null ) ) pattern = def ; return ( Pattern ) parseTopLevel ( parent , "<PATTERN>" + pattern , pattern ) ; } private SyntaxTreeNode parseTopLevel ( SyntaxTreeNode parent , String text , String expression ) { int line = 0 ; if ( _locator != null ) line = _locator . getLineNumber ( ) ; try { _xpathParser . setScanner ( new XPathLexer ( new StringReader ( text ) ) ) ; Symbol result = _xpathParser . parse ( expression , line ) ; if ( result != null ) { final SyntaxTreeNode node = ( SyntaxTreeNode ) result . value ; if ( node != null ) { node . setParser ( this ) ; node . setParent ( parent ) ; node . setLineNumber ( line ) ; return node ; } } reportError ( ERROR , new ErrorMsg ( ErrorMsg . XPATH_PARSER_ERR , expression , parent ) ) ; } catch ( Exception e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( ErrorMsg . XPATH_PARSER_ERR , expression , parent ) ) ; } SyntaxTreeNode . Dummy . setParser ( this ) ; return SyntaxTreeNode . Dummy ; } public boolean errorsFound ( ) { return _errors . size ( ) > 0 ; } public void printErrors ( ) { final int size = _errors . size ( ) ; if ( size > 0 ) { System . err . println ( new ErrorMsg ( ErrorMsg . COMPILER_ERROR_KEY ) ) ; for ( int i = 0 ; i < size ; i ++ ) { System . err . println ( "  " + _errors . elementAt ( i ) ) ; } } } public void printWarnings ( ) { final int size = _warnings . size ( ) ; if ( size > 0 ) { System . err . println ( new ErrorMsg ( ErrorMsg . COMPILER_WARNING_KEY ) ) ; for ( int i = 0 ; i < size ; i ++ ) { System . err . println ( "  " + _warnings . elementAt ( i ) ) ; } } } public void reportError ( final int category , final ErrorMsg error ) { switch ( category ) { case Constants . INTERNAL : _errors . addElement ( error ) ; break ; case Constants . UNSUPPORTED : _errors . addElement ( error ) ; break ; case Constants . FATAL : _errors . addElement ( error ) ; break ; case Constants . ERROR : _errors . addElement ( error ) ; break ; case Constants . WARNING : _warnings . addElement ( error ) ; break ; } } public Vector getErrors ( ) { return _errors ; } public Vector getWarnings ( ) { return _warnings ; } private Stack _parentStack = null ; private Hashtable _prefixMapping = null ; public void startDocument ( ) { _root = null ; _target = null ; _prefixMapping = null ; _parentStack = new Stack ( ) ; } public void endDocument ( ) { } public void startPrefixMapping ( String prefix , String uri ) { if ( _prefixMapping == null ) { _prefixMapping = new Hashtable ( ) ; } _prefixMapping . put ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) { } public void startElement ( String uri , String localname , String qname , Attributes attributes ) throws SAXException { final int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col == - 1 ) ? null : qname . substring ( 0 , col ) ; SyntaxTreeNode element = makeInstance ( uri , prefix , localname , attributes ) ; if ( element == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ELEMENT_PARSE_ERR , prefix + ':' + localname ) ; throw new SAXException ( err . toString ( ) ) ; } if ( _root == null ) { if ( ( _prefixMapping == null ) || ( _prefixMapping . containsValue ( Constants . XSLT_URI ) == false ) ) _rootNamespaceDef = false ; else _rootNamespaceDef = true ; _root = element ; } else { SyntaxTreeNode parent = ( SyntaxTreeNode ) _parentStack . peek ( ) ; parent . addElement ( element ) ; element . setParent ( parent ) ; } element . setAttributes ( ( Attributes ) new AttributeList ( attributes ) ) ; element . setPrefixMapping ( _prefixMapping ) ; if ( element instanceof Stylesheet ) { getSymbolTable ( ) . setCurrentNode ( element ) ; ( ( Stylesheet ) element ) . excludeExtensionPrefixes ( this ) ; } _prefixMapping = null ; _parentStack . push ( element ) ; } public void endElement ( String uri , String localname , String qname ) { _parentStack . pop ( ) ; } public void characters ( char [ ] ch , int start , int length ) { String string = new String ( ch , start , length ) ; SyntaxTreeNode parent = ( SyntaxTreeNode ) _parentStack . peek ( ) ; if ( string . length ( ) == 0 ) return ; if ( parent instanceof Text ) { ( ( Text ) parent ) . setText ( string ) ; return ; } if ( parent instanceof Stylesheet ) return ; SyntaxTreeNode bro = parent . lastChild ( ) ; if ( ( bro != null ) && ( bro instanceof Text ) ) { Text text = ( Text ) bro ; if ( ! text . isTextElement ( ) ) { if ( ( length > 1 ) || ( ( ( int ) ch [ 0 ] ) < 0x100 ) ) { text . setText ( string ) ; return ; } } } parent . addElement ( new Text ( string ) ) ; } private String getTokenValue ( String token ) { final int start = token . indexOf ( '"' ) ; final int stop = token . lastIndexOf ( '"' ) ; return token . substring ( start + 1 , stop ) ; } public void processingInstruction ( String name , String value ) { if ( ( _target == null ) && ( name . equals ( "xml-stylesheet" ) ) ) { String href = null ; String media = null ; String title = null ; String charset = null ; StringTokenizer tokens = new StringTokenizer ( value ) ; while ( tokens . hasMoreElements ( ) ) { String token = ( String ) tokens . nextElement ( ) ; if ( token . startsWith ( "href" ) ) href = getTokenValue ( token ) ; else if ( token . startsWith ( "media" ) ) media = getTokenValue ( token ) ; else if ( token . startsWith ( "title" ) ) title = getTokenValue ( token ) ; else if ( token . startsWith ( "charset" ) ) charset = getTokenValue ( token ) ; } if ( ( ( _PImedia == null ) || ( _PImedia . equals ( media ) ) ) && ( ( _PItitle == null ) || ( _PImedia . equals ( title ) ) ) && ( ( _PIcharset == null ) || ( _PImedia . equals ( charset ) ) ) ) { _target = href ; } } } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { } public void skippedEntity ( String name ) { } public void setDocumentLocator ( Locator locator ) { _locator = locator ; } } 	1	['76', '1', '0', '97', '204', '2562', '87', '23', '59', '0.933777778', '3281', '1', '9', '0', '0.093421053', '0', '0', '41.77631579', '13', '2.25', '1']
package org . apache . xalan . lib ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xpath . NodeSet ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . xml . sax . SAXNotSupportedException ; public class ExsltDynamic extends ExsltBase { public static final String EXSL_URI = "http://exslt.org/common" ; public static double max ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return Double . NaN ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; double maxValue = - Double . MAX_VALUE ; for ( int i = 0 ; i < contextNodes . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; double result = 0 ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; result = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) . num ( ) ; } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return Double . NaN ; } xctxt . popCurrentNode ( ) ; if ( result > maxValue ) maxValue = result ; } xctxt . popContextNodeList ( ) ; return maxValue ; } public static double min ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return Double . NaN ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; double minValue = Double . MAX_VALUE ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; double result = 0 ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; result = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) . num ( ) ; } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return Double . NaN ; } xctxt . popCurrentNode ( ) ; if ( result < minValue ) minValue = result ; } xctxt . popContextNodeList ( ) ; return minValue ; } public static double sum ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return Double . NaN ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; double sum = 0 ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; double result = 0 ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; result = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) . num ( ) ; } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return Double . NaN ; } xctxt . popCurrentNode ( ) ; sum = sum + result ; } xctxt . popContextNodeList ( ) ; return sum ; } public static NodeList map ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; Document lDoc = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return new NodeSet ( ) ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; NodeSet resultSet = new NodeSet ( ) ; resultSet . setShouldCacheNodes ( true ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; XObject object = null ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; object = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) ; if ( object instanceof XNodeSet ) { NodeList nodelist = null ; nodelist = ( ( XNodeSet ) object ) . nodelist ( ) ; for ( int k = 0 ; k < nodelist . getLength ( ) ; k ++ ) { Node n = nodelist . item ( k ) ; if ( ! resultSet . contains ( n ) ) resultSet . addNode ( n ) ; } } else { if ( lDoc == null ) { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; lDoc = db . newDocument ( ) ; } Element element = null ; if ( object instanceof XNumber ) element = lDoc . createElementNS ( EXSL_URI , "exsl:number" ) ; else if ( object instanceof XBoolean ) element = lDoc . createElementNS ( EXSL_URI , "exsl:boolean" ) ; else element = lDoc . createElementNS ( EXSL_URI , "exsl:string" ) ; Text textNode = lDoc . createTextNode ( object . str ( ) ) ; element . appendChild ( textNode ) ; resultSet . addNode ( element ) ; } } catch ( Exception e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return new NodeSet ( ) ; } xctxt . popCurrentNode ( ) ; } xctxt . popContextNodeList ( ) ; return resultSet ; } public static XObject evaluate ( ExpressionContext myContext , String xpathExpr ) throws SAXNotSupportedException { if ( myContext instanceof XPathContext . XPathExpressionContext ) { XPathContext xctxt = null ; try { xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; XPath dynamicXPath = new XPath ( xpathExpr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; return dynamicXPath . execute ( xctxt , myContext . getContextNode ( ) , xctxt . getNamespaceContext ( ) ) ; } catch ( TransformerException e ) { return new XNodeSet ( xctxt . getDTMManager ( ) ) ; } } else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; } public static NodeList closure ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return new NodeSet ( ) ; NodeSet closureSet = new NodeSet ( ) ; closureSet . setShouldCacheNodes ( true ) ; NodeList iterationList = nl ; do { NodeSet iterationSet = new NodeSet ( ) ; NodeSetDTM contextNodes = new NodeSetDTM ( iterationList , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; for ( int i = 0 ; i < iterationList . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; XObject object = null ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; object = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) ; if ( object instanceof XNodeSet ) { NodeList nodelist = null ; nodelist = ( ( XNodeSet ) object ) . nodelist ( ) ; for ( int k = 0 ; k < nodelist . getLength ( ) ; k ++ ) { Node n = nodelist . item ( k ) ; if ( ! iterationSet . contains ( n ) ) iterationSet . addNode ( n ) ; } } else { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return new NodeSet ( ) ; } } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return new NodeSet ( ) ; } xctxt . popCurrentNode ( ) ; } xctxt . popContextNodeList ( ) ; iterationList = iterationSet ; for ( int i = 0 ; i < iterationList . getLength ( ) ; i ++ ) { Node n = iterationList . item ( i ) ; if ( ! closureSet . contains ( n ) ) closureSet . addNode ( n ) ; } } while ( iterationList . getLength ( ) > 0 ) ; return closureSet ; } } 	1	['7', '2', '0', '16', '43', '21', '1', '15', '7', '1.166666667', '682', '0', '0', '0.25', '0.642857143', '0', '0', '96.28571429', '1', '0.8571', '1']
package org . apache . xalan . templates ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathFactory ; import org . apache . xpath . compiler . XPathParser ; import org . apache . xpath . objects . XObject ; public class AVTPartXPath extends AVTPart { private XPath m_xpath ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_xpath . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { return m_xpath . getExpression ( ) . canTraverseOutsideSubtree ( ) ; } public AVTPartXPath ( XPath xpath ) { m_xpath = xpath ; } public AVTPartXPath ( String val , org . apache . xml . utils . PrefixResolver nsNode , XPathParser xpathProcessor , XPathFactory factory , XPathContext liaison ) throws javax . xml . transform . TransformerException { m_xpath = new XPath ( val , null , nsNode , XPath . SELECT , liaison . getErrorListener ( ) ) ; } public String getSimpleString ( ) { return "{" + m_xpath . getPatternString ( ) + "}" ; } public void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException { XObject xobj = m_xpath . execute ( xctxt , context , nsNode ) ; if ( null != xobj ) { xobj . appendToFsb ( buf ) ; } } public void callVisitors ( XSLTVisitor visitor ) { m_xpath . getExpression ( ) . callVisitors ( m_xpath , visitor ) ; } } 	1	['7', '2', '0', '13', '20', '0', '1', '12', '7', '0', '74', '1', '1', '0.5', '0.25974026', '0', '0', '9.428571429', '1', '0.7143', '1']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class NamedMethodGenerator extends MethodGenerator { protected static int CURRENT_INDEX = 4 ; public NamedMethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_INDEX ; } return super . getLocalIndex ( name ) ; } } 	1	['3', '5', '0', '5', '6', '1', '1', '4', '2', '0.5', '28', '1', '0', '0.992805755', '0.625', '2', '3', '8', '2', '0.6667', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . patterns . NodeTest ; public class DescendantIterator extends LocPathIterator { DescendantIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int stepType = compiler . getOp ( firstStepPos ) ; boolean orSelf = ( OpCodes . FROM_DESCENDANTS_OR_SELF == stepType ) ; boolean fromRoot = false ; if ( OpCodes . FROM_SELF == stepType ) { orSelf = true ; } else if ( OpCodes . FROM_ROOT == stepType ) { fromRoot = true ; int nextStepPos = compiler . getNextStepPos ( firstStepPos ) ; if ( compiler . getOp ( nextStepPos ) == OpCodes . FROM_DESCENDANTS_OR_SELF ) orSelf = true ; } int nextStepPos = firstStepPos ; while ( true ) { nextStepPos = compiler . getNextStepPos ( nextStepPos ) ; if ( nextStepPos > 0 ) { int stepOp = compiler . getOp ( nextStepPos ) ; if ( OpCodes . ENDOP != stepOp ) firstStepPos = nextStepPos ; else break ; } else break ; } if ( ( analysis & WalkerFactory . BIT_CHILD ) != 0 ) orSelf = false ; if ( fromRoot ) { if ( orSelf ) m_axis = Axis . DESCENDANTSORSELFFROMROOT ; else m_axis = Axis . DESCENDANTSFROMROOT ; } else if ( orSelf ) m_axis = Axis . DESCENDANTORSELF ; else m_axis = Axis . DESCENDANT ; int whatToShow = compiler . getWhatToShow ( firstStepPos ) ; if ( ( 0 == ( whatToShow & ( DTMFilter . SHOW_ATTRIBUTE | DTMFilter . SHOW_ELEMENT | DTMFilter . SHOW_PROCESSING_INSTRUCTION ) ) ) || ( whatToShow == DTMFilter . SHOW_ALL ) ) initNodeTest ( whatToShow ) ; else { initNodeTest ( whatToShow , compiler . getStepNS ( firstStepPos ) , compiler . getStepLocalName ( firstStepPos ) ) ; } initPredicateInfo ( compiler , firstStepPos ) ; } public DescendantIterator ( ) { super ( null ) ; m_axis = Axis . DESCENDANTSORSELFFROMROOT ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { DescendantIterator clone = ( DescendantIterator ) super . cloneWithReset ( ) ; clone . m_traverser = m_traverser ; clone . resetProximityPositions ( ) ; return clone ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( DTM . NULL == m_lastFetched ) { resetProximityPositions ( ) ; } int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { do { if ( 0 == m_extendedTypeID ) { next = m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; } else { next = m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context , m_extendedTypeID ) : m_traverser . next ( m_context , m_lastFetched , m_extendedTypeID ) ; } if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_axis ) ; String localName = getLocalName ( ) ; String namespace = getNamespace ( ) ; int what = m_whatToShow ; if ( DTMFilter . SHOW_ALL == what || localName == NodeTest . WILD || namespace == NodeTest . WILD ) { m_extendedTypeID = 0 ; } else { int type = getNodeTypeTest ( what ) ; m_extendedTypeID = m_cdtm . getExpandedTypeID ( namespace , localName , type ) ; } } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( getPredicateCount ( ) > 0 ) return super . asNode ( xctxt ) ; int current = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( current ) ; DTMAxisTraverser traverser = dtm . getAxisTraverser ( m_axis ) ; String localName = getLocalName ( ) ; String namespace = getNamespace ( ) ; int what = m_whatToShow ; if ( DTMFilter . SHOW_ALL == what || localName == NodeTest . WILD || namespace == NodeTest . WILD ) { return traverser . first ( current ) ; } else { int type = getNodeTypeTest ( what ) ; int extendedType = dtm . getExpandedTypeID ( namespace , localName , type ) ; return traverser . first ( current , extendedType ) ; } } public void detach ( ) { m_traverser = null ; m_extendedTypeID = 0 ; super . detach ( ) ; } public int getAxis ( ) { return m_axis ; } transient protected DTMAxisTraverser m_traverser ; protected int m_axis ; protected int m_extendedTypeID ; public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( DescendantIterator ) expr ) . m_axis ) return false ; return true ; } } 	1	['9', '5', '0', '11', '42', '0', '2', '9', '8', '0.583333333', '423', '1', '1', '0.946969697', '0.277777778', '3', '11', '45.66666667', '14', '2.7778', '2']
package org . apache . xpath . functions ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncSubstringAfter extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XMLString s1 = m_arg0 . execute ( xctxt ) . xstr ( ) ; XMLString s2 = m_arg1 . execute ( xctxt ) . xstr ( ) ; int index = s1 . indexOf ( s2 ) ; return ( - 1 == index ) ? XString . EMPTYSTRING : ( XString ) s1 . substring ( index + s2 . length ( ) ) ; } } 	1	['2', '5', '0', '6', '8', '1', '0', '6', '2', '2', '34', '0', '0', '0.98245614', '0.75', '1', '6', '16', '1', '0.5', '1']
package org . apache . xpath . res ; public class XPATHErrorResources_ja extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "current() 関数は一致パターンで許可されません。" } , { ER_CURRENT_TAKES_NO_ARGS , "current() 関数は引数を受け入れません。" } , { ER_DOCUMENT_REPLACED , "document() 関数実装は org.apache.xalan.xslt.FuncDocument に置き換えられました。" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "コンテキストは所有者ドキュメントを保持しません。" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() の引数が多すぎます。" } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() の引数が多すぎます。" } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() の引数が多すぎます。" } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() の引数が多すぎます。" } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() の引数が多すぎます。" } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() の引数が多すぎます。" } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() の引数が多すぎます。" } , { ER_TRANSLATE_TAKES_3_ARGS , "translate() 関数に 3 つの引数が指定されています。" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri 関数は引数を 1 つだけ使用できます。" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "名前空間軸はまだ実装されていません。" } , { ER_UNKNOWN_AXIS , "未知の軸: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "未知の照合オペレーションです。" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() ノードテストの引数の長さが不正です。" } , { ER_CANT_CONVERT_TO_NUMBER , "{0} を数字に変換できません" } , { ER_CANT_CONVERT_TO_NODELIST , "{0} を NodeList に変換できません。" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0} を NodeSetDTM に変換できません。" } , { ER_CANT_CONVERT_TO_TYPE , "{0} を type//{1} に変換できません" } , { ER_EXPECTED_MATCH_PATTERN , "getMatchScore に予期される一致パターンです。" } , { ER_COULDNOT_GET_VAR_NAMED , "{0} という名前の変数を取得できませんでした" } , { ER_UNKNOWN_OPCODE , "エラー。未知のオプションコード: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "余分な不正トークン: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "リテラルの引用符が誤りです... 二重引用符が必要です。" } , { ER_EXPECTED_SINGLE_QUOTE , "リテラルの引用符が誤りです... 単一引用符が必要です。" } , { ER_EMPTY_EXPRESSION , "式が空です。" } , { ER_EXPECTED_BUT_FOUND , "{0} が予期されていましたが、{1} が見つかりました。" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "プログラマの表明が不正です。 - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "19990709 XPath ドラフトについて、boolean(...) 引数はもう任意ではありません。" } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "',' が見つかりましたが、その前に引数がありません。" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "',' が見つかりましたが、それに続く引数がありません。" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' または '.[predicate]' は不当な構文です。代わりに 'self::node()[predicate]' を使用してください。" } , { ER_ILLEGAL_AXIS_NAME , "不当な軸名: {0}" } , { ER_UNKNOWN_NODETYPE , "未知のノードタイプ: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "リテラル ({0}) パターンは、引用符で囲む必要があります。" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} は数字に書式設定できませんでした。" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "XML TransformerFactory Liaison を作成できませんでした: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "エラー。xpath 選択式 (-select) が見つかりませんでした。" } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "エラー。OP_LOCATIONPATH の後に ENDOP が見つかりませんでした" } , { ER_ERROR_OCCURED , "エラーが発生しました。" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "コンテキストの外で、または定義なしで VariableReference が変数に指定されました。Name = {0}" } , { ER_AXES_NOT_ALLOWED , "一致パターンには、child:: および attribute:: 軸だけが許可されます。許可されない軸 = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() の引数の数が不正です。" } , { ER_COUNT_TAKES_1_ARG , "count 関数に使用できる引数は 1 つです。" } , { ER_COULDNOT_FIND_FUNCTION , "関数 {0} が見つかりませんでした" } , { ER_UNSUPPORTED_ENCODING , "サポートされないエンコーディング: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling の DTM に問題が発生しました... 復元しています" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "プログラマエラー: EmptyNodeList に書き込みできません。" } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory は XPathContext でサポートされていません。" } , { ER_PREFIX_MUST_RESOLVE , "接頭辞は名前空間に変える必要があります: {0}" } , { ER_PARSE_NOT_SUPPORTED , "構文解析 (InputSource ソース) は XPathContext でサポートされていません。{0} をオープンできません" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... は DTM で処理されません。" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... は DTM で処理されません。" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison はタイプ {0} のノードを処理できません" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper はタイプ {0} のノードを処理できません" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse エラー: SystemID - {0} 行番号 - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse エラー" } , { ER_INVALID_UTF16_SURROGATE , "無効な UTF-16 代理が検出されました: {0} ?" } , { ER_OIERROR , "入出力エラー" } , { ER_CANNOT_CREATE_URL , "{0} の URL を作成できません" } , { ER_XPATH_READOBJECT , "XPath.readObject にあります: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "関数トークンが見つかりません。" } , { ER_CANNOT_DEAL_XPATH_TYPE , "XPath タイプ {0} は処理できません" } , { ER_NODESET_NOT_MUTABLE , "この NodeSet は可変ではありません" } , { ER_NODESETDTM_NOT_MUTABLE , "この NodeSetDTM は可変ではありません" } , { ER_VAR_NOT_RESOLVABLE , "解決できない変数: {0}" } , { ER_NULL_ERROR_HANDLER , "null エラーハンドラ" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "プログラマの表明: 未知のオプションコード: {0}" } , { ER_ZERO_OR_ONE , "0 または 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() は XRTreeFragSelectWrapper でサポートされていません" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() は XRTreeFragSelectWrapper でサポートされていません" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "XStringForChars に fsb() はサポートされていません" } , { ER_COULD_NOT_FIND_VAR , "{0} という名前の変数が見つかりませんでした" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars は引数に文字列を使用できません" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer 引数は null にできません" } , { ER_TWO_OR_THREE , "▼2 または 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "▼バインド前の変数にアクセスしました!" } , { ER_FSB_CANNOT_TAKE_STRING , "▼XStringForFSB の引数には文字列を指定できません!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "▼\n !!!! エラー! walker のルートの設定を null にしてください!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "▼この NodeSetDTM は前のノードに対して繰り返し処理を実行できません!" } , { ER_NODESET_CANNOT_ITERATE , "▼この NodeSet は前のノードに対して繰り返し処理を実行できません!" } , { ER_NODESETDTM_CANNOT_INDEX , "▼この NodeSetDTM はインデックス処理またはカウント処理を実行できません!" } , { ER_NODESET_CANNOT_INDEX , "▼この NodeSet はインデックス処理またはカウント処理を実行できません!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "▼nextNode を呼び出した後で setShouldCacheNodes を呼び出すことはできません!" } , { ER_ONLY_ALLOWS , "▼{0} で許される引数は {1} だけです" } , { ER_UNKNOWN_STEP , "▼getNextStepPos におけるプログラマの表明: 未知の stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "▼トークン '/' または '//' の後に続くべき相対ロケーションパスが見つかりません" } , { ER_EXPECTED_LOC_PATH , "▼ロケーションパスが見つかりません。代わりに次のトークンが見つかりました:  {0}" } , { ER_EXPECTED_LOC_STEP , "▼トークン '/' または '//' の後に続くべきロケーションステップが見つかりません。" } , { ER_EXPECTED_NODE_TEST , "▼NCName:* または QName の形式に一致するノードテストが見つかりません。" } , { ER_EXPECTED_STEP_PATTERN , "▼ステップパターンが見つかりません。代わりに '/' が見つかりました。" } , { ER_EXPECTED_REL_PATH_PATTERN , "▼相対パスパターンが見つかりません。" } , { ER_CANT_CONVERT_TO_BOOLEAN , "▼{0} を boolean 値に変換できません。" } , { ER_CANT_CONVERT_TO_SINGLENODE , "▼{0} を単一のノードに変換できません。この取得メソッドを適用できる型は、ANY_UNORDERED_NODE_TYPE と FIRST_ORDERED_NODE_TYPE です。" } , { ER_CANT_GET_SNAPSHOT_LENGTH , "▼型 {0} のスナップショット長を取得できません。この取得メソッドを適用できる型は、UNORDERED_NODE_SNAPSHOT_TYPE と ORDERED_NODE_SNAPSHOT_TYPE です。" } , { ER_NON_ITERATOR_TYPE , "▼非 iterator 型 {0} に対して繰り返し処理を実行することはできません" } , { ER_DOC_MUTATED , "▼結果が返された後にドキュメントが変更されたため、現在の反復子は無効になりました。" } , { ER_INVALID_XPATH_TYPE , "▼無効な XPath 型の引数: {0}" } , { ER_EMPTY_XPATH_RESULT , "▼空の XPath 結果オブジェクト" } , { ER_INCOMPATIBLE_TYPES , "▼戻り値の型 {0} は指定された型 {1} に変換できません" } , { ER_NULL_RESOLVER , "▼接頭辞リゾルバが null であったため、接頭辞の解決に失敗しました。" } , { ER_CANT_CONVERT_TO_STRING , "▼{0} を文字列値に変換できません。" } , { ER_NON_SNAPSHOT_TYPE , "▼型 {0} の snapshotItem を呼び出せません。このメソッドを呼び出せる型は、UNORDERED_NODE_SNAPSHOT_TYPE と ORDERED_NODE_SNAPSHOT_TYPE です。" } , { ER_WRONG_DOCUMENT , "▼コンテキストノードが、この XPathEvaluator にバインドされたドキュメントに所属していません。" } , { ER_WRONG_NODETYPE , "▼このコンテキストノード型はサポートされていません。" } , { ER_XPATH_ERROR , "▼XPath 内における未知のエラー" } , { WG_LOCALE_NAME_NOT_HANDLED , "format-number 関数でロケール名はまだ処理されていません。" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL プロパティはサポートされていません: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "名前空間 {0} のプロパティ {1} には現在何も行なってはなりません" } , { WG_SECURITY_EXCEPTION , "XSL システムプロパティにアクセスしようとしたときに SecurityException が発生しました: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "古い構文: quo(...) は XPath ではもう定義されていません。" } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath は nodeTest を実装するために抽出されたオブジェクトが必要です。" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "関数トークンが見つかりません。" } , { WG_COULDNOT_FIND_FUNCTION , "関数 {0} が見つかりませんでした。" } , { WG_CANNOT_MAKE_URL_FROM , "ここから URL を作成できません: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "DTM パーサで -E オプションはサポートされていません" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "コンテキストの外で、または定義なしで、変数に VariableReference が指定されました。Name = {0}" } , { WG_UNSUPPORTED_ENCODING , "サポートされないエンコーディング: {0}" } , { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "BAD_CODE" , "createMessage のパラメータが範囲外でした" } , { "FORMAT_FAILED" , "messageFormat 呼び出し中に例外がスローされました" } , { "version" , ">>>>>>> Xalan バージョン " } , { "version2" , "<<<<<<<" } , { "yes" , "はい" } , { "line" , "行番号 //" } , { "column" , "列番号 //" } , { "xsldone" , "XSLProcessor: 終了" } , { "xpath_option" , "xpath オプション: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath 式]" } , { "optionMatch" , "   [-match 一致パターン (照合診断用)]" } , { "optionAnyExpr" , "もしくは、ただ xpath 式が診断用ダンプを行うのみ" } , { "noParsermsg1" , "XSL プロセスは成功しませんでした。" } , { "noParsermsg2" , "** パーサが見つかりませんでした **" } , { "noParsermsg3" , "クラスパスをチェックしてください。" } , { "noParsermsg4" , "Java 用に IBM の XML パーサを備えていない場合は、これを以下からダウンロードできます。" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.428571429', '1872', '0', '0', '0.976190476', '1', '0', '0', '618.3333333', '1', '0.3333', '1']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncCeiling extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( Math . ceil ( m_arg0 . execute ( xctxt ) . num ( ) ) ) ; } } 	1	['2', '4', '0', '5', '7', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '1']
package org . apache . xalan . templates ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . XPathContext ; public abstract class AVTPart implements java . io . Serializable , XSLTVisitable { public AVTPart ( ) { } public abstract String getSimpleString ( ) ; public abstract void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException ; public void setXPathSupport ( XPathContext support ) { } public boolean canTraverseOutsideSubtree ( ) { return false ; } public abstract void fixupVariables ( java . util . Vector vars , int globalsSize ) ; } 	1	['6', '1', '2', '7', '7', '15', '3', '4', '6', '2', '12', '0', '0', '0', '0.361111111', '0', '0', '1', '1', '0.8333', '1']
package org . apache . xalan . transformer ; import java . text . CollationKey ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class NodeSorter { XPathContext m_execContext ; Vector m_keys ; public NodeSorter ( XPathContext p ) { m_execContext = p ; } public void sort ( DTMIterator v , Vector keys , XPathContext support ) throws javax . xml . transform . TransformerException { m_keys = keys ; int n = v . getLength ( ) ; Vector nodes = new Vector ( ) ; for ( int i = 0 ; i < n ; i ++ ) { NodeCompareElem elem = new NodeCompareElem ( v . item ( i ) ) ; nodes . addElement ( elem ) ; } Vector scratchVector = new Vector ( ) ; mergesort ( nodes , scratchVector , 0 , n - 1 , support ) ; for ( int i = 0 ; i < n ; i ++ ) { v . setItem ( ( ( NodeCompareElem ) nodes . elementAt ( i ) ) . m_node , i ) ; } v . setCurrentPos ( 0 ) ; } int compare ( NodeCompareElem n1 , NodeCompareElem n2 , int kIndex , XPathContext support ) throws TransformerException { int result = 0 ; NodeSortKey k = ( NodeSortKey ) m_keys . elementAt ( kIndex ) ; if ( k . m_treatAsNumbers ) { double n1Num , n2Num ; if ( kIndex == 0 ) { n1Num = ( ( Double ) n1 . m_key1Value ) . doubleValue ( ) ; n2Num = ( ( Double ) n2 . m_key1Value ) . doubleValue ( ) ; } else if ( kIndex == 1 ) { n1Num = ( ( Double ) n1 . m_key2Value ) . doubleValue ( ) ; n2Num = ( ( Double ) n2 . m_key2Value ) . doubleValue ( ) ; } else { XObject r1 = k . m_selectPat . execute ( m_execContext , n1 . m_node , k . m_namespaceContext ) ; XObject r2 = k . m_selectPat . execute ( m_execContext , n2 . m_node , k . m_namespaceContext ) ; n1Num = r1 . num ( ) ; n2Num = r2 . num ( ) ; } if ( ( n1Num == n2Num ) && ( ( kIndex + 1 ) < m_keys . size ( ) ) ) { result = compare ( n1 , n2 , kIndex + 1 , support ) ; } else { double diff ; if ( Double . isNaN ( n1Num ) ) { if ( Double . isNaN ( n2Num ) ) diff = 0.0 ; else diff = - 1 ; } else if ( Double . isNaN ( n2Num ) ) diff = 1 ; else diff = n1Num - n2Num ; result = ( int ) ( ( diff < 0.0 ) ? ( k . m_descending ? 1 : - 1 ) : ( diff > 0.0 ) ? ( k . m_descending ? - 1 : 1 ) : 0 ) ; } } else { CollationKey n1String , n2String ; if ( kIndex == 0 ) { n1String = ( CollationKey ) n1 . m_key1Value ; n2String = ( CollationKey ) n2 . m_key1Value ; } else if ( kIndex == 1 ) { n1String = ( CollationKey ) n1 . m_key2Value ; n2String = ( CollationKey ) n2 . m_key2Value ; } else { XObject r1 = k . m_selectPat . execute ( m_execContext , n1 . m_node , k . m_namespaceContext ) ; XObject r2 = k . m_selectPat . execute ( m_execContext , n2 . m_node , k . m_namespaceContext ) ; n1String = k . m_col . getCollationKey ( r1 . str ( ) ) ; n2String = k . m_col . getCollationKey ( r2 . str ( ) ) ; } result = n1String . compareTo ( n2String ) ; if ( k . m_caseOrderUpper ) { String tempN1 = n1String . getSourceString ( ) . toLowerCase ( ) ; String tempN2 = n2String . getSourceString ( ) . toLowerCase ( ) ; if ( tempN1 . equals ( tempN2 ) ) { result = result == 0 ? 0 : - result ; } } if ( k . m_descending ) { result = - result ; } } if ( 0 == result ) { if ( ( kIndex + 1 ) < m_keys . size ( ) ) { result = compare ( n1 , n2 , kIndex + 1 , support ) ; } } if ( 0 == result ) { DTM dtm = support . getDTM ( n1 . m_node ) ; result = dtm . isNodeAfter ( n1 . m_node , n2 . m_node ) ? - 1 : 1 ; } return result ; } void mergesort ( Vector a , Vector b , int l , int r , XPathContext support ) throws TransformerException { if ( ( r - l ) > 0 ) { int m = ( r + l ) / 2 ; mergesort ( a , b , l , m , support ) ; mergesort ( a , b , m + 1 , r , support ) ; int i , j , k ; for ( i = m ; i >= l ; i -- ) { if ( i >= b . size ( ) ) b . insertElementAt ( a . elementAt ( i ) , i ) ; else b . setElementAt ( a . elementAt ( i ) , i ) ; } i = l ; for ( j = ( m + 1 ) ; j <= r ; j ++ ) { if ( r + m + 1 - j >= b . size ( ) ) b . insertElementAt ( a . elementAt ( j ) , r + m + 1 - j ) ; else b . setElementAt ( a . elementAt ( j ) , r + m + 1 - j ) ; } j = r ; int compVal ; for ( k = l ; k <= r ; k ++ ) { if ( i == j ) compVal = - 1 ; else compVal = compare ( ( NodeCompareElem ) b . elementAt ( i ) , ( NodeCompareElem ) b . elementAt ( j ) , 0 , support ) ; if ( compVal < 0 ) { a . setElementAt ( b . elementAt ( i ) , k ) ; i ++ ; } else if ( compVal > 0 ) { a . setElementAt ( b . elementAt ( j ) , k ) ; j -- ; } } } } class NodeCompareElem { int m_node ; int maxkey = 2 ; Object m_key1Value ; Object m_key2Value ; NodeCompareElem ( int node ) throws javax . xml . transform . TransformerException { boolean tryNextKey = true ; m_node = node ; if ( ! m_keys . isEmpty ( ) ) { NodeSortKey k1 = ( NodeSortKey ) m_keys . elementAt ( 0 ) ; XObject r = k1 . m_selectPat . execute ( m_execContext , node , k1 . m_namespaceContext ) ; if ( r == null ) tryNextKey = false ; double d ; if ( k1 . m_treatAsNumbers ) { d = r . num ( ) ; m_key1Value = new Double ( d ) ; } else { m_key1Value = k1 . m_col . getCollationKey ( r . str ( ) ) ; } if ( r . getType ( ) == XObject . CLASS_NODESET ) { DTMIterator ni = ( ( XNodeSet ) r ) . iterRaw ( ) ; int current = ni . getCurrentNode ( ) ; if ( DTM . NULL == current ) current = ni . nextNode ( ) ; tryNextKey = ( DTM . NULL != current ) ; } if ( m_keys . size ( ) > 1 ) { NodeSortKey k2 = ( NodeSortKey ) m_keys . elementAt ( 1 ) ; if ( ! tryNextKey ) { if ( k2 . m_treatAsNumbers ) m_key2Value = new Double ( 0.0 ) ; else m_key2Value = k2 . m_col . getCollationKey ( "" ) ; } else { XObject r2 = k2 . m_selectPat . execute ( m_execContext , node , k2 . m_namespaceContext ) ; if ( k2 . m_treatAsNumbers ) { d = r2 . num ( ) ; m_key2Value = new Double ( d ) ; } else m_key2Value = k2 . m_col . getCollationKey ( r2 . str ( ) ) ; } } } } } } 	1	['4', '1', '0', '9', '28', '2', '2', '8', '2', '0.333333333', '475', '0', '1', '0', '0.583333333', '0', '0', '117.25', '1', '0.75', '2']
package org . apache . xpath . domapi ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . events . Event ; import org . w3c . dom . events . EventListener ; import org . w3c . dom . events . EventTarget ; import org . w3c . dom . traversal . NodeIterator ; import org . w3c . dom . xpath . XPathException ; import org . w3c . dom . xpath . XPathResult ; public class XPathResultImpl implements XPathResult , EventListener { private XObject m_resultObj ; private short m_resultType = ANY_TYPE ; private boolean m_isInvalidIteratorState = false ; private Node m_contextNode ; private NodeIterator m_iterator = null ; private NodeList m_list = null ; XPathResultImpl ( short type , XObject result , Node contextNode ) { if ( ! isValidType ( type ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_XPATH_TYPE , new Object [ ] { new Integer ( type ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } if ( null == result ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_EMPTY_XPATH_RESULT , null ) ; throw new XPathException ( XPathException . INVALID_EXPRESSION_ERR , fmsg ) ; } this . m_resultObj = result ; this . m_contextNode = contextNode ; if ( type == ANY_TYPE ) { this . m_resultType = getTypeFromXObject ( result ) ; } else { this . m_resultType = type ; } if ( ( ( m_resultType == XPathResult . ORDERED_NODE_ITERATOR_TYPE ) || ( m_resultType == XPathResult . UNORDERED_NODE_ITERATOR_TYPE ) ) && ( contextNode instanceof EventTarget ) ) { ( ( EventTarget ) contextNode ) . addEventListener ( "MutationEvents" , this , true ) ; } if ( ( m_resultType == ORDERED_NODE_ITERATOR_TYPE ) || ( m_resultType == UNORDERED_NODE_ITERATOR_TYPE ) || ( m_resultType == ANY_UNORDERED_NODE_TYPE ) || ( m_resultType == FIRST_ORDERED_NODE_TYPE ) ) { try { m_iterator = m_resultObj . nodeset ( ) ; } catch ( TransformerException te ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCOMPATIBLE_TYPES , new Object [ ] { getTypeString ( getTypeFromXObject ( m_resultObj ) ) , getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } } else if ( ( m_resultType == UNORDERED_NODE_SNAPSHOT_TYPE ) || ( m_resultType == ORDERED_NODE_SNAPSHOT_TYPE ) ) { try { m_list = m_resultObj . nodelist ( ) ; } catch ( TransformerException te ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCOMPATIBLE_TYPES , new Object [ ] { getTypeString ( getTypeFromXObject ( m_resultObj ) ) , getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } } } public short getResultType ( ) { return m_resultType ; } public double getNumberValue ( ) throws XPathException { if ( getResultType ( ) != NUMBER_TYPE ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_NUMBER , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } else { try { return m_resultObj . num ( ) ; } catch ( Exception e ) { throw new XPathException ( XPathException . TYPE_ERR , e . getMessage ( ) ) ; } } } public String getStringValue ( ) throws XPathException { if ( getResultType ( ) != STRING_TYPE ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_STRING , new Object [ ] { m_resultObj . getTypeString ( ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } else { try { return m_resultObj . str ( ) ; } catch ( Exception e ) { throw new XPathException ( XPathException . TYPE_ERR , e . getMessage ( ) ) ; } } } public boolean getBooleanValue ( ) throws XPathException { if ( getResultType ( ) != BOOLEAN_TYPE ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_BOOLEAN , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } else { try { return m_resultObj . bool ( ) ; } catch ( TransformerException e ) { throw new XPathException ( XPathException . TYPE_ERR , e . getMessage ( ) ) ; } } } public Node getSingleNodeValue ( ) throws XPathException { if ( ( m_resultType != ANY_UNORDERED_NODE_TYPE ) && ( m_resultType != FIRST_ORDERED_NODE_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_SINGLENODE , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } NodeIterator result = null ; try { result = m_resultObj . nodeset ( ) ; } catch ( TransformerException te ) { throw new XPathException ( XPathException . TYPE_ERR , te . getMessage ( ) ) ; } if ( null == result ) return null ; Node node = result . nextNode ( ) ; if ( isNamespaceNode ( node ) ) { return new XPathNamespaceImpl ( node ) ; } else { return node ; } } public boolean getInvalidIteratorState ( ) { return m_isInvalidIteratorState ; } public int getSnapshotLength ( ) throws XPathException { if ( ( m_resultType != UNORDERED_NODE_SNAPSHOT_TYPE ) && ( m_resultType != ORDERED_NODE_SNAPSHOT_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_GET_SNAPSHOT_LENGTH , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } return m_list . getLength ( ) ; } public Node iterateNext ( ) throws XPathException , DOMException { if ( ( m_resultType != UNORDERED_NODE_ITERATOR_TYPE ) && ( m_resultType != ORDERED_NODE_ITERATOR_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NON_ITERATOR_TYPE , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } if ( getInvalidIteratorState ( ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_DOC_MUTATED , null ) ; throw new DOMException ( DOMException . INVALID_STATE_ERR , fmsg ) ; } Node node = m_iterator . nextNode ( ) ; if ( isNamespaceNode ( node ) ) { return new XPathNamespaceImpl ( node ) ; } else { return node ; } } public Node snapshotItem ( int index ) throws XPathException { if ( ( m_resultType != UNORDERED_NODE_SNAPSHOT_TYPE ) && ( m_resultType != ORDERED_NODE_SNAPSHOT_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NON_SNAPSHOT_TYPE , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } Node node = m_list . item ( index ) ; if ( isNamespaceNode ( node ) ) { return new XPathNamespaceImpl ( node ) ; } else { return node ; } } public static boolean isValidType ( short type ) { switch ( type ) { case ANY_TYPE : case NUMBER_TYPE : case STRING_TYPE : case BOOLEAN_TYPE : case UNORDERED_NODE_ITERATOR_TYPE : case ORDERED_NODE_ITERATOR_TYPE : case UNORDERED_NODE_SNAPSHOT_TYPE : case ORDERED_NODE_SNAPSHOT_TYPE : case ANY_UNORDERED_NODE_TYPE : case FIRST_ORDERED_NODE_TYPE : return true ; default : return false ; } } public void handleEvent ( Event event ) { if ( event . getType ( ) . equals ( "MutationEvents" ) ) { m_isInvalidIteratorState = true ; ( ( EventTarget ) m_contextNode ) . removeEventListener ( "MutationEvents" , this , true ) ; } } public String getTypeString ( int type ) { switch ( type ) { case ANY_TYPE : return "ANY_TYPE" ; case ANY_UNORDERED_NODE_TYPE : return "ANY_UNORDERED_NODE_TYPE" ; case BOOLEAN_TYPE : return "BOOLEAN" ; case FIRST_ORDERED_NODE_TYPE : return "FIRST_ORDERED_NODE_TYPE" ; case NUMBER_TYPE : return "NUMBER_TYPE" ; case ORDERED_NODE_ITERATOR_TYPE : return "ORDERED_NODE_ITERATOR_TYPE" ; case ORDERED_NODE_SNAPSHOT_TYPE : return "ORDERED_NODE_SNAPSHOT_TYPE" ; case STRING_TYPE : return "STRING_TYPE" ; case UNORDERED_NODE_ITERATOR_TYPE : return "UNORDERED_NODE_ITERATOR_TYPE" ; case UNORDERED_NODE_SNAPSHOT_TYPE : return "UNORDERED_NODE_SNAPSHOT_TYPE" ; default : return "#UNKNOWN" ; } } private short getTypeFromXObject ( XObject object ) { switch ( object . getType ( ) ) { case XObject . CLASS_BOOLEAN : return BOOLEAN_TYPE ; case XObject . CLASS_NODESET : return UNORDERED_NODE_ITERATOR_TYPE ; case XObject . CLASS_NUMBER : return NUMBER_TYPE ; case XObject . CLASS_STRING : return STRING_TYPE ; case XObject . CLASS_RTREEFRAG : return UNORDERED_NODE_ITERATOR_TYPE ; case XObject . CLASS_NULL : return ANY_TYPE ; default : return ANY_TYPE ; } } private boolean isNamespaceNode ( Node node ) { if ( ( null != node ) && ( node . getNodeType ( ) == Node . ATTRIBUTE_NODE ) && ( node . getNodeName ( ) . startsWith ( "xmlns:" ) || node . getNodeName ( ) . equals ( "xmlns" ) ) ) { return true ; } else { return false ; } } } 	1	['15', '1', '0', '4', '40', '35', '1', '3', '12', '0.773809524', '573', '1', '1', '0', '0.255555556', '0', '0', '36.8', '5', '1.4667', '1']
package org . apache . xpath . res ; public class XPATHErrorResources_de extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Funktion current() in einem Muster nicht zulässig!" } , { ER_CURRENT_TAKES_NO_ARGS , "Funktion current() hat keine Argumente!" } , { ER_DOCUMENT_REPLACED , "Die Implementierung der Funktion document() wurde durch org.apache.xalan.xslt.FuncDocument ersetzt!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Kontext hat kein Eigentümer-Dokument!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() hat zu viele Argumente." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() hat zu viele Argumente." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() hat zu viele Argumente." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() hat zu viele Argumente." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() hat zu viele Argumente." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() hat zu viele Argumente." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() hat zu viele Argumente." } , { ER_TRANSLATE_TAKES_3_ARGS , "Funktion translate() hat drei Argumente!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Funktion unparsed-entity-uri hat ein Argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Namensraum-Achse noch nicht implementiert!" } , { ER_UNKNOWN_AXIS , "Unbekannte Achse: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "Unbekannte Match-Operation!" } , { ER_INCORRECT_ARG_LENGTH , "Argumentlänge beim Test des Knotens processing-instruction() ist nicht korrekt!" } , { ER_CANT_CONVERT_TO_NUMBER , "{0} kann nicht in Zahl konvertiert werden" } , { ER_CANT_CONVERT_TO_NODELIST , "{0} kann nicht in NodeList konvertiert werden!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0} kann nicht in NodeSetDTM konvertiert werden!" } , { ER_CANT_CONVERT_TO_TYPE , "{0} kann nicht in type//{1} konvertiert werden" } , { ER_EXPECTED_MATCH_PATTERN , "Muster in getMatchScore erwartet!" } , { ER_COULDNOT_GET_VAR_NAMED , "Variable mit Namen {0} konnte nicht abgerufen werden" } , { ER_UNKNOWN_OPCODE , "FEHLER! Unbekannter Opcode: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Zusätzliche unzulässige Token: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Literalwert mit falschen Anführungszeichen... doppelte Anführungszeichen erwartet!" } , { ER_EXPECTED_SINGLE_QUOTE , "Literalwert mit falschen Anführungszeichen... einfache Anführungszeichen erwartet!" } , { ER_EMPTY_EXPRESSION , "Leerer Ausdruck!" } , { ER_EXPECTED_BUT_FOUND , "{0} erwartet, gefunden: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programmierannahme ist falsch! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "Boolesches Argument (...) ist bei Xpath-Draft 19990709 nicht mehr optional." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "',' gefunden, aber davor kein Argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "',' gefunden, aber danach kein Argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "Syntax '..[predicate]' oder '.[predicate]' nicht zulässig. Verwenden Sie statt dessen 'self::node()[Prädikat]'." } , { ER_ILLEGAL_AXIS_NAME , "Unzulässiger Achsenname: {0}" } , { ER_UNKNOWN_NODETYPE , "Unbekannter nodetype: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Musterliteralwert ({0}) muss in Anführungszeichen eingeschlossen werden!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} konnte nicht als Zahl formatiert werden!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "XML TransformerFactory Liaison konnte nicht erstellt werden: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Fehler! 'select'-Ausdruck bei xpath nicht gefunden (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "FEHLER! ENDOP nach OP_LOCATIONPATH nicht gefunden" } , { ER_ERROR_OCCURED , "Fehler!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference für eine Variable außerhalb des Kontexts oder ohne Definition angegeben!  Name = {0}" } , { ER_AXES_NOT_ALLOWED , "Nur die Achsen child:: und attribute:: sind in Mustern zulässig! Regel verletzende Achse = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() mit falscher Anzahl von Argumenten." } , { ER_COUNT_TAKES_1_ARG , "Funktion count hat ein Argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Funktion nicht gefunden: {0}" } , { ER_UNSUPPORTED_ENCODING , "Codierung nicht unterstützt: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Problem bei DTM in getNextSibling... Wiederherstellung wird versucht" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programmierfehler: In EmptyNodeList kann nicht geschrieben werden." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory wird von XpathContext nicht unterstützt!" } , { ER_PREFIX_MUST_RESOLVE , "Präfix muss sich in Namensraum auflösen lassen: {0}" } , { ER_PARSE_NOT_SUPPORTED , "Parsen von (InputSource Quelle) in XpathContext nicht unterstützt! {0} kann nicht geöffnet werden" } , { ER_SAX_API_NOT_HANDLED , "SAX API-Zeichen (char ch[]... werden vom DTM nicht bearbeitet!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... wird vom DTM nicht bearbeitet!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison kann Knoten vom Typ {0} nicht bearbeiten" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper kann Knoten vom Typ {0} nicht bearbeiten" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Fehler bei DOM2Helper.parse: SystemID - {0} Zeile - {1}" } , { ER_XERCES_PARSE_ERROR , "Fehler bei DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Ungültiges UTF-16-Surrogat erkannt: {0} ?" } , { ER_OIERROR , "IO-Fehler" } , { ER_CANNOT_CREATE_URL , "URL kann nicht erstellt werden für: {0}" } , { ER_XPATH_READOBJECT , "In XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "Funktions-Token nicht gefunden." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Bearbeitung nicht möglich von XPath vom Typ: {0}" } , { ER_NODESET_NOT_MUTABLE , "Dieses NodeSet ist nicht mutierbar" } , { ER_NODESETDTM_NOT_MUTABLE , "Dieses NodeSetDTM ist nicht mutierbar" } , { ER_VAR_NOT_RESOLVABLE , "Variable nicht auflösbar: {0}" } , { ER_NULL_ERROR_HANDLER , "Ungültiger Error-Handler" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programmierannahme: Unbekannter Opcode: {0}" } , { ER_ZERO_OR_ONE , "0 oder 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() nicht unterstützt von XRTreeFragSelectWrapper" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() nicht unterstützt von XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() nicht unterstützt von XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Variable mit Namen {0} kann nicht gefunden werden" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars kann keine Zeichenkette als Argument haben" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "Das FastStringBuffer-Argument darf nicht Null sein" } , { ER_TWO_OR_THREE , "2 oder 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Zugriff auf Variable vor deren Bindung!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB darf keine Zeichenkette als Argument übergeben werden!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Fehler! Ausgangspunkt für Walker wird auf Null gesetzt!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Dieses NodeSetDTM-Element kann nicht zu einem vorausgegangenen Knoten iterieren!" } , { ER_NODESET_CANNOT_ITERATE , "Dieses NodeSet-Element kann nicht zu einem vorausgegangenen Knoten iterieren!" } , { ER_NODESETDTM_CANNOT_INDEX , "Dieses NodeSetDTM-Element kann keine Indizierung oder Zählung durchführen!" } , { ER_NODESET_CANNOT_INDEX , "Dieses NodeSet-Element kann keine Indizierung oder Zählung durchführen!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "setShouldCacheNodes kann nicht nach dem Aufruf von nextNode aufgerufen werden!" } , { ER_ONLY_ALLOWS , "Für {0} sind nur {1} Argumente zulässig." } , { ER_UNKNOWN_STEP , "Programmierannahme in getNextStepPos: unbekannter stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Nach dem Token '/' bzw. '//' wurde ein relativer Pfad zum Speicherort erwartet." } , { ER_EXPECTED_LOC_PATH , "Es wurde ein Pfad zum Speicherort erwartet. Vorgefunden wurde jedoch der folgende Token:  {0}" } , { ER_EXPECTED_LOC_STEP , "Nach dem Token '/' bzw. '//' wurde ein Schritt zum Speicherort erwartet." } , { ER_EXPECTED_NODE_TEST , "Es wurde ein Knotentest erwartet, der entweder NCName:* oder QName entspricht." } , { ER_EXPECTED_STEP_PATTERN , "Es wurde ein Schrittmuster erwartet. Vorgefunden wurde jedoch das Zeichen '/'." } , { ER_EXPECTED_REL_PATH_PATTERN , "Es wurde ein relatives Pfadmuster erwartet." } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0} kann nicht in Datentyp ''boolean'' konvertiert werden." } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0} kann nicht in einen einzelnen Knoten konvertiert werden. Diese Abruffunktion ist für die Typen ANY_UNORDERED_NODE_TYPE und FIRST_ORDERED_NODE_TYPE bestimmt." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Die Snapshot-Länge für diesen Typ kann nicht ermittelt werden: {0}. Diese Abruffunktion ist für die Typen UNORDERED_NODE_SNAPSHOT_TYPE und ORDERED_NODE_SNAPSHOT_TYPE bestimmt." } , { ER_NON_ITERATOR_TYPE , "Es kann keine Iteration über einen nicht-iterativen Typ durchgeführt werden: {0}" } , { ER_DOC_MUTATED , "Das Dokument wurde geändert, nachdem das Ergebnis zurückgegeben wurde. Der Iterator ist ungültig." } , { ER_INVALID_XPATH_TYPE , "Ungültiges XPath-Typargument: {0}" } , { ER_EMPTY_XPATH_RESULT , "Leeres XPath-Ergebnisobjekt" } , { ER_INCOMPATIBLE_TYPES , "Der zurückgegebene Typ {0} kann nicht in den angegebenen Typ umgewandelt werden: {1}" } , { ER_NULL_RESOLVER , "Präfix kann nicht aufgelöst werden, wenn Präfix-Resolver Null ist." } , { ER_CANT_CONVERT_TO_STRING , "{0} kann nicht in eine Zeichenkette konvertiert werden." } , { ER_NON_SNAPSHOT_TYPE , "snapshotItem kann nicht für diesen Typ aufgerufen werden: {0}. Diese Methode ist für die Typen UNORDERED_NODE_SNAPSHOT_TYPE und ORDERED_NODE_SNAPSHOT_TYPE bestimmt." } , { ER_WRONG_DOCUMENT , "Der Kontextknoten gehört nicht zu dem Dokument, das an dieses XPathEvaluator-Element gebunden ist." } , { ER_WRONG_NODETYPE , "Der Kontextknotentyp wird nicht unterstützt." } , { ER_XPATH_ERROR , "Unbekannter Fehler in XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "Name von locale in der Funktion format-number noch nicht bearbeitet!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL Property nicht unterstützt: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Zurzeit nichts tun mit Namensraum {0} in Eigenschaft: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException beim Versuch des Zugriffs auf XSL-Systemeigenschaft: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Alte Syntax: quo(...) ist in XPath nicht mehr definiert." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath benötigt ein abgeleitetes Objekt zum Implementieren von nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Funktions-Token nicht gefunden." } , { WG_COULDNOT_FIND_FUNCTION , "Funktion nicht gefunden: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "URL kann nicht erstellt werden aus: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Option -E für DTM-Parser nicht unterstützt" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference für Variable außerhalb des Kontexts oder ohne Definition angegeben!  Name = {0}" } , { WG_UNSUPPORTED_ENCODING , "Nicht unterstützte Codierung: {0}" } , { "ui_language" , "de" } , { "help_language" , "de" } , { "language" , "de" } , { "BAD_CODE" , "Parameter für createMessage außerhalb der Grenzwerte" } , { "FORMAT_FAILED" , "Ausnahme bei Aufruf von messageFormat" } , { "version" , ">>>>>>> Xalan Version " } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Zeile //" } , { "column" , "Spalte //" } , { "xsldone" , "XSLProcessor: fertig" } , { "xpath_option" , "xpath-Optionen: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath-Ausdruck]" } , { "optionMatch" , "   [-match Muster (für Trefferdiagnose)]" } , { "optionAnyExpr" , "Oder irgendein xpath-Ausdruck führt einen Diagnose-Dump aus" } , { "noParsermsg1" , "XSL Process fehlgeschlagen." } , { "noParsermsg2" , "** Parser nicht gefunden**" } , { "noParsermsg3" , "Prüfen Sie Ihren classpath." } , { "noParsermsg4" , "Wenn Sie IBMs XML Parser for Java nicht haben, können Sie ihn von folgender Adresse herunterladen" } , { "noParsermsg5" , "IBMs AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//Fehler" ; public static final String ERROR_HEADER = "Fehler: " ; public static final String WARNING_HEADER = "Warnung: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MUSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.428571429', '1872', '0', '0', '0.976190476', '1', '0', '0', '618.3333333', '1', '0.3333', '1']
package org . apache . xalan . extensions ; import java . util . Hashtable ; public abstract class ExtensionHandlerJava extends ExtensionHandler { protected String m_className = "" ; private Hashtable m_cachedMethods = new Hashtable ( ) ; protected ExtensionHandlerJava ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang ) ; m_className = className ; } public Object getFromCache ( Object methodKey , Object objType , Object [ ] methodArgs ) { return m_cachedMethods . get ( methodKey ) ; } public Object putToCache ( Object methodKey , Object objType , Object [ ] methodArgs , Object methodObj ) { return m_cachedMethods . put ( methodKey , methodObj ) ; } } 	1	['3', '2', '2', '3', '7', '0', '2', '1', '2', '0.5', '32', '1', '0', '0.75', '0.666666667', '0', '0', '9', '1', '0.6667', '1']
package org . apache . xalan . xsltc . trax ; import java . io . InputStream ; import java . io . Reader ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . w3c . dom . Document ; import org . xml . sax . InputSource ; public final class Util { public static String baseName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . baseName ( name ) ; } public static String noExtName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . noExtName ( name ) ; } public static String toJavaName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . toJavaName ( name ) ; } public static InputSource getInputSource ( XSLTC xsltc , Source source ) throws TransformerConfigurationException { InputSource input = null ; String systemId = source . getSystemId ( ) ; if ( systemId == null ) { systemId = "" ; } try { if ( source instanceof SAXSource ) { final SAXSource sax = ( SAXSource ) source ; input = sax . getInputSource ( ) ; xsltc . setXMLReader ( sax . getXMLReader ( ) ) ; } else if ( source instanceof DOMSource ) { final DOMSource domsrc = ( DOMSource ) source ; final Document dom = ( Document ) domsrc . getNode ( ) ; final DOM2SAX dom2sax = new DOM2SAX ( dom ) ; xsltc . setXMLReader ( dom2sax ) ; input = SAXSource . sourceToInputSource ( source ) ; if ( input == null ) { input = new InputSource ( domsrc . getSystemId ( ) ) ; } } else if ( source instanceof StreamSource ) { final StreamSource stream = ( StreamSource ) source ; final InputStream istream = stream . getInputStream ( ) ; final Reader reader = stream . getReader ( ) ; if ( istream != null ) { input = new InputSource ( istream ) ; } else if ( reader != null ) { input = new InputSource ( reader ) ; } else { input = new InputSource ( systemId ) ; } } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } input . setSystemId ( systemId ) ; } catch ( NullPointerException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_SOURCE_ERR , "TransformerFactory.newTemplates()" ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( SecurityException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . FILE_ACCESS_ERR , systemId ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } finally { return input ; } } } 	1	['5', '1', '0', '6', '27', '10', '2', '4', '5', '2', '149', '0', '0', '0', '0.3', '0', '0', '28.8', '1', '0.8', '3']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xpath . Expression ; import org . apache . xpath . compiler . Compiler ; public class OneStepIteratorForward extends ChildTestIterator { protected int m_axis = - 1 ; OneStepIteratorForward ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_axis = WalkerFactory . getAxisFromStep ( compiler , firstStepPos ) ; } public OneStepIteratorForward ( int axis ) { super ( null ) ; m_axis = axis ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_axis ) ; } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; return m_lastFetched ; } public int getAxis ( ) { return m_axis ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( OneStepIteratorForward ) expr ) . m_axis ) return false ; return true ; } } 	1	['6', '7', '1', '8', '16', '0', '3', '6', '4', '0.2', '94', '1', '0', '0.97080292', '0.4', '4', '10', '14.5', '3', '1.1667', '1']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; public class XNull extends XNodeSet { public XNull ( ) { super ( ) ; } public int getType ( ) { return CLASS_NULL ; } public String getTypeString ( ) { return "#CLASS_NULL" ; } public double num ( ) { return 0.0 ; } public boolean bool ( ) { return false ; } public String str ( ) { return "" ; } public int rtf ( XPathContext support ) { return DTM . NULL ; } public boolean equals ( XObject obj2 ) { return obj2 . getType ( ) == CLASS_NULL ; } } 	1	['8', '5', '0', '5', '10', '28', '2', '3', '8', '2', '31', '0', '0', '0.951048951', '0.416666667', '3', '19', '2.875', '2', '1', '1']
package org . apache . xalan . templates ; public class ElemOtherwise extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_OTHERWISE ; } public String getNodeName ( ) { return Constants . ELEMNAME_OTHERWISE_STRING ; } } 	1	['3', '3', '0', '1', '4', '3', '0', '1', '3', '2', '10', '0', '0', '0.98989899', '1', '2', '4', '2.333333333', '1', '0.6667', '1']
package org . apache . xpath . domapi ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . xpath . XPathException ; import org . w3c . dom . xpath . XPathExpression ; import org . w3c . dom . xpath . XPathNamespace ; public class XPathExpressionImpl implements XPathExpression { private PrefixResolver m_resolver ; private XPath m_xpath ; private Document m_doc = null ; XPathExpressionImpl ( XPath xpath , Document doc ) { m_xpath = xpath ; m_doc = doc ; } public Object evaluate ( Node contextNode , short type , Object result ) throws XPathException , DOMException { if ( m_doc != null ) { if ( ( contextNode != m_doc ) && ( ! contextNode . getOwnerDocument ( ) . equals ( m_doc ) ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_WRONG_DOCUMENT , null ) ; throw new DOMException ( DOMException . WRONG_DOCUMENT_ERR , fmsg ) ; } short nodeType = contextNode . getNodeType ( ) ; if ( ( nodeType != Document . DOCUMENT_NODE ) && ( nodeType != Document . ELEMENT_NODE ) && ( nodeType != Document . ATTRIBUTE_NODE ) && ( nodeType != Document . TEXT_NODE ) && ( nodeType != Document . CDATA_SECTION_NODE ) && ( nodeType != Document . COMMENT_NODE ) && ( nodeType != Document . PROCESSING_INSTRUCTION_NODE ) && ( nodeType != XPathNamespace . XPATH_NAMESPACE_NODE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_WRONG_NODETYPE , null ) ; throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , fmsg ) ; } } if ( ! XPathResultImpl . isValidType ( type ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_XPATH_TYPE , new Object [ ] { new Integer ( type ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } XPathContext xpathSupport = new XPathContext ( ) ; if ( null != m_doc ) { xpathSupport . getDTMHandleFromNode ( m_doc ) ; } XObject xobj = null ; try { xobj = m_xpath . execute ( xpathSupport , contextNode , m_resolver ) ; } catch ( TransformerException te ) { throw new XPathException ( XPathException . INVALID_EXPRESSION_ERR , te . getMessageAndLocation ( ) ) ; } return new XPathResultImpl ( type , xobj , contextNode ) ; } } 	1	['2', '1', '0', '7', '16', '0', '1', '6', '1', '0.333333333', '137', '1', '2', '0', '0.583333333', '0', '0', '66', '1', '0.5', '1']
package org . apache . xalan . trace ; public interface TraceListenerEx extends TraceListener { public void selectEnd ( EndSelectionEvent ev ) throws javax . xml . transform . TransformerException ; } 	1	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncPosition extends Function { private boolean m_isTopLevel ; public void postCompileStep ( Compiler compiler ) { m_isTopLevel = compiler . getLocationPathDepth ( ) == - 1 ; } public int getPositionInContextNodeList ( XPathContext xctxt ) { SubContextList iter = m_isTopLevel ? null : xctxt . getSubContextList ( ) ; if ( null != iter ) { int prox = iter . getProximityPosition ( xctxt ) ; return prox ; } DTMIterator cnl = xctxt . getContextNodeList ( ) ; if ( null != cnl ) { int n = cnl . getCurrentNode ( ) ; if ( n == DTM . NULL ) { if ( cnl . getCurrentPos ( ) == 0 ) return 0 ; try { cnl = cnl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } int currentNode = xctxt . getContextNode ( ) ; while ( DTM . NULL != ( n = cnl . nextNode ( ) ) ) { if ( n == currentNode ) break ; } } return cnl . getCurrentPos ( ) ; } return - 1 ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { double pos = ( double ) getPositionInContextNodeList ( xctxt ) ; return new XNumber ( pos ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	1	['5', '3', '0', '9', '17', '8', '1', '8', '5', '0.5', '92', '1', '0', '0.904761905', '0.4', '1', '6', '17.2', '8', '2.4', '1']
package org . apache . xpath . res ; public class XPATHErrorResources_es extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Esta función no se permite en un patrón de búsqueda" } , { ER_CURRENT_TAKES_NO_ARGS , "Esta función no acepta argumentos." } , { ER_DOCUMENT_REPLACED , "la implementación de la función del documento() se ha sustituido por org.apache.xalan.xslt.FuncDocument.!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "el contexto no tiene documento propietario!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "el nombre local tiene demasiados argumentos." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "el URI del espacio de nombre tiene demasiados argumentos." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "el espacio estándar tiene demasiados argumentos." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "el número tiene demasiados argumentos." } , { ER_NAME_HAS_TOO_MANY_ARGS , "el nombre tiene demasiados argumentos." } , { ER_STRING_HAS_TOO_MANY_ARGS , "la cadena tiene demasiados argumentos." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "la longitud de la cadena tiene demasiados argumentos." } , { ER_TRANSLATE_TAKES_3_ARGS , "La función de traducción utiliza tres argumentos!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "La función unparsed-entity-uri debería utilizar un argumento!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "no se ha implementado todavía el eje de espacio de nombre!" } , { ER_UNKNOWN_AXIS , "eje desconocido: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "operación de búsqueda desconocida!" } , { ER_INCORRECT_ARG_LENGTH , "La longitud de los argumentos de la prueba del nodo de instrucción de procesamiento () es incorrecta!" } , { ER_CANT_CONVERT_TO_NUMBER , "No se puede convertir {0} en un número." } , { ER_CANT_CONVERT_TO_NODELIST , "No se puede convertir {0} en una NodeList." } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "No se puede convertir {0} en un NodeSetDTM!." } , { ER_CANT_CONVERT_TO_TYPE , "No se puede convertir {0} en un tipo//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Patrón de búsqueda esperado en getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "No se ha podido obtener una variable con el nombre {0}" } , { ER_UNKNOWN_OPCODE , "ERROR! Código de operación desconocido: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Tokens adicionales no permitidos: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "error de entrecomillado... debe usar comillas dobles!" } , { ER_EXPECTED_SINGLE_QUOTE , "error de entrecomillado... debe usar comillas sencillas!" } , { ER_EMPTY_EXPRESSION , "Expresión vacía!" } , { ER_EXPECTED_BUT_FOUND , "Esperados {0}, pero encontrados: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "El aserto del programador es incorrecto! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "El argumento booleano(...) ya no es opcional con el borrador 19990709 Xpath." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Se ha encontrado ',' pero no hay ningún argumento anterior!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Se ha encontrado ',' pero no hay ningún argumento posterior!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "La sintaxis '..[predicate]' no es válida.  Sustituir por 'self::node()[predicate]'." } , { ER_ILLEGAL_AXIS_NAME , "nombre de eje no válido: {0}" } , { ER_UNKNOWN_NODETYPE , "Tipo de nodo desconocido: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "La cadena literal del patró ({0}) requiere entrecomillado!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "No se ha podido dar formato numérico a {0}!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "No se ha podido crear un vínculo XML TransformerFactory: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Error! No se ha encontrado la expresión de selección de xpath (-seleccionar)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERROR! No se ha podido encontra ENDOP después de OP_LOCATIONPATH." } , { ER_ERROR_OCCURED , "Se ha producido un error!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "Referencia variable atribuida a una variable fuera de contexto o sin definición! Nombre = {0}" } , { ER_AXES_NOT_ALLOWED , "Sólo se permiten los ejes child:: y attribute:: en los patrones de búsqueda!  Ejes incompatibles = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "El número de argumentos de la clave es incorrecto." } , { ER_COUNT_TAKES_1_ARG , "La función de cómputo debería utilizar un argumento!" } , { ER_COULDNOT_FIND_FUNCTION , "No se ha podido encontrar la función: {0}" } , { ER_UNSUPPORTED_ENCODING , "Codificación no admitida: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Se ha producido un error en DTM en getNextSibling... intentando restablecer." } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Error del programador: no se puede escribir en EmptyNodeList." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "XPathContext no admite setDOMFactory!" } , { ER_PREFIX_MUST_RESOLVE , "El prefijo debe convertirse en un espacio de nombre: {0}" } , { ER_PARSE_NOT_SUPPORTED , "análisis sintáctico (fuente InputSource source) no admitido! No se puede abri {0}" } , { ER_SAX_API_NOT_HANDLED , "Caracteres SAX API no manejados por DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "Espacio en blanco que puede ignorarse no procesado por DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison no puede manejar nodos de tipo {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper no puede manejar nodos de tipo {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Error DOM2Helper.parse: ID del sistema - {0} línea - {1}" } , { ER_XERCES_PARSE_ERROR , "Error DOM2Helper.parse." } , { ER_INVALID_UTF16_SURROGATE , "Se ha detectado un sustituto UTF-16 no válido: {0} ?" } , { ER_OIERROR , "Error de entrada/salida." } , { ER_CANNOT_CREATE_URL , "No se puede crear url para: {0}" } , { ER_XPATH_READOBJECT , "En XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "No se ha encontrado el token de función." } , { ER_CANNOT_DEAL_XPATH_TYPE , "No puede manejar el tipo XPath: {0}" } , { ER_NODESET_NOT_MUTABLE , "Este NodeSet es inmutable." } , { ER_NODESETDTM_NOT_MUTABLE , " Este NodeSetDTM es inmutable." } , { ER_VAR_NOT_RESOLVABLE , "Variable no convertible: {0}" } , { ER_NULL_ERROR_HANDLER , "Manejador de errores nulo." } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Aserto del programador: código de operación desconocido: {0}" } , { ER_ZERO_OR_ONE , "0 ór 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() no admitido por XRTreeFragSelectWrapper" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() no admitido por XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() no admitido para XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "No se ha podido encontrar variable con el nombre {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars no puede utilizar una cadena para un argumento" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "El argumento FastStringBuffer no puede ser nulo" } , { ER_TWO_OR_THREE , "2 o 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Se ha accedido a la variable antes de vincularla!" } , { ER_FSB_CANNOT_TAKE_STRING , "¡XStringForFSB no puede utilizar una cadena como argumento!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! ¡Error! Se está estableciendo la raíz de un walker a nulo" } , { ER_NODESETDTM_CANNOT_ITERATE , "¡Este NodeSetDTM no puede hacer iteraciones a un nodo previo!" } , { ER_NODESET_CANNOT_ITERATE , "¡Este NodeSet no puede hacer iteraciones a un nodo previo!" } , { ER_NODESETDTM_CANNOT_INDEX , "¡Este NodeSetDTM no puede generar índices o funciones de contador!" } , { ER_NODESET_CANNOT_INDEX , "¡Este NodeSet no puede generar índices ni funciones de contador!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "No se puede invocar setShouldCacheNodes después de haber invocado nextNode" } , { ER_ONLY_ALLOWS , "{0} sólo permite {1} argumentos" } , { ER_UNKNOWN_STEP , "Confirmación del programador en getNextStepPos: stepType desconocido: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Se esperaba una ruta de destino relativa después del token '/' o '//'." } , { ER_EXPECTED_LOC_PATH , "Se esperaba una ruta de destino, pero se ha encontrado el siguiente token:  {0}" } , { ER_EXPECTED_LOC_STEP , "Se esperaba un paso de ubicación después de '/' o '//'." } , { ER_EXPECTED_NODE_TEST , "Se esperaba una prueba de nodo coincidente con NCName:* o con QName." } , { ER_EXPECTED_STEP_PATTERN , "Se esperaba un patrón de pasos, pero se ha encontrado '/' ." } , { ER_EXPECTED_REL_PATH_PATTERN , "Se esperaba un patrón de pasos relativo." } , { ER_CANT_CONVERT_TO_BOOLEAN , "No se puede convertir {0} en una instancia booleana." } , { ER_CANT_CONVERT_TO_SINGLENODE , "No se puede convertir {0} en un nodo único. Este método getter se aplica a los tipos ANY_UNORDERED_NODE_TYPE y FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "No se puede obtener la longitud de la snapshot del tipo: {0}. Este método getter se aplica a los tipos UNORDERED_NODE_SNAPSHOT_TYPE y ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "No se puede hacer iteraciones en un tipo que no permite iteraciones: {0}" } , { ER_DOC_MUTATED , "El documento ha cambiado desde que se envió el resultado. La iteración no es válida." } , { ER_INVALID_XPATH_TYPE , "Argumento de tipo XPath no válido: {0}" } , { ER_EMPTY_XPATH_RESULT , "Objeto resultado XPath vacío" } , { ER_INCOMPATIBLE_TYPES , "El tipo devuelto: {0} no se puede transformar en el tipo especificado: {1}" } , { ER_NULL_RESOLVER , "No se puede resolver el prefijo con un convertidor de prefijo nulo." } , { ER_CANT_CONVERT_TO_STRING , "No se puede convertir {0} en una cadena." } , { ER_NON_SNAPSHOT_TYPE , "No se puede invocar snapshotItem en el tipo: {0}. Este método se aplica a los tipos UNORDERED_NODE_SNAPSHOT_TYPE y ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "El nodo de contexto no pertenece al documento vinculado a este XPathEvaluator." } , { ER_WRONG_NODETYPE , "El tipo de nodo de contexto no es compatible." } , { ER_XPATH_ERROR , "Error desconocido en XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "No se ha manejado todavía el nombre locale en la función!" } , { WG_PROPERTY_NOT_SUPPORTED , "Propiedad XSL no admitida: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Actualmente el espacio de nombres {0} en propiedad debe dejarse como está: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException al intentar tener acceso a la propiedad del sistema XSL: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Sintaxis antigua: quo(...) ya no viene definida enis XPath" } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath requiere un objeto derivado para ejecutar nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "No se ha encontrado el token de la función" } , { WG_COULDNOT_FIND_FUNCTION , "No se ha podido encontrar la función: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "No se puede crear URL desde: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "opción -E no admitida para analizador sintáctico DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference atribuida a una variable fuera de contexto o sin definición. Nombre = {0}" } , { ER_UNSUPPORTED_ENCODING , "Codificación no admitida: {0}" } , { "ui_language" , "es" } , { "help_language" , "es" } , { "language" , "es" } , { "BAD_CODE" , "El parámetro para createMessage estaba fuera de los límites" } , { "FORMAT_FAILED" , "Excepción generada la llamada messageFormat" } , { "version" , ">>>>>>> Versión Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "sí" } , { "line" , "Línea //" } , { "column" , "Columna //" } , { "xsldone" , "XSLProcessor: hecho" } , { "xpath_option" , "opciones xpath: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [- seleccionar expresión xpath]" } , { "optionMatch" , "   [-match coincidir patrón de búsqueda (para diagnósticos de búsqueda)]" } , { "optionAnyExpr" , "O una expresión xpath realizará un volcado de diagnóstico" } , { "noParsermsg1" , "Ha fallado el proceso XSLl" } , { "noParsermsg2" , "** No se ha podido encontrar analizador sintáctico **" } , { "noParsermsg3" , "Compruebe el classpath" } , { "noParsermsg4" , "Si no tiene el analizador sintáctico XML para Java de IBM, puede descargarlo desde" } , { "noParsermsg5" , "AlphaWorks de IBM: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Advertencia: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATRÓN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.428571429', '1872', '0', '0', '0.976190476', '1', '0', '0', '618.3333333', '1', '0.3333', '1']
package org . apache . xpath . res ; public class XPATHErrorResources_en extends XPATHErrorResources { } 	1	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . lang . reflect . Method ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . functions . FuncExtFunction ; public abstract class ExtensionHandler { protected String m_namespaceUri ; protected String m_scriptLang ; private static final Object NO_OBJS [ ] = new Object [ 0 ] ; private static Method getCCL ; static { try { getCCL = Thread . class . getMethod ( "getContextClassLoader" , new Class [ 0 ] ) ; } catch ( Exception e ) { getCCL = null ; } } public static Class getClassForName ( String className ) throws ClassNotFoundException { Class result = null ; if ( className . equals ( "org.apache.xalan.xslt.extensions.Redirect" ) ) className = "org.apache.xalan.lib.Redirect" ; if ( getCCL != null ) { try { ClassLoader contextClassLoader = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; result = contextClassLoader . loadClass ( className ) ; } catch ( ClassNotFoundException cnfe ) { result = Class . forName ( className ) ; } catch ( Exception e ) { getCCL = null ; result = Class . forName ( className ) ; } } else result = Class . forName ( className ) ; return result ; } protected ExtensionHandler ( String namespaceUri , String scriptLang ) { m_namespaceUri = namespaceUri ; m_scriptLang = scriptLang ; } public abstract boolean isFunctionAvailable ( String function ) ; public abstract boolean isElementAvailable ( String element ) ; public abstract Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException ; public abstract Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException ; public abstract void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException ; } 	1	['9', '1', '3', '12', '18', '34', '7', '5', '6', '0.95', '92', '0.8', '0', '0', '0.319444444', '0', '0', '8.666666667', '1', '0.7778', '1']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class ExtensionHandlerExsltFunction extends ExtensionHandler { private String m_namespace ; private StylesheetRoot m_stylesheet ; private static final QName RESULTQNAME = new QName ( Constants . S_EXSLT_FUNCTIONS_URL , Constants . EXSLT_ELEMNAME_FUNCRESULT_STRING ) ; public ExtensionHandlerExsltFunction ( String ns , StylesheetRoot stylesheet ) { super ( ns , "xml" ) ; m_namespace = ns ; m_stylesheet = stylesheet ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { } public ElemExsltFunction getFunction ( String funcName ) { QName qname = new QName ( m_namespace , funcName ) ; ElemTemplate templ = m_stylesheet . getTemplateComposed ( qname ) ; if ( templ != null && templ instanceof ElemExsltFunction ) return ( ElemExsltFunction ) templ ; else return null ; } public boolean isFunctionAvailable ( String funcName ) { return getFunction ( funcName ) != null ; } public boolean isElementAvailable ( String elemName ) { if ( ! ( new QName ( m_namespace , elemName ) . equals ( RESULTQNAME ) ) ) { return false ; } else { ElemTemplateElement elem = m_stylesheet . getFirstChildElem ( ) ; while ( elem != null && elem != m_stylesheet ) { if ( elem instanceof ElemExsltFuncResult && ancestorIsFunction ( elem ) ) return true ; ElemTemplateElement nextElem = elem . getFirstChildElem ( ) ; if ( nextElem == null ) nextElem = elem . getNextSiblingElem ( ) ; if ( nextElem == null ) nextElem = elem . getParentElem ( ) ; elem = nextElem ; } } return false ; } private boolean ancestorIsFunction ( ElemTemplateElement child ) { while ( child . getParentElem ( ) != null && ! ( child . getParentElem ( ) instanceof StylesheetRoot ) ) { if ( child . getParentElem ( ) instanceof ElemExsltFunction ) return true ; child = child . getParentElem ( ) ; } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { throw new TransformerException ( "This method should not be called." ) ; } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { ExpressionNode parent = extFunction . exprGetParent ( ) ; while ( parent != null && ! ( parent instanceof ElemTemplate ) ) { parent = parent . exprGetParent ( ) ; } ElemTemplate callerTemplate = ( parent != null ) ? ( ElemTemplate ) parent : null ; XObject [ ] methodArgs ; methodArgs = new XObject [ args . size ( ) ] ; try { for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = XObject . create ( args . elementAt ( i ) ) ; } ElemExsltFunction elemFunc = getFunction ( extFunction . getFunctionName ( ) ) ; XPathContext context = exprContext . getXPathContext ( ) ; TransformerImpl transformer = ( TransformerImpl ) context . getOwnerObject ( ) ; if ( callerTemplate != null ) elemFunc . setCallerFrameSize ( callerTemplate . m_frameSize ) ; else elemFunc . setCallerFrameSize ( 0 ) ; elemFunc . execute ( transformer , methodArgs ) ; XObject val = new XString ( "" ) ; if ( elemFunc . isResultSet ( ) ) { val = elemFunc . getResult ( ) ; elemFunc . clearResult ( ) ; } return val ; } catch ( TransformerException e ) { throw e ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } } 	1	['9', '2', '0', '15', '33', '28', '0', '15', '7', '0.625', '221', '1', '2', '0.461538462', '0.325', '1', '1', '23.22222222', '8', '2.2222', '1']
package org . apache . xpath . res ; public class XPATHErrorResources_fr extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "La fonction current() n’est pas admise dans la correspondance à la forme !" } , { ER_CURRENT_TAKES_NO_ARGS , "La fonction current() n’admet pas les arguments !" } , { ER_DOCUMENT_REPLACED , "La mise en oeuvre de la fonction document () a été remplacée par org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "le contexte n’a pas de document propriétaire !" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() a trop d’arguments." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() a trop d’arguments." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() a trop d’arguments." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() a trop d’arguments." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() a trop d’arguments." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() a trop d’arguments." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() a trop d’arguments." } , { ER_TRANSLATE_TAKES_3_ARGS , "La fonction translate() a trois arguments !" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "La fonction unparsed-entity-uri ne peut avoir qu’un seul argument !" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "l'axe namespace n’est pas encore mis en œuvre !" } , { ER_UNKNOWN_AXIS , "axe inconnu : {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "opération de correspondance inconnue !" } , { ER_INCORRECT_ARG_LENGTH , "La longueur d’argument du test du nœud processing-instruction() n’est pas correcte !" } , { ER_CANT_CONVERT_TO_NUMBER , "Impossible de convertir {0} en fonction number" } , { ER_CANT_CONVERT_TO_NODELIST , "Impossible de convertir {0} en fonction NodeList !" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Impossible de convertir {0} en fonction NodeSetDTM !" } , { ER_CANT_CONVERT_TO_TYPE , "Impossible de convertir {0} en type//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Correspondance à la forme attendue dans getMatchScore !" } , { ER_COULDNOT_GET_VAR_NAMED , "Impossible de trouver la variable nommée {0}" } , { ER_UNKNOWN_OPCODE , "ERREUR ! Code d’opération inconnu : {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Unités lexicales supplémentaires non autorisées : {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "libellé mal présenté... guillemet attendu !" } , { ER_EXPECTED_SINGLE_QUOTE , "libellé mal présenté... apostrophe attendue !" } , { ER_EMPTY_EXPRESSION , "Expression vide !" } , { ER_EXPECTED_BUT_FOUND , "{0} attendu(e), mais : {1} trouvé(e)" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Assertion de programmeur incorrecte ! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "L’argument boolean(...) n’est plus facultatif avec la version brouillon 19990709 XPath ." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "',' trouvé sans argument avant !" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "',' trouvé sans argument après !" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' ou '.[predicate]' constitue une mauvaise syntaxe. Utilisez 'self::node()[predicate]' à la place." } , { ER_ILLEGAL_AXIS_NAME , "nom d’axe non autorisé : {0}" } , { ER_UNKNOWN_NODETYPE , "Type de nœud inconnu : {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Le libellé de la forme ({0}) doit être entre guillemets !" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} ne peut pas être formaté(e) en number !" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Impossible de créer XML TransformerFactory Liaison : {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Erreur ! Impossible de trouver l’expression de sélection xpath (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERREUR ! Impossible de trouver ENDOP après OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Une erreur s’est produite !" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "L''élément VariableReference a été fourni pour la variable hors contexte ou sans définition !  Nom = {0}" } , { ER_AXES_NOT_ALLOWED , "Seuls les axes child:: et attribute:: sont admis dans les correspondances à la forme !  Axes erronés = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() dispose d’un nombre incorrect d’arguments." } , { ER_COUNT_TAKES_1_ARG , "La fonction count ne doit avoir qu’un seul argument !" } , { ER_COULDNOT_FIND_FUNCTION , "Impossible de trouver la fonction : {0}" } , { ER_UNSUPPORTED_ENCODING , "Codage non pris en charge : {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Un incident s’est produit au niveau de DTM dans getNextSibling... Tentative de récupération" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Erreur de programmation : Impossible d’écrire dans EmptyNodeList." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory n’est pas pris en charge par XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Le préfixe doit se résoudre en nom d''espace : {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (source InputSource) non pris en charge dans XpathContext ! Impossible d’ouvrir {0}" } , { ER_SAX_API_NOT_HANDLED , "Les caractères SAX API (char ch[]... ne sont pas pris en charge par DTM !" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... ne sont pas pris en charge par DTM !" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison ne peut pas prendre en charge les nœuds de type {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper ne peut pas prendre en charge les nœuds de type {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Erreur DOM2Helper.parse : ID système - {0} ligne - {1}" } , { ER_XERCES_PARSE_ERROR , "Erreur DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Substitut UTF-16 incorrect détecté : {0} ?" } , { ER_OIERROR , "Erreur d’E/S" } , { ER_CANNOT_CREATE_URL , "Impossible de créer une url pour : {0}" } , { ER_XPATH_READOBJECT , "Dans XPath.readObject : {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "Unité lexicale function introuvable." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Impossible d’opérer avec le type : {0} XPath" } , { ER_NODESET_NOT_MUTABLE , "Cet élément NodeSet n’est pas mutable" } , { ER_NODESETDTM_NOT_MUTABLE , "Cet élément NodeSetDTM n’est pas mutable" } , { ER_VAR_NOT_RESOLVABLE , "Variable non résolue : {0}" } , { ER_NULL_ERROR_HANDLER , "Gestionnaire d’erreur vide" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Assertion du programmeur : code opération inconnu : {0}" } , { ER_ZERO_OR_ONE , "0 ou 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() n’est pas pris en charge par XRTreeFragSelectWrapper" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() n’est pas pris en charge par XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() n’est pas pris en charge pour XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Impossible de trouver la variable nommée {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars ne peut pas avoir de chaîne comme argument" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "L’argument FastStringBuffer ne peut pas être égal à null" } , { ER_TWO_OR_THREE , "2 ou 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variable accédée avant sa limite !" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB ne peut pas être une chaîne pour un argument!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Erreur! Attribution d'une valeur null à la racine d'un walker !!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Ce NodeSetDTM ne peut pas être répété à un noeud précédent !" } , { ER_NODESET_CANNOT_ITERATE , "Ce NodeSet ne peut pas être répété vers un noeud précédent !" } , { ER_NODESETDTM_CANNOT_INDEX , "Ce NodeSetDTM ne peut pas exécuter de fonctions d'indexation ou de comptage !" } , { ER_NODESET_CANNOT_INDEX , "Ce NodeSet ne peut pas exécuter de fonctions d'indexation ou de comptage !" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Impossible d'appeler setShouldCacheNodes après avoir appelé nextNode !" } , { ER_ONLY_ALLOWS , "{0} n''admet que les arguments {1} arguments" } , { ER_UNKNOWN_STEP , "Assertion du programmeur dans getNextStepPos : stepType inconnu : {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Un chemin d'accès relatif était attendu après le jeton '/' ou '//'." } , { ER_EXPECTED_LOC_PATH , "Un chemin d'accès était attendu, mais l'objet suivant a été rencontré:  {0}" } , { ER_EXPECTED_LOC_STEP , "Une étape de positionnement été attendue à la suite de l'objet '/' ou '//'." } , { ER_EXPECTED_NODE_TEST , "Un test de noeud correspondant à NCName:* ou à QName était attendu." } , { ER_EXPECTED_STEP_PATTERN , "Une forme d'étape était attendue, mais '/' a été rencontré." } , { ER_EXPECTED_REL_PATH_PATTERN , "Une forme de chemin d'accès relatif était attendue." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Impossible de convertir {0} en valeur booléenne." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Impossible de convertir {0} en noeud unique. Cette méthode d'obtention s'applique aux  types ANY_UNORDERED_NODE_TYPE et FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Impossible d'obtenir une longueur d'instantané du type : {0}. Cette méthode d'obtention s'applique aux types UNORDERED_NODE_SNAPSHOT_TYPE et ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Impossible d'itérer sur le type non répétiteur : {0}" } , { ER_DOC_MUTATED , "Le document a muté depuis que le résultat a été renvoyé. L'itérateur est incorrect." } , { ER_INVALID_XPATH_TYPE , "Argument de type XPath incorrect : {0}" } , { ER_EMPTY_XPATH_RESULT , "Objet de résultat XPath vide" } , { ER_INCOMPATIBLE_TYPES , "Impossible de forcer le type renvoyé : {0} dans le fichier : {1}" } , { ER_NULL_RESOLVER , "Impossible de résoudre le préfixe sans décomposeur de préfixe." } , { ER_CANT_CONVERT_TO_STRING , "Impossible de convertir {0} en chaîne ." } , { ER_NON_SNAPSHOT_TYPE , "Impossible d'appeler snapshotItem sur le type : {0}. Cette méthode s'applique aux types UNORDERED_NODE_SNAPSHOT_TYPE et ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Le noeud de contexte n'appartient pas au document associé à ce XPathEvaluator." } , { ER_WRONG_NODETYPE , "Le noeud de contexte n'est pas pris en charge." } , { ER_XPATH_ERROR , "Erreur inconnue dans XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "Le nom de l'environnement local dans la fonction format-number n’est pas encore géré !" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL Property non pris en charge : {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Ne rien faire pour l’instant avec le nom d''espace {0} dans la propriété : {1}" } , { WG_SECURITY_EXCEPTION , "Interception de SecurityException ors de la tentative d’accès à la propriété système XSL : {0}" } , { WG_QUO_NO_LONGER_DEFINED , "L’ancienne syntaxe: quo(...) n’est plus définie dans XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath requiert un objet dérivé pour mettre en oeuvre nodeTest !" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Unité lexicale function introuvable." } , { WG_COULDNOT_FIND_FUNCTION , "Impossible de trouver la fonction : {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossible de créer une URL à partir de : {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "L’option -E n’est pas pris en charge pour l’analyseur syntaxique DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "L''élément VariableReference a été fourni pour la variable hors contexte ou sans définition !  Nom = {0}" } , { ER_UNSUPPORTED_ENCODING , "Codage non pris en charge : {0}" } , { "ui_language" , "fr" } , { "help_language" , "fr" } , { "language" , "fr" } , { "BAD_CODE" , "Paramètre pour createMessage hors limites" } , { "FORMAT_FAILED" , "Exception émise pendant l’appel de messageFormat" } , { "version" , ">>>>>>> Version Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "oui" } , { "line" , "Ligne //" } , { "column" , "Colonne //" } , { "xsldone" , "XSLProcessor: terminé" } , { "xpath_option" , "options xpath : " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [expression xpath -select]" } , { "optionMatch" , "   [correspondance à la forme -match (pour les diagnostics de correspondance)]" } , { "optionAnyExpr" , "Ou une expression xpath provoquera un échec de diagnostic" } , { "noParsermsg1" , "Echec de XSL Process." } , { "noParsermsg2" , "** Impossible de trouver l’analyseur syntaxique**" } , { "noParsermsg3" , "Veuillez vérifier votre chemin de classe." } , { "noParsermsg4" , "Si vous ne disposez pas de l’analyseur XML d’IBM pour Java, vous pouvez le télécharger à l’adresse suivante" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "Erreur : " ; public static final String WARNING_HEADER = "Attention : " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "FORME " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.428571429', '1872', '0', '0', '0.976190476', '1', '0', '0', '618.3333333', '1', '0.3333', '1']
package org . apache . xalan . templates ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringWriter ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . SourceTreeManager ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . Function2Args ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class FuncDocument extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocumentRoot ( context ) ; XObject arg = ( XObject ) this . getArg0 ( ) . execute ( xctxt ) ; String base = "" ; Expression arg1Expr = this . getArg1 ( ) ; if ( null != arg1Expr ) { XObject arg2 = arg1Expr . execute ( xctxt ) ; if ( XObject . CLASS_NODESET == arg2 . getType ( ) ) { int baseNode = arg2 . iter ( ) . nextNode ( ) ; if ( baseNode == DTM . NULL ) { warn ( xctxt , XSLTErrorResources . WG_EMPTY_SECOND_ARG , null ) ; XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; return nodes ; } else { DTM baseDTM = xctxt . getDTM ( baseNode ) ; base = baseDTM . getDocumentBaseURI ( ) ; } } else { base = arg2 . str ( ) ; } } else { assertion ( null != xctxt . getNamespaceContext ( ) , "Namespace context can not be null!" ) ; base = xctxt . getNamespaceContext ( ) . getBaseIdentifier ( ) ; } XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; NodeSetDTM mnl = nodes . mutableNodeset ( ) ; DTMIterator iterator = ( XObject . CLASS_NODESET == arg . getType ( ) ) ? arg . iter ( ) : null ; int pos = DTM . NULL ; while ( ( null == iterator ) || ( DTM . NULL != ( pos = iterator . nextNode ( ) ) ) ) { XMLString ref = ( null != iterator ) ? xctxt . getDTM ( pos ) . getStringValue ( pos ) : arg . xstr ( ) ; if ( null == arg1Expr && DTM . NULL != pos ) { DTM baseDTM = xctxt . getDTM ( pos ) ; base = baseDTM . getDocumentBaseURI ( ) ; } if ( null == ref ) continue ; if ( DTM . NULL == docContext ) { error ( xctxt , XSLTErrorResources . ER_NO_CONTEXT_OWNERDOC , null ) ; } int indexOfColon = ref . indexOf ( ':' ) ; int indexOfSlash = ref . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { base = null ; } int newDoc = getDoc ( xctxt , context , ref . toString ( ) , base ) ; if ( DTM . NULL != newDoc ) { if ( ! mnl . contains ( newDoc ) ) { mnl . addElement ( newDoc ) ; } } if ( null == iterator || newDoc == DTM . NULL ) break ; } return nodes ; } int getDoc ( XPathContext xctxt , int context , String uri , String base ) throws javax . xml . transform . TransformerException { SourceTreeManager treeMgr = xctxt . getSourceTreeManager ( ) ; Source source ; int newDoc ; try { source = treeMgr . resolveURI ( base , uri , xctxt . getSAXLocator ( ) ) ; newDoc = treeMgr . getNode ( source ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , ( SourceLocator ) xctxt . getSAXLocator ( ) , ioe ) ; } catch ( TransformerException te ) { throw new TransformerException ( te ) ; } if ( DTM . NULL != newDoc ) return newDoc ; if ( uri . length ( ) == 0 ) { uri = xctxt . getNamespaceContext ( ) . getBaseIdentifier ( ) ; try { source = treeMgr . resolveURI ( base , uri , xctxt . getSAXLocator ( ) ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , ( SourceLocator ) xctxt . getSAXLocator ( ) , ioe ) ; } } String diagnosticsString = null ; try { if ( ( null != uri ) && ( uri . toString ( ) . length ( ) > 0 ) ) { newDoc = treeMgr . getSourceTree ( source , xctxt . getSAXLocator ( ) , xctxt ) ; } else warn ( xctxt , XSLTErrorResources . WG_CANNOT_MAKE_URL_FROM , new Object [ ] { ( ( base == null ) ? "" : base ) + uri } ) ; } catch ( Throwable throwable ) { newDoc = DTM . NULL ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } if ( ( throwable instanceof NullPointerException ) || ( throwable instanceof ClassCastException ) ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ( Exception ) throwable ) ; } StringWriter sw = new StringWriter ( ) ; PrintWriter diagnosticsWriter = new PrintWriter ( sw ) ; if ( throwable instanceof TransformerException ) { TransformerException spe = ( TransformerException ) throwable ; { Throwable e = spe ; while ( null != e ) { if ( null != e . getMessage ( ) ) { diagnosticsWriter . println ( " (" + e . getClass ( ) . getName ( ) + "): " + e . getMessage ( ) ) ; } if ( e instanceof TransformerException ) { TransformerException spe2 = ( TransformerException ) e ; SourceLocator locator = spe2 . getLocator ( ) ; if ( ( null != locator ) && ( null != locator . getSystemId ( ) ) ) diagnosticsWriter . println ( "   ID: " + locator . getSystemId ( ) + " Line #" + locator . getLineNumber ( ) + " Column #" + locator . getColumnNumber ( ) ) ; e = spe2 . getException ( ) ; if ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } else e = null ; } } } else { diagnosticsWriter . println ( " (" + throwable . getClass ( ) . getName ( ) + "): " + throwable . getMessage ( ) ) ; } diagnosticsString = throwable . getMessage ( ) ; } if ( DTM . NULL == newDoc ) { if ( null != diagnosticsString ) { warn ( xctxt , XSLTErrorResources . WG_CANNOT_LOAD_REQUESTED_DOC , new Object [ ] { diagnosticsString } ) ; } else warn ( xctxt , XSLTErrorResources . WG_CANNOT_LOAD_REQUESTED_DOC , new Object [ ] { uri == null ? ( ( base == null ) ? "" : base ) + uri : uri . toString ( ) } ) ; } else { } return newDoc ; } public void error ( XPathContext xctxt , String msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; TransformerException spe = new TransformerException ( formattedMsg , ( SourceLocator ) xctxt . getSAXLocator ( ) ) ; if ( null != errHandler ) errHandler . error ( spe ) ; else System . out . println ( formattedMsg ) ; } public void warn ( XPathContext xctxt , String msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; TransformerException spe = new TransformerException ( formattedMsg , ( SourceLocator ) xctxt . getSAXLocator ( ) ) ; if ( null != errHandler ) errHandler . warning ( spe ) ; else System . out . println ( formattedMsg ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( ( argNum < 1 ) || ( argNum > 2 ) ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ONE_OR_TWO , null ) ) ; } public boolean isNodesetExpr ( ) { return true ; } } 	1	['8', '5', '0', '16', '67', '28', '1', '15', '6', '2', '551', '0', '0', '0.888888889', '0.475', '3', '8', '67.875', '1', '0.875', '2']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncRound extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( java . lang . Math . floor ( m_arg0 . execute ( xctxt ) . num ( ) + 0.5 ) ) ; } } 	1	['2', '4', '0', '5', '7', '1', '0', '5', '2', '2', '17', '0', '0', '0.979591837', '0.75', '1', '6', '7.5', '1', '0.5', '2']
package org . apache . xalan . trace ; public interface TraceListenerEx2 extends TraceListenerEx { public void traceEnd ( TracerEvent ev ) ; } 	1	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNULL ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Copy extends Instruction { private UseAttributeSets _useSets ; public void parseContents ( Parser parser ) { final String useSets = getAttribute ( "use-attribute-sets" ) ; if ( useSets . length ( ) > 0 ) { _useSets = new UseAttributeSets ( useSets , parser ) ; } parseChildren ( parser ) ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Copy" ) ; indent ( indent + IndentIncrement ) ; displayContents ( indent + IndentIncrement ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _useSets != null ) { _useSets . typeCheck ( stable ) ; } typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final LocalVariableGen name = methodGen . addLocalVariable2 ( "name" , Util . getJCRefType ( STRING_SIG ) , il . getEnd ( ) ) ; final LocalVariableGen length = methodGen . addLocalVariable2 ( "length" , Util . getJCRefType ( "I" ) , il . getEnd ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; final int cpy = cpg . addInterfaceMethodref ( DOM_INTF , "shallowCopy" , "(" + NODE_SIG + TRANSLET_OUTPUT_SIG + ")" + STRING_SIG ) ; il . append ( new INVOKEINTERFACE ( cpy , 3 ) ) ; il . append ( DUP ) ; il . append ( new ASTORE ( name . getIndex ( ) ) ) ; final BranchHandle ifBlock1 = il . append ( new IFNULL ( null ) ) ; il . append ( new ALOAD ( name . getIndex ( ) ) ) ; final int lengthMethod = cpg . addMethodref ( STRING_CLASS , "length" , "()I" ) ; il . append ( new INVOKEVIRTUAL ( lengthMethod ) ) ; il . append ( new ISTORE ( length . getIndex ( ) ) ) ; if ( _useSets != null ) { final SyntaxTreeNode parent = getParent ( ) ; if ( ( parent instanceof LiteralElement ) || ( parent instanceof LiteralElement ) ) { _useSets . translate ( classGen , methodGen ) ; } else { il . append ( new ILOAD ( length . getIndex ( ) ) ) ; final BranchHandle ifBlock2 = il . append ( new IFEQ ( null ) ) ; _useSets . translate ( classGen , methodGen ) ; ifBlock2 . setTarget ( il . append ( NOP ) ) ; } } translateContents ( classGen , methodGen ) ; il . append ( new ILOAD ( length . getIndex ( ) ) ) ; final BranchHandle ifBlock3 = il . append ( new IFEQ ( null ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new ALOAD ( name . getIndex ( ) ) ) ; il . append ( methodGen . endElement ( ) ) ; final InstructionHandle end = il . append ( NOP ) ; ifBlock1 . setTarget ( end ) ; ifBlock3 . setTarget ( end ) ; methodGen . removeLocalVariable ( name ) ; methodGen . removeLocalVariable ( length ) ; } } 	1	['5', '3', '0', '28', '42', '4', '0', '28', '4', '0.5', '253', '1', '1', '0.933333333', '0.333333333', '1', '6', '49.4', '4', '1.6', '1']
package org . apache . xalan . templates ; import org . apache . xpath . XPath ; public class ElemWhen extends ElemTemplateElement { private XPath m_test ; public void setTest ( XPath v ) { m_test = v ; } public XPath getTest ( ) { return m_test ; } public int getXSLToken ( ) { return Constants . ELEMNAME_WHEN ; } public void compose ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_test ) m_test . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_WHEN_STRING ; } public ElemWhen ( ) { } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_test . getExpression ( ) . callVisitors ( m_test , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['7', '3', '0', '9', '16', '9', '1', '8', '6', '0.5', '55', '1', '1', '0.97029703', '0.314285714', '2', '5', '6.714285714', '2', '1', '1']
package org . apache . xpath ; import java . io . Serializable ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . compiler . XPathParser ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class XPath implements Serializable , ExpressionOwner { private Expression m_mainExp ; public Expression getExpression ( ) { return m_mainExp ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_mainExp . fixupVariables ( vars , globalsSize ) ; } public void setExpression ( Expression exp ) { if ( null != m_mainExp ) exp . exprSetParent ( m_mainExp . exprGetParent ( ) ) ; m_mainExp = exp ; } public SourceLocator getLocator ( ) { return m_mainExp ; } String m_patternString ; public String getPatternString ( ) { return m_patternString ; } public static final int SELECT = 0 ; public static final int MATCH = 1 ; public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type , ErrorListener errorListener ) throws javax . xml . transform . TransformerException { if ( null == errorListener ) errorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; m_patternString = exprString ; XPathParser parser = new XPathParser ( errorListener , locator ) ; Compiler compiler = new Compiler ( errorListener , locator ) ; if ( SELECT == type ) parser . initXPath ( compiler , exprString , prefixResolver ) ; else if ( MATCH == type ) parser . initMatchPattern ( compiler , exprString , prefixResolver ) ; else throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_DEAL_XPATH_TYPE , new Object [ ] { Integer . toString ( type ) } ) ) ; Expression expr = compiler . compile ( 0 ) ; this . setExpression ( expr ) ; if ( ( null != locator ) && locator instanceof ExpressionNode ) { expr . exprSetParent ( ( ExpressionNode ) locator ) ; } } public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type ) throws javax . xml . transform . TransformerException { this ( exprString , locator , prefixResolver , type , null ) ; } public XPath ( Expression expr ) { this . setExpression ( expr ) ; } public XObject execute ( XPathContext xctxt , org . w3c . dom . Node contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { return execute ( xctxt , xctxt . getDTMHandleFromNode ( contextNode ) , namespaceContext ) ; } public XObject execute ( XPathContext xctxt , int contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { xctxt . pushNamespaceContext ( namespaceContext ) ; xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; XObject xobj = null ; try { xobj = m_mainExp . execute ( xctxt ) ; } catch ( TransformerException te ) { te . setLocator ( this . getLocator ( ) ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . error ( te ) ; } else throw te ; } catch ( Exception e ) { while ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } String msg = e . getMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { msg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_XPATH_ERROR , null ) ; } TransformerException te = new TransformerException ( msg , getLocator ( ) , e ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . fatalError ( te ) ; } else throw te ; } finally { xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } return xobj ; } public boolean bool ( XPathContext xctxt , int contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { xctxt . pushNamespaceContext ( namespaceContext ) ; xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; try { return m_mainExp . bool ( xctxt ) ; } catch ( TransformerException te ) { te . setLocator ( this . getLocator ( ) ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . error ( te ) ; } else throw te ; } catch ( Exception e ) { while ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } String msg = e . getMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { msg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_XPATH_ERROR , null ) ; } TransformerException te = new TransformerException ( msg , getLocator ( ) , e ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . fatalError ( te ) ; } else throw te ; } finally { xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } return false ; } private static final boolean DEBUG_MATCHES = false ; public double getMatchScore ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { xctxt . pushCurrentNode ( context ) ; xctxt . pushCurrentExpressionNode ( context ) ; try { XObject score = m_mainExp . execute ( xctxt ) ; if ( DEBUG_MATCHES ) { DTM dtm = xctxt . getDTM ( context ) ; System . out . println ( "score: " + score . num ( ) + " for " + dtm . getNodeName ( context ) + " for xpath " + this . getPatternString ( ) ) ; } return score . num ( ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popCurrentExpressionNode ( ) ; } } public void installFunction ( String name , int funcIndex , Function func ) { FunctionTable . installFunction ( func , funcIndex ) ; } public void warn ( XPathContext xctxt , int sourceNode , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; ErrorListener ehandler = xctxt . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . warning ( new TransformerException ( fmsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } } public void assertion ( boolean b , String msg ) { if ( ! b ) { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( XPathContext xctxt , int sourceNode , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; ErrorListener ehandler = xctxt . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . fatalError ( new TransformerException ( fmsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } else { SourceLocator slocator = xctxt . getSAXLocator ( ) ; System . out . println ( fmsg + "; file " + slocator . getSystemId ( ) + "; line " + slocator . getLineNumber ( ) + "; column " + slocator . getColumnNumber ( ) ) ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { m_mainExp . callVisitors ( this , visitor ) ; } public static final double MATCH_SCORE_NONE = Double . NEGATIVE_INFINITY ; public static final double MATCH_SCORE_QNAME = 0.0 ; public static final double MATCH_SCORE_NSWILD = - 0.25 ; public static final double MATCH_SCORE_NODETEST = - 0.5 ; public static final double MATCH_SCORE_OTHER = 0.5 ; } 	1	['17', '1', '0', '62', '64', '78', '47', '15', '17', '0.96875', '462', '0.2', '1', '0', '0.219607843', '0', '0', '25.58823529', '2', '0.9412', '1']
package org . apache . xalan . transformer ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . w3c . dom . Node ; public class MsgMgr { public MsgMgr ( TransformerImpl transformer ) { m_transformer = transformer ; } private TransformerImpl m_transformer ; public void message ( SourceLocator srcLctr , String msg , boolean terminate ) throws TransformerException { ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) { errHandler . warning ( new TransformerException ( msg , srcLctr ) ) ; } else { if ( terminate ) throw new TransformerException ( msg , srcLctr ) ; else System . out . println ( msg ) ; } } public void warn ( SourceLocator srcLctr , String msg ) throws TransformerException { warn ( srcLctr , null , null , msg , null ) ; } public void warn ( SourceLocator srcLctr , String msg , Object [ ] args ) throws TransformerException { warn ( srcLctr , null , null , msg , args ) ; } public void warn ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg ) throws TransformerException { warn ( srcLctr , styleNode , sourceNode , msg , null ) ; } public void warn ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg , Object args [ ] ) throws TransformerException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . warning ( new TransformerException ( formattedMsg , srcLctr ) ) ; else System . out . println ( formattedMsg ) ; } public void error ( SourceLocator srcLctr , String msg ) throws TransformerException { error ( srcLctr , null , null , msg , null ) ; } public void error ( SourceLocator srcLctr , String msg , Object [ ] args ) throws TransformerException { error ( srcLctr , null , null , msg , args ) ; } public void error ( SourceLocator srcLctr , String msg , Exception e ) throws TransformerException { error ( srcLctr , msg , null , e ) ; } public void error ( SourceLocator srcLctr , String msg , Object args [ ] , Exception e ) throws TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . fatalError ( new TransformerException ( formattedMsg , srcLctr ) ) ; else throw new TransformerException ( formattedMsg , srcLctr ) ; } public void error ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg ) throws TransformerException { error ( srcLctr , styleNode , sourceNode , msg , null ) ; } public void error ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg , Object args [ ] ) throws TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . fatalError ( new TransformerException ( formattedMsg , srcLctr ) ) ; else throw new TransformerException ( formattedMsg , srcLctr ) ; } } 	1	['12', '1', '0', '12', '20', '46', '11', '2', '12', '0', '176', '1', '1', '0', '0.489583333', '0', '0', '13.58333333', '1', '0.9167', '1']
package org . apache . xalan . transformer ; import java . util . Locale ; import java . util . NoSuchElementException ; import org . w3c . dom . Element ; class NumeratorFormatter { protected Element m_xslNumberElement ; NumberFormatStringTokenizer m_formatTokenizer ; Locale m_locale ; java . text . NumberFormat m_formatter ; TransformerImpl m_processor ; private final static DecimalToRoman m_romanConvertTable [ ] = { new DecimalToRoman ( 1000 , "M" , 900 , "CM" ) , new DecimalToRoman ( 500 , "D" , 400 , "CD" ) , new DecimalToRoman ( 100L , "C" , 90L , "XC" ) , new DecimalToRoman ( 50L , "L" , 40L , "XL" ) , new DecimalToRoman ( 10L , "X" , 9L , "IX" ) , new DecimalToRoman ( 5L , "V" , 4L , "IV" ) , new DecimalToRoman ( 1L , "I" , 1L , "I" ) } ; private final static char [ ] m_alphaCountTable = { 'Z' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' } ; NumeratorFormatter ( Element xslNumberElement , TransformerImpl processor ) { m_xslNumberElement = xslNumberElement ; m_processor = processor ; } protected String int2alphaCount ( int val , char [ ] table ) { int radix = table . length ; char buf [ ] = new char [ 100 ] ; int charPos = buf . length - 1 ; int lookupIndex = 1 ; int correction = 0 ; do { correction = ( ( lookupIndex == 0 ) || ( correction != 0 && lookupIndex == radix - 1 ) ) ? ( radix - 1 ) : 0 ; lookupIndex = ( val + correction ) % radix ; val = ( val / radix ) ; if ( lookupIndex == 0 && val == 0 ) break ; buf [ charPos -- ] = table [ lookupIndex ] ; } while ( val > 0 ) ; return new String ( buf , charPos + 1 , ( buf . length - charPos - 1 ) ) ; } String long2roman ( long val , boolean prefixesAreOK ) { if ( val <= 0 ) { return "#E(" + val + ")" ; } String roman = "" ; int place = 0 ; if ( val <= 3999L ) { do { while ( val >= m_romanConvertTable [ place ] . m_postValue ) { roman += m_romanConvertTable [ place ] . m_postLetter ; val -= m_romanConvertTable [ place ] . m_postValue ; } if ( prefixesAreOK ) { if ( val >= m_romanConvertTable [ place ] . m_preValue ) { roman += m_romanConvertTable [ place ] . m_preLetter ; val -= m_romanConvertTable [ place ] . m_preValue ; } } place ++ ; } while ( val > 0 ) ; } else { roman = "#error" ; } return roman ; } class NumberFormatStringTokenizer { private int currentPosition ; private int maxPosition ; private String str ; NumberFormatStringTokenizer ( String str ) { this . str = str ; maxPosition = str . length ( ) ; } void reset ( ) { currentPosition = 0 ; } String nextToken ( ) { if ( currentPosition >= maxPosition ) { throw new NoSuchElementException ( ) ; } int start = currentPosition ; while ( ( currentPosition < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) { currentPosition ++ ; } if ( ( start == currentPosition ) && ( ! Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) ) { currentPosition ++ ; } return str . substring ( start , currentPosition ) ; } boolean hasMoreTokens ( ) { return ( currentPosition >= maxPosition ) ? false : true ; } int countTokens ( ) { int count = 0 ; int currpos = currentPosition ; while ( currpos < maxPosition ) { int start = currpos ; while ( ( currpos < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currpos ) ) ) { currpos ++ ; } if ( ( start == currpos ) && ( Character . isLetterOrDigit ( str . charAt ( currpos ) ) == false ) ) { currpos ++ ; } count ++ ; } return count ; } } } 	1	['4', '1', '0', '3', '11', '4', '1', '3', '0', '1.095238095', '357', '0.428571429', '3', '0', '0.428571429', '0', '0', '86.5', '7', '3.5', '1']
package org . apache . xml . dtm . ref . sax2dtm ; import org . apache . xml . dtm . * ; import org . apache . xml . dtm . ref . * ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringDefault ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . serializer . SerializationHandler ; import javax . xml . transform . Source ; import java . util . Vector ; import org . xml . sax . * ; public class SAX2DTM2 extends SAX2DTM { public final class ChildrenIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch2 ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != NULL ) { int node = _currentNode ; _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return END ; } } public final class ParentIterator extends InternalAxisIteratorBase { private int _nodeType = DTM . NULL ; public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; if ( node != DTM . NULL ) _currentNode = _parent2 ( makeNodeIdentity ( node ) ) ; else _currentNode = DTM . NULL ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator setNodeType ( final int type ) { _nodeType = type ; return this ; } public int next ( ) { int result = _currentNode ; if ( result == END ) return DTM . NULL ; if ( _nodeType == NULL ) { _currentNode = END ; return returnNode ( makeNodeHandle ( result ) ) ; } else if ( _nodeType >= DTM . NTYPES ) { if ( _nodeType == _exptype2 ( result ) ) { _currentNode = END ; return returnNode ( makeNodeHandle ( result ) ) ; } } else { if ( _nodeType == _type2 ( result ) ) { _currentNode = END ; return returnNode ( makeNodeHandle ( result ) ) ; } } return DTM . NULL ; } } public final class TypedChildrenIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedChildrenIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch2 ( makeNodeIdentity ( _startNode ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; if ( node == DTM . NULL ) return DTM . NULL ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != DTM . NULL && _exptype2 ( node ) != nodeType ) { node = _nextsib2 ( node ) ; } } else { int eType ; while ( node != DTM . NULL ) { eType = _exptype2 ( node ) ; if ( eType >= DTM . NTYPES ) break ; else node = _nextsib2 ( node ) ; } } if ( node == DTM . NULL ) { _currentNode = DTM . NULL ; return DTM . NULL ; } else { _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } public int getNodeByPosition ( int position ) { if ( position <= 0 ) return DTM . NULL ; int node = _currentNode ; int pos = 0 ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != DTM . NULL ) { if ( _exptype2 ( node ) == nodeType ) { pos ++ ; if ( pos == position ) return makeNodeHandle ( node ) ; } node = _nextsib2 ( node ) ; } return NULL ; } else { while ( node != DTM . NULL ) { if ( _exptype2 ( node ) >= DTM . NTYPES ) { pos ++ ; if ( pos == position ) return makeNodeHandle ( node ) ; } node = _nextsib2 ( node ) ; } return NULL ; } } } public class TypedRootIterator extends RootIterator { private final int _nodeType ; public TypedRootIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { if ( _startNode == _currentNode ) return NULL ; final int node = _startNode ; int expType = _exptype2 ( makeNodeIdentity ( node ) ) ; _currentNode = node ; if ( _nodeType >= DTM . NTYPES ) { if ( _nodeType == expType ) { return returnNode ( node ) ; } } else { if ( expType < DTM . NTYPES ) { if ( expType == _nodeType ) { return returnNode ( node ) ; } } else { if ( m_extendedTypes [ expType ] . getNodeType ( ) == _nodeType ) { return returnNode ( node ) ; } } } return NULL ; } } public class FollowingSiblingIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = makeNodeIdentity ( node ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { _currentNode = ( _currentNode == DTM . NULL ) ? DTM . NULL : _nextsib2 ( _currentNode ) ; return returnNode ( makeNodeHandle ( _currentNode ) ) ; } } public final class TypedFollowingSiblingIterator extends FollowingSiblingIterator { private final int _nodeType ; public TypedFollowingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { if ( _currentNode == DTM . NULL ) { return DTM . NULL ; } int node = _currentNode ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( ( node = _nextsib2 ( node ) ) != DTM . NULL && _exptype2 ( node ) != nodeType ) { } } else { while ( ( node = _nextsib2 ( node ) ) != DTM . NULL && _exptype2 ( node ) < DTM . NTYPES ) { } } _currentNode = node ; return ( node == DTM . NULL ) ? DTM . NULL : returnNode ( makeNodeHandle ( node ) ) ; } } public final class AttributeIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstAttributeIdentity ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; if ( node != NULL ) { _currentNode = getNextAttributeIdentity ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return NULL ; } } public final class TypedAttributeIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedAttributeIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; _currentNode = getTypedAttribute ( node , _nodeType ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; _currentNode = NULL ; return returnNode ( node ) ; } } public class PrecedingSiblingIterator extends InternalAxisIteratorBase { protected int _startNodeID ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; node = _startNodeID = makeNodeIdentity ( node ) ; if ( node == NULL ) { _currentNode = node ; return resetPosition ( ) ; } int type = _type2 ( node ) ; if ( ExpandedNameTable . ATTRIBUTE == type || ExpandedNameTable . NAMESPACE == type ) { _currentNode = node ; } else { _currentNode = _parent2 ( node ) ; if ( NULL != _currentNode ) _currentNode = _firstch2 ( _currentNode ) ; else _currentNode = node ; } return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode == _startNodeID || _currentNode == DTM . NULL ) { return NULL ; } else { final int node = _currentNode ; _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public final class TypedPrecedingSiblingIterator extends PrecedingSiblingIterator { private final int _nodeType ; public TypedPrecedingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; final int nodeType = _nodeType ; final int startNodeID = _startNodeID ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != NULL && node != startNodeID && _exptype2 ( node ) != nodeType ) { node = _nextsib2 ( node ) ; } } else { while ( node != NULL && node != startNodeID && _exptype2 ( node ) < DTM . NTYPES ) { node = _nextsib2 ( node ) ; } } if ( node == DTM . NULL || node == startNodeID ) { _currentNode = NULL ; return NULL ; } else { _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } public int getLast ( ) { if ( _last != - 1 ) return _last ; setMark ( ) ; int node = _currentNode ; final int nodeType = _nodeType ; final int startNodeID = _startNodeID ; int last = 0 ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != NULL && node != startNodeID ) { if ( _exptype2 ( node ) == nodeType ) { last ++ ; } node = _nextsib2 ( node ) ; } } else { while ( node != NULL && node != startNodeID ) { if ( _exptype2 ( node ) >= DTM . NTYPES ) { last ++ ; } node = _nextsib2 ( node ) ; } } gotoMark ( ) ; return ( _last = last ) ; } } public class PrecedingIterator extends InternalAxisIteratorBase { private final int _maxAncestors = 8 ; protected int [ ] _stack = new int [ _maxAncestors ] ; protected int _sp , _oldsp ; protected int _markedsp , _markedNode , _markedDescendant ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; final int [ ] stackCopy = new int [ _stack . length ] ; System . arraycopy ( _stack , 0 , stackCopy , 0 , _stack . length ) ; clone . _stack = stackCopy ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; int parent , index ; if ( _type2 ( node ) == DTM . ATTRIBUTE_NODE ) node = _parent2 ( node ) ; _startNode = node ; _stack [ index = 0 ] = node ; parent = node ; while ( ( parent = _parent2 ( parent ) ) != NULL ) { if ( ++ index == _stack . length ) { final int [ ] stack = new int [ index * 2 ] ; System . arraycopy ( _stack , 0 , stack , 0 , index ) ; _stack = stack ; } _stack [ index ] = parent ; } if ( index > 0 ) -- index ; _currentNode = _stack [ index ] ; _oldsp = _sp = index ; return resetPosition ( ) ; } return this ; } public int next ( ) { for ( ++ _currentNode ; _sp >= 0 ; ++ _currentNode ) { if ( _currentNode < _stack [ _sp ] ) { int type = _type2 ( _currentNode ) ; if ( type != ATTRIBUTE_NODE && type != NAMESPACE_NODE ) return returnNode ( makeNodeHandle ( _currentNode ) ) ; } else -- _sp ; } return NULL ; } public DTMAxisIterator reset ( ) { _sp = _oldsp ; return resetPosition ( ) ; } public void setMark ( ) { _markedsp = _sp ; _markedNode = _currentNode ; _markedDescendant = _stack [ 0 ] ; } public void gotoMark ( ) { _sp = _markedsp ; _currentNode = _markedNode ; } } public final class TypedPrecedingIterator extends PrecedingIterator { private final int _nodeType ; public TypedPrecedingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; final int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { while ( true ) { node ++ ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else if ( _exptype2 ( node ) == nodeType ) { break ; } } } else { int expType ; while ( true ) { node ++ ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else { expType = _exptype2 ( node ) ; if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { break ; } } else { if ( m_extendedTypes [ expType ] . getNodeType ( ) == nodeType ) { break ; } } } } } _currentNode = node ; return ( node == NULL ) ? NULL : returnNode ( makeNodeHandle ( node ) ) ; } } public class FollowingIterator extends InternalAxisIteratorBase { public FollowingIterator ( ) { } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; node = makeNodeIdentity ( node ) ; int first ; int type = _type2 ( node ) ; if ( ( DTM . ATTRIBUTE_NODE == type ) || ( DTM . NAMESPACE_NODE == type ) ) { node = _parent2 ( node ) ; first = _firstch2 ( node ) ; if ( NULL != first ) { _currentNode = makeNodeHandle ( first ) ; return resetPosition ( ) ; } } do { first = _nextsib2 ( node ) ; if ( NULL == first ) node = _parent2 ( node ) ; } while ( NULL == first && NULL != node ) ; _currentNode = makeNodeHandle ( first ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; int current = makeNodeIdentity ( node ) ; while ( true ) { current ++ ; int type = _type2 ( current ) ; if ( NULL == type ) { _currentNode = NULL ; return returnNode ( node ) ; } if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; _currentNode = makeNodeHandle ( current ) ; return returnNode ( node ) ; } } } public final class TypedFollowingIterator extends FollowingIterator { private final int _nodeType ; public TypedFollowingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int current ; int node ; int type ; final int nodeType = _nodeType ; int currentNodeID = makeNodeIdentity ( _currentNode ) ; if ( nodeType >= DTM . NTYPES ) { do { node = currentNodeID ; current = node ; do { current ++ ; type = _type2 ( current ) ; } while ( type != NULL && ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) ) ; currentNodeID = ( type != NULL ) ? current : NULL ; } while ( node != DTM . NULL && _exptype2 ( node ) != nodeType ) ; } else { do { node = currentNodeID ; current = node ; do { current ++ ; type = _type2 ( current ) ; } while ( type != NULL && ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) ) ; currentNodeID = ( type != NULL ) ? current : NULL ; } while ( node != DTM . NULL && ( _exptype2 ( node ) != nodeType && _type2 ( node ) != nodeType ) ) ; } _currentNode = makeNodeHandle ( currentNodeID ) ; return ( node == DTM . NULL ? DTM . NULL : returnNode ( makeNodeHandle ( node ) ) ) ; } } public class AncestorIterator extends InternalAxisIteratorBase { private static final int m_blocksize = 32 ; int [ ] m_ancestors = new int [ m_blocksize ] ; int m_size = 0 ; int m_ancestorsPos ; int m_markedPos ; int m_realStartNode ; public int getStartNode ( ) { return m_realStartNode ; } public final boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final AncestorIterator clone = ( AncestorIterator ) super . clone ( ) ; clone . _startNode = _startNode ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; if ( nodeID == DTM . NULL ) { _currentNode = DTM . NULL ; m_ancestorsPos = 0 ; return this ; } if ( ! _includeSelf ) { nodeID = _parent2 ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } _startNode = node ; while ( nodeID != END ) { if ( m_size >= m_ancestors . length ) { int [ ] newAncestors = new int [ m_size * 2 ] ; System . arraycopy ( m_ancestors , 0 , newAncestors , 0 , m_ancestors . length ) ; m_ancestors = newAncestors ; } m_ancestors [ m_size ++ ] = node ; nodeID = _parent2 ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } m_ancestorsPos = m_size - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { m_ancestorsPos = m_size - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return resetPosition ( ) ; } public int next ( ) { int next = _currentNode ; int pos = -- m_ancestorsPos ; _currentNode = ( pos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return returnNode ( next ) ; } public void setMark ( ) { m_markedPos = m_ancestorsPos ; } public void gotoMark ( ) { m_ancestorsPos = m_markedPos ; _currentNode = m_ancestorsPos >= 0 ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; } } public final class TypedAncestorIterator extends AncestorIterator { private final int _nodeType ; public TypedAncestorIterator ( int type ) { _nodeType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; if ( nodeID == DTM . NULL ) { _currentNode = DTM . NULL ; m_ancestorsPos = 0 ; return this ; } final int nodeType = _nodeType ; if ( ! _includeSelf ) { nodeID = _parent2 ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } _startNode = node ; if ( nodeType >= DTM . NTYPES ) { while ( nodeID != END ) { int eType = _exptype2 ( nodeID ) ; if ( eType == nodeType ) { if ( m_size >= m_ancestors . length ) { int [ ] newAncestors = new int [ m_size * 2 ] ; System . arraycopy ( m_ancestors , 0 , newAncestors , 0 , m_ancestors . length ) ; m_ancestors = newAncestors ; } m_ancestors [ m_size ++ ] = makeNodeHandle ( nodeID ) ; } nodeID = _parent2 ( nodeID ) ; } } else { while ( nodeID != END ) { int eType = _exptype2 ( nodeID ) ; if ( ( eType < DTM . NTYPES && eType == nodeType ) || ( eType >= DTM . NTYPES && m_extendedTypes [ eType ] . getNodeType ( ) == nodeType ) ) { if ( m_size >= m_ancestors . length ) { int [ ] newAncestors = new int [ m_size * 2 ] ; System . arraycopy ( m_ancestors , 0 , newAncestors , 0 , m_ancestors . length ) ; m_ancestors = newAncestors ; } m_ancestors [ m_size ++ ] = makeNodeHandle ( nodeID ) ; } nodeID = _parent2 ( nodeID ) ; } } m_ancestorsPos = m_size - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return resetPosition ( ) ; } return this ; } public int getNodeByPosition ( int position ) { if ( position > 0 && position <= m_size ) { return m_ancestors [ position - 1 ] ; } else return DTM . NULL ; } public int getLast ( ) { return m_size ; } } public class DescendantIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; _startNode = node ; if ( _includeSelf ) node -- ; _currentNode = node ; return resetPosition ( ) ; } return this ; } protected final boolean isDescendant ( int identity ) { return ( _parent2 ( identity ) >= _startNode ) || ( _startNode == identity ) ; } public int next ( ) { final int startNode = _startNode ; if ( startNode == NULL ) { return NULL ; } if ( _includeSelf && ( _currentNode + 1 ) == startNode ) return returnNode ( makeNodeHandle ( ++ _currentNode ) ) ; int node = _currentNode ; int type ; if ( startNode == ROOTNODE ) { int eType ; do { node ++ ; eType = _exptype2 ( node ) ; if ( NULL == eType ) { _currentNode = NULL ; return END ; } } while ( eType == TEXT_NODE || ( type = m_extendedTypes [ eType ] . getNodeType ( ) ) == ATTRIBUTE_NODE || type == NAMESPACE_NODE ) ; } else { do { node ++ ; type = _type2 ( node ) ; if ( NULL == type || ! isDescendant ( node ) ) { _currentNode = NULL ; return END ; } } while ( ATTRIBUTE_NODE == type || TEXT_NODE == type || NAMESPACE_NODE == type ) ; } _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } public DTMAxisIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( makeNodeHandle ( _startNode ) ) ; _isRestartable = temp ; return this ; } } public final class TypedDescendantIterator extends DescendantIterator { private final int _nodeType ; public TypedDescendantIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int startNode = _startNode ; if ( _startNode == NULL ) { return NULL ; } int node = _currentNode ; int expType ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { do { node ++ ; expType = _exptype2 ( node ) ; if ( NULL == expType || _parent2 ( node ) < startNode && startNode != node ) { _currentNode = NULL ; return END ; } } while ( expType != nodeType ) ; } else if ( startNode == DTMDefaultBase . ROOTNODE ) { do { node ++ ; expType = _exptype2 ( node ) ; if ( NULL == expType ) { _currentNode = NULL ; return END ; } } while ( expType < DTM . NTYPES || m_extendedTypes [ expType ] . getNodeType ( ) != DTM . ELEMENT_NODE ) ; } else { do { node ++ ; expType = _exptype2 ( node ) ; if ( NULL == expType || _parent2 ( node ) < startNode && startNode != node ) { _currentNode = NULL ; return END ; } } while ( expType < DTM . NTYPES || m_extendedTypes [ expType ] . getNodeType ( ) != DTM . ELEMENT_NODE ) ; } _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } } public final class TypedSingletonIterator extends SingletonIterator { private final int _nodeType ; public TypedSingletonIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int result = _currentNode ; if ( result == END ) return DTM . NULL ; _currentNode = END ; if ( _nodeType >= DTM . NTYPES ) { if ( _exptype2 ( makeNodeIdentity ( result ) ) == _nodeType ) { return returnNode ( result ) ; } } else { if ( _type2 ( makeNodeIdentity ( result ) ) == _nodeType ) { return returnNode ( result ) ; } } return NULL ; } } private int [ ] m_exptype_map0 ; private int [ ] m_nextsib_map0 ; private int [ ] m_firstch_map0 ; private int [ ] m_parent_map0 ; private int [ ] [ ] m_exptype_map ; private int [ ] [ ] m_nextsib_map ; private int [ ] [ ] m_firstch_map ; private int [ ] [ ] m_parent_map ; protected ExtendedType [ ] m_extendedTypes ; protected Vector m_values ; private int m_valueIndex = 0 ; private int m_maxNodeIndex ; protected int m_SHIFT ; protected int m_MASK ; protected int m_blocksize ; protected final static int TEXT_LENGTH_BITS = 10 ; protected final static int TEXT_OFFSET_BITS = 21 ; protected final static int TEXT_LENGTH_MAX = ( 1 << TEXT_LENGTH_BITS ) - 1 ; protected final static int TEXT_OFFSET_MAX = ( 1 << TEXT_OFFSET_BITS ) - 1 ; protected boolean m_buildIdIndex = true ; private static final String EMPTY_STR = "" ; private static final XMLString EMPTY_XML_STR = new XMLStringDefault ( "" ) ; public SAX2DTM2 ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , true , true ) ; } public SAX2DTM2 ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib , boolean buildIdIndex ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib ) ; int shift ; for ( shift = 0 ; ( blocksize >>>= 1 ) != 0 ; ++ shift ) ; m_blocksize = 1 << shift ; m_SHIFT = shift ; m_MASK = m_blocksize - 1 ; m_buildIdIndex = buildIdIndex ; m_values = new Vector ( 32 , 512 ) ; m_maxNodeIndex = 1 << DTMManager . IDENT_DTM_NODE_BITS ; m_exptype_map0 = m_exptype . getMap0 ( ) ; m_nextsib_map0 = m_nextsib . getMap0 ( ) ; m_firstch_map0 = m_firstch . getMap0 ( ) ; m_parent_map0 = m_parent . getMap0 ( ) ; } public final int _exptype ( int identity ) { return m_exptype . elementAt ( identity ) ; } public final int _exptype2 ( int identity ) { if ( identity < m_blocksize ) return m_exptype_map0 [ identity ] ; else return m_exptype_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _nextsib2 ( int identity ) { if ( identity < m_blocksize ) return m_nextsib_map0 [ identity ] ; else return m_nextsib_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _firstch2 ( int identity ) { if ( identity < m_blocksize ) return m_firstch_map0 [ identity ] ; else return m_firstch_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _parent2 ( int identity ) { if ( identity < m_blocksize ) return m_parent_map0 [ identity ] ; else return m_parent_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _type2 ( int identity ) { int eType ; if ( identity < m_blocksize ) eType = m_exptype_map0 [ identity ] ; else eType = m_exptype_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; if ( NULL != eType ) return m_extendedTypes [ eType ] . getNodeType ( ) ; else return NULL ; } public final int getExpandedTypeID2 ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( nodeID != NULL ) { if ( nodeID < m_blocksize ) return m_exptype_map0 [ nodeID ] ; else return m_exptype_map [ nodeID > > > m_SHIFT ] [ nodeID & m_MASK ] ; } else return NULL ; } public final int _exptype2Type ( int exptype ) { if ( NULL != exptype ) return m_extendedTypes [ exptype ] . getNodeType ( ) ; else return NULL ; } public int getIdForNamespace ( String uri ) { int index = m_values . indexOf ( uri ) ; if ( index < 0 ) { m_values . addElement ( uri ) ; return m_valueIndex ++ ; } else return index ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( uri , localName , DTM . ELEMENT_NODE ) ; int prefixIndex = ( qName . length ( ) != localName . length ( ) ) ? m_valuesOrPrefixes . stringToIndex ( qName ) : 0 ; int elemNode = addNode ( DTM . ELEMENT_NODE , exName , m_parents . peek ( ) , m_previous , prefixIndex , true ) ; if ( m_indexing ) indexNode ( exName , elemNode ) ; m_parents . push ( elemNode ) ; int startDecls = m_contextIndexes . peek ( ) ; int nDecls = m_prefixMappings . size ( ) ; String prefix ; if ( ! m_pastFirstElement ) { prefix = "xml" ; String declURL = "http://www.w3.org/XML/1998/namespace" ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; m_values . addElement ( declURL ) ; int val = m_valueIndex ++ ; addNode ( DTM . NAMESPACE_NODE , exName , elemNode , DTM . NULL , val , false ) ; m_pastFirstElement = true ; } for ( int i = startDecls ; i < nDecls ; i += 2 ) { prefix = ( String ) m_prefixMappings . elementAt ( i ) ; if ( prefix == null ) continue ; String declURL = ( String ) m_prefixMappings . elementAt ( i + 1 ) ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; m_values . addElement ( declURL ) ; int val = m_valueIndex ++ ; addNode ( DTM . NAMESPACE_NODE , exName , elemNode , DTM . NULL , val , false ) ; } int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrQName = attributes . getQName ( i ) ; String valString = attributes . getValue ( i ) ; int nodeType ; String attrLocalName = attributes . getLocalName ( i ) ; if ( ( null != attrQName ) && ( attrQName . equals ( "xmlns" ) || attrQName . startsWith ( "xmlns:" ) ) ) { prefix = getPrefix ( attrQName , attrUri ) ; if ( declAlreadyDeclared ( prefix ) ) continue ; nodeType = DTM . NAMESPACE_NODE ; } else { nodeType = DTM . ATTRIBUTE_NODE ; if ( m_buildIdIndex && attributes . getType ( i ) . equalsIgnoreCase ( "ID" ) ) setIDAttribute ( valString , elemNode ) ; } if ( null == valString ) valString = "" ; m_values . addElement ( valString ) ; int val = m_valueIndex ++ ; if ( attrLocalName . length ( ) != attrQName . length ( ) ) { prefixIndex = m_valuesOrPrefixes . stringToIndex ( attrQName ) ; int dataIndex = m_data . size ( ) ; m_data . addElement ( prefixIndex ) ; m_data . addElement ( val ) ; val = - dataIndex ; } exName = m_expandedNameTable . getExpandedTypeID ( attrUri , attrLocalName , nodeType ) ; addNode ( nodeType , exName , elemNode , DTM . NULL , val , false ) ; } if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( elemNode ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { charactersFlush ( ) ; m_contextIndexes . quickPop ( 1 ) ; int topContextIndex = m_contextIndexes . peek ( ) ; if ( topContextIndex != m_prefixMappings . size ( ) ) { m_prefixMappings . setSize ( topContextIndex ) ; } m_previous = m_parents . pop ( ) ; popShouldStripWhitespace ( ) ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( m_insideDTD ) return ; charactersFlush ( ) ; m_values . addElement ( new String ( ch , start , length ) ) ; int dataIndex = m_valueIndex ++ ; m_previous = addNode ( DTM . COMMENT_NODE , DTM . COMMENT_NODE , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void startDocument ( ) throws SAXException { int doc = addNode ( DTM . DOCUMENT_NODE , DTM . DOCUMENT_NODE , DTM . NULL , DTM . NULL , 0 , true ) ; m_parents . push ( doc ) ; m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endDocument ( ) throws SAXException { super . endDocument ( ) ; m_exptype . addElement ( NULL ) ; m_parent . addElement ( NULL ) ; m_nextsib . addElement ( NULL ) ; m_firstch . addElement ( NULL ) ; m_extendedTypes = m_expandedNameTable . getExtendedTypes ( ) ; m_exptype_map = m_exptype . getMap ( ) ; m_nextsib_map = m_nextsib . getMap ( ) ; m_firstch_map = m_firstch . getMap ( ) ; m_parent_map = m_parent . getMap ( ) ; } protected final int addNode ( int type , int expandedTypeID , int parentIndex , int previousSibling , int dataOrPrefix , boolean canHaveFirstChild ) { int nodeIndex = m_size ++ ; if ( nodeIndex == m_maxNodeIndex ) { addNewDTMID ( nodeIndex ) ; m_maxNodeIndex += ( 1 << DTMManager . IDENT_DTM_NODE_BITS ) ; } m_firstch . addElement ( DTM . NULL ) ; m_nextsib . addElement ( DTM . NULL ) ; m_parent . addElement ( parentIndex ) ; m_exptype . addElement ( expandedTypeID ) ; m_dataOrQName . addElement ( dataOrPrefix ) ; if ( m_prevsib != null ) { m_prevsib . addElement ( previousSibling ) ; } if ( m_locator != null && m_useSourceLocationProperty ) { setSourceLocation ( ) ; } switch ( type ) { case DTM . NAMESPACE_NODE : declareNamespaceInContext ( parentIndex , nodeIndex ) ; break ; case DTM . ATTRIBUTE_NODE : break ; default : if ( DTM . NULL != previousSibling ) { m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; } else if ( DTM . NULL != parentIndex ) { m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } break ; } return nodeIndex ; } protected final void charactersFlush ( ) { if ( m_textPendingStart >= 0 ) { int length = m_chars . size ( ) - m_textPendingStart ; boolean doStrip = false ; if ( getShouldStripWhitespace ( ) ) { doStrip = m_chars . isWhitespace ( m_textPendingStart , length ) ; } if ( doStrip ) m_chars . setLength ( m_textPendingStart ) ; else { if ( length <= TEXT_LENGTH_MAX && m_textPendingStart <= TEXT_OFFSET_MAX ) { m_previous = addNode ( m_coalescedTextType , DTM . TEXT_NODE , m_parents . peek ( ) , m_previous , length + ( m_textPendingStart << TEXT_LENGTH_BITS ) , false ) ; } else { int dataIndex = m_data . size ( ) ; m_previous = addNode ( m_coalescedTextType , DTM . TEXT_NODE , m_parents . peek ( ) , m_previous , - dataIndex , false ) ; m_data . addElement ( m_textPendingStart ) ; m_data . addElement ( length ) ; } } m_textPendingStart = - 1 ; m_textType = m_coalescedTextType = DTM . TEXT_NODE ; } } public void processingInstruction ( String target , String data ) throws SAXException { charactersFlush ( ) ; int dataIndex = m_data . size ( ) ; m_previous = addNode ( DTM . PROCESSING_INSTRUCTION_NODE , DTM . PROCESSING_INSTRUCTION_NODE , m_parents . peek ( ) , m_previous , - dataIndex , false ) ; m_data . addElement ( m_valuesOrPrefixes . stringToIndex ( target ) ) ; m_values . addElement ( data ) ; m_data . addElement ( m_valueIndex ++ ) ; } public final int getFirstAttribute ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( nodeID == DTM . NULL ) return DTM . NULL ; int type = _type2 ( nodeID ) ; if ( DTM . ELEMENT_NODE == type ) { while ( true ) { nodeID ++ ; type = _type2 ( nodeID ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return makeNodeHandle ( nodeID ) ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } protected int getFirstAttributeIdentity ( int identity ) { int type = _type2 ( identity ) ; if ( DTM . ELEMENT_NODE == type ) { while ( true ) { identity ++ ; type = _type2 ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } protected int getNextAttributeIdentity ( int identity ) { while ( true ) { identity ++ ; int type = _type2 ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( type != DTM . NAMESPACE_NODE ) { break ; } } return DTM . NULL ; } protected final int getTypedAttribute ( int nodeHandle , int attType ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( nodeID == DTM . NULL ) return DTM . NULL ; int type = _type2 ( nodeID ) ; if ( DTM . ELEMENT_NODE == type ) { int expType ; while ( true ) { nodeID ++ ; expType = _exptype2 ( nodeID ) ; if ( expType != DTM . NULL ) type = m_extendedTypes [ expType ] . getNodeType ( ) ; else return DTM . NULL ; if ( type == DTM . ATTRIBUTE_NODE ) { if ( expType == attType ) return makeNodeHandle ( nodeID ) ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } public String getLocalName ( int nodeHandle ) { int expType = _exptype ( makeNodeIdentity ( nodeHandle ) ) ; if ( expType == DTM . PROCESSING_INSTRUCTION_NODE ) { int dataIndex = _dataOrQName ( makeNodeIdentity ( nodeHandle ) ) ; dataIndex = m_data . elementAt ( - dataIndex ) ; return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } else return m_expandedNameTable . getLocalName ( expType ) ; } public final String getNodeNameX ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; int eType = _exptype2 ( nodeID ) ; if ( eType == DTM . PROCESSING_INSTRUCTION_NODE ) { int dataIndex = _dataOrQName ( nodeID ) ; dataIndex = m_data . elementAt ( - dataIndex ) ; return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } final ExtendedType extType = m_extendedTypes [ eType ] ; if ( extType . getNamespace ( ) . length ( ) == 0 ) { return extType . getLocalName ( ) ; } else { int qnameIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( qnameIndex == 0 ) return extType . getLocalName ( ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public String getNodeName ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; int eType = _exptype2 ( nodeID ) ; final ExtendedType extType = m_extendedTypes [ eType ] ; if ( extType . getNamespace ( ) . length ( ) == 0 ) { int type = extType . getNodeType ( ) ; String localName = extType . getLocalName ( ) ; if ( type == DTM . NAMESPACE_NODE ) { if ( localName . length ( ) == 0 ) return "xmlns" ; else return "xmlns:" + localName ; } else if ( type == DTM . PROCESSING_INSTRUCTION_NODE ) { int dataIndex = _dataOrQName ( nodeID ) ; dataIndex = m_data . elementAt ( - dataIndex ) ; return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } else if ( localName . length ( ) == 0 ) { return m_fixednames [ type ] ; } else return localName ; } else { int qnameIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( qnameIndex == 0 ) return extType . getLocalName ( ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public XMLString getStringValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return EMPTY_XML_STR ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - 1 ; int length = 0 ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( - 1 == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - 1 == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + 1 ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > 0 ) { if ( m_xstrf != null ) return m_xstrf . newstr ( m_chars , offset , length ) ; else return new XMLStringDefault ( m_chars . getString ( offset , length ) ) ; } else return EMPTY_XML_STR ; } else return EMPTY_XML_STR ; } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( m_xstrf != null ) return m_xstrf . newstr ( m_chars , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else return new XMLStringDefault ( m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ) ; } else { if ( m_xstrf != null ) return m_xstrf . newstr ( m_chars , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; else return new XMLStringDefault ( m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } if ( m_xstrf != null ) return m_xstrf . newstr ( ( String ) m_values . elementAt ( dataIndex ) ) ; else return new XMLStringDefault ( ( String ) m_values . elementAt ( dataIndex ) ) ; } } public final String getStringValueX ( final int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return EMPTY_STR ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - 1 ; int length = 0 ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( - 1 == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - 1 == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + 1 ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > 0 ) { return m_chars . getString ( offset , length ) ; } else return EMPTY_STR ; } else return EMPTY_STR ; } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { return m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { return m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return ( String ) m_values . elementAt ( dataIndex ) ; } } public String getStringValue ( ) { int child = _firstch2 ( ROOTNODE ) ; if ( child == DTM . NULL ) return EMPTY_STR ; if ( ( _exptype2 ( child ) == DTM . TEXT_NODE ) && ( _nextsib2 ( child ) == DTM . NULL ) ) { int dataIndex = m_dataOrQName . elementAt ( child ) ; if ( dataIndex > 0 ) return m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else return m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } else return getStringValueX ( getDocument ( ) ) ; } public final void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws SAXException { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - 1 ; int length = 0 ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( - 1 == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - 1 == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + 1 ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } } } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else m_chars . sendSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; else m_chars . sendSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } String str = ( String ) m_values . elementAt ( dataIndex ) ; if ( normalize ) FastStringBuffer . sendNormalizedSAXcharacters ( str . toCharArray ( ) , 0 , str . length ( ) , ch ) ; else ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } } public String getNodeValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex > 0 ) { return m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { return m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } else if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type || DTM . DOCUMENT_NODE == type ) { return null ; } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return ( String ) m_values . elementAt ( dataIndex ) ; } } protected final void copyTextNode ( final int nodeID , SerializationHandler handler ) throws SAXException { if ( nodeID != DTM . NULL ) { int dataIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( dataIndex > 0 ) { m_chars . sendSAXcharacters ( handler , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { m_chars . sendSAXcharacters ( handler , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } } protected final String copyElement ( int nodeID , int exptype , SerializationHandler handler ) throws SAXException { final ExtendedType extType = m_extendedTypes [ exptype ] ; String uri = extType . getNamespace ( ) ; String name = extType . getLocalName ( ) ; if ( uri . length ( ) == 0 ) { handler . startElement ( name ) ; return name ; } else { int qnameIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( qnameIndex == 0 ) { handler . startElement ( name ) ; handler . namespaceAfterStartElement ( EMPTY_STR , uri ) ; return name ; } if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } String qName = m_valuesOrPrefixes . indexToString ( qnameIndex ) ; handler . startElement ( qName ) ; int prefixIndex = qName . indexOf ( ':' ) ; String prefix ; if ( prefixIndex > 0 ) { prefix = qName . substring ( 0 , prefixIndex ) ; } else { prefix = null ; } handler . namespaceAfterStartElement ( prefix , uri ) ; return qName ; } } protected final void copyAttribute ( int nodeID , int exptype , SerializationHandler handler ) throws SAXException { final ExtendedType extType = m_extendedTypes [ exptype ] ; final String uri = extType . getNamespace ( ) ; final String localName = extType . getLocalName ( ) ; String prefix = null ; String qname = null ; int dataIndex = _dataOrQName ( nodeID ) ; int valueIndex = dataIndex ; if ( uri . length ( ) != 0 ) { if ( dataIndex <= 0 ) { int prefixIndex = m_data . elementAt ( - dataIndex ) ; valueIndex = m_data . elementAt ( - dataIndex + 1 ) ; qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; int colonIndex = qname . indexOf ( ':' ) ; if ( colonIndex > 0 ) { prefix = qname . substring ( 0 , colonIndex ) ; } } handler . namespaceAfterStartElement ( prefix , uri ) ; } String nodeName = ( prefix != null ) ? qname : localName ; String nodeValue = ( String ) m_values . elementAt ( valueIndex ) ; handler . addAttribute ( nodeName , nodeValue ) ; } } 	1	['35', '5', '1', '34', '107', '213', '20', '14', '26', '0.804812834', '2248', '1', '2', '0.83919598', '0.200980392', '2', '33', '62.6', '20', '3.6286', '2']
package org . apache . xalan . templates ; import java . util . Hashtable ; import org . apache . xalan . transformer . KeyManager ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . UnionPathIterator ; import org . apache . xpath . functions . Function2Args ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class FuncKey extends Function2Args { static private Boolean ISTRUE = new Boolean ( true ) ; public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { TransformerImpl transformer = ( TransformerImpl ) xctxt . getOwnerObject ( ) ; XNodeSet nodes = null ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocumentRoot ( context ) ; if ( DTM . NULL == docContext ) { } String xkeyname = getArg0 ( ) . execute ( xctxt ) . str ( ) ; QName keyname = new QName ( xkeyname , xctxt . getNamespaceContext ( ) ) ; XObject arg = getArg1 ( ) . execute ( xctxt ) ; boolean argIsNodeSetDTM = ( XObject . CLASS_NODESET == arg . getType ( ) ) ; KeyManager kmgr = transformer . getKeyManager ( ) ; if ( argIsNodeSetDTM ) { XNodeSet ns = ( XNodeSet ) arg ; ns . setShouldCacheNodes ( true ) ; int len = ns . getLength ( ) ; if ( len <= 1 ) argIsNodeSetDTM = false ; } if ( argIsNodeSetDTM ) { Hashtable usedrefs = null ; DTMIterator ni = arg . iter ( ) ; int pos ; UnionPathIterator upi = new UnionPathIterator ( ) ; upi . exprSetParent ( this ) ; while ( DTM . NULL != ( pos = ni . nextNode ( ) ) ) { dtm = xctxt . getDTM ( pos ) ; XMLString ref = dtm . getStringValue ( pos ) ; if ( null == ref ) continue ; if ( null == usedrefs ) usedrefs = new Hashtable ( ) ; if ( usedrefs . get ( ref ) != null ) { continue ; } else { usedrefs . put ( ref , ISTRUE ) ; } XNodeSet nl = kmgr . getNodeSetDTMByKey ( xctxt , docContext , keyname , ref , xctxt . getNamespaceContext ( ) ) ; nl . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; upi . addIterator ( nl ) ; } int current = xctxt . getCurrentNode ( ) ; upi . setRoot ( current , xctxt ) ; nodes = new XNodeSet ( upi ) ; } else { XMLString ref = arg . xstr ( ) ; nodes = kmgr . getNodeSetDTMByKey ( xctxt , docContext , keyname , ref , xctxt . getNamespaceContext ( ) ) ; nodes . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; } return nodes ; } } 	1	['3', '5', '0', '14', '33', '1', '0', '14', '2', '0.5', '177', '1', '0', '0.98245614', '0.75', '1', '7', '57.66666667', '1', '0.3333', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; public final class WriterToUTF8Buffered extends Writer { private static final int buf_length = 16 * 1024 ; private final OutputStream m_os ; private final byte buf [ ] ; private int count ; public WriterToUTF8Buffered ( OutputStream out ) throws UnsupportedEncodingException { m_os = out ; buf = new byte [ buf_length + 3 ] ; count = 0 ; } public void write ( final int c ) throws IOException { if ( count >= buf_length ) flushBuffer ( ) ; if ( c < 0x80 ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } private final void writeDirect ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { final OutputStream os = m_os ; final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } } private final void writeDirect ( final String s ) throws IOException { final int n = s . length ( ) ; final OutputStream os = m_os ; for ( int i = 0 ; i < n ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } } public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; writeDirect ( chars , start , length ) ; return ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } final OutputStream os = m_os ; final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } public void write ( final String s ) throws IOException { final int length = s . length ( ) ; int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; writeDirect ( s ) ; return ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } final OutputStream os = m_os ; for ( int i = 0 ; i < length ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } public void flushBuffer ( ) throws IOException { if ( count > 0 ) { m_os . write ( buf , 0 , count ) ; count = 0 ; } } public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } } 	1	['10', '2', '0', '1', '17', '0', '1', '0', '8', '0.444444444', '588', '1', '0', '0.590909091', '0.36', '1', '2', '57.4', '1', '0.9', '1']
package org . apache . xalan . client ; import java . applet . Applet ; import java . awt . Graphics ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringReader ; import java . io . StringWriter ; import java . net . MalformedURLException ; import java . net . URL ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class XSLTProcessorApplet extends Applet { TransformerFactory m_tfactory = null ; private String m_styleURL ; private String m_documentURL ; private final String PARAM_styleURL = "styleURL" ; private final String PARAM_documentURL = "documentURL" ; private String m_styleURLOfCached = null ; private String m_documentURLOfCached = null ; private URL m_codeBase = null ; private String m_treeURL = null ; private URL m_documentBase = null ; transient private Thread m_callThread = null ; transient private TrustedAgent m_trustedAgent = null ; transient private Thread m_trustedWorker = null ; transient private String m_htmlText = null ; transient private String m_sourceText = null ; transient private String m_nameOfIDAttrOfElemToModify = null ; transient private String m_elemIdToModify = null ; transient private String m_attrNameToSet = null ; transient private String m_attrValueToSet = null ; public XSLTProcessorApplet ( ) { } public String getAppletInfo ( ) { return "Name: XSLTProcessorApplet\r\n" + "Author: Scott Boag" ; } public String [ ] [ ] getParameterInfo ( ) { String [ ] [ ] info = { { PARAM_styleURL , "String" , "URL to an XSL stylesheet" } , { PARAM_documentURL , "String" , "URL to an XML document" } , } ; return info ; } public void init ( ) { String param ; param = getParameter ( PARAM_styleURL ) ; if ( param != null ) setStyleURL ( param ) ; param = getParameter ( PARAM_documentURL ) ; if ( param != null ) setDocumentURL ( param ) ; m_codeBase = this . getCodeBase ( ) ; m_documentBase = this . getDocumentBase ( ) ; resize ( 320 , 240 ) ; } public void start ( ) { m_trustedAgent = new TrustedAgent ( ) ; Thread currentThread = Thread . currentThread ( ) ; m_trustedWorker = new Thread ( currentThread . getThreadGroup ( ) , m_trustedAgent ) ; m_trustedWorker . start ( ) ; try { m_tfactory = TransformerFactory . newInstance ( ) ; this . showStatus ( "Causing Transformer and Parser to Load and JIT..." ) ; StringReader xmlbuf = new StringReader ( "<?xml version='1.0'?><foo/>" ) ; StringReader xslbuf = new StringReader ( "<?xml version='1.0'?><xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'><xsl:template match='foo'><out/></xsl:template></xsl:stylesheet>" ) ; PrintWriter pw = new PrintWriter ( new StringWriter ( ) ) ; synchronized ( m_tfactory ) { Templates templates = m_tfactory . newTemplates ( new StreamSource ( xslbuf ) ) ; Transformer transformer = templates . newTransformer ( ) ; transformer . transform ( new StreamSource ( xmlbuf ) , new StreamResult ( pw ) ) ; } System . out . println ( "Primed the pump!" ) ; this . showStatus ( "Ready to go!" ) ; } catch ( Exception e ) { this . showStatus ( "Could not prime the pump!" ) ; System . out . println ( "Could not prime the pump!" ) ; e . printStackTrace ( ) ; } } public void paint ( Graphics g ) { } public void stop ( ) { if ( null != m_trustedWorker ) { m_trustedWorker . stop ( ) ; m_trustedWorker = null ; } m_styleURLOfCached = null ; m_documentURLOfCached = null ; } public void destroy ( ) { if ( null != m_trustedWorker ) { m_trustedWorker . stop ( ) ; m_trustedWorker = null ; } m_styleURLOfCached = null ; m_documentURLOfCached = null ; } public void setStyleURL ( String urlString ) { m_styleURL = urlString ; } public void setDocumentURL ( String urlString ) { m_documentURL = urlString ; } public void freeCache ( ) { m_styleURLOfCached = null ; m_documentURLOfCached = null ; } public void setStyleSheetAttribute ( String nameOfIDAttrOfElemToModify , String elemId , String attrName , String value ) { m_nameOfIDAttrOfElemToModify = nameOfIDAttrOfElemToModify ; m_elemIdToModify = elemId ; m_attrNameToSet = attrName ; m_attrValueToSet = value ; } transient String m_key ; transient String m_expression ; public void setStylesheetParam ( String key , String expr ) { m_key = key ; m_expression = expr ; } public String escapeString ( String s ) { StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char ch = s . charAt ( i ) ; if ( '<' == ch ) { sb . append ( "&lt;" ) ; } else if ( '>' == ch ) { sb . append ( "&gt;" ) ; } else if ( '&' == ch ) { sb . append ( "&amp;" ) ; } else if ( 0xd800 <= ch && ch < 0xdc00 ) { int next ; if ( i + 1 >= length ) { throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) } ) ) ; } else { next = s . charAt ( ++ i ) ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( ch - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } sb . append ( "&#x" ) ; sb . append ( Integer . toHexString ( next ) ) ; sb . append ( ";" ) ; } else { sb . append ( ch ) ; } } return sb . toString ( ) ; } public String getHtmlText ( ) { m_trustedAgent . m_getData = true ; m_callThread = Thread . currentThread ( ) ; try { synchronized ( m_callThread ) { m_callThread . wait ( ) ; } } catch ( InterruptedException ie ) { System . out . println ( ie . getMessage ( ) ) ; } return m_htmlText ; } public String getTreeAsText ( String treeURL ) throws IOException { m_treeURL = treeURL ; m_trustedAgent . m_getData = true ; m_trustedAgent . m_getSource = true ; m_callThread = Thread . currentThread ( ) ; try { synchronized ( m_callThread ) { m_callThread . wait ( ) ; } } catch ( InterruptedException ie ) { System . out . println ( ie . getMessage ( ) ) ; } return m_sourceText ; } private String getSource ( ) throws TransformerException { StringWriter osw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( osw , false ) ; String text = "" ; try { URL docURL = new URL ( m_documentBase , m_treeURL ) ; synchronized ( m_tfactory ) { Transformer transformer = m_tfactory . newTransformer ( ) ; StreamSource source = new StreamSource ( docURL . toString ( ) ) ; StreamResult result = new StreamResult ( pw ) ; transformer . transform ( source , result ) ; text = osw . toString ( ) ; } } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } catch ( Exception any_error ) { any_error . printStackTrace ( ) ; } return text ; } public String getSourceTreeAsText ( ) throws Exception { return getTreeAsText ( m_documentURL ) ; } public String getStyleTreeAsText ( ) throws Exception { return getTreeAsText ( m_styleURL ) ; } public String getResultTreeAsText ( ) throws Exception { return escapeString ( getHtmlText ( ) ) ; } public String transformToHtml ( String doc , String style ) { if ( null != doc ) { m_documentURL = doc ; } if ( null != style ) { m_styleURL = style ; } return getHtmlText ( ) ; } public String transformToHtml ( String doc ) { if ( null != doc ) { m_documentURL = doc ; } m_styleURL = null ; return getHtmlText ( ) ; } private String processTransformation ( ) throws TransformerException { String htmlData = null ; this . showStatus ( "Waiting for Transformer and Parser to finish loading and JITing..." ) ; synchronized ( m_tfactory ) { URL documentURL = null ; URL styleURL = null ; StringWriter osw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( osw , false ) ; StreamResult result = new StreamResult ( pw ) ; this . showStatus ( "Begin Transformation..." ) ; try { documentURL = new URL ( m_codeBase , m_documentURL ) ; StreamSource xmlSource = new StreamSource ( documentURL . toString ( ) ) ; styleURL = new URL ( m_codeBase , m_styleURL ) ; StreamSource xslSource = new StreamSource ( styleURL . toString ( ) ) ; Transformer transformer = m_tfactory . newTransformer ( xslSource ) ; if ( null != m_key ) transformer . setParameter ( m_key , m_expression ) ; transformer . transform ( xmlSource , result ) ; } catch ( TransformerConfigurationException tfe ) { tfe . printStackTrace ( ) ; System . exit ( - 1 ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } this . showStatus ( "Transformation Done!" ) ; htmlData = osw . toString ( ) ; } return htmlData ; } class TrustedAgent implements Runnable { public boolean m_getData = false ; public boolean m_getSource = false ; public void run ( ) { while ( true ) { m_trustedWorker . yield ( ) ; if ( m_getData ) { try { m_getData = false ; m_htmlText = null ; m_sourceText = null ; if ( m_getSource ) { m_getSource = false ; m_sourceText = getSource ( ) ; } else m_htmlText = processTransformation ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { synchronized ( m_callThread ) { m_callThread . notify ( ) ; } } } else { try { m_trustedWorker . sleep ( 50 ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } } } } } } 	1	['29', '5', '0', '2', '74', '300', '1', '2', '21', '0.879251701', '782', '0.857142857', '1', '0.94214876', '0.344827586', '3', '5', '25.24137931', '10', '1.5172', '2']
package org . apache . xalan . xslt ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . io . StringReader ; import java . util . Properties ; import java . util . ResourceBundle ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . TransformerFactoryConfigurationError ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . processor . XSLProcessorVersion ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . trace . PrintTraceListener ; import org . apache . xalan . trace . TraceManager ; import org . apache . xalan . transformer . XalanProperties ; import org . apache . xml . utils . DefaultErrorHandler ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class Process { protected static void printArgOptions ( ResourceBundle resbundle ) { System . out . println ( resbundle . getString ( "xslProc_option" ) ) ; System . out . println ( "\n\t\t\t" + resbundle . getString ( "xslProc_common_options" ) + "\n" ) ; System . out . println ( resbundle . getString ( "optionXSLTC" ) ) ; System . out . println ( resbundle . getString ( "optionIN" ) ) ; System . out . println ( resbundle . getString ( "optionXSL" ) ) ; System . out . println ( resbundle . getString ( "optionOUT" ) ) ; System . out . println ( resbundle . getString ( "optionV" ) ) ; System . out . println ( resbundle . getString ( "optionEDUMP" ) ) ; System . out . println ( resbundle . getString ( "optionXML" ) ) ; System . out . println ( resbundle . getString ( "optionTEXT" ) ) ; System . out . println ( resbundle . getString ( "optionHTML" ) ) ; System . out . println ( resbundle . getString ( "optionPARAM" ) ) ; System . out . println ( resbundle . getString ( "optionMEDIA" ) ) ; System . out . println ( resbundle . getString ( "optionFLAVOR" ) ) ; System . out . println ( resbundle . getString ( "optionDIAG" ) ) ; System . out . println ( resbundle . getString ( "optionURIRESOLVER" ) ) ; System . out . println ( resbundle . getString ( "optionENTITYRESOLVER" ) ) ; waitForReturnKey ( resbundle ) ; System . out . println ( resbundle . getString ( "optionCONTENTHANDLER" ) ) ; System . out . println ( "\n\t\t\t" + resbundle . getString ( "xslProc_xalan_options" ) + "\n" ) ; System . out . println ( resbundle . getString ( "optionQC" ) ) ; System . out . println ( resbundle . getString ( "optionTT" ) ) ; System . out . println ( resbundle . getString ( "optionTG" ) ) ; System . out . println ( resbundle . getString ( "optionTS" ) ) ; System . out . println ( resbundle . getString ( "optionTTC" ) ) ; System . out . println ( resbundle . getString ( "optionTCLASS" ) ) ; System . out . println ( resbundle . getString ( "optionLINENUMBERS" ) ) ; System . out . println ( resbundle . getString ( "optionINCREMENTAL" ) ) ; System . out . println ( resbundle . getString ( "optionNOOPTIMIMIZE" ) ) ; System . out . println ( resbundle . getString ( "optionRL" ) ) ; System . out . println ( "\n\t\t\t" + resbundle . getString ( "xslProc_xsltc_options" ) + "\n" ) ; System . out . println ( resbundle . getString ( "optionXO" ) ) ; System . out . println ( resbundle . getString ( "optionXD" ) ) ; waitForReturnKey ( resbundle ) ; System . out . println ( resbundle . getString ( "optionXJ" ) ) ; System . out . println ( resbundle . getString ( "optionXP" ) ) ; System . out . println ( resbundle . getString ( "optionXN" ) ) ; System . out . println ( resbundle . getString ( "optionXX" ) ) ; System . out . println ( resbundle . getString ( "optionXT" ) ) ; } public static void main ( String argv [ ] ) { boolean doStackDumpOnError = false ; boolean setQuietMode = false ; boolean doDiag = false ; java . io . PrintWriter diagnosticsWriter = new PrintWriter ( System . err , true ) ; java . io . PrintWriter dumpWriter = diagnosticsWriter ; ResourceBundle resbundle = ( XSLMessages . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . ERROR_RESOURCES ) ) ; String flavor = "s2s" ; if ( argv . length < 1 ) { printArgOptions ( resbundle ) ; } else { boolean useXSLTC = false ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( "-XSLTC" . equalsIgnoreCase ( argv [ i ] ) ) { useXSLTC = true ; } } TransformerFactory tfactory ; if ( useXSLTC ) { String key = "javax.xml.transform.TransformerFactory" ; String value = "org.apache.xalan.xsltc.trax.TransformerFactoryImpl" ; Properties props = System . getProperties ( ) ; props . put ( key , value ) ; System . setProperties ( props ) ; } try { tfactory = TransformerFactory . newInstance ( ) ; } catch ( TransformerFactoryConfigurationError pfe ) { pfe . printStackTrace ( dumpWriter ) ; diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUCCESSFUL , null ) ) ; tfactory = null ; doExit ( - 1 ) ; } boolean formatOutput = false ; boolean useSourceLocation = false ; String inFileName = null ; String outFileName = null ; String dumpFileName = null ; String xslFileName = null ; String treedumpFileName = null ; PrintTraceListener tracer = null ; String outputType = null ; String media = null ; Vector params = new Vector ( ) ; boolean quietConflictWarnings = false ; URIResolver uriResolver = null ; EntityResolver entityResolver = null ; ContentHandler contentHandler = null ; int recursionLimit = - 1 ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( "-XSLTC" . equalsIgnoreCase ( argv [ i ] ) ) { } else if ( "-TT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceTemplates = true ; } else printInvalidXSLTCOption ( "-TT" ) ; } else if ( "-TG" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceGeneration = true ; } else printInvalidXSLTCOption ( "-TG" ) ; } else if ( "-TS" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceSelection = true ; } else printInvalidXSLTCOption ( "-TS" ) ; } else if ( "-TTC" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceElements = true ; } else printInvalidXSLTCOption ( "-TTC" ) ; } else if ( "-INDENT" . equalsIgnoreCase ( argv [ i ] ) ) { int indentAmount ; if ( ( ( i + 1 ) < argv . length ) && ( argv [ i + 1 ] . charAt ( 0 ) != '-' ) ) { indentAmount = Integer . parseInt ( argv [ ++ i ] ) ; } else { indentAmount = 0 ; } } else if ( "-IN" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) inFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-IN" } ) ) ; } else if ( "-MEDIA" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) media = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-MEDIA" } ) ) ; } else if ( "-OUT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) outFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-OUT" } ) ) ; } else if ( "-XSL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) xslFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XSL" } ) ) ; } else if ( "-FLAVOR" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { flavor = argv [ ++ i ] ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-FLAVOR" } ) ) ; } else if ( "-PARAM" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 2 < argv . length ) { String name = argv [ ++ i ] ; params . addElement ( name ) ; String expression = argv [ ++ i ] ; params . addElement ( expression ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-PARAM" } ) ) ; } else if ( "-E" . equalsIgnoreCase ( argv [ i ] ) ) { } else if ( "-V" . equalsIgnoreCase ( argv [ i ] ) ) { diagnosticsWriter . println ( resbundle . getString ( "version" ) + XSLProcessorVersion . S_VERSION + ", " + resbundle . getString ( "version2" ) ) ; } else if ( "-QC" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) quietConflictWarnings = true ; else printInvalidXSLTCOption ( "-QC" ) ; } else if ( "-Q" . equalsIgnoreCase ( argv [ i ] ) ) { setQuietMode = true ; } else if ( "-DIAG" . equalsIgnoreCase ( argv [ i ] ) ) { doDiag = true ; } else if ( "-XML" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "xml" ; } else if ( "-TEXT" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "text" ; } else if ( "-HTML" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "html" ; } else if ( "-EDUMP" . equalsIgnoreCase ( argv [ i ] ) ) { doStackDumpOnError = true ; if ( ( ( i + 1 ) < argv . length ) && ( argv [ i + 1 ] . charAt ( 0 ) != '-' ) ) { dumpFileName = argv [ ++ i ] ; } } else if ( "-URIRESOLVER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { uriResolver = ( URIResolver ) Class . forName ( argv [ ++ i ] , true , ClassLoader . getSystemClassLoader ( ) ) . newInstance ( ) ; tfactory . setURIResolver ( uriResolver ) ; } catch ( Exception cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-URIResolver" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-URIResolver" } ) ) ; doExit ( - 1 ) ; } } else if ( "-ENTITYRESOLVER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { entityResolver = ( EntityResolver ) Class . forName ( argv [ ++ i ] , true , ClassLoader . getSystemClassLoader ( ) ) . newInstance ( ) ; } catch ( Exception cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-EntityResolver" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-EntityResolver" } ) ) ; doExit ( - 1 ) ; } } else if ( "-CONTENTHANDLER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { contentHandler = ( ContentHandler ) Class . forName ( argv [ ++ i ] , true , ClassLoader . getSystemClassLoader ( ) ) . newInstance ( ) ; } catch ( Exception cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-ContentHandler" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-ContentHandler" } ) ) ; doExit ( - 1 ) ; } } else if ( "-L" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) useSourceLocation = true ; else printInvalidXSLTCOption ( "-L" ) ; } else if ( "-INCREMENTAL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) tfactory . setAttribute ( "http://xml.apache.org/xalan/features/incremental" , java . lang . Boolean . TRUE ) ; else printInvalidXSLTCOption ( "-INCREMENTAL" ) ; } else if ( "-NOOPTIMIZE" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) tfactory . setAttribute ( "http://xml.apache.org/xalan/features/optimize" , java . lang . Boolean . FALSE ) ; else printInvalidXSLTCOption ( "-NOOPTIMIZE" ) ; } else if ( "-RL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( i + 1 < argv . length ) recursionLimit = Integer . parseInt ( argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-rl" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXSLTCOption ( "-RL" ) ; } } else if ( "-XO" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) { tfactory . setAttribute ( "generate-translet" , "true" ) ; tfactory . setAttribute ( "translet-name" , argv [ ++ i ] ) ; } else tfactory . setAttribute ( "generate-translet" , "true" ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XO" ) ; } } else if ( "-XD" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) tfactory . setAttribute ( "destination-directory" , argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XD" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XD" ) ; } } else if ( "-XJ" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) { tfactory . setAttribute ( "generate-translet" , "true" ) ; tfactory . setAttribute ( "jar-name" , argv [ ++ i ] ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XJ" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XJ" ) ; } } else if ( "-XP" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) tfactory . setAttribute ( "package-name" , argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XP" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XP" ) ; } } else if ( "-XN" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { tfactory . setAttribute ( "enable-inlining" , "true" ) ; } else printInvalidXalanOption ( "-XN" ) ; } else if ( "-XX" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { tfactory . setAttribute ( "debug" , "true" ) ; } else printInvalidXalanOption ( "-XX" ) ; } else if ( "-XT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { tfactory . setAttribute ( "auto-translet" , "true" ) ; } else printInvalidXalanOption ( "-XT" ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_OPTION , new Object [ ] { argv [ i ] } ) ) ; } if ( inFileName == null && xslFileName == null ) { System . err . println ( resbundle . getString ( "xslProc_no_input" ) ) ; doExit ( - 1 ) ; } try { long start = System . currentTimeMillis ( ) ; if ( null != dumpFileName ) { dumpWriter = new PrintWriter ( new FileWriter ( dumpFileName ) ) ; } Templates stylesheet = null ; if ( null != xslFileName ) { if ( flavor . equals ( "d2d" ) ) { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setNamespaceAware ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Node xslDOM = docBuilder . parse ( new InputSource ( xslFileName ) ) ; stylesheet = tfactory . newTemplates ( new DOMSource ( xslDOM , xslFileName ) ) ; } else { stylesheet = tfactory . newTemplates ( new StreamSource ( xslFileName ) ) ; } } PrintWriter resultWriter ; StreamResult strResult ; if ( null != outFileName ) { strResult = new StreamResult ( new FileOutputStream ( outFileName ) ) ; strResult . setSystemId ( outFileName ) ; } else { strResult = new StreamResult ( System . out ) ; } SAXTransformerFactory stf = ( SAXTransformerFactory ) tfactory ; if ( ! useXSLTC && useSourceLocation ) stf . setAttribute ( XalanProperties . SOURCE_LOCATION , Boolean . TRUE ) ; if ( null == stylesheet ) { Source source = stf . getAssociatedStylesheet ( new StreamSource ( inFileName ) , media , null , null ) ; if ( null != source ) stylesheet = tfactory . newTemplates ( source ) ; else { if ( null != media ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEET_IN_MEDIA , new Object [ ] { inFileName , media } ) ) ; else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEET_PI , new Object [ ] { inFileName } ) ) ; } } if ( null != stylesheet ) { Transformer transformer = flavor . equals ( "th" ) ? null : stylesheet . newTransformer ( ) ; if ( null != outputType ) { transformer . setOutputProperty ( OutputKeys . METHOD , outputType ) ; } if ( transformer instanceof org . apache . xalan . transformer . TransformerImpl ) { org . apache . xalan . transformer . TransformerImpl impl = ( org . apache . xalan . transformer . TransformerImpl ) transformer ; TraceManager tm = impl . getTraceManager ( ) ; if ( null != tracer ) tm . addTraceListener ( tracer ) ; impl . setQuietConflictWarnings ( quietConflictWarnings ) ; if ( useSourceLocation ) impl . setProperty ( XalanProperties . SOURCE_LOCATION , Boolean . TRUE ) ; if ( recursionLimit > 0 ) impl . setRecursionLimit ( recursionLimit ) ; } int nParams = params . size ( ) ; for ( int i = 0 ; i < nParams ; i += 2 ) { transformer . setParameter ( ( String ) params . elementAt ( i ) , ( String ) params . elementAt ( i + 1 ) ) ; } if ( uriResolver != null ) transformer . setURIResolver ( uriResolver ) ; if ( null != inFileName ) { if ( flavor . equals ( "d2d" ) ) { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setCoalescing ( true ) ; dfactory . setNamespaceAware ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; if ( entityResolver != null ) docBuilder . setEntityResolver ( entityResolver ) ; Node xmlDoc = docBuilder . parse ( new InputSource ( inFileName ) ) ; Document doc = docBuilder . newDocument ( ) ; org . w3c . dom . DocumentFragment outNode = doc . createDocumentFragment ( ) ; transformer . transform ( new DOMSource ( xmlDoc , inFileName ) , new DOMResult ( outNode ) ) ; Transformer serializer = stf . newTransformer ( ) ; Properties serializationProps = stylesheet . getOutputProperties ( ) ; serializer . setOutputProperties ( serializationProps ) ; if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; serializer . transform ( new DOMSource ( outNode ) , result ) ; } else serializer . transform ( new DOMSource ( outNode ) , strResult ) ; } else if ( flavor . equals ( "th" ) ) { for ( int i = 0 ; i < 1 ; i ++ ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } if ( ! useXSLTC ) stf . setAttribute ( org . apache . xalan . processor . TransformerFactoryImpl . FEATURE_INCREMENTAL , Boolean . TRUE ) ; TransformerHandler th = stf . newTransformerHandler ( stylesheet ) ; reader . setContentHandler ( th ) ; reader . setDTDHandler ( th ) ; if ( th instanceof org . xml . sax . ErrorHandler ) reader . setErrorHandler ( ( org . xml . sax . ErrorHandler ) th ) ; try { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , th ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { } catch ( org . xml . sax . SAXNotSupportedException e ) { } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } th . setResult ( strResult ) ; reader . parse ( new InputSource ( inFileName ) ) ; } } else { if ( entityResolver != null ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } reader . setEntityResolver ( entityResolver ) ; if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; transformer . transform ( new SAXSource ( reader , new InputSource ( inFileName ) ) , result ) ; } else { transformer . transform ( new SAXSource ( reader , new InputSource ( inFileName ) ) , strResult ) ; } } else if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; transformer . transform ( new StreamSource ( inFileName ) , result ) ; } else { transformer . transform ( new StreamSource ( inFileName ) , strResult ) ; } } } else { StringReader reader = new StringReader ( "<?xml version=\"1.0\"?> <doc/>" ) ; transformer . transform ( new StreamSource ( reader ) , strResult ) ; } } else { diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUCCESSFUL , null ) ) ; doExit ( - 1 ) ; } if ( null != outFileName && strResult != null ) { java . io . OutputStream out = strResult . getOutputStream ( ) ; java . io . Writer writer = strResult . getWriter ( ) ; try { if ( out != null ) out . close ( ) ; if ( writer != null ) writer . close ( ) ; } catch ( java . io . IOException ie ) { } } long stop = System . currentTimeMillis ( ) ; long millisecondsDuration = stop - start ; if ( doDiag ) { Object [ ] msgArgs = new Object [ ] { inFileName , xslFileName , new Long ( millisecondsDuration ) } ; String msg = XSLMessages . createMessage ( "diagTiming" , msgArgs ) ; diagnosticsWriter . println ( '\n' ) ; diagnosticsWriter . println ( msg ) ; } } catch ( Throwable throwable ) { while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } if ( ( throwable instanceof NullPointerException ) || ( throwable instanceof ClassCastException ) ) doStackDumpOnError = true ; diagnosticsWriter . println ( ) ; if ( doStackDumpOnError ) throwable . printStackTrace ( dumpWriter ) ; else { DefaultErrorHandler . printLocation ( diagnosticsWriter , throwable ) ; diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_XSLT_ERROR , null ) + " (" + throwable . getClass ( ) . getName ( ) + "): " + throwable . getMessage ( ) ) ; } if ( null != dumpFileName ) { dumpWriter . close ( ) ; } doExit ( - 1 ) ; } if ( null != dumpFileName ) { dumpWriter . close ( ) ; } if ( null != diagnosticsWriter ) { } diagnosticsWriter . println ( "" ) ; } } static void doExit ( int i ) { System . exit ( i ) ; } private static void waitForReturnKey ( ResourceBundle resbundle ) { System . out . println ( resbundle . getString ( "xslProc_return_to_continue" ) ) ; try { while ( System . in . read ( ) != '\n' ) ; } catch ( java . io . IOException e ) { } } private static void printInvalidXSLTCOption ( String option ) { System . err . println ( XSLMessages . createMessage ( "xslProc_invalid_xsltc_option" , new Object [ ] { option } ) ) ; } private static void printInvalidXalanOption ( String option ) { System . err . println ( XSLMessages . createMessage ( "xslProc_invalid_xalan_option" , new Object [ ] { option } ) ) ; } } 	1	['7', '1', '0', '8', '109', '21', '0', '8', '2', '2', '2034', '0', '0', '0', '0.2', '0', '0', '289.5714286', '138', '20.4286', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Param extends VariableBase { public String toString ( ) { return ( "param(" + _name + ")" ) ; } public void display ( int indent ) { indent ( indent ) ; System . out . println ( "param " + _name ) ; if ( _select != null ) { indent ( indent + IndentIncrement ) ; System . out . println ( "select " + _select . toString ( ) ) ; } displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { super . parseContents ( parser ) ; final SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof Stylesheet ) { _isLocal = false ; Param param = parser . getSymbolTable ( ) . lookupParam ( _name ) ; if ( param != null ) { final int us = this . getImportPrecedence ( ) ; final int them = param . getImportPrecedence ( ) ; if ( us == them ) { final String name = _name . toString ( ) ; reportError ( this , parser , ErrorMsg . VARIABLE_REDEF_ERR , name ) ; } else if ( them > us ) { _ignore = true ; return ; } else { param . disable ( ) ; } } ( ( Stylesheet ) parent ) . addParam ( this ) ; parser . getSymbolTable ( ) . addParam ( this ) ; } else if ( parent instanceof Template ) { _isLocal = true ; ( ( Template ) parent ) . hasParams ( true ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { _type = _select . typeCheck ( stable ) ; if ( _type instanceof ReferenceType == false ) { _select = new CastExpr ( _select , Type . Reference ) ; } } else if ( hasContents ( ) ) { typeCheckContents ( stable ) ; } _type = Type . Reference ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _ignore ) return ; _ignore = true ; final String name = getVariable ( ) ; final String signature = _type . toSignature ( ) ; final String className = _type . getClassName ( ) ; if ( isLocal ( ) ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , name ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , true ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , ADD_PARAMETER , ADD_PARAMETER_SIG ) ) ) ; if ( className != EMPTYSTRING ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } _type . translateUnBox ( classGen , methodGen ) ; if ( _refs . isEmpty ( ) ) { il . append ( _type . POP ( ) ) ; _local = null ; } else { _local = methodGen . addLocalVariable2 ( name , _type . toJCType ( ) , il . getEnd ( ) ) ; il . append ( _type . STORE ( _local . getIndex ( ) ) ) ; } } else { if ( classGen . containsField ( name ) == null ) { classGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( name ) , cpg . addUtf8 ( signature ) , null , cpg . getConstantPool ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , name ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , true ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , ADD_PARAMETER , ADD_PARAMETER_SIG ) ) ) ; _type . translateUnBox ( classGen , methodGen ) ; if ( className != EMPTYSTRING ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( classGen . getClassName ( ) , name , signature ) ) ) ; } } } } 	1	['6', '4', '0', '33', '62', '3', '8', '29', '5', '2', '369', '0', '0', '0.938271605', '0.305555556', '3', '16', '60.5', '7', '2.8333', '2']
package org . apache . xalan . transformer ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . axes . OneStepIteratorForward ; public class KeyIterator extends OneStepIteratorForward { private QName m_name ; public QName getName ( ) { return m_name ; } private Vector m_keyDeclarations ; public Vector getKeyDeclarations ( ) { return m_keyDeclarations ; } KeyIterator ( QName name , Vector keyDeclarations ) { super ( Axis . ALL ) ; m_keyDeclarations = keyDeclarations ; m_name = name ; } public short acceptNode ( int testNode ) { boolean foundKey = false ; KeyIterator ki = ( KeyIterator ) m_lpi ; org . apache . xpath . XPathContext xctxt = ki . getXPathContext ( ) ; Vector keys = ki . getKeyDeclarations ( ) ; QName name = ki . getName ( ) ; try { int nDeclarations = keys . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) keys . elementAt ( i ) ; if ( ! kd . getName ( ) . equals ( name ) ) continue ; foundKey = true ; XPath matchExpr = kd . getMatch ( ) ; double score = matchExpr . getMatchScore ( xctxt , testNode ) ; if ( score == kd . getMatch ( ) . MATCH_SCORE_NONE ) continue ; return DTMIterator . FILTER_ACCEPT ; } } catch ( TransformerException se ) { } if ( ! foundKey ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_XSLKEY_DECLARATION , new Object [ ] { name . getLocalName ( ) } ) ) ; return DTMIterator . FILTER_REJECT ; } } 	1	['4', '8', '0', '9', '15', '2', '2', '7', '3', '0.333333333', '97', '1', '1', '0.978571429', '0.4375', '2', '2', '22.75', '4', '1.5', '1']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncFloor extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( java . lang . Math . floor ( m_arg0 . execute ( xctxt ) . num ( ) ) ) ; } } 	1	['2', '4', '0', '5', '7', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '1']
package org . apache . xalan . lib ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xpath . NodeSet ; public class ExsltCommon { public static String objectType ( Object obj ) { if ( obj instanceof String ) return "string" ; else if ( obj instanceof Boolean ) return "boolean" ; else if ( obj instanceof Number ) return "number" ; else if ( obj instanceof DTMNodeIterator ) { DTMIterator dtmI = ( ( DTMNodeIterator ) obj ) . getDTMIterator ( ) ; if ( dtmI instanceof org . apache . xpath . axes . RTFIterator ) return "RTF" ; else return "node-set" ; } else return "unknown" ; } public static NodeSet nodeSet ( ExpressionContext myProcessor , Object rtf ) { return Extensions . nodeset ( myProcessor , rtf ) ; } } 	1	['3', '1', '0', '6', '6', '3', '0', '6', '3', '2', '41', '0', '0', '0', '0.444444444', '0', '0', '12.66666667', '6', '2.3333', '2']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class VariableStack implements Cloneable { public VariableStack ( ) { reset ( ) ; } public synchronized Object clone ( ) throws CloneNotSupportedException { VariableStack vs = ( VariableStack ) super . clone ( ) ; vs . _stackFrames = ( XObject [ ] ) _stackFrames . clone ( ) ; vs . _links = ( int [ ] ) _links . clone ( ) ; return vs ; } XObject [ ] _stackFrames = new XObject [ XPathContext . RECURSIONLIMIT * 2 ] ; int _frameTop ; private int _currentFrameBottom ; int [ ] _links = new int [ XPathContext . RECURSIONLIMIT ] ; int _linksTop ; public XObject elementAt ( final int i ) { return _stackFrames [ i ] ; } public int size ( ) { return _frameTop ; } public void reset ( ) { _frameTop = 0 ; _linksTop = 0 ; _links [ _linksTop ++ ] = 0 ; _stackFrames = new XObject [ _stackFrames . length ] ; } public void setStackFrame ( int sf ) { _currentFrameBottom = sf ; } public int getStackFrame ( ) { return _currentFrameBottom ; } public int link ( final int size ) { _currentFrameBottom = _frameTop ; _frameTop += size ; if ( _frameTop >= _stackFrames . length ) { XObject newsf [ ] = new XObject [ _stackFrames . length + ( 1024 * 4 ) + size ] ; System . arraycopy ( _stackFrames , 0 , newsf , 0 , _stackFrames . length ) ; _stackFrames = newsf ; } if ( _linksTop + 1 >= _links . length ) { int newlinks [ ] = new int [ _links . length + ( 1024 * 2 ) ] ; System . arraycopy ( _links , 0 , newlinks , 0 , _links . length ) ; _links = newlinks ; } _links [ _linksTop ++ ] = _currentFrameBottom ; return _currentFrameBottom ; } public void unlink ( ) { _frameTop = _links [ -- _linksTop ] ; _currentFrameBottom = _links [ _linksTop - 1 ] ; } public void unlink ( int currentFrame ) { _frameTop = _links [ -- _linksTop ] ; _currentFrameBottom = currentFrame ; } public void setLocalVariable ( int index , XObject val ) { _stackFrames [ index + _currentFrameBottom ] = val ; } public void setLocalVariable ( int index , XObject val , int stackFrame ) { _stackFrames [ index + stackFrame ] = val ; } public XObject getLocalVariable ( XPathContext xctxt , int index ) throws TransformerException { index += _currentFrameBottom ; XObject val = _stackFrames [ index ] ; if ( null == val ) throw new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VARIABLE_ACCESSED_BEFORE_BIND , null ) , xctxt . getSAXLocator ( ) ) ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return val ; } public XObject getLocalVariable ( int index , int frame ) throws TransformerException { index += frame ; XObject val = _stackFrames [ index ] ; return val ; } public XObject getLocalVariable ( XPathContext xctxt , int index , boolean destructiveOK ) throws TransformerException { index += _currentFrameBottom ; XObject val = _stackFrames [ index ] ; if ( null == val ) throw new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VARIABLE_ACCESSED_BEFORE_BIND , null ) , xctxt . getSAXLocator ( ) ) ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return destructiveOK ? val : val . getFresh ( ) ; } public boolean isLocalSet ( int index ) throws TransformerException { return ( _stackFrames [ index + _currentFrameBottom ] != null ) ; } private static XObject [ ] m_nulls = new XObject [ 1024 ] ; public void clearLocalSlots ( int start , int len ) { start += _currentFrameBottom ; System . arraycopy ( m_nulls , 0 , _stackFrames , start , len ) ; } public void setGlobalVariable ( final int index , final XObject val ) { _stackFrames [ index ] = val ; } public XObject getGlobalVariable ( XPathContext xctxt , final int index ) throws TransformerException { XObject val = _stackFrames [ index ] ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return val ; } public XObject getGlobalVariable ( XPathContext xctxt , final int index , boolean destructiveOK ) throws TransformerException { XObject val = _stackFrames [ index ] ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return destructiveOK ? val : val . getFresh ( ) ; } public XObject getVariableOrParam ( XPathContext xctxt , org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException { org . apache . xml . utils . PrefixResolver prefixResolver = xctxt . getNamespaceContext ( ) ; if ( prefixResolver instanceof org . apache . xalan . templates . ElemTemplateElement ) { org . apache . xalan . templates . ElemVariable vvar ; org . apache . xalan . templates . ElemTemplateElement prev = ( org . apache . xalan . templates . ElemTemplateElement ) prefixResolver ; if ( ! ( prev instanceof org . apache . xalan . templates . Stylesheet ) ) { while ( ! ( prev . getParentNode ( ) instanceof org . apache . xalan . templates . Stylesheet ) ) { org . apache . xalan . templates . ElemTemplateElement savedprev = prev ; while ( null != ( prev = prev . getPreviousSiblingElem ( ) ) ) { if ( prev instanceof org . apache . xalan . templates . ElemVariable ) { vvar = ( org . apache . xalan . templates . ElemVariable ) prev ; if ( vvar . getName ( ) . equals ( qname ) ) return getLocalVariable ( xctxt , vvar . getIndex ( ) ) ; } } prev = savedprev . getParentElem ( ) ; } } vvar = prev . getStylesheetRoot ( ) . getVariableOrParamComposed ( qname ) ; if ( null != vvar ) return getGlobalVariable ( xctxt , vvar . getIndex ( ) ) ; } throw new javax . xml . transform . TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VAR_NOT_RESOLVABLE , new Object [ ] { qname . toString ( ) } ) ) ; } } 	1	['22', '1', '0', '25', '42', '0', '18', '9', '21', '0.682539683', '476', '0.333333333', '2', '0', '0.365079365', '0', '0', '20.36363636', '3', '1', '2']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; public class OneStepIterator extends ChildTestIterator { protected int m_axis = - 1 ; protected DTMAxisIterator m_iterator ; OneStepIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_axis = WalkerFactory . getAxisFromStep ( compiler , firstStepPos ) ; } public OneStepIterator ( DTMAxisIterator iterator , int axis ) throws javax . xml . transform . TransformerException { super ( null ) ; m_iterator = iterator ; m_axis = axis ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; if ( m_axis > - 1 ) m_iterator = m_cdtm . getAxisIterator ( m_axis ) ; m_iterator . setStartNode ( m_context ) ; } public void detach ( ) { if ( m_allowDetach ) { if ( m_axis > - 1 ) m_iterator = null ; super . detach ( ) ; } } protected int getNextNode ( ) { return m_lastFetched = m_iterator . next ( ) ; } public Object clone ( ) throws CloneNotSupportedException { OneStepIterator clone = ( OneStepIterator ) super . clone ( ) ; if ( m_iterator != null ) { clone . m_iterator = m_iterator . cloneIterator ( ) ; } return clone ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { OneStepIterator clone = ( OneStepIterator ) super . cloneWithReset ( ) ; clone . m_iterator = m_iterator ; return clone ; } public boolean isReverseAxes ( ) { return m_iterator . isReverse ( ) ; } protected int getProximityPosition ( int predicateIndex ) { if ( ! isReverseAxes ( ) ) return super . getProximityPosition ( predicateIndex ) ; if ( predicateIndex < 0 ) return - 1 ; if ( m_proximityPositions [ predicateIndex ] <= 0 ) { XPathContext xctxt = getXPathContext ( ) ; try { OneStepIterator clone = ( OneStepIterator ) this . clone ( ) ; int root = getRoot ( ) ; xctxt . pushCurrentNode ( root ) ; clone . setRoot ( root , xctxt ) ; clone . m_predCount = predicateIndex ; int count = 1 ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } m_proximityPositions [ predicateIndex ] += count ; } catch ( CloneNotSupportedException cnse ) { } finally { xctxt . popCurrentNode ( ) ; } } return m_proximityPositions [ predicateIndex ] ; } public int getLength ( ) { if ( ! isReverseAxes ( ) ) return super . getLength ( ) ; boolean isPredicateTest = ( this == m_execContext . getSubContextList ( ) ) ; int predCount = getPredicateCount ( ) ; if ( - 1 != m_length && isPredicateTest && m_predicateIndex < 1 ) return m_length ; int count = 0 ; XPathContext xctxt = getXPathContext ( ) ; try { OneStepIterator clone = ( OneStepIterator ) this . cloneWithReset ( ) ; int root = getRoot ( ) ; xctxt . pushCurrentNode ( root ) ; clone . setRoot ( root , xctxt ) ; clone . m_predCount = m_predicateIndex ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } } catch ( CloneNotSupportedException cnse ) { } finally { xctxt . popCurrentNode ( ) ; } if ( isPredicateTest && m_predicateIndex < 1 ) m_length = count ; return count ; } protected void countProximityPosition ( int i ) { if ( ! isReverseAxes ( ) ) super . countProximityPosition ( i ) ; else if ( i < m_proximityPositions . length ) m_proximityPositions [ i ] -- ; } public void reset ( ) { super . reset ( ) ; if ( null != m_iterator ) m_iterator . reset ( ) ; } public int getAxis ( ) { return m_axis ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( OneStepIterator ) expr ) . m_axis ) return false ; return true ; } } 	1	['14', '7', '0', '12', '41', '7', '3', '10', '10', '0.346153846', '330', '1', '1', '0.917241379', '0.273809524', '4', '18', '22.42857143', '9', '2.2857', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XRTreeFragSelectWrapper ; import org . apache . xpath . objects . XString ; public class ElemVariable extends ElemTemplateElement { public ElemVariable ( ) { } protected int m_index ; int m_frameSize = - 1 ; public void setIndex ( int index ) { m_index = index ; } public int getIndex ( ) { return m_index ; } private XPath m_selectPattern ; public void setSelect ( XPath v ) { m_selectPattern = v ; } public XPath getSelect ( ) { return m_selectPattern ; } protected QName m_qname ; public void setName ( QName v ) { m_qname = v ; } public QName getName ( ) { return m_qname ; } private boolean m_isTopLevel = false ; public void setIsTopLevel ( boolean v ) { m_isTopLevel = v ; } public boolean getIsTopLevel ( ) { return m_isTopLevel ; } public int getXSLToken ( ) { return Constants . ELEMNAME_VARIABLE ; } public String getNodeName ( ) { return Constants . ELEMNAME_VARIABLE_STRING ; } public ElemVariable ( ElemVariable param ) throws TransformerException { m_selectPattern = param . m_selectPattern ; m_qname = param . m_qname ; m_isTopLevel = param . m_isTopLevel ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , var ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public XObject getValue ( TransformerImpl transformer , int sourceNode ) throws TransformerException { XObject var ; XPathContext xctxt = transformer . getXPathContext ( ) ; xctxt . pushCurrentNode ( sourceNode ) ; try { if ( null != m_selectPattern ) { var = m_selectPattern . execute ( xctxt , sourceNode , this ) ; var . allowDetachToRelease ( false ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , m_selectPattern , var ) ; } else if ( null == getFirstChildElem ( ) ) { var = XString . EMPTYSTRING ; } else { int df ; try { if ( m_parentNode instanceof Stylesheet ) df = transformer . transformToGlobalRTF ( this ) ; else df = transformer . transformToRTF ( this ) ; } finally { } var = new XRTreeFrag ( df , xctxt , this ) ; } } finally { xctxt . popCurrentNode ( ) ; } return var ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { if ( null == m_selectPattern && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { XPath newSelect = rewriteChildToExpression ( this ) ; if ( null != newSelect ) m_selectPattern = newSelect ; } StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_selectPattern ) m_selectPattern . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( ! ( m_parentNode instanceof Stylesheet ) && m_qname != null ) { m_index = cstate . addVariableName ( m_qname ) - cstate . getGlobalsSize ( ) ; } else if ( m_parentNode instanceof Stylesheet ) { cstate . resetStackFrameSize ( ) ; } super . compose ( sroot ) ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { super . endCompose ( sroot ) ; if ( m_parentNode instanceof Stylesheet ) { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; m_frameSize = cstate . getFrameSize ( ) ; cstate . resetStackFrameSize ( ) ; } } static XPath rewriteChildToExpression ( ElemTemplateElement varElem ) throws TransformerException { ElemTemplateElement t = varElem . getFirstChildElem ( ) ; if ( null != t && null == t . getNextSiblingElem ( ) ) { int etype = t . getXSLToken ( ) ; if ( Constants . ELEMNAME_VALUEOF == etype ) { ElemValueOf valueof = ( ElemValueOf ) t ; if ( valueof . getDisableOutputEscaping ( ) == false && valueof . getDOMBackPointer ( ) == null ) { varElem . m_firstChild = null ; return new XPath ( new XRTreeFragSelectWrapper ( valueof . getSelect ( ) . getExpression ( ) ) ) ; } } else if ( Constants . ELEMNAME_TEXTLITERALRESULT == etype ) { ElemTextLiteral lit = ( ElemTextLiteral ) t ; if ( lit . getDisableOutputEscaping ( ) == false && lit . getDOMBackPointer ( ) == null ) { String str = lit . getNodeValue ( ) ; XString xstr = new XString ( str ) ; varElem . m_firstChild = null ; return new XPath ( new XRTreeFragSelectWrapper ( xstr ) ) ; } } } return null ; } public void recompose ( StylesheetRoot root ) { root . recomposeVariables ( this ) ; } public void setParentElem ( ElemTemplateElement p ) { super . setParentElem ( p ) ; p . m_hasVariableDecl = true ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitVariableOrParamDecl ( this ) ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( null != m_selectPattern ) m_selectPattern . getExpression ( ) . callVisitors ( m_selectPattern , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } public boolean isPsuedoVar ( ) { java . lang . String ns = m_qname . getNamespaceURI ( ) ; if ( ( null != ns ) && ns . equals ( RedundentExprEliminator . PSUEDOVARNAMESPACE ) ) { if ( m_qname . getLocalName ( ) . startsWith ( "#" ) ) return true ; } return false ; } } 	1	['22', '3', '3', '35', '70', '151', '18', '23', '19', '0.828571429', '390', '0.8', '2', '0.907407407', '0.168181818', '2', '15', '16.5', '4', '1.0909', '2']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Run-time internal error in ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Run-time error when executing <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Invalid conversion from ''{0}'' to ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "External function ''{0}'' not supported by XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Unknown argument type in equality expression." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Invalid argument type ''{0}'' in call to ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Attempting to format number ''{0}'' using pattern ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Cannot clone iterator ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterator for axis ''{0}'' not supported." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterator for typed axis ''{0}'' not supported." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Attribute ''{0}'' outside of element." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Namespace declaration ''{0}''=''{1}'' outside of element." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Namespace for prefix ''{0}'' has not been declared." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter created using wrong type of source DOM." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "The SAX parser you are using does not handle DTD declaration events." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "The SAX parser you are using does not have support for XML Namespaces." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Could not resolve the URI reference ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '2']
package org . apache . xml . utils . res ; public class XResources_ja_JP_HA extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x3042 , 0x3044 , 0x3046 , 0x3048 , 0x304a , 0x304b , 0x304d , 0x304f , 0x3051 , 0x3053 , 0x3055 , 0x3057 , 0x3059 , 0x305b , 0x305d , 0x305f , 0x3061 , 0x3064 , 0x3066 , 0x3068 , 0x306a , 0x306b , 0x306c , 0x306d , 0x306e , 0x306f , 0x3072 , 0x3075 , 0x3078 , 0x307b , 0x307e , 0x307f , 0x3080 , 0x3081 , 0x3082 , 0x3084 , 0x3086 , 0x3088 , 0x3089 , 0x308a , 0x308b , 0x308c , 0x308d , 0x308f , 0x3090 , 0x3091 , 0x3092 , 0x3093 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '599', '0', '0', '0.976190476', '1', '0', '0', '198.3333333', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemUnknown extends ElemLiteralResult { public void execute ( TransformerImpl transformer ) throws TransformerException { } } 	1	['2', '5', '0', '2', '3', '1', '0', '2', '2', '2', '6', '0', '0', '0.995833333', '0.75', '1', '1', '2', '1', '0.5', '2']
package org . apache . xml . utils . res ; public class XResources_ja_JP_HI extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x3044 , 0x308d , 0x306f , 0x306b , 0x307b , 0x3078 , 0x3068 , 0x3061 , 0x308a , 0x306c , 0x308b , 0x3092 , 0x308f , 0x304b , 0x3088 , 0x305f , 0x308c , 0x305d , 0x3064 , 0x306d , 0x306a , 0x3089 , 0x3080 , 0x3046 , 0x3090 , 0x306e , 0x304a , 0x304f , 0x3084 , 0x307e , 0x3051 , 0x3075 , 0x3053 , 0x3048 , 0x3066 , 0x3042 , 0x3055 , 0x304d , 0x3086 , 0x3081 , 0x307f , 0x3057 , 0x3091 , 0x3072 , 0x3082 , 0x305b , 0x3059 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '595', '0', '0', '0.976190476', '1', '0', '0', '197', '1', '0.3333', '1']
package org . apache . xpath . compiler ; import org . apache . xpath . functions . Function ; public class FuncLoader { private int m_funcID ; private String m_funcName ; public String getName ( ) { return m_funcName ; } public FuncLoader ( String funcName , int funcID ) { super ( ) ; m_funcID = funcID ; m_funcName = funcName ; } public Function getFunction ( ) throws javax . xml . transform . TransformerException { try { Class function ; if ( m_funcName . indexOf ( "." ) < 0 ) { String classname = "org.apache.xpath.functions." + m_funcName ; function = Class . forName ( classname ) ; } else function = Class . forName ( m_funcName ) ; Function func = ( Function ) function . newInstance ( ) ; return func ; } catch ( ClassNotFoundException e ) { throw new javax . xml . transform . TransformerException ( e ) ; } catch ( IllegalAccessException e ) { throw new javax . xml . transform . TransformerException ( e ) ; } catch ( InstantiationException e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } } 	1	['3', '1', '0', '3', '11', '0', '2', '1', '3', '0.5', '64', '1', '0', '0', '0.555555556', '0', '0', '19.66666667', '1', '0.6667', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import org . apache . xpath . res . XPATHMessages ; public class XSLMessages extends XPATHMessages { private static ListResourceBundle XSLTBundle = null ; private static final String XSLT_ERROR_RESOURCES = "org.apache.xalan.res.XSLTErrorResources" ; public static final String createMessage ( String msgKey , Object args [ ] ) { if ( XSLTBundle == null ) XSLTBundle = loadResourceBundle ( XSLT_ERROR_RESOURCES ) ; if ( XSLTBundle != null ) { return createMsg ( XSLTBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } public static final String createWarning ( String msgKey , Object args [ ] ) { if ( XSLTBundle == null ) XSLTBundle = loadResourceBundle ( XSLT_ERROR_RESOURCES ) ; if ( XSLTBundle != null ) { return createMsg ( XSLTBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } } 	1	['4', '3', '0', '68', '7', '0', '67', '1', '3', '0.833333333', '40', '1', '0', '0.818181818', '0.555555556', '0', '0', '8.5', '3', '1.5', '1']
package org . apache . xalan . trace ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class TracerEvent implements java . util . EventListener { public final ElemTemplateElement m_styleNode ; public final TransformerImpl m_processor ; public final Node m_sourceNode ; public final QName m_mode ; public TracerEvent ( TransformerImpl processor , Node sourceNode , QName mode , ElemTemplateElement styleNode ) { this . m_processor = processor ; this . m_sourceNode = sourceNode ; this . m_mode = mode ; this . m_styleNode = styleNode ; } public static String printNode ( Node n ) { String r = n . hashCode ( ) + " " ; if ( n instanceof Element ) { r += "<" + n . getNodeName ( ) ; Node c = n . getFirstChild ( ) ; while ( null != c ) { if ( c instanceof Attr ) { r += printNode ( c ) + " " ; } c = c . getNextSibling ( ) ; } r += ">" ; } else { if ( n instanceof Attr ) { r += n . getNodeName ( ) + "=" + n . getNodeValue ( ) ; } else { r += n . getNodeName ( ) ; } } return r ; } public static String printNodeList ( NodeList l ) { String r = l . hashCode ( ) + "[" ; int len = l . getLength ( ) - 1 ; int i = 0 ; while ( i < len ) { Node n = l . item ( i ) ; if ( null != n ) { r += printNode ( n ) + ", " ; } ++ i ; } if ( i == len ) { Node n = l . item ( len ) ; if ( null != n ) { r += printNode ( n ) ; } } return r + "]" ; } } 	1	['3', '1', '0', '7', '15', '3', '4', '3', '3', '1', '183', '0', '3', '0', '0.388888889', '0', '0', '58.66666667', '5', '3.3333', '1']
package org . apache . xalan . xsltc . compiler ; import java . text . Collator ; import java . util . ArrayList ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . Method ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . NOP ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . bcel . generic . TABLESWITCH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . CompareGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSortRecordFactGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSortRecordGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; final class Sort extends Instruction implements Closure { private Expression _select ; private AttributeValue _order ; private AttributeValue _caseOrder ; private AttributeValue _dataType ; private String _data = null ; public String _lang ; public String _country ; private String _className = null ; private ArrayList _closureVars = null ; private boolean _needsSortRecordFactory = false ; public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { return null ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; _needsSortRecordFactory = true ; } } private void setInnerClassName ( String className ) { _className = className ; } public void parseContents ( Parser parser ) { final SyntaxTreeNode parent = getParent ( ) ; if ( ! ( parent instanceof ApplyTemplates ) && ! ( parent instanceof ForEach ) ) { reportError ( this , parser , ErrorMsg . STRAY_SORT_ERR , null ) ; return ; } _select = parser . parseExpression ( this , "select" , "string(.)" ) ; String val = getAttribute ( "order" ) ; if ( val . length ( ) == 0 ) val = "ascending" ; _order = AttributeValue . create ( this , val , parser ) ; val = getAttribute ( "case-order" ) ; if ( val . length ( ) == 0 ) val = "upper-first" ; _caseOrder = AttributeValue . create ( this , val , parser ) ; val = getAttribute ( "data-type" ) ; if ( val . length ( ) == 0 ) { try { final Type type = _select . typeCheck ( parser . getSymbolTable ( ) ) ; if ( type instanceof IntType ) val = "number" ; else val = "text" ; } catch ( TypeCheckError e ) { val = "text" ; } } _dataType = AttributeValue . create ( this , val , parser ) ; if ( ( val = getAttribute ( "lang" ) ) != null ) { try { StringTokenizer st = new StringTokenizer ( val , "-" , false ) ; _lang = st . nextToken ( ) ; _country = st . nextToken ( ) ; } catch ( NoSuchElementException e ) { } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tselect = _select . typeCheck ( stable ) ; if ( ! ( tselect instanceof StringType ) ) { _select = new CastExpr ( _select , Type . String ) ; } _order . typeCheck ( stable ) ; _caseOrder . typeCheck ( stable ) ; _dataType . typeCheck ( stable ) ; return Type . Void ; } public void translateSortType ( ClassGenerator classGen , MethodGenerator methodGen ) { _dataType . translate ( classGen , methodGen ) ; } public void translateSortOrder ( ClassGenerator classGen , MethodGenerator methodGen ) { _order . translate ( classGen , methodGen ) ; } public void translateSelect ( ClassGenerator classGen , MethodGenerator methodGen ) { _select . translate ( classGen , methodGen ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } public static void translateSortIterator ( ClassGenerator classGen , MethodGenerator methodGen , Expression nodeSet , Vector sortObjects ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( SORT_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_SORT_FACTORY_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( SORT_ITERATOR ) ) ) ; il . append ( DUP ) ; if ( nodeSet == null ) { final int children = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . CHILD ) ) ; il . append ( new INVOKEINTERFACE ( children , 2 ) ) ; } else { nodeSet . translate ( classGen , methodGen ) ; } compileSortRecordFactory ( sortObjects , classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } public static void compileSortRecordFactory ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen ) { String sortRecordClass = compileSortRecord ( sortObjects , classGen , methodGen ) ; boolean needsSortRecordFactory = false ; final int nsorts = sortObjects . size ( ) ; for ( int i = 0 ; i < nsorts ; i ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( i ) ; needsSortRecordFactory |= sort . _needsSortRecordFactory ; } String sortRecordFactoryClass = NODE_SORT_FACTORY ; if ( needsSortRecordFactory ) { sortRecordFactoryClass = compileSortRecordFactory ( sortObjects , classGen , methodGen , sortRecordClass ) ; } final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( sortRecordFactoryClass ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , sortRecordClass ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateSortOrder ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateSortType ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new INVOKESPECIAL ( cpg . addMethodref ( sortRecordFactoryClass , "<init>" , "(" + DOM_INTF_SIG + STRING_SIG + TRANSLET_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ) ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableRefBase varRef = ( VariableRefBase ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; il . append ( DUP ) ; il . append ( var . loadInstruction ( ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( sortRecordFactoryClass , var . getVariable ( ) , var . getType ( ) . toSignature ( ) ) ) ) ; dups . add ( varRef ) ; } } } public static String compileSortRecordFactory ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen , String sortRecordClass ) { final XSLTC xsltc = ( ( Sort ) sortObjects . firstElement ( ) ) . getXSLTC ( ) ; final String className = xsltc . getHelperClassName ( ) ; final NodeSortRecordFactGenerator sortRecordFactory = new NodeSortRecordFactGenerator ( className , NODE_SORT_FACTORY , className + ".java" , ACC_PUBLIC | ACC_SUPER | ACC_FINAL , new String [ ] { } , classGen . getStylesheet ( ) ) ; ConstantPoolGen cpg = sortRecordFactory . getConstantPool ( ) ; final int nsorts = sortObjects . size ( ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final VariableRef varRef = ( VariableRef ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; sortRecordFactory . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; dups . add ( varRef ) ; } } final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 5 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( STRING_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_INTF_SIG ) ; argTypes [ 3 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; argTypes [ 4 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; final String [ ] argNames = new String [ 5 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = "className" ; argNames [ 2 ] = TRANSLET_PNAME ; argNames [ 3 ] = "order" ; argNames [ 4 ] = "type" ; InstructionList il = new InstructionList ( ) ; final MethodGenerator constructor = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "<init>" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ALOAD_1 ) ; il . append ( ALOAD_2 ) ; il . append ( new ALOAD ( 3 ) ) ; il . append ( new ALOAD ( 4 ) ) ; il . append ( new ALOAD ( 5 ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_FACTORY , "<init>" , "(" + DOM_INTF_SIG + STRING_SIG + TRANSLET_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ) ) ; il . append ( RETURN ) ; il = new InstructionList ( ) ; final MethodGenerator makeNodeSortRecord = new MethodGenerator ( ACC_PUBLIC , Util . getJCRefType ( NODE_SORT_RECORD_SIG ) , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT } , new String [ ] { "node" , "last" } , "makeNodeSortRecord" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ILOAD_1 ) ; il . append ( ILOAD_2 ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_FACTORY , "makeNodeSortRecord" , "(II)" + NODE_SORT_RECORD_SIG ) ) ) ; il . append ( DUP ) ; il . append ( new CHECKCAST ( cpg . addClass ( sortRecordClass ) ) ) ; final int ndups = dups . size ( ) ; for ( int i = 0 ; i < ndups ; i ++ ) { final VariableRef varRef = ( VariableRef ) dups . get ( i ) ; final VariableBase var = varRef . getVariable ( ) ; final Type varType = var . getType ( ) ; il . append ( DUP ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( sortRecordClass , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; } il . append ( POP ) ; il . append ( ARETURN ) ; constructor . setMaxLocals ( ) ; constructor . setMaxStack ( ) ; sortRecordFactory . addMethod ( constructor . getMethod ( ) ) ; makeNodeSortRecord . setMaxLocals ( ) ; makeNodeSortRecord . setMaxStack ( ) ; sortRecordFactory . addMethod ( makeNodeSortRecord . getMethod ( ) ) ; xsltc . dumpClass ( sortRecordFactory . getJavaClass ( ) ) ; return className ; } private static String compileSortRecord ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen ) { final XSLTC xsltc = ( ( Sort ) sortObjects . firstElement ( ) ) . getXSLTC ( ) ; final String className = xsltc . getHelperClassName ( ) ; final NodeSortRecordGenerator sortRecord = new NodeSortRecordGenerator ( className , NODE_SORT_RECORD , "sort$0.java" , ACC_PUBLIC | ACC_SUPER | ACC_FINAL , new String [ ] { } , classGen . getStylesheet ( ) ) ; final ConstantPoolGen cpg = sortRecord . getConstantPool ( ) ; final int nsorts = sortObjects . size ( ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; sort . setInnerClassName ( className ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final VariableRef varRef = ( VariableRef ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; sortRecord . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; dups . add ( varRef ) ; } } Method init = compileInit ( sortObjects , sortRecord , cpg , className ) ; Method extract = compileExtract ( sortObjects , sortRecord , cpg , className ) ; sortRecord . addMethod ( init ) ; sortRecord . addMethod ( extract ) ; xsltc . dumpClass ( sortRecord . getJavaClass ( ) ) ; return className ; } private static Method compileInit ( Vector sortObjects , NodeSortRecordGenerator sortRecord , ConstantPoolGen cpg , String className ) { final InstructionList il = new InstructionList ( ) ; final MethodGenerator init = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , null , null , "<init>" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_RECORD , "<init>" , "()V" ) ) ) ; final int initLocale = cpg . addMethodref ( "java/util/Locale" , "<init>" , "(Ljava/lang/String;" + "Ljava/lang/String;)V" ) ; final int getCollator = cpg . addMethodref ( COLLATOR_CLASS , "getInstance" , "(Ljava/util/Locale;)" + COLLATOR_SIG ) ; final int setStrength = cpg . addMethodref ( COLLATOR_CLASS , "setStrength" , "(I)V" ) ; final int levels = sortObjects . size ( ) ; String language = null ; String country = null ; Sort sort = ( Sort ) sortObjects . elementAt ( 0 ) ; for ( int level = 0 ; level < levels ; level ++ ) { if ( language == null && sort . _lang != null ) { language = sort . _lang ; } if ( country == null && sort . _country != null ) { country = sort . _country ; } } final int collator = cpg . addFieldref ( className , "_collator" , COLLATOR_SIG ) ; final int locale = cpg . addFieldref ( className , "_locale" , LOCALE_SIG ) ; if ( language != null ) { il . append ( new NEW ( cpg . addClass ( "java/util/Locale" ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , language ) ) ; il . append ( new PUSH ( cpg , ( country != null ? country : EMPTYSTRING ) ) ) ; il . append ( new INVOKESPECIAL ( initLocale ) ) ; il . append ( ALOAD_0 ) ; il . append ( SWAP ) ; il . append ( new PUTFIELD ( locale ) ) ; il . append ( new INVOKESTATIC ( getCollator ) ) ; il . append ( ALOAD_0 ) ; il . append ( SWAP ) ; il . append ( new PUTFIELD ( collator ) ) ; } il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( collator ) ) ; il . append ( new ICONST ( Collator . TERTIARY ) ) ; il . append ( new INVOKEVIRTUAL ( setStrength ) ) ; il . append ( RETURN ) ; init . stripAttributes ( true ) ; init . setMaxLocals ( ) ; init . setMaxStack ( ) ; return init . getMethod ( ) ; } private static Method compileExtract ( Vector sortObjects , NodeSortRecordGenerator sortRecord , ConstantPoolGen cpg , String className ) { final InstructionList il = new InstructionList ( ) ; final CompareGenerator extractMethod = new CompareGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . STRING , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , Util . getJCRefType ( TRANSLET_SIG ) , org . apache . bcel . generic . Type . INT } , new String [ ] { "dom" , "current" , "level" , "translet" , "last" } , "extractValueFromDOM" , className , il , cpg ) ; final int levels = sortObjects . size ( ) ; final int match [ ] = new int [ levels ] ; final InstructionHandle target [ ] = new InstructionHandle [ levels ] ; InstructionHandle tblswitch = null ; if ( levels > 1 ) { il . append ( new ILOAD ( extractMethod . getLocalIndex ( "level" ) ) ) ; tblswitch = il . append ( new NOP ( ) ) ; } for ( int level = 0 ; level < levels ; level ++ ) { match [ level ] = level ; final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; target [ level ] = il . append ( NOP ) ; sort . translateSelect ( sortRecord , extractMethod ) ; il . append ( ARETURN ) ; } if ( levels > 1 ) { InstructionHandle defaultTarget = il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; il . insert ( tblswitch , new TABLESWITCH ( match , target , defaultTarget ) ) ; il . append ( ARETURN ) ; } extractMethod . stripAttributes ( true ) ; extractMethod . setMaxLocals ( ) ; extractMethod . setMaxStack ( ) ; extractMethod . removeNOPs ( ) ; return extractMethod . getMethod ( ) ; } } 	1	['18', '3', '0', '59', '109', '93', '2', '59', '13', '0.847058824', '1436', '0.8', '4', '0.767123288', '0.232323232', '1', '4', '78.22222222', '9', '3.0556', '3']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPathContext ; import org . xml . sax . SAXException ; public class ElemElement extends ElemUse { protected AVT m_name_avt = null ; public void setName ( AVT v ) { m_name_avt = v ; } public AVT getName ( ) { return m_name_avt ; } protected AVT m_namespace_avt = null ; public void setNamespace ( AVT v ) { m_namespace_avt = v ; } public AVT getNamespace ( ) { return m_namespace_avt ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_name_avt ) m_name_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_namespace_avt ) m_namespace_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_ELEMENT ; } public String getNodeName ( ) { return Constants . ELEMNAME_ELEMENT_STRING ; } protected boolean validateNodeName ( String nodeName ) { if ( nodeName == null ) return false ; int len = nodeName . length ( ) ; if ( len == 0 ) return false ; int indexOfNSSep = nodeName . indexOf ( ':' ) ; if ( indexOfNSSep + 1 == len ) return false ; if ( indexOfNSSep == 0 ) return false ; String localName = QName . getLocalPart ( nodeName ) ; if ( isValidNCName ( localName ) ) { String prefix = QName . getPrefixPart ( nodeName ) ; if ( prefix . length ( ) == 0 ) return true ; if ( isValidNCName ( prefix ) ) return true ; } return false ; } protected String resolvePrefix ( SerializationHandler rhandler , String prefix , String nodeNamespace ) throws TransformerException { return prefix ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; SerializationHandler rhandler = transformer . getSerializationHandler ( ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; String nodeName = m_name_avt == null ? null : m_name_avt . evaluate ( xctxt , sourceNode , this ) ; String prefix = null ; String nodeNamespace = "" ; if ( ( nodeName != null ) && ( ! m_name_avt . isSimple ( ) ) && ( ! validateNodeName ( nodeName ) ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_NAME , nodeName } ) ; nodeName = null ; } else if ( nodeName != null ) { prefix = QName . getPrefixPart ( nodeName ) ; if ( null != m_namespace_avt ) { nodeNamespace = m_namespace_avt . evaluate ( xctxt , sourceNode , this ) ; if ( null == nodeNamespace || ( prefix != null && prefix . length ( ) > 0 && nodeNamespace . length ( ) == 0 ) ) transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_NULL_URI_NAMESPACE ) ; else { prefix = resolvePrefix ( rhandler , prefix , nodeNamespace ) ; if ( null == prefix ) prefix = "" ; if ( prefix . length ( ) > 0 ) nodeName = ( prefix + ":" + QName . getLocalPart ( nodeName ) ) ; else nodeName = QName . getLocalPart ( nodeName ) ; } } else { try { nodeNamespace = getNamespaceForPrefix ( prefix ) ; if ( ( null == nodeNamespace ) && ( prefix . length ( ) == 0 ) ) nodeNamespace = "" ; else if ( null == nodeNamespace ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_COULD_NOT_RESOLVE_PREFIX , new Object [ ] { prefix } ) ; nodeName = null ; } } catch ( Exception ex ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_COULD_NOT_RESOLVE_PREFIX , new Object [ ] { prefix } ) ; nodeName = null ; } } } constructNode ( nodeName , prefix , nodeNamespace , transformer ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = false ; } else { executeNSDecls ( transformer , prefix ) ; if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , true ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = true ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } unexecuteNSDecls ( transformer , prefix ) ; } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) { if ( null != m_name_avt ) m_name_avt . callVisitors ( visitor ) ; if ( null != m_namespace_avt ) m_namespace_avt . callVisitors ( visitor ) ; } super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['13', '4', '1', '15', '51', '30', '2', '13', '9', '0.583333333', '390', '1', '2', '0.943925234', '0.230769231', '2', '6', '28.84615385', '8', '1.6923', '3']
package org . apache . xpath . functions ; public class WrongNumberArgsException extends Exception { public WrongNumberArgsException ( String argsExpected ) { super ( argsExpected ) ; } } 	1	['1', '3', '0', '12', '2', '0', '12', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . xalan . xslt ; import java . io . File ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; public class EnvironmentCheck { public static void main ( String [ ] args ) { PrintWriter sendOutputTo = new PrintWriter ( System . out , true ) ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( "-out" . equalsIgnoreCase ( args [ i ] ) ) { i ++ ; if ( i < args . length ) { try { sendOutputTo = new PrintWriter ( new FileWriter ( args [ i ] , true ) ) ; } catch ( Exception e ) { System . err . println ( "# WARNING: -out " + args [ i ] + " threw " + e . toString ( ) ) ; } } else { System . err . println ( "# WARNING: -out argument should have a filename, output sent to console" ) ; } } } EnvironmentCheck app = new EnvironmentCheck ( ) ; app . checkEnvironment ( sendOutputTo ) ; } public boolean checkEnvironment ( PrintWriter pw ) { if ( null != pw ) outWriter = pw ; Hashtable hash = getEnvironmentHash ( ) ; boolean environmentHasErrors = writeEnvironmentReport ( hash ) ; if ( environmentHasErrors ) { logMsg ( "# WARNING: Potential problems found in your environment!" ) ; logMsg ( "#    Check any 'ERROR' items above against the Xalan FAQs" ) ; logMsg ( "#    to correct potential problems with your classes/jars" ) ; logMsg ( "#    http://xml.apache.org/xalan-j/faq.html" ) ; if ( null != outWriter ) outWriter . flush ( ) ; return false ; } else { logMsg ( "# YAHOO! Your environment seems to be OK." ) ; if ( null != outWriter ) outWriter . flush ( ) ; return true ; } } public Hashtable getEnvironmentHash ( ) { Hashtable hash = new Hashtable ( ) ; checkJAXPVersion ( hash ) ; checkProcessorVersion ( hash ) ; checkParserVersion ( hash ) ; checkAntVersion ( hash ) ; checkDOMVersion ( hash ) ; checkSAXVersion ( hash ) ; checkSystemProperties ( hash ) ; return hash ; } protected boolean writeEnvironmentReport ( Hashtable h ) { if ( null == h ) { logMsg ( "# ERROR: writeEnvironmentReport called with null Hashtable" ) ; return false ; } boolean errors = false ; logMsg ( "#---- BEGIN writeEnvironmentReport($Revision: 1.19 $): Useful stuff found: ----" ) ; for ( Enumeration enum = h . keys ( ) ; enum . hasMoreElements ( ) ; ) { Object key = enum . nextElement ( ) ; String keyStr = ( String ) key ; try { if ( keyStr . startsWith ( FOUNDCLASSES ) ) { Vector v = ( Vector ) h . get ( keyStr ) ; errors |= logFoundJars ( v , keyStr ) ; } else { if ( keyStr . startsWith ( ERROR ) ) { errors = true ; } logMsg ( keyStr + "=" + h . get ( keyStr ) ) ; } } catch ( Exception e ) { logMsg ( "Reading-" + key + "= threw: " + e . toString ( ) ) ; } } logMsg ( "#----- END writeEnvironmentReport: Useful properties found: -----" ) ; return errors ; } public static final String ERROR = "ERROR." ; public static final String WARNING = "WARNING." ; public static final String ERROR_FOUND = "At least one error was found!" ; public static final String VERSION = "version." ; public static final String FOUNDCLASSES = "foundclasses." ; public static final String CLASS_PRESENT = "present-unknown-version" ; public static final String CLASS_NOTPRESENT = "not-present" ; public String [ ] jarNames = { "xalan.jar" , "xalansamples.jar" , "xalanj1compat.jar" , "xalanservlet.jar" , "xerces.jar" , "xercesImpl.jar" , "testxsl.jar" , "crimson.jar" , "lotusxsl.jar" , "jaxp.jar" , "parser.jar" , "dom.jar" , "sax.jar" , "xml.jar" , "xml-apis.jar" , "xsltc.jar" } ; protected boolean logFoundJars ( Vector v , String desc ) { if ( ( null == v ) || ( v . size ( ) < 1 ) ) return false ; boolean errors = false ; logMsg ( "#---- BEGIN Listing XML-related jars in: " + desc + " ----" ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { Hashtable subhash = ( Hashtable ) v . elementAt ( i ) ; for ( Enumeration enum = subhash . keys ( ) ; enum . hasMoreElements ( ) ; ) { Object key = enum . nextElement ( ) ; String keyStr = ( String ) key ; try { if ( keyStr . startsWith ( ERROR ) ) { errors = true ; } logMsg ( keyStr + "=" + subhash . get ( keyStr ) ) ; } catch ( Exception e ) { errors = true ; logMsg ( "Reading-" + key + "= threw: " + e . toString ( ) ) ; } } } logMsg ( "#----- END Listing XML-related jars in: " + desc + " -----" ) ; return errors ; } public void appendEnvironmentReport ( Node container , Document factory , Hashtable h ) { if ( ( null == container ) || ( null == factory ) ) { return ; } try { Element envCheckNode = factory . createElement ( "EnvironmentCheck" ) ; envCheckNode . setAttribute ( "version" , "$Revision: 1.19 $" ) ; container . appendChild ( envCheckNode ) ; if ( null == h ) { Element statusNode = factory . createElement ( "status" ) ; statusNode . setAttribute ( "result" , "ERROR" ) ; statusNode . appendChild ( factory . createTextNode ( "appendEnvironmentReport called with null Hashtable!" ) ) ; envCheckNode . appendChild ( statusNode ) ; return ; } boolean errors = false ; Element hashNode = factory . createElement ( "environment" ) ; envCheckNode . appendChild ( hashNode ) ; for ( Enumeration enum = h . keys ( ) ; enum . hasMoreElements ( ) ; ) { Object key = enum . nextElement ( ) ; String keyStr = ( String ) key ; try { if ( keyStr . startsWith ( FOUNDCLASSES ) ) { Vector v = ( Vector ) h . get ( keyStr ) ; errors |= appendFoundJars ( hashNode , factory , v , keyStr ) ; } else { if ( keyStr . startsWith ( ERROR ) ) { errors = true ; } Element node = factory . createElement ( "item" ) ; node . setAttribute ( "key" , keyStr ) ; node . appendChild ( factory . createTextNode ( ( String ) h . get ( keyStr ) ) ) ; hashNode . appendChild ( node ) ; } } catch ( Exception e ) { errors = true ; Element node = factory . createElement ( "item" ) ; node . setAttribute ( "key" , keyStr ) ; node . appendChild ( factory . createTextNode ( ERROR + " Reading " + key + " threw: " + e . toString ( ) ) ) ; hashNode . appendChild ( node ) ; } } Element statusNode = factory . createElement ( "status" ) ; statusNode . setAttribute ( "result" , ( errors ? "ERROR" : "OK" ) ) ; envCheckNode . appendChild ( statusNode ) ; } catch ( Exception e2 ) { System . err . println ( "appendEnvironmentReport threw: " + e2 . toString ( ) ) ; e2 . printStackTrace ( ) ; } } protected boolean appendFoundJars ( Node container , Document factory , Vector v , String desc ) { if ( ( null == v ) || ( v . size ( ) < 1 ) ) return false ; boolean errors = false ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { Hashtable subhash = ( Hashtable ) v . elementAt ( i ) ; for ( Enumeration enum = subhash . keys ( ) ; enum . hasMoreElements ( ) ; ) { Object key = enum . nextElement ( ) ; try { String keyStr = ( String ) key ; if ( keyStr . startsWith ( ERROR ) ) { errors = true ; } Element node = factory . createElement ( "foundJar" ) ; node . setAttribute ( "name" , keyStr . substring ( 0 , keyStr . indexOf ( "-" ) ) ) ; node . setAttribute ( "desc" , keyStr . substring ( keyStr . indexOf ( "-" ) + 1 ) ) ; node . appendChild ( factory . createTextNode ( ( String ) subhash . get ( keyStr ) ) ) ; container . appendChild ( node ) ; } catch ( Exception e ) { errors = true ; Element node = factory . createElement ( "foundJar" ) ; node . appendChild ( factory . createTextNode ( ERROR + " Reading " + key + " threw: " + e . toString ( ) ) ) ; container . appendChild ( node ) ; } } } return errors ; } protected void checkSystemProperties ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; try { String javaVersion = System . getProperty ( "java.version" ) ; h . put ( "java.version" , javaVersion ) ; } catch ( SecurityException se ) { h . put ( "java.version" , "WARNING: SecurityException thrown accessing system version properties" ) ; } try { String cp = System . getProperty ( "java.class.path" ) ; h . put ( "java.class.path" , cp ) ; Vector classpathJars = checkPathForJars ( cp , jarNames ) ; if ( null != classpathJars ) h . put ( FOUNDCLASSES + "java.class.path" , classpathJars ) ; String othercp = System . getProperty ( "sun.boot.class.path" ) ; if ( null != othercp ) { h . put ( "sun.boot.class.path" , othercp ) ; classpathJars = checkPathForJars ( othercp , jarNames ) ; if ( null != classpathJars ) h . put ( FOUNDCLASSES + "sun.boot.class.path" , classpathJars ) ; } othercp = System . getProperty ( "java.ext.dirs" ) ; if ( null != othercp ) { h . put ( "java.ext.dirs" , othercp ) ; classpathJars = checkPathForJars ( othercp , jarNames ) ; if ( null != classpathJars ) h . put ( FOUNDCLASSES + "java.ext.dirs" , classpathJars ) ; } } catch ( SecurityException se2 ) { h . put ( "java.class.path" , "WARNING: SecurityException thrown accessing system classpath properties" ) ; } } protected Vector checkPathForJars ( String cp , String [ ] jars ) { if ( ( null == cp ) || ( null == jars ) || ( 0 == cp . length ( ) ) || ( 0 == jars . length ) ) return null ; Vector v = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( cp , File . pathSeparator ) ; while ( st . hasMoreTokens ( ) ) { String filename = st . nextToken ( ) ; for ( int i = 0 ; i < jars . length ; i ++ ) { if ( filename . indexOf ( jars [ i ] ) > - 1 ) { File f = new File ( filename ) ; if ( f . exists ( ) ) { try { Hashtable h = new Hashtable ( 2 ) ; h . put ( jars [ i ] + "-path" , f . getAbsolutePath ( ) ) ; h . put ( jars [ i ] + "-apparent.version" , getApparentVersion ( jars [ i ] , f . length ( ) ) ) ; v . addElement ( h ) ; } catch ( Exception e ) { } } else { Hashtable h = new Hashtable ( 2 ) ; h . put ( jars [ i ] + "-path" , WARNING + " Classpath entry: " + filename + " does not exist" ) ; h . put ( jars [ i ] + "-apparent.version" , CLASS_NOTPRESENT ) ; v . addElement ( h ) ; } } } } return v ; } protected String getApparentVersion ( String jarName , long jarSize ) { String foundSize = ( String ) jarVersions . get ( new Long ( jarSize ) ) ; if ( ( null != foundSize ) && ( foundSize . startsWith ( jarName ) ) ) { return foundSize ; } else { if ( "xerces.jar" . equalsIgnoreCase ( jarName ) || "xercesImpl.jar" . equalsIgnoreCase ( jarName ) || "xalan.jar" . equalsIgnoreCase ( jarName ) ) { return jarName + " " + WARNING + CLASS_PRESENT ; } else { return jarName + " " + CLASS_PRESENT ; } } } protected void checkJAXPVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; final Class noArgs [ ] = new Class [ 0 ] ; Class clazz = null ; try { final String JAXP1_CLASS = "javax.xml.parsers.DocumentBuilder" ; final String JAXP11_METHOD = "getDOMImplementation" ; clazz = classForName ( JAXP1_CLASS ) ; Method method = clazz . getMethod ( JAXP11_METHOD , noArgs ) ; h . put ( VERSION + "JAXP" , "1.1" ) ; } catch ( Exception e ) { if ( null != clazz ) { h . put ( ERROR + VERSION + "JAXP" , "1.0.1" ) ; h . put ( ERROR , ERROR_FOUND ) ; } else { h . put ( ERROR + VERSION + "JAXP" , CLASS_NOTPRESENT ) ; h . put ( ERROR , ERROR_FOUND ) ; } } } protected void checkProcessorVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; try { final String XALAN1_VERSION_CLASS = "org.apache.xalan.xslt.XSLProcessorVersion" ; Class clazz = classForName ( XALAN1_VERSION_CLASS ) ; StringBuffer buf = new StringBuffer ( ) ; Field f = clazz . getField ( "PRODUCT" ) ; buf . append ( f . get ( null ) ) ; buf . append ( ';' ) ; f = clazz . getField ( "LANGUAGE" ) ; buf . append ( f . get ( null ) ) ; buf . append ( ';' ) ; f = clazz . getField ( "S_VERSION" ) ; buf . append ( f . get ( null ) ) ; buf . append ( ';' ) ; h . put ( VERSION + "xalan1" , buf . toString ( ) ) ; } catch ( Exception e1 ) { h . put ( VERSION + "xalan1" , CLASS_NOTPRESENT ) ; } try { final String XALAN2_VERSION_CLASS = "org.apache.xalan.processor.XSLProcessorVersion" ; Class clazz = classForName ( XALAN2_VERSION_CLASS ) ; StringBuffer buf = new StringBuffer ( ) ; Field f = clazz . getField ( "S_VERSION" ) ; buf . append ( f . get ( null ) ) ; h . put ( VERSION + "xalan2x" , buf . toString ( ) ) ; } catch ( Exception e2 ) { h . put ( VERSION + "xalan2x" , CLASS_NOTPRESENT ) ; } try { final String XALAN2_2_VERSION_CLASS = "org.apache.xalan.Version" ; final String XALAN2_2_VERSION_METHOD = "getVersion" ; final Class noArgs [ ] = new Class [ 0 ] ; Class clazz = classForName ( XALAN2_2_VERSION_CLASS ) ; Method method = clazz . getMethod ( XALAN2_2_VERSION_METHOD , noArgs ) ; Object returnValue = method . invoke ( null , new Object [ 0 ] ) ; h . put ( VERSION + "xalan2_2" , ( String ) returnValue ) ; } catch ( Exception e2 ) { h . put ( VERSION + "xalan2_2" , CLASS_NOTPRESENT ) ; } } protected void checkParserVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; try { final String XERCES1_VERSION_CLASS = "org.apache.xerces.framework.Version" ; Class clazz = classForName ( XERCES1_VERSION_CLASS ) ; Field f = clazz . getField ( "fVersion" ) ; String parserVersion = ( String ) f . get ( null ) ; h . put ( VERSION + "xerces1" , parserVersion ) ; } catch ( Exception e ) { h . put ( VERSION + "xerces1" , CLASS_NOTPRESENT ) ; } try { final String XERCES2_VERSION_CLASS = "org.apache.xerces.impl.Version" ; Class clazz = classForName ( XERCES2_VERSION_CLASS ) ; Field f = clazz . getField ( "fVersion" ) ; String parserVersion = ( String ) f . get ( null ) ; h . put ( VERSION + "xerces2" , parserVersion ) ; } catch ( Exception e ) { h . put ( VERSION + "xerces2" , CLASS_NOTPRESENT ) ; } try { final String CRIMSON_CLASS = "org.apache.crimson.parser.Parser2" ; Class clazz = classForName ( CRIMSON_CLASS ) ; h . put ( VERSION + "crimson" , CLASS_PRESENT ) ; } catch ( Exception e ) { h . put ( VERSION + "crimson" , CLASS_NOTPRESENT ) ; } } protected void checkAntVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; try { final String ANT_VERSION_CLASS = "org.apache.tools.ant.Main" ; final String ANT_VERSION_METHOD = "getAntVersion" ; final Class noArgs [ ] = new Class [ 0 ] ; Class clazz = classForName ( ANT_VERSION_CLASS ) ; Method method = clazz . getMethod ( ANT_VERSION_METHOD , noArgs ) ; Object returnValue = method . invoke ( null , new Object [ 0 ] ) ; h . put ( VERSION + "ant" , ( String ) returnValue ) ; } catch ( Exception e ) { h . put ( VERSION + "ant" , CLASS_NOTPRESENT ) ; } } protected void checkDOMVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; final String DOM_LEVEL2_CLASS = "org.w3c.dom.Document" ; final String DOM_LEVEL2_METHOD = "createElementNS" ; final String DOM_LEVEL2WD_CLASS = "org.w3c.dom.Node" ; final String DOM_LEVEL2WD_METHOD = "supported" ; final String DOM_LEVEL2FD_CLASS = "org.w3c.dom.Node" ; final String DOM_LEVEL2FD_METHOD = "isSupported" ; final Class twoStringArgs [ ] = { java . lang . String . class , java . lang . String . class } ; try { Class clazz = classForName ( DOM_LEVEL2_CLASS ) ; Method method = clazz . getMethod ( DOM_LEVEL2_METHOD , twoStringArgs ) ; h . put ( VERSION + "DOM" , "2.0" ) ; try { clazz = classForName ( DOM_LEVEL2WD_CLASS ) ; method = clazz . getMethod ( DOM_LEVEL2WD_METHOD , twoStringArgs ) ; h . put ( ERROR + VERSION + "DOM.draftlevel" , "2.0wd" ) ; h . put ( ERROR , ERROR_FOUND ) ; } catch ( Exception e2 ) { try { clazz = classForName ( DOM_LEVEL2FD_CLASS ) ; method = clazz . getMethod ( DOM_LEVEL2FD_METHOD , twoStringArgs ) ; h . put ( VERSION + "DOM.draftlevel" , "2.0fd" ) ; } catch ( Exception e3 ) { h . put ( ERROR + VERSION + "DOM.draftlevel" , "2.0unknown" ) ; h . put ( ERROR , ERROR_FOUND ) ; } } } catch ( Exception e ) { h . put ( ERROR + VERSION + "DOM" , "ERROR attempting to load DOM level 2 class: " + e . toString ( ) ) ; h . put ( ERROR , ERROR_FOUND ) ; } } protected void checkSAXVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; final String SAX_VERSION1_CLASS = "org.xml.sax.Parser" ; final String SAX_VERSION1_METHOD = "parse" ; final String SAX_VERSION2_CLASS = "org.xml.sax.XMLReader" ; final String SAX_VERSION2_METHOD = "parse" ; final String SAX_VERSION2BETA_CLASSNF = "org.xml.sax.helpers.AttributesImpl" ; final String SAX_VERSION2BETA_METHODNF = "setAttributes" ; final Class oneStringArg [ ] = { java . lang . String . class } ; final Class attributesArg [ ] = { org . xml . sax . Attributes . class } ; try { Class clazz = classForName ( SAX_VERSION2BETA_CLASSNF ) ; Method method = clazz . getMethod ( SAX_VERSION2BETA_METHODNF , attributesArg ) ; h . put ( VERSION + "SAX" , "2.0" ) ; } catch ( Exception e ) { h . put ( ERROR + VERSION + "SAX" , "ERROR attempting to load SAX version 2 class: " + e . toString ( ) ) ; h . put ( ERROR , ERROR_FOUND ) ; try { Class clazz = classForName ( SAX_VERSION2_CLASS ) ; Method method = clazz . getMethod ( SAX_VERSION2_METHOD , oneStringArg ) ; h . put ( VERSION + "SAX-backlevel" , "2.0beta2-or-earlier" ) ; } catch ( Exception e2 ) { h . put ( ERROR + VERSION + "SAX" , "ERROR attempting to load SAX version 2 class: " + e . toString ( ) ) ; h . put ( ERROR , ERROR_FOUND ) ; try { Class clazz = classForName ( SAX_VERSION1_CLASS ) ; Method method = clazz . getMethod ( SAX_VERSION1_METHOD , oneStringArg ) ; h . put ( VERSION + "SAX-backlevel" , "1.0" ) ; } catch ( Exception e3 ) { h . put ( ERROR + VERSION + "SAX-backlevel" , "ERROR attempting to load SAX version 1 class: " + e3 . toString ( ) ) ; } } } } protected static Class classForName ( String className ) throws ClassNotFoundException { ClassLoader classLoader = findClassLoader ( ) ; if ( classLoader == null ) { return Class . forName ( className ) ; } else { return classLoader . loadClass ( className ) ; } } protected static ClassLoader findClassLoader ( ) throws ClassNotFoundException { ClassLoader classLoader = null ; Method m = null ; try { m = Thread . class . getMethod ( "getContextClassLoader" , null ) ; } catch ( NoSuchMethodException e ) { return EnvironmentCheck . class . getClassLoader ( ) ; } try { return ( ClassLoader ) m . invoke ( Thread . currentThread ( ) , null ) ; } catch ( Exception e ) { throw new RuntimeException ( e . toString ( ) ) ; } } protected static Hashtable jarVersions = new Hashtable ( ) ; static { jarVersions . put ( new Long ( 857192 ) , "xalan.jar from xalan-j_1_1" ) ; jarVersions . put ( new Long ( 440237 ) , "xalan.jar from xalan-j_1_2" ) ; jarVersions . put ( new Long ( 436094 ) , "xalan.jar from xalan-j_1_2_1" ) ; jarVersions . put ( new Long ( 426249 ) , "xalan.jar from xalan-j_1_2_2" ) ; jarVersions . put ( new Long ( 702536 ) , "xalan.jar from xalan-j_2_0_0" ) ; jarVersions . put ( new Long ( 720930 ) , "xalan.jar from xalan-j_2_0_1" ) ; jarVersions . put ( new Long ( 732330 ) , "xalan.jar from xalan-j_2_1_0" ) ; jarVersions . put ( new Long ( 872241 ) , "xalan.jar from xalan-j_2_2_D10" ) ; jarVersions . put ( new Long ( 882739 ) , "xalan.jar from xalan-j_2_2_D11" ) ; jarVersions . put ( new Long ( 923866 ) , "xalan.jar from xalan-j_2_2_0" ) ; jarVersions . put ( new Long ( 905872 ) , "xalan.jar from xalan-j_2_3_D1" ) ; jarVersions . put ( new Long ( 906122 ) , "xalan.jar from xalan-j_2_3_0" ) ; jarVersions . put ( new Long ( 906248 ) , "xalan.jar from xalan-j_2_3_1" ) ; jarVersions . put ( new Long ( 983377 ) , "xalan.jar from xalan-j_2_4_D1" ) ; jarVersions . put ( new Long ( 997276 ) , "xalan.jar from xalan-j_2_4_0" ) ; jarVersions . put ( new Long ( 1031036 ) , "xalan.jar from xalan-j_2_4_1" ) ; jarVersions . put ( new Long ( 857171 ) , "xalan.jar from lotusxsl-j_1_0_1" ) ; jarVersions . put ( new Long ( 802165 ) , "xalan.jar from lotusxsl-j_2_0_0" ) ; jarVersions . put ( new Long ( 857692 ) , "xalan.jar from lotusxsl-j_2_2" ) ; jarVersions . put ( new Long ( 906359 ) , "xalan.jar from lotusxsl-j_2_3_1" ) ; jarVersions . put ( new Long ( 857692 ) , "xalan.jar from lotusxsl-j_2_3_2" ) ; jarVersions . put ( new Long ( 1201514 ) , "xalan.jar from lotusxsl-j_2_3_3" ) ; jarVersions . put ( new Long ( 1201599 ) , "xalan.jar from lotusxsl-j_2_3_4" ) ; jarVersions . put ( new Long ( 1201641 ) , "xalan.jar from lotusxsl-j_2_3_5" ) ; jarVersions . put ( new Long ( 596540 ) , "xsltc.jar from xalan-j_2_2_0" ) ; jarVersions . put ( new Long ( 590247 ) , "xsltc.jar from xalan-j_2_3_D1" ) ; jarVersions . put ( new Long ( 589914 ) , "xsltc.jar from xalan-j_2_3_0" ) ; jarVersions . put ( new Long ( 589915 ) , "xsltc.jar from xalan-j_2_3_1" ) ; jarVersions . put ( new Long ( 1306667 ) , "xsltc.jar from xalan-j_2_4_D1" ) ; jarVersions . put ( new Long ( 1328227 ) , "xsltc.jar from xalan-j_2_4_0" ) ; jarVersions . put ( new Long ( 1344009 ) , "xsltc.jar from xalan-j_2_4_1" ) ; jarVersions . put ( new Long ( 1348361 ) , "xsltc.jar from xalan-j_2_5_D1" ) ; jarVersions . put ( new Long ( 1268634 ) , "xsltc.jar-bundled from xalan-j_2_3_0" ) ; jarVersions . put ( new Long ( 100196 ) , "xml-apis.jar from xalan-j_2_2_0 or xalan-j_2_3_D1" ) ; jarVersions . put ( new Long ( 108484 ) , "xml-apis.jar from xalan-j_2_3_0, or xalan-j_2_3_1 from xml-commons-1.0.b2" ) ; jarVersions . put ( new Long ( 109049 ) , "xml-apis.jar from xalan-j_2_4_0 from xml-commons RIVERCOURT1 branch" ) ; jarVersions . put ( new Long ( 109049 ) , "xml-apis.jar from xalan-j_2_4_0, lotusxsl-j_2_3_2 or lotusxsl-j_2_3_3 from xml-commons RIVERCOURT1" ) ; jarVersions . put ( new Long ( 113749 ) , "xml-apis.jar from xalan-j_2_4_1, lotusxsl-j_2_3_4 or lotusxsl-j_2_3_5 from factoryfinder-build of xml-commons RIVERCOURT1" ) ; jarVersions . put ( new Long ( 124704 ) , "xml-apis.jar from xalan-j_2_5_0 from from tck-jaxp-1_2_0 branch of xml-commons" ) ; jarVersions . put ( new Long ( 424490 ) , "xalan.jar from Xerces Tools releases - ERROR:DO NOT USE!" ) ; jarVersions . put ( new Long ( 1591855 ) , "xerces.jar from xalan-j_1_1 from xerces-1..." ) ; jarVersions . put ( new Long ( 1498679 ) , "xerces.jar from xalan-j_1_2 from xerces-1_2_0.bin" ) ; jarVersions . put ( new Long ( 1484896 ) , "xerces.jar from xalan-j_1_2_1 from xerces-1_2_1.bin" ) ; jarVersions . put ( new Long ( 804460 ) , "xerces.jar from xalan-j_1_2_2 from xerces-1_2_2.bin" ) ; jarVersions . put ( new Long ( 1499244 ) , "xerces.jar from xalan-j_2_0_0 from xerces-1_2_3.bin" ) ; jarVersions . put ( new Long ( 1605266 ) , "xerces.jar from xalan-j_2_0_1 from xerces-1_3_0.bin" ) ; jarVersions . put ( new Long ( 904030 ) , "xerces.jar from xalan-j_2_1_0 from xerces-1_4.bin" ) ; jarVersions . put ( new Long ( 1190776 ) , "xerces.jar from lotusxsl_1_0_1 apparently-from xerces-1_0_3.bin" ) ; jarVersions . put ( new Long ( 1489400 ) , "xerces.jar from lotusxsl-j_2_0_0 from XML4J-3_1_1" ) ; jarVersions . put ( new Long ( 1787796 ) , "xerces.jar from lotusxsl-j_2_2 or xerces-1_4_1.bin" ) ; jarVersions . put ( new Long ( 904030 ) , "xerces.jar from xerces-1_4_0.bin" ) ; jarVersions . put ( new Long ( 1802885 ) , "xerces.jar from xerces-1_4_2.bin" ) ; jarVersions . put ( new Long ( 1734594 ) , "xerces.jar from Xerces-J-bin.2.0.0.beta3" ) ; jarVersions . put ( new Long ( 1808883 ) , "xerces.jar from xalan-j_2_2_D10,D11,D12 or xerces-1_4_3.bin" ) ; jarVersions . put ( new Long ( 1803877 ) , "xerces.jar from XML4J-3_2_1" ) ; jarVersions . put ( new Long ( 1812019 ) , "xerces.jar from xalan-j_2_2_0" ) ; jarVersions . put ( new Long ( 1720292 ) , "xercesImpl.jar from xalan-j_2_3_D1" ) ; jarVersions . put ( new Long ( 1730053 ) , "xercesImpl.jar from xalan-j_2_3_0 or xalan-j_2_3_1 from xerces-2_0_0" ) ; jarVersions . put ( new Long ( 1728861 ) , "xercesImpl.jar from xalan-j_2_4_D1 from xerces-2_0_1" ) ; jarVersions . put ( new Long ( 972027 ) , "xercesImpl.jar from xalan-j_2_4_0 from xerces-2_1" ) ; jarVersions . put ( new Long ( 831587 ) , "xercesImpl.jar from xalan-j_2_4_1 from xerces-2_2" ) ; jarVersions . put ( new Long ( 891817 ) , "xercesImpl.jar from xalan-j_2_5_D1 from xerces-2_3" ) ; jarVersions . put ( new Long ( 895924 ) , "xercesImpl.jar from xalan-j_2_5_0 from xerces-2_4" ) ; jarVersions . put ( new Long ( 1729063 ) , "xercesImpl.jar from lotusxsl-j_2_3_1 from XML4J-4_0_0" ) ; jarVersions . put ( new Long ( 1738551 ) , "xercesImpl.jar from lotusxsl-j_2_3_2 from XML4J-4_0_2" ) ; jarVersions . put ( new Long ( 3243826 ) , "xercesImpl.jar from lotusxsl-j_2_3_3 from XML4J-4_0_5" ) ; jarVersions . put ( new Long ( 1171789 ) , "xercesImpl.jar from lotusxsl-j_2_3_4 from XML4J-4_0_6" ) ; jarVersions . put ( new Long ( 1174955 ) , "xercesImpl.jar from lotusxsl-j_2_3_5 from XML4J-4_0_8" ) ; jarVersions . put ( new Long ( 1173922 ) , "xercesImpl.jar from lotusxsl-j_2_3_6 from XML4J-4_0_9" ) ; jarVersions . put ( new Long ( 831828 ) , "xercesImpl.jar from lotusxsl-j_2_4_0 from XML4J-4_1_1" ) ; jarVersions . put ( new Long ( 37485 ) , "xalanj1compat.jar from xalan-j_2_0_0" ) ; jarVersions . put ( new Long ( 38100 ) , "xalanj1compat.jar from xalan-j_2_0_1" ) ; jarVersions . put ( new Long ( 18779 ) , "xalanservlet.jar from xalan-j_2_0_0" ) ; jarVersions . put ( new Long ( 21453 ) , "xalanservlet.jar from xalan-j_2_0_1" ) ; jarVersions . put ( new Long ( 24826 ) , "xalanservlet.jar from xalan-j_2_3_1 or xalan-j_2_4_1 or lotusxsl-j_2_3_1 to lotusxsl-j-2_3_5" ) ; jarVersions . put ( new Long ( 24831 ) , "xalanservlet.jar from xalan-j_2_4_1" ) ; jarVersions . put ( new Long ( 5618 ) , "jaxp.jar from jaxp1.0.1" ) ; jarVersions . put ( new Long ( 136133 ) , "parser.jar from jaxp1.0.1" ) ; jarVersions . put ( new Long ( 28404 ) , "jaxp.jar from jaxp-1.1" ) ; jarVersions . put ( new Long ( 187162 ) , "crimson.jar from jaxp-1.1" ) ; jarVersions . put ( new Long ( 801714 ) , "xalan.jar from jaxp-1.1" ) ; jarVersions . put ( new Long ( 196399 ) , "crimson.jar from crimson-1.1.1" ) ; jarVersions . put ( new Long ( 33323 ) , "jaxp.jar from crimson-1.1.1 or jakarta-ant-1.4.1b1" ) ; jarVersions . put ( new Long ( 152717 ) , "crimson.jar from crimson-1.1.2beta2" ) ; jarVersions . put ( new Long ( 88143 ) , "xml-apis.jar from crimson-1.1.2beta2" ) ; jarVersions . put ( new Long ( 206384 ) , "crimson.jar from crimson-1.1.3 or jakarta-ant-1.4.1b1" ) ; jarVersions . put ( new Long ( 136198 ) , "parser.jar from jakarta-ant-1.3 or 1.2" ) ; jarVersions . put ( new Long ( 5537 ) , "jaxp.jar from jakarta-ant-1.3 or 1.2" ) ; jarVersions . put ( new Long ( 120274 ) , "lotusxsl.jar from lotusxsl-0_16_4" ) ; jarVersions . put ( new Long ( 120293 ) , "lotusxsl.jar from lotusxsl-0_16_5" ) ; jarVersions . put ( new Long ( 283777 ) , "lotusxsl.jar from lotusxsl-0_17_2" ) ; jarVersions . put ( new Long ( 305577 ) , "lotusxsl.jar from lotusxsl-0_17_3" ) ; jarVersions . put ( new Long ( 304500 ) , "lotusxsl.jar from lotusxsl-0_17_4" ) ; jarVersions . put ( new Long ( 714959 ) , "lotusxsl.jar from lotusxsl-0_18_1" ) ; jarVersions . put ( new Long ( 717674 ) , "lotusxsl.jar from lotusxsl-0_18_2" ) ; jarVersions . put ( new Long ( 752343 ) , "lotusxsl.jar from lotusxsl-0_18_3" ) ; jarVersions . put ( new Long ( 907101 ) , "lotusxsl.jar from lotusxsl-0_18_4" ) ; } protected PrintWriter outWriter = new PrintWriter ( System . out , true ) ; protected void logMsg ( String s ) { outWriter . println ( s ) ; } } 	1	['22', '1', '0', '1', '78', '219', '1', '0', '5', '0.972789116', '2461', '0.142857143', '0', '0', '0.227513228', '0', '0', '110.2272727', '8', '3.4091', '1']
package org . apache . xalan . processor ; import java . util . Vector ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . templates . XMLNSDecl ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . XPath ; import org . xml . sax . Attributes ; import org . xml . sax . Locator ; import org . xml . sax . helpers . AttributesImpl ; public class ProcessorLRE extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { try { ElemTemplateElement p = handler . getElemTemplateElement ( ) ; boolean excludeXSLDecl = false ; boolean isLREAsStyleSheet = false ; if ( null == p ) { XSLTElementProcessor lreProcessor = handler . popProcessor ( ) ; XSLTElementProcessor stylesheetProcessor = handler . getProcessorFor ( Constants . S_XSLNAMESPACEURL , "stylesheet" , "xsl:stylesheet" ) ; handler . pushProcessor ( lreProcessor ) ; Stylesheet stylesheet ; try { stylesheet = new StylesheetRoot ( handler . getSchema ( ) , handler . getStylesheetProcessor ( ) . getErrorListener ( ) ) ; } catch ( TransformerConfigurationException tfe ) { throw new TransformerException ( tfe ) ; } SAXSourceLocator slocator = new SAXSourceLocator ( ) ; Locator locator = handler . getLocator ( ) ; if ( null != locator ) { slocator . setLineNumber ( locator . getLineNumber ( ) ) ; slocator . setColumnNumber ( locator . getColumnNumber ( ) ) ; slocator . setPublicId ( locator . getPublicId ( ) ) ; slocator . setSystemId ( locator . getSystemId ( ) ) ; } stylesheet . setLocaterInfo ( slocator ) ; stylesheet . setPrefixes ( handler . getNamespaceSupport ( ) ) ; handler . pushStylesheet ( stylesheet ) ; isLREAsStyleSheet = true ; AttributesImpl stylesheetAttrs = new AttributesImpl ( ) ; AttributesImpl lreAttrs = new AttributesImpl ( ) ; int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrLocalName = attributes . getLocalName ( i ) ; String attrUri = attributes . getURI ( i ) ; String value = attributes . getValue ( i ) ; if ( ( null != attrUri ) && attrUri . equals ( Constants . S_XSLNAMESPACEURL ) ) { stylesheetAttrs . addAttribute ( null , attrLocalName , attrLocalName , attributes . getType ( i ) , attributes . getValue ( i ) ) ; } else if ( ( attrLocalName . startsWith ( "xmlns:" ) || attrLocalName . equals ( "xmlns" ) ) && value . equals ( Constants . S_XSLNAMESPACEURL ) ) { } else { lreAttrs . addAttribute ( attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getType ( i ) , attributes . getValue ( i ) ) ; } } attributes = lreAttrs ; try { stylesheetProcessor . setPropertiesFromAttributes ( handler , "stylesheet" , stylesheetAttrs , stylesheet ) ; } catch ( Exception e ) { String msg = e . getMessage ( ) ; if ( stylesheet . getDeclaredPrefixes ( ) == null || ! declaredXSLNS ( stylesheet ) ) { msg = msg + "; " + XSLMessages . createWarning ( XSLTErrorResources . WG_OLD_XSLT_NS , null ) ; } throw new org . xml . sax . SAXException ( msg , e ) ; } handler . pushElemTemplateElement ( stylesheet ) ; ElemTemplate template = new ElemTemplate ( ) ; appendAndPush ( handler , template ) ; XPath rootMatch = new XPath ( "/" , stylesheet , stylesheet , XPath . MATCH , handler . getStylesheetProcessor ( ) . getErrorListener ( ) ) ; template . setMatch ( rootMatch ) ; stylesheet . setTemplate ( template ) ; p = handler . getElemTemplateElement ( ) ; excludeXSLDecl = true ; } XSLTElementDef def = getElemDef ( ) ; Class classObject = def . getClassObject ( ) ; boolean isExtension = false ; boolean isComponentDecl = false ; boolean isUnknownTopLevel = false ; while ( null != p ) { if ( p instanceof ElemLiteralResult ) { ElemLiteralResult parentElem = ( ElemLiteralResult ) p ; isExtension = parentElem . containsExtensionElementURI ( uri ) ; } else if ( p instanceof Stylesheet ) { Stylesheet parentElem = ( Stylesheet ) p ; isExtension = parentElem . containsExtensionElementURI ( uri ) ; if ( ( false == isExtension ) && ( null != uri ) && ( uri . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) || uri . equals ( Constants . S_BUILTIN_OLD_EXTENSIONS_URL ) ) ) { isComponentDecl = true ; } else { isUnknownTopLevel = true ; } } if ( isExtension ) break ; p = p . getParentElem ( ) ; } ElemTemplateElement elem = null ; try { if ( isExtension ) { elem = new ElemExtensionCall ( ) ; } else if ( isComponentDecl ) { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; } else if ( isUnknownTopLevel ) { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; } else { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; } elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; elem . setPrefixes ( handler . getNamespaceSupport ( ) , excludeXSLDecl ) ; if ( elem instanceof ElemLiteralResult ) { ( ( ElemLiteralResult ) elem ) . setNamespace ( uri ) ; ( ( ElemLiteralResult ) elem ) . setLocalName ( localName ) ; ( ( ElemLiteralResult ) elem ) . setRawName ( rawName ) ; ( ( ElemLiteralResult ) elem ) . setIsLiteralResultAsStylesheet ( isLREAsStyleSheet ) ; } } catch ( InstantiationException ie ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMLITRSLT , null , ie ) ; } catch ( IllegalAccessException iae ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMLITRSLT , null , iae ) ; } setPropertiesFromAttributes ( handler , rawName , attributes , elem ) ; if ( ! isExtension && ( elem instanceof ElemLiteralResult ) ) { isExtension = ( ( ElemLiteralResult ) elem ) . containsExtensionElementURI ( uri ) ; if ( isExtension ) { elem = new ElemExtensionCall ( ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; elem . setPrefixes ( handler . getNamespaceSupport ( ) ) ; ( ( ElemLiteralResult ) elem ) . setNamespace ( uri ) ; ( ( ElemLiteralResult ) elem ) . setLocalName ( localName ) ; ( ( ElemLiteralResult ) elem ) . setRawName ( rawName ) ; setPropertiesFromAttributes ( handler , rawName , attributes , elem ) ; } } appendAndPush ( handler , elem ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ElemTemplateElement elem = handler . getElemTemplateElement ( ) ; if ( elem instanceof ElemLiteralResult ) { if ( ( ( ElemLiteralResult ) elem ) . getIsLiteralResultAsStylesheet ( ) ) { handler . popStylesheet ( ) ; } } super . endElement ( handler , uri , localName , rawName ) ; } private boolean declaredXSLNS ( Stylesheet stylesheet ) { Vector declaredPrefixes = stylesheet . getDeclaredPrefixes ( ) ; int n = declaredPrefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) declaredPrefixes . elementAt ( i ) ; if ( decl . getURI ( ) . equals ( Constants . S_XSLNAMESPACEURL ) ) return true ; } return false ; } } 	1	['4', '5', '0', '17', '77', '6', '1', '17', '3', '2', '472', '0', '0', '0.986111111', '0.5', '4', '6', '117', '3', '1.25', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import org . apache . xml . res . XMLMessages ; public class XPATHMessages extends XMLMessages { private static ListResourceBundle XPATHBundle = null ; private static final String XPATH_ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String createXPATHMessage ( String msgKey , Object args [ ] ) { if ( XPATHBundle == null ) XPATHBundle = loadResourceBundle ( XPATH_ERROR_RESOURCES ) ; if ( XPATHBundle != null ) { return createXPATHMsg ( XPATHBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } public static final String createXPATHWarning ( String msgKey , Object args [ ] ) { if ( XPATHBundle == null ) XPATHBundle = loadResourceBundle ( XPATH_ERROR_RESOURCES ) ; if ( XPATHBundle != null ) { return createXPATHMsg ( XPATHBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } public static final String createXPATHMsg ( ListResourceBundle fResourceBundle , String msgKey , Object args [ ] ) { String fmsg = null ; boolean throwex = false ; String msg = null ; if ( msgKey != null ) msg = fResourceBundle . getString ( msgKey ) ; if ( msg == null ) { msg = fResourceBundle . getString ( XPATHErrorResources . BAD_CODE ) ; throwex = true ; } if ( args != null ) { try { int n = args . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( null == args [ i ] ) args [ i ] = "" ; } fmsg = java . text . MessageFormat . format ( msg , args ) ; } catch ( Exception e ) { fmsg = fResourceBundle . getString ( XPATHErrorResources . FORMAT_FAILED ) ; fmsg += " " + msg ; } } else fmsg = msg ; if ( throwex ) { throw new RuntimeException ( fmsg ) ; } return fmsg ; } } 	1	['5', '2', '1', '2', '13', '4', '1', '1', '4', '0.875', '115', '1', '0', '0.666666667', '0.5', '0', '0', '21.6', '7', '2.6', '1']
package org . apache . xpath ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . xml . sax . ContentHandler ; public abstract class Expression implements java . io . Serializable , ExpressionNode , XPathVisitable { private ExpressionNode m_parent ; public boolean canTraverseOutsideSubtree ( ) { return false ; } public XObject execute ( XPathContext xctxt , int currentNode ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) ; } public XObject execute ( XPathContext xctxt , int currentNode , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) ; } public abstract XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException ; public XObject execute ( XPathContext xctxt , boolean destructiveOK ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) . num ( ) ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) . bool ( ) ; } public XMLString xstr ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) . xstr ( ) ; } public boolean isNodesetExpr ( ) { return false ; } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator iter = execute ( xctxt ) . iter ( ) ; return iter . nextNode ( ) ; } public DTMIterator asIterator ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { try { xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; return execute ( xctxt ) . iter ( ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; } } public DTMIterator asIteratorRaw ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { try { xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; XNodeSet nodeset = ( XNodeSet ) execute ( xctxt ) ; return nodeset . iterRaw ( ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; } } public void executeCharsToContentHandler ( XPathContext xctxt , ContentHandler handler ) throws javax . xml . transform . TransformerException , org . xml . sax . SAXException { XObject obj = execute ( xctxt ) ; obj . dispatchCharactersEvents ( handler ) ; obj . detach ( ) ; } public boolean isStableNumber ( ) { return false ; } public abstract void fixupVariables ( java . util . Vector vars , int globalsSize ) ; public abstract boolean deepEquals ( Expression expr ) ; protected final boolean isSameClass ( Expression expr ) { if ( null == expr ) return false ; return ( getClass ( ) == expr . getClass ( ) ) ; } public void warn ( XPathContext xctxt , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; eh . warning ( new TransformerException ( fmsg , xctxt . getSAXLocator ( ) ) ) ; } } public void assertion ( boolean b , java . lang . String msg ) { if ( ! b ) { java . lang . String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( XPathContext xctxt , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , this ) ; eh . fatalError ( te ) ; } } public ExpressionNode getExpressionOwner ( ) { ExpressionNode parent = exprGetParent ( ) ; while ( ( null != parent ) && ( parent instanceof Expression ) ) parent = parent . exprGetParent ( ) ; return parent ; } public void exprSetParent ( ExpressionNode n ) { assertion ( n != this , "Can not parent an expression to itself!" ) ; m_parent = n ; } public ExpressionNode exprGetParent ( ) { return m_parent ; } public void exprAddChild ( ExpressionNode n , int i ) { assertion ( false , "exprAddChild method not implemented!" ) ; } public ExpressionNode exprGetChild ( int i ) { return null ; } public int exprGetNumChildren ( ) { return 0 ; } public String getPublicId ( ) { if ( null == m_parent ) return null ; return m_parent . getPublicId ( ) ; } public String getSystemId ( ) { if ( null == m_parent ) return null ; return m_parent . getSystemId ( ) ; } public int getLineNumber ( ) { if ( null == m_parent ) return 0 ; return m_parent . getLineNumber ( ) ; } public int getColumnNumber ( ) { if ( null == m_parent ) return 0 ; return m_parent . getColumnNumber ( ) ; } } 	1	['31', '1', '6', '103', '56', '435', '95', '9', '30', '0.8', '275', '1', '1', '0', '0.190615836', '0', '0', '7.838709677', '3', '1.2903', '1']
