package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	1	['4', '1', '0', '8', '17', '0', '3', '5', '3', '0', '116', '1', '0', '0', '0.5', '0', '0', '27.75', '2', '1.25', '1']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . FormulaParser ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . FormulaRecord ; import org . apache . poi . hssf . record . LabelSSTRecord ; import org . apache . poi . hssf . record . NumberRecord ; import org . apache . poi . hssf . record . BlankRecord ; import org . apache . poi . hssf . record . BoolErrRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . aggregates . FormulaRecordAggregate ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . hssf . util . SheetReferences ; import java . util . Date ; import java . util . Calendar ; public class HSSFCell { public final static int CELL_TYPE_NUMERIC = 0 ; public final static int CELL_TYPE_STRING = 1 ; public final static int CELL_TYPE_FORMULA = 2 ; public final static int CELL_TYPE_BLANK = 3 ; public final static int CELL_TYPE_BOOLEAN = 4 ; public final static int CELL_TYPE_ERROR = 5 ; public final static short ENCODING_COMPRESSED_UNICODE = 0 ; public final static short ENCODING_UTF_16 = 1 ; private short cellNum ; private int cellType ; private HSSFCellStyle cellStyle ; private double cellValue ; private String stringValue ; private boolean booleanValue ; private byte errorValue ; private short encoding = ENCODING_COMPRESSED_UNICODE ; private Workbook book ; private Sheet sheet ; private int row ; private CellValueRecordInterface record ; protected HSSFCell ( Workbook book , Sheet sheet , int row , short col ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; setCellType ( CELL_TYPE_BLANK , false ) ; ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , short col , int type ) { checkBounds ( col ) ; cellNum = col ; this . row = row ; cellType = type ; cellStyle = null ; cellValue = 0 ; stringValue = null ; booleanValue = false ; errorValue = ( byte ) 0 ; this . book = book ; this . sheet = sheet ; switch ( type ) { case CELL_TYPE_NUMERIC : record = new NumberRecord ( ) ; ( ( NumberRecord ) record ) . setColumn ( col ) ; ( ( NumberRecord ) record ) . setRow ( row ) ; ( ( NumberRecord ) record ) . setValue ( ( short ) 0 ) ; ( ( NumberRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_STRING : record = new LabelSSTRecord ( ) ; ( ( LabelSSTRecord ) record ) . setColumn ( col ) ; ( ( LabelSSTRecord ) record ) . setRow ( row ) ; ( ( LabelSSTRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_BLANK : record = new BlankRecord ( ) ; ( ( BlankRecord ) record ) . setColumn ( col ) ; ( ( BlankRecord ) record ) . setRow ( row ) ; ( ( BlankRecord ) record ) . setXFIndex ( ( short ) 0 ) ; break ; case CELL_TYPE_FORMULA : FormulaRecord formulaRecord = new FormulaRecord ( ) ; record = new FormulaRecordAggregate ( formulaRecord , null ) ; formulaRecord . setColumn ( col ) ; formulaRecord . setRow ( row ) ; formulaRecord . setXFIndex ( ( short ) 0 ) ; case CELL_TYPE_BOOLEAN : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( false ) ; break ; case CELL_TYPE_ERROR : record = new BoolErrRecord ( ) ; ( ( BoolErrRecord ) record ) . setColumn ( col ) ; ( ( BoolErrRecord ) record ) . setRow ( row ) ; ( ( BoolErrRecord ) record ) . setXFIndex ( ( short ) 0 ) ; ( ( BoolErrRecord ) record ) . setValue ( ( byte ) 0 ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( 0xf ) ; setCellStyle ( new HSSFCellStyle ( ( short ) 0xf , xf ) ) ; } protected HSSFCell ( Workbook book , Sheet sheet , int row , CellValueRecordInterface cval ) { cellNum = cval . getColumn ( ) ; record = cval ; this . row = row ; cellType = determineType ( cval ) ; cellStyle = null ; stringValue = null ; this . book = book ; this . sheet = sheet ; switch ( cellType ) { case CELL_TYPE_NUMERIC : cellValue = ( ( NumberRecord ) cval ) . getValue ( ) ; break ; case CELL_TYPE_STRING : stringValue = book . getSSTString ( ( ( LabelSSTRecord ) cval ) . getSSTIndex ( ) ) ; break ; case CELL_TYPE_BLANK : break ; case CELL_TYPE_FORMULA : cellValue = ( ( FormulaRecordAggregate ) cval ) . getFormulaRecord ( ) . getValue ( ) ; stringValue = ( ( FormulaRecordAggregate ) cval ) . getStringValue ( ) ; break ; case CELL_TYPE_BOOLEAN : booleanValue = ( ( BoolErrRecord ) cval ) . getBooleanValue ( ) ; break ; case CELL_TYPE_ERROR : errorValue = ( ( BoolErrRecord ) cval ) . getErrorValue ( ) ; break ; } ExtendedFormatRecord xf = book . getExFormatAt ( cval . getXFIndex ( ) ) ; setCellStyle ( new HSSFCellStyle ( ( short ) cval . getXFIndex ( ) , xf ) ) ; } private HSSFCell ( ) { } private int determineType ( CellValueRecordInterface cval ) { Record record = ( Record ) cval ; int sid = record . getSid ( ) ; int retval = 0 ; switch ( sid ) { case NumberRecord . sid : retval = HSSFCell . CELL_TYPE_NUMERIC ; break ; case BlankRecord . sid : retval = HSSFCell . CELL_TYPE_BLANK ; break ; case LabelSSTRecord . sid : retval = HSSFCell . CELL_TYPE_STRING ; break ; case FormulaRecordAggregate . sid : retval = HSSFCell . CELL_TYPE_FORMULA ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; retval = ( boolErrRecord . isBoolean ( ) ) ? HSSFCell . CELL_TYPE_BOOLEAN : HSSFCell . CELL_TYPE_ERROR ; break ; } return retval ; } public void setCellNum ( short num ) { cellNum = num ; record . setColumn ( num ) ; } public short getCellNum ( ) { return cellNum ; } public void setCellType ( int cellType ) { setCellType ( cellType , true ) ; } private void setCellType ( int cellType , boolean setValue ) { if ( cellType > CELL_TYPE_ERROR ) { throw new RuntimeException ( "I have no idea what type that is!" ) ; } switch ( cellType ) { case CELL_TYPE_FORMULA : FormulaRecordAggregate frec = null ; if ( cellType != this . cellType ) { frec = new FormulaRecordAggregate ( new FormulaRecord ( ) , null ) ; } else { frec = ( FormulaRecordAggregate ) record ; } frec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { frec . getFormulaRecord ( ) . setValue ( getNumericCellValue ( ) ) ; } frec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; frec . setRow ( row ) ; record = frec ; break ; case CELL_TYPE_NUMERIC : NumberRecord nrec = null ; if ( cellType != this . cellType ) { nrec = new NumberRecord ( ) ; } else { nrec = ( NumberRecord ) record ; } nrec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { nrec . setValue ( getNumericCellValue ( ) ) ; } nrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; nrec . setRow ( row ) ; record = nrec ; break ; case CELL_TYPE_STRING : LabelSSTRecord lrec = null ; if ( cellType != this . cellType ) { lrec = new LabelSSTRecord ( ) ; } else { lrec = ( LabelSSTRecord ) record ; } lrec . setColumn ( getCellNum ( ) ) ; lrec . setRow ( row ) ; lrec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; if ( setValue ) { if ( ( getStringCellValue ( ) != null ) && ( ! getStringCellValue ( ) . equals ( "" ) ) ) { int sst = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { sst = book . addSSTString ( getStringCellValue ( ) ) ; } if ( encoding == ENCODING_UTF_16 ) { sst = book . addSSTString ( getStringCellValue ( ) , true ) ; } lrec . setSSTIndex ( sst ) ; } } record = lrec ; break ; case CELL_TYPE_BLANK : BlankRecord brec = null ; if ( cellType != this . cellType ) { brec = new BlankRecord ( ) ; } else { brec = ( BlankRecord ) record ; } brec . setColumn ( getCellNum ( ) ) ; if ( cellStyle != null ) { brec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; } else { brec . setXFIndex ( ( short ) 0 ) ; } brec . setRow ( row ) ; record = brec ; break ; case CELL_TYPE_BOOLEAN : BoolErrRecord boolRec = null ; if ( cellType != this . cellType ) { boolRec = new BoolErrRecord ( ) ; } else { boolRec = ( BoolErrRecord ) record ; } boolRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { boolRec . setValue ( getBooleanCellValue ( ) ) ; } boolRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; boolRec . setRow ( row ) ; record = boolRec ; break ; case CELL_TYPE_ERROR : BoolErrRecord errRec = null ; if ( cellType != this . cellType ) { errRec = new BoolErrRecord ( ) ; } else { errRec = ( BoolErrRecord ) record ; } errRec . setColumn ( getCellNum ( ) ) ; if ( setValue ) { errRec . setValue ( getErrorCellValue ( ) ) ; } errRec . setXFIndex ( ( short ) cellStyle . getIndex ( ) ) ; errRec . setRow ( row ) ; record = errRec ; break ; } if ( cellType != this . cellType ) { int loc = sheet . getLoc ( ) ; sheet . replaceValueRecord ( record ) ; sheet . setLoc ( loc ) ; } this . cellType = cellType ; } public int getCellType ( ) { return cellType ; } public void setCellValue ( double value ) { if ( ( cellType != CELL_TYPE_NUMERIC ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_NUMERIC , false ) ; } ( ( NumberRecord ) record ) . setValue ( value ) ; cellValue = value ; } public void setCellValue ( Date value ) { setCellValue ( HSSFDateUtil . getExcelDate ( value ) ) ; } public void setCellValue ( Calendar value ) { setCellValue ( value . getTime ( ) ) ; } public void setCellValue ( String value ) { if ( value == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { if ( ( cellType != CELL_TYPE_STRING ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_STRING , false ) ; } int index = 0 ; if ( encoding == ENCODING_COMPRESSED_UNICODE ) { index = book . addSSTString ( value ) ; } if ( encoding == ENCODING_UTF_16 ) { index = book . addSSTString ( value , true ) ; } ( ( LabelSSTRecord ) record ) . setSSTIndex ( index ) ; stringValue = value ; } } public void setCellFormula ( String formula ) { if ( formula == null ) { setCellType ( CELL_TYPE_BLANK , false ) ; } else { setCellType ( CELL_TYPE_FORMULA , false ) ; FormulaRecordAggregate rec = ( FormulaRecordAggregate ) record ; rec . getFormulaRecord ( ) . setOptions ( ( short ) 2 ) ; rec . getFormulaRecord ( ) . setValue ( 0 ) ; if ( rec . getXFIndex ( ) == ( short ) 0 ) rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula + ";" , book ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . getFormulaRecord ( ) . pushExpressionToken ( ptg [ k ] ) ; } rec . getFormulaRecord ( ) . setExpressionLength ( ( short ) size ) ; } } public String getCellFormula ( ) { String retval = FormulaParser . toFormulaString ( book , ( ( FormulaRecordAggregate ) record ) . getFormulaRecord ( ) . getParsedExpression ( ) ) ; return retval ; } public double getNumericCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return 0 ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a numeric value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a numeric value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a numeric value from an error cell" ) ; } return cellValue ; } public Date getDateCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return null ; } if ( cellType == CELL_TYPE_STRING ) { throw new NumberFormatException ( "You cannot get a date value from a String based cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a date value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a date value from an error cell" ) ; } if ( book . isUsing1904DateWindowing ( ) ) { return HSSFDateUtil . getJavaDate ( cellValue , true ) ; } else { return HSSFDateUtil . getJavaDate ( cellValue , false ) ; } } public String getStringCellValue ( ) { if ( cellType == CELL_TYPE_BLANK ) { return "" ; } if ( cellType == CELL_TYPE_NUMERIC ) { throw new NumberFormatException ( "You cannot get a string value from a numeric cell" ) ; } if ( cellType == CELL_TYPE_BOOLEAN ) { throw new NumberFormatException ( "You cannot get a string value from a boolean cell" ) ; } if ( cellType == CELL_TYPE_ERROR ) { throw new NumberFormatException ( "You cannot get a string value from an error cell" ) ; } if ( cellType == CELL_TYPE_FORMULA ) { if ( stringValue == null ) return "" ; } return stringValue ; } public void setCellValue ( boolean value ) { if ( ( cellType != CELL_TYPE_BOOLEAN ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_BOOLEAN , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; booleanValue = value ; } public void setCellErrorValue ( byte value ) { if ( ( cellType != CELL_TYPE_ERROR ) && ( cellType != CELL_TYPE_FORMULA ) ) { setCellType ( CELL_TYPE_ERROR , false ) ; } ( ( BoolErrRecord ) record ) . setValue ( value ) ; errorValue = value ; } public boolean getBooleanCellValue ( ) { if ( cellType == CELL_TYPE_BOOLEAN ) { return booleanValue ; } if ( cellType == CELL_TYPE_BLANK ) { return false ; } throw new NumberFormatException ( "You cannot get a boolean value from a non-boolean cell" ) ; } public byte getErrorCellValue ( ) { if ( cellType == CELL_TYPE_ERROR ) { return errorValue ; } if ( cellType == CELL_TYPE_BLANK ) { return ( byte ) 0 ; } throw new NumberFormatException ( "You cannot get an error value from a non-error cell" ) ; } public void setCellStyle ( HSSFCellStyle style ) { cellStyle = style ; record . setXFIndex ( style . getIndex ( ) ) ; } public HSSFCellStyle getCellStyle ( ) { return cellStyle ; } public short getEncoding ( ) { return encoding ; } public void setEncoding ( short encoding ) { this . encoding = encoding ; } protected CellValueRecordInterface getCellValueRecord ( ) { return record ; } private void checkBounds ( int cellNum ) { if ( cellNum > 255 ) { throw new RuntimeException ( "You cannot have more than 255 columns " + "in a given row (IV).  Because Excel can't handle it" ) ; } else if ( cellNum < 0 ) { throw new RuntimeException ( "You cannot reference columns with an index of less then 0." ) ; } } public void setAsActiveCell ( ) { this . sheet . setActiveCellRow ( this . row ) ; this . sheet . setActiveCellCol ( this . cellNum ) ; } } 	1	['30', '1', '0', '20', '104', '87', '5', '16', '22', '0.748275862', '1151', '0.6', '4', '0', '0.146153846', '0', '0', '36.7', '20', '2.9', '1']
package org . apache . poi . util ; import java . io . UnsupportedEncodingException ; import java . text . NumberFormat ; import java . text . FieldPosition ; public class StringUtil { private final static String ENCODING = "ISO-8859-1" ; private StringUtil ( ) { } public static String getFromUnicodeHigh ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( string [ offset + ( 2 * i ) ] & 0xFF | ( string [ offset + ( 2 * i + 1 ) ] << 8 ) ) ; } return new String ( chars ) ; } public static String getFromUnicodeHigh ( final byte [ ] string ) { return getFromUnicodeHigh ( string , 0 , string . length / 2 ) ; } public static String getFromUnicode ( final byte [ ] string , final int offset , final int len ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( offset < 0 ) || ( offset >= string . length ) ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset" ) ; } if ( ( len < 0 ) || ( ( ( string . length - offset ) / 2 ) < len ) ) { throw new IllegalArgumentException ( "Illegal length" ) ; } char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < chars . length ; i ++ ) { chars [ i ] = ( char ) ( ( string [ offset + ( 2 * i ) ] << 8 ) + string [ offset + ( 2 * i + 1 ) ] ) ; } return new String ( chars ) ; } public static String getFromUnicode ( final byte [ ] string ) { return getFromUnicode ( string , 0 , string . length / 2 ) ; } public static String getFromCompressedUnicode ( final byte [ ] string , final int offset , final int len ) { try { return new String ( string , offset , len , "ISO-8859-1" ) ; } catch ( UnsupportedEncodingException e ) { throw new InternalError ( ) ; } } public static void putCompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { output [ offset + k ] = ( byte ) input . charAt ( k ) ; } } public static void putUncompressedUnicode ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; output [ offset + ( 2 * k ) + 1 ] = ( byte ) ( c > > 8 ) ; } } public static void putUncompressedUnicodeHigh ( final String input , final byte [ ] output , final int offset ) { int strlen = input . length ( ) ; for ( int k = 0 ; k < strlen ; k ++ ) { char c = input . charAt ( k ) ; output [ offset + ( 2 * k ) ] = ( byte ) ( c > > 8 ) ; output [ offset + ( 2 * k ) ] = ( byte ) c ; } } public static String format ( String message , Object [ ] params ) { int currentParamNumber = 0 ; StringBuffer formattedMessage = new StringBuffer ( ) ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '%' ) { if ( currentParamNumber >= params . length ) { formattedMessage . append ( "?missing data?" ) ; } else if ( ( params [ currentParamNumber ] instanceof Number ) && ( i + 1 < message . length ( ) ) ) { i += matchOptionalFormatting ( ( Number ) params [ currentParamNumber ++ ] , message . substring ( i + 1 ) , formattedMessage ) ; } else { formattedMessage . append ( params [ currentParamNumber ++ ] . toString ( ) ) ; } } else { if ( ( message . charAt ( i ) == '\\' ) && ( i + 1 < message . length ( ) ) && ( message . charAt ( i + 1 ) == '%' ) ) { formattedMessage . append ( '%' ) ; i ++ ; } else { formattedMessage . append ( message . charAt ( i ) ) ; } } } return formattedMessage . toString ( ) ; } private static int matchOptionalFormatting ( Number number , String formatting , StringBuffer outputTo ) { NumberFormat numberFormat = NumberFormat . getInstance ( ) ; if ( ( 0 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 0 ) ) ) { numberFormat . setMinimumIntegerDigits ( Integer . parseInt ( formatting . charAt ( 0 ) + "" ) ) ; if ( ( 2 < formatting . length ( ) ) && ( formatting . charAt ( 1 ) == '.' ) && Character . isDigit ( formatting . charAt ( 2 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 2 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 3 ; } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } else if ( ( 0 < formatting . length ( ) ) && ( formatting . charAt ( 0 ) == '.' ) ) { if ( ( 1 < formatting . length ( ) ) && Character . isDigit ( formatting . charAt ( 1 ) ) ) { numberFormat . setMaximumFractionDigits ( Integer . parseInt ( formatting . charAt ( 1 ) + "" ) ) ; numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 2 ; } } numberFormat . format ( number , outputTo , new FieldPosition ( 0 ) ) ; return 1 ; } public static String getPreferredEncoding ( ) { return ENCODING ; } } 	1	['12', '1', '0', '14', '37', '66', '14', '0', '10', '1.090909091', '494', '1', '0', '0', '0.273809524', '0', '0', '40.08333333', '10', '2.5833', '1']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . BitField ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . model . Workbook ; public class AreaPtg extends Ptg { public final static short sid = 0x25 ; private final static int SIZE = 9 ; private short field_1_first_row ; private short field_2_last_row ; private short field_3_first_column ; private short field_4_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; private BitField column = new BitField ( 0x3FFF ) ; private AreaPtg ( ) { } public AreaPtg ( String arearef ) { AreaReference ar = new AreaReference ( arearef ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public AreaPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_first_row = LittleEndian . getShort ( data , 0 + offset ) ; field_2_last_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_first_column = LittleEndian . getShort ( data , 4 + offset ) ; field_4_last_column = LittleEndian . getShort ( data , 6 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRowRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , offset + 1 , field_1_first_row ) ; LittleEndian . putShort ( array , offset + 3 , field_2_last_row ) ; LittleEndian . putShort ( array , offset + 5 , field_3_first_column ) ; LittleEndian . putShort ( array , offset + 7 , field_4_last_column ) ; } public int getSize ( ) { return SIZE ; } public short getFirstRow ( ) { return field_1_first_row ; } public void setFirstRow ( short row ) { field_1_first_row = row ; } public short getLastRow ( ) { return field_2_last_row ; } public void setLastRow ( short row ) { field_2_last_row = row ; } public short getFirstColumn ( ) { return column . getShortValue ( field_3_first_column ) ; } public short getFirstColumnRaw ( ) { return field_3_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_3_first_column ) ; } public void setFirstRowRelative ( boolean rel ) { field_3_first_column = rowRelative . setShortBoolean ( field_3_first_column , rel ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_3_first_column ) ; } public void setFirstColRelative ( boolean rel ) { field_3_first_column = colRelative . setShortBoolean ( field_3_first_column , rel ) ; } public void setFirstColumn ( short column ) { field_3_first_column = column ; } public void setFirstColumnRaw ( short column ) { field_3_first_column = column ; } public short getLastColumn ( ) { return column . getShortValue ( field_4_last_column ) ; } public short getLastColumnRaw ( ) { return field_4_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_4_last_column ) ; } public void setLastRowRelative ( boolean rel ) { field_4_last_column = rowRelative . setShortBoolean ( field_4_last_column , rel ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_4_last_column ) ; } public void setLastColRelative ( boolean rel ) { field_4_last_column = colRelative . setShortBoolean ( field_4_last_column , rel ) ; } public void setLastColumn ( short column ) { field_4_last_column = column ; } public void setLastColumnRaw ( short column ) { field_4_last_column = column ; } public String toFormulaString ( Workbook book ) { return ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) + ":" + ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { AreaPtg ptg = new AreaPtg ( ) ; ptg . field_1_first_row = field_1_first_row ; ptg . field_2_last_row = field_2_last_row ; ptg . field_3_first_column = field_3_first_column ; ptg . field_4_last_column = field_4_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } } 	1	['29', '2', '0', '7', '53', '100', '2', '6', '28', '0.75', '556', '0.888888889', '3', '0.212121212', '0.221674877', '1', '2', '17.86206897', '5', '1.0345', '1']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . BinaryTree ; import org . apache . poi . hssf . model . Workbook ; public abstract class AbstractFunctionPtg extends OperationPtg { public static final String ATTR_NAME = "specialflag" ; public static final short INDEX_EXTERNAL = 255 ; private static BinaryTree map = produceHash ( ) ; protected static Object [ ] [ ] functionData = produceFunctionData ( ) ; protected byte returnClass ; protected byte [ ] paramClass ; protected byte field_1_num_args ; protected short field_2_fnc_index ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<FunctionPtg>" ) . append ( "\n" ) . append ( "   field_1_num_args=" ) . append ( field_1_num_args ) . append ( "\n" ) . append ( "      name         =" ) . append ( lookupName ( field_2_fnc_index ) ) . append ( "\n" ) . append ( "   field_2_fnc_index=" ) . append ( field_2_fnc_index ) . append ( "\n" ) . append ( "</FunctionPtg>" ) ; return buffer . toString ( ) ; } public int getType ( ) { return - 1 ; } public short getFunctionIndex ( ) { return field_2_fnc_index ; } public String getName ( ) { return lookupName ( field_2_fnc_index ) ; } public String toFormulaString ( Workbook book ) { return getName ( ) ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buf = new StringBuffer ( ) ; if ( field_2_fnc_index != 1 ) { buf . append ( getName ( ) ) ; buf . append ( '(' ) ; } if ( operands . length > 0 ) { for ( int i = 0 ; i < operands . length ; i ++ ) { buf . append ( operands [ i ] ) ; buf . append ( ',' ) ; } buf . deleteCharAt ( buf . length ( ) - 1 ) ; } if ( field_2_fnc_index != 1 ) { buf . append ( ")" ) ; } return buf . toString ( ) ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract int getSize ( ) ; protected String lookupName ( short index ) { return ( ( String ) map . get ( new Integer ( index ) ) ) ; } protected short lookupIndex ( String name ) { Integer index = ( Integer ) map . getKeyForValue ( name ) ; if ( index != null ) return index . shortValue ( ) ; return INDEX_EXTERNAL ; } private static BinaryTree produceHash ( ) { BinaryTree dmap = new BinaryTree ( ) ; dmap . put ( new Integer ( 0 ) , "COUNT" ) ; dmap . put ( new Integer ( 1 ) , "specialflag" ) ; dmap . put ( new Integer ( 2 ) , "ISNA" ) ; dmap . put ( new Integer ( 3 ) , "ISERROR" ) ; dmap . put ( new Integer ( 4 ) , "SUM" ) ; dmap . put ( new Integer ( 5 ) , "AVERAGE" ) ; dmap . put ( new Integer ( 6 ) , "MIN" ) ; dmap . put ( new Integer ( 7 ) , "MAX" ) ; dmap . put ( new Integer ( 8 ) , "ROW" ) ; dmap . put ( new Integer ( 9 ) , "COLUMN" ) ; dmap . put ( new Integer ( 10 ) , "NA" ) ; dmap . put ( new Integer ( 11 ) , "NPV" ) ; dmap . put ( new Integer ( 12 ) , "STDEV" ) ; dmap . put ( new Integer ( 13 ) , "DOLLAR" ) ; dmap . put ( new Integer ( 14 ) , "FIXED" ) ; dmap . put ( new Integer ( 15 ) , "SIN" ) ; dmap . put ( new Integer ( 16 ) , "COS" ) ; dmap . put ( new Integer ( 17 ) , "TAN" ) ; dmap . put ( new Integer ( 18 ) , "ATAN" ) ; dmap . put ( new Integer ( 19 ) , "PI" ) ; dmap . put ( new Integer ( 20 ) , "SQRT" ) ; dmap . put ( new Integer ( 21 ) , "EXP" ) ; dmap . put ( new Integer ( 22 ) , "LN" ) ; dmap . put ( new Integer ( 23 ) , "LOG10" ) ; dmap . put ( new Integer ( 24 ) , "ABS" ) ; dmap . put ( new Integer ( 25 ) , "INT" ) ; dmap . put ( new Integer ( 26 ) , "SIGN" ) ; dmap . put ( new Integer ( 27 ) , "ROUND" ) ; dmap . put ( new Integer ( 28 ) , "LOOKUP" ) ; dmap . put ( new Integer ( 29 ) , "INDEX" ) ; dmap . put ( new Integer ( 30 ) , "REPT" ) ; dmap . put ( new Integer ( 31 ) , "MID" ) ; dmap . put ( new Integer ( 32 ) , "LEN" ) ; dmap . put ( new Integer ( 33 ) , "VALUE" ) ; dmap . put ( new Integer ( 34 ) , "TRUE" ) ; dmap . put ( new Integer ( 35 ) , "FALSE" ) ; dmap . put ( new Integer ( 36 ) , "AND" ) ; dmap . put ( new Integer ( 37 ) , "OR" ) ; dmap . put ( new Integer ( 38 ) , "NOT" ) ; dmap . put ( new Integer ( 39 ) , "MOD" ) ; dmap . put ( new Integer ( 40 ) , "DCOUNT" ) ; dmap . put ( new Integer ( 41 ) , "DSUM" ) ; dmap . put ( new Integer ( 42 ) , "DAVERAGE" ) ; dmap . put ( new Integer ( 43 ) , "DMIN" ) ; dmap . put ( new Integer ( 44 ) , "DMAX" ) ; dmap . put ( new Integer ( 45 ) , "DSTDEV" ) ; dmap . put ( new Integer ( 46 ) , "VAR" ) ; dmap . put ( new Integer ( 47 ) , "DVAR" ) ; dmap . put ( new Integer ( 48 ) , "TEXT" ) ; dmap . put ( new Integer ( 49 ) , "LINEST" ) ; dmap . put ( new Integer ( 50 ) , "TREND" ) ; dmap . put ( new Integer ( 51 ) , "LOGEST" ) ; dmap . put ( new Integer ( 52 ) , "GROWTH" ) ; dmap . put ( new Integer ( 53 ) , "GOTO" ) ; dmap . put ( new Integer ( 54 ) , "HALT" ) ; dmap . put ( new Integer ( 56 ) , "PV" ) ; dmap . put ( new Integer ( 57 ) , "FV" ) ; dmap . put ( new Integer ( 58 ) , "NPER" ) ; dmap . put ( new Integer ( 59 ) , "PMT" ) ; dmap . put ( new Integer ( 60 ) , "RATE" ) ; dmap . put ( new Integer ( 61 ) , "MIRR" ) ; dmap . put ( new Integer ( 62 ) , "IRR" ) ; dmap . put ( new Integer ( 63 ) , "RAND" ) ; dmap . put ( new Integer ( 64 ) , "MATCH" ) ; dmap . put ( new Integer ( 65 ) , "DATE" ) ; dmap . put ( new Integer ( 66 ) , "TIME" ) ; dmap . put ( new Integer ( 67 ) , "DAY" ) ; dmap . put ( new Integer ( 68 ) , "MONTH" ) ; dmap . put ( new Integer ( 69 ) , "YEAR" ) ; dmap . put ( new Integer ( 70 ) , "WEEKDAY" ) ; dmap . put ( new Integer ( 71 ) , "HOUR" ) ; dmap . put ( new Integer ( 72 ) , "MINUTE" ) ; dmap . put ( new Integer ( 73 ) , "SECOND" ) ; dmap . put ( new Integer ( 74 ) , "NOW" ) ; dmap . put ( new Integer ( 75 ) , "AREAS" ) ; dmap . put ( new Integer ( 76 ) , "ROWS" ) ; dmap . put ( new Integer ( 77 ) , "COLUMNS" ) ; dmap . put ( new Integer ( 78 ) , "OFFSET" ) ; dmap . put ( new Integer ( 79 ) , "ABSREF" ) ; dmap . put ( new Integer ( 80 ) , "RELREF" ) ; dmap . put ( new Integer ( 81 ) , "ARGUMENT" ) ; dmap . put ( new Integer ( 82 ) , "SEARCH" ) ; dmap . put ( new Integer ( 83 ) , "TRANSPOSE" ) ; dmap . put ( new Integer ( 84 ) , "ERROR" ) ; dmap . put ( new Integer ( 85 ) , "STEP" ) ; dmap . put ( new Integer ( 86 ) , "TYPE" ) ; dmap . put ( new Integer ( 87 ) , "ECHO" ) ; dmap . put ( new Integer ( 88 ) , "SETNAME" ) ; dmap . put ( new Integer ( 89 ) , "CALLER" ) ; dmap . put ( new Integer ( 90 ) , "DEREF" ) ; dmap . put ( new Integer ( 91 ) , "WINDOWS" ) ; dmap . put ( new Integer ( 92 ) , "SERIES" ) ; dmap . put ( new Integer ( 93 ) , "DOCUMENTS" ) ; dmap . put ( new Integer ( 94 ) , "ACTIVECELL" ) ; dmap . put ( new Integer ( 95 ) , "SELECTION" ) ; dmap . put ( new Integer ( 96 ) , "RESULT" ) ; dmap . put ( new Integer ( 97 ) , "ATAN2" ) ; dmap . put ( new Integer ( 98 ) , "ASIN" ) ; dmap . put ( new Integer ( 99 ) , "ACOS" ) ; dmap . put ( new Integer ( 100 ) , "CHOOSE" ) ; dmap . put ( new Integer ( 101 ) , "HLOOKUP" ) ; dmap . put ( new Integer ( 102 ) , "VLOOKUP" ) ; dmap . put ( new Integer ( 103 ) , "LINKS" ) ; dmap . put ( new Integer ( 104 ) , "INPUT" ) ; dmap . put ( new Integer ( 105 ) , "ISREF" ) ; dmap . put ( new Integer ( 106 ) , "GETFORMULA" ) ; dmap . put ( new Integer ( 107 ) , "GETNAME" ) ; dmap . put ( new Integer ( 108 ) , "SETVALUE" ) ; dmap . put ( new Integer ( 109 ) , "LOG" ) ; dmap . put ( new Integer ( 110 ) , "EXEC" ) ; dmap . put ( new Integer ( 111 ) , "CHAR" ) ; dmap . put ( new Integer ( 112 ) , "LOWER" ) ; dmap . put ( new Integer ( 113 ) , "UPPER" ) ; dmap . put ( new Integer ( 114 ) , "PROPER" ) ; dmap . put ( new Integer ( 115 ) , "LEFT" ) ; dmap . put ( new Integer ( 116 ) , "RIGHT" ) ; dmap . put ( new Integer ( 117 ) , "EXACT" ) ; dmap . put ( new Integer ( 118 ) , "TRIM" ) ; dmap . put ( new Integer ( 119 ) , "REPLACE" ) ; dmap . put ( new Integer ( 120 ) , "SUBSTITUTE" ) ; dmap . put ( new Integer ( 121 ) , "CODE" ) ; dmap . put ( new Integer ( 122 ) , "NAMES" ) ; dmap . put ( new Integer ( 123 ) , "DIRECTORY" ) ; dmap . put ( new Integer ( 124 ) , "FIND" ) ; dmap . put ( new Integer ( 125 ) , "CELL" ) ; dmap . put ( new Integer ( 126 ) , "ISERR" ) ; dmap . put ( new Integer ( 127 ) , "ISTEXT" ) ; dmap . put ( new Integer ( 128 ) , "ISNUMBER" ) ; dmap . put ( new Integer ( 129 ) , "ISBLANK" ) ; dmap . put ( new Integer ( 130 ) , "T" ) ; dmap . put ( new Integer ( 131 ) , "N" ) ; dmap . put ( new Integer ( 132 ) , "FOPEN" ) ; dmap . put ( new Integer ( 133 ) , "FCLOSE" ) ; dmap . put ( new Integer ( 134 ) , "FSIZE" ) ; dmap . put ( new Integer ( 135 ) , "FREADLN" ) ; dmap . put ( new Integer ( 136 ) , "FREAD" ) ; dmap . put ( new Integer ( 137 ) , "FWRITELN" ) ; dmap . put ( new Integer ( 138 ) , "FWRITE" ) ; dmap . put ( new Integer ( 139 ) , "FPOS" ) ; dmap . put ( new Integer ( 140 ) , "DATEVALUE" ) ; dmap . put ( new Integer ( 141 ) , "TIMEVALUE" ) ; dmap . put ( new Integer ( 142 ) , "SLN" ) ; dmap . put ( new Integer ( 143 ) , "SYD" ) ; dmap . put ( new Integer ( 144 ) , "DDB" ) ; dmap . put ( new Integer ( 145 ) , "GETDEF" ) ; dmap . put ( new Integer ( 146 ) , "REFTEXT" ) ; dmap . put ( new Integer ( 147 ) , "TEXTREF" ) ; dmap . put ( new Integer ( 148 ) , "INDIRECT" ) ; dmap . put ( new Integer ( 149 ) , "REGISTER" ) ; dmap . put ( new Integer ( 150 ) , "CALL" ) ; dmap . put ( new Integer ( 151 ) , "ADDBAR" ) ; dmap . put ( new Integer ( 152 ) , "ADDMENU" ) ; dmap . put ( new Integer ( 153 ) , "ADDCOMMAND" ) ; dmap . put ( new Integer ( 154 ) , "ENABLECOMMAND" ) ; dmap . put ( new Integer ( 155 ) , "CHECKCOMMAND" ) ; dmap . put ( new Integer ( 156 ) , "RENAMECOMMAND" ) ; dmap . put ( new Integer ( 157 ) , "SHOWBAR" ) ; dmap . put ( new Integer ( 158 ) , "DELETEMENU" ) ; dmap . put ( new Integer ( 159 ) , "DELETECOMMAND" ) ; dmap . put ( new Integer ( 160 ) , "GETCHARTITEM" ) ; dmap . put ( new Integer ( 161 ) , "DIALOGBOX" ) ; dmap . put ( new Integer ( 162 ) , "CLEAN" ) ; dmap . put ( new Integer ( 163 ) , "MDETERM" ) ; dmap . put ( new Integer ( 164 ) , "MINVERSE" ) ; dmap . put ( new Integer ( 165 ) , "MMULT" ) ; dmap . put ( new Integer ( 166 ) , "FILES" ) ; dmap . put ( new Integer ( 167 ) , "IPMT" ) ; dmap . put ( new Integer ( 168 ) , "PPMT" ) ; dmap . put ( new Integer ( 169 ) , "COUNTA" ) ; dmap . put ( new Integer ( 170 ) , "CANCELKEY" ) ; dmap . put ( new Integer ( 175 ) , "INITIATE" ) ; dmap . put ( new Integer ( 176 ) , "REQUEST" ) ; dmap . put ( new Integer ( 177 ) , "POKE" ) ; dmap . put ( new Integer ( 178 ) , "EXECUTE" ) ; dmap . put ( new Integer ( 179 ) , "TERMINATE" ) ; dmap . put ( new Integer ( 180 ) , "RESTART" ) ; dmap . put ( new Integer ( 181 ) , "HELP" ) ; dmap . put ( new Integer ( 182 ) , "GETBAR" ) ; dmap . put ( new Integer ( 183 ) , "PRODUCT" ) ; dmap . put ( new Integer ( 184 ) , "FACT" ) ; dmap . put ( new Integer ( 185 ) , "GETCELL" ) ; dmap . put ( new Integer ( 186 ) , "GETWORKSPACE" ) ; dmap . put ( new Integer ( 187 ) , "GETWINDOW" ) ; dmap . put ( new Integer ( 188 ) , "GETDOCUMENT" ) ; dmap . put ( new Integer ( 189 ) , "DPRODUCT" ) ; dmap . put ( new Integer ( 190 ) , "ISNONTEXT" ) ; dmap . put ( new Integer ( 191 ) , "GETNOTE" ) ; dmap . put ( new Integer ( 192 ) , "NOTE" ) ; dmap . put ( new Integer ( 193 ) , "STDEVP" ) ; dmap . put ( new Integer ( 194 ) , "VARP" ) ; dmap . put ( new Integer ( 195 ) , "DSTDEVP" ) ; dmap . put ( new Integer ( 196 ) , "DVARP" ) ; dmap . put ( new Integer ( 197 ) , "TRUNC" ) ; dmap . put ( new Integer ( 198 ) , "ISLOGICAL" ) ; dmap . put ( new Integer ( 199 ) , "DCOUNTA" ) ; dmap . put ( new Integer ( 200 ) , "DELETEBAR" ) ; dmap . put ( new Integer ( 201 ) , "UNREGISTER" ) ; dmap . put ( new Integer ( 204 ) , "USDOLLAR" ) ; dmap . put ( new Integer ( 205 ) , "FINDB" ) ; dmap . put ( new Integer ( 206 ) , "SEARCHB" ) ; dmap . put ( new Integer ( 207 ) , "REPLACEB" ) ; dmap . put ( new Integer ( 208 ) , "LEFTB" ) ; dmap . put ( new Integer ( 209 ) , "RIGHTB" ) ; dmap . put ( new Integer ( 210 ) , "MIDB" ) ; dmap . put ( new Integer ( 211 ) , "LENB" ) ; dmap . put ( new Integer ( 212 ) , "ROUNDUP" ) ; dmap . put ( new Integer ( 213 ) , "ROUNDDOWN" ) ; dmap . put ( new Integer ( 214 ) , "ASC" ) ; dmap . put ( new Integer ( 215 ) , "DBCS" ) ; dmap . put ( new Integer ( 216 ) , "RANK" ) ; dmap . put ( new Integer ( 219 ) , "ADDRESS" ) ; dmap . put ( new Integer ( 220 ) , "DAYS360" ) ; dmap . put ( new Integer ( 221 ) , "TODAY" ) ; dmap . put ( new Integer ( 222 ) , "VDB" ) ; dmap . put ( new Integer ( 227 ) , "MEDIAN" ) ; dmap . put ( new Integer ( 228 ) , "SUMPRODUCT" ) ; dmap . put ( new Integer ( 229 ) , "SINH" ) ; dmap . put ( new Integer ( 230 ) , "COSH" ) ; dmap . put ( new Integer ( 231 ) , "TANH" ) ; dmap . put ( new Integer ( 232 ) , "ASINH" ) ; dmap . put ( new Integer ( 233 ) , "ACOSH" ) ; dmap . put ( new Integer ( 234 ) , "ATANH" ) ; dmap . put ( new Integer ( 235 ) , "DGET" ) ; dmap . put ( new Integer ( 236 ) , "CREATEOBJECT" ) ; dmap . put ( new Integer ( 237 ) , "VOLATILE" ) ; dmap . put ( new Integer ( 238 ) , "LASTERROR" ) ; dmap . put ( new Integer ( 239 ) , "CUSTOMUNDO" ) ; dmap . put ( new Integer ( 240 ) , "CUSTOMREPEAT" ) ; dmap . put ( new Integer ( 241 ) , "FORMULACONVERT" ) ; dmap . put ( new Integer ( 242 ) , "GETLINKINFO" ) ; dmap . put ( new Integer ( 243 ) , "TEXTBOX" ) ; dmap . put ( new Integer ( 244 ) , "INFO" ) ; dmap . put ( new Integer ( 245 ) , "GROUP" ) ; dmap . put ( new Integer ( 246 ) , "GETOBJECT" ) ; dmap . put ( new Integer ( 247 ) , "DB" ) ; dmap . put ( new Integer ( 248 ) , "PAUSE" ) ; dmap . put ( new Integer ( 250 ) , "RESUME" ) ; dmap . put ( new Integer ( 252 ) , "FREQUENCY" ) ; dmap . put ( new Integer ( 253 ) , "ADDTOOLBAR" ) ; dmap . put ( new Integer ( 254 ) , "DELETETOOLBAR" ) ; dmap . put ( new Integer ( 255 ) , "externalflag" ) ; dmap . put ( new Integer ( 256 ) , "RESETTOOLBAR" ) ; dmap . put ( new Integer ( 257 ) , "EVALUATE" ) ; dmap . put ( new Integer ( 258 ) , "GETTOOLBAR" ) ; dmap . put ( new Integer ( 259 ) , "GETTOOL" ) ; dmap . put ( new Integer ( 260 ) , "SPELLINGCHECK" ) ; dmap . put ( new Integer ( 261 ) , "ERRORTYPE" ) ; dmap . put ( new Integer ( 262 ) , "APPTITLE" ) ; dmap . put ( new Integer ( 263 ) , "WINDOWTITLE" ) ; dmap . put ( new Integer ( 264 ) , "SAVETOOLBAR" ) ; dmap . put ( new Integer ( 265 ) , "ENABLETOOL" ) ; dmap . put ( new Integer ( 266 ) , "PRESSTOOL" ) ; dmap . put ( new Integer ( 267 ) , "REGISTERID" ) ; dmap . put ( new Integer ( 268 ) , "GETWORKBOOK" ) ; dmap . put ( new Integer ( 269 ) , "AVEDEV" ) ; dmap . put ( new Integer ( 270 ) , "BETADIST" ) ; dmap . put ( new Integer ( 271 ) , "GAMMALN" ) ; dmap . put ( new Integer ( 272 ) , "BETAINV" ) ; dmap . put ( new Integer ( 273 ) , "BINOMDIST" ) ; dmap . put ( new Integer ( 274 ) , "CHIDIST" ) ; dmap . put ( new Integer ( 275 ) , "CHIINV" ) ; dmap . put ( new Integer ( 276 ) , "COMBIN" ) ; dmap . put ( new Integer ( 277 ) , "CONFIDENCE" ) ; dmap . put ( new Integer ( 278 ) , "CRITBINOM" ) ; dmap . put ( new Integer ( 279 ) , "EVEN" ) ; dmap . put ( new Integer ( 280 ) , "EXPONDIST" ) ; dmap . put ( new Integer ( 281 ) , "FDIST" ) ; dmap . put ( new Integer ( 282 ) , "FINV" ) ; dmap . put ( new Integer ( 283 ) , "FISHER" ) ; dmap . put ( new Integer ( 284 ) , "FISHERINV" ) ; dmap . put ( new Integer ( 285 ) , "FLOOR" ) ; dmap . put ( new Integer ( 286 ) , "GAMMADIST" ) ; dmap . put ( new Integer ( 287 ) , "GAMMAINV" ) ; dmap . put ( new Integer ( 288 ) , "CEILING" ) ; dmap . put ( new Integer ( 289 ) , "HYPGEOMDIST" ) ; dmap . put ( new Integer ( 290 ) , "LOGNORMDIST" ) ; dmap . put ( new Integer ( 291 ) , "LOGINV" ) ; dmap . put ( new Integer ( 292 ) , "NEGBINOMDIST" ) ; dmap . put ( new Integer ( 293 ) , "NORMDIST" ) ; dmap . put ( new Integer ( 294 ) , "NORMSDIST" ) ; dmap . put ( new Integer ( 295 ) , "NORMINV" ) ; dmap . put ( new Integer ( 296 ) , "NORMSINV" ) ; dmap . put ( new Integer ( 297 ) , "STANDARDIZE" ) ; dmap . put ( new Integer ( 298 ) , "ODD" ) ; dmap . put ( new Integer ( 299 ) , "PERMUT" ) ; dmap . put ( new Integer ( 300 ) , "POISSON" ) ; dmap . put ( new Integer ( 301 ) , "TDIST" ) ; dmap . put ( new Integer ( 302 ) , "WEIBULL" ) ; dmap . put ( new Integer ( 303 ) , "SUMXMY2" ) ; dmap . put ( new Integer ( 304 ) , "SUMX2MY2" ) ; dmap . put ( new Integer ( 305 ) , "SUMX2PY2" ) ; dmap . put ( new Integer ( 306 ) , "CHITEST" ) ; dmap . put ( new Integer ( 307 ) , "CORREL" ) ; dmap . put ( new Integer ( 308 ) , "COVAR" ) ; dmap . put ( new Integer ( 309 ) , "FORECAST" ) ; dmap . put ( new Integer ( 310 ) , "FTEST" ) ; dmap . put ( new Integer ( 311 ) , "INTERCEPT" ) ; dmap . put ( new Integer ( 312 ) , "PEARSON" ) ; dmap . put ( new Integer ( 313 ) , "RSQ" ) ; dmap . put ( new Integer ( 314 ) , "STEYX" ) ; dmap . put ( new Integer ( 315 ) , "SLOPE" ) ; dmap . put ( new Integer ( 316 ) , "TTEST" ) ; dmap . put ( new Integer ( 317 ) , "PROB" ) ; dmap . put ( new Integer ( 318 ) , "DEVSQ" ) ; dmap . put ( new Integer ( 319 ) , "GEOMEAN" ) ; dmap . put ( new Integer ( 320 ) , "HARMEAN" ) ; dmap . put ( new Integer ( 321 ) , "SUMSQ" ) ; dmap . put ( new Integer ( 322 ) , "KURT" ) ; dmap . put ( new Integer ( 323 ) , "SKEW" ) ; dmap . put ( new Integer ( 324 ) , "ZTEST" ) ; dmap . put ( new Integer ( 325 ) , "LARGE" ) ; dmap . put ( new Integer ( 326 ) , "SMALL" ) ; dmap . put ( new Integer ( 327 ) , "QUARTILE" ) ; dmap . put ( new Integer ( 328 ) , "PERCENTILE" ) ; dmap . put ( new Integer ( 329 ) , "PERCENTRANK" ) ; dmap . put ( new Integer ( 330 ) , "MODE" ) ; dmap . put ( new Integer ( 331 ) , "TRIMMEAN" ) ; dmap . put ( new Integer ( 332 ) , "TINV" ) ; dmap . put ( new Integer ( 334 ) , "MOVIECOMMAND" ) ; dmap . put ( new Integer ( 335 ) , "GETMOVIE" ) ; dmap . put ( new Integer ( 336 ) , "CONCATENATE" ) ; dmap . put ( new Integer ( 337 ) , "POWER" ) ; dmap . put ( new Integer ( 338 ) , "PIVOTADDDATA" ) ; dmap . put ( new Integer ( 339 ) , "GETPIVOTTABLE" ) ; dmap . put ( new Integer ( 340 ) , "GETPIVOTFIELD" ) ; dmap . put ( new Integer ( 341 ) , "GETPIVOTITEM" ) ; dmap . put ( new Integer ( 342 ) , "RADIANS" ) ; dmap . put ( new Integer ( 343 ) , "DEGREES" ) ; dmap . put ( new Integer ( 344 ) , "SUBTOTAL" ) ; dmap . put ( new Integer ( 345 ) , "SUMIF" ) ; dmap . put ( new Integer ( 346 ) , "COUNTIF" ) ; dmap . put ( new Integer ( 347 ) , "COUNTBLANK" ) ; dmap . put ( new Integer ( 348 ) , "SCENARIOGET" ) ; dmap . put ( new Integer ( 349 ) , "OPTIONSLISTSGET" ) ; dmap . put ( new Integer ( 350 ) , "ISPMT" ) ; dmap . put ( new Integer ( 351 ) , "DATEDIF" ) ; dmap . put ( new Integer ( 352 ) , "DATESTRING" ) ; dmap . put ( new Integer ( 353 ) , "NUMBERSTRING" ) ; dmap . put ( new Integer ( 354 ) , "ROMAN" ) ; dmap . put ( new Integer ( 355 ) , "OPENDIALOG" ) ; dmap . put ( new Integer ( 356 ) , "SAVEDIALOG" ) ; dmap . put ( new Integer ( 357 ) , "VIEWGET" ) ; dmap . put ( new Integer ( 358 ) , "GETPIVOTDATA" ) ; dmap . put ( new Integer ( 359 ) , "HYPERLINK" ) ; dmap . put ( new Integer ( 360 ) , "PHONETIC" ) ; dmap . put ( new Integer ( 361 ) , "AVERAGEA" ) ; dmap . put ( new Integer ( 362 ) , "MAXA" ) ; dmap . put ( new Integer ( 363 ) , "MINA" ) ; dmap . put ( new Integer ( 364 ) , "STDEVPA" ) ; dmap . put ( new Integer ( 365 ) , "VARPA" ) ; dmap . put ( new Integer ( 366 ) , "STDEVA" ) ; dmap . put ( new Integer ( 367 ) , "VARA" ) ; return dmap ; } private static Object [ ] [ ] produceFunctionData ( ) { Object [ ] [ ] functionData = new Object [ 368 ] [ 3 ] ; functionData [ 0 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 0 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 0 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 2 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 2 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 2 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 3 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 3 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 3 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 4 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 4 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 4 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 5 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 5 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 5 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 6 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 6 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 6 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 7 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 7 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 7 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 8 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 8 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 8 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 9 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 9 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 9 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 10 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 10 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 10 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 11 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 11 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 11 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 12 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 12 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 12 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 13 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 13 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 13 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 14 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 14 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 14 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 15 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 15 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 15 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 16 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 16 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 16 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 17 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 17 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 17 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 18 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 18 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 18 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 19 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 19 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 19 ] [ 2 ] = new Integer ( 0 ) ; functionData [ 20 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 20 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 20 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 21 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 21 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 21 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 22 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 22 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 22 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 23 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 23 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 23 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 24 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 24 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 24 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 25 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 25 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 25 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 26 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 26 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 26 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 27 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 27 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 27 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 28 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 28 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 28 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 29 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 29 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 29 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 30 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 30 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 30 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 31 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 31 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 31 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 32 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 32 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 32 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 33 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 33 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 33 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 34 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 34 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 34 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 35 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 35 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 35 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 36 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 36 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 36 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 37 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 37 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 37 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 38 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 38 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 38 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 39 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 39 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 39 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 40 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 40 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 40 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 41 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 41 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 41 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 42 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 42 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 42 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 43 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 43 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 43 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 44 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 44 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 44 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 45 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 45 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 45 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 46 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 46 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 46 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 47 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 47 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 47 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 48 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 48 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 48 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 49 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 49 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 49 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 50 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 50 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 50 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 51 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 51 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 51 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 52 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 52 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 52 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 56 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 56 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 56 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 57 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 57 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 57 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 58 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 58 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 58 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 59 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 59 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 59 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 60 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 60 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 60 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 61 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 61 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 61 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 62 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 62 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 62 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 63 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 63 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 63 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 64 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 64 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 64 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 65 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 65 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 65 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 66 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 66 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 66 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 67 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 67 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 67 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 68 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 68 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 68 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 69 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 69 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 69 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 70 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 70 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 70 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 71 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 71 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 71 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 72 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 72 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 72 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 73 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 73 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 73 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 74 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 74 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 74 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 75 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 75 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 75 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 76 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 76 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 76 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 77 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 77 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 77 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 78 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 78 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 78 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 82 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 82 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 82 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 83 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 83 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 83 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 86 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 86 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 86 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 97 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 97 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 97 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 98 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 98 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 98 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 99 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 99 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 99 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 101 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 101 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 101 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 102 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 102 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 102 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 105 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 105 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 105 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 109 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 109 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 109 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 111 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 111 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 111 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 112 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 112 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 112 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 113 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 113 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 113 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 114 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 114 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 114 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 115 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 115 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 115 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 116 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 116 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 116 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 117 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 117 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 117 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 118 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 118 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 118 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 119 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 119 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 119 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 120 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 120 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 120 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 121 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 121 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 121 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 124 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 124 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 124 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 125 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 125 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 125 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 126 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 126 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 126 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 127 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 127 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 127 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 128 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 128 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 128 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 129 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 129 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 129 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 130 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 130 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 130 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 131 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 131 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 131 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 140 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 140 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 140 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 141 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 141 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 141 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 142 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 142 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 142 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 148 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 148 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 148 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 150 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 150 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 150 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 162 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 162 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 162 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 163 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 163 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 163 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 164 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 164 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 164 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 165 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 165 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 165 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 166 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 166 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 166 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 167 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 167 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 167 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 168 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 168 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 168 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 183 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 183 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 183 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 184 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 184 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 184 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 189 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 189 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 189 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 190 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 190 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 190 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 193 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 193 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 193 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 194 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 194 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 194 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 195 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 195 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 195 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 196 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 196 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 196 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 197 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 197 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 197 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 198 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 198 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 198 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 199 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 199 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 199 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 204 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 204 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 204 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 205 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 205 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 205 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 206 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 206 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 206 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 207 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 207 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 207 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 208 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 208 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 208 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 209 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 209 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 209 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 210 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 210 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 210 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 211 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 211 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 211 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 212 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 212 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 212 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 213 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 213 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 213 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 214 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 214 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 214 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 221 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 221 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 221 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 222 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 222 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 222 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 227 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 227 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 227 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 228 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 228 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 228 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 229 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 229 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 229 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 230 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 230 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 230 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 231 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 231 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 231 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 232 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 232 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 232 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 233 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 233 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 233 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 234 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 234 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 234 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 235 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 235 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 235 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 244 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 244 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 244 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 252 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 252 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 252 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 269 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 269 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 269 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 270 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 270 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 270 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 271 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 271 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 271 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 272 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 272 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 272 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 273 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 273 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 273 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 274 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 274 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 274 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 275 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 275 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 275 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 276 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 276 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 276 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 277 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 277 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 277 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 278 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 278 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 278 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 279 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 279 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 279 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 280 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 280 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 280 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 281 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 281 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 281 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 282 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 282 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 282 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 283 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 283 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 283 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 284 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 284 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 284 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 285 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 285 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 285 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 286 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 286 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 286 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 287 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 287 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 287 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 288 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 288 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 288 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 289 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 289 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 289 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 290 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 290 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 290 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 291 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 291 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 291 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 292 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 292 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 292 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 293 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 293 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 293 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 294 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 294 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 294 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 295 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 295 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 295 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 296 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 296 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 296 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 297 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 297 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 297 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 298 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 298 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 298 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 299 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 299 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 299 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 300 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 300 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 300 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 301 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 301 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 301 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 302 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 302 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 302 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 303 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 303 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 303 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 304 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 304 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 304 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 305 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 305 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 305 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 306 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 306 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 306 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 307 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 307 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 307 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 308 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 308 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 308 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 309 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 309 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 309 ] [ 2 ] = new Integer ( 3 ) ; functionData [ 310 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 310 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 310 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 311 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 311 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 311 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 312 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 312 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 312 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 313 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 313 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 313 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 314 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 314 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 314 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 315 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 315 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 315 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 316 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 316 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 316 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 317 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 317 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 317 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 318 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 318 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 318 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 319 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 319 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 319 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 320 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 320 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 320 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 321 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 321 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 321 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 322 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 322 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 322 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 323 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 323 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 323 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 324 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 324 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 324 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 325 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 325 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 325 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 326 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 326 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 326 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 327 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 327 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 327 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 328 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 328 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 328 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 329 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 329 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 329 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 330 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 330 ] [ 1 ] = new byte [ ] { Ptg . CLASS_ARRAY } ; functionData [ 330 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 331 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 331 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 331 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 332 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 332 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 332 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 336 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 336 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 336 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 337 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 337 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 337 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 342 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 342 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 342 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 343 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 343 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 343 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 344 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 344 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 344 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 345 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 345 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 345 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 346 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 346 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 346 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 347 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 347 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 347 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 350 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 350 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 350 ] [ 2 ] = new Integer ( 4 ) ; functionData [ 352 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 352 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 352 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 354 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 354 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 354 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 358 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 358 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 358 ] [ 2 ] = new Integer ( 2 ) ; functionData [ 359 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 359 ] [ 1 ] = new byte [ ] { Ptg . CLASS_VALUE } ; functionData [ 359 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 360 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 360 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 360 ] [ 2 ] = new Integer ( 1 ) ; functionData [ 361 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 361 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 361 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 362 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 362 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 362 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 363 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 363 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 363 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 364 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 364 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 364 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 365 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 365 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 365 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 366 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 366 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 366 ] [ 2 ] = new Integer ( - 1 ) ; functionData [ 367 ] [ 0 ] = new Byte ( Ptg . CLASS_VALUE ) ; functionData [ 367 ] [ 1 ] = new byte [ ] { Ptg . CLASS_REF } ; functionData [ 367 ] [ 2 ] = new Integer ( - 1 ) ; return functionData ; } public byte getDefaultOperandClass ( ) { return returnClass ; } public byte getParameterClass ( int index ) { try { return paramClass [ index ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { return paramClass [ paramClass . length - 1 ] ; } } } 	1	['16', '2', '2', '6', '31', '102', '3', '3', '11', '0.933333333', '9849', '0.75', '1', '0.176470588', '0.19047619', '0', '0', '614.0625', '5', '1.1875', '1']
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	1	['26', '1', '3', '9', '42', '325', '8', '1', '22', '1.04', '693', '0', '0', '0', '0.544871795', '0', '0', '25.46153846', '10', '1.9615', '1']
package org . apache . poi . hpsf ; import java . io . * ; public class PropertySetFactory { public static PropertySet create ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , UnexpectedPropertySetTypeException , IOException { final PropertySet ps = new PropertySet ( stream ) ; if ( ps . isSummaryInformation ( ) ) return new SummaryInformation ( ps ) ; else if ( ps . isDocumentSummaryInformation ( ) ) return new DocumentSummaryInformation ( ps ) ; else return ps ; } } 	1	['2', '1', '0', '6', '8', '1', '0', '6', '2', '2', '28', '0', '0', '0', '0.5', '0', '0', '13', '1', '0.5', '1']
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableWriter implements BlockWritable , BATManaged { private BlockAllocationTableWriter _sbat ; private List _small_blocks ; private int _big_block_count ; private RootProperty _root ; public SmallBlockTableWriter ( final List documents , final RootProperty root ) { _sbat = new BlockAllocationTableWriter ( ) ; _small_blocks = new ArrayList ( ) ; _root = root ; Iterator iter = documents . iterator ( ) ; while ( iter . hasNext ( ) ) { POIFSDocument doc = ( POIFSDocument ) iter . next ( ) ; BlockWritable [ ] blocks = doc . getSmallBlocks ( ) ; if ( blocks . length != 0 ) { doc . setStartBlock ( _sbat . allocateSpace ( blocks . length ) ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { _small_blocks . add ( blocks [ j ] ) ; } } } _sbat . simpleCreateBlocks ( ) ; _root . setSize ( _small_blocks . size ( ) ) ; _big_block_count = SmallDocumentBlock . fill ( _small_blocks ) ; } public int getSBATBlockCount ( ) { return ( _big_block_count + 15 ) / 16 ; } public BlockAllocationTableWriter getSBAT ( ) { return _sbat ; } public int countBlocks ( ) { return _big_block_count ; } public void setStartBlock ( int start_block ) { _root . setStartBlock ( start_block ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { Iterator iter = _small_blocks . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( BlockWritable ) iter . next ( ) ) . writeBlocks ( stream ) ; } } } 	1	['6', '1', '0', '7', '22', '3', '1', '6', '6', '0.75', '111', '1', '2', '0', '0.333333333', '0', '0', '16.83333333', '1', '0.8333', '1']
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class GreaterThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x0D ; private final static String GREATERTHAN = ">" ; public GreaterThanPtg ( ) { } public GreaterThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . GREATERTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . GREATERTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new GreaterThanPtg ( ) ; } } 	1	['10', '2', '0', '4', '14', '45', '2', '2', '10', '1.111111111', '67', '0.333333333', '0', '0.272727273', '0.32', '0', '0', '5.4', '1', '0.8', '1']
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hpsf . wellknown . * ; public class Section { protected Map dictionary ; protected ClassID formatID ; public ClassID getFormatID ( ) { return formatID ; } protected long offset ; public long getOffset ( ) { return offset ; } protected int size ; public int getSize ( ) { return size ; } protected int propertyCount ; public int getPropertyCount ( ) { return propertyCount ; } protected Property [ ] properties ; public Property [ ] getProperties ( ) { return properties ; } protected Section ( ) { } public Section ( final byte [ ] src , int offset ) { formatID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; this . offset = LittleEndian . getUInt ( src , offset ) ; offset = ( int ) this . offset ; size = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; propertyCount = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; properties = new Property [ propertyCount ] ; Property propertyOne ; int codepage = - 1 ; int pass1Offset = offset ; for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , pass1Offset ) ; pass1Offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , pass1Offset + LittleEndian . INT_SIZE ) - sOffset ; if ( id == PropertyIDMap . PID_CODEPAGE ) { int o = ( int ) ( this . offset + sOffset ) ; final long type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; if ( type != Variant . VT_I2 ) throw new HPSFRuntimeException ( "Value type of property ID 1 is not VT_I2 but " + type + "." ) ; codepage = LittleEndian . getUShort ( src , o ) ; } } for ( int i = 0 ; i < properties . length ; i ++ ) { final int id = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final int sOffset = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; int length ; if ( i == properties . length - 1 ) length = ( int ) ( src . length - this . offset - sOffset ) ; else length = ( int ) LittleEndian . getUInt ( src , offset + LittleEndian . INT_SIZE ) - sOffset ; properties [ i ] = new Property ( id , src , this . offset + sOffset , length , codepage ) ; } dictionary = ( Map ) getProperty ( 0 ) ; } public Object getProperty ( final int id ) { wasNull = false ; for ( int i = 0 ; i < properties . length ; i ++ ) if ( id == properties [ i ] . getID ( ) ) return properties [ i ] . getValue ( ) ; wasNull = true ; return null ; } protected int getPropertyIntValue ( final int id ) { final Long i = ( Long ) getProperty ( id ) ; if ( i != null ) return i . intValue ( ) ; else return 0 ; } protected boolean getPropertyBooleanValue ( final int id ) { final Boolean b = ( Boolean ) getProperty ( id ) ; if ( b != null ) return b . booleanValue ( ) ; else return false ; } private boolean wasNull ; public boolean wasNull ( ) { return wasNull ; } public String getPIDString ( final int pid ) { String s = null ; if ( dictionary != null ) s = ( String ) dictionary . get ( new Integer ( pid ) ) ; if ( s == null ) s = SectionIDMap . getPIDString ( getFormatID ( ) . getBytes ( ) , pid ) ; if ( s == null ) s = SectionIDMap . UNDEFINED ; return s ; } } 	1	['12', '1', '0', '7', '30', '48', '2', '5', '9', '0.818181818', '322', '1', '2', '0', '0.5', '0', '0', '25.25', '4', '1.4167', '1']
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . usermodel . * ; public class EFHSSF { String infile ; String outfile ; HSSFWorkbook workbook = null ; HSSFSheet cursheet = null ; public EFHSSF ( ) { } public void setInputFile ( String infile ) { this . infile = infile ; } public void setOutputFile ( String outfile ) { this . outfile = outfile ; } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( infile ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new EFHSSFListener ( this ) ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; fin . close ( ) ; din . close ( ) ; FileOutputStream fout = new FileOutputStream ( outfile ) ; workbook . write ( fout ) ; fout . close ( ) ; System . out . println ( "done." ) ; } public void recordHandler ( Record record ) { HSSFRow row = null ; HSSFCell cell = null ; int sheetnum = - 1 ; switch ( record . getSid ( ) ) { case BOFRecord . sid : BOFRecord bof = ( BOFRecord ) record ; if ( bof . getType ( ) == bof . TYPE_WORKBOOK ) { workbook = new HSSFWorkbook ( ) ; } else if ( bof . getType ( ) == bof . TYPE_WORKSHEET ) { sheetnum ++ ; cursheet = workbook . getSheetAt ( sheetnum ) ; } break ; case BoundSheetRecord . sid : BoundSheetRecord bsr = ( BoundSheetRecord ) record ; workbook . createSheet ( bsr . getSheetname ( ) ) ; break ; case RowRecord . sid : RowRecord rowrec = ( RowRecord ) record ; cursheet . createRow ( rowrec . getRowNumber ( ) ) ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; row = cursheet . getRow ( numrec . getRow ( ) ) ; cell = row . createCell ( numrec . getColumn ( ) , HSSFCell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( numrec . getValue ( ) ) ; break ; case SSTRecord . sid : SSTRecord sstrec = ( SSTRecord ) record ; for ( int k = 0 ; k < sstrec . getNumUniqueStrings ( ) ; k ++ ) { workbook . addSSTString ( sstrec . getString ( k ) ) ; } break ; case LabelSSTRecord . sid : LabelSSTRecord lrec = ( LabelSSTRecord ) record ; row = cursheet . getRow ( lrec . getRow ( ) ) ; cell = row . createCell ( lrec . getColumn ( ) , HSSFCell . CELL_TYPE_STRING ) ; cell . setCellValue ( workbook . getSSTString ( lrec . getSSTIndex ( ) ) ) ; break ; } } public static void main ( String [ ] args ) { if ( ( args . length < 2 ) || ! args [ 0 ] . equals ( "--help" ) ) { try { EFHSSF viewer = new EFHSSF ( ) ; viewer . setInputFile ( args [ 0 ] ) ; viewer . setOutputFile ( args [ 1 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFHSSF" ) ; System . out . println ( "General testbed for HSSFEventFactory based testing and " + "Code examples" ) ; System . out . println ( "Usage: java org.apache.poi.hssf.dev.EFHSSF " + "file1 file2" ) ; System . out . println ( "   --will rewrite the file reading with the event api" ) ; System . out . println ( "and writing with the standard API" ) ; } } } class EFHSSFListener implements HSSFListener { EFHSSF efhssf ; public EFHSSFListener ( EFHSSF efhssf ) { this . efhssf = efhssf ; } public void processRecord ( Record record ) { efhssf . recordHandler ( record ) ; } } 	1	['6', '1', '0', '17', '45', '5', '1', '17', '6', '0.55', '247', '0', '2', '0', '0.375', '0', '0', '39.5', '10', '2.6667', '1']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class BOFRecord extends Record { public final static short sid = 0x809 ; private short field_1_version ; private short field_2_type ; private short field_3_build ; private short field_4_year ; private int field_5_history ; private int field_6_rversion ; public final static short VERSION = 0x06 ; public final static short BUILD = 0x10d3 ; public final static short BUILD_YEAR = 0x07CC ; public final static short HISTORY_MASK = 0x41 ; public final static short TYPE_WORKBOOK = 0x05 ; public final static short TYPE_VB_MODULE = 0x06 ; public final static short TYPE_WORKSHEET = 0x10 ; public final static short TYPE_CHART = 0x20 ; public final static short TYPE_EXCEL_4_MACRO = 0x40 ; public final static short TYPE_WORKSPACE_FILE = 0x100 ; public BOFRecord ( ) { } public BOFRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public BOFRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A BOF RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_version = LittleEndian . getShort ( data , 0 + offset ) ; field_2_type = LittleEndian . getShort ( data , 2 + offset ) ; field_3_build = LittleEndian . getShort ( data , 4 + offset ) ; field_4_year = LittleEndian . getShort ( data , 6 + offset ) ; field_5_history = LittleEndian . getInt ( data , 8 + offset ) ; field_6_rversion = LittleEndian . getInt ( data , 12 + offset ) ; } public void setVersion ( short version ) { field_1_version = version ; } public void setType ( short type ) { field_2_type = type ; } public void setBuild ( short build ) { field_3_build = build ; } public void setBuildYear ( short year ) { field_4_year = year ; } public void setHistoryBitMask ( int bitmask ) { field_5_history = bitmask ; } public void setRequiredVersion ( int version ) { field_6_rversion = version ; } public short getVersion ( ) { return field_1_version ; } public short getType ( ) { return field_2_type ; } public short getBuild ( ) { return field_3_build ; } public short getBuildYear ( ) { return field_4_year ; } public int getHistoryBitMask ( ) { return field_5_history ; } public int getRequiredVersion ( ) { return field_6_rversion ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[BOF RECORD]\n" ) ; buffer . append ( "    .version         = " ) . append ( Integer . toHexString ( getVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .type            = " ) . append ( Integer . toHexString ( getType ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .build           = " ) . append ( Integer . toHexString ( getBuild ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .buildyear       = " ) . append ( getBuildYear ( ) ) . append ( "\n" ) ; buffer . append ( "    .history         = " ) . append ( Integer . toHexString ( getHistoryBitMask ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .requiredversion = " ) . append ( Integer . toHexString ( getRequiredVersion ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/BOF RECORD]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x10 ) ) ; LittleEndian . putShort ( data , 4 + offset , getVersion ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getType ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getBuild ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getBuildYear ( ) ) ; LittleEndian . putInt ( data , 12 + offset , getHistoryBitMask ( ) ) ; LittleEndian . putInt ( data , 16 + offset , getRequiredVersion ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 20 ; } public short getSid ( ) { return this . sid ; } public Object clone ( ) { BOFRecord rec = new BOFRecord ( ) ; rec . field_1_version = field_1_version ; rec . field_2_type = field_2_type ; rec . field_3_build = field_3_build ; rec . field_4_year = field_4_year ; rec . field_5_history = field_5_history ; rec . field_6_rversion = field_6_rversion ; return rec ; } } 	1	['22', '2', '0', '8', '35', '169', '5', '3', '20', '0.946778711', '316', '0.352941176', '0', '0.366666667', '0.443181818', '1', '6', '12.59090909', '2', '0.9091', '1']
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	1	['5', '2', '0', '3', '20', '0', '0', '3', '4', '0.5', '138', '1', '0', '0.888888889', '0.5', '1', '1', '26.2', '12', '4.8', '1']
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; public class SummaryInformation extends SpecialPropertySet { public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation" ; public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) throw new UnexpectedPropertySetTypeException ( "Not a " + getClass ( ) . getName ( ) ) ; } public String getTitle ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TITLE ) ; } public String getSubject ( ) { return ( String ) getProperty ( PropertyIDMap . PID_SUBJECT ) ; } public String getAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_AUTHOR ) ; } public String getKeywords ( ) { return ( String ) getProperty ( PropertyIDMap . PID_KEYWORDS ) ; } public String getComments ( ) { return ( String ) getProperty ( PropertyIDMap . PID_COMMENTS ) ; } public String getTemplate ( ) { return ( String ) getProperty ( PropertyIDMap . PID_TEMPLATE ) ; } public String getLastAuthor ( ) { return ( String ) getProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; } public String getRevNumber ( ) { return ( String ) getProperty ( PropertyIDMap . PID_REVNUMBER ) ; } public Date getEditTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_EDITTIME ) ; } public Date getLastPrinted ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTPRINTED ) ; } public Date getCreateDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_CREATE_DTM ) ; } public Date getLastSaveDateTime ( ) { return ( Date ) getProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; } public int getPageCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_PAGECOUNT ) ; } public int getWordCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_WORDCOUNT ) ; } public int getCharCount ( ) { return getPropertyIntValue ( PropertyIDMap . PID_CHARCOUNT ) ; } public byte [ ] getThumbnail ( ) { return ( byte [ ] ) getProperty ( PropertyIDMap . PID_THUMBNAIL ) ; } public String getApplicationName ( ) { return ( String ) getProperty ( PropertyIDMap . PID_APPNAME ) ; } public int getSecurity ( ) { return getPropertyIntValue ( PropertyIDMap . PID_SECURITY ) ; } } 	1	['19', '3', '0', '4', '29', '171', '1', '3', '19', '1.055555556', '128', '0', '0', '0.581395349', '0.526315789', '0', '0', '5.684210526', '1', '0.9474', '1']
package org . apache . poi . hssf . model ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . util . HSSFColor ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; public class Workbook implements Model { private static final int DEBUG = POILogger . DEBUG ; private final static short CODEPAGE = ( short ) 0x4b0 ; protected WorkbookRecordList records = new WorkbookRecordList ( ) ; protected SSTRecord sst = null ; protected ExternSheetRecord externSheet = null ; protected ArrayList boundsheets = new ArrayList ( ) ; protected ArrayList formats = new ArrayList ( ) ; protected ArrayList names = new ArrayList ( ) ; protected int numxfs = 0 ; protected int numfonts = 0 ; private short maxformatid = - 1 ; private boolean uses1904datewindowing = false ; private static POILogger log = POILogFactory . getLogger ( Workbook . class ) ; public Workbook ( ) { } public static Workbook createWorkbook ( List recs ) { log . log ( DEBUG , "Workbook (readfile) created with reclen=" , new Integer ( recs . size ( ) ) ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 3 ) ; for ( int k = 0 ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == EOFRecord . sid ) { records . add ( rec ) ; log . log ( DEBUG , "found workbook eof record at " + k ) ; break ; } switch ( rec . getSid ( ) ) { case BoundSheetRecord . sid : log . log ( DEBUG , "found boundsheet record at " + k ) ; retval . boundsheets . add ( rec ) ; retval . records . setBspos ( k ) ; break ; case SSTRecord . sid : log . log ( DEBUG , "found sst record at " + k ) ; retval . sst = ( SSTRecord ) rec ; break ; case FontRecord . sid : log . log ( DEBUG , "found font record at " + k ) ; retval . records . setFontpos ( k ) ; retval . numfonts ++ ; break ; case ExtendedFormatRecord . sid : log . log ( DEBUG , "found XF record at " + k ) ; retval . records . setXfpos ( k ) ; retval . numxfs ++ ; break ; case TabIdRecord . sid : log . log ( DEBUG , "found tabid record at " + k ) ; retval . records . setTabpos ( k ) ; break ; case ProtectRecord . sid : log . log ( DEBUG , "found protect record at " + k ) ; retval . records . setProtpos ( k ) ; break ; case BackupRecord . sid : log . log ( DEBUG , "found backup record at " + k ) ; retval . records . setBackuppos ( k ) ; break ; case ExternSheetRecord . sid : log . log ( DEBUG , "found extern sheet record at " + k ) ; retval . externSheet = ( ExternSheetRecord ) rec ; break ; case NameRecord . sid : log . log ( DEBUG , "found name record at " + k ) ; retval . names . add ( rec ) ; break ; case SupBookRecord . sid : log . log ( DEBUG , "found SupBook record at " + k ) ; break ; case FormatRecord . sid : log . log ( DEBUG , "found format record at " + k ) ; retval . formats . add ( rec ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; break ; case DateWindow1904Record . sid : log . log ( DEBUG , "found datewindow1904 record at " + k ) ; retval . uses1904datewindowing = ( ( DateWindow1904Record ) rec ) . getWindowing ( ) == 1 ; break ; case PaletteRecord . sid : log . log ( DEBUG , "found palette record at " + k ) ; retval . records . setPalettepos ( k ) ; default : } records . add ( rec ) ; } retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create workbook from existing file function" ) ; return retval ; } public static Workbook createWorkbook ( ) { log . log ( DEBUG , "creating new workbook from scratch" ) ; Workbook retval = new Workbook ( ) ; ArrayList records = new ArrayList ( 30 ) ; ArrayList formats = new ArrayList ( 8 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createInterfaceHdr ( ) ) ; records . add ( retval . createMMS ( ) ) ; records . add ( retval . createInterfaceEnd ( ) ) ; records . add ( retval . createWriteAccess ( ) ) ; records . add ( retval . createCodepage ( ) ) ; records . add ( retval . createDSF ( ) ) ; records . add ( retval . createTabId ( ) ) ; retval . records . setTabpos ( records . size ( ) - 1 ) ; records . add ( retval . createFnGroupCount ( ) ) ; records . add ( retval . createWindowProtect ( ) ) ; records . add ( retval . createProtect ( ) ) ; retval . records . setProtpos ( records . size ( ) - 1 ) ; records . add ( retval . createPassword ( ) ) ; records . add ( retval . createProtectionRev4 ( ) ) ; records . add ( retval . createPasswordRev4 ( ) ) ; records . add ( retval . createWindowOne ( ) ) ; records . add ( retval . createBackup ( ) ) ; retval . records . setBackuppos ( records . size ( ) - 1 ) ; records . add ( retval . createHideObj ( ) ) ; records . add ( retval . createDateWindow1904 ( ) ) ; records . add ( retval . createPrecision ( ) ) ; records . add ( retval . createRefreshAll ( ) ) ; records . add ( retval . createBookBool ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; records . add ( retval . createFont ( ) ) ; retval . records . setFontpos ( records . size ( ) - 1 ) ; retval . numfonts = 4 ; for ( int i = 0 ; i <= 7 ; i ++ ) { Record rec ; rec = retval . createFormat ( i ) ; retval . maxformatid = retval . maxformatid >= ( ( FormatRecord ) rec ) . getIndexCode ( ) ? retval . maxformatid : ( ( FormatRecord ) rec ) . getIndexCode ( ) ; formats . add ( rec ) ; records . add ( rec ) ; } retval . formats = formats ; for ( int k = 0 ; k < 21 ; k ++ ) { records . add ( retval . createExtendedFormat ( k ) ) ; retval . numxfs ++ ; } retval . records . setXfpos ( records . size ( ) - 1 ) ; for ( int k = 0 ; k < 6 ; k ++ ) { records . add ( retval . createStyle ( k ) ) ; } retval . records . setPalettepos ( records . size ( ) ) ; records . add ( retval . createUseSelFS ( ) ) ; for ( int k = 0 ; k < 1 ; k ++ ) { BoundSheetRecord bsr = ( BoundSheetRecord ) retval . createBoundSheet ( k ) ; records . add ( bsr ) ; retval . boundsheets . add ( bsr ) ; retval . records . setBspos ( records . size ( ) - 1 ) ; } records . add ( retval . createCountry ( ) ) ; retval . sst = ( SSTRecord ) retval . createSST ( ) ; records . add ( retval . sst ) ; records . add ( retval . createExtendedSST ( ) ) ; records . add ( retval . createEOF ( ) ) ; retval . records . setRecords ( records ) ; log . log ( DEBUG , "exit create new workbook from scratch" ) ; return retval ; } public NameRecord getSpecificBuiltinRecord ( byte name , int sheetIndex ) { Iterator iterator = names . iterator ( ) ; while ( iterator . hasNext ( ) ) { NameRecord record = ( NameRecord ) iterator . next ( ) ; if ( record . getBuiltInName ( ) == name && record . getIndexToSheet ( ) == sheetIndex ) { return record ; } } return null ; } public void removeBuiltinRecord ( byte name , int sheetIndex ) { NameRecord record = getSpecificBuiltinRecord ( name , sheetIndex ) ; if ( record != null ) { names . remove ( record ) ; } } public int getNumRecords ( ) { return records . size ( ) ; } public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( "There are only " + numfonts + " font records, you asked for " + idx ) ; } FontRecord retval = ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + index ) ; return retval ; } public FontRecord createNewFont ( ) { FontRecord rec = ( FontRecord ) createFont ( ) ; records . add ( records . getFontpos ( ) + 1 , rec ) ; records . setFontpos ( records . getFontpos ( ) + 1 ) ; numfonts ++ ; return rec ; } public int getNumberOfFontRecords ( ) { return numfonts ; } public void setSheetBof ( int sheetnum , int pos ) { log . log ( DEBUG , "setting bof for sheetnum =" , new Integer ( sheetnum ) , " at pos=" , new Integer ( pos ) ) ; checkSheets ( sheetnum ) ; ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . setPositionOfBof ( pos ) ; } public BackupRecord getBackupRecord ( ) { return ( BackupRecord ) records . get ( records . getBackuppos ( ) ) ; } public void setSheetName ( int sheetnum , String sheetname ) { setSheetName ( sheetnum , sheetname , ( byte ) 0 ) ; } public void setSheetName ( int sheetnum , String sheetname , short encoding ) { checkSheets ( sheetnum ) ; BoundSheetRecord sheet = ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ; sheet . setSheetname ( sheetname ) ; sheet . setSheetnameLength ( ( byte ) sheetname . length ( ) ) ; sheet . setCompressedUnicodeFlag ( ( byte ) encoding ) ; } public void setSheetOrder ( String sheetname , int pos ) { int sheetNumber = getSheetIndex ( sheetname ) ; boundsheets . add ( pos , boundsheets . remove ( sheetNumber ) ) ; } public String getSheetName ( int sheetnum ) { return ( ( BoundSheetRecord ) boundsheets . get ( sheetnum ) ) . getSheetname ( ) ; } public int getSheetIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < boundsheets . size ( ) ; k ++ ) { String sheet = getSheetName ( k ) ; if ( sheet . equalsIgnoreCase ( name ) ) { retval = k ; break ; } } return retval ; } private void checkSheets ( int sheetnum ) { if ( ( boundsheets . size ( ) ) <= sheetnum ) { if ( ( boundsheets . size ( ) + 1 ) <= sheetnum ) { throw new RuntimeException ( "Sheet number out of bounds!" ) ; } BoundSheetRecord bsr = ( BoundSheetRecord ) createBoundSheet ( sheetnum ) ; records . add ( records . getBspos ( ) + 1 , bsr ) ; records . setBspos ( records . getBspos ( ) + 1 ) ; boundsheets . add ( bsr ) ; fixTabIdRecord ( ) ; } } public void removeSheet ( int sheetnum ) { if ( boundsheets . size ( ) > sheetnum ) { records . remove ( records . getBspos ( ) - ( boundsheets . size ( ) - 1 ) + sheetnum ) ; boundsheets . remove ( sheetnum ) ; fixTabIdRecord ( ) ; } } private void fixTabIdRecord ( ) { TabIdRecord tir = ( TabIdRecord ) records . get ( records . getTabpos ( ) ) ; short [ ] tia = new short [ boundsheets . size ( ) ] ; for ( short k = 0 ; k < tia . length ; k ++ ) { tia [ k ] = k ; } tir . setTabIdArray ( tia ) ; } public int getNumSheets ( ) { log . log ( DEBUG , "getNumSheets=" , new Integer ( boundsheets . size ( ) ) ) ; return boundsheets . size ( ) ; } public int getNumExFormats ( ) { log . log ( DEBUG , "getXF=" , new Integer ( numxfs ) ) ; return numxfs ; } public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) ; xfptr += index ; ExtendedFormatRecord retval = ( ExtendedFormatRecord ) records . get ( xfptr ) ; return retval ; } public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; records . add ( records . getXfpos ( ) + 1 , xf ) ; records . setXfpos ( records . getXfpos ( ) + 1 ) ; numxfs ++ ; return xf ; } public int addSSTString ( String string , boolean use16bits ) { log . log ( DEBUG , "insert to sst string='" , string , "' and use16bits= " , new Boolean ( use16bits ) ) ; if ( sst == null ) { insertSST ( ) ; } return sst . addString ( string , use16bits ) ; } public int addSSTString ( String string ) { return addSSTString ( string , false ) ; } public String getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } String retval = sst . getString ( str ) ; log . log ( DEBUG , "Returning SST for index=" , new Integer ( str ) , " String= " , retval ) ; return retval ; } public void insertSST ( ) { log . log ( DEBUG , "creating new SST via insertSST!" ) ; sst = ( SSTRecord ) createSST ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; } public int serialize ( int offset , byte [ ] data ) { log . log ( DEBUG , "Serializing Workbook with offsets" ) ; int pos = 0 ; SSTRecord sst = null ; int sstPos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) { sst = ( SSTRecord ) record ; sstPos = pos ; } if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) { record = sst . createExtSSTRecord ( sstPos + offset ) ; } pos += record . serialize ( pos + offset , data ) ; } } log . log ( DEBUG , "Exiting serialize workbook" ) ; return pos ; } public int getSize ( ) { int retval = 0 ; SSTRecord sst = null ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = records . get ( k ) ; if ( record . getSid ( ) != RecalcIdRecord . sid || ( ( RecalcIdRecord ) record ) . isNeeded ( ) ) { if ( record instanceof SSTRecord ) sst = ( SSTRecord ) record ; if ( record . getSid ( ) == ExtSSTRecord . sid && sst != null ) retval += sst . calcExtSSTRecordSize ( ) ; else retval += record . getRecordSize ( ) ; } } return retval ; } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 5 ) ; retval . setBuild ( ( short ) 0x10d3 ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0x41 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createInterfaceHdr ( ) { InterfaceHdrRecord retval = new InterfaceHdrRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createMMS ( ) { MMSRecord retval = new MMSRecord ( ) ; retval . setAddMenuCount ( ( byte ) 0 ) ; retval . setDelMenuCount ( ( byte ) 0 ) ; return retval ; } protected Record createInterfaceEnd ( ) { return new InterfaceEndRecord ( ) ; } protected Record createWriteAccess ( ) { WriteAccessRecord retval = new WriteAccessRecord ( ) ; retval . setUsername ( System . getProperty ( "user.name" ) ) ; return retval ; } protected Record createCodepage ( ) { CodepageRecord retval = new CodepageRecord ( ) ; retval . setCodepage ( CODEPAGE ) ; return retval ; } protected Record createDSF ( ) { DSFRecord retval = new DSFRecord ( ) ; retval . setDsf ( ( short ) 0 ) ; return retval ; } protected Record createTabId ( ) { TabIdRecord retval = new TabIdRecord ( ) ; short [ ] tabidarray = { 0 } ; retval . setTabIdArray ( tabidarray ) ; return retval ; } protected Record createFnGroupCount ( ) { FnGroupCountRecord retval = new FnGroupCountRecord ( ) ; retval . setCount ( ( short ) 14 ) ; return retval ; } protected Record createWindowProtect ( ) { WindowProtectRecord retval = new WindowProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createProtect ( ) { ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPassword ( ) { PasswordRecord retval = new PasswordRecord ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createProtectionRev4 ( ) { ProtectionRev4Record retval = new ProtectionRev4Record ( ) ; retval . setProtect ( false ) ; return retval ; } protected Record createPasswordRev4 ( ) { PasswordRev4Record retval = new PasswordRev4Record ( ) ; retval . setPassword ( ( short ) 0 ) ; return retval ; } protected Record createWindowOne ( ) { WindowOneRecord retval = new WindowOneRecord ( ) ; retval . setHorizontalHold ( ( short ) 0x168 ) ; retval . setVerticalHold ( ( short ) 0x10e ) ; retval . setWidth ( ( short ) 0x3a5c ) ; retval . setHeight ( ( short ) 0x23be ) ; retval . setOptions ( ( short ) 0x38 ) ; retval . setSelectedTab ( ( short ) 0x0 ) ; retval . setDisplayedTab ( ( short ) 0x0 ) ; retval . setNumSelectedTabs ( ( short ) 1 ) ; retval . setTabWidthRatio ( ( short ) 0x258 ) ; return retval ; } protected Record createBackup ( ) { BackupRecord retval = new BackupRecord ( ) ; retval . setBackup ( ( short ) 0 ) ; return retval ; } protected Record createHideObj ( ) { HideObjRecord retval = new HideObjRecord ( ) ; retval . setHideObj ( ( short ) 0 ) ; return retval ; } protected Record createDateWindow1904 ( ) { DateWindow1904Record retval = new DateWindow1904Record ( ) ; retval . setWindowing ( ( short ) 0 ) ; return retval ; } protected Record createPrecision ( ) { PrecisionRecord retval = new PrecisionRecord ( ) ; retval . setFullPrecision ( true ) ; return retval ; } protected Record createRefreshAll ( ) { RefreshAllRecord retval = new RefreshAllRecord ( ) ; retval . setRefreshAll ( false ) ; return retval ; } protected Record createBookBool ( ) { BookBoolRecord retval = new BookBoolRecord ( ) ; retval . setSaveLinkValues ( ( short ) 0 ) ; return retval ; } protected Record createFont ( ) { FontRecord retval = new FontRecord ( ) ; retval . setFontHeight ( ( short ) 0xc8 ) ; retval . setAttributes ( ( short ) 0x0 ) ; retval . setColorPaletteIndex ( ( short ) 0x7fff ) ; retval . setBoldWeight ( ( short ) 0x190 ) ; retval . setFontNameLength ( ( byte ) 5 ) ; retval . setFontName ( "Arial" ) ; return retval ; } protected Record createFormat ( int id ) { FormatRecord retval = new FormatRecord ( ) ; switch ( id ) { case 0 : retval . setIndexCode ( ( short ) 5 ) ; retval . setFormatStringLength ( ( byte ) 0x17 ) ; retval . setFormatString ( "\"$\"#,##0_);\\(\"$\"#,##0\\)" ) ; break ; case 1 : retval . setIndexCode ( ( short ) 6 ) ; retval . setFormatStringLength ( ( byte ) 0x1c ) ; retval . setFormatString ( "\"$\"#,##0_);[Red]\\(\"$\"#,##0\\)" ) ; break ; case 2 : retval . setIndexCode ( ( short ) 7 ) ; retval . setFormatStringLength ( ( byte ) 0x1d ) ; retval . setFormatString ( "\"$\"#,##0.00_);\\(\"$\"#,##0.00\\)" ) ; break ; case 3 : retval . setIndexCode ( ( short ) 8 ) ; retval . setFormatStringLength ( ( byte ) 0x22 ) ; retval . setFormatString ( "\"$\"#,##0.00_);[Red]\\(\"$\"#,##0.00\\)" ) ; break ; case 4 : retval . setIndexCode ( ( short ) 0x2a ) ; retval . setFormatStringLength ( ( byte ) 0x32 ) ; retval . setFormatString ( "_(\"$\"* #,##0_);_(\"$\"* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)" ) ; break ; case 5 : retval . setIndexCode ( ( short ) 0x29 ) ; retval . setFormatStringLength ( ( byte ) 0x29 ) ; retval . setFormatString ( "_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)" ) ; break ; case 6 : retval . setIndexCode ( ( short ) 0x2c ) ; retval . setFormatStringLength ( ( byte ) 0x3a ) ; retval . setFormatString ( "_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)" ) ; break ; case 7 : retval . setIndexCode ( ( short ) 0x2b ) ; retval . setFormatStringLength ( ( byte ) 0x31 ) ; retval . setFormatString ( "_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)" ) ; break ; } return retval ; } protected Record createExtendedFormat ( int id ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; switch ( id ) { case 0 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 1 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 2 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 3 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 4 : retval . setFontIndex ( ( short ) 2 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 5 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 6 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 7 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 8 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 9 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 10 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 11 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 12 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 13 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 14 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff400 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 15 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 16 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2b ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 17 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x29 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 18 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2c ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 19 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x2a ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 20 : retval . setFontIndex ( ( short ) 1 ) ; retval . setFormatIndex ( ( short ) 0x9 ) ; retval . setCellOptions ( ( short ) 0xfffffff5 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0xfffff800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 21 : retval . setFontIndex ( ( short ) 5 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x800 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 22 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 23 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x31 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 24 : retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; case 25 : retval . setFontIndex ( ( short ) 6 ) ; retval . setFormatIndex ( ( short ) 0x8 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0x5c00 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; break ; } return retval ; } protected ExtendedFormatRecord createExtendedFormat ( ) { ExtendedFormatRecord retval = new ExtendedFormatRecord ( ) ; retval . setFontIndex ( ( short ) 0 ) ; retval . setFormatIndex ( ( short ) 0x0 ) ; retval . setCellOptions ( ( short ) 0x1 ) ; retval . setAlignmentOptions ( ( short ) 0x20 ) ; retval . setIndentionOptions ( ( short ) 0 ) ; retval . setBorderOptions ( ( short ) 0 ) ; retval . setPaletteOptions ( ( short ) 0 ) ; retval . setAdtlPaletteOptions ( ( short ) 0 ) ; retval . setFillPaletteOptions ( ( short ) 0x20c0 ) ; retval . setTopBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setBottomBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setLeftBorderPaletteIdx ( HSSFColor . BLACK . index ) ; retval . setRightBorderPaletteIdx ( HSSFColor . BLACK . index ) ; return retval ; } protected Record createStyle ( int id ) { StyleRecord retval = new StyleRecord ( ) ; switch ( id ) { case 0 : retval . setIndex ( ( short ) 0xffff8010 ) ; retval . setBuiltin ( ( byte ) 3 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 1 : retval . setIndex ( ( short ) 0xffff8011 ) ; retval . setBuiltin ( ( byte ) 6 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 2 : retval . setIndex ( ( short ) 0xffff8012 ) ; retval . setBuiltin ( ( byte ) 4 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 3 : retval . setIndex ( ( short ) 0xffff8013 ) ; retval . setBuiltin ( ( byte ) 7 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 4 : retval . setIndex ( ( short ) 0xffff8000 ) ; retval . setBuiltin ( ( byte ) 0 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; case 5 : retval . setIndex ( ( short ) 0xffff8014 ) ; retval . setBuiltin ( ( byte ) 5 ) ; retval . setOutlineStyleLevel ( ( byte ) 0xffffffff ) ; break ; } return retval ; } protected PaletteRecord createPalette ( ) { return new PaletteRecord ( PaletteRecord . sid ) ; } protected Record createUseSelFS ( ) { UseSelFSRecord retval = new UseSelFSRecord ( ) ; retval . setFlag ( ( short ) 0 ) ; return retval ; } protected Record createBoundSheet ( int id ) { BoundSheetRecord retval = new BoundSheetRecord ( ) ; switch ( id ) { case 0 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet1" ) ; break ; case 1 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet2" ) ; break ; case 2 : retval . setPositionOfBof ( 0x0 ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setSheetnameLength ( ( byte ) 0x6 ) ; retval . setCompressedUnicodeFlag ( ( byte ) 0 ) ; retval . setSheetname ( "Sheet3" ) ; break ; } return retval ; } protected Record createCountry ( ) { CountryRecord retval = new CountryRecord ( ) ; retval . setDefaultCountry ( ( short ) 1 ) ; if ( Locale . getDefault ( ) . toString ( ) . equals ( "ru_RU" ) ) { retval . setCurrentCountry ( ( short ) 7 ) ; } else { retval . setCurrentCountry ( ( short ) 1 ) ; } return retval ; } protected Record createSST ( ) { return new SSTRecord ( ) ; } protected Record createExtendedSST ( ) { ExtSSTRecord retval = new ExtSSTRecord ( ) ; retval . setNumStringsPerBucket ( ( short ) 0x8 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public SheetReferences getSheetReferences ( ) { SheetReferences refs = new SheetReferences ( ) ; if ( externSheet != null ) { for ( int k = 0 ; k < externSheet . getNumOfREFStructures ( ) ; k ++ ) { String sheetName = findSheetNameFromExternSheet ( ( short ) k ) ; refs . addSheetReference ( sheetName , k ) ; } } return refs ; } public String findSheetNameFromExternSheet ( short num ) { String result = "" ; short indexToSheet = externSheet . getREFRecordAt ( num ) . getIndexToFirstSupBook ( ) ; if ( indexToSheet > - 1 ) { result = getSheetName ( indexToSheet ) ; } return result ; } public int getSheetIndexFromExternSheetIndex ( int externSheetNumber ) { if ( externSheetNumber >= externSheet . getNumOfREFStructures ( ) ) return - 1 ; else return externSheet . getREFRecordAt ( externSheetNumber ) . getIndexToFirstSupBook ( ) ; } public short checkExternSheet ( int sheetNumber ) { int i = 0 ; boolean flag = false ; short result = 0 ; if ( externSheet == null ) { externSheet = createExternSheet ( ) ; } while ( i < externSheet . getNumOfREFStructures ( ) && ! flag ) { ExternSheetSubRecord record = externSheet . getREFRecordAt ( i ) ; if ( record . getIndexToFirstSupBook ( ) == sheetNumber && record . getIndexToLastSupBook ( ) == sheetNumber ) { flag = true ; result = ( short ) i ; } ++ i ; } if ( ! flag ) { result = addSheetIndexToExternSheet ( ( short ) sheetNumber ) ; } return result ; } private short addSheetIndexToExternSheet ( short sheetNumber ) { short result ; ExternSheetSubRecord record = new ExternSheetSubRecord ( ) ; record . setIndexToFirstSupBook ( sheetNumber ) ; record . setIndexToLastSupBook ( sheetNumber ) ; externSheet . addREFRecord ( record ) ; externSheet . setNumOfREFStructures ( ( short ) ( externSheet . getNumOfREFStructures ( ) + 1 ) ) ; result = ( short ) ( externSheet . getNumOfREFStructures ( ) - 1 ) ; return result ; } public int getNumNames ( ) { int result = names . size ( ) ; return result ; } public NameRecord getNameRecord ( int index ) { NameRecord result = ( NameRecord ) names . get ( index ) ; return result ; } public NameRecord createName ( ) { NameRecord name = new NameRecord ( ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord addName ( NameRecord name ) { int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + names . size ( ) + 1 , name ) ; names . add ( name ) ; return name ; } public NameRecord createBuiltInName ( byte builtInName , int index ) { if ( index == - 1 || index + 1 > ( int ) Short . MAX_VALUE ) throw new IllegalArgumentException ( "Index is not valid [" + index + "]" ) ; NameRecord name = new NameRecord ( builtInName , ( short ) ( index ) ) ; addName ( name ) ; return name ; } public void removeName ( int namenum ) { if ( names . size ( ) > namenum ) { int idx = findFirstRecordLocBySid ( NameRecord . sid ) ; records . remove ( idx + namenum ) ; names . remove ( namenum ) ; } } protected ExternSheetRecord createExternSheet ( ) { ExternSheetRecord externSheet = new ExternSheetRecord ( ) ; int idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; records . add ( idx + 1 , externSheet ) ; SupBookRecord supbook = new SupBookRecord ( ) ; supbook . setNumberOfSheets ( ( short ) getNumSheets ( ) ) ; records . add ( idx + 1 , supbook ) ; return externSheet ; } public short getFormat ( String format , boolean createIfNotFound ) { Iterator iterator ; for ( iterator = formats . iterator ( ) ; iterator . hasNext ( ) ; ) { FormatRecord r = ( FormatRecord ) iterator . next ( ) ; if ( r . getFormatString ( ) . equals ( format ) ) { return r . getIndexCode ( ) ; } } if ( createIfNotFound ) { return createFormat ( format ) ; } return - 1 ; } public ArrayList getFormats ( ) { return formats ; } public short createFormat ( String format ) { FormatRecord rec = new FormatRecord ( ) ; maxformatid = maxformatid >= ( short ) 0xa4 ? ( short ) ( maxformatid + 1 ) : ( short ) 0xa4 ; rec . setIndexCode ( maxformatid ) ; rec . setFormatStringLength ( ( byte ) format . length ( ) ) ; rec . setFormatString ( format ) ; int pos = 0 ; while ( pos < records . size ( ) && records . get ( pos ) . getSid ( ) != FormatRecord . sid ) pos ++ ; pos += formats . size ( ) ; formats . add ( rec ) ; records . add ( pos , rec ) ; return maxformatid ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public Record findNextRecordBySid ( short sid , int pos ) { int matches = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { if ( matches ++ == pos ) return record ; } } return null ; } public List getRecords ( ) { return records . getRecords ( ) ; } public boolean isUsing1904DateWindowing ( ) { return uses1904datewindowing ; } public PaletteRecord getCustomPalette ( ) { PaletteRecord palette ; int palettePos = records . getPalettepos ( ) ; if ( palettePos != - 1 ) { Record rec = records . get ( palettePos ) ; if ( rec instanceof PaletteRecord ) { palette = ( PaletteRecord ) rec ; } else throw new RuntimeException ( "InternalError: Expected PaletteRecord but got a '" + rec + "'" ) ; } else { palette = createPalette ( ) ; records . add ( 1 , palette ) ; records . setPalettepos ( 1 ) ; } return palette ; } } 	1	['84', '1', '0', '87', '269', '2582', '45', '43', '46', '0.907321594', '3213', '1', '4', '0', '0.168674699', '0', '0', '37.0952381', '19', '1.9286', '1']
package org . apache . poi . hssf . record . formula ; import java . util . List ; import org . apache . poi . hssf . model . Workbook ; public class LessThanPtg extends OperationPtg { public final static int SIZE = 1 ; public final static byte sid = 0x09 ; private final static String LESSTHAN = "<" ; public LessThanPtg ( ) { } public LessThanPtg ( byte [ ] data , int offset ) { } public void writeBytes ( byte [ ] array , int offset ) { array [ offset + 0 ] = sid ; } public int getSize ( ) { return SIZE ; } public int getType ( ) { return TYPE_BINARY ; } public int getNumberOfOperands ( ) { return 2 ; } public String toFormulaString ( Workbook book ) { return this . LESSTHAN ; } public String toFormulaString ( String [ ] operands ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( this . LESSTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } public Object clone ( ) { return new LessThanPtg ( ) ; } } 	1	['10', '2', '0', '4', '14', '45', '2', '2', '10', '1.111111111', '67', '0.333333333', '0', '0.272727273', '0.32', '0', '0', '5.4', '1', '0.8', '1']
package org . apache . poi . util ; import java . util . * ; public class NullLogger extends POILogger { public void initialize ( final String cat ) { } public void log ( final int level , final Object obj1 ) { } public boolean check ( final int level ) { return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { } public void log ( final int level , final Object obj1 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { } public void logFormatted ( final int level , final String message , final Object obj1 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } } 	1	['23', '2', '0', '2', '24', '253', '1', '1', '23', '2', '49', '0', '0', '0.52173913', '0.669565217', '1', '2', '1.130434783', '1', '0.9565', '1']
package org . apache . poi . hpsf ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . wellknown . * ; import org . apache . poi . poifs . filesystem . * ; import org . apache . poi . util . LittleEndian ; public class PropertySet { final static byte [ ] BYTE_ORDER_ASSERTION = new byte [ ] { ( byte ) 0xFE , ( byte ) 0xFF } ; protected int byteOrder ; public int getByteOrder ( ) { return byteOrder ; } final static byte [ ] FORMAT_ASSERTION = new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 } ; protected int format ; public int getFormat ( ) { return format ; } protected int osVersion ; public final static int OS_WIN16 = 0x0000 ; public final static int OS_MACINTOSH = 0x0001 ; public final static int OS_WIN32 = 0x0002 ; public long getOSVersion ( ) { return osVersion ; } protected ClassID classID ; public ClassID getClassID ( ) { return classID ; } protected int sectionCount ; public long getSectionCount ( ) { return sectionCount ; } protected List sections ; public List getSections ( ) { return sections ; } protected PropertySet ( ) { } public PropertySet ( final InputStream stream ) throws NoPropertySetStreamException , MarkUnsupportedException , IOException { if ( isPropertySetStream ( stream ) ) { final int avail = stream . available ( ) ; final byte [ ] buffer = new byte [ avail ] ; stream . read ( buffer , 0 , buffer . length ) ; init ( buffer , 0 , buffer . length ) ; } else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream , final int offset , final int length ) throws NoPropertySetStreamException { if ( isPropertySetStream ( stream , offset , length ) ) init ( stream , offset , length ) ; else throw new NoPropertySetStreamException ( ) ; } public PropertySet ( final byte [ ] stream ) throws NoPropertySetStreamException { this ( stream , 0 , stream . length ) ; } public static boolean isPropertySetStream ( final InputStream stream ) throws MarkUnsupportedException , IOException { final int BUFFER_SIZE = 50 ; if ( ! stream . markSupported ( ) ) throw new MarkUnsupportedException ( stream . getClass ( ) . getName ( ) ) ; stream . mark ( BUFFER_SIZE ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; final int bytes = stream . read ( buffer , 0 , Math . min ( buffer . length , stream . available ( ) ) ) ; final boolean isPropertySetStream = isPropertySetStream ( buffer , 0 , bytes ) ; stream . reset ( ) ; return isPropertySetStream ; } public static boolean isPropertySetStream ( final byte [ ] src , int offset , final int length ) { final int byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; byte [ ] temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) byteOrder ) ; if ( ! Util . equal ( temp , BYTE_ORDER_ASSERTION ) ) return false ; final int format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; temp = new byte [ LittleEndian . SHORT_SIZE ] ; LittleEndian . putShort ( temp , ( short ) format ) ; if ( ! Util . equal ( temp , FORMAT_ASSERTION ) ) return false ; final long osVersion = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final ClassID classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; final long sectionCount = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount < 1 ) return false ; return true ; } private void init ( final byte [ ] src , int offset , final int length ) { byteOrder = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; format = LittleEndian . getUShort ( src , offset ) ; offset += LittleEndian . SHORT_SIZE ; osVersion = ( int ) LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; classID = new ClassID ( src , offset ) ; offset += ClassID . LENGTH ; sectionCount = LittleEndian . getInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; if ( sectionCount <= 0 ) throw new HPSFRuntimeException ( "Section count " + sectionCount + " must be greater than 0." ) ; sections = new ArrayList ( 2 ) ; for ( int i = 0 ; i < sectionCount ; i ++ ) { final Section s = new Section ( src , offset ) ; offset += ClassID . LENGTH + LittleEndian . INT_SIZE ; sections . add ( s ) ; } } public boolean isSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . SUMMARY_INFORMATION_ID ) ; } public boolean isDocumentSummaryInformation ( ) { return Util . equal ( ( ( Section ) sections . get ( 0 ) ) . getFormatID ( ) . getBytes ( ) , SectionIDMap . DOCUMENT_SUMMARY_INFORMATION_ID ) ; } public Property [ ] getProperties ( ) throws NoSingleSectionException { return getSingleSection ( ) . getProperties ( ) ; } protected Object getProperty ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getProperty ( id ) ; } protected boolean getPropertyBooleanValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyBooleanValue ( id ) ; } protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getSingleSection ( ) . getPropertyIntValue ( id ) ; } public boolean wasNull ( ) throws NoSingleSectionException { return getSingleSection ( ) . wasNull ( ) ; } public Section getSingleSection ( ) { if ( sectionCount != 1 ) throw new NoSingleSectionException ( "Property set contains " + sectionCount + " sections." ) ; return ( ( Section ) sections . get ( 0 ) ) ; } } 	1	['22', '1', '1', '14', '56', '197', '4', '10', '16', '0.813852814', '378', '0.545454545', '1', '0', '0.369047619', '0', '0', '15.68181818', '4', '1.0455', '1']
package org . apache . poi . hssf . record . aggregates ; import org . apache . poi . hssf . record . * ; import java . util . Iterator ; import java . util . List ; import java . util . TreeMap ; public class ValueRecordsAggregate extends Record { public final static short sid = - 1000 ; int firstcell = - 1 ; int lastcell = - 1 ; TreeMap records = null ; public ValueRecordsAggregate ( ) { records = new TreeMap ( ) ; } public void insertCell ( CellValueRecordInterface cell ) { Object o = records . put ( cell , cell ) ; if ( ( cell . getColumn ( ) < firstcell ) || ( firstcell == - 1 ) ) { firstcell = cell . getColumn ( ) ; } if ( ( cell . getColumn ( ) > lastcell ) || ( lastcell == - 1 ) ) { lastcell = cell . getColumn ( ) ; } } public void removeCell ( CellValueRecordInterface cell ) { records . remove ( cell ) ; } public int getPhysicalNumberOfCells ( ) { return records . size ( ) ; } public int getFirstCellNum ( ) { return firstcell ; } public int getLastCellNum ( ) { return lastcell ; } public int construct ( int offset , List records ) { int k = 0 ; FormulaRecordAggregate lastFormulaAggregate = null ; for ( k = offset ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec instanceof StringRecord == false && ! rec . isInValueSection ( ) && ! ( rec instanceof UnknownRecord ) ) { break ; } if ( rec instanceof FormulaRecord ) { lastFormulaAggregate = new FormulaRecordAggregate ( ( FormulaRecord ) rec , null ) ; insertCell ( lastFormulaAggregate ) ; } else if ( rec instanceof StringRecord ) { lastFormulaAggregate . setStringRecord ( ( StringRecord ) rec ) ; } else if ( rec instanceof SharedFormulaRecord ) { lastFormulaAggregate . setSharedFormulaRecord ( ( SharedFormulaRecord ) rec ) ; } else if ( rec . isValue ( ) ) { insertCell ( ( CellValueRecordInterface ) rec ) ; } } return k ; } public int serialize ( int offset , byte [ ] data ) { Iterator itr = records . values ( ) . iterator ( ) ; int pos = offset ; while ( itr . hasNext ( ) ) { pos += ( ( Record ) itr . next ( ) ) . serialize ( pos , data ) ; } return pos - offset ; } protected void fillFields ( byte [ ] data , short size , int offset ) { } protected void validateSid ( short id ) { } public short getSid ( ) { return sid ; } public int getRecordSize ( ) { int size = 0 ; Iterator irecs = records . values ( ) . iterator ( ) ; while ( irecs . hasNext ( ) ) { size += ( ( Record ) irecs . next ( ) ) . getRecordSize ( ) ; } return size ; } public Iterator getIterator ( ) { return records . values ( ) . iterator ( ) ; } public Object clone ( ) { ValueRecordsAggregate rec = new ValueRecordsAggregate ( ) ; for ( Iterator valIter = getIterator ( ) ; valIter . hasNext ( ) ; ) { CellValueRecordInterface val = ( CellValueRecordInterface ) ( ( CellValueRecordInterface ) valIter . next ( ) ) . clone ( ) ; rec . insertCell ( val ) ; } return rec ; } } 	1	['14', '2', '0', '8', '34', '41', '1', '7', '12', '0.711538462', '225', '0', '0', '0.458333333', '0.285714286', '1', '5', '14.78571429', '9', '2', '1']
package org . apache . poi . hssf . record ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . util . LittleEndian ; public class PaletteRecord extends Record { public final static short sid = 0x92 ; public final static byte STANDARD_PALETTE_SIZE = ( byte ) 56 ; public final static short FIRST_COLOR_INDEX = ( short ) 0x8 ; private short field_1_numcolors ; private List field_2_colors ; public PaletteRecord ( ) { } public PaletteRecord ( short id ) { super ( id , STANDARD_PALETTE_SIZE , getDefaultData ( ) ) ; } public PaletteRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public PaletteRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT An Palette RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_numcolors = LittleEndian . getShort ( data , offset + 0 ) ; field_2_colors = new ArrayList ( field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { field_2_colors . add ( new PColor ( data [ 2 + offset + ( k * 4 ) + 0 ] , data [ 2 + offset + ( k * 4 ) + 1 ] , data [ 2 + offset + ( k * 4 ) + 2 ] ) ) ; } } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[PALETTE]\n" ) ; buffer . append ( "  numcolors     = " ) . append ( field_1_numcolors ) . append ( '\n' ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; buffer . append ( "* colornum      = " ) . append ( k ) . append ( '\n' ) ; buffer . append ( c . toString ( ) ) ; buffer . append ( "/*colornum      = " ) . append ( k ) . append ( '\n' ) ; } buffer . append ( "[/PALETTE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; LittleEndian . putShort ( data , 4 + offset , field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { PColor c = ( PColor ) field_2_colors . get ( k ) ; c . serialize ( data , ( 6 + offset + ( k * 4 ) ) ) ; } return getRecordSize ( ) ; } public int getRecordSize ( ) { return 4 + 2 + ( field_1_numcolors * 4 ) ; } public short getSid ( ) { return this . sid ; } public byte [ ] getColor ( short byteIndex ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= field_2_colors . size ( ) ) { return null ; } PColor color = ( PColor ) field_2_colors . get ( i ) ; return new byte [ ] { color . red , color . green , color . blue } ; } public void setColor ( short byteIndex , byte red , byte green , byte blue ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= STANDARD_PALETTE_SIZE ) { return ; } while ( field_2_colors . size ( ) <= i ) { field_2_colors . add ( new PColor ( ( byte ) 0 , ( byte ) 0 , ( byte ) 0 ) ) ; } PColor custColor = new PColor ( red , green , blue ) ; field_2_colors . set ( i , custColor ) ; } public static byte [ ] getDefaultData ( ) { return new byte [ ] { STANDARD_PALETTE_SIZE , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 192 , ( byte ) 192 , ( byte ) 192 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 153 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 102 , ( byte ) 0 , ( byte ) 255 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 128 , ( byte ) 128 , ( byte ) 0 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 0 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 255 , ( byte ) 0 , ( byte ) 204 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 204 , ( byte ) 153 , ( byte ) 255 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 255 , ( byte ) 0 , ( byte ) 51 , ( byte ) 204 , ( byte ) 204 , ( byte ) 0 , ( byte ) 153 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 204 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 153 , ( byte ) 0 , ( byte ) 0 , ( byte ) 255 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 102 , ( byte ) 102 , ( byte ) 153 , ( byte ) 0 , ( byte ) 150 , ( byte ) 150 , ( byte ) 150 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 153 , ( byte ) 102 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 0 , ( byte ) 0 , ( byte ) 153 , ( byte ) 51 , ( byte ) 102 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 153 , ( byte ) 0 , ( byte ) 51 , ( byte ) 51 , ( byte ) 51 , ( byte ) 0 } ; } } class PColor { public byte red ; public byte green ; public byte blue ; public PColor ( byte red , byte green , byte blue ) { this . red = red ; this . green = green ; this . blue = blue ; } public void serialize ( byte [ ] data , int offset ) { data [ offset + 0 ] = red ; data [ offset + 1 ] = green ; data [ offset + 2 ] = blue ; data [ offset + 3 ] = 0 ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "  red           = " ) . append ( red & 0xff ) . append ( '\n' ) ; buffer . append ( "  green         = " ) . append ( green & 0xff ) . append ( '\n' ) ; buffer . append ( "  blue          = " ) . append ( blue & 0xff ) . append ( '\n' ) ; return buffer . toString ( ) ; } } 	1	['13', '2', '0', '8', '32', '52', '4', '4', '11', '0.933333333', '1216', '0.4', '0', '0.55', '0.415384615', '1', '6', '92.15384615', '4', '1.3846', '1']
package org . apache . poi . hssf . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import org . apache . poi . hssf . record . formula . * ; public class FormulaParser { public static int FORMULA_TYPE_CELL = 0 ; public static int FORMULA_TYPE_SHARED = 1 ; public static int FORMULA_TYPE_ARRAY = 2 ; public static int FORMULA_TYPE_CONDFOMRAT = 3 ; public static int FORMULA_TYPE_NAMEDRANGE = 4 ; private String formulaString ; private int pointer = 0 ; private int formulaLength ; private List tokens = new java . util . Stack ( ) ; private List functionTokens = new LinkedList ( ) ; private List result = new ArrayList ( ) ; private int numParen ; private static char TAB = '\t' ; private static char CR = '\n' ; private char look ; private boolean inFunction = false ; private Workbook book ; public FormulaParser ( String formula , Workbook book ) { formulaString = formula ; pointer = 0 ; this . book = book ; formulaLength = formulaString . length ( ) ; } private void GetChar ( ) { if ( pointer == formulaLength ) { look = ( char ) 0 ; return ; } look = formulaString . charAt ( pointer ++ ) ; } private void Error ( String s ) { System . out . println ( "Error: " + s ) ; } private void Abort ( String s ) { Error ( s ) ; throw new RuntimeException ( "Cannot Parse, sorry : " + s ) ; } private void Expected ( String s ) { Abort ( s + " Expected" ) ; } private boolean IsAlpha ( char c ) { return Character . isLetter ( c ) || c == '$' ; } private boolean IsDigit ( char c ) { return Character . isDigit ( c ) ; } private boolean IsAlNum ( char c ) { return ( IsAlpha ( c ) || IsDigit ( c ) ) ; } private boolean IsAddop ( char c ) { return ( c == '+' || c == '-' ) ; } private boolean IsWhite ( char c ) { return ( c == ' ' || c == TAB ) ; } private boolean IsSpecialChar ( char c ) { return ( c == '>' || c == '<' || c == '=' || c == '&' || c == '[' || c == ']' ) ; } private void SkipWhite ( ) { while ( IsWhite ( look ) ) { GetChar ( ) ; } } private void Match ( char x ) { if ( look != x ) { Expected ( "" + x + "" ) ; } else { GetChar ( ) ; SkipWhite ( ) ; } } private String GetName ( ) { StringBuffer Token = new StringBuffer ( ) ; if ( ! IsAlpha ( look ) ) { Expected ( "Name" ) ; } while ( IsAlNum ( look ) ) { Token = Token . append ( Character . toUpperCase ( look ) ) ; GetChar ( ) ; } SkipWhite ( ) ; return Token . toString ( ) ; } private String GetNameAsIs ( ) { StringBuffer Token = new StringBuffer ( ) ; while ( IsAlNum ( look ) || IsWhite ( look ) || IsSpecialChar ( look ) ) { Token = Token . append ( look ) ; GetChar ( ) ; } return Token . toString ( ) ; } private String GetNum ( ) { String Value = "" ; if ( ! IsDigit ( look ) ) Expected ( "Integer" ) ; while ( IsDigit ( look ) ) { Value = Value + look ; GetChar ( ) ; } SkipWhite ( ) ; return Value ; } private void Emit ( String s ) { System . out . print ( TAB + s ) ; } private void EmitLn ( String s ) { Emit ( s ) ; System . out . println ( ) ; ; } private void Ident ( ) { String name ; name = GetName ( ) ; if ( look == '(' ) { function ( name ) ; } else if ( look == ':' ) { String first = name ; Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new AreaPtg ( first + ":" + second ) ) ; } else if ( look == '!' ) { Match ( '!' ) ; String sheetName = name ; String first = GetName ( ) ; short externIdx = book . checkExternSheet ( book . getSheetIndex ( sheetName ) ) ; if ( look == ':' ) { Match ( ':' ) ; String second = GetName ( ) ; tokens . add ( new Area3DPtg ( first + ":" + second , externIdx ) ) ; } else { tokens . add ( new Ref3DPtg ( first , externIdx ) ) ; } } else { boolean cellRef = true ; boolean boolLit = ( name . equals ( "TRUE" ) || name . equals ( "FALSE" ) ) ; if ( boolLit ) { tokens . add ( new BoolPtg ( name ) ) ; } else if ( cellRef ) { tokens . add ( new ReferencePtg ( name ) ) ; } else { } } } private void addArgumentPointer ( ) { if ( this . functionTokens . size ( ) > 0 ) { List arguments = ( List ) this . functionTokens . get ( 0 ) ; arguments . add ( tokens . get ( tokens . size ( ) - 1 ) ) ; } } private void function ( String name ) { this . functionTokens . add ( 0 , new ArrayList ( 2 ) ) ; Match ( '(' ) ; int numArgs = Arguments ( ) ; Match ( ')' ) ; AbstractFunctionPtg functionPtg = getFunction ( name , ( byte ) numArgs ) ; tokens . add ( functionPtg ) ; if ( functionPtg . getName ( ) . equals ( "externalflag" ) ) { tokens . add ( new NamePtg ( name , this . book ) ) ; } this . functionTokens . remove ( 0 ) ; } private int getPtgSize ( int index ) { int count = 0 ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; } return count ; } private int getPtgSize ( int start , int end ) { int count = 0 ; int index = start ; Iterator ptgIterator = tokens . listIterator ( index ) ; while ( ptgIterator . hasNext ( ) && index <= end ) { Ptg ptg = ( Ptg ) ptgIterator . next ( ) ; count += ptg . getSize ( ) ; index ++ ; } return count ; } private AbstractFunctionPtg getFunction ( String name , byte numArgs ) { AbstractFunctionPtg retval = null ; if ( name . equals ( "IF" ) ) { retval = new FuncVarPtg ( AbstractFunctionPtg . ATTR_NAME , numArgs ) ; List argumentPointers = ( List ) this . functionTokens . get ( 0 ) ; AttrPtg ifPtg = new AttrPtg ( ) ; ifPtg . setData ( ( short ) 7 ) ; ifPtg . setOptimizedIf ( true ) ; if ( argumentPointers . size ( ) != 2 && argumentPointers . size ( ) != 3 ) { throw new IllegalArgumentException ( "[" + argumentPointers . size ( ) + "] Arguments Found - An IF formula requires 2 or 3 arguments. IF(CONDITION, TRUE_VALUE, FALSE_VALUE [OPTIONAL]" ) ; } int ifIndex = tokens . indexOf ( argumentPointers . get ( 0 ) ) + 1 ; tokens . add ( ifIndex , ifPtg ) ; int gotoIndex = tokens . indexOf ( argumentPointers . get ( 1 ) ) + 1 ; AttrPtg goto1Ptg = new AttrPtg ( ) ; goto1Ptg . setGoto ( true ) ; tokens . add ( gotoIndex , goto1Ptg ) ; if ( numArgs > 2 ) { AttrPtg goto2Ptg = new AttrPtg ( ) ; goto2Ptg . setGoto ( true ) ; goto2Ptg . setData ( ( short ) ( retval . getSize ( ) - 1 ) ) ; tokens . add ( goto2Ptg ) ; } ifPtg . setData ( ( short ) ( getPtgSize ( ifIndex + 1 , gotoIndex ) ) ) ; int ptgCount = this . getPtgSize ( gotoIndex ) - goto1Ptg . getSize ( ) + retval . getSize ( ) ; if ( ptgCount > ( int ) Short . MAX_VALUE ) { throw new RuntimeException ( "Ptg Size exceeds short when being specified for a goto ptg in an if" ) ; } goto1Ptg . setData ( ( short ) ( ptgCount - 1 ) ) ; } else { retval = new FuncVarPtg ( name , numArgs ) ; } return retval ; } private int Arguments ( ) { int numArgs = 0 ; if ( look != ')' ) { numArgs ++ ; Expression ( ) ; addArgumentPointer ( ) ; } while ( look == ',' || look == ';' ) { if ( look == ',' ) { Match ( ',' ) ; } else { Match ( ';' ) ; } Expression ( ) ; addArgumentPointer ( ) ; numArgs ++ ; } return numArgs ; } private void Factor ( ) { if ( look == '(' ) { Match ( '(' ) ; Expression ( ) ; Match ( ')' ) ; tokens . add ( new ParenthesisPtg ( ) ) ; } else if ( IsAlpha ( look ) ) { Ident ( ) ; } else if ( look == '"' ) { StringLiteral ( ) ; } else { String number = GetNum ( ) ; if ( look == '.' ) { Match ( '.' ) ; String decimalPart = null ; if ( IsDigit ( look ) ) number = number + "." + GetNum ( ) ; tokens . add ( new NumberPtg ( number ) ) ; } else { tokens . add ( new IntPtg ( number ) ) ; } } } private void StringLiteral ( ) { Match ( '"' ) ; StringBuffer Token = new StringBuffer ( ) ; for ( ; ; ) { if ( look == '"' ) { GetChar ( ) ; SkipWhite ( ) ; if ( look == '"' ) Token . append ( "\"" ) ; else break ; } else if ( look == 0 ) { break ; } else { Token . append ( look ) ; GetChar ( ) ; } } tokens . add ( new StringPtg ( Token . toString ( ) ) ) ; } private void Multiply ( ) { Match ( '*' ) ; Factor ( ) ; tokens . add ( new MultiplyPtg ( ) ) ; } private void Divide ( ) { Match ( '/' ) ; Factor ( ) ; tokens . add ( new DividePtg ( ) ) ; } private void Term ( ) { Factor ( ) ; while ( look == '*' || look == '/' || look == '^' || look == '&' ) { if ( look == '*' ) Multiply ( ) ; else if ( look == '/' ) Divide ( ) ; else if ( look == '^' ) Power ( ) ; else if ( look == '&' ) Concat ( ) ; } } private void Add ( ) { Match ( '+' ) ; Term ( ) ; tokens . add ( new AddPtg ( ) ) ; } private void Concat ( ) { Match ( '&' ) ; Term ( ) ; tokens . add ( new ConcatPtg ( ) ) ; } private void Equal ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new EqualPtg ( ) ) ; } private void Subtract ( ) { Match ( '-' ) ; Term ( ) ; tokens . add ( new SubtractPtg ( ) ) ; } private void Power ( ) { Match ( '^' ) ; Term ( ) ; tokens . add ( new PowerPtg ( ) ) ; } private void Expression ( ) { if ( IsAddop ( look ) ) { EmitLn ( "CLR D0" ) ; } else { Term ( ) ; } while ( IsAddop ( look ) ) { if ( look == '+' ) Add ( ) ; else if ( look == '-' ) Subtract ( ) ; } if ( look == '=' || look == '>' || look == '<' ) { if ( look == '=' ) Equal ( ) ; else if ( look == '>' ) GreaterThan ( ) ; else if ( look == '<' ) LessThan ( ) ; return ; } } private void GreaterThan ( ) { Match ( '>' ) ; if ( look == '=' ) GreaterEqual ( ) ; else { Expression ( ) ; tokens . add ( new GreaterThanPtg ( ) ) ; } } private void LessThan ( ) { Match ( '<' ) ; if ( look == '=' ) LessEqual ( ) ; else if ( look == '>' ) NotEqual ( ) ; else { Expression ( ) ; tokens . add ( new LessThanPtg ( ) ) ; } } private void GreaterEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new GreaterEqualPtg ( ) ) ; } private void LessEqual ( ) { Match ( '=' ) ; Expression ( ) ; tokens . add ( new LessEqualPtg ( ) ) ; } private void NotEqual ( ) { Match ( '>' ) ; Expression ( ) ; tokens . add ( new NotEqualPtg ( ) ) ; } private void init ( ) { GetChar ( ) ; SkipWhite ( ) ; } public void parse ( ) { synchronized ( tokens ) { init ( ) ; Expression ( ) ; } } public Ptg [ ] getRPNPtg ( ) { return getRPNPtg ( FORMULA_TYPE_CELL ) ; } public Ptg [ ] getRPNPtg ( int formulaType ) { Node node = createTree ( ) ; setRootLevelRVA ( node , formulaType ) ; setParameterRVA ( node , formulaType ) ; return ( Ptg [ ] ) tokens . toArray ( new Ptg [ 0 ] ) ; } private void setRootLevelRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( formulaType == this . FORMULA_TYPE_NAMEDRANGE ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } private void setParameterRVA ( Node n , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg ) { int numOperands = n . getNumChildren ( ) ; for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , ( ( AbstractFunctionPtg ) p ) . getParameterClass ( i ) , formulaType ) ; if ( n . getChild ( i ) . getValue ( ) instanceof AbstractFunctionPtg ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setParameterRVA ( n . getChild ( i ) , formulaType ) ; } } } private void setParameterRVA ( Node n , int expectedClass , int formulaType ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( expectedClass == Ptg . CLASS_REF ) { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_REF ) { setClass ( n , Ptg . CLASS_REF ) ; } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_ARRAY ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } } else if ( expectedClass == Ptg . CLASS_VALUE ) { if ( formulaType == FORMULA_TYPE_NAMEDRANGE ) { setClass ( n , Ptg . CLASS_ARRAY ) ; } else { setClass ( n , Ptg . CLASS_VALUE ) ; } } else { if ( p . getDefaultOperandClass ( ) == Ptg . CLASS_VALUE && ( formulaType == FORMULA_TYPE_CELL || formulaType == FORMULA_TYPE_SHARED ) ) { setClass ( n , Ptg . CLASS_VALUE ) ; } else { setClass ( n , Ptg . CLASS_ARRAY ) ; } } } private void setClass ( Node n , byte theClass ) { Ptg p = ( Ptg ) n . getValue ( ) ; if ( p instanceof AbstractFunctionPtg || ! ( p instanceof OperationPtg ) ) { p . setClass ( theClass ) ; } else { for ( int i = 0 ; i < n . getNumChildren ( ) ; i ++ ) { setClass ( n . getChild ( i ) , theClass ) ; } } } public static String toFormulaString ( Workbook book , List lptgs ) { String retval = null ; if ( lptgs == null || lptgs . size ( ) == 0 ) return "#NAME" ; Ptg [ ] ptgs = new Ptg [ lptgs . size ( ) ] ; ptgs = ( Ptg [ ] ) lptgs . toArray ( ptgs ) ; retval = toFormulaString ( book , ptgs ) ; return retval ; } public static String toFormulaString ( Workbook book , Ptg [ ] ptgs ) { if ( ptgs == null || ptgs . length == 0 ) return "#NAME" ; java . util . Stack stack = new java . util . Stack ( ) ; AttrPtg ifptg = null ; stack . push ( ptgs [ 0 ] . toFormulaString ( book ) ) ; for ( int i = 1 ; i < ptgs . length ; i ++ ) { if ( ! ( ptgs [ i ] instanceof OperationPtg ) ) { stack . push ( ptgs [ i ] . toFormulaString ( book ) ) ; continue ; } if ( ptgs [ i ] instanceof AttrPtg && ( ( AttrPtg ) ptgs [ i ] ) . isOptimizedIf ( ) ) { ifptg = ( AttrPtg ) ptgs [ i ] ; continue ; } final OperationPtg o = ( OperationPtg ) ptgs [ i ] ; final String [ ] operands = new String [ o . getNumberOfOperands ( ) ] ; for ( int j = operands . length ; j > 0 ; j -- ) { operands [ j - 1 ] = ( String ) stack . pop ( ) ; } stack . push ( o . toFormulaString ( operands ) ) ; if ( ! ( o instanceof AbstractFunctionPtg ) ) continue ; final AbstractFunctionPtg f = ( AbstractFunctionPtg ) o ; final String fname = f . getName ( ) ; if ( fname == null ) continue ; if ( ( ifptg != null ) && ( fname . equals ( "specialflag" ) ) ) { stack . push ( ifptg . toFormulaString ( new String [ ] { ( String ) stack . pop ( ) } ) ) ; continue ; } if ( fname . equals ( "externalflag" ) ) { final String top = ( String ) stack . pop ( ) ; final int paren = top . indexOf ( '(' ) ; final int comma = top . indexOf ( ',' ) ; if ( comma == - 1 ) { final int rparen = top . indexOf ( ')' ) ; stack . push ( top . substring ( paren + 1 , rparen ) + "()" ) ; } else { stack . push ( top . substring ( paren + 1 , comma ) + '(' + top . substring ( comma + 1 ) ) ; } } } return ( String ) stack . pop ( ) ; } private Node createTree ( ) { java . util . Stack stack = new java . util . Stack ( ) ; int numPtgs = tokens . size ( ) ; OperationPtg o ; int numOperands ; Node [ ] operands ; for ( int i = 0 ; i < numPtgs ; i ++ ) { if ( tokens . get ( i ) instanceof OperationPtg ) { o = ( OperationPtg ) tokens . get ( i ) ; numOperands = o . getNumberOfOperands ( ) ; operands = new Node [ numOperands ] ; for ( int j = 0 ; j < numOperands ; j ++ ) { operands [ numOperands - j - 1 ] = ( Node ) stack . pop ( ) ; } Node result = new Node ( o ) ; result . setChildren ( operands ) ; stack . push ( result ) ; } else { stack . push ( new Node ( ( Ptg ) tokens . get ( i ) ) ) ; } } return ( Node ) stack . pop ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { buf . append ( ( ( Ptg ) tokens . get ( i ) ) . toFormulaString ( book ) ) ; buf . append ( ' ' ) ; } return buf . toString ( ) ; } } class Node { private Ptg value = null ; private Node [ ] children = new Node [ 0 ] ; private int numChild = 0 ; public Node ( Ptg val ) { value = val ; } public void setChildren ( Node [ ] child ) { children = child ; numChild = child . length ; } public int getNumChildren ( ) { return numChild ; } public Node getChild ( int number ) { return children [ number ] ; } public Ptg getValue ( ) { return value ; } } 	1	['54', '1', '0', '32', '140', '651', '3', '29', '7', '0.766925638', '1806', '0.705882353', '1', '0', '0.174004193', '0', '0', '32.12962963', '14', '3.0556', '2']
package org . apache . poi . hpsf ; import java . util . * ; import org . apache . poi . util . LittleEndian ; public class Property { private static int CP_UNICODE = 1200 ; private int id ; public int getID ( ) { return id ; } private long type ; public long getType ( ) { return type ; } private Object value ; public Object getValue ( ) { return value ; } public Property ( final int id , final byte [ ] src , final long offset , int length , int codepage ) { this . id = id ; if ( id == 0 ) { value = readDictionary ( src , offset , length , codepage ) ; return ; } int o = ( int ) offset ; type = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; try { value = TypeReader . read ( src , o , length , ( int ) type ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; value = "*** null ***" ; } } protected Map readDictionary ( final byte [ ] src , final long offset , final int length , final int codepage ) { if ( offset < 0 || offset > src . length ) throw new HPSFRuntimeException ( "Illegal offset " + offset + " while HPSF stream contains " + length + " bytes." ) ; int o = ( int ) offset ; final long nrEntries = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; final Map m = new HashMap ( ( int ) nrEntries , ( float ) 1.0 ) ; for ( int i = 0 ; i < nrEntries ; i ++ ) { final Long id = new Long ( LittleEndian . getUInt ( src , o ) ) ; o += LittleEndian . INT_SIZE ; long sLength = LittleEndian . getUInt ( src , o ) ; o += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) sLength ) ; for ( int j = 0 ; j < sLength ; j ++ ) if ( codepage == CP_UNICODE ) { final int i1 = o + ( j * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } else b . append ( ( char ) src [ o + j ] ) ; while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; if ( codepage == CP_UNICODE ) { if ( sLength % 2 == 1 ) sLength ++ ; o += ( sLength + sLength ) ; } else o += sLength ; m . put ( id , b . toString ( ) ) ; } return m ; } } 	1	['6', '1', '0', '5', '25', '7', '2', '3', '4', '0.75', '230', '1', '0', '0', '0.55', '0', '0', '36.66666667', '9', '2', '2']
package org . apache . poi . hssf . dev ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . hssf . eventmodel . * ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . record . Record ; public class EFBiffViewer { String file ; public EFBiffViewer ( ) { } public void run ( ) throws IOException { FileInputStream fin = new FileInputStream ( file ) ; POIFSFileSystem poifs = new POIFSFileSystem ( fin ) ; InputStream din = poifs . createDocumentInputStream ( "Workbook" ) ; HSSFRequest req = new HSSFRequest ( ) ; req . addListenerForAllRecords ( new HSSFListener ( ) { public void processRecord ( Record rec ) { System . out . println ( rec . toString ( ) ) ; } } ) ; HSSFEventFactory factory = new HSSFEventFactory ( ) ; factory . processEvents ( req , din ) ; } public void setFile ( String file ) { this . file = file ; } public static void main ( String [ ] args ) { if ( ( args . length == 1 ) && ! args [ 0 ] . equals ( "--help" ) ) { try { EFBiffViewer viewer = new EFBiffViewer ( ) ; viewer . setFile ( args [ 0 ] ) ; viewer . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( "EFBiffViewer" ) ; System . out . println ( "Outputs biffview of records based on HSSFEventFactory" ) ; System . out . println ( "usage: java org.apache.poi.hssf.dev.EBBiffViewer " + "filename" ) ; } } } 	1	['4', '1', '0', '6', '16', '4', '1', '6', '4', '0.333333333', '82', '0', '0', '0', '0.416666667', '0', '0', '19.25', '3', '1.25', '1']
package org . apache . poi . util ; import java . io . * ; public class HexDump { public static final String EOL = System . getProperty ( "line.separator" ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index , final int length ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( data . length != 0 && index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( data . length == 0 ) return ; if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; int data_length = Math . min ( data . length , index + length ) ; for ( int j = index ; j < data_length ; j += 16 ) { int chars_read = data_length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { dump ( data , offset , stream , index , data . length - index ) ; } public static String dump ( final byte [ ] data , final long offset , final int index ) { StringBuffer buffer ; if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } long display_offset = offset + index ; buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; display_offset += chars_read ; } return buffer . toString ( ) ; } private static String dump ( final long value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { buf . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return buf . toString ( ) ; } private static String dump ( final byte value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { buf . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return buf . toString ( ) ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } public static void dump ( InputStream in , PrintStream out , int start , int bytesToDump ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; if ( bytesToDump == - 1 ) { int c = in . read ( ) ; while ( c != - 1 ) { buf . write ( c ) ; c = in . read ( ) ; } } else { int bytesRemaining = bytesToDump ; while ( bytesRemaining -- > 0 ) { int c = in . read ( ) ; if ( c == - 1 ) break ; else buf . write ( c ) ; } } byte [ ] data = buf . toByteArray ( ) ; dump ( data , 0 , out , start , data . length ) ; } } 	1	['13', '1', '0', '41', '35', '60', '41', '0', '8', '0.333333333', '618', '0.666666667', '0', '0', '0.212962963', '0', '0', '46.30769231', '10', '1.8462', '1']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	1	['8', '1', '0', '7', '17', '0', '2', '5', '7', '0.571428571', '134', '1', '2', '0', '0.458333333', '0', '0', '15.375', '3', '1.375', '1']
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	1	['9', '1', '0', '10', '20', '0', '10', '0', '9', '0.25', '294', '1', '0', '0', '0.311111111', '1', '1', '31.44444444', '7', '1.8889', '1']
package org . apache . poi . hssf . record . formula ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . model . Workbook ; public abstract class Ptg { public static Ptg createPtg ( byte [ ] data , int offset ) { byte id = data [ offset + 0 ] ; Ptg retval = null ; final byte valueRef = ReferencePtg . sid + 0x20 ; final byte arrayRef = ReferencePtg . sid + 0x40 ; final byte valueFunc = FuncPtg . sid + 0x20 ; final byte arrayFunc = FuncPtg . sid + 0x40 ; final byte valueFuncVar = FuncVarPtg . sid + 0x20 ; final byte arrayFuncVar = FuncVarPtg . sid + 0x40 ; final byte valueArea = AreaPtg . sid + 0x20 ; final byte arrayArea = AreaPtg . sid + 0x40 ; switch ( id ) { case AddPtg . sid : retval = new AddPtg ( data , offset ) ; break ; case SubtractPtg . sid : retval = new SubtractPtg ( data , offset ) ; break ; case BoolPtg . sid : retval = new BoolPtg ( data , offset ) ; break ; case IntPtg . sid : retval = new IntPtg ( data , offset ) ; break ; case DividePtg . sid : retval = new DividePtg ( data , offset ) ; break ; case MultiplyPtg . sid : retval = new MultiplyPtg ( data , offset ) ; break ; case PowerPtg . sid : retval = new PowerPtg ( data , offset ) ; break ; case EqualPtg . sid : retval = new EqualPtg ( data , offset ) ; break ; case GreaterThanPtg . sid : retval = new GreaterThanPtg ( data , offset ) ; break ; case LessThanPtg . sid : retval = new LessThanPtg ( data , offset ) ; break ; case LessEqualPtg . sid : retval = new LessEqualPtg ( data , offset ) ; break ; case GreaterEqualPtg . sid : retval = new GreaterEqualPtg ( data , offset ) ; break ; case NotEqualPtg . sid : retval = new NotEqualPtg ( data , offset ) ; break ; case ConcatPtg . sid : retval = new ConcatPtg ( data , offset ) ; break ; case AreaPtg . sid : retval = new AreaPtg ( data , offset ) ; break ; case valueArea : retval = new AreaPtg ( data , offset ) ; break ; case arrayArea : retval = new AreaPtg ( data , offset ) ; break ; case MemErrPtg . sid : case MemErrPtg . sid + 0x20 : case MemErrPtg . sid + 0x40 : retval = new MemErrPtg ( data , offset ) ; break ; case AttrPtg . sid : retval = new AttrPtg ( data , offset ) ; break ; case ReferencePtg . sid : retval = new ReferencePtg ( data , offset ) ; break ; case valueRef : retval = new ReferencePtg ( data , offset ) ; break ; case arrayRef : retval = new ReferencePtg ( data , offset ) ; break ; case ParenthesisPtg . sid : retval = new ParenthesisPtg ( data , offset ) ; break ; case MemFuncPtg . sid : retval = new MemFuncPtg ( data , offset ) ; break ; case UnionPtg . sid : retval = new UnionPtg ( data , offset ) ; break ; case FuncPtg . sid : retval = new FuncPtg ( data , offset ) ; break ; case valueFunc : retval = new FuncPtg ( data , offset ) ; break ; case arrayFunc : retval = new FuncPtg ( data , offset ) ; break ; case FuncVarPtg . sid : retval = new FuncVarPtg ( data , offset ) ; break ; case valueFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case arrayFuncVar : retval = new FuncVarPtg ( data , offset ) ; break ; case NumberPtg . sid : retval = new NumberPtg ( data , offset ) ; break ; case StringPtg . sid : retval = new StringPtg ( data , offset ) ; break ; case NamePtg . sid : case NamePtg . sid + 0x20 : case NamePtg . sid + 0x40 : retval = new NamePtg ( data , offset ) ; break ; case NameXPtg . sid : case NameXPtg . sid + 0x20 : case NameXPtg . sid + 0x40 : retval = new NameXPtg ( data , offset ) ; break ; case ExpPtg . sid : retval = new ExpPtg ( data , offset ) ; break ; case Area3DPtg . sid : case Area3DPtg . sid + 0x20 : case Area3DPtg . sid + 0x40 : retval = new Area3DPtg ( data , offset ) ; break ; case Ref3DPtg . sid : case Ref3DPtg . sid + 0x20 : case Ref3DPtg . sid + 0x40 : retval = new Ref3DPtg ( data , offset ) ; break ; case MissingArgPtg . sid : retval = new MissingArgPtg ( data , offset ) ; break ; case UnaryPlusPtg . sid : retval = new UnaryPlusPtg ( data , offset ) ; break ; case UnaryMinusPtg . sid : retval = new UnaryMinusPtg ( data , offset ) ; break ; default : throw new java . lang . UnsupportedOperationException ( Integer . toHexString ( ( int ) id ) + " (" + ( int ) id + ")" ) ; } if ( id > 0x60 ) { retval . setClass ( CLASS_ARRAY ) ; } else if ( id > 0x40 ) { retval . setClass ( CLASS_VALUE ) ; } else retval . setClass ( CLASS_REF ) ; return retval ; } public abstract int getSize ( ) ; public final byte [ ] getBytes ( ) { int size = getSize ( ) ; byte [ ] bytes = new byte [ size ] ; writeBytes ( bytes , 0 ) ; return bytes ; } public abstract void writeBytes ( byte [ ] array , int offset ) ; public abstract String toFormulaString ( Workbook book ) ; public String toDebugString ( ) { byte [ ] ba = new byte [ getSize ( ) ] ; String retval = null ; writeBytes ( ba , 0 ) ; try { retval = org . apache . poi . util . HexDump . dump ( ba , 0 , 0 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return retval ; } public String toString ( ) { return this . getClass ( ) . toString ( ) ; } public static final byte CLASS_REF = 0x00 ; public static final byte CLASS_VALUE = 0x20 ; public static final byte CLASS_ARRAY = 0x40 ; protected byte ptgClass = CLASS_REF ; public void setClass ( byte thePtgClass ) { ptgClass = thePtgClass ; } public byte getPtgClass ( ) { return ptgClass ; } public abstract byte getDefaultOperandClass ( ) ; public abstract Object clone ( ) ; } 	1	['12', '1', '16', '46', '56', '60', '25', '35', '12', '1', '415', '0.25', '0', '0', '0.283333333', '0', '0', '33.25', '4', '1.1667', '1']
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; public abstract class AbortableHSSFListener implements HSSFListener { public void processRecord ( Record record ) { } public abstract short abortableProcessRecord ( Record record ) throws HSSFUserException ; } 	1	['3', '1', '0', '4', '4', '3', '1', '3', '3', '2', '7', '0', '0', '0', '0.833333333', '0', '0', '1.333333333', '1', '0.6667', '1']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . SheetReferences ; public class HSSFName { private Workbook book ; private NameRecord name ; protected HSSFName ( Workbook book , NameRecord name ) { this . book = book ; this . name = name ; } public String getSheetName ( ) { String result ; short indexToExternSheet = name . getExternSheetNumber ( ) ; result = book . findSheetNameFromExternSheet ( indexToExternSheet ) ; return result ; } public String getNameName ( ) { String result = name . getNameText ( ) ; return result ; } public void setNameName ( String nameName ) { name . setNameText ( nameName ) ; name . setNameTextLength ( ( byte ) nameName . length ( ) ) ; } public String getReference ( ) { String result ; result = name . getAreaReference ( book ) ; return result ; } private void setSheetName ( String sheetName ) { int sheetNumber = book . getSheetIndex ( sheetName ) ; short externSheetNumber = book . checkExternSheet ( sheetNumber ) ; name . setExternSheetNumber ( externSheetNumber ) ; } public void setReference ( String ref ) { RangeAddress ra = new RangeAddress ( ref ) ; String sheetName = ra . getSheetName ( ) ; if ( ra . hasSheetName ( ) ) { setSheetName ( sheetName ) ; } name . setAreaReference ( ref ) ; } } 	1	['7', '1', '0', '4', '22', '0', '1', '3', '5', '0.166666667', '88', '1', '2', '0', '0.428571429', '0', '0', '11.28571429', '2', '1', '1']
package org . apache . poi . hssf . record . formula ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . util . RangeAddress ; import org . apache . poi . hssf . util . AreaReference ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . hssf . util . SheetReferences ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . util . BitField ; public class Area3DPtg extends Ptg { public final static byte sid = 0x3b ; private final static int SIZE = 11 ; private short field_1_index_extern_sheet ; private short field_2_first_row ; private short field_3_last_row ; private short field_4_first_column ; private short field_5_last_column ; private BitField rowRelative = new BitField ( 0x8000 ) ; private BitField colRelative = new BitField ( 0x4000 ) ; public Area3DPtg ( ) { } public Area3DPtg ( String arearef , short externIdx ) { setArea ( arearef ) ; setExternSheetIndex ( externIdx ) ; } public Area3DPtg ( byte [ ] data , int offset ) { offset ++ ; field_1_index_extern_sheet = LittleEndian . getShort ( data , 0 + offset ) ; field_2_first_row = LittleEndian . getShort ( data , 2 + offset ) ; field_3_last_row = LittleEndian . getShort ( data , 4 + offset ) ; field_4_first_column = LittleEndian . getShort ( data , 6 + offset ) ; field_5_last_column = LittleEndian . getShort ( data , 8 + offset ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "AreaPtg\n" ) ; buffer . append ( "Index to Extern Sheet = " + getExternSheetIndex ( ) ) . append ( "\n" ) ; buffer . append ( "firstRow = " + getFirstRow ( ) ) . append ( "\n" ) ; buffer . append ( "lastRow  = " + getLastRow ( ) ) . append ( "\n" ) ; buffer . append ( "firstCol = " + getFirstColumn ( ) ) . append ( "\n" ) ; buffer . append ( "lastCol  = " + getLastColumn ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel= " + isFirstRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRowRel = " + isLastRowRelative ( ) ) . append ( "\n" ) ; buffer . append ( "firstColRel   = " + isFirstColRelative ( ) ) . append ( "\n" ) ; buffer . append ( "lastColRel    = " + isLastColRelative ( ) ) . append ( "\n" ) ; return buffer . toString ( ) ; } public void writeBytes ( byte [ ] array , int offset ) { array [ 0 + offset ] = ( byte ) ( sid + ptgClass ) ; LittleEndian . putShort ( array , 1 + offset , getExternSheetIndex ( ) ) ; LittleEndian . putShort ( array , 3 + offset , getFirstRow ( ) ) ; LittleEndian . putShort ( array , 5 + offset , getLastRow ( ) ) ; LittleEndian . putShort ( array , 7 + offset , getFirstColumnRaw ( ) ) ; LittleEndian . putShort ( array , 9 + offset , getLastColumnRaw ( ) ) ; } public int getSize ( ) { return SIZE ; } public short getExternSheetIndex ( ) { return field_1_index_extern_sheet ; } public void setExternSheetIndex ( short index ) { field_1_index_extern_sheet = index ; } public short getFirstRow ( ) { return field_2_first_row ; } public void setFirstRow ( short row ) { field_2_first_row = row ; } public short getLastRow ( ) { return field_3_last_row ; } public void setLastRow ( short row ) { field_3_last_row = row ; } public short getFirstColumn ( ) { return ( short ) ( field_4_first_column & 0xFF ) ; } public short getFirstColumnRaw ( ) { return field_4_first_column ; } public boolean isFirstRowRelative ( ) { return rowRelative . isSet ( field_4_first_column ) ; } public boolean isFirstColRelative ( ) { return colRelative . isSet ( field_4_first_column ) ; } public void setFirstColumn ( short column ) { field_4_first_column &= 0xFF00 ; field_4_first_column |= column & 0xFF ; } public void setFirstColumnRaw ( short column ) { field_4_first_column = column ; } public short getLastColumn ( ) { return ( short ) ( field_5_last_column & 0xFF ) ; } public short getLastColumnRaw ( ) { return field_5_last_column ; } public boolean isLastRowRelative ( ) { return rowRelative . isSet ( field_5_last_column ) ; } public boolean isLastColRelative ( ) { return colRelative . isSet ( field_5_last_column ) ; } public void setLastColumn ( short column ) { field_5_last_column &= 0xFF00 ; field_5_last_column |= column & 0xFF ; } public void setLastColumnRaw ( short column ) { field_5_last_column = column ; } public void setFirstRowRelative ( boolean rel ) { field_4_first_column = rowRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setFirstColRelative ( boolean rel ) { field_4_first_column = colRelative . setShortBoolean ( field_4_first_column , rel ) ; } public void setLastRowRelative ( boolean rel ) { field_5_last_column = rowRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setLastColRelative ( boolean rel ) { field_5_last_column = colRelative . setShortBoolean ( field_5_last_column , rel ) ; } public void setArea ( String ref ) { AreaReference ar = new AreaReference ( ref ) ; setFirstRow ( ( short ) ar . getCells ( ) [ 0 ] . getRow ( ) ) ; setFirstColumn ( ( short ) ar . getCells ( ) [ 0 ] . getCol ( ) ) ; setLastRow ( ( short ) ar . getCells ( ) [ 1 ] . getRow ( ) ) ; setLastColumn ( ( short ) ar . getCells ( ) [ 1 ] . getCol ( ) ) ; setFirstColRelative ( ! ar . getCells ( ) [ 0 ] . isColAbsolute ( ) ) ; setLastColRelative ( ! ar . getCells ( ) [ 1 ] . isColAbsolute ( ) ) ; setFirstRowRelative ( ! ar . getCells ( ) [ 0 ] . isRowAbsolute ( ) ) ; setLastRowRelative ( ! ar . getCells ( ) [ 1 ] . isRowAbsolute ( ) ) ; } public String toFormulaString ( Workbook book ) { SheetReferences refs = book == null ? null : book . getSheetReferences ( ) ; StringBuffer retval = new StringBuffer ( ) ; if ( refs != null ) { retval . append ( refs . getSheetName ( this . field_1_index_extern_sheet ) ) ; retval . append ( '!' ) ; } retval . append ( ( new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , ! isFirstRowRelative ( ) , ! isFirstColRelative ( ) ) ) . toString ( ) ) ; retval . append ( ':' ) ; retval . append ( ( new CellReference ( getLastRow ( ) , getLastColumn ( ) , ! isLastRowRelative ( ) , ! isLastColRelative ( ) ) ) . toString ( ) ) ; return retval . toString ( ) ; } public byte getDefaultOperandClass ( ) { return Ptg . CLASS_REF ; } public Object clone ( ) { Area3DPtg ptg = new Area3DPtg ( ) ; ptg . field_1_index_extern_sheet = field_1_index_extern_sheet ; ptg . field_2_first_row = field_2_first_row ; ptg . field_3_last_row = field_3_last_row ; ptg . field_4_first_column = field_4_first_column ; ptg . field_5_last_column = field_5_last_column ; ptg . setClass ( ptgClass ) ; return ptg ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Area3DPtg ) ) return false ; final Area3DPtg area3DPtg = ( Area3DPtg ) o ; if ( field_1_index_extern_sheet != area3DPtg . field_1_index_extern_sheet ) return false ; if ( field_2_first_row != area3DPtg . field_2_first_row ) return false ; if ( field_3_last_row != area3DPtg . field_3_last_row ) return false ; if ( field_4_first_column != area3DPtg . field_4_first_column ) return false ; if ( field_5_last_column != area3DPtg . field_5_last_column ) return false ; return true ; } public int hashCode ( ) { int result ; result = ( int ) field_1_index_extern_sheet ; result = 29 * result + ( int ) field_2_first_row ; result = 29 * result + ( int ) field_3_last_row ; result = 29 * result + ( int ) field_4_first_column ; result = 29 * result + ( int ) field_5_last_column ; return result ; } } 	1	['34', '2', '0', '10', '60', '187', '4', '7', '34', '0.747474747', '728', '0.888888889', '2', '0.184210526', '0.198529412', '2', '3', '20.14705882', '8', '1.4118', '1']
package org . apache . poi . hssf . record ; import org . apache . poi . util . LittleEndian ; public class CodepageRecord extends Record { public final static short sid = 0x42 ; private short field_1_codepage ; public final static short CODEPAGE = ( short ) 0x4b0 ; public CodepageRecord ( ) { } public CodepageRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public CodepageRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A CODEPAGE RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_codepage = LittleEndian . getShort ( data , 0 + offset ) ; } public void setCodepage ( short cp ) { field_1_codepage = cp ; } public short getCodepage ( ) { return field_1_codepage ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[CODEPAGE]\n" ) ; buffer . append ( "    .codepage        = " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/CODEPAGE]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( ( short ) 0x02 ) ) ; LittleEndian . putShort ( data , 4 + offset , getCodepage ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 6 ; } public short getSid ( ) { return this . sid ; } } 	1	['11', '2', '0', '5', '21', '49', '2', '3', '9', '0.933333333', '107', '0.333333333', '0', '0.578947368', '0.522727273', '1', '6', '8.454545455', '2', '0.8182', '1']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . CellValueRecordInterface ; import org . apache . poi . hssf . record . RowRecord ; import java . util . HashMap ; import java . util . Iterator ; public class HSSFRow implements Comparable { public final static int INITIAL_CAPACITY = 5 ; private int rowNum ; private HashMap cells ; private RowRecord row ; private Workbook book ; private Sheet sheet ; protected HSSFRow ( ) { } protected HSSFRow ( Workbook book , Sheet sheet , int rowNum ) { this . rowNum = rowNum ; cells = new HashMap ( 10 ) ; this . book = book ; this . sheet = sheet ; row = new RowRecord ( ) ; row . setHeight ( ( short ) 0xff ) ; row . setLastCol ( ( short ) - 1 ) ; row . setFirstCol ( ( short ) - 1 ) ; setRowNum ( rowNum ) ; } protected HSSFRow ( Workbook book , Sheet sheet , RowRecord record ) { cells = new HashMap ( ) ; this . book = book ; this . sheet = sheet ; row = record ; setRowNum ( record . getRowNumber ( ) ) ; } public HSSFCell createCell ( short column ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public HSSFCell createCell ( short column , int type ) { HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , column , type ) ; addCell ( cell ) ; sheet . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; } public void removeCell ( HSSFCell cell ) { CellValueRecordInterface cval = cell . getCellValueRecord ( ) ; sheet . removeValueRecord ( getRowNum ( ) , cval ) ; cells . remove ( new Integer ( cell . getCellNum ( ) ) ) ; if ( cell . getCellNum ( ) == row . getLastCol ( ) ) { row . setLastCol ( findLastCell ( row . getLastCol ( ) ) ) ; } if ( cell . getCellNum ( ) == row . getFirstCol ( ) ) { row . setFirstCol ( findFirstCell ( row . getFirstCol ( ) ) ) ; } } protected HSSFCell createCellFromRecord ( CellValueRecordInterface cell ) { HSSFCell hcell = new HSSFCell ( book , sheet , getRowNum ( ) , cell ) ; addCell ( hcell ) ; return hcell ; } public void setRowNum ( int rowNum ) { this . rowNum = rowNum ; if ( row != null ) { row . setRowNumber ( rowNum ) ; } } public int getRowNum ( ) { return rowNum ; } private void addCell ( HSSFCell cell ) { if ( row . getFirstCol ( ) == - 1 ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( row . getLastCol ( ) == - 1 ) { row . setLastCol ( cell . getCellNum ( ) ) ; } cells . put ( new Integer ( cell . getCellNum ( ) ) , cell ) ; if ( cell . getCellNum ( ) < row . getFirstCol ( ) ) { row . setFirstCol ( cell . getCellNum ( ) ) ; } if ( cell . getCellNum ( ) > row . getLastCol ( ) ) { row . setLastCol ( cell . getCellNum ( ) ) ; } } public HSSFCell getCell ( short cellnum ) { return ( HSSFCell ) cells . get ( new Integer ( cellnum ) ) ; } public short getFirstCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getFirstCol ( ) ; } public short getLastCellNum ( ) { if ( getPhysicalNumberOfCells ( ) == 0 ) return - 1 ; else return row . getLastCol ( ) ; } public int getPhysicalNumberOfCells ( ) { if ( cells == null ) { return 0 ; } return cells . size ( ) ; } public void setHeight ( short height ) { row . setBadFontHeight ( true ) ; row . setHeight ( height ) ; } public void setHeightInPoints ( float height ) { row . setBadFontHeight ( true ) ; row . setHeight ( ( short ) ( height * 20 ) ) ; } public short getHeight ( ) { return row . getHeight ( ) ; } public float getHeightInPoints ( ) { return ( row . getHeight ( ) / 20 ) ; } protected RowRecord getRowRecord ( ) { return row ; } private short findLastCell ( short lastcell ) { short cellnum = ( short ) ( lastcell - 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum >= 0 ) { r = getCell ( -- cellnum ) ; } return cellnum ; } private short findFirstCell ( short firstcell ) { short cellnum = ( short ) ( firstcell + 1 ) ; HSSFCell r = getCell ( cellnum ) ; while ( r == null && cellnum <= getLastCellNum ( ) ) { r = getCell ( ++ cellnum ) ; } if ( cellnum > getLastCellNum ( ) ) return - 1 ; return cellnum ; } public Iterator cellIterator ( ) { return cells . values ( ) . iterator ( ) ; } public int compareTo ( Object obj ) { HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return 0 ; } if ( this . getRowNum ( ) < loc . getRowNum ( ) ) { return - 1 ; } if ( this . getRowNum ( ) > loc . getRowNum ( ) ) { return 1 ; } return - 1 ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof HSSFRow ) ) { return false ; } HSSFRow loc = ( HSSFRow ) obj ; if ( this . getRowNum ( ) == loc . getRowNum ( ) ) { return true ; } return false ; } } 	1	['24', '1', '0', '8', '51', '86', '3', '5', '16', '0.673913043', '447', '0.833333333', '3', '0', '0.183333333', '0', '0', '17.375', '5', '1.7083', '1']
package org . apache . poi . hssf . usermodel ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Stack ; import org . apache . poi . hssf . eventmodel . EventRecordFactory ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BackupRecord ; import org . apache . poi . hssf . record . ExtendedFormatRecord ; import org . apache . poi . hssf . record . FontRecord ; import org . apache . poi . hssf . record . NameRecord ; import org . apache . poi . hssf . record . RecordFactory ; import org . apache . poi . hssf . record . SSTRecord ; import org . apache . poi . hssf . record . UnknownRecord ; import org . apache . poi . hssf . record . WindowTwoRecord ; import org . apache . poi . hssf . record . formula . Area3DPtg ; import org . apache . poi . hssf . record . formula . MemFuncPtg ; import org . apache . poi . hssf . record . formula . UnionPtg ; import org . apache . poi . hssf . util . CellReference ; import org . apache . poi . poifs . filesystem . DirectoryEntry ; import org . apache . poi . poifs . filesystem . DocumentEntry ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . Entry ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; public class HSSFWorkbook extends java . lang . Object { private static final int DEBUG = POILogger . DEBUG ; public final static int INITIAL_CAPACITY = 3 ; private Workbook workbook ; private ArrayList sheets ; private ArrayList names ; private boolean preserveNodes ; private POIFSFileSystem poifs ; private HSSFDataFormat formatter ; private static POILogger log = POILogFactory . getLogger ( HSSFWorkbook . class ) ; public HSSFWorkbook ( ) { workbook = Workbook . createWorkbook ( ) ; sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; } public HSSFWorkbook ( POIFSFileSystem fs ) throws IOException { this ( fs , true ) ; } public HSSFWorkbook ( POIFSFileSystem fs , boolean preserveNodes ) throws IOException { this . preserveNodes = preserveNodes ; if ( preserveNodes ) { this . poifs = fs ; } sheets = new ArrayList ( INITIAL_CAPACITY ) ; names = new ArrayList ( INITIAL_CAPACITY ) ; InputStream stream = fs . createDocumentInputStream ( "Workbook" ) ; EventRecordFactory factory = new EventRecordFactory ( ) ; List records = RecordFactory . createRecords ( stream ) ; workbook = Workbook . createWorkbook ( records ) ; setPropertiesFromWorkbook ( workbook ) ; int recOffset = workbook . getNumRecords ( ) ; int sheetNum = 0 ; while ( recOffset < records . size ( ) ) { Sheet sheet = Sheet . createSheet ( records , sheetNum ++ , recOffset ) ; recOffset = sheet . getEofLoc ( ) + 1 ; sheet . convertLabelRecords ( workbook ) ; HSSFSheet hsheet = new HSSFSheet ( workbook , sheet ) ; sheets . add ( hsheet ) ; } for ( int i = 0 ; i < workbook . getNumNames ( ) ; ++ i ) { HSSFName name = new HSSFName ( workbook , workbook . getNameRecord ( i ) ) ; names . add ( name ) ; } } public HSSFWorkbook ( InputStream s ) throws IOException { this ( s , true ) ; } public HSSFWorkbook ( InputStream s , boolean preserveNodes ) throws IOException { this ( new POIFSFileSystem ( s ) , preserveNodes ) ; } private void setPropertiesFromWorkbook ( Workbook book ) { this . workbook = book ; } public void setSheetOrder ( String sheetname , int pos ) { workbook . setSheetOrder ( sheetname , pos ) ; } public final static byte ENCODING_COMPRESSED_UNICODE = 0 ; public final static byte ENCODING_UTF_16 = 1 ; public void setSheetName ( int sheet , String name ) { workbook . setSheetName ( sheet , name , ENCODING_COMPRESSED_UNICODE ) ; } public void setSheetName ( int sheet , String name , short encoding ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } switch ( encoding ) { case ENCODING_COMPRESSED_UNICODE : case ENCODING_UTF_16 : break ; default : throw new RuntimeException ( "Unsupported encoding" ) ; } workbook . setSheetName ( sheet , name , encoding ) ; } public String getSheetName ( int sheet ) { if ( sheet > ( sheets . size ( ) - 1 ) ) { throw new RuntimeException ( "Sheet out of bounds" ) ; } return workbook . getSheetName ( sheet ) ; } public int getSheetIndex ( String name ) { int retval = workbook . getSheetIndex ( name ) ; return retval ; } public HSSFSheet createSheet ( ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , "Sheet" + ( sheets . size ( ) - 1 ) ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public HSSFSheet cloneSheet ( int sheetNum ) { HSSFSheet srcSheet = ( HSSFSheet ) sheets . get ( sheetNum ) ; String srcName = workbook . getSheetName ( sheetNum ) ; if ( srcSheet != null ) { HSSFSheet clonedSheet = srcSheet . cloneSheet ( workbook ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) clonedSheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; sheets . add ( clonedSheet ) ; if ( srcName . length ( ) < 28 ) { workbook . setSheetName ( sheets . size ( ) - 1 , srcName + "(2)" ) ; } else { workbook . setSheetName ( sheets . size ( ) - 1 , srcName . substring ( 0 , 28 ) + "(2)" ) ; } return clonedSheet ; } return null ; } public HSSFSheet createSheet ( String sheetname ) { HSSFSheet sheet = new HSSFSheet ( workbook ) ; sheets . add ( sheet ) ; workbook . setSheetName ( sheets . size ( ) - 1 , sheetname ) ; WindowTwoRecord windowTwo = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; windowTwo . setSelected ( sheets . size ( ) == 1 ) ; windowTwo . setPaged ( sheets . size ( ) == 1 ) ; return sheet ; } public int getNumberOfSheets ( ) { return sheets . size ( ) ; } public HSSFSheet getSheetAt ( int index ) { return ( HSSFSheet ) sheets . get ( index ) ; } public HSSFSheet getSheet ( String name ) { HSSFSheet retval = null ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { String sheetname = workbook . getSheetName ( k ) ; if ( sheetname . equals ( name ) ) { retval = ( HSSFSheet ) sheets . get ( k ) ; } } return retval ; } public void removeSheetAt ( int index ) { sheets . remove ( index ) ; workbook . removeSheet ( index ) ; } public void setBackupFlag ( boolean backupValue ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; backupRecord . setBackup ( backupValue ? ( short ) 1 : ( short ) 0 ) ; } public boolean getBackupFlag ( ) { BackupRecord backupRecord = workbook . getBackupRecord ( ) ; return ( backupRecord . getBackup ( ) == 0 ) ? false : true ; } public void setRepeatingRowsAndColumns ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { if ( startColumn == - 1 && endColumn != - 1 ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow == - 1 && endRow != - 1 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn < - 1 || startColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( endColumn < - 1 || endColumn >= 0xFF ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow < - 1 || startRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( endRow < - 1 || endRow > 65535 ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; if ( startColumn > endColumn ) throw new IllegalArgumentException ( "Invalid column range specification" ) ; if ( startRow > endRow ) throw new IllegalArgumentException ( "Invalid row range specification" ) ; HSSFSheet sheet = getSheetAt ( sheetIndex ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; boolean settingRowAndColumn = startColumn != - 1 && endColumn != - 1 && startRow != - 1 && endRow != - 1 ; boolean removingRange = startColumn == - 1 && endColumn == - 1 && startRow == - 1 && endRow == - 1 ; boolean isNewRecord = false ; NameRecord nameRecord ; nameRecord = findExistingRowColHeaderNameRecord ( sheetIndex ) ; if ( removingRange ) { if ( nameRecord != null ) workbook . removeName ( findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ) ; return ; } if ( nameRecord == null ) { nameRecord = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_TITLE , externSheetIndex + 1 ) ; isNewRecord = true ; } short definitionTextLength = settingRowAndColumn ? ( short ) 0x001a : ( short ) 0x000b ; nameRecord . setDefinitionTextLength ( definitionTextLength ) ; Stack ptgs = new Stack ( ) ; if ( settingRowAndColumn ) { MemFuncPtg memFuncPtg = new MemFuncPtg ( ) ; memFuncPtg . setLenRefSubexpression ( 23 ) ; ptgs . add ( memFuncPtg ) ; } if ( startColumn >= 0 ) { Area3DPtg area3DPtg1 = new Area3DPtg ( ) ; area3DPtg1 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg1 . setFirstColumn ( ( short ) startColumn ) ; area3DPtg1 . setLastColumn ( ( short ) endColumn ) ; area3DPtg1 . setFirstRow ( ( short ) 0 ) ; area3DPtg1 . setLastRow ( ( short ) 0xFFFF ) ; ptgs . add ( area3DPtg1 ) ; } if ( startRow >= 0 ) { Area3DPtg area3DPtg2 = new Area3DPtg ( ) ; area3DPtg2 . setExternSheetIndex ( externSheetIndex ) ; area3DPtg2 . setFirstColumn ( ( short ) 0 ) ; area3DPtg2 . setLastColumn ( ( short ) 0x00FF ) ; area3DPtg2 . setFirstRow ( ( short ) startRow ) ; area3DPtg2 . setLastRow ( ( short ) endRow ) ; ptgs . add ( area3DPtg2 ) ; } if ( settingRowAndColumn ) { UnionPtg unionPtg = new UnionPtg ( ) ; ptgs . add ( unionPtg ) ; } nameRecord . setNameDefinition ( ptgs ) ; if ( isNewRecord ) { HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; } HSSFPrintSetup printSetup = sheet . getPrintSetup ( ) ; printSetup . setValidSettings ( false ) ; WindowTwoRecord w2 = ( WindowTwoRecord ) sheet . getSheet ( ) . findFirstRecordBySid ( WindowTwoRecord . sid ) ; w2 . setPaged ( true ) ; } private NameRecord findExistingRowColHeaderNameRecord ( int sheetIndex ) { int index = findExistingRowColHeaderNameRecordIdx ( sheetIndex ) ; if ( index == - 1 ) return null ; else return ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ; } private int findExistingRowColHeaderNameRecordIdx ( int sheetIndex ) { int index = 0 ; NameRecord r = null ; while ( ( r = ( NameRecord ) workbook . findNextRecordBySid ( NameRecord . sid , index ) ) != null ) { int nameRecordSheetIndex = workbook . getSheetIndexFromExternSheetIndex ( r . getEqualsToIndexToSheet ( ) - 1 ) ; if ( isRowColHeaderRecord ( r ) && nameRecordSheetIndex == sheetIndex ) { return index ; } index ++ ; } return - 1 ; } private boolean isRowColHeaderRecord ( NameRecord r ) { return r . getOptionFlag ( ) == 0x20 && ( "" + ( ( char ) 7 ) ) . equals ( r . getNameText ( ) ) ; } public HSSFFont createFont ( ) { FontRecord font = workbook . createNewFont ( ) ; short fontindex = ( short ) ( getNumberOfFonts ( ) - 1 ) ; if ( fontindex > 3 ) { fontindex ++ ; } HSSFFont retval = new HSSFFont ( fontindex , font ) ; return retval ; } public short getNumberOfFonts ( ) { return ( short ) workbook . getNumberOfFontRecords ( ) ; } public HSSFFont getFontAt ( short idx ) { FontRecord font = workbook . getFontRecordAt ( idx ) ; HSSFFont retval = new HSSFFont ( idx , font ) ; return retval ; } public HSSFCellStyle createCellStyle ( ) { ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - 1 ) ; HSSFCellStyle style = new HSSFCellStyle ( index , xfr ) ; return style ; } public short getNumCellStyles ( ) { return ( short ) workbook . getNumExFormats ( ) ; } public HSSFCellStyle getCellStyleAt ( short idx ) { ExtendedFormatRecord xfr = workbook . getExFormatAt ( idx ) ; HSSFCellStyle style = new HSSFCellStyle ( idx , xfr ) ; return style ; } public void write ( OutputStream stream ) throws IOException { byte [ ] bytes = getBytes ( ) ; POIFSFileSystem fs = new POIFSFileSystem ( ) ; fs . createDocument ( new ByteArrayInputStream ( bytes ) , "Workbook" ) ; if ( preserveNodes ) { List excepts = new ArrayList ( 1 ) ; excepts . add ( "Workbook" ) ; copyNodes ( this . poifs , fs , excepts ) ; } fs . writeFilesystem ( stream ) ; } public byte [ ] getBytes ( ) { log . log ( DEBUG , "HSSFWorkbook.getBytes()" ) ; int wbsize = workbook . getSize ( ) ; int totalsize = wbsize ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { workbook . setSheetBof ( k , totalsize ) ; totalsize += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . getSize ( ) ; } byte [ ] retval = new byte [ totalsize ] ; int pos = workbook . serialize ( 0 , retval ) ; for ( int k = 0 ; k < sheets . size ( ) ; k ++ ) { pos += ( ( HSSFSheet ) sheets . get ( k ) ) . getSheet ( ) . serialize ( pos , retval ) ; } return retval ; } public int addSSTString ( String string ) { return workbook . addSSTString ( string ) ; } public String getSSTString ( int index ) { return workbook . getSSTString ( index ) ; } Workbook getWorkbook ( ) { return workbook ; } public int getNumberOfNames ( ) { int result = names . size ( ) ; return result ; } public HSSFName getNameAt ( int index ) { HSSFName result = ( HSSFName ) names . get ( index ) ; return result ; } public String getNameName ( int index ) { String result = getNameAt ( index ) . getNameName ( ) ; return result ; } public void setPrintArea ( int sheetIndex , String reference ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) name = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; short externSheetIndex = getWorkbook ( ) . checkExternSheet ( sheetIndex ) ; name . setExternSheetNumber ( externSheetIndex ) ; name . setAreaReference ( reference ) ; } public void setPrintArea ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { CellReference cell = new CellReference ( startRow , startColumn , true , true ) ; String reference = cell . toString ( ) ; cell = new CellReference ( endRow , endColumn , true , true ) ; reference = reference + ":" + cell . toString ( ) ; setPrintArea ( sheetIndex , reference ) ; } public String getPrintArea ( int sheetIndex ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) return null ; return name . getAreaReference ( workbook ) ; } public void removePrintArea ( int sheetIndex ) { getWorkbook ( ) . removeBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; } public HSSFName createName ( ) { NameRecord nameRecord = workbook . createName ( ) ; HSSFName newName = new HSSFName ( workbook , nameRecord ) ; names . add ( newName ) ; return newName ; } public int getNameIndex ( String name ) { int retval = - 1 ; for ( int k = 0 ; k < names . size ( ) ; k ++ ) { String nameName = getNameName ( k ) ; if ( nameName . equals ( name ) ) { retval = k ; break ; } } return retval ; } public void removeName ( int index ) { names . remove ( index ) ; workbook . removeName ( index ) ; } public HSSFDataFormat createDataFormat ( ) { if ( formatter == null ) formatter = new HSSFDataFormat ( workbook ) ; return formatter ; } public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; } public HSSFPalette getCustomPalette ( ) { return new HSSFPalette ( workbook . getCustomPalette ( ) ) ; } private void copyNodes ( POIFSFileSystem source , POIFSFileSystem target , List excepts ) throws IOException { DirectoryEntry root = source . getRoot ( ) ; DirectoryEntry newRoot = target . getRoot ( ) ; Iterator entries = root . getEntries ( ) ; while ( entries . hasNext ( ) ) { Entry entry = ( Entry ) entries . next ( ) ; if ( ! isInList ( entry . getName ( ) , excepts ) ) { copyNodeRecursively ( entry , newRoot ) ; } } } private boolean isInList ( String entry , List list ) { for ( int k = 0 ; k < list . size ( ) ; k ++ ) { if ( list . get ( k ) . equals ( entry ) ) { return true ; } } return false ; } private void copyNodeRecursively ( Entry entry , DirectoryEntry target ) throws IOException { DirectoryEntry newTarget = null ; if ( entry . isDirectoryEntry ( ) ) { newTarget = target . createDirectory ( entry . getName ( ) ) ; Iterator entries = ( ( DirectoryEntry ) entry ) . getEntries ( ) ; while ( entries . hasNext ( ) ) { copyNodeRecursively ( ( Entry ) entries . next ( ) , newTarget ) ; } } else { DocumentEntry dentry = ( DocumentEntry ) entry ; DocumentInputStream dstream = new DocumentInputStream ( dentry ) ; target . createDocument ( dentry . getName ( ) , dstream ) ; dstream . close ( ) ; } } public void insertChartRecord ( ) { int loc = workbook . findFirstRecordLocBySid ( SSTRecord . sid ) ; byte [ ] data = { ( byte ) 0x0F , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xF0 , ( byte ) 0x52 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x06 , ( byte ) 0xF0 , ( byte ) 0x18 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x02 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x01 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x03 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x33 , ( byte ) 0x00 , ( byte ) 0x0B , ( byte ) 0xF0 , ( byte ) 0x12 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xBF , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x00 , ( byte ) 0x81 , ( byte ) 0x01 , ( byte ) 0x09 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xC0 , ( byte ) 0x01 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x40 , ( byte ) 0x00 , ( byte ) 0x1E , ( byte ) 0xF1 , ( byte ) 0x10 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x0D , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x0C , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0x17 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x08 , ( byte ) 0xF7 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x10 , } ; UnknownRecord r = new UnknownRecord ( ( short ) 0x00EB , ( short ) 0x005a , data ) ; workbook . getRecords ( ) . add ( loc , r ) ; } } 	1	['53', '1', '0', '32', '172', '106', '2', '30', '44', '0.877622378', '1743', '0.727272727', '4', '0', '0.146449704', '0', '0', '31.67924528', '32', '2.0943', '1']
package org . apache . poi . hssf . record ; import org . apache . poi . util . BitField ; import org . apache . poi . util . LittleEndian ; public class ExtendedFormatRecord extends Record { public final static short sid = 0xE0 ; public final static short NULL = ( short ) 0xfff0 ; public final static short XF_STYLE = 1 ; public final static short XF_CELL = 0 ; public final static short NONE = 0x0 ; public final static short THIN = 0x1 ; public final static short MEDIUM = 0x2 ; public final static short DASHED = 0x3 ; public final static short DOTTED = 0x4 ; public final static short THICK = 0x5 ; public final static short DOUBLE = 0x6 ; public final static short HAIR = 0x7 ; public final static short MEDIUM_DASHED = 0x8 ; public final static short DASH_DOT = 0x9 ; public final static short MEDIUM_DASH_DOT = 0xA ; public final static short DASH_DOT_DOT = 0xB ; public final static short MEDIUM_DASH_DOT_DOT = 0xC ; public final static short SLANTED_DASH_DOT = 0xD ; public final static short GENERAL = 0x0 ; public final static short LEFT = 0x1 ; public final static short CENTER = 0x2 ; public final static short RIGHT = 0x3 ; public final static short FILL = 0x4 ; public final static short JUSTIFY = 0x5 ; public final static short CENTER_SELECTION = 0x6 ; public final static short VERTICAL_TOP = 0x0 ; public final static short VERTICAL_CENTER = 0x1 ; public final static short VERTICAL_BOTTOM = 0x2 ; public final static short VERTICAL_JUSTIFY = 0x3 ; public final static short NO_FILL = 0 ; public final static short SOLID_FILL = 1 ; public final static short FINE_DOTS = 2 ; public final static short ALT_BARS = 3 ; public final static short SPARSE_DOTS = 4 ; public final static short THICK_HORZ_BANDS = 5 ; public final static short THICK_VERT_BANDS = 6 ; public final static short THICK_BACKWARD_DIAG = 7 ; public final static short THICK_FORWARD_DIAG = 8 ; public final static short BIG_SPOTS = 9 ; public final static short BRICKS = 10 ; public final static short THIN_HORZ_BANDS = 11 ; public final static short THIN_VERT_BANDS = 12 ; public final static short THIN_BACKWARD_DIAG = 13 ; public final static short THIN_FORWARD_DIAG = 14 ; public final static short SQUARES = 15 ; public final static short DIAMONDS = 16 ; private short field_1_font_index ; private short field_2_format_index ; static final private BitField _locked = new BitField ( 0x0001 ) ; static final private BitField _hidden = new BitField ( 0x0002 ) ; static final private BitField _xf_type = new BitField ( 0x0004 ) ; static final private BitField _123_prefix = new BitField ( 0x0008 ) ; static final private BitField _parent_index = new BitField ( 0xFFF0 ) ; private short field_3_cell_options ; static final private BitField _alignment = new BitField ( 0x0007 ) ; static final private BitField _wrap_text = new BitField ( 0x0008 ) ; static final private BitField _vertical_alignment = new BitField ( 0x0070 ) ; static final private BitField _justify_last = new BitField ( 0x0080 ) ; static final private BitField _rotation = new BitField ( 0xFF00 ) ; private short field_4_alignment_options ; static final private BitField _indent = new BitField ( 0x000F ) ; static final private BitField _shrink_to_fit = new BitField ( 0x0010 ) ; static final private BitField _merge_cells = new BitField ( 0x0020 ) ; static final private BitField _reading_order = new BitField ( 0x00C0 ) ; static final private BitField _indent_not_parent_format = new BitField ( 0x0400 ) ; static final private BitField _indent_not_parent_font = new BitField ( 0x0800 ) ; static final private BitField _indent_not_parent_alignment = new BitField ( 0x1000 ) ; static final private BitField _indent_not_parent_border = new BitField ( 0x2000 ) ; static final private BitField _indent_not_parent_pattern = new BitField ( 0x4000 ) ; static final private BitField _indent_not_parent_cell_options = new BitField ( 0x8000 ) ; private short field_5_indention_options ; static final private BitField _border_left = new BitField ( 0x000F ) ; static final private BitField _border_right = new BitField ( 0x00F0 ) ; static final private BitField _border_top = new BitField ( 0x0F00 ) ; static final private BitField _border_bottom = new BitField ( 0xF000 ) ; private short field_6_border_options ; static final private BitField _left_border_palette_idx = new BitField ( 0x007F ) ; static final private BitField _right_border_palette_idx = new BitField ( 0x3F80 ) ; static final private BitField _diag = new BitField ( 0xC000 ) ; private short field_7_palette_options ; static final private BitField _top_border_palette_idx = new BitField ( 0x0000007F ) ; static final private BitField _bottom_border_palette_idx = new BitField ( 0x00003F80 ) ; static final private BitField _adtl_diag = new BitField ( 0x001fc000 ) ; static final private BitField _adtl_diag_line_style = new BitField ( 0x01e00000 ) ; static final private BitField _adtl_fill_pattern = new BitField ( 0xfc000000 ) ; private int field_8_adtl_palette_options ; static final private BitField _fill_foreground = new BitField ( 0x007F ) ; static final private BitField _fill_background = new BitField ( 0x3f80 ) ; private short field_9_fill_palette_options ; public ExtendedFormatRecord ( ) { } public ExtendedFormatRecord ( short id , short size , byte [ ] data ) { super ( id , size , data ) ; } public ExtendedFormatRecord ( short id , short size , byte [ ] data , int offset ) { super ( id , size , data , offset ) ; } protected void validateSid ( short id ) { if ( id != sid ) { throw new RecordFormatException ( "NOT A EXTENDED FORMAT RECORD" ) ; } } protected void fillFields ( byte [ ] data , short size , int offset ) { field_1_font_index = LittleEndian . getShort ( data , 0 + offset ) ; field_2_format_index = LittleEndian . getShort ( data , 2 + offset ) ; field_3_cell_options = LittleEndian . getShort ( data , 4 + offset ) ; field_4_alignment_options = LittleEndian . getShort ( data , 6 + offset ) ; field_5_indention_options = LittleEndian . getShort ( data , 8 + offset ) ; field_6_border_options = LittleEndian . getShort ( data , 10 + offset ) ; field_7_palette_options = LittleEndian . getShort ( data , 12 + offset ) ; field_8_adtl_palette_options = LittleEndian . getInt ( data , 14 + offset ) ; field_9_fill_palette_options = LittleEndian . getShort ( data , 18 + offset ) ; } public void setFontIndex ( short index ) { field_1_font_index = index ; } public void setFormatIndex ( short index ) { field_2_format_index = index ; } public void setCellOptions ( short options ) { field_3_cell_options = options ; } public void setLocked ( boolean locked ) { field_3_cell_options = _locked . setShortBoolean ( field_3_cell_options , locked ) ; } public void setHidden ( boolean hidden ) { field_3_cell_options = _hidden . setShortBoolean ( field_3_cell_options , hidden ) ; } public void setXFType ( short type ) { field_3_cell_options = _xf_type . setShortValue ( field_3_cell_options , type ) ; } public void set123Prefix ( boolean prefix ) { field_3_cell_options = _123_prefix . setShortBoolean ( field_3_cell_options , prefix ) ; } public void setParentIndex ( short parent ) { field_3_cell_options = _parent_index . setShortValue ( field_3_cell_options , parent ) ; } public void setAlignmentOptions ( short options ) { field_4_alignment_options = options ; } public void setAlignment ( short align ) { field_4_alignment_options = _alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setWrapText ( boolean wrapped ) { field_4_alignment_options = _wrap_text . setShortBoolean ( field_4_alignment_options , wrapped ) ; } public void setVerticalAlignment ( short align ) { field_4_alignment_options = _vertical_alignment . setShortValue ( field_4_alignment_options , align ) ; } public void setJustifyLast ( short justify ) { field_4_alignment_options = _justify_last . setShortValue ( field_4_alignment_options , justify ) ; } public void setRotation ( short rotation ) { field_4_alignment_options = _rotation . setShortValue ( field_4_alignment_options , rotation ) ; } public void setIndentionOptions ( short options ) { field_5_indention_options = options ; } public void setIndent ( short indent ) { field_5_indention_options = _indent . setShortValue ( field_5_indention_options , indent ) ; } public void setShrinkToFit ( boolean shrink ) { field_5_indention_options = _shrink_to_fit . setShortBoolean ( field_5_indention_options , shrink ) ; } public void setMergeCells ( boolean merge ) { field_5_indention_options = _merge_cells . setShortBoolean ( field_5_indention_options , merge ) ; } public void setReadingOrder ( short order ) { field_5_indention_options = _reading_order . setShortValue ( field_5_indention_options , order ) ; } public void setIndentNotParentFormat ( boolean parent ) { field_5_indention_options = _indent_not_parent_format . setShortBoolean ( field_5_indention_options , parent ) ; } public void setIndentNotParentFont ( boolean font ) { field_5_indention_options = _indent_not_parent_font . setShortBoolean ( field_5_indention_options , font ) ; } public void setIndentNotParentAlignment ( boolean alignment ) { field_5_indention_options = _indent_not_parent_alignment . setShortBoolean ( field_5_indention_options , alignment ) ; } public void setIndentNotParentBorder ( boolean border ) { field_5_indention_options = _indent_not_parent_border . setShortBoolean ( field_5_indention_options , border ) ; } public void setIndentNotParentPattern ( boolean pattern ) { field_5_indention_options = _indent_not_parent_pattern . setShortBoolean ( field_5_indention_options , pattern ) ; } public void setIndentNotParentCellOptions ( boolean options ) { field_5_indention_options = _indent_not_parent_cell_options . setShortBoolean ( field_5_indention_options , options ) ; } public void setBorderOptions ( short options ) { field_6_border_options = options ; } public void setBorderLeft ( short border ) { field_6_border_options = _border_left . setShortValue ( field_6_border_options , border ) ; } public void setBorderRight ( short border ) { field_6_border_options = _border_right . setShortValue ( field_6_border_options , border ) ; } public void setBorderTop ( short border ) { field_6_border_options = _border_top . setShortValue ( field_6_border_options , border ) ; } public void setBorderBottom ( short border ) { field_6_border_options = _border_bottom . setShortValue ( field_6_border_options , border ) ; } public void setPaletteOptions ( short options ) { field_7_palette_options = options ; } public void setLeftBorderPaletteIdx ( short border ) { field_7_palette_options = _left_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setRightBorderPaletteIdx ( short border ) { field_7_palette_options = _right_border_palette_idx . setShortValue ( field_7_palette_options , border ) ; } public void setDiag ( short diag ) { field_7_palette_options = _diag . setShortValue ( field_7_palette_options , diag ) ; } public void setAdtlPaletteOptions ( short options ) { field_8_adtl_palette_options = options ; } public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setBottomBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _bottom_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } public void setAdtlDiag ( short diag ) { field_8_adtl_palette_options = _adtl_diag . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlDiagLineStyle ( short diag ) { field_8_adtl_palette_options = _adtl_diag_line_style . setValue ( field_8_adtl_palette_options , diag ) ; } public void setAdtlFillPattern ( short fill ) { field_8_adtl_palette_options = _adtl_fill_pattern . setValue ( field_8_adtl_palette_options , fill ) ; } public void setFillPaletteOptions ( short options ) { field_9_fill_palette_options = options ; } public void setFillForeground ( short color ) { field_9_fill_palette_options = _fill_foreground . setShortValue ( field_9_fill_palette_options , color ) ; } public void setFillBackground ( short color ) { field_9_fill_palette_options = _fill_background . setShortValue ( field_9_fill_palette_options , color ) ; } public short getFontIndex ( ) { return field_1_font_index ; } public short getFormatIndex ( ) { return field_2_format_index ; } public short getCellOptions ( ) { return field_3_cell_options ; } public boolean isLocked ( ) { return _locked . isSet ( field_3_cell_options ) ; } public boolean isHidden ( ) { return _hidden . isSet ( field_3_cell_options ) ; } public short getXFType ( ) { return _xf_type . getShortValue ( field_3_cell_options ) ; } public boolean get123Prefix ( ) { return _123_prefix . isSet ( field_3_cell_options ) ; } public short getParentIndex ( ) { return _parent_index . getShortValue ( field_3_cell_options ) ; } public short getAlignmentOptions ( ) { return field_4_alignment_options ; } public short getAlignment ( ) { return _alignment . getShortValue ( field_4_alignment_options ) ; } public boolean getWrapText ( ) { return _wrap_text . isSet ( field_4_alignment_options ) ; } public short getVerticalAlignment ( ) { return _vertical_alignment . getShortValue ( field_4_alignment_options ) ; } public short getJustifyLast ( ) { return _justify_last . getShortValue ( field_4_alignment_options ) ; } public short getRotation ( ) { return _rotation . getShortValue ( field_4_alignment_options ) ; } public short getIndentionOptions ( ) { return field_5_indention_options ; } public short getIndent ( ) { return _indent . getShortValue ( field_5_indention_options ) ; } public boolean getShrinkToFit ( ) { return _shrink_to_fit . isSet ( field_5_indention_options ) ; } public boolean getMergeCells ( ) { return _merge_cells . isSet ( field_5_indention_options ) ; } public short getReadingOrder ( ) { return _reading_order . getShortValue ( field_5_indention_options ) ; } public boolean isIndentNotParentFormat ( ) { return _indent_not_parent_format . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentFont ( ) { return _indent_not_parent_font . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentAlignment ( ) { return _indent_not_parent_alignment . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentBorder ( ) { return _indent_not_parent_border . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentPattern ( ) { return _indent_not_parent_pattern . isSet ( field_5_indention_options ) ; } public boolean isIndentNotParentCellOptions ( ) { return _indent_not_parent_cell_options . isSet ( field_5_indention_options ) ; } public short getBorderOptions ( ) { return field_6_border_options ; } public short getBorderLeft ( ) { return _border_left . getShortValue ( field_6_border_options ) ; } public short getBorderRight ( ) { return _border_right . getShortValue ( field_6_border_options ) ; } public short getBorderTop ( ) { return _border_top . getShortValue ( field_6_border_options ) ; } public short getBorderBottom ( ) { return _border_bottom . getShortValue ( field_6_border_options ) ; } public short getPaletteOptions ( ) { return field_7_palette_options ; } public short getLeftBorderPaletteIdx ( ) { return _left_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getRightBorderPaletteIdx ( ) { return _right_border_palette_idx . getShortValue ( field_7_palette_options ) ; } public short getDiag ( ) { return _diag . getShortValue ( field_7_palette_options ) ; } public int getAdtlPaletteOptions ( ) { return field_8_adtl_palette_options ; } public short getTopBorderPaletteIdx ( ) { return ( short ) _top_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getBottomBorderPaletteIdx ( ) { return ( short ) _bottom_border_palette_idx . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiag ( ) { return ( short ) _adtl_diag . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlDiagLineStyle ( ) { return ( short ) _adtl_diag_line_style . getValue ( field_8_adtl_palette_options ) ; } public short getAdtlFillPattern ( ) { return ( short ) _adtl_fill_pattern . getValue ( field_8_adtl_palette_options ) ; } public short getFillPaletteOptions ( ) { return field_9_fill_palette_options ; } public short getFillForeground ( ) { return _fill_foreground . getShortValue ( field_9_fill_palette_options ) ; } public short getFillBackground ( ) { return _fill_background . getShortValue ( field_9_fill_palette_options ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[EXTENDEDFORMAT]\n" ) ; if ( getXFType ( ) == XF_STYLE ) { buffer . append ( " STYLE_RECORD_TYPE\n" ) ; } else if ( getXFType ( ) == XF_CELL ) { buffer . append ( " CELL_RECORD_TYPE\n" ) ; } buffer . append ( "    .fontindex       = " ) . append ( Integer . toHexString ( getFontIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .formatindex     = " ) . append ( Integer . toHexString ( getFormatIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .celloptions     = " ) . append ( Integer . toHexString ( getCellOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .islocked  = " ) . append ( isLocked ( ) ) . append ( "\n" ) ; buffer . append ( "          .ishidden  = " ) . append ( isHidden ( ) ) . append ( "\n" ) ; buffer . append ( "          .recordtype= " ) . append ( Integer . toHexString ( getXFType ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .parentidx = " ) . append ( Integer . toHexString ( getParentIndex ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .alignmentoptions= " ) . append ( Integer . toHexString ( getAlignmentOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .alignment = " ) . append ( getAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .wraptext  = " ) . append ( getWrapText ( ) ) . append ( "\n" ) ; buffer . append ( "          .valignment= " ) . append ( Integer . toHexString ( getVerticalAlignment ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .justlast  = " ) . append ( Integer . toHexString ( getJustifyLast ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rotation  = " ) . append ( Integer . toHexString ( getRotation ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .indentionoptions= " ) . append ( Integer . toHexString ( getIndentionOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .indent    = " ) . append ( Integer . toHexString ( getIndent ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .shrinktoft= " ) . append ( getShrinkToFit ( ) ) . append ( "\n" ) ; buffer . append ( "          .mergecells= " ) . append ( getMergeCells ( ) ) . append ( "\n" ) ; buffer . append ( "          .readngordr= " ) . append ( Integer . toHexString ( getReadingOrder ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .formatflag= " ) . append ( isIndentNotParentFormat ( ) ) . append ( "\n" ) ; buffer . append ( "          .fontflag  = " ) . append ( isIndentNotParentFont ( ) ) . append ( "\n" ) ; buffer . append ( "          .prntalgnmt= " ) . append ( isIndentNotParentAlignment ( ) ) . append ( "\n" ) ; buffer . append ( "          .borderflag= " ) . append ( isIndentNotParentBorder ( ) ) . append ( "\n" ) ; buffer . append ( "          .paternflag= " ) . append ( isIndentNotParentPattern ( ) ) . append ( "\n" ) ; buffer . append ( "          .celloption= " ) . append ( isIndentNotParentCellOptions ( ) ) . append ( "\n" ) ; buffer . append ( "    .borderoptns     = " ) . append ( Integer . toHexString ( getBorderOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .lftln     = " ) . append ( Integer . toHexString ( getBorderLeft ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rgtln     = " ) . append ( Integer . toHexString ( getBorderRight ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topln     = " ) . append ( Integer . toHexString ( getBorderTop ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .btmln     = " ) . append ( Integer . toHexString ( getBorderBottom ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptns     = " ) . append ( Integer . toHexString ( getPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .leftborder= " ) . append ( Integer . toHexString ( getLeftBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .rghtborder= " ) . append ( Integer . toHexString ( getRightBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diag      = " ) . append ( Integer . toHexString ( getDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .paleteoptn2     = " ) . append ( Integer . toHexString ( getAdtlPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .topborder = " ) . append ( Integer . toHexString ( getTopBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .botmborder= " ) . append ( Integer . toHexString ( getBottomBorderPaletteIdx ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .adtldiag  = " ) . append ( Integer . toHexString ( getAdtlDiag ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .diaglnstyl= " ) . append ( Integer . toHexString ( getAdtlDiagLineStyle ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .fillpattrn= " ) . append ( Integer . toHexString ( getAdtlFillPattern ( ) ) ) . append ( "\n" ) ; buffer . append ( "    .fillpaloptn     = " ) . append ( Integer . toHexString ( getFillPaletteOptions ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .foreground= " ) . append ( Integer . toHexString ( getFillForeground ( ) ) ) . append ( "\n" ) ; buffer . append ( "          .background= " ) . append ( Integer . toHexString ( getFillBackground ( ) ) ) . append ( "\n" ) ; buffer . append ( "[/EXTENDEDFORMAT]\n" ) ; return buffer . toString ( ) ; } public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , sid ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( 20 ) ) ; LittleEndian . putShort ( data , 4 + offset , getFontIndex ( ) ) ; LittleEndian . putShort ( data , 6 + offset , getFormatIndex ( ) ) ; LittleEndian . putShort ( data , 8 + offset , getCellOptions ( ) ) ; LittleEndian . putShort ( data , 10 + offset , getAlignmentOptions ( ) ) ; LittleEndian . putShort ( data , 12 + offset , getIndentionOptions ( ) ) ; LittleEndian . putShort ( data , 14 + offset , getBorderOptions ( ) ) ; LittleEndian . putShort ( data , 16 + offset , getPaletteOptions ( ) ) ; LittleEndian . putInt ( data , 18 + offset , getAdtlPaletteOptions ( ) ) ; LittleEndian . putShort ( data , 22 + offset , getFillPaletteOptions ( ) ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 24 ; } public short getSid ( ) { return this . sid ; } } 	1	['96', '2', '0', '9', '117', '3214', '5', '4', '93', '0.981194559', '1478', '0.483146067', '34', '0.106796117', '0.313684211', '1', '6', '13.46875', '3', '0.9896', '1']
package org . apache . poi . hssf . model ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . record . formula . Ptg ; import org . apache . poi . util . * ; import org . apache . poi . hssf . record . aggregates . * ; public class Sheet implements Model { public static final short LeftMargin = 0 ; public static final short RightMargin = 1 ; public static final short TopMargin = 2 ; public static final short BottomMargin = 3 ; protected ArrayList records = null ; int preoffset = 0 ; int loc = 0 ; protected boolean containsLabels = false ; protected int dimsloc = 0 ; protected DimensionsRecord dims ; protected DefaultColWidthRecord defaultcolwidth = null ; protected DefaultRowHeightRecord defaultrowheight = null ; protected GridsetRecord gridset = null ; protected PrintSetupRecord printSetup = null ; protected HeaderRecord header = null ; protected FooterRecord footer = null ; protected PrintGridlinesRecord printGridlines = null ; protected WindowTwoRecord windowTwo = null ; protected MergeCellsRecord merged = null ; protected Margin margins [ ] = null ; protected List mergedRecords = new ArrayList ( ) ; protected int numMergedRegions = 0 ; protected SelectionRecord selection = null ; private static POILogger log = POILogFactory . getLogger ( Sheet . class ) ; private ArrayList columnSizes = null ; protected ValueRecordsAggregate cells = null ; protected RowRecordsAggregate rows = null ; private Iterator valueRecIterator = null ; private Iterator rowRecIterator = null ; protected int eofLoc = 0 ; protected ProtectRecord protect = null ; public static final byte PANE_LOWER_RIGHT = ( byte ) 0 ; public static final byte PANE_UPPER_RIGHT = ( byte ) 1 ; public static final byte PANE_LOWER_LEFT = ( byte ) 2 ; public static final byte PANE_UPPER_LEFT = ( byte ) 3 ; public Sheet ( ) { } public static Sheet createSheet ( List recs , int sheetnum , int offset ) { log . logFormatted ( log . DEBUG , "Sheet createSheet (existing file) with %" , new Integer ( recs . size ( ) ) ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( recs . size ( ) / 5 ) ; boolean isfirstcell = true ; boolean isfirstrow = true ; int bofEofNestingLevel = 0 ; for ( int k = offset ; k < recs . size ( ) ; k ++ ) { Record rec = ( Record ) recs . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { log . log ( log . DEBUG , "Hit label record." ) ; retval . containsLabels = true ; } else if ( rec . getSid ( ) == BOFRecord . sid ) { bofEofNestingLevel ++ ; log . log ( log . DEBUG , "Hit BOF record. Nesting increased to " + bofEofNestingLevel ) ; } else if ( rec . getSid ( ) == EOFRecord . sid ) { -- bofEofNestingLevel ; log . log ( log . DEBUG , "Hit EOF record. Nesting decreased to " + bofEofNestingLevel ) ; if ( bofEofNestingLevel == 0 ) { records . add ( rec ) ; retval . eofLoc = k ; break ; } } else if ( rec . getSid ( ) == DimensionsRecord . sid ) { retval . dims = ( DimensionsRecord ) rec ; retval . dimsloc = records . size ( ) ; } else if ( rec . getSid ( ) == MergeCellsRecord . sid ) { retval . mergedRecords . add ( rec ) ; retval . merged = ( MergeCellsRecord ) rec ; retval . numMergedRegions += retval . merged . getNumAreas ( ) ; } else if ( rec . getSid ( ) == ColumnInfoRecord . sid ) { if ( retval . columnSizes == null ) { retval . columnSizes = new ArrayList ( ) ; } retval . columnSizes . add ( rec ) ; } else if ( rec . getSid ( ) == DefaultColWidthRecord . sid ) { retval . defaultcolwidth = ( DefaultColWidthRecord ) rec ; } else if ( rec . getSid ( ) == DefaultRowHeightRecord . sid ) { retval . defaultrowheight = ( DefaultRowHeightRecord ) rec ; } else if ( rec . isValue ( ) && bofEofNestingLevel == 1 ) { if ( isfirstcell ) { retval . cells = new ValueRecordsAggregate ( ) ; rec = retval . cells ; retval . cells . construct ( k , recs ) ; isfirstcell = false ; } else { rec = null ; } } else if ( rec . getSid ( ) == StringRecord . sid ) { rec = null ; } else if ( rec . getSid ( ) == RowRecord . sid ) { RowRecord row = ( RowRecord ) rec ; if ( ! isfirstrow ) rec = null ; if ( isfirstrow ) { retval . rows = new RowRecordsAggregate ( ) ; rec = retval . rows ; isfirstrow = false ; } retval . rows . insertRow ( row ) ; } else if ( rec . getSid ( ) == PrintGridlinesRecord . sid ) { retval . printGridlines = ( PrintGridlinesRecord ) rec ; } else if ( rec . getSid ( ) == HeaderRecord . sid && bofEofNestingLevel == 1 ) { retval . header = ( HeaderRecord ) rec ; } else if ( rec . getSid ( ) == FooterRecord . sid && bofEofNestingLevel == 1 ) { retval . footer = ( FooterRecord ) rec ; } else if ( rec . getSid ( ) == PrintSetupRecord . sid && bofEofNestingLevel == 1 ) { retval . printSetup = ( PrintSetupRecord ) rec ; } else if ( rec . getSid ( ) == LeftMarginRecord . sid ) { retval . getMargins ( ) [ LeftMargin ] = ( LeftMarginRecord ) rec ; } else if ( rec . getSid ( ) == RightMarginRecord . sid ) { retval . getMargins ( ) [ RightMargin ] = ( RightMarginRecord ) rec ; } else if ( rec . getSid ( ) == TopMarginRecord . sid ) { retval . getMargins ( ) [ TopMargin ] = ( TopMarginRecord ) rec ; } else if ( rec . getSid ( ) == BottomMarginRecord . sid ) { retval . getMargins ( ) [ BottomMargin ] = ( BottomMarginRecord ) rec ; } else if ( rec . getSid ( ) == SelectionRecord . sid ) { retval . selection = ( SelectionRecord ) rec ; } else if ( rec . getSid ( ) == WindowTwoRecord . sid ) { retval . windowTwo = ( WindowTwoRecord ) rec ; } else if ( rec . getSid ( ) == ProtectRecord . sid ) { retval . protect = ( ProtectRecord ) rec ; } if ( rec != null ) { records . add ( rec ) ; } } retval . records = records ; retval . checkCells ( ) ; retval . checkRows ( ) ; log . log ( log . DEBUG , "sheet createSheet (existing file) exited" ) ; return retval ; } public Sheet cloneSheet ( ) { ArrayList clonedRecords = new ArrayList ( this . records . size ( ) ) ; for ( int i = 0 ; i < this . records . size ( ) ; i ++ ) { Record rec = ( Record ) ( ( Record ) this . records . get ( i ) ) . clone ( ) ; if ( rec instanceof RowRecordsAggregate ) { RowRecordsAggregate rrAgg = ( RowRecordsAggregate ) rec ; for ( Iterator rowIter = rrAgg . getIterator ( ) ; rowIter . hasNext ( ) ; ) { Record rowRec = ( Record ) rowIter . next ( ) ; clonedRecords . add ( rowRec ) ; } } else if ( rec instanceof ValueRecordsAggregate ) { ValueRecordsAggregate vrAgg = ( ValueRecordsAggregate ) rec ; for ( Iterator cellIter = vrAgg . getIterator ( ) ; cellIter . hasNext ( ) ; ) { Record valRec = ( Record ) cellIter . next ( ) ; clonedRecords . add ( valRec ) ; } } else if ( rec instanceof FormulaRecordAggregate ) { FormulaRecordAggregate fmAgg = ( FormulaRecordAggregate ) rec ; Record fmAggRec = fmAgg . getFormulaRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; fmAggRec = fmAgg . getStringRecord ( ) ; if ( fmAggRec != null ) clonedRecords . add ( fmAggRec ) ; } else { clonedRecords . add ( rec ) ; } } return createSheet ( clonedRecords , 0 , 0 ) ; } public static Sheet createSheet ( List records , int sheetnum ) { log . log ( log . DEBUG , "Sheet createSheet (exisiting file) assumed offset 0" ) ; return createSheet ( records , sheetnum , 0 ) ; } public static Sheet createSheet ( ) { log . log ( log . DEBUG , "Sheet createsheet from scratch called" ) ; Sheet retval = new Sheet ( ) ; ArrayList records = new ArrayList ( 30 ) ; records . add ( retval . createBOF ( ) ) ; records . add ( retval . createCalcMode ( ) ) ; records . add ( retval . createCalcCount ( ) ) ; records . add ( retval . createRefMode ( ) ) ; records . add ( retval . createIteration ( ) ) ; records . add ( retval . createDelta ( ) ) ; records . add ( retval . createSaveRecalc ( ) ) ; records . add ( retval . createPrintHeaders ( ) ) ; retval . printGridlines = ( PrintGridlinesRecord ) retval . createPrintGridlines ( ) ; records . add ( retval . printGridlines ) ; retval . gridset = ( GridsetRecord ) retval . createGridset ( ) ; records . add ( retval . gridset ) ; records . add ( retval . createGuts ( ) ) ; retval . defaultrowheight = ( DefaultRowHeightRecord ) retval . createDefaultRowHeight ( ) ; records . add ( retval . defaultrowheight ) ; records . add ( retval . createWSBool ( ) ) ; retval . header = ( HeaderRecord ) retval . createHeader ( ) ; records . add ( retval . header ) ; retval . footer = ( FooterRecord ) retval . createFooter ( ) ; records . add ( retval . footer ) ; records . add ( retval . createHCenter ( ) ) ; records . add ( retval . createVCenter ( ) ) ; retval . printSetup = ( PrintSetupRecord ) retval . createPrintSetup ( ) ; records . add ( retval . printSetup ) ; retval . defaultcolwidth = ( DefaultColWidthRecord ) retval . createDefaultColWidth ( ) ; records . add ( retval . defaultcolwidth ) ; retval . dims = ( DimensionsRecord ) retval . createDimensions ( ) ; retval . dimsloc = 19 ; records . add ( retval . dims ) ; records . add ( retval . windowTwo = retval . createWindowTwo ( ) ) ; retval . setLoc ( records . size ( ) - 1 ) ; retval . selection = ( SelectionRecord ) retval . createSelection ( ) ; records . add ( retval . selection ) ; retval . protect = ( ProtectRecord ) retval . createProtect ( ) ; records . add ( retval . protect ) ; records . add ( retval . createEOF ( ) ) ; retval . records = records ; log . log ( log . DEBUG , "Sheet createsheet from scratch exit" ) ; return retval ; } private void checkCells ( ) { if ( cells == null ) { cells = new ValueRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , cells ) ; } } private void checkRows ( ) { if ( rows == null ) { rows = new RowRecordsAggregate ( ) ; records . add ( getDimsLoc ( ) + 1 , rows ) ; } } public int addMergedRegion ( int rowFrom , short colFrom , int rowTo , short colTo ) { if ( merged == null || merged . getNumAreas ( ) == 1027 ) { merged = ( MergeCellsRecord ) createMergedCells ( ) ; mergedRecords . add ( merged ) ; records . add ( records . size ( ) - 1 , merged ) ; } merged . addArea ( rowFrom , colFrom , rowTo , colTo ) ; return numMergedRegions ++ ; } public void removeMergedRegion ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } MergeCellsRecord rec = ( MergeCellsRecord ) mergedRecords . get ( pos ) ; rec . removeAreaAt ( index - startNumRegions ) ; numMergedRegions -- ; if ( rec . getNumAreas ( ) == 0 ) { mergedRecords . remove ( pos ) ; records . remove ( merged ) ; if ( merged == rec ) { if ( mergedRecords . size ( ) > 0 ) { merged = ( MergeCellsRecord ) mergedRecords . get ( mergedRecords . size ( ) - 1 ) ; } else { merged = null ; } } } } public MergeCellsRecord . MergedRegion getMergedRegionAt ( int index ) { if ( index >= numMergedRegions || mergedRecords . size ( ) == 0 ) return null ; int pos = 0 ; int startNumRegions = 0 ; if ( numMergedRegions - index < merged . getNumAreas ( ) ) { pos = mergedRecords . size ( ) - 1 ; startNumRegions = numMergedRegions - merged . getNumAreas ( ) ; } else { for ( int n = 0 ; n < mergedRecords . size ( ) ; n ++ ) { MergeCellsRecord record = ( MergeCellsRecord ) mergedRecords . get ( n ) ; if ( startNumRegions + record . getNumAreas ( ) > index ) { pos = n ; break ; } startNumRegions += record . getNumAreas ( ) ; } } return ( ( MergeCellsRecord ) mergedRecords . get ( pos ) ) . getAreaAt ( index - startNumRegions ) ; } public int getNumMergedRegions ( ) { return numMergedRegions ; } public void convertLabelRecords ( Workbook wb ) { log . log ( log . DEBUG , "convertLabelRecords called" ) ; if ( containsLabels ) { for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record rec = ( Record ) records . get ( k ) ; if ( rec . getSid ( ) == LabelRecord . sid ) { LabelRecord oldrec = ( LabelRecord ) rec ; records . remove ( k ) ; LabelSSTRecord newrec = new LabelSSTRecord ( ) ; int stringid = wb . addSSTString ( oldrec . getValue ( ) ) ; newrec . setRow ( oldrec . getRow ( ) ) ; newrec . setColumn ( oldrec . getColumn ( ) ) ; newrec . setXFIndex ( oldrec . getXFIndex ( ) ) ; newrec . setSSTIndex ( stringid ) ; records . add ( k , newrec ) ; } } } log . log ( log . DEBUG , "convertLabelRecords exit" ) ; } public int getNumRecords ( ) { checkCells ( ) ; checkRows ( ) ; log . log ( log . DEBUG , "Sheet.getNumRecords" ) ; log . logFormatted ( log . DEBUG , "returning % + % + % - 2 = %" , new int [ ] { records . size ( ) , cells . getPhysicalNumberOfCells ( ) , rows . getPhysicalNumberOfRows ( ) , records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 } ) ; return records . size ( ) + cells . getPhysicalNumberOfCells ( ) + rows . getPhysicalNumberOfRows ( ) - 2 ; } public void setDimensions ( int firstrow , short firstcol , int lastrow , short lastcol ) { log . log ( log . DEBUG , "Sheet.setDimensions" ) ; log . log ( log . DEBUG , ( new StringBuffer ( "firstrow" ) ) . append ( firstrow ) . append ( "firstcol" ) . append ( firstcol ) . append ( "lastrow" ) . append ( lastrow ) . append ( "lastcol" ) . append ( lastcol ) . toString ( ) ) ; dims . setFirstCol ( firstcol ) ; dims . setFirstRow ( firstrow ) ; dims . setLastCol ( lastcol ) ; dims . setLastRow ( lastrow ) ; log . log ( log . DEBUG , "Sheet.setDimensions exiting" ) ; } public void setLoc ( int loc ) { valueRecIterator = null ; log . log ( log . DEBUG , "sheet.setLoc(): " + loc ) ; this . loc = loc ; } public int getLoc ( ) { log . log ( log . DEBUG , "sheet.getLoc():" + loc ) ; return loc ; } public void setPreOffset ( int offset ) { this . preoffset = offset ; } public int getPreOffset ( ) { return preoffset ; } public byte [ ] serialize ( ) { log . log ( log . DEBUG , "Sheet.serialize" ) ; byte [ ] retval = null ; int arraysize = getSize ( ) ; int pos = 0 ; retval = new byte [ arraysize ] ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { pos += ( ( Record ) records . get ( k ) ) . serialize ( pos , retval ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " + retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { log . log ( log . DEBUG , "Sheet.serialize using offsets" ) ; int pos = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { Record record = ( ( Record ) records . get ( k ) ) ; pos += record . serialize ( pos + offset , data ) ; } log . log ( log . DEBUG , "Sheet.serialize returning " ) ; return pos ; } public RowRecord createRow ( int row ) { log . log ( log . DEBUG , "create row number " + row ) ; RowRecord rowrec = new RowRecord ( ) ; rowrec . setRowNumber ( row ) ; rowrec . setHeight ( ( short ) 0xff ) ; rowrec . setOptimize ( ( short ) 0x0 ) ; rowrec . setOptionFlags ( ( short ) 0x0 ) ; rowrec . setXFIndex ( ( short ) 0x0 ) ; return rowrec ; } public LabelSSTRecord createLabelSST ( int row , short col , int index ) { log . logFormatted ( log . DEBUG , "create labelsst row,col,index %,%,%" , new int [ ] { row , col , index } ) ; LabelSSTRecord rec = new LabelSSTRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setSSTIndex ( index ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public NumberRecord createNumber ( int row , short col , double value ) { log . logFormatted ( log . DEBUG , "create number row,col,value %,%,%" , new double [ ] { row , col , value } ) ; NumberRecord rec = new NumberRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setValue ( value ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public BlankRecord createBlank ( int row , short col ) { log . logFormatted ( log . DEBUG , "create blank row,col %,%" , new int [ ] { row , col } ) ; BlankRecord rec = new BlankRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setXFIndex ( ( short ) 0x0f ) ; return rec ; } public FormulaRecord createFormula ( int row , short col , String formula ) { log . logFormatted ( log . DEBUG , "create formula row,col,formula %,%,%" , new int [ ] { row , col } , formula ) ; FormulaRecord rec = new FormulaRecord ( ) ; rec . setRow ( row ) ; rec . setColumn ( col ) ; rec . setOptions ( ( short ) 2 ) ; rec . setValue ( 0 ) ; rec . setXFIndex ( ( short ) 0x0f ) ; FormulaParser fp = new FormulaParser ( formula , null ) ; fp . parse ( ) ; Ptg [ ] ptg = fp . getRPNPtg ( ) ; int size = 0 ; for ( int k = 0 ; k < ptg . length ; k ++ ) { size += ptg [ k ] . getSize ( ) ; rec . pushExpressionToken ( ptg [ k ] ) ; } rec . setExpressionLength ( ( short ) size ) ; return rec ; } public void addValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "add value record  row,loc %,%" , new int [ ] { row , loc } ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( col . getColumn ( ) > d . getLastCol ( ) ) { d . setLastCol ( ( short ) ( col . getColumn ( ) + 1 ) ) ; } if ( col . getColumn ( ) < d . getFirstCol ( ) ) { d . setFirstCol ( col . getColumn ( ) ) ; } cells . insertCell ( col ) ; } public void removeValueRecord ( int row , CellValueRecordInterface col ) { checkCells ( ) ; log . logFormatted ( log . DEBUG , "remove value record row,dimsloc %,%" , new int [ ] { row , dimsloc } ) ; loc = dimsloc ; cells . removeCell ( col ) ; } public void replaceValueRecord ( CellValueRecordInterface newval ) { checkCells ( ) ; setLoc ( dimsloc ) ; log . log ( log . DEBUG , "replaceValueRecord " ) ; cells . insertCell ( newval ) ; } public void addRow ( RowRecord row ) { checkRows ( ) ; log . log ( log . DEBUG , "addRow " ) ; DimensionsRecord d = ( DimensionsRecord ) records . get ( getDimsLoc ( ) ) ; if ( row . getRowNumber ( ) > d . getLastRow ( ) ) { d . setLastRow ( row . getRowNumber ( ) + 1 ) ; } if ( row . getRowNumber ( ) < d . getFirstRow ( ) ) { d . setFirstRow ( row . getRowNumber ( ) ) ; } RowRecord existingRow = rows . getRow ( row . getRowNumber ( ) ) ; if ( existingRow != null ) rows . removeRow ( existingRow ) ; rows . insertRow ( row ) ; log . log ( log . DEBUG , "exit addRow" ) ; } public void removeRow ( RowRecord row ) { checkRows ( ) ; setLoc ( getDimsLoc ( ) ) ; rows . removeRow ( row ) ; } public CellValueRecordInterface getNextValueRecord ( ) { log . log ( log . DEBUG , "getNextValue loc= " + loc ) ; if ( valueRecIterator == null ) { valueRecIterator = cells . getIterator ( ) ; } if ( ! valueRecIterator . hasNext ( ) ) { return null ; } return ( CellValueRecordInterface ) valueRecIterator . next ( ) ; } public RowRecord getNextRow ( ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; if ( rowRecIterator == null ) { rowRecIterator = rows . getIterator ( ) ; } if ( ! rowRecIterator . hasNext ( ) ) { return null ; } return ( RowRecord ) rowRecIterator . next ( ) ; } public RowRecord getRow ( int rownum ) { log . log ( log . DEBUG , "getNextRow loc= " + loc ) ; return rows . getRow ( rownum ) ; } public void addDBCellRecords ( ) { int offset = 0 ; int recnum = 0 ; int rownum = 0 ; IndexRecord index = null ; IntList rowOffsets = new IntList ( ) ; for ( recnum = 0 ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == IndexRecord . sid ) { index = ( IndexRecord ) rec ; } if ( rec . getSid ( ) != RowRecord . sid ) { offset += rec . serialize ( ) . length ; } else { break ; } } for ( ; recnum < records . size ( ) ; recnum ++ ) { Record rec = ( Record ) records . get ( recnum ) ; if ( rec . getSid ( ) == RowRecord . sid ) { rownum ++ ; rowOffsets . add ( offset ) ; if ( ( rownum % 32 ) == 0 ) { for ( int rn = recnum ; rn < records . size ( ) ; rn ++ ) { rec = ( Record ) records . get ( rn ) ; if ( ( ! rec . isInValueSection ( ) ) || ( rec . getSid ( ) == RowRecord . sid ) ) { records . add ( rn , createDBCell ( offset , rowOffsets , index ) ) ; recnum = rn ; break ; } } } else { } } if ( ! rec . isInValueSection ( ) ) { records . add ( recnum , createDBCell ( offset , rowOffsets , index ) ) ; break ; } offset += rec . serialize ( ) . length ; } } private DBCellRecord createDBCell ( int offset , IntList rowoffsets , IndexRecord index ) { DBCellRecord rec = new DBCellRecord ( ) ; rec . setRowOffset ( offset - rowoffsets . get ( 0 ) ) ; rec . addCellOffset ( ( short ) 0x0 ) ; addDbCellToIndex ( offset , index ) ; return rec ; } private void addDbCellToIndex ( int offset , IndexRecord index ) { int numdbcells = index . getNumDbcells ( ) + 1 ; index . addDbcell ( offset + preoffset ) ; for ( int k = 0 ; k < numdbcells ; k ++ ) { int dbval = index . getDbcellAt ( k ) ; index . setDbcell ( k , dbval + 4 ) ; } } protected Record createBOF ( ) { BOFRecord retval = new BOFRecord ( ) ; retval . setVersion ( ( short ) 0x600 ) ; retval . setType ( ( short ) 0x010 ) ; retval . setBuild ( ( short ) 0x0dbb ) ; retval . setBuildYear ( ( short ) 1996 ) ; retval . setHistoryBitMask ( 0xc1 ) ; retval . setRequiredVersion ( 0x6 ) ; return retval ; } protected Record createIndex ( ) { IndexRecord retval = new IndexRecord ( ) ; retval . setFirstRow ( 0 ) ; retval . setLastRowAdd1 ( 0 ) ; return retval ; } protected Record createCalcMode ( ) { CalcModeRecord retval = new CalcModeRecord ( ) ; retval . setCalcMode ( ( short ) 1 ) ; return retval ; } protected Record createCalcCount ( ) { CalcCountRecord retval = new CalcCountRecord ( ) ; retval . setIterations ( ( short ) 0x64 ) ; return retval ; } protected Record createRefMode ( ) { RefModeRecord retval = new RefModeRecord ( ) ; retval . setMode ( retval . USE_A1_MODE ) ; return retval ; } protected Record createIteration ( ) { IterationRecord retval = new IterationRecord ( ) ; retval . setIteration ( false ) ; return retval ; } protected Record createDelta ( ) { DeltaRecord retval = new DeltaRecord ( ) ; retval . setMaxChange ( 0.0010 ) ; return retval ; } protected Record createSaveRecalc ( ) { SaveRecalcRecord retval = new SaveRecalcRecord ( ) ; retval . setRecalc ( true ) ; return retval ; } protected Record createPrintHeaders ( ) { PrintHeadersRecord retval = new PrintHeadersRecord ( ) ; retval . setPrintHeaders ( false ) ; return retval ; } protected Record createPrintGridlines ( ) { PrintGridlinesRecord retval = new PrintGridlinesRecord ( ) ; retval . setPrintGridlines ( false ) ; return retval ; } protected Record createGridset ( ) { GridsetRecord retval = new GridsetRecord ( ) ; retval . setGridset ( true ) ; return retval ; } protected Record createGuts ( ) { GutsRecord retval = new GutsRecord ( ) ; retval . setLeftRowGutter ( ( short ) 0 ) ; retval . setTopColGutter ( ( short ) 0 ) ; retval . setRowLevelMax ( ( short ) 0 ) ; retval . setColLevelMax ( ( short ) 0 ) ; return retval ; } protected Record createDefaultRowHeight ( ) { DefaultRowHeightRecord retval = new DefaultRowHeightRecord ( ) ; retval . setOptionFlags ( ( short ) 0 ) ; retval . setRowHeight ( ( short ) 0xff ) ; return retval ; } protected Record createWSBool ( ) { WSBoolRecord retval = new WSBoolRecord ( ) ; retval . setWSBool1 ( ( byte ) 0x4 ) ; retval . setWSBool2 ( ( byte ) 0xffffffc1 ) ; return retval ; } protected Record createHeader ( ) { HeaderRecord retval = new HeaderRecord ( ) ; retval . setHeaderLength ( ( byte ) 0 ) ; retval . setHeader ( null ) ; return retval ; } protected Record createFooter ( ) { FooterRecord retval = new FooterRecord ( ) ; retval . setFooterLength ( ( byte ) 0 ) ; retval . setFooter ( null ) ; return retval ; } protected Record createHCenter ( ) { HCenterRecord retval = new HCenterRecord ( ) ; retval . setHCenter ( false ) ; return retval ; } protected Record createVCenter ( ) { VCenterRecord retval = new VCenterRecord ( ) ; retval . setVCenter ( false ) ; return retval ; } protected Record createPrintSetup ( ) { PrintSetupRecord retval = new PrintSetupRecord ( ) ; retval . setPaperSize ( ( short ) 1 ) ; retval . setScale ( ( short ) 100 ) ; retval . setPageStart ( ( short ) 1 ) ; retval . setFitWidth ( ( short ) 1 ) ; retval . setFitHeight ( ( short ) 1 ) ; retval . setOptions ( ( short ) 2 ) ; retval . setHResolution ( ( short ) 300 ) ; retval . setVResolution ( ( short ) 300 ) ; retval . setHeaderMargin ( 0.5 ) ; retval . setFooterMargin ( 0.5 ) ; retval . setCopies ( ( short ) 0 ) ; return retval ; } protected Record createDefaultColWidth ( ) { DefaultColWidthRecord retval = new DefaultColWidthRecord ( ) ; retval . setColWidth ( ( short ) 8 ) ; return retval ; } protected Record createColInfo ( ) { ColumnInfoRecord retval = new ColumnInfoRecord ( ) ; retval . setColumnWidth ( ( short ) 0x8 ) ; retval . setOptions ( ( short ) 6 ) ; retval . setXFIndex ( ( short ) 0x0f ) ; return retval ; } public short getDefaultColumnWidth ( ) { return defaultcolwidth . getColWidth ( ) ; } public boolean isGridsPrinted ( ) { return ! gridset . getGridset ( ) ; } public void setGridsPrinted ( boolean value ) { gridset . setGridset ( ! value ) ; } public void setDefaultColumnWidth ( short dcw ) { defaultcolwidth . setColWidth ( dcw ) ; } public void setDefaultRowHeight ( short dch ) { defaultrowheight . setRowHeight ( dch ) ; } public short getDefaultRowHeight ( ) { return defaultrowheight . getRowHeight ( ) ; } public short getColumnWidth ( short column ) { short retval = 0 ; ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes != null ) { for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } } if ( ci != null ) { retval = ci . getColumnWidth ( ) ; } else { retval = defaultcolwidth . getColWidth ( ) ; } return retval ; } public void setColumnWidth ( short column , short width ) { ColumnInfoRecord ci = null ; int k = 0 ; if ( columnSizes == null ) { columnSizes = new ArrayList ( ) ; } for ( k = 0 ; k < columnSizes . size ( ) ; k ++ ) { ci = ( ColumnInfoRecord ) columnSizes . get ( k ) ; if ( ( ci . getFirstColumn ( ) <= column ) && ( column <= ci . getLastColumn ( ) ) ) { break ; } ci = null ; } if ( ci != null ) { if ( ci . getColumnWidth ( ) == width ) { } else if ( ( ci . getFirstColumn ( ) == column ) && ( ci . getLastColumn ( ) == column ) ) { ci . setColumnWidth ( width ) ; } else if ( ( ci . getFirstColumn ( ) == column ) || ( ci . getLastColumn ( ) == column ) ) { if ( ci . getFirstColumn ( ) == column ) { ci . setFirstColumn ( ( short ) ( column + 1 ) ) ; } else { ci . setLastColumn ( ( short ) ( column - 1 ) ) ; } ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } else { short lastcolumn = ci . getLastColumn ( ) ; ci . setLastColumn ( ( short ) ( column - 1 ) ) ; ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( ( short ) ( column + 1 ) ) ; nci . setLastColumn ( lastcolumn ) ; nci . setOptions ( ci . getOptions ( ) ) ; nci . setXFIndex ( ci . getXFIndex ( ) ) ; nci . setColumnWidth ( ci . getColumnWidth ( ) ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } else { ColumnInfoRecord nci = ( ColumnInfoRecord ) createColInfo ( ) ; nci . setFirstColumn ( column ) ; nci . setLastColumn ( column ) ; nci . setColumnWidth ( width ) ; columnSizes . add ( k , nci ) ; records . add ( ( 1 + getDimsLoc ( ) - columnSizes . size ( ) ) + k , nci ) ; dimsloc ++ ; } } protected Record createDimensions ( ) { DimensionsRecord retval = new DimensionsRecord ( ) ; retval . setFirstCol ( ( short ) 0 ) ; retval . setLastRow ( 1 ) ; retval . setFirstRow ( 0 ) ; retval . setLastCol ( ( short ) 1 ) ; return retval ; } protected WindowTwoRecord createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) 0x6b6 ) ; retval . setTopRow ( ( short ) 0 ) ; retval . setLeftCol ( ( short ) 0 ) ; retval . setHeaderColor ( 0x40 ) ; retval . setPageBreakZoom ( ( short ) 0 ) ; retval . setNormalZoom ( ( short ) 0 ) ; return retval ; } protected Record createSelection ( ) { SelectionRecord retval = new SelectionRecord ( ) ; retval . setPane ( ( byte ) 0x3 ) ; retval . setActiveCellCol ( ( short ) 0x0 ) ; retval . setActiveCellRow ( ( short ) 0x0 ) ; retval . setNumRefs ( ( short ) 0x0 ) ; return retval ; } public int getActiveCellRow ( ) { if ( selection == null ) { return 0 ; } return selection . getActiveCellRow ( ) ; } public void setActiveCellRow ( int row ) { if ( selection != null ) { selection . setActiveCellRow ( row ) ; } } public short getActiveCellCol ( ) { if ( selection == null ) { return ( short ) 0 ; } return selection . getActiveCellCol ( ) ; } public void setActiveCellCol ( short col ) { if ( selection != null ) { selection . setActiveCellCol ( col ) ; } } protected Record createMergedCells ( ) { MergeCellsRecord retval = new MergeCellsRecord ( ) ; retval . setNumAreas ( ( short ) 0 ) ; return retval ; } protected Record createEOF ( ) { return new EOFRecord ( ) ; } public int getDimsLoc ( ) { log . log ( log . DEBUG , "getDimsLoc dimsloc= " + dimsloc ) ; return dimsloc ; } public void checkDimsLoc ( Record rec , int recloc ) { if ( rec . getSid ( ) == DimensionsRecord . sid ) { loc = recloc ; dimsloc = recloc ; } } public int getSize ( ) { int retval = 0 ; for ( int k = 0 ; k < records . size ( ) ; k ++ ) { retval += ( ( Record ) records . get ( k ) ) . getRecordSize ( ) ; } return retval ; } public List getRecords ( ) { return records ; } public GridsetRecord getGridsetRecord ( ) { return gridset ; } public Record findFirstRecordBySid ( short sid ) { for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return record ; } } return null ; } public void setSCLRecord ( SCLRecord sclRecord ) { int oldRecordLoc = findFirstRecordLocBySid ( SCLRecord . sid ) ; if ( oldRecordLoc == - 1 ) { int windowRecordLoc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; records . add ( windowRecordLoc + 1 , sclRecord ) ; } else { records . set ( oldRecordLoc , sclRecord ) ; } } public int findFirstRecordLocBySid ( short sid ) { int index = 0 ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; if ( record . getSid ( ) == sid ) { return index ; } index ++ ; } return - 1 ; } public HeaderRecord getHeader ( ) { return header ; } public void setHeader ( HeaderRecord newHeader ) { header = newHeader ; } public FooterRecord getFooter ( ) { return footer ; } public void setFooter ( FooterRecord newFooter ) { footer = newFooter ; } public PrintSetupRecord getPrintSetup ( ) { return printSetup ; } public void setPrintSetup ( PrintSetupRecord newPrintSetup ) { printSetup = newPrintSetup ; } public PrintGridlinesRecord getPrintGridlines ( ) { return printGridlines ; } public void setPrintGridlines ( PrintGridlinesRecord newPrintGridlines ) { printGridlines = newPrintGridlines ; } public void setSelected ( boolean sel ) { windowTwo . setSelected ( sel ) ; } public double getMargin ( short margin ) { if ( getMargins ( ) [ margin ] != null ) return margins [ margin ] . getMargin ( ) ; else { switch ( margin ) { case LeftMargin : return .75 ; case RightMargin : return .75 ; case TopMargin : return 1.0 ; case BottomMargin : return 1.0 ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } } } public void setMargin ( short margin , double size ) { Margin m = getMargins ( ) [ margin ] ; if ( m == null ) { switch ( margin ) { case LeftMargin : m = new LeftMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case RightMargin : m = new RightMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case TopMargin : m = new TopMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; case BottomMargin : m = new BottomMarginRecord ( ) ; records . add ( getDimsLoc ( ) + 1 , m ) ; break ; default : throw new RuntimeException ( "Unknown margin constant:  " + margin ) ; } margins [ margin ] = m ; } m . setMargin ( size ) ; } public int getEofLoc ( ) { return eofLoc ; } public void createFreezePane ( int colSplit , int rowSplit , int topRow , int leftmostColumn ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord pane = new PaneRecord ( ) ; pane . setX ( ( short ) colSplit ) ; pane . setY ( ( short ) rowSplit ) ; pane . setTopRow ( ( short ) topRow ) ; pane . setLeftColumn ( ( short ) leftmostColumn ) ; if ( rowSplit == 0 ) { pane . setTopRow ( ( short ) 0 ) ; pane . setActivePane ( ( short ) 1 ) ; } else if ( colSplit == 0 ) { pane . setLeftColumn ( ( short ) 64 ) ; pane . setActivePane ( ( short ) 2 ) ; } else { pane . setActivePane ( ( short ) 0 ) ; } records . add ( loc + 1 , pane ) ; windowTwo . setFreezePanes ( true ) ; windowTwo . setFreezePanesNoSplit ( true ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( ( byte ) pane . getActivePane ( ) ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public void createSplitPane ( int xSplitPos , int ySplitPos , int topRow , int leftmostColumn , int activePane ) { int loc = findFirstRecordLocBySid ( WindowTwoRecord . sid ) ; PaneRecord r = new PaneRecord ( ) ; r . setX ( ( short ) xSplitPos ) ; r . setY ( ( short ) ySplitPos ) ; r . setTopRow ( ( short ) topRow ) ; r . setLeftColumn ( ( short ) leftmostColumn ) ; r . setActivePane ( ( short ) activePane ) ; records . add ( loc + 1 , r ) ; windowTwo . setFreezePanes ( false ) ; windowTwo . setFreezePanesNoSplit ( false ) ; SelectionRecord sel = ( SelectionRecord ) findFirstRecordBySid ( SelectionRecord . sid ) ; sel . setPane ( PANE_LOWER_RIGHT ) ; int selLoc = findFirstRecordLocBySid ( SelectionRecord . sid ) ; } public SelectionRecord getSelection ( ) { return selection ; } public void setSelection ( SelectionRecord selection ) { this . selection = selection ; } protected Record createProtect ( ) { log . log ( log . DEBUG , "create protect record with protection disabled" ) ; ProtectRecord retval = new ProtectRecord ( ) ; retval . setProtect ( false ) ; return retval ; } public ProtectRecord getProtect ( ) { return protect ; } public void setDisplayGridlines ( boolean show ) { windowTwo . setDisplayGridlines ( show ) ; } public boolean isDisplayGridlines ( ) { return windowTwo . getDisplayGridlines ( ) ; } public void setDisplayFormulas ( boolean show ) { windowTwo . setDisplayFormulas ( show ) ; } public boolean isDisplayFormulas ( ) { return windowTwo . getDisplayFormulas ( ) ; } public void setDisplayRowColHeadings ( boolean show ) { windowTwo . setDisplayRowColHeadings ( show ) ; } public boolean isDisplayRowColHeadings ( ) { return windowTwo . getDisplayRowColHeadings ( ) ; } protected Margin [ ] getMargins ( ) { if ( margins == null ) margins = new Margin [ 4 ] ; return margins ; } } 	1	['108', '1', '0', '60', '341', '4268', '5', '55', '75', '0.93564753', '3365', '0.714285714', '16', '0', '0.078971963', '0', '0', '29.83333333', '34', '2.0556', '1']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FontRecord ; public class HSSFFont { public final static String FONT_ARIAL = "Arial" ; public final static short BOLDWEIGHT_NORMAL = 0x190 ; public final static short BOLDWEIGHT_BOLD = 0x2bc ; public final static short COLOR_NORMAL = 0x7fff ; public final static short COLOR_RED = 0xa ; public final static short SS_NONE = 0 ; public final static short SS_SUPER = 1 ; public final static short SS_SUB = 2 ; public final static byte U_NONE = 0 ; public final static byte U_SINGLE = 1 ; public final static byte U_DOUBLE = 2 ; public final static byte U_SINGLE_ACCOUNTING = 0x21 ; public final static byte U_DOUBLE_ACCOUNTING = 0x22 ; private FontRecord font ; private short index ; protected HSSFFont ( short index , FontRecord rec ) { font = rec ; this . index = index ; } public void setFontName ( String name ) { font . setFontName ( name ) ; font . setFontNameLength ( ( byte ) name . length ( ) ) ; } public String getFontName ( ) { return font . getFontName ( ) ; } public short getIndex ( ) { return index ; } public void setFontHeight ( short height ) { font . setFontHeight ( height ) ; } public void setFontHeightInPoints ( short height ) { font . setFontHeight ( ( short ) ( height * 20 ) ) ; } public short getFontHeight ( ) { return font . getFontHeight ( ) ; } public short getFontHeightInPoints ( ) { return ( short ) ( font . getFontHeight ( ) / 20 ) ; } public void setItalic ( boolean italic ) { font . setItalic ( italic ) ; } public boolean getItalic ( ) { return font . isItalic ( ) ; } public void setStrikeout ( boolean strikeout ) { font . setStrikeout ( strikeout ) ; } public boolean getStrikeout ( ) { return font . isStruckout ( ) ; } public void setColor ( short color ) { font . setColorPaletteIndex ( color ) ; } public short getColor ( ) { return font . getColorPaletteIndex ( ) ; } public void setBoldweight ( short boldweight ) { font . setBoldWeight ( boldweight ) ; } public short getBoldweight ( ) { return font . getBoldWeight ( ) ; } public void setTypeOffset ( short offset ) { font . setSuperSubScript ( offset ) ; } public short getTypeOffset ( ) { return font . getSuperSubScript ( ) ; } public void setUnderline ( byte underline ) { font . setUnderline ( underline ) ; } public byte getUnderline ( ) { return font . getUnderline ( ) ; } } 	1	['20', '1', '0', '4', '39', '0', '3', '1', '19', '0.978947368', '140', '0.133333333', '1', '0', '0.258333333', '0', '0', '5.25', '1', '0.95', '1']
package org . apache . poi . hssf . usermodel ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class HSSFDateUtil { private HSSFDateUtil ( ) { } private static final int BAD_DATE = - 1 ; private static final long DAY_MILLISECONDS = 24 * 60 * 60 * 1000 ; private static final double CAL_1900_ABSOLUTE = ( double ) absoluteDay ( new GregorianCalendar ( 1900 , Calendar . JANUARY , 1 ) ) - 2.0 ; public static double getExcelDate ( Date date ) { Calendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( date ) ; if ( calStart . get ( Calendar . YEAR ) < 1900 ) { return BAD_DATE ; } else { calStart = dayStart ( calStart ) ; double fraction = ( date . getTime ( ) - calStart . getTime ( ) . getTime ( ) ) / ( double ) DAY_MILLISECONDS ; return fraction + ( double ) absoluteDay ( calStart ) - CAL_1900_ABSOLUTE ; } } public static Date getJavaDate ( double date ) { return getJavaDate ( date , false ) ; } public static Date getJavaDate ( double date , boolean use1904windowing ) { if ( isValidExcelDate ( date ) ) { int startYear = 1900 ; int dayAdjust = - 1 ; int wholeDays = ( int ) Math . floor ( date ) ; if ( use1904windowing ) { startYear = 1904 ; dayAdjust = 1 ; } else if ( wholeDays < 61 ) { dayAdjust = 0 ; } GregorianCalendar calendar = new GregorianCalendar ( startYear , 0 , wholeDays + dayAdjust ) ; int millisecondsInDay = ( int ) ( ( date - Math . floor ( date ) ) * ( double ) DAY_MILLISECONDS + 0.5 ) ; calendar . set ( GregorianCalendar . MILLISECOND , millisecondsInDay ) ; return calendar . getTime ( ) ; } else { return null ; } } public static boolean isInternalDateFormat ( int format ) { boolean retval = false ; switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 : case 0xa8 : case 0xa9 : case 0xaa : case 0xab : case 0xac : case 0xad : retval = true ; break ; default : retval = false ; break ; } return retval ; } public static boolean isCellDateFormatted ( HSSFCell cell ) { if ( cell == null ) return false ; boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( HSSFDateUtil . isValidExcelDate ( d ) ) { HSSFCellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; } public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; } private static int absoluteDay ( Calendar cal ) { return cal . get ( Calendar . DAY_OF_YEAR ) + daysInPriorYears ( cal . get ( Calendar . YEAR ) ) ; } private static int daysInPriorYears ( int yr ) { if ( yr < 1601 ) { throw new IllegalArgumentException ( "'year' must be 1601 or greater" ) ; } int y = yr - 1601 ; int days = 365 * y + y / 4 - y / 100 + y / 400 ; return days ; } private static Calendar dayStart ( final Calendar cal ) { cal . get ( Calendar . HOUR_OF_DAY ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . get ( Calendar . HOUR_OF_DAY ) ; return cal ; } } 	1	['11', '1', '0', '2', '26', '53', '1', '2', '6', '1.033333333', '226', '1', '0', '0', '0.157142857', '0', '0', '19.27272727', '24', '3.6364', '1']
