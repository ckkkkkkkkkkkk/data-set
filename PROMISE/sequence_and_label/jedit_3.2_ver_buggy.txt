package org . gjt . sp . jedit ; import java . util . Vector ; import org . gjt . sp . jedit . gui . OptionsDialog ; public abstract class EditPlugin { public String getClassName ( ) { return getClass ( ) . getName ( ) ; } public void start ( ) { } public void stop ( ) { } public void createMenuItems ( Vector menuItems ) { } public void createMenuItems ( View view , Vector menus , Vector menuItems ) { } public void createOptionPanes ( OptionsDialog optionsDialog ) { } public EditPlugin . JAR getJAR ( ) { return jar ; } public static class Broken extends EditPlugin { public String getClassName ( ) { return clazz ; } Broken ( String clazz ) { this . clazz = clazz ; } private String clazz ; } public static class JAR { public String getPath ( ) { return path ; } public JARClassLoader getClassLoader ( ) { return classLoader ; } public void addPlugin ( EditPlugin plugin ) { plugin . jar = JAR . this ; plugins . addElement ( plugin ) ; plugin . start ( ) ; } public EditPlugin [ ] getPlugins ( ) { EditPlugin [ ] array = new EditPlugin [ plugins . size ( ) ] ; plugins . copyInto ( array ) ; return array ; } public JAR ( String path , JARClassLoader classLoader ) { this . path = path ; this . classLoader = classLoader ; plugins = new Vector ( ) ; } void getPlugins ( Vector vector ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { vector . addElement ( plugins . elementAt ( i ) ) ; } } private String path ; private JARClassLoader classLoader ; private Vector plugins ; } private EditPlugin . JAR jar ; } 	1	['10', '1', '2', '11', '13', '39', '10', '3', '8', '0.777777778', '33', '1', '1', '0', '0.25', '0', '0', '2.2', '1', '0.9', '1']
package org . gjt . sp . jedit . browser ; import gnu . regexp . * ; import javax . swing . border . EmptyBorder ; import javax . swing . event . EventListenerList ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class VFSBrowser extends JPanel implements EBComponent , DockableWindow { public static final String NAME = "vfs.browser" ; public static final int OPEN_DIALOG = 0 ; public static final int SAVE_DIALOG = 1 ; public static final int BROWSER = 2 ; public VFSBrowser ( View view , String path ) { this ( view , path , BROWSER , false ) ; } public VFSBrowser ( View view , String path , int mode , boolean multipleSelection ) { super ( new BorderLayout ( ) ) ; listenerList = new EventListenerList ( ) ; this . mode = mode ; this . multipleSelection = multipleSelection ; this . view = view ; ActionHandler actionHandler = new ActionHandler ( ) ; Box topBox = new Box ( BoxLayout . Y_AXIS ) ; topBox . add ( createToolBar ( ) ) ; GridBagLayout layout = new GridBagLayout ( ) ; JPanel pathAndFilterPanel = new JPanel ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridwidth = cons . gridheight = 1 ; cons . gridx = cons . gridy = 0 ; cons . fill = GridBagConstraints . BOTH ; cons . anchor = GridBagConstraints . EAST ; JLabel label = new JLabel ( jEdit . getProperty ( "vfs.browser.path" ) , SwingConstants . RIGHT ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; layout . setConstraints ( label , cons ) ; pathAndFilterPanel . add ( label ) ; pathField = new HistoryTextField ( "vfs.browser.path" , true , false ) ; Dimension prefSize = pathField . getPreferredSize ( ) ; prefSize . width = 0 ; pathField . setPreferredSize ( prefSize ) ; pathField . addActionListener ( actionHandler ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( pathField , cons ) ; pathAndFilterPanel . add ( pathField ) ; filterCheckbox = new JCheckBox ( jEdit . getProperty ( "vfs.browser.filter" ) ) ; filterCheckbox . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; filterCheckbox . setRequestFocusEnabled ( false ) ; filterCheckbox . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; filterCheckbox . setSelected ( mode != BROWSER || jEdit . getBooleanProperty ( "vfs.browser.filter-enabled" ) ) ; filterCheckbox . setForeground ( new Color ( UIManager . getColor ( "Label.foreground" ) . getRGB ( ) ) ) ; filterCheckbox . addActionListener ( actionHandler ) ; cons . gridx = 0 ; cons . weightx = 0.0f ; cons . gridy = 1 ; layout . setConstraints ( filterCheckbox , cons ) ; pathAndFilterPanel . add ( filterCheckbox ) ; filterField = new HistoryTextField ( "vfs.browser.filter" , true ) ; filterField . addActionListener ( actionHandler ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( filterField , cons ) ; pathAndFilterPanel . add ( filterField ) ; topBox . add ( pathAndFilterPanel ) ; add ( BorderLayout . NORTH , topBox ) ; add ( BorderLayout . CENTER , browserView = new BrowserView ( this ) ) ; propertiesChanged ( ) ; HistoryModel filterModel = HistoryModel . getModel ( "vfs.browser.filter" ) ; String filter ; if ( mode == BROWSER || view == null || ! jEdit . getBooleanProperty ( "vfs.browser.currentBufferFilter" ) ) { filter = jEdit . getProperty ( "vfs.browser.last-filter" ) ; if ( filter == null ) filter = jEdit . getProperty ( "vfs.browser.default-filter" ) ; } else { String name = view . getBuffer ( ) . getName ( ) ; int index = name . lastIndexOf ( '.' ) ; if ( index == - 1 ) filter = jEdit . getProperty ( "vfs.browser.default-filter" ) ; else { String ext = name . substring ( index ) ; filter = "*" + ext ; } } filterField . setText ( filter ) ; filterField . addCurrentToHistory ( ) ; updateFilterEnabled ( ) ; if ( path == null ) { String defaultPath = jEdit . getProperty ( "vfs.browser.defaultPath" ) ; String userHome = System . getProperty ( "user.home" ) ; if ( defaultPath . equals ( "home" ) ) path = userHome ; else if ( defaultPath . equals ( "buffer" ) ) { if ( view != null ) { Buffer buffer = view . getBuffer ( ) ; path = buffer . getVFS ( ) . getParentOfPath ( buffer . getPath ( ) ) ; } else path = userHome ; } else if ( defaultPath . equals ( "last" ) ) { HistoryModel pathModel = HistoryModel . getModel ( "vfs.browser.path" ) ; if ( pathModel . getSize ( ) == 0 ) path = userHome ; else path = pathModel . getItem ( 0 ) ; } else if ( defaultPath . equals ( "favorites" ) ) path = "favorites:" ; else { path = userHome ; } } setDirectory ( path ) ; } public void addNotify ( ) { super . addNotify ( ) ; EditBus . addToBus ( this ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; jEdit . setBooleanProperty ( "vfs.browser.filter-enabled" , filterCheckbox . isSelected ( ) ) ; if ( mode == BROWSER || ! jEdit . getBooleanProperty ( "vfs.browser.currentBufferFilter" ) ) { jEdit . setProperty ( "vfs.browser.last-filter" , filterField . getText ( ) ) ; } EditBus . removeFromBus ( this ) ; } public String getName ( ) { return NAME ; } public Component getComponent ( ) { return this ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof ViewUpdate ) handleViewUpdate ( ( ViewUpdate ) msg ) ; else if ( msg instanceof BufferUpdate ) handleBufferUpdate ( ( BufferUpdate ) msg ) ; else if ( msg instanceof PropertiesChanged ) propertiesChanged ( ) ; else if ( msg instanceof VFSUpdate ) { if ( requestRunning ) return ; browserView . reloadDirectory ( ( ( VFSUpdate ) msg ) . getPath ( ) ) ; } } public String getDirectory ( ) { return path ; } public void setDirectory ( String path ) { if ( path . length ( ) != 1 && ( path . endsWith ( "/" ) || path . endsWith ( java . io . File . separator ) ) ) path = path . substring ( 0 , path . length ( ) - 1 ) ; if ( path . startsWith ( "file:" ) ) path = path . substring ( 5 ) ; this . path = path ; pathField . setText ( path ) ; pathField . addCurrentToHistory ( ) ; reloadDirectory ( ) ; } public void reloadDirectory ( ) { try { String filter = filterField . getText ( ) ; if ( filter . length ( ) == 0 ) filter = "*" ; filenameFilter = new RE ( MiscUtilities . globToRE ( filter ) , RE . REG_ICASE ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , VFSBrowser . this , e ) ; String [ ] args = { filterField . getText ( ) , e . getMessage ( ) } ; GUIUtilities . error ( VFSBrowser . this , "vfs.browser.bad-filter" , args ) ; } loadDirectory ( path ) ; } public void loadDirectory ( String path ) { VFS vfs = VFSManager . getVFSForPath ( path ) ; Object session = vfs . createVFSSession ( path , this ) ; if ( session == null ) return ; if ( ! startRequest ( ) ) return ; VFSManager . runInWorkThread ( new BrowserIORequest ( BrowserIORequest . LIST_DIRECTORY , this , session , vfs , path , null ) ) ; } public void delete ( String path ) { if ( MiscUtilities . isURL ( path ) && FavoritesVFS . PROTOCOL . equals ( MiscUtilities . getProtocolOfURL ( path ) ) ) { Object [ ] args = { path . substring ( FavoritesVFS . PROTOCOL . length ( ) + 1 ) } ; int result = GUIUtilities . confirm ( this , "vfs.browser.delete-favorites" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } else { Object [ ] args = { path } ; int result = GUIUtilities . confirm ( this , "vfs.browser.delete-confirm" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } VFS vfs = VFSManager . getVFSForPath ( path ) ; Object session = vfs . createVFSSession ( path , this ) ; if ( session == null ) return ; if ( ! startRequest ( ) ) return ; VFSManager . runInWorkThread ( new BrowserIORequest ( BrowserIORequest . DELETE , this , session , vfs , path , null ) ) ; } public void rename ( String from ) { VFS vfs = VFSManager . getVFSForPath ( from ) ; String filename = vfs . getFileName ( from ) ; String [ ] args = { filename } ; String to = GUIUtilities . input ( this , "vfs.browser.rename" , args , filename ) ; if ( to == null ) return ; to = vfs . constructPath ( vfs . getParentOfPath ( from ) , to ) ; Object session = vfs . createVFSSession ( from , this ) ; if ( session == null ) return ; if ( ! startRequest ( ) ) return ; VFSManager . runInWorkThread ( new BrowserIORequest ( BrowserIORequest . RENAME , this , session , vfs , from , to ) ) ; } public void mkdir ( ) { String newDirectory = GUIUtilities . input ( this , "vfs.browser.mkdir" , null ) ; if ( newDirectory == null ) return ; VFS . DirectoryEntry [ ] selected = getSelectedFiles ( ) ; String parent ; if ( selected . length == 0 ) parent = path ; else if ( selected [ 0 ] . type == VFS . DirectoryEntry . FILE ) { parent = selected [ 0 ] . path ; parent = VFSManager . getVFSForPath ( parent ) . getParentOfPath ( parent ) ; } else parent = selected [ 0 ] . path ; VFS vfs = VFSManager . getVFSForPath ( parent ) ; newDirectory = vfs . constructPath ( parent , newDirectory ) ; Object session = vfs . createVFSSession ( newDirectory , this ) ; if ( session == null ) return ; if ( ! startRequest ( ) ) return ; VFSManager . runInWorkThread ( new BrowserIORequest ( BrowserIORequest . MKDIR , this , session , vfs , newDirectory , null ) ) ; } public View getView ( ) { return view ; } public int getMode ( ) { return mode ; } public boolean isMultipleSelectionEnabled ( ) { return multipleSelection ; } public boolean getShowHiddenFiles ( ) { return showHiddenFiles ; } public void setShowHiddenFiles ( boolean showHiddenFiles ) { this . showHiddenFiles = showHiddenFiles ; } public String getFilenameFilter ( ) { if ( filterCheckbox . isSelected ( ) ) { String filter = filterField . getText ( ) ; if ( filter . length ( ) == 0 ) return "*" ; else return filter ; } else return "*" ; } public void setFilenameFilter ( String filter ) { if ( filter == null || filter . length ( ) == 0 || filter . equals ( "*" ) ) filterCheckbox . setSelected ( false ) ; else { filterCheckbox . setSelected ( true ) ; filterField . setText ( filter ) ; } } public BrowserView getBrowserView ( ) { return browserView ; } public VFS . DirectoryEntry [ ] getSelectedFiles ( ) { return browserView . getSelectedFiles ( ) ; } public void addBrowserListener ( BrowserListener l ) { listenerList . add ( BrowserListener . class , l ) ; } public void removeBrowserListener ( BrowserListener l ) { listenerList . remove ( BrowserListener . class , l ) ; } void directoryLoaded ( final VFS . DirectoryEntry [ ] list ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { boolean filterEnabled = filterCheckbox . isSelected ( ) ; Vector directoryVector = new Vector ( ) ; if ( list == null ) { browserView . directoryLoaded ( directoryVector ) ; return ; } for ( int i = 0 ; i < list . length ; i ++ ) { VFS . DirectoryEntry file = list [ i ] ; if ( file . hidden && ! showHiddenFiles ) continue ; if ( file . type == VFS . DirectoryEntry . FILE && filterEnabled && filenameFilter != null && ! filenameFilter . isMatch ( file . name ) ) continue ; directoryVector . addElement ( file ) ; } if ( sortFiles ) { MiscUtilities . quicksort ( directoryVector , new FileCompare ( ) ) ; } browserView . directoryLoaded ( directoryVector ) ; } } ) ; } class FileCompare implements MiscUtilities . Compare { public int compare ( Object obj1 , Object obj2 ) { VFS . DirectoryEntry file1 = ( VFS . DirectoryEntry ) obj1 ; VFS . DirectoryEntry file2 = ( VFS . DirectoryEntry ) obj2 ; if ( ! sortMixFilesAndDirs ) { if ( file1 . type != file2 . type ) return file2 . type - file1 . type ; } if ( sortIgnoreCase ) { return file1 . name . toLowerCase ( ) . compareTo ( file2 . name . toLowerCase ( ) ) ; } else { return file1 . name . compareTo ( file2 . name ) ; } } } void filesSelected ( ) { VFS . DirectoryEntry [ ] selectedFiles = browserView . getSelectedFiles ( ) ; if ( mode == BROWSER ) { for ( int i = 0 ; i < selectedFiles . length ; i ++ ) { VFS . DirectoryEntry file = selectedFiles [ i ] ; Buffer buffer = jEdit . getBuffer ( file . path ) ; if ( buffer != null && view != null ) view . setBuffer ( buffer ) ; } } Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { if ( listeners [ i ] == BrowserListener . class ) { BrowserListener l = ( BrowserListener ) listeners [ i + 1 ] ; l . filesSelected ( this , selectedFiles ) ; } } } void filesActivated ( ) { VFS . DirectoryEntry [ ] selectedFiles = browserView . getSelectedFiles ( ) ; for ( int i = 0 ; i < selectedFiles . length ; i ++ ) { VFS . DirectoryEntry file = selectedFiles [ i ] ; if ( file . type == VFS . DirectoryEntry . DIRECTORY || file . type == VFS . DirectoryEntry . FILESYSTEM ) setDirectory ( file . path ) ; else if ( mode == BROWSER ) { Buffer buffer = jEdit . getBuffer ( file . path ) ; if ( buffer == null ) buffer = jEdit . openFile ( null , file . path ) ; else if ( doubleClickClose ) { jEdit . closeBuffer ( view , buffer ) ; break ; } if ( buffer != null ) { if ( view == null ) view = jEdit . newView ( null , buffer ) ; else view . setBuffer ( buffer ) ; } } else { } } Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { if ( listeners [ i ] == BrowserListener . class ) { BrowserListener l = ( BrowserListener ) listeners [ i + 1 ] ; l . filesActivated ( this , selectedFiles ) ; } } } void endRequest ( ) { requestRunning = false ; } private EventListenerList listenerList ; private View view ; private String path ; private HistoryTextField pathField ; private JCheckBox filterCheckbox ; private HistoryTextField filterField ; private JButton up , reload , roots , home , synchronize ; private BrowserView browserView ; private RE filenameFilter ; private int mode ; private boolean multipleSelection ; private boolean showHiddenFiles ; private boolean sortFiles ; private boolean sortMixFilesAndDirs ; private boolean sortIgnoreCase ; private boolean doubleClickClose ; private boolean requestRunning ; private JToolBar createToolBar ( ) { JToolBar toolBar = new JToolBar ( ) ; toolBar . setFloatable ( false ) ; toolBar . putClientProperty ( "JToolBar.isRollover" , Boolean . TRUE ) ; toolBar . add ( up = createToolButton ( "up" ) ) ; toolBar . add ( new UpMenuButton ( up ) ) ; toolBar . add ( reload = createToolButton ( "reload" ) ) ; toolBar . addSeparator ( ) ; toolBar . add ( roots = createToolButton ( "roots" ) ) ; toolBar . add ( home = createToolButton ( "home" ) ) ; toolBar . add ( synchronize = createToolButton ( "synchronize" ) ) ; toolBar . addSeparator ( ) ; toolBar . add ( new MoreMenuButton ( ) ) ; toolBar . add ( Box . createGlue ( ) ) ; return toolBar ; } private JButton createToolButton ( String name ) { JButton button = new JButton ( ) ; String prefix = "vfs.browser." ; button . setIcon ( GUIUtilities . loadIcon ( jEdit . getProperty ( prefix + name + ".icon" ) ) ) ; button . setToolTipText ( jEdit . getProperty ( prefix + name + ".label" ) ) ; button . setRequestFocusEnabled ( false ) ; button . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; button . addActionListener ( new ActionHandler ( ) ) ; return button ; } private void handleViewUpdate ( ViewUpdate vmsg ) { if ( vmsg . getWhat ( ) == ViewUpdate . CLOSED && vmsg . getView ( ) == view ) view = null ; } private void handleBufferUpdate ( BufferUpdate bmsg ) { if ( bmsg . getWhat ( ) == BufferUpdate . CREATED || bmsg . getWhat ( ) == BufferUpdate . CLOSED ) browserView . updateFileView ( ) ; else if ( bmsg . getWhat ( ) == BufferUpdate . DIRTY_CHANGED ) { if ( ! bmsg . getBuffer ( ) . isDirty ( ) ) browserView . updateFileView ( ) ; } } private void propertiesChanged ( ) { showHiddenFiles = jEdit . getBooleanProperty ( "vfs.browser.showHiddenFiles" ) ; sortFiles = jEdit . getBooleanProperty ( "vfs.browser.sortFiles" ) ; sortMixFilesAndDirs = jEdit . getBooleanProperty ( "vfs.browser.sortMixFilesAndDirs" ) ; sortIgnoreCase = jEdit . getBooleanProperty ( "vfs.browser.sortIgnoreCase" ) ; doubleClickClose = jEdit . getBooleanProperty ( "vfs.browser.doubleClickClose" ) ; browserView . propertiesChanged ( ) ; if ( path != null ) reloadDirectory ( ) ; } private boolean startRequest ( ) { if ( requestRunning ) { Log . log ( Log . DEBUG , this , new Throwable ( "For debugging purposes" ) ) ; GUIUtilities . error ( this , "browser-multiple-io" , null ) ; return false ; } else { requestRunning = true ; return true ; } } private void updateFilterEnabled ( ) { filterField . setEnabled ( filterCheckbox . isSelected ( ) ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == pathField || source == filterField || source == filterCheckbox ) { updateFilterEnabled ( ) ; String path = pathField . getText ( ) ; if ( path != null ) setDirectory ( path ) ; } else if ( source == up ) { VFS vfs = VFSManager . getVFSForPath ( path ) ; setDirectory ( vfs . getParentOfPath ( path ) ) ; } else if ( source == reload ) reloadDirectory ( ) ; else if ( source == roots ) setDirectory ( FileRootsVFS . PROTOCOL + ":" ) ; else if ( source == home ) setDirectory ( System . getProperty ( "user.home" ) ) ; else if ( source == synchronize ) { if ( view != null ) { Buffer buffer = view . getBuffer ( ) ; setDirectory ( buffer . getVFS ( ) . getParentOfPath ( buffer . getPath ( ) ) ) ; } else getToolkit ( ) . beep ( ) ; } } } class UpMenuButton extends JButton { UpMenuButton ( JButton upButton ) { this . upButton = upButton ; setIcon ( GUIUtilities . loadIcon ( jEdit . getProperty ( "vfs.browser.up-menu.icon" ) ) ) ; UpMenuButton . this . setToolTipText ( jEdit . getProperty ( "vfs.browser.up-menu.label" ) ) ; UpMenuButton . this . setRequestFocusEnabled ( false ) ; setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; UpMenuButton . this . addMouseListener ( new MouseHandler ( ) ) ; } private JButton upButton ; private JPopupMenu popup ; private void createPopup ( ) { popup = new JPopupMenu ( ) ; ActionHandler actionHandler = new ActionHandler ( ) ; VFS vfs = VFSManager . getVFSForPath ( path ) ; String dir = vfs . getParentOfPath ( path ) ; for ( ; ; ) { JMenuItem menuItem = new JMenuItem ( dir ) ; menuItem . addActionListener ( actionHandler ) ; popup . add ( menuItem ) ; String parentDir = vfs . getParentOfPath ( dir ) ; if ( parentDir . equals ( dir ) ) break ; else dir = parentDir ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { setDirectory ( evt . getActionCommand ( ) ) ; } } class MouseHandler extends MouseAdapter { public void mousePressed ( MouseEvent evt ) { if ( popup == null || ! popup . isVisible ( ) ) { createPopup ( ) ; popup . show ( upButton , 0 , upButton . getHeight ( ) ) ; } else { popup . setVisible ( false ) ; popup = null ; } } } } class MoreMenuButton extends JButton { MoreMenuButton ( ) { setText ( jEdit . getProperty ( "vfs.browser.more.label" ) ) ; setIcon ( GUIUtilities . loadIcon ( jEdit . getProperty ( "vfs.browser.more.icon" ) ) ) ; setHorizontalTextPosition ( SwingConstants . LEFT ) ; MoreMenuButton . this . setRequestFocusEnabled ( false ) ; setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; MoreMenuButton . this . addMouseListener ( new MouseHandler ( ) ) ; } JPopupMenu popup ; class MouseHandler extends MouseAdapter { public void mousePressed ( MouseEvent evt ) { if ( popup == null || ! popup . isVisible ( ) ) { popup = new BrowserPopupMenu ( VFSBrowser . this , null ) ; popup . show ( MoreMenuButton . this , 0 , MoreMenuButton . this . getHeight ( ) ) ; } else { popup . setVisible ( false ) ; popup = null ; } } } } } 	1	['54', '5', '0', '41', '175', '1183', '21', '27', '25', '0.930333817', '1425', '0.846153846', '5', '0.926241135', '0.122895623', '3', '12', '24.90740741', '11', '2.1296', '18']
package org . gjt . sp . jedit . options ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; public class DockingOptionPane extends AbstractOptionPane { public DockingOptionPane ( ) { super ( "docking" ) ; } public void _init ( ) { Box box = new Box ( BoxLayout . X_AXIS ) ; ButtonGroup grp = new ButtonGroup ( ) ; layout1 = new JToggleButton ( GUIUtilities . loadIcon ( "dock_layout1.gif" ) ) ; grp . add ( layout1 ) ; box . add ( layout1 ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; layout2 = new JToggleButton ( GUIUtilities . loadIcon ( "dock_layout2.gif" ) ) ; grp . add ( layout2 ) ; box . add ( layout2 ) ; if ( jEdit . getBooleanProperty ( "view.docking.alternateLayout" ) ) layout2 . setSelected ( true ) ; else layout1 . setSelected ( true ) ; addComponent ( jEdit . getProperty ( "options.docking.layout" ) , box ) ; String [ ] positions = { jEdit . getProperty ( "options.docking.top" ) , jEdit . getProperty ( "options.docking.bottom" ) , } ; tabsPos = new JComboBox ( positions ) ; tabsPos . setSelectedIndex ( Integer . parseInt ( jEdit . getProperty ( "view.docking.tabsPos" ) ) ) ; addComponent ( jEdit . getProperty ( "options.docking.tabsPos" ) , tabsPos ) ; addComponent ( Box . createVerticalStrut ( 6 ) ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = 3 ; cons . gridwidth = cons . gridheight = GridBagConstraints . REMAINDER ; cons . fill = GridBagConstraints . BOTH ; cons . weightx = cons . weighty = 1.0f ; JScrollPane windowScroller = createWindowTableScroller ( ) ; gridBag . setConstraints ( windowScroller , cons ) ; add ( windowScroller ) ; } public void _save ( ) { jEdit . setBooleanProperty ( "view.docking.alternateLayout" , layout2 . isSelected ( ) ) ; jEdit . setProperty ( "view.docking.tabsPos" , String . valueOf ( tabsPos . getSelectedIndex ( ) ) ) ; windowModel . save ( ) ; } private JToggleButton layout1 ; private JToggleButton layout2 ; private JComboBox tabsPos ; private JTable windowTable ; private WindowTableModel windowModel ; private JScrollPane createWindowTableScroller ( ) { windowModel = createWindowModel ( ) ; windowTable = new JTable ( windowModel ) ; windowTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; windowTable . setColumnSelectionAllowed ( false ) ; windowTable . setRowSelectionAllowed ( false ) ; windowTable . setCellSelectionEnabled ( false ) ; DockPositionCellRenderer comboBox = new DockPositionCellRenderer ( ) ; comboBox . setRequestFocusEnabled ( false ) ; windowTable . setRowHeight ( comboBox . getPreferredSize ( ) . height ) ; TableColumn column = windowTable . getColumnModel ( ) . getColumn ( 1 ) ; column . setCellRenderer ( comboBox ) ; comboBox = new DockPositionCellRenderer ( ) ; comboBox . setRequestFocusEnabled ( false ) ; column . setCellEditor ( new DefaultCellEditor ( comboBox ) ) ; Dimension d = windowTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 200 ) ; JScrollPane scroller = new JScrollPane ( windowTable ) ; scroller . setPreferredSize ( d ) ; return scroller ; } private WindowTableModel createWindowModel ( ) { return new WindowTableModel ( ) ; } class DockPositionCellRenderer extends JComboBox implements TableCellRenderer { DockPositionCellRenderer ( ) { super ( new String [ ] { DockableWindowManager . FLOATING , DockableWindowManager . TOP , DockableWindowManager . LEFT , DockableWindowManager . BOTTOM , DockableWindowManager . RIGHT } ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { setSelectedItem ( value ) ; return this ; } } } class WindowTableModel extends AbstractTableModel { private Vector windows ; WindowTableModel ( ) { Object [ ] list = EditBus . getNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST ) ; windows = new Vector ( list . length ) ; for ( int i = 0 ; i < list . length ; i ++ ) { windows . addElement ( new Entry ( ( String ) list [ i ] ) ) ; } sort ( ) ; } public void sort ( ) { MiscUtilities . quicksort ( windows , new WindowCompare ( ) ) ; fireTableDataChanged ( ) ; } public int getColumnCount ( ) { return 3 ; } public int getRowCount ( ) { return windows . size ( ) ; } public Class getColumnClass ( int col ) { switch ( col ) { case 0 : case 1 : return String . class ; case 2 : return Boolean . class ; default : throw new InternalError ( ) ; } } public Object getValueAt ( int row , int col ) { Entry window = ( Entry ) windows . elementAt ( row ) ; switch ( col ) { case 0 : return window . title ; case 1 : return window . dockPosition ; case 2 : return new Boolean ( window . autoOpen ) ; default : throw new InternalError ( ) ; } } public boolean isCellEditable ( int row , int col ) { return ( col != 0 ) ; } public void setValueAt ( Object value , int row , int col ) { if ( col == 0 ) return ; Entry window = ( Entry ) windows . elementAt ( row ) ; switch ( col ) { case 1 : window . dockPosition = ( String ) value ; break ; case 2 : window . autoOpen = ( ( Boolean ) value ) . booleanValue ( ) ; break ; default : throw new InternalError ( ) ; } fireTableRowsUpdated ( row , row ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.docking.title" ) ; case 1 : return jEdit . getProperty ( "options.docking.dockPosition" ) ; case 2 : return jEdit . getProperty ( "options.docking.autoOpen" ) ; default : throw new InternalError ( ) ; } } public void save ( ) { for ( int i = 0 ; i < windows . size ( ) ; i ++ ) { ( ( Entry ) windows . elementAt ( i ) ) . save ( ) ; } } class Entry { String name ; String title ; String dockPosition ; boolean autoOpen ; Entry ( String name ) { this . name = name ; title = jEdit . getProperty ( name + ".title" ) ; if ( title == null ) title = name ; dockPosition = jEdit . getProperty ( name + ".dock-position" ) ; if ( dockPosition == null ) dockPosition = DockableWindowManager . FLOATING ; autoOpen = jEdit . getBooleanProperty ( name + ".auto-open" ) ; } void save ( ) { jEdit . setProperty ( name + ".dock-position" , dockPosition ) ; jEdit . setBooleanProperty ( name + ".auto-open" , autoOpen ) ; } } class WindowCompare implements MiscUtilities . Compare { public int compare ( Object obj1 , Object obj2 ) { Entry e1 = ( Entry ) obj1 ; Entry e2 = ( Entry ) obj2 ; return e1 . title . compareTo ( e2 . title ) ; } } } 	1	['5', '6', '0', '6', '51', '6', '2', '5', '3', '0.75', '260', '1', '1', '0.993993994', '1', '2', '4', '50', '3', '1.4', '1']
package org . gjt . sp . jedit . gui ; import com . microstar . xml . * ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . text . html . * ; import javax . swing . text . Document ; import javax . swing . tree . * ; import java . awt . * ; import java . awt . event . * ; import java . io . * ; import java . net . * ; import java . util . * ; import org . gjt . sp . jedit . msg . PropertiesChanged ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class HelpViewer extends JFrame implements EBComponent { public static void gotoURL ( URL url ) { new HelpViewer ( url . toString ( ) ) ; } public HelpViewer ( URL url ) { this ( url . toString ( ) ) ; } public HelpViewer ( String url ) { super ( jEdit . getProperty ( "helpviewer.title" ) ) ; setIconImage ( GUIUtilities . getEditorIcon ( ) ) ; history = new String [ 25 ] ; nodes = new Hashtable ( ) ; ActionHandler actionListener = new ActionHandler ( ) ; JToolBar toolBar = new JToolBar ( ) ; toolBar . setFloatable ( false ) ; toolBar . putClientProperty ( "JToolBar.isRollover" , Boolean . TRUE ) ; JLabel label = new JLabel ( jEdit . getProperty ( "helpviewer.url" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 12 , 0 , 12 ) ) ; toolBar . add ( label ) ; Box box = new Box ( BoxLayout . Y_AXIS ) ; box . add ( Box . createGlue ( ) ) ; urlField = new JTextField ( ) ; urlField . addKeyListener ( new KeyHandler ( ) ) ; Dimension dim = urlField . getPreferredSize ( ) ; dim . width = Integer . MAX_VALUE ; urlField . setMaximumSize ( dim ) ; box . add ( urlField ) ; box . add ( Box . createGlue ( ) ) ; toolBar . add ( box ) ; toolBar . add ( Box . createHorizontalStrut ( 6 ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 0 , 12 , 0 , 0 ) ) ; back = new JButton ( GUIUtilities . loadIcon ( "Back24.gif" ) ) ; back . setToolTipText ( jEdit . getProperty ( "helpviewer.back" ) ) ; back . addActionListener ( actionListener ) ; back . setRequestFocusEnabled ( false ) ; toolBar . add ( back ) ; forward = new JButton ( GUIUtilities . loadIcon ( "Forward24.gif" ) ) ; forward . addActionListener ( actionListener ) ; forward . setToolTipText ( jEdit . getProperty ( "helpviewer.forward" ) ) ; forward . setRequestFocusEnabled ( false ) ; toolBar . add ( forward ) ; back . setPreferredSize ( forward . getPreferredSize ( ) ) ; getContentPane ( ) . add ( BorderLayout . NORTH , toolBar ) ; createTOC ( ) ; toc = new TOCTree ( tocModel ) ; toc . putClientProperty ( "JTree.lineStyle" , "Angled" ) ; toc . setCellRenderer ( new TOCCellRenderer ( ) ) ; toc . setEditable ( false ) ; toc . setRootVisible ( false ) ; toc . setShowsRootHandles ( true ) ; viewer = new JEditorPane ( ) ; viewer . setEditable ( false ) ; viewer . addHyperlinkListener ( new LinkHandler ( ) ) ; viewer . setFont ( new Font ( "Monospaced" , Font . PLAIN , 12 ) ) ; JSplitPane splitter = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , new JScrollPane ( toc ) , new JScrollPane ( viewer ) ) ; splitter . setBorder ( null ) ; getContentPane ( ) . add ( BorderLayout . CENTER , splitter ) ; gotoURL ( url , true ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; setSize ( 800 , 400 ) ; GUIUtilities . loadGeometry ( this , "helpviewer" ) ; EditBus . addToBus ( this ) ; show ( ) ; } public void gotoURL ( String url , boolean addToHistory ) { viewer . setCursor ( Cursor . getDefaultCursor ( ) ) ; int index = url . indexOf ( '#' ) ; URL _url = null ; try { _url = new URL ( url ) ; urlField . setText ( _url . toString ( ) ) ; viewer . setPage ( _url ) ; if ( addToHistory ) { history [ historyPos ] = url ; if ( historyPos + 1 == history . length ) { System . arraycopy ( history , 1 , history , 0 , history . length - 1 ) ; history [ historyPos ] = null ; } else historyPos ++ ; } } catch ( MalformedURLException mf ) { Log . log ( Log . ERROR , this , mf ) ; String [ ] args = { url , mf . getMessage ( ) } ; GUIUtilities . error ( this , "badurl" , args ) ; return ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] args = { url , io . toString ( ) } ; GUIUtilities . error ( this , "read-error" , args ) ; return ; } index = url . lastIndexOf ( "/doc/" ) ; if ( index != - 1 ) url = url . substring ( index + 5 ) ; DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) nodes . get ( url ) ; if ( node == null ) return ; TreePath path = new TreePath ( tocModel . getPathToRoot ( node ) ) ; toc . expandPath ( path ) ; toc . setSelectionPath ( path ) ; toc . scrollPathToVisible ( path ) ; } public void dispose ( ) { EditBus . removeFromBus ( this ) ; GUIUtilities . saveGeometry ( this , "helpviewer" ) ; super . dispose ( ) ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof PropertiesChanged ) SwingUtilities . updateComponentTreeUI ( getRootPane ( ) ) ; } private JButton back ; private JButton forward ; private DefaultTreeModel tocModel ; private JTree toc ; private Hashtable nodes ; private JEditorPane viewer ; private JTextField urlField ; private String [ ] history ; private int historyPos ; private void createTOC ( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode ( ) ; root . add ( createNode ( "welcome.html" , jEdit . getProperty ( "helpviewer.toc.welcome" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/README.txt" , jEdit . getProperty ( "helpviewer.toc.readme" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/NEWS.txt" , jEdit . getProperty ( "helpviewer.toc.news" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/TODO.txt" , jEdit . getProperty ( "helpviewer.toc.todo" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/CHANGES.txt" , jEdit . getProperty ( "helpviewer.toc.changes" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/COPYING.txt" , jEdit . getProperty ( "helpviewer.toc.copying" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/COPYING.DOC.txt" , jEdit . getProperty ( "helpviewer.toc.copying-doc" ) ) ) ; loadUserGuideTOC ( root ) ; DefaultMutableTreeNode pluginDocs = new DefaultMutableTreeNode ( jEdit . getProperty ( "helpviewer.toc.plugins" ) , true ) ; EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin plugin = plugins [ i ] ; EditPlugin . JAR jar = plugin . getJAR ( ) ; if ( jar == null ) continue ; String name = plugin . getClassName ( ) ; String docs = jEdit . getProperty ( "plugin." + name + ".docs" ) ; String label = jEdit . getProperty ( "plugin." + name + ".name" ) ; if ( docs != null ) { if ( label != null && docs != null ) { URL url = jar . getClassLoader ( ) . getResource ( docs ) ; if ( url != null ) { pluginDocs . add ( createNode ( url . toString ( ) , label ) ) ; } } } } root . add ( pluginDocs ) ; tocModel = new DefaultTreeModel ( root ) ; } private void loadUserGuideTOC ( DefaultMutableTreeNode root ) { URL resource = getClass ( ) . getResource ( "/doc/users-guide/toc.xml" ) ; if ( resource == null ) return ; TOCHandler h = new TOCHandler ( root ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( h ) ; try { parser . parse ( null , null , new InputStreamReader ( resource . openStream ( ) ) ) ; } catch ( XmlException xe ) { int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , this , "toc.xml:" + line + ": " + message ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } } private DefaultMutableTreeNode createNode ( String href , String title ) { DefaultMutableTreeNode node = new DefaultMutableTreeNode ( new HelpNode ( href , title ) , true ) ; nodes . put ( href , node ) ; return node ; } static class HelpNode { String href , title ; HelpNode ( String href , String title ) { this . href = href ; this . title = title ; } public String toString ( ) { return title ; } } class TOCHandler extends HandlerBase { TOCHandler ( DefaultMutableTreeNode root ) { nodes = new Stack ( ) ; node = root ; } public void attribute ( String aname , String value , boolean isSpecified ) { if ( aname . equals ( "HREF" ) ) href = value ; } public void charData ( char [ ] c , int off , int len ) { if ( tag . equals ( "TITLE" ) ) title = new String ( c , off , len ) ; } public void startElement ( String name ) { tag = name ; } public void endElement ( String name ) { if ( name == null ) return ; if ( name . equals ( "TITLE" ) ) { DefaultMutableTreeNode newNode = createNode ( "users-guide/" + href , title ) ; node . add ( newNode ) ; nodes . push ( node ) ; node = newNode ; } else if ( name . equals ( "ENTRY" ) ) node = ( DefaultMutableTreeNode ) nodes . pop ( ) ; } private String tag ; private String title ; private String href ; private DefaultMutableTreeNode node ; private Stack nodes ; } class TOCTree extends JTree { TOCTree ( TreeModel model ) { super ( model ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( this ) ; } public final String getToolTipText ( MouseEvent evt ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { Rectangle cellRect = getPathBounds ( path ) ; if ( cellRect != null && ! cellRectIsVisible ( cellRect ) ) return path . getLastPathComponent ( ) . toString ( ) ; } return null ; } public final Point getToolTipLocation ( MouseEvent evt ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { Rectangle cellRect = getPathBounds ( path ) ; if ( cellRect != null && ! cellRectIsVisible ( cellRect ) ) { return new Point ( cellRect . x , cellRect . y - 1 ) ; } } return null ; } protected void processMouseEvent ( MouseEvent evt ) { ToolTipManager ttm = ToolTipManager . sharedInstance ( ) ; switch ( evt . getID ( ) ) { case MouseEvent . MOUSE_ENTERED : toolTipInitialDelay = ttm . getInitialDelay ( ) ; toolTipReshowDelay = ttm . getReshowDelay ( ) ; ttm . setInitialDelay ( 200 ) ; ttm . setReshowDelay ( 0 ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_EXITED : ttm . setInitialDelay ( toolTipInitialDelay ) ; ttm . setReshowDelay ( toolTipReshowDelay ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_CLICKED : TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { if ( ! isPathSelected ( path ) ) setSelectionPath ( path ) ; Object obj = ( ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( ! ( obj instanceof HelpNode ) ) { toc . expandPath ( path ) ; return ; } HelpNode node = ( HelpNode ) obj ; gotoURL ( node . href , true ) ; } super . processMouseEvent ( evt ) ; break ; default : super . processMouseEvent ( evt ) ; break ; } } private int toolTipInitialDelay = - 1 ; private int toolTipReshowDelay = - 1 ; private boolean cellRectIsVisible ( Rectangle cellRect ) { Rectangle vr = TOCTree . this . getVisibleRect ( ) ; return vr . contains ( cellRect . x , cellRect . y ) && vr . contains ( cellRect . x + cellRect . width , cellRect . y + cellRect . height ) ; } } class TOCCellRenderer extends DefaultTreeCellRenderer { EmptyBorder border = new EmptyBorder ( 1 , 0 , 1 , 1 ) ; public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean focus ) { super . getTreeCellRendererComponent ( tree , value , sel , expanded , leaf , row , focus ) ; setIcon ( null ) ; setBorder ( border ) ; return this ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == back ) { if ( historyPos <= 1 ) getToolkit ( ) . beep ( ) ; else { String url = history [ -- historyPos - 1 ] ; gotoURL ( url , false ) ; } } else if ( source == forward ) { if ( history . length - historyPos <= 1 ) getToolkit ( ) . beep ( ) ; else { String url = history [ historyPos ] ; if ( url == null ) getToolkit ( ) . beep ( ) ; else { historyPos ++ ; gotoURL ( url , false ) ; } } } } } class LinkHandler implements HyperlinkListener { public void hyperlinkUpdate ( HyperlinkEvent evt ) { if ( evt . getEventType ( ) == HyperlinkEvent . EventType . ACTIVATED ) { if ( evt instanceof HTMLFrameHyperlinkEvent ) { ( ( HTMLDocument ) viewer . getDocument ( ) ) . processHTMLFrameHyperlinkEvent ( ( HTMLFrameHyperlinkEvent ) evt ) ; } else { URL url = evt . getURL ( ) ; if ( url != null ) gotoURL ( url . toString ( ) , true ) ; } } else if ( evt . getEventType ( ) == HyperlinkEvent . EventType . ENTERED ) { viewer . setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND_CURSOR ) ) ; } else if ( evt . getEventType ( ) == HyperlinkEvent . EventType . EXITED ) { viewer . setCursor ( Cursor . getDefaultCursor ( ) ) ; } } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { gotoURL ( urlField . getText ( ) , true ) ; } } } } 	1	['18', '6', '0', '21', '124', '117', '7', '20', '6', '0.77124183', '762', '1', '0', '0.975794251', '0.1875', '3', '6', '40.83333333', '7', '1.5556', '5']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class EditingOptionPane extends AbstractOptionPane { public EditingOptionPane ( ) { super ( "editing" ) ; } protected void _init ( ) { Mode [ ] modes = jEdit . getModes ( ) ; String defaultModeString = jEdit . getProperty ( "buffer.defaultMode" ) ; String [ ] modeNames = new String [ modes . length ] ; int index = 0 ; for ( int i = 0 ; i < modes . length ; i ++ ) { Mode _mode = modes [ i ] ; modeNames [ i ] = _mode . getName ( ) ; if ( defaultModeString . equals ( _mode . getName ( ) ) ) index = i ; } defaultMode = new JComboBox ( modeNames ) ; defaultMode . setSelectedIndex ( index ) ; addComponent ( jEdit . getProperty ( "options.editing.defaultMode" ) , defaultMode ) ; String [ ] tabSizes = { "2" , "4" , "8" } ; defaultTabSize = new JComboBox ( tabSizes ) ; defaultTabSize . setEditable ( true ) ; defaultTabSize . setSelectedItem ( jEdit . getProperty ( "buffer.tabSize" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.tabSize" ) , defaultTabSize ) ; defaultIndentSize = new JComboBox ( tabSizes ) ; defaultIndentSize . setEditable ( true ) ; defaultIndentSize . setSelectedItem ( jEdit . getProperty ( "buffer.indentSize" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.indentSize" ) , defaultIndentSize ) ; String [ ] lineLens = { "0" , "72" , "76" , "80" } ; defaultMaxLineLen = new JComboBox ( lineLens ) ; defaultMaxLineLen . setEditable ( true ) ; defaultMaxLineLen . setSelectedItem ( jEdit . getProperty ( "buffer.maxLineLen" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.maxLineLen" ) , defaultMaxLineLen ) ; defaultWordBreakChars = new JTextField ( jEdit . getProperty ( "buffer.wordBreakChars" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.wordBreakChars" ) , defaultWordBreakChars ) ; defaultCollapseFolds = new JTextField ( jEdit . getProperty ( "buffer.collapseFolds" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.collapseFolds" ) , defaultCollapseFolds ) ; undoCount = new JTextField ( jEdit . getProperty ( "buffer.undoCount" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.undoCount" ) , undoCount ) ; defaultSyntax = new JCheckBox ( jEdit . getProperty ( "options.editing" + ".syntax" ) ) ; defaultSyntax . setSelected ( jEdit . getBooleanProperty ( "buffer.syntax" ) ) ; addComponent ( defaultSyntax ) ; defaultIndentOnTab = new JCheckBox ( jEdit . getProperty ( "options.editing" + ".indentOnTab" ) ) ; defaultIndentOnTab . setSelected ( jEdit . getBooleanProperty ( "buffer.indentOnTab" ) ) ; addComponent ( defaultIndentOnTab ) ; defaultIndentOnEnter = new JCheckBox ( jEdit . getProperty ( "options.editing" + ".indentOnEnter" ) ) ; defaultIndentOnEnter . setSelected ( jEdit . getBooleanProperty ( "buffer.indentOnEnter" ) ) ; addComponent ( defaultIndentOnEnter ) ; defaultNoTabs = new JCheckBox ( jEdit . getProperty ( "options.editing" + ".noTabs" ) ) ; defaultNoTabs . setSelected ( jEdit . getBooleanProperty ( "buffer.noTabs" ) ) ; addComponent ( defaultNoTabs ) ; } protected void _save ( ) { jEdit . setProperty ( "buffer.defaultMode" , ( String ) defaultMode . getSelectedItem ( ) ) ; jEdit . setProperty ( "buffer.tabSize" , ( String ) defaultTabSize . getSelectedItem ( ) ) ; jEdit . setProperty ( "buffer.indentSize" , ( String ) defaultIndentSize . getSelectedItem ( ) ) ; jEdit . setProperty ( "buffer.maxLineLen" , ( String ) defaultMaxLineLen . getSelectedItem ( ) ) ; jEdit . setProperty ( "buffer.wordBreakChars" , defaultWordBreakChars . getText ( ) ) ; jEdit . setProperty ( "buffer.collapseFolds" , defaultCollapseFolds . getText ( ) ) ; jEdit . setProperty ( "buffer.undoCount" , undoCount . getText ( ) ) ; jEdit . setBooleanProperty ( "buffer.syntax" , defaultSyntax . isSelected ( ) ) ; jEdit . setBooleanProperty ( "buffer.indentOnTab" , defaultIndentOnTab . isSelected ( ) ) ; jEdit . setBooleanProperty ( "buffer.indentOnEnter" , defaultIndentOnEnter . isSelected ( ) ) ; jEdit . setBooleanProperty ( "buffer.noTabs" , defaultNoTabs . isSelected ( ) ) ; } private JComboBox defaultMode ; private JComboBox defaultTabSize ; private JComboBox defaultIndentSize ; private JComboBox defaultMaxLineLen ; private JTextField defaultWordBreakChars ; private JTextField defaultCollapseFolds ; private JTextField undoCount ; private JCheckBox defaultSyntax ; private JCheckBox defaultIndentOnTab ; private JCheckBox defaultIndentOnEnter ; private JCheckBox defaultNoTabs ; } 	1	['3', '6', '0', '4', '23', '1', '1', '3', '1', '0.5', '330', '1', '0', '0.996987952', '1', '2', '4', '105.3333333', '3', '1.3333', '3']
package org . gjt . sp . jedit . textarea ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . plaf . metal . MetalLookAndFeel ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . text . Segment ; import javax . swing . text . Utilities ; import javax . swing . undo . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class JEditTextArea extends JComponent { public JEditTextArea ( View view ) { enableEvents ( AWTEvent . FOCUS_EVENT_MASK | AWTEvent . KEY_EVENT_MASK ) ; this . view = view ; selection = new Vector ( ) ; renderer = TextRenderer . createTextRenderer ( ) ; painter = new TextAreaPainter ( this ) ; gutter = new Gutter ( view , this ) ; documentHandler = new DocumentHandler ( ) ; foldHandler = new FoldHandler ( ) ; listenerList = new EventListenerList ( ) ; caretEvent = new MutableCaretEvent ( ) ; bracketLine = bracketPosition = - 1 ; blink = true ; lineSegment = new Segment ( ) ; setLayout ( new ScrollLayout ( ) ) ; add ( LEFT , gutter ) ; add ( CENTER , painter ) ; add ( RIGHT , vertical = new JScrollBar ( JScrollBar . VERTICAL ) ) ; add ( BOTTOM , horizontal = new JScrollBar ( JScrollBar . HORIZONTAL ) ) ; horizontal . setValues ( 0 , 0 , 0 , 0 ) ; if ( UIManager . getLookAndFeel ( ) instanceof MetalLookAndFeel ) { setBorder ( new TextAreaBorder ( ) ) ; vertical . putClientProperty ( "JScrollBar.isFreeStanding" , Boolean . FALSE ) ; horizontal . putClientProperty ( "JScrollBar.isFreeStanding" , Boolean . FALSE ) ; } vertical . addAdjustmentListener ( new AdjustHandler ( ) ) ; horizontal . addAdjustmentListener ( new AdjustHandler ( ) ) ; painter . addComponentListener ( new ComponentHandler ( ) ) ; mouseHandler = new MouseHandler ( ) ; painter . addMouseListener ( mouseHandler ) ; painter . addMouseMotionListener ( mouseHandler ) ; addFocusListener ( new FocusHandler ( ) ) ; focusedComponent = this ; } public final TextAreaPainter getPainter ( ) { return painter ; } public final Gutter getGutter ( ) { return gutter ; } public final boolean isCaretBlinkEnabled ( ) { return caretBlinks ; } public void setCaretBlinkEnabled ( boolean caretBlinks ) { this . caretBlinks = caretBlinks ; if ( ! caretBlinks ) blink = false ; if ( buffer != null ) invalidateLine ( caretLine ) ; } public final void blinkCaret ( ) { if ( caretBlinks ) { blink = ! blink ; invalidateLine ( caretLine ) ; } else blink = true ; } public final int getElectricScroll ( ) { return electricScroll ; } public final void setElectricScroll ( int electricScroll ) { this . electricScroll = electricScroll ; } public final boolean isMiddleMousePasteEnabled ( ) { return middleMousePaste ; } public final void setMiddleMousePasteEnabled ( boolean middleMousePaste ) { this . middleMousePaste = middleMousePaste ; } public void updateScrollBars ( ) { if ( vertical != null && visibleLines != 0 ) { int lineCount = getVirtualLineCount ( ) ; if ( lineCount < firstLine + visibleLines ) { int newFirstLine = Math . max ( 0 , lineCount - visibleLines ) ; if ( newFirstLine != firstLine ) { setFirstLine ( newFirstLine ) ; return ; } } vertical . setValues ( firstLine , visibleLines , 0 , lineCount ) ; vertical . setUnitIncrement ( 2 ) ; vertical . setBlockIncrement ( visibleLines ) ; } int width = painter . getWidth ( ) ; if ( horizontal != null && width != 0 ) { maxHorizontalScrollWidth = 0 ; painter . repaint ( ) ; horizontal . setUnitIncrement ( painter . getFontMetrics ( ) . charWidth ( 'w' ) ) ; horizontal . setBlockIncrement ( width / 2 ) ; } } public final int getFirstLine ( ) { return firstLine ; } public void setFirstLine ( int firstLine ) { if ( firstLine == this . firstLine ) return ; _setFirstLine ( firstLine ) ; view . synchroScrollVertical ( this , firstLine ) ; } public void _setFirstLine ( int firstLine ) { this . firstLine = Math . max ( 0 , firstLine ) ; physFirstLine = buffer . virtualToPhysical ( this . firstLine ) ; maxHorizontalScrollWidth = 0 ; if ( this . firstLine != vertical . getValue ( ) ) updateScrollBars ( ) ; painter . repaint ( ) ; gutter . repaint ( ) ; fireScrollEvent ( true ) ; } public final int getVisibleLines ( ) { return visibleLines ; } public final int getHorizontalOffset ( ) { return horizontalOffset ; } public void setHorizontalOffset ( int horizontalOffset ) { if ( horizontalOffset == this . horizontalOffset ) return ; _setHorizontalOffset ( horizontalOffset ) ; view . synchroScrollHorizontal ( this , horizontalOffset ) ; } public void _setHorizontalOffset ( int horizontalOffset ) { this . horizontalOffset = horizontalOffset ; if ( horizontalOffset != horizontal . getValue ( ) ) updateScrollBars ( ) ; painter . repaint ( ) ; fireScrollEvent ( false ) ; } public boolean setOrigin ( int firstLine , int horizontalOffset ) { setFirstLine ( firstLine ) ; setHorizontalOffset ( horizontalOffset ) ; return true ; } public void centerCaret ( ) { Element map = buffer . getDefaultRootElement ( ) ; int gotoLine = buffer . virtualToPhysical ( firstLine + visibleLines / 2 ) ; if ( gotoLine < 0 || gotoLine >= map . getElementCount ( ) ) { getToolkit ( ) . beep ( ) ; return ; } Element element = map . getElement ( gotoLine ) ; setCaretPosition ( element . getStartOffset ( ) ) ; } public void scrollUpLine ( ) { if ( firstLine > 0 ) setFirstLine ( firstLine - 1 ) ; else getToolkit ( ) . beep ( ) ; } public void scrollUpPage ( ) { if ( firstLine > 0 ) { int newFirstLine = firstLine - visibleLines ; setFirstLine ( newFirstLine ) ; } else { getToolkit ( ) . beep ( ) ; } } public void scrollDownLine ( ) { int numLines = getVirtualLineCount ( ) ; if ( firstLine + visibleLines < numLines ) setFirstLine ( firstLine + 1 ) ; else getToolkit ( ) . beep ( ) ; } public void scrollDownPage ( ) { int numLines = getVirtualLineCount ( ) ; if ( firstLine + visibleLines < numLines ) { int newFirstLine = firstLine + visibleLines ; setFirstLine ( newFirstLine + visibleLines < numLines ? newFirstLine : numLines - visibleLines ) ; } else { getToolkit ( ) . beep ( ) ; } } public void scrollToCaret ( boolean doElectricScroll ) { if ( ! buffer . isLineVisible ( caretLine ) ) buffer . expandFoldAt ( caretLine , true , this ) ; int offset = caret - getLineStartOffset ( caretLine ) ; int virtualCaretLine = buffer . physicalToVirtual ( caretLine ) ; if ( visibleLines == 0 ) { setFirstLine ( caretLine - electricScroll ) ; return ; } int electricScroll ; if ( doElectricScroll && visibleLines > this . electricScroll * 2 ) electricScroll = this . electricScroll ; else electricScroll = 0 ; boolean changed = false ; int _firstLine = firstLine + electricScroll ; int _lastLine = firstLine + visibleLines - electricScroll ; if ( virtualCaretLine > _firstLine && virtualCaretLine < _lastLine ) { } else if ( _firstLine - virtualCaretLine > visibleLines || virtualCaretLine - _lastLine > visibleLines ) { int startLine , endLine ; Selection s = getSelectionAtOffset ( caret ) ; if ( s == null ) { startLine = endLine = virtualCaretLine ; } else { startLine = buffer . physicalToVirtual ( s . startLine ) ; endLine = buffer . physicalToVirtual ( s . endLine ) ; } if ( endLine - startLine <= visibleLines ) firstLine = ( startLine + endLine - visibleLines ) / 2 ; else firstLine = buffer . physicalToVirtual ( caretLine ) - visibleLines / 2 ; firstLine = Math . min ( firstLine , buffer . getVirtualLineCount ( ) - visibleLines ) ; firstLine = Math . max ( firstLine , 0 ) ; changed = true ; } else if ( virtualCaretLine < _firstLine ) { firstLine = Math . max ( 0 , virtualCaretLine - electricScroll ) ; changed = true ; } else if ( virtualCaretLine >= _lastLine ) { firstLine = ( virtualCaretLine - visibleLines ) + electricScroll + 1 ; if ( firstLine >= getVirtualLineCount ( ) - visibleLines ) firstLine = getVirtualLineCount ( ) - visibleLines ; changed = true ; } int x = offsetToX ( caretLine , offset ) ; int width = painter . getFontMetrics ( ) . charWidth ( 'w' ) ; if ( x < 0 ) { horizontalOffset = Math . min ( 0 , horizontalOffset - x + width + 5 ) ; changed = true ; } else if ( x >= painter . getWidth ( ) - width - 5 ) { horizontalOffset = horizontalOffset + ( painter . getWidth ( ) - x ) - width - 5 ; changed = true ; } if ( changed ) { if ( firstLine < 0 ) firstLine = 0 ; physFirstLine = buffer . virtualToPhysical ( firstLine ) ; updateScrollBars ( ) ; painter . repaint ( ) ; gutter . repaint ( ) ; view . synchroScrollVertical ( this , firstLine ) ; view . synchroScrollHorizontal ( this , horizontalOffset ) ; fireScrollEvent ( true ) ; fireScrollEvent ( false ) ; } } public int lineToY ( int line ) { FontMetrics fm = painter . getFontMetrics ( ) ; return ( line - firstLine ) * fm . getHeight ( ) - ( fm . getLeading ( ) + fm . getDescent ( ) ) ; } public int yToLine ( int y ) { FontMetrics fm = painter . getFontMetrics ( ) ; int height = fm . getHeight ( ) ; return Math . max ( 0 , Math . min ( getVirtualLineCount ( ) - 1 , y / height + firstLine ) ) ; } public TextRenderer getTextRenderer ( ) { return renderer ; } public int offsetToX ( int line , int offset ) { Token tokens = buffer . markTokens ( line ) . getFirstToken ( ) ; getLineText ( line , lineSegment ) ; char [ ] text = lineSegment . array ; int off = lineSegment . offset ; float x = ( float ) horizontalOffset ; Toolkit toolkit = painter . getToolkit ( ) ; Font defaultFont = painter . getFont ( ) ; SyntaxStyle [ ] styles = painter . getStyles ( ) ; for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) return ( int ) x ; Font font ; if ( id == Token . NULL ) font = defaultFont ; else font = styles [ id ] . getFont ( ) ; int len = tokens . length ; if ( offset < len ) { return ( int ) ( x + renderer . charsWidth ( text , off , offset , font , x , painter ) ) ; } else { x += renderer . charsWidth ( text , off , len , font , x , painter ) ; off += len ; offset -= len ; } tokens = tokens . next ; } } public int xToOffset ( int line , int x ) { return xToOffset ( line , x , true ) ; } public int xToOffset ( int line , int x , boolean round ) { Token tokens = buffer . markTokens ( line ) . getFirstToken ( ) ; getLineText ( line , lineSegment ) ; char [ ] text = lineSegment . array ; int off = lineSegment . offset ; Toolkit toolkit = painter . getToolkit ( ) ; Font defaultFont = painter . getFont ( ) ; SyntaxStyle [ ] styles = painter . getStyles ( ) ; float [ ] widthArray = new float [ ] { horizontalOffset } ; for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) return lineSegment . count ; Font font ; if ( id == Token . NULL ) font = defaultFont ; else font = styles [ id ] . getFont ( ) ; int len = tokens . length ; int offset = renderer . xToOffset ( text , off , len , font , x , painter , round , widthArray ) ; if ( offset != - 1 ) return offset - lineSegment . offset ; off += len ; tokens = tokens . next ; } } public int xyToOffset ( int x , int y ) { return xyToOffset ( x , y , true ) ; } public int xyToOffset ( int x , int y , boolean round ) { FontMetrics fm = painter . getFontMetrics ( ) ; int height = fm . getHeight ( ) ; int line = y / height + firstLine ; if ( line < 0 ) return 0 ; else if ( line >= getVirtualLineCount ( ) ) { return getLineEndOffset ( buffer . virtualToPhysical ( buffer . getVirtualLineCount ( ) - 1 ) ) - 1 ; } else { line = buffer . virtualToPhysical ( line ) ; return getLineStartOffset ( line ) + xToOffset ( line , x ) ; } } public final void invalidateLine ( int line ) { line = buffer . physicalToVirtual ( line ) ; FontMetrics fm = painter . getFontMetrics ( ) ; int y = lineToY ( line ) + fm . getDescent ( ) + fm . getLeading ( ) ; painter . repaint ( 0 , y , painter . getWidth ( ) , fm . getHeight ( ) ) ; gutter . repaint ( 0 , y , gutter . getWidth ( ) , fm . getHeight ( ) ) ; } public final void invalidateLineRange ( int firstLine , int lastLine ) { firstLine = buffer . physicalToVirtual ( firstLine ) ; if ( lastLine > buffer . virtualToPhysical ( buffer . getVirtualLineCount ( ) - 1 ) ) { lastLine = ( lastLine - buffer . getLineCount ( ) ) + buffer . getVirtualLineCount ( ) ; } else lastLine = buffer . physicalToVirtual ( lastLine ) ; FontMetrics fm = painter . getFontMetrics ( ) ; int y = lineToY ( firstLine ) + fm . getDescent ( ) + fm . getLeading ( ) ; int height = ( lastLine - firstLine + 1 ) * fm . getHeight ( ) ; painter . repaint ( 0 , y , painter . getWidth ( ) , height ) ; gutter . repaint ( 0 , y , gutter . getWidth ( ) , height ) ; } public final void invalidateSelectedLines ( ) { for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; invalidateLineRange ( s . startLine , s . endLine ) ; } } public final Buffer getBuffer ( ) { return buffer ; } public void setBuffer ( Buffer buffer ) { if ( this . buffer == buffer ) return ; if ( this . buffer != null ) { this . buffer . removeDocumentListener ( documentHandler ) ; this . buffer . removeFoldListener ( foldHandler ) ; } this . buffer = buffer ; buffer . addDocumentListener ( documentHandler ) ; buffer . addFoldListener ( foldHandler ) ; documentHandlerInstalled = true ; maxHorizontalScrollWidth = 0 ; painter . updateTabSize ( ) ; setCaretPosition ( 0 ) ; updateScrollBars ( ) ; painter . repaint ( ) ; gutter . repaint ( ) ; } public final int getBufferLength ( ) { return buffer . getLength ( ) ; } public final int getLineCount ( ) { return buffer . getLineCount ( ) ; } public final int getVirtualLineCount ( ) { return buffer . getVirtualLineCount ( ) ; } public final int getLineOfOffset ( int offset ) { return buffer . getDefaultRootElement ( ) . getElementIndex ( offset ) ; } public int getLineStartOffset ( int line ) { Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line ) ; if ( lineElement == null ) return - 1 ; else return lineElement . getStartOffset ( ) ; } public int getLineEndOffset ( int line ) { Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line ) ; if ( lineElement == null ) return - 1 ; else return lineElement . getEndOffset ( ) ; } public int getLineLength ( int line ) { Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line ) ; if ( lineElement == null ) return - 1 ; else return lineElement . getEndOffset ( ) - lineElement . getStartOffset ( ) - 1 ; } public String getText ( ) { try { return buffer . getText ( 0 , buffer . getLength ( ) ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; return null ; } } public void setText ( String text ) { try { buffer . beginCompoundEdit ( ) ; buffer . remove ( 0 , buffer . getLength ( ) ) ; buffer . insertString ( 0 , text , null ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } finally { buffer . endCompoundEdit ( ) ; } } public final String getText ( int start , int len ) { try { return buffer . getText ( start , len ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; return null ; } } public final void getText ( int start , int len , Segment segment ) { try { buffer . getText ( start , len , segment ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; segment . offset = segment . count = 0 ; } } public final String getLineText ( int lineIndex ) { int start = getLineStartOffset ( lineIndex ) ; return getText ( start , getLineEndOffset ( lineIndex ) - start - 1 ) ; } public final void getLineText ( int lineIndex , Segment segment ) { Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( lineIndex ) ; int start = lineElement . getStartOffset ( ) ; getText ( start , lineElement . getEndOffset ( ) - start - 1 , segment ) ; } public final void selectAll ( ) { setSelection ( new Selection . Range ( 0 , buffer . getLength ( ) ) ) ; moveCaretPosition ( buffer . getLength ( ) , true ) ; } public void selectLine ( ) { int caretLine = getCaretLine ( ) ; int start = getLineStartOffset ( caretLine ) ; int end = getLineEndOffset ( caretLine ) - 1 ; setSelection ( new Selection . Range ( start , end ) ) ; moveCaretPosition ( end ) ; } public void selectParagraph ( ) { int caretLine = getCaretLine ( ) ; if ( getLineLength ( caretLine ) == 0 ) { view . getToolkit ( ) . beep ( ) ; return ; } int start = caretLine ; int end = caretLine ; while ( start >= 0 ) { if ( getLineLength ( start ) == 0 ) break ; else start -- ; } while ( end < getLineCount ( ) ) { if ( getLineLength ( end ) == 0 ) break ; else end ++ ; } int selectionStart = getLineStartOffset ( start + 1 ) ; int selectionEnd = getLineEndOffset ( end - 1 ) - 1 ; setSelection ( new Selection . Range ( selectionStart , selectionEnd ) ) ; moveCaretPosition ( selectionEnd ) ; } public void selectWord ( ) { int line = getCaretLine ( ) ; int lineStart = getLineStartOffset ( line ) ; int offset = getCaretPosition ( ) - lineStart ; if ( getLineLength ( line ) == 0 ) return ; String lineText = getLineText ( line ) ; String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; if ( offset == getLineLength ( line ) ) offset -- ; int wordStart = TextUtilities . findWordStart ( lineText , offset , noWordSep ) ; int wordEnd = TextUtilities . findWordEnd ( lineText , offset + 1 , noWordSep ) ; setSelection ( new Selection . Range ( lineStart + wordStart , lineStart + wordEnd ) ) ; moveCaretPosition ( lineStart + wordEnd ) ; } public final int getSelectionStart ( ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getStart ( ) ; } public int getSelectionStart ( int line ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getStart ( buffer , line ) ; } public final int getSelectionStartLine ( ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getStartLine ( ) ; } public final void setSelectionStart ( int selectionStart ) { select ( selectionStart , getSelectionEnd ( ) , true ) ; } public final int getSelectionEnd ( ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getEnd ( ) ; } public int getSelectionEnd ( int line ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getEnd ( buffer , line ) ; } public final int getSelectionEndLine ( ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getEndLine ( ) ; } public final void setSelectionEnd ( int selectionEnd ) { select ( getSelectionStart ( ) , selectionEnd , true ) ; } public final int getMarkPosition ( ) { Selection s = getSelectionAtOffset ( caret ) ; if ( s == null ) return caret ; if ( s . start == caret ) return s . end ; else if ( s . end == caret ) return s . start ; else return caret ; } public final int getMarkLine ( ) { if ( selection . size ( ) != 1 ) return caretLine ; Selection s = ( Selection ) selection . elementAt ( 0 ) ; if ( s . start == caret ) return s . endLine ; else if ( s . end == caret ) return s . startLine ; else return caretLine ; } public void select ( int start , int end ) { select ( start , end , true ) ; } public void select ( int start , int end , boolean doElectricScroll ) { selectNone ( ) ; int newStart , newEnd ; if ( start < end ) { newStart = start ; newEnd = end ; } else { newStart = end ; newEnd = start ; } setSelection ( new Selection . Range ( newStart , newEnd ) ) ; moveCaretPosition ( end , doElectricScroll ) ; } public boolean isSelectionRectangular ( ) { Selection s = getSelectionAtOffset ( caret ) ; if ( s == null ) return false ; else return ( s instanceof Selection . Rect ) ; } public void setCaretPosition ( int newCaret ) { invalidateSelectedLines ( ) ; selection . removeAllElements ( ) ; moveCaretPosition ( newCaret , true ) ; } public void setCaretPosition ( int newCaret , boolean doElectricScroll ) { invalidateSelectedLines ( ) ; selection . removeAllElements ( ) ; moveCaretPosition ( newCaret , doElectricScroll ) ; } public void moveCaretPosition ( int newCaret ) { moveCaretPosition ( newCaret , true ) ; } public void moveCaretPosition ( int newCaret , boolean doElectricScroll ) { if ( newCaret < 0 || newCaret > buffer . getLength ( ) ) { throw new IllegalArgumentException ( "caret out of bounds: " + newCaret ) ; } blink = true ; caretTimer . restart ( ) ; if ( caret == newCaret ) { scrollToCaret ( doElectricScroll ) ; return ; } int newCaretLine = getLineOfOffset ( newCaret ) ; magicCaret = offsetToX ( newCaretLine , newCaret - getLineStartOffset ( newCaretLine ) ) ; invalidateLine ( caretLine ) ; invalidateLine ( newCaretLine ) ; buffer . addUndoableEdit ( new CaretUndo ( caret ) ) ; caret = newCaret ; caretLine = newCaretLine ; if ( focusedComponent == this ) scrollToCaret ( doElectricScroll ) ; updateBracketHighlight ( ) ; fireCaretEvent ( ) ; } public int getCaretPosition ( ) { return caret ; } public int getCaretLine ( ) { return caretLine ; } public int getSelectionCount ( ) { return selection . size ( ) ; } public Selection [ ] getSelection ( ) { Selection [ ] sel = new Selection [ selection . size ( ) ] ; selection . copyInto ( sel ) ; return sel ; } public void selectNone ( ) { setSelection ( ( Selection ) null ) ; } public void setSelection ( Selection [ ] selection ) { invalidateSelectedLines ( ) ; this . selection . removeAllElements ( ) ; if ( selection != null ) { for ( int i = 0 ; i < selection . length ; i ++ ) _addToSelection ( selection [ i ] ) ; } fireCaretEvent ( ) ; } public void setSelection ( Selection selection ) { invalidateSelectedLines ( ) ; this . selection . removeAllElements ( ) ; if ( selection != null ) _addToSelection ( selection ) ; fireCaretEvent ( ) ; } public void addToSelection ( Selection [ ] selection ) { if ( selection != null ) { for ( int i = 0 ; i < selection . length ; i ++ ) _addToSelection ( selection [ i ] ) ; } fireCaretEvent ( ) ; } public void addToSelection ( Selection selection ) { _addToSelection ( selection ) ; fireCaretEvent ( ) ; } public Selection getSelectionAtOffset ( int offset ) { if ( selection != null ) { for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; if ( offset >= s . start && offset <= s . end ) return s ; } } return null ; } public void removeFromSelection ( Selection sel ) { selection . removeElement ( sel ) ; invalidateLineRange ( sel . startLine , sel . endLine ) ; fireCaretEvent ( ) ; } public void removeFromSelection ( int offset ) { Selection sel = getSelectionAtOffset ( offset ) ; if ( sel == null ) return ; selection . removeElement ( sel ) ; invalidateLineRange ( sel . startLine , sel . endLine ) ; fireCaretEvent ( ) ; } public void resizeSelection ( int offset , int end , boolean rect ) { Selection s = getSelectionAtOffset ( offset ) ; if ( s != null ) { invalidateLineRange ( s . startLine , s . endLine ) ; selection . removeElement ( s ) ; } if ( end < offset ) { int tmp = offset ; offset = end ; end = tmp ; } Selection newSel ; if ( rect ) newSel = new Selection . Rect ( offset , end ) ; else newSel = new Selection . Range ( offset , end ) ; _addToSelection ( newSel ) ; fireCaretEvent ( ) ; } public void extendSelection ( int offset , int end ) { Selection s = getSelectionAtOffset ( offset ) ; if ( s != null ) { invalidateLineRange ( s . startLine , s . endLine ) ; selection . removeElement ( s ) ; if ( offset == s . start ) { offset = end ; end = s . end ; } else if ( offset == s . end ) { offset = s . start ; } } if ( end < offset ) { int tmp = end ; end = offset ; offset = tmp ; } _addToSelection ( new Selection . Range ( offset , end ) ) ; fireCaretEvent ( ) ; } public String getSelectedText ( Selection s ) { StringBuffer buf = new StringBuffer ( ) ; getSelectedText ( s , buf ) ; return buf . toString ( ) ; } public String getSelectedText ( String separator ) { if ( selection . size ( ) == 0 ) return null ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { if ( i != 0 ) buf . append ( separator ) ; getSelectedText ( ( Selection ) selection . elementAt ( i ) , buf ) ; } return buf . toString ( ) ; } public String getSelectedText ( ) { return getSelectedText ( "\n" ) ; } public void setSelectedText ( Selection s , String selectedText ) { if ( ! isEditable ( ) ) { throw new InternalError ( "Text component" + " read only" ) ; } try { buffer . beginCompoundEdit ( ) ; if ( s instanceof Selection . Rect ) { Element map = buffer . getDefaultRootElement ( ) ; int start = s . start - map . getElement ( s . startLine ) . getStartOffset ( ) ; int end = s . end - map . getElement ( s . endLine ) . getStartOffset ( ) ; if ( end < start ) { int tmp = end ; end = start ; start = tmp ; } int lastNewline = 0 ; int currNewline = 0 ; for ( int i = s . startLine ; i <= s . endLine ; i ++ ) { Element lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; int lineEnd = lineElement . getEndOffset ( ) - 1 ; int rectStart = Math . min ( lineEnd , lineStart + start ) ; buffer . remove ( rectStart , Math . min ( lineEnd - rectStart , end - start ) ) ; if ( selectedText == null ) continue ; currNewline = selectedText . indexOf ( '\n' , lastNewline ) ; if ( currNewline == - 1 ) currNewline = selectedText . length ( ) ; buffer . insertString ( rectStart , selectedText . substring ( lastNewline , currNewline ) , null ) ; lastNewline = Math . min ( selectedText . length ( ) , currNewline + 1 ) ; } if ( selectedText != null && currNewline != selectedText . length ( ) ) { int offset = map . getElement ( s . endLine ) . getEndOffset ( ) - 1 ; buffer . insertString ( offset , "\n" , null ) ; buffer . insertString ( offset + 1 , selectedText . substring ( currNewline + 1 ) , null ) ; } } else { buffer . remove ( s . start , s . end - s . start ) ; if ( selectedText != null && selectedText . length ( ) != 0 ) { buffer . insertString ( s . start , selectedText , null ) ; } } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { buffer . endCompoundEdit ( ) ; } } public void setSelectedText ( String selectedText ) { if ( ! isEditable ( ) ) { throw new InternalError ( "Text component" + " read only" ) ; } Selection [ ] selection = getSelection ( ) ; if ( selection . length == 0 ) { try { buffer . insertString ( caret , selectedText , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } else { try { buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { setSelectedText ( selection [ i ] , selectedText ) ; } } finally { buffer . endCompoundEdit ( ) ; } } selectNone ( ) ; } public int [ ] getSelectedLines ( ) { Integer line ; Hashtable hash = new Hashtable ( ) ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; for ( int j = s . startLine ; j <= s . endLine ; j ++ ) { line = new Integer ( j ) ; hash . put ( line , line ) ; } } line = new Integer ( caretLine ) ; hash . put ( line , line ) ; int [ ] returnValue = new int [ hash . size ( ) ] ; int i = 0 ; Enumeration keys = hash . keys ( ) ; while ( keys . hasMoreElements ( ) ) { line = ( Integer ) keys . nextElement ( ) ; returnValue [ i ++ ] = line . intValue ( ) ; } quicksort ( returnValue , 0 , returnValue . length - 1 ) ; return returnValue ; } public final boolean isEditable ( ) { return buffer . isEditable ( ) ; } public final JPopupMenu getRightClickPopup ( ) { return popup ; } public final void setRightClickPopup ( JPopupMenu popup ) { this . popup = popup ; } public final int getMagicCaretPosition ( ) { return ( magicCaret == - 1 ? offsetToX ( caretLine , caret - getLineStartOffset ( caretLine ) ) : magicCaret ) ; } public final void setMagicCaretPosition ( int magicCaret ) { this . magicCaret = magicCaret ; } public void userInput ( char ch ) { if ( ! isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( ch == ' ' && Abbrevs . getExpandOnInput ( ) && Abbrevs . expandAbbrev ( view , false ) ) return ; else if ( ch == '\t' ) { if ( buffer . getBooleanProperty ( "indentOnTab" ) && selection . size ( ) == 0 && buffer . indentLine ( caretLine , true , false ) ) return ; else if ( buffer . getBooleanProperty ( "noTabs" ) ) { int lineStart = getLineStartOffset ( caretLine ) ; String line = getText ( lineStart , caret - lineStart ) ; setSelectedText ( createSoftTab ( line , buffer . getTabSize ( ) ) ) ; } else setSelectedText ( "\t" ) ; return ; } else if ( ch == '\n' ) { try { buffer . beginCompoundEdit ( ) ; setSelectedText ( "\n" ) ; if ( buffer . getBooleanProperty ( "indentOnEnter" ) ) buffer . indentLine ( caretLine , true , false ) ; } finally { buffer . endCompoundEdit ( ) ; } return ; } else { String str = String . valueOf ( ch ) ; if ( selection . size ( ) != 0 ) { setSelectedText ( str ) ; return ; } try { if ( ch == ' ' ) { if ( doWordWrap ( caretLine , true ) ) return ; } else doWordWrap ( caretLine , false ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } try { buffer . beginCompoundEdit ( ) ; if ( overwrite ) { int caretLineEnd = getLineEndOffset ( caretLine ) ; if ( caretLineEnd - caret > 1 ) buffer . remove ( caret , 1 ) ; } buffer . insertString ( caret , str , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { buffer . endCompoundEdit ( ) ; } } String indentOpenBrackets = ( String ) buffer . getProperty ( "indentOpenBrackets" ) ; String indentCloseBrackets = ( String ) buffer . getProperty ( "indentCloseBrackets" ) ; if ( ( indentCloseBrackets != null && indentCloseBrackets . indexOf ( ch ) != - 1 ) || ( indentOpenBrackets != null && indentOpenBrackets . indexOf ( ch ) != - 1 ) ) { buffer . indentLine ( caretLine , false , true ) ; } } public final boolean isOverwriteEnabled ( ) { return overwrite ; } public final void setOverwriteEnabled ( boolean overwrite ) { this . overwrite = overwrite ; invalidateLine ( caretLine ) ; if ( view . getStatus ( ) != null ) view . getStatus ( ) . updateMiscStatus ( ) ; } public final void toggleOverwriteEnabled ( ) { overwrite = ! overwrite ; invalidateLine ( caretLine ) ; if ( view . getStatus ( ) != null ) view . getStatus ( ) . updateMiscStatus ( ) ; } public final int getBracketPosition ( ) { return bracketPosition ; } public final int getBracketLine ( ) { return bracketLine ; } public final void addCaretListener ( CaretListener listener ) { listenerList . add ( CaretListener . class , listener ) ; } public final void removeCaretListener ( CaretListener listener ) { listenerList . remove ( CaretListener . class , listener ) ; } public final void addScrollListener ( ScrollListener listener ) { listenerList . add ( ScrollListener . class , listener ) ; } public final void removeScrollListener ( ScrollListener listener ) { listenerList . remove ( ScrollListener . class , listener ) ; } public void backspace ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( selection . size ( ) != 0 ) setSelectedText ( "" ) ; else { if ( caret == 0 ) { getToolkit ( ) . beep ( ) ; return ; } try { buffer . remove ( caret - 1 , 1 ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } } public void backspaceWord ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( selection . size ( ) != 0 ) { setSelectedText ( "" ) ; return ; } int lineStart = getLineStartOffset ( caretLine ) ; int _caret = caret - lineStart ; String lineText = getLineText ( caretLine ) ; if ( _caret == 0 ) { if ( lineStart == 0 ) { getToolkit ( ) . beep ( ) ; return ; } _caret -- ; } else { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; _caret = TextUtilities . findWordStart ( lineText , _caret - 1 , noWordSep ) ; } try { buffer . remove ( _caret + lineStart , caret - ( _caret + lineStart ) ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void delete ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( selection . size ( ) != 0 ) setSelectedText ( null ) ; else { if ( caret == buffer . getLength ( ) ) { getToolkit ( ) . beep ( ) ; return ; } try { buffer . remove ( caret , 1 ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } } public void deleteToEndOfLine ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } try { buffer . remove ( caret , getLineEndOffset ( caretLine ) - caret - 1 ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void deleteLine ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( caretLine ) ; try { int start = lineElement . getStartOffset ( ) ; int end = lineElement . getEndOffset ( ) ; if ( end > buffer . getLength ( ) ) { if ( start != 0 ) start -- ; end -- ; } buffer . remove ( start , end - start ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void deleteParagraph ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } int start = 0 , end = buffer . getLength ( ) ; loop : for ( int i = caretLine - 1 ; i >= 0 ; i -- ) { getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : continue loop ; } } start = getLineStartOffset ( i ) ; break loop ; } loop : for ( int i = caretLine + 1 ; i < getLineCount ( ) ; i ++ ) { getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : continue loop ; } } end = getLineEndOffset ( i ) - 1 ; break loop ; } try { buffer . remove ( start , end - start ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void deleteToStartOfLine ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( caretLine ) ; try { buffer . remove ( lineElement . getStartOffset ( ) , caret - lineElement . getStartOffset ( ) ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void deleteWord ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( selection . size ( ) != 0 ) { setSelectedText ( "" ) ; return ; } int lineStart = getLineStartOffset ( caretLine ) ; int _caret = caret - lineStart ; String lineText = getLineText ( caretLine ) ; if ( _caret == lineText . length ( ) ) { if ( lineStart + _caret == buffer . getLength ( ) ) { getToolkit ( ) . beep ( ) ; return ; } _caret ++ ; } else { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; _caret = TextUtilities . findWordEnd ( lineText , _caret + 1 , noWordSep ) ; } try { buffer . remove ( caret , ( _caret + lineStart ) - caret ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void goToNextBracket ( boolean select ) { String text = getText ( caret , buffer . getLength ( ) - caret - 1 ) ; int newCaret = - 1 ; loop : for ( int i = 0 ; i < text . length ( ) ; i ++ ) { switch ( text . charAt ( i ) ) { case ')' : case ']' : case '}' : newCaret = caret + i + 1 ; break loop ; } } if ( newCaret == - 1 ) getToolkit ( ) . beep ( ) ; else { if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } } public void goToNextCharacter ( boolean select ) { if ( ! select && selection . size ( ) != 0 ) { Selection s = getSelectionAtOffset ( caret ) ; if ( s != null ) { if ( multi ) { if ( caret != s . end ) { moveCaretPosition ( s . end ) ; return ; } } else { setCaretPosition ( s . end ) ; return ; } } } if ( caret == buffer . getLength ( ) ) getToolkit ( ) . beep ( ) ; int newCaret ; if ( caret == getLineEndOffset ( caretLine ) - 1 ) { int line = buffer . getNextVisibleLine ( caretLine ) ; if ( line == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } newCaret = getLineStartOffset ( line ) ; } else newCaret = caret + 1 ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToNextLine ( boolean select ) { int caret = getCaretPosition ( ) ; int line = getCaretLine ( ) ; int magic = getMagicCaretPosition ( ) ; int nextLine = buffer . getNextVisibleLine ( line ) ; if ( nextLine == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } int newCaret = getLineStartOffset ( nextLine ) + xToOffset ( nextLine , magic + 1 ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( magic ) ; } public void goToNextMarker ( boolean select ) { Vector markers = buffer . getMarkers ( ) ; Marker marker = null ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker _marker = ( Marker ) markers . elementAt ( i ) ; if ( _marker . getPosition ( ) > caret ) { marker = _marker ; break ; } } if ( marker == null ) getToolkit ( ) . beep ( ) ; else { if ( select ) extendSelection ( caret , marker . getPosition ( ) ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( marker . getPosition ( ) ) ; } } public void goToNextPage ( boolean select ) { int lineCount = buffer . getVirtualLineCount ( ) ; int magic = getMagicCaretPosition ( ) ; if ( firstLine + visibleLines * 2 >= lineCount - 1 ) setFirstLine ( lineCount - visibleLines ) ; else setFirstLine ( firstLine + visibleLines ) ; int newLine = buffer . virtualToPhysical ( Math . min ( lineCount - 1 , buffer . physicalToVirtual ( caretLine ) + visibleLines ) ) ; int newCaret = getLineStartOffset ( newLine ) + xToOffset ( newLine , magic + 1 ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( magic ) ; } public void goToNextParagraph ( boolean select ) { int lineNo = getCaretLine ( ) ; int newCaret = getBufferLength ( ) ; boolean foundBlank = false ; loop : for ( int i = lineNo + 1 ; i < getLineCount ( ) ; i ++ ) { if ( ! buffer . isLineVisible ( i ) ) continue ; getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : if ( foundBlank ) { newCaret = getLineStartOffset ( i ) ; break loop ; } else continue loop ; } } foundBlank = true ; } if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToNextWord ( boolean select ) { int lineStart = getLineStartOffset ( caretLine ) ; int newCaret = caret - lineStart ; String lineText = getLineText ( caretLine ) ; if ( newCaret == lineText . length ( ) ) { int nextLine = buffer . getNextVisibleLine ( caretLine ) ; if ( nextLine == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } newCaret = getLineStartOffset ( nextLine ) ; } else { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; newCaret = TextUtilities . findWordEnd ( lineText , newCaret + 1 , noWordSep ) + lineStart ; } if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToPrevBracket ( boolean select ) { String text = getText ( 0 , caret ) ; int newCaret = - 1 ; loop : for ( int i = getCaretPosition ( ) - 1 ; i >= 0 ; i -- ) { switch ( text . charAt ( i ) ) { case '(' : case '[' : case '{' : newCaret = i ; break loop ; } } if ( newCaret == - 1 ) getToolkit ( ) . beep ( ) ; else { if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } } public void goToPrevCharacter ( boolean select ) { if ( ! select && selection . size ( ) != 0 ) { Selection s = getSelectionAtOffset ( caret ) ; if ( s != null ) { if ( multi ) { if ( caret != s . start ) { moveCaretPosition ( s . start ) ; return ; } } else { setCaretPosition ( s . start ) ; return ; } } } int newCaret ; if ( caret == getLineStartOffset ( caretLine ) ) { int line = buffer . getPrevVisibleLine ( caretLine ) ; if ( line == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } newCaret = getLineEndOffset ( line ) - 1 ; } else newCaret = caret - 1 ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToPrevLine ( boolean select ) { int magic = getMagicCaretPosition ( ) ; int prevLine = buffer . getPrevVisibleLine ( caretLine ) ; if ( prevLine == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } int newCaret = getLineStartOffset ( prevLine ) + xToOffset ( prevLine , magic + 1 ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( magic ) ; } public void goToPrevMarker ( boolean select ) { Vector markers = buffer . getMarkers ( ) ; Marker marker = null ; for ( int i = markers . size ( ) - 1 ; i >= 0 ; i -- ) { Marker _marker = ( Marker ) markers . elementAt ( i ) ; if ( _marker . getPosition ( ) < caret ) { marker = _marker ; break ; } } if ( marker == null ) getToolkit ( ) . beep ( ) ; else { if ( select ) extendSelection ( caret , marker . getPosition ( ) ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( marker . getPosition ( ) ) ; } } public void goToPrevPage ( boolean select ) { if ( firstLine < visibleLines ) setFirstLine ( 0 ) ; else setFirstLine ( firstLine - visibleLines ) ; int magic = getMagicCaretPosition ( ) ; int newLine = buffer . virtualToPhysical ( Math . max ( 0 , buffer . physicalToVirtual ( caretLine ) - visibleLines ) ) ; int newCaret = getLineStartOffset ( newLine ) + xToOffset ( newLine , magic + 1 ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( magic ) ; } public void goToPrevParagraph ( boolean select ) { int lineNo = caretLine ; int newCaret = 0 ; boolean foundBlank = false ; loop : for ( int i = lineNo - 1 ; i >= 0 ; i -- ) { if ( ! buffer . isLineVisible ( i ) ) continue ; getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : if ( foundBlank ) { newCaret = getLineEndOffset ( i ) - 1 ; break loop ; } else continue loop ; } } foundBlank = true ; } if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToPrevWord ( boolean select ) { int lineStart = getLineStartOffset ( caretLine ) ; int newCaret = caret - lineStart ; String lineText = getLineText ( caretLine ) ; if ( newCaret == 0 ) { if ( lineStart == 0 ) { view . getToolkit ( ) . beep ( ) ; return ; } else { int prevLine = buffer . getPrevVisibleLine ( caretLine ) ; if ( prevLine == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } newCaret = getLineEndOffset ( prevLine ) - 1 ; } } else { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; newCaret = TextUtilities . findWordStart ( lineText , newCaret - 1 , noWordSep ) + lineStart ; } if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void smartHome ( boolean select ) { if ( ! jEdit . getBooleanProperty ( "view.homeEnd" ) ) goToStartOfLine ( select ) ; else { switch ( view . getInputHandler ( ) . getLastActionCount ( ) ) { case 1 : goToStartOfWhiteSpace ( select ) ; break ; case 2 : goToStartOfLine ( select ) ; break ; default : goToFirstVisibleLine ( select ) ; break ; } } } public void smartEnd ( boolean select ) { if ( ! jEdit . getBooleanProperty ( "view.homeEnd" ) ) goToEndOfLine ( select ) ; else { switch ( view . getInputHandler ( ) . getLastActionCount ( ) ) { case 1 : goToEndOfWhiteSpace ( select ) ; break ; case 2 : goToEndOfLine ( select ) ; break ; default : goToLastVisibleLine ( select ) ; break ; } } } public void goToStartOfLine ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToStartOfLine(" + select + ");" ) ; int newCaret = getLineStartOffset ( getCaretLine ( ) ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToEndOfLine ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToEndOfLine(" + select + ");" ) ; int newCaret = getLineEndOffset ( getCaretLine ( ) ) - 1 ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( Integer . MAX_VALUE ) ; } public void goToStartOfWhiteSpace ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToStartOfWhiteSpace(" + select + ");" ) ; int firstIndent = MiscUtilities . getLeadingWhiteSpace ( getLineText ( caretLine ) ) ; int firstOfLine = getLineStartOffset ( caretLine ) ; firstIndent = firstOfLine + firstIndent ; if ( firstIndent == getLineEndOffset ( caretLine ) - 1 ) firstIndent = firstOfLine ; if ( select ) extendSelection ( caret , firstIndent ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( firstIndent ) ; } public void goToEndOfWhiteSpace ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToEndOfWhiteSpace(" + select + ");" ) ; int lastIndent = MiscUtilities . getTrailingWhiteSpace ( getLineText ( caretLine ) ) ; int lastOfLine = getLineEndOffset ( caretLine ) - 1 ; lastIndent = lastOfLine - lastIndent ; if ( lastIndent == getLineStartOffset ( caretLine ) ) lastIndent = lastOfLine ; if ( select ) extendSelection ( caret , lastIndent ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( lastIndent ) ; } public void goToFirstVisibleLine ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToFirstVisibleLine(" + select + ");" ) ; int firstVisibleLine = ( firstLine <= electricScroll ) ? 0 : firstLine + electricScroll ; if ( firstVisibleLine >= getVirtualLineCount ( ) ) firstVisibleLine = getVirtualLineCount ( ) - 1 ; firstVisibleLine = buffer . virtualToPhysical ( firstVisibleLine ) ; int firstVisible = getLineEndOffset ( firstVisibleLine ) - 1 ; if ( select ) extendSelection ( caret , firstVisible ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( firstVisible ) ; } public void goToLastVisibleLine ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToLastVisibleLine(" + select + ");" ) ; int lastVisibleLine = firstLine + visibleLines ; if ( lastVisibleLine >= getVirtualLineCount ( ) ) lastVisibleLine = getVirtualLineCount ( ) - 1 ; else if ( lastVisibleLine <= electricScroll ) lastVisibleLine = 0 ; else lastVisibleLine -= ( electricScroll + 1 ) ; lastVisibleLine = buffer . virtualToPhysical ( lastVisibleLine ) ; int lastVisible = getLineEndOffset ( lastVisibleLine ) - 1 ; if ( select ) extendSelection ( caret , lastVisible ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( lastVisible ) ; } public void goToMarker ( char shortcut , boolean select ) { Marker marker = buffer . getMarker ( shortcut ) ; if ( marker == null ) { getToolkit ( ) . beep ( ) ; return ; } int pos = marker . getPosition ( ) ; if ( select ) extendSelection ( caret , pos ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( pos ) ; } public void addMarker ( ) { Selection [ ] selection = getSelection ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; if ( s . startLine != s . endLine ) { if ( s . startLine != caretLine ) buffer . addMarker ( '\0' , s . start ) ; } if ( s . endLine != caretLine ) buffer . addMarker ( '\0' , s . end ) ; } buffer . addOrRemoveMarker ( '\0' , caret ) ; } public void swapMarkerAndCaret ( char shortcut ) { Marker marker = buffer . getMarker ( shortcut ) ; if ( marker == null ) { getToolkit ( ) . beep ( ) ; return ; } int caret = getCaretPosition ( ) ; setCaretPosition ( marker . getPosition ( ) ) ; buffer . addMarker ( shortcut , caret ) ; } public void lineComment ( ) { String comment = ( String ) buffer . getProperty ( "lineComment" ) ; if ( ! buffer . isEditable ( ) || comment == null || comment . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } comment = comment + ' ' ; buffer . beginCompoundEdit ( ) ; int [ ] lines = getSelectedLines ( ) ; try { for ( int i = 0 ; i < lines . length ; i ++ ) { buffer . insertString ( getLineStartOffset ( lines [ i ] ) , comment , null ) ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { buffer . endCompoundEdit ( ) ; } selectNone ( ) ; } public void rangeComment ( ) { String commentStart = ( String ) buffer . getProperty ( "commentStart" ) ; String commentEnd = ( String ) buffer . getProperty ( "commentEnd" ) ; if ( ! buffer . isEditable ( ) || commentStart == null || commentEnd == null || commentStart . length ( ) == 0 || commentEnd . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } commentStart = commentStart + ' ' ; commentEnd = ' ' + commentEnd ; try { buffer . beginCompoundEdit ( ) ; Selection [ ] selection = getSelection ( ) ; if ( selection . length == 0 ) { int oldCaret = caret ; buffer . insertString ( caret , commentStart , null ) ; buffer . insertString ( caret , commentEnd , null ) ; setCaretPosition ( oldCaret + commentStart . length ( ) ) ; } for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; if ( s instanceof Selection . Range ) { buffer . insertString ( s . start , commentStart , null ) ; buffer . insertString ( s . end , commentEnd , null ) ; } else if ( s instanceof Selection . Rect ) { for ( int j = s . startLine ; j <= s . endLine ; j ++ ) { buffer . insertString ( s . getStart ( buffer , j ) , commentStart , null ) ; int end = s . getEnd ( buffer , j ) + ( j == s . endLine ? 0 : commentStart . length ( ) ) ; buffer . insertString ( end , commentEnd , null ) ; } } } selectNone ( ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { buffer . endCompoundEdit ( ) ; } } public void formatParagraph ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } int maxLineLength = ( ( Integer ) buffer . getProperty ( "maxLineLen" ) ) . intValue ( ) ; if ( maxLineLength <= 0 ) { getToolkit ( ) . beep ( ) ; return ; } Selection [ ] selection = getSelection ( ) ; if ( selection . length != 0 ) { buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , TextUtilities . format ( getSelectedText ( s ) , maxLineLength ) ) ; } buffer . endCompoundEdit ( ) ; } else { int lineNo = getCaretLine ( ) ; int start = 0 , end = buffer . getLength ( ) ; loop : for ( int i = lineNo - 1 ; i >= 0 ; i -- ) { getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : continue loop ; } } start = getLineStartOffset ( i ) ; break loop ; } loop : for ( int i = lineNo + 1 ; i < getLineCount ( ) ; i ++ ) { getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : continue loop ; } } end = getLineEndOffset ( i ) - 1 ; break loop ; } try { buffer . beginCompoundEdit ( ) ; String text = buffer . getText ( start , end - start ) ; buffer . remove ( start , end - start ) ; buffer . insertString ( start , TextUtilities . format ( text , maxLineLength ) , null ) ; } catch ( BadLocationException bl ) { return ; } finally { buffer . endCompoundEdit ( ) ; } } } public void spacesToTabs ( ) { Selection [ ] selection = getSelection ( ) ; if ( ! buffer . isEditable ( ) || selection . length == 0 ) { getToolkit ( ) . beep ( ) ; return ; } buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , TextUtilities . spacesToTabs ( getSelectedText ( s ) , buffer . getTabSize ( ) ) ) ; } buffer . endCompoundEdit ( ) ; } public void tabsToSpaces ( ) { Selection [ ] selection = getSelection ( ) ; if ( ! buffer . isEditable ( ) || selection . length == 0 ) { getToolkit ( ) . beep ( ) ; return ; } buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , TextUtilities . tabsToSpaces ( getSelectedText ( s ) , buffer . getTabSize ( ) ) ) ; } buffer . endCompoundEdit ( ) ; } public void toUpperCase ( ) { Selection [ ] selection = getSelection ( ) ; if ( ! buffer . isEditable ( ) || selection . length == 0 ) { getToolkit ( ) . beep ( ) ; return ; } buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , getSelectedText ( s ) . toUpperCase ( ) ) ; } buffer . endCompoundEdit ( ) ; } public void toLowerCase ( ) { Selection [ ] selection = getSelection ( ) ; if ( ! buffer . isEditable ( ) || selection . length == 0 ) { getToolkit ( ) . beep ( ) ; return ; } buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , getSelectedText ( s ) . toLowerCase ( ) ) ; } buffer . endCompoundEdit ( ) ; } public void removeTrailingWhiteSpace ( ) { if ( ! buffer . isEditable ( ) ) getToolkit ( ) . beep ( ) ; else { buffer . removeTrailingWhiteSpace ( getSelectedLines ( ) ) ; } } public void indentSelectedLines ( ) { if ( ! buffer . isEditable ( ) ) getToolkit ( ) . beep ( ) ; else { buffer . indentLines ( getSelectedLines ( ) ) ; selectNone ( ) ; } } public void shiftIndentLeft ( ) { if ( ! buffer . isEditable ( ) ) getToolkit ( ) . beep ( ) ; else { buffer . shiftIndentLeft ( getSelectedLines ( ) ) ; } } public void shiftIndentRight ( ) { if ( ! buffer . isEditable ( ) ) getToolkit ( ) . beep ( ) ; else { buffer . shiftIndentRight ( getSelectedLines ( ) ) ; } } public void joinLines ( ) { Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( caretLine ) ; int start = lineElement . getStartOffset ( ) ; int end = lineElement . getEndOffset ( ) ; if ( end > buffer . getLength ( ) ) { getToolkit ( ) . beep ( ) ; return ; } Element nextLineElement = map . getElement ( caretLine + 1 ) ; int nextStart = nextLineElement . getStartOffset ( ) ; int nextEnd = nextLineElement . getEndOffset ( ) ; try { buffer . remove ( end - 1 , MiscUtilities . getLeadingWhiteSpace ( buffer . getText ( nextStart , nextEnd - nextStart ) ) + 1 ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void goToMatchingBracket ( ) { int dot = caret - getLineStartOffset ( caretLine ) ; try { int bracket = TextUtilities . findMatchingBracket ( buffer , caretLine , Math . max ( 0 , dot - 1 ) ) ; if ( bracket != - 1 ) { setCaretPosition ( bracket + 1 ) ; return ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } getToolkit ( ) . beep ( ) ; } private final String openBrackets = "([{" ; private final String closeBrackets = ")]}" ; public void selectBlock ( ) { Selection s = getSelectionAtOffset ( caret ) ; int start , end ; if ( s == null ) start = end = caret ; else { start = s . start ; end = s . end ; } String text = getText ( 0 , buffer . getLength ( ) ) ; int count = 1 ; char openBracket = '\0' ; char closeBracket = '\0' ; if ( start == 0 ) { view . getToolkit ( ) . beep ( ) ; return ; } backward_scan : while ( -- start > 0 ) { char c = text . charAt ( start ) ; int index = openBrackets . indexOf ( c ) ; if ( index != - 1 ) { if ( -- count == 0 ) { openBracket = c ; closeBracket = closeBrackets . charAt ( index ) ; break backward_scan ; } } else if ( closeBrackets . indexOf ( c ) != - 1 ) count ++ ; } count = 1 ; if ( openBracket == '\0' ) { getToolkit ( ) . beep ( ) ; return ; } else { forward_scan : do { char c = text . charAt ( end ) ; if ( c == closeBracket ) { if ( -- count == 0 ) { end ++ ; break forward_scan ; } } else if ( c == openBracket ) count ++ ; } while ( ++ end < buffer . getLength ( ) ) ; } setSelection ( new Selection . Range ( start , end ) ) ; moveCaretPosition ( end ) ; } public void showGoToLineDialog ( ) { String line = GUIUtilities . input ( view , "goto-line" , null ) ; if ( line == null ) return ; try { int lineNumber = Integer . parseInt ( line ) - 1 ; setCaretPosition ( getLineStartOffset ( lineNumber ) ) ; } catch ( Exception e ) { getToolkit ( ) . beep ( ) ; } } public void showSelectLineRangeDialog ( ) { new SelectLineRange ( view ) ; } public void showWordCountDialog ( ) { String selection = getSelectedText ( ) ; if ( selection != null ) { doWordCount ( view , selection ) ; return ; } try { doWordCount ( view , buffer . getText ( 0 , buffer . getLength ( ) ) ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void completeWord ( ) { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; if ( noWordSep == null ) noWordSep = "" ; if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } String line = getLineText ( caretLine ) ; int dot = caret - getLineStartOffset ( caretLine ) ; if ( dot == 0 ) { getToolkit ( ) . beep ( ) ; return ; } char ch = line . charAt ( dot - 1 ) ; if ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } int wordStart = TextUtilities . findWordStart ( line , dot - 1 , noWordSep ) ; String word = line . substring ( wordStart , dot ) ; if ( word . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } Vector completions = new Vector ( ) ; int wordLen = word . length ( ) ; for ( int i = 0 ; i < getLineCount ( ) ; i ++ ) { line = getLineText ( i ) ; if ( line . startsWith ( word ) ) { if ( i == caretLine && wordStart == 0 ) continue ; String _word = completeWord ( line , 0 , noWordSep ) ; if ( _word . length ( ) != wordLen ) { if ( completions . indexOf ( _word ) == - 1 ) completions . addElement ( _word ) ; } } int len = line . length ( ) - word . length ( ) ; for ( int j = 0 ; j < len ; j ++ ) { char c = line . charAt ( j ) ; if ( ! Character . isLetterOrDigit ( c ) && noWordSep . indexOf ( c ) == - 1 ) { if ( i == caretLine && wordStart == ( j + 1 ) ) continue ; if ( line . regionMatches ( j + 1 , word , 0 , wordLen ) ) { String _word = completeWord ( line , j + 1 , noWordSep ) ; if ( _word . length ( ) != wordLen ) { if ( completions . indexOf ( _word ) == - 1 ) completions . addElement ( _word ) ; } } } } } MiscUtilities . quicksort ( completions , new MiscUtilities . StringICaseCompare ( ) ) ; if ( completions . size ( ) == 0 ) getToolkit ( ) . beep ( ) ; else if ( completions . size ( ) == 1 ) { setSelectedText ( ( ( String ) completions . elementAt ( 0 ) ) . substring ( wordLen ) ) ; } else { Point location = new Point ( offsetToX ( caretLine , wordStart ) , painter . getFontMetrics ( ) . getHeight ( ) * ( buffer . physicalToVirtual ( caretLine ) - firstLine + 1 ) ) ; SwingUtilities . convertPointToScreen ( location , painter ) ; new CompleteWord ( view , word , completions , location ) ; } } public void selectFold ( ) { selectFoldAt ( caretLine ) ; } public void selectFoldAt ( int line ) { int start ; int end ; if ( buffer . isFoldStart ( line ) ) { start = line ; int foldLevel = buffer . getFoldLevel ( line ) ; line ++ ; while ( line < buffer . getLineCount ( ) && buffer . getFoldLevel ( line ) > foldLevel ) line ++ ; end = line ; } else { start = line ; int foldLevel = buffer . getFoldLevel ( line ) ; while ( start >= 0 && buffer . getFoldLevel ( start ) >= foldLevel ) start -- ; end = line ; while ( end < buffer . getLineCount ( ) && buffer . getFoldLevel ( end ) >= foldLevel ) end ++ ; } int newCaret = getLineEndOffset ( end ) - 1 ; extendSelection ( getLineStartOffset ( start ) , newCaret ) ; moveCaretPosition ( newCaret ) ; } public void addNotify ( ) { super . addNotify ( ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( painter ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( gutter ) ; if ( ! documentHandlerInstalled ) { documentHandlerInstalled = true ; buffer . addDocumentListener ( documentHandler ) ; buffer . addFoldListener ( foldHandler ) ; } recalculateVisibleLines ( ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; ToolTipManager . sharedInstance ( ) . unregisterComponent ( painter ) ; ToolTipManager . sharedInstance ( ) . unregisterComponent ( gutter ) ; if ( focusedComponent == this ) focusedComponent = null ; if ( documentHandlerInstalled ) { buffer . removeDocumentListener ( documentHandler ) ; buffer . removeFoldListener ( foldHandler ) ; documentHandlerInstalled = false ; } } public boolean hasFocus ( ) { Component c = this ; while ( ! ( c instanceof Window ) ) { if ( c == null ) return false ; c = c . getParent ( ) ; } Component focusOwner = ( ( Window ) c ) . getFocusOwner ( ) ; boolean hasFocus = ( focusOwner == this ) ; if ( hasFocus && focusedComponent != this ) focusedComponent = this ; return hasFocus ; } public void grabFocus ( ) { super . grabFocus ( ) ; hasFocus ( ) ; } public boolean getFocusTraversalKeysEnabled ( ) { return false ; } public final boolean isMultipleSelectionEnabled ( ) { return multi ; } public final void toggleMultipleSelectionEnabled ( ) { multi = ! multi ; if ( view . getStatus ( ) != null ) view . getStatus ( ) . updateMiscStatus ( ) ; } public final void setMultipleSelectionEnabled ( boolean multi ) { JEditTextArea . multi = multi ; if ( view . getStatus ( ) != null ) view . getStatus ( ) . updateMiscStatus ( ) ; } public void processKeyEvent ( KeyEvent evt ) { evt = KeyEventWorkaround . processKeyEvent ( evt ) ; if ( evt == null ) return ; if ( view . isClosed ( ) ) return ; InputHandler inputHandler = view . getInputHandler ( ) ; KeyListener keyEventInterceptor = view . getKeyEventInterceptor ( ) ; switch ( evt . getID ( ) ) { case KeyEvent . KEY_TYPED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyTyped ( evt ) ; else inputHandler . keyTyped ( evt ) ; break ; case KeyEvent . KEY_PRESSED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyPressed ( evt ) ; else inputHandler . keyPressed ( evt ) ; break ; case KeyEvent . KEY_RELEASED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyReleased ( evt ) ; else inputHandler . keyReleased ( evt ) ; break ; } if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } Segment lineSegment ; MouseHandler mouseHandler ; int maxHorizontalScrollWidth ; Vector selection ; final boolean isCaretVisible ( ) { return blink && hasFocus ( ) ; } final boolean isHighlightVisible ( ) { return hasFocus ( ) ; } void recalculateVisibleLines ( ) { if ( painter == null ) return ; int height = painter . getHeight ( ) ; int lineHeight = painter . getFontMetrics ( ) . getHeight ( ) ; visibleLines = height / lineHeight ; updateScrollBars ( ) ; } void updateMaxHorizontalScrollWidth ( ) { int _maxHorizontalScrollWidth = buffer . getMaxLineWidth ( physFirstLine , visibleLines ) ; if ( _maxHorizontalScrollWidth != maxHorizontalScrollWidth ) { maxHorizontalScrollWidth = _maxHorizontalScrollWidth ; horizontal . setValues ( - horizontalOffset , painter . getWidth ( ) , 0 , maxHorizontalScrollWidth + painter . getFontMetrics ( ) . charWidth ( 'w' ) ) ; } } private static String CENTER = "center" ; private static String RIGHT = "right" ; private static String LEFT = "left" ; private static String BOTTOM = "bottom" ; private static Timer caretTimer ; private static JEditTextArea focusedComponent ; private View view ; private Gutter gutter ; private TextAreaPainter painter ; private JPopupMenu popup ; private EventListenerList listenerList ; private MutableCaretEvent caretEvent ; private boolean caretBlinks ; private boolean blink ; private int firstLine ; private int physFirstLine ; private int visibleLines ; private int electricScroll ; private int horizontalOffset ; private boolean middleMousePaste ; private JScrollBar vertical ; private JScrollBar horizontal ; private boolean scrollBarsInitialized ; private Buffer buffer ; private DocumentHandler documentHandler ; private FoldHandler foldHandler ; private boolean documentHandlerInstalled ; private int caret ; private int caretLine ; private int bracketPosition ; private int bracketLine ; private int magicCaret ; private static boolean multi ; private boolean overwrite ; private TextRenderer renderer ; private static void quicksort ( int [ ] obj , int _start , int _end ) { int start = _start ; int end = _end ; int mid = obj [ ( _start + _end ) / 2 ] ; if ( _start > _end ) return ; while ( start <= end ) { while ( start < _end && obj [ start ] < mid ) start ++ ; while ( end > _start && obj [ end ] > mid ) end -- ; if ( start <= end ) { int tmp = obj [ start ] ; obj [ start ] = obj [ end ] ; obj [ end ] = tmp ; start ++ ; end -- ; } } if ( _start < end ) quicksort ( obj , _start , end ) ; if ( start < _end ) quicksort ( obj , start , _end ) ; } private void _addToSelection ( Selection addMe ) { if ( addMe . start < 0 ) addMe . start = 0 ; else if ( addMe . end > buffer . getLength ( ) ) addMe . end = buffer . getLength ( ) ; if ( addMe . start > addMe . end ) { throw new IllegalArgumentException ( addMe . start + " > " + addMe . end ) ; } else if ( addMe . start == addMe . end ) return ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; if ( _selectionsOverlap ( s , addMe ) ) { addMe . start = Math . min ( s . start , addMe . start ) ; addMe . end = Math . max ( s . end , addMe . end ) ; selection . removeElement ( s ) ; i -- ; } } addMe . startLine = getLineOfOffset ( addMe . start ) ; addMe . endLine = getLineOfOffset ( addMe . end ) ; selection . addElement ( addMe ) ; invalidateLineRange ( addMe . startLine , addMe . endLine ) ; } private boolean _selectionsOverlap ( Selection s1 , Selection s2 ) { if ( ( s1 . start >= s2 . start && s1 . start <= s2 . end ) || ( s1 . end >= s2 . start && s1 . end <= s2 . end ) ) return true ; else return false ; } private void getSelectedText ( Selection s , StringBuffer buf ) { if ( s instanceof Selection . Rect ) { Element map = buffer . getDefaultRootElement ( ) ; int start = s . start - map . getElement ( s . startLine ) . getStartOffset ( ) ; int end = s . end - map . getElement ( s . endLine ) . getStartOffset ( ) ; if ( end < start ) { int tmp = end ; end = start ; start = tmp ; } for ( int i = s . startLine ; i <= s . endLine ; i ++ ) { Element lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; int lineEnd = lineElement . getEndOffset ( ) - 1 ; int lineLen = lineEnd - lineStart ; lineStart = Math . min ( lineStart + start , lineEnd ) ; lineLen = Math . min ( end - start , lineEnd - lineStart ) ; getText ( lineStart , lineLen , lineSegment ) ; buf . append ( lineSegment . array , lineSegment . offset , lineSegment . count ) ; if ( i != s . endLine ) buf . append ( '\n' ) ; } } else { getText ( s . start , s . end - s . start , lineSegment ) ; buf . append ( lineSegment . array , lineSegment . offset , lineSegment . count ) ; } } private void fireCaretEvent ( ) { Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -- ) { if ( listeners [ i ] == CaretListener . class ) { ( ( CaretListener ) listeners [ i + 1 ] ) . caretUpdate ( caretEvent ) ; } } } private void fireScrollEvent ( boolean vertical ) { Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -- ) { if ( listeners [ i ] == ScrollListener . class ) { if ( vertical ) ( ( ScrollListener ) listeners [ i + 1 ] ) . scrolledVertically ( this ) ; else ( ( ScrollListener ) listeners [ i + 1 ] ) . scrolledHorizontally ( this ) ; } } } private String createSoftTab ( String line , int tabSize ) { int pos = 0 ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { switch ( line . charAt ( pos ) ) { case '\t' : pos = 0 ; break ; default : if ( ++ pos >= tabSize ) pos = 0 ; break ; } } return MiscUtilities . createWhiteSpace ( tabSize - pos , 0 ) ; } private boolean doWordWrap ( int line , boolean spaceInserted ) throws BadLocationException { int maxLineLen = ( ( Integer ) buffer . getProperty ( "maxLineLen" ) ) . intValue ( ) ; if ( maxLineLen <= 0 ) return false ; Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line ) ; int start = lineElement . getStartOffset ( ) ; int end = lineElement . getEndOffset ( ) ; int len = end - start - 1 ; if ( getCaretPosition ( ) != end - 1 ) return false ; boolean returnValue = false ; int tabSize = buffer . getTabSize ( ) ; String wordBreakChars = ( String ) buffer . getProperty ( "wordBreakChars" ) ; buffer . getText ( start , len , lineSegment ) ; int lineStart = lineSegment . offset ; int logicalLength = 0 ; int lastWordOffset = - 1 ; boolean lastWasSpace = true ; boolean initialWhiteSpace = true ; int initialWhiteSpaceLength = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = lineSegment . array [ lineStart + i ] ; if ( ch == '\t' ) { if ( initialWhiteSpace ) initialWhiteSpaceLength = i + 1 ; logicalLength += tabSize - ( logicalLength % tabSize ) ; if ( ! lastWasSpace && logicalLength <= maxLineLen ) { lastWordOffset = i ; lastWasSpace = true ; } } else if ( ch == ' ' ) { if ( initialWhiteSpace ) initialWhiteSpaceLength = i + 1 ; logicalLength ++ ; if ( ! lastWasSpace && logicalLength <= maxLineLen ) { lastWordOffset = i ; lastWasSpace = true ; } } else if ( wordBreakChars != null && wordBreakChars . indexOf ( ch ) != - 1 ) { initialWhiteSpace = false ; logicalLength ++ ; if ( ! lastWasSpace && logicalLength <= maxLineLen ) { lastWordOffset = i ; lastWasSpace = true ; } } else { initialWhiteSpace = false ; logicalLength ++ ; lastWasSpace = false ; } int insertNewLineAt ; if ( spaceInserted && logicalLength == maxLineLen && i == len - 1 ) { insertNewLineAt = end - 1 ; returnValue = true ; } else if ( logicalLength >= maxLineLen && lastWordOffset != - 1 ) insertNewLineAt = lastWordOffset + start ; else continue ; try { buffer . beginCompoundEdit ( ) ; buffer . insertString ( insertNewLineAt , "\n" , null ) ; buffer . indentLine ( line + 1 , true , true ) ; } finally { buffer . endCompoundEdit ( ) ; } return returnValue ; } return false ; } private void doWordCount ( View view , String text ) { char [ ] chars = text . toCharArray ( ) ; int characters = chars . length ; int words ; if ( characters == 0 ) words = 0 ; else words = 1 ; int lines = 1 ; boolean word = false ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '\r' : case '\n' : lines ++ ; case ' ' : case '\t' : if ( word ) { words ++ ; word = false ; } break ; default : word = true ; break ; } } Object [ ] args = { new Integer ( characters ) , new Integer ( words ) , new Integer ( lines ) } ; GUIUtilities . message ( view , "wordcount" , args ) ; } private String completeWord ( String line , int offset , String noWordSep ) { int wordEnd = TextUtilities . findWordEnd ( line , offset + 1 , noWordSep ) ; return line . substring ( offset , wordEnd ) ; } private void updateBracketHighlight ( ) { if ( ! painter . isBracketHighlightEnabled ( ) ) return ; if ( bracketLine != - 1 ) invalidateLine ( bracketLine ) ; int line = getCaretLine ( ) ; int offset = getCaretPosition ( ) - getLineStartOffset ( line ) ; if ( offset == 0 ) { bracketPosition = bracketLine = - 1 ; return ; } int endLine ; if ( visibleLines == 0 ) endLine = buffer . getLineCount ( ) ; else { endLine = Math . min ( buffer . getLineCount ( ) , buffer . virtualToPhysical ( firstLine + visibleLines ) ) ; } int beginLine = Math . min ( line , physFirstLine ) ; try { int bracketOffset = TextUtilities . findMatchingBracket ( buffer , line , offset - 1 , beginLine , endLine ) ; if ( bracketOffset != - 1 ) { bracketLine = getLineOfOffset ( bracketOffset ) ; bracketPosition = bracketOffset - getLineStartOffset ( bracketLine ) ; invalidateLine ( bracketLine ) ; return ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } bracketLine = bracketPosition = - 1 ; } private void documentChanged ( DocumentEvent evt ) { DocumentEvent . ElementChange ch = evt . getChange ( buffer . getDefaultRootElement ( ) ) ; int count ; if ( ch == null ) count = 0 ; else count = ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ; int line = getLineOfOffset ( evt . getOffset ( ) ) ; if ( count == 0 ) invalidateLine ( line ) ; else if ( line < firstLine ) { setFirstLine ( firstLine + count ) ; } else { updateScrollBars ( ) ; invalidateLineRange ( line , buffer . virtualToPhysical ( firstLine + visibleLines ) ) ; } } static class TextAreaBorder extends AbstractBorder { private static final Insets insets = new Insets ( 1 , 1 , 2 , 2 ) ; public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . translate ( x , y ) ; g . setColor ( MetalLookAndFeel . getControlDarkShadow ( ) ) ; g . drawRect ( 0 , 0 , width - 2 , height - 2 ) ; g . setColor ( MetalLookAndFeel . getControlHighlight ( ) ) ; g . drawLine ( width - 1 , 1 , width - 1 , height - 1 ) ; g . drawLine ( 1 , height - 1 , width - 1 , height - 1 ) ; g . setColor ( MetalLookAndFeel . getControl ( ) ) ; g . drawLine ( width - 2 , 2 , width - 2 , 2 ) ; g . drawLine ( 1 , height - 2 , 1 , height - 2 ) ; g . translate ( - x , - y ) ; } public Insets getBorderInsets ( Component c ) { return new Insets ( 1 , 1 , 2 , 2 ) ; } } class ScrollLayout implements LayoutManager { public void addLayoutComponent ( String name , Component comp ) { if ( name . equals ( CENTER ) ) center = comp ; else if ( name . equals ( RIGHT ) ) right = comp ; else if ( name . equals ( LEFT ) ) left = comp ; else if ( name . equals ( BOTTOM ) ) bottom = comp ; } public void removeLayoutComponent ( Component comp ) { if ( center == comp ) center = null ; else if ( right == comp ) right = null ; else if ( left == comp ) left = null ; else if ( bottom == comp ) bottom = null ; } public Dimension preferredLayoutSize ( Container parent ) { Dimension dim = new Dimension ( ) ; Border border = getBorder ( ) ; Insets insets ; if ( border == null ) insets = new Insets ( 0 , 0 , 0 , 0 ) ; else { insets = getBorder ( ) . getBorderInsets ( JEditTextArea . this ) ; } dim . width = insets . left + insets . right ; dim . height = insets . top + insets . bottom ; Dimension leftPref = left . getPreferredSize ( ) ; dim . width += leftPref . width ; Dimension centerPref = center . getPreferredSize ( ) ; dim . width += centerPref . width ; dim . height += centerPref . height ; Dimension rightPref = right . getPreferredSize ( ) ; dim . width += rightPref . width ; Dimension bottomPref = bottom . getPreferredSize ( ) ; dim . height += bottomPref . height ; return dim ; } public Dimension minimumLayoutSize ( Container parent ) { Dimension dim = new Dimension ( ) ; Border border = getBorder ( ) ; Insets insets ; if ( border == null ) insets = new Insets ( 0 , 0 , 0 , 0 ) ; else { insets = getBorder ( ) . getBorderInsets ( JEditTextArea . this ) ; } dim . width = insets . left + insets . right ; dim . height = insets . top + insets . bottom ; Dimension leftPref = left . getMinimumSize ( ) ; dim . width += leftPref . width ; Dimension centerPref = center . getMinimumSize ( ) ; dim . width += centerPref . width ; dim . height += centerPref . height ; Dimension rightPref = right . getMinimumSize ( ) ; dim . width += rightPref . width ; Dimension bottomPref = bottom . getMinimumSize ( ) ; dim . height += bottomPref . height ; return dim ; } public void layoutContainer ( Container parent ) { Dimension size = parent . getSize ( ) ; Border border = getBorder ( ) ; Insets insets ; if ( border == null ) insets = new Insets ( 0 , 0 , 0 , 0 ) ; else { insets = getBorder ( ) . getBorderInsets ( JEditTextArea . this ) ; } int itop = insets . top ; int ileft = insets . left ; int ibottom = insets . bottom ; int iright = insets . right ; int rightWidth = right . getPreferredSize ( ) . width ; int leftWidth = left . getPreferredSize ( ) . width ; int bottomHeight = bottom . getPreferredSize ( ) . height ; int centerWidth = Math . max ( 0 , size . width - leftWidth - rightWidth - ileft - iright ) ; int centerHeight = Math . max ( 0 , size . height - bottomHeight - itop - ibottom ) ; left . setBounds ( ileft , itop , leftWidth , centerHeight ) ; center . setBounds ( ileft + leftWidth , itop , centerWidth , centerHeight ) ; right . setBounds ( ileft + leftWidth + centerWidth , itop , rightWidth , centerHeight ) ; bottom . setBounds ( ileft , itop + centerHeight , Math . max ( 0 , size . width - rightWidth - ileft - iright ) , bottomHeight ) ; } Component center ; Component left ; Component right ; Component bottom ; } static class CaretBlinker implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( focusedComponent != null && focusedComponent . hasFocus ( ) ) focusedComponent . blinkCaret ( ) ; } } class MutableCaretEvent extends CaretEvent { MutableCaretEvent ( ) { super ( JEditTextArea . this ) ; } public int getDot ( ) { return getCaretPosition ( ) ; } public int getMark ( ) { return getMarkPosition ( ) ; } } class AdjustHandler implements AdjustmentListener { public void adjustmentValueChanged ( final AdjustmentEvent evt ) { if ( ! scrollBarsInitialized ) return ; if ( evt . getAdjustable ( ) == vertical ) setFirstLine ( vertical . getValue ( ) ) ; else setHorizontalOffset ( - horizontal . getValue ( ) ) ; } } class ComponentHandler extends ComponentAdapter { public void componentResized ( ComponentEvent evt ) { recalculateVisibleLines ( ) ; scrollBarsInitialized = true ; } } class DocumentHandler implements DocumentListener { public void insertUpdate ( DocumentEvent evt ) { if ( ! buffer . isLoaded ( ) ) return ; documentChanged ( evt ) ; int offset = evt . getOffset ( ) ; int length = evt . getLength ( ) ; if ( caret >= offset ) moveCaretPosition ( caret + length , true ) ; else updateBracketHighlight ( ) ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; boolean changed = false ; if ( s . start >= offset ) { s . start += length ; s . startLine = getLineOfOffset ( s . start ) ; changed = true ; } if ( s . end >= offset ) { s . end += length ; s . endLine = getLineOfOffset ( s . end ) ; changed = true ; } if ( changed ) invalidateLineRange ( s . startLine , s . endLine ) ; } } public void removeUpdate ( DocumentEvent evt ) { if ( ! buffer . isLoaded ( ) ) return ; documentChanged ( evt ) ; int offset = evt . getOffset ( ) ; int length = evt . getLength ( ) ; int end = offset + length ; boolean caretEvent = false ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; boolean changed = false ; if ( s . start > offset && s . start <= end ) { s . start = offset ; changed = caretEvent = true ; } else if ( s . start > end ) { s . start -= length ; changed = caretEvent = true ; } if ( s . end > offset && s . end <= end ) { s . end = offset ; changed = caretEvent = true ; } else if ( s . end > end ) { s . end -= length ; changed = caretEvent = true ; } if ( s . start == s . end ) { selection . removeElement ( s ) ; invalidateLineRange ( s . startLine , s . endLine ) ; i -- ; } else if ( changed ) { s . startLine = getLineOfOffset ( s . start ) ; s . endLine = getLineOfOffset ( s . end ) ; invalidateLineRange ( s . startLine , s . endLine ) ; } } if ( caret > offset && caret <= end ) moveCaretPosition ( offset , false ) ; else if ( caret > end ) moveCaretPosition ( caret - length , false ) ; else { updateBracketHighlight ( ) ; if ( caretEvent ) fireCaretEvent ( ) ; } } public void changedUpdate ( DocumentEvent evt ) { } } class FoldHandler implements Buffer . FoldListener { public void foldLevelsChanged ( int firstLine , int lastLine ) { invalidateLineRange ( firstLine , lastLine ) ; } public void foldStructureChanged ( ) { setFirstLine ( buffer . physicalToVirtual ( physFirstLine ) ) ; updateScrollBars ( ) ; gutter . repaint ( ) ; if ( view . getTextArea ( ) == JEditTextArea . this ) view . getStatus ( ) . updateFoldStatus ( ) ; } } class FocusHandler implements FocusListener { public void focusGained ( FocusEvent evt ) { invalidateLine ( caretLine ) ; view . updateGutterBorders ( ) ; } public void focusLost ( FocusEvent evt ) { invalidateLine ( caretLine ) ; } } class MouseHandler extends MouseAdapter implements MouseMotionListener { private int dragStartLine ; private int dragStartOffset ; private int dragStart ; private int clickCount ; public void mousePressed ( MouseEvent evt ) { buffer . endCompoundEdit ( ) ; grabFocus ( ) ; if ( GUIUtilities . isPopupTrigger ( evt ) && popup != null ) { if ( popup . isVisible ( ) ) popup . setVisible ( false ) ; else popup . show ( painter , evt . getX ( ) + 1 , evt . getY ( ) + 1 ) ; return ; } blink = true ; invalidateLine ( caretLine ) ; int x = evt . getX ( ) ; int y = evt . getY ( ) ; dragStartLine = buffer . virtualToPhysical ( yToLine ( y ) ) ; dragStartOffset = xToOffset ( dragStartLine , x ) ; dragStart = xyToOffset ( x , y , ! painter . isBlockCaretEnabled ( ) ) ; clickCount = evt . getClickCount ( ) ; switch ( clickCount ) { case 1 : doSingleClick ( evt ) ; break ; case 2 : try { doDoubleClick ( evt ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } break ; default : doTripleClick ( evt ) ; break ; } } public void mouseReleased ( MouseEvent evt ) { if ( getSelectionCount ( ) != 0 ) Registers . setRegister ( '%' , getSelectedText ( ) ) ; } private void doSingleClick ( MouseEvent evt ) { if ( evt . isShiftDown ( ) ) { resizeSelection ( getMarkPosition ( ) , dragStart , evt . isControlDown ( ) ) ; moveCaretPosition ( dragStart , false ) ; dragStartLine = getMarkLine ( ) ; dragStart = getMarkPosition ( ) ; dragStartOffset = dragStart - getLineStartOffset ( dragStartLine ) ; } else { if ( ! multi ) selectNone ( ) ; moveCaretPosition ( dragStart , false ) ; if ( middleMousePaste && ( evt . getModifiers ( ) & InputEvent . BUTTON2_MASK ) != 0 ) { if ( ! isEditable ( ) ) getToolkit ( ) . beep ( ) ; else Registers . paste ( JEditTextArea . this , '%' ) ; } } } private void doDoubleClick ( MouseEvent evt ) throws BadLocationException { if ( getLineLength ( dragStartLine ) == 0 ) return ; try { int bracket = TextUtilities . findMatchingBracket ( buffer , dragStartLine , Math . max ( 0 , dragStartOffset - 1 ) ) ; if ( bracket != - 1 ) { if ( bracket < caret ) { addToSelection ( new Selection . Range ( bracket , caret ) ) ; } else { addToSelection ( new Selection . Range ( caret - 1 , ++ bracket ) ) ; } moveCaretPosition ( bracket , false ) ; return ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } String lineText = getLineText ( dragStartLine ) ; String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; if ( dragStartOffset == getLineLength ( dragStartLine ) ) dragStartOffset -- ; int wordStart = TextUtilities . findWordStart ( lineText , dragStartOffset , noWordSep ) ; int wordEnd = TextUtilities . findWordEnd ( lineText , dragStartOffset + 1 , noWordSep ) ; int lineStart = getLineStartOffset ( dragStartLine ) ; addToSelection ( new Selection . Range ( lineStart + wordStart , lineStart + wordEnd ) ) ; moveCaretPosition ( lineStart + wordEnd , false ) ; } private void doTripleClick ( MouseEvent evt ) { int newCaret = getLineEndOffset ( dragStartLine ) ; addToSelection ( new Selection . Range ( getLineStartOffset ( dragStartLine ) , newCaret ) ) ; moveCaretPosition ( newCaret ) ; } public void mouseDragged ( MouseEvent evt ) { if ( GUIUtilities . isPopupTrigger ( evt ) || ( popup != null && popup . isVisible ( ) ) ) return ; boolean rect = evt . isControlDown ( ) ; switch ( clickCount ) { case 1 : doSingleDrag ( evt , rect ) ; break ; case 2 : doDoubleDrag ( evt , rect ) ; break ; default : doTripleDrag ( evt , rect ) ; break ; } } public void mouseMoved ( MouseEvent evt ) { } private void doSingleDrag ( MouseEvent evt , boolean rect ) { int dot = xyToOffset ( evt . getX ( ) , evt . getY ( ) , ! painter . isBlockCaretEnabled ( ) ) ; if ( dot == caret ) return ; resizeSelection ( dragStart , dot , rect ) ; moveCaretPosition ( dot , false ) ; } private void doDoubleDrag ( MouseEvent evt , boolean rect ) { int markLineStart = getLineStartOffset ( dragStartLine ) ; int markLineLength = getLineLength ( dragStartLine ) ; int mark = dragStartOffset ; int line = buffer . virtualToPhysical ( yToLine ( evt . getY ( ) ) ) ; int lineStart = getLineStartOffset ( line ) ; int lineLength = getLineLength ( line ) ; int offset = xToOffset ( line , evt . getX ( ) ) ; String lineText = getLineText ( line ) ; String markLineText = getLineText ( dragStartLine ) ; String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; if ( markLineStart + dragStartOffset > lineStart + offset ) { if ( offset != 0 && offset != lineLength ) { offset = TextUtilities . findWordStart ( lineText , offset , noWordSep ) ; } if ( markLineLength != 0 ) { mark = TextUtilities . findWordEnd ( markLineText , mark , noWordSep ) ; } } else { if ( offset != 0 && lineLength != 0 ) { offset = TextUtilities . findWordEnd ( lineText , offset , noWordSep ) ; } if ( mark != 0 && mark != markLineLength ) { mark = TextUtilities . findWordStart ( markLineText , mark , noWordSep ) ; } } if ( lineStart + offset == caret ) return ; resizeSelection ( markLineStart + mark , lineStart + offset , rect ) ; moveCaretPosition ( lineStart + offset , false ) ; } private void doTripleDrag ( MouseEvent evt , boolean rect ) { int mouseLine = buffer . virtualToPhysical ( yToLine ( evt . getY ( ) ) ) ; int offset = xToOffset ( mouseLine , evt . getX ( ) ) ; int mark ; int mouse ; if ( dragStartLine > mouseLine ) { mark = getLineEndOffset ( dragStartLine ) - 1 ; if ( offset == getLineLength ( mouseLine ) ) mouse = getLineEndOffset ( mouseLine ) - 1 ; else mouse = getLineStartOffset ( mouseLine ) ; } else { mark = getLineStartOffset ( dragStartLine ) ; if ( offset == 0 ) mouse = getLineStartOffset ( mouseLine ) ; else mouse = getLineEndOffset ( mouseLine ) - 1 ; } if ( mouse == caret ) return ; resizeSelection ( mark , mouse , rect ) ; moveCaretPosition ( mouse , false ) ; } } static class CaretUndo extends AbstractUndoableEdit { private int caret ; CaretUndo ( int caret ) { this . caret = caret ; } public boolean isSignificant ( ) { return false ; } public String getPresentationName ( ) { return "caret move" ; } public void undo ( ) throws CannotUndoException { super . undo ( ) ; if ( focusedComponent != null ) { int length = focusedComponent . getBuffer ( ) . getLength ( ) ; if ( caret <= length ) { focusedComponent . selectNone ( ) ; focusedComponent . setCaretPosition ( caret ) ; } else Log . log ( Log . WARNING , this , caret + " > " + length + "??!!" ) ; } } public boolean addEdit ( UndoableEdit edit ) { if ( edit instanceof CaretUndo ) { edit . die ( ) ; return true ; } else return false ; } public String toString ( ) { return getPresentationName ( ) + "[caret=" + caret + "]" ; } } static { caretTimer = new Timer ( 500 , new CaretBlinker ( ) ) ; caretTimer . setInitialDelay ( 500 ) ; caretTimer . start ( ) ; } } 	1	['211', '4', '0', '59', '430', '11469', '40', '39', '169', '0.883277962', '7612', '0.906976744', '10', '0.755555556', '0.084391534', '3', '9', '34.87203791', '25', '3.0521', '45']
package org . gjt . sp . jedit ; import gnu . regexp . REException ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . io . File ; import java . net . * ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . browser . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . VFS ; import org . gjt . sp . jedit . msg . PropertiesChanged ; import org . gjt . sp . jedit . syntax . SyntaxStyle ; import org . gjt . sp . jedit . syntax . Token ; import org . gjt . sp . util . Log ; public class GUIUtilities { public static final Icon NEW_BUFFER_ICON ; public static final Icon DIRTY_BUFFER_ICON ; public static final Icon READ_ONLY_BUFFER_ICON ; public static final Icon NORMAL_BUFFER_ICON ; public static final Icon EDITOR_WINDOW_ICON ; public static final Icon PLUGIN_WINDOW_ICON ; public static JMenuBar loadMenuBar ( String name ) { String menus = jEdit . getProperty ( name ) ; StringTokenizer st = new StringTokenizer ( menus ) ; JMenuBar mbar = new JMenuBar ( ) ; while ( st . hasMoreTokens ( ) ) mbar . add ( GUIUtilities . loadMenu ( st . nextToken ( ) ) ) ; return mbar ; } public static JMenu loadMenu ( String name ) { if ( name . equals ( "open-encoding" ) ) return new OpenWithEncodingMenu ( ) ; else if ( name . equals ( "recent-files" ) ) return new RecentFilesMenu ( ) ; else if ( name . equals ( "current-directory" ) ) return new CurrentDirectoryMenu ( ) ; else if ( name . equals ( "markers" ) ) return new MarkersMenu ( ) ; else if ( name . equals ( "macros" ) ) return new MacrosMenu ( ) ; else if ( name . equals ( "plugins" ) ) return new PluginsMenu ( ) ; else return new EnhancedMenu ( name ) ; } public static JPopupMenu loadPopupMenu ( String name ) { JPopupMenu menu = new JPopupMenu ( ) ; String menuItems = jEdit . getProperty ( name ) ; if ( menuItems != null ) { StringTokenizer st = new StringTokenizer ( menuItems ) ; while ( st . hasMoreTokens ( ) ) { String menuItemName = st . nextToken ( ) ; if ( menuItemName . equals ( "-" ) ) menu . addSeparator ( ) ; else { if ( menuItemName . startsWith ( "%" ) ) menu . add ( loadMenu ( menuItemName . substring ( 1 ) ) ) ; else menu . add ( loadMenuItem ( menuItemName , false ) ) ; } } } return menu ; } public static JMenuItem loadMenuItem ( String name ) { return loadMenuItem ( name , true ) ; } public static JMenuItem loadMenuItem ( String name , boolean setMnemonic ) { String label ; EditAction action ; if ( name . startsWith ( "play-macro@" ) ) { Macros . Macro macro = Macros . getMacro ( name . substring ( 11 ) ) ; if ( macro != null ) { label = macro . name ; int index = label . lastIndexOf ( '/' ) ; label = label . substring ( index + 1 ) . replace ( '_' , ' ' ) ; action = macro . action ; } else { label = name . substring ( 11 ) ; action = null ; } } else { action = jEdit . getAction ( name ) ; label = jEdit . getProperty ( name . concat ( ".label" ) ) ; if ( label == null ) label = name ; } char mnemonic ; int index = label . indexOf ( '$' ) ; if ( index != - 1 && label . length ( ) - index > 1 ) { mnemonic = Character . toLowerCase ( label . charAt ( index + 1 ) ) ; label = label . substring ( 0 , index ) . concat ( label . substring ( ++ index ) ) ; } else mnemonic = '\0' ; JMenuItem mi ; if ( action != null && action . isToggle ( ) ) mi = new EnhancedCheckBoxMenuItem ( label , action ) ; else mi = new EnhancedMenuItem ( label , action ) ; if ( setMnemonic && mnemonic != '\0' ) mi . setMnemonic ( mnemonic ) ; return mi ; } public static JToolBar loadToolBar ( String name ) { JToolBar toolBar = new JToolBar ( ) ; toolBar . setFloatable ( false ) ; toolBar . putClientProperty ( "JToolBar.isRollover" , Boolean . TRUE ) ; String buttons = jEdit . getProperty ( name ) ; if ( buttons != null ) { StringTokenizer st = new StringTokenizer ( buttons ) ; while ( st . hasMoreTokens ( ) ) { String button = st . nextToken ( ) ; if ( button . equals ( "-" ) ) toolBar . addSeparator ( ) ; else { JButton b = loadToolButton ( button ) ; if ( b != null ) toolBar . add ( b ) ; } } } return toolBar ; } public static EnhancedButton loadToolButton ( String name ) { String label ; EditAction action ; if ( name . startsWith ( "play-macro@" ) ) { Macros . Macro macro = Macros . getMacro ( name . substring ( 11 ) ) ; if ( macro != null ) { label = macro . name ; int index = label . lastIndexOf ( '/' ) ; label = label . substring ( index + 1 ) . replace ( '_' , ' ' ) ; action = macro . action ; } else { label = name . substring ( 11 ) ; action = null ; } } else { action = jEdit . getAction ( name ) ; label = jEdit . getProperty ( name . concat ( ".label" ) ) ; if ( label == null ) label = name ; else label = prettifyMenuLabel ( label ) ; } Icon icon ; String iconName = jEdit . getProperty ( name + ".icon" ) ; if ( iconName != null ) { icon = loadIcon ( iconName ) ; if ( icon == null ) return null ; } else return null ; String toolTip = label ; String shortcut = jEdit . getProperty ( name + ".shortcut" ) ; if ( shortcut != null ) toolTip = toolTip + " (" + shortcut + ")" ; return new EnhancedButton ( icon , toolTip , action ) ; } public static Icon loadIcon ( String iconName ) { Icon icon = ( Icon ) icons . get ( iconName ) ; if ( icon != null ) return icon ; if ( iconName . startsWith ( "file:" ) ) { icon = new ImageIcon ( iconName . substring ( 5 ) ) ; } else { URL url = GUIUtilities . class . getResource ( "/org/gjt/sp/jedit/icons/" + iconName ) ; if ( url == null ) { Log . log ( Log . ERROR , GUIUtilities . class , "Icon not found: " + iconName ) ; return null ; } icon = new ImageIcon ( url ) ; } icons . put ( iconName , icon ) ; return icon ; } public static String prettifyMenuLabel ( String label ) { int index = label . indexOf ( '$' ) ; if ( index != - 1 ) { label = label . substring ( 0 , index ) . concat ( label . substring ( index + 1 ) ) ; } return label ; } public static void message ( Component comp , String name , Object [ ] args ) { hideSplashScreen ( ) ; JOptionPane . showMessageDialog ( comp , jEdit . getProperty ( name . concat ( ".message" ) , args ) , jEdit . getProperty ( name . concat ( ".title" ) , args ) , JOptionPane . INFORMATION_MESSAGE ) ; } public static void error ( Component comp , String name , Object [ ] args ) { hideSplashScreen ( ) ; JOptionPane . showMessageDialog ( comp , jEdit . getProperty ( name . concat ( ".message" ) , args ) , jEdit . getProperty ( name . concat ( ".title" ) , args ) , JOptionPane . ERROR_MESSAGE ) ; } public static String input ( Component comp , String name , Object def ) { return input ( comp , name , null , def ) ; } public static String inputProperty ( Component comp , String name , String def ) { return inputProperty ( comp , name , null , def ) ; } public static String input ( Component comp , String name , Object [ ] args , Object def ) { hideSplashScreen ( ) ; String retVal = ( String ) JOptionPane . showInputDialog ( comp , jEdit . getProperty ( name . concat ( ".message" ) , args ) , jEdit . getProperty ( name . concat ( ".title" ) ) , JOptionPane . QUESTION_MESSAGE , null , null , def ) ; return retVal ; } public static String inputProperty ( Component comp , String name , Object [ ] args , String def ) { hideSplashScreen ( ) ; String retVal = ( String ) JOptionPane . showInputDialog ( comp , jEdit . getProperty ( name . concat ( ".message" ) , args ) , jEdit . getProperty ( name . concat ( ".title" ) ) , JOptionPane . QUESTION_MESSAGE , null , null , jEdit . getProperty ( def ) ) ; if ( retVal != null ) jEdit . setProperty ( def , retVal ) ; return retVal ; } public static int confirm ( Component comp , String name , Object [ ] args , int buttons , int type ) { hideSplashScreen ( ) ; return JOptionPane . showConfirmDialog ( comp , jEdit . getProperty ( name + ".message" , args ) , jEdit . getProperty ( name + ".title" ) , buttons , type ) ; } public static String [ ] showVFSFileDialog ( View view , String path , int type , boolean multipleSelection ) { VFSFileChooserDialog fileChooser = new VFSFileChooserDialog ( view , path , type , multipleSelection ) ; String [ ] selectedFiles = fileChooser . getSelectedFiles ( ) ; if ( selectedFiles == null ) return null ; return selectedFiles ; } public static Color parseColor ( String name ) { return parseColor ( name , Color . black ) ; } public static Color parseColor ( String name , Color defaultColor ) { if ( name == null ) return defaultColor ; else if ( name . startsWith ( "#" ) ) { try { return Color . decode ( name ) ; } catch ( NumberFormatException nf ) { return defaultColor ; } } else if ( "red" . equals ( name ) ) return Color . red ; else if ( "green" . equals ( name ) ) return Color . green ; else if ( "blue" . equals ( name ) ) return Color . blue ; else if ( "yellow" . equals ( name ) ) return Color . yellow ; else if ( "orange" . equals ( name ) ) return Color . orange ; else if ( "white" . equals ( name ) ) return Color . white ; else if ( "lightGray" . equals ( name ) ) return Color . lightGray ; else if ( "gray" . equals ( name ) ) return Color . gray ; else if ( "darkGray" . equals ( name ) ) return Color . darkGray ; else if ( "black" . equals ( name ) ) return Color . black ; else if ( "cyan" . equals ( name ) ) return Color . cyan ; else if ( "magenta" . equals ( name ) ) return Color . magenta ; else if ( "pink" . equals ( name ) ) return Color . pink ; else return defaultColor ; } public static String getColorHexString ( Color c ) { String colString = Integer . toHexString ( c . getRGB ( ) & 0xffffff ) ; return "#000000" . substring ( 0 , 7 - colString . length ( ) ) . concat ( colString ) ; } public static SyntaxStyle parseStyle ( String str , String family , int size ) throws IllegalArgumentException { Color fgColor = Color . black ; Color bgColor = null ; boolean italic = false ; boolean bold = false ; StringTokenizer st = new StringTokenizer ( str ) ; while ( st . hasMoreTokens ( ) ) { String s = st . nextToken ( ) ; if ( s . startsWith ( "color:" ) ) { fgColor = GUIUtilities . parseColor ( s . substring ( 6 ) , Color . black ) ; } else if ( s . startsWith ( "bgColor:" ) ) { bgColor = GUIUtilities . parseColor ( s . substring ( 8 ) , null ) ; } else if ( s . startsWith ( "style:" ) ) { for ( int i = 6 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == 'i' ) italic = true ; else if ( s . charAt ( i ) == 'b' ) bold = true ; else throw new IllegalArgumentException ( "Invalid style: " + s ) ; } } else throw new IllegalArgumentException ( "Invalid directive: " + s ) ; } return new SyntaxStyle ( fgColor , bgColor , new Font ( family , ( italic ? Font . ITALIC : 0 ) | ( bold ? Font . BOLD : 0 ) , size ) ) ; } public static String getStyleString ( SyntaxStyle style ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "color:" + getColorHexString ( style . getForegroundColor ( ) ) ) ; if ( style . getBackgroundColor ( ) != null ) { buf . append ( " bgColor:" + getColorHexString ( style . getBackgroundColor ( ) ) ) ; } if ( ! style . getFont ( ) . isPlain ( ) ) { buf . append ( " style:" + ( style . getFont ( ) . isItalic ( ) ? "i" : "" ) + ( style . getFont ( ) . isBold ( ) ? "b" : "" ) ) ; } return buf . toString ( ) ; } public static SyntaxStyle [ ] loadStyles ( String family , int size ) { SyntaxStyle [ ] styles = new SyntaxStyle [ Token . ID_COUNT ] ; try { styles [ Token . COMMENT1 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.comment1" ) , family , size ) ; styles [ Token . COMMENT2 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.comment2" ) , family , size ) ; styles [ Token . LITERAL1 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.literal1" ) , family , size ) ; styles [ Token . LITERAL2 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.literal2" ) , family , size ) ; styles [ Token . LABEL ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.label" ) , family , size ) ; styles [ Token . KEYWORD1 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.keyword1" ) , family , size ) ; styles [ Token . KEYWORD2 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.keyword2" ) , family , size ) ; styles [ Token . KEYWORD3 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.keyword3" ) , family , size ) ; styles [ Token . FUNCTION ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.function" ) , family , size ) ; styles [ Token . MARKUP ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.markup" ) , family , size ) ; styles [ Token . OPERATOR ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.operator" ) , family , size ) ; styles [ Token . DIGIT ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.digit" ) , family , size ) ; styles [ Token . INVALID ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.invalid" ) , family , size ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , GUIUtilities . class , e ) ; } return styles ; } public static void loadGeometry ( Window win , String name ) { int x , y , width , height , adjust_x , adjust_y , adjust_width , adjust_height ; try { width = Integer . parseInt ( jEdit . getProperty ( name + ".width" ) ) ; height = Integer . parseInt ( jEdit . getProperty ( name + ".height" ) ) ; } catch ( NumberFormatException nf ) { Dimension size = win . getSize ( ) ; width = size . width ; height = size . height ; } try { x = Integer . parseInt ( jEdit . getProperty ( name + ".x" ) ) ; y = Integer . parseInt ( jEdit . getProperty ( name + ".y" ) ) ; } catch ( NumberFormatException nf ) { Component parent = win . getParent ( ) ; if ( parent == null ) { Dimension screen = win . getToolkit ( ) . getScreenSize ( ) ; x = ( screen . width - width ) / 2 ; y = ( screen . height - height ) / 2 ; } else { Rectangle bounds = parent . getBounds ( ) ; x = bounds . x + ( bounds . width - width ) / 2 ; y = bounds . y + ( bounds . height - height ) / 2 ; } } try { adjust_x = Integer . parseInt ( jEdit . getProperty ( name + ".dx" ) ) ; adjust_y = Integer . parseInt ( jEdit . getProperty ( name + ".dy" ) ) ; adjust_width = Integer . parseInt ( jEdit . getProperty ( name + ".d-width" ) ) ; adjust_height = Integer . parseInt ( jEdit . getProperty ( name + ".d-height" ) ) ; } catch ( NumberFormatException nf ) { adjust_x = adjust_y = 0 ; adjust_width = adjust_height = 0 ; } Rectangle desired = new Rectangle ( x , y , width , height ) ; Rectangle required = new Rectangle ( x - adjust_x , y - adjust_y , width - adjust_width , height - adjust_height ) ; win . setBounds ( required ) ; if ( File . separatorChar == '/' && System . getProperty ( "java.version" ) . compareTo ( "1.2" ) < 0 ) { win . setBounds ( required ) ; new UnixWorkaround ( win , name , desired , required ) ; } else win . setBounds ( desired ) ; } static class UnixWorkaround { Window win ; String name ; Rectangle desired ; Rectangle required ; long start ; boolean windowOpened ; UnixWorkaround ( Window win , String name , Rectangle desired , Rectangle required ) { this . win = win ; this . name = name ; this . desired = desired ; this . required = required ; start = System . currentTimeMillis ( ) ; win . addComponentListener ( new ComponentHandler ( ) ) ; win . addWindowListener ( new WindowHandler ( ) ) ; } class ComponentHandler extends ComponentAdapter { public void componentMoved ( ComponentEvent evt ) { if ( System . currentTimeMillis ( ) - start < 1000 ) { Rectangle r = win . getBounds ( ) ; if ( ! windowOpened && r . equals ( required ) ) return ; if ( ! r . equals ( desired ) ) { win . setBounds ( desired ) ; } } else win . removeComponentListener ( this ) ; } public void componentResized ( ComponentEvent evt ) { if ( System . currentTimeMillis ( ) - start < 1000 ) { Rectangle r = win . getBounds ( ) ; if ( ! windowOpened && r . equals ( required ) ) return ; if ( ! r . equals ( desired ) ) { win . setBounds ( desired ) ; } } else win . removeComponentListener ( this ) ; } } class WindowHandler extends WindowAdapter { public void windowOpened ( WindowEvent evt ) { windowOpened = true ; Rectangle r = win . getBounds ( ) ; if ( r . x != desired . x || r . y != desired . y || r . width != desired . width || r . height != desired . height ) { jEdit . setProperty ( name + ".dx" , String . valueOf ( r . x - required . x ) ) ; jEdit . setProperty ( name + ".dy" , String . valueOf ( r . y - required . y ) ) ; jEdit . setProperty ( name + ".d-width" , String . valueOf ( r . width - required . width ) ) ; jEdit . setProperty ( name + ".d-height" , String . valueOf ( r . height - required . height ) ) ; } win . removeWindowListener ( this ) ; } } } public static void saveGeometry ( Window win , String name ) { Rectangle bounds = win . getBounds ( ) ; jEdit . setProperty ( name + ".x" , String . valueOf ( bounds . x ) ) ; jEdit . setProperty ( name + ".y" , String . valueOf ( bounds . y ) ) ; jEdit . setProperty ( name + ".width" , String . valueOf ( bounds . width ) ) ; jEdit . setProperty ( name + ".height" , String . valueOf ( bounds . height ) ) ; } public static void hideSplashScreen ( ) { if ( splash != null ) { splash . dispose ( ) ; splash = null ; } } public static Image getEditorIcon ( ) { return ( ( ImageIcon ) EDITOR_WINDOW_ICON ) . getImage ( ) ; } public static Image getPluginIcon ( ) { return ( ( ImageIcon ) PLUGIN_WINDOW_ICON ) . getImage ( ) ; } public static void requestFocus ( final Window win , final Component comp ) { win . addWindowListener ( new WindowAdapter ( ) { public void windowActivated ( WindowEvent evt ) { comp . requestFocus ( ) ; win . removeWindowListener ( this ) ; } } ) ; } public static boolean isPopupTrigger ( MouseEvent evt ) { if ( macOS ) return evt . isControlDown ( ) ; else return ( ( evt . getModifiers ( ) & InputEvent . BUTTON3_MASK ) != 0 ) ; } public static JMenu loadMenu ( View view , String name ) { return loadMenu ( name ) ; } public static JMenuItem loadMenuItem ( View view , String name ) { return loadMenuItem ( name , true ) ; } public static Icon loadToolBarIcon ( String iconName ) { return loadIcon ( iconName ) ; } public static String showFileDialog ( View view , String file , int type ) { if ( file == null ) file = System . getProperty ( "user.dir" ) ; File _file = new File ( file ) ; JFileChooser chooser = new JFileChooser ( ) ; chooser . setCurrentDirectory ( _file ) ; if ( _file . isDirectory ( ) ) chooser . setSelectedFile ( null ) ; else chooser . setSelectedFile ( _file ) ; chooser . setDialogType ( type ) ; chooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ; int retVal = chooser . showDialog ( view , null ) ; if ( retVal == JFileChooser . APPROVE_OPTION ) { File selectedFile = chooser . getSelectedFile ( ) ; if ( selectedFile != null ) return selectedFile . getAbsolutePath ( ) ; } return null ; } static void showSplashScreen ( ) { splash = new SplashScreen ( ) ; } static void advanceSplashProgress ( ) { if ( splash != null ) splash . advance ( ) ; } private static SplashScreen splash ; private static boolean macOS ; private static Hashtable icons ; private GUIUtilities ( ) { } static { macOS = ( System . getProperty ( "os.name" ) . indexOf ( "MacOS" ) != - 1 ) ; icons = new Hashtable ( ) ; NEW_BUFFER_ICON = loadIcon ( "new.gif" ) ; DIRTY_BUFFER_ICON = loadIcon ( "dirty.gif" ) ; READ_ONLY_BUFFER_ICON = loadIcon ( "readonly.gif" ) ; NORMAL_BUFFER_ICON = loadIcon ( "normal.gif" ) ; EDITOR_WINDOW_ICON = loadIcon ( "jedit_icon1.gif" ) ; PLUGIN_WINDOW_ICON = loadIcon ( "jedit_icon2.gif" ) ; } } 	1	['39', '1', '0', '70', '144', '725', '58', '21', '34', '0.955263158', '1492', '0.4', '1', '0', '0.135964912', '0', '0', '37', '16', '2.6923', '8']
package org . gjt . sp . jedit . gui ; import java . awt . event . * ; import java . awt . * ; public class KeyEventWorkaround { public static final int ALT_GRAPH_MASK = 1 << 5 ; public static KeyEvent processKeyEvent ( KeyEvent evt ) { int keyCode = evt . getKeyCode ( ) ; char ch = evt . getKeyChar ( ) ; switch ( evt . getID ( ) ) { case KeyEvent . KEY_PRESSED : if ( keyCode == KeyEvent . VK_CONTROL || keyCode == KeyEvent . VK_SHIFT || keyCode == KeyEvent . VK_ALT || keyCode == KeyEvent . VK_META || keyCode == '\0' ) return null ; if ( ! java14 ) handleBrokenKeys ( evt . getModifiers ( ) , keyCode ) ; return evt ; case KeyEvent . KEY_TYPED : if ( ( ch < 0x20 || ch == 0x7f || ch == 0xff ) && ch != '\b' ) return null ; if ( ( evt . isControlDown ( ) ^ evt . isAltDown ( ) ) || evt . isMetaDown ( ) ) return null ; if ( ! java14 ) { if ( last == LAST_BROKEN && System . currentTimeMillis ( ) - lastKeyTime < 750 && ! Character . isLetter ( ch ) ) { last = LAST_NOTHING ; return null ; } else if ( last == LAST_ALT && System . currentTimeMillis ( ) - lastKeyTime < 750 ) { last = LAST_NOTHING ; return null ; } } return evt ; default : return evt ; } } private static boolean java14 ; private static long lastKeyTime ; private static int last ; private static final int LAST_NOTHING = 0 ; private static final int LAST_ALTGR = 1 ; private static final int LAST_ALT = 2 ; private static final int LAST_BROKEN = 3 ; static { java14 = ( System . getProperty ( "java.version" ) . compareTo ( "1.4" ) >= 0 ) ; } private static void handleBrokenKeys ( int modifiers , int keyCode ) { if ( modifiers == ( KeyEvent . ALT_MASK | KeyEvent . CTRL_MASK ) || modifiers == ( KeyEvent . ALT_MASK | KeyEvent . CTRL_MASK | KeyEvent . SHIFT_MASK ) ) { last = LAST_ALTGR ; return ; } else if ( ( modifiers & ( ~ ( ALT_GRAPH_MASK | KeyEvent . SHIFT_MASK ) ) ) == 0 ) { last = LAST_NOTHING ; return ; } if ( ( modifiers & KeyEvent . ALT_MASK ) != 0 ) last = LAST_ALT ; else if ( ( keyCode < KeyEvent . VK_A || keyCode > KeyEvent . VK_Z ) && keyCode != KeyEvent . VK_LEFT && keyCode != KeyEvent . VK_RIGHT && keyCode != KeyEvent . VK_UP && keyCode != KeyEvent . VK_DOWN && keyCode != KeyEvent . VK_DELETE && keyCode != KeyEvent . VK_BACK_SPACE && keyCode != KeyEvent . VK_TAB && keyCode != KeyEvent . VK_ENTER ) last = LAST_BROKEN ; else last = LAST_NOTHING ; lastKeyTime = System . currentTimeMillis ( ) ; } } 	1	['4', '1', '0', '5', '16', '2', '5', '0', '2', '1.083333333', '179', '0.875', '0', '0', '0.333333333', '0', '0', '41.75', '20', '8.75', '5']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import java . awt . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; public class PastePrevious extends EnhancedDialog implements ActionListener , ListSelectionListener , MouseListener { public PastePrevious ( View view ) { super ( view , jEdit . getProperty ( "pasteprev.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; clipHistory = HistoryModel . getModel ( "clipboard" ) ; clips = new JList ( new AbstractListModel ( ) { public int getSize ( ) { return clipHistory . getSize ( ) ; } public Object getElementAt ( int index ) { return clipHistory . getItem ( index ) ; } } ) ; clips . setVisibleRowCount ( 16 ) ; clips . addMouseListener ( this ) ; clips . addListSelectionListener ( this ) ; insert = new JButton ( jEdit . getProperty ( "pasteprev.insert" ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "pasteprev.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , label ) ; JScrollPane scroller = new JScrollPane ( clips ) ; Dimension dim = scroller . getPreferredSize ( ) ; scroller . setPreferredSize ( new Dimension ( 640 , dim . height ) ) ; content . add ( scroller , BorderLayout . CENTER ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( insert ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; panel . add ( cancel ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( panel , BorderLayout . SOUTH ) ; updateButtons ( ) ; getRootPane ( ) . setDefaultButton ( insert ) ; insert . addActionListener ( this ) ; cancel . addActionListener ( this ) ; GUIUtilities . requestFocus ( this , clips ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { int selected = clips . getSelectedIndex ( ) ; if ( selected == - 1 ) { view . getToolkit ( ) . beep ( ) ; return ; } String clip = clipHistory . getItem ( selected ) ; view . getTextArea ( ) . setSelectedText ( clip ) ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == insert ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; } public void mouseClicked ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) ok ( ) ; } public void mouseEntered ( MouseEvent evt ) { } public void mouseExited ( MouseEvent evt ) { } public void mousePressed ( MouseEvent evt ) { } public void mouseReleased ( MouseEvent evt ) { } public void valueChanged ( ListSelectionEvent evt ) { updateButtons ( ) ; } private View view ; private JList clips ; private HistoryModel clipHistory ; private JButton insert ; private JButton cancel ; private void updateButtons ( ) { int selected = clips . getSelectedIndex ( ) ; insert . setEnabled ( selected != - 1 ) ; } } 	1	['12', '7', '0', '7', '57', '52', '1', '7', '10', '0.709090909', '279', '1', '2', '0.983433735', '0.277777778', '0', '0', '21.83333333', '3', '1.3333', '1']
package org . gjt . sp . jedit ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class EditPane extends JPanel implements EBComponent { public View getView ( ) { return view ; } public Buffer getBuffer ( ) { return buffer ; } public void setBuffer ( final Buffer buffer ) { if ( this . buffer == buffer ) return ; if ( buffer . isClosed ( ) ) throw new InternalError ( buffer + " has been closed" ) ; buffer . endCompoundEdit ( ) ; recentBuffer = this . buffer ; if ( recentBuffer != null ) saveCaretInfo ( ) ; this . buffer = buffer ; textArea . setBuffer ( buffer ) ; if ( ! init ) { view . updateTitle ( ) ; if ( bufferSwitcher != null ) { if ( bufferSwitcher . getSelectedItem ( ) != buffer ) bufferSwitcher . setSelectedItem ( buffer ) ; } EditBus . send ( new EditPaneUpdate ( this , EditPaneUpdate . BUFFER_CHANGED ) ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( view . getEditPane ( ) == EditPane . this && ( bufferSwitcher == null || ! bufferSwitcher . isPopupVisible ( ) ) ) { focusOnTextArea ( ) ; } } } ) ; Runnable runnable = new Runnable ( ) { public void run ( ) { loadCaretInfo ( ) ; buffer . checkModTime ( view ) ; } } ; if ( buffer . isPerformingIO ( ) ) VFSManager . runInAWTThread ( runnable ) ; else runnable . run ( ) ; } public void prevBuffer ( ) { Buffer buffer = this . buffer . getPrev ( ) ; if ( buffer == null ) setBuffer ( jEdit . getLastBuffer ( ) ) ; else setBuffer ( buffer ) ; } public void nextBuffer ( ) { Buffer buffer = this . buffer . getNext ( ) ; if ( buffer == null ) setBuffer ( jEdit . getFirstBuffer ( ) ) ; else setBuffer ( buffer ) ; } public void recentBuffer ( ) { if ( recentBuffer != null ) setBuffer ( recentBuffer ) ; else getToolkit ( ) . beep ( ) ; } public void focusOnTextArea ( ) { textArea . grabFocus ( ) ; } public JEditTextArea getTextArea ( ) { return textArea ; } public void saveCaretInfo ( ) { buffer . putProperty ( Buffer . CARET , new Integer ( textArea . getCaretPosition ( ) ) ) ; Selection [ ] selection = textArea . getSelection ( ) ; if ( selection != null ) buffer . putProperty ( Buffer . SELECTION , selection ) ; buffer . putProperty ( Buffer . SCROLL_VERT , new Integer ( textArea . getFirstLine ( ) ) ) ; buffer . putProperty ( Buffer . SCROLL_HORIZ , new Integer ( textArea . getHorizontalOffset ( ) ) ) ; } public void loadCaretInfo ( ) { Integer caret = ( Integer ) buffer . getProperty ( Buffer . CARET ) ; Selection [ ] selection = ( Selection [ ] ) buffer . getProperty ( Buffer . SELECTION ) ; Integer firstLine = ( Integer ) buffer . getProperty ( Buffer . SCROLL_VERT ) ; Integer horizontalOffset = ( Integer ) buffer . getProperty ( Buffer . SCROLL_HORIZ ) ; if ( caret != null ) { textArea . setCaretPosition ( Math . min ( caret . intValue ( ) , buffer . getLength ( ) ) ) ; } if ( selection != null ) textArea . setSelection ( selection ) ; if ( firstLine != null ) textArea . setFirstLine ( firstLine . intValue ( ) ) ; if ( horizontalOffset != null ) textArea . setHorizontalOffset ( horizontalOffset . intValue ( ) ) ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof PropertiesChanged ) { propertiesChanged ( ) ; loadBufferSwitcher ( ) ; } else if ( msg instanceof BufferUpdate ) handleBufferUpdate ( ( BufferUpdate ) msg ) ; } public final Dimension getMinimumSize ( ) { return new Dimension ( 0 , 0 ) ; } EditPane ( View view , Buffer buffer ) { super ( new BorderLayout ( ) ) ; init = true ; this . view = view ; EditBus . addToBus ( this ) ; textArea = new JEditTextArea ( view ) ; add ( BorderLayout . CENTER , textArea ) ; markerHighlight = new MarkerHighlight ( ) ; textArea . getGutter ( ) . addCustomHighlight ( markerHighlight ) ; propertiesChanged ( ) ; if ( buffer == null ) setBuffer ( jEdit . getFirstBuffer ( ) ) ; else setBuffer ( buffer ) ; loadBufferSwitcher ( ) ; init = false ; } void close ( ) { saveCaretInfo ( ) ; EditBus . send ( new EditPaneUpdate ( this , EditPaneUpdate . DESTROYED ) ) ; EditBus . removeFromBus ( this ) ; } private boolean init ; private View view ; private Buffer buffer ; private Buffer recentBuffer ; private BufferSwitcher bufferSwitcher ; private JEditTextArea textArea ; private MarkerHighlight markerHighlight ; private void propertiesChanged ( ) { TextAreaPainter painter = textArea . getPainter ( ) ; painter . setFont ( UIManager . getFont ( "TextArea.font" ) ) ; painter . setBracketHighlightEnabled ( jEdit . getBooleanProperty ( "view.bracketHighlight" ) ) ; painter . setBracketHighlightColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bracketHighlightColor" ) ) ) ; painter . setEOLMarkersPainted ( jEdit . getBooleanProperty ( "view.eolMarkers" ) ) ; painter . setEOLMarkerColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.eolMarkerColor" ) ) ) ; painter . setWrapGuidePainted ( jEdit . getBooleanProperty ( "view.wrapGuide" ) ) ; painter . setWrapGuideColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.wrapGuideColor" ) ) ) ; painter . setCaretColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.caretColor" ) ) ) ; painter . setSelectionColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.selectionColor" ) ) ) ; painter . setBackground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ; painter . setForeground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.fgColor" ) ) ) ; painter . setBlockCaretEnabled ( jEdit . getBooleanProperty ( "view.blockCaret" ) ) ; painter . setLineHighlightEnabled ( jEdit . getBooleanProperty ( "view.lineHighlight" ) ) ; painter . setLineHighlightColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.lineHighlightColor" ) ) ) ; painter . setAntiAliasEnabled ( jEdit . getBooleanProperty ( "view.antiAlias" ) ) ; painter . setFractionalFontMetricsEnabled ( jEdit . getBooleanProperty ( "view.fracFontMetrics" ) ) ; painter . setStyles ( GUIUtilities . loadStyles ( jEdit . getProperty ( "view.font" ) , Integer . parseInt ( jEdit . getProperty ( "view.fontsize" ) ) ) ) ; Gutter gutter = textArea . getGutter ( ) ; gutter . setExpanded ( jEdit . getBooleanProperty ( "view.gutter.lineNumbers" ) ) ; try { int interval = Integer . parseInt ( jEdit . getProperty ( "view.gutter.highlightInterval" ) ) ; gutter . setHighlightInterval ( interval ) ; } catch ( NumberFormatException nf ) { } gutter . setCurrentLineHighlightEnabled ( jEdit . getBooleanProperty ( "view.gutter.highlightCurrentLine" ) ) ; gutter . setBackground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.bgColor" ) ) ) ; gutter . setForeground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.fgColor" ) ) ) ; gutter . setHighlightedForeground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.highlightColor" ) ) ) ; gutter . setFoldColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.foldColor" ) ) ) ; markerHighlight . setMarkerHighlightColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.markerColor" ) ) ) ; markerHighlight . setHighlightEnabled ( jEdit . getBooleanProperty ( "view.gutter.markerHighlight" ) ) ; gutter . setCurrentLineForeground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.currentLineColor" ) ) ) ; String alignment = jEdit . getProperty ( "view.gutter.numberAlignment" ) ; if ( "right" . equals ( alignment ) ) { gutter . setLineNumberAlignment ( Gutter . RIGHT ) ; } else if ( "center" . equals ( alignment ) ) { gutter . setLineNumberAlignment ( Gutter . CENTER ) ; } else { gutter . setLineNumberAlignment ( Gutter . LEFT ) ; } try { String fontname = jEdit . getProperty ( "view.gutter.font" ) ; int fontsize = Integer . parseInt ( jEdit . getProperty ( "view.gutter.fontsize" ) ) ; int fontstyle = Integer . parseInt ( jEdit . getProperty ( "view.gutter.fontstyle" ) ) ; gutter . setFont ( new Font ( fontname , fontstyle , fontsize ) ) ; } catch ( NumberFormatException nf ) { } try { int width = Integer . parseInt ( jEdit . getProperty ( "view.gutter.borderWidth" ) ) ; gutter . setBorder ( width , GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.focusBorderColor" ) ) , GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.noFocusBorderColor" ) ) , textArea . getPainter ( ) . getBackground ( ) ) ; } catch ( NumberFormatException nf ) { } textArea . setCaretBlinkEnabled ( jEdit . getBooleanProperty ( "view.caretBlink" ) ) ; try { textArea . setElectricScroll ( Integer . parseInt ( jEdit . getProperty ( "view.electricBorders" ) ) ) ; } catch ( NumberFormatException nf ) { textArea . setElectricScroll ( 0 ) ; } textArea . setRightClickPopup ( GUIUtilities . loadPopupMenu ( "view.context" ) ) ; textArea . setMiddleMousePasteEnabled ( jEdit . getBooleanProperty ( "view.middleMousePaste" ) ) ; } private void loadBufferSwitcher ( ) { if ( jEdit . getBooleanProperty ( "view.showBufferSwitcher" ) ) { if ( bufferSwitcher == null ) { bufferSwitcher = new BufferSwitcher ( this ) ; add ( BorderLayout . NORTH , bufferSwitcher ) ; bufferSwitcher . updateBufferList ( ) ; revalidate ( ) ; } } else if ( bufferSwitcher != null ) { remove ( bufferSwitcher ) ; revalidate ( ) ; bufferSwitcher = null ; } } private void handleBufferUpdate ( BufferUpdate msg ) { Buffer _buffer = msg . getBuffer ( ) ; if ( msg . getWhat ( ) == BufferUpdate . CREATED ) { if ( bufferSwitcher != null ) bufferSwitcher . updateBufferList ( ) ; if ( buffer . isClosed ( ) ) setBuffer ( jEdit . getFirstBuffer ( ) ) ; } else if ( msg . getWhat ( ) == BufferUpdate . CLOSED ) { if ( bufferSwitcher != null ) bufferSwitcher . updateBufferList ( ) ; if ( _buffer == buffer ) { Buffer newBuffer = ( recentBuffer != null ? recentBuffer : _buffer . getPrev ( ) ) ; if ( newBuffer != null && ! newBuffer . isClosed ( ) ) setBuffer ( newBuffer ) ; else if ( jEdit . getBufferCount ( ) != 0 ) setBuffer ( jEdit . getFirstBuffer ( ) ) ; recentBuffer = null ; } else if ( _buffer == recentBuffer ) recentBuffer = null ; } else if ( msg . getWhat ( ) == BufferUpdate . LOAD_STARTED ) { if ( _buffer == buffer ) { textArea . setCaretPosition ( 0 ) ; textArea . getPainter ( ) . repaint ( ) ; } } else if ( msg . getWhat ( ) == BufferUpdate . DIRTY_CHANGED ) { if ( _buffer == buffer ) { if ( bufferSwitcher != null ) { if ( buffer . isDirty ( ) ) bufferSwitcher . repaint ( ) ; else bufferSwitcher . updateBufferList ( ) ; } } } else if ( msg . getWhat ( ) == BufferUpdate . LOADED ) { if ( _buffer == buffer ) { textArea . repaint ( ) ; textArea . updateScrollBars ( ) ; if ( bufferSwitcher != null ) bufferSwitcher . updateBufferList ( ) ; if ( view . getEditPane ( ) == this ) { StatusBar status = view . getStatus ( ) ; status . repaintCaretStatus ( ) ; status . updateBufferStatus ( ) ; status . updateMiscStatus ( ) ; } loadCaretInfo ( ) ; } } else if ( msg . getWhat ( ) == BufferUpdate . MARKERS_CHANGED ) { if ( _buffer == buffer ) textArea . getGutter ( ) . repaint ( ) ; } else if ( msg . getWhat ( ) == BufferUpdate . MODE_CHANGED ) { if ( _buffer == buffer ) { textArea . getPainter ( ) . repaint ( ) ; if ( view . getEditPane ( ) == this ) view . getStatus ( ) . updateBufferStatus ( ) ; } } else if ( msg . getWhat ( ) == BufferUpdate . ENCODING_CHANGED ) { if ( _buffer == buffer ) { if ( view . getEditPane ( ) == this ) view . getStatus ( ) . updateBufferStatus ( ) ; } } } } 	1	['19', '5', '0', '31', '132', '57', '16', '22', '12', '0.595238095', '828', '1', '6', '0.973174367', '0.210526316', '1', '1', '42.21052632', '21', '3.2105', '5']
package org . gjt . sp . jedit . options ; import javax . swing . border . EmptyBorder ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . gui . EditAbbrevDialog ; import org . gjt . sp . jedit . * ; public class AbbrevsOptionPane extends AbstractOptionPane { public AbbrevsOptionPane ( ) { super ( "abbrevs" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; JPanel panel2 = new JPanel ( ) ; panel2 . setLayout ( new BoxLayout ( panel2 , BoxLayout . X_AXIS ) ) ; panel2 . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; panel2 . add ( Box . createGlue ( ) ) ; expandOnInput = new JCheckBox ( jEdit . getProperty ( "options.abbrevs" + ".expandOnInput" ) , Abbrevs . getExpandOnInput ( ) ) ; panel2 . add ( expandOnInput ) ; panel2 . add ( Box . createGlue ( ) ) ; panel . add ( panel2 , BorderLayout . NORTH ) ; JPanel panel3 = new JPanel ( ) ; JLabel label = new JLabel ( jEdit . getProperty ( "options.abbrevs.set" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; panel3 . add ( label ) ; Hashtable _modeAbbrevs = Abbrevs . getModeAbbrevs ( ) ; modeAbbrevs = new Hashtable ( ) ; Mode [ ] modes = jEdit . getModes ( ) ; String [ ] sets = new String [ modes . length + 1 ] ; sets [ 0 ] = "global" ; for ( int i = 0 ; i < modes . length ; i ++ ) { String name = modes [ i ] . getName ( ) ; sets [ i + 1 ] = name ; modeAbbrevs . put ( name , new AbbrevsModel ( ( Hashtable ) _modeAbbrevs . get ( name ) ) ) ; } setsComboBox = new JComboBox ( sets ) ; setsComboBox . addActionListener ( new ActionHandler ( ) ) ; panel3 . add ( setsComboBox ) ; panel . add ( panel3 , BorderLayout . SOUTH ) ; add ( BorderLayout . NORTH , panel ) ; globalAbbrevs = new AbbrevsModel ( Abbrevs . getGlobalAbbrevs ( ) ) ; abbrevsTable = new JTable ( globalAbbrevs ) ; abbrevsTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; abbrevsTable . getTableHeader ( ) . addMouseListener ( new HeaderMouseHandler ( ) ) ; abbrevsTable . addMouseListener ( new TableMouseHandler ( ) ) ; Dimension d = abbrevsTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 200 ) ; JScrollPane scroller = new JScrollPane ( abbrevsTable ) ; scroller . setPreferredSize ( d ) ; add ( BorderLayout . CENTER , scroller ) ; } protected void _save ( ) { if ( abbrevsTable . getCellEditor ( ) != null ) abbrevsTable . getCellEditor ( ) . stopCellEditing ( ) ; Abbrevs . setExpandOnInput ( expandOnInput . isSelected ( ) ) ; Abbrevs . setGlobalAbbrevs ( globalAbbrevs . toHashtable ( ) ) ; Hashtable modeHash = new Hashtable ( ) ; Enumeration keys = modeAbbrevs . keys ( ) ; Enumeration values = modeAbbrevs . elements ( ) ; while ( keys . hasMoreElements ( ) ) { modeHash . put ( keys . nextElement ( ) , ( ( AbbrevsModel ) values . nextElement ( ) ) . toHashtable ( ) ) ; } Abbrevs . setModeAbbrevs ( modeHash ) ; } private JComboBox setsComboBox ; private JCheckBox expandOnInput ; private JTable abbrevsTable ; private AbbrevsModel globalAbbrevs ; private Hashtable modeAbbrevs ; class HeaderMouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { switch ( abbrevsTable . getTableHeader ( ) . columnAtPoint ( evt . getPoint ( ) ) ) { case 0 : ( ( AbbrevsModel ) abbrevsTable . getModel ( ) ) . sort ( 0 ) ; break ; case 1 : ( ( AbbrevsModel ) abbrevsTable . getModel ( ) ) . sort ( 1 ) ; break ; } } } class TableMouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { if ( abbrevsTable . getSelectedColumn ( ) == 1 ) { TableModel abbrevsModel = abbrevsTable . getModel ( ) ; int row = abbrevsTable . getSelectedRow ( ) ; String abbrev = ( String ) abbrevsModel . getValueAt ( row , 0 ) ; String expansion = ( String ) abbrevsModel . getValueAt ( row , 1 ) ; expansion = new EditAbbrevDialog ( AbbrevsOptionPane . this , abbrev , expansion ) . getExpansion ( ) ; if ( expansion != null ) abbrevsModel . setValueAt ( expansion , row , 1 ) ; } } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == setsComboBox ) { String selected = ( String ) setsComboBox . getSelectedItem ( ) ; if ( selected . equals ( "global" ) ) { abbrevsTable . setModel ( globalAbbrevs ) ; } else { abbrevsTable . setModel ( ( AbbrevsModel ) modeAbbrevs . get ( selected ) ) ; } } } } } class AbbrevsModel extends AbstractTableModel { Vector abbrevs ; AbbrevsModel ( ) { abbrevs = new Vector ( ) ; } AbbrevsModel ( Hashtable abbrevHash ) { this ( ) ; if ( abbrevHash != null ) { Enumeration abbrevEnum = abbrevHash . keys ( ) ; Enumeration expandEnum = abbrevHash . elements ( ) ; while ( abbrevEnum . hasMoreElements ( ) ) { abbrevs . addElement ( new Abbrev ( ( String ) abbrevEnum . nextElement ( ) , ( String ) expandEnum . nextElement ( ) ) ) ; } sort ( 0 ) ; } } public void sort ( int col ) { MiscUtilities . quicksort ( abbrevs , new AbbrevCompare ( col ) ) ; fireTableDataChanged ( ) ; } public Hashtable toHashtable ( ) { Hashtable hash = new Hashtable ( ) ; for ( int i = 0 ; i < abbrevs . size ( ) ; i ++ ) { Abbrev abbrev = ( Abbrev ) abbrevs . elementAt ( i ) ; if ( abbrev . abbrev . length ( ) > 0 && abbrev . expand . length ( ) > 0 ) { hash . put ( abbrev . abbrev , abbrev . expand ) ; } } return hash ; } public int getColumnCount ( ) { return 2 ; } public int getRowCount ( ) { return abbrevs . size ( ) + 1 ; } public Object getValueAt ( int row , int col ) { if ( row == abbrevs . size ( ) ) return null ; Abbrev abbrev = ( Abbrev ) abbrevs . elementAt ( row ) ; switch ( col ) { case 0 : return abbrev . abbrev ; case 1 : return abbrev . expand ; default : return null ; } } public boolean isCellEditable ( int row , int col ) { return ( col == 0 ) ; } public void setValueAt ( Object value , int row , int col ) { if ( value == null ) value = "" ; Abbrev abbrev ; if ( row == abbrevs . size ( ) ) { abbrev = new Abbrev ( ) ; abbrevs . addElement ( abbrev ) ; } else abbrev = ( Abbrev ) abbrevs . elementAt ( row ) ; if ( col == 0 ) abbrev . abbrev = ( String ) value ; else abbrev . expand = ( String ) value ; fireTableRowsUpdated ( row , row + 1 ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.abbrevs.abbrev" ) ; case 1 : return jEdit . getProperty ( "options.abbrevs.expand" ) ; default : return null ; } } class AbbrevCompare implements MiscUtilities . Compare { int col ; AbbrevCompare ( int col ) { this . col = col ; } public int compare ( Object obj1 , Object obj2 ) { Abbrev a1 = ( Abbrev ) obj1 ; Abbrev a2 = ( Abbrev ) obj2 ; if ( col == 0 ) { String abbrev1 = a1 . abbrev . toLowerCase ( ) ; String abbrev2 = a2 . abbrev . toLowerCase ( ) ; return abbrev1 . compareTo ( abbrev2 ) ; } else { String expand1 = a1 . expand . toLowerCase ( ) ; String expand2 = a2 . expand . toLowerCase ( ) ; return expand1 . compareTo ( expand2 ) ; } } } } class Abbrev { Abbrev ( ) { } Abbrev ( String abbrev , String expand ) { this . abbrev = abbrev ; this . expand = expand ; } String abbrev ; String expand ; } 	1	['7', '6', '0', '9', '58', '5', '4', '8', '1', '0.733333333', '300', '1', '1', '0.991017964', '0.5', '4', '12', '41.14285714', '5', '1.7143', '1']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . * ; public class CloseDialog extends EnhancedDialog { public CloseDialog ( View view ) { super ( view , jEdit . getProperty ( "close.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "close.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , label ) ; bufferList = new JList ( bufferModel = new DefaultListModel ( ) ) ; bufferList . setVisibleRowCount ( 10 ) ; bufferList . addListSelectionListener ( new ListHandler ( ) ) ; Buffer [ ] buffers = jEdit . getBuffers ( ) ; for ( int i = 0 ; i < buffers . length ; i ++ ) { Buffer buffer = buffers [ i ] ; if ( buffer . isDirty ( ) ) { bufferModel . addElement ( buffer . getPath ( ) ) ; } } content . add ( BorderLayout . CENTER , new JScrollPane ( bufferList ) ) ; ActionHandler actionListener = new ActionHandler ( ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; buttons . add ( Box . createGlue ( ) ) ; buttons . add ( save = new JButton ( jEdit . getProperty ( "close.save" ) ) ) ; save . setMnemonic ( jEdit . getProperty ( "close.save.mnemonic" ) . charAt ( 0 ) ) ; save . addActionListener ( actionListener ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( discard = new JButton ( jEdit . getProperty ( "close.discard" ) ) ) ; discard . setMnemonic ( jEdit . getProperty ( "close.discard.mnemonic" ) . charAt ( 0 ) ) ; discard . addActionListener ( actionListener ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ) ; cancel . addActionListener ( actionListener ) ; buttons . add ( Box . createGlue ( ) ) ; bufferList . setSelectedIndex ( 0 ) ; content . add ( BorderLayout . SOUTH , buttons ) ; GUIUtilities . requestFocus ( this , bufferList ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public boolean isOK ( ) { return ok ; } public void ok ( ) { } public void cancel ( ) { dispose ( ) ; } private View view ; private JList bufferList ; private DefaultListModel bufferModel ; private JButton save ; private JButton discard ; private JButton cancel ; private boolean ok ; private void updateButtons ( ) { int index = bufferList . getSelectedIndex ( ) ; save . getModel ( ) . setEnabled ( index != - 1 ) ; discard . getModel ( ) . setEnabled ( index != - 1 ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == save ) { Object [ ] paths = bufferList . getSelectedValues ( ) ; for ( int i = 0 ; i < paths . length ; i ++ ) { String path = ( String ) paths [ i ] ; Buffer buffer = jEdit . getBuffer ( path ) ; if ( ! buffer . save ( view , null , true ) ) return ; VFSManager . waitForRequests ( ) ; jEdit . _closeBuffer ( view , buffer ) ; bufferModel . removeElement ( path ) ; } updateButtons ( ) ; if ( bufferModel . getSize ( ) == 0 ) { ok = true ; dispose ( ) ; } } else if ( source == discard ) { Object [ ] paths = bufferList . getSelectedValues ( ) ; for ( int i = 0 ; i < paths . length ; i ++ ) { String path = ( String ) paths [ i ] ; Buffer buffer = jEdit . getBuffer ( path ) ; jEdit . _closeBuffer ( view , buffer ) ; bufferModel . removeElement ( path ) ; } updateButtons ( ) ; if ( bufferModel . getSize ( ) == 0 ) { ok = true ; dispose ( ) ; } } else if ( source == cancel ) cancel ( ) ; } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { int index = bufferList . getSelectedIndex ( ) ; if ( index != - 1 ) view . setBuffer ( jEdit . getBuffer ( ( String ) bufferModel . getElementAt ( index ) ) ) ; updateButtons ( ) ; } } } 	1	['14', '7', '0', '7', '54', '65', '3', '7', '4', '0.846153846', '313', '1', '1', '0.98048048', '0.285714286', '0', '0', '20.85714286', '3', '1.0714', '3']
package org . gjt . sp . jedit . search ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . text . BadLocationException ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . io . File ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . FileVFS ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class SearchDialog extends EnhancedDialog { public static final int CURRENT_BUFFER = 0 ; public static final int ALL_BUFFERS = 1 ; public static final int DIRECTORY = 2 ; public SearchDialog ( View view , String searchString ) { this ( view , searchString , CURRENT_BUFFER ) ; } public SearchDialog ( View view , String searchString , int searchIn ) { super ( view , jEdit . getProperty ( "search.title" ) , false ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 0 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel centerPanel = new JPanel ( new BorderLayout ( ) ) ; centerPanel . add ( BorderLayout . NORTH , createFieldPanel ( ) ) ; centerPanel . add ( BorderLayout . CENTER , createSearchSettingsPanel ( ) ) ; content . add ( BorderLayout . CENTER , centerPanel ) ; content . add ( BorderLayout . SOUTH , createMultiFilePanel ( ) ) ; content . add ( BorderLayout . EAST , createButtonsPanel ( ) ) ; if ( searchString != null && searchString . indexOf ( '\n' ) == - 1 ) { find . setText ( searchString ) ; find . selectAll ( ) ; } else replace . setText ( null ) ; ignoreCase . setSelected ( SearchAndReplace . getIgnoreCase ( ) ) ; regexp . setSelected ( SearchAndReplace . getRegexp ( ) ) ; wrap . setSelected ( SearchAndReplace . getAutoWrapAround ( ) ) ; if ( SearchAndReplace . getReverseSearch ( ) ) searchBack . setSelected ( true ) ; else searchForward . setSelected ( true ) ; if ( SearchAndReplace . getBeanShellReplace ( ) ) beanShellReplace . setSelected ( true ) ; else stringReplace . setSelected ( true ) ; if ( searchIn == CURRENT_BUFFER ) searchCurrentBuffer . setSelected ( true ) ; else if ( searchIn == ALL_BUFFERS ) searchAllBuffers . setSelected ( true ) ; else if ( searchIn == DIRECTORY ) searchDirectory . setSelected ( true ) ; SearchFileSet fileset = SearchAndReplace . getSearchFileSet ( ) ; if ( fileset instanceof DirectoryListSet ) { filter . setText ( ( ( DirectoryListSet ) fileset ) . getFileFilter ( ) ) ; directory . setText ( ( ( DirectoryListSet ) fileset ) . getDirectory ( ) ) ; searchSubDirectories . setSelected ( ( ( DirectoryListSet ) fileset ) . isRecursive ( ) ) ; } else { String path ; if ( view . getBuffer ( ) . getVFS ( ) instanceof FileVFS ) { path = MiscUtilities . getParentOfPath ( view . getBuffer ( ) . getPath ( ) ) ; } else path = System . getProperty ( "user.dir" ) ; directory . setText ( path ) ; if ( fileset instanceof AllBufferSet ) { filter . setText ( ( ( AllBufferSet ) fileset ) . getFileFilter ( ) ) ; } else { filter . setText ( "*" + MiscUtilities . getFileExtension ( view . getBuffer ( ) . getName ( ) ) ) ; } searchSubDirectories . setSelected ( true ) ; } keepDialog . setSelected ( jEdit . getBooleanProperty ( "search.keepDialog.toggle" ) ) ; hyperSearch . setSelected ( jEdit . getBooleanProperty ( "search.hypersearch.toggle" ) ) ; updateEnabled ( ) ; pack ( ) ; jEdit . unsetProperty ( "search.width" ) ; jEdit . unsetProperty ( "search.d-width" ) ; jEdit . unsetProperty ( "search.height" ) ; jEdit . unsetProperty ( "search.d-height" ) ; GUIUtilities . loadGeometry ( this , "search" ) ; show ( ) ; GUIUtilities . requestFocus ( this , find ) ; } public void ok ( ) { try { setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; if ( ! save ( ) ) return ; if ( hyperSearch . isSelected ( ) ) { if ( SearchAndReplace . hyperSearch ( view ) ) ; closeOrKeepDialog ( ) ; } else { if ( SearchAndReplace . find ( view ) ) closeOrKeepDialog ( ) ; } } finally { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } public void cancel ( ) { save ( ) ; GUIUtilities . saveGeometry ( this , "search" ) ; setVisible ( false ) ; } private View view ; private HistoryTextField find , replace ; private JRadioButton stringReplace , beanShellReplace ; private JCheckBox keepDialog , ignoreCase , regexp , hyperSearch , wrap ; private JRadioButton searchBack , searchForward ; private JRadioButton searchCurrentBuffer , searchAllBuffers , searchDirectory ; private HistoryTextField filter , directory ; private JCheckBox searchSubDirectories ; private JButton choose ; private JButton findBtn , replaceBtn , replaceAndFindBtn , replaceAllBtn , closeBtn ; private JPanel createFieldPanel ( ) { ButtonActionHandler actionHandler = new ButtonActionHandler ( ) ; JPanel fieldPanel = new JPanel ( new VariableGridLayout ( VariableGridLayout . FIXED_NUM_COLUMNS , 1 ) ) ; fieldPanel . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 12 ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "search.find" ) ) ; label . setDisplayedMnemonic ( jEdit . getProperty ( "search.find.mnemonic" ) . charAt ( 0 ) ) ; find = new HistoryTextField ( "find" ) ; find . addActionListener ( actionHandler ) ; label . setLabelFor ( find ) ; label . setBorder ( new EmptyBorder ( 12 , 0 , 2 , 0 ) ) ; fieldPanel . add ( label ) ; fieldPanel . add ( find ) ; label = new JLabel ( jEdit . getProperty ( "search.replace" ) ) ; label . setDisplayedMnemonic ( jEdit . getProperty ( "search.replace.mnemonic" ) . charAt ( 0 ) ) ; label . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; fieldPanel . add ( label ) ; ButtonGroup grp = new ButtonGroup ( ) ; ReplaceActionHandler replaceActionHandler = new ReplaceActionHandler ( ) ; Box replaceModeBox = new Box ( BoxLayout . X_AXIS ) ; stringReplace = new MyJRadioButton ( jEdit . getProperty ( "search.string-replace-btn" ) ) ; stringReplace . addActionListener ( replaceActionHandler ) ; grp . add ( stringReplace ) ; replaceModeBox . add ( stringReplace ) ; replaceModeBox . add ( Box . createHorizontalStrut ( 12 ) ) ; beanShellReplace = new MyJRadioButton ( jEdit . getProperty ( "search.beanshell-replace-btn" ) ) ; beanShellReplace . addActionListener ( replaceActionHandler ) ; grp . add ( beanShellReplace ) ; replaceModeBox . add ( beanShellReplace ) ; fieldPanel . add ( replaceModeBox ) ; fieldPanel . add ( Box . createVerticalStrut ( 3 ) ) ; replace = new HistoryTextField ( "replace" ) ; replace . addActionListener ( actionHandler ) ; label . setLabelFor ( replace ) ; fieldPanel . add ( replace ) ; return fieldPanel ; } private JPanel createSearchSettingsPanel ( ) { JPanel searchSettings = new JPanel ( new VariableGridLayout ( VariableGridLayout . FIXED_NUM_COLUMNS , 3 ) ) ; searchSettings . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 12 ) ) ; SettingsActionHandler actionHandler = new SettingsActionHandler ( ) ; ButtonGroup fileset = new ButtonGroup ( ) ; searchSettings . add ( new JLabel ( jEdit . getProperty ( "search.fileset" ) ) ) ; keepDialog = new JCheckBox ( jEdit . getProperty ( "search.keep" ) ) ; keepDialog . setMnemonic ( jEdit . getProperty ( "search.keep.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( keepDialog ) ; searchSettings . add ( new JLabel ( jEdit . getProperty ( "search.direction" ) ) ) ; ButtonGroup direction = new ButtonGroup ( ) ; searchCurrentBuffer = new JRadioButton ( jEdit . getProperty ( "search.current" ) ) ; searchCurrentBuffer . setMnemonic ( jEdit . getProperty ( "search.current.mnemonic" ) . charAt ( 0 ) ) ; fileset . add ( searchCurrentBuffer ) ; searchSettings . add ( searchCurrentBuffer ) ; searchCurrentBuffer . addActionListener ( actionHandler ) ; ignoreCase = new JCheckBox ( jEdit . getProperty ( "search.case" ) ) ; ignoreCase . setMnemonic ( jEdit . getProperty ( "search.case.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( ignoreCase ) ; ignoreCase . addActionListener ( actionHandler ) ; searchBack = new JRadioButton ( jEdit . getProperty ( "search.back" ) ) ; searchBack . setMnemonic ( jEdit . getProperty ( "search.back.mnemonic" ) . charAt ( 0 ) ) ; direction . add ( searchBack ) ; searchSettings . add ( searchBack ) ; searchBack . addActionListener ( actionHandler ) ; searchAllBuffers = new JRadioButton ( jEdit . getProperty ( "search.all" ) ) ; searchAllBuffers . setMnemonic ( jEdit . getProperty ( "search.all.mnemonic" ) . charAt ( 0 ) ) ; fileset . add ( searchAllBuffers ) ; searchSettings . add ( searchAllBuffers ) ; searchAllBuffers . addActionListener ( actionHandler ) ; regexp = new JCheckBox ( jEdit . getProperty ( "search.regexp" ) ) ; regexp . setMnemonic ( jEdit . getProperty ( "search.regexp.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( regexp ) ; regexp . addActionListener ( actionHandler ) ; searchForward = new JRadioButton ( jEdit . getProperty ( "search.forward" ) ) ; searchForward . setMnemonic ( jEdit . getProperty ( "search.forward.mnemonic" ) . charAt ( 0 ) ) ; direction . add ( searchForward ) ; searchSettings . add ( searchForward ) ; searchForward . addActionListener ( actionHandler ) ; searchDirectory = new JRadioButton ( jEdit . getProperty ( "search.directory" ) ) ; searchDirectory . setMnemonic ( jEdit . getProperty ( "search.directory.mnemonic" ) . charAt ( 0 ) ) ; fileset . add ( searchDirectory ) ; searchSettings . add ( searchDirectory ) ; searchDirectory . addActionListener ( actionHandler ) ; hyperSearch = new JCheckBox ( jEdit . getProperty ( "search.hypersearch" ) ) ; hyperSearch . setMnemonic ( jEdit . getProperty ( "search.hypersearch.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( hyperSearch ) ; hyperSearch . addActionListener ( actionHandler ) ; wrap = new JCheckBox ( jEdit . getProperty ( "search.wrap" ) ) ; wrap . setMnemonic ( jEdit . getProperty ( "search.wrap.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( wrap ) ; wrap . addActionListener ( actionHandler ) ; return searchSettings ; } private JPanel createMultiFilePanel ( ) { JPanel multifile = new JPanel ( ) ; GridBagLayout layout = new GridBagLayout ( ) ; multifile . setLayout ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = cons . gridwidth = cons . gridheight = 1 ; cons . anchor = GridBagConstraints . WEST ; cons . fill = GridBagConstraints . HORIZONTAL ; MultiFileActionHandler actionListener = new MultiFileActionHandler ( ) ; filter = new HistoryTextField ( "search.filter" ) ; filter . addActionListener ( actionListener ) ; cons . insets = new Insets ( 0 , 0 , 3 , 0 ) ; JLabel label = new JLabel ( jEdit . getProperty ( "search.filterField" ) , SwingConstants . RIGHT ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; label . setDisplayedMnemonic ( jEdit . getProperty ( "search.filterField.mnemonic" ) . charAt ( 0 ) ) ; label . setLabelFor ( filter ) ; cons . weightx = 0.0f ; layout . setConstraints ( label , cons ) ; multifile . add ( label ) ; cons . insets = new Insets ( 0 , 0 , 3 , 6 ) ; cons . weightx = 1.0f ; layout . setConstraints ( filter , cons ) ; multifile . add ( filter ) ; cons . gridy ++ ; directory = new HistoryTextField ( "search.directory" ) ; directory . addActionListener ( actionListener ) ; label = new JLabel ( jEdit . getProperty ( "search.directoryField" ) , SwingConstants . RIGHT ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; label . setDisplayedMnemonic ( jEdit . getProperty ( "search.directoryField.mnemonic" ) . charAt ( 0 ) ) ; label . setLabelFor ( directory ) ; cons . insets = new Insets ( 0 , 0 , 3 , 0 ) ; cons . weightx = 0.0f ; layout . setConstraints ( label , cons ) ; multifile . add ( label ) ; cons . insets = new Insets ( 0 , 0 , 3 , 6 ) ; cons . weightx = 1.0f ; cons . gridwidth = 2 ; layout . setConstraints ( directory , cons ) ; multifile . add ( directory ) ; choose = new JButton ( jEdit . getProperty ( "search.choose" ) ) ; choose . setMnemonic ( jEdit . getProperty ( "search.choose.mnemonic" ) . charAt ( 0 ) ) ; cons . insets = new Insets ( 0 , 0 , 3 , 0 ) ; cons . weightx = 0.0f ; cons . gridwidth = 1 ; layout . setConstraints ( choose , cons ) ; multifile . add ( choose ) ; choose . addActionListener ( actionListener ) ; cons . insets = new Insets ( 0 , 0 , 0 , 0 ) ; cons . gridy ++ ; cons . gridwidth = 4 ; searchSubDirectories = new JCheckBox ( jEdit . getProperty ( "search.subdirs" ) ) ; searchSubDirectories . setMnemonic ( jEdit . getProperty ( "search.subdirs.mnemonic" ) . charAt ( 0 ) ) ; layout . setConstraints ( searchSubDirectories , cons ) ; multifile . add ( searchSubDirectories ) ; return multifile ; } private Box createButtonsPanel ( ) { Box box = new Box ( BoxLayout . Y_AXIS ) ; ButtonActionHandler actionHandler = new ButtonActionHandler ( ) ; box . add ( Box . createVerticalStrut ( 12 ) ) ; JPanel grid = new JPanel ( new GridLayout ( 5 , 1 , 0 , 12 ) ) ; findBtn = new JButton ( jEdit . getProperty ( "search.findBtn" ) ) ; getRootPane ( ) . setDefaultButton ( findBtn ) ; grid . add ( findBtn ) ; findBtn . addActionListener ( actionHandler ) ; replaceBtn = new JButton ( jEdit . getProperty ( "search.replaceBtn" ) ) ; replaceBtn . setMnemonic ( jEdit . getProperty ( "search.replaceBtn.mnemonic" ) . charAt ( 0 ) ) ; grid . add ( replaceBtn ) ; replaceBtn . addActionListener ( actionHandler ) ; replaceAndFindBtn = new JButton ( jEdit . getProperty ( "search.replaceAndFindBtn" ) ) ; replaceAndFindBtn . setMnemonic ( jEdit . getProperty ( "search.replaceAndFindBtn.mnemonic" ) . charAt ( 0 ) ) ; grid . add ( replaceAndFindBtn ) ; replaceAndFindBtn . addActionListener ( actionHandler ) ; replaceAllBtn = new JButton ( jEdit . getProperty ( "search.replaceAllBtn" ) ) ; replaceAllBtn . setMnemonic ( jEdit . getProperty ( "search.replaceAllBtn.mnemonic" ) . charAt ( 0 ) ) ; grid . add ( replaceAllBtn ) ; replaceAllBtn . addActionListener ( actionHandler ) ; closeBtn = new JButton ( jEdit . getProperty ( "common.close" ) ) ; grid . add ( closeBtn ) ; closeBtn . addActionListener ( actionHandler ) ; grid . setMaximumSize ( grid . getPreferredSize ( ) ) ; box . add ( grid ) ; box . add ( Box . createGlue ( ) ) ; return box ; } private void updateEnabled ( ) { boolean replaceEnabled = ! hyperSearch . isSelected ( ) ; stringReplace . setEnabled ( replaceEnabled ) ; beanShellReplace . setEnabled ( replaceEnabled ) ; replace . setEnabled ( replaceEnabled ) ; replaceBtn . setEnabled ( replaceEnabled ) ; replaceAndFindBtn . setEnabled ( replaceEnabled ) ; replaceAllBtn . setEnabled ( replaceEnabled ) ; wrap . setEnabled ( replaceEnabled ) ; boolean reverseEnabled = replaceEnabled && searchCurrentBuffer . isSelected ( ) ; searchBack . setEnabled ( reverseEnabled ) ; searchForward . setEnabled ( reverseEnabled ) ; boolean regexpEnabled = ( hyperSearch . isSelected ( ) || ! ( searchBack . isEnabled ( ) && searchBack . isSelected ( ) ) ) ; regexp . setEnabled ( regexpEnabled ) ; filter . setEnabled ( searchAllBuffers . isSelected ( ) || searchDirectory . isSelected ( ) ) ; boolean directoryEnabled = searchDirectory . isSelected ( ) ; directory . setEnabled ( directoryEnabled ) ; choose . setEnabled ( directoryEnabled ) ; searchSubDirectories . setEnabled ( directoryEnabled ) ; } private boolean save ( ) { String filter = this . filter . getText ( ) ; this . filter . addCurrentToHistory ( ) ; if ( filter . length ( ) == 0 ) filter = "*" ; SearchFileSet fileset = SearchAndReplace . getSearchFileSet ( ) ; if ( searchCurrentBuffer . isSelected ( ) ) fileset = new CurrentBufferSet ( ) ; else if ( searchAllBuffers . isSelected ( ) ) fileset = new AllBufferSet ( filter ) ; else if ( searchDirectory . isSelected ( ) ) { String directory = this . directory . getText ( ) ; this . directory . addCurrentToHistory ( ) ; boolean recurse = searchSubDirectories . isSelected ( ) ; if ( fileset instanceof DirectoryListSet ) { DirectoryListSet dset = ( DirectoryListSet ) fileset ; if ( ! dset . getDirectory ( ) . equals ( directory ) || ! dset . getFileFilter ( ) . equals ( filter ) || ! dset . isRecursive ( ) == recurse ) fileset = new DirectoryListSet ( directory , filter , recurse ) ; } else fileset = new DirectoryListSet ( directory , filter , recurse ) ; } else { fileset = null ; } jEdit . setBooleanProperty ( "search.keepDialog.toggle" , keepDialog . isSelected ( ) ) ; jEdit . setBooleanProperty ( "search.hypersearch.toggle" , hyperSearch . isSelected ( ) ) ; boolean ok = true ; if ( fileset . getBufferCount ( ) == 0 ) { GUIUtilities . error ( this , "empty-fileset" , null ) ; ok = false ; } else SearchAndReplace . setSearchFileSet ( fileset ) ; if ( find . getText ( ) . length ( ) != 0 ) { find . addCurrentToHistory ( ) ; SearchAndReplace . setSearchString ( find . getText ( ) ) ; replace . addCurrentToHistory ( ) ; SearchAndReplace . setReplaceString ( replace . getText ( ) ) ; } else ok = false ; return ok ; } private void closeOrKeepDialog ( ) { if ( keepDialog . isSelected ( ) ) return ; else { GUIUtilities . saveGeometry ( this , "search" ) ; setVisible ( false ) ; } } class MyJRadioButton extends JRadioButton { MyJRadioButton ( String label ) { super ( label ) ; } public boolean isFocusTraversable ( ) { return false ; } } class ReplaceActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { replace . setModel ( beanShellReplace . isSelected ( ) ? "replace.script" : "replace" ) ; SearchAndReplace . setBeanShellReplace ( beanShellReplace . isSelected ( ) ) ; } } class SettingsActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ignoreCase ) SearchAndReplace . setIgnoreCase ( ignoreCase . isSelected ( ) ) ; else if ( source == regexp ) SearchAndReplace . setRegexp ( regexp . isSelected ( ) ) ; else if ( source == searchBack || source == searchForward ) SearchAndReplace . setReverseSearch ( searchBack . isSelected ( ) ) ; else if ( source == wrap ) SearchAndReplace . setAutoWrapAround ( wrap . isSelected ( ) ) ; updateEnabled ( ) ; } } class MultiFileActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == choose ) { File dir = new File ( directory . getText ( ) ) ; JFileChooser chooser = new JFileChooser ( dir . getParent ( ) ) ; chooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; chooser . setSelectedFile ( dir ) ; if ( chooser . showOpenDialog ( SearchDialog . this ) == JFileChooser . APPROVE_OPTION ) directory . setText ( chooser . getSelectedFile ( ) . getPath ( ) ) ; } else { ok ( ) ; } } } class ButtonActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == closeBtn ) cancel ( ) ; else if ( source == findBtn || source == find || source == replace ) { ok ( ) ; } else if ( source == replaceBtn ) { save ( ) ; if ( SearchAndReplace . replace ( view ) ) closeOrKeepDialog ( ) ; else getToolkit ( ) . beep ( ) ; } else if ( source == replaceAndFindBtn ) { save ( ) ; if ( SearchAndReplace . replace ( view ) ) ok ( ) ; else getToolkit ( ) . beep ( ) ; } else if ( source == replaceAllBtn ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; save ( ) ; if ( SearchAndReplace . replaceAll ( view ) ) closeOrKeepDialog ( ) ; else getToolkit ( ) . beep ( ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } } } 	1	['30', '7', '0', '22', '137', '315', '7', '20', '4', '0.830140485', '1603', '0.888888889', '5', '0.958883994', '0.233333333', '2', '2', '51.53333333', '11', '2.0333', '7']
package org . gjt . sp . jedit . io ; import java . awt . Component ; import java . util . Vector ; import org . gjt . sp . jedit . jEdit ; public class FavoritesVFS extends VFS { public static final String PROTOCOL = "favorites" ; public FavoritesVFS ( ) { super ( "favorites" ) ; instance = this ; } public int getCapabilities ( ) { return DELETE_CAP ; } public String getParentOfPath ( String path ) { return PROTOCOL + ":" ; } public VFS . DirectoryEntry [ ] _listDirectory ( Object session , String url , Component comp ) { synchronized ( lock ) { VFS . DirectoryEntry [ ] retVal = new VFS . DirectoryEntry [ favorites . size ( ) ] ; for ( int i = 0 ; i < retVal . length ; i ++ ) { String favorite = ( String ) favorites . elementAt ( i ) ; retVal [ i ] = _getDirectoryEntry ( session , favorite , comp ) ; } return retVal ; } } public DirectoryEntry _getDirectoryEntry ( Object session , String path , Component comp ) { return new VFS . DirectoryEntry ( path , path , "favorites:" + path , VFS . DirectoryEntry . DIRECTORY , 0L , false ) ; } public boolean _delete ( Object session , String path , Component comp ) { synchronized ( lock ) { path = path . substring ( PROTOCOL . length ( ) + 1 ) ; favorites . removeElement ( path ) ; VFSManager . sendVFSUpdate ( this , PROTOCOL + ":" , false ) ; } return true ; } public static void loadFavorites ( ) { synchronized ( lock ) { String favorite ; int i = 0 ; while ( ( favorite = jEdit . getProperty ( "vfs.favorite." + i ) ) != null ) { favorites . addElement ( favorite ) ; i ++ ; } } } public static void addToFavorites ( String path ) { synchronized ( lock ) { favorites . addElement ( path ) ; VFSManager . sendVFSUpdate ( instance , PROTOCOL + ":" , false ) ; } } public static void saveFavorites ( ) { synchronized ( lock ) { for ( int i = 0 ; i < favorites . size ( ) ; i ++ ) { jEdit . setProperty ( "vfs.favorite." + i , ( String ) favorites . elementAt ( i ) ) ; } jEdit . unsetProperty ( "vfs.favorite." + favorites . size ( ) ) ; } } private static FavoritesVFS instance ; private static Object lock = new Object ( ) ; private static Vector favorites = new Vector ( ) ; } 	1	['10', '2', '0', '5', '28', '13', '3', '4', '9', '0.722222222', '230', '0.75', '1', '0.724137931', '0.472222222', '1', '3', '21.6', '3', '1.2', '2']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . io . File ; import org . gjt . sp . jedit . * ; public class CurrentDirectoryMenu extends EnhancedMenu { public CurrentDirectoryMenu ( ) { super ( "current-directory" ) ; } public void setPopupMenuVisible ( boolean b ) { if ( b ) { final View view = EditAction . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) removeAll ( ) ; File file = view . getBuffer ( ) . getFile ( ) ; if ( file == null ) { JMenuItem mi = new JMenuItem ( jEdit . getProperty ( "current-directory.not-local" ) ) ; mi . setEnabled ( false ) ; add ( mi ) ; super . setPopupMenuVisible ( b ) ; return ; } File dir = new File ( file . getParent ( ) ) ; JMenuItem mi = new JMenuItem ( dir . getPath ( ) ) ; mi . setEnabled ( false ) ; add ( mi ) ; addSeparator ( ) ; JMenu current = this ; ActionListener listener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { jEdit . openFile ( view , evt . getActionCommand ( ) ) ; } } ; String backupPrefix = jEdit . getProperty ( "backup.prefix" ) ; String backupSuffix = jEdit . getProperty ( "backup.suffix" ) ; String [ ] list = dir . list ( ) ; if ( list != null ) { MiscUtilities . quicksort ( list , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String name = list [ i ] ; if ( name . endsWith ( ".marks" ) ) continue ; if ( name . startsWith ( "#" ) && name . endsWith ( "#" ) ) continue ; if ( ( backupPrefix . length ( ) != 0 && name . startsWith ( backupPrefix ) ) || ( backupSuffix . length ( ) != 0 && name . endsWith ( backupSuffix ) ) ) continue ; file = new File ( dir , name ) ; if ( file . isDirectory ( ) ) continue ; mi = new JMenuItem ( name ) ; mi . setActionCommand ( file . getPath ( ) ) ; mi . addActionListener ( listener ) ; if ( current . getItemCount ( ) >= 20 ) { JMenu newCurrent = new JMenu ( jEdit . getProperty ( "common.more" ) ) ; current . add ( newCurrent ) ; current = newCurrent ; } current . add ( mi ) ; } } } super . setPopupMenuVisible ( b ) ; } } 	1	['2', '8', '0', '10', '30', '1', '2', '9', '2', '2', '175', '0', '0', '0.998835856', '0.75', '2', '3', '86.5', '15', '7.5', '3']
package org . gjt . sp . jedit . options ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import javax . swing . plaf . metal . MetalLookAndFeel ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . syntax . SyntaxStyle ; import org . gjt . sp . jedit . gui . EnhancedDialog ; import org . gjt . sp . jedit . * ; public class ColorOptionPane extends AbstractOptionPane { public static final EmptyBorder noFocusBorder = new EmptyBorder ( 1 , 1 , 1 , 1 ) ; public ColorOptionPane ( ) { super ( "color" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; add ( BorderLayout . CENTER , createColorTableScroller ( ) ) ; } protected void _save ( ) { colorModel . save ( ) ; } private ColorTableModel colorModel ; private JTable colorTable ; private JScrollPane createColorTableScroller ( ) { colorModel = createColorTableModel ( ) ; colorTable = new JTable ( colorModel ) ; colorTable . setRowSelectionAllowed ( false ) ; colorTable . setColumnSelectionAllowed ( false ) ; colorTable . setCellSelectionEnabled ( false ) ; colorTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; colorTable . addMouseListener ( new MouseHandler ( ) ) ; TableColumnModel tcm = colorTable . getColumnModel ( ) ; TableColumn colorColumn = tcm . getColumn ( 1 ) ; colorColumn . setCellRenderer ( new ColorTableModel . ColorRenderer ( ) ) ; Dimension d = colorTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 100 ) ; JScrollPane scroller = new JScrollPane ( colorTable ) ; scroller . setPreferredSize ( d ) ; return scroller ; } private ColorTableModel createColorTableModel ( ) { return new ColorTableModel ( ) ; } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { int row = colorTable . rowAtPoint ( evt . getPoint ( ) ) ; if ( row == - 1 ) return ; Color color = JColorChooser . showDialog ( ColorOptionPane . this , jEdit . getProperty ( "colorChooser.title" ) , ( Color ) colorModel . getValueAt ( row , 1 ) ) ; if ( color != null ) colorModel . setValueAt ( color , row , 1 ) ; } } } class ColorTableModel extends AbstractTableModel { private Vector colorChoices ; ColorTableModel ( ) { colorChoices = new Vector ( 16 ) ; addColorChoice ( "options.color.bgColor" , "view.bgColor" ) ; addColorChoice ( "options.color.fgColor" , "view.fgColor" ) ; addColorChoice ( "options.color.caretColor" , "view.caretColor" ) ; addColorChoice ( "options.color.selectionColor" , "view.selectionColor" ) ; addColorChoice ( "options.color.lineHighlightColor" , "view.lineHighlightColor" ) ; addColorChoice ( "options.color.bracketHighlightColor" , "view.bracketHighlightColor" ) ; addColorChoice ( "options.color.eolMarkerColor" , "view.eolMarkerColor" ) ; addColorChoice ( "options.color.wrapGuideColor" , "view.wrapGuideColor" ) ; addColorChoice ( "options.color.gutterBgColor" , "view.gutter.bgColor" ) ; addColorChoice ( "options.color.gutterFgColor" , "view.gutter.fgColor" ) ; addColorChoice ( "options.color.gutterHighlightColor" , "view.gutter.highlightColor" ) ; addColorChoice ( "options.color.gutterCurrentLineColor" , "view.gutter.currentLineColor" ) ; addColorChoice ( "options.color.gutterMarkerColor" , "view.gutter.markerColor" ) ; addColorChoice ( "options.color.gutterFoldColor" , "view.gutter.foldColor" ) ; addColorChoice ( "options.color.gutterFocusBorderColor" , "view.gutter.focusBorderColor" ) ; addColorChoice ( "options.color.gutterNoFocusBorderColor" , "view.gutter.noFocusBorderColor" ) ; if ( ! ( UIManager . getLookAndFeel ( ) instanceof MetalLookAndFeel ) ) { addColorChoice ( "options.color.dockingBorderColor" , "view.docking.borderColor" ) ; } } public int getColumnCount ( ) { return 2 ; } public int getRowCount ( ) { return colorChoices . size ( ) ; } public Object getValueAt ( int row , int col ) { ColorChoice ch = ( ColorChoice ) colorChoices . elementAt ( row ) ; switch ( col ) { case 0 : return ch . label ; case 1 : return ch . color ; default : return null ; } } public void setValueAt ( Object value , int row , int col ) { ColorChoice ch = ( ColorChoice ) colorChoices . elementAt ( row ) ; if ( col == 1 ) ch . color = ( Color ) value ; fireTableRowsUpdated ( row , row ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.color.object" ) ; case 1 : return jEdit . getProperty ( "options.color.color" ) ; default : return null ; } } public void save ( ) { for ( int i = 0 ; i < colorChoices . size ( ) ; i ++ ) { ColorChoice ch = ( ColorChoice ) colorChoices . elementAt ( i ) ; jEdit . setProperty ( ch . property , GUIUtilities . getColorHexString ( ch . color ) ) ; } } private void addColorChoice ( String label , String property ) { colorChoices . addElement ( new ColorChoice ( jEdit . getProperty ( label ) , property , GUIUtilities . parseColor ( jEdit . getProperty ( property ) ) ) ) ; } static class ColorChoice { String label ; String property ; Color color ; ColorChoice ( String label , String property , Color color ) { this . label = label ; this . property = property ; this . color = color ; } } static class ColorRenderer extends JLabel implements TableCellRenderer { public ColorRenderer ( ) { setOpaque ( true ) ; setBorder ( StyleOptionPane . noFocusBorder ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean cellHasFocus , int row , int col ) { if ( isSelected ) { setBackground ( table . getSelectionBackground ( ) ) ; setForeground ( table . getSelectionForeground ( ) ) ; } else { setBackground ( table . getBackground ( ) ) ; setForeground ( table . getForeground ( ) ) ; } if ( value != null ) setBackground ( ( Color ) value ) ; setBorder ( ( cellHasFocus ) ? UIManager . getBorder ( "Table.focusCellHighlightBorder" ) : StyleOptionPane . noFocusBorder ) ; return this ; } } } 	1	['8', '6', '0', '5', '31', '20', '2', '4', '1', '0.761904762', '123', '0.666666667', '1', '0.991017964', '0.5', '4', '12', '14', '2', '0.875', '2']
package org . gjt . sp . jedit . textarea ; import java . awt . * ; import java . awt . event . * ; import javax . swing . * ; import javax . swing . border . * ; import org . gjt . sp . jedit . * ; public class Gutter extends JComponent implements SwingConstants { public Gutter ( View view , JEditTextArea textArea ) { this . view = view ; this . textArea = textArea ; setDoubleBuffered ( true ) ; MouseHandler ml = new MouseHandler ( ) ; addMouseListener ( ml ) ; addMouseMotionListener ( ml ) ; } public void paintComponent ( Graphics gfx ) { Rectangle clip = gfx . getClipBounds ( ) ; gfx . setColor ( getBackground ( ) ) ; gfx . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; if ( ! textArea . getBuffer ( ) . isLoaded ( ) ) return ; int lineHeight = textArea . getPainter ( ) . getFontMetrics ( ) . getHeight ( ) ; int firstLine = clip . y / lineHeight + textArea . getFirstLine ( ) ; int lastLine = ( clip . y + clip . height - 1 ) / lineHeight + textArea . getFirstLine ( ) ; FontMetrics pfm = textArea . getPainter ( ) . getFontMetrics ( ) ; Color fg = getForeground ( ) ; int baseline = ( int ) ( ( this . baseline + lineHeight - pfm . getDescent ( ) ) / 2.0 ) ; boolean highlightCurrentLine = currentLineHighlightEnabled && textArea . selection . size ( ) == 0 ; int y = ( clip . y - clip . y % lineHeight ) ; Buffer buffer = textArea . getBuffer ( ) ; int firstValidLine = firstLine >= 0 ? firstLine : 0 ; int lastValidLine = ( lastLine >= buffer . getVirtualLineCount ( ) ) ? buffer . getVirtualLineCount ( ) - 1 : lastLine ; for ( int line = firstLine ; line <= lastLine ; line ++ , y += lineHeight ) { boolean valid = ( line >= firstValidLine && line <= lastValidLine ) ; if ( highlights != null ) highlights . paintHighlight ( gfx , line , y ) ; if ( ! valid ) return ; int physicalLine = buffer . virtualToPhysical ( line ) ; if ( physicalLine != buffer . getLineCount ( ) - 1 ) { if ( buffer . isFoldStart ( physicalLine ) ) { gfx . setColor ( foldColor ) ; if ( buffer . isLineVisible ( physicalLine + 1 ) ) gfx . drawRect ( 2 , y + ( lineHeight - 6 ) / 2 , 5 , 5 ) ; else gfx . fillRect ( 2 , y + ( lineHeight - 6 ) / 2 , 6 , 6 ) ; } } if ( ! expanded ) continue ; String number = Integer . toString ( physicalLine + 1 ) ; int offset ; switch ( alignment ) { case RIGHT : offset = gutterSize . width - collapsedSize . width - ( fm . stringWidth ( number ) + 1 ) ; break ; case CENTER : offset = ( ( gutterSize . width - collapsedSize . width ) - fm . stringWidth ( number ) ) / 2 ; break ; case LEFT : default : offset = 0 ; break ; } if ( physicalLine == textArea . getCaretLine ( ) && highlightCurrentLine ) { gfx . setColor ( currentLineHighlight ) ; } else if ( interval > 1 && ( line + 1 ) % interval == 0 ) gfx . setColor ( intervalHighlight ) ; else gfx . setColor ( fg ) ; gfx . drawString ( number , FOLD_MARKER_SIZE + offset , baseline + y ) ; } } public void addCustomHighlight ( TextAreaHighlight highlight ) { highlight . init ( textArea , highlights ) ; highlights = highlight ; } public void setBorder ( int width , Color color1 , Color color2 , Color color3 ) { this . borderWidth = width ; focusBorder = new CompoundBorder ( new MatteBorder ( 0 , 0 , 0 , width , color3 ) , new MatteBorder ( 0 , 0 , 0 , width , color1 ) ) ; noFocusBorder = new CompoundBorder ( new MatteBorder ( 0 , 0 , 0 , width , color3 ) , new MatteBorder ( 0 , 0 , 0 , width , color2 ) ) ; updateBorder ( ) ; } public void updateBorder ( ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( view . getEditPane ( ) == null ) return ; if ( view . getEditPane ( ) . getTextArea ( ) == textArea ) setBorder ( focusBorder ) ; else setBorder ( noFocusBorder ) ; } } ) ; } public void setBorder ( Border border ) { super . setBorder ( border ) ; if ( border == null ) { collapsedSize . width = 0 ; collapsedSize . height = 0 ; } else { Insets insets = border . getBorderInsets ( this ) ; collapsedSize . width = FOLD_MARKER_SIZE + insets . right ; collapsedSize . height = gutterSize . height = insets . top + insets . bottom ; gutterSize . width = FOLD_MARKER_SIZE + insets . right + fm . stringWidth ( "12345" ) ; } } public void setFont ( Font font ) { super . setFont ( font ) ; fm = getFontMetrics ( font ) ; baseline = fm . getAscent ( ) ; } public Color getHighlightedForeground ( ) { return intervalHighlight ; } public void setHighlightedForeground ( Color highlight ) { intervalHighlight = highlight ; } public Color getCurrentLineForeground ( ) { return currentLineHighlight ; } public void setCurrentLineForeground ( Color highlight ) { currentLineHighlight = highlight ; } public Color getFoldColor ( ) { return foldColor ; } public void setFoldColor ( Color foldColor ) { this . foldColor = foldColor ; } public Dimension getPreferredSize ( ) { if ( expanded ) return gutterSize ; else return collapsedSize ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public String getToolTipText ( MouseEvent evt ) { return ( highlights == null ) ? null : highlights . getToolTipText ( evt ) ; } public int getLineNumberAlignment ( ) { return alignment ; } public void setLineNumberAlignment ( int alignment ) { if ( this . alignment == alignment ) return ; this . alignment = alignment ; repaint ( ) ; } public boolean isExpanded ( ) { return expanded ; } public void setExpanded ( boolean expanded ) { if ( this . expanded == expanded ) return ; this . expanded = expanded ; textArea . revalidate ( ) ; } public void toggleExpanded ( ) { setExpanded ( ! expanded ) ; } public int getHighlightInterval ( ) { return interval ; } public void setHighlightInterval ( int interval ) { if ( interval <= 1 ) interval = 0 ; this . interval = interval ; repaint ( ) ; } public boolean isCurrentLineHighlightEnabled ( ) { return currentLineHighlightEnabled ; } public void setCurrentLineHighlightEnabled ( boolean enabled ) { if ( currentLineHighlightEnabled == enabled ) return ; currentLineHighlightEnabled = enabled ; repaint ( ) ; } private static final int FOLD_MARKER_SIZE = 10 ; private View view ; private JEditTextArea textArea ; private TextAreaHighlight highlights ; private int baseline ; private Dimension gutterSize = new Dimension ( 0 , 0 ) ; private Dimension collapsedSize = new Dimension ( 0 , 0 ) ; private Color intervalHighlight ; private Color currentLineHighlight ; private Color foldColor ; private FontMetrics fm ; private int alignment ; private int interval ; private boolean currentLineHighlightEnabled ; private boolean expanded ; private int borderWidth ; private Border focusBorder , noFocusBorder ; class MouseHandler implements MouseListener , MouseMotionListener { boolean drag ; int toolTipInitialDelay , toolTipReshowDelay ; public void mouseEntered ( MouseEvent e ) { ToolTipManager ttm = ToolTipManager . sharedInstance ( ) ; toolTipInitialDelay = ttm . getInitialDelay ( ) ; toolTipReshowDelay = ttm . getReshowDelay ( ) ; ttm . setInitialDelay ( 0 ) ; ttm . setReshowDelay ( 0 ) ; } public void mouseExited ( MouseEvent evt ) { ToolTipManager ttm = ToolTipManager . sharedInstance ( ) ; ttm . setInitialDelay ( toolTipInitialDelay ) ; ttm . setReshowDelay ( toolTipReshowDelay ) ; } public void mousePressed ( MouseEvent e ) { if ( e . getX ( ) < getWidth ( ) - borderWidth * 2 ) { Buffer buffer = textArea . getBuffer ( ) ; int line = e . getY ( ) / textArea . getPainter ( ) . getFontMetrics ( ) . getHeight ( ) + textArea . getFirstLine ( ) ; if ( line > buffer . getVirtualLineCount ( ) - 1 ) return ; line = buffer . virtualToPhysical ( line ) ; if ( buffer . isFoldStart ( line ) ) { if ( e . isControlDown ( ) ) { buffer . expandFoldAt ( line , true , textArea ) ; textArea . selectFoldAt ( line ) ; } else if ( buffer . isLineVisible ( line + 1 ) ) buffer . collapseFoldAt ( line ) ; else buffer . expandFoldAt ( line , e . isShiftDown ( ) , textArea ) ; } } else { e . translatePoint ( - getWidth ( ) , 0 ) ; textArea . mouseHandler . mousePressed ( e ) ; drag = true ; } } public void mouseDragged ( MouseEvent e ) { if ( drag && e . getX ( ) >= getWidth ( ) - borderWidth * 2 ) { e . translatePoint ( - getWidth ( ) , 0 ) ; textArea . mouseHandler . mouseDragged ( e ) ; } } public void mouseMoved ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { if ( drag && e . getX ( ) >= getWidth ( ) - borderWidth * 2 ) { e . translatePoint ( - getWidth ( ) , 0 ) ; textArea . mouseHandler . mouseReleased ( e ) ; } drag = false ; } public void mouseClicked ( MouseEvent e ) { } } } 	1	['30', '4', '0', '10', '73', '337', '7', '7', '25', '0.927203065', '628', '1', '3', '0.957037037', '0.127777778', '3', '18', '19.33333333', '20', '1.9', '8']
package org . gjt . sp . jedit . options ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; public class BrowserOptionPane extends AbstractOptionPane { public BrowserOptionPane ( ) { super ( "browser" ) ; } public void _init ( ) { String [ ] dirs = { jEdit . getProperty ( "options.browser.defaultPath.buffer" ) , jEdit . getProperty ( "options.browser.defaultPath.home" ) , jEdit . getProperty ( "options.browser.defaultPath.favorites" ) , jEdit . getProperty ( "options.browser.defaultPath.last" ) } ; defaultDirectory = new JComboBox ( dirs ) ; String defaultDir = jEdit . getProperty ( "vfs.browser.defaultPath" ) ; if ( "buffer" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 0 ) ; else if ( "home" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 1 ) ; else if ( "favorites" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 2 ) ; else if ( "last" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 3 ) ; addComponent ( jEdit . getProperty ( "options.browser.defaultPath" ) , defaultDirectory ) ; showIcons = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".showIcons" ) ) ; showIcons . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".showIcons" ) ) ; addComponent ( showIcons ) ; showHiddenFiles = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".showHiddenFiles" ) ) ; showHiddenFiles . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".showHiddenFiles" ) ) ; addComponent ( showHiddenFiles ) ; sortFiles = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".sortFiles" ) ) ; sortFiles . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".sortFiles" ) ) ; addComponent ( sortFiles ) ; sortIgnoreCase = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".sortIgnoreCase" ) ) ; sortIgnoreCase . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".sortIgnoreCase" ) ) ; addComponent ( sortIgnoreCase ) ; sortMixFilesAndDirs = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".sortMixFilesAndDirs" ) ) ; sortMixFilesAndDirs . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".sortMixFilesAndDirs" ) ) ; addComponent ( sortMixFilesAndDirs ) ; doubleClickClose = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".doubleClickClose" ) ) ; doubleClickClose . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".doubleClickClose" ) ) ; addComponent ( doubleClickClose ) ; currentBufferFilter = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".currentBufferFilter" ) ) ; currentBufferFilter . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".currentBufferFilter" ) ) ; addComponent ( currentBufferFilter ) ; } public void _save ( ) { String [ ] dirs = { "buffer" , "home" , "favorites" , "last" } ; jEdit . setProperty ( "vfs.browser.defaultPath" , dirs [ defaultDirectory . getSelectedIndex ( ) ] ) ; jEdit . setBooleanProperty ( "vfs.browser.showIcons" , showIcons . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.showHiddenFiles" , showHiddenFiles . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.sortFiles" , sortFiles . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.sortIgnoreCase" , sortIgnoreCase . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.sortMixFilesAndDirs" , sortMixFilesAndDirs . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.doubleClickClose" , doubleClickClose . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.currentBufferFilter" , currentBufferFilter . isSelected ( ) ) ; } private JComboBox defaultDirectory ; private JCheckBox showIcons ; private JCheckBox showHiddenFiles ; private JCheckBox sortFiles ; private JCheckBox sortIgnoreCase ; private JCheckBox sortMixFilesAndDirs ; private JCheckBox doubleClickClose ; private JCheckBox currentBufferFilter ; } 	1	['3', '6', '0', '3', '17', '1', '1', '2', '3', '0.5', '263', '1', '0', '0.996987952', '1', '2', '4', '84', '5', '2', '2']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; public class EnhancedMenuItem extends JMenuItem { public EnhancedMenuItem ( String label , EditAction action ) { super ( label ) ; this . action = action ; if ( action != null ) { setEnabled ( true ) ; addActionListener ( new EditAction . Wrapper ( action ) ) ; shortcutProp1 = action . getName ( ) + ".shortcut" ; shortcutProp2 = action . getName ( ) + ".shortcut2" ; } else setEnabled ( false ) ; } public Dimension getPreferredSize ( ) { Dimension d = super . getPreferredSize ( ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { d . width += ( getFontMetrics ( acceleratorFont ) . stringWidth ( shortcut ) + 10 ) ; } return d ; } public void paint ( Graphics g ) { super . paint ( g ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { g . setFont ( acceleratorFont ) ; g . setColor ( getModel ( ) . isArmed ( ) ? acceleratorSelectionForeground : acceleratorForeground ) ; FontMetrics fm = g . getFontMetrics ( ) ; Insets insets = getInsets ( ) ; g . drawString ( shortcut , getWidth ( ) - ( fm . stringWidth ( shortcut ) + insets . right + insets . left ) , getFont ( ) . getSize ( ) + ( insets . top - 1 ) ) ; } } private String shortcutProp1 ; private String shortcutProp2 ; private EditAction action ; private static Font acceleratorFont ; private static Color acceleratorForeground ; private static Color acceleratorSelectionForeground ; private String getShortcut ( ) { if ( action == null ) return null ; else { String shortcut1 = jEdit . getProperty ( shortcutProp1 ) ; String shortcut2 = jEdit . getProperty ( shortcutProp2 ) ; if ( shortcut1 == null || shortcut1 . length ( ) == 0 ) { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return null ; else return shortcut2 ; } else { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return shortcut1 ; else return shortcut1 + " or " + shortcut2 ; } } } static { acceleratorFont = UIManager . getFont ( "MenuItem.acceleratorFont" ) ; acceleratorFont = new Font ( "Monospaced" , acceleratorFont . getStyle ( ) , acceleratorFont . getSize ( ) ) ; acceleratorForeground = UIManager . getColor ( "MenuItem.acceleratorForeground" ) ; acceleratorSelectionForeground = UIManager . getColor ( "MenuItem.acceleratorSelectionForeground" ) ; } } 	1	['5', '6', '0', '5', '33', '2', '2', '3', '3', '0.458333333', '191', '1', '1', '0.996240602', '0.4375', '2', '11', '36', '8', '2.6', '2']
package org . gjt . sp . util ; import javax . swing . event . EventListenerList ; import javax . swing . SwingUtilities ; public class WorkThreadPool { public WorkThreadPool ( String name , int count ) { listenerList = new EventListenerList ( ) ; if ( count != 0 ) { threadGroup = new ThreadGroup ( name ) ; threads = new WorkThread [ count ] ; for ( int i = 0 ; i < threads . length ; i ++ ) { threads [ i ] = new WorkThread ( this , threadGroup , name + " #" + ( i + 1 ) ) ; } } else Log . log ( Log . WARNING , this , "Async I/O disabled" ) ; } public void start ( ) { if ( threads != null ) { for ( int i = 0 ; i < threads . length ; i ++ ) { threads [ i ] . start ( ) ; } } } public void addWorkRequest ( Runnable run , boolean inAWT ) { if ( threads == null ) { run . run ( ) ; return ; } if ( inAWT && requestCount == 0 && awtRequestCount == 0 ) { if ( SwingUtilities . isEventDispatchThread ( ) ) run . run ( ) ; else SwingUtilities . invokeLater ( run ) ; return ; } Request request = new Request ( run ) ; synchronized ( lock ) { if ( inAWT ) { if ( firstAWTRequest == null && lastAWTRequest == null ) firstAWTRequest = lastAWTRequest = request ; else { lastAWTRequest . next = request ; lastAWTRequest = request ; } awtRequestCount ++ ; if ( requestCount == 0 ) queueAWTRunner ( ) ; } else { if ( firstRequest == null && lastRequest == null ) firstRequest = lastRequest = request ; else { lastRequest . next = request ; lastRequest = request ; } requestCount ++ ; } lock . notify ( ) ; } } public void waitForRequests ( ) { if ( threads == null ) return ; synchronized ( waitForAllLock ) { while ( requestCount != 0 ) { try { waitForAllLock . wait ( ) ; } catch ( InterruptedException ie ) { Log . log ( Log . ERROR , this , ie ) ; } } } if ( SwingUtilities . isEventDispatchThread ( ) ) { doAWTRequests ( ) ; } else { try { SwingUtilities . invokeAndWait ( new RunRequestsInAWTThread ( ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } } } public int getRequestCount ( ) { return requestCount ; } public int getThreadCount ( ) { if ( threads == null ) return 0 ; else return threads . length ; } public WorkThread getThread ( int index ) { return threads [ index ] ; } public final void addProgressListener ( WorkThreadProgressListener listener ) { listenerList . add ( WorkThreadProgressListener . class , listener ) ; } public final void removeProgressListener ( WorkThreadProgressListener listener ) { listenerList . remove ( WorkThreadProgressListener . class , listener ) ; } Object lock = new String ( "Work thread pool request queue lock" ) ; Object waitForAllLock = new String ( "Work thread pool waitForAll() notifier" ) ; void fireProgressChanged ( WorkThread thread ) { final Object [ ] listeners = listenerList . getListenerList ( ) ; if ( listeners . length != 0 ) { int index = 0 ; for ( int i = 0 ; i < threads . length ; i ++ ) { if ( threads [ i ] == thread ) { index = i ; break ; } } final int _index = index ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { for ( int i = listeners . length - 2 ; i >= 0 ; i -- ) { if ( listeners [ i ] == WorkThreadProgressListener . class ) { ( ( WorkThreadProgressListener ) listeners [ i + 1 ] ) . progressUpdate ( WorkThreadPool . this , _index ) ; } } } } ) ; } } void requestDone ( ) { synchronized ( lock ) { requestCount -- ; if ( requestCount == 0 && firstAWTRequest != null ) queueAWTRunner ( ) ; } } Request getNextRequest ( ) { synchronized ( lock ) { Request request = firstRequest ; if ( request == null ) return null ; firstRequest = firstRequest . next ; if ( firstRequest == null ) lastRequest = null ; if ( request . alreadyRun ) throw new InternalError ( "AIEE!!! Request run twice!!! " + request . run ) ; request . alreadyRun = true ; return request ; } } private ThreadGroup threadGroup ; private WorkThread [ ] threads ; private Request firstRequest ; private Request lastRequest ; private int requestCount ; private boolean awtRunnerQueued ; private Request firstAWTRequest ; private Request lastAWTRequest ; private int awtRequestCount ; private EventListenerList listenerList ; private void doAWTRequests ( ) { while ( firstAWTRequest != null ) { doAWTRequest ( getNextAWTRequest ( ) ) ; } } private void doAWTRequest ( Request request ) { try { request . run . run ( ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , WorkThread . class , "Exception " + "in AWT thread:" ) ; Log . log ( Log . ERROR , WorkThread . class , t ) ; } awtRequestCount -- ; } private void queueAWTRunner ( ) { if ( ! awtRunnerQueued ) { awtRunnerQueued = true ; SwingUtilities . invokeLater ( new RunRequestsInAWTThread ( ) ) ; } } private Request getNextAWTRequest ( ) { synchronized ( lock ) { Request request = firstAWTRequest ; firstAWTRequest = firstAWTRequest . next ; if ( firstAWTRequest == null ) lastAWTRequest = null ; if ( request . alreadyRun ) throw new InternalError ( "AIEE!!! Request run twice!!! " + request . run ) ; request . alreadyRun = true ; return request ; } } static int ID ; static class Request { int id = ++ ID ; Runnable run ; boolean alreadyRun ; Request next ; Request ( Runnable run ) { this . run = run ; } public String toString ( ) { return "[id=" + id + ",run=" + run + "]" ; } } class RunRequestsInAWTThread implements Runnable { public void run ( ) { awtRunnerQueued = false ; doAWTRequests ( ) ; } } } 	1	['22', '1', '0', '12', '51', '129', '11', '6', '9', '0.873015873', '593', '0.8', '5', '0', '0.140909091', '0', '0', '25.27272727', '11', '2.6818', '1']
package org . gjt . sp . jedit . browser ; import javax . swing . event . * ; import javax . swing . tree . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Enumeration ; import java . util . Vector ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . * ; public class BrowserView extends JPanel { public BrowserView ( VFSBrowser browser ) { this . browser = browser ; currentlyLoadingTreeNode = rootNode = new DefaultMutableTreeNode ( null , true ) ; model = new DefaultTreeModel ( rootNode , true ) ; tree = new BrowserJTree ( model ) ; tree . setCellRenderer ( renderer ) ; tree . setEditable ( false ) ; tree . addTreeExpansionListener ( new TreeHandler ( ) ) ; tree . putClientProperty ( "JTree.lineStyle" , "Angled" ) ; if ( browser . isMultipleSelectionEnabled ( ) ) tree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . DISCONTIGUOUS_TREE_SELECTION ) ; else tree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . SINGLE_TREE_SELECTION ) ; setLayout ( new BorderLayout ( ) ) ; scroller = new JScrollPane ( tree ) ; scroller . setPreferredSize ( new Dimension ( 0 , 200 ) ) ; add ( BorderLayout . CENTER , scroller ) ; propertiesChanged ( ) ; } public VFS . DirectoryEntry [ ] getSelectedFiles ( ) { Vector selected = new Vector ( tree . getSelectionCount ( ) ) ; TreePath [ ] paths = tree . getSelectionPaths ( ) ; if ( paths == null ) return new VFS . DirectoryEntry [ 0 ] ; for ( int i = 0 ; i < paths . length ; i ++ ) { DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) paths [ i ] . getLastPathComponent ( ) ; Object obj = treeNode . getUserObject ( ) ; if ( obj instanceof VFS . DirectoryEntry ) selected . addElement ( obj ) ; } VFS . DirectoryEntry [ ] retVal = new VFS . DirectoryEntry [ selected . size ( ) ] ; selected . copyInto ( retVal ) ; return retVal ; } public void selectNone ( ) { tree . setSelectionPaths ( new TreePath [ 0 ] ) ; } public void directoryLoaded ( Vector directory ) { if ( currentlyLoadingTreeNode == rootNode ) rootNode . setUserObject ( browser . getDirectory ( ) ) ; currentlyLoadingTreeNode . removeAllChildren ( ) ; if ( directory != null ) { for ( int i = 0 ; i < directory . size ( ) ; i ++ ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) directory . elementAt ( i ) ; boolean allowsChildren = ( file . type != VFS . DirectoryEntry . FILE ) ; currentlyLoadingTreeNode . add ( new DefaultMutableTreeNode ( file , allowsChildren ) ) ; } } model . reload ( currentlyLoadingTreeNode ) ; tree . expandPath ( new TreePath ( currentlyLoadingTreeNode . getPath ( ) ) ) ; currentlyLoadingTreeNode = rootNode ; timer . stop ( ) ; typeSelectBuffer . setLength ( 0 ) ; } public void updateFileView ( ) { tree . repaint ( ) ; } public void reloadDirectory ( String path ) { String browserDir = browser . getDirectory ( ) ; if ( browserDir . startsWith ( FavoritesVFS . PROTOCOL ) ) reloadDirectory ( rootNode , path ) ; else if ( browserDir . startsWith ( FileRootsVFS . PROTOCOL ) ) { if ( ! MiscUtilities . isURL ( path ) || MiscUtilities . getProtocolOfURL ( path ) . equals ( "file" ) ) reloadDirectory ( rootNode , path ) ; } else if ( path . startsWith ( browserDir ) ) reloadDirectory ( rootNode , path ) ; } public Component getDefaultFocusComponent ( ) { return tree ; } public void propertiesChanged ( ) { showIcons = jEdit . getBooleanProperty ( "vfs.browser.showIcons" ) ; renderer . propertiesChanged ( ) ; } private VFSBrowser browser ; private JTree tree ; private JScrollPane scroller ; private DefaultTreeModel model ; private DefaultMutableTreeNode rootNode ; private DefaultMutableTreeNode currentlyLoadingTreeNode ; private BrowserPopupMenu popup ; private boolean showIcons ; private FileCellRenderer renderer = new FileCellRenderer ( ) ; private StringBuffer typeSelectBuffer = new StringBuffer ( ) ; private Timer timer = new Timer ( 0 , new ClearTypeSelect ( ) ) ; class ClearTypeSelect implements ActionListener { public void actionPerformed ( ActionEvent evt ) { typeSelectBuffer . setLength ( 0 ) ; browser . filesSelected ( ) ; } } private boolean reloadDirectory ( DefaultMutableTreeNode node , String path ) { if ( ! tree . isExpanded ( new TreePath ( node . getPath ( ) ) ) ) return false ; Object userObject = node . getUserObject ( ) ; if ( userObject instanceof String ) { if ( path . equals ( userObject ) ) { loadDirectoryNode ( node , path , false ) ; return true ; } } else if ( userObject instanceof VFS . DirectoryEntry ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) userObject ; if ( file . type == VFS . DirectoryEntry . FILE ) return false ; if ( path . equals ( file . path ) ) { loadDirectoryNode ( node , path , false ) ; return true ; } } if ( node . getChildCount ( ) != 0 ) { Enumeration children = node . children ( ) ; while ( children . hasMoreElements ( ) ) { DefaultMutableTreeNode child = ( DefaultMutableTreeNode ) children . nextElement ( ) ; if ( reloadDirectory ( child , path ) ) return true ; } } return false ; } private void loadDirectoryNode ( DefaultMutableTreeNode node , String path , boolean showLoading ) { currentlyLoadingTreeNode = node ; if ( showLoading ) { node . removeAllChildren ( ) ; node . add ( new DefaultMutableTreeNode ( new LoadingPlaceholder ( ) , false ) ) ; } model . reload ( currentlyLoadingTreeNode ) ; browser . loadDirectory ( path ) ; } private void showFilePopup ( VFS . DirectoryEntry file , Point point ) { popup = new BrowserPopupMenu ( browser , file ) ; popup . show ( tree , point . x + 1 , point . y + 1 ) ; } class BrowserJTree extends JTree { BrowserJTree ( TreeModel model ) { super ( model ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( this ) ; } public final String getToolTipText ( MouseEvent evt ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { Rectangle cellRect = getPathBounds ( path ) ; if ( cellRect != null && ! cellRectIsVisible ( cellRect ) ) return path . getLastPathComponent ( ) . toString ( ) ; } return null ; } public final Point getToolTipLocation ( MouseEvent evt ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { Rectangle cellRect = getPathBounds ( path ) ; if ( cellRect != null && ! cellRectIsVisible ( cellRect ) ) { return new Point ( cellRect . x + ( showIcons ? 20 : 1 ) , cellRect . y + ( showIcons ? 1 : - 1 ) ) ; } } return null ; } protected void processKeyEvent ( KeyEvent evt ) { if ( evt . getID ( ) == KeyEvent . KEY_PRESSED ) { switch ( evt . getKeyCode ( ) ) { case KeyEvent . VK_ENTER : browser . filesActivated ( ) ; evt . consume ( ) ; break ; case KeyEvent . VK_LEFT : if ( getMinSelectionRow ( ) == - 1 || getMinSelectionRow ( ) == 0 ) { String directory = browser . getDirectory ( ) ; browser . setDirectory ( VFSManager . getVFSForPath ( directory ) . getParentOfPath ( directory ) ) ; evt . consume ( ) ; } break ; } } else if ( evt . getID ( ) == KeyEvent . KEY_TYPED ) { typeSelectBuffer . append ( evt . getKeyChar ( ) ) ; doTypeSelect ( typeSelectBuffer . toString ( ) ) ; timer . stop ( ) ; timer . setInitialDelay ( 500 ) ; timer . setRepeats ( false ) ; timer . start ( ) ; } if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } protected void processMouseEvent ( MouseEvent evt ) { ToolTipManager ttm = ToolTipManager . sharedInstance ( ) ; switch ( evt . getID ( ) ) { case MouseEvent . MOUSE_ENTERED : toolTipInitialDelay = ttm . getInitialDelay ( ) ; toolTipReshowDelay = ttm . getReshowDelay ( ) ; ttm . setInitialDelay ( 200 ) ; ttm . setReshowDelay ( 0 ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_EXITED : ttm . setInitialDelay ( toolTipInitialDelay ) ; ttm . setReshowDelay ( toolTipReshowDelay ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_CLICKED : if ( ( evt . getModifiers ( ) & MouseEvent . BUTTON1_MASK ) != 0 ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path == null ) { super . processMouseEvent ( evt ) ; break ; } if ( ! isPathSelected ( path ) ) setSelectionPath ( path ) ; if ( evt . getClickCount ( ) == 1 ) { browser . filesSelected ( ) ; super . processMouseEvent ( evt ) ; } if ( evt . getClickCount ( ) == 2 ) { browser . filesActivated ( ) ; break ; } } else if ( GUIUtilities . isPopupTrigger ( evt ) ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_PRESSED : if ( ( evt . getModifiers ( ) & MouseEvent . BUTTON1_MASK ) != 0 ) { if ( popup != null && popup . isVisible ( ) ) popup . setVisible ( false ) ; if ( evt . getClickCount ( ) == 2 ) break ; } else if ( GUIUtilities . isPopupTrigger ( evt ) ) { if ( popup != null && popup . isVisible ( ) ) { popup . setVisible ( false ) ; break ; } TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path == null ) showFilePopup ( null , evt . getPoint ( ) ) ; else { setSelectionPath ( path ) ; browser . filesSelected ( ) ; Object userObject = ( ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( userObject instanceof VFS . DirectoryEntry ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) userObject ; showFilePopup ( file , evt . getPoint ( ) ) ; } else showFilePopup ( null , evt . getPoint ( ) ) ; } break ; } super . processMouseEvent ( evt ) ; break ; default : super . processMouseEvent ( evt ) ; break ; } } private int toolTipInitialDelay = - 1 ; private int toolTipReshowDelay = - 1 ; private boolean cellRectIsVisible ( Rectangle cellRect ) { Rectangle vr = BrowserJTree . this . getVisibleRect ( ) ; return vr . contains ( cellRect . x , cellRect . y ) && vr . contains ( cellRect . x + cellRect . width , cellRect . y + cellRect . height ) ; } private void doTypeSelect ( String str ) { if ( getSelectionCount ( ) == 0 ) doTypeSelect ( str , 0 , getRowCount ( ) ) ; else { int start = getMaxSelectionRow ( ) ; boolean retVal = doTypeSelect ( str , start , getRowCount ( ) ) ; if ( ! retVal ) { doTypeSelect ( str , 0 , start ) ; } } } private boolean doTypeSelect ( String str , int start , int end ) { for ( int i = start ; i < end ; i ++ ) { DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) getPathForRow ( i ) . getLastPathComponent ( ) ; Object obj = treeNode . getUserObject ( ) ; if ( obj instanceof VFS . DirectoryEntry ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) obj ; if ( file . name . regionMatches ( true , 0 , str , 0 , str . length ( ) ) ) { clearSelection ( ) ; setSelectionRow ( i ) ; scrollRowToVisible ( i ) ; return true ; } } } return false ; } } class TreeHandler implements TreeExpansionListener { public void treeExpanded ( TreeExpansionEvent evt ) { TreePath path = evt . getPath ( ) ; DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ; Object userObject = treeNode . getUserObject ( ) ; if ( userObject instanceof VFS . DirectoryEntry ) { loadDirectoryNode ( treeNode , ( ( VFS . DirectoryEntry ) userObject ) . path , true ) ; } } public void treeCollapsed ( TreeExpansionEvent evt ) { TreePath path = evt . getPath ( ) ; DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ; if ( treeNode . getUserObject ( ) instanceof VFS . DirectoryEntry ) { treeNode . removeAllChildren ( ) ; treeNode . add ( new DefaultMutableTreeNode ( new LoadingPlaceholder ( ) , false ) ) ; model . reload ( treeNode ) ; } } } class LoadingPlaceholder { } } 	1	['19', '5', '0', '13', '77', '71', '8', '10', '8', '0.813131313', '498', '1', '3', '0.973174367', '0.198830409', '0', '0', '24.63157895', '9', '2.0526', '17']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . FontSelector ; import org . gjt . sp . jedit . * ; public class PrintOptionPane extends AbstractOptionPane { public PrintOptionPane ( ) { super ( "print" ) ; } protected void _init ( ) { String _fontFamily = jEdit . getProperty ( "print.font" ) ; int _fontStyle ; try { _fontStyle = Integer . parseInt ( jEdit . getProperty ( "print.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { _fontStyle = Font . PLAIN ; } int _fontSize ; try { _fontSize = Integer . parseInt ( jEdit . getProperty ( "print.fontsize" ) ) ; } catch ( NumberFormatException nf ) { _fontSize = 14 ; } font = new FontSelector ( new Font ( _fontFamily , _fontStyle , _fontSize ) ) ; addComponent ( jEdit . getProperty ( "options.print.font" ) , font ) ; printHeader = new JCheckBox ( jEdit . getProperty ( "options.print" + ".header" ) ) ; printHeader . setSelected ( jEdit . getBooleanProperty ( "print.header" ) ) ; addComponent ( printHeader ) ; printFooter = new JCheckBox ( jEdit . getProperty ( "options.print" + ".footer" ) ) ; printFooter . setSelected ( jEdit . getBooleanProperty ( "print.footer" ) ) ; addComponent ( printFooter ) ; printLineNumbers = new JCheckBox ( jEdit . getProperty ( "options.print" + ".lineNumbers" ) ) ; printLineNumbers . setSelected ( jEdit . getBooleanProperty ( "print.lineNumbers" ) ) ; addComponent ( printLineNumbers ) ; style = new JCheckBox ( jEdit . getProperty ( "options.print" + ".style" ) ) ; style . setSelected ( jEdit . getBooleanProperty ( "print.style" ) ) ; addComponent ( style ) ; color = new JCheckBox ( jEdit . getProperty ( "options.print" + ".color" ) ) ; color . setSelected ( jEdit . getBooleanProperty ( "print.color" ) ) ; addComponent ( color ) ; addSeparator ( "options.print.margins" ) ; topMargin = new JTextField ( jEdit . getProperty ( "print.margin.top" ) ) ; addComponent ( jEdit . getProperty ( "options.print.margin.top" ) , topMargin ) ; leftMargin = new JTextField ( jEdit . getProperty ( "print.margin.left" ) ) ; addComponent ( jEdit . getProperty ( "options.print.margin.left" ) , leftMargin ) ; bottomMargin = new JTextField ( jEdit . getProperty ( "print.margin.bottom" ) ) ; addComponent ( jEdit . getProperty ( "options.print.margin.bottom" ) , bottomMargin ) ; rightMargin = new JTextField ( jEdit . getProperty ( "print.margin.right" ) ) ; addComponent ( jEdit . getProperty ( "options.print.margin.right" ) , rightMargin ) ; } protected void _save ( ) { Font _font = font . getFont ( ) ; jEdit . setProperty ( "print.font" , _font . getFamily ( ) ) ; jEdit . setProperty ( "print.fontsize" , String . valueOf ( _font . getSize ( ) ) ) ; jEdit . setProperty ( "print.fontstyle" , String . valueOf ( _font . getStyle ( ) ) ) ; jEdit . setBooleanProperty ( "print.header" , printHeader . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.footer" , printFooter . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.lineNumbers" , printLineNumbers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.style" , style . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.color" , color . isSelected ( ) ) ; jEdit . setProperty ( "print.margin.top" , topMargin . getText ( ) ) ; jEdit . setProperty ( "print.margin.left" , leftMargin . getText ( ) ) ; jEdit . setProperty ( "print.margin.bottom" , bottomMargin . getText ( ) ) ; jEdit . setProperty ( "print.margin.right" , rightMargin . getText ( ) ) ; } private FontSelector font ; private JCheckBox printHeader ; private JCheckBox printFooter ; private JCheckBox printLineNumbers ; private JCheckBox style ; private JCheckBox color ; private JTextField topMargin ; private JTextField leftMargin ; private JTextField bottomMargin ; private JTextField rightMargin ; } 	1	['3', '6', '0', '4', '24', '1', '1', '3', '1', '0.5', '253', '1', '1', '0.996987952', '1', '1', '3', '80', '1', '0.6667', '1']
package org . gjt . sp . jedit ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . * ; public abstract class AbstractOptionPane extends JPanel implements OptionPane { public AbstractOptionPane ( String name ) { this . name = name ; setLayout ( gridBag = new GridBagLayout ( ) ) ; } public String getName ( ) { return name ; } public Component getComponent ( ) { return this ; } public void init ( ) { if ( ! initialized ) { initialized = true ; _init ( ) ; } } public void save ( ) { if ( initialized ) _save ( ) ; } protected boolean initialized ; protected GridBagLayout gridBag ; protected int y ; protected void _init ( ) { } protected void _save ( ) { } protected void addComponent ( String label , Component comp ) { GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = 1 ; cons . weightx = 0.0f ; cons . fill = GridBagConstraints . BOTH ; JLabel l = new JLabel ( label , SwingConstants . RIGHT ) ; l . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; gridBag . setConstraints ( l , cons ) ; add ( l ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; gridBag . setConstraints ( comp , cons ) ; add ( comp ) ; } protected void addComponent ( Component comp ) { GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = cons . REMAINDER ; cons . fill = GridBagConstraints . NONE ; cons . anchor = GridBagConstraints . WEST ; cons . weightx = 1.0f ; gridBag . setConstraints ( comp , cons ) ; add ( comp ) ; } protected void addSeparator ( String label ) { Box box = new Box ( BoxLayout . X_AXIS ) ; Box box2 = new Box ( BoxLayout . Y_AXIS ) ; box2 . add ( Box . createGlue ( ) ) ; box2 . add ( new JSeparator ( JSeparator . HORIZONTAL ) ) ; box2 . add ( Box . createGlue ( ) ) ; box . add ( box2 ) ; JLabel l = new JLabel ( jEdit . getProperty ( label ) ) ; l . setMaximumSize ( l . getPreferredSize ( ) ) ; box . add ( l ) ; Box box3 = new Box ( BoxLayout . Y_AXIS ) ; box3 . add ( Box . createGlue ( ) ) ; box3 . add ( new JSeparator ( JSeparator . HORIZONTAL ) ) ; box3 . add ( Box . createGlue ( ) ) ; box . add ( box3 ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = cons . REMAINDER ; cons . fill = GridBagConstraints . BOTH ; cons . anchor = GridBagConstraints . WEST ; cons . weightx = 1.0f ; gridBag . setConstraints ( box , cons ) ; add ( box ) ; } private String name ; } 	1	['10', '5', '15', '17', '27', '29', '15', '2', '5', '0.805555556', '258', '1', '0', '0.986404834', '0.5', '0', '0', '24.4', '2', '1.1', '1']
package org . gjt . sp . jedit . syntax ; import com . microstar . xml . * ; import java . io . * ; import java . net . URL ; import java . util . Enumeration ; import java . util . Stack ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class XModeHandler extends HandlerBase { public XModeHandler ( XmlParser parser , String modeName , String path ) { this . modeName = modeName ; this . parser = parser ; this . path = path ; stateStack = new Stack ( ) ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "xmode.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "/org/gjt/sp/jedit/xmode.dtd" ) ) ) ; } catch ( Exception e ) { error ( "dtd" , e ) ; } } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { String tag = peekElement ( ) ; aname = ( aname == null ) ? null : aname . intern ( ) ; value = ( value == null ) ? null : value . intern ( ) ; if ( aname == "NAME" ) { propName = value ; } else if ( aname == "VALUE" ) { propValue = value ; } else if ( aname == "TYPE" ) { lastTokenID = stringToToken ( value ) ; } else if ( aname == "AT_LINE_START" ) { lastAtLineStart = ( isSpecified ) ? ( value == "TRUE" ) : false ; } else if ( aname == "NO_LINE_BREAK" ) { lastNoLineBreak = ( isSpecified ) ? ( value == "TRUE" ) : false ; } else if ( aname == "NO_WORD_BREAK" ) { lastNoWordBreak = ( isSpecified ) ? ( value == "TRUE" ) : false ; } else if ( aname == "EXCLUDE_MATCH" ) { lastExcludeMatch = ( isSpecified ) ? ( value == "TRUE" ) : false ; } else if ( aname == "IGNORE_CASE" ) { lastIgnoreCase = ( isSpecified ) ? ( value != "FALSE" ) : true ; } else if ( aname == "HIGHLIGHT_DIGITS" ) { lastHighlightDigits = ( isSpecified ) ? ( value != "FALSE" ) : false ; } else if ( aname == "AT_CHAR" ) { try { if ( isSpecified ) termChar = Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { error ( "termchar-invalid" , value ) ; termChar = - 1 ; } } else if ( aname == "ESCAPE" ) { lastEscape = value ; } else if ( aname == "SET" ) { lastSetName = value ; } else if ( aname == "DELEGATE" ) { lastDelegateSet = value ; } else if ( aname == "DEFAULT" ) { lastDefaultID = stringToToken ( value ) ; } } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "MODE" . equalsIgnoreCase ( name ) ) return ; error ( "doctype-invalid" , name ) ; } public void charData ( char [ ] c , int off , int len ) { String tag = peekElement ( ) ; String text = new String ( c , off , len ) ; if ( tag == "WHITESPACE" || tag == "EOL_SPAN" || tag == "MARK_PREVIOUS" || tag == "MARK_FOLLOWING" || tag == "SEQ" || tag == "BEGIN" ) { lastStart = text ; } else if ( tag == "END" ) { lastEnd = text ; } else { lastKeyword = text ; } } public void startElement ( String tag ) { tag = pushElement ( tag ) ; if ( tag == "MODE" ) { mode = jEdit . getMode ( modeName ) ; if ( mode == null ) { mode = new Mode ( modeName ) ; jEdit . addMode ( mode ) ; } } else if ( tag == "KEYWORDS" ) { keywords = new KeywordMap ( true ) ; } else if ( tag == "RULES" ) { rules = new ParserRuleSet ( ) ; rules . setIgnoreCase ( lastIgnoreCase ) ; rules . setHighlightDigits ( lastHighlightDigits ) ; rules . setEscape ( lastEscape ) ; rules . setDefault ( lastDefaultID ) ; } } public void endElement ( String name ) { if ( name == null ) return ; String tag = popElement ( ) ; if ( name . equalsIgnoreCase ( tag ) ) { if ( tag == "MODE" ) { mode . init ( ) ; mode . setTokenMarker ( marker ) ; } else if ( tag == "PROPERTY" ) { try { mode . setProperty ( propName , new Integer ( propValue ) ) ; } catch ( NumberFormatException nf ) { mode . setProperty ( propName , propValue ) ; } } else if ( tag == "KEYWORDS" ) { keywords . setIgnoreCase ( lastIgnoreCase ) ; lastIgnoreCase = true ; } else if ( tag == "RULES" ) { rules . setKeywords ( keywords ) ; marker . addRuleSet ( lastSetName , rules ) ; keywords = null ; lastSetName = null ; lastEscape = null ; lastIgnoreCase = true ; lastHighlightDigits = false ; lastDefaultID = Token . NULL ; rules = null ; } else if ( tag == "TERMINATE" ) { setTerminateChar ( termChar ) ; termChar = - 1 ; } else if ( tag == "WHITESPACE" ) { if ( lastStart == null ) { error ( "empty-tag" , "WHITESPACE" ) ; return ; } addRule ( ParserRuleFactory . createWhitespaceRule ( lastStart ) ) ; lastStart = null ; lastEnd = null ; } else if ( tag == "EOL_SPAN" ) { if ( lastStart == null ) { error ( "empty-tag" , "EOL_SPAN" ) ; return ; } addRule ( ParserRuleFactory . createEOLSpanRule ( lastStart , lastTokenID , lastAtLineStart , lastExcludeMatch ) ) ; lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; lastExcludeMatch = false ; } else if ( tag == "MARK_PREVIOUS" ) { if ( lastStart == null ) { error ( "empty-tag" , "MARK_PREVIOUS" ) ; return ; } addRule ( ParserRuleFactory . createMarkPreviousRule ( lastStart , lastTokenID , lastAtLineStart , lastExcludeMatch ) ) ; lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; lastExcludeMatch = false ; } else if ( tag == "MARK_FOLLOWING" ) { if ( lastStart == null ) { error ( "empty-tag" , "MARK_FOLLOWING" ) ; return ; } addRule ( ParserRuleFactory . createMarkFollowingRule ( lastStart , lastTokenID , lastAtLineStart , lastExcludeMatch ) ) ; lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; lastExcludeMatch = false ; } else if ( tag == "SEQ" ) { if ( lastStart == null ) { error ( "empty-tag" , "SEQ" ) ; return ; } addRule ( ParserRuleFactory . createSequenceRule ( lastStart , lastTokenID , lastAtLineStart ) ) ; lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; } else if ( tag == "END" ) { if ( lastDelegateSet == null ) { addRule ( ParserRuleFactory . createSpanRule ( lastStart , lastEnd , lastTokenID , lastNoLineBreak , lastAtLineStart , lastExcludeMatch , lastNoWordBreak ) ) ; } else { if ( lastDelegateSet . indexOf ( "::" ) == - 1 ) { lastDelegateSet = modeName + "::" + lastDelegateSet ; } addRule ( ParserRuleFactory . createDelegateSpanRule ( lastStart , lastEnd , lastDelegateSet , lastTokenID , lastNoLineBreak , lastAtLineStart , lastExcludeMatch , lastNoWordBreak ) ) ; } lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; lastNoLineBreak = false ; lastExcludeMatch = false ; lastNoWordBreak = false ; lastDelegateSet = null ; } else if ( tag == "NULL" ) { addKeyword ( lastKeyword , Token . NULL ) ; } else if ( tag == "COMMENT1" ) { addKeyword ( lastKeyword , Token . COMMENT1 ) ; } else if ( tag == "COMMENT2" ) { addKeyword ( lastKeyword , Token . COMMENT2 ) ; } else if ( tag == "LITERAL1" ) { addKeyword ( lastKeyword , Token . LITERAL1 ) ; } else if ( tag == "LITERAL2" ) { addKeyword ( lastKeyword , Token . LITERAL2 ) ; } else if ( tag == "LABEL" ) { addKeyword ( lastKeyword , Token . LABEL ) ; } else if ( tag == "KEYWORD1" ) { addKeyword ( lastKeyword , Token . KEYWORD1 ) ; } else if ( tag == "KEYWORD2" ) { addKeyword ( lastKeyword , Token . KEYWORD2 ) ; } else if ( tag == "KEYWORD3" ) { addKeyword ( lastKeyword , Token . KEYWORD3 ) ; } else if ( tag == "FUNCTION" ) { addKeyword ( lastKeyword , Token . FUNCTION ) ; } else if ( tag == "MARKUP" ) { addKeyword ( lastKeyword , Token . MARKUP ) ; } else if ( tag == "OPERATOR" ) { addKeyword ( lastKeyword , Token . OPERATOR ) ; } else if ( tag == "DIGIT" ) { addKeyword ( lastKeyword , Token . DIGIT ) ; } } else { throw new InternalError ( ) ; } } public void startDocument ( ) { marker = new TokenMarker ( ) ; marker . setName ( modeName ) ; pushElement ( null ) ; } private XmlParser parser ; private String modeName ; private String path ; private TokenMarker marker ; private KeywordMap keywords ; private Mode mode ; private Stack stateStack ; private String propName ; private String propValue ; private String lastStart ; private String lastEnd ; private String lastKeyword ; private String lastSetName ; private String lastEscape ; private String lastDelegateSet ; private ParserRuleSet rules ; private byte lastDefaultID = Token . NULL ; private byte lastTokenID ; private int termChar = - 1 ; private boolean lastNoLineBreak ; private boolean lastNoWordBreak ; private boolean lastAtLineStart ; private boolean lastExcludeMatch ; private boolean lastIgnoreCase = true ; private boolean lastHighlightDigits ; private byte stringToToken ( String value ) { if ( value == "NULL" ) { return Token . NULL ; } else if ( value == "COMMENT1" ) { return Token . COMMENT1 ; } else if ( value == "COMMENT2" ) { return Token . COMMENT2 ; } else if ( value == "LITERAL1" ) { return Token . LITERAL1 ; } else if ( value == "LITERAL2" ) { return Token . LITERAL2 ; } else if ( value == "LABEL" ) { return Token . LABEL ; } else if ( value == "KEYWORD1" ) { return Token . KEYWORD1 ; } else if ( value == "KEYWORD2" ) { return Token . KEYWORD2 ; } else if ( value == "KEYWORD3" ) { return Token . KEYWORD3 ; } else if ( value == "FUNCTION" ) { return Token . FUNCTION ; } else if ( value == "MARKUP" ) { return Token . MARKUP ; } else if ( value == "OPERATOR" ) { return Token . OPERATOR ; } else if ( value == "DIGIT" ) { return Token . DIGIT ; } else if ( value == "INVALID" ) { return Token . INVALID ; } else { error ( "token-invalid" , value ) ; return Token . NULL ; } } private void addKeyword ( String k , byte id ) { if ( k == null ) { error ( "empty-keyword" ) ; return ; } if ( keywords == null ) return ; keywords . add ( k , id ) ; } private void addRule ( ParserRule r ) { rules . addRule ( r ) ; } private void setTerminateChar ( int atChar ) { rules . setTerminateChar ( atChar ) ; } private String pushElement ( String name ) { name = ( name == null ) ? null : name . intern ( ) ; stateStack . push ( name ) ; return name ; } private String peekElement ( ) { return ( String ) stateStack . peek ( ) ; } private String popElement ( ) { return ( String ) stateStack . pop ( ) ; } private void error ( String msg ) { _error ( jEdit . getProperty ( "xmode-error." + msg ) ) ; } private void error ( String msg , String subst ) { _error ( jEdit . getProperty ( "xmode-error." + msg , new String [ ] { subst } ) ) ; } private void error ( String msg , Throwable t ) { _error ( jEdit . getProperty ( "xmode-error." + msg , new String [ ] { t . toString ( ) } ) ) ; Log . log ( Log . ERROR , this , t ) ; } private void _error ( String msg ) { Object [ ] args = { path , new Integer ( parser . getLineNumber ( ) ) , new Integer ( parser . getColumnNumber ( ) ) , msg } ; GUIUtilities . error ( null , "xmode-error" , args ) ; } } 	1	['19', '2', '0', '11', '75', '123', '1', '11', '8', '0.888888889', '1106', '1', '5', '0.419354839', '0.233918129', '1', '1', '55.89473684', '33', '5.5789', '2']
package org . gjt . sp . jedit ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . JOptionPane ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . File ; import java . io . IOException ; import java . util . * ; import org . gjt . sp . jedit . browser . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . util . Log ; public class Macros { public static void message ( View view , String message ) { JOptionPane . showMessageDialog ( view , message , jEdit . getProperty ( "macro-message.title" ) , JOptionPane . INFORMATION_MESSAGE ) ; } public static void error ( View view , String message ) { JOptionPane . showMessageDialog ( view , message , jEdit . getProperty ( "macro-message.title" ) , JOptionPane . ERROR_MESSAGE ) ; } public static String input ( View view , String prompt ) { return input ( view , prompt , null ) ; } public static String input ( View view , String prompt , String defaultValue ) { return ( String ) JOptionPane . showInputDialog ( view , prompt , jEdit . getProperty ( "macro-input.title" ) , JOptionPane . QUESTION_MESSAGE , null , null , defaultValue ) ; } public static void browseSystemMacros ( View view ) { if ( userMacroPath == null ) { GUIUtilities . error ( view , "no-webstart" , null ) ; return ; } DockableWindowManager dockableWindowManager = view . getDockableWindowManager ( ) ; dockableWindowManager . addDockableWindow ( VFSBrowser . NAME ) ; final VFSBrowser browser = ( VFSBrowser ) dockableWindowManager . getDockableWindow ( VFSBrowser . NAME ) ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { browser . setDirectory ( systemMacroPath ) ; } } ) ; } public static void browseUserMacros ( View view ) { if ( userMacroPath == null ) { GUIUtilities . error ( view , "no-settings" , null ) ; return ; } DockableWindowManager dockableWindowManager = view . getDockableWindowManager ( ) ; dockableWindowManager . addDockableWindow ( VFSBrowser . NAME ) ; final VFSBrowser browser = ( VFSBrowser ) dockableWindowManager . getDockableWindow ( VFSBrowser . NAME ) ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { browser . setDirectory ( userMacroPath ) ; } } ) ; } public static void loadMacros ( ) { macroList = new Vector ( ) ; macroHierarchy = new Vector ( ) ; macroHash = new Hashtable ( ) ; if ( jEdit . getJEditHome ( ) != null ) { systemMacroPath = MiscUtilities . constructPath ( jEdit . getJEditHome ( ) , "macros" ) ; loadMacros ( macroHierarchy , "" , new File ( systemMacroPath ) ) ; } String settings = jEdit . getSettingsDirectory ( ) ; if ( settings != null ) { userMacroPath = MiscUtilities . constructPath ( settings , "macros" ) ; loadMacros ( macroHierarchy , "" , new File ( userMacroPath ) ) ; } MiscUtilities . quicksort ( macroList , new MiscUtilities . StringICaseCompare ( ) ) ; EditBus . send ( new MacrosChanged ( null ) ) ; } public static Vector getMacroHierarchy ( ) { return macroHierarchy ; } public static Vector getMacroList ( ) { return macroList ; } public static Macro getMacro ( String macro ) { return ( Macro ) macroHash . get ( macro ) ; } public static class Macro { public String name ; public String path ; public EditAction action ; public Macro ( String name , final String path ) { this . name = name ; this . path = path ; action = new EditAction ( name , false ) { public void invoke ( View view ) { lastMacro = path ; Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; BeanShell . runScript ( view , path , true , false ) ; } finally { buffer . endCompoundEdit ( ) ; } } } ; } public String toString ( ) { return name ; } } public static void recordTemporaryMacro ( View view ) { String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) { GUIUtilities . error ( view , "no-settings" , new String [ 0 ] ) ; return ; } if ( view . getMacroRecorder ( ) != null ) { GUIUtilities . error ( view , "already-recording" , new String [ 0 ] ) ; return ; } Buffer buffer = jEdit . openFile ( null , settings + File . separator + "macros" , "Temporary_Macro.bsh" , true , null ) ; if ( buffer == null ) return ; try { buffer . remove ( 0 , buffer . getLength ( ) ) ; buffer . insertString ( 0 , jEdit . getProperty ( "macro.temp.header" ) , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , Macros . class , bl ) ; } recordMacro ( view , buffer , true ) ; } public static void recordMacro ( View view ) { String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) { GUIUtilities . error ( view , "no-settings" , new String [ 0 ] ) ; return ; } if ( view . getMacroRecorder ( ) != null ) { GUIUtilities . error ( view , "already-recording" , new String [ 0 ] ) ; return ; } String name = GUIUtilities . input ( view , "record" , null ) ; if ( name == null ) return ; name = name . replace ( ' ' , '_' ) ; Buffer buffer = jEdit . openFile ( null , null , MiscUtilities . constructPath ( settings , "macros" , name + ".bsh" ) , true , null ) ; if ( buffer == null ) return ; try { buffer . remove ( 0 , buffer . getLength ( ) ) ; buffer . insertString ( 0 , jEdit . getProperty ( "macro.header" ) , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , Macros . class , bl ) ; } recordMacro ( view , buffer , false ) ; } public static void stopRecording ( View view ) { InputHandler inputHandler = view . getInputHandler ( ) ; Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder == null ) GUIUtilities . error ( view , "macro-not-recording" , null ) ; else { view . setMacroRecorder ( null ) ; if ( ! recorder . temporary ) view . setBuffer ( recorder . buffer ) ; recorder . dispose ( ) ; } } public static void runTemporaryMacro ( View view ) { String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) { GUIUtilities . error ( view , "no-settings" , new String [ 0 ] ) ; return ; } lastMacro = MiscUtilities . constructPath ( jEdit . getSettingsDirectory ( ) , "macros" , "Temporary_Macro.bsh" ) ; Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; BeanShell . runScript ( view , lastMacro , true , false ) ; } finally { buffer . endCompoundEdit ( ) ; } } public static void runLastMacro ( View view ) { if ( lastMacro == null ) view . getToolkit ( ) . beep ( ) ; else BeanShell . runScript ( view , lastMacro , true , false ) ; } private static String systemMacroPath ; private static String userMacroPath ; private static Vector macroList ; private static Vector macroHierarchy ; private static Hashtable macroHash ; private static String lastMacro ; static { EditBus . addToBus ( new MacrosEBComponent ( ) ) ; } private static void loadMacros ( Vector vector , String path , File directory ) { String [ ] macroFiles = directory . list ( ) ; if ( macroFiles == null ) return ; MiscUtilities . quicksort ( macroFiles , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < macroFiles . length ; i ++ ) { String fileName = macroFiles [ i ] ; File file = new File ( directory , fileName ) ; if ( fileName . toLowerCase ( ) . endsWith ( ".bsh" ) ) { String label = fileName . substring ( 0 , fileName . length ( ) - 4 ) ; String name = path + label ; Macro newMacro = new Macro ( name , file . getPath ( ) ) ; vector . addElement ( newMacro ) ; macroList . addElement ( newMacro ) ; macroHash . put ( name , newMacro ) ; } else if ( file . isDirectory ( ) ) { Vector submenu = new Vector ( ) ; submenu . addElement ( fileName . replace ( '_' , ' ' ) ) ; loadMacros ( submenu , path + fileName + '/' , file ) ; vector . addElement ( submenu ) ; } } } private static void recordMacro ( View view , Buffer buffer , boolean temporary ) { lastMacro = buffer . getPath ( ) ; view . setMacroRecorder ( new Recorder ( view , buffer , temporary ) ) ; view . getStatus ( ) . setMessage ( null ) ; } static class MacrosEBComponent implements EBComponent { public void handleMessage ( EBMessage msg ) { if ( msg instanceof BufferUpdate ) { BufferUpdate bmsg = ( BufferUpdate ) msg ; if ( bmsg . getWhat ( ) == BufferUpdate . DIRTY_CHANGED && ! bmsg . getBuffer ( ) . isDirty ( ) ) maybeReloadMacros ( bmsg . getBuffer ( ) . getPath ( ) ) ; } else if ( msg instanceof VFSUpdate ) { maybeReloadMacros ( ( ( VFSUpdate ) msg ) . getPath ( ) ) ; } } private void maybeReloadMacros ( String path ) { if ( File . separatorChar == '\\' || File . separatorChar == ':' ) { path = path . toLowerCase ( ) ; if ( systemMacroPath != null && path . startsWith ( systemMacroPath . toLowerCase ( ) ) ) loadMacros ( ) ; if ( userMacroPath != null && path . startsWith ( userMacroPath . toLowerCase ( ) ) ) loadMacros ( ) ; } else { if ( systemMacroPath != null && path . startsWith ( systemMacroPath ) ) loadMacros ( ) ; if ( userMacroPath != null && path . startsWith ( userMacroPath ) ) loadMacros ( ) ; } } } public static class Recorder implements EBComponent { View view ; Buffer buffer ; boolean temporary ; boolean lastWasInput ; public Recorder ( View view , Buffer buffer , boolean temporary ) { this . view = view ; this . buffer = buffer ; this . temporary = temporary ; EditBus . addToBus ( this ) ; } public void record ( String code ) { if ( lastWasInput ) { lastWasInput = false ; append ( "\");" ) ; } append ( "\n" ) ; append ( code ) ; } public void record ( int repeat , String code ) { if ( repeat == 1 ) record ( code ) ; else { record ( "for(int i = 1; i <= " + repeat + "; i++)\n" + "{\n" + code + "\n" + "}" ) ; } } public void record ( int repeat , char ch ) { if ( ch == '\n' ) record ( repeat , "textArea.userInput(\'\\n\');" ) ; else if ( ch == '\t' ) record ( repeat , "textArea.userInput(\'\\t\');" ) ; else { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < repeat ; i ++ ) buf . append ( ch ) ; String charStr = MiscUtilities . charsToEscapes ( buf . toString ( ) ) ; if ( lastWasInput ) append ( charStr ) ; else { append ( "\ntextArea.setSelectedText(\"" + charStr ) ; lastWasInput = true ; } } } public void handleMessage ( EBMessage msg ) { if ( msg instanceof BufferUpdate ) { BufferUpdate bmsg = ( BufferUpdate ) msg ; if ( bmsg . getWhat ( ) == BufferUpdate . CLOSED ) { if ( bmsg . getBuffer ( ) == buffer ) stopRecording ( view ) ; } } } private void append ( String str ) { try { buffer . insertString ( buffer . getLength ( ) , str , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } private void dispose ( ) { if ( lastWasInput ) { lastWasInput = false ; append ( "\");" ) ; } int lineCount = buffer . getDefaultRootElement ( ) . getElementCount ( ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { buffer . indentLine ( i , true , true ) ; } EditBus . removeFromBus ( this ) ; view . getStatus ( ) . setMessage ( null ) ; } } } 	1	['24', '1', '0', '29', '89', '228', '11', '24', '16', '0.900621118', '534', '1', '0', '0', '0.155279503', '0', '0', '20.95833333', '6', '1.875', '6']
package org . gjt . sp . jedit . syntax ; import javax . swing . text . * ; import java . util . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class TokenMarker { public static final int MAJOR_ACTIONS = 0x000000FF ; public static final int WHITESPACE = 1 << 0 ; public static final int SPAN = 1 << 1 ; public static final int MARK_PREVIOUS = 1 << 2 ; public static final int MARK_FOLLOWING = 1 << 3 ; public static final int EOL_SPAN = 1 << 4 ; public static final int ACTION_HINTS = 0x0000FF00 ; public static final int EXCLUDE_MATCH = 1 << 8 ; public static final int AT_LINE_START = 1 << 9 ; public static final int NO_LINE_BREAK = 1 << 10 ; public static final int NO_WORD_BREAK = 1 << 11 ; public static final int IS_ESCAPE = 1 << 12 ; public static final int DELEGATE = 1 << 13 ; public TokenMarker ( ) { ruleSets = new Hashtable ( 64 ) ; } public void addRuleSet ( String setName , ParserRuleSet rules ) { if ( rules == null ) return ; if ( setName == null ) setName = "MAIN" ; ruleSets . put ( rulePfx . concat ( setName ) , rules ) ; } public ParserRuleSet getMainRuleSet ( ) { return getRuleSet ( rulePfx + "MAIN" ) ; } public ParserRuleSet getRuleSet ( String setName ) { ParserRuleSet rules ; rules = ( ParserRuleSet ) ruleSets . get ( setName ) ; if ( rules == null && ! setName . startsWith ( rulePfx ) ) { int delim = setName . indexOf ( "::" ) ; String modeName = setName . substring ( 0 , delim ) ; Mode mode = jEdit . getMode ( modeName ) ; if ( mode == null ) { Log . log ( Log . ERROR , TokenMarker . class , "Unknown edit mode: " + modeName ) ; rules = null ; } else { TokenMarker marker = mode . getTokenMarker ( ) ; rules = marker . getRuleSet ( setName ) ; } ruleSets . put ( setName , rules ) ; } if ( rules == null ) { Log . log ( Log . ERROR , this , "Unresolved delegate target: " + setName ) ; } return rules ; } public String getName ( ) { return name ; } public void setName ( String name ) { if ( name == null ) throw new NullPointerException ( ) ; this . name = name ; rulePfx = name . concat ( "::" ) ; } public void markTokens ( Buffer . LineInfo prevInfo , Buffer . LineInfo info , Segment line ) { LineContext lastContext = ( prevInfo == null ? null : prevInfo . context ) ; if ( lastContext == null ) { lastContext = new LineContext ( null , getRuleSet ( rulePfx . concat ( "MAIN" ) ) ) ; } context = info . context ; context . parent = ( lastContext . parent == null ? null : ( LineContext ) lastContext . parent . clone ( ) ) ; context . inRule = lastContext . inRule ; context . rules = lastContext . rules ; lastOffset = lastKeyword = line . offset ; lineLength = line . count + line . offset ; int terminateChar = context . rules . getTerminateChar ( ) ; int searchLimit = ( terminateChar >= 0 && terminateChar < line . count ) ? line . offset + terminateChar : lineLength ; escaped = false ; boolean b ; boolean tempEscaped ; Segment tempPattern ; ParserRule rule ; LineContext tempContext ; for ( pos = line . offset ; pos < searchLimit ; pos ++ ) { if ( context . parent != null ) { tempContext = context ; context = context . parent ; pattern . array = context . inRule . searchChars ; pattern . count = context . inRule . sequenceLengths [ 1 ] ; pattern . offset = context . inRule . sequenceLengths [ 0 ] ; b = handleRule ( info , line , context . inRule ) ; context = tempContext ; if ( ! b ) { if ( escaped ) { escaped = false ; } else { if ( pos != lastOffset ) { if ( context . inRule == null ) { markKeyword ( info , line , lastKeyword , pos ) ; info . addToken ( pos - lastOffset , context . rules . getDefault ( ) ) ; } else if ( ( context . inRule . action & ( NO_LINE_BREAK | NO_WORD_BREAK ) ) == 0 ) { info . addToken ( pos - lastOffset , context . inRule . token ) ; } else { info . addToken ( pos - lastOffset , Token . INVALID ) ; } } context = ( LineContext ) context . parent ; if ( ( context . inRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; } else { info . addToken ( pattern . count , context . inRule . token ) ; } context . inRule = null ; lastKeyword = lastOffset = pos + pattern . count ; } pos += ( pattern . count - 1 ) ; continue ; } } if ( ( rule = context . rules . getEscapeRule ( ) ) != null ) { tempPattern = pattern ; pattern = context . rules . getEscapePattern ( ) ; tempEscaped = escaped ; b = handleRule ( info , line , rule ) ; pattern = tempPattern ; if ( ! b ) { if ( tempEscaped ) escaped = false ; continue ; } } rule = context . inRule ; if ( rule != null && ( rule . action & SPAN ) == SPAN ) { pattern . array = rule . searchChars ; pattern . count = rule . sequenceLengths [ 1 ] ; pattern . offset = rule . sequenceLengths [ 0 ] ; if ( ! handleRule ( info , line , rule ) || ( rule . action & SOFT_SPAN ) == 0 ) { escaped = false ; continue ; } } rule = context . rules . getRules ( line . array [ pos ] ) ; while ( rule != null ) { pattern . array = rule . searchChars ; if ( context . inRule == rule && ( rule . action & SPAN ) == SPAN ) { pattern . count = rule . sequenceLengths [ 1 ] ; pattern . offset = rule . sequenceLengths [ 0 ] ; } else { pattern . count = rule . sequenceLengths [ 0 ] ; pattern . offset = 0 ; } if ( ! handleRule ( info , line , rule ) ) break ; rule = rule . next ; } escaped = false ; } if ( context . inRule == null ) markKeyword ( info , line , lastKeyword , lineLength ) ; if ( lastOffset != lineLength ) { if ( context . inRule == null ) { info . addToken ( lineLength - lastOffset , context . rules . getDefault ( ) ) ; } else if ( ( context . inRule . action & SPAN ) == SPAN && ( context . inRule . action & ( NO_LINE_BREAK | NO_WORD_BREAK ) ) != 0 ) { info . addToken ( lineLength - lastOffset , Token . INVALID ) ; context . inRule = null ; } else { info . addToken ( lineLength - lastOffset , context . inRule . token ) ; if ( ( context . inRule . action & MARK_FOLLOWING ) == MARK_FOLLOWING ) { context . inRule = null ; } } } info . context = context ; } private static final int SOFT_SPAN = MARK_FOLLOWING | NO_WORD_BREAK ; private String name ; private String rulePfx ; private Hashtable ruleSets ; private LineContext context ; private Segment pattern = new Segment ( new char [ 0 ] , 0 , 0 ) ; private int lastOffset ; private int lastKeyword ; private int lineLength ; private int pos ; private boolean escaped ; private boolean handleRule ( Buffer . LineInfo info , Segment line , ParserRule checkRule ) { if ( pattern . count == 0 ) return true ; if ( lineLength - pos < pattern . count ) return true ; char a , b ; for ( int k = 0 ; k < pattern . count ; k ++ ) { a = pattern . array [ pattern . offset + k ] ; b = line . array [ pos + k ] ; if ( ! ( a == b || context . rules . getIgnoreCase ( ) && ( Character . toLowerCase ( a ) == b || a == Character . toLowerCase ( b ) ) ) ) return true ; } if ( escaped ) { pos += pattern . count - 1 ; return false ; } else if ( ( checkRule . action & IS_ESCAPE ) == IS_ESCAPE ) { escaped = true ; pos += pattern . count - 1 ; return false ; } if ( context . inRule != checkRule && context . inRule != null && ( context . inRule . action & SOFT_SPAN ) != 0 ) { if ( ( context . inRule . action & NO_WORD_BREAK ) == NO_WORD_BREAK ) { info . addToken ( pos - lastOffset , Token . INVALID ) ; } else { info . addToken ( pos - lastOffset , context . inRule . token ) ; } lastOffset = lastKeyword = pos ; context . inRule = null ; } if ( context . inRule == null ) { if ( ( checkRule . action & AT_LINE_START ) == AT_LINE_START ) { if ( ( ( ( checkRule . action & MARK_PREVIOUS ) != 0 ) ? lastKeyword : pos ) != line . offset ) { return true ; } } markKeyword ( info , line , lastKeyword , pos ) ; if ( ( checkRule . action & MARK_PREVIOUS ) != MARK_PREVIOUS ) { lastKeyword = pos + pattern . count ; if ( ( checkRule . action & WHITESPACE ) == WHITESPACE ) { return false ; } if ( lastOffset < pos ) { info . addToken ( pos - lastOffset , context . rules . getDefault ( ) ) ; } } switch ( checkRule . action & MAJOR_ACTIONS ) { case 0 : info . addToken ( pattern . count , checkRule . token ) ; lastOffset = pos + pattern . count ; break ; case SPAN : context . inRule = checkRule ; if ( ( checkRule . action & DELEGATE ) != DELEGATE ) { if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; lastOffset = pos + pattern . count ; } else { lastOffset = pos ; } } else { String setName = new String ( checkRule . searchChars , checkRule . sequenceLengths [ 0 ] + checkRule . sequenceLengths [ 1 ] , checkRule . sequenceLengths [ 2 ] ) ; ParserRuleSet delegateSet = getRuleSet ( setName ) ; if ( delegateSet != null ) { if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; } else { info . addToken ( pattern . count , checkRule . token ) ; } lastOffset = pos + pattern . count ; context = new LineContext ( delegateSet , context ) ; } } break ; case EOL_SPAN : if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; info . addToken ( lineLength - ( pos + pattern . count ) , checkRule . token ) ; } else { info . addToken ( lineLength - pos , checkRule . token ) ; } lastOffset = lineLength ; lastKeyword = lineLength ; pos = lineLength ; return false ; case MARK_PREVIOUS : if ( lastKeyword > lastOffset ) { info . addToken ( lastKeyword - lastOffset , context . rules . getDefault ( ) ) ; lastOffset = lastKeyword ; } if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pos - lastOffset , checkRule . token ) ; info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; } else { info . addToken ( pos - lastOffset + pattern . count , checkRule . token ) ; } lastOffset = pos + pattern . count ; break ; case MARK_FOLLOWING : context . inRule = checkRule ; if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; lastOffset = pos + pattern . count ; } else { lastOffset = pos ; } break ; default : throw new InternalError ( "Unhandled major action" ) ; } lastKeyword = lastOffset ; pos += ( pattern . count - 1 ) ; return false ; } else if ( ( checkRule . action & SPAN ) == SPAN ) { if ( ( checkRule . action & DELEGATE ) != DELEGATE ) { context . inRule = null ; if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pos - lastOffset , checkRule . token ) ; info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; } else { info . addToken ( ( pos + pattern . count ) - lastOffset , checkRule . token ) ; } lastKeyword = lastOffset = pos + pattern . count ; pos += ( pattern . count - 1 ) ; } return false ; } return true ; } private void markKeyword ( Buffer . LineInfo info , Segment line , int start , int end ) { KeywordMap keywords = context . rules . getKeywords ( ) ; int len = end - start ; if ( context . rules . getHighlightDigits ( ) ) { boolean digit = true ; char [ ] array = line . array ; boolean octal = false ; boolean hex = false ; boolean seenSomeDigits = false ; loop : for ( int i = 0 ; i < len ; i ++ ) { char ch = array [ start + i ] ; switch ( ch ) { case '0' : if ( i == 0 ) octal = true ; seenSomeDigits = true ; continue loop ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : seenSomeDigits = true ; continue loop ; case 'x' : case 'X' : if ( octal && i == 1 ) { hex = true ; continue loop ; } else break ; case 'd' : case 'D' : if ( hex ) continue loop ; else break ; case 'f' : case 'F' : if ( hex || seenSomeDigits ) continue loop ; else break ; case 'l' : case 'L' : if ( seenSomeDigits ) continue loop ; else break ; case 'e' : case 'E' : if ( seenSomeDigits ) continue loop ; else break ; case 'a' : case 'A' : case 'b' : case 'B' : case 'c' : case 'C' : if ( hex ) continue loop ; else break ; case '.' : case '-' : continue loop ; default : break ; } digit = false ; break loop ; } if ( digit ) { if ( start != lastOffset ) { info . addToken ( start - lastOffset , context . rules . getDefault ( ) ) ; } info . addToken ( len , Token . DIGIT ) ; lastKeyword = lastOffset = end ; return ; } } if ( keywords != null ) { byte id = keywords . lookup ( line , start , len ) ; if ( id != Token . NULL ) { if ( start != lastOffset ) { info . addToken ( start - lastOffset , context . rules . getDefault ( ) ) ; } info . addToken ( len , id ) ; lastKeyword = lastOffset = end ; } } } public static class LineContext { public LineContext parent ; public ParserRule inRule ; public ParserRuleSet rules ; public LineContext ( ParserRule r , ParserRuleSet rs ) { inRule = r ; rules = rs ; } public LineContext ( ParserRuleSet rs , LineContext lc ) { rules = rs ; parent = ( lc == null ? null : ( LineContext ) lc . clone ( ) ) ; } public LineContext ( ParserRule r ) { inRule = r ; } public LineContext ( ) { } public Object clone ( ) { LineContext lc = new LineContext ( ) ; lc . inRule = inRule ; lc . rules = rules ; lc . parent = ( parent == null ) ? null : ( LineContext ) parent . clone ( ) ; return lc ; } } } 	1	['10', '1', '0', '10', '46', '9', '4', '8', '7', '0.951111111', '1441', '0.48', '1', '0', '0.314285714', '0', '0', '140.6', '32', '8.5', '1']
package org . gjt . sp . jedit . search ; import javax . swing . text . BadLocationException ; import javax . swing . text . Segment ; import javax . swing . JOptionPane ; import java . awt . Component ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . msg . SearchSettingsChanged ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class SearchAndReplace { public static void setSearchString ( String search ) { if ( search . equals ( SearchAndReplace . search ) ) return ; SearchAndReplace . search = search ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static String getSearchString ( ) { return search ; } public static void setReplaceString ( String replace ) { if ( replace . equals ( SearchAndReplace . replace ) ) return ; SearchAndReplace . replace = replace ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static String getReplaceString ( ) { return replace ; } public static void setIgnoreCase ( boolean ignoreCase ) { if ( ignoreCase == SearchAndReplace . ignoreCase ) return ; SearchAndReplace . ignoreCase = ignoreCase ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getIgnoreCase ( ) { return ignoreCase ; } public static void setRegexp ( boolean regexp ) { if ( regexp == SearchAndReplace . regexp ) return ; SearchAndReplace . regexp = regexp ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getRegexp ( ) { return regexp ; } public static void setReverseSearch ( boolean reverse ) { if ( reverse == SearchAndReplace . reverse ) return ; SearchAndReplace . reverse = reverse ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getReverseSearch ( ) { return reverse ; } public static void setBeanShellReplace ( boolean beanshell ) { if ( beanshell == SearchAndReplace . beanshell ) return ; SearchAndReplace . beanshell = beanshell ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getBeanShellReplace ( ) { return beanshell ; } public static void setAutoWrapAround ( boolean wrap ) { if ( wrap == SearchAndReplace . wrap ) return ; SearchAndReplace . wrap = wrap ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getAutoWrapAround ( ) { return wrap ; } public static void setSearchMatcher ( SearchMatcher matcher ) { SearchAndReplace . matcher = matcher ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static SearchMatcher getSearchMatcher ( ) throws Exception { return getSearchMatcher ( true ) ; } public static SearchMatcher getSearchMatcher ( boolean reverseOK ) throws Exception { reverseOK &= ( fileset instanceof CurrentBufferSet ) ; if ( matcher != null && ( reverseOK || ! reverse ) ) return matcher ; if ( search == null || "" . equals ( search ) ) return null ; String replace = ( SearchAndReplace . replace == null ? "" : SearchAndReplace . replace ) ; String replaceMethod ; if ( beanshell && replace . length ( ) != 0 ) { replaceMethod = BeanShell . cacheBlock ( "replace" , "return (" + replace + ");" , false ) ; } else replaceMethod = null ; if ( regexp ) matcher = new RESearchMatcher ( search , replace , ignoreCase , beanshell , replaceMethod ) ; else { matcher = new BoyerMooreSearchMatcher ( search , replace , ignoreCase , reverse && reverseOK , beanshell , replaceMethod ) ; } return matcher ; } public static void setSearchFileSet ( SearchFileSet fileset ) { SearchAndReplace . fileset = fileset ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static SearchFileSet getSearchFileSet ( ) { return fileset ; } public static boolean hyperSearch ( View view ) { record ( view , "hyperSearch(view)" , false , true ) ; view . getDockableWindowManager ( ) . addDockableWindow ( HyperSearchResults . NAME ) ; final HyperSearchResults results = ( HyperSearchResults ) view . getDockableWindowManager ( ) . getDockableWindow ( HyperSearchResults . NAME ) ; results . searchStarted ( ) ; try { VFSManager . runInWorkThread ( new HyperSearchRequest ( view , getSearchMatcher ( false ) , results ) ) ; return true ; } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; return false ; } } public static boolean find ( View view ) { boolean repeat = false ; Buffer buffer = fileset . getNextBuffer ( view , null ) ; try { SearchMatcher matcher = getSearchMatcher ( true ) ; if ( matcher == null ) { view . getToolkit ( ) . beep ( ) ; return false ; } record ( view , "find(view)" , false , true ) ; view . showWaitCursor ( ) ; loop : for ( ; ; ) { while ( buffer != null ) { if ( ! buffer . isLoaded ( ) ) VFSManager . waitForRequests ( ) ; int start ; if ( view . getBuffer ( ) == buffer && ! repeat ) { JEditTextArea textArea = view . getTextArea ( ) ; Selection s = textArea . getSelectionAtOffset ( textArea . getCaretPosition ( ) ) ; if ( s == null ) start = textArea . getCaretPosition ( ) ; else if ( reverse ) start = s . getStart ( ) ; else start = s . getEnd ( ) ; } else if ( reverse ) start = buffer . getLength ( ) ; else start = 0 ; if ( find ( view , buffer , start ) ) return true ; buffer = fileset . getNextBuffer ( view , buffer ) ; } if ( repeat ) { view . getToolkit ( ) . beep ( ) ; return false ; } if ( BeanShell . isScriptRunning ( ) ) break loop ; boolean restart ; if ( wrap ) { view . getStatus ( ) . setMessageAndClear ( jEdit . getProperty ( "view.status.auto-wrap" ) ) ; restart = true ; } else { Integer [ ] args = { new Integer ( reverse ? 1 : 0 ) } ; int result = GUIUtilities . confirm ( view , "keepsearching" , args , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; restart = ( result == JOptionPane . YES_OPTION ) ; } if ( restart ) { buffer = fileset . getFirstBuffer ( view ) ; repeat = true ; } else break loop ; } } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; } finally { view . hideWaitCursor ( ) ; } return false ; } public static boolean find ( final View view , final Buffer buffer , final int start ) throws Exception { SearchMatcher matcher = getSearchMatcher ( true ) ; Segment text = new Segment ( ) ; if ( reverse ) buffer . getText ( 0 , start , text ) ; else buffer . getText ( start , buffer . getLength ( ) - start , text ) ; int [ ] match = matcher . nextMatch ( text ) ; if ( match != null ) { fileset . matchFound ( buffer ) ; view . setBuffer ( buffer ) ; JEditTextArea textArea = view . getTextArea ( ) ; int matchStart = ( reverse ? 0 : start ) ; textArea . setSelection ( new Selection . Range ( matchStart + match [ 0 ] , matchStart + match [ 1 ] ) ) ; textArea . moveCaretPosition ( matchStart + match [ 1 ] ) ; return true ; } else return false ; } public static boolean replace ( View view ) { JEditTextArea textArea = view . getTextArea ( ) ; Selection [ ] selection = textArea . getSelection ( ) ; if ( selection . length == 0 ) { view . getToolkit ( ) . beep ( ) ; return false ; } record ( view , "replace(view)" , true , false ) ; Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; int retVal = 0 ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; int start = s . getStart ( ) ; retVal += _replace ( view , buffer , s . getStart ( ) , s . getEnd ( ) ) ; textArea . removeFromSelection ( s ) ; if ( s instanceof Selection . Range ) { textArea . addToSelection ( new Selection . Range ( start , s . getEnd ( ) ) ) ; } else if ( s instanceof Selection . Rect ) { textArea . addToSelection ( new Selection . Rect ( start , s . getEnd ( ) ) ) ; } } if ( retVal == 0 ) { view . getToolkit ( ) . beep ( ) ; return false ; } return true ; } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; } finally { buffer . endCompoundEdit ( ) ; } return false ; } public static boolean replace ( View view , Buffer buffer , int start , int end ) { JEditTextArea textArea = view . getTextArea ( ) ; try { int retVal = 0 ; buffer . beginCompoundEdit ( ) ; retVal += _replace ( view , buffer , start , end ) ; if ( retVal != 0 ) return true ; } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; } finally { buffer . endCompoundEdit ( ) ; } return false ; } public static boolean replaceAll ( View view ) { int fileCount = 0 ; int occurCount = 0 ; record ( view , "replaceAll(view)" , true , true ) ; view . showWaitCursor ( ) ; try { Buffer buffer = fileset . getFirstBuffer ( view ) ; do { if ( buffer . isPerformingIO ( ) ) VFSManager . waitForRequests ( ) ; try { buffer . beginCompoundEdit ( ) ; int retVal = _replace ( view , buffer , 0 , buffer . getLength ( ) ) ; if ( retVal != 0 ) { fileCount ++ ; occurCount += retVal ; fileset . matchFound ( buffer ) ; } } finally { buffer . endCompoundEdit ( ) ; } } while ( ( buffer = fileset . getNextBuffer ( view , buffer ) ) != null ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; } finally { view . hideWaitCursor ( ) ; } if ( ! BeanShell . isScriptRunning ( ) ) { Object [ ] args = { new Integer ( occurCount ) , new Integer ( fileCount ) } ; view . getStatus ( ) . setMessageAndClear ( jEdit . getProperty ( "view.status.replace-all" , args ) ) ; } return ( fileCount != 0 ) ; } public static void load ( ) { search = jEdit . getProperty ( "search.find.value" ) ; replace = jEdit . getProperty ( "search.replace.value" ) ; ignoreCase = jEdit . getBooleanProperty ( "search.ignoreCase.toggle" ) ; regexp = jEdit . getBooleanProperty ( "search.regexp.toggle" ) ; reverse = jEdit . getBooleanProperty ( "search.reverse.toggle" ) ; beanshell = jEdit . getBooleanProperty ( "search.beanshell.toggle" ) ; wrap = jEdit . getBooleanProperty ( "search.wrap.toggle" ) ; String filesetCode = jEdit . getProperty ( "search.fileset.value" ) ; if ( filesetCode != null ) { fileset = ( SearchFileSet ) BeanShell . eval ( null , filesetCode , true ) ; } if ( fileset == null ) fileset = new CurrentBufferSet ( ) ; } public static void save ( ) { jEdit . setProperty ( "search.find.value" , search ) ; jEdit . setProperty ( "search.replace.value" , replace ) ; jEdit . setBooleanProperty ( "search.ignoreCase.toggle" , ignoreCase ) ; jEdit . setBooleanProperty ( "search.regexp.toggle" , regexp ) ; jEdit . setBooleanProperty ( "search.reverse.toggle" , reverse ) ; jEdit . setBooleanProperty ( "search.beanshell.toggle" , beanshell ) ; jEdit . setBooleanProperty ( "search.wrap.toggle" , wrap ) ; String code = fileset . getCode ( ) ; if ( code != null ) jEdit . setProperty ( "search.fileset.value" , code ) ; else jEdit . unsetProperty ( "search.fileset.value" ) ; } private static String search ; private static String replace ; private static boolean regexp ; private static boolean ignoreCase ; private static boolean reverse ; private static boolean beanshell ; private static boolean wrap ; private static SearchMatcher matcher ; private static SearchFileSet fileset ; private static void record ( View view , String action , boolean replaceAction , boolean recordFileSet ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) { recorder . record ( "SearchAndReplace.setSearchString(\"" + MiscUtilities . charsToEscapes ( search ) + "\");" ) ; if ( replaceAction ) { recorder . record ( "SearchAndReplace.setReplaceString(\"" + MiscUtilities . charsToEscapes ( replace ) + "\");" ) ; recorder . record ( "SearchAndReplace.setBeanShellReplace(" + beanshell + ");" ) ; } else { recorder . record ( "SearchAndReplace.setAutoWrapAround(" + wrap + ");" ) ; recorder . record ( "SearchAndReplace.setReverseSearch(" + reverse + ");" ) ; } recorder . record ( "SearchAndReplace.setIgnoreCase(" + ignoreCase + ");" ) ; recorder . record ( "SearchAndReplace.setRegexp(" + regexp + ");" ) ; if ( recordFileSet ) { recorder . record ( "SearchAndReplace.setSearchFileSet(" + fileset . getCode ( ) + ");" ) ; } recorder . record ( "SearchAndReplace." + action + ";" ) ; } } private static int _replace ( View view , Buffer buffer , int start , int end ) throws Exception { if ( ! buffer . isEditable ( ) ) return 0 ; SearchMatcher matcher = getSearchMatcher ( false ) ; if ( matcher == null ) return 0 ; int occurCount = 0 ; Segment text = new Segment ( ) ; int offset = start ; loop : for ( ; ; ) { buffer . getText ( offset , end - offset , text ) ; int [ ] occur = matcher . nextMatch ( text ) ; if ( occur == null ) break loop ; int _start = occur [ 0 ] ; int _length = occur [ 1 ] - occur [ 0 ] ; String found = new String ( text . array , text . offset + _start , _length ) ; String subst = matcher . substitute ( found ) ; if ( subst != null ) { buffer . remove ( offset + _start , _length ) ; buffer . insertString ( offset + _start , subst , null ) ; occurCount ++ ; offset += _start + subst . length ( ) ; end += ( subst . length ( ) - found . length ( ) ) ; } else offset += _start + _length ; } return occurCount ; } } 	1	['31', '1', '0', '34', '108', '197', '9', '27', '28', '0.64', '1228', '1', '2', '0', '0.112903226', '0', '0', '38.29032258', '23', '3.129', '9']
package org . gjt . sp . jedit . options ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . syntax . SyntaxStyle ; import org . gjt . sp . jedit . gui . EnhancedDialog ; import org . gjt . sp . jedit . * ; public class StyleOptionPane extends AbstractOptionPane { public static final EmptyBorder noFocusBorder = new EmptyBorder ( 1 , 1 , 1 , 1 ) ; public StyleOptionPane ( ) { super ( "style" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; add ( BorderLayout . CENTER , createStyleTableScroller ( ) ) ; } protected void _save ( ) { styleModel . save ( ) ; } private StyleTableModel styleModel ; private JTable styleTable ; private JScrollPane createStyleTableScroller ( ) { styleModel = createStyleTableModel ( ) ; styleTable = new JTable ( styleModel ) ; styleTable . setRowSelectionAllowed ( false ) ; styleTable . setColumnSelectionAllowed ( false ) ; styleTable . setCellSelectionEnabled ( false ) ; styleTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; styleTable . addMouseListener ( new MouseHandler ( ) ) ; TableColumnModel tcm = styleTable . getColumnModel ( ) ; TableColumn styleColumn = tcm . getColumn ( 1 ) ; styleColumn . setCellRenderer ( new StyleTableModel . StyleRenderer ( ) ) ; Dimension d = styleTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 100 ) ; JScrollPane scroller = new JScrollPane ( styleTable ) ; scroller . setPreferredSize ( d ) ; return scroller ; } private StyleTableModel createStyleTableModel ( ) { return new StyleTableModel ( ) ; } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { int row = styleTable . rowAtPoint ( evt . getPoint ( ) ) ; if ( row == - 1 ) return ; SyntaxStyle style = new StyleEditor ( StyleOptionPane . this , ( SyntaxStyle ) styleModel . getValueAt ( row , 1 ) ) . getStyle ( ) ; if ( style != null ) styleModel . setValueAt ( style , row , 1 ) ; } } } class StyleTableModel extends AbstractTableModel { private Vector styleChoices ; StyleTableModel ( ) { styleChoices = new Vector ( 13 ) ; addStyleChoice ( "options.style.comment1Style" , "view.style.comment1" ) ; addStyleChoice ( "options.style.comment2Style" , "view.style.comment2" ) ; addStyleChoice ( "options.style.literal1Style" , "view.style.literal1" ) ; addStyleChoice ( "options.style.literal2Style" , "view.style.literal2" ) ; addStyleChoice ( "options.style.labelStyle" , "view.style.label" ) ; addStyleChoice ( "options.style.keyword1Style" , "view.style.keyword1" ) ; addStyleChoice ( "options.style.keyword2Style" , "view.style.keyword2" ) ; addStyleChoice ( "options.style.keyword3Style" , "view.style.keyword3" ) ; addStyleChoice ( "options.style.functionStyle" , "view.style.function" ) ; addStyleChoice ( "options.style.markupStyle" , "view.style.markup" ) ; addStyleChoice ( "options.style.operatorStyle" , "view.style.operator" ) ; addStyleChoice ( "options.style.digitStyle" , "view.style.digit" ) ; addStyleChoice ( "options.style.invalidStyle" , "view.style.invalid" ) ; } public int getColumnCount ( ) { return 2 ; } public int getRowCount ( ) { return styleChoices . size ( ) ; } public Object getValueAt ( int row , int col ) { StyleChoice ch = ( StyleChoice ) styleChoices . elementAt ( row ) ; switch ( col ) { case 0 : return ch . label ; case 1 : return ch . style ; default : return null ; } } public void setValueAt ( Object value , int row , int col ) { StyleChoice ch = ( StyleChoice ) styleChoices . elementAt ( row ) ; if ( col == 1 ) ch . style = ( SyntaxStyle ) value ; fireTableRowsUpdated ( row , row ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.style.object" ) ; case 1 : return jEdit . getProperty ( "options.style.style" ) ; default : return null ; } } public void save ( ) { for ( int i = 0 ; i < styleChoices . size ( ) ; i ++ ) { StyleChoice ch = ( StyleChoice ) styleChoices . elementAt ( i ) ; jEdit . setProperty ( ch . property , GUIUtilities . getStyleString ( ch . style ) ) ; } } private void addStyleChoice ( String label , String property ) { styleChoices . addElement ( new StyleChoice ( jEdit . getProperty ( label ) , property , GUIUtilities . parseStyle ( jEdit . getProperty ( property ) , "Dialog" , 12 ) ) ) ; } static class StyleChoice { String label ; String property ; SyntaxStyle style ; StyleChoice ( String label , String property , SyntaxStyle style ) { this . label = label ; this . property = property ; this . style = style ; } } static class StyleRenderer extends JLabel implements TableCellRenderer { public StyleRenderer ( ) { setOpaque ( true ) ; setBorder ( StyleOptionPane . noFocusBorder ) ; setText ( "Hello World" ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean cellHasFocus , int row , int col ) { if ( value != null ) { SyntaxStyle style = ( SyntaxStyle ) value ; setForeground ( style . getForegroundColor ( ) ) ; if ( style . getBackgroundColor ( ) != null ) setBackground ( style . getBackgroundColor ( ) ) ; else { setBackground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ; } setFont ( style . getFont ( ) ) ; } setBorder ( ( cellHasFocus ) ? UIManager . getBorder ( "Table.focusCellHighlightBorder" ) : StyleOptionPane . noFocusBorder ) ; return this ; } } } class StyleEditor extends EnhancedDialog implements ActionListener { StyleEditor ( Component comp , SyntaxStyle style ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "style-editor.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; panel . add ( italics = new JCheckBox ( jEdit . getProperty ( "style-editor.italics" ) ) ) ; italics . setSelected ( style . getFont ( ) . isItalic ( ) ) ; panel . add ( Box . createHorizontalStrut ( 2 ) ) ; panel . add ( bold = new JCheckBox ( jEdit . getProperty ( "style-editor.bold" ) ) ) ; bold . setSelected ( style . getFont ( ) . isBold ( ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; panel . add ( new JLabel ( jEdit . getProperty ( "style-editor.fgColor" ) ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; panel . add ( fgColor = new JButton ( "    " ) ) ; fgColor . setBackground ( style . getForegroundColor ( ) ) ; fgColor . setRequestFocusEnabled ( false ) ; fgColor . addActionListener ( this ) ; fgColor . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; panel . add ( new JLabel ( jEdit . getProperty ( "style-editor.bgColor" ) ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; panel . add ( bgColor = new JButton ( "    " ) ) ; if ( style . getBackgroundColor ( ) == null ) bgColor . setBackground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ; else bgColor . setBackground ( style . getBackgroundColor ( ) ) ; bgColor . setRequestFocusEnabled ( false ) ; bgColor . addActionListener ( this ) ; bgColor . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; content . add ( BorderLayout . CENTER , panel ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; box . add ( ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; ok . addActionListener ( this ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; box . add ( cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ) ; cancel . addActionListener ( this ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; Dimension screen = getToolkit ( ) . getScreenSize ( ) ; pack ( ) ; setLocationRelativeTo ( JOptionPane . getFrameForComponent ( comp ) ) ; show ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; else if ( source == fgColor || source == bgColor ) { JButton b = ( JButton ) source ; Color c = JColorChooser . showDialog ( this , jEdit . getProperty ( "colorChooser.title" ) , b . getBackground ( ) ) ; if ( c != null ) b . setBackground ( c ) ; } } public void ok ( ) { okClicked = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public SyntaxStyle getStyle ( ) { if ( ! okClicked ) return null ; Color background = bgColor . getBackground ( ) ; if ( background . equals ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ) background = null ; return new SyntaxStyle ( fgColor . getBackground ( ) , background , new Font ( "Dialog" , ( italics . isSelected ( ) ? Font . ITALIC : 0 ) | ( bold . isSelected ( ) ? Font . BOLD : 0 ) , 12 ) ) ; } private JCheckBox italics ; private JCheckBox bold ; private JButton fgColor ; private JButton bgColor ; private JButton ok ; private JButton cancel ; private boolean okClicked ; } 	1	['8', '6', '0', '6', '31', '20', '4', '4', '1', '0.761904762', '123', '0.666666667', '1', '0.991017964', '0.5', '4', '12', '14', '2', '0.875', '1']
package org . gjt . sp . jedit . pluginmgr ; import com . microstar . xml . * ; import java . io . * ; import java . util . Stack ; import org . gjt . sp . util . Log ; class PluginListHandler extends HandlerBase { PluginListHandler ( PluginList pluginList , String path ) { this . pluginList = pluginList ; this . path = path ; stateStack = new Stack ( ) ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "plugins.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "/org/gjt/sp/jedit/pluginmgr/plugins.dtd" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error while opening" + " plugins.dtd:" ) ; Log . log ( Log . ERROR , this , e ) ; } } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { aname = ( aname == null ) ? null : aname . intern ( ) ; value = ( value == null ) ? null : value . intern ( ) ; if ( aname == "NAME" ) name = value ; else if ( aname == "JAR" ) jar = value ; else if ( aname == "VERSION" ) version = value ; else if ( aname == "DATE" ) date = value ; else if ( aname == "OBSOLETE" ) obsolete = ( "TRUE" . equals ( value ) ) ; else if ( aname == "WHAT" ) depWhat = value ; else if ( aname == "FROM" ) depFrom = value ; else if ( aname == "TO" ) depTo = value ; else if ( aname == "PLUGIN" ) depPlugin = value ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "PLUGINS" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , path + ": DOCTYPE must be PLUGINS" ) ; } public void charData ( char [ ] c , int off , int len ) { String tag = peekElement ( ) ; String text = new String ( c , off , len ) ; if ( tag == "DESCRIPTION" ) { description = text ; } else if ( tag == "PLUGIN_SET_ENTRY" ) pluginSetEntry = text ; else if ( tag == "AUTHOR" ) { if ( author != null && author . length ( ) != 0 ) author = author + ", " + text ; else author = text ; } else if ( tag == "DOWNLOAD" ) download = text ; else if ( tag == "DOWNLOAD_SOURCE" ) downloadSource = text ; } public void startElement ( String tag ) { tag = pushElement ( tag ) ; if ( tag == "PLUGIN_SET" ) { description = null ; pluginSet = new PluginList . PluginSet ( ) ; } else if ( tag == "PLUGIN" ) { description = null ; author = null ; branch = null ; plugin = new PluginList . Plugin ( ) ; } else if ( tag == "BRANCH" ) { download = null ; branch = new PluginList . Branch ( ) ; } } public void endElement ( String tag ) { if ( tag == null ) return ; else tag = tag . intern ( ) ; popElement ( ) ; if ( tag == "PLUGIN_SET" ) { pluginList . addPluginSet ( pluginSet ) ; pluginSet = null ; pluginSetEntry = null ; } else if ( tag == "PLUGIN_SET_ENTRY" ) { pluginSet . plugins . addElement ( pluginSetEntry ) ; pluginSetEntry = null ; } else if ( tag == "PLUGIN" ) { plugin . jar = jar ; plugin . name = name ; plugin . author = author ; plugin . description = description ; pluginList . addPlugin ( plugin ) ; jar = null ; name = null ; author = null ; } else if ( tag == "BRANCH" ) { branch . version = version ; branch . date = date ; branch . download = download ; branch . downloadSource = downloadSource ; branch . obsolete = obsolete ; plugin . branches . addElement ( branch ) ; version = null ; download = null ; obsolete = false ; } else if ( tag == "DEPEND" ) { PluginList . Dependency dep = new PluginList . Dependency ( depWhat , depFrom , depTo , depPlugin ) ; branch . deps . addElement ( dep ) ; depWhat = null ; depFrom = null ; depTo = null ; depPlugin = null ; } } public void startDocument ( ) { try { pushElement ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void endDocument ( ) { pluginList . finished ( ) ; } private String path ; private PluginList pluginList ; private PluginList . PluginSet pluginSet ; private String pluginSetEntry ; private PluginList . Plugin plugin ; private String jar ; private String author ; private PluginList . Branch branch ; private boolean obsolete ; private String version ; private String date ; private String download ; private String downloadSource ; private String depWhat ; private String depFrom ; private String depTo ; private String depPlugin ; private String name ; private String description ; private Stack stateStack ; private String pushElement ( String name ) { name = ( name == null ) ? null : name . intern ( ) ; stateStack . push ( name ) ; return name ; } private String peekElement ( ) { return ( String ) stateStack . peek ( ) ; } private String popElement ( ) { return ( String ) stateStack . pop ( ) ; } } 	1	['12', '2', '0', '7', '38', '38', '1', '7', '8', '0.863636364', '470', '1', '4', '0.541666667', '0.319444444', '1', '3', '36.5', '12', '3.3333', '1']
package org . gjt . sp . jedit ; import java . awt . event . ActionEvent ; import java . awt . * ; public class BeanShellAction extends EditAction { public BeanShellAction ( String name , boolean plugin , String code , String isSelected , boolean noRepeat , boolean noRecord ) { super ( name , plugin ) ; this . code = code ; this . isSelected = isSelected ; this . noRepeat = noRepeat ; this . noRecord = noRecord ; sanitizedName = name . replace ( '.' , '_' ) . replace ( '-' , '_' ) ; } public void invoke ( View view ) { if ( cachedCode == null ) { String cachedCodeName = "action_" + sanitizedName ; cachedCode = BeanShell . cacheBlock ( cachedCodeName , code , true ) ; } BeanShell . runCachedBlock ( cachedCode , view , null ) ; } public boolean isToggle ( ) { return isSelected != null ; } public boolean isSelected ( View view ) { if ( isSelected == null ) return false ; if ( cachedIsSelected == null ) { String cachedIsSelectedName = "selected_" + sanitizedName ; cachedIsSelected = BeanShell . cacheBlock ( cachedIsSelectedName , isSelected , true ) ; } return Boolean . TRUE . equals ( BeanShell . runCachedBlock ( cachedIsSelected , view , null ) ) ; } public boolean noRepeat ( ) { return noRepeat ; } public boolean noRecord ( ) { return noRecord ; } public String getCode ( ) { return code . trim ( ) ; } private boolean noRepeat ; private boolean noRecord ; private String code ; private String isSelected ; private String cachedCode ; private String cachedIsSelected ; private String sanitizedName ; } 	1	['7', '2', '0', '5', '16', '3', '1', '4', '7', '0.80952381', '115', '1', '0', '0.7', '0.392857143', '1', '1', '14.42857143', '3', '1.4286', '1']
package org . gjt . sp . jedit ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import javax . swing . text . * ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . util . * ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . search . SearchBar ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class View extends JFrame implements EBComponent { public DockableWindowManager getDockableWindowManager ( ) { return dockableWindowManager ; } public void quickIncrementalSearch ( ) { if ( searchBar == null ) { getToolkit ( ) . beep ( ) ; return ; } String text = getTextArea ( ) . getSelectedText ( ) ; if ( text != null && text . indexOf ( '\n' ) != - 1 ) text = null ; searchBar . setHyperSearch ( false ) ; searchBar . getField ( ) . setText ( text ) ; searchBar . getField ( ) . selectAll ( ) ; searchBar . getField ( ) . requestFocus ( ) ; } public void quickHyperSearch ( ) { if ( searchBar == null ) { getToolkit ( ) . beep ( ) ; return ; } String text = getTextArea ( ) . getSelectedText ( ) ; if ( text != null && text . indexOf ( '\n' ) != - 1 ) text = null ; searchBar . setHyperSearch ( true ) ; searchBar . getField ( ) . setText ( text ) ; searchBar . getField ( ) . selectAll ( ) ; searchBar . getField ( ) . requestFocus ( ) ; } public final SearchBar getSearchBar ( ) { return searchBar ; } public KeyListener getKeyEventInterceptor ( ) { return keyEventInterceptor ; } public void setKeyEventInterceptor ( KeyListener listener ) { this . keyEventInterceptor = listener ; } public InputHandler getInputHandler ( ) { return inputHandler ; } public void setInputHandler ( InputHandler inputHandler ) { this . inputHandler = inputHandler ; } public Macros . Recorder getMacroRecorder ( ) { return recorder ; } public void setMacroRecorder ( Macros . Recorder recorder ) { this . recorder = recorder ; } public StatusBar getStatus ( ) { return status ; } public void splitHorizontally ( ) { split ( JSplitPane . VERTICAL_SPLIT ) ; } public void splitVertically ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } public void split ( int orientation ) { editPane . saveCaretInfo ( ) ; EditPane oldEditPane = editPane ; setEditPane ( createEditPane ( oldEditPane . getBuffer ( ) ) ) ; editPane . loadCaretInfo ( ) ; JComponent oldParent = ( JComponent ) oldEditPane . getParent ( ) ; if ( oldParent instanceof JSplitPane ) { JSplitPane oldSplitPane = ( JSplitPane ) oldParent ; int dividerPos = oldSplitPane . getDividerLocation ( ) ; Component left = oldSplitPane . getLeftComponent ( ) ; final JSplitPane newSplitPane = new JSplitPane ( orientation , oldEditPane , editPane ) ; newSplitPane . setBorder ( null ) ; if ( left == oldEditPane ) oldSplitPane . setLeftComponent ( newSplitPane ) ; else oldSplitPane . setRightComponent ( newSplitPane ) ; oldSplitPane . setDividerLocation ( dividerPos ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { newSplitPane . setDividerLocation ( 0.5 ) ; editPane . focusOnTextArea ( ) ; } } ) ; } else { JSplitPane newSplitPane = splitPane = new JSplitPane ( orientation , oldEditPane , editPane ) ; newSplitPane . setBorder ( null ) ; oldParent . add ( splitPane ) ; oldParent . revalidate ( ) ; Dimension size ; if ( oldParent instanceof JSplitPane ) size = oldParent . getSize ( ) ; else size = oldEditPane . getSize ( ) ; newSplitPane . setDividerLocation ( ( ( orientation == JSplitPane . VERTICAL_SPLIT ) ? size . height : size . width ) / 2 ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { editPane . focusOnTextArea ( ) ; } } ) ; } } public void unsplit ( ) { if ( splitPane != null ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { EditPane _editPane = editPanes [ i ] ; if ( editPane != _editPane ) _editPane . close ( ) ; } JComponent parent = ( JComponent ) splitPane . getParent ( ) ; parent . remove ( splitPane ) ; parent . add ( editPane ) ; parent . revalidate ( ) ; splitPane = null ; updateTitle ( ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { editPane . focusOnTextArea ( ) ; } } ) ; } public void nextTextArea ( ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPane == editPanes [ i ] ) { if ( i == editPanes . length - 1 ) editPanes [ 0 ] . focusOnTextArea ( ) ; else editPanes [ i + 1 ] . focusOnTextArea ( ) ; break ; } } } public void prevTextArea ( ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPane == editPanes [ i ] ) { if ( i == 0 ) editPanes [ editPanes . length - 1 ] . focusOnTextArea ( ) ; else editPanes [ i - 1 ] . focusOnTextArea ( ) ; break ; } } } public JSplitPane getSplitPane ( ) { return splitPane ; } public Buffer getBuffer ( ) { return editPane . getBuffer ( ) ; } public void setBuffer ( Buffer buffer ) { editPane . setBuffer ( buffer ) ; } public JEditTextArea getTextArea ( ) { return editPane . getTextArea ( ) ; } public EditPane getEditPane ( ) { return editPane ; } public EditPane [ ] getEditPanes ( ) { if ( splitPane == null ) { EditPane [ ] ep = { editPane } ; return ep ; } else { Vector vec = new Vector ( ) ; getEditPanes ( vec , splitPane ) ; EditPane [ ] ep = new EditPane [ vec . size ( ) ] ; vec . copyInto ( ep ) ; return ep ; } } public String getSplitConfig ( ) { StringBuffer splitConfig = new StringBuffer ( ) ; splitConfig . append ( getBuffer ( ) . getPath ( ) ) ; return splitConfig . toString ( ) ; } public void updateGutterBorders ( ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) editPanes [ i ] . getTextArea ( ) . getGutter ( ) . updateBorder ( ) ; } public void addToolBar ( Component toolBar ) { toolBars . add ( toolBar ) ; getRootPane ( ) . revalidate ( ) ; } public void removeToolBar ( Component toolBar ) { toolBars . remove ( toolBar ) ; getRootPane ( ) . revalidate ( ) ; } public boolean isClosed ( ) { return closed ; } public synchronized void showWaitCursor ( ) { if ( waitCount ++ == 0 ) { Cursor cursor = Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ; setCursor ( cursor ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { EditPane editPane = editPanes [ i ] ; editPane . getTextArea ( ) . getPainter ( ) . setCursor ( cursor ) ; } } } public synchronized void hideWaitCursor ( ) { if ( waitCount > 0 ) waitCount -- ; if ( waitCount == 0 ) { Cursor cursor = Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ; setCursor ( cursor ) ; cursor = Cursor . getPredefinedCursor ( Cursor . TEXT_CURSOR ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { EditPane editPane = editPanes [ i ] ; editPane . getTextArea ( ) . getPainter ( ) . setCursor ( cursor ) ; } } } public boolean isSynchroScrollEnabled ( ) { return synchroScroll ; } public void toggleSynchroScrollEnabled ( ) { setSynchroScrollEnabled ( ! synchroScroll ) ; } public void setSynchroScrollEnabled ( boolean synchroScroll ) { this . synchroScroll = synchroScroll ; JEditTextArea textArea = getTextArea ( ) ; int firstLine = textArea . getFirstLine ( ) ; int horizontalOffset = textArea . getHorizontalOffset ( ) ; synchroScrollVertical ( textArea , firstLine ) ; synchroScrollHorizontal ( textArea , horizontalOffset ) ; } public void synchroScrollVertical ( JEditTextArea textArea , int firstLine ) { if ( ! synchroScroll ) return ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPanes [ i ] . getTextArea ( ) != textArea ) editPanes [ i ] . getTextArea ( ) . _setFirstLine ( firstLine ) ; } } public void synchroScrollHorizontal ( JEditTextArea textArea , int horizontalOffset ) { if ( ! synchroScroll ) return ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPanes [ i ] . getTextArea ( ) != textArea ) editPanes [ i ] . getTextArea ( ) . _setHorizontalOffset ( horizontalOffset ) ; } } public View getNext ( ) { return next ; } public View getPrev ( ) { return prev ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof PropertiesChanged ) propertiesChanged ( ) ; else if ( msg instanceof SearchSettingsChanged ) { if ( searchBar != null ) searchBar . update ( ) ; } else if ( msg instanceof BufferUpdate ) handleBufferUpdate ( ( BufferUpdate ) msg ) ; else if ( msg instanceof EditPaneUpdate ) handleEditPaneUpdate ( ( EditPaneUpdate ) msg ) ; } public void processKeyEvent ( KeyEvent evt ) { if ( isClosed ( ) ) return ; if ( getFocusOwner ( ) instanceof JTextComponent ) { if ( evt . getID ( ) == KeyEvent . KEY_PRESSED ) { switch ( evt . getKeyCode ( ) ) { case KeyEvent . VK_BACK_SPACE : case KeyEvent . VK_TAB : case KeyEvent . VK_ENTER : return ; } } Keymap keymap = ( ( JTextComponent ) getFocusOwner ( ) ) . getKeymap ( ) ; if ( keymap . getAction ( KeyStroke . getKeyStrokeForEvent ( evt ) ) != null ) return ; } if ( evt . isConsumed ( ) ) return ; evt = KeyEventWorkaround . processKeyEvent ( evt ) ; if ( evt == null ) return ; switch ( evt . getID ( ) ) { case KeyEvent . KEY_TYPED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyTyped ( evt ) ; else if ( inputHandler . isPrefixActive ( ) ) inputHandler . keyTyped ( evt ) ; break ; case KeyEvent . KEY_PRESSED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyPressed ( evt ) ; else inputHandler . keyPressed ( evt ) ; break ; case KeyEvent . KEY_RELEASED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyReleased ( evt ) ; else inputHandler . keyReleased ( evt ) ; break ; } if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } View prev ; View next ; View ( Buffer buffer , String splitConfig ) { setIconImage ( GUIUtilities . getEditorIcon ( ) ) ; dockableWindowManager = new DockableWindowManager ( this ) ; Component comp = restoreSplitConfig ( buffer , splitConfig ) ; dockableWindowManager . add ( comp ) ; EditBus . addToBus ( this ) ; setJMenuBar ( GUIUtilities . loadMenuBar ( "view.mbar" ) ) ; toolBars = new Box ( BoxLayout . Y_AXIS ) ; inputHandler = new DefaultInputHandler ( this , ( DefaultInputHandler ) jEdit . getInputHandler ( ) ) ; propertiesChanged ( ) ; getContentPane ( ) . add ( BorderLayout . NORTH , toolBars ) ; getContentPane ( ) . add ( BorderLayout . CENTER , dockableWindowManager ) ; getContentPane ( ) . add ( BorderLayout . SOUTH , status = new StatusBar ( this ) ) ; setDefaultCloseOperation ( DO_NOTHING_ON_CLOSE ) ; addWindowListener ( new WindowHandler ( ) ) ; dockableWindowManager . init ( ) ; } void close ( ) { closed = true ; dockableWindowManager . close ( ) ; GUIUtilities . saveGeometry ( this , "view" ) ; EditBus . removeFromBus ( this ) ; dispose ( ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) editPanes [ i ] . close ( ) ; toolBars = null ; toolBar = null ; searchBar = null ; splitPane = null ; inputHandler = null ; recorder = null ; setContentPane ( new JPanel ( ) ) ; } void updateTitle ( ) { Vector buffers = new Vector ( ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { Buffer buffer = editPanes [ i ] . getBuffer ( ) ; if ( buffers . indexOf ( buffer ) == - 1 ) buffers . addElement ( buffer ) ; } StringBuffer title = new StringBuffer ( jEdit . getProperty ( "view.title" ) ) ; for ( int i = 0 ; i < buffers . size ( ) ; i ++ ) { if ( i != 0 ) title . append ( ", " ) ; Buffer buffer = ( Buffer ) buffers . elementAt ( i ) ; title . append ( ( showFullPath && ! buffer . isNewFile ( ) ) ? buffer . getPath ( ) : buffer . getName ( ) ) ; } setTitle ( title . toString ( ) ) ; } private boolean closed ; private DockableWindowManager dockableWindowManager ; private Box toolBars ; private JToolBar toolBar ; private SearchBar searchBar ; private boolean synchroScroll ; private EditPane editPane ; private JSplitPane splitPane ; private StatusBar status ; private KeyListener keyEventInterceptor ; private InputHandler inputHandler ; private Macros . Recorder recorder ; private int waitCount ; private boolean showFullPath ; private void getEditPanes ( Vector vec , Component comp ) { if ( comp instanceof EditPane ) vec . addElement ( comp ) ; else if ( comp instanceof JSplitPane ) { JSplitPane split = ( JSplitPane ) comp ; getEditPanes ( vec , split . getLeftComponent ( ) ) ; getEditPanes ( vec , split . getRightComponent ( ) ) ; } } private void getSplitConfig ( JSplitPane splitPane , StringBuffer splitConfig ) { Component left = splitPane . getLeftComponent ( ) ; if ( left instanceof JSplitPane ) getSplitConfig ( ( JSplitPane ) left , splitConfig ) ; else { splitConfig . append ( '\t' ) ; splitConfig . append ( ( ( EditPane ) left ) . getBuffer ( ) . getPath ( ) ) ; } Component right = splitPane . getRightComponent ( ) ; if ( right instanceof JSplitPane ) getSplitConfig ( ( JSplitPane ) right , splitConfig ) ; else { splitConfig . append ( '\t' ) ; splitConfig . append ( ( ( EditPane ) right ) . getBuffer ( ) . getPath ( ) ) ; } splitConfig . append ( splitPane . getOrientation ( ) == JSplitPane . VERTICAL_SPLIT ? "\tvertical" : "\thorizontal" ) ; } private Component restoreSplitConfig ( Buffer buffer , String splitConfig ) { if ( buffer != null ) return ( editPane = createEditPane ( buffer ) ) ; else if ( splitConfig == null ) return ( editPane = createEditPane ( jEdit . getFirstBuffer ( ) ) ) ; Stack stack = new Stack ( ) ; StringTokenizer st = new StringTokenizer ( splitConfig , "\t" ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( token . equals ( "vertical" ) ) { stack . push ( splitPane = new JSplitPane ( JSplitPane . VERTICAL_SPLIT , ( Component ) stack . pop ( ) , ( Component ) stack . pop ( ) ) ) ; splitPane . setBorder ( null ) ; splitPane . setDividerLocation ( 0.5 ) ; } else if ( token . equals ( "horizontal" ) ) { stack . push ( splitPane = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , ( Component ) stack . pop ( ) , ( Component ) stack . pop ( ) ) ) ; splitPane . setBorder ( null ) ; splitPane . setDividerLocation ( 0.5 ) ; } else { buffer = jEdit . getBuffer ( token ) ; if ( buffer == null ) buffer = jEdit . getFirstBuffer ( ) ; stack . push ( editPane = createEditPane ( buffer ) ) ; } } return ( Component ) stack . peek ( ) ; } private void propertiesChanged ( ) { loadToolBars ( ) ; showFullPath = jEdit . getBooleanProperty ( "view.showFullPath" ) ; updateTitle ( ) ; dockableWindowManager . propertiesChanged ( ) ; SwingUtilities . updateComponentTreeUI ( getRootPane ( ) ) ; } private void loadToolBars ( ) { if ( jEdit . getBooleanProperty ( "view.showToolbar" ) ) { if ( toolBar != null ) toolBars . remove ( toolBar ) ; toolBar = GUIUtilities . loadToolBar ( "view.toolbar" ) ; toolBar . add ( Box . createGlue ( ) ) ; toolBars . add ( toolBar , 0 ) ; getRootPane ( ) . revalidate ( ) ; } else if ( toolBar != null ) { removeToolBar ( toolBar ) ; toolBar = null ; } if ( jEdit . getBooleanProperty ( "view.showSearchbar" ) ) { if ( searchBar == null ) { searchBar = new SearchBar ( this ) ; addToolBar ( searchBar ) ; } } else if ( searchBar != null ) { removeToolBar ( searchBar ) ; searchBar = null ; } } private EditPane createEditPane ( Buffer buffer ) { EditPane editPane = new EditPane ( this , buffer ) ; JEditTextArea textArea = editPane . getTextArea ( ) ; textArea . addFocusListener ( new FocusHandler ( ) ) ; textArea . addCaretListener ( new CaretHandler ( ) ) ; textArea . addScrollListener ( new ScrollHandler ( ) ) ; EditBus . send ( new EditPaneUpdate ( editPane , EditPaneUpdate . CREATED ) ) ; return editPane ; } private void setEditPane ( EditPane editPane ) { this . editPane = editPane ; status . repaintCaretStatus ( ) ; status . updateBufferStatus ( ) ; status . updateMiscStatus ( ) ; } private void handleBufferUpdate ( BufferUpdate msg ) { Buffer buffer = msg . getBuffer ( ) ; if ( msg . getWhat ( ) == BufferUpdate . DIRTY_CHANGED ) { if ( ! buffer . isDirty ( ) ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPanes [ i ] . getBuffer ( ) == buffer ) { updateTitle ( ) ; break ; } } } } } private void handleEditPaneUpdate ( EditPaneUpdate msg ) { if ( msg . getEditPane ( ) . getView ( ) == this && msg . getWhat ( ) == EditPaneUpdate . BUFFER_CHANGED ) { status . repaintCaretStatus ( ) ; status . updateBufferStatus ( ) ; status . updateMiscStatus ( ) ; status . updateFoldStatus ( ) ; } } class CaretHandler implements CaretListener { public void caretUpdate ( CaretEvent evt ) { status . repaintCaretStatus ( ) ; status . updateMiscStatus ( ) ; } } class FocusHandler extends FocusAdapter { public void focusGained ( FocusEvent evt ) { Component comp = ( Component ) evt . getSource ( ) ; while ( ! ( comp instanceof EditPane ) ) { if ( comp == null ) return ; comp = comp . getParent ( ) ; } setEditPane ( ( EditPane ) comp ) ; } } class ScrollHandler implements ScrollListener { public void scrolledVertically ( JEditTextArea textArea ) { if ( getTextArea ( ) == textArea ) status . repaintCaretStatus ( ) ; } public void scrolledHorizontally ( JEditTextArea textArea ) { } } class WindowHandler extends WindowAdapter { boolean gotFocus ; public void windowActivated ( WindowEvent evt ) { if ( ! gotFocus ) { editPane . focusOnTextArea ( ) ; gotFocus = true ; } final Vector buffers = new Vector ( ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { Buffer buffer = ( ( EditPane ) editPanes [ i ] ) . getBuffer ( ) ; if ( buffers . contains ( buffer ) ) continue ; else buffers . addElement ( buffer ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { for ( int i = 0 ; i < buffers . size ( ) ; i ++ ) { ( ( Buffer ) buffers . elementAt ( i ) ) . checkModTime ( View . this ) ; } } } ) ; } public void windowClosing ( WindowEvent evt ) { jEdit . closeView ( View . this ) ; } } } 	1	['55', '6', '0', '109', '200', '1197', '99', '30', '40', '0.892361111', '1437', '0.875', '8', '0.922746781', '0.0784689', '1', '1', '24.83636364', '13', '2.5091', '5']
package org . gjt . sp . jedit . io ; import java . awt . Component ; import java . io . * ; import org . gjt . sp . jedit . * ; public abstract class VFS { public static final int READ_CAP = 1 << 0 ; public static final int WRITE_CAP = 1 << 1 ; public static final int BROWSE_CAP = 1 << 2 ; public static final int DELETE_CAP = 1 << 3 ; public static final int RENAME_CAP = 1 << 4 ; public static final int MKDIR_CAP = 1 << 5 ; public VFS ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public abstract int getCapabilities ( ) ; public String showBrowseDialog ( Object [ ] session , Component comp ) { return null ; } public String getFileName ( String path ) { return MiscUtilities . getFileName ( path ) ; } public String getParentOfPath ( String path ) { return null ; } public String constructPath ( String parent , String path ) { return parent + path ; } public char getFileSeparator ( ) { return '/' ; } public Object createVFSSession ( String path , Component comp ) { return new Object ( ) ; } public boolean load ( View view , Buffer buffer , String path ) { if ( ( getCapabilities ( ) & READ_CAP ) == 0 ) { VFSManager . error ( view , "vfs.not-supported.load" , new String [ ] { name } ) ; return false ; } Object session = createVFSSession ( path , view ) ; if ( session == null ) return false ; BufferIORequest request = new BufferIORequest ( BufferIORequest . LOAD , view , buffer , session , this , path ) ; if ( buffer . isTemporary ( ) ) request . run ( ) ; else VFSManager . runInWorkThread ( request ) ; return true ; } public boolean save ( View view , Buffer buffer , String path ) { if ( ( getCapabilities ( ) & WRITE_CAP ) == 0 ) { VFSManager . error ( view , "vfs.not-supported.save" , new String [ ] { name } ) ; return false ; } Object session = createVFSSession ( path , view ) ; if ( session == null ) return false ; if ( ! path . equals ( buffer . getPath ( ) ) ) buffer . getDocumentProperties ( ) . remove ( Buffer . BACKED_UP ) ; VFSManager . runInWorkThread ( new BufferIORequest ( BufferIORequest . SAVE , view , buffer , session , this , path ) ) ; return true ; } public boolean insert ( View view , Buffer buffer , String path ) { if ( ( getCapabilities ( ) & READ_CAP ) == 0 ) { VFSManager . error ( view , "vfs.not-supported.load" , new String [ ] { name } ) ; return false ; } Object session = createVFSSession ( path , view ) ; if ( session == null ) return false ; VFSManager . runInWorkThread ( new BufferIORequest ( BufferIORequest . INSERT , view , buffer , session , this , path ) ) ; return true ; } public DirectoryEntry [ ] _listDirectory ( Object session , String directory , Component comp ) throws IOException { VFSManager . error ( comp , "vfs.not-supported.list" , new String [ ] { name } ) ; return null ; } public DirectoryEntry _getDirectoryEntry ( Object session , String path , Component comp ) throws IOException { return null ; } public static class DirectoryEntry implements Serializable { public static final int FILE = 0 ; public static final int DIRECTORY = 1 ; public static final int FILESYSTEM = 2 ; public String name ; public String path ; public String deletePath ; public int type ; public long length ; public boolean hidden ; public DirectoryEntry ( String name , String path , String deletePath , int type , long length , boolean hidden ) { this . name = name ; this . path = path ; this . deletePath = deletePath ; this . type = type ; this . length = length ; this . hidden = hidden ; } public String toString ( ) { return name ; } } public boolean _delete ( Object session , String path , Component comp ) throws IOException { return false ; } public boolean _rename ( Object session , String from , String to , Component comp ) throws IOException { return false ; } public boolean _mkdir ( Object session , String directory , Component comp ) throws IOException { return false ; } public void _backup ( Object session , String path , Component comp ) throws IOException { } public InputStream _createInputStream ( Object session , String path , boolean ignoreErrors , Component comp ) throws IOException { VFSManager . error ( comp , "vfs.not-supported.load" , new String [ ] { name } ) ; return null ; } public OutputStream _createOutputStream ( Object session , String path , Component comp ) throws IOException { VFSManager . error ( comp , "vfs.not-supported.save" , new String [ ] { name } ) ; return null ; } public void _saveComplete ( Object session , Buffer buffer , Component comp ) throws IOException { } public void _endVFSSession ( Object session , Component comp ) throws IOException { } private String name ; } 	1	['22', '1', '4', '23', '36', '175', '20', '6', '22', '0.993197279', '239', '0.142857143', '0', '0', '0.392045455', '0', '0', '9.545454545', '4', '1.3182', '4']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . io . VFS ; import org . gjt . sp . jedit . * ; public class RecentFilesMenu extends EnhancedMenu { public RecentFilesMenu ( ) { super ( "recent-files" ) ; } public void setPopupMenuVisible ( boolean b ) { if ( b ) { final View view = EditAction . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) removeAll ( ) ; ActionListener actionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { jEdit . openFile ( view , evt . getActionCommand ( ) ) ; view . getStatus ( ) . setMessage ( null ) ; } } ; MouseListener mouseListener = new MouseAdapter ( ) { public void mouseEntered ( MouseEvent evt ) { view . getStatus ( ) . setMessage ( ( ( JMenuItem ) evt . getSource ( ) ) . getActionCommand ( ) ) ; } public void mouseExited ( MouseEvent evt ) { view . getStatus ( ) . setMessage ( null ) ; } } ; Vector recentVector = BufferHistory . getBufferHistory ( ) ; if ( recentVector . size ( ) == 0 ) { add ( GUIUtilities . loadMenuItem ( "no-recent" ) ) ; return ; } int recentFileCount = Math . min ( recentVector . size ( ) , Integer . parseInt ( jEdit . getProperty ( "history" ) ) ) ; for ( int i = recentVector . size ( ) - 1 ; i >= recentVector . size ( ) - recentFileCount ; i -- ) { String path = ( ( BufferHistory . Entry ) recentVector . elementAt ( i ) ) . path ; VFS vfs = VFSManager . getVFSForPath ( path ) ; JMenuItem menuItem = new JMenuItem ( vfs . getFileName ( path ) ) ; menuItem . setActionCommand ( path ) ; menuItem . addActionListener ( actionListener ) ; menuItem . addMouseListener ( mouseListener ) ; add ( menuItem ) ; } } super . setPopupMenuVisible ( b ) ; } } 	1	['2', '8', '0', '11', '23', '1', '3', '11', '2', '2', '100', '0', '0', '0.998835856', '0.75', '1', '2', '49', '7', '3.5', '1']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . Component ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . * ; public class OpenWithEncodingMenu extends EnhancedMenu { public OpenWithEncodingMenu ( ) { super ( "open-encoding" ) ; ActionListener listener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { Hashtable props = new Hashtable ( ) ; props . put ( "encoding" , evt . getActionCommand ( ) ) ; jEdit . showOpenFileDialog ( EditAction . getView ( ( Component ) evt . getSource ( ) ) , props ) ; } } ; String systemEncoding = System . getProperty ( "file.encoding" ) ; JMenuItem mi = new JMenuItem ( jEdit . getProperty ( "os-encoding" ) ) ; mi . setActionCommand ( systemEncoding ) ; mi . addActionListener ( listener ) ; add ( mi ) ; mi = new JMenuItem ( jEdit . getProperty ( "jedit-encoding" ) ) ; mi . setActionCommand ( jEdit . getProperty ( "buffer.encoding" , systemEncoding ) ) ; mi . addActionListener ( listener ) ; add ( mi ) ; addSeparator ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { mi = new JMenuItem ( st . nextToken ( ) ) ; mi . addActionListener ( listener ) ; add ( mi ) ; } addSeparator ( ) ; add ( GUIUtilities . loadMenuItem ( "other-encoding" ) ) ; } } 	1	['1', '8', '0', '4', '15', '0', '2', '4', '1', '2', '83', '0', '0', '1', '1', '0', '0', '82', '0', '0', '1']
package org . gjt . sp . jedit . search ; import javax . swing . text . Segment ; public interface SearchMatcher { int [ ] nextMatch ( Segment text ) ; String substitute ( String text ) throws Exception ; } 	1	['2', '1', '0', '4', '2', '1', '4', '0', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '2']
package org . gjt . sp . jedit . browser ; import java . io . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . MiscUtilities ; import org . gjt . sp . util . WorkRequest ; import org . gjt . sp . util . WorkThread ; public class BrowserIORequest extends WorkRequest { public static final int LIST_DIRECTORY = 0 ; public static final int DELETE = 1 ; public static final int RENAME = 2 ; public static final int MKDIR = 3 ; public BrowserIORequest ( int type , VFSBrowser browser , Object session , VFS vfs , String path1 , String path2 ) { this . type = type ; this . browser = browser ; this . session = session ; this . vfs = vfs ; this . path1 = path1 ; this . path2 = path2 ; } public void run ( ) { switch ( type ) { case LIST_DIRECTORY : listDirectory ( ) ; break ; case DELETE : delete ( ) ; break ; case RENAME : rename ( ) ; break ; case MKDIR : mkdir ( ) ; break ; } browser . endRequest ( ) ; } public String toString ( ) { String typeString ; switch ( type ) { case LIST_DIRECTORY : typeString = "LIST_DIRECTORY" ; break ; case DELETE : typeString = "DELETE" ; break ; case RENAME : typeString = "RENAME" ; break ; case MKDIR : typeString = "MKDIR" ; break ; default : typeString = "UNKNOWN!!!" ; break ; } return getClass ( ) . getName ( ) + "[type=" + typeString + ",vfs=" + vfs + ",path1=" + path1 + ",path2=" + path2 + "]" ; } private int type ; private VFSBrowser browser ; private Object session ; private VFS vfs ; private String path1 ; private String path2 ; private void listDirectory ( ) { VFS . DirectoryEntry [ ] directory = null ; String [ ] args = { path1 } ; setStatus ( jEdit . getProperty ( "vfs.status.listing-directory" , args ) ) ; try { setAbortable ( true ) ; directory = vfs . _listDirectory ( session , path1 , browser ) ; } catch ( IOException io ) { setAbortable ( false ) ; String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } catch ( WorkThread . Abort a ) { } finally { try { vfs . _endVFSSession ( session , browser ) ; } catch ( IOException io ) { setAbortable ( false ) ; String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } setAbortable ( false ) ; browser . directoryLoaded ( directory ) ; } private void delete ( ) { try { setAbortable ( true ) ; String [ ] args = { path1 } ; setStatus ( jEdit . getProperty ( "vfs.status.deleting" , args ) ) ; try { if ( ! vfs . _delete ( session , path1 , browser ) ) VFSManager . error ( browser , "vfs.browser.delete-error" , args ) ; } catch ( IOException io ) { String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } catch ( WorkThread . Abort a ) { } finally { try { vfs . _endVFSSession ( session , browser ) ; } catch ( IOException io ) { String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } } private void rename ( ) { try { setAbortable ( true ) ; String [ ] args = { path1 , path2 } ; setStatus ( jEdit . getProperty ( "vfs.status.renaming" , args ) ) ; try { VFS . DirectoryEntry file = vfs . _getDirectoryEntry ( session , path2 , browser ) ; if ( file != null ) VFSManager . error ( browser , "vfs.browser.rename-exists" , new String [ ] { path2 } ) ; else { if ( ! vfs . _rename ( session , path1 , path2 , browser ) ) VFSManager . error ( browser , "vfs.browser.rename-error" , new String [ ] { path1 } ) ; } } catch ( IOException io ) { String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } catch ( WorkThread . Abort a ) { } finally { try { vfs . _endVFSSession ( session , browser ) ; } catch ( IOException io ) { String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } } private void mkdir ( ) { try { setAbortable ( true ) ; String [ ] args = { path1 } ; setStatus ( jEdit . getProperty ( "vfs.status.mkdir" , args ) ) ; try { if ( ! vfs . _mkdir ( session , path1 , browser ) ) VFSManager . error ( browser , "vfs.browser.mkdir-error" , args ) ; } catch ( IOException io ) { args [ 0 ] = io . toString ( ) ; VFSManager . error ( browser , "ioerror" , args ) ; } } catch ( WorkThread . Abort a ) { } finally { try { vfs . _endVFSSession ( session , browser ) ; } catch ( IOException io ) { String [ ] args = { io . toString ( ) } ; VFSManager . error ( browser , "ioerror" , args ) ; } } } } 	1	['7', '2', '0', '7', '27', '0', '1', '7', '3', '0.616666667', '500', '0.6', '2', '0.454545455', '0.285714286', '0', '0', '69', '5', '3.1429', '5']
package org . gjt . sp . jedit . gui ; import org . gjt . sp . jedit . browser . VFSBrowser ; import org . gjt . sp . jedit . msg . CreateDockableWindow ; import org . gjt . sp . jedit . search . HyperSearchResults ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; public class DockableWindowManager extends JPanel { public static final String FLOATING = "floating" ; public static final String TOP = "top" ; public static final String LEFT = "left" ; public static final String BOTTOM = "bottom" ; public static final String RIGHT = "right" ; public DockableWindowManager ( View view ) { setLayout ( new DockableLayout ( ) ) ; this . view = view ; windows = new Hashtable ( ) ; top = new DockableWindowContainer . TabbedPane ( TOP ) ; left = new DockableWindowContainer . TabbedPane ( LEFT ) ; bottom = new DockableWindowContainer . TabbedPane ( BOTTOM ) ; right = new DockableWindowContainer . TabbedPane ( RIGHT ) ; add ( BorderLayout . NORTH , top ) ; add ( BorderLayout . WEST , left ) ; add ( BorderLayout . SOUTH , bottom ) ; add ( BorderLayout . EAST , right ) ; } public void init ( ) { Object [ ] dockables = EditBus . getNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST ) ; if ( dockables != null ) { for ( int i = 0 ; i < dockables . length ; i ++ ) { String name = ( String ) dockables [ i ] ; if ( jEdit . getBooleanProperty ( name + ".auto-open" ) ) addDockableWindow ( name ) ; } } top . setCollapsed ( jEdit . getBooleanProperty ( "view.dock.top.collapsed" ) ) ; left . setCollapsed ( jEdit . getBooleanProperty ( "view.dock.left.collapsed" ) ) ; bottom . setCollapsed ( jEdit . getBooleanProperty ( "view.dock.bottom.collapsed" ) ) ; right . setCollapsed ( jEdit . getBooleanProperty ( "view.dock.right.collapsed" ) ) ; } public void showDockableWindow ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry == null ) { Log . log ( Log . ERROR , this , "Unknown dockable window: " + name ) ; return ; } entry . container . showDockableWindow ( entry . win ) ; } public void addDockableWindow ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry != null ) { entry . container . showDockableWindow ( entry . win ) ; return ; } String position = jEdit . getProperty ( name + ".dock-position" , FLOATING ) ; CreateDockableWindow msg = new CreateDockableWindow ( view , name , position ) ; EditBus . send ( msg ) ; DockableWindow win = msg . getDockableWindow ( ) ; if ( win == null ) { Log . log ( Log . ERROR , this , "Unknown dockable window: " + name ) ; return ; } addDockableWindow ( win , position ) ; } public void addDockableWindow ( DockableWindow win ) { String name = win . getName ( ) ; String position = jEdit . getProperty ( name + ".dock-position" , FLOATING ) ; addDockableWindow ( win , position ) ; } public void addDockableWindow ( DockableWindow win , String position ) { String name = win . getName ( ) ; if ( windows . get ( name ) != null ) { throw new IllegalArgumentException ( "This DockableWindowManager" + " already has a window named " + name ) ; } DockableWindowContainer container ; if ( position . equals ( FLOATING ) ) container = new DockableWindowContainer . Floating ( this ) ; else { if ( position . equals ( TOP ) ) container = top ; else if ( position . equals ( LEFT ) ) container = left ; else if ( position . equals ( BOTTOM ) ) container = bottom ; else if ( position . equals ( RIGHT ) ) container = right ; else throw new InternalError ( "Unknown position: " + position ) ; } Log . log ( Log . DEBUG , this , "Adding " + name + " with position " + position ) ; container . addDockableWindow ( win ) ; Entry entry = new Entry ( win , position , container ) ; windows . put ( name , entry ) ; } public void removeDockableWindow ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry == null ) { Log . log ( Log . ERROR , this , "This DockableWindowManager" + " does not have a window named " + name ) ; return ; } Log . log ( Log . DEBUG , this , "Removing " + name + " from " + entry . container ) ; entry . container . saveDockableWindow ( entry . win ) ; entry . container . removeDockableWindow ( entry . win ) ; windows . remove ( name ) ; } public void toggleDockableWindow ( String name ) { if ( isDockableWindowVisible ( name ) ) removeDockableWindow ( name ) ; else addDockableWindow ( name ) ; } public DockableWindow getDockableWindow ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry == null ) return null ; else return entry . win ; } public boolean isDockableWindowVisible ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry == null ) return false ; else return entry . container . isDockableWindowVisible ( entry . win ) ; } public void close ( ) { Enumeration enum = windows . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Entry entry = ( Entry ) enum . nextElement ( ) ; entry . container . saveDockableWindow ( entry . win ) ; entry . container . removeDockableWindow ( entry . win ) ; } top . saveDimension ( ) ; left . saveDimension ( ) ; bottom . saveDimension ( ) ; right . saveDimension ( ) ; } public DockableWindowContainer . TabbedPane getTopDockingArea ( ) { return top ; } public DockableWindowContainer . TabbedPane getLeftDockingArea ( ) { return left ; } public DockableWindowContainer . TabbedPane getBottomDockingArea ( ) { return bottom ; } public DockableWindowContainer . TabbedPane getRightDockingArea ( ) { return right ; } public void propertiesChanged ( ) { alternateLayout = jEdit . getBooleanProperty ( "view.docking.alternateLayout" ) ; left . propertiesChanged ( ) ; right . propertiesChanged ( ) ; top . propertiesChanged ( ) ; bottom . propertiesChanged ( ) ; Enumeration enum = windows . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Entry entry = ( Entry ) enum . nextElement ( ) ; if ( entry . container instanceof DockableWindowContainer . Floating ) { SwingUtilities . updateComponentTreeUI ( ( ( JFrame ) entry . container ) . getRootPane ( ) ) ; } } revalidate ( ) ; } private View view ; private Hashtable windows ; private boolean alternateLayout ; private DockableWindowContainer . TabbedPane left ; private DockableWindowContainer . TabbedPane right ; private DockableWindowContainer . TabbedPane top ; private DockableWindowContainer . TabbedPane bottom ; static { EditBus . addToBus ( new DefaultFactory ( ) ) ; EditBus . addToNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST , "vfs.browser" ) ; EditBus . addToNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST , "hypersearch-results" ) ; EditBus . addToNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST , "log-viewer" ) ; } class DockableLayout implements LayoutManager2 { Container top , left , bottom , right ; Component center ; public void addLayoutComponent ( String name , Component comp ) { addLayoutComponent ( comp , name ) ; } public void addLayoutComponent ( Component comp , Object cons ) { if ( BorderLayout . NORTH . equals ( cons ) ) top = ( Container ) comp ; else if ( BorderLayout . WEST . equals ( cons ) ) left = ( Container ) comp ; else if ( BorderLayout . SOUTH . equals ( cons ) ) bottom = ( Container ) comp ; else if ( BorderLayout . EAST . equals ( cons ) ) right = ( Container ) comp ; else center = comp ; } public void removeLayoutComponent ( Component comp ) { if ( top == comp ) top = null ; else if ( left == comp ) left = null ; else if ( bottom == comp ) bottom = null ; else if ( right == comp ) right = null ; else if ( center == comp ) center = null ; } public Dimension preferredLayoutSize ( Container parent ) { Dimension prefSize = new Dimension ( 0 , 0 ) ; Dimension _top = top . getPreferredSize ( ) ; Dimension _left = left . getPreferredSize ( ) ; Dimension _bottom = bottom . getPreferredSize ( ) ; Dimension _right = right . getPreferredSize ( ) ; Dimension _center = ( center == null ? new Dimension ( 0 , 0 ) : center . getPreferredSize ( ) ) ; prefSize . height = _top . height + _bottom . height + _center . height ; prefSize . width = _left . width + _right . width + _center . width ; return prefSize ; } public Dimension minimumLayoutSize ( Container parent ) { return preferredLayoutSize ( parent ) ; } public Dimension maximumLayoutSize ( Container parent ) { return new Dimension ( Integer . MAX_VALUE , Integer . MAX_VALUE ) ; } public void layoutContainer ( Container parent ) { Dimension size = parent . getSize ( ) ; Dimension prefSize = new Dimension ( 0 , 0 ) ; Dimension _top = top . getPreferredSize ( ) ; Dimension _left = left . getPreferredSize ( ) ; Dimension _bottom = bottom . getPreferredSize ( ) ; Dimension _right = right . getPreferredSize ( ) ; Dimension _center = ( center == null ? new Dimension ( 0 , 0 ) : center . getPreferredSize ( ) ) ; if ( _left . width + _right . width > size . width ) { if ( left . getComponentCount ( ) == 0 ) _left . width = 0 ; else { _left . width = DockableWindowContainer . TabbedPane . SPLITTER_WIDTH ; } if ( right . getComponentCount ( ) == 0 ) _right . width = 0 ; else { _right . width = DockableWindowContainer . TabbedPane . SPLITTER_WIDTH ; } } if ( _top . height + _bottom . height > size . height ) { if ( top . getComponentCount ( ) == 0 ) _top . height = 0 ; else { _top . height = DockableWindowContainer . TabbedPane . SPLITTER_WIDTH ; } if ( bottom . getComponentCount ( ) == 0 ) _bottom . height = 0 ; else { _bottom . height = DockableWindowContainer . TabbedPane . SPLITTER_WIDTH ; } } int _width = size . width - _left . width - _right . width ; int _height = size . height - _top . height - _bottom . height ; if ( alternateLayout ) { top . setBounds ( 0 , 0 , size . width , _top . height ) ; bottom . setBounds ( 0 , size . height - _bottom . height , size . width , _bottom . height ) ; left . setBounds ( 0 , _top . height , _left . width , _height ) ; right . setBounds ( size . width - _right . width , _top . height , _right . width , _height ) ; } else { left . setBounds ( 0 , 0 , _left . width , size . height ) ; right . setBounds ( size . width - _right . width , 0 , _right . width , size . height ) ; top . setBounds ( _left . width , 0 , _width , _top . height ) ; bottom . setBounds ( _left . width , size . height - _bottom . height , _width , _bottom . height ) ; } if ( center != null ) center . setBounds ( _left . width , _top . height , _width , _height ) ; } public float getLayoutAlignmentX ( Container target ) { return 0.5f ; } public float getLayoutAlignmentY ( Container target ) { return 0.5f ; } public void invalidateLayout ( Container target ) { } } static class Entry { DockableWindow win ; String position ; DockableWindowContainer container ; Entry ( DockableWindow win , String position , DockableWindowContainer container ) { this . win = win ; this . position = position ; this . container = container ; } } static class DefaultFactory implements EBComponent { public void handleMessage ( EBMessage msg ) { if ( msg instanceof CreateDockableWindow ) { CreateDockableWindow cmsg = ( CreateDockableWindow ) msg ; String name = cmsg . getDockableWindowName ( ) ; if ( name . equals ( "vfs.browser" ) ) { cmsg . setDockableWindow ( new VFSBrowser ( cmsg . getView ( ) , null ) ) ; } else if ( name . equals ( "hypersearch-results" ) ) { cmsg . setDockableWindow ( new HyperSearchResults ( cmsg . getView ( ) ) ) ; } else if ( name . equals ( "log-viewer" ) ) { cmsg . setDockableWindow ( new LogViewer ( ) ) ; } } } } } 	1	['18', '5', '0', '16', '62', '31', '5', '14', '16', '0.794117647', '551', '0.583333333', '5', '0.976083707', '0.317647059', '0', '0', '28.94444444', '7', '1.9444', '8']
package org . gjt . sp . jedit . options ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . File ; import java . net . * ; import java . util . * ; import org . gjt . sp . jedit . browser . VFSBrowser ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class ToolBarOptionPane extends AbstractOptionPane { public ToolBarOptionPane ( ) { super ( "toolbar" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; JPanel panel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; showToolbar = new JCheckBox ( jEdit . getProperty ( "options.toolbar.showToolbar" ) ) ; showToolbar . setSelected ( jEdit . getBooleanProperty ( "view.showToolbar" ) ) ; panel . add ( showToolbar ) ; panel . add ( new JLabel ( jEdit . getProperty ( "options.toolbar.caption" ) ) ) ; add ( BorderLayout . NORTH , panel ) ; String toolbar = jEdit . getProperty ( "view.toolbar" ) ; StringTokenizer st = new StringTokenizer ( toolbar ) ; listModel = new DefaultListModel ( ) ; while ( st . hasMoreTokens ( ) ) { String actionName = ( String ) st . nextToken ( ) ; String label = ContextOptionPane . getActionLabel ( actionName ) ; if ( label == null ) continue ; Icon icon ; String iconName ; if ( actionName . equals ( "-" ) ) { iconName = null ; icon = null ; } else { iconName = jEdit . getProperty ( actionName + ".icon" ) ; if ( iconName == null ) continue ; icon = GUIUtilities . loadIcon ( iconName ) ; } listModel . addElement ( new Button ( actionName , iconName , icon , label ) ) ; } list = new JList ( listModel ) ; list . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; list . addListSelectionListener ( new ListHandler ( ) ) ; list . setCellRenderer ( new ButtonCellRenderer ( ) ) ; add ( BorderLayout . CENTER , new JScrollPane ( list ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setBorder ( new EmptyBorder ( 3 , 0 , 0 , 0 ) ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( Box . createGlue ( ) ) ; ActionHandler actionHandler = new ActionHandler ( ) ; add = new JButton ( jEdit . getProperty ( "options.toolbar.add" ) ) ; add . addActionListener ( actionHandler ) ; buttons . add ( add ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; remove = new JButton ( jEdit . getProperty ( "options.toolbar.remove" ) ) ; remove . addActionListener ( actionHandler ) ; buttons . add ( remove ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; moveUp = new JButton ( jEdit . getProperty ( "options.toolbar.moveUp" ) ) ; moveUp . addActionListener ( actionHandler ) ; buttons . add ( moveUp ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; moveDown = new JButton ( jEdit . getProperty ( "options.toolbar.moveDown" ) ) ; moveDown . addActionListener ( actionHandler ) ; buttons . add ( moveDown ) ; buttons . add ( Box . createGlue ( ) ) ; updateButtons ( ) ; add ( BorderLayout . SOUTH , buttons ) ; EditAction [ ] actions = jEdit . getActions ( ) ; Vector vector = new Vector ( actions . length ) ; for ( int i = 0 ; i < actions . length ; i ++ ) { String actionName = actions [ i ] . getName ( ) ; String label = jEdit . getProperty ( actionName + ".label" ) ; if ( label == null ) continue ; vector . addElement ( new Button ( actionName , null , null , label ) ) ; } MiscUtilities . quicksort ( vector , new ButtonCompare ( ) ) ; actionsList = new DefaultListModel ( ) ; actionsList . ensureCapacity ( vector . size ( ) ) ; for ( int i = 0 ; i < vector . size ( ) ; i ++ ) { actionsList . addElement ( vector . elementAt ( i ) ) ; } iconList = new DefaultComboBoxModel ( ) ; st = new StringTokenizer ( jEdit . getProperty ( "icons" ) ) ; while ( st . hasMoreElements ( ) ) { String icon = st . nextToken ( ) ; iconList . addElement ( new IconListEntry ( GUIUtilities . loadIcon ( icon ) , icon ) ) ; } } class ButtonCompare implements MiscUtilities . Compare { public int compare ( Object obj1 , Object obj2 ) { return ( ( Button ) obj1 ) . label . toLowerCase ( ) . compareTo ( ( ( Button ) obj2 ) . label . toLowerCase ( ) ) ; } } protected void _save ( ) { jEdit . setBooleanProperty ( "view.showToolbar" , showToolbar . isSelected ( ) ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < listModel . getSize ( ) ; i ++ ) { if ( i != 0 ) buf . append ( ' ' ) ; Button button = ( Button ) listModel . elementAt ( i ) ; buf . append ( button . actionName ) ; jEdit . setProperty ( button . actionName + ".icon" , button . iconName ) ; } jEdit . setProperty ( "view.toolbar" , buf . toString ( ) ) ; } private JCheckBox showToolbar ; private DefaultListModel listModel ; private JList list ; private JButton add ; private JButton remove ; private JButton moveUp , moveDown ; private DefaultListModel actionsList ; private DefaultComboBoxModel iconList ; private void updateButtons ( ) { int index = list . getSelectedIndex ( ) ; remove . setEnabled ( index != - 1 && listModel . getSize ( ) != 0 ) ; moveUp . setEnabled ( index > 0 ) ; moveDown . setEnabled ( index != - 1 && index != listModel . getSize ( ) - 1 ) ; } static class Button { String actionName ; String iconName ; Icon icon ; String label ; Button ( String actionName , String iconName , Icon icon , String label ) { this . actionName = actionName ; this . iconName = iconName ; this . icon = icon ; if ( label . equals ( "-" ) ) this . label = label ; else this . label = GUIUtilities . prettifyMenuLabel ( label ) ; } public String toString ( ) { return label ; } } static class IconListEntry { Icon icon ; String name ; IconListEntry ( Icon icon , String name ) { this . icon = icon ; this . name = name ; } } static class ButtonCellRenderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; Button button = ( Button ) value ; setText ( button . label ) ; setIcon ( button . icon ) ; return this ; } } static class IconCellRenderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; IconListEntry icon = ( IconListEntry ) value ; setText ( icon . name ) ; setIcon ( icon . icon ) ; return this ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == add ) { ToolBarAddDialog dialog = new ToolBarAddDialog ( ToolBarOptionPane . this , actionsList , iconList ) ; Button selection = dialog . getSelection ( ) ; if ( selection == null ) return ; int index = list . getSelectedIndex ( ) ; if ( index == - 1 ) index = listModel . getSize ( ) ; else index ++ ; listModel . insertElementAt ( selection , index ) ; list . setSelectedIndex ( index ) ; } else if ( source == remove ) { int index = list . getSelectedIndex ( ) ; listModel . removeElementAt ( index ) ; updateButtons ( ) ; } else if ( source == moveUp ) { int index = list . getSelectedIndex ( ) ; Object selected = list . getSelectedValue ( ) ; listModel . removeElementAt ( index ) ; listModel . insertElementAt ( selected , index - 1 ) ; list . setSelectedIndex ( index - 1 ) ; } else if ( source == moveDown ) { int index = list . getSelectedIndex ( ) ; Object selected = list . getSelectedValue ( ) ; listModel . removeElementAt ( index ) ; listModel . insertElementAt ( selected , index + 1 ) ; list . setSelectedIndex ( index + 1 ) ; } } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { updateButtons ( ) ; } } } class ToolBarAddDialog extends EnhancedDialog { public ToolBarAddDialog ( Component comp , ListModel actionsListModel , ComboBoxModel iconListModel ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "options.toolbar.add.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; content . add ( BorderLayout . NORTH , new JLabel ( jEdit . getProperty ( "options.toolbar.add.caption" ) ) ) ; JPanel mainPanel = new JPanel ( new BorderLayout ( 0 , 6 ) ) ; JPanel radioPanel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; ActionHandler actionHandler = new ActionHandler ( ) ; ButtonGroup grp = new ButtonGroup ( ) ; separator = new JRadioButton ( jEdit . getProperty ( "options.toolbar" + ".add.separator" ) ) ; separator . setSelected ( true ) ; separator . addActionListener ( actionHandler ) ; grp . add ( separator ) ; radioPanel . add ( separator ) ; action = new JRadioButton ( jEdit . getProperty ( "options.toolbar" + ".add.action" ) ) ; action . addActionListener ( actionHandler ) ; grp . add ( action ) ; radioPanel . add ( action ) ; mainPanel . add ( BorderLayout . NORTH , radioPanel ) ; actionsList = new JList ( actionsListModel ) ; actionsList . setVisibleRowCount ( 8 ) ; JPanel centerPanel = new JPanel ( new BorderLayout ( 0 , 3 ) ) ; centerPanel . add ( BorderLayout . NORTH , new JScrollPane ( actionsList ) ) ; macro = new JRadioButton ( jEdit . getProperty ( "options.toolbar" + ".add.macro" ) ) ; macro . addActionListener ( actionHandler ) ; grp . add ( macro ) ; centerPanel . add ( BorderLayout . CENTER , macro ) ; macrosList = new JList ( Macros . getMacroList ( ) ) ; macrosList . setVisibleRowCount ( 8 ) ; centerPanel . add ( BorderLayout . SOUTH , new JScrollPane ( macrosList ) ) ; mainPanel . add ( BorderLayout . CENTER , centerPanel ) ; JPanel iconPanel = new JPanel ( new BorderLayout ( 0 , 3 ) ) ; JPanel labelPanel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; labelPanel . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; JPanel compPanel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; grp = new ButtonGroup ( ) ; labelPanel . add ( builtin = new JRadioButton ( jEdit . getProperty ( "options.toolbar.add.builtin" ) ) ) ; builtin . addActionListener ( actionHandler ) ; builtin . setSelected ( true ) ; grp . add ( builtin ) ; labelPanel . add ( file = new JRadioButton ( jEdit . getProperty ( "options.toolbar.add.file" ) ) ) ; grp . add ( file ) ; file . addActionListener ( actionHandler ) ; iconPanel . add ( BorderLayout . WEST , labelPanel ) ; builtinCombo = new JComboBox ( iconListModel ) ; builtinCombo . setRenderer ( new ToolBarOptionPane . IconCellRenderer ( ) ) ; compPanel . add ( builtinCombo ) ; fileButton = new JButton ( jEdit . getProperty ( "options.toolbar.add.no-icon" ) ) ; fileButton . setMargin ( new Insets ( 1 , 1 , 1 , 1 ) ) ; fileButton . setIcon ( GUIUtilities . loadIcon ( "Blank24.gif" ) ) ; fileButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; fileButton . addActionListener ( actionHandler ) ; compPanel . add ( fileButton ) ; iconPanel . add ( BorderLayout . CENTER , compPanel ) ; mainPanel . add ( BorderLayout . SOUTH , iconPanel ) ; content . add ( BorderLayout . CENTER , mainPanel ) ; JPanel southPanel = new JPanel ( ) ; southPanel . setLayout ( new BoxLayout ( southPanel , BoxLayout . X_AXIS ) ) ; southPanel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; southPanel . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( actionHandler ) ; getRootPane ( ) . setDefaultButton ( ok ) ; southPanel . add ( ok ) ; southPanel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( actionHandler ) ; southPanel . add ( cancel ) ; southPanel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , southPanel ) ; updateEnabled ( ) ; pack ( ) ; setLocationRelativeTo ( JOptionPane . getFrameForComponent ( comp ) ) ; show ( ) ; } public void ok ( ) { isOK = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public ToolBarOptionPane . Button getSelection ( ) { if ( ! isOK ) return null ; if ( separator . isSelected ( ) ) return new ToolBarOptionPane . Button ( "-" , null , null , "-" ) ; else { Icon icon ; String iconName ; if ( builtin . isSelected ( ) ) { ToolBarOptionPane . IconListEntry selectedIcon = ( ToolBarOptionPane . IconListEntry ) builtinCombo . getSelectedItem ( ) ; icon = selectedIcon . icon ; iconName = selectedIcon . name ; } else { icon = fileButton . getIcon ( ) ; iconName = fileIcon ; if ( iconName == null ) iconName = "Blank24.gif" ; } String label ; String actionName ; if ( action . isSelected ( ) ) { ToolBarOptionPane . Button button = ( ToolBarOptionPane . Button ) actionsList . getSelectedValue ( ) ; label = button . label ; actionName = button . actionName ; } else if ( macro . isSelected ( ) ) { actionName = "play-macro@" + macrosList . getSelectedValue ( ) ; label = ContextOptionPane . getActionLabel ( actionName ) ; } else throw new InternalError ( ) ; return new ToolBarOptionPane . Button ( actionName , iconName , icon , label ) ; } } private boolean isOK ; private JRadioButton separator , action , macro ; private JList actionsList , macrosList ; private JRadioButton builtin ; private JComboBox builtinCombo ; private JRadioButton file ; private JButton fileButton ; private String fileIcon ; private JButton ok , cancel ; private void updateEnabled ( ) { actionsList . setEnabled ( action . isSelected ( ) ) ; macrosList . setEnabled ( macro . isSelected ( ) ) ; boolean iconControlsEnabled = ! separator . isSelected ( ) ; builtin . setEnabled ( iconControlsEnabled ) ; file . setEnabled ( iconControlsEnabled ) ; builtinCombo . setEnabled ( iconControlsEnabled && builtin . isSelected ( ) ) ; fileButton . setEnabled ( iconControlsEnabled && file . isSelected ( ) ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source instanceof JRadioButton ) updateEnabled ( ) ; else if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; else if ( source == builtin || source == file ) updateEnabled ( ) ; else if ( source == fileButton ) { String directory ; if ( fileIcon == null ) directory = null ; else directory = MiscUtilities . getParentOfPath ( fileIcon ) ; String paths [ ] = GUIUtilities . showVFSFileDialog ( null , directory , VFSBrowser . OPEN_DIALOG , false ) ; if ( paths == null ) return ; fileIcon = "file:" + paths [ 0 ] ; try { fileButton . setIcon ( new ImageIcon ( new URL ( fileIcon ) ) ) ; } catch ( MalformedURLException mf ) { Log . log ( Log . ERROR , this , mf ) ; } fileButton . setText ( MiscUtilities . getFileName ( fileIcon ) ) ; } } } } 	1	['13', '6', '0', '14', '75', '44', '4', '13', '1', '0.814814815', '517', '1', '0', '0.982195846', '0.5', '3', '5', '38.07692308', '12', '2.3077', '1']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import java . io . * ; import java . util . Stack ; import org . gjt . sp . util . Log ; class ActionListHandler extends HandlerBase { ActionListHandler ( String path , boolean plugin ) { this . path = path ; this . plugin = plugin ; stateStack = new Stack ( ) ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "actions.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "actions.dtd" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error while opening" + " actions.dtd:" ) ; Log . log ( Log . ERROR , this , e ) ; } } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { aname = ( aname == null ) ? null : aname . intern ( ) ; value = ( value == null ) ? null : value . intern ( ) ; if ( aname == "NAME" ) actionName = value ; else if ( aname == "NO_REPEAT" ) noRepeat = ( value == "TRUE" ) ; else if ( aname == "NO_RECORD" ) noRecord = ( value == "TRUE" ) ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "ACTIONS" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , path + ": DOCTYPE must be ACTIONS" ) ; } public void charData ( char [ ] c , int off , int len ) { String tag = peekElement ( ) ; String text = new String ( c , off , len ) ; if ( tag == "CODE" ) { code = text ; } else if ( tag == "IS_SELECTED" ) { isSelected = text ; } } public void startElement ( String tag ) { tag = pushElement ( tag ) ; if ( tag == "ACTION" ) { code = null ; isSelected = null ; } } public void endElement ( String name ) { if ( name == null ) return ; String tag = peekElement ( ) ; if ( name . equals ( tag ) ) { if ( tag == "ACTION" ) { jEdit . addAction ( new BeanShellAction ( actionName , plugin , code , isSelected , noRepeat , noRecord ) ) ; } popElement ( ) ; } else { throw new InternalError ( ) ; } } public void startDocument ( ) { try { pushElement ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private String path ; private boolean plugin ; private String actionName ; private String code ; private String isSelected ; private boolean noRepeat ; private boolean noRecord ; private Stack stateStack ; private String pushElement ( String name ) { name = ( name == null ) ? null : name . intern ( ) ; stateStack . push ( name ) ; return name ; } private String peekElement ( ) { return ( String ) stateStack . peek ( ) ; } private String popElement ( ) { return ( String ) stateStack . pop ( ) ; } } 	1	['11', '2', '0', '5', '31', '31', '1', '5', '7', '0.8', '231', '1', '0', '0.565217391', '0.4', '1', '3', '19.27272727', '8', '2.2727', '2']
package org . gjt . sp . jedit . gui ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class MarkersMenu extends EnhancedMenu { public MarkersMenu ( ) { super ( "markers" ) ; } public void setPopupMenuVisible ( boolean b ) { if ( b ) { final View view = EditAction . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) { for ( int i = getMenuComponentCount ( ) - 1 ; i >= 0 ; i -- ) { Component comp = getMenuComponent ( i ) ; if ( comp instanceof JSeparator ) break ; else remove ( comp ) ; } } Buffer buffer = view . getBuffer ( ) ; Element map = buffer . getDefaultRootElement ( ) ; Vector markers = buffer . getMarkers ( ) ; if ( markers . size ( ) == 0 ) { JMenuItem mi = new JMenuItem ( jEdit . getProperty ( "no-markers.label" ) ) ; mi . setEnabled ( false ) ; add ( mi ) ; super . setPopupMenuVisible ( b ) ; return ; } JMenu current = this ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { final Marker marker = ( Marker ) markers . elementAt ( i ) ; int lineNo = map . getElementIndex ( marker . getPosition ( ) ) ; if ( current . getItemCount ( ) >= 20 ) { JMenu newCurrent = new JMenu ( jEdit . getProperty ( "common.more" ) ) ; current . add ( newCurrent ) ; current = newCurrent ; } JMenuItem mi = new MarkersMenuItem ( buffer , lineNo , marker . getShortcut ( ) ) ; mi . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { view . getTextArea ( ) . setCaretPosition ( marker . getPosition ( ) ) ; } } ) ; current . add ( mi ) ; } } super . setPopupMenuVisible ( b ) ; } static class MarkersMenuItem extends JMenuItem { MarkersMenuItem ( Buffer buffer , int lineNo , char shortcut ) { Element line = buffer . getDefaultRootElement ( ) . getElement ( lineNo ) ; try { int start = line . getStartOffset ( ) ; String text = buffer . getText ( start , line . getEndOffset ( ) - start - 1 ) ; text = text . trim ( ) ; if ( text . length ( ) == 0 ) text = jEdit . getProperty ( "markers.blank-line" ) ; setText ( lineNo + ": " + text ) ; } catch ( BadLocationException ble ) { Log . log ( Log . ERROR , this , ble ) ; } shortcutProp = "goto-marker.shortcut" ; MarkersMenuItem . this . shortcut = shortcut ; } public Dimension getPreferredSize ( ) { Dimension d = super . getPreferredSize ( ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { d . width += ( getFontMetrics ( acceleratorFont ) . stringWidth ( shortcut ) + 10 ) ; } return d ; } public void paint ( Graphics g ) { super . paint ( g ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { g . setFont ( acceleratorFont ) ; g . setColor ( getModel ( ) . isArmed ( ) ? acceleratorSelectionForeground : acceleratorForeground ) ; FontMetrics fm = g . getFontMetrics ( ) ; Insets insets = getInsets ( ) ; g . drawString ( shortcut , getWidth ( ) - ( fm . stringWidth ( shortcut ) + insets . right + insets . left ) , getFont ( ) . getSize ( ) + ( insets . top - 1 ) ) ; } } private String shortcutProp ; private char shortcut ; private static Font acceleratorFont ; private static Color acceleratorForeground ; private static Color acceleratorSelectionForeground ; private String getShortcut ( ) { if ( shortcut == '\0' ) return null ; else { String shortcutPrefix = jEdit . getProperty ( shortcutProp ) ; if ( shortcutPrefix == null ) return null ; else { return shortcutPrefix + " " + shortcut ; } } } static { acceleratorFont = UIManager . getFont ( "MenuItem.acceleratorFont" ) ; acceleratorFont = new Font ( "Monospaced" , acceleratorFont . getStyle ( ) , acceleratorFont . getSize ( ) ) ; acceleratorForeground = UIManager . getColor ( "MenuItem.acceleratorForeground" ) ; acceleratorSelectionForeground = UIManager . getColor ( "MenuItem.acceleratorSelectionForeground" ) ; } } } 	1	['2', '8', '0', '9', '25', '1', '2', '8', '2', '2', '127', '0', '0', '0.998835856', '0.75', '3', '4', '62.5', '9', '4.5', '2']
package org . gjt . sp . jedit . browser ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . File ; import java . util . Vector ; import org . gjt . sp . jedit . gui . EnhancedDialog ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . * ; public class VFSFileChooserDialog extends EnhancedDialog { public VFSFileChooserDialog ( View view , String path , int mode , boolean multipleSelection ) { super ( view , jEdit . getProperty ( "vfs.browser.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; String name ; if ( path == null || path . endsWith ( File . separator ) || path . endsWith ( "/" ) ) name = null ; else { VFS vfs = VFSManager . getVFSForPath ( path ) ; name = vfs . getFileName ( path ) ; path = vfs . getParentOfPath ( path ) ; } browser = new VFSBrowser ( view , path , mode , multipleSelection ) ; browser . addBrowserListener ( new BrowserHandler ( ) ) ; content . add ( BorderLayout . CENTER , browser ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; panel . add ( new JLabel ( jEdit . getProperty ( "vfs.browser.dialog.filename" ) ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; filenameField = new JTextField ( 20 ) ; filenameField . setText ( name ) ; filenameField . addKeyListener ( new KeyHandler ( ) ) ; filenameField . selectAll ( ) ; Dimension dim = filenameField . getPreferredSize ( ) ; dim . width = Integer . MAX_VALUE ; filenameField . setMaximumSize ( dim ) ; Box box = new Box ( BoxLayout . Y_AXIS ) ; box . add ( Box . createGlue ( ) ) ; box . add ( filenameField ) ; box . add ( Box . createGlue ( ) ) ; panel . add ( box ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; if ( mode == VFSBrowser . SAVE_DIALOG ) { GUIUtilities . requestFocus ( this , filenameField ) ; } else { GUIUtilities . requestFocus ( this , browser . getBrowserView ( ) . getDefaultFocusComponent ( ) ) ; } ok = new JButton ( jEdit . getProperty ( "vfs.browser.dialog." + ( mode == VFSBrowser . OPEN_DIALOG ? "open" : "save" ) ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; panel . add ( ok ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; panel . add ( cancel ) ; if ( mode != VFSBrowser . SAVE_DIALOG ) panel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , panel ) ; pack ( ) ; GUIUtilities . loadGeometry ( this , "vfs.browser.dialog" ) ; show ( ) ; } public void dispose ( ) { GUIUtilities . saveGeometry ( this , "vfs.browser.dialog" ) ; super . dispose ( ) ; } public void ok ( ) { VFS . DirectoryEntry [ ] files = browser . getSelectedFiles ( ) ; String directory = browser . getDirectory ( ) ; if ( files . length == 0 ) { filename = filenameField . getText ( ) ; if ( filename . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } } else { for ( int i = 0 ; i < files . length ; i ++ ) { VFS . DirectoryEntry file = files [ i ] ; if ( file . type == VFS . DirectoryEntry . FILESYSTEM || file . type == VFS . DirectoryEntry . DIRECTORY ) { browser . setDirectory ( file . path ) ; return ; } else if ( browser . getMode ( ) == VFSBrowser . SAVE_DIALOG ) filename = file . path ; } } if ( browser . getMode ( ) == VFSBrowser . SAVE_DIALOG ) { VFS vfs = VFSManager . getVFSForPath ( directory ) ; filename = vfs . constructPath ( directory , filename ) ; if ( vfs instanceof FileVFS && doFileExistsWarning ( filename ) ) return ; } isOK = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public String [ ] getSelectedFiles ( ) { if ( ! isOK ) return null ; if ( filename != null ) return new String [ ] { filename } ; else { Vector vector = new Vector ( ) ; VFS . DirectoryEntry [ ] selectedFiles = browser . getSelectedFiles ( ) ; for ( int i = 0 ; i < selectedFiles . length ; i ++ ) { VFS . DirectoryEntry file = selectedFiles [ i ] ; if ( file . type == VFS . DirectoryEntry . FILE ) vector . addElement ( file . path ) ; } String [ ] retVal = new String [ vector . size ( ) ] ; vector . copyInto ( retVal ) ; return retVal ; } } private VFSBrowser browser ; private JTextField filenameField ; private String filename ; private JButton ok ; private JButton cancel ; private boolean isOK ; private boolean doFileExistsWarning ( String filename ) { if ( new File ( filename ) . exists ( ) ) { String [ ] args = { MiscUtilities . getFileName ( filename ) } ; int result = GUIUtilities . confirm ( browser , "fileexists" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return true ; } return false ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) ok ( ) ; else if ( evt . getSource ( ) == cancel ) cancel ( ) ; } } class BrowserHandler implements BrowserListener { public void filesSelected ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) { if ( files . length == 0 ) return ; else if ( files . length == 1 ) { VFS . DirectoryEntry file = files [ 0 ] ; if ( file . type == VFS . DirectoryEntry . FILE ) { String path = file . path ; String directory = browser . getDirectory ( ) ; VFS vfs = VFSManager . getVFSForPath ( directory ) ; String parent = vfs . getParentOfPath ( path ) ; if ( parent . endsWith ( "/" ) || parent . endsWith ( File . separator ) ) parent = parent . substring ( 0 , parent . length ( ) - 1 ) ; if ( parent . equals ( directory ) ) path = file . name ; filenameField . setText ( path ) ; } } else { filenameField . setText ( null ) ; } } public void filesActivated ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { VFS . DirectoryEntry file = files [ i ] ; if ( file . type == VFS . DirectoryEntry . FILESYSTEM || file . type == VFS . DirectoryEntry . DIRECTORY ) { return ; } } ok ( ) ; } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { browser . getBrowserView ( ) . selectNone ( ) ; } } } 	1	['10', '7', '0', '15', '74', '17', '4', '15', '5', '0.814814815', '477', '1', '1', '0.986404834', '0.25', '4', '7', '46.1', '9', '2.3', '4']
package org . gjt . sp . jedit . search ; import javax . swing . text . * ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . Buffer ; import org . gjt . sp . util . Log ; public class HyperSearchResult { public String path ; public Buffer buffer ; public int line ; public Position linePos ; public String str ; public HyperSearchResult ( Buffer buffer , int line ) { path = buffer . getPath ( ) ; this . line = line ; if ( ! buffer . isTemporary ( ) ) bufferOpened ( buffer ) ; str = ( line + 1 ) + ": " + getLine ( buffer , buffer . getDefaultRootElement ( ) . getElement ( line ) ) ; } String getLine ( Buffer buffer , Element elem ) { if ( elem == null ) return "" ; try { return buffer . getText ( elem . getStartOffset ( ) , elem . getEndOffset ( ) - elem . getStartOffset ( ) - 1 ) . replace ( '\t' , ' ' ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; return "" ; } } public void bufferOpened ( Buffer buffer ) { this . buffer = buffer ; Element map = buffer . getDefaultRootElement ( ) ; Element elem = map . getElement ( line ) ; if ( elem == null ) elem = map . getElement ( map . getElementCount ( ) - 1 ) ; try { linePos = buffer . createPosition ( elem . getStartOffset ( ) ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void bufferClosed ( ) { buffer = null ; linePos = null ; } public Buffer getBuffer ( ) { if ( buffer == null ) buffer = jEdit . openFile ( null , path ) ; return buffer ; } public String toString ( ) { return str ; } } 	1	['6', '1', '0', '8', '23', '3', '4', '4', '5', '0.68', '128', '0', '1', '0', '0.458333333', '0', '0', '19.5', '2', '1.3333', '1']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . Border ; import javax . swing . border . AbstractBorder ; import javax . swing . border . CompoundBorder ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . * ; public class HistoryTextField extends JTextField { public HistoryTextField ( ) { this ( null ) ; } public HistoryTextField ( String name ) { this ( name , false , true ) ; } public HistoryTextField ( String name , boolean instantPopups ) { this ( name , instantPopups , true ) ; } public HistoryTextField ( String name , boolean instantPopups , boolean enterAddsToHistory ) { setBorder ( new CompoundBorder ( getBorder ( ) , new HistoryBorder ( ) ) ) ; if ( name != null ) historyModel = HistoryModel . getModel ( name ) ; addMouseMotionListener ( new MouseHandler ( ) ) ; this . instantPopups = instantPopups ; this . enterAddsToHistory = enterAddsToHistory ; index = - 1 ; } public void setModel ( String name ) { if ( name == null ) historyModel = null ; else historyModel = HistoryModel . getModel ( name ) ; index = - 1 ; } public void addCurrentToHistory ( ) { if ( historyModel != null ) historyModel . addItem ( getText ( ) ) ; index = 0 ; } public void setText ( String text ) { super . setText ( text ) ; index = - 1 ; } public HistoryModel getModel ( ) { return historyModel ; } public void fireActionPerformed ( ) { super . fireActionPerformed ( ) ; } protected void processKeyEvent ( KeyEvent evt ) { if ( ! isEnabled ( ) ) return ; evt = KeyEventWorkaround . processKeyEvent ( evt ) ; if ( evt == null ) return ; if ( evt . getID ( ) == KeyEvent . KEY_PRESSED ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( enterAddsToHistory ) addCurrentToHistory ( ) ; if ( evt . getModifiers ( ) == 0 ) { fireActionPerformed ( ) ; evt . consume ( ) ; } } else if ( evt . getKeyCode ( ) == KeyEvent . VK_UP ) { if ( evt . isShiftDown ( ) ) doBackwardSearch ( ) ; else historyPrevious ( ) ; evt . consume ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_DOWN ) { if ( evt . isShiftDown ( ) ) doForwardSearch ( ) ; else historyNext ( ) ; evt . consume ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_TAB && evt . isControlDown ( ) ) { doBackwardSearch ( ) ; evt . consume ( ) ; } } if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } protected void processMouseEvent ( MouseEvent evt ) { if ( ! isEnabled ( ) ) return ; switch ( evt . getID ( ) ) { case MouseEvent . MOUSE_PRESSED : Border border = getBorder ( ) ; Insets insets = border . getBorderInsets ( HistoryTextField . this ) ; if ( evt . getX ( ) >= getWidth ( ) - insets . right || GUIUtilities . isPopupTrigger ( evt ) ) { if ( evt . isShiftDown ( ) ) showPopupMenu ( getText ( ) . substring ( 0 , getSelectionStart ( ) ) , 0 , getHeight ( ) ) ; else showPopupMenu ( "" , 0 , getHeight ( ) ) ; } else super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_EXITED : setCursor ( Cursor . getDefaultCursor ( ) ) ; super . processMouseEvent ( evt ) ; break ; default : super . processMouseEvent ( evt ) ; break ; } } private HistoryModel historyModel ; private JPopupMenu popup ; private boolean instantPopups ; private boolean enterAddsToHistory ; private String current ; private int index ; private void doBackwardSearch ( ) { if ( historyModel == null ) return ; if ( getSelectionEnd ( ) != getDocument ( ) . getLength ( ) ) { setCaretPosition ( getDocument ( ) . getLength ( ) ) ; } String text = getText ( ) . substring ( 0 , getSelectionStart ( ) ) ; if ( text == null ) { historyPrevious ( ) ; return ; } for ( int i = index + 1 ; i < historyModel . getSize ( ) ; i ++ ) { String item = historyModel . getItem ( i ) ; if ( item . startsWith ( text ) ) { replaceSelection ( item . substring ( text . length ( ) ) ) ; select ( text . length ( ) , getDocument ( ) . getLength ( ) ) ; index = i ; return ; } } getToolkit ( ) . beep ( ) ; } private void doForwardSearch ( ) { if ( historyModel == null ) return ; if ( getSelectionEnd ( ) != getDocument ( ) . getLength ( ) ) { setCaretPosition ( getDocument ( ) . getLength ( ) ) ; } String text = getText ( ) . substring ( 0 , getSelectionStart ( ) ) ; if ( text == null ) { historyNext ( ) ; return ; } for ( int i = index - 1 ; i >= 0 ; i -- ) { String item = historyModel . getItem ( i ) ; if ( item . startsWith ( text ) ) { replaceSelection ( item . substring ( text . length ( ) ) ) ; select ( text . length ( ) , getDocument ( ) . getLength ( ) ) ; index = i ; return ; } } getToolkit ( ) . beep ( ) ; } private void historyPrevious ( ) { if ( historyModel == null ) return ; if ( index == historyModel . getSize ( ) - 1 ) getToolkit ( ) . beep ( ) ; else if ( index == - 1 ) { current = getText ( ) ; setText ( historyModel . getItem ( 0 ) ) ; index = 0 ; } else { int newIndex = index + 1 ; setText ( historyModel . getItem ( newIndex ) ) ; index = newIndex ; } } private void historyNext ( ) { if ( historyModel == null ) return ; if ( index == - 1 ) getToolkit ( ) . beep ( ) ; else if ( index == 0 ) setText ( current ) ; else { int newIndex = index - 1 ; setText ( historyModel . getItem ( newIndex ) ) ; index = newIndex ; } } private void showPopupMenu ( String text , int x , int y ) { if ( historyModel == null ) return ; requestFocus ( ) ; if ( popup != null && popup . isVisible ( ) ) { popup . setVisible ( false ) ; return ; } ActionHandler actionListener = new ActionHandler ( ) ; popup = new JPopupMenu ( ) ; JMenuItem caption = new JMenuItem ( jEdit . getProperty ( "history.caption" ) ) ; caption . getModel ( ) . setEnabled ( false ) ; popup . add ( caption ) ; popup . addSeparator ( ) ; for ( int i = 0 ; i < historyModel . getSize ( ) ; i ++ ) { String item = historyModel . getItem ( i ) ; if ( item . startsWith ( text ) ) { JMenuItem menuItem = new JMenuItem ( item ) ; menuItem . setActionCommand ( String . valueOf ( i ) ) ; menuItem . addActionListener ( actionListener ) ; popup . add ( menuItem ) ; } } popup . show ( this , x , y ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { int ind = Integer . parseInt ( evt . getActionCommand ( ) ) ; if ( ind == - 1 ) { if ( index != - 1 ) setText ( current ) ; } else { setText ( historyModel . getItem ( ind ) ) ; index = ind ; } if ( instantPopups ) { addCurrentToHistory ( ) ; fireActionPerformed ( ) ; } } } class MouseHandler extends MouseMotionAdapter { public void mouseMoved ( MouseEvent evt ) { Border border = getBorder ( ) ; Insets insets = border . getBorderInsets ( HistoryTextField . this ) ; if ( evt . getX ( ) >= getWidth ( ) - insets . right ) setCursor ( Cursor . getDefaultCursor ( ) ) ; else setCursor ( Cursor . getPredefinedCursor ( Cursor . TEXT_CURSOR ) ) ; } } static class HistoryBorder extends AbstractBorder { static final int WIDTH = 16 ; public void paintBorder ( Component c , Graphics g , int x , int y , int w , int h ) { g . translate ( x + w - WIDTH , y - 1 ) ; int w2 = WIDTH / 2 ; int h2 = h / 2 ; g . setColor ( UIManager . getColor ( c . isEnabled ( ) && ( ( HistoryTextField ) c ) . getModel ( ) != null ? "Menu.foreground" : "Menu.disabledForeground" ) ) ; g . drawLine ( w2 - 5 , h2 - 2 , w2 + 4 , h2 - 2 ) ; g . drawLine ( w2 - 4 , h2 - 1 , w2 + 3 , h2 - 1 ) ; g . drawLine ( w2 - 3 , h2 , w2 + 2 , h2 ) ; g . drawLine ( w2 - 2 , h2 + 1 , w2 + 1 , h2 + 1 ) ; g . drawLine ( w2 - 1 , h2 + 2 , w2 , h2 + 2 ) ; g . translate ( - ( x + w - WIDTH ) , - ( y - 1 ) ) ; } public Insets getBorderInsets ( Component c ) { return new Insets ( 0 , 0 , 0 , WIDTH ) ; } } } 	1	['21', '6', '0', '17', '83', '64', '13', '7', '9', '0.691666667', '589', '1', '1', '0.978986403', '0.224489796', '3', '7', '26.76190476', '13', '2.7619', '2']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . * ; public class BeanShellErrorDialog extends EnhancedDialog { public BeanShellErrorDialog ( View view , String message ) { super ( view , jEdit . getProperty ( "beanshell-error.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel caption = new JPanel ( new GridLayout ( 2 , 1 , 3 , 3 ) ) ; caption . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 0 ) ) ; caption . add ( new JLabel ( jEdit . getProperty ( "beanshell-error.message.1" ) ) ) ; caption . add ( new JLabel ( jEdit . getProperty ( "beanshell-error.message.2" ) ) ) ; content . add ( BorderLayout . NORTH , caption ) ; JTextArea textArea = new JTextArea ( 10 , 60 ) ; textArea . setText ( message ) ; textArea . setLineWrap ( true ) ; textArea . setWrapStyleWord ( true ) ; content . add ( BorderLayout . CENTER , new JScrollPane ( textArea ) ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; panel . add ( Box . createGlue ( ) ) ; JButton ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; panel . add ( ok ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( panel , BorderLayout . SOUTH ) ; getRootPane ( ) . setDefaultButton ( ok ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { dispose ( ) ; } } } 	1	['3', '7', '0', '5', '33', '3', '2', '4', '3', '2', '162', '0', '0', '0.996946565', '0.555555556', '0', '0', '53', '1', '0.6667', '1']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . * ; public class LoadSaveOptionPane extends AbstractOptionPane { public LoadSaveOptionPane ( ) { super ( "loadsave" ) ; } public void _init ( ) { autosave = new JTextField ( jEdit . getProperty ( "autosave" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.autosave" ) , autosave ) ; backups = new JTextField ( jEdit . getProperty ( "backups" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backups" ) , backups ) ; backupDirectory = new JTextField ( jEdit . getProperty ( "backup.directory" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backupDirectory" ) , backupDirectory ) ; backupPrefix = new JTextField ( jEdit . getProperty ( "backup.prefix" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backupPrefix" ) , backupPrefix ) ; backupSuffix = new JTextField ( jEdit . getProperty ( "backup.suffix" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backupSuffix" ) , backupSuffix ) ; String [ ] lineSeps = { jEdit . getProperty ( "lineSep.unix" ) , jEdit . getProperty ( "lineSep.windows" ) , jEdit . getProperty ( "lineSep.mac" ) } ; lineSeparator = new JComboBox ( lineSeps ) ; String lineSep = jEdit . getProperty ( "buffer.lineSeparator" , System . getProperty ( "line.separator" ) ) ; if ( "\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 0 ) ; else if ( "\r\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 1 ) ; else if ( "\r" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 2 ) ; addComponent ( jEdit . getProperty ( "options.loadsave.lineSeparator" ) , lineSeparator ) ; DefaultComboBoxModel encodings = new DefaultComboBoxModel ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { encodings . addElement ( st . nextToken ( ) ) ; } encoding = new JComboBox ( encodings ) ; encoding . setEditable ( true ) ; encoding . setSelectedItem ( jEdit . getProperty ( "buffer.encoding" , System . getProperty ( "file.encoding" ) ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.encoding" ) , encoding ) ; ioThreadCount = new JTextField ( jEdit . getProperty ( "ioThreadCount" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.ioThreadCount" ) , ioThreadCount ) ; restore = new JCheckBox ( jEdit . getProperty ( "options.loadsave.restore" ) ) ; restore . setSelected ( jEdit . getBooleanProperty ( "restore" ) ) ; restore . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { restoreCLI . setEnabled ( restore . isSelected ( ) ) ; } } ) ; addComponent ( restore ) ; restoreCLI = new JCheckBox ( jEdit . getProperty ( "options.loadsave.restore.cli" ) ) ; restoreCLI . setSelected ( jEdit . getBooleanProperty ( "restore.cli" ) ) ; restoreCLI . setEnabled ( restore . isSelected ( ) ) ; addComponent ( restoreCLI ) ; newView = new JCheckBox ( jEdit . getProperty ( "options.loadsave.newView" ) ) ; newView . setSelected ( jEdit . getBooleanProperty ( "client.newView" ) ) ; addComponent ( newView ) ; persistentMarkers = new JCheckBox ( jEdit . getProperty ( "options.loadsave.persistentMarkers" ) ) ; persistentMarkers . setSelected ( jEdit . getBooleanProperty ( "persistentMarkers" ) ) ; addComponent ( persistentMarkers ) ; parseFully = new JCheckBox ( jEdit . getProperty ( "options.loadsave.parseFully" ) ) ; parseFully . setSelected ( jEdit . getBooleanProperty ( "parseFully" ) ) ; addComponent ( parseFully ) ; } public void _save ( ) { jEdit . setProperty ( "autosave" , autosave . getText ( ) ) ; jEdit . setProperty ( "backups" , backups . getText ( ) ) ; jEdit . setProperty ( "backup.directory" , backupDirectory . getText ( ) ) ; jEdit . setProperty ( "backup.prefix" , backupPrefix . getText ( ) ) ; jEdit . setProperty ( "backup.suffix" , backupSuffix . getText ( ) ) ; String lineSep = null ; switch ( lineSeparator . getSelectedIndex ( ) ) { case 0 : lineSep = "\n" ; break ; case 1 : lineSep = "\r\n" ; break ; case 2 : lineSep = "\r" ; break ; } jEdit . setProperty ( "buffer.lineSeparator" , lineSep ) ; jEdit . setProperty ( "buffer.encoding" , ( String ) encoding . getSelectedItem ( ) ) ; jEdit . setProperty ( "ioThreadCount" , ioThreadCount . getText ( ) ) ; jEdit . setBooleanProperty ( "restore" , restore . isSelected ( ) ) ; jEdit . setBooleanProperty ( "restore.cli" , restoreCLI . isSelected ( ) ) ; jEdit . setBooleanProperty ( "client.newView" , newView . isSelected ( ) ) ; jEdit . setBooleanProperty ( "persistentMarkers" , persistentMarkers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "parseFully" , parseFully . isSelected ( ) ) ; } private JTextField autosave ; private JTextField backups ; private JTextField backupDirectory ; private JTextField backupPrefix ; private JTextField backupSuffix ; private JComboBox lineSeparator ; private JComboBox encoding ; private JTextField ioThreadCount ; private JCheckBox restore ; private JCheckBox restoreCLI ; private JCheckBox newView ; private JCheckBox persistentMarkers ; private JCheckBox parseFully ; } 	1	['5', '6', '0', '4', '35', '0', '2', '3', '3', '0.711538462', '386', '1', '0', '0.993993994', '0.5', '3', '5', '73.6', '6', '2', '1']
package org . gjt . sp . jedit . syntax ; import java . util . Enumeration ; import java . util . Vector ; import javax . swing . text . Segment ; public class ParserRuleSet { public ParserRuleSet ( ) { ruleMapFirst = new ParserRule [ RULE_BUCKET_COUNT ] ; ruleMapLast = new ParserRule [ RULE_BUCKET_COUNT ] ; } public void addRule ( ParserRule r ) { int key = Character . toUpperCase ( r . searchChars [ 0 ] ) % RULE_BUCKET_COUNT ; ParserRule last = ruleMapLast [ key ] ; if ( last == null ) ruleMapFirst [ key ] = ruleMapLast [ key ] = r ; else { last . next = r ; ruleMapLast [ key ] = r ; } } public void dump ( ) { for ( int i = 0 ; i < RULE_BUCKET_COUNT ; i ++ ) { ParserRule first = ruleMapFirst [ i ] ; if ( first == null ) System . err . println ( 0 ) ; else { int j = 0 ; while ( first != null ) { j ++ ; first = first . next ; } System . err . println ( j ) ; } } } public ParserRule getRules ( char ch ) { int key = Character . toUpperCase ( ch ) % RULE_BUCKET_COUNT ; return ruleMapFirst [ key ] ; } public int getTerminateChar ( ) { return terminateChar ; } public void setTerminateChar ( int atChar ) { terminateChar = ( atChar >= 0 ) ? atChar : - 1 ; } public boolean getIgnoreCase ( ) { return ignoreCase ; } public void setIgnoreCase ( boolean b ) { ignoreCase = b ; } public KeywordMap getKeywords ( ) { return keywords ; } public void setKeywords ( KeywordMap km ) { keywords = km ; } public boolean getHighlightDigits ( ) { return highlightDigits ; } public void setHighlightDigits ( boolean highlightDigits ) { this . highlightDigits = highlightDigits ; } public ParserRule getEscapeRule ( ) { return escapeRule ; } public Segment getEscapePattern ( ) { if ( escapePattern == null && escapeRule != null ) { escapePattern = new Segment ( escapeRule . searchChars , 0 , escapeRule . sequenceLengths [ 0 ] ) ; } return escapePattern ; } public void setEscape ( String esc ) { if ( esc == null ) { escapeRule = null ; } else { escapeRule = ParserRuleFactory . createEscapeRule ( esc ) ; } escapePattern = null ; } public byte getDefault ( ) { return defaultToken ; } public void setDefault ( byte def ) { defaultToken = def ; } private static final int RULE_BUCKET_COUNT = 32 ; private KeywordMap keywords ; private ParserRule [ ] ruleMapFirst ; private ParserRule [ ] ruleMapLast ; private ParserRule escapeRule ; private Segment escapePattern ; private int terminateChar = - 1 ; private boolean ignoreCase = true ; private boolean highlightDigits ; private byte defaultToken ; } 	1	['17', '1', '0', '8', '22', '100', '5', '3', '17', '0.91875', '199', '1', '4', '0', '0.183823529', '0', '0', '10.11764706', '4', '1.4118', '1']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . * ; public class IOProgressMonitor extends JDialog { public IOProgressMonitor ( View view ) { super ( view , jEdit . getProperty ( "io-progress-monitor.title" ) , false ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; caption = new JLabel ( ) ; updateCaption ( ) ; content . add ( BorderLayout . NORTH , caption ) ; Box threadBox = new Box ( BoxLayout . Y_AXIS ) ; threads = new ThreadProgress [ VFSManager . getIOThreadPool ( ) . getThreadCount ( ) ] ; for ( int i = 0 ; i < threads . length ; i ++ ) { threadBox . add ( Box . createVerticalStrut ( 6 ) ) ; threads [ i ] = new ThreadProgress ( i ) ; threadBox . add ( threads [ i ] ) ; } content . add ( BorderLayout . CENTER , threadBox ) ; workThreadHandler = new WorkThreadHandler ( ) ; VFSManager . getIOThreadPool ( ) . addProgressListener ( workThreadHandler ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; GUIUtilities . loadGeometry ( this , "io-progress-monitor" ) ; show ( ) ; } public void dispose ( ) { GUIUtilities . saveGeometry ( this , "io-progress-monitor" ) ; VFSManager . getIOThreadPool ( ) . removeProgressListener ( workThreadHandler ) ; super . dispose ( ) ; } private JLabel caption ; private ThreadProgress [ ] threads ; private WorkThreadHandler workThreadHandler ; private void updateCaption ( ) { String [ ] args = { String . valueOf ( VFSManager . getIOThreadPool ( ) . getRequestCount ( ) ) } ; caption . setText ( jEdit . getProperty ( "io-progress-monitor.caption" , args ) ) ; } class WorkThreadHandler implements WorkThreadProgressListener { public void progressUpdate ( WorkThreadPool pool , int index ) { updateCaption ( ) ; threads [ index ] . update ( ) ; } } class ThreadProgress extends JPanel { public ThreadProgress ( int index ) { super ( new BorderLayout ( ) ) ; this . index = index ; JPanel box = new JPanel ( ) ; box . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; box . setLayout ( new BoxLayout ( box , BoxLayout . Y_AXIS ) ) ; box . add ( Box . createGlue ( ) ) ; box . add ( progress = new JProgressBar ( ) ) ; progress . setStringPainted ( true ) ; box . add ( Box . createGlue ( ) ) ; ThreadProgress . this . add ( BorderLayout . CENTER , box ) ; abort = new JButton ( jEdit . getProperty ( "io-progress-monitor.abort" ) ) ; abort . addActionListener ( new ActionHandler ( ) ) ; ThreadProgress . this . add ( BorderLayout . EAST , abort ) ; update ( ) ; } public void update ( ) { WorkThread thread = VFSManager . getIOThreadPool ( ) . getThread ( index ) ; if ( thread . isRequestRunning ( ) ) { abort . setEnabled ( true ) ; progress . setString ( thread . getStatus ( ) ) ; progress . setMaximum ( thread . getProgressMaximum ( ) ) ; progress . setValue ( thread . getProgressValue ( ) ) ; } else { abort . setEnabled ( false ) ; progress . setString ( jEdit . getProperty ( "io-progress-monitor" + ".idle" ) ) ; progress . setValue ( 0 ) ; } } private int index ; private JProgressBar progress ; private JButton abort ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == abort ) { int result = GUIUtilities . confirm ( IOProgressMonitor . this , "abort" , null , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { VFSManager . getIOThreadPool ( ) . getThread ( index ) . abortCurrentRequest ( ) ; } } } } } } 	1	['5', '6', '0', '10', '33', '4', '4', '8', '2', '0.666666667', '152', '1', '2', '0.99389313', '0.4', '1', '1', '28.8', '1', '0.8', '1']
package org . gjt . sp . jedit . pluginmgr ; import com . microstar . xml . XmlException ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . InterruptedIOException ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; class PluginListDownloadProgress extends JDialog { PluginListDownloadProgress ( PluginManager window ) { super ( JOptionPane . getFrameForComponent ( window ) , jEdit . getProperty ( "plugin-list.progress.title" ) , true ) ; this . window = window ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel caption = new JLabel ( jEdit . getProperty ( "plugin-list.progress.caption" ) ) ; caption . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; content . add ( BorderLayout . NORTH , caption ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; JButton stop = new JButton ( jEdit . getProperty ( "plugin-list.progress.stop" ) ) ; stop . addActionListener ( new ActionHandler ( ) ) ; stop . setMaximumSize ( stop . getPreferredSize ( ) ) ; box . add ( stop ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . CENTER , box ) ; addWindowListener ( new WindowHandler ( ) ) ; setDefaultCloseOperation ( DO_NOTHING_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( window ) ; setResizable ( false ) ; show ( ) ; } PluginList getPluginList ( ) { return list ; } private PluginManager window ; private PluginList list ; private DownloadThread thread ; class DownloadThread extends Thread { public void run ( ) { try { list = new PluginList ( ) ; dispose ( ) ; } catch ( InterruptedIOException iio ) { dispose ( ) ; } catch ( XmlException xe ) { dispose ( ) ; int line = xe . getLine ( ) ; String path = jEdit . getProperty ( "plugin-manager.url" ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , this , path + ":" + line + ": " + message ) ; String [ ] pp = { path , String . valueOf ( line ) , message } ; GUIUtilities . error ( window , "plugin-list.xmlerror" , pp ) ; } catch ( Exception e ) { dispose ( ) ; Log . log ( Log . ERROR , this , e ) ; String [ ] pp = { e . toString ( ) } ; GUIUtilities . error ( window , "plugin-list.ioerror" , pp ) ; } } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { thread . interrupt ( ) ; } } class WindowHandler extends WindowAdapter { boolean done ; public void windowActivated ( WindowEvent evt ) { if ( done ) return ; done = true ; thread = new DownloadThread ( ) ; thread . start ( ) ; } public void windowClosing ( WindowEvent evt ) { thread . interrupt ( ) ; } } } 	1	['7', '6', '0', '7', '33', '11', '4', '6', '0', '0.777777778', '145', '1', '3', '0.99086758', '0.285714286', '0', '0', '19.28571429', '1', '0.8571', '1']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import java . io . * ; import java . util . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class BufferHistory { public static Entry getEntry ( String path ) { Enumeration enum = history . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Entry entry = ( Entry ) enum . nextElement ( ) ; if ( pathsCaseInsensitive ) { if ( entry . path . equalsIgnoreCase ( path ) ) return entry ; } else { if ( entry . path . equals ( path ) ) return entry ; } } return null ; } public static void setEntry ( String path , int caret , Selection [ ] selection , String encoding ) { removeEntry ( path ) ; addEntry ( new Entry ( path , caret , selectionToString ( selection ) , encoding ) ) ; } public static Vector getBufferHistory ( ) { return history ; } public static void load ( File file ) { try { max = Integer . parseInt ( jEdit . getProperty ( "recentFiles" ) ) ; } catch ( NumberFormatException e ) { max = 50 ; } Log . log ( Log . MESSAGE , jEdit . class , "Loading recent file list " + file ) ; RecentHandler handler = new RecentHandler ( ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( handler ) ; try { BufferedReader in = new BufferedReader ( new FileReader ( file ) ) ; parser . parse ( null , null , in ) ; } catch ( XmlException xe ) { int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , BufferHistory . class , file + ":" + line + ": " + message ) ; } catch ( FileNotFoundException fnf ) { Log . log ( Log . DEBUG , BufferHistory . class , fnf ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , BufferHistory . class , e ) ; } } public static void save ( File file ) { String lineSep = System . getProperty ( "line.separator" ) ; try { BufferedWriter out = new BufferedWriter ( new FileWriter ( file ) ) ; out . write ( "<?xml version=\"1.0\"?>" ) ; out . write ( lineSep ) ; out . write ( "<!DOCTYPE RECENT SYSTEM \"recent.dtd\">" ) ; out . write ( lineSep ) ; out . write ( "<RECENT>" ) ; out . write ( lineSep ) ; Enumeration enum = history . elements ( ) ; while ( enum . hasMoreElements ( ) ) { out . write ( "<ENTRY>" ) ; out . write ( lineSep ) ; Entry entry = ( Entry ) enum . nextElement ( ) ; out . write ( "<PATH><![CDATA[" ) ; out . write ( entry . path ) ; out . write ( "]]></PATH>" ) ; out . write ( lineSep ) ; out . write ( "<CARET>" ) ; out . write ( String . valueOf ( entry . caret ) ) ; out . write ( "</CARET>" ) ; out . write ( lineSep ) ; if ( entry . selection != null && entry . selection . length ( ) > 0 ) { out . write ( "<SELECTION>" ) ; out . write ( entry . selection ) ; out . write ( "</SELECTION>" ) ; out . write ( lineSep ) ; } if ( entry . encoding != null ) { out . write ( "<ENCODING>" ) ; out . write ( entry . encoding ) ; out . write ( "</ENCODING>" ) ; out . write ( lineSep ) ; } out . write ( "</ENTRY>" ) ; out . write ( lineSep ) ; } out . write ( "</RECENT>" ) ; out . write ( lineSep ) ; out . close ( ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , BufferHistory . class , e ) ; } } private static Vector history ; private static boolean pathsCaseInsensitive ; private static int max ; static { history = new Vector ( ) ; pathsCaseInsensitive = ( File . separatorChar == '\\' || File . separatorChar == ':' ) ; } static void addEntry ( Entry entry ) { history . addElement ( entry ) ; while ( history . size ( ) > max ) history . removeElementAt ( 0 ) ; } static void removeEntry ( String path ) { Enumeration enum = history . elements ( ) ; for ( int i = 0 ; i < history . size ( ) ; i ++ ) { Entry entry = ( Entry ) history . elementAt ( i ) ; if ( entry . path . equals ( path ) ) { history . removeElementAt ( i ) ; return ; } } } private static String selectionToString ( Selection [ ] s ) { if ( s == null ) return null ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( i != 0 ) buf . append ( ' ' ) ; Selection sel = s [ i ] ; if ( sel instanceof Selection . Range ) buf . append ( "range " ) ; else buf . append ( "rect " ) ; buf . append ( sel . getStart ( ) ) ; buf . append ( ' ' ) ; buf . append ( sel . getEnd ( ) ) ; } return buf . toString ( ) ; } private static Selection [ ] stringToSelection ( String s ) { if ( s == null ) return null ; Vector selection = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( s ) ; while ( st . hasMoreTokens ( ) ) { String type = st . nextToken ( ) ; int start = Integer . parseInt ( st . nextToken ( ) ) ; int end = Integer . parseInt ( st . nextToken ( ) ) ; Selection sel ; if ( type . equals ( "range" ) ) sel = new Selection . Range ( start , end ) ; else sel = new Selection . Rect ( start , end ) ; selection . addElement ( sel ) ; } Selection [ ] returnValue = new Selection [ selection . size ( ) ] ; selection . copyInto ( returnValue ) ; return returnValue ; } public static class Entry { public String path ; public int caret ; public String selection ; public String encoding ; public Selection [ ] getSelection ( ) { return stringToSelection ( selection ) ; } public Entry ( String path , int caret , String selection , String encoding ) { this . path = path ; this . caret = caret ; this . selection = selection ; this . encoding = encoding ; } } static class RecentHandler extends HandlerBase { public Object resolveEntity ( String publicId , String systemId ) { if ( "recent.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "recent.dtd" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error while opening" + " recent.dtd:" ) ; Log . log ( Log . ERROR , this , e ) ; } } return null ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "RECENT" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , "recent.xml: DOCTYPE must be RECENT" ) ; } public void endElement ( String name ) { if ( name . equals ( "ENTRY" ) ) { addEntry ( new Entry ( path , caret , selection , encoding ) ) ; path = null ; caret = 0 ; selection = null ; encoding = null ; } else if ( name . equals ( "PATH" ) ) path = charData ; else if ( name . equals ( "CARET" ) ) caret = Integer . parseInt ( charData ) ; else if ( name . equals ( "SELECTION" ) ) selection = charData ; else if ( name . equals ( "ENCODING" ) ) encoding = charData ; } public void charData ( char [ ] ch , int start , int length ) { charData = new String ( ch , start , length ) ; } private String path ; private int caret ; private String selection ; private String encoding ; private String charData ; } } 	1	['13', '1', '0', '11', '61', '44', '4', '10', '6', '0.833333333', '488', '1', '0', '0', '0.180555556', '0', '0', '36.15384615', '6', '2.5385', '1']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . text . Segment ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . * ; public class StatusBar extends JPanel { public StatusBar ( View view ) { super ( new BorderLayout ( 3 , 3 ) ) ; setBorder ( new EmptyBorder ( 3 , 0 , 0 , 0 ) ) ; this . view = view ; Border border = new BevelBorder ( BevelBorder . LOWERED ) ; caretStatus = new VICaretStatus ( ) ; caretStatus . setBorder ( border ) ; add ( BorderLayout . WEST , caretStatus ) ; message = new JLabel ( ) ; message . setForeground ( Color . black ) ; message . setBorder ( border ) ; add ( BorderLayout . CENTER , message ) ; MouseHandler mouseHandler = new MouseHandler ( ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; mode = new JLabel ( ) ; mode . setForeground ( Color . black ) ; mode . setBorder ( border ) ; mode . setToolTipText ( jEdit . getProperty ( "view.status.mode-tooltip" ) ) ; mode . addMouseListener ( mouseHandler ) ; box . add ( mode ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; encoding = new JLabel ( ) ; encoding . setForeground ( Color . black ) ; encoding . setBorder ( border ) ; encoding . setToolTipText ( jEdit . getProperty ( "view.status.encoding-tooltip" ) ) ; encoding . addMouseListener ( mouseHandler ) ; box . add ( encoding ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; multiSelect = new JLabel ( "multi" ) ; multiSelect . setBorder ( border ) ; multiSelect . addMouseListener ( mouseHandler ) ; box . add ( multiSelect ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; overwrite = new JLabel ( "over" ) ; overwrite . setBorder ( border ) ; overwrite . addMouseListener ( mouseHandler ) ; box . add ( overwrite ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; fold = new JLabel ( "fold" ) ; fold . setBorder ( border ) ; box . add ( fold ) ; updateBufferStatus ( ) ; updateMiscStatus ( ) ; updateFoldStatus ( ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; ioProgress = new MiniIOProgress ( ) ; ioProgress . setBorder ( border ) ; ioProgress . addMouseListener ( mouseHandler ) ; box . add ( ioProgress ) ; Dimension dim = multiSelect . getPreferredSize ( ) ; dim . width = 40 ; ioProgress . setPreferredSize ( dim ) ; add ( BorderLayout . EAST , box ) ; } public void setMessageAndClear ( String message ) { setMessage ( message ) ; tempTimer = new Timer ( 0 , new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { setMessage ( null ) ; } } ) ; tempTimer . setInitialDelay ( 10000 ) ; tempTimer . setRepeats ( false ) ; tempTimer . start ( ) ; } public void setMessage ( String message ) { if ( tempTimer != null ) { tempTimer . stop ( ) ; tempTimer = null ; } if ( message == null ) { InputHandler inputHandler = view . getInputHandler ( ) ; if ( inputHandler . isRepeatEnabled ( ) ) { int repeatCount = inputHandler . getRepeatCount ( ) ; this . message . setText ( jEdit . getProperty ( "view.status.repeat" , new Object [ ] { repeatCount == 1 ? "" : String . valueOf ( repeatCount ) } ) ) ; } else if ( view . getMacroRecorder ( ) != null ) this . message . setText ( jEdit . getProperty ( "view.status.recording" ) ) ; else this . message . setText ( null ) ; } else this . message . setText ( message ) ; } public void repaintCaretStatus ( ) { caretStatus . repaint ( ) ; } public void updateBufferStatus ( ) { Buffer buffer = view . getBuffer ( ) ; mode . setText ( buffer . getMode ( ) . getName ( ) ) ; encoding . setText ( buffer . getProperty ( "encoding" ) . toString ( ) ) ; } public void updateMiscStatus ( ) { JEditTextArea textArea = view . getTextArea ( ) ; if ( textArea . isMultipleSelectionEnabled ( ) ) multiSelect . setForeground ( Color . black ) ; else { if ( textArea . getSelectionCount ( ) > 1 ) { multiSelect . setForeground ( UIManager . getColor ( "Label.foreground" ) ) ; } else multiSelect . setForeground ( gray ) ; } if ( textArea . isOverwriteEnabled ( ) ) overwrite . setForeground ( Color . black ) ; else overwrite . setForeground ( gray ) ; } public void updateFoldStatus ( ) { Buffer buffer = view . getBuffer ( ) ; if ( buffer . getLineCount ( ) != buffer . getVirtualLineCount ( ) ) fold . setForeground ( Color . black ) ; else fold . setForeground ( gray ) ; } private View view ; private VICaretStatus caretStatus ; private JLabel message ; private JLabel mode ; private JLabel encoding ; private JLabel multiSelect ; private JLabel overwrite ; private JLabel fold ; private MiniIOProgress ioProgress ; private Color gray = new Color ( 142 , 142 , 142 ) ; StringBuffer buf = new StringBuffer ( ) ; private Timer tempTimer ; class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { Object source = evt . getSource ( ) ; if ( source == mode || source == encoding ) new BufferOptions ( view , view . getBuffer ( ) ) ; else if ( source == multiSelect ) view . getTextArea ( ) . toggleMultipleSelectionEnabled ( ) ; else if ( source == overwrite ) view . getTextArea ( ) . toggleOverwriteEnabled ( ) ; else if ( source == ioProgress ) new IOProgressMonitor ( view ) ; } } class VICaretStatus extends JComponent { public VICaretStatus ( ) { VICaretStatus . this . setForeground ( UIManager . getColor ( "Button.foreground" ) ) ; VICaretStatus . this . setBackground ( UIManager . getColor ( "Label.background" ) ) ; VICaretStatus . this . setFont ( UIManager . getFont ( "Label.font" ) ) ; Dimension size = new Dimension ( VICaretStatus . this . getFontMetrics ( VICaretStatus . this . getFont ( ) ) . stringWidth ( testStr ) , 0 ) ; VICaretStatus . this . setPreferredSize ( size ) ; } public void paintComponent ( Graphics g ) { Buffer buffer = view . getBuffer ( ) ; if ( ! buffer . isLoaded ( ) ) return ; FontMetrics fm = g . getFontMetrics ( ) ; JEditTextArea textArea = view . getTextArea ( ) ; int currLine = textArea . getCaretLine ( ) ; int dot = textArea . getCaretPosition ( ) - textArea . getLineStartOffset ( currLine ) ; int virtualPosition = getVirtualPosition ( dot , buffer , textArea ) ; buf . setLength ( 0 ) ; buf . append ( Integer . toString ( currLine + 1 ) ) ; buf . append ( ',' ) ; buf . append ( Integer . toString ( dot + 1 ) ) ; if ( virtualPosition != dot ) { buf . append ( '-' ) ; buf . append ( Integer . toString ( virtualPosition + 1 ) ) ; } buf . append ( ' ' ) ; int firstLine = textArea . getFirstLine ( ) ; int visible = textArea . getVisibleLines ( ) ; int lineCount = textArea . getVirtualLineCount ( ) ; if ( visible >= lineCount ) { buf . append ( "All" ) ; } else if ( firstLine == 0 ) { buf . append ( "Top" ) ; } else if ( firstLine + visible >= lineCount ) { buf . append ( "Bot" ) ; } else { float percent = ( float ) firstLine / ( float ) lineCount * 100.0f ; buf . append ( Integer . toString ( ( int ) percent ) ) ; buf . append ( '%' ) ; } g . drawString ( buf . toString ( ) , VICaretStatus . this . getBorder ( ) . getBorderInsets ( this ) . left + 1 , ( VICaretStatus . this . getHeight ( ) + fm . getAscent ( ) ) / 2 - 1 ) ; } private static final String testStr = "9999,999-999 99%" ; private Segment seg = new Segment ( ) ; private int getVirtualPosition ( int dot , Buffer buffer , JEditTextArea textArea ) { int line = textArea . getCaretLine ( ) ; textArea . getLineText ( line , seg ) ; int virtualPosition = 0 ; int tabSize = buffer . getTabSize ( ) ; for ( int i = 0 ; i < seg . count && i < dot ; ++ i ) { char ch = seg . array [ seg . offset + i ] ; if ( ch == '\t' ) { virtualPosition += tabSize - ( virtualPosition % tabSize ) ; } else { ++ virtualPosition ; } } return virtualPosition ; } } class MiniIOProgress extends JComponent implements WorkThreadProgressListener { public MiniIOProgress ( ) { MiniIOProgress . this . setDoubleBuffered ( true ) ; MiniIOProgress . this . setForeground ( UIManager . getColor ( "Button.foreground" ) ) ; MiniIOProgress . this . setBackground ( UIManager . getColor ( "Button.background" ) ) ; icon = GUIUtilities . loadIcon ( "io.gif" ) ; } public void addNotify ( ) { super . addNotify ( ) ; VFSManager . getIOThreadPool ( ) . addProgressListener ( this ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; VFSManager . getIOThreadPool ( ) . removeProgressListener ( this ) ; } public void progressUpdate ( WorkThreadPool threadPool , int threadIndex ) { MiniIOProgress . this . repaint ( ) ; } public void paintComponent ( Graphics g ) { WorkThreadPool ioThreadPool = VFSManager . getIOThreadPool ( ) ; if ( ioThreadPool . getThreadCount ( ) == 0 ) return ; FontMetrics fm = g . getFontMetrics ( ) ; if ( ioThreadPool . getRequestCount ( ) == 0 ) return ; else { icon . paintIcon ( this , g , MiniIOProgress . this . getWidth ( ) - icon . getIconWidth ( ) - 3 , ( MiniIOProgress . this . getHeight ( ) - icon . getIconHeight ( ) ) / 2 ) ; } Insets insets = MiniIOProgress . this . getBorder ( ) . getBorderInsets ( this ) ; int progressHeight = ( MiniIOProgress . this . getHeight ( ) - insets . top - insets . bottom ) / ioThreadPool . getThreadCount ( ) ; int progressWidth = MiniIOProgress . this . getWidth ( ) - icon . getIconWidth ( ) - insets . left - insets . right - 2 ; for ( int i = 0 ; i < ioThreadPool . getThreadCount ( ) ; i ++ ) { WorkThread thread = ioThreadPool . getThread ( i ) ; int max = thread . getProgressMaximum ( ) ; if ( ! thread . isRequestRunning ( ) || max == 0 ) continue ; int value = thread . getProgressValue ( ) ; double progressRatio = ( ( double ) value / max ) ; progressRatio = Math . min ( progressRatio , 1.0 ) ; g . fillRect ( insets . left , insets . top + i * progressHeight , ( int ) ( progressRatio * progressWidth ) , progressHeight ) ; } } public Dimension getPreferredSize ( ) { return new Dimension ( 40 , icon . getIconHeight ( ) ) ; } private Icon icon ; } } 	1	['14', '5', '0', '20', '72', '37', '17', '11', '8', '0.857142857', '533', '0.928571429', '3', '0.98048048', '0.257142857', '2', '5', '36.07142857', '6', '1.7857', '4']
package org . gjt . sp . jedit ; import gnu . regexp . * ; import java . util . Hashtable ; import org . gjt . sp . jedit . syntax . TokenMarker ; import org . gjt . sp . util . Log ; public class Mode { public Mode ( String name ) { this . name = name ; props = new Hashtable ( ) ; } public void init ( ) { try { String filenameGlob = ( String ) getProperty ( "filenameGlob" ) ; if ( filenameGlob != null && filenameGlob . length ( ) != 0 ) { filenameRE = new RE ( MiscUtilities . globToRE ( filenameGlob ) , RE . REG_ICASE ) ; } String firstlineGlob = ( String ) getProperty ( "firstlineGlob" ) ; if ( firstlineGlob != null && firstlineGlob . length ( ) != 0 ) { firstlineRE = new RE ( MiscUtilities . globToRE ( firstlineGlob ) , RE . REG_ICASE ) ; } } catch ( REException re ) { Log . log ( Log . ERROR , this , "Invalid filename/firstline" + " globs in mode " + name ) ; Log . log ( Log . ERROR , this , re ) ; } } public TokenMarker getTokenMarker ( ) { loadIfNecessary ( ) ; return marker ; } public void setTokenMarker ( TokenMarker marker ) { this . marker = marker ; } public void loadIfNecessary ( ) { if ( marker == null ) jEdit . loadMode ( this ) ; } public Object getProperty ( String key ) { String prefix = "mode." + name + "." ; String property = jEdit . getProperty ( prefix + key ) ; if ( property != null ) { Object value ; try { value = new Integer ( property ) ; } catch ( NumberFormatException nf ) { value = property ; } return value ; } Object value = props . get ( key ) ; if ( value != null ) return value ; String global = jEdit . getProperty ( "buffer." + key ) ; if ( global != null ) { try { return new Integer ( global ) ; } catch ( NumberFormatException nf ) { return global ; } } else return null ; } public boolean getBooleanProperty ( String key ) { Object value = getProperty ( key ) ; if ( "true" . equals ( value ) || "on" . equals ( value ) || "yes" . equals ( value ) ) return true ; else return false ; } public void setProperty ( String key , Object value ) { props . put ( key , value ) ; } public void unsetProperty ( String key ) { props . remove ( key ) ; } public boolean accept ( String fileName , String firstLine ) { if ( filenameRE != null && filenameRE . isMatch ( fileName ) ) return true ; if ( firstlineRE != null && firstlineRE . isMatch ( firstLine ) ) return true ; return false ; } public String getName ( ) { return name ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + getName ( ) + "]" ; } private String name ; private Hashtable props ; private RE firstlineRE ; private RE filenameRE ; private TokenMarker marker ; } 	1	['12', '1', '0', '19', '32', '36', '15', '6', '12', '0.745454545', '236', '1', '3', '0', '0.416666667', '0', '0', '18.25', '5', '2', '1']
package org . gjt . sp . jedit . browser ; import java . awt . * ; import javax . swing . * ; import javax . swing . tree . * ; import javax . swing . border . * ; import org . gjt . sp . jedit . io . VFS ; import org . gjt . sp . jedit . * ; public final class FileCellRenderer extends JLabel implements TreeCellRenderer { public FileCellRenderer ( ) { Font font = UIManager . getFont ( "Tree.font" ) ; setFont ( new Font ( font . getFamily ( ) , font . getStyle ( ) , font . getSize ( ) ) ) ; UIDefaults metalDefaults = new javax . swing . plaf . metal . MetalLookAndFeel ( ) . getDefaults ( ) ; fileIcon = metalDefaults . getIcon ( "FileView.fileIcon" ) ; dirIcon = metalDefaults . getIcon ( "FileView.directoryIcon" ) ; filesystemIcon = metalDefaults . getIcon ( "FileView.hardDriveIcon" ) ; loadingIcon = metalDefaults . getIcon ( "FileView.hardDriveIcon" ) ; setOpaque ( true ) ; } public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean focus ) { if ( sel ) { setBackground ( treeSelectionBackground ) ; setForeground ( treeSelectionForeground ) ; } else { setBackground ( treeNoSelectionBackground ) ; setForeground ( treeNoSelectionForeground ) ; } DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) value ; Object userObject = treeNode . getUserObject ( ) ; if ( userObject instanceof VFS . DirectoryEntry ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) userObject ; boolean opened = ( jEdit . getBuffer ( file . path ) != null ) ; setBorder ( opened ? openBorder : closedBorder ) ; if ( showIcons ) { setIcon ( getIconForFile ( file ) ) ; setText ( file . name ) ; } else { setIcon ( null ) ; setText ( file . type == VFS . DirectoryEntry . DIRECTORY ? file . name + "/" : file . name ) ; } } else if ( userObject instanceof BrowserView . LoadingPlaceholder ) { if ( showIcons ) setIcon ( loadingIcon ) ; else setIcon ( null ) ; setText ( jEdit . getProperty ( "vfs.browser.tree.loading" ) ) ; setBorder ( closedBorder ) ; } else if ( userObject instanceof String ) { if ( showIcons ) { setIcon ( dirIcon ) ; setText ( ( String ) userObject ) ; } else { setIcon ( null ) ; setText ( userObject + "/" ) ; } setBorder ( closedBorder ) ; } else { setIcon ( null ) ; setText ( null ) ; } return this ; } protected Icon getIconForFile ( VFS . DirectoryEntry file ) { if ( file . type == VFS . DirectoryEntry . DIRECTORY ) return dirIcon ; else if ( file . type == VFS . DirectoryEntry . FILESYSTEM ) return filesystemIcon ; else return fileIcon ; } boolean showIcons ; void propertiesChanged ( ) { setBackground ( UIManager . getColor ( "Tree.textBackground" ) ) ; showIcons = jEdit . getBooleanProperty ( "vfs.browser.showIcons" ) ; if ( showIcons ) { closedBorder = new EmptyBorder ( 0 , 3 , 0 , 0 ) ; openBorder = new CompoundBorder ( new MatteBorder ( 0 , 2 , 0 , 0 , UIManager . getColor ( "Tree.textForeground" ) ) , new EmptyBorder ( 0 , 1 , 0 , 0 ) ) ; } else { closedBorder = new EmptyBorder ( 1 , 4 , 1 , 1 ) ; openBorder = new CompoundBorder ( new MatteBorder ( 0 , 2 , 0 , 0 , UIManager . getColor ( "Tree.textForeground" ) ) , new EmptyBorder ( 1 , 2 , 1 , 1 ) ) ; } treeSelectionForeground = UIManager . getColor ( "Tree.selectionForeground" ) ; treeNoSelectionForeground = UIManager . getColor ( "Tree.textForeground" ) ; treeSelectionBackground = UIManager . getColor ( "Tree.selectionBackground" ) ; treeNoSelectionBackground = UIManager . getColor ( "Tree.textBackground" ) ; } private Icon fileIcon ; private Icon dirIcon ; private Icon filesystemIcon ; private Icon loadingIcon ; private Border closedBorder ; private Border openBorder ; private Color treeSelectionForeground ; private Color treeNoSelectionForeground ; private Color treeSelectionBackground ; private Color treeNoSelectionBackground ; } 	1	['4', '5', '0', '5', '32', '0', '1', '4', '2', '0.575757576', '313', '0.909090909', '0', '0.995601173', '0.375', '0', '0', '74.5', '11', '4', '4']
package org . gjt . sp . jedit ; import javax . swing . text . * ; import org . gjt . sp . jedit . syntax . * ; public class TextUtilities { public static int findMatchingBracket ( Buffer buffer , int line , int offset ) throws BadLocationException { return findMatchingBracket ( buffer , line , offset , 0 , buffer . getDefaultRootElement ( ) . getElementCount ( ) ) ; } public static int findMatchingBracket ( Buffer buffer , int line , int offset , int startLine , int endLine ) throws BadLocationException { if ( buffer . getLength ( ) == 0 ) return - 1 ; Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( line ) ; Segment lineText = new Segment ( ) ; int lineStart = lineElement . getStartOffset ( ) ; buffer . getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 , lineText ) ; char c = lineText . array [ lineText . offset + offset ] ; char cprime ; boolean direction ; switch ( c ) { case '(' : cprime = ')' ; direction = false ; break ; case ')' : cprime = '(' ; direction = true ; break ; case '[' : cprime = ']' ; direction = false ; break ; case ']' : cprime = '[' ; direction = true ; break ; case '{' : cprime = '}' ; direction = false ; break ; case '}' : cprime = '{' ; direction = true ; break ; default : return - 1 ; } int count ; byte idOfBracket = Token . NULL ; Buffer . LineInfo lineInfo = buffer . markTokens ( line ) ; Token lineTokens = lineInfo . getFirstToken ( ) ; int tokenListOffset = 0 ; for ( ; ; ) { if ( lineTokens . id == Token . END ) throw new InternalError ( "offset > line length" ) ; if ( tokenListOffset + lineTokens . length > offset ) { idOfBracket = lineTokens . id ; break ; } else { tokenListOffset += lineTokens . length ; lineTokens = lineTokens . next ; } } if ( direction ) { count = 0 ; for ( int i = line ; i >= startLine ; i -- ) { lineElement = map . getElement ( i ) ; lineStart = lineElement . getStartOffset ( ) ; int lineLength = lineElement . getEndOffset ( ) - lineStart - 1 ; buffer . getText ( lineStart , lineLength , lineText ) ; int scanStartOffset ; if ( i != line ) { lineTokens = buffer . markTokens ( i ) . getLastToken ( ) ; tokenListOffset = scanStartOffset = lineLength - 1 ; } else { if ( tokenListOffset != lineLength ) tokenListOffset += lineTokens . length ; scanStartOffset = offset ; } while ( lineTokens != null ) { byte id = lineTokens . id ; if ( id == Token . END ) { lineTokens = lineTokens . prev ; continue ; } int len = lineTokens . length ; if ( id == idOfBracket ) { for ( int j = scanStartOffset ; j >= Math . max ( 0 , tokenListOffset - len ) ; j -- ) { if ( j >= lineText . count ) System . err . println ( "WARNING: " + j + " >= " + lineText . count ) ; else if ( j < 0 ) { System . err . println ( "sso=" + scanStartOffset + ", tlo=" + tokenListOffset + ",len=" + len ) ; System . err . println ( "WARNING: " + j + " < 0" ) ; } char ch = lineText . array [ lineText . offset + j ] ; if ( ch == c ) count ++ ; else if ( ch == cprime ) { if ( -- count == 0 ) return lineStart + j ; } } } scanStartOffset = tokenListOffset = tokenListOffset - len ; lineTokens = lineTokens . prev ; } } } else { count = 0 ; for ( int i = line ; i < endLine ; i ++ ) { lineElement = map . getElement ( i ) ; lineStart = lineElement . getStartOffset ( ) ; buffer . getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 , lineText ) ; int scanStartOffset ; if ( i != line ) { lineTokens = buffer . markTokens ( i ) . getFirstToken ( ) ; tokenListOffset = 0 ; scanStartOffset = 0 ; } else scanStartOffset = offset + 1 ; for ( ; ; ) { byte id = lineTokens . id ; if ( id == Token . END ) break ; int len = lineTokens . length ; if ( id == idOfBracket ) { for ( int j = scanStartOffset ; j < tokenListOffset + len ; j ++ ) { char ch = lineText . array [ lineText . offset + j ] ; if ( ch == c ) count ++ ; else if ( ch == cprime ) { if ( count -- == 0 ) return lineStart + j ; } } } scanStartOffset = tokenListOffset = tokenListOffset + len ; lineTokens = lineTokens . next ; } } } return - 1 ; } public static int findWordStart ( String line , int pos , String noWordSep ) { char ch = line . charAt ( pos ) ; if ( noWordSep == null ) noWordSep = "" ; boolean selectNoLetter = ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ; int wordStart = 0 ; for ( int i = pos ; i >= 0 ; i -- ) { ch = line . charAt ( i ) ; if ( selectNoLetter ^ ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ) { wordStart = i + 1 ; break ; } } return wordStart ; } public static int findWordEnd ( String line , int pos , String noWordSep ) { if ( pos != 0 ) pos -- ; char ch = line . charAt ( pos ) ; if ( noWordSep == null ) noWordSep = "" ; boolean selectNoLetter = ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ; int wordEnd = line . length ( ) ; for ( int i = pos ; i < line . length ( ) ; i ++ ) { ch = line . charAt ( i ) ; if ( selectNoLetter ^ ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ) { wordEnd = i ; break ; } } return wordEnd ; } public static boolean regionMatches ( boolean ignoreCase , Segment text , int offset , char [ ] match ) { int length = offset + match . length ; char [ ] textArray = text . array ; if ( length > text . offset + text . count ) return false ; for ( int i = offset , j = 0 ; i < length ; i ++ , j ++ ) { char c1 = textArray [ i ] ; char c2 = match [ j ] ; if ( ignoreCase ) { c1 = Character . toUpperCase ( c1 ) ; c2 = Character . toUpperCase ( c2 ) ; } if ( c1 != c2 ) return false ; } return true ; } public static String spacesToTabs ( String in , int tabSize ) { StringBuffer buf = new StringBuffer ( ) ; int width = 0 ; int whitespace = 0 ; for ( int i = 0 ; i < in . length ( ) ; i ++ ) { switch ( in . charAt ( i ) ) { case ' ' : whitespace ++ ; width ++ ; break ; case '\t' : int tab = tabSize - ( width % tabSize ) ; width += tab ; whitespace += tab ; break ; case '\n' : if ( whitespace != 0 ) { buf . append ( MiscUtilities . createWhiteSpace ( whitespace , tabSize ) ) ; } whitespace = 0 ; width = 0 ; buf . append ( '\n' ) ; break ; default : if ( whitespace != 0 ) { buf . append ( MiscUtilities . createWhiteSpace ( whitespace , tabSize ) ) ; whitespace = 0 ; } buf . append ( in . charAt ( i ) ) ; width ++ ; break ; } } if ( whitespace != 0 ) { buf . append ( MiscUtilities . createWhiteSpace ( whitespace , tabSize ) ) ; } return buf . toString ( ) ; } public static String tabsToSpaces ( String in , int tabSize ) { StringBuffer buf = new StringBuffer ( ) ; int width = 0 ; for ( int i = 0 ; i < in . length ( ) ; i ++ ) { switch ( in . charAt ( i ) ) { case '\t' : int count = tabSize - ( width % tabSize ) ; width += count ; while ( -- count >= 0 ) buf . append ( ' ' ) ; break ; case '\n' : width = 0 ; buf . append ( in . charAt ( i ) ) ; break ; default : width ++ ; buf . append ( in . charAt ( i ) ) ; break ; } } return buf . toString ( ) ; } public static String format ( String text , int maxLineLength ) { StringBuffer buf = new StringBuffer ( ) ; StringBuffer word = new StringBuffer ( ) ; int lineLength = 0 ; boolean newline = true ; boolean space = false ; char [ ] chars = text . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { char c = chars [ i ] ; switch ( c ) { case '\n' : if ( i == 0 || chars . length - i <= 2 ) { if ( lineLength + word . length ( ) >= maxLineLength ) buf . append ( '\n' ) ; else if ( space && word . length ( ) != 0 ) buf . append ( ' ' ) ; buf . append ( word ) ; word . setLength ( 0 ) ; buf . append ( '\n' ) ; newline = true ; space = false ; break ; } else if ( newline ) { if ( lineLength + word . length ( ) >= maxLineLength ) buf . append ( '\n' ) ; else if ( space && word . length ( ) != 0 ) buf . append ( ' ' ) ; buf . append ( word ) ; word . setLength ( 0 ) ; buf . append ( "\n\n" ) ; newline = space = false ; lineLength = 0 ; break ; } else newline = true ; case ' ' : if ( lineLength + word . length ( ) >= maxLineLength ) { buf . append ( '\n' ) ; lineLength = 0 ; newline = true ; } else if ( space && lineLength != 0 && word . length ( ) != 0 ) { buf . append ( ' ' ) ; lineLength ++ ; space = false ; } else space = true ; buf . append ( word ) ; lineLength += word . length ( ) ; word . setLength ( 0 ) ; break ; default : newline = false ; if ( lineLength != 0 ) space = true ; word . append ( c ) ; break ; } } if ( lineLength + word . length ( ) >= maxLineLength ) buf . append ( '\n' ) ; else if ( space && word . length ( ) != 0 ) buf . append ( ' ' ) ; buf . append ( word ) ; return buf . toString ( ) ; } } 	1	['9', '1', '0', '8', '39', '36', '5', '4', '9', '2', '904', '0', '0', '0', '0.301587302', '0', '0', '99.44444444', '20', '6', '5']
package org . gjt . sp . jedit ; import java . io . * ; import java . lang . reflect . Modifier ; import java . net . * ; import java . util . * ; import java . util . zip . * ; import org . gjt . sp . util . Log ; public class JARClassLoader extends ClassLoader { public JARClassLoader ( ) { } public JARClassLoader ( String path ) throws IOException { zipFile = new ZipFile ( path ) ; Enumeration entires = zipFile . entries ( ) ; while ( entires . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) entires . nextElement ( ) ; String name = entry . getName ( ) ; String lname = name . toLowerCase ( ) ; if ( lname . equals ( "actions.xml" ) ) { jEdit . loadActions ( path + "!actions.xml" , new BufferedReader ( new InputStreamReader ( zipFile . getInputStream ( entry ) ) ) , true ) ; } else if ( lname . endsWith ( ".props" ) ) jEdit . loadProps ( zipFile . getInputStream ( entry ) , true ) ; else if ( name . endsWith ( "Plugin.class" ) ) pluginClasses . addElement ( name ) ; } jar = new EditPlugin . JAR ( path , this ) ; jEdit . addPluginJAR ( jar ) ; } public Class loadClass ( String clazz , boolean resolveIt ) throws ClassNotFoundException { return loadClass ( clazz , resolveIt , true ) ; } public InputStream getResourceAsStream ( String name ) { if ( zipFile == null ) return null ; try { ZipEntry entry = zipFile . getEntry ( name ) ; if ( entry == null ) return getSystemResourceAsStream ( name ) ; else return zipFile . getInputStream ( entry ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; return null ; } } public URL getResource ( String name ) { if ( zipFile == null ) return null ; ZipEntry entry = zipFile . getEntry ( name ) ; if ( entry == null ) return getSystemResource ( name ) ; try { return new URL ( getResourceAsPath ( name ) ) ; } catch ( MalformedURLException mu ) { Log . log ( Log . ERROR , this , mu ) ; return null ; } } public String getResourceAsPath ( String name ) { if ( zipFile == null ) return null ; if ( ! name . startsWith ( "/" ) ) name = "/" + name ; return "jeditresource:/" + MiscUtilities . getFileName ( jar . getPath ( ) ) + "!" + name ; } public void closeZipFile ( ) { if ( zipFile == null ) return ; try { zipFile . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; } zipFile = null ; } public ZipFile getZipFile ( ) { return zipFile ; } void startAllPlugins ( ) { for ( int i = 0 ; i < pluginClasses . size ( ) ; i ++ ) { String name = ( String ) pluginClasses . elementAt ( i ) ; name = MiscUtilities . fileToClass ( name ) ; try { loadPluginClass ( name ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , this , "Error while starting plugin " + name ) ; Log . log ( Log . ERROR , this , t ) ; jar . addPlugin ( new EditPlugin . Broken ( name ) ) ; String [ ] args = { name , t . toString ( ) } ; GUIUtilities . error ( null , "plugin.start-error" , args ) ; } } } private EditPlugin . JAR jar ; private Vector pluginClasses = new Vector ( ) ; private ZipFile zipFile ; private void loadPluginClass ( String name ) throws Exception { EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { if ( plugins [ i ] . getClass ( ) . getName ( ) . equals ( name ) ) { String [ ] args = { name } ; GUIUtilities . error ( null , "plugin.already-loaded" , args ) ; return ; } } if ( ! checkDependencies ( name ) ) { jar . addPlugin ( new EditPlugin . Broken ( name ) ) ; return ; } Class clazz = loadClass ( name , true ) ; int modifiers = clazz . getModifiers ( ) ; if ( ! Modifier . isInterface ( modifiers ) && ! Modifier . isAbstract ( modifiers ) && EditPlugin . class . isAssignableFrom ( clazz ) ) { String version = jEdit . getProperty ( "plugin." + name + ".version" ) ; if ( version == null ) { Log . log ( Log . WARNING , this , "Plugin " + name + " doesn't" + " have a 'version' property." ) ; version = "" ; } else version = " (version " + version + ")" ; Log . log ( Log . NOTICE , this , "Starting plugin " + name + version ) ; jar . addPlugin ( ( EditPlugin ) clazz . newInstance ( ) ) ; } } private boolean checkDependencies ( String name ) { int i = 0 ; String dep ; while ( ( dep = jEdit . getProperty ( "plugin." + name + ".depend." + i ++ ) ) != null ) { int index = dep . indexOf ( ' ' ) ; if ( index == - 1 ) { Log . log ( Log . ERROR , this , name + " has an invalid" + " dependency: " + dep ) ; return false ; } String what = dep . substring ( 0 , index ) ; String arg = dep . substring ( index + 1 ) ; if ( what . equals ( "jdk" ) ) { if ( System . getProperty ( "java.version" ) . compareTo ( arg ) < 0 ) { String [ ] args = { name , arg , System . getProperty ( "java.version" ) } ; GUIUtilities . error ( null , "plugin.dep-jdk" , args ) ; return false ; } } else if ( what . equals ( "jedit" ) ) { if ( jEdit . getBuild ( ) . compareTo ( arg ) < 0 ) { String needs = MiscUtilities . buildToVersion ( arg ) ; String [ ] args = { name , needs , jEdit . getVersion ( ) } ; GUIUtilities . error ( null , "plugin.dep-jedit" , args ) ; return false ; } } else if ( what . equals ( "plugin" ) ) { int index2 = arg . indexOf ( ' ' ) ; if ( index2 == - 1 ) { Log . log ( Log . ERROR , this , name + " has an invalid dependency: " + dep + " (version is missing)" ) ; return false ; } String plugin = arg . substring ( 0 , index2 ) ; String needVersion = arg . substring ( index2 + 1 ) ; String currVersion = jEdit . getProperty ( "plugin." + plugin + ".version" ) ; if ( currVersion == null ) { String [ ] args = { name , needVersion , plugin } ; GUIUtilities . error ( null , "plugin.dep-plugin.no-version" , args ) ; return false ; } if ( MiscUtilities . compareVersions ( currVersion , needVersion ) < 0 ) { String [ ] args = { name , needVersion , plugin , currVersion } ; GUIUtilities . error ( null , "plugin.dep-plugin" , args ) ; return false ; } if ( jEdit . getPlugin ( plugin ) instanceof EditPlugin . Broken ) { String [ ] args = { name , plugin } ; GUIUtilities . error ( null , "plugin.dep-plugin.broken" , args ) ; return false ; } } else if ( what . equals ( "class" ) ) { try { loadClass ( arg , false ) ; } catch ( Exception e ) { String [ ] args = { name , arg } ; GUIUtilities . error ( null , "plugin.dep-class" , args ) ; return false ; } } else { Log . log ( Log . ERROR , this , name + " has unknown" + " dependency: " + dep ) ; return false ; } } return true ; } private Class findOtherClass ( String clazz , boolean resolveIt ) throws ClassNotFoundException { EditPlugin . JAR [ ] jars = jEdit . getPluginJARs ( ) ; for ( int i = 0 ; i < jars . length ; i ++ ) { JARClassLoader loader = jars [ i ] . getClassLoader ( ) ; Class cls = loader . loadClass ( clazz , resolveIt , false ) ; if ( cls != null ) return cls ; } ClassLoader loader = getClass ( ) . getClassLoader ( ) ; if ( loader != null ) return loader . loadClass ( clazz ) ; return findSystemClass ( clazz ) ; } private Class loadClass ( String clazz , boolean resolveIt , boolean doDepencies ) throws ClassNotFoundException { Class cls = findLoadedClass ( clazz ) ; if ( cls != null ) { if ( resolveIt ) resolveClass ( cls ) ; return cls ; } if ( zipFile == null ) { if ( doDepencies ) return findOtherClass ( clazz , resolveIt ) ; else return null ; } String name = MiscUtilities . classToFile ( clazz ) ; try { ZipEntry entry = zipFile . getEntry ( name ) ; if ( entry == null ) { if ( doDepencies ) return findOtherClass ( clazz , resolveIt ) ; else return null ; } InputStream in = zipFile . getInputStream ( entry ) ; int len = ( int ) entry . getSize ( ) ; byte [ ] data = new byte [ len ] ; int success = 0 ; int offset = 0 ; while ( success < len ) { len -= success ; offset += success ; success = in . read ( data , offset , len ) ; if ( success == - 1 ) { Log . log ( Log . ERROR , this , "Failed to load class " + clazz + " from " + zipFile . getName ( ) ) ; throw new ClassNotFoundException ( clazz ) ; } } cls = defineClass ( clazz , data , 0 , data . length ) ; if ( resolveIt ) resolveClass ( cls ) ; return cls ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; throw new ClassNotFoundException ( clazz ) ; } } } 	1	['14', '2', '0', '11', '88', '35', '6', '7', '8', '0.673076923', '889', '1', '1', '0.842105263', '0.619047619', '1', '7', '62.21428571', '10', '2.0714', '4']
package org . gjt . sp . jedit . gui ; import javax . swing . KeyStroke ; import java . awt . event . * ; import java . awt . Toolkit ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class DefaultInputHandler extends InputHandler { public DefaultInputHandler ( View view ) { super ( view ) ; bindings = currentBindings = new Hashtable ( ) ; } public DefaultInputHandler ( View view , DefaultInputHandler copy ) { super ( view ) ; bindings = currentBindings = copy . bindings ; } public void addKeyBinding ( String keyBinding , EditAction action ) { Hashtable current = bindings ; StringTokenizer st = new StringTokenizer ( keyBinding ) ; while ( st . hasMoreTokens ( ) ) { KeyStroke keyStroke = parseKeyStroke ( st . nextToken ( ) ) ; if ( keyStroke == null ) return ; if ( st . hasMoreTokens ( ) ) { Object o = current . get ( keyStroke ) ; if ( o instanceof Hashtable ) current = ( Hashtable ) o ; else { o = new Hashtable ( ) ; current . put ( keyStroke , o ) ; current = ( Hashtable ) o ; } } else current . put ( keyStroke , action ) ; } } public void removeKeyBinding ( String keyBinding ) { throw new InternalError ( "Not yet implemented" ) ; } public void removeAllKeyBindings ( ) { bindings . clear ( ) ; } public Object getKeyBinding ( String keyBinding ) { Hashtable current = bindings ; StringTokenizer st = new StringTokenizer ( keyBinding ) ; while ( st . hasMoreTokens ( ) ) { KeyStroke keyStroke = parseKeyStroke ( st . nextToken ( ) ) ; if ( keyStroke == null ) return null ; if ( st . hasMoreTokens ( ) ) { Object o = current . get ( keyStroke ) ; if ( o instanceof Hashtable ) current = ( Hashtable ) o ; else return o ; } else { return current . get ( keyStroke ) ; } } return null ; } public boolean isPrefixActive ( ) { return bindings != currentBindings ; } public void keyPressed ( KeyEvent evt ) { int keyCode = evt . getKeyCode ( ) ; int modifiers = evt . getModifiers ( ) ; if ( modifiers == 0 && bindings == currentBindings && ( keyCode == KeyEvent . VK_ENTER || keyCode == KeyEvent . VK_TAB ) ) { userInput ( ( char ) keyCode ) ; evt . consume ( ) ; return ; } if ( ( modifiers & ~ KeyEvent . SHIFT_MASK ) == 0 ) { switch ( keyCode ) { case KeyEvent . VK_BACK_SPACE : case KeyEvent . VK_DELETE : case KeyEvent . VK_ESCAPE : case KeyEvent . VK_ENTER : case KeyEvent . VK_TAB : break ; default : if ( ! evt . isActionKey ( ) ) return ; else break ; } } if ( readNextChar != null ) { readNextChar = null ; view . getStatus ( ) . setMessage ( null ) ; } KeyStroke keyStroke = KeyStroke . getKeyStroke ( keyCode , modifiers ) ; Object o = currentBindings . get ( keyStroke ) ; if ( o == null ) { if ( currentBindings != bindings ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; repeatCount = 0 ; repeat = false ; evt . consume ( ) ; } currentBindings = bindings ; return ; } else if ( o instanceof EditAction ) { currentBindings = bindings ; invokeAction ( ( EditAction ) o ) ; evt . consume ( ) ; return ; } else if ( o instanceof Hashtable ) { currentBindings = ( Hashtable ) o ; evt . consume ( ) ; return ; } } public void keyTyped ( KeyEvent evt ) { char c = evt . getKeyChar ( ) ; if ( c == '\b' ) return ; KeyStroke keyStroke ; if ( c == ' ' ) keyStroke = KeyStroke . getKeyStroke ( KeyEvent . VK_SPACE , 0 ) ; else keyStroke = KeyStroke . getKeyStroke ( c ) ; Object o = currentBindings . get ( keyStroke ) ; if ( o instanceof Hashtable ) { currentBindings = ( Hashtable ) o ; return ; } else if ( o instanceof EditAction ) { currentBindings = bindings ; invokeAction ( ( EditAction ) o ) ; return ; } currentBindings = bindings ; if ( repeat && Character . isDigit ( c ) ) { repeatCount *= 10 ; repeatCount += ( c - '0' ) ; view . getStatus ( ) . setMessage ( null ) ; } else userInput ( c ) ; } public static KeyStroke parseKeyStroke ( String keyStroke ) { if ( keyStroke == null ) return null ; int modifiers = 0 ; int index = keyStroke . indexOf ( '+' ) ; if ( index != - 1 ) { for ( int i = 0 ; i < index ; i ++ ) { switch ( Character . toUpperCase ( keyStroke . charAt ( i ) ) ) { case 'A' : modifiers |= InputEvent . ALT_MASK ; break ; case 'C' : if ( macOS ) modifiers |= InputEvent . META_MASK ; else modifiers |= InputEvent . CTRL_MASK ; break ; case 'M' : if ( macOS ) modifiers |= InputEvent . CTRL_MASK ; else modifiers |= InputEvent . META_MASK ; break ; case 'S' : modifiers |= InputEvent . SHIFT_MASK ; break ; } } } String key = keyStroke . substring ( index + 1 ) ; if ( key . length ( ) == 1 ) { char ch = key . charAt ( 0 ) ; if ( modifiers == 0 ) return KeyStroke . getKeyStroke ( ch ) ; else { return KeyStroke . getKeyStroke ( Character . toUpperCase ( ch ) , modifiers ) ; } } else if ( key . length ( ) == 0 ) { Log . log ( Log . ERROR , DefaultInputHandler . class , "Invalid key stroke: " + keyStroke ) ; return null ; } else { int ch ; try { ch = KeyEvent . class . getField ( "VK_" . concat ( key ) ) . getInt ( null ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , DefaultInputHandler . class , "Invalid key stroke: " + keyStroke ) ; return null ; } return KeyStroke . getKeyStroke ( ch , modifiers ) ; } } private Hashtable bindings ; private Hashtable currentBindings ; private static boolean macOS ; static { macOS = ( System . getProperty ( "os.name" ) . indexOf ( "MacOS" ) != - 1 ) ; } } 	1	['12', '3', '0', '6', '52', '8', '2', '5', '10', '0.672727273', '501', '1', '0', '0.666666667', '0.303030303', '1', '4', '40.33333333', '17', '4.3333', '5']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . lang . reflect . Field ; import java . util . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class GrabKeyDialog extends JDialog { public GrabKeyDialog ( Component comp , KeyBinding binding , Vector allBindings ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "grab-key.title" ) , true ) ; this . binding = binding ; this . allBindings = allBindings ; enableEvents ( AWTEvent . KEY_EVENT_MASK ) ; JPanel content = new JPanel ( new GridLayout ( 0 , 1 , 0 , 6 ) ) { public boolean isManagingFocus ( ) { return false ; } public boolean getFocusTraversalKeysEnabled ( ) { return false ; } } ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "grab-key.caption" , new String [ ] { binding . label } ) ) ; Box input = Box . createHorizontalBox ( ) ; shortcut = new InputPane ( ) ; input . add ( shortcut ) ; input . add ( Box . createHorizontalStrut ( 12 ) ) ; clear = new JButton ( jEdit . getProperty ( "grab-key.clear" ) ) ; clear . addActionListener ( new ActionHandler ( ) ) ; input . add ( clear ) ; assignedTo = new JLabel ( ) ; updateAssignedTo ( null ) ; Box buttons = Box . createHorizontalBox ( ) ; buttons . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( ok ) ; buttons . add ( Box . createHorizontalStrut ( 12 ) ) ; if ( binding . isAssigned ( ) ) { remove = new JButton ( jEdit . getProperty ( "grab-key.remove" ) ) ; remove . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( remove ) ; buttons . add ( Box . createHorizontalStrut ( 12 ) ) ; } cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( cancel ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( label ) ; content . add ( input ) ; content . add ( assignedTo ) ; content . add ( buttons ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( comp ) ; setResizable ( false ) ; show ( ) ; } public String getShortcut ( ) { if ( isOK ) return shortcut . getText ( ) ; else return null ; } public boolean isOK ( ) { return isOK ; } public boolean isManagingFocus ( ) { return false ; } public boolean getFocusTraversalKeysEnabled ( ) { return false ; } protected void processKeyEvent ( KeyEvent evt ) { shortcut . processKeyEvent ( evt ) ; } private InputPane shortcut ; private JLabel assignedTo ; private JButton ok ; private JButton remove ; private JButton cancel ; private JButton clear ; private boolean isOK ; private KeyBinding binding ; private Vector allBindings ; private String getSymbolicName ( int keyCode ) { if ( keyCode == KeyEvent . VK_UNDEFINED ) return null ; if ( keyCode >= KeyEvent . VK_A && keyCode <= KeyEvent . VK_Z ) return String . valueOf ( Character . toLowerCase ( ( char ) keyCode ) ) ; try { Field [ ] fields = KeyEvent . class . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field field = fields [ i ] ; String name = field . getName ( ) ; if ( name . startsWith ( "VK_" ) && field . getInt ( null ) == keyCode ) { return name . substring ( 3 ) ; } } } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } return null ; } private void updateAssignedTo ( String shortcut ) { String text = jEdit . getProperty ( "grab-key.assigned-to.none" ) ; KeyBinding kb = getKeyBinding ( shortcut ) ; if ( kb != null ) if ( kb . isPrefix ) text = jEdit . getProperty ( "grab-key.assigned-to.prefix" , new String [ ] { shortcut } ) ; else text = kb . label ; if ( ok != null ) ok . setEnabled ( kb == null || ! kb . isPrefix ) ; assignedTo . setText ( jEdit . getProperty ( "grab-key.assigned-to" , new String [ ] { text } ) ) ; } private KeyBinding getKeyBinding ( String shortcut ) { if ( shortcut == null || shortcut . length ( ) == 0 ) return null ; String spacedShortcut = shortcut + " " ; Enumeration enum = allBindings . elements ( ) ; while ( enum . hasMoreElements ( ) ) { KeyBinding kb = ( KeyBinding ) enum . nextElement ( ) ; if ( ! kb . isAssigned ( ) ) continue ; String spacedKbShortcut = kb . shortcut + " " ; if ( spacedShortcut . startsWith ( spacedKbShortcut ) ) return kb ; if ( spacedKbShortcut . startsWith ( spacedShortcut ) ) { return new KeyBinding ( kb . name , kb . label , shortcut , true ) ; } } return null ; } public static class KeyBinding { public KeyBinding ( String name , String label , String shortcut , boolean isPrefix ) { this . name = name ; this . label = label ; this . shortcut = shortcut ; this . isPrefix = isPrefix ; } public String name ; public String label ; public String shortcut ; public boolean isPrefix ; public boolean isAssigned ( ) { return shortcut != null && shortcut . length ( ) > 0 ; } } class InputPane extends JTextField { public boolean getFocusTraversalKeysEnabled ( ) { return false ; } protected void processKeyEvent ( KeyEvent _evt ) { if ( _evt . getID ( ) != KeyEvent . KEY_PRESSED ) return ; KeyEvent evt = KeyEventWorkaround . processKeyEvent ( _evt ) ; if ( evt == null ) { Log . log ( Log . DEBUG , this , "Event " + _evt + " filtered" ) ; return ; } else Log . log ( Log . DEBUG , this , "Event " + _evt + " passed" ) ; evt . consume ( ) ; StringBuffer keyString = new StringBuffer ( getText ( ) ) ; if ( getDocument ( ) . getLength ( ) != 0 ) keyString . append ( ' ' ) ; boolean appendPlus = false ; if ( evt . isControlDown ( ) ) { keyString . append ( macOS ? 'M' : 'C' ) ; appendPlus = true ; } if ( evt . isAltDown ( ) ) { keyString . append ( 'A' ) ; appendPlus = true ; } if ( evt . isMetaDown ( ) ) { keyString . append ( macOS ? 'C' : 'M' ) ; appendPlus = true ; } if ( evt . getID ( ) != KeyEvent . KEY_TYPED && evt . isShiftDown ( ) ) { keyString . append ( 'S' ) ; appendPlus = true ; } if ( appendPlus ) keyString . append ( '+' ) ; int keyCode = evt . getKeyCode ( ) ; String symbolicName = getSymbolicName ( keyCode ) ; if ( symbolicName == null ) return ; keyString . append ( symbolicName ) ; setText ( keyString . toString ( ) ) ; updateAssignedTo ( keyString . toString ( ) ) ; } private boolean macOS = ( System . getProperty ( "os.name" ) . indexOf ( "MacOS" ) != - 1 ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) { if ( canClose ( ) ) dispose ( ) ; } else if ( evt . getSource ( ) == remove ) { shortcut . setText ( null ) ; isOK = true ; dispose ( ) ; } else if ( evt . getSource ( ) == cancel ) dispose ( ) ; else if ( evt . getSource ( ) == clear ) { shortcut . setText ( null ) ; updateAssignedTo ( null ) ; } } private boolean canClose ( ) { String shortcutString = shortcut . getText ( ) ; if ( shortcutString . length ( ) == 0 && binding . isAssigned ( ) ) { int answer = GUIUtilities . confirm ( GrabKeyDialog . this , "grab-key.remove-ask" , null , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( answer == JOptionPane . YES_OPTION ) { shortcut . setText ( null ) ; isOK = true ; } else if ( answer == JOptionPane . CANCEL_OPTION ) return false ; return true ; } KeyBinding other = getKeyBinding ( shortcutString ) ; if ( other == null || other == binding ) { isOK = true ; return true ; } if ( other . name == binding . name ) { GUIUtilities . error ( GrabKeyDialog . this , "grab-key.duplicate-alt-shortcut" , null ) ; return false ; } if ( other . isPrefix ) { GUIUtilities . error ( GrabKeyDialog . this , "grab-key.prefix-shortcut" , null ) ; return false ; } int answer = GUIUtilities . confirm ( GrabKeyDialog . this , "grab-key.duplicate-shortcut" , new Object [ ] { other . label } , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( answer == JOptionPane . YES_OPTION ) { if ( other . shortcut != null && shortcutString . startsWith ( other . shortcut ) ) { other . shortcut = null ; } isOK = true ; return true ; } else if ( answer == JOptionPane . CANCEL_OPTION ) return false ; return true ; } } } 	1	['21', '6', '0', '7', '71', '170', '4', '6', '5', '0.9', '508', '1', '2', '0.970193741', '0.169312169', '1', '1', '22.71428571', '8', '1.8571', '1']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . tree . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . File ; import java . util . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class PluginManager extends JDialog { public PluginManager ( View view ) { super ( view , jEdit . getProperty ( "plugin-manager.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel caption = new JLabel ( jEdit . getProperty ( "plugin-manager.caption" ) ) ; caption . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , caption ) ; tree = new JTree ( ) ; tree . setCellRenderer ( new Renderer ( ) ) ; tree . setRootVisible ( false ) ; tree . setVisibleRowCount ( 16 ) ; tree . addTreeSelectionListener ( new TreeHandler ( ) ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( BorderLayout . CENTER , new JScrollPane ( tree ) ) ; JPanel panel2 = new JPanel ( new BorderLayout ( ) ) ; panel2 . setBorder ( new EmptyBorder ( 6 , 0 , 0 , 0 ) ) ; JPanel labelBox = new JPanel ( new GridLayout ( 3 , 1 , 0 , 3 ) ) ; labelBox . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "plugin-manager" + ".info.name" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "plugin-manager" + ".info.author" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "plugin-manager" + ".info.version" ) , SwingConstants . RIGHT ) ) ; panel2 . add ( BorderLayout . WEST , labelBox ) ; JPanel valueBox = new JPanel ( new GridLayout ( 3 , 1 , 0 , 3 ) ) ; valueBox . add ( name = new JLabel ( ) ) ; valueBox . add ( author = new JLabel ( ) ) ; valueBox . add ( version = new JLabel ( ) ) ; panel2 . add ( BorderLayout . CENTER , valueBox ) ; panel . add ( BorderLayout . SOUTH , panel2 ) ; content . add ( BorderLayout . CENTER , panel ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; buttons . add ( Box . createGlue ( ) ) ; remove = new JButton ( jEdit . getProperty ( "plugin-manager" + ".remove" ) ) ; remove . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( remove ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; update = new JButton ( jEdit . getProperty ( "plugin-manager" + ".update" ) ) ; update . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( update ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; install = new JButton ( jEdit . getProperty ( "plugin-manager" + ".install" ) ) ; install . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( install ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( close ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , buttons ) ; updateTree ( ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } private JTree tree ; private JLabel name ; private JLabel author ; private JLabel version ; private JButton remove ; private JButton update ; private JButton install ; private JButton close ; private void updateTree ( ) { DefaultMutableTreeNode treeRoot = new DefaultMutableTreeNode ( ) ; DefaultTreeModel treeModel = new DefaultTreeModel ( treeRoot ) ; DefaultMutableTreeNode loadedTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "plugin-manager.loaded" ) , true ) ; DefaultMutableTreeNode notLoadedTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "plugin-manager.not-loaded" ) , true ) ; DefaultMutableTreeNode newTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "plugin-manager.new" ) , true ) ; EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin plugin = plugins [ i ] ; String path = plugin . getJAR ( ) . getPath ( ) ; if ( ! new File ( path ) . exists ( ) ) { continue ; } if ( plugin instanceof EditPlugin . Broken ) { Entry entry = new Entry ( path , plugin . getClassName ( ) , true ) ; notLoadedTree . add ( new DefaultMutableTreeNode ( entry ) ) ; } else { Entry entry = new Entry ( path , plugin . getClassName ( ) , false ) ; loadedTree . add ( new DefaultMutableTreeNode ( entry ) ) ; } } if ( notLoadedTree . getChildCount ( ) != 0 ) treeRoot . add ( notLoadedTree ) ; if ( loadedTree . getChildCount ( ) != 0 ) treeRoot . add ( loadedTree ) ; String [ ] newPlugins = jEdit . getNotLoadedPluginJARs ( ) ; for ( int i = 0 ; i < newPlugins . length ; i ++ ) { Entry entry = new Entry ( newPlugins [ i ] , null , false ) ; newTree . add ( new DefaultMutableTreeNode ( entry ) ) ; } if ( newTree . getChildCount ( ) != 0 ) treeRoot . add ( newTree ) ; tree . setModel ( treeModel ) ; for ( int i = 0 ; i < tree . getRowCount ( ) ; i ++ ) tree . expandRow ( i ) ; remove . setEnabled ( false ) ; name . setText ( null ) ; author . setText ( null ) ; version . setText ( null ) ; } class Entry { String clazz ; String name , version , author ; Vector jars ; boolean broken ; Entry ( String path , String clazz , boolean broken ) { Entry . this . clazz = clazz ; Entry . this . broken = broken ; jars = new Vector ( ) ; jars . addElement ( path ) ; if ( clazz == null ) Entry . this . name = path ; else { Entry . this . name = jEdit . getProperty ( "plugin." + clazz + ".name" ) ; if ( name == null ) name = clazz ; Entry . this . version = jEdit . getProperty ( "plugin." + clazz + ".version" ) ; Entry . this . author = jEdit . getProperty ( "plugin." + clazz + ".author" ) ; String jarsProp = jEdit . getProperty ( "plugin." + clazz + ".jars" ) ; if ( jarsProp != null ) { String directory = MiscUtilities . getParentOfPath ( path ) ; StringTokenizer st = new StringTokenizer ( jarsProp ) ; while ( st . hasMoreElements ( ) ) { jars . addElement ( MiscUtilities . constructPath ( directory , st . nextToken ( ) ) ) ; } } } } public String toString ( ) { return Entry . this . name ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == close ) dispose ( ) ; else if ( source == remove ) { TreePath [ ] selected = tree . getSelectionModel ( ) . getSelectionPaths ( ) ; StringBuffer buf = new StringBuffer ( ) ; Roster roster = new Roster ( ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { Object last = ( ( DefaultMutableTreeNode ) selected [ i ] . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( last instanceof Entry ) { Entry entry = ( Entry ) last ; for ( int j = 0 ; j < entry . jars . size ( ) ; j ++ ) { String jar = ( String ) entry . jars . elementAt ( j ) ; if ( buf . length ( ) != 0 ) buf . append ( '\n' ) ; buf . append ( jar ) ; roster . addOperation ( new Roster . Remove ( jar ) ) ; } } } String [ ] args = { buf . toString ( ) } ; if ( GUIUtilities . confirm ( PluginManager . this , "plugin-manager.remove-confirm" , args , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . YES_OPTION ) { new PluginManagerProgress ( PluginManager . this , jEdit . getProperty ( "plugin-manager.progress" + ".removing-task" ) , roster ) ; updateTree ( ) ; } } else if ( source == update ) { PluginList list = new PluginListDownloadProgress ( PluginManager . this ) . getPluginList ( ) ; if ( list == null ) return ; if ( jEdit . getSettingsDirectory ( ) == null ) { GUIUtilities . error ( PluginManager . this , "no-settings" , null ) ; return ; } Vector plugins = new Vector ( ) ; for ( int i = 0 ; i < list . plugins . size ( ) ; i ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) list . plugins . elementAt ( i ) ; PluginList . Branch branch = plugin . getCompatibleBranch ( ) ; if ( branch != null && plugin . installedVersion != null && MiscUtilities . compareVersions ( branch . version , plugin . installedVersion ) > 0 ) plugins . addElement ( plugin ) ; } if ( plugins . size ( ) == 0 ) { GUIUtilities . message ( PluginManager . this , "plugin-manager.up-to-date" , null ) ; return ; } Roster roster = new Roster ( ) ; new InstallPluginsDialog ( PluginManager . this , plugins , InstallPluginsDialog . UPDATE ) . installPlugins ( roster ) ; if ( roster . isEmpty ( ) ) return ; new PluginManagerProgress ( PluginManager . this , jEdit . getProperty ( "plugin-manager.progress" + ".updating-task" ) , roster ) ; updateTree ( ) ; } else if ( source == install ) { PluginList list = new PluginListDownloadProgress ( PluginManager . this ) . getPluginList ( ) ; if ( list == null ) return ; if ( jEdit . getSettingsDirectory ( ) == null && jEdit . getJEditHome ( ) == null ) { GUIUtilities . error ( PluginManager . this , "no-settings" , null ) ; return ; } Vector plugins = new Vector ( ) ; for ( int i = 0 ; i < list . plugins . size ( ) ; i ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) list . plugins . elementAt ( i ) ; if ( plugin . installed == null && plugin . canBeInstalled ( ) ) plugins . addElement ( plugin ) ; } Roster roster = new Roster ( ) ; new InstallPluginsDialog ( PluginManager . this , plugins , InstallPluginsDialog . INSTALL ) . installPlugins ( roster ) ; if ( roster . isEmpty ( ) ) return ; new PluginManagerProgress ( PluginManager . this , jEdit . getProperty ( "plugin-manager.progress" + ".installing-task" ) , roster ) ; updateTree ( ) ; } } } class TreeHandler implements TreeSelectionListener { public void valueChanged ( TreeSelectionEvent evt ) { TreePath selection = evt . getPath ( ) ; DefaultMutableTreeNode node ; if ( selection == null ) { node = null ; } else { node = ( DefaultMutableTreeNode ) selection . getLastPathComponent ( ) ; } name . setText ( null ) ; author . setText ( null ) ; version . setText ( null ) ; if ( node != null && node . isLeaf ( ) && node . getUserObject ( ) instanceof Entry ) { remove . setEnabled ( true ) ; Entry entry = ( Entry ) node . getUserObject ( ) ; if ( entry . clazz != null ) { name . setText ( entry . name ) ; author . setText ( entry . author ) ; version . setText ( entry . version ) ; } } else remove . setEnabled ( false ) ; } } class Renderer extends DefaultTreeCellRenderer { public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean selected , boolean expanded , boolean leaf , int row , boolean hasFocus ) { super . getTreeCellRendererComponent ( tree , value , selected , expanded , leaf , row , hasFocus ) ; setIcon ( null ) ; return this ; } } } 	1	['11', '6', '0', '11', '64', '27', '6', '9', '1', '0.775', '595', '1', '0', '0.984871407', '0.363636364', '0', '0', '52.36363636', '12', '1.9091', '3']
package org . gjt . sp . jedit . search ; import java . awt . event . * ; import java . awt . * ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . text . BadLocationException ; import javax . swing . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . jedit . gui . HistoryTextField ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class SearchBar extends JPanel { public SearchBar ( View view ) { super ( new BorderLayout ( ) ) ; this . view = view ; JLabel label = new JLabel ( jEdit . getProperty ( "view.search.find" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 2 , 0 , 12 ) ) ; add ( label , BorderLayout . WEST ) ; Box box = new Box ( BoxLayout . Y_AXIS ) ; box . add ( Box . createGlue ( ) ) ; box . add ( find = new HistoryTextField ( "find" ) ) ; Dimension min = find . getPreferredSize ( ) ; min . width = Integer . MAX_VALUE ; find . setMaximumSize ( min ) ; ActionHandler actionHandler = new ActionHandler ( ) ; find . addKeyListener ( new KeyHandler ( ) ) ; find . addActionListener ( actionHandler ) ; find . getDocument ( ) . addDocumentListener ( new DocumentHandler ( ) ) ; box . add ( Box . createGlue ( ) ) ; add ( box , BorderLayout . CENTER ) ; Insets margin = new Insets ( 1 , 1 , 1 , 1 ) ; Box buttons = new Box ( BoxLayout . X_AXIS ) ; buttons . add ( Box . createHorizontalStrut ( 12 ) ) ; buttons . add ( ignoreCase = new JCheckBox ( jEdit . getProperty ( "search.case" ) ) ) ; ignoreCase . addActionListener ( actionHandler ) ; ignoreCase . setMargin ( margin ) ; buttons . add ( Box . createHorizontalStrut ( 2 ) ) ; buttons . add ( regexp = new JCheckBox ( jEdit . getProperty ( "search.regexp" ) ) ) ; regexp . addActionListener ( actionHandler ) ; regexp . setMargin ( margin ) ; buttons . add ( Box . createHorizontalStrut ( 2 ) ) ; buttons . add ( hyperSearch = new JCheckBox ( jEdit . getProperty ( "search.hypersearch" ) ) ) ; hyperSearch . addActionListener ( actionHandler ) ; hyperSearch . setMargin ( margin ) ; update ( ) ; add ( buttons , BorderLayout . EAST ) ; } public HistoryTextField getField ( ) { return find ; } public void setHyperSearch ( boolean hyperSearch ) { jEdit . setBooleanProperty ( "view.search.hypersearch.toggle" , hyperSearch ) ; this . hyperSearch . setSelected ( hyperSearch ) ; find . setModel ( this . hyperSearch . isSelected ( ) ? "find" : null ) ; } public void update ( ) { ignoreCase . setSelected ( SearchAndReplace . getIgnoreCase ( ) ) ; regexp . setSelected ( SearchAndReplace . getRegexp ( ) ) ; hyperSearch . setSelected ( jEdit . getBooleanProperty ( "view.search.hypersearch.toggle" ) ) ; find . setModel ( hyperSearch . isSelected ( ) ? "find" : null ) ; } private View view ; private HistoryTextField find ; private JCheckBox ignoreCase , regexp , hyperSearch ; private void find ( boolean reverse ) { String text = find . getText ( ) ; if ( text . length ( ) == 0 ) { jEdit . setBooleanProperty ( "search.hypersearch.toggle" , hyperSearch . isSelected ( ) ) ; new SearchDialog ( view , null ) ; } else if ( hyperSearch . isSelected ( ) ) { find . setText ( null ) ; SearchAndReplace . setSearchString ( text ) ; SearchAndReplace . setSearchFileSet ( new CurrentBufferSet ( ) ) ; SearchAndReplace . hyperSearch ( view ) ; } else { int start ; JEditTextArea textArea = view . getTextArea ( ) ; Selection s = textArea . getSelectionAtOffset ( textArea . getCaretPosition ( ) ) ; if ( s == null ) start = textArea . getCaretPosition ( ) ; else if ( reverse ) start = s . getStart ( ) ; else start = s . getEnd ( ) ; if ( ! incrementalSearch ( start , reverse ) ) { if ( ! incrementalSearch ( reverse ? view . getBuffer ( ) . getLength ( ) : 0 , reverse ) ) { getToolkit ( ) . beep ( ) ; } } } } private boolean incrementalSearch ( int start , boolean reverse ) { SearchAndReplace . setSearchFileSet ( new CurrentBufferSet ( ) ) ; SearchAndReplace . setSearchString ( find . getText ( ) ) ; SearchAndReplace . setReverseSearch ( reverse ) ; try { if ( SearchAndReplace . find ( view , view . getBuffer ( ) , start ) ) return true ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } catch ( Exception e ) { Log . log ( Log . DEBUG , this , e ) ; return true ; } return false ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( evt . getSource ( ) == find ) find ( false ) ; else if ( evt . getSource ( ) == hyperSearch ) { jEdit . setBooleanProperty ( "view.search.hypersearch.toggle" , hyperSearch . isSelected ( ) ) ; update ( ) ; } else if ( evt . getSource ( ) == ignoreCase ) { SearchAndReplace . setIgnoreCase ( ignoreCase . isSelected ( ) ) ; } else if ( evt . getSource ( ) == regexp ) { SearchAndReplace . setRegexp ( regexp . isSelected ( ) ) ; } } } class DocumentHandler implements DocumentListener { public void insertUpdate ( DocumentEvent evt ) { if ( ! hyperSearch . isSelected ( ) ) { int start ; JEditTextArea textArea = view . getTextArea ( ) ; Selection s = textArea . getSelectionAtOffset ( textArea . getCaretPosition ( ) ) ; if ( s == null ) start = textArea . getCaretPosition ( ) ; else start = s . getStart ( ) ; if ( ! incrementalSearch ( start , false ) ) { if ( ! incrementalSearch ( 0 , false ) ) { getToolkit ( ) . beep ( ) ; } } } } public void removeUpdate ( DocumentEvent evt ) { if ( ! hyperSearch . isSelected ( ) ) { String text = find . getText ( ) ; if ( text . length ( ) != 0 ) { if ( regexp . isSelected ( ) ) { incrementalSearch ( 0 , false ) ; } else { int start ; JEditTextArea textArea = view . getTextArea ( ) ; Selection s = textArea . getSelectionAtOffset ( textArea . getCaretPosition ( ) ) ; if ( s == null ) start = textArea . getCaretPosition ( ) ; else start = s . getStart ( ) ; incrementalSearch ( start , true ) ; } } } } public void changedUpdate ( DocumentEvent evt ) { } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { switch ( evt . getKeyCode ( ) ) { case KeyEvent . VK_LEFT : case KeyEvent . VK_RIGHT : case KeyEvent . VK_UP : case KeyEvent . VK_DOWN : if ( ! hyperSearch . isSelected ( ) ) { evt . consume ( ) ; view . getEditPane ( ) . focusOnTextArea ( ) ; view . getEditPane ( ) . getTextArea ( ) . processKeyEvent ( evt ) ; } break ; case KeyEvent . VK_ESCAPE : evt . consume ( ) ; view . getEditPane ( ) . focusOnTextArea ( ) ; break ; case KeyEvent . VK_ENTER : if ( evt . isShiftDown ( ) ) { evt . consume ( ) ; find ( true ) ; } break ; } } } } 	1	['13', '5', '0', '14', '65', '14', '4', '14', '4', '0.633333333', '398', '1', '2', '0.981954887', '0.323076923', '2', '5', '29.23076923', '8', '1.6154', '3']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class AboutDialog extends EnhancedDialog { public AboutDialog ( View view ) { super ( view , jEdit . getProperty ( "about.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBackground ( Color . white ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBackground ( Color . white ) ; String [ ] args = { jEdit . getVersion ( ) } ; JLabel label = new JLabel ( jEdit . getProperty ( "about.version" , args ) , SwingConstants . CENTER ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; panel . add ( BorderLayout . NORTH , label ) ; JLabel splash = new JLabel ( new ImageIcon ( getClass ( ) . getResource ( "/org/gjt/sp/jedit/jedit_logo.gif" ) ) ) ; panel . add ( BorderLayout . CENTER , splash ) ; label = new JLabel ( jEdit . getProperty ( "about.caption" ) , SwingConstants . CENTER ) ; label . setBorder ( new EmptyBorder ( 12 , 0 , 12 , 0 ) ) ; panel . add ( BorderLayout . SOUTH , label ) ; content . add ( BorderLayout . CENTER , panel ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( new ActionHandler ( ) ) ; getRootPane ( ) . setDefaultButton ( close ) ; box . add ( close ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; pack ( ) ; setResizable ( false ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } private JButton close ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { dispose ( ) ; } } } 	1	['3', '7', '0', '4', '33', '3', '1', '4', '3', '1', '176', '1', '0', '0.996946565', '0.666666667', '0', '0', '57.33333333', '1', '0.6667', '2']
package org . gjt . sp . jedit ; import bsh . * ; import javax . swing . text . BadLocationException ; import javax . swing . text . Segment ; import javax . swing . JFileChooser ; import java . lang . reflect . InvocationTargetException ; import java . io . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . gui . BeanShellErrorDialog ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . util . Log ; public class BeanShell { public static void evalSelection ( View view , JEditTextArea textArea ) { String command = textArea . getSelectedText ( ) ; if ( command == null ) { view . getToolkit ( ) . beep ( ) ; return ; } Object returnValue = eval ( view , command , false ) ; if ( returnValue != null ) textArea . setSelectedText ( returnValue . toString ( ) ) ; } public static void showEvaluateDialog ( View view ) { String command = GUIUtilities . input ( view , "beanshell-eval-input" , null ) ; if ( command != null ) { if ( ! command . endsWith ( ";" ) ) command = command + ";" ; int repeat = view . getInputHandler ( ) . getRepeatCount ( ) ; if ( view . getMacroRecorder ( ) != null ) { view . getMacroRecorder ( ) . record ( repeat , command ) ; } Object returnValue = null ; try { for ( int i = 0 ; i < repeat ; i ++ ) { returnValue = eval ( view , command , true ) ; } } catch ( Error t ) { } if ( returnValue != null ) { String [ ] args = { returnValue . toString ( ) } ; GUIUtilities . message ( view , "beanshell-eval" , args ) ; } } } public static void showRunScriptDialog ( View view ) { String [ ] paths = GUIUtilities . showVFSFileDialog ( view , null , JFileChooser . OPEN_DIALOG , true ) ; if ( paths != null ) { Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < paths . length ; i ++ ) runScript ( view , paths [ i ] , true , false ) ; } finally { buffer . endCompoundEdit ( ) ; } } } public static void runScript ( View view , String path , boolean ownNamespace , boolean rethrowBshErrors ) { Reader in ; Buffer buffer = jEdit . getBuffer ( path ) ; VFS vfs = VFSManager . getVFSForPath ( path ) ; Object session = vfs . createVFSSession ( path , view ) ; if ( session == null ) { return ; } try { if ( buffer != null && buffer . isLoaded ( ) ) { StringBuffer buf = new StringBuffer ( ) ; try { buf . append ( buffer . getText ( 0 , buffer . getLength ( ) ) ) ; } catch ( BadLocationException e ) { throw new InternalError ( ) ; } buf . append ( "\n" ) ; in = new StringReader ( buf . toString ( ) ) ; } else { in = new BufferedReader ( new InputStreamReader ( vfs . _createInputStream ( session , path , true , view ) ) ) ; } runScript ( view , path , in , ownNamespace , rethrowBshErrors ) ; } catch ( IOException e ) { Log . log ( Log . ERROR , BeanShell . class , e ) ; GUIUtilities . error ( view , "read-error" , new String [ ] { path , e . toString ( ) } ) ; return ; } finally { try { vfs . _endVFSSession ( session , view ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , BeanShell . class , io ) ; GUIUtilities . error ( view , "read-error" , new String [ ] { path , io . toString ( ) } ) ; } } } public static void runScript ( View view , String path , Reader in , boolean ownNamespace , boolean rethrowBshErrors ) { Log . log ( Log . MESSAGE , BeanShell . class , "Running script " + path ) ; NameSpace namespace ; if ( ownNamespace ) namespace = new NameSpace ( global , "script namespace" ) ; else namespace = global ; Interpreter interp = createInterpreter ( namespace ) ; try { if ( view != null ) { EditPane editPane = view . getEditPane ( ) ; interp . set ( "view" , view ) ; interp . set ( "editPane" , editPane ) ; interp . set ( "buffer" , editPane . getBuffer ( ) ) ; interp . set ( "textArea" , editPane . getTextArea ( ) ) ; } running = true ; interp . eval ( in , namespace , path ) ; } catch ( Throwable e ) { if ( e instanceof TargetError ) e = ( ( TargetError ) e ) . getTarget ( ) ; if ( e instanceof InvocationTargetException ) e = ( ( InvocationTargetException ) e ) . getTargetException ( ) ; Log . log ( Log . ERROR , BeanShell . class , e ) ; new BeanShellErrorDialog ( view , e . toString ( ) ) ; if ( e instanceof Error && rethrowBshErrors ) throw ( Error ) e ; } finally { running = false ; } } public static Object eval ( View view , String command , boolean rethrowBshErrors ) { return eval ( view , global , command , rethrowBshErrors ) ; } public static Object eval ( View view , NameSpace namespace , String command , boolean rethrowBshErrors ) { Interpreter interp = createInterpreter ( namespace ) ; try { if ( view != null ) { EditPane editPane = view . getEditPane ( ) ; interp . set ( "view" , view ) ; interp . set ( "editPane" , editPane ) ; interp . set ( "buffer" , editPane . getBuffer ( ) ) ; interp . set ( "textArea" , editPane . getTextArea ( ) ) ; } return interp . eval ( command ) ; } catch ( Throwable e ) { if ( e instanceof TargetError ) e = ( ( TargetError ) e ) . getTarget ( ) ; if ( e instanceof InvocationTargetException ) e = ( ( InvocationTargetException ) e ) . getTargetException ( ) ; Log . log ( Log . ERROR , BeanShell . class , e ) ; new BeanShellErrorDialog ( view , e . toString ( ) ) ; if ( e instanceof Error && rethrowBshErrors ) throw ( Error ) e ; } return null ; } public static String cacheBlock ( String id , String code , boolean childNamespace ) { String name ; if ( id == null ) name = "b_" + ( cachedBlockCounter ++ ) ; else name = "b_" + id ; code = "setNameSpace(__cruft.namespace);\n" + name + "(ns) {\n" + "setNameSpace(ns);" + code + "\n}" ; eval ( null , code , false ) ; return name ; } public static Object runCachedBlock ( String id , View view , NameSpace namespace ) { if ( namespace == null ) namespace = internal ; Object [ ] args = { namespace } ; try { if ( view != null ) { namespace . setVariable ( "view" , view ) ; EditPane editPane = view . getEditPane ( ) ; namespace . setVariable ( "editPane" , editPane ) ; namespace . setVariable ( "buffer" , editPane . getBuffer ( ) ) ; namespace . setVariable ( "textArea" , editPane . getTextArea ( ) ) ; } Object retVal = internal . invokeMethod ( id , args , interpForMethods ) ; if ( retVal instanceof Primitive ) { if ( retVal == Primitive . VOID ) return null ; else return ( ( Primitive ) retVal ) . getValue ( ) ; } else return retVal ; } catch ( Throwable e ) { if ( e instanceof TargetError ) e = ( ( TargetError ) e ) . getTarget ( ) ; if ( e instanceof InvocationTargetException ) e = ( ( InvocationTargetException ) e ) . getTargetException ( ) ; Log . log ( Log . ERROR , BeanShell . class , e ) ; new BeanShellErrorDialog ( view , e . toString ( ) ) ; } finally { try { namespace . setVariable ( "view" , null ) ; namespace . setVariable ( "editPane" , null ) ; namespace . setVariable ( "buffer" , null ) ; namespace . setVariable ( "textArea" , null ) ; } catch ( EvalError e ) { } } return null ; } public static boolean isScriptRunning ( ) { return running ; } public static NameSpace getNameSpace ( ) { return global ; } static void init ( ) { Log . log ( Log . DEBUG , BeanShell . class , "Initializing BeanShell" + " interpreter" ) ; BshClassManager . setClassLoader ( new JARClassLoader ( ) ) ; global = new NameSpace ( "jEdit embedded BeanShell Interpreter" ) ; interpForMethods = createInterpreter ( global ) ; try { Interpreter interp = createInterpreter ( global ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( BeanShell . class . getResourceAsStream ( "jedit.bsh" ) ) ) ; interp . eval ( in , global , "jedit.bsh" ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , BeanShell . class , t ) ; System . exit ( 1 ) ; } internal = ( NameSpace ) eval ( null , "__cruft.namespace;" , false ) ; } private static Interpreter interpForMethods ; private static NameSpace global ; private static NameSpace internal ; private static boolean running ; private static int cachedBlockCounter ; private static Interpreter createInterpreter ( NameSpace nameSpace ) { return new Interpreter ( null , System . out , System . err , false , nameSpace ) ; } } 	1	['15', '1', '0', '26', '75', '73', '9', '19', '12', '0.785714286', '736', '1', '3', '0', '0.247619048', '0', '0', '47.66666667', '13', '4.4', '4']
package org . gjt . sp . jedit ; import javax . swing . SwingUtilities ; import java . io . * ; import java . net . * ; import java . util . Random ; import org . gjt . sp . util . Log ; public class EditServer extends Thread { EditServer ( String portFile ) { super ( "jEdit server daemon [" + portFile + "]" ) ; setDaemon ( true ) ; this . portFile = portFile ; try { socket = new ServerSocket ( 0 , 2 , InetAddress . getByName ( "127.0.0.1" ) ) ; authKey = Math . abs ( new Random ( ) . nextInt ( ) ) ; int port = socket . getLocalPort ( ) ; FileWriter out = new FileWriter ( portFile ) ; out . write ( String . valueOf ( port ) ) ; out . write ( "\n" ) ; out . write ( String . valueOf ( authKey ) ) ; out . write ( "\n" ) ; out . close ( ) ; Log . log ( Log . DEBUG , this , "jEdit server started on port " + socket . getLocalPort ( ) ) ; Log . log ( Log . DEBUG , this , "Authorization key is " + authKey ) ; ok = true ; } catch ( IOException io ) { Log . log ( Log . NOTICE , this , io ) ; } } public boolean isOK ( ) { return ok ; } public void run ( ) { try { for ( ; ; ) { Socket client = socket . accept ( ) ; Log . log ( Log . MESSAGE , this , client + ": connected" ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( client . getInputStream ( ) , "UTF8" ) ) ; try { int key = Integer . parseInt ( in . readLine ( ) ) ; if ( key != authKey ) { Log . log ( Log . ERROR , this , client + ": wrong" + " authorization key" ) ; in . close ( ) ; client . close ( ) ; return ; } } catch ( Exception e ) { Log . log ( Log . ERROR , this , client + ": invalid" + " authorization key" ) ; in . close ( ) ; client . close ( ) ; return ; } Log . log ( Log . DEBUG , this , client + ": authenticated" + " successfully" ) ; handleClient ( client , in ) ; client . close ( ) ; } } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; } } public static void handleClient ( boolean restore , String parent , String [ ] args ) { String splitConfig = null ; boolean newView = jEdit . getBooleanProperty ( "client.newView" ) ; if ( jEdit . getFirstView ( ) == null || newView ) { Buffer buffer = jEdit . openFiles ( null , parent , args ) ; if ( restore ) { if ( jEdit . getFirstBuffer ( ) == null ) splitConfig = jEdit . restoreOpenFiles ( ) ; else if ( jEdit . getBooleanProperty ( "restore.cli" ) ) { jEdit . restoreOpenFiles ( ) ; } } if ( jEdit . getFirstBuffer ( ) == null ) buffer = jEdit . newFile ( null ) ; if ( splitConfig != null ) jEdit . newView ( null , splitConfig ) ; else jEdit . newView ( null , buffer ) ; } else { View view = jEdit . getFirstView ( ) ; jEdit . openFiles ( view , parent , args ) ; view . requestFocus ( ) ; view . toFront ( ) ; return ; } } void stopServer ( ) { stop ( ) ; new File ( portFile ) . delete ( ) ; } private String portFile ; private ServerSocket socket ; private int authKey ; private boolean ok ; private void handleClient ( Socket client , Reader in ) throws IOException { final StringBuffer script = new StringBuffer ( ) ; char [ ] buf = new char [ 1024 ] ; int count ; while ( ( count = in . read ( buf , 0 , buf . length ) ) != - 1 ) { script . append ( buf , 0 , count ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { String scriptString = script . toString ( ) ; Log . log ( Log . DEBUG , this , scriptString ) ; BeanShell . eval ( null , scriptString , false ) ; } } ) ; } } 	1	['6', '2', '0', '6', '50', '9', '3', '5', '3', '0.8', '305', '1', '0', '0.924242424', '0.305555556', '0', '0', '49.16666667', '8', '2', '4']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class ModeOptionPane extends AbstractOptionPane { public ModeOptionPane ( ) { super ( "mode" ) ; } protected void _init ( ) { Mode [ ] modes = jEdit . getModes ( ) ; String [ ] modeNames = new String [ modes . length ] ; modeProps = new ModeProperties [ modes . length ] ; for ( int i = 0 ; i < modes . length ; i ++ ) { modeProps [ i ] = new ModeProperties ( modes [ i ] ) ; modeNames [ i ] = modes [ i ] . getName ( ) ; } mode = new JComboBox ( modeNames ) ; mode . addActionListener ( new ActionHandler ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.mode" ) , mode ) ; useDefaults = new JCheckBox ( jEdit . getProperty ( "options.mode.useDefaults" ) ) ; useDefaults . addActionListener ( new ActionHandler ( ) ) ; addComponent ( useDefaults ) ; addComponent ( jEdit . getProperty ( "options.mode.filenameGlob" ) , filenameGlob = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.firstlineGlob" ) , firstlineGlob = new JTextField ( ) ) ; String [ ] tabSizes = { "2" , "4" , "8" } ; addComponent ( jEdit . getProperty ( "options.editing.tabSize" ) , tabSize = new JComboBox ( tabSizes ) ) ; tabSize . setEditable ( true ) ; addComponent ( jEdit . getProperty ( "options.editing.indentSize" ) , indentSize = new JComboBox ( tabSizes ) ) ; indentSize . setEditable ( true ) ; String [ ] lineLens = { "0" , "72" , "76" , "80" } ; addComponent ( jEdit . getProperty ( "options.editing.maxLineLen" ) , maxLineLen = new JComboBox ( lineLens ) ) ; maxLineLen . setEditable ( true ) ; addComponent ( jEdit . getProperty ( "options.editing.wordBreakChars" ) , wordBreakChars = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.commentStart" ) , commentStart = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.commentEnd" ) , commentEnd = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.lineComment" ) , lineComment = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.noWordSep" ) , noWordSep = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.editing.collapseFolds" ) , collapseFolds = new JTextField ( ) ) ; addComponent ( syntax = new JCheckBox ( jEdit . getProperty ( "options.editing.syntax" ) ) ) ; addComponent ( indentOnTab = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnTab" ) ) ) ; addComponent ( indentOnEnter = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnEnter" ) ) ) ; addComponent ( noTabs = new JCheckBox ( jEdit . getProperty ( "options.editing.noTabs" ) ) ) ; selectMode ( ) ; } protected void _save ( ) { saveMode ( ) ; for ( int i = 0 ; i < modeProps . length ; i ++ ) { modeProps [ i ] . save ( ) ; } } private ModeProperties [ ] modeProps ; private ModeProperties current ; private JComboBox mode ; private JCheckBox useDefaults ; private JTextField filenameGlob ; private JTextField firstlineGlob ; private JComboBox tabSize ; private JComboBox indentSize ; private JComboBox maxLineLen ; private JTextField wordBreakChars ; private JTextField commentStart ; private JTextField commentEnd ; private JTextField lineComment ; private JTextField noWordSep ; private JTextField collapseFolds ; private JCheckBox noTabs ; private JCheckBox indentOnTab ; private JCheckBox indentOnEnter ; private JCheckBox syntax ; private void saveMode ( ) { current . useDefaults = useDefaults . isSelected ( ) ; current . filenameGlob = filenameGlob . getText ( ) ; current . firstlineGlob = firstlineGlob . getText ( ) ; current . tabSize = ( String ) tabSize . getSelectedItem ( ) ; current . indentSize = ( String ) indentSize . getSelectedItem ( ) ; current . maxLineLen = ( String ) maxLineLen . getSelectedItem ( ) ; current . wordBreakChars = wordBreakChars . getText ( ) ; current . commentStart = commentStart . getText ( ) ; current . commentEnd = commentEnd . getText ( ) ; current . lineComment = lineComment . getText ( ) ; current . noWordSep = noWordSep . getText ( ) ; current . collapseFolds = collapseFolds . getText ( ) ; current . noTabs = noTabs . isSelected ( ) ; current . indentOnEnter = indentOnEnter . isSelected ( ) ; current . indentOnTab = indentOnTab . isSelected ( ) ; current . syntax = syntax . isSelected ( ) ; } private void selectMode ( ) { current = modeProps [ mode . getSelectedIndex ( ) ] ; current . edited = true ; current . load ( ) ; useDefaults . setSelected ( current . useDefaults ) ; filenameGlob . setText ( current . filenameGlob ) ; firstlineGlob . setText ( current . firstlineGlob ) ; tabSize . setSelectedItem ( current . tabSize ) ; indentSize . setSelectedItem ( current . indentSize ) ; maxLineLen . setSelectedItem ( current . maxLineLen ) ; wordBreakChars . setText ( current . wordBreakChars ) ; commentStart . setText ( current . commentStart ) ; commentEnd . setText ( current . commentEnd ) ; lineComment . setText ( current . lineComment ) ; noWordSep . setText ( current . noWordSep ) ; collapseFolds . setText ( current . collapseFolds ) ; noTabs . setSelected ( current . noTabs ) ; indentOnTab . setSelected ( current . indentOnTab ) ; indentOnEnter . setSelected ( current . indentOnEnter ) ; syntax . setSelected ( current . syntax ) ; updateEnabled ( ) ; } private void updateEnabled ( ) { boolean enabled = ! modeProps [ mode . getSelectedIndex ( ) ] . useDefaults ; filenameGlob . setEnabled ( enabled ) ; firstlineGlob . setEnabled ( enabled ) ; tabSize . setEnabled ( enabled ) ; indentSize . setEnabled ( enabled ) ; maxLineLen . setEnabled ( enabled ) ; wordBreakChars . setEnabled ( enabled ) ; commentStart . setEnabled ( enabled ) ; commentEnd . setEnabled ( enabled ) ; lineComment . setEnabled ( enabled ) ; noWordSep . setEnabled ( enabled ) ; collapseFolds . setEnabled ( enabled ) ; noTabs . setEnabled ( enabled ) ; indentOnTab . setEnabled ( enabled ) ; indentOnEnter . setEnabled ( enabled ) ; syntax . setEnabled ( enabled ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == mode ) { saveMode ( ) ; selectMode ( ) ; } else if ( evt . getSource ( ) == useDefaults ) { modeProps [ mode . getSelectedIndex ( ) ] . useDefaults = useDefaults . isSelected ( ) ; updateEnabled ( ) ; } } } class ModeProperties { Mode mode ; boolean edited ; boolean loaded ; boolean useDefaults ; String filenameGlob ; String firstlineGlob ; String tabSize ; String indentSize ; String maxLineLen ; String wordBreakChars ; String commentStart ; String commentEnd ; String lineComment ; String noWordSep ; String collapseFolds ; boolean noTabs ; boolean indentOnTab ; boolean indentOnEnter ; boolean syntax ; ModeProperties ( Mode mode ) { this . mode = mode ; } void load ( ) { if ( loaded ) return ; loaded = true ; mode . loadIfNecessary ( ) ; useDefaults = ! jEdit . getBooleanProperty ( "mode." + mode . getName ( ) + ".customSettings" ) ; filenameGlob = ( String ) mode . getProperty ( "filenameGlob" ) ; firstlineGlob = ( String ) mode . getProperty ( "firstlineGlob" ) ; tabSize = mode . getProperty ( "tabSize" ) . toString ( ) ; indentSize = mode . getProperty ( "indentSize" ) . toString ( ) ; maxLineLen = mode . getProperty ( "maxLineLen" ) . toString ( ) ; wordBreakChars = ( String ) mode . getProperty ( "wordBreakChars" ) ; commentStart = ( String ) mode . getProperty ( "commentStart" ) ; commentEnd = ( String ) mode . getProperty ( "commentEnd" ) ; lineComment = ( String ) mode . getProperty ( "lineComment" ) ; noWordSep = ( String ) mode . getProperty ( "noWordSep" ) ; collapseFolds = mode . getProperty ( "collapseFolds" ) . toString ( ) ; noTabs = mode . getBooleanProperty ( "noTabs" ) ; indentOnTab = mode . getBooleanProperty ( "indentOnTab" ) ; indentOnEnter = mode . getBooleanProperty ( "indentOnEnter" ) ; syntax = mode . getBooleanProperty ( "syntax" ) ; } void save ( ) { if ( ! edited ) return ; String prefix = "mode." + mode . getName ( ) + "." ; jEdit . setBooleanProperty ( prefix + "customSettings" , ! useDefaults ) ; if ( useDefaults ) { jEdit . resetProperty ( prefix + "filenameGlob" ) ; jEdit . resetProperty ( prefix + "firstlineGlob" ) ; jEdit . resetProperty ( prefix + "tabSize" ) ; jEdit . resetProperty ( prefix + "indentSize" ) ; jEdit . resetProperty ( prefix + "maxLineLen" ) ; jEdit . resetProperty ( prefix + "wordBreakChars" ) ; jEdit . resetProperty ( prefix + "commentStart" ) ; jEdit . resetProperty ( prefix + "commentEnd" ) ; jEdit . resetProperty ( prefix + "lineComment" ) ; jEdit . resetProperty ( prefix + "noWordSep" ) ; jEdit . resetProperty ( prefix + "collapseFolds" ) ; jEdit . resetProperty ( prefix + "noTabs" ) ; jEdit . resetProperty ( prefix + "indentOnTab" ) ; jEdit . resetProperty ( prefix + "indentOnEnter" ) ; jEdit . resetProperty ( prefix + "syntax" ) ; } else { jEdit . setProperty ( prefix + "filenameGlob" , filenameGlob ) ; jEdit . setProperty ( prefix + "firstlineGlob" , firstlineGlob ) ; jEdit . setProperty ( prefix + "tabSize" , tabSize ) ; jEdit . setProperty ( prefix + "indentSize" , indentSize ) ; jEdit . setProperty ( prefix + "maxLineLen" , maxLineLen ) ; jEdit . setProperty ( prefix + "wordBreakChars" , wordBreakChars ) ; jEdit . setProperty ( prefix + "commentStart" , commentStart ) ; jEdit . setProperty ( prefix + "commentEnd" , commentEnd ) ; jEdit . setProperty ( prefix + "lineComment" , lineComment ) ; jEdit . setProperty ( prefix + "noWordSep" , noWordSep ) ; jEdit . setProperty ( prefix + "collapseFolds" , collapseFolds ) ; jEdit . setBooleanProperty ( prefix + "noTabs" , noTabs ) ; jEdit . setBooleanProperty ( prefix + "indentOnTab" , indentOnTab ) ; jEdit . setBooleanProperty ( prefix + "indentOnEnter" , indentOnEnter ) ; jEdit . setBooleanProperty ( prefix + "syntax" , syntax ) ; } } } } 	1	['12', '6', '0', '6', '38', '28', '3', '5', '1', '0.392344498', '645', '1', '2', '0.983655275', '0.5', '1', '3', '51.16666667', '5', '1.4167', '3']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . tree . * ; import java . awt . * ; import java . awt . event . * ; import java . util . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . jedit . options . * ; import org . gjt . sp . util . Log ; public class OptionsDialog extends EnhancedDialog implements ActionListener , TreeSelectionListener { public OptionsDialog ( View view ) { super ( view , jEdit . getProperty ( "options.title" ) , true ) ; view . showWaitCursor ( ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; content . setLayout ( new BorderLayout ( ) ) ; JPanel stage = new JPanel ( new BorderLayout ( ) ) ; stage . setBorder ( new EmptyBorder ( 0 , 6 , 0 , 0 ) ) ; content . add ( stage , BorderLayout . CENTER ) ; currentLabel = new JLabel ( ) ; currentLabel . setHorizontalAlignment ( JLabel . LEFT ) ; currentLabel . setBorder ( BorderFactory . createMatteBorder ( 0 , 0 , 1 , 0 , Color . black ) ) ; stage . add ( currentLabel , BorderLayout . NORTH ) ; cardPanel = new JPanel ( new CardLayout ( ) ) ; cardPanel . setBorder ( new EmptyBorder ( 5 , 0 , 0 , 0 ) ) ; stage . add ( cardPanel , BorderLayout . CENTER ) ; paneTree = new JTree ( createOptionTreeModel ( ) ) ; paneTree . setCellRenderer ( new PaneNameRenderer ( ) ) ; paneTree . putClientProperty ( "JTree.lineStyle" , "Angled" ) ; paneTree . setShowsRootHandles ( true ) ; paneTree . setRootVisible ( false ) ; content . add ( new JScrollPane ( paneTree , JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_AS_NEEDED ) , BorderLayout . WEST ) ; JPanel buttons = new JPanel ( ) ; buttons . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( this ) ; buttons . add ( ok ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( this ) ; buttons . add ( cancel ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; apply = new JButton ( jEdit . getProperty ( "common.apply" ) ) ; apply . addActionListener ( this ) ; buttons . add ( apply ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( buttons , BorderLayout . SOUTH ) ; TreePath jEditPath = new TreePath ( new Object [ ] { paneTree . getModel ( ) . getRoot ( ) , jEditGroup } ) ; paneTree . getSelectionModel ( ) . addTreeSelectionListener ( this ) ; paneTree . setSelectionPath ( jEditPath . pathByAddingChild ( jEditGroup . getMember ( 0 ) ) ) ; view . hideWaitCursor ( ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void addOptionGroup ( OptionGroup group ) { addOptionGroup ( group , pluginsGroup ) ; } public void addOptionPane ( OptionPane pane ) { addOptionPane ( pane , pluginsGroup ) ; } public void ok ( ) { ok ( true ) ; } public void cancel ( ) { dispose ( ) ; } public void ok ( boolean dispose ) { OptionTreeModel m = ( OptionTreeModel ) paneTree . getModel ( ) ; ( ( OptionGroup ) m . getRoot ( ) ) . save ( ) ; jEdit . propertiesChanged ( ) ; jEdit . saveSettings ( ) ; if ( dispose ) dispose ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) { ok ( ) ; } else if ( source == cancel ) { cancel ( ) ; } else if ( source == apply ) { ok ( false ) ; } } public void valueChanged ( TreeSelectionEvent evt ) { TreePath path = evt . getPath ( ) ; if ( path == null || ! ( path . getLastPathComponent ( ) instanceof OptionPane ) ) return ; Object [ ] nodes = path . getPath ( ) ; StringBuffer buf = new StringBuffer ( ) ; OptionPane optionPane = null ; String name = null ; int lastIdx = nodes . length - 1 ; for ( int i = paneTree . isRootVisible ( ) ? 0 : 1 ; i <= lastIdx ; i ++ ) { if ( nodes [ i ] instanceof OptionPane ) { optionPane = ( OptionPane ) nodes [ i ] ; name = optionPane . getName ( ) ; } else if ( nodes [ i ] instanceof OptionGroup ) { name = ( ( OptionGroup ) nodes [ i ] ) . getName ( ) ; } else { continue ; } if ( name != null ) { String label = jEdit . getProperty ( "options." + name + ".label" ) ; if ( label == null ) { buf . append ( name ) ; } else { buf . append ( label ) ; } } if ( i != lastIdx ) buf . append ( ": " ) ; } currentLabel . setText ( buf . toString ( ) ) ; optionPane . init ( ) ; pack ( ) ; ( ( CardLayout ) cardPanel . getLayout ( ) ) . show ( cardPanel , name ) ; } private Hashtable panes ; private JTree paneTree ; private JPanel cardPanel ; private JLabel currentLabel ; private JButton ok ; private JButton cancel ; private JButton apply ; private OptionGroup jEditGroup ; private OptionGroup pluginsGroup ; private OptionTreeModel createOptionTreeModel ( ) { OptionTreeModel paneTreeModel = new OptionTreeModel ( ) ; OptionGroup rootGroup = ( OptionGroup ) paneTreeModel . getRoot ( ) ; jEditGroup = new OptionGroup ( "jedit" ) ; addOptionPane ( new GeneralOptionPane ( ) , jEditGroup ) ; addOptionPane ( new LoadSaveOptionPane ( ) , jEditGroup ) ; addOptionPane ( new EditingOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ModeOptionPane ( ) , jEditGroup ) ; addOptionPane ( new TextAreaOptionPane ( ) , jEditGroup ) ; addOptionPane ( new GutterOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ColorOptionPane ( ) , jEditGroup ) ; addOptionPane ( new StyleOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ShortcutsOptionPane ( ) , jEditGroup ) ; addOptionPane ( new DockingOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ContextOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ToolBarOptionPane ( ) , jEditGroup ) ; addOptionPane ( new AbbrevsOptionPane ( ) , jEditGroup ) ; addOptionPane ( new PrintOptionPane ( ) , jEditGroup ) ; addOptionPane ( new BrowserOptionPane ( ) , jEditGroup ) ; addOptionGroup ( jEditGroup , rootGroup ) ; pluginsGroup = new OptionGroup ( "plugins" ) ; EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin ep = plugins [ i ] ; try { ep . createOptionPanes ( this ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , ep , "Error creating option pane" ) ; Log . log ( Log . ERROR , ep , t ) ; } } if ( pluginsGroup . getMemberCount ( ) > 0 ) { addOptionGroup ( pluginsGroup , rootGroup ) ; } return paneTreeModel ; } private void addOptionGroup ( OptionGroup child , OptionGroup parent ) { Enumeration enum = child . getMembers ( ) ; while ( enum . hasMoreElements ( ) ) { Object elem = enum . nextElement ( ) ; if ( elem instanceof OptionPane ) { addOptionPane ( ( OptionPane ) elem , child ) ; } else if ( elem instanceof OptionGroup ) { addOptionGroup ( ( OptionGroup ) elem , child ) ; } } parent . addOptionGroup ( child ) ; } private void addOptionPane ( OptionPane pane , OptionGroup parent ) { String name = pane . getName ( ) ; cardPanel . add ( pane . getComponent ( ) , name ) ; parent . addOptionPane ( pane ) ; } class PaneNameRenderer extends JLabel implements TreeCellRenderer { public PaneNameRenderer ( ) { setOpaque ( true ) ; paneFont = UIManager . getFont ( "Tree.font" ) ; groupFont = new Font ( paneFont . getName ( ) , paneFont . getStyle ( ) | Font . BOLD , paneFont . getSize ( ) ) ; } public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean selected , boolean expanded , boolean leaf , int row , boolean hasFocus ) { if ( selected ) { this . setBackground ( UIManager . getColor ( "Tree.selectionBackground" ) ) ; this . setForeground ( UIManager . getColor ( "Tree.selectionForeground" ) ) ; } else { this . setBackground ( UIManager . getColor ( "Tree.background" ) ) ; this . setForeground ( UIManager . getColor ( "Tree.foreground" ) ) ; } String name = null ; if ( value instanceof OptionGroup ) { name = ( ( OptionGroup ) value ) . getName ( ) ; this . setFont ( groupFont ) ; } else if ( value instanceof OptionPane ) { name = ( ( OptionPane ) value ) . getName ( ) ; this . setFont ( paneFont ) ; } if ( name == null ) { setText ( null ) ; } else { String label = jEdit . getProperty ( "options." + name + ".label" ) ; if ( label == null ) { setText ( name ) ; } else { setText ( label ) ; } } setIcon ( null ) ; return this ; } private Border noFocusBorder = BorderFactory . createEmptyBorder ( 1 , 1 , 1 , 1 ) ; private Border focusBorder = BorderFactory . createLineBorder ( UIManager . getColor ( "Tree.selectionBorderColor" ) ) ; private Font paneFont ; private Font groupFont ; } class OptionTreeModel implements TreeModel { public void addTreeModelListener ( TreeModelListener l ) { listenerList . add ( TreeModelListener . class , l ) ; } public void removeTreeModelListener ( TreeModelListener l ) { listenerList . remove ( TreeModelListener . class , l ) ; } public Object getChild ( Object parent , int index ) { if ( parent instanceof OptionGroup ) { return ( ( OptionGroup ) parent ) . getMember ( index ) ; } else { return null ; } } public int getChildCount ( Object parent ) { if ( parent instanceof OptionGroup ) { return ( ( OptionGroup ) parent ) . getMemberCount ( ) ; } else { return 0 ; } } public int getIndexOfChild ( Object parent , Object child ) { if ( parent instanceof OptionGroup ) { return ( ( OptionGroup ) parent ) . getMemberIndex ( child ) ; } else { return - 1 ; } } public Object getRoot ( ) { return root ; } public boolean isLeaf ( Object node ) { return node instanceof OptionPane ; } public void valueForPathChanged ( TreePath path , Object newValue ) { } protected void fireNodesChanged ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent modelEvent = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] != TreeModelListener . class ) continue ; if ( modelEvent == null ) { modelEvent = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesChanged ( modelEvent ) ; } } protected void fireNodesInserted ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent modelEvent = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] != TreeModelListener . class ) continue ; if ( modelEvent == null ) { modelEvent = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesInserted ( modelEvent ) ; } } protected void fireNodesRemoved ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent modelEvent = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] != TreeModelListener . class ) continue ; if ( modelEvent == null ) { modelEvent = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesRemoved ( modelEvent ) ; } } protected void fireTreeStructureChanged ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent modelEvent = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] != TreeModelListener . class ) continue ; if ( modelEvent == null ) { modelEvent = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeStructureChanged ( modelEvent ) ; } } private OptionGroup root = new OptionGroup ( "root" ) ; private EventListenerList listenerList = new EventListenerList ( ) ; } } 	1	['14', '7', '0', '24', '106', '69', '3', '24', '8', '0.869230769', '708', '1', '2', '0.98048048', '0.174603175', '0', '0', '48.85714286', '9', '2.2143', '2']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import java . io . * ; import java . util . Stack ; import org . gjt . sp . util . Log ; class ModeCatalogHandler extends HandlerBase { ModeCatalogHandler ( String directory , boolean resource ) { this . directory = directory ; this . resource = resource ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "catalog.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "catalog.dtd" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error while opening" + " catalog.dtd:" ) ; Log . log ( Log . ERROR , this , e ) ; } } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { aname = ( aname == null ) ? null : aname . intern ( ) ; if ( aname == "NAME" ) modeName = value ; else if ( aname == "FILE" ) { if ( value == null ) { Log . log ( Log . ERROR , this , directory + "catalog:" + " mode " + modeName + " doesn't have" + " a FILE attribute" ) ; } else file = value ; } else if ( aname == "FILE_NAME_GLOB" ) filenameGlob = value ; else if ( aname == "FIRST_LINE_GLOB" ) firstlineGlob = value ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "CATALOG" . equals ( name ) || "MODES" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , directory + "catalog: DOCTYPE must be CATALOG" ) ; } public void endElement ( String name ) { if ( name . equals ( "MODE" ) ) { Mode mode = jEdit . getMode ( modeName ) ; if ( mode == null ) { mode = new Mode ( modeName ) ; jEdit . addMode ( mode ) ; } Object path ; if ( resource ) path = jEdit . class . getResource ( directory + file ) ; else path = MiscUtilities . constructPath ( directory , file ) ; mode . setProperty ( "file" , path ) ; if ( filenameGlob != null ) mode . setProperty ( "filenameGlob" , filenameGlob ) ; else mode . unsetProperty ( "filenameGlob" ) ; if ( firstlineGlob != null ) mode . setProperty ( "firstlineGlob" , firstlineGlob ) ; else mode . unsetProperty ( "firstlineGlob" ) ; mode . init ( ) ; modeName = file = filenameGlob = firstlineGlob = null ; } } private String directory ; private boolean resource ; private String modeName ; private String file ; private String filenameGlob ; private String firstlineGlob ; } 	1	['6', '2', '0', '5', '28', '3', '1', '5', '4', '0.771428571', '230', '1', '0', '0.722222222', '0.722222222', '1', '3', '36.16666667', '7', '3', '1']
package org . gjt . sp . jedit ; import javax . swing . JMenuItem ; import java . io . * ; import java . util . Vector ; import java . util . StringTokenizer ; public class MiscUtilities { public static String fileToClass ( String name ) { char [ ] clsName = name . toCharArray ( ) ; for ( int i = clsName . length - 6 ; i >= 0 ; i -- ) if ( clsName [ i ] == '/' ) clsName [ i ] = '.' ; return new String ( clsName , 0 , clsName . length - 6 ) ; } public static String classToFile ( String name ) { return name . replace ( '.' , '/' ) . concat ( ".class" ) ; } public static String constructPath ( String parent , String path ) { if ( new File ( path ) . isAbsolute ( ) ) return canonPath ( path ) ; if ( parent == null ) parent = System . getProperty ( "user.dir" ) ; if ( File . separatorChar == '\\' ) { if ( path . length ( ) == 2 && path . charAt ( 1 ) == ':' ) return path ; if ( path . startsWith ( "/" ) || path . startsWith ( "\\" ) ) parent = parent . substring ( 0 , 2 ) ; } if ( parent . endsWith ( File . separator ) || path . endsWith ( "/" ) ) return canonPath ( parent + path ) ; else return canonPath ( parent + File . separator + path ) ; } public static String constructPath ( String parent , String path1 , String path2 ) { return constructPath ( constructPath ( parent , path1 ) , path2 ) ; } public static String concatPath ( String parent , String path ) { if ( path . startsWith ( File . separator ) ) path = path . substring ( 1 ) ; else if ( ( path . length ( ) >= 3 ) && ( path . charAt ( 1 ) == ':' ) ) path = path . replace ( ':' , File . separatorChar ) ; if ( parent == null ) parent = System . getProperty ( "user.dir" ) ; if ( parent . endsWith ( File . separator ) ) return parent + path ; else return parent + File . separator + path ; } public static String getFileExtension ( String name ) { int index = name . indexOf ( '.' ) ; if ( index == - 1 ) return "" ; else return name . substring ( index ) ; } public static String getFileName ( String path ) { int count = Math . max ( 0 , path . length ( ) - 2 ) ; int index1 = path . lastIndexOf ( File . separatorChar , count ) ; int index2 = path . lastIndexOf ( '/' , count ) ; return path . substring ( Math . max ( index1 , index2 ) + 1 ) ; } public static String getFileParent ( String path ) { return getParentOfPath ( path ) ; } public static String getParentOfPath ( String path ) { int count = Math . max ( 0 , path . length ( ) - 2 ) ; int index = path . lastIndexOf ( File . separatorChar , count ) ; if ( index == - 1 ) index = path . lastIndexOf ( '/' , count ) ; if ( index == - 1 ) { index = path . lastIndexOf ( ':' ) ; } return path . substring ( 0 , index + 1 ) ; } public static String getFileProtocol ( String url ) { return getProtocolOfURL ( url ) ; } public static String getProtocolOfURL ( String url ) { return url . substring ( 0 , url . indexOf ( ':' ) ) ; } public static boolean isURL ( String str ) { int fsIndex = Math . max ( str . indexOf ( File . separatorChar ) , str . indexOf ( '/' ) ) ; if ( fsIndex == 0 ) return false ; else if ( fsIndex == 2 ) return false ; int cIndex = str . indexOf ( ':' ) ; if ( cIndex <= 1 ) return false ; else if ( fsIndex != - 1 && cIndex > fsIndex ) return false ; return true ; } public static int getLeadingWhiteSpace ( String str ) { int whitespace = 0 ; loop : for ( ; whitespace < str . length ( ) ; ) { switch ( str . charAt ( whitespace ) ) { case ' ' : case '\t' : whitespace ++ ; break ; default : break loop ; } } return whitespace ; } public static int getTrailingWhiteSpace ( String str ) { int whitespace = 0 ; loop : for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { switch ( str . charAt ( i ) ) { case ' ' : case '\t' : whitespace ++ ; break ; default : break loop ; } } return whitespace ; } public static int getLeadingWhiteSpaceWidth ( String str , int tabSize ) { int whitespace = 0 ; loop : for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case ' ' : whitespace ++ ; break ; case '\t' : whitespace += ( tabSize - whitespace % tabSize ) ; break ; default : break loop ; } } return whitespace ; } public static String createWhiteSpace ( int len , int tabSize ) { StringBuffer buf = new StringBuffer ( ) ; if ( tabSize == 0 ) { while ( len -- > 0 ) buf . append ( ' ' ) ; } else { int count = len / tabSize ; while ( count -- > 0 ) buf . append ( '\t' ) ; count = len % tabSize ; while ( count -- > 0 ) buf . append ( ' ' ) ; } return buf . toString ( ) ; } public static String globToRE ( String glob ) { StringBuffer buf = new StringBuffer ( ) ; boolean backslash = false ; boolean insideGroup = false ; for ( int i = 0 ; i < glob . length ( ) ; i ++ ) { char c = glob . charAt ( i ) ; if ( backslash ) { buf . append ( '\\' ) ; buf . append ( c ) ; backslash = false ; continue ; } switch ( c ) { case '\\' : backslash = true ; break ; case '?' : buf . append ( '.' ) ; break ; case '.' : buf . append ( "\\." ) ; break ; case '*' : buf . append ( ".*" ) ; break ; case '{' : buf . append ( '(' ) ; insideGroup = true ; break ; case ',' : if ( insideGroup ) buf . append ( '|' ) ; else buf . append ( ',' ) ; break ; case '}' : buf . append ( ')' ) ; insideGroup = false ; break ; default : buf . append ( c ) ; } } return buf . toString ( ) ; } public static String escapesToChars ( String str ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; switch ( c ) { case '\\' : if ( i == str . length ( ) - 1 ) { buf . append ( '\\' ) ; break ; } c = str . charAt ( ++ i ) ; switch ( c ) { case 'n' : buf . append ( '\n' ) ; break ; case 't' : buf . append ( '\t' ) ; break ; default : buf . append ( c ) ; break ; } break ; default : buf . append ( c ) ; } } return buf . toString ( ) ; } public static String charsToEscapes ( String str ) { return charsToEscapes ( str , false ) ; } public static String charsToEscapes ( String str , boolean history ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; switch ( c ) { case '\n' : buf . append ( "\\n" ) ; break ; case '\t' : buf . append ( "\\t" ) ; break ; case '[' : if ( history ) buf . append ( "\\[" ) ; else buf . append ( c ) ; break ; case ']' : if ( history ) buf . append ( "\\]" ) ; else buf . append ( c ) ; break ; case '"' : if ( history ) buf . append ( c ) ; else buf . append ( "\\\"" ) ; break ; case '\'' : if ( history ) buf . append ( c ) ; else buf . append ( "\\\'" ) ; break ; case '\\' : buf . append ( "\\\\" ) ; break ; default : buf . append ( c ) ; break ; } } return buf . toString ( ) ; } public static void quicksort ( Object [ ] obj , Compare compare ) { if ( obj . length == 0 ) return ; quicksort ( obj , 0 , obj . length - 1 , compare ) ; } public static void quicksort ( Vector vector , Compare compare ) { if ( vector . size ( ) == 0 ) return ; quicksort ( vector , 0 , vector . size ( ) - 1 , compare ) ; } public interface Compare { int compare ( Object obj1 , Object obj2 ) ; } public static class StringCompare implements Compare { public int compare ( Object obj1 , Object obj2 ) { return obj1 . toString ( ) . compareTo ( obj2 . toString ( ) ) ; } } public static class StringICaseCompare implements Compare { public int compare ( Object obj1 , Object obj2 ) { return obj1 . toString ( ) . toLowerCase ( ) . compareTo ( obj2 . toString ( ) . toLowerCase ( ) ) ; } } public static class MenuItemCompare implements Compare { public int compare ( Object obj1 , Object obj2 ) { return ( ( JMenuItem ) obj1 ) . getText ( ) . compareTo ( ( ( JMenuItem ) obj2 ) . getText ( ) ) ; } } public static class VersionCompare implements Compare { public int compare ( Object obj1 , Object obj2 ) { String v1 = obj1 . toString ( ) ; String v2 = obj2 . toString ( ) ; StringTokenizer vt1 = new StringTokenizer ( v1 , "." ) ; StringTokenizer vt2 = new StringTokenizer ( v2 , "." ) ; int comp = 0 ; while ( vt1 . hasMoreTokens ( ) && vt2 . hasMoreTokens ( ) ) { String vt1tok = vt1 . nextToken ( ) ; String vt2tok = vt2 . nextToken ( ) ; try { int i1 = Integer . parseInt ( vt1tok ) ; int i2 = Integer . parseInt ( vt2tok ) ; comp = i1 < i2 ? - 1 : i1 > i2 ? 1 : 0 ; } catch ( NumberFormatException e ) { comp = vt1tok . compareTo ( vt2tok ) ; } if ( comp != 0 ) return comp ; } return vt1 . hasMoreTokens ( ) ? 1 : vt2 . hasMoreTokens ( ) ? - 1 : 0 ; } } public static int compareVersions ( String version1 , String version2 ) { VersionCompare comparator = new VersionCompare ( ) ; return comparator . compare ( version1 , version2 ) ; } public static String buildToVersion ( String build ) { if ( build . length ( ) != 11 ) return "<unknown version: " + build + ">" ; int major = Integer . parseInt ( build . substring ( 0 , 2 ) ) ; int minor = Integer . parseInt ( build . substring ( 3 , 5 ) ) ; int beta = Integer . parseInt ( build . substring ( 6 , 8 ) ) ; int bugfix = Integer . parseInt ( build . substring ( 9 , 11 ) ) ; return "" + major + "." + minor + ( beta != 99 ? "pre" + beta : ( bugfix != 0 ? "." + bugfix : "final" ) ) ; } private MiscUtilities ( ) { } private static String canonPath ( String path ) { if ( File . separatorChar == '\\' ) { path = path . replace ( '/' , '\\' ) ; } try { return new File ( path ) . getCanonicalPath ( ) ; } catch ( Exception e ) { return path ; } } private static void quicksort ( Object [ ] obj , int _start , int _end , Compare compare ) { int start = _start ; int end = _end ; Object mid = obj [ ( _start + _end ) / 2 ] ; if ( _start > _end ) return ; while ( start <= end ) { while ( ( start < _end ) && ( compare . compare ( obj [ start ] , mid ) < 0 ) ) start ++ ; while ( ( end > _start ) && ( compare . compare ( obj [ end ] , mid ) > 0 ) ) end -- ; if ( start <= end ) { Object o = obj [ start ] ; obj [ start ] = obj [ end ] ; obj [ end ] = o ; start ++ ; end -- ; } } if ( _start < end ) quicksort ( obj , _start , end , compare ) ; if ( start < _end ) quicksort ( obj , start , _end , compare ) ; } private static void quicksort ( Vector obj , int _start , int _end , Compare compare ) { int start = _start ; int end = _end ; Object mid = obj . elementAt ( ( _start + _end ) / 2 ) ; if ( _start > _end ) return ; while ( start <= end ) { while ( ( start < _end ) && ( compare . compare ( obj . elementAt ( start ) , mid ) < 0 ) ) start ++ ; while ( ( end > _start ) && ( compare . compare ( obj . elementAt ( end ) , mid ) > 0 ) ) end -- ; if ( start <= end ) { Object o = obj . elementAt ( start ) ; obj . setElementAt ( obj . elementAt ( end ) , start ) ; obj . setElementAt ( o , end ) ; start ++ ; end -- ; } } if ( _start < end ) quicksort ( obj , _start , end , compare ) ; if ( start < _end ) quicksort ( obj , start , _end , compare ) ; } } 	1	['28', '1', '0', '45', '60', '378', '43', '2', '24', '2', '950', '0', '0', '0', '0.183673469', '0', '0', '32.92857143', '14', '3.7143', '4']
package org . gjt . sp . jedit . search ; import bsh . NameSpace ; import javax . swing . text . Segment ; import org . gjt . sp . jedit . BeanShell ; import org . gjt . sp . util . Log ; public class BoyerMooreSearchMatcher implements SearchMatcher { public BoyerMooreSearchMatcher ( String pattern , String replace , boolean ignoreCase , boolean reverseSearch , boolean beanshell , String replaceMethod ) { if ( ignoreCase ) { this . pattern = pattern . toUpperCase ( ) . toCharArray ( ) ; } else { this . pattern = pattern . toCharArray ( ) ; } if ( reverseSearch ) { char [ ] tmp = new char [ this . pattern . length ] ; for ( int i = 0 ; i < tmp . length ; i ++ ) { tmp [ i ] = this . pattern [ this . pattern . length - ( i + 1 ) ] ; } this . pattern = tmp ; } this . replace = replace ; this . ignoreCase = ignoreCase ; this . reverseSearch = reverseSearch ; this . beanshell = beanshell ; if ( beanshell ) { this . replaceMethod = replaceMethod ; replaceNS = new NameSpace ( BeanShell . getNameSpace ( ) , "search and replace" ) ; } generateSkipArray ( ) ; generateSuffixArray ( ) ; } public int [ ] nextMatch ( Segment text ) { int pos = match ( text . array , text . offset , text . offset + text . count ) ; if ( pos == - 1 ) { return null ; } else { return new int [ ] { pos - text . offset , pos + pattern . length - text . offset } ; } } public String substitute ( String text ) throws Exception { if ( beanshell ) { replaceNS . setVariable ( "_0" , text ) ; Object obj = BeanShell . runCachedBlock ( replaceMethod , null , replaceNS ) ; if ( obj == null ) return null ; else return obj . toString ( ) ; } else return replace ; } public int match ( char [ ] text , int offset , int length ) { int anchor = reverseSearch ? length - 1 : offset ; int pos ; int last_anchor = reverseSearch ? offset + pattern . length - 1 : length - pattern . length ; int pattern_end = pattern . length - 1 ; char ch = 0 ; int bad_char ; int good_suffix ; SEARCH : while ( reverseSearch ? anchor >= last_anchor : anchor <= last_anchor ) { for ( pos = pattern_end ; pos >= 0 ; -- pos ) { int idx = reverseSearch ? anchor - pos : anchor + pos ; ch = ignoreCase ? Character . toUpperCase ( text [ idx ] ) : text [ idx ] ; if ( ch != pattern [ pos ] ) { bad_char = pos - skip [ getSkipIndex ( ch ) ] ; good_suffix = suffix [ pos ] ; int skip = ( bad_char > good_suffix ) ? bad_char : good_suffix ; anchor += reverseSearch ? - skip : skip ; continue SEARCH ; } } return ( reverseSearch ? anchor - pattern_end : anchor ) ; } return - 1 ; } private char [ ] pattern ; private String replace ; private boolean ignoreCase ; private boolean reverseSearch ; private boolean beanshell ; private String replaceMethod ; private NameSpace replaceNS ; private int [ ] skip ; private int [ ] suffix ; private void generateSkipArray ( ) { skip = new int [ 256 ] ; if ( pattern . length == 0 ) return ; int pos = 0 ; do { skip [ getSkipIndex ( pattern [ pos ] ) ] = pos ; } while ( ++ pos < pattern . length ) ; } private static final int getSkipIndex ( char ch ) { return ( ( int ) ch ) & 0x000000FF ; } private void generateSuffixArray ( ) { int m = pattern . length ; int j = m + 1 ; suffix = new int [ j ] ; int [ ] tmp = new int [ j ] ; tmp [ m ] = j ; for ( int i = m ; i > 0 ; -- i ) { while ( j <= m && pattern [ i - 1 ] != pattern [ j - 1 ] ) { if ( suffix [ j ] == 0 ) { suffix [ j ] = j - i ; } j = tmp [ j ] ; } tmp [ i - 1 ] = -- j ; } int k = tmp [ 0 ] ; for ( j = 0 ; j <= m ; j ++ ) { if ( j > 0 ) { suffix [ j - 1 ] = ( suffix [ j ] == 0 ) ? k : suffix [ j ] ; } if ( j == k ) { k = tmp [ k ] ; } } } } 	1	['7', '1', '0', '5', '16', '0', '1', '4', '4', '0.666666667', '416', '1', '1', '0', '0.265306122', '0', '0', '57.14285714', '14', '4.1429', '3']
package org . gjt . sp . jedit . proto . jeditresource ; import java . io . * ; import java . net . * ; import org . gjt . sp . jedit . * ; public class PluginResURLConnection extends URLConnection { public PluginResURLConnection ( URL url ) throws IOException { super ( url ) ; String file = url . getFile ( ) ; int index = file . indexOf ( '!' , 0 ) ; if ( index == - 1 ) { plugin = null ; resource = file ; } else { int start ; if ( file . charAt ( 0 ) == '/' ) start = 1 ; else start = 0 ; plugin = file . substring ( start , index ) ; resource = file . substring ( index + 1 ) ; } if ( plugin != null && resource . startsWith ( "/" ) ) resource = resource . substring ( 1 ) ; } public void connect ( ) throws IOException { if ( ! connected ) { if ( plugin == null ) { in = jEdit . class . getResourceAsStream ( resource ) ; } else { EditPlugin . JAR [ ] plugins = jEdit . getPluginJARs ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin . JAR jar = plugins [ i ] ; if ( MiscUtilities . getFileName ( jar . getPath ( ) ) . equalsIgnoreCase ( plugin ) ) { in = jar . getClassLoader ( ) . getResourceAsStream ( resource ) ; break ; } } } if ( in == null ) { throw new IOException ( "Resource not found: " + resource ) ; } connected = true ; } } public InputStream getInputStream ( ) throws IOException { connect ( ) ; return in ; } public String getHeaderField ( String name ) { if ( name . equals ( "content-type" ) ) { if ( resource . endsWith ( ".html" ) ) return "text/html" ; else if ( resource . endsWith ( ".txt" ) ) return "text/plain" ; else if ( resource . endsWith ( ".rtf" ) ) return "text/rtf" ; else if ( resource . endsWith ( ".gif" ) ) return "image/gif" ; else if ( resource . endsWith ( ".jpg" ) || resource . endsWith ( ".jpeg" ) ) return "image/jpeg" ; else return null ; } else return null ; } private InputStream in ; private String plugin ; private String resource ; } 	1	['5', '2', '0', '5', '28', '2', '1', '4', '4', '0.5625', '199', '1', '0', '0.935483871', '0.466666667', '1', '7', '38', '8', '2.2', '1']
package org . gjt . sp . jedit ; import gnu . regexp . * ; import javax . swing . * ; import javax . swing . event . * ; import javax . swing . text . * ; import javax . swing . undo . * ; import java . awt . * ; import java . io . File ; import java . util . * ; import org . gjt . sp . jedit . browser . VFSBrowser ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . search . RESearchMatcher ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class Buffer extends PlainDocument implements EBComponent { public static final String LINESEP = "lineSeparator" ; public static final String BACKED_UP = "Buffer__backedUp" ; public static final String CARET = "Buffer__caret" ; public static final String SELECTION = "Buffer__selection" ; public static final String SCROLL_VERT = "Buffer__scrollVert" ; public static final String SCROLL_HORIZ = "Buffer__scrollHoriz" ; public static final String ENCODING = "encoding" ; public void propertiesChanged ( ) { if ( getBooleanProperty ( "syntax" ) ) setTokenMarker ( mode . getTokenMarker ( ) ) ; else setTokenMarker ( jEdit . getMode ( "text" ) . getTokenMarker ( ) ) ; if ( undo != null ) { try { undo . setLimit ( Integer . parseInt ( jEdit . getProperty ( "buffer.undoCount" ) ) ) ; } catch ( NumberFormatException nf ) { undo . setLimit ( 100 ) ; } } putProperty ( "tabSize" , getProperty ( "tabSize" ) ) ; putProperty ( "maxLineLen" , getProperty ( "maxLineLen" ) ) ; } public void showInsertFileDialog ( View view ) { String [ ] files = GUIUtilities . showVFSFileDialog ( view , null , VFSBrowser . OPEN_DIALOG , false ) ; if ( files != null ) insert ( view , files [ 0 ] ) ; } public void print ( View view ) { PrintJob job = view . getToolkit ( ) . getPrintJob ( view , name , null ) ; if ( job == null ) return ; view . showWaitCursor ( ) ; int topMargin ; int leftMargin ; int bottomMargin ; int rightMargin ; int ppi = job . getPageResolution ( ) ; try { topMargin = ( int ) ( Float . valueOf ( jEdit . getProperty ( "print.margin.top" ) ) . floatValue ( ) * ppi ) ; } catch ( NumberFormatException nf ) { topMargin = ppi / 2 ; } try { leftMargin = ( int ) ( Float . valueOf ( jEdit . getProperty ( "print.margin.left" ) ) . floatValue ( ) * ppi ) ; } catch ( NumberFormatException nf ) { leftMargin = ppi / 2 ; } try { bottomMargin = ( int ) ( Float . valueOf ( jEdit . getProperty ( "print.margin.bottom" ) ) . floatValue ( ) * ppi ) ; } catch ( NumberFormatException nf ) { bottomMargin = topMargin ; } try { rightMargin = ( int ) ( Float . valueOf ( jEdit . getProperty ( "print.margin.right" ) ) . floatValue ( ) * ppi ) ; } catch ( NumberFormatException nf ) { rightMargin = leftMargin ; } boolean printHeader = jEdit . getBooleanProperty ( "print.header" ) ; boolean printFooter = jEdit . getBooleanProperty ( "print.footer" ) ; boolean printLineNumbers = jEdit . getBooleanProperty ( "print.lineNumbers" ) ; boolean syntax = jEdit . getBooleanProperty ( "print.syntax" ) ; String header = path ; String footer = new Date ( ) . toString ( ) ; int lineCount = getDefaultRootElement ( ) . getElementCount ( ) ; TabExpander expander = null ; Graphics gfx = null ; String fontFamily = jEdit . getProperty ( "print.font" ) ; int fontSize ; try { fontSize = Integer . parseInt ( jEdit . getProperty ( "print.fontsize" ) ) ; } catch ( NumberFormatException nf ) { fontSize = 10 ; } int fontStyle ; try { fontStyle = Integer . parseInt ( jEdit . getProperty ( "print.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { fontStyle = Font . PLAIN ; } SyntaxStyle [ ] styles = GUIUtilities . loadStyles ( fontFamily , fontSize ) ; boolean style = jEdit . getBooleanProperty ( "print.style" ) ; boolean color = jEdit . getBooleanProperty ( "print.color" ) ; Font font = new Font ( fontFamily , fontStyle , fontSize ) ; FontMetrics fm = null ; Dimension pageDimension = job . getPageDimension ( ) ; int pageWidth = pageDimension . width ; int pageHeight = pageDimension . height ; int y = 0 ; int tabSize = 0 ; int lineHeight = 0 ; int page = 0 ; int lineNumberDigits = ( int ) Math . ceil ( Math . log ( lineCount ) / Math . log ( 10 ) ) ; int lineNumberWidth = 0 ; TextRenderer renderer = TextRenderer . createPrintTextRenderer ( ) ; renderer . configure ( false , false ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { if ( gfx == null ) { page ++ ; gfx = job . getGraphics ( ) ; renderer . setupGraphics ( gfx ) ; gfx . setFont ( font ) ; fm = gfx . getFontMetrics ( ) ; if ( printLineNumbers ) { lineNumberWidth = fm . charWidth ( '0' ) * lineNumberDigits ; } else lineNumberWidth = 0 ; lineHeight = fm . getHeight ( ) ; tabSize = getTabSize ( ) * fm . charWidth ( ' ' ) ; expander = new PrintTabExpander ( leftMargin + lineNumberWidth , tabSize ) ; y = topMargin + lineHeight - fm . getDescent ( ) - fm . getLeading ( ) ; if ( printHeader ) { gfx . setColor ( Color . lightGray ) ; gfx . fillRect ( leftMargin , topMargin , pageWidth - leftMargin - rightMargin , lineHeight ) ; gfx . setColor ( Color . black ) ; gfx . drawString ( header , leftMargin , y ) ; y += lineHeight ; } } y += lineHeight ; gfx . setColor ( Color . black ) ; gfx . setFont ( font ) ; int x = leftMargin ; if ( printLineNumbers ) { String lineNumber = String . valueOf ( i + 1 ) ; gfx . drawString ( lineNumber , ( leftMargin + lineNumberWidth ) - fm . stringWidth ( lineNumber ) , y ) ; x += lineNumberWidth + fm . charWidth ( '0' ) ; } paintSyntaxLine ( i , gfx , x , y , expander , style , color , font , Color . black , Color . white , styles , renderer ) ; int bottomOfPage = pageHeight - bottomMargin - lineHeight ; if ( printFooter ) bottomOfPage -= lineHeight * 2 ; if ( y >= bottomOfPage || i == lineCount - 1 ) { if ( printFooter ) { y = pageHeight - bottomMargin ; gfx . setColor ( Color . lightGray ) ; gfx . setFont ( font ) ; gfx . fillRect ( leftMargin , y - lineHeight , pageWidth - leftMargin - rightMargin , lineHeight ) ; gfx . setColor ( Color . black ) ; y -= ( lineHeight - fm . getAscent ( ) ) ; gfx . drawString ( footer , leftMargin , y ) ; Integer [ ] args = { new Integer ( page ) } ; String pageStr = jEdit . getProperty ( "print.page" , args ) ; int width = fm . stringWidth ( pageStr ) ; gfx . drawString ( pageStr , pageWidth - rightMargin - width , y ) ; } gfx . dispose ( ) ; gfx = null ; } } job . end ( ) ; view . hideWaitCursor ( ) ; } public void reload ( View view ) { if ( getFlag ( DIRTY ) ) { String [ ] args = { name } ; int result = GUIUtilities . confirm ( view , "changedreload" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } view . getEditPane ( ) . saveCaretInfo ( ) ; load ( view , true ) ; } public boolean load ( final View view , final boolean reload ) { if ( isPerformingIO ( ) ) { GUIUtilities . error ( view , "buffer-multiple-io" , null ) ; return false ; } setFlag ( LOADING , true ) ; EditBus . send ( new BufferUpdate ( this , view , BufferUpdate . LOAD_STARTED ) ) ; undo = null ; final boolean loadAutosave ; if ( reload || ! getFlag ( NEW_FILE ) ) { if ( file != null ) modTime = file . lastModified ( ) ; if ( ! reload && autosaveFile != null && autosaveFile . exists ( ) ) loadAutosave = recoverAutosave ( view ) ; else { if ( autosaveFile != null ) autosaveFile . delete ( ) ; loadAutosave = false ; } if ( ! loadAutosave ) { if ( ! vfs . load ( view , this , path ) ) { setFlag ( LOADING , false ) ; return false ; } } } else loadAutosave = false ; Runnable runnable = new Runnable ( ) { public void run ( ) { StringBuffer sbuf = ( StringBuffer ) getProperty ( BufferIORequest . LOAD_DATA ) ; if ( sbuf != null ) { try { remove ( 0 , getLength ( ) ) ; insertString ( 0 , sbuf . toString ( ) , null ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } } getDocumentProperties ( ) . remove ( "tabSize" ) ; getDocumentProperties ( ) . remove ( "indentSize" ) ; getDocumentProperties ( ) . remove ( "maxLineLen" ) ; getDocumentProperties ( ) . remove ( BufferIORequest . LOAD_DATA ) ; undo = new MyUndoManager ( ) ; try { undo . setLimit ( Integer . parseInt ( jEdit . getProperty ( "buffer.undoCount" ) ) ) ; } catch ( NumberFormatException nf ) { undo . setLimit ( 100 ) ; } setMode ( ) ; setFlag ( LOADING , false ) ; if ( reload ) setDirty ( false ) ; if ( loadAutosave ) setFlag ( DIRTY , true ) ; if ( jEdit . getBooleanProperty ( "parseFully" ) ) { for ( int i = 0 ; i < lineCount ; i ++ ) markTokens ( i ) ; } try { int collapseFolds = ( ( Integer ) getProperty ( "collapseFolds" ) ) . intValue ( ) ; if ( collapseFolds != 0 ) expandFolds ( collapseFolds ) ; } catch ( Exception e ) { } if ( ! getFlag ( TEMPORARY ) ) { EditBus . send ( new BufferUpdate ( Buffer . this , view , BufferUpdate . LOADED ) ) ; EditBus . send ( new BufferUpdate ( Buffer . this , view , BufferUpdate . MARKERS_CHANGED ) ) ; } } } ; if ( getFlag ( TEMPORARY ) ) runnable . run ( ) ; else VFSManager . runInAWTThread ( runnable ) ; return true ; } public boolean insert ( final View view , String path ) { if ( isPerformingIO ( ) ) { GUIUtilities . error ( view , "buffer-multiple-io" , null ) ; return false ; } if ( ! MiscUtilities . isURL ( path ) ) path = MiscUtilities . constructPath ( this . path , path ) ; Buffer buffer = jEdit . getBuffer ( path ) ; if ( buffer != null ) { try { view . getTextArea ( ) . setSelectedText ( buffer . getText ( 0 , buffer . getLength ( ) ) ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } return true ; } VFS vfs = VFSManager . getVFSForPath ( path ) ; setFlag ( IO , true ) ; if ( ! vfs . insert ( view , this , path ) ) { setFlag ( IO , false ) ; return false ; } VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { setFlag ( IO , false ) ; StringBuffer sbuf = ( StringBuffer ) getProperty ( BufferIORequest . LOAD_DATA ) ; if ( sbuf != null ) { getDocumentProperties ( ) . remove ( BufferIORequest . LOAD_DATA ) ; view . getTextArea ( ) . setSelectedText ( sbuf . toString ( ) ) ; } } } ) ; return true ; } public void autosave ( ) { if ( autosaveFile == null || ! getFlag ( AUTOSAVE_DIRTY ) || ! getFlag ( DIRTY ) || getFlag ( LOADING ) || getFlag ( IO ) ) return ; setFlag ( AUTOSAVE_DIRTY , false ) ; VFSManager . runInWorkThread ( new BufferIORequest ( BufferIORequest . AUTOSAVE , null , this , null , VFSManager . getFileVFS ( ) , autosaveFile . getPath ( ) ) ) ; } public boolean saveAs ( View view , boolean rename ) { String [ ] files = GUIUtilities . showVFSFileDialog ( view , path , VFSBrowser . SAVE_DIALOG , false ) ; if ( files == null ) return false ; return save ( view , files [ 0 ] , rename ) ; } public boolean save ( View view , String path ) { return save ( view , path , true ) ; } public boolean save ( final View view , String path , final boolean rename ) { if ( isPerformingIO ( ) ) { GUIUtilities . error ( view , "buffer-multiple-io" , null ) ; return false ; } if ( path == null && getFlag ( NEW_FILE ) ) return saveAs ( view , rename ) ; if ( path == null && file != null ) { long newModTime = file . lastModified ( ) ; if ( newModTime != modTime ) { Object [ ] args = { this . path } ; int result = GUIUtilities . confirm ( view , "filechanged-save" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return false ; } } setFlag ( IO , true ) ; EditBus . send ( new BufferUpdate ( this , view , BufferUpdate . SAVING ) ) ; if ( path == null ) path = this . path ; VFS vfs = VFSManager . getVFSForPath ( path ) ; if ( ! vfs . save ( view , this , path ) ) { setFlag ( IO , false ) ; return false ; } final String oldPath = this . path ; if ( rename ) setPath ( path ) ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { if ( getFlag ( NEW_FILE ) || ! getPath ( ) . equals ( oldPath ) ) VFSManager . sendVFSUpdate ( getVFS ( ) , getPath ( ) , true ) ; setFlag ( IO , false ) ; if ( rename ) { try { Buffer . this . _writeLock ( ) ; if ( autosaveFile != null ) autosaveFile . delete ( ) ; setFlag ( AUTOSAVE_DIRTY , false ) ; setFlag ( READ_ONLY , false ) ; setFlag ( NEW_FILE , false ) ; setFlag ( UNTITLED , false ) ; setFlag ( DIRTY , false ) ; } finally { Buffer . this . _writeUnlock ( ) ; } if ( ! getPath ( ) . equals ( oldPath ) ) { jEdit . updatePosition ( Buffer . this ) ; setMode ( ) ; } if ( file != null ) modTime = file . lastModified ( ) ; EditBus . send ( new BufferUpdate ( Buffer . this , view , BufferUpdate . DIRTY_CHANGED ) ) ; } } } ) ; return true ; } public void _writeLock ( ) { writeLock ( ) ; } public void _writeUnlock ( ) { writeUnlock ( ) ; } public long getLastModified ( ) { return modTime ; } public void setLastModified ( long modTime ) { this . modTime = modTime ; } public void checkModTime ( View view ) { if ( file == null || getFlag ( NEW_FILE ) || getFlag ( IO ) ) return ; boolean newReadOnly = ( file . exists ( ) && ! file . canWrite ( ) ) ; if ( newReadOnly != getFlag ( READ_ONLY ) ) { setFlag ( READ_ONLY , newReadOnly ) ; EditBus . send ( new BufferUpdate ( this , view , BufferUpdate . DIRTY_CHANGED ) ) ; } if ( ! jEdit . getBooleanProperty ( "view.checkModStatus" ) ) return ; long oldModTime = modTime ; long newModTime = file . lastModified ( ) ; if ( newModTime != oldModTime ) { modTime = newModTime ; if ( ! file . exists ( ) ) { setFlag ( NEW_FILE , true ) ; EditBus . send ( new BufferUpdate ( this , view , BufferUpdate . DIRTY_CHANGED ) ) ; Object [ ] args = { path } ; GUIUtilities . message ( view , "filedeleted" , args ) ; return ; } String prop = ( isDirty ( ) ? "filechanged-dirty" : "filechanged-focus" ) ; Object [ ] args = { path } ; int result = GUIUtilities . confirm ( view , prop , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { view . getEditPane ( ) . saveCaretInfo ( ) ; load ( view , true ) ; } } } public VFS getVFS ( ) { return vfs ; } public final File getFile ( ) { return file ; } public final File getAutosaveFile ( ) { return autosaveFile ; } public final String getName ( ) { return name ; } public final String getPath ( ) { return path ; } public final boolean isClosed ( ) { return getFlag ( CLOSED ) ; } public final boolean isLoaded ( ) { return ! getFlag ( LOADING ) ; } public final boolean isPerformingIO ( ) { return getFlag ( LOADING ) || getFlag ( IO ) ; } public final boolean isSaving ( ) { return getFlag ( IO ) ; } public final boolean isNewFile ( ) { return getFlag ( NEW_FILE ) ; } public final void setNewFile ( boolean newFile ) { setFlag ( NEW_FILE , newFile ) ; } public final boolean isUntitled ( ) { return getFlag ( UNTITLED ) ; } public final boolean isDirty ( ) { return getFlag ( DIRTY ) ; } public final boolean isReadOnly ( ) { return getFlag ( READ_ONLY ) ; } public final boolean isEditable ( ) { return ! ( getFlag ( READ_ONLY ) || getFlag ( IO ) || getFlag ( LOADING ) ) ; } public final void setReadOnly ( boolean readOnly ) { setFlag ( READ_ONLY , readOnly ) ; } public void setDirty ( boolean d ) { boolean old_d = getFlag ( DIRTY ) ; if ( d ) { if ( getFlag ( LOADING ) || getFlag ( READ_ONLY ) ) return ; if ( getFlag ( DIRTY ) && getFlag ( AUTOSAVE_DIRTY ) ) return ; setFlag ( DIRTY , true ) ; setFlag ( AUTOSAVE_DIRTY , true ) ; } else { setFlag ( DIRTY , false ) ; setFlag ( AUTOSAVE_DIRTY , false ) ; } if ( d != old_d ) { EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . DIRTY_CHANGED ) ) ; } } public boolean isTemporary ( ) { return getFlag ( TEMPORARY ) ; } public Icon getIcon ( ) { if ( getFlag ( DIRTY ) ) return GUIUtilities . DIRTY_BUFFER_ICON ; else if ( getFlag ( READ_ONLY ) ) return GUIUtilities . READ_ONLY_BUFFER_ICON ; else if ( getFlag ( NEW_FILE ) ) return GUIUtilities . NEW_BUFFER_ICON ; else return GUIUtilities . NORMAL_BUFFER_ICON ; } public void undo ( ) { if ( undo == null ) return ; if ( ! isEditable ( ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } try { setFlag ( UNDO_IN_PROGRESS , true ) ; undo . undo ( ) ; } catch ( CannotUndoException cu ) { Log . log ( Log . DEBUG , this , cu ) ; Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } finally { setFlag ( UNDO_IN_PROGRESS , false ) ; } } public void redo ( ) { if ( undo == null ) return ; if ( ! isEditable ( ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } try { setFlag ( UNDO_IN_PROGRESS , true ) ; undo . redo ( ) ; } catch ( CannotRedoException cr ) { Log . log ( Log . DEBUG , this , cr ) ; Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } finally { setFlag ( UNDO_IN_PROGRESS , false ) ; } } public void addUndoableEdit ( UndoableEdit edit ) { if ( undo == null || getFlag ( UNDO_IN_PROGRESS ) || getFlag ( LOADING ) ) return ; if ( undo . canRedo ( ) && ! edit . isSignificant ( ) ) return ; if ( compoundEdit != null ) { compoundEditNonEmpty = true ; compoundEdit . addEdit ( edit ) ; } else undo . addEdit ( edit ) ; } public void beginCompoundEdit ( ) { if ( getFlag ( TEMPORARY ) ) return ; compoundEditCount ++ ; if ( compoundEdit == null ) { compoundEditNonEmpty = false ; compoundEdit = new CompoundEdit ( ) ; } } public void endCompoundEdit ( ) { if ( getFlag ( TEMPORARY ) ) return ; if ( compoundEditCount == 0 ) return ; compoundEditCount -- ; if ( compoundEditCount == 0 ) { compoundEdit . end ( ) ; if ( compoundEditNonEmpty && compoundEdit . canUndo ( ) ) undo . addEdit ( compoundEdit ) ; compoundEdit = null ; } } public boolean insideCompoundEdit ( ) { return compoundEdit != null ; } public void removeTrailingWhiteSpace ( int [ ] lines ) { Element map = getDefaultRootElement ( ) ; try { beginCompoundEdit ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { int pos , lineStart , lineEnd , tail ; Element lineElement = map . getElement ( lines [ i ] ) ; getText ( lineElement . getStartOffset ( ) , lineElement . getEndOffset ( ) - lineElement . getStartOffset ( ) - 1 , seg ) ; if ( seg . count == 0 ) continue ; lineStart = seg . offset ; lineEnd = seg . offset + seg . count - 1 ; for ( pos = lineEnd ; pos >= lineStart ; pos -- ) { if ( ! Character . isWhitespace ( seg . array [ pos ] ) ) break ; } tail = lineEnd - pos ; if ( tail == 0 ) continue ; remove ( lineElement . getEndOffset ( ) - 1 - tail , tail ) ; } } catch ( BadLocationException ble ) { Log . log ( Log . ERROR , this , ble ) ; } finally { endCompoundEdit ( ) ; } } public void shiftIndentLeft ( int [ ] lines ) { int tabSize = getTabSize ( ) ; int indentSize = getIndentSize ( ) ; boolean noTabs = getBooleanProperty ( "noTabs" ) ; Element map = getDefaultRootElement ( ) ; try { beginCompoundEdit ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { Element lineElement = map . getElement ( lines [ i ] ) ; int lineStart = lineElement . getStartOffset ( ) ; String line = getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 ) ; int whiteSpace = MiscUtilities . getLeadingWhiteSpace ( line ) ; if ( whiteSpace == 0 ) continue ; int whiteSpaceWidth = Math . max ( 0 , MiscUtilities . getLeadingWhiteSpaceWidth ( line , tabSize ) - indentSize ) ; remove ( lineStart , whiteSpace ) ; insertString ( lineStart , MiscUtilities . createWhiteSpace ( whiteSpaceWidth , ( noTabs ? 0 : tabSize ) ) , null ) ; } } catch ( BadLocationException ble ) { Log . log ( Log . ERROR , this , ble ) ; } finally { endCompoundEdit ( ) ; } } public void shiftIndentRight ( int [ ] lines ) { try { beginCompoundEdit ( ) ; int tabSize = getTabSize ( ) ; int indentSize = getIndentSize ( ) ; boolean noTabs = getBooleanProperty ( "noTabs" ) ; Element map = getDefaultRootElement ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { Element lineElement = map . getElement ( lines [ i ] ) ; int lineStart = lineElement . getStartOffset ( ) ; String line = getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 ) ; int whiteSpace = MiscUtilities . getLeadingWhiteSpace ( line ) ; int whiteSpaceWidth = MiscUtilities . getLeadingWhiteSpaceWidth ( line , tabSize ) + indentSize ; remove ( lineStart , whiteSpace ) ; insertString ( lineStart , MiscUtilities . createWhiteSpace ( whiteSpaceWidth , ( noTabs ? 0 : tabSize ) ) , null ) ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { endCompoundEdit ( ) ; } } public int getTabSize ( ) { return ( ( Integer ) getProperty ( "tabSize" ) ) . intValue ( ) ; } public int getIndentSize ( ) { return ( ( Integer ) getProperty ( "indentSize" ) ) . intValue ( ) ; } public boolean getBooleanProperty ( String name ) { Object obj = getProperty ( name ) ; if ( obj instanceof Boolean ) return ( ( Boolean ) obj ) . booleanValue ( ) ; else if ( "true" . equals ( obj ) || "on" . equals ( obj ) || "yes" . equals ( obj ) ) return true ; else return false ; } public void putBooleanProperty ( String name , boolean value ) { putProperty ( name , value ? Boolean . TRUE : Boolean . FALSE ) ; } public final Mode getMode ( ) { return mode ; } public void setMode ( Mode mode ) { if ( mode == null ) throw new NullPointerException ( "Mode must be non-null" ) ; if ( this . mode == mode ) return ; Mode oldMode = this . mode ; this . mode = mode ; propertiesChanged ( ) ; if ( oldMode != null ) { EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . MODE_CHANGED ) ) ; } } public void setMode ( ) { if ( ! getFlag ( LOADING ) ) clearProperties ( ) ; parseBufferLocalProperties ( ) ; String userMode = ( String ) getProperty ( "mode" ) ; if ( userMode != null ) { Mode m = jEdit . getMode ( userMode ) ; if ( m != null ) { setMode ( m ) ; return ; } } String nogzName = name . substring ( 0 , name . length ( ) - ( name . endsWith ( ".gz" ) ? 3 : 0 ) ) ; Element lineElement = getDefaultRootElement ( ) . getElement ( 0 ) ; try { String line = getText ( 0 , ( lineElement == null ? 0 : lineElement . getEndOffset ( ) - 1 ) ) ; Mode [ ] modes = jEdit . getModes ( ) ; for ( int i = 0 ; i < modes . length ; i ++ ) { if ( modes [ i ] . accept ( nogzName , line ) ) { setMode ( modes [ i ] ) ; return ; } } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } Mode defaultMode = jEdit . getMode ( jEdit . getProperty ( "buffer.defaultMode" ) ) ; if ( defaultMode == null ) defaultMode = jEdit . getMode ( "text" ) ; setMode ( defaultMode ) ; } public boolean indentLine ( int lineIndex , boolean canIncreaseIndent , boolean canDecreaseIndent ) { if ( lineIndex == 0 ) return false ; String openBrackets = ( String ) getProperty ( "indentOpenBrackets" ) ; String closeBrackets = ( String ) getProperty ( "indentCloseBrackets" ) ; String _indentPrevLine = ( String ) getProperty ( "indentPrevLine" ) ; boolean doubleBracketIndent = getBooleanProperty ( "doubleBracketIndent" ) ; RE indentPrevLineRE = null ; if ( openBrackets == null ) openBrackets = "" ; if ( closeBrackets == null ) closeBrackets = "" ; if ( _indentPrevLine != null ) { try { indentPrevLineRE = new RE ( _indentPrevLine , RE . REG_ICASE , RESearchMatcher . RE_SYNTAX_JEDIT ) ; } catch ( REException re ) { Log . log ( Log . ERROR , this , "Invalid 'indentPrevLine'" + " regexp: " + _indentPrevLine ) ; Log . log ( Log . ERROR , this , re ) ; } } int tabSize = getTabSize ( ) ; int indentSize = getIndentSize ( ) ; boolean noTabs = getBooleanProperty ( "noTabs" ) ; Element map = getDefaultRootElement ( ) ; String prevLine = null ; String line = null ; Element lineElement = map . getElement ( lineIndex ) ; int start = lineElement . getStartOffset ( ) ; try { line = getText ( start , lineElement . getEndOffset ( ) - start - 1 ) ; for ( int i = lineIndex - 1 ; i >= 0 ; i -- ) { lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; int len = lineElement . getEndOffset ( ) - lineStart - 1 ; if ( len != 0 ) { prevLine = getText ( lineStart , len ) ; break ; } } if ( prevLine == null ) return false ; } catch ( BadLocationException e ) { Log . log ( Log . ERROR , this , e ) ; return false ; } boolean prevLineMatches = ( indentPrevLineRE == null ? false : indentPrevLineRE . isMatch ( prevLine ) ) ; boolean prevLineStart = true ; int prevLineIndent = 0 ; int prevLineBrackets = 0 ; for ( int i = 0 ; i < prevLine . length ( ) ; i ++ ) { char c = prevLine . charAt ( i ) ; switch ( c ) { case ' ' : if ( prevLineStart ) prevLineIndent ++ ; break ; case '\t' : if ( prevLineStart ) { prevLineIndent += ( tabSize - ( prevLineIndent % tabSize ) ) ; } break ; default : prevLineStart = false ; if ( closeBrackets . indexOf ( c ) != - 1 ) prevLineBrackets = Math . max ( prevLineBrackets - 1 , 0 ) ; else if ( openBrackets . indexOf ( c ) != - 1 ) { if ( ! doubleBracketIndent ) prevLineMatches = false ; prevLineBrackets ++ ; } break ; } } boolean lineStart = true ; int lineIndent = 0 ; int lineWidth = 0 ; int lineBrackets = 0 ; int closeBracketIndex = - 1 ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { char c = line . charAt ( i ) ; switch ( c ) { case ' ' : if ( lineStart ) { lineIndent ++ ; lineWidth ++ ; } break ; case '\t' : if ( lineStart ) { lineIndent += ( tabSize - ( lineIndent % tabSize ) ) ; lineWidth ++ ; } break ; default : lineStart = false ; if ( closeBrackets . indexOf ( c ) != - 1 ) { if ( lineBrackets == 0 ) closeBracketIndex = i ; else lineBrackets -- ; } else if ( openBrackets . indexOf ( c ) != - 1 ) { if ( ! doubleBracketIndent ) prevLineMatches = false ; lineBrackets ++ ; } break ; } } try { if ( closeBracketIndex != - 1 ) { int offset = TextUtilities . findMatchingBracket ( this , lineIndex , closeBracketIndex ) ; if ( offset != - 1 ) { lineElement = map . getElement ( map . getElementIndex ( offset ) ) ; int startOffset = lineElement . getStartOffset ( ) ; String closeLine = getText ( startOffset , lineElement . getEndOffset ( ) - startOffset - 1 ) ; prevLineIndent = MiscUtilities . getLeadingWhiteSpaceWidth ( closeLine , tabSize ) ; } else return false ; } else { prevLineIndent += ( prevLineBrackets * indentSize ) ; } if ( prevLineMatches ) prevLineIndent += indentSize ; if ( ! canDecreaseIndent && prevLineIndent <= lineIndent ) return false ; if ( ! canIncreaseIndent && prevLineIndent >= lineIndent ) return false ; remove ( start , lineWidth ) ; insertString ( start , MiscUtilities . createWhiteSpace ( prevLineIndent , ( noTabs ? 0 : tabSize ) ) , null ) ; return true ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } return false ; } public void indentLines ( int start , int end ) { beginCompoundEdit ( ) ; for ( int i = start ; i <= end ; i ++ ) indentLine ( i , true , true ) ; endCompoundEdit ( ) ; } public void indentLines ( int [ ] lines ) { beginCompoundEdit ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) indentLine ( lines [ i ] , true , true ) ; endCompoundEdit ( ) ; } public void tokenizeLines ( ) { } public void tokenizeLines ( int start , int len ) { linesChanged ( start , len ) ; for ( int i = 0 ; i < len ; i ++ ) markTokens ( start + i ) ; } public int paintSyntaxLine ( int lineIndex , Graphics gfx , int _x , int _y , TabExpander expander , boolean style , boolean color , Font defaultFont , Color foreground , Color background , SyntaxStyle [ ] styles , TextRenderer renderer ) { float x = ( float ) _x ; float y = ( float ) _y ; LineInfo info = lineInfo [ lineIndex ] ; if ( info . tokensValid ) { Element lineElement = getDefaultRootElement ( ) . getElement ( lineIndex ) ; int lineStart = lineElement . getStartOffset ( ) ; try { getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 , seg ) ; } catch ( BadLocationException e ) { Log . log ( Log . ERROR , this , e ) ; } } else markTokens ( lineIndex ) ; Token tokens = info . firstToken ; char [ ] text = seg . array ; int off = seg . offset ; for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) break ; Color tokenForeground ; Color tokenBackground = null ; if ( id == Token . NULL ) { gfx . setFont ( defaultFont ) ; tokenForeground = foreground ; } else { if ( style ) gfx . setFont ( styles [ id ] . getFont ( ) ) ; else gfx . setFont ( defaultFont ) ; if ( color ) { tokenBackground = styles [ id ] . getBackgroundColor ( ) ; tokenForeground = styles [ id ] . getForegroundColor ( ) ; } else tokenForeground = foreground ; } int len = tokens . length ; x = renderer . drawChars ( text , off , len , gfx , x , y , expander , tokenForeground , tokenBackground , background ) ; off += len ; tokens = tokens . next ; } return ( int ) x ; } public LineInfo markTokens ( int lineIndex ) { LineInfo info = lineInfo [ lineIndex ] ; if ( info . tokensValid ) return info ; int start = Math . max ( 0 , lineIndex - 100 ) - 1 ; int end = Math . max ( 0 , lineIndex - 100 ) ; for ( int i = lineIndex - 1 ; i > end ; i -- ) { if ( lineInfo [ i ] . tokensValid ) { start = i ; break ; } } LineInfo prev ; if ( start == - 1 ) prev = null ; else prev = lineInfo [ start ] ; Element map = getDefaultRootElement ( ) ; for ( int i = start + 1 ; i <= lineIndex ; i ++ ) { info = lineInfo [ i ] ; if ( info . tokensValid ) { prev = info ; continue ; } Element lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; try { getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 , seg ) ; } catch ( BadLocationException e ) { Log . log ( Log . ERROR , this , e ) ; } info . lastToken = null ; ParserRule oldRule = info . context . inRule ; TokenMarker . LineContext oldParent = info . context . parent ; tokenMarker . markTokens ( prev , info , seg ) ; ParserRule newRule = info . context . inRule ; TokenMarker . LineContext newParent = info . context . parent ; info . tokensValid = true ; if ( i != lastTokenizedLine ) { nextLineRequested = false ; lastTokenizedLine = i ; } nextLineRequested |= ( oldRule != newRule || oldParent != newParent ) ; info . addToken ( 0 , Token . END ) ; prev = info ; } if ( nextLineRequested && lineCount - lineIndex > 1 ) { linesChanged ( lineIndex + 1 , lineCount - lineIndex - 1 ) ; } return info ; } public boolean setLineWidth ( int lineIndex , int width ) { LineInfo info = lineInfo [ lineIndex ] ; int oldWidth = info . width ; info . width = width ; return width != oldWidth ; } public int getMaxLineWidth ( int start , int len ) { int retVal = 0 ; int lines = 0 ; for ( int i = start ; ; i ++ ) { if ( i >= lineCount || lines >= len ) break ; LineInfo info = lineInfo [ i ] ; if ( info . visible ) { retVal = Math . max ( lineInfo [ i ] . width , retVal ) ; lines ++ ; } } return retVal ; } public boolean isNextLineRequested ( ) { return nextLineRequested ; } public LineInfo getLineInfo ( int line ) { return lineInfo [ line ] ; } public boolean isLineVisible ( int line ) { return lineInfo [ line ] . visible ; } public boolean isFoldStart ( int line ) { if ( line == lineCount - 1 ) return false ; return getFoldLevel ( line ) < getFoldLevel ( line + 1 ) ; } public int getFoldLevel ( int line ) { LineInfo info = lineInfo [ line ] ; if ( info . foldLevelValid ) return info . foldLevel ; else { boolean changed = false ; int tabSize = getTabSize ( ) ; Element lineElement = getDefaultRootElement ( ) . getElement ( line ) ; int start = lineElement . getStartOffset ( ) ; try { getText ( start , lineElement . getEndOffset ( ) - start - 1 , seg ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } int offset = seg . offset ; int count = seg . count ; int whitespace = 0 ; if ( count == 0 ) { if ( line != 0 ) whitespace = getFoldLevel ( line - 1 ) ; else whitespace = 0 ; } else { boolean seenNonWhitespace = false ; loop : for ( int i = 0 ; i < count ; i ++ ) { switch ( seg . array [ offset + i ] ) { case ' ' : whitespace ++ ; break ; case '\t' : whitespace += ( tabSize - whitespace % tabSize ) ; break ; default : seenNonWhitespace = true ; break loop ; } } if ( ! seenNonWhitespace ) { if ( line != 0 ) whitespace = getFoldLevel ( line - 1 ) ; else whitespace = 0 ; } } if ( info . foldLevel != whitespace ) { info . foldLevel = whitespace ; fireFoldLevelsChanged ( line - 1 , line - 1 ) ; } info . foldLevelValid = true ; return whitespace ; } } public int getPrevVisibleLine ( int lineNo ) { for ( int i = lineNo - 1 ; i >= 0 ; i -- ) { if ( lineInfo [ i ] . visible ) return i ; } return - 1 ; } public int getNextVisibleLine ( int lineNo ) { for ( int i = lineNo + 1 ; i < lineCount ; i ++ ) { if ( lineInfo [ i ] . visible ) return i ; } return - 1 ; } public int virtualToPhysical ( int lineNo ) { if ( ( lineNo < virtualLineCount && lineNo >= virtualLines . length ) || lineNo < 0 ) throw new RuntimeException ( "lineNo = " + lineNo ) ; if ( lineNo >= virtualLineCount ) return lineCount + ( lineNo - virtualLineCount ) ; return virtualLines [ lineNo ] ; } public int physicalToVirtual ( int lineNo ) { int start = 0 ; int end = virtualLineCount - 1 ; if ( lineNo < virtualLines [ start ] ) return start ; else if ( lineNo > virtualLines [ end ] ) return end ; for ( ; ; ) { switch ( end - start ) { case 0 : if ( virtualLines [ start ] < lineNo ) return start + 1 ; else return start ; case 1 : if ( virtualLines [ start ] < lineNo ) { if ( virtualLines [ end ] < lineNo ) return end + 1 ; else return end ; } else return start ; default : int pivot = start + ( end - start ) / 2 ; int value = virtualLines [ pivot ] ; if ( value == lineNo ) return pivot ; else if ( value < lineNo ) start = pivot + 1 ; else end = pivot - 1 ; break ; } } } public boolean collapseFoldAt ( int line ) { int initialFoldLevel = getFoldLevel ( line ) ; int start = 0 ; int end = lineCount - 1 ; if ( line != lineCount - 1 && getFoldLevel ( line + 1 ) > initialFoldLevel ) { start = line + 1 ; for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( getFoldLevel ( i ) <= initialFoldLevel ) { end = i - 1 ; break ; } } } else { boolean ok = false ; for ( int i = line - 1 ; i >= 0 ; i -- ) { if ( getFoldLevel ( i ) < initialFoldLevel ) { start = i + 1 ; ok = true ; break ; } } if ( ! ok ) { return false ; } for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( getFoldLevel ( i ) < initialFoldLevel ) { end = i - 1 ; break ; } } } int delta = ( end - start + 1 ) ; for ( int i = start ; i <= end ; i ++ ) { LineInfo info = lineInfo [ i ] ; if ( info . visible ) info . visible = false ; else delta -- ; } if ( delta == 0 ) { return false ; } start = physicalToVirtual ( start ) ; virtualLineCount -= delta ; System . arraycopy ( virtualLines , start + delta , virtualLines , start , virtualLines . length - start - delta ) ; fireFoldStructureChanged ( ) ; return true ; } public boolean expandFoldAt ( int line , boolean fully , JEditTextArea textArea ) { int initialFoldLevel = getFoldLevel ( line ) ; int start = 0 ; int end = lineCount - 1 ; if ( line != lineCount - 1 && lineInfo [ line ] . visible && ! lineInfo [ line + 1 ] . visible && getFoldLevel ( line + 1 ) > initialFoldLevel ) { start = line + 1 ; for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( lineInfo [ i ] . visible && getFoldLevel ( i ) <= initialFoldLevel ) { end = i - 1 ; break ; } } } else { boolean ok = false ; for ( int i = line - 1 ; i >= 0 ; i -- ) { if ( lineInfo [ i ] . visible && getFoldLevel ( i ) < initialFoldLevel ) { start = i + 1 ; ok = true ; break ; } } if ( ! ok ) { return false ; } for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( lineInfo [ i ] . visible && getFoldLevel ( i ) < initialFoldLevel ) { end = i - 1 ; break ; } } } int delta = 0 ; int tmpMapLen = 0 ; int [ ] tmpVirtualMap = new int [ end - start + 1 ] ; initialFoldLevel = getFoldLevel ( start ) ; for ( int i = start ; i <= end ; i ++ ) { LineInfo info = lineInfo [ i ] ; if ( info . visible ) { tmpVirtualMap [ tmpMapLen ++ ] = i ; } else if ( ! fully && getFoldLevel ( i ) > initialFoldLevel ) { } else { tmpVirtualMap [ tmpMapLen ++ ] = i ; delta ++ ; info . visible = true ; } } int virtualLine ; if ( start > virtualLines [ virtualLineCount - 1 ] ) virtualLine = virtualLineCount ; else virtualLine = physicalToVirtual ( start ) ; virtualLineCount += delta ; if ( virtualLines . length <= virtualLineCount ) { int [ ] virtualLinesN = new int [ ( virtualLineCount + 1 ) * 2 ] ; System . arraycopy ( virtualLines , 0 , virtualLinesN , 0 , virtualLines . length ) ; virtualLines = virtualLinesN ; } System . arraycopy ( virtualLines , virtualLine , virtualLines , virtualLine + delta , virtualLines . length - virtualLine - delta ) ; for ( int j = 0 ; j < tmpMapLen ; j ++ ) { virtualLines [ virtualLine + j ] = tmpVirtualMap [ j ] ; } fireFoldStructureChanged ( ) ; if ( textArea != null ) { int firstLine = textArea . getFirstLine ( ) ; int visibleLines = textArea . getVisibleLines ( ) ; if ( virtualLine + delta >= firstLine + visibleLines && delta < visibleLines - 1 ) { textArea . setFirstLine ( virtualLine + delta - visibleLines + 1 ) ; } } return true ; } public void expandFolds ( char digit ) { if ( digit < '1' || digit > '9' ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } else expandFolds ( ( int ) ( digit - '1' ) + 1 ) ; } public void expandFolds ( int level ) { if ( virtualLines . length <= lineCount ) { int [ ] virtualLinesN = new int [ ( lineCount + 1 ) * 2 ] ; System . arraycopy ( virtualLines , 0 , virtualLinesN , 0 , virtualLines . length ) ; virtualLines = virtualLinesN ; } level = ( level - 1 ) * getIndentSize ( ) + 1 ; boolean seenVisibleLine = false ; virtualLineCount = 0 ; for ( int i = 0 ; i < lineCount ; i ++ ) { if ( ! seenVisibleLine || getFoldLevel ( i ) < level ) { seenVisibleLine = true ; lineInfo [ i ] . visible = true ; virtualLines [ virtualLineCount ++ ] = i ; } else lineInfo [ i ] . visible = false ; } fireFoldStructureChanged ( ) ; } public void expandAllFolds ( ) { if ( virtualLines . length <= lineCount ) { int [ ] virtualLinesN = new int [ ( lineCount + 1 ) * 2 ] ; System . arraycopy ( virtualLines , 0 , virtualLinesN , 0 , virtualLines . length ) ; virtualLines = virtualLinesN ; } virtualLineCount = lineCount ; for ( int i = 0 ; i < lineCount ; i ++ ) { virtualLines [ i ] = i ; lineInfo [ i ] . visible = true ; } fireFoldStructureChanged ( ) ; } public void narrow ( int start , int end ) { virtualLineCount = end - start + 1 ; virtualLines = new int [ virtualLineCount ] ; for ( int i = 0 ; i < start ; i ++ ) lineInfo [ i ] . visible = false ; for ( int i = start ; i <= end ; i ++ ) { LineInfo info = lineInfo [ i ] ; info . visible = true ; virtualLines [ i - start ] = i ; } for ( int i = end + 1 ; i < lineCount ; i ++ ) lineInfo [ i ] . visible = false ; fireFoldStructureChanged ( ) ; } public void addFoldListener ( FoldListener l ) { foldListeners . addElement ( l ) ; } public void removeFoldListener ( FoldListener l ) { foldListeners . removeElement ( l ) ; } public int getLineCount ( ) { return lineCount ; } public int getVirtualLineCount ( ) { return virtualLineCount ; } public final Vector getMarkers ( ) { return markers ; } public void addOrRemoveMarker ( char shortcut , int pos ) { Element map = getDefaultRootElement ( ) ; int line = map . getElementIndex ( pos ) ; if ( getMarkerAtLine ( line ) != null ) removeMarker ( line ) ; else addMarker ( shortcut , pos ) ; } public void addMarker ( char shortcut , int pos ) { if ( ! getFlag ( READ_ONLY ) && jEdit . getBooleanProperty ( "persistentMarkers" ) ) setDirty ( true ) ; Marker markerN = new Marker ( this , shortcut , pos ) ; boolean added = false ; Element map = getDefaultRootElement ( ) ; int line = map . getElementIndex ( pos ) ; if ( ! getFlag ( LOADING ) ) { markerN . createPosition ( ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; if ( shortcut != '\0' && marker . getShortcut ( ) == shortcut ) marker . setShortcut ( '\0' ) ; if ( map . getElementIndex ( marker . getPosition ( ) ) == line ) { markers . removeElementAt ( i ) ; i -- ; } } for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; if ( marker . getPosition ( ) > pos ) { markers . insertElementAt ( markerN , i ) ; added = true ; break ; } } } if ( ! added ) markers . addElement ( markerN ) ; if ( ! getFlag ( LOADING ) ) { EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . MARKERS_CHANGED ) ) ; } } public Marker getMarkerAtLine ( int line ) { Element map = getDefaultRootElement ( ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; if ( map . getElementIndex ( marker . getPosition ( ) ) == line ) return marker ; } return null ; } public void removeMarker ( int line ) { Element map = getDefaultRootElement ( ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; if ( map . getElementIndex ( marker . getPosition ( ) ) == line ) { if ( ! getFlag ( READ_ONLY ) && jEdit . getBooleanProperty ( "persistentMarkers" ) ) setDirty ( true ) ; marker . removePosition ( ) ; markers . removeElementAt ( i ) ; i -- ; } } EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . MARKERS_CHANGED ) ) ; } public void removeAllMarkers ( ) { if ( ! getFlag ( READ_ONLY ) && jEdit . getBooleanProperty ( "persistentMarkers" ) ) setDirty ( true ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) ( ( Marker ) markers . elementAt ( i ) ) . removePosition ( ) ; markers . removeAllElements ( ) ; EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . MARKERS_CHANGED ) ) ; } public Marker getMarker ( char shortcut ) { Enumeration enum = markers . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Marker marker = ( Marker ) enum . nextElement ( ) ; if ( marker . getShortcut ( ) == shortcut ) return marker ; } return null ; } public final Buffer getNext ( ) { return next ; } public final Buffer getPrev ( ) { return prev ; } public final int getIndex ( ) { int count = 0 ; Buffer buffer = prev ; for ( ; ; ) { if ( buffer == null ) break ; count ++ ; buffer = buffer . prev ; } return count ; } public String toString ( ) { return name + " (" + vfs . getParentOfPath ( path ) + ")" ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof PropertiesChanged ) propertiesChanged ( ) ; } Buffer prev ; Buffer next ; Buffer ( View view , String path , boolean newFile , boolean temp , Hashtable props ) { lineCount = 1 ; lineInfo = new LineInfo [ 1 ] ; lineInfo [ 0 ] = new LineInfo ( ) ; lineInfo [ 0 ] . visible = true ; virtualLineCount = 1 ; virtualLines = new int [ 1 ] ; foldListeners = new Vector ( ) ; seg = new Segment ( ) ; lastTokenizedLine = - 1 ; setDocumentProperties ( new BufferProps ( ) ) ; clearProperties ( ) ; setFlag ( TEMPORARY , temp ) ; markers = new Vector ( ) ; addUndoableEditListener ( new UndoHandler ( ) ) ; Enumeration keys = props . keys ( ) ; Enumeration values = props . elements ( ) ; while ( keys . hasMoreElements ( ) ) { putProperty ( keys . nextElement ( ) , values . nextElement ( ) ) ; } Mode defaultMode = jEdit . getMode ( jEdit . getProperty ( "buffer.defaultMode" ) ) ; if ( defaultMode == null ) defaultMode = jEdit . getMode ( "text" ) ; setMode ( defaultMode ) ; setPath ( path ) ; setFlag ( UNTITLED , newFile ) ; if ( file != null ) newFile |= ! file . exists ( ) ; if ( ! temp ) EditBus . addToBus ( Buffer . this ) ; setFlag ( NEW_FILE , newFile ) ; } void commitTemporary ( ) { setFlag ( TEMPORARY , false ) ; EditBus . addToBus ( this ) ; } void close ( ) { setFlag ( CLOSED , true ) ; if ( autosaveFile != null ) autosaveFile . delete ( ) ; EditBus . removeFromBus ( this ) ; } protected void fireInsertUpdate ( DocumentEvent evt ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { int index = ch . getIndex ( ) ; int len = ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ; addLinesToMap ( ch . getIndex ( ) + 1 , len ) ; linesChanged ( index , lineCount - index ) ; index += ( len + 1 ) ; } else { linesChanged ( getDefaultRootElement ( ) . getElementIndex ( evt . getOffset ( ) ) , 1 ) ; } super . fireInsertUpdate ( evt ) ; setDirty ( true ) ; } protected void fireRemoveUpdate ( DocumentEvent evt ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { int index = ch . getIndex ( ) ; int len = ch . getChildrenRemoved ( ) . length - ch . getChildrenAdded ( ) . length ; removeLinesFromMap ( index , len ) ; linesChanged ( index , lineCount - index ) ; } else { linesChanged ( getDefaultRootElement ( ) . getElementIndex ( evt . getOffset ( ) ) , 1 ) ; } super . fireRemoveUpdate ( evt ) ; setDirty ( true ) ; } private void setFlag ( int flag , boolean value ) { if ( value ) flags |= ( 1 << flag ) ; else flags &= ~ ( 1 << flag ) ; } private boolean getFlag ( int flag ) { int mask = ( 1 << flag ) ; return ( flags & mask ) == mask ; } private static final int CLOSED = 0 ; private static final int LOADING = 1 ; private static final int IO = 2 ; private static final int NEW_FILE = 3 ; private static final int UNTITLED = 4 ; private static final int AUTOSAVE_DIRTY = 5 ; private static final int DIRTY = 6 ; private static final int READ_ONLY = 7 ; private static final int UNDO_IN_PROGRESS = 8 ; private static final int TEMPORARY = 9 ; private int flags ; private long modTime ; private File file ; private VFS vfs ; private File autosaveFile ; private String path ; private String name ; private Mode mode ; private MyUndoManager undo ; private CompoundEdit compoundEdit ; private boolean compoundEditNonEmpty ; private int compoundEditCount ; private Vector markers ; private int savedSelStart ; private int savedSelEnd ; private TokenMarker tokenMarker ; private Segment seg ; private LineInfo [ ] lineInfo ; private int lineCount ; private int lastTokenizedLine ; private boolean nextLineRequested ; private int [ ] virtualLines ; private int virtualLineCount ; private Vector foldListeners ; private void setPath ( String path ) { this . path = path ; vfs = VFSManager . getVFSForPath ( path ) ; if ( ( vfs . getCapabilities ( ) & VFS . WRITE_CAP ) == 0 ) setReadOnly ( true ) ; name = vfs . getFileName ( path ) ; if ( vfs instanceof FileVFS ) { file = new File ( path ) ; if ( autosaveFile != null ) autosaveFile . delete ( ) ; autosaveFile = new File ( file . getParent ( ) , '#' + name + '#' ) ; } } private boolean recoverAutosave ( final View view ) { if ( ! autosaveFile . canRead ( ) ) return false ; GUIUtilities . hideSplashScreen ( ) ; final Object [ ] args = { autosaveFile . getPath ( ) } ; int result = GUIUtilities . confirm ( view , "autosave-found" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { vfs . load ( view , this , autosaveFile . getPath ( ) ) ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { GUIUtilities . message ( view , "autosave-loaded" , args ) ; } } ) ; return true ; } else return false ; } private void clearProperties ( ) { Object lineSeparator = getProperty ( LINESEP ) ; Object encoding = getProperty ( ENCODING ) ; ( ( BufferProps ) getDocumentProperties ( ) ) . clear ( ) ; putProperty ( "i18n" , Boolean . FALSE ) ; if ( lineSeparator != null ) putProperty ( LINESEP , lineSeparator ) ; if ( encoding != null ) putProperty ( ENCODING , encoding ) ; else putProperty ( ENCODING , System . getProperty ( "file.encoding" ) ) ; } private void parseBufferLocalProperties ( ) { try { Element map = getDefaultRootElement ( ) ; for ( int i = 0 ; i < Math . min ( 10 , map . getElementCount ( ) ) ; i ++ ) { Element line = map . getElement ( i ) ; String text = getText ( line . getStartOffset ( ) , line . getEndOffset ( ) - line . getStartOffset ( ) - 1 ) ; parseBufferLocalProperty ( text ) ; } for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { ( ( Marker ) markers . elementAt ( i ) ) . createPosition ( ) ; } } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } } private void parseBufferLocalProperty ( String prop ) { StringBuffer buf = new StringBuffer ( ) ; String name = null ; boolean escape = false ; for ( int i = 0 ; i < prop . length ( ) ; i ++ ) { char c = prop . charAt ( i ) ; switch ( c ) { case ':' : if ( escape ) { escape = false ; buf . append ( ':' ) ; break ; } if ( name != null ) { String value = buf . toString ( ) ; try { putProperty ( name , new Integer ( value ) ) ; } catch ( NumberFormatException nf ) { putProperty ( name , value ) ; } } buf . setLength ( 0 ) ; break ; case '=' : if ( escape ) { escape = false ; buf . append ( '=' ) ; break ; } name = buf . toString ( ) ; buf . setLength ( 0 ) ; break ; case '\\' : if ( escape ) buf . append ( '\\' ) ; escape = ! escape ; break ; case 'n' : if ( escape ) { buf . append ( '\n' ) ; escape = false ; break ; } case 't' : if ( escape ) { buf . append ( '\t' ) ; escape = false ; break ; } default : buf . append ( c ) ; break ; } } } private void setTokenMarker ( TokenMarker tokenMarker ) { this . tokenMarker = tokenMarker ; ParserRuleSet mainSet = tokenMarker . getMainRuleSet ( ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { LineInfo info = lineInfo [ i ] ; info . context = new TokenMarker . LineContext ( null , mainSet ) ; info . tokensValid = false ; } } private void addLinesToMap ( int index , int lines ) { if ( lines <= 0 ) return ; LineInfo prev = lineInfo [ index - 1 ] ; int virtualLine ; if ( index == lineCount ) virtualLine = virtualLineCount ; else virtualLine = physicalToVirtual ( index ) ; int virtualLength ; if ( prev . visible ) { virtualLineCount += lines ; if ( virtualLines . length <= virtualLineCount ) { int [ ] virtualLinesN = new int [ ( virtualLineCount + 1 ) * 2 ] ; System . arraycopy ( virtualLines , 0 , virtualLinesN , 0 , virtualLines . length ) ; virtualLines = virtualLinesN ; } virtualLength = virtualLine + lines ; System . arraycopy ( virtualLines , virtualLine , virtualLines , virtualLength , virtualLines . length - virtualLength ) ; for ( int i = 0 ; i < lines ; i ++ ) virtualLines [ virtualLine + i ] = index + i ; } else virtualLength = virtualLine ; for ( int i = virtualLength ; i < virtualLineCount ; i ++ ) virtualLines [ i ] += lines ; lineCount += lines ; if ( lineInfo . length <= lineCount ) { LineInfo [ ] lineInfoN = new LineInfo [ ( lineCount + 1 ) * 2 ] ; System . arraycopy ( lineInfo , 0 , lineInfoN , 0 , lineInfo . length ) ; lineInfo = lineInfoN ; } int length = index + lines ; System . arraycopy ( lineInfo , index , lineInfo , length , lineInfo . length - length ) ; ParserRuleSet mainSet = tokenMarker . getMainRuleSet ( ) ; for ( int i = 0 ; i < lines ; i ++ ) { LineInfo info = new LineInfo ( ) ; info . context = new TokenMarker . LineContext ( null , mainSet ) ; info . visible = prev . visible ; lineInfo [ index + i ] = info ; } } private void removeLinesFromMap ( int index , int lines ) { if ( lines <= 0 ) return ; int length = index + lines ; int virtualLine = physicalToVirtual ( index ) ; int virtualLength = physicalToVirtual ( length ) ; if ( length <= virtualLines [ virtualLineCount - 1 ] ) { System . arraycopy ( virtualLines , virtualLength , virtualLines , virtualLine , virtualLines . length - virtualLength ) ; for ( int i = virtualLine ; i < virtualLineCount - ( virtualLength - virtualLine ) ; i ++ ) virtualLines [ i ] -= lines ; } virtualLineCount -= ( virtualLength - virtualLine ) ; lineCount -= lines ; System . arraycopy ( lineInfo , length , lineInfo , index , lineInfo . length - length ) ; } private void linesChanged ( int index , int lines ) { for ( int i = 0 ; i < lines ; i ++ ) { LineInfo info = lineInfo [ index + i ] ; info . tokensValid = false ; info . foldLevelValid = false ; } } static class PrintTabExpander implements TabExpander { private int leftMargin ; private int tabSize ; public PrintTabExpander ( int leftMargin , int tabSize ) { this . leftMargin = leftMargin ; this . tabSize = tabSize ; } public float nextTabStop ( float x , int tabOffset ) { int ntabs = ( ( int ) x - leftMargin ) / tabSize ; return ( ntabs + 1 ) * tabSize + leftMargin ; } } private void fireFoldLevelsChanged ( int firstLine , int lastLine ) { for ( int i = 0 ; i < foldListeners . size ( ) ; i ++ ) { ( ( FoldListener ) foldListeners . elementAt ( i ) ) . foldLevelsChanged ( firstLine , lastLine ) ; } } private void fireFoldStructureChanged ( ) { for ( int i = 0 ; i < foldListeners . size ( ) ; i ++ ) { ( ( FoldListener ) foldListeners . elementAt ( i ) ) . foldStructureChanged ( ) ; } } public static interface FoldListener { void foldLevelsChanged ( int firstLine , int lastLine ) ; void foldStructureChanged ( ) ; } public static class LineInfo { public TokenMarker . LineContext context ; public Token getFirstToken ( ) { return firstToken ; } public Token getLastToken ( ) { return lastToken ; } public void addToken ( int length , byte id ) { if ( length == 0 && id != Token . END ) return ; if ( firstToken == null ) { firstToken = new Token ( length , id ) ; lastToken = firstToken ; } else if ( lastToken == null ) { lastToken = firstToken ; firstToken . length = length ; firstToken . id = id ; } else if ( lastToken . id == id ) { lastToken . length += length ; } else if ( lastToken . next == null ) { lastToken . next = new Token ( length , id ) ; lastToken . next . prev = lastToken ; lastToken = lastToken . next ; } else { lastToken = lastToken . next ; lastToken . length = length ; lastToken . id = id ; } } Token firstToken ; Token lastToken ; boolean tokensValid ; int width ; int foldLevel ; boolean foldLevelValid ; boolean visible ; } class BufferProps extends Hashtable { public Object get ( Object key ) { Object o = super . get ( key ) ; if ( o != null ) return o ; if ( ! ( key instanceof String ) ) return null ; if ( mode != null ) return mode . getProperty ( ( String ) key ) ; else { String value = jEdit . getProperty ( "buffer." + key ) ; if ( value == null ) return null ; try { return new Integer ( value ) ; } catch ( NumberFormatException nf ) { return value ; } } } } class MyUndoManager extends UndoManager { public UndoableEdit editToBeUndone ( ) { return super . editToBeUndone ( ) ; } public UndoableEdit editToBeRedone ( ) { return super . editToBeRedone ( ) ; } } class UndoHandler implements UndoableEditListener { public void undoableEditHappened ( UndoableEditEvent evt ) { addUndoableEdit ( evt . getEdit ( ) ) ; } } } 	1	['126', '3', '0', '102', '316', '6941', '79', '40', '90', '0.95255814', '5047', '0.790697674', '7', '0.324324324', '0.068783069', '1', '1', '38.71428571', '25', '3.5317', '25']
package org . gjt . sp . jedit . gui ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . msg . BufferUpdate ; import org . gjt . sp . jedit . * ; public class BufferOptions extends EnhancedDialog { public BufferOptions ( View view , Buffer buffer ) { super ( view , jEdit . getProperty ( "buffer-options.title" ) , true ) ; this . view = view ; this . buffer = buffer ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; ActionHandler actionListener = new ActionHandler ( ) ; JPanel panel = new JPanel ( ) ; GridBagLayout layout = new GridBagLayout ( ) ; panel . setLayout ( layout ) ; Insets nullInsets = new Insets ( 0 , 0 , 0 , 0 ) ; Insets labelInsets = new Insets ( 0 , 0 , 0 , 12 ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridx = cons . gridy = 0 ; cons . gridwidth = cons . gridheight = 1 ; cons . fill = GridBagConstraints . BOTH ; cons . weightx = 0.0f ; cons . insets = labelInsets ; cons . gridx = 0 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; JLabel label = new JLabel ( jEdit . getProperty ( "buffer-options.mode" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; modes = jEdit . getModes ( ) ; String bufferMode = buffer . getMode ( ) . getName ( ) ; int index = 0 ; String [ ] modeNames = new String [ modes . length ] ; for ( int i = 0 ; i < modes . length ; i ++ ) { Mode mode = modes [ i ] ; modeNames [ i ] = mode . getName ( ) ; if ( bufferMode . equals ( mode . getName ( ) ) ) index = i ; } mode = new JComboBox ( modeNames ) ; mode . setSelectedIndex ( index ) ; mode . addActionListener ( actionListener ) ; layout . setConstraints ( mode , cons ) ; panel . add ( mode ) ; cons . gridx = 0 ; cons . gridy = 1 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "options.editing.tabSize" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; String [ ] tabSizes = { "2" , "4" , "8" } ; tabSize = new JComboBox ( tabSizes ) ; tabSize . setEditable ( true ) ; tabSize . setSelectedItem ( buffer . getProperty ( "tabSize" ) ) ; tabSize . addActionListener ( actionListener ) ; layout . setConstraints ( tabSize , cons ) ; panel . add ( tabSize ) ; cons . gridx = 0 ; cons . gridy = 2 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "options.editing.indentSize" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; indentSize = new JComboBox ( tabSizes ) ; indentSize . setEditable ( true ) ; indentSize . setSelectedItem ( buffer . getProperty ( "indentSize" ) ) ; indentSize . addActionListener ( actionListener ) ; layout . setConstraints ( indentSize , cons ) ; panel . add ( indentSize ) ; cons . gridx = 0 ; cons . gridy = 3 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "options.editing.maxLineLen" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; String [ ] lineLengths = { "0" , "72" , "76" , "80" } ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; maxLineLen = new JComboBox ( lineLengths ) ; maxLineLen . setEditable ( true ) ; maxLineLen . setSelectedItem ( buffer . getProperty ( "maxLineLen" ) ) ; maxLineLen . addActionListener ( actionListener ) ; layout . setConstraints ( maxLineLen , cons ) ; panel . add ( maxLineLen ) ; cons . gridx = 0 ; cons . gridy = 4 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "buffer-options.lineSeparator" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; String [ ] lineSeps = { jEdit . getProperty ( "lineSep.unix" ) , jEdit . getProperty ( "lineSep.windows" ) , jEdit . getProperty ( "lineSep.mac" ) } ; lineSeparator = new JComboBox ( lineSeps ) ; String lineSep = ( String ) buffer . getProperty ( Buffer . LINESEP ) ; if ( lineSep == null ) lineSep = System . getProperty ( "line.separator" ) ; if ( "\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 0 ) ; else if ( "\r\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 1 ) ; else if ( "\r" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 2 ) ; lineSeparator . addActionListener ( actionListener ) ; layout . setConstraints ( lineSeparator , cons ) ; panel . add ( lineSeparator ) ; cons . gridx = 0 ; cons . gridy = 5 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "buffer-options.encoding" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; DefaultComboBoxModel encodings = new DefaultComboBoxModel ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { encodings . addElement ( st . nextToken ( ) ) ; } encoding = new JComboBox ( encodings ) ; encoding . setEditable ( true ) ; encoding . setSelectedItem ( buffer . getProperty ( Buffer . ENCODING ) ) ; layout . setConstraints ( encoding , cons ) ; panel . add ( encoding ) ; cons . gridx = 0 ; cons . gridy = 6 ; cons . weightx = 0.0f ; cons . gridwidth = cons . REMAINDER ; cons . fill = GridBagConstraints . NONE ; cons . anchor = GridBagConstraints . WEST ; syntax = new JCheckBox ( jEdit . getProperty ( "options.editing.syntax" ) ) ; syntax . setSelected ( buffer . getBooleanProperty ( "syntax" ) ) ; syntax . addActionListener ( actionListener ) ; layout . setConstraints ( syntax , cons ) ; panel . add ( syntax ) ; cons . gridy = 7 ; indentOnTab = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnTab" ) ) ; indentOnTab . setSelected ( buffer . getBooleanProperty ( "indentOnTab" ) ) ; indentOnTab . addActionListener ( actionListener ) ; layout . setConstraints ( indentOnTab , cons ) ; panel . add ( indentOnTab ) ; cons . gridy = 8 ; indentOnEnter = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnEnter" ) ) ; indentOnEnter . setSelected ( buffer . getBooleanProperty ( "indentOnEnter" ) ) ; indentOnEnter . addActionListener ( actionListener ) ; layout . setConstraints ( indentOnEnter , cons ) ; panel . add ( indentOnEnter ) ; cons . gridy = 9 ; noTabs = new JCheckBox ( jEdit . getProperty ( "options.editing.noTabs" ) ) ; noTabs . setSelected ( buffer . getBooleanProperty ( "noTabs" ) ) ; noTabs . addActionListener ( actionListener ) ; layout . setConstraints ( noTabs , cons ) ; panel . add ( noTabs ) ; cons . gridy = 10 ; cons . insets = new Insets ( 6 , 0 , 6 , 0 ) ; label = new JLabel ( jEdit . getProperty ( "buffer-options.props" ) ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; content . add ( BorderLayout . NORTH , panel ) ; props = new JTextArea ( 4 , 4 ) ; props . setLineWrap ( true ) ; props . setWrapStyleWord ( false ) ; content . add ( BorderLayout . CENTER , new JScrollPane ( props ) ) ; updatePropsField ( ) ; panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; panel . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( actionListener ) ; getRootPane ( ) . setDefaultButton ( ok ) ; panel . add ( ok ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( actionListener ) ; panel . add ( cancel ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , panel ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { try { buffer . putProperty ( "tabSize" , new Integer ( tabSize . getSelectedItem ( ) . toString ( ) ) ) ; } catch ( NumberFormatException nf ) { } try { buffer . putProperty ( "indentSize" , new Integer ( indentSize . getSelectedItem ( ) . toString ( ) ) ) ; } catch ( NumberFormatException nf ) { } try { buffer . putProperty ( "maxLineLen" , new Integer ( maxLineLen . getSelectedItem ( ) . toString ( ) ) ) ; } catch ( NumberFormatException nf ) { } int index = mode . getSelectedIndex ( ) ; buffer . setMode ( modes [ index ] ) ; index = lineSeparator . getSelectedIndex ( ) ; String lineSep ; if ( index == 0 ) lineSep = "\n" ; else if ( index == 1 ) lineSep = "\r\n" ; else if ( index == 2 ) lineSep = "\r" ; else throw new InternalError ( ) ; String oldLineSep = ( String ) buffer . getProperty ( Buffer . LINESEP ) ; if ( oldLineSep == null ) oldLineSep = System . getProperty ( "line.separator" ) ; if ( ! oldLineSep . equals ( lineSep ) ) { buffer . putProperty ( "lineSeparator" , lineSep ) ; buffer . setDirty ( true ) ; } String encoding = ( String ) this . encoding . getSelectedItem ( ) ; String oldEncoding = ( String ) buffer . getProperty ( Buffer . ENCODING ) ; if ( ! oldEncoding . equals ( encoding ) ) { buffer . putProperty ( Buffer . ENCODING , encoding ) ; buffer . setDirty ( true ) ; EditBus . send ( new BufferUpdate ( buffer , view , BufferUpdate . ENCODING_CHANGED ) ) ; } buffer . putBooleanProperty ( "syntax" , syntax . isSelected ( ) ) ; buffer . putBooleanProperty ( "indentOnTab" , indentOnTab . isSelected ( ) ) ; buffer . putBooleanProperty ( "indentOnEnter" , indentOnEnter . isSelected ( ) ) ; buffer . putBooleanProperty ( "noTabs" , noTabs . isSelected ( ) ) ; buffer . propertiesChanged ( ) ; dispose ( ) ; view . getTextArea ( ) . getPainter ( ) . repaint ( ) ; } public void cancel ( ) { dispose ( ) ; } private View view ; private Buffer buffer ; private JComboBox tabSize ; private JComboBox indentSize ; private JComboBox maxLineLen ; private Mode [ ] modes ; private JComboBox mode ; private JComboBox lineSeparator ; private JComboBox encoding ; private JCheckBox indentOnTab ; private JCheckBox indentOnEnter ; private JCheckBox syntax ; private JCheckBox noTabs ; private JTextArea props ; private JButton ok ; private JButton cancel ; private void updatePropsField ( ) { props . setText ( ":mode=" + modes [ mode . getSelectedIndex ( ) ] . getName ( ) + ":tabSize=" + tabSize . getSelectedItem ( ) + ":indentSize=" + indentSize . getSelectedItem ( ) + ":noTabs=" + noTabs . isSelected ( ) + ":indentOnTab=" + indentOnTab . isSelected ( ) + ":indentOnEnter=" + indentOnEnter . isSelected ( ) + ":syntax=" + syntax . isSelected ( ) + ":maxLineLen=" + maxLineLen . getSelectedItem ( ) + ":" ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; else if ( source == mode ) { Mode _mode = jEdit . getMode ( ( String ) mode . getSelectedItem ( ) ) ; tabSize . setSelectedItem ( _mode . getProperty ( "tabSize" ) ) ; indentSize . setSelectedItem ( _mode . getProperty ( "indentSize" ) ) ; maxLineLen . setSelectedItem ( _mode . getProperty ( "maxLineLen" ) ) ; indentOnTab . setSelected ( _mode . getBooleanProperty ( "indentOnTab" ) ) ; indentOnEnter . setSelected ( _mode . getBooleanProperty ( "indentOnEnter" ) ) ; syntax . setSelected ( _mode . getBooleanProperty ( "syntax" ) ) ; noTabs . setSelected ( _mode . getBooleanProperty ( "noTabs" ) ) ; updatePropsField ( ) ; } else updatePropsField ( ) ; } } } 	1	['15', '7', '0', '12', '91', '47', '2', '11', '3', '0.808035714', '1186', '1', '3', '0.979010495', '0.283333333', '1', '1', '77', '7', '1.3333', '6']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . event . * ; import java . awt . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; public class CompleteWord extends JWindow { public CompleteWord ( View view , String word , Vector completions , Point location ) { super ( view ) ; this . view = view ; this . word = word ; words = new JList ( completions ) ; words . setVisibleRowCount ( Math . min ( completions . size ( ) , 8 ) ) ; words . addMouseListener ( new MouseHandler ( ) ) ; words . setSelectedIndex ( 0 ) ; words . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scroller = new JScrollPane ( words , JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; getContentPane ( ) . add ( scroller , BorderLayout . CENTER ) ; GUIUtilities . requestFocus ( this , words ) ; pack ( ) ; setLocation ( location ) ; show ( ) ; KeyHandler keyHandler = new KeyHandler ( ) ; addKeyListener ( keyHandler ) ; getRootPane ( ) . addKeyListener ( keyHandler ) ; words . addKeyListener ( keyHandler ) ; view . setKeyEventInterceptor ( keyHandler ) ; } public void dispose ( ) { view . setKeyEventInterceptor ( null ) ; super . dispose ( ) ; } private View view ; private String word ; private JList words ; private void insertSelected ( ) { view . getTextArea ( ) . setSelectedText ( ( ( String ) words . getSelectedValue ( ) ) . substring ( word . length ( ) ) ) ; dispose ( ) ; } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { switch ( evt . getKeyCode ( ) ) { case KeyEvent . VK_TAB : case KeyEvent . VK_ENTER : insertSelected ( ) ; evt . consume ( ) ; break ; case KeyEvent . VK_ESCAPE : dispose ( ) ; evt . consume ( ) ; break ; case KeyEvent . VK_UP : if ( getFocusOwner ( ) == words ) return ; int selected = words . getSelectedIndex ( ) ; if ( selected == 0 ) return ; selected = selected - 1 ; words . setSelectedIndex ( selected ) ; words . ensureIndexIsVisible ( selected ) ; evt . consume ( ) ; break ; case KeyEvent . VK_DOWN : if ( getFocusOwner ( ) == words ) return ; selected = words . getSelectedIndex ( ) ; if ( selected == words . getModel ( ) . getSize ( ) - 1 ) return ; selected = selected + 1 ; words . setSelectedIndex ( selected ) ; words . ensureIndexIsVisible ( selected ) ; evt . consume ( ) ; break ; default : dispose ( ) ; view . processKeyEvent ( evt ) ; break ; } } public void keyTyped ( KeyEvent evt ) { evt = KeyEventWorkaround . processKeyEvent ( evt ) ; if ( evt == null ) return ; else { dispose ( ) ; view . processKeyEvent ( evt ) ; } } } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { insertSelected ( ) ; } } } 	1	['6', '5', '0', '5', '34', '0', '3', '5', '2', '0.4', '129', '1', '1', '0.991816694', '0.277777778', '0', '0', '20', '1', '0.8333', '1']
package org . gjt . sp . jedit . options ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; public class ContextOptionPane extends AbstractOptionPane { public ContextOptionPane ( ) { super ( "context" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; JLabel caption = new JLabel ( jEdit . getProperty ( "options.context.caption" ) ) ; add ( BorderLayout . NORTH , caption ) ; String contextMenu = jEdit . getProperty ( "view.context" ) ; StringTokenizer st = new StringTokenizer ( contextMenu ) ; listModel = new DefaultListModel ( ) ; while ( st . hasMoreTokens ( ) ) { String actionName = ( String ) st . nextToken ( ) ; String label = getActionLabel ( actionName ) ; if ( label == null ) continue ; listModel . addElement ( new MenuItem ( actionName , label ) ) ; } list = new JList ( listModel ) ; list . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; list . addListSelectionListener ( new ListHandler ( ) ) ; add ( BorderLayout . CENTER , new JScrollPane ( list ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setBorder ( new EmptyBorder ( 3 , 0 , 0 , 0 ) ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( Box . createGlue ( ) ) ; ActionHandler actionHandler = new ActionHandler ( ) ; add = new JButton ( jEdit . getProperty ( "options.context.add" ) ) ; add . addActionListener ( actionHandler ) ; buttons . add ( add ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; remove = new JButton ( jEdit . getProperty ( "options.context.remove" ) ) ; remove . addActionListener ( actionHandler ) ; buttons . add ( remove ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; moveUp = new JButton ( jEdit . getProperty ( "options.context.moveUp" ) ) ; moveUp . addActionListener ( actionHandler ) ; buttons . add ( moveUp ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; moveDown = new JButton ( jEdit . getProperty ( "options.context.moveDown" ) ) ; moveDown . addActionListener ( actionHandler ) ; buttons . add ( moveDown ) ; buttons . add ( Box . createGlue ( ) ) ; updateButtons ( ) ; add ( BorderLayout . SOUTH , buttons ) ; EditAction [ ] actions = jEdit . getActions ( ) ; Vector vector = new Vector ( actions . length ) ; for ( int i = 0 ; i < actions . length ; i ++ ) { String actionName = actions [ i ] . getName ( ) ; String label = jEdit . getProperty ( actionName + ".label" ) ; if ( label == null ) continue ; vector . addElement ( new MenuItem ( actionName , label ) ) ; } MiscUtilities . quicksort ( vector , new MenuItemCompare ( ) ) ; actionsList = new DefaultListModel ( ) ; actionsList . ensureCapacity ( vector . size ( ) ) ; for ( int i = 0 ; i < vector . size ( ) ; i ++ ) { actionsList . addElement ( vector . elementAt ( i ) ) ; } } class MenuItemCompare implements MiscUtilities . Compare { public int compare ( Object obj1 , Object obj2 ) { return ( ( MenuItem ) obj1 ) . label . toLowerCase ( ) . compareTo ( ( ( MenuItem ) obj2 ) . label . toLowerCase ( ) ) ; } } protected void _save ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < listModel . getSize ( ) ; i ++ ) { if ( i != 0 ) buf . append ( ' ' ) ; buf . append ( ( ( MenuItem ) listModel . elementAt ( i ) ) . actionName ) ; } jEdit . setProperty ( "view.context" , buf . toString ( ) ) ; } static String getActionLabel ( String actionName ) { if ( actionName . equals ( "-" ) ) return "-" ; else { if ( actionName . startsWith ( "play-macro@" ) ) { int index = Math . max ( 11 , actionName . indexOf ( '/' ) + 1 ) ; return actionName . substring ( index ) . replace ( '_' , ' ' ) ; } else return jEdit . getProperty ( actionName + ".label" ) ; } } private DefaultListModel listModel ; private JList list ; private JButton add ; private JButton remove ; private JButton moveUp , moveDown ; private DefaultListModel actionsList ; private void updateButtons ( ) { int index = list . getSelectedIndex ( ) ; remove . setEnabled ( index != - 1 && listModel . getSize ( ) != 0 ) ; moveUp . setEnabled ( index > 0 ) ; moveDown . setEnabled ( index != - 1 && index != listModel . getSize ( ) - 1 ) ; } static class MenuItem { String actionName ; String label ; MenuItem ( String actionName , String label ) { this . actionName = actionName ; if ( label . equals ( "-" ) ) this . label = label ; else this . label = GUIUtilities . prettifyMenuLabel ( label ) ; } public String toString ( ) { return label ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == add ) { ContextAddDialog dialog = new ContextAddDialog ( ContextOptionPane . this , actionsList ) ; MenuItem selection = dialog . getSelection ( ) ; if ( selection == null ) return ; int index = list . getSelectedIndex ( ) ; if ( index == - 1 ) index = listModel . getSize ( ) ; else index ++ ; listModel . insertElementAt ( selection , index ) ; list . setSelectedIndex ( index ) ; } else if ( source == remove ) { int index = list . getSelectedIndex ( ) ; listModel . removeElementAt ( index ) ; updateButtons ( ) ; } else if ( source == moveUp ) { int index = list . getSelectedIndex ( ) ; Object selected = list . getSelectedValue ( ) ; listModel . removeElementAt ( index ) ; listModel . insertElementAt ( selected , index - 1 ) ; list . setSelectedIndex ( index - 1 ) ; } else if ( source == moveDown ) { int index = list . getSelectedIndex ( ) ; Object selected = list . getSelectedValue ( ) ; listModel . removeElementAt ( index ) ; listModel . insertElementAt ( selected , index + 1 ) ; list . setSelectedIndex ( index + 1 ) ; } } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { updateButtons ( ) ; } } } class ContextAddDialog extends EnhancedDialog { public ContextAddDialog ( Component comp , ListModel actionsListModel ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "options.context.add.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; content . add ( BorderLayout . NORTH , new JLabel ( jEdit . getProperty ( "options.context.add.caption" ) ) ) ; JPanel mainPanel = new JPanel ( new BorderLayout ( 6 , 0 ) ) ; ActionHandler actionHandler = new ActionHandler ( ) ; ButtonGroup grp = new ButtonGroup ( ) ; separator = new JRadioButton ( jEdit . getProperty ( "options.context" + ".add.separator" ) ) ; separator . setSelected ( true ) ; separator . addActionListener ( actionHandler ) ; grp . add ( separator ) ; mainPanel . add ( BorderLayout . NORTH , separator ) ; JPanel actionPanel = new JPanel ( new BorderLayout ( 6 , 0 ) ) ; action = new JRadioButton ( jEdit . getProperty ( "options.context" + ".add.action" ) ) ; action . addActionListener ( actionHandler ) ; grp . add ( action ) ; actionPanel . add ( BorderLayout . NORTH , action ) ; actionsList = new JList ( actionsListModel ) ; actionsList . setVisibleRowCount ( 8 ) ; actionsList . setEnabled ( false ) ; actionPanel . add ( BorderLayout . CENTER , new JScrollPane ( actionsList ) ) ; mainPanel . add ( BorderLayout . CENTER , actionPanel ) ; JPanel macroPanel = new JPanel ( new BorderLayout ( 6 , 0 ) ) ; macro = new JRadioButton ( jEdit . getProperty ( "options.context" + ".add.macro" ) ) ; macro . addActionListener ( actionHandler ) ; grp . add ( macro ) ; macroPanel . add ( BorderLayout . NORTH , macro ) ; macrosList = new JList ( Macros . getMacroList ( ) ) ; macrosList . setVisibleRowCount ( 8 ) ; macrosList . setEnabled ( false ) ; macroPanel . add ( BorderLayout . CENTER , new JScrollPane ( macrosList ) ) ; mainPanel . add ( BorderLayout . SOUTH , macroPanel ) ; content . add ( BorderLayout . CENTER , mainPanel ) ; JPanel southPanel = new JPanel ( ) ; southPanel . setLayout ( new BoxLayout ( southPanel , BoxLayout . X_AXIS ) ) ; southPanel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; southPanel . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( actionHandler ) ; getRootPane ( ) . setDefaultButton ( ok ) ; southPanel . add ( ok ) ; southPanel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( actionHandler ) ; southPanel . add ( cancel ) ; southPanel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , southPanel ) ; pack ( ) ; setLocationRelativeTo ( JOptionPane . getFrameForComponent ( comp ) ) ; show ( ) ; } public void ok ( ) { isOK = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public ContextOptionPane . MenuItem getSelection ( ) { if ( ! isOK ) return null ; if ( separator . isSelected ( ) ) return new ContextOptionPane . MenuItem ( "-" , "-" ) ; else if ( action . isSelected ( ) ) return ( ContextOptionPane . MenuItem ) actionsList . getSelectedValue ( ) ; else if ( macro . isSelected ( ) ) { String selectedMacro = macrosList . getSelectedValue ( ) . toString ( ) ; selectedMacro = "play-macro@" + selectedMacro ; return new ContextOptionPane . MenuItem ( selectedMacro , ContextOptionPane . getActionLabel ( selectedMacro ) ) ; } else throw new InternalError ( ) ; } private boolean isOK ; private JRadioButton separator , action , macro ; private JList actionsList , macrosList ; private JButton ok , cancel ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source instanceof JRadioButton ) { actionsList . setEnabled ( action . isSelected ( ) ) ; macrosList . setEnabled ( macro . isSelected ( ) ) ; } if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; } } } 	1	['13', '6', '0', '13', '65', '46', '7', '9', '1', '0.785714286', '438', '1', '0', '0.982195846', '0.333333333', '2', '4', '32.15384615', '9', '2.2308', '1']
package org . gjt . sp . jedit . io ; import java . awt . Component ; import java . io . * ; import java . net . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class UrlVFS extends VFS { public UrlVFS ( ) { super ( "url" ) ; } public int getCapabilities ( ) { return READ_CAP | WRITE_CAP ; } public String constructPath ( String parent , String path ) { if ( parent . endsWith ( "/" ) ) return parent + path ; else return parent + '/' + path ; } public String getParentOfPath ( String path ) { return MiscUtilities . getParentOfPath ( path ) ; } public InputStream _createInputStream ( Object session , String path , boolean ignoreErrors , Component comp ) throws IOException { try { return new URL ( path ) . openStream ( ) ; } catch ( MalformedURLException mu ) { Log . log ( Log . ERROR , this , mu ) ; String [ ] args = { path , mu . getMessage ( ) } ; VFSManager . error ( comp , "badurl" , args ) ; return null ; } } public OutputStream _createOutputStream ( Object session , String path , Component comp ) throws IOException { try { return new URL ( path ) . openConnection ( ) . getOutputStream ( ) ; } catch ( MalformedURLException mu ) { Log . log ( Log . ERROR , this , mu ) ; String [ ] args = { path } ; VFSManager . error ( comp , "badurl" , args ) ; return null ; } } } 	1	['6', '2', '0', '4', '19', '15', '1', '4', '6', '2', '93', '0', '0', '0.807692308', '0.5', '1', '3', '14.5', '2', '1', '1']
package org . gjt . sp . util ; public class WorkThread extends Thread { public WorkThread ( WorkThreadPool pool , ThreadGroup group , String name ) { super ( group , name ) ; setDaemon ( true ) ; setPriority ( 4 ) ; this . pool = pool ; } public void setAbortable ( boolean abortable ) { synchronized ( abortLock ) { this . abortable = abortable ; if ( aborted ) stop ( new Abort ( ) ) ; } } public boolean isRequestRunning ( ) { return requestRunning ; } public String getStatus ( ) { return status ; } public void setStatus ( String status ) { this . status = status ; pool . fireProgressChanged ( this ) ; } public int getProgressValue ( ) { return progressValue ; } public void setProgressValue ( int progressValue ) { this . progressValue = progressValue ; pool . fireProgressChanged ( this ) ; } public int getProgressMaximum ( ) { return progressMaximum ; } public void setProgressMaximum ( int progressMaximum ) { this . progressMaximum = progressMaximum ; pool . fireProgressChanged ( this ) ; } public void abortCurrentRequest ( ) { synchronized ( abortLock ) { if ( abortable && ! aborted ) stop ( new Abort ( ) ) ; aborted = true ; } } public void run ( ) { Log . log ( Log . DEBUG , this , "Work request thread starting [" + getName ( ) + "]" ) ; for ( ; ; ) { doRequests ( ) ; } } private WorkThreadPool pool ; private Object abortLock = new Object ( ) ; private boolean requestRunning ; private boolean abortable ; private boolean aborted ; private String status ; private int progressValue ; private int progressMaximum ; private void doRequests ( ) { WorkThreadPool . Request request ; for ( ; ; ) { request = pool . getNextRequest ( ) ; if ( request == null ) break ; else { requestRunning = true ; pool . fireProgressChanged ( this ) ; doRequest ( request ) ; requestRunning = false ; pool . fireProgressChanged ( this ) ; } } synchronized ( pool . waitForAllLock ) { pool . waitForAllLock . notifyAll ( ) ; } synchronized ( pool . lock ) { try { pool . lock . wait ( ) ; } catch ( InterruptedException ie ) { Log . log ( Log . ERROR , this , ie ) ; } } } private void doRequest ( WorkThreadPool . Request request ) { try { request . run . run ( ) ; } catch ( Abort a ) { Log . log ( Log . ERROR , WorkThread . class , "Unhandled abort" ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , WorkThread . class , "Exception " + "in work thread:" ) ; Log . log ( Log . ERROR , WorkThread . class , t ) ; } finally { synchronized ( abortLock ) { aborted = abortable = false ; } status = null ; progressValue = progressMaximum = 0 ; pool . requestDone ( ) ; pool . fireProgressChanged ( this ) ; } } public static class Abort extends Error { public Abort ( ) { super ( "Work request aborted" ) ; } } } 	1	['14', '2', '0', '8', '34', '37', '5', '4', '11', '0.760683761', '324', '1', '1', '0.824324324', '0.224489796', '0', '0', '21.5', '8', '1.7143', '1']
package org . gjt . sp . jedit . io ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . text . Segment ; import java . io . * ; import java . util . zip . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . * ; public class BufferIORequest extends WorkRequest { public static final int IOBUFSIZE = 32768 ; public static final int PROGRESS_INTERVAL = 300 ; public static final String LOAD_DATA = "IORequest__loadData" ; public static final int LOAD = 0 ; public static final int SAVE = 1 ; public static final int AUTOSAVE = 2 ; public static final int INSERT = 3 ; public BufferIORequest ( int type , View view , Buffer buffer , Object session , VFS vfs , String path ) { this . type = type ; this . view = view ; this . buffer = buffer ; this . session = session ; this . vfs = vfs ; this . path = path ; markersPath = vfs . getParentOfPath ( path ) + '.' + vfs . getFileName ( path ) + ".marks" ; } public void run ( ) { switch ( type ) { case LOAD : load ( ) ; break ; case SAVE : save ( ) ; break ; case AUTOSAVE : autosave ( ) ; break ; case INSERT : insert ( ) ; break ; } } public String toString ( ) { String typeString ; switch ( type ) { case LOAD : typeString = "LOAD" ; break ; case SAVE : typeString = "SAVE" ; break ; case AUTOSAVE : typeString = "AUTOSAVE" ; break ; default : typeString = "UNKNOWN!!!" ; } return getClass ( ) . getName ( ) + "[type=" + typeString + ",buffer=" + buffer + "]" ; } private int type ; private View view ; private Buffer buffer ; private Object session ; private VFS vfs ; private String path ; private String markersPath ; private void load ( ) { InputStream in = null ; try { try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.load" , args ) ) ; setAbortable ( true ) ; setProgressValue ( 0 ) ; VFS . DirectoryEntry entry = vfs . _getDirectoryEntry ( session , path , view ) ; long length ; if ( entry != null ) length = entry . length ; else length = 0L ; in = vfs . _createInputStream ( session , path , false , view ) ; if ( in == null ) return ; if ( path . endsWith ( ".gz" ) ) in = new GZIPInputStream ( in ) ; String lineSeparator = read ( buffer , in , length ) ; buffer . putProperty ( Buffer . LINESEP , lineSeparator ) ; buffer . setNewFile ( false ) ; } catch ( CharConversionException ch ) { Log . log ( Log . ERROR , this , ch ) ; Object [ ] pp = { path , buffer . getProperty ( Buffer . ENCODING ) , ch . toString ( ) } ; VFSManager . error ( view , "encoding-error" , pp ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; Object [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "read-error" , pp ) ; } if ( jEdit . getBooleanProperty ( "persistentMarkers" ) ) { try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.load-markers" , args ) ) ; setAbortable ( true ) ; in = vfs . _createInputStream ( session , markersPath , true , view ) ; if ( in != null ) readMarkers ( buffer , in ) ; } catch ( IOException io ) { } } } catch ( WorkThread . Abort a ) { if ( in != null ) { try { in . close ( ) ; } catch ( IOException io ) { } } } finally { try { vfs . _endVFSSession ( session , view ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "read-error" , pp ) ; } catch ( WorkThread . Abort a ) { } } } private String read ( Buffer buffer , InputStream _in , long length ) throws IOException { boolean trackProgress = ( length != 0 ) ; File file = buffer . getFile ( ) ; setProgressValue ( 0 ) ; setProgressMaximum ( ( int ) length ) ; if ( length == 0 ) length = IOBUFSIZE ; StringBuffer sbuf = new StringBuffer ( ( int ) length ) ; InputStreamReader in = new InputStreamReader ( _in , ( String ) buffer . getProperty ( Buffer . ENCODING ) ) ; char [ ] buf = new char [ IOBUFSIZE ] ; int len ; boolean CRLF = false ; boolean CROnly = false ; boolean lastWasCR = false ; int lineCount = 0 ; while ( ( len = in . read ( buf , 0 , buf . length ) ) != - 1 ) { int lastLine = 0 ; for ( int i = 0 ; i < len ; i ++ ) { switch ( buf [ i ] ) { case '\r' : if ( lastWasCR ) { CROnly = true ; CRLF = false ; } else { lastWasCR = true ; } sbuf . append ( buf , lastLine , i - lastLine ) ; sbuf . append ( '\n' ) ; if ( trackProgress && lineCount ++ % PROGRESS_INTERVAL == 0 ) setProgressValue ( sbuf . length ( ) ) ; lastLine = i + 1 ; break ; case '\n' : if ( lastWasCR ) { CROnly = false ; CRLF = true ; lastWasCR = false ; lastLine = i + 1 ; } else { CROnly = false ; CRLF = false ; sbuf . append ( buf , lastLine , i - lastLine ) ; sbuf . append ( '\n' ) ; if ( trackProgress && lineCount ++ % PROGRESS_INTERVAL == 0 ) setProgressValue ( sbuf . length ( ) ) ; lastLine = i + 1 ; } break ; default : if ( lastWasCR ) { CROnly = true ; CRLF = false ; lastWasCR = false ; } break ; } } if ( trackProgress ) setProgressValue ( sbuf . length ( ) ) ; sbuf . append ( buf , lastLine , len - lastLine ) ; } setAbortable ( false ) ; String returnValue ; if ( CRLF ) returnValue = "\r\n" ; else if ( CROnly ) returnValue = "\r" ; else returnValue = "\n" ; in . close ( ) ; int bufferLength = sbuf . length ( ) ; if ( bufferLength != 0 ) { char ch = sbuf . charAt ( bufferLength - 1 ) ; if ( length >= 2 && ch == 0x1a && sbuf . charAt ( bufferLength - 2 ) == '\n' ) sbuf . setLength ( bufferLength - 2 ) ; else if ( ch == '\n' ) sbuf . setLength ( bufferLength - 1 ) ; } buffer . putProperty ( LOAD_DATA , sbuf ) ; return returnValue ; } private void readMarkers ( Buffer buffer , InputStream _in ) throws IOException { buffer . removeAllMarkers ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( _in ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( ! line . startsWith ( "!" ) ) continue ; char shortcut = line . charAt ( 1 ) ; int start = line . indexOf ( ';' ) ; int end = line . indexOf ( ';' , start + 1 ) ; int position = Integer . parseInt ( line . substring ( start + 1 , end ) ) ; buffer . addMarker ( shortcut , position ) ; } in . close ( ) ; } private void save ( ) { OutputStream out = null ; try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.save" , args ) ) ; setAbortable ( true ) ; try { buffer . readLock ( ) ; String savePath ; if ( ( vfs . getCapabilities ( ) & VFS . RENAME_CAP ) != 0 ) { savePath = vfs . getParentOfPath ( path ) + '#' + vfs . getFileName ( path ) + "#save#" ; } else savePath = path ; out = vfs . _createOutputStream ( session , savePath , view ) ; if ( out != null ) { if ( path . endsWith ( ".gz" ) ) out = new GZIPOutputStream ( out ) ; write ( buffer , out ) ; } if ( buffer . getProperty ( Buffer . BACKED_UP ) == null ) { vfs . _backup ( session , path , view ) ; buffer . putProperty ( Buffer . BACKED_UP , Boolean . TRUE ) ; } if ( ( vfs . getCapabilities ( ) & VFS . RENAME_CAP ) != 0 ) vfs . _rename ( session , savePath , path , view ) ; if ( ( vfs . getCapabilities ( ) & VFS . DELETE_CAP ) != 0 ) { if ( jEdit . getBooleanProperty ( "persistentMarkers" ) && buffer . getMarkers ( ) . size ( ) != 0 ) { setStatus ( jEdit . getProperty ( "vfs.status.save-markers" , args ) ) ; setProgressValue ( 0 ) ; out = vfs . _createOutputStream ( session , markersPath , view ) ; if ( out != null ) writeMarkers ( buffer , out ) ; } else vfs . _delete ( session , markersPath , view ) ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "write-error" , pp ) ; } finally { buffer . readUnlock ( ) ; } } catch ( WorkThread . Abort a ) { if ( out != null ) { try { out . close ( ) ; } catch ( IOException io ) { } } } finally { try { vfs . _saveComplete ( session , buffer , view ) ; vfs . _endVFSSession ( session , view ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "write-error" , pp ) ; } catch ( WorkThread . Abort a ) { } } } private void autosave ( ) { OutputStream out = null ; try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.autosave" , args ) ) ; setAbortable ( true ) ; try { buffer . readLock ( ) ; if ( ! buffer . isDirty ( ) ) { return ; } out = vfs . _createOutputStream ( session , path , view ) ; if ( out == null ) return ; write ( buffer , out ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } catch ( IOException io ) { } finally { buffer . readUnlock ( ) ; } } catch ( WorkThread . Abort a ) { if ( out != null ) { try { out . close ( ) ; } catch ( IOException io ) { } } } } private void write ( Buffer buffer , OutputStream _out ) throws IOException , BadLocationException { BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( _out , ( String ) buffer . getProperty ( Buffer . ENCODING ) ) , IOBUFSIZE ) ; Segment lineSegment = new Segment ( ) ; String newline = ( String ) buffer . getProperty ( Buffer . LINESEP ) ; if ( newline == null ) newline = System . getProperty ( "line.separator" ) ; Element map = buffer . getDefaultRootElement ( ) ; setProgressMaximum ( map . getElementCount ( ) / PROGRESS_INTERVAL ) ; setProgressValue ( 0 ) ; int i = 0 ; while ( i < map . getElementCount ( ) ) { Element line = map . getElement ( i ) ; int start = line . getStartOffset ( ) ; buffer . getText ( start , line . getEndOffset ( ) - start - 1 , lineSegment ) ; out . write ( lineSegment . array , lineSegment . offset , lineSegment . count ) ; out . write ( newline ) ; if ( ++ i % PROGRESS_INTERVAL == 0 ) setProgressValue ( i / PROGRESS_INTERVAL ) ; } out . close ( ) ; } private void writeMarkers ( Buffer buffer , OutputStream out ) throws IOException { Writer o = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; Vector markers = buffer . getMarkers ( ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; o . write ( '!' ) ; o . write ( marker . getShortcut ( ) ) ; o . write ( ';' ) ; String pos = String . valueOf ( marker . getPosition ( ) ) ; o . write ( pos ) ; o . write ( ';' ) ; o . write ( pos ) ; o . write ( '\n' ) ; } o . close ( ) ; } private void insert ( ) { InputStream in = null ; try { try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.load" , args ) ) ; setAbortable ( true ) ; VFS . DirectoryEntry entry = vfs . _getDirectoryEntry ( session , path , view ) ; long length ; if ( entry != null ) length = entry . length ; else length = 0L ; in = vfs . _createInputStream ( session , path , false , view ) ; if ( in == null ) return ; if ( path . endsWith ( ".gz" ) ) in = new GZIPInputStream ( in ) ; read ( buffer , in , length ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "read-error" , pp ) ; } } catch ( WorkThread . Abort a ) { if ( in != null ) { try { in . close ( ) ; } catch ( IOException io ) { } } } finally { try { vfs . _endVFSSession ( session , view ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "read-error" , pp ) ; } catch ( WorkThread . Abort a ) { } } } } 	1	['11', '2', '0', '10', '96', '21', '2', '10', '3', '0.828571429', '1272', '0.5', '3', '0.333333333', '0.236363636', '0', '0', '113.3636364', '17', '4.9091', '9']
package org . gjt . sp . jedit . textarea ; import javax . swing . text . * ; import org . gjt . sp . jedit . Buffer ; public abstract class Selection { public int getStart ( ) { return start ; } public int getEnd ( ) { return end ; } public int getStartLine ( ) { return startLine ; } public int getEndLine ( ) { return endLine ; } public abstract int getStart ( Buffer buffer , int line ) ; public abstract int getEnd ( Buffer buffer , int line ) ; public String toString ( ) { return getClass ( ) . getName ( ) + "[start=" + start + ",end=" + end + ",startLine=" + startLine + ",endLine=" + endLine + "]" ; } int start , end , startLine , endLine ; protected Selection ( ) { } protected Selection ( Selection copy ) { start = copy . start ; end = copy . end ; } protected Selection ( int start , int end ) { this . start = start ; this . end = end ; } public static class Range extends Selection { public Range ( ) { super ( ) ; } public Range ( Selection sel ) { super ( sel ) ; } public Range ( int start , int end ) { super ( start , end ) ; } public int getStart ( Buffer buffer , int line ) { if ( line == startLine ) return start ; else { Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( line ) ; return lineElement . getStartOffset ( ) ; } } public int getEnd ( Buffer buffer , int line ) { if ( line == endLine ) return end ; else { Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( line ) ; return lineElement . getEndOffset ( ) - 1 ; } } } public static class Rect extends Selection { public Rect ( ) { super ( ) ; } public Rect ( Selection sel ) { super ( sel ) ; } public Rect ( int start , int end ) { super ( start , end ) ; } public int getStart ( Buffer buffer , int line ) { if ( line == startLine ) return start ; else { Element map = buffer . getDefaultRootElement ( ) ; int _start = start - map . getElement ( startLine ) . getStartOffset ( ) ; int _end = end - map . getElement ( endLine ) . getStartOffset ( ) ; Element lineElement = map . getElement ( line ) ; return Math . min ( lineElement . getEndOffset ( ) - 1 , lineElement . getStartOffset ( ) + Math . min ( _start , _end ) ) ; } } public int getEnd ( Buffer buffer , int line ) { if ( line == endLine ) return end ; else { Element map = buffer . getDefaultRootElement ( ) ; int _start = start - map . getElement ( startLine ) . getStartOffset ( ) ; int _end = end - map . getElement ( endLine ) . getStartOffset ( ) ; Element lineElement = map . getElement ( line ) ; return Math . min ( lineElement . getEndOffset ( ) - 1 , lineElement . getStartOffset ( ) + Math . max ( _start , _end ) ) ; } } } } 	1	['10', '1', '2', '15', '17', '23', '14', '1', '7', '0.777777778', '80', '0', '0', '0', '0.4', '0', '0', '6.6', '1', '0.7', '1']
package org . gjt . sp . jedit . syntax ; public class Token { public static final byte NULL = 0 ; public static final byte COMMENT1 = 1 ; public static final byte COMMENT2 = 2 ; public static final byte LITERAL1 = 3 ; public static final byte LITERAL2 = 4 ; public static final byte LABEL = 5 ; public static final byte KEYWORD1 = 6 ; public static final byte KEYWORD2 = 7 ; public static final byte KEYWORD3 = 8 ; public static final byte FUNCTION = 9 ; public static final byte MARKUP = 10 ; public static final byte OPERATOR = 11 ; public static final byte DIGIT = 12 ; public static final byte INVALID = 13 ; public static final byte ID_COUNT = 14 ; public static final byte END = 127 ; public int length ; public byte id ; public Token prev ; public Token next ; public Token ( int length , byte id ) { this . length = length ; this . id = id ; } public String toString ( ) { return "[id=" + id + ",length=" + length + "]" ; } } 	1	['2', '1', '0', '4', '7', '0', '4', '0', '2', '1.8', '48', '0', '2', '0', '0.666666667', '0', '0', '13', '1', '0.5', '1']
package org . gjt . sp . jedit . textarea ; import javax . swing . text . * ; import javax . swing . JComponent ; import java . awt . event . MouseEvent ; import java . awt . * ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . Buffer ; import org . gjt . sp . jedit . TextUtilities ; import org . gjt . sp . util . Log ; public class TextAreaPainter extends JComponent implements TabExpander { public TextAreaPainter ( JEditTextArea textArea ) { enableEvents ( AWTEvent . FOCUS_EVENT_MASK | AWTEvent . KEY_EVENT_MASK | AWTEvent . MOUSE_EVENT_MASK ) ; this . textArea = textArea ; setAutoscrolls ( true ) ; setDoubleBuffered ( true ) ; setOpaque ( true ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . TEXT_CURSOR ) ) ; } public boolean isManagingFocus ( ) { return false ; } public boolean getFocusTraversalKeysEnabled ( ) { return false ; } public final SyntaxStyle [ ] getStyles ( ) { return styles ; } public final void setStyles ( SyntaxStyle [ ] styles ) { this . styles = styles ; repaint ( ) ; } public final Color getCaretColor ( ) { return caretColor ; } public final void setCaretColor ( Color caretColor ) { this . caretColor = caretColor ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getCaretLine ( ) ) ; } public final Color getSelectionColor ( ) { return selectionColor ; } public final void setSelectionColor ( Color selectionColor ) { this . selectionColor = selectionColor ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateSelectedLines ( ) ; } public final Color getLineHighlightColor ( ) { return lineHighlightColor ; } public final void setLineHighlightColor ( Color lineHighlightColor ) { this . lineHighlightColor = lineHighlightColor ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getCaretLine ( ) ) ; } public final boolean isLineHighlightEnabled ( ) { return lineHighlight ; } public final void setLineHighlightEnabled ( boolean lineHighlight ) { this . lineHighlight = lineHighlight ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateSelectedLines ( ) ; } public final Color getBracketHighlightColor ( ) { return bracketHighlightColor ; } public final void setBracketHighlightColor ( Color bracketHighlightColor ) { this . bracketHighlightColor = bracketHighlightColor ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getBracketLine ( ) ) ; } public final boolean isBracketHighlightEnabled ( ) { return bracketHighlight ; } public final void setBracketHighlightEnabled ( boolean bracketHighlight ) { this . bracketHighlight = bracketHighlight ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getBracketLine ( ) ) ; } public final boolean isBlockCaretEnabled ( ) { return blockCaret ; } public final void setBlockCaretEnabled ( boolean blockCaret ) { this . blockCaret = blockCaret ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getCaretLine ( ) ) ; } public final Color getEOLMarkerColor ( ) { return eolMarkerColor ; } public final void setEOLMarkerColor ( Color eolMarkerColor ) { this . eolMarkerColor = eolMarkerColor ; repaint ( ) ; } public final boolean getEOLMarkersPainted ( ) { return eolMarkers ; } public final void setEOLMarkersPainted ( boolean eolMarkers ) { this . eolMarkers = eolMarkers ; repaint ( ) ; } public final Color getWrapGuideColor ( ) { return wrapGuideColor ; } public final void setWrapGuideColor ( Color wrapGuideColor ) { this . wrapGuideColor = wrapGuideColor ; repaint ( ) ; } public final boolean getWrapGuidePainted ( ) { return wrapGuide ; } public final void setWrapGuidePainted ( boolean wrapGuide ) { this . wrapGuide = wrapGuide ; repaint ( ) ; } public void setAntiAliasEnabled ( boolean antiAlias ) { this . antiAlias = antiAlias ; textArea . getTextRenderer ( ) . configure ( antiAlias , fracFontMetrics ) ; } public boolean isAntiAliasEnabled ( ) { return antiAlias ; } public void setFractionalFontMetricsEnabled ( boolean fracFontMetrics ) { this . fracFontMetrics = fracFontMetrics ; textArea . getTextRenderer ( ) . configure ( antiAlias , fracFontMetrics ) ; } public boolean isFractionalFontMetricsEnabled ( ) { return fracFontMetrics ; } public void addCustomHighlight ( TextAreaHighlight highlight ) { highlight . init ( textArea , highlights ) ; highlights = highlight ; } public String getToolTipText ( MouseEvent evt ) { if ( maxLineLen != 0 ) { int wrapGuidePos = maxLineLen + textArea . getHorizontalOffset ( ) ; if ( Math . abs ( evt . getX ( ) - wrapGuidePos ) < 5 ) { return String . valueOf ( textArea . getBuffer ( ) . getProperty ( "maxLineLen" ) ) ; } } if ( highlights != null ) return highlights . getToolTipText ( evt ) ; else return null ; } public FontMetrics getFontMetrics ( ) { return fm ; } public void setFont ( Font font ) { super . setFont ( font ) ; fm = getFontMetrics ( font ) ; textArea . recalculateVisibleLines ( ) ; updateTabSize ( ) ; } public void paintComponent ( Graphics gfx ) { updateTabSize ( ) ; textArea . getTextRenderer ( ) . setupGraphics ( gfx ) ; Buffer buffer = textArea . getBuffer ( ) ; Rectangle clipRect = gfx . getClipBounds ( ) ; gfx . setColor ( getBackground ( ) ) ; gfx . fillRect ( clipRect . x , clipRect . y , clipRect . width , clipRect . height ) ; int x = textArea . getHorizontalOffset ( ) ; int height = fm . getHeight ( ) ; int firstLine = textArea . getFirstLine ( ) ; int firstInvalid = firstLine + clipRect . y / height ; int lastInvalid = firstLine + ( clipRect . y + clipRect . height - 1 ) / height ; int lineCount = textArea . getVirtualLineCount ( ) ; int y = ( clipRect . y - clipRect . y % height ) ; try { int maxWidth = textArea . maxHorizontalScrollWidth ; boolean updateMaxHorizontalScrollWidth = false ; for ( int line = firstInvalid ; line <= lastInvalid ; line ++ ) { boolean valid = buffer . isLoaded ( ) && line >= 0 && line < lineCount ; int physicalLine ; if ( valid ) physicalLine = buffer . virtualToPhysical ( line ) ; else { int virtualLineCount = buffer . getVirtualLineCount ( ) ; physicalLine = buffer . virtualToPhysical ( virtualLineCount - 1 ) + ( line - virtualLineCount ) ; } int width = paintLine ( gfx , buffer , valid , line , physicalLine , x , y ) - x + 5 ; if ( valid ) { buffer . setLineWidth ( physicalLine , width ) ; if ( width > maxWidth ) updateMaxHorizontalScrollWidth = true ; } y += height ; } if ( buffer . isNextLineRequested ( ) ) { int h = clipRect . y + clipRect . height ; repaint ( 0 , h , getWidth ( ) , getHeight ( ) - h ) ; } if ( updateMaxHorizontalScrollWidth ) textArea . updateMaxHorizontalScrollWidth ( ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error repainting line" + " range {" + firstInvalid + "," + lastInvalid + "}:" ) ; Log . log ( Log . ERROR , this , e ) ; } } public float nextTabStop ( float x , int tabOffset ) { int offset = textArea . getHorizontalOffset ( ) ; int ntabs = ( ( int ) x - offset ) / tabSize ; return ( ntabs + 1 ) * tabSize + offset ; } public Dimension getPreferredSize ( ) { Dimension dim = new Dimension ( ) ; dim . width = fm . charWidth ( 'w' ) * 80 ; dim . height = fm . getHeight ( ) * 25 ; return dim ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } void updateTabSize ( ) { if ( textArea . getBuffer ( ) == null ) return ; tabSize = fm . charWidth ( ' ' ) * ( ( Integer ) textArea . getBuffer ( ) . getProperty ( PlainDocument . tabSizeAttribute ) ) . intValue ( ) ; int _maxLineLen = ( ( Integer ) textArea . getBuffer ( ) . getProperty ( "maxLineLen" ) ) . intValue ( ) ; if ( _maxLineLen <= 0 ) maxLineLen = 0 ; else maxLineLen = fm . charWidth ( ' ' ) * _maxLineLen ; } private JEditTextArea textArea ; private SyntaxStyle [ ] styles ; private Color caretColor ; private Color selectionColor ; private Color lineHighlightColor ; private Color bracketHighlightColor ; private Color eolMarkerColor ; private Color wrapGuideColor ; private boolean blockCaret ; private boolean lineHighlight ; private boolean bracketHighlight ; private boolean eolMarkers ; private boolean wrapGuide ; private boolean antiAlias ; private boolean fracFontMetrics ; private int tabSize ; private int maxLineLen ; private FontMetrics fm ; private TextAreaHighlight highlights ; private int paintLine ( Graphics gfx , Buffer buffer , boolean valid , int virtualLine , int physicalLine , int x , int y ) { paintHighlight ( gfx , virtualLine , physicalLine , y , valid ) ; if ( maxLineLen != 0 && wrapGuide ) { gfx . setColor ( wrapGuideColor ) ; gfx . drawLine ( x + maxLineLen , y , x + maxLineLen , y + fm . getHeight ( ) ) ; } if ( valid ) { Font defaultFont = getFont ( ) ; Color defaultColor = getForeground ( ) ; gfx . setFont ( defaultFont ) ; gfx . setColor ( defaultColor ) ; int baseLine = y + fm . getHeight ( ) - fm . getLeading ( ) - fm . getDescent ( ) ; x = buffer . paintSyntaxLine ( physicalLine , gfx , x , baseLine , this , true , true , defaultFont , defaultColor , ( lineHighlight && textArea . getSelectionCount ( ) == 0 && physicalLine == textArea . getCaretLine ( ) ? lineHighlightColor : getBackground ( ) ) , styles , textArea . getTextRenderer ( ) ) ; if ( eolMarkers ) { gfx . setFont ( defaultFont ) ; gfx . setColor ( eolMarkerColor ) ; gfx . drawString ( "." , x , baseLine ) ; } if ( physicalLine == textArea . getCaretLine ( ) && textArea . isCaretVisible ( ) ) paintCaret ( gfx , physicalLine , y ) ; if ( buffer . isFoldStart ( physicalLine ) && ! buffer . isLineVisible ( physicalLine + 1 ) ) { gfx . setColor ( defaultColor ) ; int start = textArea . getHorizontalOffset ( ) + fm . charWidth ( ' ' ) * buffer . getFoldLevel ( physicalLine ) ; gfx . drawLine ( start , y + fm . getHeight ( ) - 1 , x - 1 , y + fm . getHeight ( ) - 1 ) ; } } return x ; } private void paintHighlight ( Graphics gfx , int virtualLine , int physicalLine , int y , boolean valid ) { if ( valid ) { if ( textArea . selection . size ( ) == 0 ) { if ( lineHighlight && physicalLine == textArea . getCaretLine ( ) ) { gfx . setColor ( lineHighlightColor ) ; gfx . fillRect ( 0 , y , getWidth ( ) , fm . getHeight ( ) ) ; } } else { gfx . setColor ( selectionColor ) ; for ( int i = textArea . selection . size ( ) - 1 ; i >= 0 ; i -- ) { paintSelection ( gfx , physicalLine , y , ( Selection ) textArea . selection . elementAt ( i ) ) ; } } if ( bracketHighlight && physicalLine == textArea . getBracketLine ( ) && textArea . isHighlightVisible ( ) ) paintBracketHighlight ( gfx , physicalLine , y ) ; } if ( highlights != null ) { highlights . paintHighlight ( gfx , virtualLine , y - fm . getLeading ( ) - fm . getDescent ( ) ) ; } } private void paintBracketHighlight ( Graphics gfx , int physicalLine , int y ) { int position = textArea . getBracketPosition ( ) ; if ( position == - 1 ) return ; int x = textArea . offsetToX ( physicalLine , position ) ; gfx . setColor ( bracketHighlightColor ) ; gfx . drawRect ( x , y , fm . charWidth ( '(' ) - 1 , fm . getHeight ( ) - 1 ) ; } private void paintCaret ( Graphics gfx , int physicalLine , int y ) { int offset = textArea . getCaretPosition ( ) - textArea . getLineStartOffset ( physicalLine ) ; int caretX = textArea . offsetToX ( physicalLine , offset ) ; int height = fm . getHeight ( ) ; gfx . setColor ( caretColor ) ; if ( textArea . isOverwriteEnabled ( ) ) { gfx . drawLine ( caretX , y + height - 1 , caretX + fm . charWidth ( 'w' ) , y + height - 1 ) ; } else if ( blockCaret ) { if ( textArea . selection == null && lineHighlight ) gfx . setXORMode ( lineHighlightColor ) ; else gfx . setXORMode ( getBackground ( ) ) ; gfx . fillRect ( caretX , y , fm . charWidth ( 'w' ) , height ) ; gfx . setPaintMode ( ) ; } else { gfx . drawLine ( caretX , y , caretX , y + height - 1 ) ; } } private void paintSelection ( Graphics gfx , int physicalLine , int y , Selection s ) { if ( physicalLine < s . startLine || physicalLine > s . endLine ) return ; int lineStart = textArea . getLineStartOffset ( physicalLine ) ; int x1 , x2 ; if ( s instanceof Selection . Rect ) { int lineLen = textArea . getLineLength ( physicalLine ) ; x1 = textArea . offsetToX ( physicalLine , Math . min ( lineLen , s . start - textArea . getLineStartOffset ( s . startLine ) ) ) ; x2 = textArea . offsetToX ( physicalLine , Math . min ( lineLen , s . end - textArea . getLineStartOffset ( s . endLine ) ) ) ; if ( x1 > x2 ) { int tmp = x2 ; x2 = x1 ; x1 = tmp ; } } else if ( s . startLine == s . endLine ) { x1 = textArea . offsetToX ( physicalLine , s . start - lineStart ) ; x2 = textArea . offsetToX ( physicalLine , s . end - lineStart ) ; } else if ( physicalLine == s . startLine ) { x1 = textArea . offsetToX ( physicalLine , s . start - lineStart ) ; x2 = getWidth ( ) ; } else if ( physicalLine == s . endLine ) { x1 = 0 ; x2 = textArea . offsetToX ( physicalLine , s . end - lineStart ) ; } else { x1 = 0 ; x2 = getWidth ( ) ; } if ( x1 == x2 ) x2 ++ ; gfx . fillRect ( x1 , y , x2 - x1 , fm . getHeight ( ) ) ; } } 	1	['45', '4', '0', '15', '122', '462', '8', '8', '39', '0.899521531', '1143', '1', '3', '0.936231884', '0.136752137', '3', '18', '23.97777778', '12', '2.0889', '16']
package org . gjt . sp . jedit ; import javax . swing . text . BadLocationException ; import javax . swing . text . Position ; import org . gjt . sp . util . Log ; public class Marker { public char getShortcut ( ) { return shortcut ; } public void setShortcut ( char shortcut ) { this . shortcut = shortcut ; } public int getPosition ( ) { return ( position == null ? pos : position . getOffset ( ) ) ; } Marker ( Buffer buffer , char shortcut , int position ) { this . buffer = buffer ; this . shortcut = shortcut ; this . pos = position ; } void createPosition ( ) { try { position = buffer . createPosition ( pos ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } void removePosition ( ) { position = null ; } private Buffer buffer ; private char shortcut ; private int pos ; private Position position ; } 	1	['6', '1', '0', '8', '10', '0', '7', '2', '3', '0.65', '57', '1', '1', '0', '0.416666667', '0', '0', '7.833333333', '2', '1', '2']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class PluginManagerProgress extends JDialog { public PluginManagerProgress ( JDialog dialog , String caption , Roster roster ) { super ( JOptionPane . getFrameForComponent ( dialog ) , caption , true ) ; this . roster = roster ; JPanel content = new JPanel ( new BorderLayout ( 12 , 12 ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; globalProgress = new JProgressBar ( ) ; globalProgress . setStringPainted ( true ) ; globalProgress . setString ( caption ) ; count = roster . getOperationCount ( ) ; globalProgress . setMaximum ( count ) ; content . add ( BorderLayout . NORTH , globalProgress ) ; localProgress = new JProgressBar ( ) ; localProgress . setStringPainted ( true ) ; content . add ( BorderLayout . CENTER , localProgress ) ; stop = new JButton ( jEdit . getProperty ( "plugin-manager.progress.stop" ) ) ; stop . addActionListener ( new ActionHandler ( ) ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( stop ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , panel ) ; addWindowListener ( new WindowHandler ( ) ) ; pack ( ) ; Dimension screen = getToolkit ( ) . getScreenSize ( ) ; Dimension size = getSize ( ) ; size . width = Math . max ( size . width , 500 ) ; setSize ( size ) ; setLocationRelativeTo ( dialog ) ; show ( ) ; } public void removing ( String plugin ) { String [ ] args = { plugin } ; showMessage ( jEdit . getProperty ( "plugin-manager.progress.removing" , args ) ) ; stop . setEnabled ( true ) ; } public void downloading ( String plugin ) { String [ ] args = { plugin } ; showMessage ( jEdit . getProperty ( "plugin-manager.progress.downloading" , args ) ) ; stop . setEnabled ( true ) ; } public void installing ( String plugin ) { String [ ] args = { plugin } ; showMessage ( jEdit . getProperty ( "plugin-manager.progress.installing" , args ) ) ; stop . setEnabled ( false ) ; } public void setMaximum ( final int total ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { localProgress . setMaximum ( total ) ; } } ) ; } public void setValue ( final int value ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { localProgress . setValue ( value ) ; } } ) ; } public void done ( final boolean ok ) { this . ok |= ok ; try { if ( ! ok || done == count ) { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { dispose ( ) ; if ( ok ) { GUIUtilities . message ( PluginManagerProgress . this , "plugin-manager.done" , null ) ; } else { } } } ) ; } else { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { globalProgress . setValue ( done ++ ) ; localProgress . setValue ( 0 ) ; } } ) ; } } catch ( Exception e ) { } } public boolean isOK ( ) { return ok ; } private Thread thread ; private JProgressBar globalProgress , localProgress ; private JButton stop ; private int count ; private int done = 1 ; private boolean ok ; private Roster roster ; private void showMessage ( final String msg ) { try { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { localProgress . setString ( msg ) ; } } ) ; } catch ( Exception e ) { } Thread . yield ( ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == stop ) { thread . interrupt ( ) ; dispose ( ) ; } } } class WindowHandler extends WindowAdapter { boolean done ; public void windowActivated ( WindowEvent evt ) { if ( done ) return ; done = true ; thread = new RosterThread ( ) ; thread . start ( ) ; } public void windowClosing ( WindowEvent evt ) { thread . interrupt ( ) ; dispose ( ) ; } } class RosterThread extends Thread { RosterThread ( ) { super ( "Plugin manager thread" ) ; } public void run ( ) { roster . performOperations ( PluginManagerProgress . this ) ; } } } 	1	['17', '6', '0', '14', '59', '94', '13', '9', '8', '0.8984375', '334', '1', '1', '0.976011994', '0.213235294', '3', '6', '18.17647059', '5', '1.3529', '1']
package org . gjt . sp . jedit . io ; import java . util . Enumeration ; import java . util . Hashtable ; import javax . swing . SwingUtilities ; import java . awt . Component ; import java . util . Vector ; import org . gjt . sp . jedit . msg . VFSUpdate ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; import org . gjt . sp . util . WorkThreadPool ; public class VFSManager { public static void start ( ) { ioThreadPool . start ( ) ; } public static WorkThreadPool getIOThreadPool ( ) { return ioThreadPool ; } public static VFS getFileVFS ( ) { return fileVFS ; } public static VFS getUrlVFS ( ) { return urlVFS ; } public static VFS getVFSByName ( String name ) { return ( VFS ) vfsHash . get ( name ) ; } public static VFS getVFSForProtocol ( String protocol ) { if ( protocol . equals ( "file" ) ) return fileVFS ; else { VFS vfs = ( VFS ) protocolHash . get ( protocol ) ; if ( vfs != null ) return vfs ; else return urlVFS ; } } public static VFS getVFSForPath ( String path ) { if ( MiscUtilities . isURL ( path ) ) return getVFSForProtocol ( MiscUtilities . getProtocolOfURL ( path ) ) ; else return fileVFS ; } public static void registerVFS ( String protocol , VFS vfs ) { Log . log ( Log . DEBUG , VFSManager . class , "Registered " + vfs . getName ( ) + " filesystem for " + protocol + " protocol" ) ; vfsHash . put ( vfs . getName ( ) , vfs ) ; protocolHash . put ( protocol , vfs ) ; } public static Enumeration getFilesystems ( ) { return vfsHash . elements ( ) ; } public static void waitForRequests ( ) { ioThreadPool . waitForRequests ( ) ; } public static boolean errorOccurred ( ) { return error ; } public static int getRequestCount ( ) { return ioThreadPool . getRequestCount ( ) ; } public static void runInAWTThread ( Runnable run ) { ioThreadPool . addWorkRequest ( run , true ) ; } public static void runInWorkThread ( Runnable run ) { ioThreadPool . addWorkRequest ( run , false ) ; } public static void error ( final Component comp , final String error , final Object [ ] args ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { GUIUtilities . error ( comp , error , args ) ; return ; } VFSManager . error = true ; runInAWTThread ( new Runnable ( ) { public void run ( ) { VFSManager . error = false ; if ( comp == null || ! comp . isShowing ( ) ) GUIUtilities . error ( null , error , args ) ; else GUIUtilities . error ( comp , error , args ) ; } } ) ; } public static void sendVFSUpdate ( VFS vfs , String path , boolean parent ) { if ( parent ) { sendVFSUpdate ( vfs , vfs . getParentOfPath ( path ) , false ) ; sendVFSUpdate ( vfs , path , false ) ; } else { if ( path . length ( ) != 1 && ( path . endsWith ( "/" ) || path . endsWith ( java . io . File . separator ) ) ) path = path . substring ( 0 , path . length ( ) - 1 ) ; synchronized ( vfsUpdateLock ) { for ( int i = 0 ; i < vfsUpdates . size ( ) ; i ++ ) { VFSUpdate msg = ( VFSUpdate ) vfsUpdates . elementAt ( i ) ; if ( msg . getPath ( ) . equals ( path ) ) { return ; } } vfsUpdates . addElement ( new VFSUpdate ( path ) ) ; if ( vfsUpdates . size ( ) == 1 ) { VFSManager . runInAWTThread ( new SendVFSUpdatesSafely ( ) ) ; } } } } static class SendVFSUpdatesSafely implements Runnable { public void run ( ) { synchronized ( vfsUpdateLock ) { for ( int i = 0 ; i < vfsUpdates . size ( ) ; i ++ ) { EditBus . send ( ( VFSUpdate ) vfsUpdates . elementAt ( i ) ) ; } vfsUpdates . removeAllElements ( ) ; } } } private static WorkThreadPool ioThreadPool ; private static VFS fileVFS ; private static VFS urlVFS ; private static Hashtable vfsHash ; private static Hashtable protocolHash ; private static boolean error ; private static Object vfsUpdateLock ; private static Vector vfsUpdates ; static { int count ; try { count = Integer . parseInt ( jEdit . getProperty ( "ioThreadCount" ) ) ; } catch ( NumberFormatException nf ) { count = 4 ; } ioThreadPool = new WorkThreadPool ( "jEdit I/O" , count ) ; fileVFS = new FileVFS ( ) ; urlVFS = new UrlVFS ( ) ; vfsHash = new Hashtable ( ) ; protocolHash = new Hashtable ( ) ; vfsUpdateLock = new Object ( ) ; vfsUpdates = new Vector ( ) ; registerVFS ( FavoritesVFS . PROTOCOL , new FavoritesVFS ( ) ) ; registerVFS ( FileRootsVFS . PROTOCOL , new FileRootsVFS ( ) ) ; } private VFSManager ( ) { } } 	1	['23', '1', '0', '39', '64', '159', '33', '13', '16', '0.858585859', '300', '1', '3', '0', '0.103896104', '0', '0', '11.65217391', '9', '1.4783', '2']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; class InstallPluginsDialog extends EnhancedDialog { static final int INSTALL = 0 ; static final int UPDATE = 1 ; InstallPluginsDialog ( JDialog dialog , Vector model , int mode ) { super ( JOptionPane . getFrameForComponent ( dialog ) , ( mode == INSTALL ? jEdit . getProperty ( "install-plugins.title" ) : jEdit . getProperty ( "update-plugins.title" ) ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "install-plugins.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , label ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; plugins = new JCheckBoxList ( model ) ; plugins . getSelectionModel ( ) . addListSelectionListener ( new ListHandler ( ) ) ; JScrollPane scroller = new JScrollPane ( plugins ) ; Dimension dim = scroller . getPreferredSize ( ) ; dim . height = 120 ; scroller . setPreferredSize ( dim ) ; panel . add ( BorderLayout . CENTER , scroller ) ; JPanel panel2 = new JPanel ( new BorderLayout ( ) ) ; panel2 . setBorder ( new EmptyBorder ( 6 , 0 , 0 , 0 ) ) ; JPanel labelBox = new JPanel ( new GridLayout ( ( mode == UPDATE ? 6 : 5 ) , 1 , 0 , 3 ) ) ; labelBox . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 12 ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.name" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.author" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.latest-version" ) , SwingConstants . RIGHT ) ) ; if ( mode == UPDATE ) { labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.installed-version" ) , SwingConstants . RIGHT ) ) ; } labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.updated" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.description" ) , SwingConstants . RIGHT ) ) ; panel2 . add ( BorderLayout . WEST , labelBox ) ; JPanel valueBox = new JPanel ( new GridLayout ( ( mode == UPDATE ? 6 : 5 ) , 1 , 0 , 3 ) ) ; valueBox . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 0 ) ) ; valueBox . add ( name = new JLabel ( ) ) ; valueBox . add ( author = new JLabel ( ) ) ; valueBox . add ( latestVersion = new JLabel ( ) ) ; if ( mode == UPDATE ) { valueBox . add ( installedVersion = new JLabel ( ) ) ; } valueBox . add ( updated = new JLabel ( ) ) ; valueBox . add ( Box . createGlue ( ) ) ; panel2 . add ( BorderLayout . CENTER , valueBox ) ; JPanel panel3 = new JPanel ( new BorderLayout ( 0 , 3 ) ) ; description = new JTextArea ( 6 , 30 ) ; description . setEditable ( false ) ; description . setLineWrap ( true ) ; description . setWrapStyleWord ( true ) ; panel3 . add ( BorderLayout . NORTH , new JScrollPane ( description ) ) ; if ( mode == INSTALL ) { JPanel panel4 = new JPanel ( new BorderLayout ( 0 , 3 ) ) ; ButtonGroup grp = new ButtonGroup ( ) ; installUser = new JRadioButton ( ) ; String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) { settings = jEdit . getProperty ( "install-plugins.none" ) ; installUser . setEnabled ( false ) ; } else { settings = MiscUtilities . constructPath ( settings , "jars" ) ; installUser . setEnabled ( true ) ; } String [ ] args = { settings } ; installUser . setText ( jEdit . getProperty ( "install-plugins.user" , args ) ) ; grp . add ( installUser ) ; panel4 . add ( BorderLayout . CENTER , installUser ) ; installSystem = new JRadioButton ( ) ; String jEditHome = jEdit . getJEditHome ( ) ; if ( jEditHome == null ) { jEditHome = jEdit . getProperty ( "install-plugins.none" ) ; installSystem . setEnabled ( false ) ; } else { jEditHome = MiscUtilities . constructPath ( jEditHome , "jars" ) ; installSystem . setEnabled ( true ) ; } args [ 0 ] = jEditHome ; installSystem . setText ( jEdit . getProperty ( "install-plugins.system" , args ) ) ; grp . add ( installSystem ) ; panel4 . add ( BorderLayout . SOUTH , installSystem ) ; if ( installUser . isEnabled ( ) ) installUser . setSelected ( true ) ; else installSystem . setSelected ( true ) ; panel3 . add ( BorderLayout . CENTER , panel4 ) ; } panel3 . add ( BorderLayout . SOUTH , downloadSource = new JCheckBox ( jEdit . getProperty ( "install-plugins.downloadSource" ) ) ) ; downloadSource . setSelected ( jEdit . getBooleanProperty ( "install-plugins" + ".downloadSource.value" ) ) ; panel2 . add ( BorderLayout . SOUTH , panel3 ) ; panel . add ( BorderLayout . SOUTH , panel2 ) ; content . add ( BorderLayout . CENTER , panel ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; install = new JButton ( jEdit . getProperty ( "install-plugins.install" ) ) ; install . setEnabled ( false ) ; getRootPane ( ) . setDefaultButton ( install ) ; install . addActionListener ( new ActionHandler ( ) ) ; box . add ( install ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; box . add ( cancel ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; pack ( ) ; setLocationRelativeTo ( dialog ) ; show ( ) ; } public void ok ( ) { jEdit . setBooleanProperty ( "install-plugins.downloadSource.value" , downloadSource . isSelected ( ) ) ; dispose ( ) ; } public void cancel ( ) { cancelled = true ; dispose ( ) ; } void installPlugins ( Roster roster ) { if ( cancelled ) return ; String installDirectory ; if ( installUser == null || installUser . isSelected ( ) ) { installDirectory = MiscUtilities . constructPath ( jEdit . getSettingsDirectory ( ) , "jars" ) ; } else { installDirectory = MiscUtilities . constructPath ( jEdit . getJEditHome ( ) , "jars" ) ; } Object [ ] selected = plugins . getCheckedValues ( ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) selected [ i ] ; plugin . install ( roster , installDirectory , downloadSource . isSelected ( ) ) ; } } private JCheckBoxList plugins ; private JLabel name ; private JLabel author ; private JLabel latestVersion ; private JLabel installedVersion ; private JLabel updated ; private JTextArea description ; private JRadioButton installUser ; private JRadioButton installSystem ; private JCheckBox downloadSource ; private JButton install ; private JButton cancel ; private boolean cancelled ; private Thread thread ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == install ) ok ( ) ; else cancel ( ) ; } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { Object selected = plugins . getSelectedValue ( ) ; if ( selected instanceof PluginList . Plugin ) { install . setEnabled ( true ) ; PluginList . Plugin plugin = ( PluginList . Plugin ) selected ; PluginList . Branch branch = plugin . getCompatibleBranch ( ) ; name . setText ( plugin . name ) ; author . setText ( plugin . author ) ; if ( branch . obsolete ) latestVersion . setText ( jEdit . getProperty ( "install-plugins.info.obsolete" ) ) ; else latestVersion . setText ( branch . version ) ; if ( installedVersion != null ) installedVersion . setText ( plugin . installedVersion ) ; updated . setText ( branch . date ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < branch . deps . size ( ) ; i ++ ) { PluginList . Dependency dep = ( PluginList . Dependency ) branch . deps . elementAt ( i ) ; if ( dep . what . equals ( "plugin" ) && ! dep . isSatisfied ( ) ) { if ( buf . length ( ) != 0 ) buf . append ( ", " ) ; buf . append ( dep . plugin ) ; } } description . setText ( plugin . description + ( buf . length ( ) == 0 ? "" : jEdit . getProperty ( "install-plugins.info" + ".also-install" ) + buf . toString ( ) + ( branch . obsolete ? jEdit . getProperty ( "install-plugins.info.obsolete-text" ) : "" ) ) ) ; } else { install . setEnabled ( false ) ; name . setText ( null ) ; author . setText ( null ) ; latestVersion . setText ( null ) ; if ( installedVersion != null ) installedVersion . setText ( null ) ; updated . setText ( null ) ; description . setText ( null ) ; } } } } 	1	['12', '7', '0', '9', '72', '40', '3', '8', '2', '0.943181818', '687', '0.875', '1', '0.983433735', '0.222222222', '1', '3', '54.91666667', '5', '1.25', '4']
package org . gjt . sp . jedit . gui ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . IOException ; import java . net . URL ; import java . util . Random ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class TipOfTheDay extends EnhancedDialog { public TipOfTheDay ( View view ) { super ( view , jEdit . getProperty ( "tip.title" ) , false ) ; setContentPane ( new TipPanel ( ) ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } class TipPanel extends JPanel { TipPanel ( ) { super ( new BorderLayout ( 12 , 12 ) ) ; setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "tip.caption" ) ) ; label . setFont ( new Font ( "SansSerif" , Font . PLAIN , 24 ) ) ; label . setForeground ( UIManager . getColor ( "Button.foreground" ) ) ; TipPanel . this . add ( BorderLayout . NORTH , label ) ; tipText = new JEditorPane ( ) ; tipText . setEditable ( false ) ; tipText . setContentType ( "text/html" ) ; nextTip ( ) ; JScrollPane scroller = new JScrollPane ( tipText ) ; scroller . setPreferredSize ( new Dimension ( 150 , 150 ) ) ; TipPanel . this . add ( BorderLayout . CENTER , scroller ) ; ActionHandler actionHandler = new ActionHandler ( ) ; Box buttons = new Box ( BoxLayout . X_AXIS ) ; showNextTime = new JCheckBox ( jEdit . getProperty ( "tip.show-next-time" ) , jEdit . getBooleanProperty ( "tip.show" ) ) ; showNextTime . addActionListener ( actionHandler ) ; buttons . add ( showNextTime ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( Box . createGlue ( ) ) ; nextTip = new JButton ( jEdit . getProperty ( "tip.next-tip" ) ) ; nextTip . addActionListener ( actionHandler ) ; buttons . add ( nextTip ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( actionHandler ) ; buttons . add ( close ) ; TipOfTheDay . this . getRootPane ( ) . setDefaultButton ( close ) ; Dimension dim = nextTip . getPreferredSize ( ) ; dim . width = Math . max ( dim . width , close . getPreferredSize ( ) . width ) ; nextTip . setPreferredSize ( dim ) ; close . setPreferredSize ( dim ) ; TipPanel . this . add ( BorderLayout . SOUTH , buttons ) ; } private JCheckBox showNextTime ; private JButton nextTip , close ; private JEditorPane tipText ; private int currentTip = - 1 ; private void nextTip ( ) { int count = Integer . parseInt ( jEdit . getProperty ( "tip.count" ) ) ; int tipToShow = currentTip ; while ( tipToShow == currentTip ) tipToShow = Math . abs ( new Random ( ) . nextInt ( ) ) % count ; try { tipText . setPage ( TipOfTheDay . class . getResource ( "/org/gjt/sp/jedit/tips/tip" + tipToShow + ".html" ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == showNextTime ) { jEdit . setBooleanProperty ( "tip.show" , showNextTime . isSelected ( ) ) ; } else if ( source == nextTip ) nextTip ( ) ; else if ( source == close ) dispose ( ) ; } } } } 	1	['6', '7', '0', '6', '18', '13', '3', '4', '3', '0.8', '55', '1', '0', '0.992401216', '0.25', '0', '0', '8', '1', '0.8333', '2']
package org . gjt . sp . jedit . pluginmgr ; import com . microstar . xml . * ; import java . io . * ; import java . net . URL ; import java . util . Hashtable ; import java . util . Vector ; import org . gjt . sp . util . Log ; import org . gjt . sp . jedit . * ; class PluginList { Vector plugins ; Hashtable pluginHash ; Vector pluginSets ; PluginList ( ) throws Exception { plugins = new Vector ( ) ; pluginHash = new Hashtable ( ) ; pluginSets = new Vector ( ) ; String path = jEdit . getProperty ( "plugin-manager.url" ) ; PluginListHandler handler = new PluginListHandler ( this , path ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( handler ) ; parser . parse ( null , null , new BufferedReader ( new InputStreamReader ( new URL ( path ) . openStream ( ) , "UTF8" ) ) ) ; } void addPlugin ( Plugin plugin ) { plugin . checkIfInstalled ( ) ; plugins . addElement ( plugin ) ; pluginHash . put ( plugin . name , plugin ) ; } void addPluginSet ( PluginSet set ) { pluginSets . addElement ( set ) ; } void finished ( ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { Plugin plugin = ( Plugin ) plugins . elementAt ( i ) ; for ( int j = 0 ; j < plugin . branches . size ( ) ; j ++ ) { Branch branch = ( Branch ) plugin . branches . elementAt ( j ) ; for ( int k = 0 ; k < branch . deps . size ( ) ; k ++ ) { Dependency dep = ( Dependency ) branch . deps . elementAt ( k ) ; if ( dep . what . equals ( "plugin" ) ) dep . plugin = ( Plugin ) pluginHash . get ( dep . pluginName ) ; } } } } void dump ( ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { System . err . println ( ( Plugin ) plugins . elementAt ( i ) ) ; System . err . println ( ) ; } } static class PluginSet { String name ; String description ; Vector plugins = new Vector ( ) ; void install ( Roster roster , String installDirectory , boolean downloadSource ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { Plugin plugin = ( Plugin ) plugins . elementAt ( i ) ; if ( plugin . canBeInstalled ( ) ) { plugin . install ( roster , installDirectory , downloadSource ) ; } } } public String toString ( ) { return plugins . toString ( ) ; } } static class Plugin { String jar ; String name ; String description ; String author ; Vector branches = new Vector ( ) ; String installed ; String installedVersion ; void checkIfInstalled ( ) { EditPlugin . JAR [ ] jars = jEdit . getPluginJARs ( ) ; for ( int i = 0 ; i < jars . length ; i ++ ) { String path = jars [ i ] . getPath ( ) ; if ( ! new File ( path ) . exists ( ) ) continue ; if ( MiscUtilities . getFileName ( path ) . equals ( jar ) ) { installed = path ; EditPlugin [ ] plugins = jars [ i ] . getPlugins ( ) ; if ( plugins . length >= 1 ) { installedVersion = jEdit . getProperty ( "plugin." + plugins [ 0 ] . getClassName ( ) + ".version" ) ; } break ; } } String [ ] notLoaded = jEdit . getNotLoadedPluginJARs ( ) ; for ( int i = 0 ; i < notLoaded . length ; i ++ ) { String path = notLoaded [ i ] ; if ( MiscUtilities . getFileName ( path ) . equals ( jar ) ) { installed = path ; break ; } } } Branch getCompatibleBranch ( ) { for ( int i = 0 ; i < branches . size ( ) ; i ++ ) { Branch branch = ( Branch ) branches . elementAt ( i ) ; if ( branch . canSatisfyDependencies ( ) ) return branch ; } return null ; } boolean canBeInstalled ( ) { Branch branch = getCompatibleBranch ( ) ; return branch != null && ! branch . obsolete ; } void install ( Roster roster , String installDirectory , boolean downloadSource ) { if ( installed != null ) roster . addOperation ( new Roster . Remove ( installed ) ) ; Branch branch = getCompatibleBranch ( ) ; if ( branch . obsolete ) return ; branch . satisfyDependencies ( roster , installDirectory , downloadSource ) ; if ( installed != null ) { installDirectory = MiscUtilities . getParentOfPath ( installed ) ; } roster . addOperation ( new Roster . Install ( ( downloadSource ? branch . downloadSource : branch . download ) , installDirectory ) ) ; } public String toString ( ) { return name ; } } static class Branch { String version ; String date ; String download ; String downloadSource ; boolean obsolete ; Vector deps = new Vector ( ) ; boolean canSatisfyDependencies ( ) { for ( int i = 0 ; i < deps . size ( ) ; i ++ ) { Dependency dep = ( Dependency ) deps . elementAt ( i ) ; if ( ! dep . canSatisfy ( ) ) return false ; } return true ; } void satisfyDependencies ( Roster roster , String installDirectory , boolean downloadSource ) { for ( int i = 0 ; i < deps . size ( ) ; i ++ ) { Dependency dep = ( Dependency ) deps . elementAt ( i ) ; dep . satisfy ( roster , installDirectory , downloadSource ) ; } } public String toString ( ) { return "[version=" + version + ",download=" + download + ",obsolete=" + obsolete + ",deps=" + deps + "]" ; } } static class Dependency { String what ; String from ; String to ; String pluginName ; Plugin plugin ; Dependency ( String what , String from , String to , String pluginName ) { this . what = what ; this . from = from ; this . to = to ; this . pluginName = pluginName ; } boolean isSatisfied ( ) { if ( what . equals ( "plugin" ) ) { for ( int i = 0 ; i < plugin . branches . size ( ) ; i ++ ) { Branch branch = ( Branch ) plugin . branches . elementAt ( i ) ; if ( plugin . installedVersion != null && ( from == null || MiscUtilities . compareVersions ( plugin . installedVersion , from ) >= 0 ) && ( to == null || MiscUtilities . compareVersions ( plugin . installedVersion , to ) <= 0 ) ) { return true ; } } return false ; } else if ( what . equals ( "jdk" ) ) { String javaVersion = System . getProperty ( "java.version" ) . substring ( 0 , 3 ) ; if ( ( from == null || MiscUtilities . compareVersions ( javaVersion , from ) >= 0 ) && ( to == null || MiscUtilities . compareVersions ( javaVersion , to ) <= 0 ) ) return true ; else return false ; } else if ( what . equals ( "jedit" ) ) { String build = jEdit . getBuild ( ) ; if ( ( from == null || MiscUtilities . compareVersions ( build , from ) >= 0 ) && ( to == null || MiscUtilities . compareVersions ( build , to ) <= 0 ) ) return true ; else return false ; } else { Log . log ( Log . ERROR , this , "Invalid dependency: " + what ) ; return false ; } } boolean canSatisfy ( ) { return ( what . equals ( "plugin" ) || isSatisfied ( ) ) ; } void satisfy ( Roster roster , String installDirectory , boolean downloadSource ) { if ( what . equals ( "plugin" ) ) { for ( int i = 0 ; i < plugin . branches . size ( ) ; i ++ ) { Branch branch = ( Branch ) plugin . branches . elementAt ( i ) ; if ( ( plugin . installedVersion == null || MiscUtilities . compareVersions ( plugin . installedVersion , branch . version ) < 0 ) && ( from == null || MiscUtilities . compareVersions ( branch . version , from ) >= 0 ) && ( to == null || MiscUtilities . compareVersions ( branch . version , to ) <= 0 ) ) { plugin . install ( roster , installDirectory , downloadSource ) ; return ; } } } } public String toString ( ) { return "[what=" + what + ",from=" + from + ",to=" + to + ",plugin=" + plugin + "]" ; } } } 	1	['5', '1', '0', '11', '26', '0', '4', '8', '0', '0.5', '155', '0', '0', '0', '0.466666667', '0', '0', '29.4', '5', '1.8', '2']
package org . gjt . sp . jedit . io ; import javax . swing . filechooser . FileSystemView ; import java . awt . Component ; import java . io . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class FileVFS extends VFS { public static final String BACKED_UP_PROPERTY = "FileVFS__backedUp" ; public static final String PERMISSIONS_PROPERTY = "FileVFS__perms" ; public FileVFS ( ) { super ( "file" ) ; fsView = FileSystemView . getFileSystemView ( ) ; } public int getCapabilities ( ) { return READ_CAP | WRITE_CAP | BROWSE_CAP | DELETE_CAP | RENAME_CAP | MKDIR_CAP ; } public String getParentOfPath ( String path ) { if ( File . separatorChar == '\\' ) { if ( path . length ( ) == 2 && path . charAt ( 1 ) == ':' ) return FileRootsVFS . PROTOCOL + ":" ; else if ( path . length ( ) == 3 && path . endsWith ( ":\\" ) ) return FileRootsVFS . PROTOCOL + ":" ; } if ( path . equals ( "/" ) ) return FileRootsVFS . PROTOCOL + ":" ; return MiscUtilities . getParentOfPath ( path ) ; } public String constructPath ( String parent , String path ) { return MiscUtilities . constructPath ( parent , path ) ; } public char getFileSeparator ( ) { return File . separatorChar ; } public boolean load ( View view , Buffer buffer , String path ) { File file = buffer . getFile ( ) ; if ( ! file . exists ( ) ) { buffer . setNewFile ( true ) ; return false ; } else buffer . setReadOnly ( ! file . canWrite ( ) ) ; if ( file . isDirectory ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "open-directory" , args ) ; buffer . setNewFile ( false ) ; return false ; } if ( ! file . canRead ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "no-read" , args ) ; buffer . setNewFile ( false ) ; return false ; } return super . load ( view , buffer , path ) ; } public boolean save ( View view , Buffer buffer , String path ) { File file = new File ( path ) ; if ( file . isDirectory ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "save-directory" , args ) ; return false ; } if ( ( file . exists ( ) && ! file . canWrite ( ) ) || ( ! file . exists ( ) && ! new File ( file . getParent ( ) ) . canWrite ( ) ) ) { String [ ] args = { path } ; GUIUtilities . error ( view , "no-write" , args ) ; return false ; } int permissions = getPermissions ( buffer . getPath ( ) ) ; Log . log ( Log . DEBUG , this , buffer . getPath ( ) + " has permissions 0" + Integer . toString ( permissions , 8 ) ) ; buffer . putProperty ( PERMISSIONS_PROPERTY , new Integer ( permissions ) ) ; return super . save ( view , buffer , path ) ; } public boolean insert ( View view , Buffer buffer , String path ) { File file = new File ( path ) ; if ( ! file . exists ( ) ) return false ; if ( file . isDirectory ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "open-directory" , args ) ; return false ; } if ( ! file . canRead ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "no-read" , args ) ; return false ; } return super . load ( view , buffer , path ) ; } public VFS . DirectoryEntry [ ] _listDirectory ( Object session , String path , Component comp ) { if ( File . separatorChar == '\\' ) { if ( path . length ( ) == 2 && path . charAt ( 1 ) == ':' ) path = path . concat ( File . separator ) ; } File directory = new File ( path ) ; String [ ] list = directory . list ( ) ; if ( list == null ) { String [ ] pp = { path } ; VFSManager . error ( comp , "directory-error-nomsg" , pp ) ; return null ; } Vector list2 = new Vector ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String name = list [ i ] ; String _path ; if ( path . endsWith ( File . separator ) ) _path = path + name ; else _path = path + File . separatorChar + name ; File file = new File ( _path ) ; int type ; if ( file . isDirectory ( ) ) type = VFS . DirectoryEntry . DIRECTORY ; else type = VFS . DirectoryEntry . FILE ; VFS . DirectoryEntry entry = new VFS . DirectoryEntry ( name , _path , _path , type , file . length ( ) , fsView . isHiddenFile ( file ) ) ; list2 . addElement ( entry ) ; } VFS . DirectoryEntry [ ] retVal = new VFS . DirectoryEntry [ list2 . size ( ) ] ; list2 . copyInto ( retVal ) ; return retVal ; } public DirectoryEntry _getDirectoryEntry ( Object session , String path , Component comp ) { if ( path . endsWith ( "/" ) || path . endsWith ( File . separator ) ) path = path . substring ( 0 , path . length ( ) - 1 ) ; File file = new File ( path ) ; if ( ! file . exists ( ) ) return null ; int type ; if ( file . isDirectory ( ) ) type = VFS . DirectoryEntry . DIRECTORY ; else type = VFS . DirectoryEntry . FILE ; return new VFS . DirectoryEntry ( file . getName ( ) , path , path , type , file . length ( ) , fsView . isHiddenFile ( file ) ) ; } public boolean _delete ( Object session , String path , Component comp ) { boolean retVal = new File ( path ) . delete ( ) ; if ( retVal ) VFSManager . sendVFSUpdate ( this , path , true ) ; return retVal ; } public boolean _rename ( Object session , String from , String to , Component comp ) { File _to = new File ( to ) ; _to . delete ( ) ; boolean retVal = new File ( from ) . renameTo ( _to ) ; VFSManager . sendVFSUpdate ( this , from , true ) ; VFSManager . sendVFSUpdate ( this , to , true ) ; return retVal ; } public boolean _mkdir ( Object session , String directory , Component comp ) { boolean retVal = new File ( directory ) . mkdirs ( ) ; VFSManager . sendVFSUpdate ( this , directory , true ) ; return retVal ; } public void _backup ( Object session , String path , Component comp ) throws IOException { int backups ; try { backups = Integer . parseInt ( jEdit . getProperty ( "backups" ) ) ; } catch ( NumberFormatException nf ) { Log . log ( Log . ERROR , this , nf ) ; backups = 1 ; } if ( backups == 0 ) return ; String backupPrefix = jEdit . getProperty ( "backup.prefix" , "" ) ; String backupSuffix = jEdit . getProperty ( "backup.suffix" , "~" ) ; File file = new File ( path ) ; String backupDirectory = jEdit . getProperty ( "backup.directory" ) ; if ( backupDirectory == null || backupDirectory . length ( ) == 0 ) backupDirectory = file . getParent ( ) ; else { backupDirectory = MiscUtilities . constructPath ( System . getProperty ( "user.home" ) , backupDirectory ) ; backupDirectory = MiscUtilities . concatPath ( backupDirectory , file . getParent ( ) ) ; File dir = new File ( backupDirectory ) ; if ( ! dir . exists ( ) ) dir . mkdirs ( ) ; } String name = file . getName ( ) ; if ( backups == 1 ) { file . renameTo ( new File ( backupDirectory , backupPrefix + name + backupSuffix ) ) ; } else { new File ( backupDirectory , backupPrefix + name + backupSuffix + backups + backupSuffix ) . delete ( ) ; for ( int i = backups - 1 ; i > 0 ; i -- ) { File backup = new File ( backupDirectory , backupPrefix + name + backupSuffix + i + backupSuffix ) ; backup . renameTo ( new File ( backupDirectory , backupPrefix + name + backupSuffix + ( i + 1 ) + backupSuffix ) ) ; } file . renameTo ( new File ( backupDirectory , backupPrefix + name + backupSuffix + "1" + backupSuffix ) ) ; } } public InputStream _createInputStream ( Object session , String path , boolean ignoreErrors , Component comp ) throws IOException { try { return new FileInputStream ( path ) ; } catch ( IOException io ) { if ( ignoreErrors ) return null ; else throw io ; } } public OutputStream _createOutputStream ( Object session , String path , Component comp ) throws IOException { OutputStream retVal = new FileOutputStream ( path ) ; return retVal ; } public void _saveComplete ( Object session , Buffer buffer , Component comp ) { int permissions = ( ( Integer ) buffer . getProperty ( PERMISSIONS_PROPERTY ) ) . intValue ( ) ; setPermissions ( buffer . getPath ( ) , permissions ) ; } public static int getPermissions ( String path ) { int permissions = 0 ; if ( isUnix ) { String [ ] cmdarray = { "ls" , "-ld" , path } ; try { Process process = Runtime . getRuntime ( ) . exec ( cmdarray ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String output = reader . readLine ( ) ; if ( output != null ) { String s = output . substring ( 1 , 10 ) ; if ( s . length ( ) == 9 ) { if ( s . charAt ( 0 ) == 'r' ) permissions += 0400 ; if ( s . charAt ( 1 ) == 'w' ) permissions += 0200 ; if ( s . charAt ( 2 ) == 'x' ) permissions += 0100 ; else if ( s . charAt ( 2 ) == 's' ) permissions += 04100 ; else if ( s . charAt ( 2 ) == 'S' ) permissions += 04000 ; if ( s . charAt ( 3 ) == 'r' ) permissions += 040 ; if ( s . charAt ( 4 ) == 'w' ) permissions += 020 ; if ( s . charAt ( 5 ) == 'x' ) permissions += 010 ; else if ( s . charAt ( 5 ) == 's' ) permissions += 02010 ; else if ( s . charAt ( 5 ) == 'S' ) permissions += 02000 ; if ( s . charAt ( 6 ) == 'r' ) permissions += 04 ; if ( s . charAt ( 7 ) == 'w' ) permissions += 02 ; if ( s . charAt ( 8 ) == 'x' ) permissions += 01 ; else if ( s . charAt ( 8 ) == 't' ) permissions += 01001 ; else if ( s . charAt ( 8 ) == 'T' ) permissions += 01000 ; } } } catch ( Throwable t ) { } } return permissions ; } public static void setPermissions ( String path , int permissions ) { if ( permissions != 0 ) { if ( isUnix ) { String [ ] cmdarray = { "chmod" , Integer . toString ( permissions , 8 ) , path } ; try { Process process = Runtime . getRuntime ( ) . exec ( cmdarray ) ; process . getInputStream ( ) . close ( ) ; process . getOutputStream ( ) . close ( ) ; process . getErrorStream ( ) . close ( ) ; int exitCode = process . waitFor ( ) ; if ( exitCode != 0 ) Log . log ( Log . NOTICE , FileVFS . class , "chmod exited with code " + exitCode ) ; } catch ( Throwable t ) { } } } } private FileSystemView fsView ; private static boolean isUnix ; static { if ( File . separatorChar == '/' ) { String osName = System . getProperty ( "os.name" ) ; if ( osName . indexOf ( "MacOS" ) != - 1 ) { if ( osName . indexOf ( "X" ) != - 1 ) { isUnix = true ; } else { isUnix = false ; } } else { isUnix = true ; } } Log . log ( Log . DEBUG , FileVFS . class , "Unix operating system " + ( isUnix ? "detected; will" : "not detected; will not" ) + " use permission-preserving code" ) ; } } 	1	['21', '2', '0', '12', '94', '198', '5', '9', '19', '0.94', '981', '0.6', '0', '0.525', '0.375', '2', '4', '45.47619048', '16', '3.1905', '6']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class EnhancedCheckBoxMenuItem extends JCheckBoxMenuItem { public EnhancedCheckBoxMenuItem ( String label , EditAction action ) { super ( label ) ; this . action = action ; if ( action != null ) { setEnabled ( true ) ; addActionListener ( new EditAction . Wrapper ( action ) ) ; shortcutProp1 = action . getName ( ) + ".shortcut" ; shortcutProp2 = action . getName ( ) + ".shortcut2" ; } else setEnabled ( false ) ; setModel ( new Model ( ) ) ; } public Dimension getPreferredSize ( ) { Dimension d = super . getPreferredSize ( ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { d . width += ( getFontMetrics ( acceleratorFont ) . stringWidth ( shortcut ) + 10 ) ; } return d ; } public void paint ( Graphics g ) { super . paint ( g ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { g . setFont ( acceleratorFont ) ; g . setColor ( getModel ( ) . isArmed ( ) ? acceleratorSelectionForeground : acceleratorForeground ) ; FontMetrics fm = g . getFontMetrics ( ) ; Insets insets = getInsets ( ) ; g . drawString ( shortcut , getWidth ( ) - ( fm . stringWidth ( shortcut ) + insets . right + insets . left ) , getFont ( ) . getSize ( ) + ( insets . top - 1 ) ) ; } } public String getActionCommand ( ) { return getModel ( ) . getActionCommand ( ) ; } private String shortcutProp1 ; private String shortcutProp2 ; private EditAction action ; private static Font acceleratorFont ; private static Color acceleratorForeground ; private static Color acceleratorSelectionForeground ; private String getShortcut ( ) { if ( action == null ) return null ; else { String shortcut1 = jEdit . getProperty ( shortcutProp1 ) ; String shortcut2 = jEdit . getProperty ( shortcutProp2 ) ; if ( shortcut1 == null || shortcut1 . length ( ) == 0 ) { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return null ; else return shortcut2 ; } else { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return shortcut1 ; else return shortcut1 + " or " + shortcut2 ; } } } static { acceleratorFont = UIManager . getFont ( "MenuItem.acceleratorFont" ) ; acceleratorFont = new Font ( "Monospaced" , acceleratorFont . getStyle ( ) , acceleratorFont . getSize ( ) ) ; acceleratorForeground = UIManager . getColor ( "MenuItem.acceleratorForeground" ) ; acceleratorSelectionForeground = UIManager . getColor ( "MenuItem.acceleratorSelectionForeground" ) ; } class Model extends DefaultButtonModel { public boolean isSelected ( ) { if ( ! isShowing ( ) ) return false ; try { return action . isSelected ( EditAction . getView ( EnhancedCheckBoxMenuItem . this ) ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , this , t ) ; return false ; } } public void setSelected ( boolean b ) { } } } 	1	['7', '7', '0', '5', '38', '9', '2', '4', '4', '0.611111111', '210', '1', '1', '0.993811881', '0.3', '3', '13', '28.14285714', '8', '2.1429', '2']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import javax . swing . plaf . metal . * ; import javax . swing . plaf . FontUIResource ; import javax . swing . text . Element ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . io . * ; import java . net . * ; import java . text . MessageFormat ; import java . util . * ; import org . gjt . sp . jedit . browser . VFSBrowser ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . search . SearchAndReplace ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class jEdit { public static String getVersion ( ) { return MiscUtilities . buildToVersion ( getBuild ( ) ) ; } public static String getBuild ( ) { return "03.02.99.00" ; } public static void main ( String [ ] args ) { int level = Log . WARNING ; if ( args . length >= 1 ) { String levelStr = args [ 0 ] ; if ( levelStr . length ( ) == 1 && Character . isDigit ( levelStr . charAt ( 0 ) ) ) { level = Integer . parseInt ( levelStr ) ; args [ 0 ] = null ; } } boolean endOpts = false ; settingsDirectory = MiscUtilities . constructPath ( System . getProperty ( "user.home" ) , ".jedit" ) ; String portFile = "server" ; boolean restore = true ; boolean noStartupScripts = false ; String userDir = System . getProperty ( "user.dir" ) ; String scriptFile = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg == null ) continue ; else if ( arg . length ( ) == 0 ) args [ i ] = null ; else if ( arg . startsWith ( "-" ) && ! endOpts ) { if ( arg . equals ( "--" ) ) endOpts = true ; else if ( arg . equals ( "-usage" ) ) { version ( ) ; System . err . println ( ) ; usage ( ) ; System . exit ( 1 ) ; } else if ( arg . equals ( "-version" ) ) { version ( ) ; System . exit ( 1 ) ; } else if ( arg . equals ( "-nosettings" ) ) settingsDirectory = null ; else if ( arg . startsWith ( "-settings=" ) ) settingsDirectory = arg . substring ( 10 ) ; else if ( arg . startsWith ( "-noserver" ) ) portFile = null ; else if ( arg . equals ( "-server" ) ) portFile = "server" ; else if ( arg . startsWith ( "-server=" ) ) portFile = arg . substring ( 8 ) ; else if ( arg . startsWith ( "-background" ) ) background = true ; else if ( arg . equals ( "-norestore" ) ) restore = false ; else if ( arg . equals ( "-nostartupscripts" ) ) noStartupScripts = true ; else if ( arg . startsWith ( "-run=" ) ) scriptFile = arg . substring ( 5 ) ; else { System . err . println ( "Unknown option: " + arg ) ; usage ( ) ; System . exit ( 1 ) ; } args [ i ] = null ; } } if ( settingsDirectory != null && portFile != null ) portFile = MiscUtilities . constructPath ( settingsDirectory , portFile ) ; else portFile = null ; Log . init ( true , level ) ; if ( portFile != null && new File ( portFile ) . exists ( ) ) { int port , key ; try { BufferedReader in = new BufferedReader ( new FileReader ( portFile ) ) ; port = Integer . parseInt ( in . readLine ( ) ) ; key = Integer . parseInt ( in . readLine ( ) ) ; in . close ( ) ; Socket socket = new Socket ( InetAddress . getByName ( "127.0.0.1" ) , port ) ; Writer out = new OutputStreamWriter ( socket . getOutputStream ( ) , "UTF8" ) ; out . write ( String . valueOf ( key ) ) ; out . write ( '\n' ) ; String script = makeServerScript ( restore , args , scriptFile ) ; out . write ( script ) ; out . close ( ) ; System . exit ( 0 ) ; } catch ( Exception e ) { Log . log ( Log . NOTICE , jEdit . class , "An error occurred" + " while connecting to the jEdit server instance." ) ; Log . log ( Log . NOTICE , jEdit . class , "This probably means that" + " jEdit crashed and/or exited abnormally" ) ; Log . log ( Log . NOTICE , jEdit . class , "the last time it was run." ) ; Log . log ( Log . NOTICE , jEdit . class , "If you don't" + " know what this means, don't worry." ) ; Log . log ( Log . NOTICE , jEdit . class , e ) ; } } if ( System . getProperty ( "os.name" ) . indexOf ( "MacOS X" ) != - 1 ) { System . getProperties ( ) . put ( "com.apple.macos.useScreenMenuBar" , "true" ) ; } boolean showSplash = true ; Writer stream ; if ( settingsDirectory != null ) { File _settingsDirectory = new File ( settingsDirectory ) ; if ( ! _settingsDirectory . exists ( ) ) _settingsDirectory . mkdirs ( ) ; File _macrosDirectory = new File ( settingsDirectory , "macros" ) ; if ( ! _macrosDirectory . exists ( ) ) _macrosDirectory . mkdir ( ) ; String logPath = MiscUtilities . constructPath ( settingsDirectory , "activity.log" ) ; try { stream = new BufferedWriter ( new FileWriter ( logPath ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; stream = null ; } if ( new File ( settingsDirectory , "nosplash" ) . exists ( ) ) showSplash = false ; } else { stream = null ; } if ( showSplash ) GUIUtilities . showSplashScreen ( ) ; Log . setLogWriter ( stream ) ; Log . log ( Log . NOTICE , jEdit . class , "jEdit version " + getVersion ( ) ) ; Log . log ( Log . MESSAGE , jEdit . class , "Settings directory is " + settingsDirectory ) ; if ( portFile != null ) { server = new EditServer ( portFile ) ; if ( ! server . isOK ( ) ) server = null ; } else { if ( background ) { background = false ; System . err . println ( "You cannot specify both the" + " -background and -noserver switches" ) ; } } initMisc ( ) ; initSystemProperties ( ) ; BeanShell . init ( ) ; GUIUtilities . advanceSplashProgress ( ) ; if ( jEditHome != null ) initSiteProperties ( ) ; initUserProperties ( ) ; initActions ( ) ; initPlugins ( ) ; if ( settingsDirectory != null ) { File history = new File ( MiscUtilities . constructPath ( settingsDirectory , "history" ) ) ; if ( history . exists ( ) ) historyModTime = history . lastModified ( ) ; HistoryModel . loadHistory ( history ) ; File recent = new File ( MiscUtilities . constructPath ( settingsDirectory , "recent.xml" ) ) ; if ( recent . exists ( ) ) recentModTime = recent . lastModified ( ) ; BufferHistory . load ( recent ) ; } Abbrevs . load ( ) ; GUIUtilities . advanceSplashProgress ( ) ; sortBuffers = getBooleanProperty ( "sortBuffers" ) ; sortByName = getBooleanProperty ( "sortByName" ) ; initPLAF ( ) ; reloadModes ( ) ; GUIUtilities . advanceSplashProgress ( ) ; SearchAndReplace . load ( ) ; FavoritesVFS . loadFavorites ( ) ; Macros . loadMacros ( ) ; GUIUtilities . advanceSplashProgress ( ) ; for ( int i = 0 ; i < jars . size ( ) ; i ++ ) { ( ( EditPlugin . JAR ) jars . elementAt ( i ) ) . getClassLoader ( ) . startAllPlugins ( ) ; } if ( ! noStartupScripts && jEditHome != null ) { String path = MiscUtilities . constructPath ( jEditHome , "startup" ) ; File file = new File ( path ) ; if ( file . exists ( ) ) runStartupScripts ( file ) ; } if ( ! noStartupScripts && settingsDirectory != null ) { String path = MiscUtilities . constructPath ( settingsDirectory , "startup" ) ; File file = new File ( path ) ; if ( ! file . exists ( ) ) file . mkdirs ( ) ; else runStartupScripts ( file ) ; } if ( scriptFile != null ) { scriptFile = MiscUtilities . constructPath ( userDir , scriptFile ) ; BeanShell . runScript ( null , scriptFile , false , false ) ; } propertiesChanged ( ) ; GUIUtilities . advanceSplashProgress ( ) ; Buffer buffer = openFiles ( null , userDir , args ) ; String splitConfig = null ; if ( restore && settingsDirectory != null && jEdit . getBooleanProperty ( "restore" ) && ( bufferCount == 0 || jEdit . getBooleanProperty ( "restore.cli" ) ) ) { splitConfig = restoreOpenFiles ( ) ; } final Buffer _buffer = buffer ; final String _splitConfig = splitConfig ; GUIUtilities . advanceSplashProgress ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( bufferCount == 0 ) newFile ( null ) ; EditBus . send ( new EditorStarted ( null ) ) ; View view ; if ( _buffer != null ) view = newView ( null , _buffer ) ; else view = newView ( null , _splitConfig ) ; if ( jEdit . getBooleanProperty ( "firstTime" ) ) new HelpViewer ( "welcome.html" ) ; else if ( jEdit . getBooleanProperty ( "tip.show" ) ) new TipOfTheDay ( view ) ; setBooleanProperty ( "firstTime" , false ) ; VFSManager . start ( ) ; if ( server != null ) server . start ( ) ; GUIUtilities . hideSplashScreen ( ) ; Log . log ( Log . MESSAGE , jEdit . class , "Startup " + "complete" ) ; } } ) ; } public static final Properties getProperties ( ) { return props ; } public static final String getProperty ( String name ) { return props . getProperty ( name ) ; } public static final String getProperty ( String name , String def ) { return props . getProperty ( name , def ) ; } public static final String getProperty ( String name , Object [ ] args ) { if ( name == null ) return null ; if ( args == null ) return props . getProperty ( name , name ) ; else return MessageFormat . format ( props . getProperty ( name , name ) , args ) ; } public static final boolean getBooleanProperty ( String name ) { return getBooleanProperty ( name , false ) ; } public static final boolean getBooleanProperty ( String name , boolean def ) { String value = getProperty ( name ) ; if ( value == null ) return def ; else if ( value . equals ( "true" ) || value . equals ( "yes" ) || value . equals ( "on" ) ) return true ; else if ( value . equals ( "false" ) || value . equals ( "no" ) || value . equals ( "off" ) ) return false ; else return def ; } public static final void setProperty ( String name , String value ) { if ( value == null || value . length ( ) == 0 ) { String prop = ( String ) defaultProps . get ( name ) ; if ( prop == null || prop . length ( ) == 0 ) props . remove ( name ) ; else props . put ( name , "" ) ; } else { String prop = ( String ) defaultProps . get ( name ) ; if ( value . equals ( prop ) ) props . remove ( name ) ; else props . put ( name , value ) ; } } public static final void setTemporaryProperty ( String name , String value ) { props . remove ( name ) ; defaultProps . put ( name , value ) ; } public static final void setDefaultProperty ( String name , String value ) { setTemporaryProperty ( name , value ) ; } public static final void setBooleanProperty ( String name , boolean value ) { setProperty ( name , value ? "true" : "false" ) ; } public static final void unsetProperty ( String name ) { if ( defaultProps . get ( name ) != null ) props . put ( name , "" ) ; else props . remove ( name ) ; } public static final void resetProperty ( String name ) { props . remove ( name ) ; } public static void propertiesChanged ( ) { initKeyBindings ( ) ; int interval ; try { interval = Integer . parseInt ( getProperty ( "autosave" ) ) ; } catch ( NumberFormatException nf ) { interval = 30 ; } Autosave . setInterval ( interval ) ; saveCaret = getBooleanProperty ( "saveCaret" ) ; UIDefaults defaults = UIManager . getDefaults ( ) ; if ( jEdit . getBooleanProperty ( "globalColors" ) ) { Color background = new javax . swing . plaf . ColorUIResource ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ; Color foreground = new javax . swing . plaf . ColorUIResource ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.fgColor" ) ) ) ; Color caretColor = new javax . swing . plaf . ColorUIResource ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.caretColor" ) ) ) ; Color selectionColor = new javax . swing . plaf . ColorUIResource ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.selectionColor" ) ) ) ; String [ ] prefixes = { "TextField" , "TextArea" , "List" , "Table" } ; for ( int i = 0 ; i < prefixes . length ; i ++ ) { String prefix = prefixes [ i ] ; defaults . put ( prefix + ".disabledBackground" , background ) ; defaults . put ( prefix + ".background" , background ) ; defaults . put ( prefix + ".disabledForeground" , foreground ) ; defaults . put ( prefix + ".foreground" , foreground ) ; defaults . put ( prefix + ".caretForeground" , caretColor ) ; defaults . put ( prefix + ".selectionForeground" , foreground ) ; defaults . put ( prefix + ".selectionBackground" , selectionColor ) ; } defaults . put ( "Tree.background" , background ) ; defaults . put ( "Tree.foreground" , foreground ) ; defaults . put ( "Tree.textBackground" , background ) ; defaults . put ( "Tree.textForeground" , foreground ) ; defaults . put ( "Tree.selectionForeground" , foreground ) ; defaults . put ( "Tree.selectionBackground" , selectionColor ) ; } String family = jEdit . getProperty ( "view.font" ) ; int size ; try { size = Integer . parseInt ( jEdit . getProperty ( "view.fontsize" ) ) ; } catch ( NumberFormatException nf ) { size = 14 ; } int style ; try { style = Integer . parseInt ( jEdit . getProperty ( "view.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { style = Font . PLAIN ; } Font font = new Font ( family , style , size ) ; defaults . put ( "TextArea.font" , font ) ; defaults . put ( "TextPane.font" , font ) ; EditBus . send ( new PropertiesChanged ( null ) ) ; } public static String [ ] getNotLoadedPluginJARs ( ) { Vector returnValue = new Vector ( ) ; if ( jEditHome != null ) { String systemPluginDir = MiscUtilities . constructPath ( jEditHome , "jars" ) ; String [ ] list = new File ( systemPluginDir ) . list ( ) ; if ( list != null ) getNotLoadedPluginJARs ( returnValue , systemPluginDir , list ) ; } if ( settingsDirectory != null ) { String userPluginDir = MiscUtilities . constructPath ( settingsDirectory , "jars" ) ; String [ ] list = new File ( userPluginDir ) . list ( ) ; if ( list != null ) { getNotLoadedPluginJARs ( returnValue , userPluginDir , list ) ; } } String [ ] _returnValue = new String [ returnValue . size ( ) ] ; returnValue . copyInto ( _returnValue ) ; return _returnValue ; } public static EditPlugin getPlugin ( String name ) { EditPlugin [ ] plugins = getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { if ( plugins [ i ] . getClassName ( ) . equals ( name ) ) return plugins [ i ] ; } return null ; } public static EditPlugin [ ] getPlugins ( ) { Vector vector = new Vector ( ) ; for ( int i = 0 ; i < jars . size ( ) ; i ++ ) { ( ( EditPlugin . JAR ) jars . elementAt ( i ) ) . getPlugins ( vector ) ; } plugins . getPlugins ( vector ) ; EditPlugin [ ] array = new EditPlugin [ vector . size ( ) ] ; vector . copyInto ( array ) ; return array ; } public static EditPlugin . JAR [ ] getPluginJARs ( ) { EditPlugin . JAR [ ] array = new EditPlugin . JAR [ jars . size ( ) ] ; jars . copyInto ( array ) ; return array ; } public static EditPlugin . JAR getPluginJAR ( String path ) { for ( int i = 0 ; i < jars . size ( ) ; i ++ ) { EditPlugin . JAR jar = ( EditPlugin . JAR ) jars . elementAt ( i ) ; if ( jar . getPath ( ) . equals ( path ) ) return jar ; } return null ; } public static void addPluginJAR ( EditPlugin . JAR plugin ) { jars . addElement ( plugin ) ; } public static void addAction ( EditAction action ) { actionHash . put ( action . getName ( ) , action ) ; } public static EditAction getAction ( String action ) { return ( EditAction ) actionHash . get ( action ) ; } public static EditAction [ ] getActions ( ) { EditAction [ ] actions = new EditAction [ actionHash . size ( ) ] ; Enumeration enum = actionHash . elements ( ) ; int i = 0 ; while ( enum . hasMoreElements ( ) ) { actions [ i ++ ] = ( EditAction ) enum . nextElement ( ) ; } return actions ; } public static void reloadModes ( ) { modes = new Vector ( 50 ) ; if ( jEditHome == null ) loadModeCatalog ( "/modes/catalog" , true ) ; else { loadModeCatalog ( MiscUtilities . constructPath ( jEditHome , "modes" , "catalog" ) , false ) ; } if ( settingsDirectory != null ) { File userModeDir = new File ( MiscUtilities . constructPath ( settingsDirectory , "modes" ) ) ; if ( ! userModeDir . exists ( ) ) userModeDir . mkdirs ( ) ; File userCatalog = new File ( MiscUtilities . constructPath ( settingsDirectory , "modes" , "catalog" ) ) ; if ( ! userCatalog . exists ( ) ) { try { FileWriter out = new FileWriter ( userCatalog ) ; out . write ( jEdit . getProperty ( "defaultCatalog" ) ) ; out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , io ) ; } } loadModeCatalog ( userCatalog . getPath ( ) , false ) ; } Buffer buffer = buffersFirst ; while ( buffer != null ) { buffer . setMode ( ) ; buffer = buffer . next ; } } public static Mode getMode ( String name ) { for ( int i = 0 ; i < modes . size ( ) ; i ++ ) { Mode mode = ( Mode ) modes . elementAt ( i ) ; if ( mode . getName ( ) . equals ( name ) ) return mode ; } return null ; } public static Mode [ ] getModes ( ) { Mode [ ] array = new Mode [ modes . size ( ) ] ; modes . copyInto ( array ) ; return array ; } public static void showOpenFileDialog ( View view ) { showOpenFileDialog ( view , null ) ; } public static void showOpenFileWithOtherEncodingDialog ( View view ) { String encoding = GUIUtilities . input ( view , "encoding-prompt" , null , jEdit . getProperty ( "buffer.encoding" , System . getProperty ( "file.encoding" ) ) ) ; if ( encoding == null ) return ; Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) { recorder . record ( "props = new Hashtable();" ) ; recorder . record ( "props.put(\"encoding\",\"" + encoding + "\");" ) ; recorder . record ( "jEdit.showOpenFileDialog(view,props);" ) ; } Hashtable props = new Hashtable ( ) ; props . put ( Buffer . ENCODING , encoding ) ; showOpenFileDialog ( view , props ) ; } public static void showOpenFileDialog ( View view , Hashtable props ) { String [ ] files = GUIUtilities . showVFSFileDialog ( view , null , VFSBrowser . OPEN_DIALOG , true ) ; Buffer buffer = null ; if ( files != null ) { for ( int i = 0 ; i < files . length ; i ++ ) { Buffer newBuffer = openFile ( null , null , files [ i ] , false , props ) ; if ( newBuffer != null ) buffer = newBuffer ; } } if ( buffer != null ) view . setBuffer ( buffer ) ; } public static String restoreOpenFiles ( ) { if ( settingsDirectory == null ) return null ; File session = new File ( MiscUtilities . constructPath ( settingsDirectory , "session" ) ) ; if ( ! session . exists ( ) ) return null ; String splitConfig = null ; try { BufferedReader in = new BufferedReader ( new FileReader ( session ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "splits\t" ) ) splitConfig = line . substring ( 7 ) ; else openFile ( null , line ) ; } in . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , "Error while loading " + session ) ; Log . log ( Log . ERROR , jEdit . class , io ) ; } return splitConfig ; } public static void saveOpenFiles ( View view ) { if ( settingsDirectory == null ) return ; view . getEditPane ( ) . saveCaretInfo ( ) ; Buffer current = view . getBuffer ( ) ; File session = new File ( MiscUtilities . constructPath ( settingsDirectory , "session" ) ) ; try { String lineSep = System . getProperty ( "line.separator" ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( session ) ) ; Buffer buffer = buffersFirst ; while ( buffer != null ) { out . write ( buffer . getPath ( ) ) ; out . write ( lineSep ) ; buffer = buffer . next ; } out . write ( "splits\t" ) ; out . write ( view . getSplitConfig ( ) ) ; out . write ( lineSep ) ; out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , "Error while saving " + session ) ; Log . log ( Log . ERROR , jEdit . class , io ) ; } } public static Buffer openFiles ( View view , String parent , String [ ] args ) { Buffer retVal = null ; Buffer lastBuffer = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg == null ) continue ; else if ( arg . startsWith ( "+line:" ) || arg . startsWith ( "+marker:" ) ) { if ( lastBuffer != null ) gotoMarker ( view , lastBuffer , arg ) ; continue ; } lastBuffer = openFile ( null , parent , arg , false , null ) ; if ( retVal == null && lastBuffer != null ) retVal = lastBuffer ; } if ( view != null && retVal != null ) view . setBuffer ( retVal ) ; return retVal ; } public static Buffer openFile ( View view , String path ) { return openFile ( view , null , path , false , new Hashtable ( ) ) ; } public static Buffer openFile ( View view , String parent , String path , boolean readOnly , boolean newFile ) { return openFile ( view , parent , path , newFile , new Hashtable ( ) ) ; } public static Buffer openFile ( View view , String parent , String path , boolean readOnly , boolean newFile , Hashtable props ) { return openFile ( view , parent , path , newFile , props ) ; } public static Buffer openFile ( final View view , String parent , String path , boolean newFile , Hashtable props ) { if ( view != null && parent == null ) { File file = view . getBuffer ( ) . getFile ( ) ; if ( file != null ) parent = file . getParent ( ) ; } String protocol ; if ( MiscUtilities . isURL ( path ) ) { protocol = MiscUtilities . getProtocolOfURL ( path ) ; if ( protocol . equals ( "file" ) ) path = path . substring ( 5 ) ; } else protocol = "file" ; if ( protocol . equals ( "file" ) ) path = MiscUtilities . constructPath ( parent , path ) ; Buffer buffer = getBuffer ( path ) ; if ( buffer != null ) { if ( view != null ) view . setBuffer ( buffer ) ; return buffer ; } if ( props == null ) props = new Hashtable ( ) ; BufferHistory . Entry entry = BufferHistory . getEntry ( path ) ; if ( entry != null && saveCaret && props . get ( Buffer . CARET ) == null ) { int caret = entry . caret ; props . put ( Buffer . CARET , new Integer ( entry . caret ) ) ; if ( entry . selection != null ) { props . put ( Buffer . SELECTION , entry . getSelection ( ) ) ; } } if ( entry != null && props . get ( Buffer . ENCODING ) == null ) { if ( entry . encoding != null ) props . put ( Buffer . ENCODING , entry . encoding ) ; } final Buffer newBuffer = new Buffer ( view , path , newFile , false , props ) ; if ( ! newBuffer . load ( view , false ) ) return null ; addBufferToList ( newBuffer ) ; EditBus . send ( new BufferUpdate ( newBuffer , view , BufferUpdate . CREATED ) ) ; if ( view != null ) view . setBuffer ( newBuffer ) ; return newBuffer ; } public static Buffer openTemporary ( View view , String parent , String path , boolean newFile ) { if ( view != null && parent == null ) { File file = view . getBuffer ( ) . getFile ( ) ; if ( file != null ) parent = file . getParent ( ) ; } String protocol ; if ( MiscUtilities . isURL ( path ) ) { protocol = MiscUtilities . getProtocolOfURL ( path ) ; if ( protocol . equals ( "file" ) ) path = path . substring ( 5 ) ; } else protocol = "file" ; if ( protocol . equals ( "file" ) ) path = MiscUtilities . constructPath ( parent , path ) ; Buffer buffer = getBuffer ( path ) ; if ( buffer != null ) return buffer ; buffer = new Buffer ( null , path , newFile , true , new Hashtable ( ) ) ; if ( ! buffer . load ( view , false ) ) return null ; else return buffer ; } public static void commitTemporary ( Buffer buffer ) { if ( ! buffer . isTemporary ( ) ) return ; buffer . setMode ( ) ; buffer . propertiesChanged ( ) ; addBufferToList ( buffer ) ; buffer . commitTemporary ( ) ; EditBus . send ( new BufferUpdate ( buffer , null , BufferUpdate . CREATED ) ) ; } public static Buffer newFile ( View view ) { return newFile ( view , null ) ; } public static Buffer newFile ( View view , String dir ) { if ( dir != null && buffersFirst != null && buffersFirst == buffersLast && buffersFirst . isUntitled ( ) && ! buffersFirst . isDirty ( ) ) { closeBuffer ( view , buffersFirst ) ; return buffersFirst ; } int untitledCount = 0 ; Buffer buffer = buffersFirst ; while ( buffer != null ) { if ( buffer . getName ( ) . startsWith ( "Untitled-" ) ) { try { untitledCount = Math . max ( untitledCount , Integer . parseInt ( buffer . getName ( ) . substring ( 9 ) ) ) ; } catch ( NumberFormatException nf ) { } } buffer = buffer . next ; } return openFile ( view , dir , "Untitled-" + ( untitledCount + 1 ) , true , null ) ; } public static boolean closeBuffer ( View view , Buffer buffer ) { if ( buffer . isPerformingIO ( ) ) { VFSManager . waitForRequests ( ) ; if ( VFSManager . errorOccurred ( ) ) return false ; } if ( buffer . isDirty ( ) ) { Object [ ] args = { buffer . getName ( ) } ; int result = GUIUtilities . confirm ( view , "notsaved" , args , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { if ( ! buffer . save ( view , null , true ) ) return false ; } else if ( result != JOptionPane . NO_OPTION ) return false ; } _closeBuffer ( view , buffer ) ; return true ; } public static void _closeBuffer ( View view , Buffer buffer ) { if ( buffer . isClosed ( ) ) { return ; } if ( ! buffer . isNewFile ( ) ) { view . getEditPane ( ) . saveCaretInfo ( ) ; Integer _caret = ( Integer ) buffer . getProperty ( Buffer . CARET ) ; int caret = ( _caret == null ? 0 : _caret . intValue ( ) ) ; BufferHistory . setEntry ( buffer . getPath ( ) , caret , ( Selection [ ] ) buffer . getProperty ( Buffer . SELECTION ) , ( String ) buffer . getProperty ( Buffer . ENCODING ) ) ; } removeBufferFromList ( buffer ) ; buffer . close ( ) ; EditBus . send ( new BufferUpdate ( buffer , view , BufferUpdate . CLOSED ) ) ; if ( buffersFirst == null && buffersLast == null ) newFile ( view ) ; } public static boolean closeAllBuffers ( View view ) { return closeAllBuffers ( view , false ) ; } public static boolean closeAllBuffers ( View view , boolean isExiting ) { boolean dirty = false ; Buffer buffer = buffersFirst ; while ( buffer != null ) { if ( buffer . isDirty ( ) ) { dirty = true ; break ; } buffer = buffer . next ; } if ( dirty ) { boolean ok = new CloseDialog ( view ) . isOK ( ) ; if ( ! ok ) return false ; } VFSManager . waitForRequests ( ) ; if ( VFSManager . errorOccurred ( ) ) return false ; buffer = buffersFirst ; buffersFirst = buffersLast = null ; bufferCount = 0 ; while ( buffer != null ) { if ( ! buffer . isNewFile ( ) ) { Integer _caret = ( Integer ) buffer . getProperty ( Buffer . CARET ) ; int caret = ( _caret == null ? 0 : _caret . intValue ( ) ) ; BufferHistory . setEntry ( buffer . getPath ( ) , caret , ( Selection [ ] ) buffer . getProperty ( Buffer . SELECTION ) , ( String ) buffer . getProperty ( Buffer . ENCODING ) ) ; } buffer . close ( ) ; if ( ! isExiting ) { EditBus . send ( new BufferUpdate ( buffer , view , BufferUpdate . CLOSED ) ) ; } buffer = buffer . next ; } if ( ! isExiting ) newFile ( view ) ; return true ; } public static void saveAllBuffers ( View view , boolean confirm ) { if ( confirm ) { int result = GUIUtilities . confirm ( view , "saveall" , null , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } Buffer buffer = buffersFirst ; while ( buffer != null ) { if ( buffer . isDirty ( ) ) buffer . save ( view , null , true ) ; buffer = buffer . next ; } } public static void reloadAllBuffers ( final View view , boolean confirm ) { if ( confirm ) { int result = GUIUtilities . confirm ( view , "reload-all" , null , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } View _view = viewsFirst ; while ( _view != null ) { EditPane [ ] panes = _view . getEditPanes ( ) ; for ( int i = 0 ; i < panes . length ; i ++ ) { panes [ i ] . saveCaretInfo ( ) ; } _view = _view . next ; } Buffer [ ] buffers = jEdit . getBuffers ( ) ; for ( int i = 0 ; i < buffers . length ; i ++ ) { Buffer buffer = buffers [ i ] ; buffer . load ( view , true ) ; } } public static Buffer getBuffer ( String path ) { boolean caseInsensitiveFilesystem = ( File . separatorChar == '\\' || File . separatorChar == ':' ) ; Buffer buffer = buffersFirst ; while ( buffer != null ) { String _path = buffer . getPath ( ) ; if ( caseInsensitiveFilesystem ) { if ( _path . equalsIgnoreCase ( path ) ) return buffer ; } else { if ( _path . equals ( path ) ) return buffer ; } buffer = buffer . next ; } return null ; } public static Buffer [ ] getBuffers ( ) { Buffer [ ] buffers = new Buffer [ bufferCount ] ; Buffer buffer = buffersFirst ; for ( int i = 0 ; i < bufferCount ; i ++ ) { buffers [ i ] = buffer ; buffer = buffer . next ; } return buffers ; } public static int getBufferCount ( ) { return bufferCount ; } public static Buffer getFirstBuffer ( ) { return buffersFirst ; } public static Buffer getLastBuffer ( ) { return buffersLast ; } public static InputHandler getInputHandler ( ) { return inputHandler ; } public static View newView ( View view , Buffer buffer ) { if ( view != null ) { view . showWaitCursor ( ) ; view . getEditPane ( ) . saveCaretInfo ( ) ; } View newView = new View ( buffer , null ) ; newView . pack ( ) ; if ( view != null ) { GUIUtilities . saveGeometry ( view , "view" ) ; view . hideWaitCursor ( ) ; } GUIUtilities . loadGeometry ( newView , "view" ) ; addViewToList ( newView ) ; EditBus . send ( new ViewUpdate ( newView , ViewUpdate . CREATED ) ) ; newView . show ( ) ; return newView ; } public static View newView ( View view ) { return newView ( view , view . getSplitConfig ( ) ) ; } public static View newView ( View view , String splitConfig ) { if ( view != null ) { view . showWaitCursor ( ) ; view . getEditPane ( ) . saveCaretInfo ( ) ; } View newView = new View ( null , splitConfig ) ; newView . pack ( ) ; if ( view != null ) { GUIUtilities . saveGeometry ( view , "view" ) ; view . hideWaitCursor ( ) ; } GUIUtilities . loadGeometry ( newView , "view" ) ; addViewToList ( newView ) ; EditBus . send ( new ViewUpdate ( newView , ViewUpdate . CREATED ) ) ; newView . show ( ) ; return newView ; } public static void closeView ( View view ) { closeView ( view , true ) ; } public static View [ ] getViews ( ) { View [ ] views = new View [ viewCount ] ; View view = viewsFirst ; for ( int i = 0 ; i < viewCount ; i ++ ) { views [ i ] = view ; view = view . next ; } return views ; } public static int getViewCount ( ) { return viewCount ; } public static View getFirstView ( ) { return viewsFirst ; } public static View getLastView ( ) { return viewsLast ; } public static String getJEditHome ( ) { return jEditHome ; } public static String getSettingsDirectory ( ) { return settingsDirectory ; } public static void saveSettings ( ) { if ( settingsDirectory != null ) { File file = new File ( MiscUtilities . constructPath ( settingsDirectory , "recent.xml" ) ) ; if ( file . exists ( ) && file . lastModified ( ) != recentModTime ) { Log . log ( Log . WARNING , jEdit . class , file + " changed" + " on disk; will not save recent files" ) ; } else { BufferHistory . save ( file ) ; } recentModTime = file . lastModified ( ) ; file = new File ( MiscUtilities . constructPath ( settingsDirectory , "history" ) ) ; if ( file . exists ( ) && file . lastModified ( ) != historyModTime ) { Log . log ( Log . WARNING , jEdit . class , file + " changed" + " on disk; will not save history" ) ; } else { HistoryModel . saveHistory ( file ) ; } historyModTime = file . lastModified ( ) ; SearchAndReplace . save ( ) ; Abbrevs . save ( ) ; FavoritesVFS . saveFavorites ( ) ; file = new File ( MiscUtilities . constructPath ( settingsDirectory , "properties" ) ) ; if ( file . exists ( ) && file . lastModified ( ) != propsModTime ) { Log . log ( Log . WARNING , jEdit . class , file + " changed" + " on disk; will not save user properties" ) ; } else { try { OutputStream out = new FileOutputStream ( file ) ; props . save ( out , "jEdit properties" ) ; out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , io ) ; } propsModTime = file . lastModified ( ) ; } } } public static void exit ( View view , boolean reallyExit ) { VFSManager . waitForRequests ( ) ; EditBus . send ( new EditorExitRequested ( view ) ) ; reallyExit |= ! background ; saveOpenFiles ( view ) ; if ( ! closeAllBuffers ( view , reallyExit ) ) return ; if ( ! reallyExit ) { view = viewsFirst ; while ( view != null ) { closeView ( view , false ) ; view = view . next ; } saveSettings ( ) ; return ; } view . close ( ) ; Autosave . stop ( ) ; if ( server != null ) server . stopServer ( ) ; EditPlugin [ ] plugins = getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { plugins [ i ] . stop ( ) ; } EditBus . send ( new EditorExiting ( null ) ) ; saveSettings ( ) ; Log . closeStream ( ) ; System . exit ( 0 ) ; } static void updatePosition ( Buffer buffer ) { if ( sortBuffers ) { removeBufferFromList ( buffer ) ; addBufferToList ( buffer ) ; } } public static void addMode ( Mode mode ) { Log . log ( Log . DEBUG , jEdit . class , "Adding edit mode " + mode . getName ( ) ) ; modes . addElement ( mode ) ; } static void loadMode ( Mode mode ) { Object fileName = mode . getProperty ( "file" ) ; Log . log ( Log . NOTICE , jEdit . class , "Loading edit mode " + fileName ) ; XmlParser parser = new XmlParser ( ) ; XModeHandler xmh = new XModeHandler ( parser , mode . getName ( ) , fileName . toString ( ) ) ; parser . setHandler ( xmh ) ; try { Reader grammar ; if ( fileName instanceof URL ) { grammar = new BufferedReader ( new InputStreamReader ( ( ( URL ) fileName ) . openStream ( ) ) ) ; } else { grammar = new BufferedReader ( new FileReader ( ( String ) fileName ) ) ; } parser . parse ( null , null , grammar ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; if ( e instanceof XmlException ) { XmlException xe = ( XmlException ) e ; int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Object [ ] args = { fileName , new Integer ( line ) , message } ; GUIUtilities . error ( null , "xmode-parse" , args ) ; } TokenMarker marker = new TokenMarker ( ) ; marker . addRuleSet ( "MAIN" , new ParserRuleSet ( ) ) ; mode . setTokenMarker ( marker ) ; } } static void loadProps ( InputStream in , boolean def ) throws IOException { in = new BufferedInputStream ( in ) ; if ( def ) defaultProps . load ( in ) ; else props . load ( in ) ; in . close ( ) ; } static void addPlugin ( EditPlugin plugin ) { plugins . addPlugin ( plugin ) ; } static boolean loadActions ( String path , Reader in , boolean plugin ) { Log . log ( Log . DEBUG , jEdit . class , "Loading actions from " + path ) ; ActionListHandler ah = new ActionListHandler ( path , plugin ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( ah ) ; try { parser . parse ( null , null , in ) ; return true ; } catch ( XmlException xe ) { int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , jEdit . class , path + ":" + line + ": " + message ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; } return false ; } private static String jEditHome ; private static String settingsDirectory ; private static long propsModTime , historyModTime , recentModTime ; private static Properties defaultProps ; private static Properties props ; private static EditServer server ; private static boolean background ; private static Hashtable actionHash ; private static Vector jars ; private static EditPlugin . JAR plugins ; private static Vector modes ; private static Vector recent ; private static boolean saveCaret ; private static InputHandler inputHandler ; private static boolean sortBuffers ; private static boolean sortByName ; private static int bufferCount ; private static Buffer buffersFirst ; private static Buffer buffersLast ; private static int viewCount ; private static View viewsFirst ; private static View viewsLast ; private jEdit ( ) { } private static void usage ( ) { System . out . println ( "Usage: jedit [<options>] [<files>]" ) ; System . out . println ( "	<file> +marker:<marker>: Positions caret" + " at marker <marker>" ) ; System . out . println ( "	<file> +line:<line>: Positions caret" + " at line number <line>" ) ; System . out . println ( "	--: End of options" ) ; System . out . println ( "	-background: Run in background mode" ) ; System . out . println ( "	-norestore: Don't restore previously open files" ) ; System . out . println ( "	-run=<script>: Run the specified BeanShell script" ) ; System . out . println ( "	-server: Read/write server" + " info from/to $HOME/.jedit/server" ) ; System . out . println ( "	-server=<name>: Read/write server" + " info from/to $HOME/.jedit/<name>" ) ; System . out . println ( "	-noserver: Don't start edit server" ) ; System . out . println ( "	-settings=<path>: Load user-specific" + " settings from <path>" ) ; System . out . println ( "	-nosettings: Don't load user-specific" + " settings" ) ; System . out . println ( "	-nostartupscripts: Don't run startup scripts" ) ; System . out . println ( "	-version: Print jEdit version and exit" ) ; System . out . println ( "	-usage: Print this message and exit" ) ; System . out . println ( ) ; System . out . println ( "To set minimum activity log level," + " specify a number as the first" ) ; System . out . println ( "command line parameter" + " (1-9, 1 = print everything, 9 = fatal errors only)" ) ; System . out . println ( ) ; System . out . println ( "Report bugs to Slava Pestov <slava@jedit.org>." ) ; } private static void version ( ) { System . out . println ( "jEdit " + getVersion ( ) ) ; } private static String makeServerScript ( boolean restore , String [ ] args , String scriptFile ) { StringBuffer script = new StringBuffer ( ) ; String userDir = System . getProperty ( "user.dir" ) ; script . append ( "parent = \"" ) ; script . append ( MiscUtilities . charsToEscapes ( userDir ) ) ; script . append ( "\";\n" ) ; script . append ( "args = new String[" ) ; script . append ( args . length ) ; script . append ( "];\n" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { script . append ( "args[" ) ; script . append ( i ) ; script . append ( "] = " ) ; if ( args [ i ] == null ) script . append ( "null" ) ; else { script . append ( '"' ) ; script . append ( MiscUtilities . charsToEscapes ( args [ i ] ) ) ; script . append ( '"' ) ; } script . append ( ";\n" ) ; } script . append ( "EditServer.handleClient(" + restore + ",parent,args);\n" ) ; if ( scriptFile != null ) { scriptFile = MiscUtilities . constructPath ( userDir , scriptFile ) ; script . append ( "BeanShell.runScript(null,\"" + MiscUtilities . charsToEscapes ( scriptFile ) + "\",false,false);\n" ) ; } return script . toString ( ) ; } private static void initMisc ( ) { System . getProperties ( ) . put ( "java.protocol.handler.pkgs" , "org.gjt.sp.jedit.proto|" + System . getProperty ( "java.protocol.handler.pkgs" , "" ) ) ; inputHandler = new DefaultInputHandler ( null ) ; jEditHome = System . getProperty ( "jedit.home" ) ; if ( jEditHome == null ) { String classpath = System . getProperty ( "java.class.path" ) ; int index = classpath . toLowerCase ( ) . indexOf ( "jedit.jar" ) ; int start = classpath . lastIndexOf ( File . pathSeparator , index ) + 1 ; if ( index > start ) { jEditHome = classpath . substring ( start , index - 1 ) ; } else { { jEditHome = System . getProperty ( "user.dir" ) ; } } } Log . log ( Log . MESSAGE , jEdit . class , "jEdit home directory is " + jEditHome ) ; actionHash = new Hashtable ( ) ; plugins = new EditPlugin . JAR ( null , null ) ; jars = new Vector ( ) ; } private static void initSystemProperties ( ) { defaultProps = props = new Properties ( ) ; try { loadProps ( jEdit . class . getResourceAsStream ( "/org/gjt/sp/jedit/jedit.props" ) , true ) ; loadProps ( jEdit . class . getResourceAsStream ( "/org/gjt/sp/jedit/jedit_gui.props" ) , true ) ; loadProps ( jEdit . class . getResourceAsStream ( "/org/gjt/sp/jedit/jedit_keys.props" ) , true ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , "Error while loading system properties!" ) ; Log . log ( Log . ERROR , jEdit . class , "One of the following property files could not be loaded:\n" + "- jedit.props\n" + "- jedit_gui.props\n" + "- jedit_keys.props\n" + "jedit.jar is probably corrupt." ) ; Log . log ( Log . ERROR , jEdit . class , e ) ; System . exit ( 1 ) ; } } private static void initSiteProperties ( ) { String siteSettingsDirectory = MiscUtilities . constructPath ( jEditHome , "properties" ) ; File siteSettings = new File ( siteSettingsDirectory ) ; if ( ! ( siteSettings . exists ( ) && siteSettings . isDirectory ( ) ) ) return ; String [ ] snippets = siteSettings . list ( ) ; if ( snippets == null ) return ; MiscUtilities . quicksort ( snippets , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < snippets . length ; ++ i ) { String snippet = snippets [ i ] ; if ( ! snippet . toLowerCase ( ) . endsWith ( ".props" ) ) continue ; try { String path = MiscUtilities . constructPath ( siteSettingsDirectory , snippet ) ; Log . log ( Log . DEBUG , jEdit . class , "Loading site snippet: " + path ) ; loadProps ( new FileInputStream ( new File ( path ) ) , true ) ; } catch ( FileNotFoundException fnf ) { Log . log ( Log . DEBUG , jEdit . class , fnf ) ; } catch ( IOException e ) { Log . log ( Log . ERROR , jEdit . class , "Cannot load site snippet " + snippet ) ; Log . log ( Log . ERROR , jEdit . class , e ) ; } } } private static void initActions ( ) { Reader in = new BufferedReader ( new InputStreamReader ( jEdit . class . getResourceAsStream ( "actions.xml" ) ) ) ; if ( ! loadActions ( "actions.xml" , in , false ) ) System . exit ( 1 ) ; } private static void initPlugins ( ) { if ( jEditHome != null ) loadPlugins ( MiscUtilities . constructPath ( jEditHome , "jars" ) ) ; else { try { InputStream in = jEdit . class . getResourceAsStream ( "Firewall.props" ) ; if ( in != null ) { loadProps ( in , true ) ; Class clazz ; ClassLoader loader = jEdit . class . getClassLoader ( ) ; if ( loader != null ) clazz = loader . loadClass ( "FirewallPlugin" ) ; else clazz = Class . forName ( "FirewallPlugin" ) ; EditPlugin plugin = ( EditPlugin ) clazz . newInstance ( ) ; addPlugin ( plugin ) ; } } catch ( Throwable t ) { Log . log ( Log . ERROR , jEdit . class , "Could not load firewall plugin:" ) ; Log . log ( Log . ERROR , jEdit . class , t ) ; } } if ( settingsDirectory != null ) { File jarsDirectory = new File ( settingsDirectory , "jars" ) ; if ( ! jarsDirectory . exists ( ) ) jarsDirectory . mkdir ( ) ; loadPlugins ( jarsDirectory . getPath ( ) ) ; } } private static void initUserProperties ( ) { props = new Properties ( defaultProps ) ; if ( settingsDirectory != null ) { File file = new File ( MiscUtilities . constructPath ( settingsDirectory , "properties" ) ) ; propsModTime = file . lastModified ( ) ; try { loadProps ( new FileInputStream ( file ) , false ) ; } catch ( FileNotFoundException fnf ) { Log . log ( Log . DEBUG , jEdit . class , fnf ) ; } catch ( IOException e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; } } } private static void initPLAF ( ) { String lf = getProperty ( "lookAndFeel" ) ; try { if ( lf != null && lf . length ( ) != 0 ) UIManager . setLookAndFeel ( lf ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; } } private static void runStartupScripts ( File directory ) { if ( ! directory . isDirectory ( ) ) return ; String [ ] snippets = directory . list ( ) ; if ( snippets == null ) return ; MiscUtilities . quicksort ( snippets , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < snippets . length ; ++ i ) { String snippet = snippets [ i ] ; if ( ! snippet . toLowerCase ( ) . endsWith ( ".bsh" ) ) continue ; String path = new File ( directory , snippet ) . getPath ( ) ; BeanShell . runScript ( null , path , false , false ) ; } } private static void getNotLoadedPluginJARs ( Vector returnValue , String dir , String [ ] list ) { loop : for ( int i = 0 ; i < list . length ; i ++ ) { String name = list [ i ] ; if ( ! name . toLowerCase ( ) . endsWith ( ".jar" ) ) continue loop ; String path = MiscUtilities . constructPath ( dir , name ) ; for ( int j = 0 ; j < jars . size ( ) ; j ++ ) { EditPlugin . JAR jar = ( EditPlugin . JAR ) jars . elementAt ( j ) ; String jarPath = jar . getPath ( ) ; String jarName = MiscUtilities . getFileName ( jarPath ) ; if ( path . equals ( jarPath ) ) continue loop ; else if ( ! new File ( jarPath ) . exists ( ) && name . equals ( jarName ) ) continue loop ; } returnValue . addElement ( path ) ; } } private static void gotoMarker ( final View view , final Buffer buffer , final String marker ) { VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { int pos ; if ( marker . startsWith ( "+line:" ) ) { try { int line = Integer . parseInt ( marker . substring ( 6 ) ) ; Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line - 1 ) ; pos = lineElement . getStartOffset ( ) ; } catch ( Exception e ) { return ; } } else if ( marker . startsWith ( "+marker:" ) ) { if ( marker . length ( ) != 9 ) return ; Marker m = buffer . getMarker ( marker . charAt ( 8 ) ) ; if ( m == null ) return ; pos = m . getPosition ( ) ; } else throw new InternalError ( ) ; if ( view != null && view . getBuffer ( ) == buffer ) view . getTextArea ( ) . setCaretPosition ( pos ) ; else buffer . putProperty ( Buffer . CARET , new Integer ( pos ) ) ; } } ) ; } private static void addBufferToList ( Buffer buffer ) { if ( viewCount <= 1 && buffersFirst != null && buffersFirst == buffersLast && buffersFirst . isUntitled ( ) && ! buffersFirst . isDirty ( ) ) { Buffer oldBuffersFirst = buffersFirst ; buffersFirst = buffersLast = buffer ; EditBus . send ( new BufferUpdate ( oldBuffersFirst , null , BufferUpdate . CLOSED ) ) ; return ; } bufferCount ++ ; if ( buffersFirst == null ) { buffersFirst = buffersLast = buffer ; return ; } else if ( sortBuffers ) { String name1 = ( sortByName ? buffer . getName ( ) : buffer . getPath ( ) ) . toLowerCase ( ) ; Buffer _buffer = buffersFirst ; while ( _buffer != null ) { String name2 = ( sortByName ? _buffer . getName ( ) : _buffer . getPath ( ) ) . toLowerCase ( ) ; if ( name1 . compareTo ( name2 ) <= 0 ) { buffer . next = _buffer ; buffer . prev = _buffer . prev ; _buffer . prev = buffer ; if ( _buffer != buffersFirst ) buffer . prev . next = buffer ; else buffersFirst = buffer ; return ; } _buffer = _buffer . next ; } } buffer . prev = buffersLast ; buffersLast . next = buffer ; buffersLast = buffer ; } private static void removeBufferFromList ( Buffer buffer ) { bufferCount -- ; if ( buffer == buffersFirst && buffer == buffersLast ) { buffersFirst = buffersLast = null ; return ; } if ( buffer == buffersFirst ) { buffersFirst = buffer . next ; buffer . next . prev = null ; } else { buffer . prev . next = buffer . next ; } if ( buffer == buffersLast ) { buffersLast = buffersLast . prev ; buffer . prev . next = null ; } else { buffer . next . prev = buffer . prev ; } buffer . next = buffer . prev = null ; } private static void addViewToList ( View view ) { viewCount ++ ; if ( viewsFirst == null ) viewsFirst = viewsLast = view ; else { view . prev = viewsLast ; viewsLast . next = view ; viewsLast = view ; } } private static void removeViewFromList ( View view ) { viewCount -- ; if ( viewsFirst == viewsLast ) { viewsFirst = viewsLast = null ; return ; } if ( view == viewsFirst ) { viewsFirst = view . next ; view . next . prev = null ; } else { view . prev . next = view . next ; } if ( view == viewsLast ) { viewsLast = viewsLast . prev ; view . prev . next = null ; } else { view . next . prev = view . prev ; } } private static void closeView ( View view , boolean callExit ) { if ( viewsFirst == viewsLast && callExit ) exit ( view , false ) ; else { EditBus . send ( new ViewUpdate ( view , ViewUpdate . CLOSED ) ) ; view . close ( ) ; removeViewFromList ( view ) ; } } private static void loadModeCatalog ( String path , boolean resource ) { Log . log ( Log . MESSAGE , jEdit . class , "Loading mode catalog file " + path ) ; ModeCatalogHandler handler = new ModeCatalogHandler ( MiscUtilities . getParentOfPath ( path ) , resource ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( handler ) ; try { InputStream _in ; if ( resource ) _in = jEdit . class . getResourceAsStream ( path ) ; else _in = new FileInputStream ( path ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( _in ) ) ; parser . parse ( null , null , in ) ; } catch ( XmlException xe ) { int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , jEdit . class , path + ":" + line + ": " + message ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; } } private static void loadPlugins ( String directory ) { Log . log ( Log . NOTICE , jEdit . class , "Loading plugins from " + directory ) ; File file = new File ( directory ) ; if ( ! ( file . exists ( ) && file . isDirectory ( ) ) ) return ; String [ ] plugins = file . list ( ) ; if ( plugins == null ) return ; MiscUtilities . quicksort ( plugins , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { String plugin = plugins [ i ] ; if ( ! plugin . toLowerCase ( ) . endsWith ( ".jar" ) ) continue ; String path = MiscUtilities . constructPath ( directory , plugin ) ; if ( plugin . equals ( "EditBuddy.jar" ) || plugin . equals ( "PluginManager.jar" ) || plugin . equals ( "jaxp.jar" ) || plugin . equals ( "crimson.jar" ) ) { String [ ] args = { plugin } ; GUIUtilities . error ( null , "plugin.obsolete" , args ) ; continue ; } try { Log . log ( Log . DEBUG , jEdit . class , "Scanning JAR file: " + path ) ; new JARClassLoader ( path ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , "Cannot load" + " plugin " + plugin ) ; Log . log ( Log . ERROR , jEdit . class , io ) ; String [ ] args = { plugin , io . toString ( ) } ; GUIUtilities . error ( null , "plugin.load-error" , args ) ; } } } private static void initKeyBindings ( ) { inputHandler . removeAllKeyBindings ( ) ; EditAction [ ] actions = getActions ( ) ; for ( int i = 0 ; i < actions . length ; i ++ ) { EditAction action = actions [ i ] ; String shortcut1 = jEdit . getProperty ( action . getName ( ) + ".shortcut" ) ; if ( shortcut1 != null ) inputHandler . addKeyBinding ( shortcut1 , action ) ; String shortcut2 = jEdit . getProperty ( action . getName ( ) + ".shortcut2" ) ; if ( shortcut2 != null ) inputHandler . addKeyBinding ( shortcut2 , action ) ; } Vector macros = Macros . getMacroList ( ) ; for ( int i = 0 ; i < macros . size ( ) ; i ++ ) { Macros . Macro macro = ( Macros . Macro ) macros . elementAt ( i ) ; String shortcut1 = jEdit . getProperty ( macro . name + ".shortcut" ) ; if ( shortcut1 != null ) jEdit . getInputHandler ( ) . addKeyBinding ( shortcut1 , macro . action ) ; String shortcut2 = jEdit . getProperty ( macro . name + ".shortcut2" ) ; if ( shortcut2 != null ) jEdit . getInputHandler ( ) . addKeyBinding ( shortcut2 , macro . action ) ; } } } 	1	['99', '1', '0', '162', '325', '4043', '137', '48', '67', '0.915102041', '4367', '1', '7', '0', '0.059417706', '0', '0', '42.85858586', '56', '4.0707', '23']
package org . gjt . sp . jedit . search ; import bsh . NameSpace ; import gnu . regexp . * ; import javax . swing . text . Segment ; import org . gjt . sp . jedit . BeanShell ; import org . gjt . sp . jedit . MiscUtilities ; public class RESearchMatcher implements SearchMatcher { public static final RESyntax RE_SYNTAX_JEDIT = new RESyntax ( RESyntax . RE_SYNTAX_PERL5 ) . set ( RESyntax . RE_CHAR_CLASSES ) . setLineSeparator ( "\n" ) ; public RESearchMatcher ( String search , String replace , boolean ignoreCase , boolean beanshell , String replaceMethod ) throws Exception { this . replace = MiscUtilities . escapesToChars ( replace ) ; this . beanshell = beanshell ; this . replaceMethod = replaceMethod ; replaceNS = new NameSpace ( BeanShell . getNameSpace ( ) , "search and replace" ) ; re = new RE ( search , ( ignoreCase ? RE . REG_ICASE : 0 ) | RE . REG_MULTILINE , RE_SYNTAX_JEDIT ) ; } public int [ ] nextMatch ( Segment text ) { REMatch match = re . getMatch ( new CharIndexedSegment ( text , 0 ) ) ; if ( match == null ) return null ; int start = match . getStartIndex ( ) ; int end = match . getEndIndex ( ) ; if ( start == end ) { return null ; } int [ ] result = { start , end } ; return result ; } public String substitute ( String text ) throws Exception { REMatch match = re . getMatch ( text ) ; if ( match == null ) return null ; if ( beanshell ) { int count = match . getSubCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) replaceNS . setVariable ( "_" + i , match . toString ( i ) ) ; Object obj = BeanShell . runCachedBlock ( replaceMethod , null , replaceNS ) ; if ( obj == null ) return null ; else return obj . toString ( ) ; } else return match . substituteInto ( replace ) ; } private String replace ; private RE re ; private boolean beanshell ; private String replaceMethod ; private NameSpace replaceNS ; } 	1	['4', '1', '0', '11', '25', '0', '2', '9', '3', '0.611111111', '145', '0.833333333', '3', '0', '0.583333333', '0', '0', '33.75', '3', '1', '4']
package org . gjt . sp . jedit . search ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . text . Segment ; import javax . swing . tree . * ; import javax . swing . SwingUtilities ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . Buffer ; import org . gjt . sp . jedit . GUIUtilities ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . View ; import org . gjt . sp . util . * ; public class HyperSearchRequest extends WorkRequest { public HyperSearchRequest ( View view , SearchMatcher matcher , HyperSearchResults results ) { this . view = view ; this . matcher = matcher ; this . results = results ; this . resultTreeModel = results . getTreeModel ( ) ; this . resultTreeRoot = ( DefaultMutableTreeNode ) resultTreeModel . getRoot ( ) ; } public void run ( ) { SearchFileSet fileset = SearchAndReplace . getSearchFileSet ( ) ; setProgressMaximum ( fileset . getBufferCount ( ) ) ; setStatus ( jEdit . getProperty ( "hypersearch.status" ) ) ; int resultCount = 0 ; int bufferCount = 0 ; try { int current = 0 ; Buffer buffer = fileset . getFirstBuffer ( view ) ; if ( buffer != null ) { do { setProgressValue ( ++ current ) ; int thisResultCount = doHyperSearch ( buffer , matcher ) ; if ( thisResultCount != 0 ) { bufferCount ++ ; resultCount += thisResultCount ; } } while ( ( buffer = fileset . getNextBuffer ( view , buffer ) ) != null ) ; } } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; VFSManager . error ( view , "searcherror" , args ) ; } catch ( WorkThread . Abort a ) { } finally { final int _resultCount = resultCount ; final int _bufferCount = bufferCount ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { results . searchDone ( _resultCount , _bufferCount ) ; } } ) ; } } private View view ; private SearchMatcher matcher ; private HyperSearchResults results ; private DefaultTreeModel resultTreeModel ; private DefaultMutableTreeNode resultTreeRoot ; private int doHyperSearch ( Buffer buffer , SearchMatcher matcher ) throws Exception { setAbortable ( false ) ; int resultCount = 0 ; final DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode ( buffer . getPath ( ) ) ; try { buffer . readLock ( ) ; Element map = buffer . getDefaultRootElement ( ) ; Segment text = new Segment ( ) ; int offset = 0 ; int length = buffer . getLength ( ) ; int line = - 1 ; loop : for ( ; ; ) { buffer . getText ( offset , length - offset , text ) ; int [ ] match = matcher . nextMatch ( text ) ; if ( match == null ) break loop ; offset += match [ 1 ] ; int newLine = map . getElementIndex ( offset ) ; if ( line == newLine ) { continue loop ; } line = newLine ; resultCount ++ ; bufferNode . insert ( new DefaultMutableTreeNode ( new HyperSearchResult ( buffer , line ) , false ) , bufferNode . getChildCount ( ) ) ; } } finally { buffer . readUnlock ( ) ; } if ( resultCount != 0 ) { resultTreeRoot . insert ( bufferNode , resultTreeRoot . getChildCount ( ) ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { resultTreeModel . reload ( resultTreeRoot ) ; } } ) ; } setAbortable ( true ) ; return resultCount ; } } 	1	['6', '2', '0', '14', '40', '3', '3', '14', '2', '0.72', '252', '1', '3', '0.5', '0.305555556', '1', '1', '40.16666667', '10', '2.3333', '3']
package org . gjt . sp . jedit . gui ; import javax . swing . JOptionPane ; import javax . swing . JPopupMenu ; import java . awt . event . * ; import java . awt . Component ; import java . util . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public abstract class InputHandler extends KeyAdapter { public InputHandler ( View view ) { this . view = view ; } public abstract void addKeyBinding ( String keyBinding , EditAction action ) ; public abstract void removeKeyBinding ( String keyBinding ) ; public abstract void removeAllKeyBindings ( ) ; public boolean isPrefixActive ( ) { return false ; } public boolean isRepeatEnabled ( ) { return repeat ; } public void setRepeatEnabled ( boolean repeat ) { this . repeat = repeat ; repeatCount = 0 ; view . getStatus ( ) . setMessage ( null ) ; } public int getRepeatCount ( ) { return ( repeat && repeatCount > 0 ? repeatCount : 1 ) ; } public void setRepeatCount ( int repeatCount ) { repeat = true ; this . repeatCount = repeatCount ; view . getStatus ( ) . setMessage ( null ) ; } public EditAction getLastAction ( ) { return lastAction ; } public int getLastActionCount ( ) { return lastActionCount ; } public void readNextChar ( String msg , String code ) { view . getStatus ( ) . setMessage ( msg ) ; readNextChar ( code ) ; } public void readNextChar ( String code ) { readNextChar = code ; } public void invokeAction ( EditAction action ) { Buffer buffer = view . getBuffer ( ) ; buffer . endCompoundEdit ( ) ; if ( lastAction == action ) lastActionCount ++ ; else { lastAction = action ; lastActionCount = 1 ; } boolean _repeat = repeat ; int _repeatCount = getRepeatCount ( ) ; if ( action . noRepeat ( ) || _repeatCount == 1 ) action . invoke ( view ) ; else { if ( _repeatCount > REPEAT_COUNT_THRESHOLD ) { String label = jEdit . getProperty ( action . getName ( ) + ".label" ) ; if ( label == null ) label = action . getName ( ) ; else label = GUIUtilities . prettifyMenuLabel ( label ) ; Object [ ] pp = { label , new Integer ( _repeatCount ) } ; if ( GUIUtilities . confirm ( view , "large-repeat-count" , pp , JOptionPane . WARNING_MESSAGE , JOptionPane . YES_NO_OPTION ) != JOptionPane . YES_OPTION ) { repeat = false ; repeatCount = 0 ; view . getStatus ( ) . setMessage ( null ) ; return ; } } try { buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < _repeatCount ; i ++ ) action . invoke ( view ) ; } finally { buffer . endCompoundEdit ( ) ; } } Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null && ! action . noRecord ( ) ) recorder . record ( _repeatCount , action . getCode ( ) ) ; if ( _repeat ) { if ( readNextChar != null ) return ; repeat = false ; repeatCount = 0 ; view . getStatus ( ) . setMessage ( null ) ; } } private static final int REPEAT_COUNT_THRESHOLD = 20 ; protected View view ; protected boolean repeat ; protected int repeatCount ; protected EditAction lastAction ; protected int lastActionCount ; protected String readNextChar ; protected void userInput ( char ch ) { lastAction = null ; if ( readNextChar != null ) invokeReadNextChar ( ch ) ; else { Buffer buffer = view . getBuffer ( ) ; if ( ! buffer . insideCompoundEdit ( ) ) buffer . beginCompoundEdit ( ) ; JEditTextArea textArea = view . getTextArea ( ) ; int _repeatCount = getRepeatCount ( ) ; if ( _repeatCount == 1 ) textArea . userInput ( ch ) ; else { if ( _repeatCount > REPEAT_COUNT_THRESHOLD ) { Object [ ] pp = { String . valueOf ( ch ) , new Integer ( _repeatCount ) } ; if ( GUIUtilities . confirm ( view , "large-repeat-count.user-input" , pp , JOptionPane . WARNING_MESSAGE , JOptionPane . YES_NO_OPTION ) != JOptionPane . YES_OPTION ) { repeat = false ; repeatCount = 0 ; view . getStatus ( ) . setMessage ( null ) ; return ; } } for ( int i = 0 ; i < _repeatCount ; i ++ ) textArea . userInput ( ch ) ; } Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( _repeatCount , ch ) ; } setRepeatEnabled ( false ) ; } protected void invokeReadNextChar ( char ch ) { String charStr = MiscUtilities . charsToEscapes ( String . valueOf ( ch ) ) ; int index ; while ( ( index = readNextChar . indexOf ( "__char__" ) ) != - 1 ) { readNextChar = readNextChar . substring ( 0 , index ) + '\'' + charStr + '\'' + readNextChar . substring ( index + 8 ) ; } Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( getRepeatCount ( ) , readNextChar ) ; if ( getRepeatCount ( ) != 1 ) { Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; BeanShell . eval ( view , "for(int i = 1; i < " + getRepeatCount ( ) + "; i++)\n{\n" + readNextChar + "\n}" , false ) ; } finally { buffer . endCompoundEdit ( ) ; } } else BeanShell . eval ( view , readNextChar , false ) ; readNextChar = null ; view . getStatus ( ) . setMessage ( null ) ; } } 	1	['16', '2', '1', '13', '47', '48', '8', '10', '14', '0.780952381', '443', '1', '2', '0.166666667', '0.241071429', '0', '0', '26.25', '14', '2.625', '6']
package org . gjt . sp . jedit . search ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . text . * ; import javax . swing . tree . * ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . Buffer ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; import org . gjt . sp . jedit . EditBus ; import org . gjt . sp . jedit . View ; import org . gjt . sp . util . Log ; public class HyperSearchResults extends JPanel implements DockableWindow , EBComponent { public static final String NAME = "hypersearch-results" ; public HyperSearchResults ( View view ) { super ( new BorderLayout ( ) ) ; this . view = view ; caption = new JLabel ( ) ; updateCaption ( 0 , 0 ) ; add ( BorderLayout . NORTH , caption ) ; resultTreeRoot = new DefaultMutableTreeNode ( ) ; resultTreeModel = new DefaultTreeModel ( resultTreeRoot ) ; resultTree = new JTree ( resultTreeModel ) ; resultTree . setCellRenderer ( new ResultCellRenderer ( ) ) ; resultTree . setVisibleRowCount ( 16 ) ; resultTree . setRootVisible ( false ) ; resultTree . setShowsRootHandles ( true ) ; resultTree . putClientProperty ( "JTree.lineStyle" , "Angled" ) ; resultTree . setEditable ( false ) ; resultTree . addMouseListener ( new MouseHandler ( ) ) ; JScrollPane scrollPane = new JScrollPane ( resultTree ) ; Dimension dim = scrollPane . getPreferredSize ( ) ; dim . width = 400 ; scrollPane . setPreferredSize ( dim ) ; add ( BorderLayout . CENTER , scrollPane ) ; } public String getName ( ) { return NAME ; } public Component getComponent ( ) { return this ; } public void addNotify ( ) { super . addNotify ( ) ; EditBus . addToBus ( this ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; EditBus . removeFromBus ( this ) ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof BufferUpdate ) { BufferUpdate bmsg = ( BufferUpdate ) msg ; Buffer buffer = bmsg . getBuffer ( ) ; if ( bmsg . getWhat ( ) == BufferUpdate . LOADED ) { for ( int i = resultTreeRoot . getChildCount ( ) - 1 ; i >= 0 ; i -- ) { DefaultMutableTreeNode bufferNode = ( DefaultMutableTreeNode ) resultTreeRoot . getChildAt ( i ) ; for ( int j = bufferNode . getChildCount ( ) - 1 ; j >= 0 ; j -- ) { HyperSearchResult result = ( HyperSearchResult ) ( ( DefaultMutableTreeNode ) bufferNode . getChildAt ( j ) ) . getUserObject ( ) ; if ( buffer . getPath ( ) . equals ( result . path ) ) result . bufferOpened ( buffer ) ; } } } else if ( bmsg . getWhat ( ) == BufferUpdate . CLOSED ) { for ( int i = resultTreeRoot . getChildCount ( ) - 1 ; i >= 0 ; i -- ) { DefaultMutableTreeNode bufferNode = ( DefaultMutableTreeNode ) resultTreeRoot . getChildAt ( i ) ; for ( int j = bufferNode . getChildCount ( ) - 1 ; j >= 0 ; j -- ) { HyperSearchResult result = ( HyperSearchResult ) ( ( DefaultMutableTreeNode ) bufferNode . getChildAt ( j ) ) . getUserObject ( ) ; if ( buffer . getPath ( ) . equals ( result . path ) ) result . bufferClosed ( ) ; } } } } } public DefaultTreeModel getTreeModel ( ) { return resultTreeModel ; } public void searchStarted ( ) { caption . setText ( jEdit . getProperty ( "hypersearch-results.searching" ) ) ; resultTreeRoot . removeAllChildren ( ) ; resultTreeModel . reload ( resultTreeRoot ) ; } public void searchDone ( int resultCount , int bufferCount ) { updateCaption ( resultCount , bufferCount ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( resultTreeRoot . getChildCount ( ) == 1 ) { resultTree . expandPath ( new TreePath ( ( ( DefaultMutableTreeNode ) resultTreeRoot . getChildAt ( 0 ) ) . getPath ( ) ) ) ; } } } ) ; } private View view ; private JLabel caption ; private JTree resultTree ; private DefaultMutableTreeNode resultTreeRoot ; private DefaultTreeModel resultTreeModel ; private void updateCaption ( int resultCount , int bufferCount ) { Object [ ] pp = { new Integer ( resultCount ) , new Integer ( bufferCount ) } ; caption . setText ( jEdit . getProperty ( "hypersearch-results.caption" , pp ) ) ; } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { TreePath path = resultTree . getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path == null ) return ; Object value = ( ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( value instanceof String ) { Buffer buffer = jEdit . openFile ( view , ( String ) value ) ; if ( buffer == null ) return ; view . setBuffer ( buffer ) ; view . toFront ( ) ; view . requestFocus ( ) ; } else { final HyperSearchResult result = ( HyperSearchResult ) value ; final Buffer buffer = result . getBuffer ( ) ; if ( buffer == null ) return ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { int pos = result . linePos . getOffset ( ) ; view . setBuffer ( buffer ) ; view . getTextArea ( ) . setCaretPosition ( pos ) ; view . toFront ( ) ; view . requestFocus ( ) ; } } ) ; } } } class ResultCellRenderer extends DefaultTreeCellRenderer { public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean hasFocus ) { Component comp = super . getTreeCellRendererComponent ( tree , value , sel , expanded , leaf , row , hasFocus ) ; if ( ! ( comp instanceof JLabel ) ) return comp ; JLabel label = ( JLabel ) comp ; label . setIcon ( null ) ; return label ; } } } 	1	['13', '5', '0', '17', '53', '54', '8', '12', '9', '0.875', '303', '0.833333333', '1', '0.981954887', '0.261538462', '3', '12', '21.84615385', '10', '1.6923', '2']
