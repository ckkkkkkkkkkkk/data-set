package org . apache . tools . ant ; import java . io . * ; public class DefaultLogger implements BuildLogger { private static int LEFT_COLUMN_SIZE = 12 ; protected PrintStream out ; protected PrintStream err ; protected int msgOutputLevel = Project . MSG_ERR ; private long startTime = System . currentTimeMillis ( ) ; protected static String lSep = System . getProperty ( "line.separator" ) ; protected boolean emacsMode = false ; public void setMessageOutputLevel ( int level ) { this . msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . out = output ; } public void setErrorPrintStream ( PrintStream err ) { this . err = err ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void buildStarted ( BuildEvent event ) { startTime = System . currentTimeMillis ( ) ; } public void buildFinished ( BuildEvent event ) { Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( lSep + "BUILD SUCCESSFUL" ) ; } else { err . println ( lSep + "BUILD FAILED" + lSep ) ; error . printStackTrace ( err ) ; } out . println ( lSep + "Total time: " + formatTime ( System . currentTimeMillis ( ) - startTime ) ) ; } public void targetStarted ( BuildEvent event ) { if ( Project . MSG_INFO <= msgOutputLevel ) { out . println ( lSep + event . getTarget ( ) . getName ( ) + ":" ) ; } } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { PrintStream logTo = event . getPriority ( ) == Project . MSG_ERR ? err : out ; if ( event . getPriority ( ) <= msgOutputLevel ) { if ( event . getTask ( ) != null ) { String name = event . getTask ( ) . getTaskName ( ) ; if ( ! emacsMode ) { String msg = "[" + name + "] " ; for ( int i = 0 ; i < ( LEFT_COLUMN_SIZE - msg . length ( ) ) ; i ++ ) { logTo . print ( " " ) ; } logTo . print ( msg ) ; } } logTo . println ( event . getMessage ( ) ) ; } } protected static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } } 	1	['14', '1', '1', '8', '32', '49', '4', '4', '12', '0.835164835', '257', '1', '0', '0', '0.307692308', '0', '0', '16.85714286', '6', '1.6429', '2']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . BuildException ; import java . io . * ; import java . util . Enumeration ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; public class PatternSet extends DataType { private Vector includeList = new Vector ( ) ; private Vector excludeList = new Vector ( ) ; private File incl = null ; private File excl = null ; public class NameEntry { private String name ; private String ifCond ; private String unlessCond ; public void setName ( String name ) { this . name = name ; } public void setIf ( String cond ) { ifCond = cond ; } public void setUnless ( String cond ) { unlessCond = cond ; } public String getName ( ) { return name ; } public String evalName ( Project p ) { return valid ( p ) ? name : null ; } private boolean valid ( Project p ) { if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } } public PatternSet ( ) { super ( ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! includeList . isEmpty ( ) || ! excludeList . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includeList ) ; } public NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludeList ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null && includes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( includes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createInclude ( ) . setName ( tok . nextToken ( ) ) ; } } } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null && excludes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( excludes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( tok . nextToken ( ) ) ; } } } private NameEntry addPatternToList ( Vector list ) { NameEntry result = new NameEntry ( ) ; list . addElement ( result ) ; return result ; } public void setIncludesfile ( File incl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( ! incl . exists ( ) ) { throw new BuildException ( "Includesfile " + incl . getAbsolutePath ( ) + " not found." ) ; } this . incl = incl ; } public void setExcludesfile ( File excl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( ! excl . exists ( ) ) { throw new BuildException ( "Excludesfile " + excl . getAbsolutePath ( ) + " not found." ) ; } this . excl = excl ; } private void readPatterns ( File patternfile , Vector patternlist , Project p ) throws BuildException { try { BufferedReader patternReader = new BufferedReader ( new FileReader ( patternfile ) ) ; String line = patternReader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) > 0 ) { line = ProjectHelper . replaceProperties ( p , line , p . getProperties ( ) ) ; addPatternToList ( patternlist ) . setName ( line ) ; } line = patternReader . readLine ( ) ; } } catch ( IOException ioe ) { String msg = "An error occured while reading from pattern file: " + patternfile ; throw new BuildException ( msg , ioe ) ; } } public void append ( PatternSet other , Project p ) { if ( isReference ( ) ) { throw new BuildException ( "Cannot append to a reference" ) ; } String [ ] incl = other . getIncludePatterns ( p ) ; if ( incl != null ) { for ( int i = 0 ; i < incl . length ; i ++ ) { createInclude ( ) . setName ( incl [ i ] ) ; } } String [ ] excl = other . getExcludePatterns ( p ) ; if ( excl != null ) { for ( int i = 0 ; i < excl . length ; i ++ ) { createExclude ( ) . setName ( excl [ i ] ) ; } } } public String [ ] getIncludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getIncludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( includeList , p ) ; } } public String [ ] getExcludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExcludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( excludeList , p ) ; } } boolean hasPatterns ( ) { return incl != null || excl != null || includeList . size ( ) > 0 || excludeList . size ( ) > 0 ; } private PatternSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof PatternSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a patternset" ; throw new BuildException ( msg ) ; } else { return ( PatternSet ) o ; } } private String [ ] makeArray ( Vector list , Project p ) { if ( list . size ( ) == 0 ) return null ; Vector tmpNames = new Vector ( ) ; for ( Enumeration e = list . elements ( ) ; e . hasMoreElements ( ) ; ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String pattern = ne . evalName ( p ) ; if ( pattern != null && pattern . length ( ) > 0 ) { tmpNames . addElement ( pattern ) ; } } String result [ ] = new String [ tmpNames . size ( ) ] ; tmpNames . copyInto ( result ) ; return result ; } private void readFiles ( Project p ) { if ( incl != null ) { readPatterns ( incl , includeList , p ) ; incl = null ; } if ( excl != null ) { readPatterns ( excl , excludeList , p ) ; excl = null ; } } } 	1	['17', '3', '0', '10', '55', '76', '5', '6', '11', '0.59375', '461', '1', '0', '0.652173913', '0.285714286', '1', '1', '25.88235294', '6', '2.6471', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . File ; public class Mkdir extends Task { private File dir ; public void execute ( ) throws BuildException { if ( dir == null ) { throw new BuildException ( "dir attribute is required" , location ) ; } if ( dir . isFile ( ) ) { throw new BuildException ( "Unable to create directory as a file already exists with that name: " + dir . getAbsolutePath ( ) ) ; } if ( ! dir . exists ( ) ) { boolean result = dir . mkdirs ( ) ; if ( result == false ) { String msg = "Directory " + dir . getAbsolutePath ( ) + " creation was not " + "succesful for an unknown reason" ; throw new BuildException ( msg , location ) ; } log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } } public void setDir ( File dir ) { this . dir = dir ; } } 	1	['3', '3', '0', '3', '14', '1', '0', '3', '3', '0.5', '84', '1', '0', '0.948717949', '0.666666667', '1', '1', '26.66666667', '1', '0.6667', '1']
package org . apache . tools . ant ; import java . lang . reflect . * ; import java . util . * ; import java . util . zip . * ; import java . io . * ; import org . apache . tools . ant . types . Path ; public class AntClassLoader extends ClassLoader { static private final int BUFFER_SIZE = 1024 ; private Path classpath ; private Project project ; private boolean systemFirst = true ; private Vector systemPackages = new Vector ( ) ; private Vector loaderPackages = new Vector ( ) ; private boolean ignoreBase = false ; private static Method getProtectionDomain = null ; private static Method defineClassProtectionDomain = null ; static { try { getProtectionDomain = Class . class . getMethod ( "getProtectionDomain" , new Class [ 0 ] ) ; Class protectionDomain = Class . forName ( "java.security.ProtectionDomain" ) ; Class [ ] args = new Class [ ] { String . class , byte [ ] . class , Integer . TYPE , Integer . TYPE , protectionDomain } ; defineClassProtectionDomain = ClassLoader . class . getDeclaredMethod ( "defineClass" , args ) ; } catch ( Exception e ) { } } public AntClassLoader ( Project project , Path classpath ) { this . project = project ; this . classpath = classpath . concatSystemClasspath ( "ignore" ) ; addSystemPackageRoot ( "java" ) ; addSystemPackageRoot ( "javax" ) ; } public AntClassLoader ( Project project , Path classpath , boolean systemFirst ) { this ( project , classpath ) ; this . systemFirst = systemFirst ; } public void setIsolated ( boolean isolated ) { ignoreBase = isolated ; } public void addSystemPackageRoot ( String packageRoot ) { systemPackages . addElement ( packageRoot + "." ) ; } public void addLoaderPackageRoot ( String packageRoot ) { loaderPackages . addElement ( packageRoot + "." ) ; } public Class forceLoadClass ( String classname ) throws ClassNotFoundException { project . log ( "force loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findClass ( classname ) ; } return theClass ; } public Class forceLoadSystemClass ( String classname ) throws ClassNotFoundException { project . log ( "force system loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findBaseClass ( classname ) ; } return theClass ; } public InputStream getResourceAsStream ( String name ) { InputStream stream = null ; String [ ] pathElements = classpath . list ( ) ; for ( int i = 0 ; i < pathElements . length && stream == null ; ++ i ) { File pathComponent = project . resolveFile ( ( String ) pathElements [ i ] ) ; stream = getResourceStream ( pathComponent , name ) ; } return stream ; } private InputStream getResourceStream ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { return new FileInputStream ( resource ) ; } } else { ZipFile zipFile = null ; try { zipFile = new ZipFile ( file ) ; ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytesRead ; InputStream stream = zipFile . getInputStream ( entry ) ; while ( ( bytesRead = stream . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { baos . write ( buffer , 0 , bytesRead ) ; } return new ByteArrayInputStream ( baos . toByteArray ( ) ) ; } } finally { if ( zipFile != null ) { zipFile . close ( ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } protected Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { boolean useSystemFirst = systemFirst ; for ( Enumeration e = systemPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( classname . startsWith ( packageName ) ) { useSystemFirst = true ; break ; } } for ( Enumeration e = loaderPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( classname . startsWith ( packageName ) ) { useSystemFirst = false ; break ; } } Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { if ( useSystemFirst ) { try { theClass = findBaseClass ( classname ) ; project . log ( "Class " + classname + " loaded from system loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { theClass = findClass ( classname ) ; project . log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } else { try { theClass = findClass ( classname ) ; project . log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { if ( ignoreBase ) { throw cnfe ; } theClass = findBaseClass ( classname ) ; project . log ( "Class " + classname + " loaded from system loader" , Project . MSG_DEBUG ) ; } } } if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } private String getClassFilename ( String classname ) { return classname . replace ( '.' , '/' ) + ".class" ; } private Class getClassFromStream ( InputStream stream , String classname ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; int bytesRead = - 1 ; byte [ ] buffer = new byte [ 1024 ] ; while ( ( bytesRead = stream . read ( buffer , 0 , 1024 ) ) != - 1 ) { baos . write ( buffer , 0 , bytesRead ) ; } byte [ ] classData = baos . toByteArray ( ) ; if ( defineClassProtectionDomain != null ) { try { Object domain = getProtectionDomain . invoke ( Project . class , new Object [ 0 ] ) ; Object [ ] args = new Object [ ] { classname , classData , new Integer ( 0 ) , new Integer ( classData . length ) , domain } ; return ( Class ) defineClassProtectionDomain . invoke ( this , args ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof ClassFormatError ) { throw ( ClassFormatError ) t ; } else { throw new IOException ( t . toString ( ) ) ; } } catch ( Exception e ) { throw new IOException ( e . toString ( ) ) ; } } else { return defineClass ( classname , classData , 0 , classData . length ) ; } } public Class findClass ( String name ) throws ClassNotFoundException { project . log ( "Finding class " + name , Project . MSG_DEBUG ) ; try { return findClass ( name , classpath ) ; } catch ( ClassNotFoundException e ) { throw e ; } } private Class findClass ( String name , Path path ) throws ClassNotFoundException { InputStream stream = null ; String classFilename = getClassFilename ( name ) ; try { String [ ] pathElements = path . list ( ) ; for ( int i = 0 ; i < pathElements . length && stream == null ; ++ i ) { File pathComponent = project . resolveFile ( ( String ) pathElements [ i ] ) ; stream = getResourceStream ( pathComponent , classFilename ) ; } if ( stream == null ) { throw new ClassNotFoundException ( ) ; } return getClassFromStream ( stream , name ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new ClassNotFoundException ( ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } } private Class findBaseClass ( String name ) throws ClassNotFoundException { ClassLoader base = AntClassLoader . class . getClassLoader ( ) ; if ( base == null ) { return findSystemClass ( name ) ; } else { return base . loadClass ( name ) ; } } } 	1	['17', '2', '0', '9', '64', '76', '7', '2', '9', '0.879166667', '713', '0.6', '2', '0.708333333', '0.339285714', '1', '3', '40.05882353', '9', '1.4118', '2']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . * ; import java . io . * ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . Date ; public class Rmic extends MatchingTask { private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopopts ; private boolean idl = false ; private String idlopts ; private boolean debug = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; public void setBase ( File base ) { this . baseDir = base ; } public void setClassname ( String classname ) { this . classname = classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public void setIiopopts ( String iiopopts ) { this . iiopopts = iiopopts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public void setIdlopts ( String idlopts ) { this . idlopts = idlopts ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( "base attribute must be set!" , location ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( "base does not exist!" , location ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_INFO ) ; } if ( iiop ) { log ( "IIOP has been turned on." , Project . MSG_INFO ) ; if ( iiopopts != null ) { log ( "IIOP Options: " + iiopopts , Project . MSG_INFO ) ; } } if ( idl ) { log ( "IDL has been turned on." , Project . MSG_INFO ) ; if ( idlopts != null ) { log ( "IDL Options: " + idlopts , Project . MSG_INFO ) ; } } Path classpath = getCompileClasspath ( baseDir ) ; loader = new AntClassLoader ( project , classpath ) ; if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } ) ; } OutputStream logstr = new LogOutputStream ( this , Project . MSG_WARN ) ; sun . rmi . rmic . Main compiler = new sun . rmi . rmic . Main ( logstr , "rmic" ) ; Commandline cmd = new Commandline ( ) ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( baseDir ) ; cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( null != stubVersion ) { if ( "1.1" . equals ( stubVersion ) ) cmd . createArgument ( ) . setValue ( "-v1.1" ) ; else if ( "1.2" . equals ( stubVersion ) ) cmd . createArgument ( ) . setValue ( "-v1.2" ) ; else cmd . createArgument ( ) . setValue ( "-vcompat" ) ; } if ( null != sourceBase ) cmd . createArgument ( ) . setValue ( "-keepgenerated" ) ; if ( iiop ) { cmd . createArgument ( ) . setValue ( "-iiop" ) ; if ( iiopopts != null ) cmd . createArgument ( ) . setValue ( iiopopts ) ; } if ( idl ) { cmd . createArgument ( ) . setValue ( "-idl" ) ; if ( idlopts != null ) cmd . createArgument ( ) . setValue ( idlopts ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; for ( int j = 0 ; j < fileCount ; j ++ ) { cmd . createArgument ( ) . setValue ( ( String ) compileList . elementAt ( j ) ) ; } log ( "Compilation args: " + cmd . toString ( ) , Project . MSG_VERBOSE ) ; compiler . compile ( cmd . getArguments ( ) ) ; } if ( null != sourceBase ) { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) ) ; } } compileList . removeAllElements ( ) ; } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname ) throws BuildException { String stubFileName = classname . replace ( '.' , File . separatorChar ) + "_Stub.java" ; File oldStubFile = new File ( baseDir , stubFileName ) ; File newStubFile = new File ( sourceBaseFile , stubFileName ) ; try { project . copyFile ( oldStubFile , newStubFile , filtering ) ; oldStubFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldStubFile + " to " + newStubFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } if ( ! "1.2" . equals ( stubVersion ) ) { String skelFileName = classname . replace ( '.' , '/' ) + "_Skel.java" ; File oldSkelFile = new File ( baseDir , skelFileName ) ; File newSkelFile = new File ( sourceBaseFile , skelFileName ) ; try { project . copyFile ( oldSkelFile , newSkelFile , filtering ) ; oldSkelFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldSkelFile + " to " + newSkelFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } protected void scanDir ( File baseDir , String files [ ] ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; String [ ] newFiles = sfs . restrict ( files , baseDir , baseDir , new RmicFileNameMapper ( ) ) ; for ( int i = 0 ; i < newFiles . length ; i ++ ) { String classname = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . indexOf ( ".class" ) ) ; compileList . addElement ( classname ) ; } } private Path getCompileClasspath ( File baseFile ) { Path classpath = new Path ( project , baseFile . getAbsolutePath ( ) ) ; if ( compileClasspath == null ) { classpath . addExisting ( Path . systemClasspath ) ; } else { classpath . addExisting ( compileClasspath . concatSystemClasspath ( ) ) ; } if ( Project . getJavaVersion ( ) . startsWith ( "1.2" ) ) { String bootcp = System . getProperty ( "sun.boot.class.path" ) ; if ( bootcp != null ) { classpath . addExisting ( new Path ( project , bootcp ) ) ; } } return classpath ; } private class RmicFileNameMapper implements FileNameMapper { private GlobPatternMapper stubMapper ; private GlobPatternMapper skelMapper ; RmicFileNameMapper ( ) { stubMapper = new GlobPatternMapper ( ) ; stubMapper . setFrom ( "*.class" ) ; stubMapper . setTo ( "*_Stub.class" ) ; if ( ! "1.2" . equals ( stubVersion ) ) { skelMapper = new GlobPatternMapper ( ) ; skelMapper . setFrom ( "*.class" ) ; skelMapper . setTo ( "*_Skel.class" ) ; } } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { String [ ] stubName = stubMapper . mapFileName ( name ) ; if ( stubName == null || name . endsWith ( "_Stub.class" ) || name . endsWith ( "_Skel.class" ) ) { return null ; } String classname = name . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . indexOf ( ".class" ) ) ; if ( verify ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) || ! isValidRmiRemote ( testClass ) ) { return null ; } } catch ( ClassNotFoundException e ) { log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } } if ( skelMapper != null ) { return new String [ ] { stubName [ 0 ] , skelMapper . mapFileName ( name ) [ 0 ] } ; } else { return stubName ; } } private boolean isValidRmiRemote ( Class testClass ) { Class rmiRemote = java . rmi . Remote . class ; if ( rmiRemote . equals ( testClass ) ) { return true ; } Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( rmiRemote . equals ( interfaces [ i ] ) ) { return true ; } if ( isValidRmiRemote ( interfaces [ i ] ) ) { return true ; } } } return false ; } } } 	1	['22', '4', '0', '16', '72', '165', '1', '16', '16', '0.904761905', '675', '1', '1', '0.787878788', '0.227272727', '3', '3', '29.04545455', '4', '1.2273', '1']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . zip . * ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; public class Zip extends MatchingTask { private File zipFile ; private File baseDir ; private boolean doCompress = true ; protected String archiveType = "zip" ; private static long emptyCrc = new CRC32 ( ) . getValue ( ) ; protected String emptyBehavior = "skip" ; private Vector filesets = new Vector ( ) ; private Hashtable addedDirs = new Hashtable ( ) ; public void setZipfile ( File zipFile ) { this . zipFile = zipFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean c ) { doCompress = c ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addZipfileset ( ZipFileSet set ) { filesets . addElement ( set ) ; } public void setWhenempty ( String we ) throws BuildException { we = we . toLowerCase ( ) ; if ( ! "fail" . equals ( we ) && ! "skip" . equals ( we ) && ! "create" . equals ( we ) ) throw new BuildException ( "Unrecognized whenempty attribute: " + we ) ; emptyBehavior = we ; } public void execute ( ) throws BuildException { if ( baseDir == null && filesets . size ( ) == 0 && "zip" . equals ( archiveType ) ) { throw new BuildException ( "basedir attribute must be set, or at least " + "one fileset must be given!" ) ; } if ( zipFile == null ) { throw new BuildException ( "You must specify the " + archiveType + " file to create!" ) ; } Vector dss = new Vector ( ) ; if ( baseDir != null ) dss . addElement ( getDirectoryScanner ( baseDir ) ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; dss . addElement ( fs . getDirectoryScanner ( project ) ) ; } int dssSize = dss . size ( ) ; FileScanner [ ] scanners = new FileScanner [ dssSize ] ; dss . copyInto ( scanners ) ; if ( isUpToDate ( scanners , zipFile ) ) return ; log ( "Building " + archiveType + ": " + zipFile . getAbsolutePath ( ) ) ; try { boolean success = false ; ZipOutputStream zOut = new ZipOutputStream ( new FileOutputStream ( zipFile ) ) ; try { if ( doCompress ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } initZipOutputStream ( zOut ) ; if ( baseDir != null ) addFiles ( getDirectoryScanner ( baseDir ) , zOut , "" , "" ) ; addFiles ( filesets , zOut ) ; success = true ; } finally { try { if ( zOut != null ) zOut . close ( ) ; } catch ( IOException ex ) { if ( success ) throw ex ; } } } catch ( IOException ioe ) { String msg = "Problem creating " + archiveType + ": " + ioe . getMessage ( ) ; if ( ! zipFile . delete ( ) ) { msg += " (and the archive is probably corrupt but I could not delete it)" ; } throw new BuildException ( msg , ioe , location ) ; } finally { cleanUp ( ) ; } } protected void addFiles ( FileScanner scanner , ZipOutputStream zOut , String prefix , String fullpath ) throws IOException { if ( prefix . length ( ) > 0 && fullpath . length ( ) > 0 ) throw new BuildException ( "Both prefix and fullpath attributes may not be set on the same fileset." ) ; File thisBaseDir = scanner . getBasedir ( ) ; String [ ] dirs = scanner . getIncludedDirectories ( ) ; if ( dirs . length > 0 && fullpath . length ( ) > 0 ) throw new BuildException ( "fullpath attribute may only be specified for filesets that specify a single file." ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { String name = dirs [ i ] . replace ( File . separatorChar , '/' ) ; if ( ! name . endsWith ( "/" ) ) { name += "/" ; } addParentDirs ( thisBaseDir , name , zOut , prefix ) ; } String [ ] files = scanner . getIncludedFiles ( ) ; if ( files . length > 1 && fullpath . length ( ) > 0 ) throw new BuildException ( "fullpath attribute may only be specified for filesets that specify a single file." ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( thisBaseDir , files [ i ] ) ; if ( fullpath . length ( ) > 0 ) { addParentDirs ( null , fullpath , zOut , "" ) ; zipFile ( f , zOut , fullpath ) ; } else { String name = files [ i ] . replace ( File . separatorChar , '/' ) ; addParentDirs ( thisBaseDir , name , zOut , prefix ) ; zipFile ( f , zOut , prefix + name ) ; } } } protected void addZipEntries ( ZipFileSet fs , DirectoryScanner ds , ZipOutputStream zOut , String prefix ) throws IOException { ZipScanner zipScanner = ( ZipScanner ) ds ; File zipSrc = fs . getSrc ( ) ; ZipEntry entry ; ZipInputStream in = new ZipInputStream ( new FileInputStream ( zipSrc ) ) ; while ( ( entry = in . getNextEntry ( ) ) != null ) { String vPath = entry . getName ( ) ; if ( zipScanner . match ( vPath ) ) { addParentDirs ( null , vPath , zOut , prefix ) ; if ( ! entry . isDirectory ( ) ) { zipFile ( in , zOut , prefix + vPath , entry . getTime ( ) ) ; } } } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected boolean isUpToDate ( FileScanner [ ] scanners , File zipFile ) throws BuildException { String [ ] [ ] fileNames = grabFileNames ( scanners ) ; File [ ] files = grabFiles ( scanners , fileNames ) ; if ( files . length == 0 ) { if ( emptyBehavior . equals ( "skip" ) ) { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; return true ; } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , location ) ; } else { if ( zipFile . exists ( ) ) return true ; log ( "Note: creating empty " + archiveType + " archive " + zipFile , Project . MSG_INFO ) ; try { OutputStream os = new FileOutputStream ( zipFile ) ; try { byte [ ] empty = new byte [ 22 ] ; empty [ 0 ] = 80 ; empty [ 1 ] = 75 ; empty [ 2 ] = 5 ; empty [ 3 ] = 6 ; os . write ( empty ) ; } finally { os . close ( ) ; } } catch ( IOException ioe ) { throw new BuildException ( "Could not create empty ZIP archive" , ioe , location ) ; } return true ; } } else { for ( int i = 0 ; i < files . length ; ++ i ) { if ( files [ i ] . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , location ) ; } } if ( ! zipFile . exists ( ) ) return false ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( zipFile . getAbsolutePath ( ) ) ; for ( int i = 0 ; i < scanners . length ; i ++ ) { if ( sfs . restrict ( fileNames [ i ] , scanners [ i ] . getBasedir ( ) , null , mm ) . length > 0 ) { return false ; } } return true ; } } protected static File [ ] grabFiles ( FileScanner [ ] scanners ) { return grabFiles ( scanners , grabFileNames ( scanners ) ) ; } protected static File [ ] grabFiles ( FileScanner [ ] scanners , String [ ] [ ] fileNames ) { Vector files = new Vector ( ) ; for ( int i = 0 ; i < fileNames . length ; i ++ ) { File thisBaseDir = scanners [ i ] . getBasedir ( ) ; for ( int j = 0 ; j < fileNames [ i ] . length ; j ++ ) files . addElement ( new File ( thisBaseDir , fileNames [ i ] [ j ] ) ) ; } File [ ] toret = new File [ files . size ( ) ] ; files . copyInto ( toret ) ; return toret ; } protected static String [ ] [ ] grabFileNames ( FileScanner [ ] scanners ) { String [ ] [ ] result = new String [ scanners . length ] [ ] ; for ( int i = 0 ; i < scanners . length ; i ++ ) { String [ ] files = scanners [ i ] . getIncludedFiles ( ) ; String [ ] dirs = scanners [ i ] . getIncludedDirectories ( ) ; result [ i ] = new String [ files . length + dirs . length ] ; System . arraycopy ( files , 0 , result [ i ] , 0 , files . length ) ; System . arraycopy ( dirs , 0 , result [ i ] , files . length , dirs . length ) ; } return result ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath ) throws IOException { if ( addedDirs . get ( vPath ) != null ) { return ; } addedDirs . put ( vPath , vPath ) ; ZipEntry ze = new ZipEntry ( vPath ) ; if ( dir != null ) ze . setTime ( dir . lastModified ( ) ) ; ze . setSize ( 0 ) ; ze . setMethod ( ZipEntry . STORED ) ; ze . setCrc ( emptyCrc ) ; zOut . putNextEntry ( ze ) ; } protected void zipFile ( InputStream in , ZipOutputStream zOut , String vPath , long lastModified ) throws IOException { ZipEntry ze = new ZipEntry ( vPath ) ; ze . setTime ( lastModified ) ; if ( ! doCompress ) { long size = 0 ; CRC32 cal = new CRC32 ( ) ; if ( ! in . markSupported ( ) ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; bos . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } else { in . mark ( Integer . MAX_VALUE ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . reset ( ) ; } ze . setSize ( size ) ; ze . setCrc ( cal . getValue ( ) ) ; } zOut . putNextEntry ( ze ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( file . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , location ) ; } FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut , vPath , file . lastModified ( ) ) ; } finally { fIn . close ( ) ; } } protected void addParentDirs ( File baseDir , String entry , ZipOutputStream zOut , String prefix ) throws IOException { Stack directories = new Stack ( ) ; int slashPos = entry . length ( ) ; while ( ( slashPos = entry . lastIndexOf ( ( int ) '/' , slashPos - 1 ) ) != - 1 ) { String dir = entry . substring ( 0 , slashPos + 1 ) ; if ( addedDirs . get ( prefix + dir ) != null ) { break ; } directories . push ( dir ) ; } while ( ! directories . isEmpty ( ) ) { String dir = ( String ) directories . pop ( ) ; File f = null ; if ( baseDir != null ) { f = new File ( baseDir , dir ) ; } else { f = new File ( dir ) ; } zipDir ( f , zOut , prefix + dir ) ; } } protected void addFiles ( Vector filesets , ZipOutputStream zOut ) throws IOException { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String prefix = "" ; String fullpath = "" ; if ( fs instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) fs ; prefix = zfs . getPrefix ( ) ; fullpath = zfs . getFullpath ( ) ; } if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } if ( prefix . length ( ) > 0 ) { addParentDirs ( null , prefix , zOut , "" ) ; zipDir ( null , zOut , prefix ) ; } else if ( fullpath . length ( ) > 0 ) { addParentDirs ( null , fullpath , zOut , "" ) ; } if ( fs instanceof ZipFileSet && ( ( ZipFileSet ) fs ) . getSrc ( ) != null ) { addZipEntries ( ( ZipFileSet ) fs , ds , zOut , prefix ) ; } else { addFiles ( ds , zOut , prefix , fullpath ) ; } } } protected void cleanUp ( ) { } } 	1	['22', '4', '1', '15', '104', '185', '2', '13', '8', '0.839285714', '1180', '1', '0', '0.795918367', '0.180272109', '3', '3', '52.27272727', '3', '1.0455', '3']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import java . io . File ; import java . util . Stack ; import java . util . Vector ; public class FileSet extends DataType { private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private File dir ; private boolean useDefaultExcludes = true ; public FileSet ( ) { super ( ) ; } protected FileSet ( FileSet fileset ) { this . dir = fileset . dir ; this . defaultPatterns = fileset . defaultPatterns ; this . additionalPatterns = fileset . additionalPatterns ; this . useDefaultExcludes = fileset . useDefaultExcludes ; } public void setRefid ( Reference r ) throws BuildException { if ( dir != null || defaultPatterns . hasPatterns ( ) ) { throw tooManyAttributes ( ) ; } if ( ! additionalPatterns . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( ! dir . exists ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " not found." ) ; } if ( ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a directory." ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public PatternSet createPatternSet ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PatternSet patterns = new PatternSet ( ) ; additionalPatterns . addElement ( patterns ) ; return patterns ; } public PatternSet . NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExclude ( ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludes ( excludes ) ; } public void setIncludesfile ( File incl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludesfile ( incl ) ; } public void setExcludesfile ( File excl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludesfile ( excl ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . useDefaultExcludes = useDefaultExcludes ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for fileset." ) ; } DirectoryScanner ds = new DirectoryScanner ( ) ; setupDirectoryScanner ( ds , p ) ; ds . scan ( ) ; return ds ; } public void setupDirectoryScanner ( FileScanner ds , Project p ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds cannot be null" ) ; } ds . setBasedir ( dir ) ; for ( int i = 0 ; i < additionalPatterns . size ( ) ; i ++ ) { Object o = additionalPatterns . elementAt ( i ) ; defaultPatterns . append ( ( PatternSet ) o , p ) ; } ds . setIncludes ( defaultPatterns . getIncludePatterns ( p ) ) ; ds . setExcludes ( defaultPatterns . getExcludePatterns ( p ) ) ; if ( useDefaultExcludes ) ds . addDefaultExcludes ( ) ; } protected FileSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof FileSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a fileset" ; throw new BuildException ( msg ) ; } else { return ( FileSet ) o ; } } } 	1	['16', '3', '2', '24', '56', '0', '16', '8', '14', '0.6', '353', '1', '1', '0.681818182', '0.2265625', '1', '1', '20.8125', '4', '1.75', '1']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class Main { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private PrintStream out = System . out ; private PrintStream err = System . err ; private Vector targets = new Vector ( 5 ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 5 ) ; private String loggerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void main ( String [ ] args ) { Main m = null ; try { m = new Main ( args ) ; } catch ( Throwable exc ) { printMessage ( exc ) ; System . exit ( 1 ) ; } try { m . runBuild ( ) ; System . exit ( 0 ) ; } catch ( BuildException be ) { if ( m . err != System . err ) { printMessage ( be ) ; } System . exit ( 1 ) ; } catch ( Throwable exc ) { printMessage ( exc ) ; System . exit ( 1 ) ; } } protected Main ( String [ ] args ) throws BuildException { String searchForThis = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; out = new PrintStream ( new FileOutputStream ( logFile ) ) ; err = out ; System . setOut ( out ) ; System . setErr ( out ) ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write permissions." ; System . out . println ( msg ) ; return ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) value = args [ ++ i ] ; definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { System . out . println ( "Only one logger class may be specified." ) ; return ; } loggerClassname = args [ ++ i ] ; } else if ( arg . equals ( "-emacs" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . out . println ( msg ) ; printUsage ( ) ; return ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( "." , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } readyToRun = true ; } private File getParentFile ( File file ) { String filename = file . getAbsolutePath ( ) ; file = new File ( filename ) ; filename = file . getParent ( ) ; if ( filename != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + filename ) ; } return ( filename == null ) ? null : new File ( filename ) ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ) throws BuildException { if ( ! readyToRun ) { return ; } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } Project project = new Project ( ) ; Throwable error = null ; try { addBuildListeners ( project ) ; project . fireBuildStarted ( ) ; project . init ( ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( "ant.file" , buildFile . getAbsolutePath ( ) ) ; try { Class . forName ( "javax.xml.parsers.SAXParserFactory" ) ; ProjectHelper . configureProject ( project , buildFile ) ; } catch ( NoClassDefFoundError ncdfe ) { throw new BuildException ( "No JAXP compliant XML parser found. See http://java.sun.com/xml for the\nreference implementation." , ncdfe ) ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( "No JAXP compliant XML parser found. See http://java.sun.com/xml for the\nreference implementation." , cnfe ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "No JAXP compliant XML parser found. See http://java.sun.com/xml for the\nreference implementation." , npe ) ; } if ( targets . size ( ) == 0 ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } if ( projectHelp ) { printTargets ( project ) ; } else { project . executeTargets ( targets ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error err ) { error = err ; throw err ; } finally { project . fireBuildFinished ( error ) ; } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; try { BuildListener listener = ( BuildListener ) Class . forName ( className ) . newInstance ( ) ; project . addBuildListener ( listener ) ; } catch ( Exception exc ) { throw new BuildException ( "Unable to instantiate listener " + className , exc ) ; } } } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { logger = ( BuildLogger ) ( Class . forName ( loggerClassname ) . newInstance ( ) ) ; } catch ( ClassCastException e ) { System . err . println ( "The specified logger class " + loggerClassname + " does not implement the BuildLogger interface" ) ; throw new RuntimeException ( ) ; } catch ( Exception e ) { System . err . println ( "Unable to instantiate specified logger class " + loggerClassname + " : " + e . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help                  print this message" + lSep ) ; msg . append ( "  -projecthelp           print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -quiet                 be extra quiet" + lSep ) ; msg . append ( "  -verbose               be extra verbose" + lSep ) ; msg . append ( "  -debug                 print debugging information" + lSep ) ; msg . append ( "  -emacs                 produce logging information without adornments" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -find <file>           search for buildfile towards the root of the" + lSep ) ; msg . append ( "                         filesystem and use it" + lSep ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; msg . append ( lSep ) ; System . out . println ( msg . toString ( ) ) ; } catch ( IOException ioe ) { System . err . println ( "Could not load the version information." ) ; System . err . println ( ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { System . err . println ( "Could not load the version information." ) ; } } private static void printTargets ( Project project ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } printTargets ( topNames , topDescriptions , "Main targets:" , maxLength ) ; printTargets ( subNames , null , "Subtargets:" , 0 ) ; } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) < maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } System . out . println ( msg . toString ( ) ) ; } } 	1	['14', '1', '0', '7', '82', '65', '0', '7', '1', '0.816568047', '1253', '0.846153846', '0', '0', '0.169642857', '0', '0', '87.57142857', '4', '2.1429', '1']
package org . apache . tools . ant ; import java . util . Vector ; public class UnknownElement extends Task { private String elementName ; private Task realTask ; private Vector children = new Vector ( ) ; public UnknownElement ( String elementName ) { this . elementName = elementName ; } public String getTag ( ) { return elementName ; } public void maybeConfigure ( ) throws BuildException { realTask = project . createTask ( elementName ) ; if ( realTask == null ) { log ( "Could not create task of type: " + elementName + " Common solutions" + " are adding the task to defaults.properties and executing bin/bootstrap" , Project . MSG_DEBUG ) ; throw new BuildException ( "Could not create task of type: " + elementName + ". Common solutions are to use taskdef to declare" + " your task, or, if this is an optional task," + " to put the optional.jar in the lib directory of" + " your ant installation (ANT_HOME)." , location ) ; } realTask . setLocation ( location ) ; String id = wrapper . getAttributes ( ) . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , realTask ) ; } realTask . init ( ) ; realTask . setOwningTarget ( target ) ; wrapper . setProxy ( realTask ) ; realTask . setRuntimeConfigurableWrapper ( wrapper ) ; handleChildren ( realTask , wrapper ) ; realTask . maybeConfigure ( ) ; target . replaceTask ( this , realTask ) ; } public void execute ( ) { if ( realTask == null ) { throw new BuildException ( "Could not create task of type: " + elementName , location ) ; } realTask . execute ( ) ; } public void addChild ( UnknownElement child ) { children . addElement ( child ) ; } protected void handleChildren ( Object parent , RuntimeConfigurable parentWrapper ) throws BuildException { if ( parent instanceof TaskAdapter ) { parent = ( ( TaskAdapter ) parent ) . getProxy ( ) ; } Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; for ( int i = 0 ; i < children . size ( ) ; i ++ ) { UnknownElement child = ( UnknownElement ) children . elementAt ( i ) ; Object realChild = ih . createElement ( parent , child . getTag ( ) ) ; RuntimeConfigurable childWrapper = parentWrapper . getChild ( i ) ; childWrapper . setProxy ( realChild ) ; child . handleChildren ( realChild , childWrapper ) ; } } } 	1	['6', '3', '0', '10', '33', '0', '3', '8', '5', '0.466666667', '198', '1', '1', '0.880952381', '0.333333333', '2', '4', '31.5', '2', '1', '3']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . io . * ; import java . util . * ; public class Property extends Task { protected String name ; protected String value ; protected File file ; protected String resource ; protected Path classpath ; protected String env ; protected Reference ref = null ; protected boolean userProperty = false ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setLocation ( File location ) { setValue ( location . getAbsolutePath ( ) ) ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } public void setRefid ( Reference ref ) { this . ref = ref ; } public Reference getRefid ( ) { return ref ; } public void setResource ( String resource ) { this . resource = resource ; } public String getResource ( ) { return resource ; } public void setEnvironment ( String env ) { this . env = env ; } public String getEnvironment ( ) { return env ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setUserProperty ( boolean userProperty ) { this . userProperty = userProperty ; } public String toString ( ) { return value == null ? "" : value ; } public void execute ( ) throws BuildException { try { if ( ( name != null ) && ( value != null ) ) { addProperty ( name , value ) ; } if ( file != null ) loadFile ( file ) ; if ( resource != null ) loadResource ( resource ) ; if ( env != null ) loadEnvironment ( env ) ; if ( ( name != null ) && ( ref != null ) ) { Object obj = ref . getReferencedObject ( getProject ( ) ) ; if ( obj != null ) { addProperty ( name , obj . toString ( ) ) ; } } } catch ( Exception e ) { throw new BuildException ( e , location ) ; } } protected void loadFile ( File file ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; try { if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; try { props . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } addProperties ( props ) ; } else { log ( "Unable to find " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; } } catch ( Exception ex ) { throw new BuildException ( ex . getMessage ( ) , ex , location ) ; } } protected void loadResource ( String name ) { Properties props = new Properties ( ) ; log ( "Resource Loading " + name , Project . MSG_VERBOSE ) ; try { ClassLoader cL = null ; InputStream is = null ; if ( classpath != null ) { cL = new AntClassLoader ( project , classpath , false ) ; } else { cL = this . getClass ( ) . getClassLoader ( ) ; } if ( cL == null ) { is = ClassLoader . getSystemResourceAsStream ( name ) ; } else { is = cL . getResourceAsStream ( name ) ; } if ( is != null ) { props . load ( is ) ; addProperties ( props ) ; } else { log ( "Unable to find resource " + name , Project . MSG_WARN ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } protected void loadEnvironment ( String prefix ) { Properties props = new Properties ( ) ; if ( ! prefix . endsWith ( "." ) ) prefix += "." ; log ( "Loading Environment " + prefix , Project . MSG_VERBOSE ) ; try { Vector osEnv = Execute . getProcEnvironment ( ) ; for ( Enumeration e = osEnv . elements ( ) ; e . hasMoreElements ( ) ; ) { String entry = ( String ) e . nextElement ( ) ; int pos = entry . indexOf ( '=' ) ; props . put ( prefix + entry . substring ( 0 , pos ) , entry . substring ( pos + 1 ) ) ; } addProperties ( props ) ; } catch ( Exception ex ) { throw new BuildException ( ex , location ) ; } } protected void addProperties ( Properties props ) { resolveAllProperties ( props ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) props . getProperty ( name ) ; String v = ProjectHelper . replaceProperties ( project , value , project . getProperties ( ) ) ; addProperty ( name , value ) ; } } protected void addProperty ( String n , String v ) { if ( userProperty ) { if ( project . getUserProperty ( n ) == null ) { project . setUserProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } else { if ( project . getProperty ( n ) == null ) { project . setProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } } private void resolveAllProperties ( Hashtable props ) { Hashtable unresolvableProperties = new Hashtable ( ) ; for ( Enumeration e = props . keys ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) props . get ( name ) ; boolean resolved = false ; while ( ! resolved ) { Vector propsInValue = new Vector ( ) ; resolved = true ; boolean unresolvable = false ; if ( extractProperties ( value , propsInValue ) ) { for ( int i = 0 ; i < propsInValue . size ( ) ; i ++ ) { String elem = ( String ) propsInValue . elementAt ( i ) ; if ( elem . equals ( name ) || unresolvableProperties . containsKey ( elem ) ) { unresolvable = true ; break ; } if ( project . getProperties ( ) . containsKey ( elem ) || props . containsKey ( elem ) ) { resolved = false ; } } } if ( unresolvable ) { unresolvableProperties . put ( name , value ) ; resolved = true ; } if ( ! resolved ) { value = ProjectHelper . replaceProperties ( project , value , project . getProperties ( ) ) ; value = ProjectHelper . replaceProperties ( project , value , props ) ; props . put ( name , value ) ; } } } } private boolean extractProperties ( String source , Vector properties ) { int i = 0 ; int prev = 0 ; int pos ; while ( ( pos = source . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos == ( source . length ( ) - 1 ) ) { prev = pos + 1 ; } else if ( source . charAt ( pos + 1 ) != '{' ) { prev = pos + 2 ; } else { int endName = source . indexOf ( '}' , pos ) ; String n = source . substring ( pos + 2 , endName ) ; properties . addElement ( n ) ; prev = endName + 1 ; } } return ( properties . size ( ) > 0 ) ; } } 	1	['27', '3', '0', '11', '83', '291', '2', '9', '20', '0.889423077', '658', '1', '2', '0.587301587', '0.185185185', '0', '0', '23.07407407', '11', '1.9259', '2']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import org . xml . sax . * ; import org . w3c . dom . * ; import org . apache . tools . ant . taskdefs . * ; import javax . xml . parsers . * ; public class ProjectHelper { private static SAXParserFactory parserFactory = null ; private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; public static void configureProject ( Project project , File buildFile ) throws BuildException { new ProjectHelper ( project , buildFile ) . parse ( ) ; } private ProjectHelper ( Project project , File buildFile ) { this . project = project ; this . buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; } private void parse ( ) throws BuildException { FileInputStream inputStream = null ; InputSource inputSource = null ; try { SAXParser saxParser = getParserFactory ( ) . newSAXParser ( ) ; parser = saxParser . getParser ( ) ; String uri = "file:" + buildFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; for ( int index = uri . indexOf ( '#' ) ; index != - 1 ; index = uri . indexOf ( '#' ) ) { uri = uri . substring ( 0 , index ) + "%23" + uri . substring ( index + 1 ) ; } inputStream = new FileInputStream ( buildFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + buildFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; saxParser . parse ( inputSource , new RootHandler ( ) ) ; } catch ( ParserConfigurationException exc ) { throw new BuildException ( "Parser has not been configured correctly" , exc ) ; } catch ( SAXParseException exc ) { Location location = new Location ( buildFile . toString ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file" , exc ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ioe ) { } } } } private class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; public AbstractHandler ( DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , locator ) ; } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { String s = new String ( buf , start , end ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , locator ) ; } } protected void finished ( ) { } public void endElement ( String name ) throws SAXException { finished ( ) ; parser . setDocumentHandler ( parentHandler ) ; } } private class RootHandler extends HandlerBase { public InputSource resolveEntity ( String publicId , String systemId ) { project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = systemId . substring ( 5 ) ; int index = path . indexOf ( "file:" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + path . substring ( index + 5 ) ; index = path . indexOf ( "file:" ) ; } String entitySystemId = path ; index = path . indexOf ( "%23" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + "#" + path . substring ( index + 3 ) ; index = path . indexOf ( "%23" ) ; } File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = new File ( buildFileParent , path ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( "file:" + entitySystemId ) ; return inputSource ; } catch ( FileNotFoundException fne ) { project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected XML type" , locator ) ; } } public void setDocumentLocator ( Locator locator ) { ProjectHelper . this . locator = locator ; } } private class ProjectHandler extends AbstractHandler { public ProjectHandler ( DocumentHandler parentHandler ) { super ( parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , locator ) ; } } if ( def == null ) { throw new SAXParseException ( "The default attribute of project is required" , locator ) ; } project . setDefaultTarget ( def ) ; if ( name != null ) { project . setName ( name ) ; project . addReference ( name , project ) ; } if ( id != null ) project . addReference ( id , project ) ; if ( project . getProperty ( "basedir" ) != null ) { project . setBasedir ( project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { project . setBasedir ( buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { project . setBasedir ( baseDir ) ; } else { project . setBasedir ( ( new File ( buildFileParent , baseDir ) ) . getAbsolutePath ( ) ) ; } } } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "taskdef" ) ) { handleTaskdef ( name , attrs ) ; } else if ( name . equals ( "property" ) ) { handleProperty ( name , attrs ) ; } else if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else if ( project . getDataTypeDefinitions ( ) . get ( name ) != null ) { handleDataType ( name , attrs ) ; } else { throw new SAXParseException ( "Unexpected element \"" + name + "\"" , locator ) ; } } private void handleTaskdef ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( this , null ) ) . init ( name , attrs ) ; } private void handleProperty ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( this , null ) ) . init ( name , attrs ) ; } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( this ) . init ( tag , attrs ) ; } private void handleDataType ( String name , AttributeList attrs ) throws SAXParseException { new DataTypeHandler ( this ) . init ( name , attrs ) ; } } private class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( DocumentHandler parentHandler ) { super ( parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , locator ) ; } target = new Target ( ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) project . addReference ( id , target ) ; if ( depends . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depends , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { target . addDependency ( tok . nextToken ( ) . trim ( ) ) ; } } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new TaskHandler ( this , target ) . init ( name , attrs ) ; } } private class TaskHandler extends AbstractHandler { private Target target ; private Task task ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( DocumentHandler parentHandler , Target target ) { super ( parentHandler ) ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( project ) ; } task . setLocation ( new Location ( buildFile . toString ( ) , locator . getLineNumber ( ) , locator . getColumnNumber ( ) ) ) ; configureId ( task , attrs ) ; if ( target != null ) { task . setOwningTarget ( target ) ; target . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; } else { task . init ( ) ; configure ( task , attrs , project ) ; } } protected void finished ( ) { if ( task != null && target == null ) { task . execute ( ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { if ( wrapper == null ) { try { addText ( task , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } else { wrapper . addText ( buf , start , end ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( this , task , wrapper ) . init ( name , attrs ) ; } } private class NestedElementHandler extends AbstractHandler { private Object target ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; public NestedElementHandler ( DocumentHandler parentHandler , Object target , RuntimeConfigurable parentWrapper ) { super ( parentHandler ) ; if ( target instanceof TaskAdapter ) { this . target = ( ( TaskAdapter ) target ) . getProxy ( ) ; } else { this . target = target ; } this . parentWrapper = parentWrapper ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class targetClass = target . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( targetClass ) ; try { if ( target instanceof UnknownElement ) { child = new UnknownElement ( propType . toLowerCase ( ) ) ; ( ( UnknownElement ) target ) . addChild ( ( UnknownElement ) child ) ; } else { child = ih . createElement ( target , propType . toLowerCase ( ) ) ; } configureId ( child , attrs ) ; if ( parentWrapper != null ) { childWrapper = new RuntimeConfigurable ( child ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } else { configure ( child , attrs , project ) ; } } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { if ( parentWrapper == null ) { try { addText ( child , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } else { childWrapper . addText ( buf , start , end ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( this , child , childWrapper ) . init ( name , attrs ) ; } } private class DataTypeHandler extends AbstractHandler { private Object element ; public DataTypeHandler ( DocumentHandler parentHandler ) { super ( parentHandler ) ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } configureId ( element , attrs ) ; configure ( element , attrs , project ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { try { addText ( element , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( this , element , null ) . init ( name , attrs ) ; } } public static void configure ( Object target , AttributeList attrs , Project project ) throws BuildException { if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( target . getClass ( ) ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String value = replaceProperties ( project , attrs . getValue ( i ) , project . getProperties ( ) ) ; try { ih . setAttribute ( project , target , attrs . getName ( i ) . toLowerCase ( ) , value ) ; } catch ( BuildException be ) { if ( ! attrs . getName ( i ) . equals ( "id" ) ) { throw be ; } } } } public static void addText ( Object target , char [ ] buf , int start , int end ) throws BuildException { addText ( target , new String ( buf , start , end ) ) ; } public static void addText ( Object target , String text ) throws BuildException { if ( text == null || text . trim ( ) . length ( ) == 0 ) { return ; } if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper . getHelper ( target . getClass ( ) ) . addText ( target , text ) ; } public static String replaceProperties ( Project project , String value , Hashtable keys ) throws BuildException { StringBuffer sb = new StringBuffer ( ) ; int i = 0 ; int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { sb . append ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { sb . append ( '$' ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { sb . append ( value . charAt ( pos + 1 ) ) ; prev = pos + 2 ; } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in prop: " + value ) ; } String n = value . substring ( pos + 2 , endName ) ; if ( ! keys . containsKey ( n ) ) { project . log ( "Property ${" + n + "} has not been set" , Project . MSG_VERBOSE ) ; } String v = ( keys . containsKey ( n ) ) ? ( String ) keys . get ( n ) : "${" + n + "}" ; sb . append ( v ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) sb . append ( value . substring ( prev ) ) ; return sb . toString ( ) ; } private static SAXParserFactory getParserFactory ( ) { if ( parserFactory == null ) { parserFactory = SAXParserFactory . newInstance ( ) ; } return parserFactory ; } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	1	['17', '1', '0', '19', '73', '112', '13', '7', '5', '0.84375', '502', '1', '1', '0', '0.170454545', '0', '0', '28.17647059', '2', '1', '3']
package org . apache . tools . ant ; import java . util . Enumeration ; import java . util . Vector ; import org . xml . sax . AttributeList ; import org . xml . sax . helpers . AttributeListImpl ; public class RuntimeConfigurable { private Vector children = new Vector ( ) ; private Object wrappedObject = null ; private AttributeList attributes ; private StringBuffer characters = new StringBuffer ( ) ; public RuntimeConfigurable ( Object proxy ) { wrappedObject = proxy ; } void setProxy ( Object proxy ) { wrappedObject = proxy ; } public void setAttributes ( AttributeList attributes ) { this . attributes = new AttributeListImpl ( attributes ) ; } public AttributeList getAttributes ( ) { return attributes ; } public void addChild ( RuntimeConfigurable child ) { children . addElement ( child ) ; } RuntimeConfigurable getChild ( int index ) { return ( RuntimeConfigurable ) children . elementAt ( index ) ; } public void addText ( String data ) { characters . append ( data ) ; } public void addText ( char [ ] buf , int start , int end ) { addText ( new String ( buf , start , end ) ) ; } public void maybeConfigure ( Project p ) throws BuildException { if ( attributes != null ) { ProjectHelper . configure ( wrappedObject , attributes , p ) ; attributes = null ; } if ( characters . length ( ) != 0 ) { ProjectHelper . addText ( wrappedObject , characters . toString ( ) ) ; characters . setLength ( 0 ) ; } Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { RuntimeConfigurable child = ( RuntimeConfigurable ) enum . nextElement ( ) ; child . maybeConfigure ( p ) ; } } } 	1	['9', '1', '0', '8', '25', '10', '5', '3', '7', '0.6875', '114', '1', '0', '0', '0.25', '0', '0', '11.22222222', '1', '0.8889', '2']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . * ; import java . util . * ; import java . text . * ; public class FixCRLF extends MatchingTask { private int addcr ; private int addtab ; private int ctrlz ; private int tablength = 8 ; private File srcDir ; private File destDir = null ; public FixCRLF ( ) { if ( System . getProperty ( "path.separator" ) . equals ( ":" ) ) { addcr = - 1 ; ctrlz = - 1 ; } else { addcr = + 1 ; ctrlz = 0 ; } } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setCr ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { addcr = - 1 ; } else if ( option . equals ( "asis" ) ) { addcr = 0 ; } else { addcr = + 1 ; } } public void setTab ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { addtab = - 1 ; } else if ( option . equals ( "asis" ) ) { addtab = 0 ; } else { addtab = + 1 ; } } public void setTablength ( int tlength ) throws BuildException { if ( tlength < 2 || ( tlength & ( tlength - 1 ) ) != 0 ) { throw new BuildException ( "tablength must be a positive power of 2" , location ) ; } tablength = tlength ; } public void setEof ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { ctrlz = - 1 ; } else if ( option . equals ( "asis" ) ) { ctrlz = 0 ; } else { ctrlz = + 1 ; } } public void execute ( ) throws BuildException { if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } log ( "options:" + " cr=" + ( addcr == - 1 ? "add" : addcr == 0 ? "asis" : "remove" ) + " tab=" + ( addtab == - 1 ? "add" : addtab == 0 ? "asis" : "remove" ) + " eof=" + ( ctrlz == - 1 ? "add" : ctrlz == 0 ? "asis" : "remove" ) + " tablength=" + tablength , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File srcFile = new File ( srcDir , files [ i ] ) ; int count = ( int ) srcFile . length ( ) ; byte indata [ ] = new byte [ count ] ; try { FileInputStream inStream = new FileInputStream ( srcFile ) ; inStream . read ( indata ) ; inStream . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } int cr = 0 ; int lf = 0 ; int tab = 0 ; for ( int k = 0 ; k < count ; k ++ ) { byte c = indata [ k ] ; if ( c == '\r' ) cr ++ ; if ( c == '\n' ) lf ++ ; if ( c == '\t' ) tab ++ ; } boolean eof = ( ( count > 0 ) && ( indata [ count - 1 ] == 0x1A ) ) ; log ( srcFile + ": size=" + count + " cr=" + cr + " lf=" + lf + " tab=" + tab + " eof=" + eof , Project . MSG_VERBOSE ) ; int outsize = count ; if ( addcr != 0 ) outsize -= cr ; if ( addcr == + 1 ) outsize += lf ; if ( addtab == - 1 ) outsize += tab * ( tablength - 1 ) ; if ( ctrlz == + 1 ) outsize += 1 ; byte outdata [ ] = new byte [ outsize ] ; int o = 0 ; int line = o ; int col = 0 ; for ( int k = 0 ; k < count ; k ++ ) { switch ( indata [ k ] ) { case ( byte ) ' ' : if ( addtab == 0 ) outdata [ o ++ ] = ( byte ) ' ' ; col ++ ; break ; case ( byte ) '\t' : if ( addtab == 0 ) { outdata [ o ++ ] = ( byte ) '\t' ; col ++ ; } else { col = ( col | ( tablength - 1 ) ) + 1 ; } break ; case ( byte ) '\r' : if ( addcr == 0 ) { outdata [ o ++ ] = ( byte ) '\r' ; col ++ ; } break ; case ( byte ) '\n' : if ( addcr == + 1 ) outdata [ o ++ ] = ( byte ) '\r' ; outdata [ o ++ ] = ( byte ) '\n' ; line = o ; col = 0 ; break ; default : if ( addtab > 0 && o + 1 < line + col ) { int diff = o - line ; while ( ( diff | ( tablength - 1 ) ) < col ) { outdata [ o ++ ] = ( byte ) '\t' ; line -= ( tablength - 1 ) - ( diff & ( tablength - 1 ) ) ; diff = o - line ; } ; } ; while ( o < line + col ) outdata [ o ++ ] = ( byte ) ' ' ; outdata [ o ++ ] = indata [ k ] ; col ++ ; } } if ( ctrlz == + 1 ) { if ( outdata [ o - 1 ] != 0x1A ) outdata [ o ++ ] = 0x1A ; } else if ( ctrlz == - 1 ) { if ( o > 2 && outdata [ o - 1 ] == 0x0A && outdata [ o - 2 ] == 0x1A ) o -- ; if ( o > 1 && outdata [ o - 1 ] == 0x1A ) o -- ; } try { File destFile = srcFile ; if ( destDir != null ) destFile = new File ( destDir , files [ i ] ) ; FileOutputStream outStream = new FileOutputStream ( destFile ) ; outStream . write ( outdata , 0 , o ) ; outStream . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } } 	1	['8', '4', '0', '7', '34', '6', '0', '7', '8', '0.761904762', '626', '1', '0', '0.917647059', '0.4375', '2', '2', '76.5', '3', '1.625', '3']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . ByteArrayOutputStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; public class Execute { public final static int INVALID = Integer . MAX_VALUE ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher launcher = createCommandLauncher ( ) ; private static Vector procEnvironment = null ; private static CommandLauncher createCommandLauncher ( ) { try { return new Java13CommandLauncher ( ) ; } catch ( NoSuchMethodException exc ) { } String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "mac os" ) >= 0 ) { return new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( osname . indexOf ( "os/2" ) >= 0 ) { return new WinNTCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( osname . indexOf ( "windows" ) >= 0 ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } if ( osname . indexOf ( "nt" ) >= 0 || osname . indexOf ( "2000" ) >= 0 ) { return new WinNTCommandLauncher ( baseLauncher ) ; } else { return new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else { return new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) return procEnvironment ; procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( out . toString ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { procEnvironment . addElement ( line ) ; } } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "mac os" ) >= 0 ) { String [ ] cmd = null ; return cmd ; } else if ( osname . indexOf ( "os/2" ) >= 0 ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else if ( osname . indexOf ( "indows" ) >= 0 ) { if ( osname . indexOf ( "nt" ) >= 0 || osname . indexOf ( "2000" ) >= 0 ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else { String [ ] cmd = { "command.com" , "/c" , "set" } ; return cmd ; } } else { String [ ] cmd = { "/usr/bin/env" } ; return cmd ; } } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { this . streamHandler = streamHandler ; this . watchdog = watchdog ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { if ( env == null || newEnvironment ) return env ; return patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) workingDirectory = null ; else workingDirectory = wd ; } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public int execute ( ) throws IOException { final Process process = launcher . exec ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; if ( watchdog != null ) watchdog . start ( process ) ; waitFor ( process ) ; if ( watchdog != null ) watchdog . stop ( ) ; streamHandler . stop ( ) ; if ( watchdog != null ) watchdog . checkException ( ) ; return getExitValue ( ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } private String [ ] patchEnvironment ( ) { Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { int pos = env [ i ] . indexOf ( '=' ) ; String key = env [ i ] . substring ( 0 , pos + 1 ) ; int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( ( ( String ) osEnv . elementAt ( j ) ) . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; break ; } } osEnv . addElement ( env [ i ] ) ; } String [ ] result = new String [ osEnv . size ( ) ] ; osEnv . copyInto ( result ) ; return result ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . toString ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . toString ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different directory under this JVM" ) ; } } private static class Java11CommandLauncher extends CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] newcmd = new String [ cmd . length ] ; for ( int i = 0 ; i < cmd . length ; i ++ ) { newcmd [ i ] = Commandline . quoteArgument ( cmd [ i ] ) ; } if ( project != null ) { project . log ( "Execute:Java11CommandLauncher: " + Commandline . toString ( newcmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( newcmd , env ) ; } } private static class Java13CommandLauncher extends CommandLauncher { public Java13CommandLauncher ( ) throws NoSuchMethodException { _execWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . toString ( cmd ) , Project . MSG_DEBUG ) ; } Object [ ] arguments = { cmd , env , workingDir } ; return ( Process ) _execWithCWD . invoke ( Runtime . getRuntime ( ) , arguments ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new IOException ( realexc . getMessage ( ) ) ; } } catch ( Exception exc ) { throw new IOException ( exc . getMessage ( ) ) ; } } private Method _execWithCWD ; } private static class CommandLauncherProxy extends CommandLauncher { CommandLauncherProxy ( CommandLauncher launcher ) { _launcher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return _launcher . exec ( project , cmd , env ) ; } private CommandLauncher _launcher ; } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = workingDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; _script = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } if ( project == null ) { throw new IOException ( "Cannot locate antRun script: No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + _script ) . toString ( ) ; String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = workingDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String _script ; } } 	1	['21', '1', '0', '25', '77', '162', '10', '16', '14', '0.7375', '566', '0.916666667', '4', '0', '0.135', '0', '0', '25.38095238', '7', '1.8095', '1']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import java . text . * ; public class Project { public static final int MSG_ERR = 0 ; public static final int MSG_WARN = 1 ; public static final int MSG_INFO = 2 ; public static final int MSG_VERBOSE = 3 ; public static final int MSG_DEBUG = 4 ; private static final String VISITING = "VISITING" ; private static final String VISITED = "VISITED" ; private static String javaVersion ; public static final String JAVA_1_0 = "1.0" ; public static final String JAVA_1_1 = "1.1" ; public static final String JAVA_1_2 = "1.2" ; public static final String JAVA_1_3 = "1.3" ; public static final String TOKEN_START = "@" ; public static final String TOKEN_END = "@" ; private String name ; private Hashtable properties = new Hashtable ( ) ; private Hashtable userProperties = new Hashtable ( ) ; private Hashtable references = new Hashtable ( ) ; private String defaultTarget ; private Hashtable dataClassDefinitions = new Hashtable ( ) ; private Hashtable taskClassDefinitions = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable filters = new Hashtable ( ) ; private File baseDir ; private Vector listeners = new Vector ( ) ; private static java . lang . reflect . Method setLastModified = null ; private static Object lockReflection = new Object ( ) ; static { try { javaVersion = JAVA_1_0 ; Class . forName ( "java.lang.Void" ) ; javaVersion = JAVA_1_1 ; Class . forName ( "java.lang.ThreadLocal" ) ; javaVersion = JAVA_1_2 ; Class . forName ( "java.lang.StrictMath" ) ; javaVersion = JAVA_1_3 ; } catch ( ClassNotFoundException cnfe ) { } } public Project ( ) { } public void init ( ) throws BuildException { setJavaVersionProperty ( ) ; String defs = "/org/apache/tools/ant/taskdefs/defaults.properties" ; try { Properties props = new Properties ( ) ; InputStream in = this . getClass ( ) . getResourceAsStream ( defs ) ; if ( in == null ) { throw new BuildException ( "Can't load default task list" ) ; } props . load ( in ) ; in . close ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; String value = props . getProperty ( key ) ; try { Class taskClass = Class . forName ( value ) ; addTaskDefinition ( key , taskClass ) ; } catch ( NoClassDefFoundError ncdfe ) { } catch ( ClassNotFoundException cnfe ) { } } } catch ( IOException ioe ) { throw new BuildException ( "Can't load default task list" ) ; } String dataDefs = "/org/apache/tools/ant/types/defaults.properties" ; try { Properties props = new Properties ( ) ; InputStream in = this . getClass ( ) . getResourceAsStream ( dataDefs ) ; if ( in == null ) { throw new BuildException ( "Can't load default datatype list" ) ; } props . load ( in ) ; in . close ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; String value = props . getProperty ( key ) ; try { Class dataClass = Class . forName ( value ) ; addDataTypeDefinition ( key , dataClass ) ; } catch ( NoClassDefFoundError ncdfe ) { } catch ( ClassNotFoundException cnfe ) { } } } catch ( IOException ioe ) { throw new BuildException ( "Can't load default datatype list" ) ; } Properties systemP = System . getProperties ( ) ; Enumeration e = systemP . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) systemP . get ( name ) ; this . setProperty ( name , value ) ; } } public void addBuildListener ( BuildListener listener ) { listeners . addElement ( listener ) ; } public void removeBuildListener ( BuildListener listener ) { listeners . removeElement ( listener ) ; } public Vector getBuildListeners ( ) { return listeners ; } public void log ( String msg ) { log ( msg , MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { fireMessageLogged ( this , msg , msgLevel ) ; } public void log ( Task task , String msg , int msgLevel ) { fireMessageLogged ( task , msg , msgLevel ) ; } public void log ( Target target , String msg , int msgLevel ) { fireMessageLogged ( target , msg , msgLevel ) ; } public void setProperty ( String name , String value ) { if ( null != userProperties . get ( name ) ) return ; log ( "Setting project property: " + name + " -> " + value , MSG_DEBUG ) ; properties . put ( name , value ) ; } public void setUserProperty ( String name , String value ) { log ( "Setting ro project property: " + name + " -> " + value , MSG_DEBUG ) ; userProperties . put ( name , value ) ; properties . put ( name , value ) ; } public String getProperty ( String name ) { if ( name == null ) return null ; String property = ( String ) properties . get ( name ) ; return property ; } public String getUserProperty ( String name ) { if ( name == null ) return null ; String property = ( String ) userProperties . get ( name ) ; return property ; } public Hashtable getProperties ( ) { return properties ; } public Hashtable getUserProperties ( ) { return userProperties ; } public void setDefaultTarget ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public String getDefaultTarget ( ) { return defaultTarget ; } public void setDefault ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public void setName ( String name ) { setUserProperty ( "ant.project.name" , name ) ; this . name = name ; } public String getName ( ) { return name ; } public void addFilter ( String token , String value ) { if ( token == null ) return ; log ( "Setting token to filter: " + token + " -> " + value , MSG_DEBUG ) ; this . filters . put ( token , value ) ; } public Hashtable getFilters ( ) { return filters ; } public void setBasedir ( String baseD ) throws BuildException { try { setBaseDir ( new File ( new File ( baseD ) . getCanonicalPath ( ) ) ) ; } catch ( IOException ioe ) { String msg = "Can't set basedir " + baseD + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } public void setBaseDir ( File baseDir ) { this . baseDir = baseDir ; setProperty ( "basedir" , baseDir . getAbsolutePath ( ) ) ; String msg = "Project base dir set to: " + baseDir ; log ( msg , MSG_VERBOSE ) ; } public File getBaseDir ( ) { if ( baseDir == null ) { try { setBasedir ( "." ) ; } catch ( BuildException ex ) { ex . printStackTrace ( ) ; } } return baseDir ; } public static String getJavaVersion ( ) { return javaVersion ; } public void setJavaVersionProperty ( ) { setProperty ( "ant.java.version" , javaVersion ) ; if ( javaVersion == JAVA_1_0 ) { throw new BuildException ( "Ant cannot work on Java 1.0" ) ; } log ( "Detected Java Version: " + javaVersion , MSG_VERBOSE ) ; log ( "Detected OS: " + System . getProperty ( "os.name" ) , MSG_VERBOSE ) ; } public void addTaskDefinition ( String taskName , Class taskClass ) { String msg = " +User task: " + taskName + "     " + taskClass . getName ( ) ; log ( msg , MSG_DEBUG ) ; taskClassDefinitions . put ( taskName , taskClass ) ; } public Hashtable getTaskDefinitions ( ) { return taskClassDefinitions ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { String msg = " +User datatype: " + typeName + "     " + typeClass . getName ( ) ; log ( msg , MSG_DEBUG ) ; dataClassDefinitions . put ( typeName , typeClass ) ; } public Hashtable getDataTypeDefinitions ( ) { return dataClassDefinitions ; } public void addTarget ( Target target ) { String name = target . getName ( ) ; if ( targets . get ( name ) != null ) { throw new BuildException ( "Duplicate target: `" + name + "'" ) ; } addOrReplaceTarget ( name , target ) ; } public void addTarget ( String targetName , Target target ) throws BuildException { if ( targets . get ( targetName ) != null ) { throw new BuildException ( "Duplicate target: `" + targetName + "'" ) ; } addOrReplaceTarget ( targetName , target ) ; } public void addOrReplaceTarget ( Target target ) { addOrReplaceTarget ( target . getName ( ) , target ) ; } public void addOrReplaceTarget ( String targetName , Target target ) { String msg = " +Target: " + targetName ; log ( msg , MSG_DEBUG ) ; target . setProject ( this ) ; targets . put ( targetName , target ) ; } public Hashtable getTargets ( ) { return targets ; } public Task createTask ( String taskType ) throws BuildException { Class c = ( Class ) taskClassDefinitions . get ( taskType ) ; if ( c == null ) return null ; try { Object o = c . newInstance ( ) ; Task task = null ; if ( o instanceof Task ) { task = ( Task ) o ; } else { TaskAdapter taskA = new TaskAdapter ( ) ; taskA . setProxy ( o ) ; task = taskA ; } task . setProject ( this ) ; task . setTaskType ( taskType ) ; task . setTaskName ( taskType ) ; String msg = "   +Task: " + taskType ; log ( msg , MSG_DEBUG ) ; return task ; } catch ( Throwable t ) { String msg = "Could not create task of type: " + taskType + " due to " + t ; throw new BuildException ( msg , t ) ; } } public Object createDataType ( String typeName ) throws BuildException { Class c = ( Class ) dataClassDefinitions . get ( typeName ) ; if ( c == null ) return null ; try { java . lang . reflect . Constructor ctor = null ; boolean noArg = false ; try { ctor = c . getConstructor ( new Class [ 0 ] ) ; noArg = true ; } catch ( NoSuchMethodException nse ) { ctor = c . getConstructor ( new Class [ ] { getClass ( ) } ) ; noArg = false ; } Object o = null ; if ( noArg ) { o = ctor . newInstance ( new Object [ 0 ] ) ; } else { o = ctor . newInstance ( new Object [ ] { this } ) ; } String msg = "   +DataType: " + typeName ; log ( msg , MSG_DEBUG ) ; return o ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; String msg = "Could not create datatype of type: " + typeName + " due to " + t ; throw new BuildException ( msg , t ) ; } catch ( Throwable t ) { String msg = "Could not create datatype of type: " + typeName + " due to " + t ; throw new BuildException ( msg , t ) ; } } public void executeTargets ( Vector targetNames ) throws BuildException { Throwable error = null ; for ( int i = 0 ; i < targetNames . size ( ) ; i ++ ) { executeTarget ( ( String ) targetNames . elementAt ( i ) ) ; } } public void executeTarget ( String targetName ) throws BuildException { if ( targetName == null ) { String msg = "No target specified" ; throw new BuildException ( msg ) ; } Vector sortedTargets = topoSort ( targetName , targets ) ; int curidx = 0 ; Target curtarget ; do { curtarget = ( Target ) sortedTargets . elementAt ( curidx ++ ) ; runTarget ( curtarget ) ; } while ( ! curtarget . getName ( ) . equals ( targetName ) ) ; } public File resolveFile ( String fileName ) { fileName = fileName . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( fileName . startsWith ( File . separator ) ) { try { return new File ( new File ( fileName ) . getCanonicalPath ( ) ) ; } catch ( IOException e ) { log ( "IOException getting canonical path for " + fileName + ": " + e . getMessage ( ) , MSG_ERR ) ; return new File ( fileName ) ; } } if ( fileName . length ( ) >= 2 && Character . isLetter ( fileName . charAt ( 0 ) ) && fileName . charAt ( 1 ) == ':' ) { char [ ] ca = fileName . replace ( '/' , '\\' ) . toCharArray ( ) ; char c ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ca . length ; i ++ ) { if ( ( ca [ i ] != '\\' ) || ( ca [ i ] == '\\' && i > 0 && ca [ i - 1 ] != '\\' ) ) { if ( i == 0 && Character . isLetter ( ca [ i ] ) && i < ca . length - 1 && ca [ i + 1 ] == ':' ) { c = Character . toUpperCase ( ca [ i ] ) ; } else { c = ca [ i ] ; } sb . append ( c ) ; } } return new File ( sb . toString ( ) ) ; } File file = new File ( baseDir . getAbsolutePath ( ) ) ; StringTokenizer tok = new StringTokenizer ( fileName , File . separator , false ) ; while ( tok . hasMoreTokens ( ) ) { String part = tok . nextToken ( ) ; if ( part . equals ( ".." ) ) { String parentFile = file . getParent ( ) ; if ( parentFile == null ) { throw new BuildException ( "The file or path you specified (" + fileName + ") is invalid releative to " + baseDir . getAbsolutePath ( ) ) ; } file = new File ( parentFile ) ; } else if ( part . equals ( "." ) ) { } else { file = new File ( file , part ) ; } } try { return new File ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { log ( "IOException getting canonical path for " + file + ": " + e . getMessage ( ) , MSG_ERR ) ; return new File ( file . getAbsolutePath ( ) ) ; } } static public String translatePath ( String to_process ) { if ( to_process == null || to_process . length ( ) == 0 ) { return "" ; } StringBuffer path = new StringBuffer ( to_process . length ( ) + 50 ) ; PathTokenizer tokenizer = new PathTokenizer ( to_process ) ; while ( tokenizer . hasMoreTokens ( ) ) { String pathComponent = tokenizer . nextToken ( ) ; pathComponent = pathComponent . replace ( '/' , File . separatorChar ) ; pathComponent = pathComponent . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) != 0 ) { path . append ( File . pathSeparatorChar ) ; } path . append ( pathComponent ) ; } return path . toString ( ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , false ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filtering ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filtering , overwrite ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filtering , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , false ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering ) throws IOException { copyFile ( sourceFile , destFile , filtering , false ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filtering , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { if ( overwrite || destFile . lastModified ( ) < sourceFile . lastModified ( ) ) { log ( "Copy: " + sourceFile . getAbsolutePath ( ) + " -> " + destFile . getAbsolutePath ( ) , MSG_VERBOSE ) ; File parent = new File ( destFile . getParent ( ) ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } if ( filtering ) { BufferedReader in = new BufferedReader ( new FileReader ( sourceFile ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( destFile ) ) ; int length ; String newline = null ; String line = in . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { newline = replace ( line , filters ) ; out . write ( newline ) ; out . newLine ( ) ; } line = in . readLine ( ) ; } out . close ( ) ; in . close ( ) ; } else { FileInputStream in = new FileInputStream ( sourceFile ) ; FileOutputStream out = new FileOutputStream ( destFile ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . close ( ) ; out . close ( ) ; } if ( preserveLastModified ) { setFileLastModified ( destFile , sourceFile . lastModified ( ) ) ; } } } void setFileLastModified ( File file , long time ) throws BuildException { if ( getJavaVersion ( ) == JAVA_1_1 ) { log ( "Cannot change the modification time of " + file + " in JDK 1.1" , Project . MSG_WARN ) ; return ; } if ( setLastModified == null ) { synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse ) ; } } } } Long [ ] times = new Long [ 1 ] ; if ( time < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( time ) ; } try { log ( "Setting modification time for " + file , MSG_VERBOSE ) ; setLastModified . invoke ( file , times ) ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time " + "of " + file , nested ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time " + "of " + file , other ) ; } } private String replace ( String s , Hashtable tokens ) { int index = s . indexOf ( TOKEN_START ) ; if ( index > - 1 ) { try { StringBuffer b = new StringBuffer ( ) ; int i = 0 ; String token = null ; String value = null ; do { int endIndex = s . indexOf ( TOKEN_END , index + TOKEN_START . length ( ) + 1 ) ; if ( endIndex == - 1 ) { break ; } token = s . substring ( index + TOKEN_START . length ( ) , endIndex ) ; b . append ( s . substring ( i , index ) ) ; if ( tokens . containsKey ( token ) ) { value = ( String ) tokens . get ( token ) ; log ( "Replacing: " + TOKEN_START + token + TOKEN_END + " -> " + value , MSG_VERBOSE ) ; b . append ( value ) ; i = index + TOKEN_START . length ( ) + token . length ( ) + TOKEN_END . length ( ) ; } else { b . append ( TOKEN_START ) ; i = index + TOKEN_START . length ( ) ; } } while ( ( index = s . indexOf ( TOKEN_START , i ) ) > - 1 ) ; b . append ( s . substring ( i ) ) ; return b . toString ( ) ; } catch ( StringIndexOutOfBoundsException e ) { return s ; } } else { return s ; } } public static boolean toBoolean ( String s ) { return ( s . equalsIgnoreCase ( "on" ) || s . equalsIgnoreCase ( "true" ) || s . equalsIgnoreCase ( "yes" ) ) ; } public void runTarget ( Target target ) throws BuildException { try { fireTargetStarted ( target ) ; target . execute ( ) ; fireTargetFinished ( target , null ) ; } catch ( RuntimeException exc ) { fireTargetFinished ( target , exc ) ; throw exc ; } } public final Vector topoSort ( String root , Hashtable targets ) throws BuildException { Vector ret = new Vector ( ) ; Hashtable state = new Hashtable ( ) ; Stack visiting = new Stack ( ) ; tsort ( root , targets , state , visiting , ret ) ; log ( "Build sequence for target `" + root + "' is " + ret , MSG_VERBOSE ) ; for ( Enumeration en = targets . keys ( ) ; en . hasMoreElements ( ) ; ) { String curTarget = ( String ) ( en . nextElement ( ) ) ; String st = ( String ) state . get ( curTarget ) ; if ( st == null ) { tsort ( curTarget , targets , state , visiting , ret ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + curTarget ) ; } } log ( "Complete build sequence is " + ret , MSG_VERBOSE ) ; return ret ; } private final void tsort ( String root , Hashtable targets , Hashtable state , Stack visiting , Vector ret ) throws BuildException { state . put ( root , VISITING ) ; visiting . push ( root ) ; Target target = ( Target ) ( targets . get ( root ) ) ; if ( target == null ) { StringBuffer sb = new StringBuffer ( "Target `" ) ; sb . append ( root ) ; sb . append ( "' does not exist in this project. " ) ; visiting . pop ( ) ; if ( ! visiting . empty ( ) ) { String parent = ( String ) visiting . peek ( ) ; sb . append ( "It is used from target `" ) ; sb . append ( parent ) ; sb . append ( "'." ) ; } throw new BuildException ( new String ( sb ) ) ; } for ( Enumeration en = target . getDependencies ( ) ; en . hasMoreElements ( ) ; ) { String cur = ( String ) en . nextElement ( ) ; String m = ( String ) state . get ( cur ) ; if ( m == null ) { tsort ( cur , targets , state , visiting , ret ) ; } else if ( m == VISITING ) { throw makeCircularException ( cur , visiting ) ; } } String p = ( String ) visiting . pop ( ) ; if ( root != p ) { throw new RuntimeException ( "Unexpected internal error: expected to pop " + root + " but got " + p ) ; } state . put ( root , VISITED ) ; ret . addElement ( target ) ; } private static BuildException makeCircularException ( String end , Stack stk ) { StringBuffer sb = new StringBuffer ( "Circular dependency: " ) ; sb . append ( end ) ; String c ; do { c = ( String ) stk . pop ( ) ; sb . append ( " <- " ) ; sb . append ( c ) ; } while ( ! c . equals ( end ) ) ; return new BuildException ( new String ( sb ) ) ; } public void addReference ( String name , Object value ) { references . put ( name , value ) ; } public Hashtable getReferences ( ) { return references ; } protected void fireBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . buildStarted ( event ) ; } } protected void fireBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . buildFinished ( event ) ; } } protected void fireTargetStarted ( Target target ) { BuildEvent event = new BuildEvent ( target ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . targetStarted ( event ) ; } } protected void fireTargetFinished ( Target target , Throwable exception ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( exception ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . targetFinished ( event ) ; } } protected void fireTaskStarted ( Task task ) { BuildEvent event = new BuildEvent ( task ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . taskStarted ( event ) ; } } protected void fireTaskFinished ( Task task , Throwable exception ) { BuildEvent event = new BuildEvent ( task ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . taskFinished ( event ) ; } } private void fireMessageLoggedEvent ( BuildEvent event , String message , int priority ) { event . setMessage ( message , priority ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . messageLogged ( event ) ; } } protected void fireMessageLogged ( Project project , String message , int priority ) { BuildEvent event = new BuildEvent ( project ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Target target , String message , int priority ) { BuildEvent event = new BuildEvent ( target ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Task task , String message , int priority ) { BuildEvent event = new BuildEvent ( task ) ; fireMessageLoggedEvent ( event , message , priority ) ; } } 	1	['71', '1', '0', '103', '186', '2247', '99', '7', '55', '0.97244898', '2193', '0.571428571', '0', '0', '0.127731092', '0', '0', '29.49295775', '18', '1.5775', '1']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . Random ; public abstract class DefaultCompilerAdapter implements CompilerAdapter { protected Path src ; protected File destDir ; protected String encoding ; protected boolean debug = false ; protected boolean optimize = false ; protected boolean deprecation = false ; protected boolean depend = false ; protected boolean verbose = false ; protected String target ; protected Path bootclasspath ; protected Path extdirs ; protected Path compileClasspath ; protected Project project ; protected Location location ; protected boolean includeAntRuntime ; protected boolean includeJavaRuntime ; protected File [ ] compileList ; protected static String lSep = System . getProperty ( "line.separator" ) ; protected Javac attributes ; public void setJavac ( Javac attributes ) { this . attributes = attributes ; src = attributes . getSrcdir ( ) ; destDir = attributes . getDestdir ( ) ; encoding = attributes . getEncoding ( ) ; debug = attributes . getDebug ( ) ; optimize = attributes . getOptimize ( ) ; deprecation = attributes . getDeprecation ( ) ; depend = attributes . getDepend ( ) ; verbose = attributes . getVerbose ( ) ; target = attributes . getTarget ( ) ; bootclasspath = attributes . getBootclasspath ( ) ; extdirs = attributes . getExtdirs ( ) ; compileList = attributes . getFileList ( ) ; compileClasspath = attributes . getClasspath ( ) ; project = attributes . getProject ( ) ; location = attributes . getLocation ( ) ; includeAntRuntime = attributes . getIncludeantruntime ( ) ; includeJavaRuntime = attributes . getIncludejavaruntime ( ) ; } public Javac getJavac ( ) { return attributes ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( project ) ; if ( destDir != null ) { classpath . setLocation ( destDir ) ; } if ( compileClasspath == null ) { if ( includeAntRuntime ) { classpath . addExisting ( Path . systemClasspath ) ; } } else { if ( includeAntRuntime ) { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "ignore" ) ) ; } } if ( includeJavaRuntime ) { if ( System . getProperty ( "java.vendor" ) . toLowerCase ( ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; classpath . addFileset ( msZipFiles ) ; } else if ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "classes.zip" ) ) ; } else { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; } } return classpath ; } protected Commandline setupJavacCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = getCompileClasspath ( ) ; if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { cmd . createArgument ( ) . setValue ( classpath . toString ( ) + File . pathSeparator + src . toString ( ) ) ; } else { cmd . createArgument ( ) . setPath ( classpath ) ; cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( src ) ; if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } } if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( bootclasspath != null ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bootclasspath ) ; } if ( extdirs != null ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } if ( depend ) { if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } else if ( Project . getJavaVersion ( ) . startsWith ( "1.2" ) ) { cmd . createArgument ( ) . setValue ( "-Xdepend" ) ; } else { attributes . log ( "depend attribute is not supported by the modern compiler" , Project . MSG_WARN ) ; } } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { attributes . log ( "Compilation args: " + cmd . toString ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . length != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; for ( int i = 0 ; i < compileList . length ; i ++ ) { String arg = compileList [ i ] . getAbsolutePath ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg + lSep ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName ) { String [ ] commandArray = null ; File tmpFile = null ; try { if ( Commandline . toString ( args ) . length ( ) > 4096 ) { PrintWriter out = null ; try { tmpFile = new File ( "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + tmpFile . getAbsolutePath ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { Execute exe = new Execute ( new LogStreamHandler ( attributes , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; return exe . getExitValue ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running " + args [ 0 ] + " compiler" , e , location ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void addExtdirsToClasspath ( Path classpath ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( project , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( ! dirs [ i ] . endsWith ( File . separator ) ) { dirs [ i ] += File . separator ; } File dir = project . resolveFile ( dirs [ i ] ) ; FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; classpath . addFileset ( fs ) ; } } } 	1	['10', '1', '4', '17', '81', '5', '4', '13', '4', '0.783625731', '743', '1', '7', '0', '0.259259259', '0', '0', '71.4', '14', '4.2', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . * ; import java . io . * ; import java . util . * ; public class Replace extends MatchingTask { private File src = null ; private NestedString token = null ; private NestedString value = new NestedString ( ) ; private File propertyFile = null ; private Properties properties = null ; private Vector replacefilters = new Vector ( ) ; private File dir = null ; public class NestedString { private StringBuffer buf = new StringBuffer ( ) ; public void addText ( String val ) { buf . append ( val ) ; } public String getText ( ) { return buf . toString ( ) ; } } public class Replacefilter { private String token ; private String value ; private String property ; public void validate ( ) throws BuildException { if ( token == null ) { String message = "token is a mandatory attribute " + "of replacefilter." ; throw new BuildException ( message ) ; } if ( "" . equals ( token ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message ) ; } if ( ( value != null ) && ( property != null ) ) { String message = "Either value or property " + "can be specified, but a replacefilter " + "element cannot have both." ; throw new BuildException ( message ) ; } if ( ( property != null ) ) { if ( propertyFile == null ) { String message = "The replacefilter's property attribute " + "can only be used with the replacetask's " + "propertyFile attribute." ; throw new BuildException ( message ) ; } if ( properties == null || properties . getProperty ( property ) == null ) { String message = "property \"" + property + "\" was not found in " + propertyFile . getPath ( ) ; throw new BuildException ( message ) ; } } } public String getReplaceValue ( ) { if ( property != null ) { return ( String ) properties . getProperty ( property ) ; } else if ( value != null ) { return value ; } else if ( Replace . this . value != null ) { return Replace . this . value . getText ( ) ; } else { return new String ( "" ) ; } } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setProperty ( String property ) { this . property = property ; } public String getProperty ( ) { return property ; } } public void execute ( ) throws BuildException { validateAttributes ( ) ; if ( propertyFile != null ) { properties = getProperties ( propertyFile ) ; } validateReplacefilters ( ) ; if ( src != null ) { processFile ( src ) ; } if ( dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] srcs = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < srcs . length ; i ++ ) { File file = new File ( dir , srcs [ i ] ) ; processFile ( file ) ; } } } public void validateAttributes ( ) throws BuildException { if ( src == null && dir == null ) { String message = "Either the file or the dir attribute " + "must be specified" ; throw new BuildException ( message , location ) ; } if ( propertyFile != null && ! propertyFile . exists ( ) ) { String message = "Property file " + propertyFile . getPath ( ) + " does not exist." ; throw new BuildException ( message , location ) ; } if ( token == null && replacefilters . size ( ) == 0 ) { String message = "Either token or a nested replacefilter " + "must be specified" ; throw new BuildException ( message , location ) ; } if ( token != null && "" . equals ( token . getText ( ) ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message , location ) ; } } public void validateReplacefilters ( ) throws BuildException { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter element = ( Replacefilter ) replacefilters . elementAt ( i ) ; element . validate ( ) ; } } public Properties getProperties ( File propertyFile ) throws BuildException { Properties properties = new Properties ( ) ; try { properties . load ( new FileInputStream ( propertyFile ) ) ; } catch ( FileNotFoundException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") not found." ; throw new BuildException ( message ) ; } catch ( IOException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") cannot be loaded." ; throw new BuildException ( message ) ; } return properties ; } private void processFile ( File src ) throws BuildException { if ( ! src . exists ( ) ) { throw new BuildException ( "Replace: source file " + src . getPath ( ) + " doesn't exist" , location ) ; } File temp = new File ( src . getPath ( ) + ".temp" ) ; if ( temp . exists ( ) ) { throw new BuildException ( "Replace: temporary file " + temp . getPath ( ) + " already exists" , location ) ; } try { BufferedReader br = new BufferedReader ( new FileReader ( src ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( temp ) ) ; int fileLength = ( int ) ( src . length ( ) ) ; char [ ] tmpBuf = new char [ fileLength ] ; int numread = 0 ; int totread = 0 ; while ( numread != - 1 && totread < fileLength ) { numread = br . read ( tmpBuf , totread , fileLength ) ; totread += numread ; } String buf = new String ( tmpBuf ) ; String newString = new String ( buf ) ; if ( token != null ) { String linesep = System . getProperty ( "line.separator" ) ; String val = stringReplace ( value . getText ( ) , "\n" , linesep ) ; String tok = stringReplace ( token . getText ( ) , "\n" , linesep ) ; log ( "Replacing in " + src . getPath ( ) + ": " + token . getText ( ) + " --> " + value . getText ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , tok , val ) ; } if ( replacefilters . size ( ) > 0 ) { newString = processReplacefilters ( newString , src . getPath ( ) ) ; } boolean changes = ! newString . equals ( buf ) ; if ( changes ) { bw . write ( newString , 0 , newString . length ( ) ) ; bw . flush ( ) ; } bw . close ( ) ; br . close ( ) ; if ( changes ) { src . delete ( ) ; temp . renameTo ( src ) ; } else { temp . delete ( ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new BuildException ( ioe , location ) ; } } private String processReplacefilters ( String buffer , String filename ) { String newString = new String ( buffer ) ; for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; log ( "Replacing in " + filename + ": " + filter . getToken ( ) + " --> " + filter . getReplaceValue ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , filter . getToken ( ) , filter . getReplaceValue ( ) ) ; } return newString ; } public void setFile ( File file ) { this . src = file ; } public void setDir ( File dir ) { this . dir = dir ; } public void setToken ( String token ) { createReplaceToken ( ) . addText ( token ) ; } public void setValue ( String value ) { createReplaceValue ( ) . addText ( value ) ; } public NestedString createReplaceToken ( ) { if ( token == null ) { token = new NestedString ( ) ; } return token ; } public NestedString createReplaceValue ( ) { return value ; } public void setPropertyFile ( String filename ) { propertyFile = project . resolveFile ( filename ) ; } public Replacefilter createReplacefilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . addElement ( filter ) ; return filter ; } private String stringReplace ( String str , String str1 , String str2 ) { StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = str . indexOf ( str1 ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( str . substring ( start , found ) ) ; } if ( str2 != null ) { ret . append ( str2 ) ; } start = found + str1 . length ( ) ; found = str . indexOf ( str1 , start ) ; } if ( str . length ( ) > start ) { ret . append ( str . substring ( start , str . length ( ) ) ) ; } return ret . toString ( ) ; } } 	1	['19', '4', '0', '8', '69', '91', '2', '8', '13', '0.777777778', '632', '1', '2', '0.8125', '0.368421053', '1', '1', '31.89473684', '5', '1.2632', '1']
package org . apache . tools . ant . types ; import java . util . * ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private SysProperties sysProperties = new SysProperties ( ) ; private Path classpath = null ; private String vmVersion ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; public String [ ] getVariables ( ) throws BuildException { String props [ ] = super . getVariables ( ) ; if ( props == null ) return null ; for ( int i = 0 ; i < props . length ; i ++ ) { props [ i ] = "-D" + props [ i ] ; } return props ; } public int size ( ) { return variables . size ( ) ; } public void setSystem ( ) throws BuildException { try { Properties p = new Properties ( sys = System . getProperties ( ) ) ; for ( Enumeration e = variables . elements ( ) ; e . hasMoreElements ( ) ; ) { Environment . Variable v = ( Environment . Variable ) e . nextElement ( ) ; p . put ( v . getKey ( ) , v . getValue ( ) ) ; } System . setProperties ( p ) ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public void restoreSystem ( ) throws BuildException { if ( sys == null ) throw new BuildException ( "Unbalanced nesting of SysProperties" ) ; try { System . setProperties ( sys ) ; sys = null ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public Object clone ( ) { try { SysProperties c = ( SysProperties ) super . clone ( ) ; c . variables = ( Vector ) variables . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { return null ; } } } public CommandlineJava ( ) { setVm ( "java" ) ; setVmversion ( org . apache . tools . ant . Project . getJavaVersion ( ) ) ; } public Commandline . Argument createArgument ( ) { return javaCommand . createArgument ( ) ; } public Commandline . Argument createVmArgument ( ) { return vmCommand . createArgument ( ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public void setVm ( String vm ) { vmCommand . setExecutable ( vm ) ; } public void setVmversion ( String value ) { vmVersion = value ; } public void setClassname ( String classname ) { javaCommand . setExecutable ( classname ) ; } public String getClassname ( ) { return javaCommand . getExecutable ( ) ; } public Path createClasspath ( Project p ) { if ( classpath == null ) { classpath = new Path ( p ) ; } return classpath ; } public String getVmversion ( ) { return vmVersion ; } public String [ ] getCommandline ( ) { Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; int size = vmCommand . size ( ) + javaCommand . size ( ) + sysProperties . size ( ) ; if ( fullClasspath != null && fullClasspath . size ( ) > 0 ) { size += 2 ; } String [ ] result = new String [ size ] ; System . arraycopy ( vmCommand . getCommandline ( ) , 0 , result , 0 , vmCommand . size ( ) ) ; int pos = vmCommand . size ( ) ; if ( sysProperties . size ( ) > 0 ) { System . arraycopy ( sysProperties . getVariables ( ) , 0 , result , pos , sysProperties . size ( ) ) ; pos += sysProperties . size ( ) ; } if ( fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { result [ pos ++ ] = "-classpath" ; result [ pos ++ ] = fullClasspath . toString ( ) ; } System . arraycopy ( javaCommand . getCommandline ( ) , 0 , result , pos , javaCommand . size ( ) ) ; return result ; } public String toString ( ) { return Commandline . toString ( getCommandline ( ) ) ; } public int size ( ) { int size = vmCommand . size ( ) + javaCommand . size ( ) ; if ( classpath != null && classpath . size ( ) > 0 ) { size += 2 ; } return size ; } public Commandline getJavaCommand ( ) { return javaCommand ; } public Commandline getVmCommand ( ) { return vmCommand ; } public Path getClasspath ( ) { return classpath ; } public void setSystemProperties ( ) throws BuildException { sysProperties . setSystem ( ) ; } public void restoreSystemProperties ( ) throws BuildException { sysProperties . restoreSystem ( ) ; } public SysProperties getSystemProperties ( ) { return sysProperties ; } public Object clone ( ) { CommandlineJava c = new CommandlineJava ( ) ; c . vmCommand = ( Commandline ) vmCommand . clone ( ) ; c . javaCommand = ( Commandline ) javaCommand . clone ( ) ; c . sysProperties = ( SysProperties ) sysProperties . clone ( ) ; if ( classpath != null ) { c . classpath = ( Path ) classpath . clone ( ) ; } c . vmVersion = vmVersion ; return c ; } public void clearJavaArgs ( ) { javaCommand . clearArgs ( ) ; } } 	1	['21', '1', '0', '9', '47', '48', '1', '8', '21', '0.68', '277', '1', '4', '0', '0.30952381', '0', '0', '11.95238095', '7', '1.4286', '1']
package org . apache . tools . ant ; import java . util . * ; public class Target { private String name ; private String ifCondition = "" ; private String unlessCondition = "" ; private Vector dependencies = new Vector ( 2 ) ; private Vector tasks = new Vector ( 5 ) ; private Project project ; private String description = null ; public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setDepends ( String depS ) { if ( depS . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depS , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { addDependency ( tok . nextToken ( ) . trim ( ) ) ; } } } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void addTask ( Task task ) { tasks . addElement ( task ) ; } public Task [ ] getTasks ( ) { Task [ ] retval = new Task [ tasks . size ( ) ] ; tasks . copyInto ( retval ) ; return retval ; } public void addDependency ( String dependency ) { dependencies . addElement ( dependency ) ; } public Enumeration getDependencies ( ) { return dependencies . elements ( ) ; } public void setIf ( String property ) { this . ifCondition = ( property == null ) ? "" : property ; } public void setUnless ( String property ) { this . unlessCondition = ( property == null ) ? "" : property ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public String toString ( ) { return name ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { Enumeration enum = tasks . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Task task = ( Task ) enum . nextElement ( ) ; try { project . fireTaskStarted ( task ) ; task . maybeConfigure ( ) ; task . execute ( ) ; project . fireTaskFinished ( task , null ) ; } catch ( RuntimeException exc ) { if ( exc instanceof BuildException ) { BuildException be = ( BuildException ) exc ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( task . getLocation ( ) ) ; } } project . fireTaskFinished ( task , exc ) ; throw exc ; } } } else if ( ! testIfCondition ( ) ) { project . log ( this , "Skipped because property '" + this . ifCondition + "' not set." , Project . MSG_VERBOSE ) ; } else { project . log ( this , "Skipped because property '" + this . unlessCondition + "' set." , Project . MSG_VERBOSE ) ; } } void replaceTask ( UnknownElement el , Task t ) { int index = - 1 ; while ( ( index = tasks . indexOf ( el ) ) >= 0 ) { tasks . setElementAt ( t , index ) ; } } private boolean testIfCondition ( ) { return "" . equals ( ifCondition ) || project . getProperty ( ifCondition ) != null ; } private boolean testUnlessCondition ( ) { return "" . equals ( unlessCondition ) || project . getProperty ( unlessCondition ) == null ; } } 	1	['19', '1', '0', '18', '47', '97', '16', '5', '16', '0.833333333', '273', '1', '1', '0', '0.305263158', '0', '0', '13', '3', '1.4211', '1']
package org . apache . tools . ant ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . lang . reflect . * ; import java . io . File ; import java . util . * ; public class IntrospectionHelper { private Hashtable attributeTypes ; private Hashtable attributeSetters ; private Hashtable nestedTypes ; private Hashtable nestedCreators ; private Method addText = null ; private Class bean ; private static Hashtable helpers = new Hashtable ( ) ; private IntrospectionHelper ( final Class bean ) { attributeTypes = new Hashtable ( ) ; attributeSetters = new Hashtable ( ) ; nestedTypes = new Hashtable ( ) ; nestedCreators = new Hashtable ( ) ; this . bean = bean ; Method [ ] methods = bean . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method m = methods [ i ] ; final String name = m . getName ( ) ; Class returnType = m . getReturnType ( ) ; Class [ ] args = m . getParameterTypes ( ) ; if ( org . apache . tools . ant . Task . class . isAssignableFrom ( bean ) && args . length == 1 && ( ( "setLocation" . equals ( name ) && org . apache . tools . ant . Location . class . equals ( args [ 0 ] ) ) || ( "setTaskType" . equals ( name ) && java . lang . String . class . equals ( args [ 0 ] ) ) ) ) { continue ; } if ( "addText" . equals ( name ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && java . lang . String . class . equals ( args [ 0 ] ) ) { addText = methods [ i ] ; } else if ( name . startsWith ( "set" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! args [ 0 ] . isArray ( ) ) { String propName = getPropertyName ( name , "set" ) ; AttributeSetter as = createAttributeSetter ( m , args [ 0 ] ) ; if ( as != null ) { attributeTypes . put ( propName , args [ 0 ] ) ; attributeSetters . put ( propName , as ) ; } } else if ( name . startsWith ( "create" ) && ! returnType . isArray ( ) && ! returnType . isPrimitive ( ) && args . length == 0 ) { String propName = getPropertyName ( name , "create" ) ; nestedTypes . put ( propName , returnType ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException { return m . invoke ( parent , new Object [ ] { } ) ; } } ) ; } else if ( name . startsWith ( "add" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { final Constructor c = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; String propName = getPropertyName ( name , "add" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException { Object o = c . newInstance ( new Object [ ] { } ) ; m . invoke ( parent , new Object [ ] { o } ) ; return o ; } } ) ; } catch ( NoSuchMethodException nse ) { } } } } public synchronized static IntrospectionHelper getHelper ( Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) helpers . get ( c ) ; if ( ih == null ) { ih = new IntrospectionHelper ( c ) ; helpers . put ( c , ih ) ; } return ih ; } public void setAttribute ( Project p , Object element , String attributeName , String value ) throws BuildException { AttributeSetter as = ( AttributeSetter ) attributeSetters . get ( attributeName ) ; if ( as == null ) { String msg = "Class " + element . getClass ( ) . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute" ; throw new BuildException ( msg ) ; } try { as . set ( p , element , value ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void addText ( Object element , String text ) { if ( addText == null ) { String msg = "Class " + element . getClass ( ) . getName ( ) + " doesn't support nested text elements" ; throw new BuildException ( msg ) ; } try { addText . invoke ( element , new String [ ] { text } ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Object createElement ( Object element , String elementName ) throws BuildException { NestedCreator nc = ( NestedCreator ) nestedCreators . get ( elementName ) ; if ( nc == null ) { String msg = "Class " + element . getClass ( ) . getName ( ) + " doesn't support the nested \"" + elementName + "\" element" ; throw new BuildException ( msg ) ; } try { return nc . create ( element ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Class getElementType ( String elementName ) throws BuildException { Class nt = ( Class ) nestedTypes . get ( elementName ) ; if ( nt == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element" ; throw new BuildException ( msg ) ; } return nt ; } public Class getAttributeType ( String attributeName ) throws BuildException { Class at = ( Class ) attributeTypes . get ( attributeName ) ; if ( at == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute" ; throw new BuildException ( msg ) ; } return at ; } public boolean supportsCharacters ( ) { return addText != null ; } public Enumeration getAttributes ( ) { return attributeSetters . keys ( ) ; } public Enumeration getNestedElements ( ) { return nestedTypes . keys ( ) ; } private AttributeSetter createAttributeSetter ( final Method m , final Class arg ) { if ( java . lang . String . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new String [ ] { value } ) ; } } ; } else if ( java . lang . Character . class . equals ( arg ) || java . lang . Character . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Character [ ] { new Character ( value . charAt ( 0 ) ) } ) ; } } ; } else if ( java . lang . Byte . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Byte [ ] { new Byte ( value ) } ) ; } } ; } else if ( java . lang . Short . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Short [ ] { new Short ( value ) } ) ; } } ; } else if ( java . lang . Integer . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Integer [ ] { new Integer ( value ) } ) ; } } ; } else if ( java . lang . Long . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Long [ ] { new Long ( value ) } ) ; } } ; } else if ( java . lang . Float . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Float [ ] { new Float ( value ) } ) ; } } ; } else if ( java . lang . Double . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Double [ ] { new Double ( value ) } ) ; } } ; } else if ( java . lang . Boolean . class . equals ( arg ) || java . lang . Boolean . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Boolean [ ] { new Boolean ( Project . toBoolean ( value ) ) } ) ; } } ; } else if ( java . lang . Class . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Class [ ] { Class . forName ( value ) } ) ; } catch ( ClassNotFoundException ce ) { throw new BuildException ( ce ) ; } } } ; } else if ( java . io . File . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new File [ ] { p . resolveFile ( value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . Path . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Path [ ] { new Path ( p , value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . EnumeratedAttribute . class . isAssignableFrom ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { org . apache . tools . ant . types . EnumeratedAttribute ea = ( org . apache . tools . ant . types . EnumeratedAttribute ) arg . newInstance ( ) ; ea . setValue ( value ) ; m . invoke ( parent , new EnumeratedAttribute [ ] { ea } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } else { try { final Constructor c = arg . getConstructor ( new Class [ ] { java . lang . String . class } ) ; return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Object [ ] { c . newInstance ( new String [ ] { value } ) } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } catch ( NoSuchMethodException nme ) { } } return null ; } private String getPropertyName ( String methodName , String prefix ) { int start = prefix . length ( ) ; return methodName . substring ( start ) . toLowerCase ( ) ; } private interface NestedCreator { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; } private interface AttributeSetter { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException ; } } 	1	['14', '1', '0', '24', '63', '63', '20', '20', '9', '0.841346154', '822', '0.4375', '0', '0', '0.333333333', '0', '0', '56.57142857', '24', '2.7857', '2']
