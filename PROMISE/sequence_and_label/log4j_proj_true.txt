package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class ISO8601DateFormat extends AbsoluteTimeDateFormat { public ISO8601DateFormat ( ) { } public ISO8601DateFormat ( TimeZone timeZone ) { super ( timeZone ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; String month ; switch ( calendar . get ( Calendar . MONTH ) ) { case Calendar . JANUARY : month = "-01-" ; break ; case Calendar . FEBRUARY : month = "-02-" ; break ; case Calendar . MARCH : month = "-03-" ; break ; case Calendar . APRIL : month = "-04-" ; break ; case Calendar . MAY : month = "-05-" ; break ; case Calendar . JUNE : month = "-06-" ; break ; case Calendar . JULY : month = "-07-" ; break ; case Calendar . AUGUST : month = "-08-" ; break ; case Calendar . SEPTEMBER : month = "-09-" ; break ; case Calendar . OCTOBER : month = "-10-" ; break ; case Calendar . NOVEMBER : month = "-11-" ; break ; case Calendar . DECEMBER : month = "-12-" ; break ; default : month = "-NA-" ; break ; } sbuf . append ( month ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '12', '6', '2', '1', '4', '2', '99', '0', '0', '0.953488372', '0.357142857', '1', '3', '23.75', '3', '1', '0']
package org . apache . log4j . xml ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . DateLayout ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . XMLReaderFactory ; import org . xml . sax . SAXException ; import org . apache . xerces . parsers . SAXParser ; import org . apache . trax . Processor ; import org . apache . trax . TemplatesBuilder ; import org . apache . trax . Templates ; import org . apache . trax . Transformer ; import org . apache . trax . Result ; import org . apache . trax . ProcessorException ; import org . apache . trax . ProcessorFactoryException ; import org . apache . trax . TransformException ; import org . apache . serialize . SerializerFactory ; import org . apache . serialize . Serializer ; import org . apache . serialize . OutputFormat ; import org . xml . sax . helpers . AttributesImpl ; import java . io . FileOutputStream ; import java . io . IOException ; public class Transform { public static void main ( String [ ] args ) throws Exception { PropertyConfigurator . disableAll ( ) ; PropertyConfigurator . configure ( "x.lcf" ) ; Processor processor = Processor . newInstance ( "xslt" ) ; XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; TemplatesBuilder templatesBuilder = processor . getTemplatesBuilder ( ) ; reader . setContentHandler ( templatesBuilder ) ; if ( templatesBuilder instanceof LexicalHandler ) { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , templatesBuilder ) ; } reader . parse ( args [ 0 ] ) ; Templates templates = templatesBuilder . getTemplates ( ) ; Transformer transformer = templates . newTransformer ( ) ; FileOutputStream fos = new FileOutputStream ( args [ 2 ] ) ; Result result = new Result ( fos ) ; Serializer serializer = SerializerFactory . getSerializer ( "xml" ) ; serializer . setOutputStream ( fos ) ; transformer . setContentHandler ( serializer . asContentHandler ( ) ) ; org . xml . sax . ContentHandler chandler = transformer . getInputContentHandler ( ) ; DC dc = new DC ( chandler ) ; reader . setContentHandler ( dc ) ; if ( chandler instanceof LexicalHandler ) { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , chandler ) ; } else { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , null ) ; } reader . parse ( args [ 1 ] ) ; } } class DC implements ContentHandler { static Category cat = Category . getInstance ( "DC" ) ; ContentHandler chandler ; DC ( ContentHandler chandler ) { this . chandler = chandler ; } public void characters ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { cat . debug ( "characters: [" + new String ( ch , start , length ) + "] called" ) ; chandler . characters ( ch , start , length ) ; } public void endDocument ( ) throws org . xml . sax . SAXException { cat . debug ( "endDocument called." ) ; chandler . endDocument ( ) ; } public void endElement ( String namespaceURI , String localName , String qName ) throws org . xml . sax . SAXException { cat . debug ( "endElement(" + namespaceURI + ", " + localName + ", " + qName + ") called" ) ; chandler . endElement ( namespaceURI , localName , qName ) ; } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { cat . debug ( "endPrefixMapping(" + prefix + ") called" ) ; chandler . endPrefixMapping ( prefix ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { cat . debug ( "ignorableWhitespace called" ) ; chandler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( java . lang . String target , java . lang . String data ) throws org . xml . sax . SAXException { cat . debug ( "processingInstruction called" ) ; chandler . processingInstruction ( target , data ) ; } public void setDocumentLocator ( Locator locator ) { cat . debug ( "setDocumentLocator called" ) ; chandler . setDocumentLocator ( locator ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { cat . debug ( "skippedEntity(" + name + ")  called" ) ; chandler . skippedEntity ( name ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { cat . debug ( "startDocument called" ) ; chandler . startDocument ( ) ; } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws org . xml . sax . SAXException { cat . debug ( "startElement(" + namespaceURI + ", " + localName + ", " + qName + ")called" ) ; if ( "log4j:event" . equals ( qName ) ) { cat . debug ( "-------------" ) ; if ( atts instanceof org . xml . sax . helpers . AttributesImpl ) { AttributesImpl ai = ( AttributesImpl ) atts ; int i = atts . getIndex ( "timestamp" ) ; ai . setValue ( i , "hello" ) ; } String ts = atts . getValue ( "timestamp" ) ; cat . debug ( "New timestamp is " + ts ) ; } chandler . startElement ( namespaceURI , localName , qName , atts ) ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { cat . debug ( "startPrefixMapping(" + prefix + ", " + uri + ") called" ) ; chandler . startPrefixMapping ( prefix , uri ) ; } } 	0	['2', '1', '0', '0', '3', '1', '0', '0', '2', '2', '6', '0', '0', '0', '0.5', '0', '0', '2', '1', '0.5', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Appender ; import java . util . Vector ; import java . util . Enumeration ; public class AppenderAttachableImpl implements AppenderAttachable { protected Vector appenderList ; public void addAppender ( Appender newAppender ) { if ( newAppender == null ) return ; if ( appenderList == null ) { appenderList = new Vector ( 1 ) ; } if ( ! appenderList . contains ( newAppender ) ) appenderList . addElement ( newAppender ) ; } public int appendLoopOnAppenders ( LoggingEvent event ) { int size = 0 ; Appender appender ; if ( appenderList != null ) { size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; appender . doAppend ( event ) ; } } return size ; } public Enumeration getAllAppenders ( ) { if ( appenderList == null ) return null ; else return appenderList . elements ( ) ; } public Appender getAppender ( String name ) { if ( appenderList == null || name == null ) return null ; int size = appenderList . size ( ) ; Appender appender ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; if ( name . equals ( appender . getName ( ) ) ) return appender ; } return null ; } public void removeAllAppenders ( ) { if ( appenderList != null ) { int len = appenderList . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Appender a = ( Appender ) appenderList . elementAt ( i ) ; a . close ( ) ; } appenderList . removeAllElements ( ) ; appenderList = null ; } } public void removeAppender ( Appender appender ) { if ( appender == null || appenderList == null ) return ; appenderList . removeElement ( appender ) ; } public void removeAppender ( String name ) { if ( name == null || appenderList == null ) return ; int size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( name . equals ( ( ( Appender ) appenderList . elementAt ( i ) ) . getName ( ) ) ) { appenderList . removeElementAt ( i ) ; break ; } } } } 	0	['8', '1', '0', '6', '22', '0', '3', '3', '8', '0.142857143', '176', '1', '0', '0', '0.40625', '0', '0', '20.875', '5', '3.125', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . RelativeTimeDateFormat ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . helpers . DateTimeDateFormat ; import org . apache . log4j . helpers . ISO8601DateFormat ; import org . apache . log4j . spi . LoggingEvent ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . text . FieldPosition ; abstract public class DateLayout extends Layout { public final static String NULL_DATE_FORMAT = "NULL" ; public final static String RELATIVE_TIME_DATE_FORMAT = "RELATIVE" ; protected FieldPosition pos = new FieldPosition ( 0 ) ; final static public String DATE_FORMAT_OPTION = "DateFormat" ; final static public String TIMEZONE_OPTION = "TimeZone" ; private String timeZoneID ; private String dateFormatOption ; protected DateFormat dateFormat ; protected Date date = new Date ( ) ; public void activateOptions ( ) { setDateFormat ( dateFormatOption ) ; if ( timeZoneID != null && dateFormat != null ) { dateFormat . setTimeZone ( TimeZone . getTimeZone ( timeZoneID ) ) ; } } public String [ ] getOptionStrings ( ) { return new String [ ] { DATE_FORMAT_OPTION , TIMEZONE_OPTION } ; } public void dateFormat ( StringBuffer buf , LoggingEvent event ) { if ( dateFormat != null ) { date . setTime ( event . timeStamp ) ; dateFormat . format ( date , buf , this . pos ) ; buf . append ( ' ' ) ; } } public void setDateFormat ( DateFormat dateFormat , TimeZone timeZone ) { this . dateFormat = dateFormat ; this . dateFormat . setTimeZone ( timeZone ) ; } public void setDateFormat ( String dateFormatType ) { setDateFormat ( dateFormatType , TimeZone . getDefault ( ) ) ; } public void setDateFormat ( String dateFormatType , TimeZone timeZone ) { if ( dateFormatType == null ) { this . dateFormat = null ; return ; } if ( dateFormatType . equalsIgnoreCase ( NULL_DATE_FORMAT ) ) { this . dateFormat = null ; } else if ( dateFormatType . equalsIgnoreCase ( RELATIVE_TIME_DATE_FORMAT ) ) { this . dateFormat = new RelativeTimeDateFormat ( ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) { this . dateFormat = new AbsoluteTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) { this . dateFormat = new DateTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) { this . dateFormat = new ISO8601DateFormat ( timeZone ) ; } else { this . dateFormat = new SimpleDateFormat ( dateFormatType ) ; this . dateFormat . setTimeZone ( timeZone ) ; } } public void setOption ( String option , String value ) { if ( option . equalsIgnoreCase ( DATE_FORMAT_OPTION ) ) { dateFormatOption = value . toUpperCase ( ) ; } else if ( option . equalsIgnoreCase ( TIMEZONE_OPTION ) ) { timeZoneID = value ; } } } 	0	['8', '2', '1', '7', '24', '12', '1', '6', '8', '0.936507937', '179', '0.555555556', '0', '0.533333333', '0.333333333', '0', '0', '20.25', '7', '2.25', '0']
package org . apache . log4j ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Layout implements OptionHandler { public final static String LINE_SEP = System . getProperty ( "line.separator" ) ; public final static int LINE_SEP_LEN = LINE_SEP . length ( ) ; abstract public String format ( LoggingEvent event ) ; public String getContentType ( ) { return "text/plain" ; } public String getHeader ( ) { return null ; } public String getFooter ( ) { return null ; } abstract public boolean ignoresThrowable ( ) ; } 	0	['10', '1', '5', '34', '13', '45', '32', '2', '9', '1', '28', '0', '0', '0', '0.407407407', '0', '0', '1.6', '1', '0.8', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; public class DefaultInit { static Category cat = Category . getInstance ( DefaultInit . class . getName ( ) ) ; public static void main ( String [ ] argv ) { cat . debug ( "Hello world" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.DefaultInit " ) ; System . exit ( 1 ) ; } } 	0	['5', '1', '0', '1', '14', '8', '0', '1', '2', '0.875', '45', '0', '1', '0', '0.333333333', '0', '0', '7.6', '1', '0.6', '0']
package org . apache . log4j . performance ; import java . util . Date ; public class ConcatVsArray { static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.performance.ConcatVsArray " + "string1 string2 runLength\n" + "       where runLength is an integer." ) ; System . exit ( 1 ) ; } public static void main ( String args [ ] ) { if ( args . length != 3 ) { Usage ( ) ; } String s1 = args [ 0 ] ; String s2 = args [ 1 ] ; int runLength = 0 ; try { runLength = Integer . parseInt ( args [ 2 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } double micros ; String [ ] sa ; long before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { sa = new String [ ] { s1 , s2 } ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The anonymous array loop took around " + micros + " microseconds." ) ; String s ; before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { s = s1 + s2 ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The append loop took around " + micros + " microseconds." ) ; } } 	0	['3', '1', '0', '0', '14', '3', '0', '0', '2', '2', '133', '0', '0', '0', '0.333333333', '0', '0', '43.33333333', '4', '1.6667', '0']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . DateLayout ; import org . apache . log4j . helpers . RelativeTimeDateFormat ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . helpers . DateTimeDateFormat ; import org . apache . log4j . helpers . ISO8601DateFormat ; import org . apache . log4j . spi . LoggingEvent ; public class TTCCLayout extends DateLayout { final static public String THREAD_PRINTING_OPTION = "ThreadPrinting" ; final static public String CATEGORY_PREFIXING_OPTION = "CategoryPrefixing" ; final static public String CONTEXT_PRINTING_OPTION = "ContextPrinting" ; private boolean threadPrinting = true ; private boolean categoryPrefixing = true ; private boolean contextPrinting = true ; protected final StringBuffer buf = new StringBuffer ( 256 ) ; public TTCCLayout ( ) { this . setDateFormat ( RELATIVE_TIME_DATE_FORMAT , null ) ; } public TTCCLayout ( String dateFormatType ) { this . setDateFormat ( dateFormatType ) ; } public String format ( LoggingEvent event ) { buf . setLength ( 0 ) ; dateFormat ( buf , event ) ; if ( this . threadPrinting ) { buf . append ( '[' ) ; buf . append ( event . getThreadName ( ) ) ; buf . append ( "] " ) ; } buf . append ( event . priority . toString ( ) ) ; buf . append ( ' ' ) ; if ( this . categoryPrefixing ) { buf . append ( event . categoryName ) ; buf . append ( ' ' ) ; } if ( this . contextPrinting ) { event . getNDC ( ) ; if ( event . ndc != null ) { buf . append ( event . ndc ) ; buf . append ( ' ' ) ; } } buf . append ( "- " ) ; buf . append ( event . message ) ; buf . append ( LINE_SEP ) ; return buf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { THREAD_PRINTING_OPTION , CATEGORY_PREFIXING_OPTION , CONTEXT_PRINTING_OPTION } ) ; } public boolean ignoresThrowable ( ) { return true ; } public void setOption ( String key , String value ) { super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( THREAD_PRINTING_OPTION ) ) threadPrinting = OptionConverter . toBoolean ( value , threadPrinting ) ; else if ( key . equalsIgnoreCase ( CATEGORY_PREFIXING_OPTION ) ) categoryPrefixing = OptionConverter . toBoolean ( value , categoryPrefixing ) ; else if ( key . equalsIgnoreCase ( CONTEXT_PRINTING_OPTION ) ) contextPrinting = OptionConverter . toBoolean ( value , contextPrinting ) ; } public void setCategoryPrefixing ( boolean categoryPrefixing ) { this . categoryPrefixing = categoryPrefixing ; } public void setThreadPrinting ( boolean threadPrinting ) { this . threadPrinting = threadPrinting ; } } 	0	['8', '3', '0', '7', '25', '0', '2', '5', '8', '0.795918367', '217', '0.571428571', '0', '0.714285714', '0.40625', '1', '1', '25.25', '5', '1.625', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; public class Hello { static Category cat = Category . getInstance ( Hello . class ) ; public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; cat . debug ( "Hello world." ) ; cat . info ( "What a beatiful day." ) ; } } 	0	['4', '1', '0', '2', '12', '4', '0', '2', '2', '0.833333333', '38', '0', '1', '0', '0.333333333', '0', '0', '8', '1', '0.5', '0']
package org . apache . log4j . spi ; public interface OptionHandler { void activateOptions ( ) ; String [ ] getOptionStrings ( ) ; void setOption ( String option , String value ) ; } 	0	['3', '1', '0', '8', '3', '3', '8', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . InputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; public class SocketNode implements Runnable { Socket socket ; Hierarchy hierarchy ; ObjectInputStream ois ; static Category cat = Category . getInstance ( SocketNode . class . getName ( ) ) ; public SocketNode ( Socket socket , Hierarchy hierarchy ) { this . socket = socket ; this . hierarchy = hierarchy ; try { ois = new ObjectInputStream ( socket . getInputStream ( ) ) ; } catch ( Exception e ) { cat . error ( "Could not open ObjectInputStream to " + socket , e ) ; } } public void run ( ) { LoggingEvent event ; Category remoteCategory ; try { while ( true ) { event = ( LoggingEvent ) ois . readObject ( ) ; remoteCategory = hierarchy . getInstance ( event . categoryName ) ; if ( event . priority . isGreaterOrEqual ( remoteCategory . getChainedPriority ( ) ) ) { remoteCategory . callAppenders ( event ) ; } } } catch ( java . io . EOFException e ) { cat . info ( "Caught java.io.EOFException closing conneciton." ) ; } catch ( java . net . SocketException e ) { cat . info ( "Caught java.net.SocketException closing conneciton." ) ; } catch ( Exception e ) { cat . error ( "Unexpected exception. Closing conneciton." , e ) ; } try { ois . close ( ) ; } catch ( Exception e ) { cat . info ( "Could not close connection." , e ) ; } } } 	0	['4', '1', '0', '7', '25', '0', '3', '4', '2', '0.733333333', '106', '0', '2', '0', '0.416666667', '0', '0', '24.25', '2', '0.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . * ; import java . util . * ; import java . text . * ; public class L7D { static ResourceBundle [ ] bundles ; public static void main ( String args [ ] ) { if ( args . length == 3 ) init ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + L7D . class . getName ( ) + "configFile ISO639LanguageCode ISO2166CountryCode" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String lanCode , String countryCode ) { PropertyConfigurator . configure ( configFile ) ; bundles = new ResourceBundle [ 3 ] ; try { bundles [ 0 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "en" , "US" ) ) ; bundles [ 1 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "FR" ) ) ; bundles [ 2 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "CH" ) ) ; } catch ( MissingResourceException e ) { e . printStackTrace ( ) ; } } static void test ( ) { Category root = Category . getRoot ( ) ; for ( int i = 0 ; i < bundles . length ; i ++ ) { root . setResourceBundle ( bundles [ i ] ) ; root . l7dlog ( Priority . DEBUG , "bogus1" , null ) ; root . l7dlog ( Priority . INFO , "test" , null ) ; root . l7dlog ( Priority . WARN , "hello_world" , null ) ; root . l7dlog ( Priority . DEBUG , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "bogusMsg" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . INFO , "bogus2" , null ) ; } } } 	0	['6', '1', '0', '3', '25', '13', '0', '3', '2', '0.7', '202', '0', '0', '0', '0.277777778', '0', '0', '32.33333333', '2', '1.3333', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Enumeration ; public class Finalize { static Category CAT = Category . getInstance ( Finalize . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Finalize . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; InputStreamReader in = new InputStreamReader ( System . in ) ; Category root = Category . getRoot ( ) ; System . out . println ( "Type 'q' to quit" ) ; int j = 0 ; while ( true ) { System . gc ( ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } System . gc ( ) ; System . out . println ( "Read [" + i + "]." ) ; if ( i == - 1 ) break ; else if ( i == 'q' ) break ; else root . debug ( "Hello " + ( ++ j ) ) ; } root . removeAllAppenders ( ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; } static void foo ( Category cat ) { Enumeration enum = cat . getAllAppenders ( ) ; while ( enum != null && enum . hasMoreElements ( ) ) { ( ( org . apache . log4j . Appender ) enum . nextElement ( ) ) . close ( ) ; } } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	0	['9', '1', '0', '3', '34', '34', '0', '3', '2', '0.875', '167', '0', '1', '0', '0.175', '0', '0', '17.33333333', '3', '1.4444', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Appender ; import java . util . Enumeration ; import java . util . Vector ; public class MultipleAppenders { public static void main ( String argv [ ] ) { PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; Enumeration e1 = root . getAllAppenders ( ) ; Vector v = new Vector ( 1 ) ; while ( e1 . hasMoreElements ( ) ) { Appender a = ( Appender ) e1 . nextElement ( ) ; v . addElement ( a ) ; String appenderName = a . getName ( ) ; if ( a != root . getAppender ( appenderName ) ) { System . out . println ( appenderName + " lookup failed. Exiting." ) ; System . exit ( 1 ) ; } root . addAppender ( a ) ; } root . addAppender ( null ) ; Enumeration e2 = root . getAllAppenders ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . elementAt ( i ) != e2 . nextElement ( ) ) { } } if ( e2 . hasMoreElements ( ) ) { System . out . println ( "Failure, e2 has remaining elements. Exiting." ) ; System . exit ( 1 ) ; } System . out . println ( "OK" ) ; } } 	0	['2', '1', '0', '3', '20', '1', '0', '3', '2', '2', '85', '0', '0', '0', '0.5', '0', '0', '41.5', '6', '3', '0']
package org . apache . log4j . helpers ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class NullEnumeration implements Enumeration { private static final NullEnumeration instance = new NullEnumeration ( ) ; private NullEnumeration ( ) { } public static NullEnumeration getInstance ( ) { return instance ; } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) { throw new NoSuchElementException ( ) ; } } 	0	['5', '1', '0', '1', '7', '8', '1', '0', '3', '0.75', '22', '1', '1', '0', '0.75', '0', '0', '3.2', '1', '0.6', '0']
package org . apache . log4j ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OnlyOnceErrorHandler ; import org . apache . log4j . helpers . LogLog ; public abstract class AppenderSkeleton implements Appender , OptionHandler { protected Layout layout ; protected String name ; protected Priority threshold ; protected ErrorHandler errorHandler = new OnlyOnceErrorHandler ( ) ; protected Filter headFilter ; protected Filter tailFilter ; protected boolean closed = false ; public static final String THRESHOLD_OPTION = "Threshold" ; public void activateOptions ( ) { } public void addFilter ( Filter newFilter ) { if ( headFilter == null ) { headFilter = tailFilter = newFilter ; } else { tailFilter . next = newFilter ; tailFilter = newFilter ; } } abstract protected void append ( LoggingEvent event ) ; public void clearFilters ( ) { headFilter = tailFilter = null ; } public void finalize ( ) { if ( this . closed ) return ; LogLog . debug ( "Finalizing appender named [" + name + "]." ) ; close ( ) ; } public ErrorHandler getErrorHandler ( ) { return this . errorHandler ; } public final Filter getFirstFilter ( ) { return headFilter ; } public final String getName ( ) { return this . name ; } public String [ ] getOptionStrings ( ) { return new String [ ] { THRESHOLD_OPTION } ; } public boolean isAsSevereAsThreshold ( Priority priority ) { return ( ( threshold == null ) || priority . isGreaterOrEqual ( threshold ) ) ; } public synchronized void doAppend ( LoggingEvent event ) { if ( closed ) { LogLog . error ( "Attempted to append to closed appender named [" + name + "]." ) ; } if ( ! isAsSevereAsThreshold ( event . priority ) ) { return ; } Filter f = this . headFilter ; FILTER_LOOP : while ( f != null ) { switch ( f . decide ( event ) ) { case Filter . DENY : return ; case Filter . ACCEPT : break FILTER_LOOP ; case Filter . NEUTRAL : f = f . next ; } } this . append ( event ) ; } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { LogLog . error ( "It is forbidden to set a null ErrorHandler. Ignoring directive." ) ; } else { this . errorHandler = eh ; } } public void setLayout ( Layout layout ) { this . layout = layout ; } public void setName ( String name ) { this . name = name ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( THRESHOLD_OPTION ) ) { threshold = Priority . toPriority ( value ) ; } } public void setThreshold ( Priority threshold ) { this . threshold = threshold ; } } 	0	['19', '1', '9', '20', '31', '131', '11', '9', '18', '0.909722222', '181', '0.875', '5', '0', '0.210526316', '0', '0', '8.105263158', '4', '1.4211', '0']
package org . apache . log4j . nt . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . nt . NTEventLogAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class NTMin { static Category cat = Category . getInstance ( NTMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { init ( ) ; test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + NTMin . class + "" ) ; System . exit ( 1 ) ; } static void init ( ) { BasicConfigurator . configure ( new NTEventLogAppender ( ) ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '6', '30', '17', '0', '6', '2', '0.75', '144', '0', '1', '0', '0.277777778', '0', '0', '19.28571429', '2', '0.8571', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class QuietWriter extends FilterWriter { protected ErrorHandler errorHandler ; public QuietWriter ( Writer writer , ErrorHandler errorHandler ) { super ( writer ) ; setErrorHandler ( errorHandler ) ; } public void write ( String string ) { try { out . write ( string ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to write [" + string + "]." , e , ErrorCode . WRITE_FAILURE ) ; } } public void flush ( ) { try { out . flush ( ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to flush writer," , e , ErrorCode . FLUSH_FAILURE ) ; } } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { throw new IllegalArgumentException ( "Attempted to set null ErrorHandler." ) ; } else { this . errorHandler = eh ; } } } 	0	['4', '3', '2', '9', '12', '0', '8', '1', '4', '0', '57', '1', '1', '0.857142857', '0.5', '2', '2', '13', '2', '1', '0']
package org . apache . log4j ; class CategoryKey { String name ; int hashCache ; CategoryKey ( String name ) { this . name = name . intern ( ) ; hashCache = name . hashCode ( ) ; } final public int hashCode ( ) { return hashCache ; } final public boolean equals ( Object rArg ) { if ( this == rArg ) return true ; if ( rArg != null && CategoryKey . class == rArg . getClass ( ) ) return name == ( ( CategoryKey ) rArg ) . name ; else return false ; } } 	0	['4', '1', '0', '1', '11', '2', '1', '0', '2', '0.777777778', '61', '0', '0', '0', '0.5', '1', '1', '13.5', '6', '2', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; public class ConfigurationFileParsing { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { NDC . push ( "testing" ) ; PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; root . debug ( "Message 1" ) ; root . debug ( "Message 2" ) ; NDC . pop ( ) ; } else { Usage ( "Wrong number of arguments." ) ; } } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ConfigurationFileParsing . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '3', '19', '6', '0', '3', '2', '0.666666667', '68', '0', '0', '0', '0.333333333', '0', '0', '15.75', '2', '1.25', '0']
package org . apache . log4j . helpers ; import java . io . PrintWriter ; public class TracerPrintWriter extends PrintWriter { protected QuietWriter qWriter ; public TracerPrintWriter ( QuietWriter qWriter ) { super ( qWriter ) ; this . qWriter = qWriter ; } final public void setQuietWriter ( QuietWriter qWriter ) { this . qWriter = qWriter ; } public void println ( Object o ) { this . qWriter . write ( o . toString ( ) ) ; this . qWriter . write ( org . apache . log4j . Layout . LINE_SEP ) ; } public void println ( char [ ] s ) { this . println ( new String ( s ) ) ; } public void println ( String s ) { this . qWriter . write ( s ) ; this . qWriter . write ( org . apache . log4j . Layout . LINE_SEP ) ; } } 	0	['5', '3', '1', '5', '9', '0', '3', '2', '5', '0', '43', '1', '1', '0.93442623', '0.4', '1', '1', '7.4', '1', '0.8', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class BoundedFIFO { LoggingEvent [ ] buf ; int numElements = 0 ; int first = 0 ; int next = 0 ; int maxSize ; public BoundedFIFO ( int maxSize ) { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; buf = new LoggingEvent [ maxSize ] ; } public LoggingEvent get ( ) { if ( numElements == 0 ) return null ; LoggingEvent r = buf [ first ] ; if ( ++ first == maxSize ) { first = 0 ; } numElements -- ; return r ; } public void put ( LoggingEvent o ) { if ( numElements != maxSize ) { buf [ next ] = o ; if ( ++ next == maxSize ) { next = 0 ; } numElements ++ ; } } public int getMaxSize ( ) { return maxSize ; } public boolean isFull ( ) { return numElements == maxSize ; } public int length ( ) { return numElements ; } public boolean wasEmpty ( ) { return numElements == 1 ; } public boolean wasFull ( ) { return ( numElements + 1 == maxSize ) ; } } 	0	['8', '1', '0', '3', '14', '0', '2', '1', '8', '0.571428571', '146', '0', '1', '0', '0.416666667', '0', '0', '16.625', '3', '1.75', '0']
package org . apache . log4j . gui ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Priority ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . spi . LoggingEvent ; import javax . swing . JList ; import javax . swing . AbstractListModel ; import javax . swing . JFrame ; import javax . swing . JButton ; import javax . swing . JLabel ; import javax . swing . JTable ; import javax . swing . JTextArea ; import javax . swing . table . AbstractTableModel ; import javax . swing . table . TableCellRenderer ; import javax . swing . JScrollPane ; import javax . swing . ListCellRenderer ; import java . awt . Component ; import java . awt . FlowLayout ; import javax . swing . BoxLayout ; import java . awt . BorderLayout ; import java . awt . Dimension ; import java . awt . event . ActionListener ; import java . awt . event . ActionEvent ; import java . awt . Container ; import javax . swing . ImageIcon ; import java . awt . Image ; import java . awt . Toolkit ; import java . net . URL ; import java . awt . Rectangle ; public class JTableAppender extends JTable { static Category cat = Category . getInstance ( JTableAppender . class . getName ( ) ) ; PatternLayout layout ; public JTableAppender ( ) { layout = new PatternLayout ( "%r %p %c [%t] -  %m" ) ; this . setDefaultRenderer ( Object . class , new Renderer ( ) ) ; } public void add ( LoggingEvent event ) { ( ( JTableAppenderModel ) getModel ( ) ) . add ( event ) ; } public Dimension getPreferredSize ( ) { System . out . println ( "getPreferredSize() called" ) ; return super . getPreferredSize ( ) ; } static public void main ( String [ ] args ) { JFrame frame = new JFrame ( "JListView test" ) ; Container container = frame . getContentPane ( ) ; JTableAppender appender = new JTableAppender ( ) ; JTableAppenderModel model = new JTableAppenderModel ( Integer . parseInt ( args [ 0 ] ) ) ; appender . setModel ( model ) ; JScrollPane sp = new JScrollPane ( appender ) ; sp . setPreferredSize ( new Dimension ( 250 , 80 ) ) ; container . setLayout ( new BoxLayout ( container , BoxLayout . X_AXIS ) ) ; container . add ( sp ) ; JButton button = new JButton ( "ADD" ) ; container . add ( button ) ; button . addActionListener ( new JTableAddAction ( appender ) ) ; frame . setVisible ( true ) ; frame . setSize ( new Dimension ( 700 , 700 ) ) ; long before = System . currentTimeMillis ( ) ; int RUN = 10000 ; int i = 0 ; while ( i ++ < RUN ) { LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . ERROR , "Message " + i , null ) ; event . getThreadName ( ) ; if ( i % 10 == 0 ) { event . throwable = new Exception ( "hello " + i ) ; } appender . add ( event ) ; } long after = System . currentTimeMillis ( ) ; System . out . println ( "Time taken :" + ( ( after - before ) * 1000 / RUN ) ) ; } class Renderer extends JTextArea implements TableCellRenderer { Object o = new Object ( ) ; int i = 0 ; public Renderer ( ) { System . out . println ( "Render() called ----------------------" ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { System . out . println ( o + " ============== " + i ++ ) ; if ( value instanceof LoggingEvent ) { LoggingEvent event = ( LoggingEvent ) value ; String str = layout . format ( event ) ; String t = event . getThrowableInformation ( ) ; if ( t != null ) { System . out . println ( "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" ) ; setText ( str + Layout . LINE_SEP + t ) ; } else { setText ( str ) ; } } else { setText ( value . toString ( ) ) ; } return this ; } } } class JTableAppenderModel extends AbstractTableModel { CyclicBuffer cb ; JTableAppenderModel ( int size ) { cb = new CyclicBuffer ( size ) ; } public void add ( LoggingEvent event ) { cb . add ( event ) ; int j = cb . length ( ) ; fireTableDataChanged ( ) ; } public int getColumnCount ( ) { return 1 ; } public int getRowCount ( ) { return cb . length ( ) ; } public Object getValueAt ( int row , int col ) { return cb . get ( row ) ; } } class JTableAddAction implements ActionListener { int j ; JTableAppender appender ; Category cat = Category . getInstance ( "x" ) ; public JTableAddAction ( JTableAppender appender ) { this . appender = appender ; j = 0 ; } public void actionPerformed ( ActionEvent e ) { System . out . println ( "Action occured" ) ; LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . DEBUG , "Message " + j , null ) ; if ( j % 5 == 0 ) { event . throwable = new Exception ( "hello " + j ) ; } j ++ ; appender . add ( event ) ; } } 	0	['6', '5', '0', '7', '44', '13', '2', '7', '4', '0.85', '208', '0', '2', '0.995139733', '0.3', '2', '2', '33', '3', '1', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; final public class RootCategory extends Category { public RootCategory ( Priority priority ) { super ( "root" ) ; this . priority = priority ; } final public Priority getChainedPriority ( ) { return priority ; } final public void setPriority ( Priority priority ) { if ( priority == null ) { LogLog . error ( "You have tried to set a null priority to root." , new Throwable ( ) ) ; } else { this . priority = priority ; } } } 	0	['3', '2', '0', '4', '6', '3', '2', '3', '3', '2', '25', '0', '0', '0.959183673', '0.833333333', '1', '6', '7.333333333', '2', '1', '0']
package org . apache . log4j . net ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . TracerPrintWriter ; class SyslogTracerPrintWriter extends TracerPrintWriter { static String TAB = "    " ; SyslogTracerPrintWriter ( QuietWriter qWriter ) { super ( qWriter ) ; } public void println ( Object o ) { this . qWriter . write ( o . toString ( ) ) ; } public void println ( String s ) { this . qWriter . write ( TAB + s . substring ( 1 ) ) ; } } 	0	['4', '4', '0', '3', '11', '4', '1', '2', '2', '0.666666667', '32', '0', '0', '0.968253968', '0.5', '2', '2', '6.75', '1', '0.5', '0']
package org . apache . log4j . gui ; import java . awt . Color ; import java . awt . Image ; import java . awt . Toolkit ; import java . io . * ; import java . net . URL ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Hashtable ; import javax . swing . Icon ; import javax . swing . ImageIcon ; import javax . swing . JTextPane ; import javax . swing . text . BadLocationException ; import javax . swing . text . MutableAttributeSet ; import javax . swing . text . SimpleAttributeSet ; import javax . swing . text . StyleConstants ; import javax . swing . text . StyledDocument ; import javax . swing . text . TabSet ; import javax . swing . text . TabStop ; import org . apache . log4j . * ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . Loader ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . TracerPrintWriter ; import org . apache . log4j . helpers . OptionConverter ; public class TextPaneAppender extends AppenderSkeleton { JTextPane textpane ; StyledDocument doc ; TracerPrintWriter tp ; StringWriter sw ; QuietWriter qw ; Hashtable attributes ; Hashtable icons ; private String label ; private boolean fancy ; final String LABEL_OPTION = "Label" ; final String COLOR_OPTION_FATAL = "Color.Emerg" ; final String COLOR_OPTION_ERROR = "Color.Error" ; final String COLOR_OPTION_WARN = "Color.Warn" ; final String COLOR_OPTION_INFO = "Color.Info" ; final String COLOR_OPTION_DEBUG = "Color.Debug" ; final String COLOR_OPTION_BACKGROUND = "Color.Background" ; final String FANCY_OPTION = "Fancy" ; final String FONT_NAME_OPTION = "Font.Name" ; final String FONT_SIZE_OPTION = "Font.Size" ; public static Image loadIcon ( String path ) { Image img = null ; try { URL url = ClassLoader . getSystemResource ( path ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public TextPaneAppender ( Layout layout , String name ) { this ( ) ; this . layout = layout ; this . name = name ; setTextPane ( new JTextPane ( ) ) ; createAttributes ( ) ; createIcons ( ) ; } public TextPaneAppender ( ) { super ( ) ; setTextPane ( new JTextPane ( ) ) ; createAttributes ( ) ; createIcons ( ) ; this . label = "" ; this . sw = new StringWriter ( ) ; this . qw = new QuietWriter ( sw , errorHandler ) ; this . tp = new TracerPrintWriter ( qw ) ; this . fancy = true ; } public void close ( ) { } private void createAttributes ( ) { Priority prio [ ] = Priority . getAllPossiblePriorities ( ) ; attributes = new Hashtable ( ) ; for ( int i = 0 ; i < prio . length ; i ++ ) { MutableAttributeSet att = new SimpleAttributeSet ( ) ; attributes . put ( prio [ i ] , att ) ; StyleConstants . setFontSize ( att , 14 ) ; } StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . ERROR ) , Color . red ) ; StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . WARN ) , Color . orange ) ; StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . INFO ) , Color . gray ) ; StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . DEBUG ) , Color . black ) ; } private void createIcons ( ) { Priority prio [ ] = Priority . getAllPossiblePriorities ( ) ; icons = new Hashtable ( ) ; for ( int i = 0 ; i < prio . length ; i ++ ) { if ( prio [ i ] . equals ( Priority . FATAL ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/RedFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . ERROR ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/RedFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . WARN ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/BlueFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . INFO ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/GreenFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . DEBUG ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/GreenFlag.gif" ) ) ) ; } } public void append ( LoggingEvent event ) { String text = this . layout . format ( event ) ; String trace = "" ; if ( event . throwable != null ) { event . throwable . printStackTrace ( tp ) ; for ( int i = 0 ; i < sw . getBuffer ( ) . length ( ) ; i ++ ) { if ( sw . getBuffer ( ) . charAt ( i ) == '\t' ) sw . getBuffer ( ) . replace ( i , i + 1 , "        " ) ; } trace = sw . toString ( ) ; sw . getBuffer ( ) . delete ( 0 , sw . getBuffer ( ) . length ( ) ) ; } try { if ( fancy ) { textpane . setEditable ( true ) ; textpane . insertIcon ( ( ImageIcon ) icons . get ( event . priority ) ) ; textpane . setEditable ( false ) ; } doc . insertString ( doc . getLength ( ) , text + trace , ( MutableAttributeSet ) attributes . get ( event . priority ) ) ; } catch ( BadLocationException badex ) { System . err . println ( badex ) ; } textpane . setCaretPosition ( doc . getLength ( ) ) ; } public JTextPane getTextPane ( ) { return textpane ; } public String getLabel ( ) { return label ; } public String [ ] getOptionStrings ( ) { return new String [ ] { LABEL_OPTION , COLOR_OPTION_FATAL , COLOR_OPTION_ERROR , COLOR_OPTION_WARN , COLOR_OPTION_INFO , COLOR_OPTION_DEBUG , COLOR_OPTION_BACKGROUND , FANCY_OPTION , FONT_NAME_OPTION , FONT_SIZE_OPTION } ; } private Color parseColor ( String v ) { StringTokenizer st = new StringTokenizer ( v , "," ) ; int val [ ] = { 255 , 255 , 255 , 255 } ; int i = 0 ; while ( st . hasMoreTokens ( ) ) { val [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; i ++ ; } return new Color ( val [ 0 ] , val [ 1 ] , val [ 2 ] , val [ 3 ] ) ; } public void setLayout ( Layout layout ) { this . layout = layout ; } public void setName ( String name ) { this . name = name ; } public void setTextPane ( JTextPane textpane ) { this . textpane = textpane ; textpane . setEditable ( false ) ; textpane . setBackground ( Color . lightGray ) ; this . doc = textpane . getStyledDocument ( ) ; } private void setColor ( Priority p , String v ) { StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( p ) , parseColor ( v ) ) ; } private void setFontSize ( int size ) { Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { StyleConstants . setFontSize ( ( MutableAttributeSet ) e . nextElement ( ) , size ) ; } return ; } private void setFontName ( String name ) { Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { StyleConstants . setFontFamily ( ( MutableAttributeSet ) e . nextElement ( ) , name ) ; } return ; } public void setOption ( String option , String value ) { if ( option . equalsIgnoreCase ( LABEL_OPTION ) ) this . label = value ; if ( option . equalsIgnoreCase ( COLOR_OPTION_FATAL ) ) setColor ( Priority . FATAL , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_ERROR ) ) setColor ( Priority . ERROR , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_WARN ) ) setColor ( Priority . WARN , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_INFO ) ) setColor ( Priority . INFO , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_DEBUG ) ) setColor ( Priority . DEBUG , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_BACKGROUND ) ) textpane . setBackground ( parseColor ( value ) ) ; if ( option . equalsIgnoreCase ( FANCY_OPTION ) ) fancy = OptionConverter . toBoolean ( value , fancy ) ; if ( option . equalsIgnoreCase ( FONT_SIZE_OPTION ) ) setFontSize ( Integer . parseInt ( value ) ) ; if ( option . equalsIgnoreCase ( FONT_NAME_OPTION ) ) setFontName ( value ) ; return ; } public boolean requiresLayout ( ) { return true ; } } 	0	['19', '2', '0', '10', '69', '129', '2', '8', '13', '0.885964912', '675', '0.105263158', '2', '0.514285714', '0.233082707', '1', '3', '33.52631579', '11', '2.1579', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressAsyncAppender extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int BRANCHING_FACTOR = 4 ; static int maxThreads ; static long msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { if ( args . length != 1 ) { usage ( ) ; } DOMConfigurator . configure ( "stressAsyncAppender.xml" ) ; try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java " + StressAsyncAppender . class . getName ( ) + " MAX_THREADS" ) ; System . exit ( 1 ) ; } public StressAsyncAppender ( ) { } public void run ( ) { int loopLength = StressAsyncAppender . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop, loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; synchronized ( lock ) { root . debug ( "Message number " + msgCounter ++ ) ; } } synchronized ( lock ) { StressAsyncAppender . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressAsyncAppender . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstrained ( n ) ; root . debug ( "Creating " + n + " child StressAsyncAppender threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressAsyncAppender, threadCounter = " + ( ++ threadCounter ) ) ; new StressAsyncAppender ( ) . start ( ) ; } } } static public int maxThreadsConstrained ( int a ) { int maxAllowed = StressAsyncAppender . maxThreads - StressAsyncAppender . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public void delay ( long millis ) { try { Thread . currentThread ( ) . sleep ( millis ) ; } catch ( Exception e ) { } } } 	0	['10', '2', '0', '2', '37', '23', '0', '2', '7', '0.833333333', '301', '0', '1', '0.884057971', '0.2', '0', '0', '28.1', '4', '1.7', '0']
package org . apache . log4j . performance ; public class SystemTime { static int RUN_LENGTH = 1000000 ; static public void main ( String [ ] args ) { double t = systemCurrentTimeLoop ( ) ; System . out . println ( "Average System.currentTimeMillis() call took " + t ) ; t = currentThreadNameloop ( ) ; System . out . println ( "Average Thread.currentThread().getName() call took " + t ) ; } static double systemCurrentTimeLoop ( ) { long before = System . currentTimeMillis ( ) ; long l ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { l = System . currentTimeMillis ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double currentThreadNameloop ( ) { long before = System . currentTimeMillis ( ) ; String t ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { t = Thread . currentThread ( ) . getName ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '14', '4', '0', '0', '2', '0.25', '80', '0', '0', '0', '0.25', '0', '0', '14.8', '2', '1', '0']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . LogLog ; import javax . jms . Message ; import javax . jms . JMSException ; import javax . jms . DeliveryMode ; import java . util . Enumeration ; public class MessageRenderer implements ObjectRenderer { public MessageRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof Message ) { StringBuffer sbuf = new StringBuffer ( ) ; Message m = ( Message ) o ; try { sbuf . append ( "DeliveryMode=" ) ; switch ( m . getJMSDeliveryMode ( ) ) { case DeliveryMode . NON_PERSISTENT : sbuf . append ( "NON_PERSISTENT" ) ; break ; case DeliveryMode . PERSISTENT : sbuf . append ( "PERSISTENT" ) ; break ; default : sbuf . append ( "UNKNOWN" ) ; } sbuf . append ( ", CorrelationID=" ) ; sbuf . append ( m . getJMSCorrelationID ( ) ) ; sbuf . append ( ", Destination=" ) ; sbuf . append ( m . getJMSDestination ( ) ) ; sbuf . append ( ", Expiration=" ) ; sbuf . append ( m . getJMSExpiration ( ) ) ; sbuf . append ( ", MessageID=" ) ; sbuf . append ( m . getJMSMessageID ( ) ) ; sbuf . append ( ", Priority=" ) ; sbuf . append ( m . getJMSPriority ( ) ) ; sbuf . append ( ", Redelivered=" ) ; sbuf . append ( m . getJMSRedelivered ( ) ) ; sbuf . append ( ", ReplyTo=" ) ; sbuf . append ( m . getJMSReplyTo ( ) ) ; sbuf . append ( ", Timestamp=" ) ; sbuf . append ( m . getJMSTimestamp ( ) ) ; sbuf . append ( ", Type=" ) ; sbuf . append ( m . getJMSType ( ) ) ; } catch ( JMSException e ) { LogLog . error ( "Could not parse Message." , e ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '3', '22', '1', '1', '2', '2', '2', '128', '0', '0', '0', '0.75', '0', '0', '63', '5', '2.5', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import java . io . IOException ; public class SyslogWriter extends Writer { final int SYSLOG_PORT = 514 ; static String syslogHost ; private InetAddress address ; private DatagramSocket ds ; public SyslogWriter ( String syslogHost ) { this . syslogHost = syslogHost ; try { this . address = InetAddress . getByName ( syslogHost ) ; } catch ( UnknownHostException e ) { LogLog . error ( "Could not find " + syslogHost + ". All logging will FAIL." , e ) ; } try { this . ds = new DatagramSocket ( ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; LogLog . error ( "Could not instantiate DatagramSocket to " + syslogHost + ". All logging will FAIL." , e ) ; } } public void write ( char [ ] buf , int off , int len ) throws IOException { this . write ( new String ( buf , off , len ) ) ; } public void write ( String string ) throws IOException { DatagramPacket packet = new DatagramPacket ( string . getBytes ( ) , string . length ( ) , address , SYSLOG_PORT ) ; if ( this . ds != null ) ds . send ( packet ) ; } public void flush ( ) { } public void close ( ) { } } 	0	['5', '2', '0', '2', '18', '8', '1', '1', '5', '0.75', '88', '0.5', '0', '0.764705882', '0.45', '1', '2', '15.8', '1', '0.8', '0']
package org . apache . log4j . performance ; import java . io . Writer ; import java . io . IOException ; public class NOPWriter extends Writer { public void write ( char [ ] cbuf ) throws IOException { } public void write ( char [ ] cbuf , int off , int len ) throws IOException { } public void write ( int b ) throws IOException { } public void write ( String s ) throws IOException { } public void write ( String s , int off , int len ) throws IOException { } public void flush ( ) throws IOException { } public void close ( ) throws IOException { System . err . println ( "Close called." ) ; } } 	0	['8', '2', '0', '0', '10', '28', '0', '0', '8', '2', '21', '0', '0', '0.65', '0.46875', '1', '2', '1.625', '1', '0.875', '0']
package org . apache . log4j . xml . test ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . xml . test . TPriority ; public class TCategory extends Category implements OptionHandler { private static TFactory factory = new TFactory ( ) ; static String instanceFQCN = TCategory . class . getName ( ) ; public static final String SUFFIX_OPTION = "Suffix" ; String suffix ; public TCategory ( String name ) { super ( name ) ; } public void activateOptions ( ) { } public void debug ( String message ) { log ( instanceFQCN , Priority . DEBUG , message + suffix , null ) ; } public static Category getInstance ( String name ) { return Category . getInstance ( name , factory ) ; } public String [ ] getOptionStrings ( ) { return ( new String [ ] { SUFFIX_OPTION } ) ; } public void setOption ( String option , String value ) { System . out . println ( option + "=" + value ) ; if ( option == null ) { return ; } if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { this . suffix = value ; System . out . println ( "Setting suffix to" + suffix ) ; } } public void trace ( String message ) { if ( disable <= TPriority . TRACE_INT ) return ; if ( TPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , TPriority . TRACE , message , null ) ) ; } public void trace ( String message , Exception e ) { if ( disable <= TPriority . TRACE_INT ) return ; if ( TPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , TPriority . TRACE , message , e ) ) ; } private static class TFactory implements CategoryFactory { TFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new TCategory ( name ) ; } } } 	0	['10', '2', '0', '7', '27', '29', '1', '7', '8', '0.911111111', '145', '0.2', '1', '0.854545455', '0.555555556', '1', '3', '13', '3', '1.4', '0']
package org . apache . log4j . xml . examples ; import org . apache . log4j . Priority ; public class XPriority extends Priority { static final int TRACE_INT = 800 ; static final int FATAL_INT = 1 ; static final int SYSLOG_FATAL_INT = 0 ; static final int SYSLOG_TRACE_INT = 7 ; public static final XPriority TRACE = new XPriority ( TRACE_INT , "TRACE" , 7 ) ; public static final XPriority FATAL = new XPriority ( FATAL_INT , "FATAL" , FATAL_INT ) ; protected XPriority ( int level , String strLevel , int syslogEquiv ) { super ( level , strLevel , syslogEquiv ) ; } public static Priority toPriority ( String sArg ) { if ( sArg == null ) return XPriority . TRACE ; String stringVal = sArg . toUpperCase ( ) ; if ( stringVal . equals ( "TRACE" ) ) return XPriority . TRACE ; if ( stringVal . equals ( "FATAL" ) ) return XPriority . FATAL ; return Priority . toPriority ( sArg ) ; } public static Priority toPriority ( int i ) throws IllegalArgumentException { switch ( i ) { case TRACE_INT : return XPriority . TRACE ; case FATAL_INT : return XPriority . FATAL ; } return Priority . toPriority ( i ) ; } } 	0	['4', '2', '0', '2', '9', '0', '1', '1', '2', '1', '62', '0', '2', '0.8', '0.555555556', '1', '1', '13', '4', '1.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . * ; public class CategoryWrapper { Category c ; static String FQCN = CategoryWrapper . class . getName ( ) ; CategoryWrapper ( String name ) { c = Category . getInstance ( name ) ; } public static void main ( String argv [ ] ) { Layout layout = new PatternLayout ( "%p [%t] %C %F - %m\n" ) ; Appender out = new FileAppender ( layout , System . out ) ; CategoryWrapper w1 = new CategoryWrapper ( "c1" ) ; w1 . addAppender ( out ) ; w1 . print ( "hello" ) ; } public void addAppender ( Appender appender ) { c . addAppender ( appender ) ; } public void print ( String msg ) { c . log ( FQCN + ".print" , Priority . DEBUG , msg , null ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + CategoryWrapper . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['7', '1', '0', '6', '22', '11', '0', '6', '3', '0.666666667', '107', '0', '1', '0', '0.375', '0', '0', '13.85714286', '2', '0.8571', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import java . io . IOException ; import java . io . InputStreamReader ; public class SMTPMin { static Category cat = Category . getInstance ( SMTPMin . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SMTPMin . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; Category . shutdown ( ) ; Thread . currentThread ( ) . getThreadGroup ( ) . list ( ) ; } } 	0	['7', '1', '0', '4', '32', '17', '0', '4', '2', '0.666666667', '155', '0', '1', '0', '0.277777778', '0', '0', '20.85714286', '2', '1', '0']
package org . apache . log4j . varia ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; public class StringMatchFilter extends Filter { public static final String STRING_TO_MATCH_OPTION = "StringToMatch" ; public static final String ACCEPT_ON_MATCH_OPTION = "AcceptOnMatch" ; boolean acceptOnMatch = true ; String stringToMatch ; public int decide ( LoggingEvent event ) { if ( event . message == null || stringToMatch == null ) return Filter . NEUTRAL ; if ( event . message instanceof String ) { String msg = ( String ) event . message ; if ( msg . indexOf ( stringToMatch ) == - 1 ) { return Filter . NEUTRAL ; } else { if ( acceptOnMatch ) { return Filter . ACCEPT ; } else { return Filter . DENY ; } } } else { return Filter . NEUTRAL ; } } public String [ ] getOptionStrings ( ) { return new String [ ] { STRING_TO_MATCH_OPTION , ACCEPT_ON_MATCH_OPTION } ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( STRING_TO_MATCH_OPTION ) ) { stringToMatch = value ; } else if ( key . equalsIgnoreCase ( ACCEPT_ON_MATCH_OPTION ) ) { acceptOnMatch = OptionConverter . toBoolean ( value , acceptOnMatch ) ; } } } 	0	['4', '2', '0', '3', '8', '0', '0', '3', '4', '0.916666667', '76', '0', '0', '0.571428571', '0.5', '0', '0', '17', '6', '2.5', '0']
package org . apache . log4j . performance ; public class NewVsSetLen { static String s ; static int BIGBUF_LEN = 1048576 ; static int SBUF_LEN = 256 ; static int RUN_LENGTH = BIGBUF_LEN / 4 ; static char [ ] sbuf = new char [ SBUF_LEN ] ; static char [ ] bigbuf = new char [ BIGBUF_LEN ] ; { for ( int i = 0 ; i < SBUF_LEN ; i ++ ) { sbuf [ i ] = ( char ) ( i ) ; } for ( int i = 0 ; i < BIGBUF_LEN ; i ++ ) { bigbuf [ i ] = ( char ) ( i ) ; } } static public void main ( String [ ] args ) { int t ; for ( int len = SBUF_LEN ; len <= BIGBUF_LEN ; len *= 4 , RUN_LENGTH /= 4 ) { System . out . println ( "<td>" + len + "\n" ) ; for ( int second = 0 ; second < 16 ; ) { System . out . println ( "SECOND loop=" + second + ", RUN_LENGTH=" + RUN_LENGTH + ", len=" + len ) ; t = ( int ) newBuffer ( len , second ) ; ; System . out . print ( "<td>" + t ) ; t = ( int ) setLen ( len , second ) ; System . out . println ( " <td>" + t + " \n" ) ; if ( second == 0 ) { second = 1 ; } else { second *= 2 ; } } } } static double newBuffer ( int size , int second ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; } for ( int x = 0 ; x < second ; x ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double setLen ( int size , int second ) { long before = System . currentTimeMillis ( ) ; StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } for ( int x = 0 ; x < second ; x ++ ) { buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '16', '0', '0', '0', '2', '0.208333333', '268', '0', '0', '0', '0.333333333', '0', '0', '51.4', '4', '2', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public abstract class PatternConverter { public PatternConverter next ; int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; protected PatternConverter ( ) { } protected PatternConverter ( FormattingInfo fi ) { min = fi . min ; max = fi . max ; leftAlign = fi . leftAlign ; } abstract protected String convert ( LoggingEvent event ) ; public void format ( StringBuffer sbuf , LoggingEvent e ) { String s = convert ( e ) ; if ( s == null ) { if ( 0 < min ) spacePad ( sbuf , min ) ; return ; } int len = s . length ( ) ; if ( len > max ) sbuf . append ( s . substring ( len - max ) ) ; else if ( len < min ) { if ( leftAlign ) { sbuf . append ( s ) ; spacePad ( sbuf , min - len ) ; } else { spacePad ( sbuf , min - len ) ; sbuf . append ( s ) ; } } else sbuf . append ( s ) ; } static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['6', '1', '5', '9', '10', '7', '7', '2', '2', '0.72', '174', '0', '1', '0', '0.44', '0', '0', '27.16666667', '6', '1.8333', '0']
package org . apache . log4j . xml . examples ; import org . apache . log4j . helpers . LogLog ; public class ReportParserError implements org . xml . sax . ErrorHandler { void report ( String msg , org . xml . sax . SAXParseException e ) { LogLog . error ( msg + e . getMessage ( ) + "\n\tat line=" + e . getLineNumber ( ) + " col=" + e . getColumnNumber ( ) + " of " + "SystemId=\"" + e . getSystemId ( ) + "\" PublicID = \"" + e . getPublicId ( ) + '\"' ) ; } public void warning ( org . xml . sax . SAXParseException e ) { report ( "WARNING: " , e ) ; } public void error ( org . xml . sax . SAXParseException e ) { report ( "ERROR: " , e ) ; } public void fatalError ( org . xml . sax . SAXParseException e ) { report ( "FATAL: " , e ) ; } } 	0	['5', '1', '0', '1', '17', '10', '0', '1', '4', '2', '58', '0', '0', '0', '0.666666667', '0', '0', '10.6', '1', '0.8', '0']
package org . apache . log4j . varia ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . LoggingEvent ; public class DenyAllFilter extends Filter { public int decide ( LoggingEvent event ) { return Filter . DENY ; } public String [ ] getOptionStrings ( ) { return null ; } public void setOption ( String key , String value ) { } } 	0	['4', '2', '0', '2', '5', '6', '0', '2', '4', '2', '12', '0', '0', '0.571428571', '0.5', '0', '0', '2', '1', '0.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . * ; import org . apache . log4j . gui . TextPaneAppender ; import javax . swing . JFrame ; import javax . swing . JTextPane ; import java . awt . Dimension ; public class TP { static Category cat = Category . getInstance ( TP . class . getName ( ) ) ; public static void main ( String argv [ ] ) { JFrame frame = new JFrame ( "asdasd" ) ; Category root = Category . getRoot ( ) ; PatternLayout layout = new PatternLayout ( "%p [%t] $c{2} %m\n" ) ; TextPaneAppender ap = new TextPaneAppender ( layout , "c" ) ; JTextPane textPane = ap . getTextPane ( ) ; textPane . setPreferredSize ( new Dimension ( 200 , 200 ) ) ; frame . getContentPane ( ) . add ( textPane ) ; frame . pack ( ) ; ap . getTextPane ( ) . setVisible ( true ) ; frame . setVisible ( true ) ; root . addAppender ( ap ) ; cat . debug ( "Message 1." ) ; cat . debug ( "Message 2." ) ; } } 	0	['4', '1', '0', '5', '24', '4', '0', '5', '2', '0.833333333', '83', '0', '1', '0', '0.333333333', '0', '0', '19.25', '1', '0.5', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; import java . io . InputStreamReader ; public class SocketMin { static Category cat = Category . getInstance ( SyslogMin . class . getName ( ) ) ; static SocketAppender s ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; if ( argv [ 2 ] . equals ( "true" ) ) loop ( ) ; else test ( ) ; s . close ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketMin . class + " host port true|false" ) ; System . exit ( 1 ) ; } static void init ( String host , String portStr ) { Category root = Category . getRoot ( ) ; BasicConfigurator . configure ( ) ; try { int port = Integer . parseInt ( portStr ) ; cat . info ( "Creating socket appender (" + host + "," + port + ")." ) ; s = new SocketAppender ( host , port ) ; s . setName ( "S" ) ; root . addAppender ( s ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } catch ( Exception e ) { System . err . println ( "Could not start!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } static void loop ( ) { Category root = Category . getRoot ( ) ; InputStreamReader in = new InputStreamReader ( System . in ) ; System . out . println ( "Type 'q' to quit" ) ; int i ; int k = 0 ; while ( true ) { cat . debug ( "Message " + k ++ ) ; cat . info ( "Message " + k ++ ) ; cat . warn ( "Message " + k ++ ) ; cat . error ( "Message " + k ++ , new Exception ( "Just testing" ) ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } if ( i == - 1 ) break ; if ( i == 'q' ) break ; if ( i == 'r' ) { System . out . println ( "Removing appender S" ) ; root . removeAppender ( "S" ) ; } } } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['8', '1', '0', '7', '42', '14', '0', '7', '2', '0.75', '308', '0', '2', '0', '0.238095238', '0', '0', '37', '4', '1.5', '0']
package org . apache . log4j . test ; class Base64 { final static int MAX_LINE = 76 ; static byte [ ] asciiEncoding = { 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 43 , 47 } ; static char [ ] charEnc = new char [ 64 ] ; static { for ( int i = 0 ; i < 26 ; i ++ ) { charEnc [ i ] = ( char ) ( 'A' + i ) ; charEnc [ i + 26 ] = ( char ) ( 'a' + i ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { charEnc [ i + 52 ] = ( char ) ( '0' + i ) ; } charEnc [ 62 ] = '+' ; charEnc [ 63 ] = '/' ; } static String toString ( byte [ ] inbuf ) { return toString ( inbuf , 0 , inbuf . length ) ; } static String toString ( byte [ ] inbuf , int offset , int length ) { StringBuffer output = new StringBuffer ( ( length ) * 4 / 3 + 1 ) ; int in ; char [ ] out = new char [ 4 ] ; int i = offset ; boolean ended = false ; int last = offset + length ; int j ; int bitsRead ; while ( ! ended ) { in = 0 ; bitsRead = 0 ; for ( j = 0 ; j < 3 ; j ++ ) { if ( i == last ) { ended = true ; break ; } in = ( in << 8 ) | ( inbuf [ i ++ ] & 0xFF ) ; bitsRead += 8 ; } while ( bitsRead >= 6 ) { bitsRead -= 6 ; output . append ( charEnc [ ( in > > > bitsRead ) & 0x3F ] ) ; } if ( bitsRead == 4 ) { output . append ( charEnc [ ( in & 0x0F ) << 2 ] ) ; output . append ( "=" ) ; } else if ( bitsRead == 2 ) { output . append ( charEnc [ ( in & 0x03 ) << 4 ] ) ; output . append ( "==" ) ; } } return output . toString ( ) ; } public static void main ( String [ ] args ) { byte [ ] inbuf = new byte [ MAX_LINE ] ; while ( true ) { try { int read = System . in . read ( inbuf , 0 , MAX_LINE ) ; if ( read == - 1 ) break ; System . out . println ( "Read " + read + " chars." ) ; System . out . println ( Base64 . toString ( inbuf , 0 , read ) ) ; } catch ( Exception e ) { System . out . println ( "Exception " + e ) ; } } } } 	0	['5', '1', '0', '0', '15', '8', '0', '0', '1', '0.833333333', '479', '0', '0', '0', '0.3125', '0', '0', '94.2', '7', '2', '0']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . Category ; import java . util . Random ; class StressCategory { static Priority [ ] priority = new Priority [ ] { Priority . DEBUG , Priority . INFO , Priority . WARN , Priority . ERROR , Priority . FATAL } ; static Priority defaultPriority = Category . getRoot ( ) . getPriority ( ) ; static int LENGTH ; static String [ ] names ; static Category [ ] cat ; static CT [ ] ct ; static Random random = new Random ( 10 ) ; public static void main ( String [ ] args ) { LENGTH = args . length ; if ( LENGTH == 0 ) { System . err . println ( "Usage: java " + StressCategory . class . getName ( ) + " name1 ... nameN\n." ) ; System . exit ( 1 ) ; } if ( LENGTH >= 7 ) { System . err . println ( "This stress test suffers from combinatorial explosion.\n" + "Invoking with seven arguments takes about 90 minutes even on fast machines" ) ; } names = new String [ LENGTH ] ; for ( int i = 0 ; i < LENGTH ; i ++ ) { names [ i ] = args [ i ] ; } cat = new Category [ LENGTH ] ; ct = new CT [ LENGTH ] ; permute ( 0 ) ; } static void permute ( int n ) { if ( n == LENGTH ) createLoop ( 0 ) ; else for ( int i = n ; i < LENGTH ; i ++ ) { swap ( names , n , i ) ; permute ( n + 1 ) ; swap ( names , n , i ) ; } } static void swap ( String [ ] names , int i , int j ) { String t = names [ i ] ; names [ i ] = names [ j ] ; names [ j ] = t ; } public static void permutationDump ( ) { System . out . print ( "Current permutation is - " ) ; for ( int i = 0 ; i < LENGTH ; i ++ ) { System . out . print ( names [ i ] + " " ) ; } System . out . println ( ) ; } static void createLoop ( int n ) { if ( n == LENGTH ) { for ( int i = 0 ; i < LENGTH ; i ++ ) { if ( ct [ i ] == null ) cat [ i ] = null ; else { cat [ i ] = Category . getInstance ( ct [ i ] . catstr ) ; cat [ i ] . setPriority ( ct [ i ] . priority ) ; } } test ( ) ; Category . defaultHierarchy . clear ( ) ; } else { ct [ n ] = null ; createLoop ( n + 1 ) ; ct [ n ] = new CT ( names [ n ] , null ) ; createLoop ( n + 1 ) ; int r = random . nextInt ( ) ; if ( r < 0 ) r = - r ; ct [ n ] = new CT ( names [ n ] , priority [ r % 5 ] ) ; createLoop ( n + 1 ) ; } } static void test ( ) { for ( int i = 0 ; i < LENGTH ; i ++ ) { if ( ! checkCorrectness ( i ) ) { System . out . println ( "Failed stress test." ) ; permutationDump ( ) ; ctDump ( ) ; catDump ( ) ; System . exit ( 1 ) ; } } } static void ctDump ( ) { for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( ct [ j ] != null ) System . out . println ( "ct [" + j + "] = (" + ct [ j ] . catstr + "," + ct [ j ] . priority + ")" ) ; else System . out . println ( "ct [" + j + "] = undefined" ) ; } } static void catDump ( ) { for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( cat [ j ] != null ) System . out . println ( "cat[" + j + "] = (" + cat [ j ] . name + "," + cat [ j ] . getPriority ( ) + ")" ) ; else System . out . println ( "cat[" + j + "] = undefined" ) ; } } static boolean checkCorrectness ( int i ) { CT localCT = ct [ i ] ; if ( localCT == null ) return true ; Priority expected = getExpectedPrioriy ( localCT ) ; Priority purported = cat [ i ] . getChainedPriority ( ) ; if ( expected != purported ) { System . out . println ( "Expected priority for " + localCT . catstr + " is " + expected ) ; System . out . println ( "Purported priority for " + cat [ i ] . name + " is " + purported ) ; return false ; } return true ; } static Priority getExpectedPrioriy ( CT ctParam ) { Priority priority = ctParam . priority ; if ( priority != null ) return priority ; String catstr = ctParam . catstr ; for ( int i = catstr . lastIndexOf ( '.' , catstr . length ( ) - 1 ) ; i >= 0 ; i = catstr . lastIndexOf ( '.' , i - 1 ) ) { String substr = catstr . substring ( 0 , i ) ; for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( ct [ j ] != null && substr . equals ( ct [ j ] . catstr ) ) { Priority p = ct [ j ] . priority ; if ( p != null ) return p ; } } } return defaultPriority ; } static class CT { public String catstr ; public Priority priority ; CT ( String catstr , Priority priority ) { this . catstr = catstr ; this . priority = priority ; } } } 	0	['13', '1', '0', '4', '40', '8', '0', '4', '2', '0.697916667', '516', '0', '4', '0', '0.15', '0', '0', '38.07692308', '7', '2.7692', '0']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; public class SimpleLayout extends Layout { StringBuffer sbuf = new StringBuffer ( 128 ) ; public SimpleLayout ( ) { } public void activateOptions ( ) { } public String format ( LoggingEvent event ) { sbuf . setLength ( 0 ) ; sbuf . append ( event . priority . toString ( ) ) ; sbuf . append ( " - " ) ; sbuf . append ( event . message ) ; sbuf . append ( LINE_SEP ) ; return sbuf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ 0 ] ; } public boolean ignoresThrowable ( ) { return true ; } public void setOption ( String option , String value ) { } } 	0	['6', '2', '0', '6', '12', '13', '3', '3', '6', '0.8', '54', '0', '0', '0.615384615', '0.444444444', '0', '0', '7.833333333', '1', '0.8333', '0']
package org . apache . log4j . helpers ; public class FormattingInfo { int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; void reset ( ) { min = - 1 ; max = 0x7FFFFFFF ; leftAlign = false ; } void dump ( ) { LogLog . debug ( "min=" + min + ", max=" + max + ", leftAlign=" + leftAlign ) ; } } 	0	['3', '1', '0', '9', '10', '0', '8', '1', '1', '0', '49', '0', '0', '0', '1', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . log4j . helpers ; import java . util . Date ; import java . util . Calendar ; import java . util . TimeZone ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class AbsoluteTimeDateFormat extends DateFormat { public final static String ABS_TIME_DATE_FORMAT = "ABSOLUTE" ; public final static String DATE_AND_TIME_DATE_FORMAT = "DATE" ; public final static String ISO8601_DATE_FORMAT = "ISO8601" ; public AbsoluteTimeDateFormat ( ) { setCalendar ( Calendar . getInstance ( ) ) ; } public AbsoluteTimeDateFormat ( TimeZone timeZone ) { setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; if ( hour < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( hour ) ; sbuf . append ( ':' ) ; int mins = calendar . get ( Calendar . MINUTE ) ; if ( mins < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( mins ) ; sbuf . append ( ':' ) ; int secs = calendar . get ( Calendar . SECOND ) ; if ( secs < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( secs ) ; sbuf . append ( ',' ) ; int millis = calendar . get ( Calendar . MILLISECOND ) ; if ( millis < 100 ) sbuf . append ( '0' ) ; if ( millis < 10 ) sbuf . append ( '0' ) ; sbuf . append ( millis ) ; return sbuf ; } public Date parse ( String s , ParsePosition pos ) { return null ; } } 	0	['4', '3', '2', '4', '12', '6', '4', '0', '4', '1.333333333', '111', '0', '0', '0.951219512', '0.357142857', '1', '3', '26', '6', '1.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . xml . DOMConfigurator ; public class DelayedLoop { static Category cat = Category . getInstance ( DelayedLoop . class ) ; static int loopLength ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + DelayedLoop . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { if ( configFile . endsWith ( "xml" ) ) { DOMConfigurator . configureAndWatch ( configFile , 3000 ) ; } else { PropertyConfigurator . configureAndWatch ( configFile , 3000 ) ; } } static void test ( ) { int i = 0 ; while ( true ) { cat . debug ( "MSG " + i ++ ) ; try { Thread . currentThread ( ) . sleep ( 1000 ) ; } catch ( Exception e ) { } } } } 	0	['7', '1', '0', '3', '25', '17', '0', '3', '2', '0.833333333', '105', '0', '1', '0', '0.277777778', '0', '0', '13.57142857', '2', '1.1429', '0']
package org . apache . log4j . or ; public interface ObjectRenderer { public String doRender ( Object o ) ; } 	0	['1', '1', '0', '8', '1', '0', '8', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . net ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; public class SimpleSocketServer { static Category cat = Category . getInstance ( SimpleSocketServer . class . getName ( ) ) ; static int port ; public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; try { cat . info ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { cat . info ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; cat . info ( "Connected to client at " + socket . getInetAddress ( ) ) ; cat . info ( "Starting new socket node." ) ; new Thread ( new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SimpleSocketServer . class . getName ( ) + " port configFile" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	0	['6', '1', '0', '4', '30', '9', '0', '4', '2', '0.666666667', '144', '0', '1', '0', '0.333333333', '0', '0', '22.5', '2', '1', '0']
package org . apache . log4j . helpers ; import java . io . File ; import java . io . Writer ; import java . io . FileWriter ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class CountingQuietWriter extends QuietWriter { protected long count ; public CountingQuietWriter ( Writer writer , ErrorHandler eh ) { super ( writer , eh ) ; } public void write ( String string ) { try { out . write ( string ) ; count += string . length ( ) ; } catch ( IOException e ) { errorHandler . error ( "Write failure." , e , ErrorCode . WRITE_FAILURE ) ; } } public long getCount ( ) { return count ; } public void setCount ( long count ) { this . count = count ; } } 	0	['4', '4', '0', '3', '8', '0', '1', '2', '4', '0.333333333', '38', '1', '0', '0.875', '0.4', '2', '2', '8.25', '1', '0.75', '0']
package org . apache . log4j . performance ; import java . util . Vector ; public class ListVsVector { static int RUN_LENGTH = 1000000 ; static Vector v = new Vector ( ) ; static Chain head ; static String tmp ; static public void main ( String [ ] args ) { v . addElement ( "aaa" ) ; v . addElement ( "bbb" ) ; v . addElement ( "ccc" ) ; v . addElement ( "ddd" ) ; v . addElement ( "eee" ) ; Chain c = new Chain ( "aaa" ) ; head = c ; c . next = new Chain ( "bbb" ) ; c = c . next ; c . next = new Chain ( "ccc" ) ; c = c . next ; c . next = new Chain ( "ddd" ) ; c = c . next ; c . next = new Chain ( "eee" ) ; double t ; t = loopChain ( ) ; System . out . println ( "Looping thourgh the chain took " + t ) ; t = loopVector ( ) ; System . out . println ( "Looping thourgh the vector took " + t ) ; } static double loopChain ( ) { long before = System . currentTimeMillis ( ) ; Chain c ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { c = head ; while ( c != null ) { tmp = c . s ; c = c . next ; } } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double loopVector ( ) { long before = System . currentTimeMillis ( ) ; int size = v . size ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) tmp = ( String ) v . elementAt ( j ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static class Chain { public String s ; public Chain next ; Chain ( String s ) { this . s = s ; } void setNext ( Chain c ) { next = c ; } } } 	0	['5', '1', '0', '1', '17', '0', '0', '1', '2', '0.5', '163', '0', '1', '0', '0.25', '0', '0', '30.8', '3', '1.4', '0']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import java . util . Properties ; import javax . jms . * ; import javax . naming . InitialContext ; import javax . naming . Context ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; public class JMSAppender extends AppenderSkeleton { TopicConnection topicConnection ; TopicSession topicSession ; TopicPublisher topicPublisher ; static String TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION = "TopicConnectionFactoryBindingName" ; static String TOPIC_BINDING_NAME_OPTION = "TopicBindingName" ; String topicBindingName ; String tcfBindingName ; public JMSAppender ( ) { } protected Object lookup ( Context ctx , String name ) throws NamingException { try { return ctx . lookup ( name ) ; } catch ( NameNotFoundException e ) { LogLog . error ( "Could not find name [" + name + "]." ) ; throw e ; } } public void activateOptions ( ) { TopicConnectionFactory topicConnectionFactory ; try { Context ctx = new InitialContext ( ) ; topicConnectionFactory = ( TopicConnectionFactory ) lookup ( ctx , tcfBindingName ) ; topicConnection = topicConnectionFactory . createTopicConnection ( ) ; topicConnection . start ( ) ; topicSession = topicConnection . createTopicSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Topic topic = ( Topic ) lookup ( ctx , topicBindingName ) ; topicPublisher = topicSession . createPublisher ( topic ) ; ctx . close ( ) ; } catch ( Exception e ) { errorHandler . error ( "Error while activating options for appender named [" + name + "]." , e , ErrorCode . GENERIC_FAILURE ) ; } } protected boolean checkEntryConditions ( ) { String fail = null ; if ( this . topicConnection == null ) { fail = "No TopicConnection" ; } else if ( this . topicSession == null ) { fail = "No TopicSession" ; } else if ( this . topicPublisher == null ) { fail = "No TopicPublisher" ; } if ( fail != null ) { errorHandler . error ( fail + " for JMSAppender named [" + name + "]." ) ; return false ; } else { return true ; } } public synchronized void close ( ) { if ( this . closed ) return ; LogLog . debug ( "Closing appender [" + name + "]." ) ; this . closed = true ; try { if ( topicSession != null ) topicSession . close ( ) ; if ( topicConnection != null ) topicConnection . close ( ) ; } catch ( Exception e ) { LogLog . error ( "Error while closing JMSAppender [" + name + "]." , e ) ; } topicPublisher = null ; topicSession = null ; topicConnection = null ; } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } try { ObjectMessage msg = topicSession . createObjectMessage ( ) ; msg . setObject ( event ) ; topicPublisher . publish ( msg ) ; } catch ( Exception e ) { errorHandler . error ( "Could not publish message in JMSAppender [" + name + "]." , e , ErrorCode . GENERIC_FAILURE ) ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { TOPIC_BINDING_NAME_OPTION , TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION } ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equals ( TOPIC_BINDING_NAME_OPTION ) ) topicBindingName = value ; else if ( key . equals ( TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION ) ) { tcfBindingName = value ; } } public boolean requiresLayout ( ) { return false ; } } 	0	['10', '2', '0', '5', '35', '25', '0', '5', '7', '0.761904762', '272', '0', '0', '0.692307692', '0.361111111', '2', '3', '25.5', '5', '1.8', '0']
package org . apache . log4j . spi ; public interface TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; public interface CategoryFactory { public Category makeNewCategoryInstance ( String name ) ; } 	0	['1', '1', '0', '8', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Hierarchy ; import java . net . URL ; public interface Configurator { void doConfigure ( URL url , Hierarchy hierarchy ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . or ; class DefaultRenderer implements ObjectRenderer { DefaultRenderer ( ) { } public String doRender ( Object o ) { return o . toString ( ) ; } } 	0	['2', '1', '0', '2', '4', '1', '1', '1', '1', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressNDC extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int PUSH_MISS = LOOP_LENGTH / 2 ; static final int POP_MISS = PUSH_MISS * 2 ; static final int BRANCHING_FACTOR = 4 + 1 ; static int maxThreads ; static int msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { root . setPriority ( Priority . DEBUG ) ; BasicConfigurator . configure ( ) ; if ( args . length != 1 ) { usage ( ) ; } try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } root . debug ( "push(IP=127.0.0.1)" ) ; NDC . push ( "IP=127.0.0.1" ) ; while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.StressNDC " + "MAX_THREADS" ) ; System . exit ( 1 ) ; } Stack parentDC ; public StressNDC ( Stack parentDC ) { this . setName ( randomID ( ) ) ; this . parentDC = parentDC ; } public void run ( ) { NDC . inherit ( parentDC ) ; int loopLength = StressNDC . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop.debug( loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; if ( randomInt ( PUSH_MISS ) == 0 ) { String id = randomID ( ) ; root . debug ( "push(" + id + ")" ) ; NDC . push ( id ) ; } root . debug ( "Message number " + StressNDC . msgCounter ++ ) ; if ( randomInt ( POP_MISS ) == 0 ) { root . debug ( "pop()" ) ; NDC . pop ( ) ; } } synchronized ( lock ) { StressNDC . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressNDC . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } if ( ( loopLength % 2 ) == 0 ) { root . debug ( "Removing NDC for this thread." ) ; NDC . remove ( ) ; } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstained ( n ) ; root . debug ( "Creating " + n + " child StressNDC threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressNDC, threadCounter = " + ( ++ threadCounter ) ) ; new StressNDC ( NDC . cloneStack ( ) ) . start ( ) ; } } } static public int maxThreadsConstained ( int a ) { int maxAllowed = StressNDC . maxThreads - StressNDC . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public static String randomID ( ) { return Integer . toHexString ( random . nextInt ( ) & 0xFFFFFF ) ; } } 	0	['9', '2', '0', '4', '37', '8', '0', '4', '7', '0.822916667', '314', '0', '1', '0.897058824', '0.21875', '0', '0', '32.55555556', '7', '2', '0']
package org . apache . log4j . varia ; import java . io . File ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . FileAppender ; import org . apache . log4j . Layout ; public class ResilientFileAppender extends FileAppender { File file ; public ResilientFileAppender ( ) { } public ResilientFileAppender ( Layout layout , Writer writer ) { super ( layout , writer ) ; } protected boolean checkEntryConditions ( ) { if ( ! super . checkEntryConditions ( ) ) { return false ; } if ( ( file != null ) && ! file . exists ( ) ) { file = new File ( fileName ) ; try { setFile ( fileName ) ; } catch ( java . io . IOException e ) { LogLog . error ( "setFile(" + fileName + "," + fileAppend + ") call failed." , e ) ; } } return true ; } public void setFile ( String fileName , boolean append ) throws IOException { super . setFile ( fileName , append ) ; file = new File ( fileName ) ; } protected void reset ( ) { super . reset ( ) ; file = null ; } } 	0	['5', '3', '0', '3', '18', '4', '0', '3', '3', '0.5', '76', '0', '0', '0.916666667', '0.36', '1', '7', '14', '4', '1.2', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; import java . util . Enumeration ; public interface AppenderAttachable { public void addAppender ( Appender newAppender ) ; public Enumeration getAllAppenders ( ) ; public Appender getAppender ( String name ) ; void removeAllAppenders ( ) ; void removeAppender ( Appender appender ) ; void removeAppender ( String name ) ; } 	0	['6', '1', '0', '5', '6', '15', '4', '1', '6', '2', '6', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; public interface ErrorHandler extends OptionHandler { void error ( String message , Exception e , int errorCode ) ; void error ( String message ) ; } 	0	['2', '1', '0', '15', '2', '1', '14', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . or . MessageRenderer ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import javax . jms . * ; import javax . naming . InitialContext ; import javax . naming . Context ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; public class JMSSink { static public void main ( String [ ] args ) { if ( args . length != 3 ) { usage ( "Wrong number of arguments." ) ; } String tcfBindingName = args [ 0 ] ; String topicBindingName = args [ 1 ] ; PropertyConfigurator . configure ( args [ 2 ] ) ; Category . getDefaultHierarchy ( ) . addRenderer ( Message . class , new MessageRenderer ( ) ) ; try { Context ctx = new InitialContext ( ) ; TopicConnectionFactory topicConnectionFactory ; topicConnectionFactory = ( TopicConnectionFactory ) lookup ( ctx , tcfBindingName ) ; TopicConnection topicConnection = topicConnectionFactory . createTopicConnection ( ) ; topicConnection . start ( ) ; TopicSession topicSession = topicConnection . createTopicSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Topic topic = ( Topic ) ctx . lookup ( topicBindingName ) ; TopicSubscriber topicSubscriber = topicSession . createDurableSubscriber ( topic , "x" ) ; LoggingEvent event ; Category remoteCategory ; while ( true ) { ObjectMessage msg = ( ObjectMessage ) topicSubscriber . receive ( ) ; event = ( LoggingEvent ) msg . getObject ( ) ; remoteCategory = Category . getInstance ( event . categoryName ) ; remoteCategory . callAppenders ( event ) ; } } catch ( Exception e ) { LogLog . error ( "Could not read JMS message." , e ) ; } } protected static Object lookup ( Context ctx , String name ) throws NamingException { try { return ctx . lookup ( name ) ; } catch ( NameNotFoundException e ) { LogLog . error ( "Could not find name [" + name + "]." ) ; throw e ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + JMSSink . class . getName ( ) + " TopicConnectionFactoryBindingName TopicBindingName configFile" ) ; System . exit ( 1 ) ; } } 	0	['5', '1', '0', '7', '31', '10', '0', '7', '2', '0.875', '145', '0', '0', '0', '0.3', '0', '0', '27.6', '3', '1.4', '0']
package org . apache . log4j . varia ; import java . io . * ; import java . net . Socket ; import java . net . ServerSocket ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . RollingFileAppender ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; public class ExternallyRolledFileAppender extends RollingFileAppender { static final public String PORT_OPTION = "Port" ; static final public String ROLL_OVER = "RollOver" ; static final public String OK = "OK" ; int port = 0 ; HUP hup ; public ExternallyRolledFileAppender ( ) { } public void activateOptions ( ) { super . activateOptions ( ) ; if ( port != 0 ) { if ( hup != null ) { hup . interrupt ( ) ; } hup = new HUP ( this , port ) ; hup . setDaemon ( true ) ; hup . start ( ) ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { PORT_OPTION } ) ; } public void setOption ( String option , String value ) { super . setOption ( option , value ) ; if ( option . equalsIgnoreCase ( PORT_OPTION ) ) { port = OptionConverter . toInt ( value , port ) ; LogLog . debug ( "Port option set to " + port ) ; } } } class HUP extends Thread { int port ; ExternallyRolledFileAppender er ; HUP ( ExternallyRolledFileAppender er , int port ) { this . er = er ; this . port = port ; } public void run ( ) { while ( ! isInterrupted ( ) ) { try { ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { Socket socket = serverSocket . accept ( ) ; LogLog . debug ( "Connected to client at " + socket . getInetAddress ( ) ) ; new Thread ( new HUPNode ( socket , er ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } class HUPNode implements Runnable { Socket socket ; DataInputStream dis ; DataOutputStream dos ; ExternallyRolledFileAppender er ; public HUPNode ( Socket socket , ExternallyRolledFileAppender er ) { this . socket = socket ; this . er = er ; try { dis = new DataInputStream ( socket . getInputStream ( ) ) ; dos = new DataOutputStream ( socket . getOutputStream ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void run ( ) { try { String line = dis . readUTF ( ) ; LogLog . debug ( "Got external roll over signal." ) ; if ( ExternallyRolledFileAppender . ROLL_OVER . equals ( line ) ) { synchronized ( er ) { er . rollOver ( ) ; } dos . writeUTF ( ExternallyRolledFileAppender . OK ) ; } else { dos . writeUTF ( "Expecting [RollOver] string." ) ; } dos . close ( ) ; } catch ( Exception e ) { LogLog . error ( "Unexptected exception. Exiting HUPNode." , e ) ; } } } 	0	['4', '4', '0', '6', '20', '0', '2', '5', '4', '1.066666667', '77', '0', '1', '0.931818182', '0.625', '2', '4', '17', '3', '1.5', '0']
package org . apache . log4j . gui . examples ; import java . awt . BorderLayout ; import java . awt . event . * ; import javax . swing . * ; import org . apache . log4j . * ; import org . apache . log4j . gui . * ; public class TextPaneAppenderExample implements ActionListener { JFrame mainframe ; ButtonGroup priorities ; TextPaneAppender tpa ; Category gui ; Priority prio [ ] ; JTabbedPane logview ; public TextPaneAppenderExample ( ) { mainframe = new JFrame ( "Testing the TextPaneAppender..." ) ; mainframe . setSize ( 300 , 300 ) ; logview = new JTabbedPane ( ) ; createLogger ( ) ; createMenuBar ( ) ; mainframe . setVisible ( true ) ; mainframe . getContentPane ( ) . add ( logview ) ; } public void createLogger ( ) { tpa = new TextPaneAppender ( new PatternLayout ( "%-5p %d [%t]:  %m%n" ) , "Debug" ) ; logview . addTab ( "Events ..." , new JScrollPane ( tpa . getTextPane ( ) ) ) ; gui = Category . getInstance ( this . getClass ( ) . getName ( ) ) ; gui . addAppender ( tpa ) ; } public void createMenuBar ( ) { JMenu file = new JMenu ( "File" ) ; JMenuItem exit = new JMenuItem ( "Exit" ) ; exit . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ae ) { System . exit ( 0 ) ; } } ) ; file . add ( exit ) ; JMenuBar mb = new JMenuBar ( ) ; mb . add ( file ) ; JMenu logevent = new JMenu ( "LoggingEvents" ) ; JMenu selectprio = new JMenu ( "Priority" ) ; prio = Priority . getAllPossiblePriorities ( ) ; JRadioButtonMenuItem priority [ ] = new JRadioButtonMenuItem [ prio . length ] ; priorities = new ButtonGroup ( ) ; for ( int i = 0 ; i < prio . length ; i ++ ) { if ( i == 0 ) priority [ i ] = new JRadioButtonMenuItem ( prio [ i ] . toString ( ) , true ) ; else priority [ i ] = new JRadioButtonMenuItem ( prio [ i ] . toString ( ) ) ; priority [ i ] . setActionCommand ( prio [ i ] . toString ( ) ) ; selectprio . add ( priority [ i ] ) ; priorities . add ( priority [ i ] ) ; } logevent . add ( selectprio ) ; JMenuItem lognow = new JMenuItem ( "LogIt!" ) ; lognow . addActionListener ( this ) ; logevent . add ( lognow ) ; mb . add ( logevent ) ; mainframe . setJMenuBar ( mb ) ; } public void actionPerformed ( ActionEvent ae ) { String logtext = JOptionPane . showInputDialog ( "Text to log" ) ; if ( logtext == null ) logtext = "NO Input" ; int i = 0 ; String name = priorities . getSelection ( ) . getActionCommand ( ) ; while ( ! prio [ i ] . toString ( ) . equals ( name ) ) i = i + 1 ; gui . log ( prio [ i ] , logtext ) ; } static public void main ( String args [ ] ) { TextPaneAppenderExample tpex = new TextPaneAppenderExample ( ) ; } } 	0	['5', '1', '0', '7', '41', '2', '1', '7', '5', '0.375', '250', '0', '3', '0', '0.4', '0', '0', '47.8', '3', '1.6', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . Appender ; import org . apache . log4j . FileAppender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . TTCCLayout ; import org . apache . log4j . Priority ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import java . io . IOException ; public class Min { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test1 ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.Min " + "simple|ttcc" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String layoutType ) { Appender appender = null ; Layout layout = null ; if ( layoutType . equals ( "simple" ) ) layout = new SimpleLayout ( ) ; else if ( layoutType . equals ( "ttcc" ) ) { layout = new TTCCLayout ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ; } else Usage ( "Wrong layoutType [" + layoutType + "]." ) ; appender = new FileAppender ( layout , System . out ) ; BasicConfigurator . configure ( appender ) ; } static void test1 ( ) { int i = 0 ; Category ERR = Category . getInstance ( "ERR" ) ; ERR . setPriority ( Priority . ERROR ) ; Category INF = Category . getInstance ( "INF" ) ; INF . setPriority ( Priority . INFO ) ; Category INF_ERR = Category . getInstance ( "INF.ERR" ) ; INF_ERR . setPriority ( Priority . ERROR ) ; Category DEB = Category . getInstance ( "DEB" ) ; DEB . setPriority ( Priority . DEBUG ) ; Category INF_UNDEF = Category . getInstance ( "INF.UNDEF" ) ; Category INF_ERR_UNDEF = Category . getInstance ( "INF.ERR.UNDEF" ) ; Category UNDEF = Category . getInstance ( "UNDEF" ) ; ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; ERR . error ( "Message " + i ) ; i ++ ; INF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF . error ( "Message " + i ) ; i ++ ; INF . warn ( "Message " + i ) ; i ++ ; INF . info ( "Message " + i ) ; i ++ ; INF_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_UNDEF . error ( "Message " + i ) ; i ++ ; INF_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR . error ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR_UNDEF . error ( "Message " + i ) ; i ++ ; DEB . log ( Priority . FATAL , "Message " + i ) ; i ++ ; DEB . error ( "Message " + i ) ; i ++ ; DEB . warn ( "Message " + i ) ; i ++ ; DEB . info ( "Message " + i ) ; i ++ ; DEB . debug ( "Message " + i ) ; i ++ ; UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; UNDEF . error ( "Message " + i ) ; i ++ ; UNDEF . warn ( "Message " + i ) ; i ++ ; UNDEF . info ( "Message " + i ) ; i ++ ; UNDEF . debug ( "Message " + i , new Exception ( "Just testing." ) ) ; i ++ ; ERR . warn ( "Message " + i ) ; i ++ ; ERR . info ( "Message " + i ) ; i ++ ; ERR . debug ( "Message " + i ) ; i ++ ; INF . debug ( "Message " + i ) ; i ++ ; INF_UNDEF . debug ( "Message " + i ) ; i ++ ; INF_ERR . warn ( "Message " + i ) ; i ++ ; INF_ERR . info ( "Message " + i ) ; i ++ ; INF_ERR . debug ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . debug ( "Message " + i ) ; i ++ ; INF . info ( "Messages should bear numbers 0 through 23." ) ; } } 	0	['5', '1', '0', '8', '26', '10', '0', '8', '2', '2', '508', '0', '0', '0', '0.266666667', '0', '0', '100.6', '3', '1.4', '0']
package org . apache . log4j . test ; public class SpacePad { static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; static public void main ( String [ ] args ) { StringBuffer sbuf = new StringBuffer ( ) ; for ( int i = 0 ; i < 35 ; i ++ ) { sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , i ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , 67 ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } static public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['4', '1', '0', '0', '10', '4', '0', '0', '3', '0.333333333', '114', '0', '0', '0', '0.333333333', '0', '0', '27.25', '4', '1.5', '0']
package org . apache . log4j . gui ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Priority ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . spi . LoggingEvent ; import javax . swing . JList ; import javax . swing . AbstractListModel ; import javax . swing . JFrame ; import javax . swing . JButton ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JTextArea ; import javax . swing . JScrollPane ; import javax . swing . ListCellRenderer ; import java . awt . Component ; import java . awt . FlowLayout ; import java . awt . GridLayout ; import javax . swing . BoxLayout ; import java . awt . BorderLayout ; import java . awt . Dimension ; import java . awt . event . ActionListener ; import java . awt . event . ActionEvent ; import java . awt . Container ; import javax . swing . ImageIcon ; import java . awt . Image ; import java . awt . Toolkit ; import java . net . URL ; import java . awt . Rectangle ; public class JListView extends JList { static Category cat = Category . getInstance ( JListView . class . getName ( ) ) ; PatternLayout layout ; static LoggingEvent proto = new LoggingEvent ( "x" , cat , Priority . ERROR , "Message " , new Throwable ( ) ) ; public JListView ( JListViewModel model ) { super ( model ) ; layout = new PatternLayout ( "%r %p %c [%t] -  %m" ) ; this . setCellRenderer ( new MyCellRenderer ( ) ) ; } public void add ( LoggingEvent event ) { ( ( JListViewModel ) getModel ( ) ) . add ( event ) ; } static public void main ( String [ ] args ) { JFrame frame = new JFrame ( "JListView test" ) ; Container container = frame . getContentPane ( ) ; JListView view = new JListView ( new JListViewModel ( Integer . parseInt ( args [ 0 ] ) ) ) ; JScrollPane sp = new JScrollPane ( view ) ; sp . setPreferredSize ( new Dimension ( 250 , 80 ) ) ; container . setLayout ( new BoxLayout ( container , BoxLayout . X_AXIS ) ) ; container . add ( sp ) ; JButton b1 = new JButton ( "Add 1" ) ; JButton b10 = new JButton ( "Add 10" ) ; JButton b100 = new JButton ( "Add 100" ) ; JButton b1000 = new JButton ( "Add 1000" ) ; JButton b10000 = new JButton ( "Add 10000" ) ; JPanel panel = new JPanel ( new GridLayout ( 0 , 1 ) ) ; container . add ( panel ) ; panel . add ( b1 ) ; panel . add ( b10 ) ; panel . add ( b100 ) ; panel . add ( b1000 ) ; panel . add ( b10000 ) ; AddAction a1 = new AddAction ( view , 1 ) ; AddAction a10 = new AddAction ( view , 10 ) ; AddAction a100 = new AddAction ( view , 100 ) ; AddAction a1000 = new AddAction ( view , 1000 ) ; AddAction a10000 = new AddAction ( view , 10000 ) ; b1 . addActionListener ( a1 ) ; b10 . addActionListener ( a10 ) ; b100 . addActionListener ( a100 ) ; b1000 . addActionListener ( a1000 ) ; b10000 . addActionListener ( a10000 ) ; frame . setVisible ( true ) ; frame . setSize ( new Dimension ( 700 , 700 ) ) ; long before = System . currentTimeMillis ( ) ; int RUN = 1000 ; int i = 0 ; while ( i ++ < RUN ) { LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . ERROR , "Message " + i , null ) ; event . getThreadName ( ) ; if ( i % 10 == 0 ) { event . throwable = new Exception ( "hello " + i ) ; } view . add ( event ) ; } long after = System . currentTimeMillis ( ) ; System . out . println ( "Time taken :" + ( ( after - before ) * 1000 / RUN ) ) ; } class MyCellRenderer extends JTextArea implements ListCellRenderer { Object o = new Object ( ) ; int i = 0 ; final ImageIcon longIcon = new ImageIcon ( "RedFlag.gif" ) ; public MyCellRenderer ( ) { System . out . println ( "----------------------" ) ; } public int getTabSize ( ) { return 2 ; } public Image loadIcon ( String path ) { Image img = null ; try { URL url = ClassLoader . getSystemResource ( path ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { if ( value instanceof LoggingEvent ) { LoggingEvent event = ( LoggingEvent ) value ; String str = layout . format ( event ) ; String t = event . getThrowableInformation ( ) ; if ( t != null ) { setText ( str + Layout . LINE_SEP + t ) ; } else { setText ( str ) ; } } else { setText ( value . toString ( ) ) ; } return this ; } } } class JListViewModel extends AbstractListModel { CyclicBuffer cb ; JListViewModel ( int size ) { cb = new CyclicBuffer ( size ) ; } public void add ( LoggingEvent event ) { cb . add ( event ) ; int j = cb . length ( ) ; fireContentsChanged ( this , 0 , j ) ; } public Object getElementAt ( int index ) { return cb . get ( index ) ; } public int getSize ( ) { return cb . length ( ) ; } } class AddAction implements ActionListener { Thread t ; static int counter = 0 ; public AddAction ( JListView view , int burst ) { this . t = new AddThread ( view , burst ) ; t . start ( ) ; } public void actionPerformed ( ActionEvent e ) { System . out . println ( "Action occured" ) ; synchronized ( t ) { t . notify ( ) ; } } class AddThread extends Thread { int burst ; JListView view ; Category cat = Category . getInstance ( "x" ) ; AddThread ( JListView view , int burst ) { super ( ) ; this . burst = burst ; this . view = view ; setName ( "AddThread" + burst ) ; } public void run ( ) { while ( true ) { synchronized ( this ) { try { this . wait ( ) ; } catch ( Exception e ) { } } for ( int i = 0 ; i < burst ; i ++ ) { LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . DEBUG , "Message " + counter , null ) ; event . getThreadName ( ) ; if ( counter % 50 == 0 ) { event . throwable = new Exception ( "hello " + counter ) ; } counter ++ ; view . add ( event ) ; } } } } } 	0	['5', '5', '0', '8', '44', '8', '3', '7', '3', '0.875', '289', '0', '3', '0.995695839', '0.3', '0', '0', '56', '3', '1', '0']
package org . apache . log4j . or ; import java . util . Hashtable ; public class RendererMap { Hashtable map ; static ObjectRenderer defaultRenderer = new DefaultRenderer ( ) ; public RendererMap ( ) { map = new Hashtable ( ) ; } public String findAndRender ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) . doRender ( o ) ; } public ObjectRenderer get ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) ; } public ObjectRenderer get ( Class clazz ) { ObjectRenderer r = null ; for ( Class c = clazz ; c != null ; c = c . getSuperclass ( ) ) { r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } r = searchInterfaces ( c ) ; if ( r != null ) return r ; } return defaultRenderer ; } ObjectRenderer searchInterfaces ( Class c ) { ObjectRenderer r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } else { Class [ ] ia = c . getInterfaces ( ) ; for ( int i = 0 ; i < ia . length ; i ++ ) { r = searchInterfaces ( ia [ i ] ) ; if ( r != null ) return r ; } } return null ; } public ObjectRenderer getDefaultRenderer ( ) { return defaultRenderer ; } public void clear ( ) { map . clear ( ) ; } public void put ( Class clazz , ObjectRenderer or ) { map . put ( clazz , or ) ; } } 	0	['9', '1', '0', '5', '19', '10', '3', '2', '7', '0.375', '120', '0', '1', '0', '0.4375', '0', '0', '12.11111111', '4', '1.6667', '0']
package org . apache . log4j . test ; import java . util . Properties ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; public class SysoutConfigurator implements Configurator { public void doConfigure ( java . net . URL url , Hierarchy hierarchy ) { Category . getRoot ( ) . addAppender ( new FileAppender ( new SimpleLayout ( ) , System . out ) ) ; } } 	0	['2', '1', '0', '7', '7', '1', '0', '7', '2', '2', '15', '0', '0', '0', '0.666666667', '0', '0', '6.5', '1', '0.5', '0']
package org . apache . log4j ; import org . apache . log4j . spi . CategoryFactory ; class DefaultCategoryFactory implements CategoryFactory { DefaultCategoryFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new Category ( name ) ; } } 	0	['2', '1', '0', '4', '4', '1', '2', '2', '1', '2', '10', '0', '0', '0', '0.75', '0', '0', '4', '1', '0.5', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; public class SyslogQuietWriter extends QuietWriter { int syslogFacility ; int priority ; public SyslogQuietWriter ( Writer writer , int syslogFacility , ErrorHandler eh ) { super ( writer , eh ) ; this . syslogFacility = syslogFacility ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setSyslogFacility ( int syslogFacility ) { this . syslogFacility = syslogFacility ; } public void write ( String string ) { super . write ( "<" + ( syslogFacility | priority ) + ">" + string ) ; } } 	0	['4', '4', '0', '3', '10', '0', '1', '2', '4', '0.5', '41', '0', '0', '0.875', '0.5', '2', '2', '8.75', '1', '0.75', '0']
package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class DateTimeDateFormat extends AbsoluteTimeDateFormat { String [ ] shortMonths ; public DateTimeDateFormat ( ) { super ( ) ; shortMonths = new DateFormatSymbols ( ) . getShortMonths ( ) ; } public DateTimeDateFormat ( TimeZone timeZone ) { this ( ) ; setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; sbuf . append ( shortMonths [ calendar . get ( Calendar . MONTH ) ] ) ; sbuf . append ( ' ' ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '15', '4', '2', '1', '4', '0.333333333', '80', '0', '0', '0.953488372', '0.357142857', '1', '3', '18.75', '2', '0.75', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import org . apache . log4j . net . SocketAppender ; public class Loop { public static void main ( String [ ] args ) { Category root = Category . getRoot ( ) ; Category cat = Category . getInstance ( Loop . class . getName ( ) ) ; if ( args . length != 2 ) usage ( "Wrong number of arguments." ) ; String host = args [ 0 ] ; int port = 0 ; try { port = Integer . valueOf ( args [ 1 ] ) . intValue ( ) ; } catch ( NumberFormatException e ) { usage ( "Argument [" + args [ 1 ] + "] is not in proper int form." ) ; } SocketAppender sa = new SocketAppender ( host , port ) ; Layout layout = new PatternLayout ( "%5p [%t] %x %c - %m\n" ) ; FileAppender so = new FileAppender ( layout , System . out ) ; root . addAppender ( sa ) ; root . addAppender ( so ) ; int i = 0 ; while ( true ) { NDC . push ( "" + ( i ++ ) ) ; cat . debug ( "Debug message." ) ; root . info ( "Info message." ) ; NDC . pop ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Loop . class . getName ( ) + " host port" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '7', '27', '4', '0', '7', '2', '0.666666667', '134', '0', '0', '0', '0.333333333', '0', '0', '32.25', '3', '1.5', '0']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; public class ThreadGroupRenderer implements ObjectRenderer { public ThreadGroupRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof ThreadGroup ) { StringBuffer sbuf = new StringBuffer ( ) ; ThreadGroup tg = ( ThreadGroup ) o ; sbuf . append ( "java.lang.ThreadGroup[name=" ) ; sbuf . append ( tg . getName ( ) ) ; sbuf . append ( ", maxpri=" ) ; sbuf . append ( tg . getMaxPriority ( ) ) ; sbuf . append ( "]" ) ; Thread [ ] t = new Thread [ tg . activeCount ( ) ] ; tg . enumerate ( t ) ; for ( int i = 0 ; i < t . length ; i ++ ) { sbuf . append ( Layout . LINE_SEP ) ; sbuf . append ( "   Thread=[" ) ; sbuf . append ( t [ i ] . getName ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . getPriority ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . isDaemon ( ) ) ; sbuf . append ( "]" ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '2', '16', '1', '0', '2', '2', '2', '100', '0', '0', '0', '0.75', '0', '0', '49', '3', '1.5', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class SyslogMin { static Category CAT = Category . getInstance ( SyslogMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SyslogMin . class + " configFile" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String configFile ) { int port = 0 ; PropertyConfigurator . configure ( configFile ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; CAT . debug ( "Message " + i ++ ) ; CAT . info ( "Message " + i ++ ) ; CAT . warn ( "Message " + i ++ ) ; CAT . error ( "Message " + i ++ ) ; CAT . log ( Priority . FATAL , "Message " + i ++ ) ; CAT . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '4', '29', '17', '0', '4', '2', '0.666666667', '154', '0', '1', '0', '0.333333333', '0', '0', '20.71428571', '2', '1', '0']
package org . apache . log4j . varia . test ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; public class Loop { static Category cat = Category . getInstance ( Loop . class . getName ( ) ) ; static int loopLength ; public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Loop . class . getName ( ) + "configFile loopLength" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String loopStr ) { PropertyConfigurator . configure ( configFile ) ; try { loopLength = Integer . parseInt ( loopStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret loopLength [" + loopStr + "]." ) ; } } static void test ( ) { for ( int i = 0 ; i < loopLength ; i ++ ) { Thread . yield ( ) ; cat . debug ( "MSG " + i ) ; } } } 	0	['7', '1', '0', '2', '24', '15', '0', '2', '2', '0.611111111', '117', '0', '1', '0', '0.277777778', '0', '0', '15.28571429', '2', '1.1429', '0']
package org . apache . log4j . varia ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import java . io . IOException ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . net . Socket ; public class Roller { static Category cat = Category . getInstance ( Roller . class . getName ( ) ) ; static String host ; static int port ; Roller ( ) { } public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; roll ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Roller . class . getName ( ) + "host_name port_number" ) ; System . exit ( 1 ) ; } static void init ( String hostArg , String portArg ) { host = hostArg ; try { port = Integer . parseInt ( portArg ) ; } catch ( java . lang . NumberFormatException e ) { usage ( "Second argument " + portArg + " is not a valid integer." ) ; } } static void roll ( ) { try { Socket socket = new Socket ( host , port ) ; DataOutputStream dos = new DataOutputStream ( socket . getOutputStream ( ) ) ; DataInputStream dis = new DataInputStream ( socket . getInputStream ( ) ) ; dos . writeUTF ( ExternallyRolledFileAppender . ROLL_OVER ) ; String rc = dis . readUTF ( ) ; if ( ExternallyRolledFileAppender . OK . equals ( rc ) ) { cat . info ( "Roll over signal acknowledged by remote appender." ) ; } else { cat . warn ( "Unexpected return code " + rc + " from remote entity." ) ; System . exit ( 2 ) ; } } catch ( IOException e ) { cat . error ( "Could not send roll signal on host " + host + " port " + port + " ." , e ) ; System . exit ( 2 ) ; } System . exit ( 0 ) ; } } 	0	['7', '1', '0', '2', '32', '15', '0', '2', '1', '0.625', '168', '0', '1', '0', '0.277777778', '0', '0', '22.42857143', '2', '1.1429', '0']
package org . apache . log4j . xml . test ; import org . apache . log4j . Priority ; public class TPriority extends Priority { static final int TRACE_INT = 8000 ; static final int SYSLOG_TRACE_INT = 7 ; private static String TRACE_STR = "TRACE" ; public static final TPriority TRACE = new TPriority ( TRACE_INT , "TRACE" , 7 ) ; protected TPriority ( int level , String strLevel , int syslogEquiv ) { super ( level , strLevel , syslogEquiv ) ; } public static Priority toPriority ( String sArg ) { if ( sArg == null ) return TPriority . TRACE ; String stringVal = sArg . toUpperCase ( ) ; if ( stringVal . equalsIgnoreCase ( TRACE_STR ) ) return TPriority . TRACE ; return Priority . toPriority ( sArg ) ; } public static Priority toPriority ( int i ) throws IllegalArgumentException { switch ( i ) { case TRACE_INT : return TPriority . TRACE ; } return Priority . toPriority ( i ) ; } } 	0	['4', '2', '0', '2', '9', '0', '1', '1', '2', '0.916666667', '47', '0.25', '1', '0.8', '0.555555556', '0', '0', '9.75', '3', '1.25', '0']
package org . apache . log4j . spi ; public interface ErrorCode { public final int GENERIC_FAILURE = 0 ; public final int WRITE_FAILURE = 1 ; public final int FLUSH_FAILURE = 2 ; public final int CLOSE_FAILURE = 3 ; public final int FILE_OPEN_FAILURE = 4 ; public final int MISSING_LAYOUT = 5 ; public final int ADDRESS_PARSE_FAILURE = 6 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . log4j . helpers ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class RelativeTimeDateFormat extends DateFormat { protected final long startTime ; public RelativeTimeDateFormat ( ) { this . startTime = System . currentTimeMillis ( ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { return sbuf . append ( ( date . getTime ( ) - startTime ) ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['3', '3', '0', '1', '7', '1', '1', '0', '3', '0.5', '20', '1', '0', '0.951219512', '0.444444444', '1', '3', '5.333333333', '1', '0.6667', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; public class NotLogging { static int runLength ; final static int INITIAL_HASH_SIZE = 101 ; static String SHORT_MSG = "Hello World" ; static Category SHORT_CAT = Category . getInstance ( "A0123456789" ) ; static Category MEDIUM_CAT = Category . getInstance ( "A0123456789.B0123456789" ) ; static Category LONG_CAT = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static Category INEXISTENT_SHORT_CAT = Category . getInstance ( "I0123456789" ) ; static Category INEXISTENT_MEDIUM_CAT = Category . getInstance ( "I0123456789.B0123456789" ) ; static Category INEXISTENT_LONG_CAT = Category . getInstance ( "I0123456789.B0123456789.C0123456789" ) ; static Category [ ] CAT_ARRAY = new Category [ ] { SHORT_CAT , MEDIUM_CAT , LONG_CAT , INEXISTENT_SHORT_CAT , INEXISTENT_MEDIUM_CAT , INEXISTENT_LONG_CAT } ; static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.NotLogging true|false runLength\n" + "true indicates shipped code, false indicates code in development" + "  where runLength is an int representing the run length of loops\n" + "We suggest that runLength be at least 100'000." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length != 2 ) { Usage ( ) ; } ProgramInit ( argv ) ; double delta ; System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = SimpleMessage ( CAT_ARRAY [ i ] , SHORT_MSG , runLength ) ; System . out . println ( "Simple argument,          " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = FullyOptimizedComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Fully optimized complex,  " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = ComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Complex message argument, " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } } static void ProgramInit ( String [ ] args ) { try { runLength = Integer . parseInt ( args [ 1 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } FileAppender appender = new FileAppender ( new SimpleLayout ( ) , System . err ) ; if ( "false" . equals ( args [ 0 ] ) ) ; else if ( "true" . equals ( args [ 0 ] ) ) { System . out . println ( "Flagging as shipped code." ) ; BasicConfigurator . disableInfo ( ) ; } else Usage ( ) ; SHORT_CAT . setPriority ( Priority . INFO ) ; Category . getRoot ( ) . setPriority ( Priority . INFO ) ; } static double SimpleMessage ( Category category , String msg , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( msg ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double FullyOptimizedComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { if ( category . isDebugEnabled ( ) ) category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double ComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } } 	0	['8', '1', '0', '6', '30', '22', '0', '6', '2', '0.942857143', '324', '0', '7', '0', '0.285714286', '0', '0', '38.25', '5', '2', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class NullAppender extends AppenderSkeleton { public static String s ; public String t ; public NullAppender ( ) { } public NullAppender ( Layout layout ) { this . layout = layout ; } public void close ( ) { } public void doAppend ( LoggingEvent event ) { if ( layout != null ) { t = layout . format ( event ) ; s = t ; } } public void append ( LoggingEvent event ) { } public boolean requiresLayout ( ) { return true ; } } 	0	['6', '2', '0', '3', '8', '15', '0', '3', '6', '1', '34', '0', '0', '0.818181818', '0.5', '1', '1', '4.333333333', '2', '0.8333', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; public class ROFile { static Category cat = Category . getInstance ( ROFile . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ROFile . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; cat . debug ( "Message " + ++ i ) ; } } 	0	['7', '1', '0', '2', '21', '17', '0', '2', '2', '0.666666667', '90', '0', '1', '0', '0.277777778', '0', '0', '11.57142857', '2', '1', '0']
package org . apache . log4j ; import java . util . Vector ; class ProvisionNode extends Vector { ProvisionNode ( Category cat ) { super ( ) ; this . addElement ( cat ) ; } } 	0	['1', '4', '0', '2', '3', '0', '1', '1', '0', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . log4j . xml . examples ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . net . * ; public class XMLSample { static Category cat = Category . getInstance ( XMLSample . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; sample ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + XMLSample . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { DOMConfigurator . configure ( configFile ) ; } static void sample ( ) { int i = - 1 ; Category root = Category . getRoot ( ) ; cat . debug ( "Message " + ++ i ) ; cat . warn ( "Message " + ++ i ) ; cat . error ( "Message " + ++ i ) ; Exception e = new Exception ( "Just testing" ) ; cat . debug ( "Message " + ++ i , e ) ; } } 	0	['7', '1', '0', '2', '26', '17', '0', '2', '2', '0.666666667', '131', '0', '1', '0', '0.277777778', '0', '0', '17.42857143', '2', '1', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; import java . io . InputStreamReader ; public class SocketMin { static Category cat = Category . getInstance ( SyslogMin . class . getName ( ) ) ; static SocketAppender s ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; if ( argv [ 2 ] . equals ( "true" ) ) loop ( ) ; else test ( ) ; s . close ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketMin . class + " host port true|false" ) ; System . exit ( 1 ) ; } static void init ( String host , String portStr ) { Category root = Category . getRoot ( ) ; BasicConfigurator . configure ( ) ; try { int port = Integer . parseInt ( portStr ) ; cat . info ( "Creating socket appender (" + host + "," + port + ")." ) ; s = new SocketAppender ( host , port ) ; s . setName ( "S" ) ; root . addAppender ( s ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } catch ( Exception e ) { System . err . println ( "Could not start!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } static void loop ( ) { Category root = Category . getRoot ( ) ; InputStreamReader in = new InputStreamReader ( System . in ) ; System . out . println ( "Type 'q' to quit" ) ; int i ; int k = 0 ; while ( true ) { cat . debug ( "Message " + k ++ ) ; cat . info ( "Message " + k ++ ) ; cat . warn ( "Message " + k ++ ) ; cat . error ( "Message " + k ++ , new Exception ( "Just testing" ) ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } if ( i == - 1 ) break ; if ( i == 'q' ) break ; if ( i == 'r' ) { System . out . println ( "Removing appender S" ) ; root . removeAppender ( "S" ) ; } } } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['8', '1', '0', '7', '42', '14', '0', '7', '2', '0.75', '308', '0', '2', '0', '0.238095238', '0', '0', '37', '4', '1.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; public class DefaultInit { static Category cat = Category . getInstance ( DefaultInit . class . getName ( ) ) ; public static void main ( String [ ] argv ) { cat . debug ( "Hello world" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.DefaultInit " ) ; System . exit ( 1 ) ; } } 	0	['5', '1', '0', '1', '14', '8', '0', '1', '2', '0.875', '45', '0', '1', '0', '0.333333333', '0', '0', '7.6', '1', '0.6', '0']
package org . apache . log4j . spi ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Filter implements OptionHandler { public Filter next ; public static final int DENY = - 1 ; public static final int NEUTRAL = 0 ; public static final int ACCEPT = 1 ; public void activateOptions ( ) { } abstract public int decide ( LoggingEvent event ) ; } 	0	['5', '1', '0', '4', '6', '10', '2', '2', '5', '1.25', '13', '0', '1', '0', '0.466666667', '0', '0', '0.8', '1', '0.8', '0']
package org . apache . log4j . helpers ; public class FormattingInfo { int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; void reset ( ) { min = - 1 ; max = 0x7FFFFFFF ; leftAlign = false ; } void dump ( ) { LogLog . debug ( "min=" + min + ", max=" + max + ", leftAlign=" + leftAlign ) ; } } 	0	['3', '1', '0', '9', '10', '0', '8', '1', '1', '0', '49', '0', '0', '0', '1', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . log4j . or ; class DefaultRenderer implements ObjectRenderer { DefaultRenderer ( ) { } public String doRender ( Object o ) { return o . toString ( ) ; } } 	0	['2', '1', '0', '2', '4', '1', '1', '1', '1', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressNDC extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int PUSH_MISS = LOOP_LENGTH / 2 ; static final int POP_MISS = PUSH_MISS * 2 ; static final int BRANCHING_FACTOR = 4 + 1 ; static int maxThreads ; static int msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { root . setPriority ( Priority . DEBUG ) ; BasicConfigurator . configure ( ) ; if ( args . length != 1 ) { usage ( ) ; } try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } root . debug ( "push(IP=127.0.0.1)" ) ; NDC . push ( "IP=127.0.0.1" ) ; while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.StressNDC " + "MAX_THREADS" ) ; System . exit ( 1 ) ; } Stack parentDC ; public StressNDC ( Stack parentDC ) { this . setName ( randomID ( ) ) ; this . parentDC = parentDC ; } public void run ( ) { NDC . inherit ( parentDC ) ; int loopLength = StressNDC . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop.debug( loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; if ( randomInt ( PUSH_MISS ) == 0 ) { String id = randomID ( ) ; root . debug ( "push(" + id + ")" ) ; NDC . push ( id ) ; } root . debug ( "Message number " + StressNDC . msgCounter ++ ) ; if ( randomInt ( POP_MISS ) == 0 ) { root . debug ( "pop()" ) ; NDC . pop ( ) ; } } synchronized ( lock ) { StressNDC . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressNDC . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } if ( ( loopLength % 2 ) == 0 ) { root . debug ( "Removing NDC for this thread." ) ; NDC . remove ( ) ; } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstained ( n ) ; root . debug ( "Creating " + n + " child StressNDC threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressNDC, threadCounter = " + ( ++ threadCounter ) ) ; new StressNDC ( NDC . cloneStack ( ) ) . start ( ) ; } } } static public int maxThreadsConstained ( int a ) { int maxAllowed = StressNDC . maxThreads - StressNDC . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public static String randomID ( ) { return Integer . toHexString ( random . nextInt ( ) & 0xFFFFFF ) ; } } 	0	['9', '2', '0', '4', '37', '8', '0', '4', '7', '0.822916667', '314', '0', '1', '0.897058824', '0.21875', '0', '0', '32.55555556', '7', '2', '0']
package org . apache . log4j ; class CategoryKey { String name ; int hashCache ; CategoryKey ( String name ) { this . name = name . intern ( ) ; hashCache = name . hashCode ( ) ; } final public int hashCode ( ) { return hashCache ; } final public boolean equals ( Object rArg ) { if ( this == rArg ) return true ; if ( rArg != null && CategoryKey . class == rArg . getClass ( ) ) return name == ( ( CategoryKey ) rArg ) . name ; else return false ; } } 	0	['4', '1', '0', '1', '11', '2', '1', '0', '2', '0.777777778', '61', '0', '0', '0', '0.5', '1', '1', '13.5', '6', '2', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class NullAppender extends AppenderSkeleton { public static String s ; public String t ; public NullAppender ( ) { } public NullAppender ( Layout layout ) { this . layout = layout ; } public void close ( ) { } public void doAppend ( LoggingEvent event ) { if ( layout != null ) { t = layout . format ( event ) ; s = t ; } } public void append ( LoggingEvent event ) { } public boolean requiresLayout ( ) { return true ; } } 	0	['6', '2', '0', '3', '8', '15', '0', '3', '6', '1', '34', '0', '0', '0.818181818', '0.5', '1', '1', '4.333333333', '2', '0.8333', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; public class ROFile { static Category cat = Category . getInstance ( ROFile . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ROFile . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; cat . debug ( "Message " + ++ i ) ; } } 	0	['7', '1', '0', '2', '21', '17', '0', '2', '2', '0.666666667', '90', '0', '1', '0', '0.277777778', '0', '0', '11.57142857', '2', '1', '0']
package org . apache . log4j ; import java . util . Vector ; class ProvisionNode extends Vector { ProvisionNode ( Category cat ) { super ( ) ; this . addElement ( cat ) ; } } 	0	['1', '4', '0', '2', '3', '0', '1', '1', '0', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; public class ConfigurationFileParsing { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { NDC . push ( "testing" ) ; PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; root . debug ( "Message 1" ) ; root . debug ( "Message 2" ) ; NDC . pop ( ) ; Category . shutdown ( ) ; } else { Usage ( "Wrong number of arguments." ) ; } } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ConfigurationFileParsing . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '3', '20', '6', '0', '3', '2', '0.666666667', '69', '0', '0', '0', '0.333333333', '0', '0', '16', '2', '1.25', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; public interface ErrorHandler extends OptionHandler { void error ( String message , Exception e , int errorCode ) ; void error ( String message ) ; } 	0	['2', '1', '0', '14', '2', '1', '13', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . spi ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Layout ; public class LocationInfo implements java . io . Serializable { transient String lineNumber ; transient String fileName ; transient String className ; transient String methodName ; public String fullInfo ; private static StringWriter sw = new StringWriter ( ) ; private static PrintWriter pw = new PrintWriter ( sw ) ; public final static String NA = "?" ; static final long serialVersionUID = - 1325822038990805636L ; static boolean inVisualAge = false ; static { try { Class dummy = Class . forName ( "com.ibm.uvm.tools.DebugSupport" ) ; inVisualAge = true ; LogLog . debug ( "Detected IBM VisualAge environment." ) ; } catch ( Throwable e ) { } } public LocationInfo ( Throwable t , String fqnOfCallingClass ) { if ( t == null ) return ; String s ; synchronized ( sw ) { t . printStackTrace ( pw ) ; s = sw . toString ( ) ; sw . getBuffer ( ) . setLength ( 0 ) ; } int ibegin , iend ; ibegin = s . lastIndexOf ( fqnOfCallingClass ) ; if ( ibegin == - 1 ) return ; ibegin = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( ibegin == - 1 ) return ; ibegin += Layout . LINE_SEP_LEN ; iend = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( iend == - 1 ) return ; if ( ! inVisualAge ) { ibegin = s . lastIndexOf ( "at " , iend ) ; if ( ibegin == - 1 ) return ; ibegin += 3 ; } this . fullInfo = s . substring ( ibegin , iend ) ; } public String getClassName ( ) { if ( fullInfo == null ) return NA ; if ( className == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; if ( iend == - 1 ) className = NA ; else { iend = fullInfo . lastIndexOf ( '.' , iend ) ; int ibegin = 0 ; if ( inVisualAge ) { ibegin = fullInfo . lastIndexOf ( ' ' , iend ) + 1 ; } if ( iend == - 1 ) className = NA ; else className = this . fullInfo . substring ( ibegin , iend ) ; } } return className ; } public String getFileName ( ) { if ( fullInfo == null ) return NA ; if ( fileName == null ) { int iend = fullInfo . lastIndexOf ( ':' ) ; if ( iend == - 1 ) fileName = NA ; else { int ibegin = fullInfo . lastIndexOf ( '(' , iend - 1 ) ; fileName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } } return fileName ; } public String getLineNumber ( ) { if ( fullInfo == null ) return NA ; if ( lineNumber == null ) { int iend = fullInfo . lastIndexOf ( ')' ) ; int ibegin = fullInfo . lastIndexOf ( ':' , iend - 1 ) ; if ( ibegin == - 1 ) lineNumber = NA ; else lineNumber = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return lineNumber ; } public String getMethodName ( ) { if ( fullInfo == null ) return NA ; if ( methodName == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; int ibegin = fullInfo . lastIndexOf ( '.' , iend ) ; if ( ibegin == - 1 ) methodName = NA ; else methodName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return methodName ; } } 	0	['6', '1', '0', '9', '21', '0', '7', '2', '5', '0.88', '286', '0.2', '0', '0', '0.466666667', '0', '0', '45', '6', '3', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class BoundedFIFO { LoggingEvent [ ] buf ; int numElements = 0 ; int first = 0 ; int next = 0 ; int maxSize ; public BoundedFIFO ( int maxSize ) { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; buf = new LoggingEvent [ maxSize ] ; } public LoggingEvent get ( ) { if ( numElements == 0 ) return null ; LoggingEvent r = buf [ first ] ; if ( ++ first == maxSize ) { first = 0 ; } numElements -- ; return r ; } public void put ( LoggingEvent o ) { if ( numElements != maxSize ) { buf [ next ] = o ; if ( ++ next == maxSize ) { next = 0 ; } numElements ++ ; } } public int getMaxSize ( ) { return maxSize ; } public boolean isFull ( ) { return numElements == maxSize ; } public int length ( ) { return numElements ; } int min ( int a , int b ) { return a < b ? a : b ; } synchronized public void resize ( int newSize ) { if ( newSize == maxSize ) return ; LoggingEvent [ ] tmp = new LoggingEvent [ newSize ] ; int len1 = maxSize - first ; len1 = min ( len1 , newSize ) ; len1 = min ( len1 , numElements ) ; System . arraycopy ( buf , first , tmp , 0 , len1 ) ; int len2 = 0 ; if ( ( len1 < numElements ) && ( len1 < newSize ) ) { len2 = numElements - len1 ; len2 = min ( len2 , newSize - len1 ) ; System . arraycopy ( buf , 0 , tmp , len1 , len2 ) ; } this . buf = tmp ; this . maxSize = newSize ; this . first = 0 ; this . numElements = len1 + len2 ; this . next = this . numElements ; if ( this . next == this . maxSize ) this . next = 0 ; } public boolean wasEmpty ( ) { return numElements == 1 ; } public boolean wasFull ( ) { return ( numElements + 1 == maxSize ) ; } } 	0	['10', '1', '0', '3', '17', '0', '2', '1', '9', '0.555555556', '243', '0', '1', '0', '0.466666667', '0', '0', '22.8', '5', '2.1', '0']
package org . apache . log4j . config ; import java . io . * ; import java . util . * ; import org . apache . log4j . * ; public class PropertyPrinter implements PropertyGetter . PropertyCallback { protected int numAppenders = 0 ; protected Hashtable appenderNames = new Hashtable ( ) ; protected Hashtable layoutNames = new Hashtable ( ) ; protected PrintWriter out ; protected boolean doCapitalize ; public PropertyPrinter ( PrintWriter out ) { this ( out , false ) ; } public PropertyPrinter ( PrintWriter out , boolean doCapitalize ) { this . out = out ; this . doCapitalize = doCapitalize ; print ( out ) ; out . flush ( ) ; } protected String genAppName ( ) { return "A" + numAppenders ++ ; } protected boolean isGenAppName ( String name ) { if ( name . length ( ) < 2 || name . charAt ( 0 ) != 'A' ) return false ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { if ( name . charAt ( i ) < '0' || name . charAt ( i ) > '9' ) return false ; } return true ; } public void print ( PrintWriter out ) { printOptions ( out , Category . getRoot ( ) ) ; Enumeration cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { printOptions ( out , ( Category ) cats . nextElement ( ) ) ; } } protected void printOptions ( PrintWriter out , Category cat ) { Enumeration appenders = cat . getAllAppenders ( ) ; Priority prio = cat . getPriority ( ) ; String appenderString = ( prio == null ? "" : prio . toString ( ) ) ; while ( appenders . hasMoreElements ( ) ) { Appender app = ( Appender ) appenders . nextElement ( ) ; String name ; if ( ( name = ( String ) appenderNames . get ( app ) ) == null ) { if ( ( name = app . getName ( ) ) == null || isGenAppName ( name ) ) { name = genAppName ( ) ; } appenderNames . put ( app , name ) ; printOptions ( out , app , "log4j.appender." + name ) ; if ( app . getLayout ( ) != null ) { printOptions ( out , app . getLayout ( ) , "log4j.appender." + name + ".layout" ) ; } } appenderString += ", " + name ; } String catKey = ( cat == Category . getRoot ( ) ) ? "log4j.rootCategory" : "log4j.category." + cat . getName ( ) ; if ( appenderString != "" ) { out . println ( catKey + "=" + appenderString ) ; } } protected void printOptions ( PrintWriter out , Object obj , String fullname ) { out . println ( fullname + "=" + obj . getClass ( ) . getName ( ) ) ; PropertyGetter . getProperties ( obj , this , fullname + "." ) ; } public void foundProperty ( Object obj , String prefix , String name , Object value ) { if ( obj instanceof Appender && "name" . equals ( name ) ) { return ; } if ( doCapitalize ) { name = capitalize ( name ) ; } out . println ( prefix + name + "=" + value . toString ( ) ) ; } public static String capitalize ( String name ) { if ( Character . isLowerCase ( name . charAt ( 0 ) ) ) { if ( name . length ( ) == 1 || Character . isLowerCase ( name . charAt ( 1 ) ) ) { StringBuffer newname = new StringBuffer ( name ) ; newname . setCharAt ( 0 , Character . toUpperCase ( name . charAt ( 0 ) ) ) ; return newname . toString ( ) ; } } return name ; } public static void main ( String [ ] args ) { new PropertyPrinter ( new PrintWriter ( System . out ) ) ; } } 	0	['10', '1', '0', '7', '42', '39', '1', '6', '6', '0.644444444', '328', '1', '0', '0', '0.314285714', '0', '0', '31.3', '9', '2.8', '0']
package org . apache . log4j . test ; public class SpacePad { static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; static public void main ( String [ ] args ) { StringBuffer sbuf = new StringBuffer ( ) ; for ( int i = 0 ; i < 35 ; i ++ ) { sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , i ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , 67 ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } static public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['4', '1', '0', '0', '10', '4', '0', '0', '3', '0.333333333', '114', '0', '0', '0', '0.333333333', '0', '0', '27.25', '4', '1.5', '0']
package org . apache . log4j . or ; import java . util . Hashtable ; public class RendererMap { Hashtable map ; static ObjectRenderer defaultRenderer = new DefaultRenderer ( ) ; public RendererMap ( ) { map = new Hashtable ( ) ; } public String findAndRender ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) . doRender ( o ) ; } public ObjectRenderer get ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) ; } public ObjectRenderer get ( Class clazz ) { ObjectRenderer r = null ; for ( Class c = clazz ; c != null ; c = c . getSuperclass ( ) ) { r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } r = searchInterfaces ( c ) ; if ( r != null ) return r ; } return defaultRenderer ; } ObjectRenderer searchInterfaces ( Class c ) { ObjectRenderer r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } else { Class [ ] ia = c . getInterfaces ( ) ; for ( int i = 0 ; i < ia . length ; i ++ ) { r = searchInterfaces ( ia [ i ] ) ; if ( r != null ) return r ; } } return null ; } public ObjectRenderer getDefaultRenderer ( ) { return defaultRenderer ; } public void clear ( ) { map . clear ( ) ; } public void put ( Class clazz , ObjectRenderer or ) { map . put ( clazz , or ) ; } } 	0	['9', '1', '0', '5', '19', '10', '3', '2', '7', '0.375', '120', '0', '1', '0', '0.4375', '0', '0', '12.11111111', '4', '1.6667', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class CyclicBuffer { LoggingEvent [ ] ea ; int first ; int last ; int numElems ; int maxSize ; public CyclicBuffer ( int maxSize ) throws IllegalArgumentException { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; ea = new LoggingEvent [ maxSize ] ; first = 0 ; last = 0 ; numElems = 0 ; } public void add ( LoggingEvent event ) { ea [ last ] = event ; if ( ++ last == maxSize ) last = 0 ; if ( numElems < maxSize ) numElems ++ ; else if ( ++ first == maxSize ) first = 0 ; } public LoggingEvent get ( int i ) { if ( i < 0 || i >= numElems ) return null ; return ea [ ( first + i ) % maxSize ] ; } public int getMaxSize ( ) { return maxSize ; } public LoggingEvent get ( ) { LoggingEvent r = null ; if ( numElems > 0 ) { numElems -- ; r = ea [ first ] ; ea [ first ] = null ; if ( ++ first == maxSize ) first = 0 ; } return r ; } public int length ( ) { return numElems ; } public void resize ( int newSize ) { if ( newSize < 0 ) { throw new IllegalArgumentException ( "Negative array size [" + newSize + "] not allowed." ) ; } if ( newSize == numElems ) return ; LoggingEvent [ ] temp = new LoggingEvent [ newSize ] ; int loopLen = newSize < numElems ? newSize : numElems ; for ( int i = 0 ; i < loopLen ; i ++ ) { temp [ i ] = ea [ first ] ; ea [ first ] = null ; if ( ++ first == numElems ) first = 0 ; } ea = temp ; first = 0 ; numElems = loopLen ; maxSize = newSize ; if ( loopLen == newSize ) { last = 0 ; } else { last = loopLen ; } } } 	0	['7', '1', '0', '2', '13', '0', '1', '1', '7', '0.333333333', '246', '0', '1', '0', '0.523809524', '0', '0', '33.42857143', '7', '2.7143', '0']
package org . apache . log4j ; import org . apache . log4j . spi . CategoryFactory ; class DefaultCategoryFactory implements CategoryFactory { DefaultCategoryFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new Category ( name ) ; } } 	0	['2', '1', '0', '4', '4', '1', '2', '2', '1', '2', '10', '0', '0', '0', '0.75', '0', '0', '4', '1', '0.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressAsyncAppender extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int BRANCHING_FACTOR = 4 ; static int maxThreads ; static long msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { if ( args . length != 1 ) { usage ( ) ; } DOMConfigurator . configure ( "xml/stressAsyncAppender.xml" ) ; try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java " + StressAsyncAppender . class . getName ( ) + " MAX_THREADS" ) ; System . exit ( 1 ) ; } public StressAsyncAppender ( ) { } public void run ( ) { int loopLength = StressAsyncAppender . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop, loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; synchronized ( lock ) { root . debug ( "Message number " + msgCounter ++ ) ; } } synchronized ( lock ) { StressAsyncAppender . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressAsyncAppender . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstrained ( n ) ; root . debug ( "Creating " + n + " child StressAsyncAppender threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressAsyncAppender, threadCounter = " + ( ++ threadCounter ) ) ; new StressAsyncAppender ( ) . start ( ) ; } } } static public int maxThreadsConstrained ( int a ) { int maxAllowed = StressAsyncAppender . maxThreads - StressAsyncAppender . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public void delay ( long millis ) { try { Thread . currentThread ( ) . sleep ( millis ) ; } catch ( Exception e ) { } } } 	0	['10', '2', '0', '2', '37', '23', '0', '2', '7', '0.833333333', '301', '0', '1', '0.884057971', '0.2', '0', '0', '28.1', '4', '1.7', '0']
package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class DateTimeDateFormat extends AbsoluteTimeDateFormat { String [ ] shortMonths ; public DateTimeDateFormat ( ) { super ( ) ; shortMonths = new DateFormatSymbols ( ) . getShortMonths ( ) ; } public DateTimeDateFormat ( TimeZone timeZone ) { this ( ) ; setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; sbuf . append ( shortMonths [ calendar . get ( Calendar . MONTH ) ] ) ; sbuf . append ( ' ' ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '15', '4', '2', '1', '4', '0.333333333', '80', '0', '0', '0.953488372', '0.357142857', '1', '3', '18.75', '2', '0.75', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import org . apache . log4j . net . SocketAppender ; public class Loop { public static void main ( String [ ] args ) { Category root = Category . getRoot ( ) ; Category cat = Category . getInstance ( Loop . class . getName ( ) ) ; if ( args . length != 2 ) usage ( "Wrong number of arguments." ) ; String host = args [ 0 ] ; int port = 0 ; try { port = Integer . valueOf ( args [ 1 ] ) . intValue ( ) ; } catch ( NumberFormatException e ) { usage ( "Argument [" + args [ 1 ] + "] is not in proper int form." ) ; } SocketAppender sa = new SocketAppender ( host , port ) ; Layout layout = new PatternLayout ( "%5p [%t] %x %c - %m\n" ) ; Appender so = new ConsoleAppender ( layout , "System.out" ) ; root . addAppender ( sa ) ; root . addAppender ( so ) ; int i = 0 ; while ( true ) { NDC . push ( "" + ( i ++ ) ) ; cat . debug ( "Debug message." ) ; root . info ( "Info message." ) ; NDC . pop ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Loop . class . getName ( ) + " host port" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '7', '27', '4', '0', '7', '2', '0.666666667', '134', '0', '0', '0', '0.333333333', '0', '0', '32.25', '3', '1.5', '0']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; public class ThreadGroupRenderer implements ObjectRenderer { public ThreadGroupRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof ThreadGroup ) { StringBuffer sbuf = new StringBuffer ( ) ; ThreadGroup tg = ( ThreadGroup ) o ; sbuf . append ( "java.lang.ThreadGroup[name=" ) ; sbuf . append ( tg . getName ( ) ) ; sbuf . append ( ", maxpri=" ) ; sbuf . append ( tg . getMaxPriority ( ) ) ; sbuf . append ( "]" ) ; Thread [ ] t = new Thread [ tg . activeCount ( ) ] ; tg . enumerate ( t ) ; for ( int i = 0 ; i < t . length ; i ++ ) { sbuf . append ( Layout . LINE_SEP ) ; sbuf . append ( "   Thread=[" ) ; sbuf . append ( t [ i ] . getName ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . getPriority ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . isDaemon ( ) ) ; sbuf . append ( "]" ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '2', '16', '1', '0', '2', '2', '2', '100', '0', '0', '0', '0.75', '0', '0', '49', '3', '1.5', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class SyslogMin { static Category CAT = Category . getInstance ( SyslogMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SyslogMin . class + " configFile" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String configFile ) { int port = 0 ; PropertyConfigurator . configure ( configFile ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; CAT . debug ( "Message " + i ++ ) ; CAT . info ( "Message " + i ++ ) ; CAT . warn ( "Message " + i ++ ) ; CAT . error ( "Message " + i ++ ) ; CAT . log ( Priority . FATAL , "Message " + i ++ ) ; CAT . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '4', '29', '17', '0', '4', '2', '0.666666667', '154', '0', '1', '0', '0.333333333', '0', '0', '20.71428571', '2', '1', '0']
package org . apache . log4j . spi ; public interface ErrorCode { public final int GENERIC_FAILURE = 0 ; public final int WRITE_FAILURE = 1 ; public final int FLUSH_FAILURE = 2 ; public final int CLOSE_FAILURE = 3 ; public final int FILE_OPEN_FAILURE = 4 ; public final int MISSING_LAYOUT = 5 ; public final int ADDRESS_PARSE_FAILURE = 6 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . log4j . helpers ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class RelativeTimeDateFormat extends DateFormat { protected final long startTime ; public RelativeTimeDateFormat ( ) { this . startTime = System . currentTimeMillis ( ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { return sbuf . append ( ( date . getTime ( ) - startTime ) ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['3', '3', '0', '1', '7', '1', '1', '0', '3', '0.5', '20', '1', '0', '0.951219512', '0.444444444', '1', '3', '5.333333333', '1', '0.6667', '0']
package org . apache . log4j ; import java . beans . * ; import org . apache . log4j . helpers . LogLog ; import java . lang . reflect . Method ; public class RollingFileAppenderBeanInfo extends SimpleBeanInfo { private PropertyDescriptor [ ] props ; public RollingFileAppenderBeanInfo ( ) { Class clazz = RollingFileAppender . class ; try { BeanInfo bi = Introspector . getBeanInfo ( clazz , Introspector . IGNORE_ALL_BEANINFO ) ; props = bi . getPropertyDescriptors ( ) ; if ( props != null ) { for ( int i = 0 ; i < props . length ; i ++ ) { if ( props [ i ] . getName ( ) . equals ( "maxFileSize" ) ) { Method m = clazz . getMethod ( "setMaxFileSize" , new Class [ ] { String . class } ) ; props [ i ] = new PropertyDescriptor ( "maxFileSize" , null , m ) ; } } } Introspector . flushFromCaches ( RollingFileAppender . class ) ; } catch ( IntrospectionException e ) { LogLog . error ( "Could not inspect RollingFileAppender." , e ) ; } catch ( NoSuchMethodException e ) { LogLog . error ( "Could not find setter method for RollingFileAppender." , e ) ; } } public PropertyDescriptor [ ] getPropertyDescriptors ( ) { return props ; } } 	0	['3', '2', '0', '1', '15', '1', '0', '1', '2', '0.833333333', '105', '0.333333333', '0', '0.818181818', '0.5', '0', '0', '33', '1', '0.6667', '0']
package org . apache . log4j . helpers ; import java . util . Date ; import java . util . Calendar ; import java . util . TimeZone ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class AbsoluteTimeDateFormat extends DateFormat { public final static String ABS_TIME_DATE_FORMAT = "ABSOLUTE" ; public final static String DATE_AND_TIME_DATE_FORMAT = "DATE" ; public final static String ISO8601_DATE_FORMAT = "ISO8601" ; public AbsoluteTimeDateFormat ( ) { setCalendar ( Calendar . getInstance ( ) ) ; } public AbsoluteTimeDateFormat ( TimeZone timeZone ) { setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; if ( hour < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( hour ) ; sbuf . append ( ':' ) ; int mins = calendar . get ( Calendar . MINUTE ) ; if ( mins < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( mins ) ; sbuf . append ( ':' ) ; int secs = calendar . get ( Calendar . SECOND ) ; if ( secs < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( secs ) ; sbuf . append ( ',' ) ; int millis = calendar . get ( Calendar . MILLISECOND ) ; if ( millis < 100 ) sbuf . append ( '0' ) ; if ( millis < 10 ) sbuf . append ( '0' ) ; sbuf . append ( millis ) ; return sbuf ; } public Date parse ( String s , ParsePosition pos ) { return null ; } } 	0	['4', '3', '2', '4', '12', '6', '4', '0', '4', '1.333333333', '111', '0', '0', '0.951219512', '0.357142857', '1', '3', '26', '6', '1.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . xml . DOMConfigurator ; public class DelayedLoop { static Category cat = Category . getInstance ( DelayedLoop . class ) ; static int loopLength ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + DelayedLoop . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { if ( configFile . endsWith ( "xml" ) ) { DOMConfigurator . configureAndWatch ( configFile , 3000 ) ; } else { PropertyConfigurator . configureAndWatch ( configFile , 3000 ) ; } } static void test ( ) { int i = 0 ; while ( true ) { cat . debug ( "MSG " + i ++ ) ; try { Thread . currentThread ( ) . sleep ( 1000 ) ; } catch ( Exception e ) { } } } } 	0	['7', '1', '0', '3', '25', '17', '0', '3', '2', '0.833333333', '105', '0', '1', '0', '0.277777778', '0', '0', '13.57142857', '2', '1.1429', '0']
package org . apache . log4j . or ; public interface ObjectRenderer { public String doRender ( Object o ) ; } 	0	['1', '1', '0', '7', '1', '0', '7', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . performance ; import java . util . Vector ; public class ListVsVector { static int RUN_LENGTH = 1000000 ; static Vector v = new Vector ( ) ; static Chain head ; static String tmp ; static public void main ( String [ ] args ) { v . addElement ( "aaa" ) ; v . addElement ( "bbb" ) ; v . addElement ( "ccc" ) ; v . addElement ( "ddd" ) ; v . addElement ( "eee" ) ; Chain c = new Chain ( "aaa" ) ; head = c ; c . next = new Chain ( "bbb" ) ; c = c . next ; c . next = new Chain ( "ccc" ) ; c = c . next ; c . next = new Chain ( "ddd" ) ; c = c . next ; c . next = new Chain ( "eee" ) ; double t ; t = loopChain ( ) ; System . out . println ( "Looping thourgh the chain took " + t ) ; t = loopVector ( ) ; System . out . println ( "Looping thourgh the vector took " + t ) ; } static double loopChain ( ) { long before = System . currentTimeMillis ( ) ; Chain c ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { c = head ; while ( c != null ) { tmp = c . s ; c = c . next ; } } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double loopVector ( ) { long before = System . currentTimeMillis ( ) ; int size = v . size ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) tmp = ( String ) v . elementAt ( j ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static class Chain { public String s ; public Chain next ; Chain ( String s ) { this . s = s ; } void setNext ( Chain c ) { next = c ; } } } 	0	['5', '1', '0', '1', '17', '0', '0', '1', '2', '0.5', '163', '0', '1', '0', '0.25', '0', '0', '30.8', '3', '1.4', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Enumeration ; public class Finalize { static Category CAT = Category . getInstance ( Finalize . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Finalize . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; InputStreamReader in = new InputStreamReader ( System . in ) ; Category root = Category . getRoot ( ) ; System . out . println ( "Type 'q' to quit" ) ; int j = 0 ; while ( true ) { System . gc ( ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } System . gc ( ) ; System . out . println ( "Read [" + i + "]." ) ; if ( i == - 1 ) break ; else if ( i == 'q' ) break ; else root . debug ( "Hello " + ( ++ j ) ) ; } root . removeAllAppenders ( ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; } static void foo ( Category cat ) { Enumeration enum = cat . getAllAppenders ( ) ; while ( enum != null && enum . hasMoreElements ( ) ) { ( ( org . apache . log4j . Appender ) enum . nextElement ( ) ) . close ( ) ; } } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	0	['9', '1', '0', '3', '34', '34', '0', '3', '2', '0.875', '167', '0', '1', '0', '0.175', '0', '0', '17.33333333', '3', '1.4444', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Appender ; import java . util . Enumeration ; import java . util . Vector ; public class MultipleAppenders { public static void main ( String argv [ ] ) { PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; Enumeration e1 = root . getAllAppenders ( ) ; Vector v = new Vector ( 1 ) ; while ( e1 . hasMoreElements ( ) ) { Appender a = ( Appender ) e1 . nextElement ( ) ; v . addElement ( a ) ; String appenderName = a . getName ( ) ; if ( a != root . getAppender ( appenderName ) ) { System . out . println ( appenderName + " lookup failed. Exiting." ) ; System . exit ( 1 ) ; } root . addAppender ( a ) ; } root . addAppender ( null ) ; Enumeration e2 = root . getAllAppenders ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . elementAt ( i ) != e2 . nextElement ( ) ) { } } if ( e2 . hasMoreElements ( ) ) { System . out . println ( "Failure, e2 has remaining elements. Exiting." ) ; System . exit ( 1 ) ; } System . out . println ( "OK" ) ; } } 	0	['2', '1', '0', '3', '20', '1', '0', '3', '2', '2', '85', '0', '0', '0', '0.5', '0', '0', '41.5', '6', '3', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; public interface CategoryFactory { public Category makeNewCategoryInstance ( String name ) ; } 	0	['1', '1', '0', '6', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . Layout ; import org . apache . log4j . NDC ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . LocationInfo ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; public class PatternParser { private static final char ESCAPE_CHAR = '%' ; private static final int LITERAL_STATE = 0 ; private static final int CONVERTER_STATE = 1 ; private static final int MINUS_STATE = 2 ; private static final int DOT_STATE = 3 ; private static final int MIN_STATE = 4 ; private static final int MAX_STATE = 5 ; static final int FULL_LOCATION_CONVERTER = 1000 ; static final int METHOD_LOCATION_CONVERTER = 1001 ; static final int CLASS_LOCATION_CONVERTER = 1002 ; static final int LINE_LOCATION_CONVERTER = 1003 ; static final int FILE_LOCATION_CONVERTER = 1004 ; static final int RELATIVE_TIME_CONVERTER = 2000 ; static final int THREAD_CONVERTER = 2001 ; static final int PRIORITY_CONVERTER = 2002 ; static final int NDC_CONVERTER = 2003 ; static final int MESSAGE_CONVERTER = 2004 ; int state ; protected StringBuffer currentLiteral = new StringBuffer ( 32 ) ; protected int patternLength ; protected int i ; PatternConverter head ; PatternConverter tail ; protected FormattingInfo formattingInfo = new FormattingInfo ( ) ; protected String pattern ; public PatternParser ( String pattern ) { this . pattern = pattern ; patternLength = pattern . length ( ) ; state = LITERAL_STATE ; } private void addToList ( PatternConverter pc ) { if ( head == null ) { head = tail = pc ; } else { tail . next = pc ; tail = pc ; } } private String extractOption ( ) { if ( ( i < patternLength ) && ( pattern . charAt ( i ) == '{' ) ) { int end = pattern . indexOf ( '}' , i ) ; if ( end > i ) { String r = pattern . substring ( i + 1 , end ) ; i = end + 1 ; return r ; } } return null ; } private int extractPrecisionOption ( ) { String opt = extractOption ( ) ; int r = 0 ; if ( opt != null ) { try { r = Integer . parseInt ( opt ) ; if ( r <= 0 ) { LogLog . error ( "Precision option (" + opt + ") isn't a positive integer." ) ; r = 0 ; } } catch ( NumberFormatException e ) { LogLog . error ( "Category option \"" + opt + "\" not a decimal integer." , e ) ; } } return r ; } public PatternConverter parse ( ) { char c ; i = 0 ; while ( i < patternLength ) { c = pattern . charAt ( i ++ ) ; switch ( state ) { case LITERAL_STATE : if ( i == patternLength ) { currentLiteral . append ( c ) ; continue ; } if ( c == ESCAPE_CHAR ) { switch ( pattern . charAt ( i ) ) { case ESCAPE_CHAR : currentLiteral . append ( c ) ; i ++ ; break ; case 'n' : currentLiteral . append ( Layout . LINE_SEP ) ; i ++ ; break ; default : if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } currentLiteral . setLength ( 0 ) ; currentLiteral . append ( c ) ; state = CONVERTER_STATE ; formattingInfo . reset ( ) ; } } else { currentLiteral . append ( c ) ; } break ; case CONVERTER_STATE : currentLiteral . append ( c ) ; switch ( c ) { case '-' : formattingInfo . leftAlign = true ; break ; case '.' : state = DOT_STATE ; break ; default : if ( c >= '0' && c <= '9' ) { formattingInfo . min = c - '0' ; state = MIN_STATE ; } else finalizeConverter ( c ) ; } break ; case MIN_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . min = formattingInfo . min * 10 + ( c - '0' ) ; else if ( c == '.' ) state = DOT_STATE ; else { finalizeConverter ( c ) ; } break ; case DOT_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) { formattingInfo . max = c - '0' ; state = MAX_STATE ; } else { LogLog . error ( "Error occured in position " + i + ".\n Was expecting digit, instead got char \"" + c + "\"." ) ; state = LITERAL_STATE ; } break ; case MAX_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . max = formattingInfo . max * 10 + ( c - '0' ) ; else { finalizeConverter ( c ) ; state = LITERAL_STATE ; } break ; } } if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } return head ; } protected void finalizeConverter ( char c ) { PatternConverter pc = null ; switch ( c ) { case 'c' : pc = new CategoryPatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'C' : pc = new ClassNamePatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'd' : String dateFormatStr = AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ; DateFormat df ; String dOpt = extractOption ( ) ; if ( dOpt != null ) dateFormatStr = dOpt ; if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) df = new ISO8601DateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) df = new AbsoluteTimeDateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) df = new DateTimeDateFormat ( ) ; else { try { df = new SimpleDateFormat ( dateFormatStr ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Could not instantiate SimpleDateFormat with " + dateFormatStr , e ) ; df = ( DateFormat ) OptionConverter . instantiateByClassName ( "org.apache.log4j.helpers.ISO8601DateFormat" , DateFormat . class , null ) ; } } pc = new DatePatternConverter ( formattingInfo , df ) ; currentLiteral . setLength ( 0 ) ; break ; case 'F' : pc = new LocationPatternConverter ( formattingInfo , FILE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'l' : pc = new LocationPatternConverter ( formattingInfo , FULL_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'L' : pc = new LocationPatternConverter ( formattingInfo , LINE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'm' : pc = new BasicPatternConverter ( formattingInfo , MESSAGE_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'M' : pc = new LocationPatternConverter ( formattingInfo , METHOD_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'p' : pc = new BasicPatternConverter ( formattingInfo , PRIORITY_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'r' : pc = new BasicPatternConverter ( formattingInfo , RELATIVE_TIME_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 't' : pc = new BasicPatternConverter ( formattingInfo , THREAD_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'x' : pc = new BasicPatternConverter ( formattingInfo , NDC_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; default : LogLog . error ( "Unexpected char [" + c + "] at position " + i + " in conversion patterrn." ) ; pc = new LiteralPatternConverter ( currentLiteral . toString ( ) ) ; currentLiteral . setLength ( 0 ) ; } addConverter ( pc ) ; } protected void addConverter ( PatternConverter pc ) { currentLiteral . setLength ( 0 ) ; addToList ( pc ) ; state = LITERAL_STATE ; formattingInfo . reset ( ) ; } private static class BasicPatternConverter extends PatternConverter { int type ; BasicPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { switch ( type ) { case RELATIVE_TIME_CONVERTER : return ( Long . toString ( event . timeStamp - LoggingEvent . getStartTime ( ) ) ) ; case THREAD_CONVERTER : return event . getThreadName ( ) ; case PRIORITY_CONVERTER : return event . priority . toString ( ) ; case NDC_CONVERTER : return event . getNDC ( ) ; case MESSAGE_CONVERTER : { return event . getRenderedMessage ( ) ; } default : return null ; } } } private static class LiteralPatternConverter extends PatternConverter { private String literal ; LiteralPatternConverter ( String value ) { literal = value ; } public final void format ( StringBuffer sbuf , LoggingEvent event ) { sbuf . append ( literal ) ; } public String convert ( LoggingEvent event ) { return literal ; } } private static class DatePatternConverter extends PatternConverter { private DateFormat df ; private Date date ; DatePatternConverter ( FormattingInfo formattingInfo , DateFormat df ) { super ( formattingInfo ) ; date = new Date ( ) ; this . df = df ; } public String convert ( LoggingEvent event ) { date . setTime ( event . timeStamp ) ; String converted = null ; try { converted = df . format ( date ) ; } catch ( Exception ex ) { LogLog . error ( "Error occured while converting date." , ex ) ; } return converted ; } } private class LocationPatternConverter extends PatternConverter { int type ; LocationPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { LocationInfo locationInfo = event . getLocationInformation ( ) ; switch ( type ) { case FULL_LOCATION_CONVERTER : return locationInfo . fullInfo ; case METHOD_LOCATION_CONVERTER : return locationInfo . getMethodName ( ) ; case LINE_LOCATION_CONVERTER : return locationInfo . getLineNumber ( ) ; case FILE_LOCATION_CONVERTER : return locationInfo . getFileName ( ) ; default : return null ; } } } private static abstract class NamedPatternConverter extends PatternConverter { int precision ; NamedPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo ) ; this . precision = precision ; } abstract String getFullyQualifiedName ( LoggingEvent event ) ; public String convert ( LoggingEvent event ) { String n = getFullyQualifiedName ( event ) ; if ( precision <= 0 ) return n ; else { int len = n . length ( ) ; int end = len - 1 ; for ( int i = precision ; i > 0 ; i -- ) { end = n . lastIndexOf ( '.' , end - 1 ) ; if ( end == - 1 ) return n ; } return n . substring ( end + 1 , len ) ; } } } private class ClassNamePatternConverter extends NamedPatternConverter { ClassNamePatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { return event . getLocationInformation ( ) . getClassName ( ) ; } } private class CategoryPatternConverter extends NamedPatternConverter { CategoryPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { return event . categoryName ; } } } 	0	['8', '1', '0', '15', '41', '8', '4', '14', '2', '0.956043956', '693', '0.461538462', '3', '0', '0.375', '0', '0', '82.375', '21', '6.25', '0']
package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class ISO8601DateFormat extends AbsoluteTimeDateFormat { public ISO8601DateFormat ( ) { } public ISO8601DateFormat ( TimeZone timeZone ) { super ( timeZone ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; String month ; switch ( calendar . get ( Calendar . MONTH ) ) { case Calendar . JANUARY : month = "-01-" ; break ; case Calendar . FEBRUARY : month = "-02-" ; break ; case Calendar . MARCH : month = "-03-" ; break ; case Calendar . APRIL : month = "-04-" ; break ; case Calendar . MAY : month = "-05-" ; break ; case Calendar . JUNE : month = "-06-" ; break ; case Calendar . JULY : month = "-07-" ; break ; case Calendar . AUGUST : month = "-08-" ; break ; case Calendar . SEPTEMBER : month = "-09-" ; break ; case Calendar . OCTOBER : month = "-10-" ; break ; case Calendar . NOVEMBER : month = "-11-" ; break ; case Calendar . DECEMBER : month = "-12-" ; break ; default : month = "-NA-" ; break ; } sbuf . append ( month ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '12', '6', '2', '1', '4', '2', '99', '0', '0', '0.953488372', '0.357142857', '1', '3', '23.75', '3', '1', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Appender ; import java . util . Vector ; import java . util . Enumeration ; public class AppenderAttachableImpl implements AppenderAttachable { protected Vector appenderList ; public void addAppender ( Appender newAppender ) { if ( newAppender == null ) return ; if ( appenderList == null ) { appenderList = new Vector ( 1 ) ; } if ( ! appenderList . contains ( newAppender ) ) appenderList . addElement ( newAppender ) ; } public int appendLoopOnAppenders ( LoggingEvent event ) { int size = 0 ; Appender appender ; if ( appenderList != null ) { size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; appender . doAppend ( event ) ; } } return size ; } public Enumeration getAllAppenders ( ) { if ( appenderList == null ) return null ; else return appenderList . elements ( ) ; } public Appender getAppender ( String name ) { if ( appenderList == null || name == null ) return null ; int size = appenderList . size ( ) ; Appender appender ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; if ( name . equals ( appender . getName ( ) ) ) return appender ; } return null ; } public void removeAllAppenders ( ) { if ( appenderList != null ) { int len = appenderList . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Appender a = ( Appender ) appenderList . elementAt ( i ) ; a . close ( ) ; } appenderList . removeAllElements ( ) ; appenderList = null ; } } public void removeAppender ( Appender appender ) { if ( appender == null || appenderList == null ) return ; appenderList . removeElement ( appender ) ; } public void removeAppender ( String name ) { if ( name == null || appenderList == null ) return ; int size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( name . equals ( ( ( Appender ) appenderList . elementAt ( i ) ) . getName ( ) ) ) { appenderList . removeElementAt ( i ) ; break ; } } } } 	0	['8', '1', '0', '6', '22', '0', '3', '3', '8', '0.142857143', '176', '1', '0', '0', '0.40625', '0', '0', '20.875', '5', '3.125', '0']
package org . apache . log4j ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Layout implements OptionHandler { public final static String LINE_SEP = System . getProperty ( "line.separator" ) ; public final static int LINE_SEP_LEN = LINE_SEP . length ( ) ; abstract public String format ( LoggingEvent event ) ; public String getContentType ( ) { return "text/plain" ; } public String getHeader ( ) { return null ; } public String getFooter ( ) { return null ; } abstract public boolean ignoresThrowable ( ) ; } 	0	['10', '1', '4', '26', '13', '45', '24', '2', '9', '1', '28', '0', '0', '0', '0.407407407', '0', '0', '1.6', '1', '0.8', '0']
package org . apache . log4j . test ; class Base64 { final static int MAX_LINE = 76 ; static byte [ ] asciiEncoding = { 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 43 , 47 } ; static char [ ] charEnc = new char [ 64 ] ; static { for ( int i = 0 ; i < 26 ; i ++ ) { charEnc [ i ] = ( char ) ( 'A' + i ) ; charEnc [ i + 26 ] = ( char ) ( 'a' + i ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { charEnc [ i + 52 ] = ( char ) ( '0' + i ) ; } charEnc [ 62 ] = '+' ; charEnc [ 63 ] = '/' ; } static String toString ( byte [ ] inbuf ) { return toString ( inbuf , 0 , inbuf . length ) ; } static String toString ( byte [ ] inbuf , int offset , int length ) { StringBuffer output = new StringBuffer ( ( length ) * 4 / 3 + 1 ) ; int in ; char [ ] out = new char [ 4 ] ; int i = offset ; boolean ended = false ; int last = offset + length ; int j ; int bitsRead ; while ( ! ended ) { in = 0 ; bitsRead = 0 ; for ( j = 0 ; j < 3 ; j ++ ) { if ( i == last ) { ended = true ; break ; } in = ( in << 8 ) | ( inbuf [ i ++ ] & 0xFF ) ; bitsRead += 8 ; } while ( bitsRead >= 6 ) { bitsRead -= 6 ; output . append ( charEnc [ ( in > > > bitsRead ) & 0x3F ] ) ; } if ( bitsRead == 4 ) { output . append ( charEnc [ ( in & 0x0F ) << 2 ] ) ; output . append ( "=" ) ; } else if ( bitsRead == 2 ) { output . append ( charEnc [ ( in & 0x03 ) << 4 ] ) ; output . append ( "==" ) ; } } return output . toString ( ) ; } public static void main ( String [ ] args ) { byte [ ] inbuf = new byte [ MAX_LINE ] ; while ( true ) { try { int read = System . in . read ( inbuf , 0 , MAX_LINE ) ; if ( read == - 1 ) break ; System . out . println ( "Read " + read + " chars." ) ; System . out . println ( Base64 . toString ( inbuf , 0 , read ) ) ; } catch ( Exception e ) { System . out . println ( "Exception " + e ) ; } } } } 	0	['5', '1', '0', '0', '15', '8', '0', '0', '1', '0.833333333', '479', '0', '0', '0', '0.3125', '0', '0', '94.2', '7', '2', '0']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; public class SimpleLayout extends Layout { StringBuffer sbuf = new StringBuffer ( 128 ) ; public SimpleLayout ( ) { } public String [ ] getOptionStrings ( ) { return new String [ 0 ] ; } public void setOption ( String option , String value ) { } public void activateOptions ( ) { } public String format ( LoggingEvent event ) { sbuf . setLength ( 0 ) ; sbuf . append ( event . priority . toString ( ) ) ; sbuf . append ( " - " ) ; sbuf . append ( event . getRenderedMessage ( ) ) ; sbuf . append ( LINE_SEP ) ; return sbuf . toString ( ) ; } public boolean ignoresThrowable ( ) { return true ; } } 	0	['6', '2', '0', '6', '13', '13', '3', '3', '6', '0.8', '54', '0', '0', '0.615384615', '0.444444444', '0', '0', '7.833333333', '1', '0.8333', '0']
package org . apache . log4j . performance ; import java . util . Date ; public class ConcatVsArray { static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.performance.ConcatVsArray " + "string1 string2 runLength\n" + "       where runLength is an integer." ) ; System . exit ( 1 ) ; } public static void main ( String args [ ] ) { if ( args . length != 3 ) { Usage ( ) ; } String s1 = args [ 0 ] ; String s2 = args [ 1 ] ; int runLength = 0 ; try { runLength = Integer . parseInt ( args [ 2 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } double micros ; String [ ] sa ; long before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { sa = new String [ ] { s1 , s2 } ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The anonymous array loop took around " + micros + " microseconds." ) ; String s ; before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { s = s1 + s2 ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The append loop took around " + micros + " microseconds." ) ; } } 	0	['3', '1', '0', '0', '14', '3', '0', '0', '2', '2', '133', '0', '0', '0', '0.333333333', '0', '0', '43.33333333', '4', '1.6667', '0']
package org . apache . log4j . nt . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . nt . NTEventLogAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class NTMin { static Category cat = Category . getInstance ( NTMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { init ( ) ; test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + NTMin . class + "" ) ; System . exit ( 1 ) ; } static void init ( ) { BasicConfigurator . configure ( new NTEventLogAppender ( ) ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '6', '30', '17', '0', '6', '2', '0.75', '144', '0', '1', '0', '0.277777778', '0', '0', '19.28571429', '2', '0.8571', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class QuietWriter extends FilterWriter { protected ErrorHandler errorHandler ; public QuietWriter ( Writer writer , ErrorHandler errorHandler ) { super ( writer ) ; setErrorHandler ( errorHandler ) ; } public void write ( String string ) { try { out . write ( string ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to write [" + string + "]." , e , ErrorCode . WRITE_FAILURE ) ; } } public void flush ( ) { try { out . flush ( ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to flush writer," , e , ErrorCode . FLUSH_FAILURE ) ; } } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { throw new IllegalArgumentException ( "Attempted to set null ErrorHandler." ) ; } else { this . errorHandler = eh ; } } } 	0	['4', '3', '2', '6', '12', '0', '5', '1', '4', '0', '57', '1', '1', '0.857142857', '0.5', '2', '2', '13', '2', '1', '0']
package org . apache . log4j . helpers ; import java . io . File ; import org . apache . log4j . helpers . LogLog ; public abstract class FileWatchdog extends Thread { static final public long DEFAULT_DELAY = 60000 ; protected String filename ; protected long delay = DEFAULT_DELAY ; File file ; long lastModif = 0 ; boolean warnedAlready = false ; boolean interrupted = false ; protected FileWatchdog ( String filename ) { this . filename = filename ; file = new File ( filename ) ; setDaemon ( true ) ; checkAndConfigure ( ) ; } public void setDelay ( long delay ) { this . delay = delay ; } abstract protected void doOnChange ( ) ; protected void checkAndConfigure ( ) { boolean fileExists ; try { fileExists = file . exists ( ) ; } catch ( SecurityException e ) { LogLog . warn ( "Was not allowed to read check file existance, file:[" + filename + "]." ) ; interrupted = true ; return ; } if ( fileExists ) { long l = file . lastModified ( ) ; if ( l > lastModif ) { lastModif = l ; doOnChange ( ) ; warnedAlready = false ; } } else { if ( ! warnedAlready ) { LogLog . debug ( "[" + filename + "] does not exist." ) ; warnedAlready = true ; } } } public void run ( ) { while ( ! interrupted ) { try { Thread . currentThread ( ) . sleep ( delay ) ; } catch ( InterruptedException e ) { } checkAndConfigure ( ) ; } } } 	0	['5', '2', '0', '2', '17', '0', '1', '1', '2', '0.607142857', '120', '0.285714286', '0', '0.938461538', '0.466666667', '1', '1', '21.6', '3', '1.4', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import java . io . IOException ; import java . io . InputStreamReader ; public class SMTPMin { static Category cat = Category . getInstance ( SMTPMin . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SMTPMin . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; Category . shutdown ( ) ; Thread . currentThread ( ) . getThreadGroup ( ) . list ( ) ; } } 	0	['7', '1', '0', '4', '32', '17', '0', '4', '2', '0.666666667', '155', '0', '1', '0', '0.277777778', '0', '0', '20.85714286', '2', '1', '0']
package org . apache . log4j . performance ; public class NewVsSetLen { static String s ; static int BIGBUF_LEN = 1048576 ; static int SBUF_LEN = 256 ; static int RUN_LENGTH = BIGBUF_LEN / 4 ; static char [ ] sbuf = new char [ SBUF_LEN ] ; static char [ ] bigbuf = new char [ BIGBUF_LEN ] ; { for ( int i = 0 ; i < SBUF_LEN ; i ++ ) { sbuf [ i ] = ( char ) ( i ) ; } for ( int i = 0 ; i < BIGBUF_LEN ; i ++ ) { bigbuf [ i ] = ( char ) ( i ) ; } } static public void main ( String [ ] args ) { int t ; for ( int len = SBUF_LEN ; len <= BIGBUF_LEN ; len *= 4 , RUN_LENGTH /= 4 ) { System . out . println ( "<td>" + len + "\n" ) ; for ( int second = 0 ; second < 16 ; ) { System . out . println ( "SECOND loop=" + second + ", RUN_LENGTH=" + RUN_LENGTH + ", len=" + len ) ; t = ( int ) newBuffer ( len , second ) ; ; System . out . print ( "<td>" + t ) ; t = ( int ) setLen ( len , second ) ; System . out . println ( " <td>" + t + " \n" ) ; if ( second == 0 ) { second = 1 ; } else { second *= 2 ; } } } } static double newBuffer ( int size , int second ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; } for ( int x = 0 ; x < second ; x ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double setLen ( int size , int second ) { long before = System . currentTimeMillis ( ) ; StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } for ( int x = 0 ; x < second ; x ++ ) { buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '16', '0', '0', '0', '2', '0.208333333', '268', '0', '0', '0', '0.333333333', '0', '0', '51.4', '4', '2', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public abstract class PatternConverter { public PatternConverter next ; int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; protected PatternConverter ( ) { } protected PatternConverter ( FormattingInfo fi ) { min = fi . min ; max = fi . max ; leftAlign = fi . leftAlign ; } abstract protected String convert ( LoggingEvent event ) ; public void format ( StringBuffer sbuf , LoggingEvent e ) { String s = convert ( e ) ; if ( s == null ) { if ( 0 < min ) spacePad ( sbuf , min ) ; return ; } int len = s . length ( ) ; if ( len > max ) sbuf . append ( s . substring ( len - max ) ) ; else if ( len < min ) { if ( leftAlign ) { sbuf . append ( s ) ; spacePad ( sbuf , min - len ) ; } else { spacePad ( sbuf , min - len ) ; sbuf . append ( s ) ; } } else sbuf . append ( s ) ; } static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['6', '1', '5', '9', '10', '7', '7', '2', '2', '0.72', '174', '0', '1', '0', '0.44', '0', '0', '27.16666667', '6', '1.8333', '0']
package org . apache . log4j . test ; import java . io . * ; import org . apache . log4j . config . PropertyPrinter ; public class PrintProperties { public static void main ( String [ ] args ) { new PropertyPrinter ( new PrintWriter ( System . out ) , true ) ; } } 	0	['2', '1', '0', '1', '5', '1', '0', '1', '2', '2', '15', '0', '0', '0', '0.5', '0', '0', '6.5', '1', '0.5', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; import java . util . Enumeration ; public interface AppenderAttachable { public void addAppender ( Appender newAppender ) ; public Enumeration getAllAppenders ( ) ; public Appender getAppender ( String name ) ; void removeAllAppenders ( ) ; void removeAppender ( Appender appender ) ; void removeAppender ( String name ) ; } 	0	['6', '1', '0', '4', '6', '15', '3', '1', '6', '2', '6', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . helpers ; public class LogLog { public static final String DEBUG_KEY = "log4j.debug" ; public static final String CONFIG_DEBUG_KEY = "log4j.configDebug" ; protected static boolean debugEnabled = false ; private static boolean quietMode = false ; private static final String PREFIX = "log4j: " ; private static final String ERR_PREFIX = "log4j:ERROR " ; private static final String WARN_PREFIX = "log4j:WARN " ; static { String key = OptionConverter . getSystemProperty ( DEBUG_KEY , null ) ; if ( key == null ) { key = OptionConverter . getSystemProperty ( CONFIG_DEBUG_KEY , null ) ; } if ( key != null ) { debugEnabled = OptionConverter . toBoolean ( key , true ) ; } } static public void setInternalDebugging ( boolean enabled ) { debugEnabled = enabled ; } public static void debug ( String msg ) { if ( debugEnabled && ! quietMode ) { System . out . println ( PREFIX + msg ) ; } } public static void debug ( String msg , Throwable t ) { if ( debugEnabled && ! quietMode ) { System . out . println ( PREFIX + msg ) ; if ( t != null ) t . printStackTrace ( System . out ) ; } } public static void error ( String msg ) { if ( quietMode ) return ; System . err . println ( ERR_PREFIX + msg ) ; } public static void error ( String msg , Throwable t ) { if ( quietMode ) return ; System . err . println ( ERR_PREFIX + msg ) ; if ( t != null ) { t . printStackTrace ( ) ; } } public static void setQuietMode ( boolean quietMode ) { LogLog . quietMode = quietMode ; } public static void warn ( String msg ) { if ( quietMode ) return ; System . err . println ( WARN_PREFIX + msg ) ; } public static void warn ( String msg , Throwable t ) { if ( quietMode ) return ; System . err . println ( WARN_PREFIX + msg ) ; if ( t != null ) { t . printStackTrace ( ) ; } } } 	0	['10', '1', '0', '34', '19', '0', '34', '1', '9', '0.920634921', '146', '0.714285714', '0', '0', '0.333333333', '0', '0', '12.9', '4', '1.9', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . Appender ; import org . apache . log4j . ConsoleAppender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . TTCCLayout ; import org . apache . log4j . Priority ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import java . io . IOException ; public class Min { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test1 ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.Min " + "simple|ttcc" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String layoutType ) { Appender appender = null ; Layout layout = null ; if ( layoutType . equals ( "simple" ) ) layout = new SimpleLayout ( ) ; else if ( layoutType . equals ( "ttcc" ) ) { layout = new TTCCLayout ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ; } else Usage ( "Wrong layoutType [" + layoutType + "]." ) ; appender = new ConsoleAppender ( layout , "System.out" ) ; BasicConfigurator . configure ( appender ) ; } static void test1 ( ) { int i = 0 ; Category ERR = Category . getInstance ( "ERR" ) ; ERR . setPriority ( Priority . ERROR ) ; Category INF = Category . getInstance ( "INF" ) ; INF . setPriority ( Priority . INFO ) ; Category INF_ERR = Category . getInstance ( "INF.ERR" ) ; INF_ERR . setPriority ( Priority . ERROR ) ; Category DEB = Category . getInstance ( "DEB" ) ; DEB . setPriority ( Priority . DEBUG ) ; Category INF_UNDEF = Category . getInstance ( "INF.UNDEF" ) ; Category INF_ERR_UNDEF = Category . getInstance ( "INF.ERR.UNDEF" ) ; Category UNDEF = Category . getInstance ( "UNDEF" ) ; ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; ERR . error ( "Message " + i ) ; i ++ ; INF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF . error ( "Message " + i ) ; i ++ ; INF . warn ( "Message " + i ) ; i ++ ; INF . info ( "Message " + i ) ; i ++ ; INF_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_UNDEF . error ( "Message " + i ) ; i ++ ; INF_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR . error ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR_UNDEF . error ( "Message " + i ) ; i ++ ; DEB . log ( Priority . FATAL , "Message " + i ) ; i ++ ; DEB . error ( "Message " + i ) ; i ++ ; DEB . warn ( "Message " + i ) ; i ++ ; DEB . info ( "Message " + i ) ; i ++ ; DEB . debug ( "Message " + i ) ; i ++ ; UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; UNDEF . error ( "Message " + i ) ; i ++ ; UNDEF . warn ( "Message " + i ) ; i ++ ; UNDEF . info ( "Message " + i ) ; i ++ ; UNDEF . debug ( "Message " + i , new Exception ( "Just testing." ) ) ; i ++ ; ERR . warn ( "Message " + i ) ; i ++ ; ERR . info ( "Message " + i ) ; i ++ ; ERR . debug ( "Message " + i ) ; i ++ ; INF . debug ( "Message " + i ) ; i ++ ; INF_UNDEF . debug ( "Message " + i ) ; i ++ ; INF_ERR . warn ( "Message " + i ) ; i ++ ; INF_ERR . info ( "Message " + i ) ; i ++ ; INF_ERR . debug ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . debug ( "Message " + i ) ; i ++ ; INF . info ( "Messages should bear numbers 0 through 23." ) ; } } 	0	['5', '1', '0', '8', '26', '10', '0', '8', '2', '2', '508', '0', '0', '0', '0.266666667', '0', '0', '100.6', '3', '1.4', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; final public class RootCategory extends Category { public RootCategory ( Priority priority ) { super ( "root" ) ; setPriority ( priority ) ; } final public Priority getChainedPriority ( ) { return priority ; } final public void setPriority ( Priority priority ) { if ( priority == null ) { LogLog . error ( "You have tried to set a null priority to root." , new Throwable ( ) ) ; } else { this . priority = priority ; } } } 	0	['3', '2', '0', '4', '6', '3', '2', '3', '3', '2', '25', '0', '0', '0.959183673', '0.833333333', '1', '5', '7.333333333', '2', '1', '0']
package org . apache . log4j . test ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . net . SocketNode ; import org . apache . log4j . net . SocketServer ; public class ShortSocketServer { static Category cat = Category . getInstance ( ShortSocketServer . class . getName ( ) ) ; static int port ; public static void main ( String argv [ ] ) { if ( argv . length == 2 ) { init ( argv [ 0 ] , argv [ 1 ] ) ; } else { usage ( "Wrong number of arguments." ) ; } try { LogLog . debug ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; LogLog . debug ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; LogLog . debug ( "Connected to client at " + socket . getInetAddress ( ) ) ; LogLog . debug ( "Starting new socket node." ) ; SocketNode sn = new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ; Thread t = new Thread ( sn ) ; t . start ( ) ; t . join ( ) ; } catch ( Exception e ) { cat . error ( "Error while in main." , e ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ShortSocketServer . class . getName ( ) + " port configFile" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	0	['6', '1', '0', '5', '32', '9', '0', '5', '2', '0.666666667', '148', '0', '1', '0', '0.333333333', '0', '0', '23.16666667', '2', '1', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; public class SyslogQuietWriter extends QuietWriter { int syslogFacility ; int priority ; public SyslogQuietWriter ( Writer writer , int syslogFacility , ErrorHandler eh ) { super ( writer , eh ) ; this . syslogFacility = syslogFacility ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setSyslogFacility ( int syslogFacility ) { this . syslogFacility = syslogFacility ; } public void write ( String string ) { super . write ( "<" + ( syslogFacility | priority ) + ">" + string ) ; } } 	0	['4', '4', '0', '3', '10', '0', '1', '2', '4', '0.5', '41', '0', '0', '0.875', '0.5', '2', '2', '8.75', '1', '0.75', '0']
package org . apache . log4j . performance ; public class SystemTime { static int RUN_LENGTH = 1000000 ; static public void main ( String [ ] args ) { double t = systemCurrentTimeLoop ( ) ; System . out . println ( "Average System.currentTimeMillis() call took " + t ) ; t = currentThreadNameloop ( ) ; System . out . println ( "Average Thread.currentThread().getName() call took " + t ) ; } static double systemCurrentTimeLoop ( ) { long before = System . currentTimeMillis ( ) ; long l ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { l = System . currentTimeMillis ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double currentThreadNameloop ( ) { long before = System . currentTimeMillis ( ) ; String t ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { t = Thread . currentThread ( ) . getName ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '14', '4', '0', '0', '2', '0.25', '80', '0', '0', '0', '0.25', '0', '0', '14.8', '2', '1', '0']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . LogLog ; import javax . jms . Message ; import javax . jms . JMSException ; import javax . jms . DeliveryMode ; import java . util . Enumeration ; public class MessageRenderer implements ObjectRenderer { public MessageRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof Message ) { StringBuffer sbuf = new StringBuffer ( ) ; Message m = ( Message ) o ; try { sbuf . append ( "DeliveryMode=" ) ; switch ( m . getJMSDeliveryMode ( ) ) { case DeliveryMode . NON_PERSISTENT : sbuf . append ( "NON_PERSISTENT" ) ; break ; case DeliveryMode . PERSISTENT : sbuf . append ( "PERSISTENT" ) ; break ; default : sbuf . append ( "UNKNOWN" ) ; } sbuf . append ( ", CorrelationID=" ) ; sbuf . append ( m . getJMSCorrelationID ( ) ) ; sbuf . append ( ", Destination=" ) ; sbuf . append ( m . getJMSDestination ( ) ) ; sbuf . append ( ", Expiration=" ) ; sbuf . append ( m . getJMSExpiration ( ) ) ; sbuf . append ( ", MessageID=" ) ; sbuf . append ( m . getJMSMessageID ( ) ) ; sbuf . append ( ", Priority=" ) ; sbuf . append ( m . getJMSPriority ( ) ) ; sbuf . append ( ", Redelivered=" ) ; sbuf . append ( m . getJMSRedelivered ( ) ) ; sbuf . append ( ", ReplyTo=" ) ; sbuf . append ( m . getJMSReplyTo ( ) ) ; sbuf . append ( ", Timestamp=" ) ; sbuf . append ( m . getJMSTimestamp ( ) ) ; sbuf . append ( ", Type=" ) ; sbuf . append ( m . getJMSType ( ) ) ; } catch ( JMSException e ) { LogLog . error ( "Could not parse Message." , e ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '3', '22', '1', '1', '2', '2', '2', '128', '0', '0', '0', '0.75', '0', '0', '63', '5', '2.5', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import java . io . IOException ; public class SyslogWriter extends Writer { final int SYSLOG_PORT = 514 ; static String syslogHost ; private InetAddress address ; private DatagramSocket ds ; public SyslogWriter ( String syslogHost ) { this . syslogHost = syslogHost ; try { this . address = InetAddress . getByName ( syslogHost ) ; } catch ( UnknownHostException e ) { LogLog . error ( "Could not find " + syslogHost + ". All logging will FAIL." , e ) ; } try { this . ds = new DatagramSocket ( ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; LogLog . error ( "Could not instantiate DatagramSocket to " + syslogHost + ". All logging will FAIL." , e ) ; } } public void write ( char [ ] buf , int off , int len ) throws IOException { this . write ( new String ( buf , off , len ) ) ; } public void write ( String string ) throws IOException { DatagramPacket packet = new DatagramPacket ( string . getBytes ( ) , string . length ( ) , address , SYSLOG_PORT ) ; if ( this . ds != null ) ds . send ( packet ) ; } public void flush ( ) { } public void close ( ) { } } 	0	['5', '2', '0', '2', '18', '8', '1', '1', '5', '0.75', '88', '0.5', '0', '0.764705882', '0.45', '1', '2', '15.8', '1', '0.8', '0']
package org . apache . log4j . performance ; import java . io . Writer ; import java . io . IOException ; public class NOPWriter extends Writer { public void write ( char [ ] cbuf ) throws IOException { } public void write ( char [ ] cbuf , int off , int len ) throws IOException { } public void write ( int b ) throws IOException { } public void write ( String s ) throws IOException { } public void write ( String s , int off , int len ) throws IOException { } public void flush ( ) throws IOException { } public void close ( ) throws IOException { System . err . println ( "Close called." ) ; } } 	0	['8', '2', '0', '0', '10', '28', '0', '0', '8', '2', '21', '0', '0', '0.65', '0.46875', '1', '2', '1.625', '1', '0.875', '0']
package org . apache . log4j ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . LoggingEvent ; public interface Appender { void addFilter ( Filter newFilter ) ; public Filter getFilter ( ) ; public void clearFilters ( ) ; public void close ( ) ; public void doAppend ( LoggingEvent event ) ; public String getName ( ) ; public void setErrorHandler ( ErrorHandler errorHandler ) ; public ErrorHandler getErrorHandler ( ) ; public void setLayout ( Layout layout ) ; public Layout getLayout ( ) ; public void setName ( String name ) ; public boolean requiresLayout ( ) ; } 	0	['12', '1', '0', '21', '12', '66', '17', '4', '12', '2', '12', '0', '0', '0', '0.236111111', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . test ; import org . apache . log4j . * ; public class CategoryWrapper { Category c ; static String FQCN = CategoryWrapper . class . getName ( ) ; CategoryWrapper ( String name ) { c = Category . getInstance ( name ) ; } public static void main ( String argv [ ] ) { Layout layout = new PatternLayout ( "%p [%t] %C %F - %m\n" ) ; Appender out = new ConsoleAppender ( layout , ConsoleAppender . SYSTEM_OUT ) ; CategoryWrapper w1 = new CategoryWrapper ( "c1" ) ; w1 . addAppender ( out ) ; w1 . print ( "hello" ) ; } public void addAppender ( Appender appender ) { c . addAppender ( appender ) ; } public void print ( String msg ) { c . log ( FQCN + ".print" , Priority . DEBUG , msg , null ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + CategoryWrapper . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['7', '1', '0', '6', '22', '11', '0', '6', '3', '0.666666667', '107', '0', '1', '0', '0.375', '0', '0', '13.85714286', '2', '0.8571', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . ErrorHandler ; public class OnlyOnceErrorHandler implements ErrorHandler { final String WARN_PREFIX = "log4j warning: " ; final String ERROR_PREFIX = "log4j error: " ; boolean firstTime = true ; public String [ ] getOptionStrings ( ) { return null ; } public void setOption ( String key , String value ) { } public void activateOptions ( ) { } public void error ( String message , Exception e , int errorCode ) { if ( firstTime ) { LogLog . error ( message , e ) ; firstTime = false ; } } public void error ( String message ) { if ( firstTime ) { LogLog . error ( message ) ; firstTime = false ; } } } 	0	['6', '1', '0', '3', '9', '9', '1', '2', '6', '0.866666667', '44', '0', '0', '0', '0.458333333', '0', '0', '5.833333333', '2', '1.1667', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; public class Hello { static Category cat = Category . getInstance ( Hello . class ) ; public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; cat . debug ( "Hello world." ) ; cat . info ( "What a beatiful day." ) ; } } 	0	['4', '1', '0', '2', '12', '4', '0', '2', '2', '0.833333333', '38', '0', '1', '0', '0.333333333', '0', '0', '8', '1', '0.5', '0']
package org . apache . log4j . helpers ; import java . io . File ; import java . io . Writer ; import java . io . FileWriter ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class CountingQuietWriter extends QuietWriter { protected long count ; public CountingQuietWriter ( Writer writer , ErrorHandler eh ) { super ( writer , eh ) ; } public void write ( String string ) { try { out . write ( string ) ; count += string . length ( ) ; } catch ( IOException e ) { errorHandler . error ( "Write failure." , e , ErrorCode . WRITE_FAILURE ) ; } } public long getCount ( ) { return count ; } public void setCount ( long count ) { this . count = count ; } } 	0	['4', '4', '0', '3', '8', '0', '1', '2', '4', '0.333333333', '38', '1', '0', '0.875', '0.4', '2', '2', '8.25', '1', '0.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . * ; import java . util . * ; import java . text . * ; public class L7D { static ResourceBundle [ ] bundles ; public static void main ( String args [ ] ) { if ( args . length == 3 ) init ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + L7D . class . getName ( ) + "configFile ISO639LanguageCode ISO2166CountryCode" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String lanCode , String countryCode ) { PropertyConfigurator . configure ( configFile ) ; bundles = new ResourceBundle [ 3 ] ; try { bundles [ 0 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "en" , "US" ) ) ; bundles [ 1 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "FR" ) ) ; bundles [ 2 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "CH" ) ) ; } catch ( MissingResourceException e ) { e . printStackTrace ( ) ; } } static void test ( ) { Category root = Category . getRoot ( ) ; for ( int i = 0 ; i < bundles . length ; i ++ ) { root . setResourceBundle ( bundles [ i ] ) ; root . l7dlog ( Priority . DEBUG , "bogus1" , null ) ; root . l7dlog ( Priority . INFO , "test" , null ) ; root . l7dlog ( Priority . WARN , "hello_world" , null ) ; root . l7dlog ( Priority . DEBUG , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "bogusMsg" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . INFO , "bogus2" , null ) ; } } } 	0	['6', '1', '0', '3', '25', '13', '0', '3', '2', '0.7', '202', '0', '0', '0', '0.277777778', '0', '0', '32.33333333', '2', '1.3333', '0']
package org . apache . log4j . spi ; public interface TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . config ; public class PropertySetterException extends Exception { protected Throwable rootCause ; public PropertySetterException ( String msg ) { super ( msg ) ; } public PropertySetterException ( Throwable rootCause ) { super ( ) ; this . rootCause = rootCause ; } public String getMessage ( ) { String msg = super . getMessage ( ) ; if ( msg == null && rootCause != null ) { msg = rootCause . getMessage ( ) ; } return msg ; } } 	0	['3', '3', '0', '1', '6', '1', '1', '0', '3', '0.5', '28', '1', '0', '0.944444444', '0.555555556', '1', '1', '8', '3', '1', '0']
package org . apache . log4j . helpers ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class NullEnumeration implements Enumeration { private static final NullEnumeration instance = new NullEnumeration ( ) ; private NullEnumeration ( ) { } public static NullEnumeration getInstance ( ) { return instance ; } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) { throw new NoSuchElementException ( ) ; } } 	0	['5', '1', '0', '1', '7', '8', '1', '0', '3', '0.75', '22', '1', '1', '0', '0.75', '0', '0', '3.2', '1', '0.6', '0']
package org . apache . log4j . test ; class Base64 { final static int MAX_LINE = 76 ; static byte [ ] asciiEncoding = { 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 43 , 47 } ; static char [ ] charEnc = new char [ 64 ] ; static { for ( int i = 0 ; i < 26 ; i ++ ) { charEnc [ i ] = ( char ) ( 'A' + i ) ; charEnc [ i + 26 ] = ( char ) ( 'a' + i ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { charEnc [ i + 52 ] = ( char ) ( '0' + i ) ; } charEnc [ 62 ] = '+' ; charEnc [ 63 ] = '/' ; } static String toString ( byte [ ] inbuf ) { return toString ( inbuf , 0 , inbuf . length ) ; } static String toString ( byte [ ] inbuf , int offset , int length ) { StringBuffer output = new StringBuffer ( ( length ) * 4 / 3 + 1 ) ; int in ; char [ ] out = new char [ 4 ] ; int i = offset ; boolean ended = false ; int last = offset + length ; int j ; int bitsRead ; while ( ! ended ) { in = 0 ; bitsRead = 0 ; for ( j = 0 ; j < 3 ; j ++ ) { if ( i == last ) { ended = true ; break ; } in = ( in << 8 ) | ( inbuf [ i ++ ] & 0xFF ) ; bitsRead += 8 ; } while ( bitsRead >= 6 ) { bitsRead -= 6 ; output . append ( charEnc [ ( in > > > bitsRead ) & 0x3F ] ) ; } if ( bitsRead == 4 ) { output . append ( charEnc [ ( in & 0x0F ) << 2 ] ) ; output . append ( "=" ) ; } else if ( bitsRead == 2 ) { output . append ( charEnc [ ( in & 0x03 ) << 4 ] ) ; output . append ( "==" ) ; } } return output . toString ( ) ; } public static void main ( String [ ] args ) { byte [ ] inbuf = new byte [ MAX_LINE ] ; while ( true ) { try { int read = System . in . read ( inbuf , 0 , MAX_LINE ) ; if ( read == - 1 ) break ; System . out . println ( "Read " + read + " chars." ) ; System . out . println ( Base64 . toString ( inbuf , 0 , read ) ) ; } catch ( Exception e ) { System . out . println ( "Exception " + e ) ; } } } } 	0	['5', '1', '0', '0', '15', '8', '0', '0', '1', '0.833333333', '479', '0', '0', '0', '0.3125', '0', '0', '94.2', '7', '2', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . ConsoleAppender ; import org . apache . log4j . Level ; public class NotLogging { static int runLength ; final static int INITIAL_HASH_SIZE = 101 ; static String SHORT_MSG = "Hello World" ; static Category SHORT_CAT = Category . getInstance ( "A0123456789" ) ; static Category MEDIUM_CAT = Category . getInstance ( "A0123456789.B0123456789" ) ; static Category LONG_CAT = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static Category INEXISTENT_SHORT_CAT = Category . getInstance ( "I0123456789" ) ; static Category INEXISTENT_MEDIUM_CAT = Category . getInstance ( "I0123456789.B0123456789" ) ; static Category INEXISTENT_LONG_CAT = Category . getInstance ( "I0123456789.B0123456789.C0123456789" ) ; static Category [ ] CAT_ARRAY = new Category [ ] { SHORT_CAT , MEDIUM_CAT , LONG_CAT , INEXISTENT_SHORT_CAT , INEXISTENT_MEDIUM_CAT , INEXISTENT_LONG_CAT } ; static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.NotLogging true|false runLength\n" + "true indicates shipped code, false indicates code in development" + "  where runLength is an int representing the run length of loops\n" + "We suggest that runLength be at least 100'000." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length != 2 ) { Usage ( ) ; } ProgramInit ( argv ) ; double delta ; System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = SimpleMessage ( CAT_ARRAY [ i ] , SHORT_MSG , runLength ) ; System . out . println ( "Simple argument,          " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = FullyOptimizedComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Fully optimized complex,  " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = ComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Complex message argument, " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } } static void ProgramInit ( String [ ] args ) { try { runLength = Integer . parseInt ( args [ 1 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } ConsoleAppender appender = new ConsoleAppender ( new SimpleLayout ( ) ) ; if ( "false" . equals ( args [ 0 ] ) ) { } else if ( "true" . equals ( args [ 0 ] ) ) { System . out . println ( "Flagging as shipped code." ) ; Category . getDefaultHierarchy ( ) . setThreshold ( ( Level ) Level . WARN ) ; } else Usage ( ) ; SHORT_CAT . setLevel ( ( Level ) Level . INFO ) ; Category . getRoot ( ) . setLevel ( ( Level ) Level . INFO ) ; } static double SimpleMessage ( Category category , String msg , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( msg ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double FullyOptimizedComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { if ( category . isDebugEnabled ( ) ) category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double ComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } } 	0	['8', '1', '0', '6', '31', '22', '0', '6', '2', '0.942857143', '325', '0', '7', '0', '0.285714286', '0', '0', '38.375', '5', '2', '0']
package org . apache . log4j . performance ; import java . util . Date ; public class ConcatVsArray { static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.performance.ConcatVsArray " + "string1 string2 runLength\n" + "       where runLength is an integer." ) ; System . exit ( 1 ) ; } public static void main ( String args [ ] ) { if ( args . length != 3 ) { Usage ( ) ; } String s1 = args [ 0 ] ; String s2 = args [ 1 ] ; int runLength = 0 ; try { runLength = Integer . parseInt ( args [ 2 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } double micros ; String [ ] sa ; long before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { sa = new String [ ] { s1 , s2 } ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The anonymous array loop took around " + micros + " microseconds." ) ; String s ; before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { s = s1 + s2 ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The append loop took around " + micros + " microseconds." ) ; } } 	0	['3', '1', '0', '0', '14', '3', '0', '0', '2', '2', '133', '0', '0', '0', '0.333333333', '0', '0', '43.33333333', '4', '1.6667', '0']
package org . apache . log4j . lf5 . util ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; public class ProductProperties { protected Properties _productProperties ; private static ProductProperties _reference = null ; private static Object _synchronizingObject = new Object ( ) ; private ProductProperties ( ) { this ( new Resource ( "org/apache/log4j/lf5/lf5.properties" ) ) ; } private ProductProperties ( Resource resource ) { super ( ) ; _productProperties = new Properties ( ) ; try { InputStream source = getSource ( resource ) ; byte [ ] contents = StreamUtils . getBytes ( source ) ; _productProperties = getProperties ( contents ) ; source . close ( ) ; validateProductProperties ( ) ; } catch ( Exception e ) { String error = e . getMessage ( ) ; throw new ExceptionInInitializerError ( error ) ; } } public static ProductProperties getInstance ( ) { if ( _reference == null ) { synchronized ( _synchronizingObject ) { if ( _reference == null ) { _reference = new ProductProperties ( ) ; } } } return _reference ; } public static String getPropertyNameOfProductName ( ) { return "product.name" ; } public static String getPropertyNameOfProductVersionNumber ( ) { return "product.version.number" ; } public static String getPropertyNameOfProductReleaseDate ( ) { return "product.release.date" ; } public String getProductName ( ) { return _productProperties . getProperty ( getPropertyNameOfProductName ( ) ) ; } public void setProductName ( String productName ) { _productProperties . setProperty ( getPropertyNameOfProductName ( ) , productName ) ; } public String getProductVersionNumber ( ) { return _productProperties . getProperty ( getPropertyNameOfProductVersionNumber ( ) ) ; } public void setProductVersionNumber ( String productVersionNumber ) { _productProperties . setProperty ( getPropertyNameOfProductVersionNumber ( ) , productVersionNumber ) ; } public String getProductReleaseDate ( ) { return _productProperties . getProperty ( getPropertyNameOfProductReleaseDate ( ) ) ; } public void setProductReleaseDate ( String productReleaseDate ) { _productProperties . setProperty ( getPropertyNameOfProductReleaseDate ( ) , productReleaseDate ) ; } public String get ( String name ) { return _productProperties . getProperty ( name ) ; } public Object set ( String name , String value ) { return _productProperties . setProperty ( name , value ) ; } public String getLogFactor5 ( ) { return getString ( "lf5" ) ; } public String getString ( String propertyName ) { return String . valueOf ( get ( propertyName ) ) ; } protected void validateProductProperties ( ) throws Exception { String value = null ; value = getProductVersionNumber ( ) ; if ( ( value == null ) || value . equals ( "" ) ) { throw new Exception ( "Product version number is null." ) ; } value = getProductReleaseDate ( ) ; if ( ( value == null ) || value . equals ( "" ) ) { throw new Exception ( "Product release date is null." ) ; } } private InputStream getSource ( Resource resource ) { return new BufferedInputStream ( ResourceUtils . getResourceAsStream ( this , resource ) ) ; } private Properties getProperties ( byte [ ] contents ) throws IOException { ByteArrayInputStream source = new ByteArrayInputStream ( contents ) ; Properties result = new Properties ( ) ; result . load ( source ) ; source . close ( ) ; return result ; } } 	0	['20', '1', '0', '5', '37', '116', '2', '3', '14', '0.754385965', '209', '1', '1', '0', '0.315789474', '0', '0', '9.3', '3', '0.95', '0']
package org . apache . log4j . lf5 . viewer ; import org . apache . log4j . lf5 . util . ProductProperties ; import org . apache . log4j . lf5 . util . Resource ; import javax . swing . * ; import java . awt . * ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . net . URL ; public class LogFactor5AboutDialog extends JDialog { public LogFactor5AboutDialog ( Frame owner ) { super ( owner , "About LogFactor5" , true ) ; ProductProperties props = ProductProperties . getInstance ( ) ; setTitle ( "About LogFactor5" ) ; JPanel imagePanel = new JPanel ( ) ; Resource aboutResource = new Resource ( "org/apache/log4j/lf5/viewer/images/" + "lf5_about.gif" ) ; URL aboutIconURL = aboutResource . getURL ( ) ; ImageIcon aboutIcon = null ; if ( aboutIconURL != null ) { aboutIcon = new ImageIcon ( aboutIconURL ) ; } JLabel imageLabel = new JLabel ( ) ; if ( aboutIcon != null ) { imageLabel . setIcon ( aboutIcon ) ; } imagePanel . add ( imageLabel ) ; JPanel textPanel = new JPanel ( ) ; textPanel . setLayout ( new GridLayout ( 3 , 1 ) ) ; int numberOfRows = 13 ; numberOfRows = 11 ; JPanel mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new GridLayout ( numberOfRows , 1 ) ) ; JLabel aboutLF5 = new JLabel ( "LogFactor5 v" + props . getProductVersionNumber ( ) , JLabel . CENTER ) ; aboutLF5 . setHorizontalAlignment ( SwingConstants . CENTER ) ; JLabel donate = new JLabel ( "Contributed by ThoughtWorks Inc." ) ; donate . setHorizontalAlignment ( SwingConstants . CENTER ) ; mainPanel . add ( aboutLF5 ) ; mainPanel . add ( Box . createVerticalStrut ( 10 ) ) ; mainPanel . add ( donate ) ; mainPanel . add ( Box . createVerticalStrut ( 10 ) ) ; JButton ok = new JButton ( "OK" ) ; JPanel southPanel = new JPanel ( ) ; southPanel . setLayout ( new FlowLayout ( ) ) ; southPanel . add ( ok ) ; ok . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { hide ( ) ; } } ) ; getContentPane ( ) . add ( imagePanel , BorderLayout . NORTH ) ; getContentPane ( ) . add ( mainPanel , BorderLayout . CENTER ) ; getContentPane ( ) . add ( southPanel , BorderLayout . SOUTH ) ; setSize ( 414 , 400 ) ; center ( ) ; } protected void center ( ) { Dimension screen = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; Dimension comp = getSize ( ) ; setLocation ( ( ( screen . width - comp . width ) / 2 ) , ( ( screen . height - comp . height ) / 2 ) ) ; } } 	0	['2', '6', '0', '4', '33', '1', '2', '3', '1', '2', '184', '0', '0', '0.998417722', '0.75', '0', '0', '91', '1', '0.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressNDC extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int PUSH_MISS = LOOP_LENGTH / 2 ; static final int POP_MISS = PUSH_MISS * 2 ; static final int BRANCHING_FACTOR = 4 + 1 ; static int maxThreads ; static int msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { BasicConfigurator . configure ( ) ; if ( args . length != 1 ) { usage ( ) ; } try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } root . debug ( "push(IP=127.0.0.1)" ) ; NDC . push ( "IP=127.0.0.1" ) ; while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.StressNDC " + "MAX_THREADS" ) ; System . exit ( 1 ) ; } Stack parentDC ; public StressNDC ( Stack parentDC ) { this . setName ( randomID ( ) ) ; this . parentDC = parentDC ; } public void run ( ) { NDC . inherit ( parentDC ) ; int loopLength = StressNDC . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop.debug( loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; if ( randomInt ( PUSH_MISS ) == 0 ) { String id = randomID ( ) ; root . debug ( "push(" + id + ")" ) ; NDC . push ( id ) ; } root . debug ( "Message number " + StressNDC . msgCounter ++ ) ; if ( randomInt ( POP_MISS ) == 0 ) { root . debug ( "pop()" ) ; NDC . pop ( ) ; } } synchronized ( lock ) { StressNDC . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressNDC . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } if ( ( loopLength % 2 ) == 0 ) { root . debug ( "Removing NDC for this thread." ) ; NDC . remove ( ) ; } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstained ( n ) ; root . debug ( "Creating " + n + " child StressNDC threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressNDC, threadCounter = " + ( ++ threadCounter ) ) ; new StressNDC ( NDC . cloneStack ( ) ) . start ( ) ; } } } static public int maxThreadsConstained ( int a ) { int maxAllowed = StressNDC . maxThreads - StressNDC . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public static String randomID ( ) { return Integer . toString ( random . nextInt ( ) & 0xFFFFFF ) ; } } 	0	['9', '2', '0', '3', '36', '8', '0', '3', '7', '0.822916667', '311', '0', '1', '0.897058824', '0.21875', '0', '0', '32.22222222', '7', '2', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . NDC ; import org . apache . log4j . performance . NOPWriter ; public class Logging { static int runLength ; static int delay = - 1 ; static int burstLen = 100 ; static int DELAY_MULT = 1000 / burstLen ; static Category cat = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Logging . class . getName ( ) + " confFile runLength [delay] [burstLen]\n" + "        confFile is an XML configuration file and\n" + "        runLength (integer) is the length of test loop.\n" + "        delay is the time in millisecs to wait every bustLen log requests." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] , null , null ) ; else if ( argv . length == 4 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] , argv [ 3 ] ) ; else Usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; double delta ; String msg = "ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890" ; if ( delay <= 0 ) delta = NoDelayLoop ( cat , msg ) ; else delta = DelayedLoop ( cat , msg ) ; System . out . print ( ( int ) delta ) ; Category . shutdown ( ) ; } static void init ( String configFile , String runLengthStr , String delayStr , String burstLenStr ) { try { runLength = Integer . parseInt ( runLengthStr ) ; if ( delayStr != null ) { delay = Integer . parseInt ( delayStr ) ; } if ( delayStr != null ) { burstLen = Integer . parseInt ( burstLenStr ) ; DELAY_MULT = 1000 / burstLen ; } } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; } DOMConfigurator . configure ( configFile ) ; } static double NoDelayLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; } return ( ( System . currentTimeMillis ( ) - before ) * 1000.0 ) / runLength ; } static double DelayedLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; int j = 0 ; Thread currentThread = Thread . currentThread ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; if ( j ++ == burstLen ) { j = 0 ; try { currentThread . sleep ( delay ) ; } catch ( Exception e ) { } } } double actualTime = ( ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ) ; System . out . println ( "actual time: " + actualTime ) ; return ( actualTime - delay * DELAY_MULT ) ; } } 	0	['8', '1', '0', '3', '30', '12', '0', '3', '2', '0.666666667', '228', '0', '1', '0', '0.321428571', '0', '0', '26.75', '4', '1.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . * ; import java . util . * ; import java . text . * ; public class L7D { static ResourceBundle [ ] bundles ; public static void main ( String args [ ] ) { if ( args . length == 3 ) init ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + L7D . class . getName ( ) + "configFile ISO639LanguageCode ISO2166CountryCode" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String lanCode , String countryCode ) { PropertyConfigurator . configure ( configFile ) ; bundles = new ResourceBundle [ 3 ] ; try { bundles [ 0 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "en" , "US" ) ) ; bundles [ 1 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "FR" ) ) ; bundles [ 2 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "CH" ) ) ; } catch ( MissingResourceException e ) { e . printStackTrace ( ) ; } } static void test ( ) { Category root = Category . getRoot ( ) ; for ( int i = 0 ; i < bundles . length ; i ++ ) { root . setResourceBundle ( bundles [ i ] ) ; root . l7dlog ( Priority . DEBUG , "bogus1" , null ) ; root . l7dlog ( Priority . INFO , "test" , null ) ; root . l7dlog ( Priority . WARN , "hello_world" , null ) ; root . l7dlog ( Priority . DEBUG , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "bogusMsg" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . INFO , "bogus2" , null ) ; } } } 	0	['6', '1', '0', '3', '25', '13', '0', '3', '2', '0.7', '202', '0', '0', '0', '0.277777778', '0', '0', '32.33333333', '2', '1.3333', '0']
