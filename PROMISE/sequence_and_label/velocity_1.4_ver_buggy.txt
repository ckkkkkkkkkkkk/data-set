package org . apache . velocity . context ; public interface Context { Object put ( String key , Object value ) ; Object get ( String key ) ; boolean containsKey ( Object key ) ; Object [ ] getKeys ( ) ; Object remove ( Object key ) ; } 	1	['5', '1', '0', '34', '5', '10', '34', '0', '5', '2', '5', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . util . introspection ; import org . apache . velocity . util . ArrayIterator ; import org . apache . velocity . util . EnumerationIterator ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . parser . node . AbstractExecutor ; import org . apache . velocity . runtime . parser . node . PropertyExecutor ; import org . apache . velocity . runtime . parser . node . GetExecutor ; import org . apache . velocity . runtime . parser . node . BooleanPropertyExecutor ; import java . lang . reflect . Method ; import java . util . Iterator ; import java . util . Collection ; import java . util . Map ; import java . util . Enumeration ; import java . util . ArrayList ; public class UberspectImpl implements Uberspect , UberspectLoggable { private RuntimeLogger rlog ; private static Introspector introspector ; public void init ( ) throws Exception { } public void setRuntimeLogger ( RuntimeLogger runtimeLogger ) { rlog = runtimeLogger ; introspector = new Introspector ( rlog ) ; } public Iterator getIterator ( Object obj , Info i ) throws Exception { if ( obj . getClass ( ) . isArray ( ) ) { return new ArrayIterator ( obj ) ; } else if ( obj instanceof Collection ) { return ( ( Collection ) obj ) . iterator ( ) ; } else if ( obj instanceof Map ) { return ( ( Map ) obj ) . values ( ) . iterator ( ) ; } else if ( obj instanceof Iterator ) { rlog . warn ( "Warning! The iterative " + " is an Iterator in the #foreach() loop at [" + i . getLine ( ) + "," + i . getColumn ( ) + "]" + " in template " + i . getTemplateName ( ) + ". Because it's not resetable," + " if used in more than once, this may lead to" + " unexpected results." ) ; return ( ( Iterator ) obj ) ; } else if ( obj instanceof Enumeration ) { rlog . warn ( "Warning! The iterative " + " is an Enumeration in the #foreach() loop at [" + i . getLine ( ) + "," + i . getColumn ( ) + "]" + " in template " + i . getTemplateName ( ) + ". Because it's not resetable," + " if used in more than once, this may lead to" + " unexpected results." ) ; return new EnumerationIterator ( ( Enumeration ) obj ) ; } rlog . warn ( "Could not determine type of iterator in " + "#foreach loop " + " at [" + i . getLine ( ) + "," + i . getColumn ( ) + "]" + " in template " + i . getTemplateName ( ) ) ; return null ; } public VelMethod getMethod ( Object obj , String methodName , Object [ ] args , Info i ) throws Exception { if ( obj == null ) return null ; Method m = introspector . getMethod ( obj . getClass ( ) , methodName , args ) ; return ( m != null ) ? new VelMethodImpl ( m ) : null ; } public VelPropertyGet getPropertyGet ( Object obj , String identifier , Info i ) throws Exception { AbstractExecutor executor ; Class claz = obj . getClass ( ) ; executor = new PropertyExecutor ( rlog , introspector , claz , identifier ) ; if ( executor . isAlive ( ) == false ) { executor = new GetExecutor ( rlog , introspector , claz , identifier ) ; } if ( executor . isAlive ( ) == false ) { executor = new BooleanPropertyExecutor ( rlog , introspector , claz , identifier ) ; } return ( executor != null ) ? new VelGetterImpl ( executor ) : null ; } public VelPropertySet getPropertySet ( Object obj , String identifier , Object arg , Info i ) throws Exception { Class claz = obj . getClass ( ) ; VelPropertySet vs = null ; VelMethod vm = null ; try { Object [ ] params = { arg } ; try { vm = getMethod ( obj , "set" + identifier , params , i ) ; if ( vm == null ) { throw new NoSuchMethodException ( ) ; } } catch ( NoSuchMethodException nsme2 ) { StringBuffer sb = new StringBuffer ( "set" ) ; sb . append ( identifier ) ; if ( Character . isLowerCase ( sb . charAt ( 3 ) ) ) { sb . setCharAt ( 3 , Character . toUpperCase ( sb . charAt ( 3 ) ) ) ; } else { sb . setCharAt ( 3 , Character . toLowerCase ( sb . charAt ( 3 ) ) ) ; } vm = getMethod ( obj , sb . toString ( ) , params , i ) ; if ( vm == null ) { throw new NoSuchMethodException ( ) ; } } } catch ( NoSuchMethodException nsme ) { if ( Map . class . isAssignableFrom ( claz ) ) { Object [ ] params = { new Object ( ) , new Object ( ) } ; vm = getMethod ( obj , "put" , params , i ) ; if ( vm != null ) return new VelSetterImpl ( vm , identifier ) ; } } return ( vm != null ) ? new VelSetterImpl ( vm ) : null ; } public class VelMethodImpl implements VelMethod { Method method = null ; public VelMethodImpl ( Method m ) { method = m ; } private VelMethodImpl ( ) { } public Object invoke ( Object o , Object [ ] params ) throws Exception { return method . invoke ( o , params ) ; } public boolean isCacheable ( ) { return true ; } public String getMethodName ( ) { return method . getName ( ) ; } public Class getReturnType ( ) { return method . getReturnType ( ) ; } } public class VelGetterImpl implements VelPropertyGet { AbstractExecutor ae = null ; public VelGetterImpl ( AbstractExecutor exec ) { ae = exec ; } private VelGetterImpl ( ) { } public Object invoke ( Object o ) throws Exception { return ae . execute ( o ) ; } public boolean isCacheable ( ) { return true ; } public String getMethodName ( ) { return ae . getMethod ( ) . getName ( ) ; } } public class VelSetterImpl implements VelPropertySet { VelMethod vm = null ; String putKey = null ; public VelSetterImpl ( VelMethod velmethod ) { this . vm = velmethod ; } public VelSetterImpl ( VelMethod velmethod , String key ) { this . vm = velmethod ; putKey = key ; } private VelSetterImpl ( ) { } public Object invoke ( Object o , Object value ) throws Exception { ArrayList al = new ArrayList ( ) ; if ( putKey != null ) { al . add ( putKey ) ; al . add ( value ) ; } else { al . add ( value ) ; } return vm . invoke ( o , al . toArray ( ) ) ; } public boolean isCacheable ( ) { return true ; } public String getMethodName ( ) { return vm . getMethodName ( ) ; } } } 	1	['8', '1', '0', '17', '44', '18', '3', '17', '7', '0.761904762', '360', '0.666666667', '2', '0', '0.4375', '0', '0', '43.625', '1', '0.875', '3']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . * ; public class ASTIncludeStatement extends SimpleNode { public ASTIncludeStatement ( int id ) { super ( id ) ; } public ASTIncludeStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	1	['3', '2', '0', '3', '6', '3', '0', '3', '3', '2', '17', '0', '0', '0.964285714', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '1']
package org . apache . velocity . util . introspection ; import java . util . Map ; import java . util . Set ; import java . util . HashMap ; import java . util . HashSet ; import java . lang . reflect . Method ; public class IntrospectorBase { protected Map classMethodMaps = new HashMap ( ) ; protected Set cachedClassNames = new HashSet ( ) ; public Method getMethod ( Class c , String name , Object [ ] params ) throws Exception { if ( c == null ) { throw new Exception ( "Introspector.getMethod(): Class method key was null: " + name ) ; } ClassMap classMap = null ; synchronized ( classMethodMaps ) { classMap = ( ClassMap ) classMethodMaps . get ( c ) ; if ( classMap == null ) { if ( cachedClassNames . contains ( c . getName ( ) ) ) { clearCache ( ) ; } classMap = createClassMap ( c ) ; } } return classMap . findMethod ( name , params ) ; } protected ClassMap createClassMap ( Class c ) { ClassMap classMap = new ClassMap ( c ) ; classMethodMaps . put ( c , classMap ) ; cachedClassNames . add ( c . getName ( ) ) ; return classMap ; } protected void clearCache ( ) { classMethodMaps . clear ( ) ; cachedClassNames = new HashSet ( ) ; } } 	1	['4', '1', '1', '2', '19', '0', '1', '1', '2', '0', '101', '1', '0', '0', '0.5', '0', '0', '23.75', '1', '0.75', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . * ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; public class ASTIfStatement extends SimpleNode { public ASTIfStatement ( int id ) { super ( id ) ; } public ASTIfStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { if ( jjtGetChild ( 0 ) . evaluate ( context ) ) { jjtGetChild ( 1 ) . render ( context , writer ) ; return true ; } int totalNodes = jjtGetNumChildren ( ) ; for ( int i = 2 ; i < totalNodes ; i ++ ) { if ( jjtGetChild ( i ) . evaluate ( context ) ) { jjtGetChild ( i ) . render ( context , writer ) ; return true ; } } return true ; } public void process ( InternalContextAdapter context , ParserVisitor visitor ) { } } 	1	['5', '2', '0', '10', '12', '10', '4', '8', '5', '2', '62', '0', '0', '0.9', '0.4', '1', '2', '11.4', '1', '0.6', '1']
package org . apache . velocity . app . event ; import org . apache . velocity . context . InternalEventContext ; import org . apache . velocity . context . Context ; public class EventCartridge implements ReferenceInsertionEventHandler , NullSetEventHandler , MethodExceptionEventHandler { private ReferenceInsertionEventHandler rieh = null ; private NullSetEventHandler nseh = null ; private MethodExceptionEventHandler meeh = null ; public boolean addEventHandler ( EventHandler ev ) { if ( ev == null ) { return false ; } boolean found = false ; if ( ev instanceof ReferenceInsertionEventHandler ) { rieh = ( ReferenceInsertionEventHandler ) ev ; found = true ; } if ( ev instanceof NullSetEventHandler ) { nseh = ( NullSetEventHandler ) ev ; found = true ; } if ( ev instanceof MethodExceptionEventHandler ) { meeh = ( MethodExceptionEventHandler ) ev ; found = true ; } return found ; } public boolean removeEventHandler ( EventHandler ev ) { if ( ev == null ) { return false ; } boolean found = false ; if ( ev == rieh ) { rieh = null ; found = true ; } if ( ev == nseh ) { nseh = null ; found = true ; } if ( ev == meeh ) { meeh = null ; found = true ; } return found ; } public Object referenceInsert ( String reference , Object value ) { if ( rieh == null ) { return value ; } return rieh . referenceInsert ( reference , value ) ; } public boolean shouldLogOnNullSet ( String lhs , String rhs ) { if ( nseh == null ) { return true ; } return nseh . shouldLogOnNullSet ( lhs , rhs ) ; } public Object methodException ( Class claz , String method , Exception e ) throws Exception { if ( meeh == null ) { throw e ; } return meeh . methodException ( claz , method , e ) ; } public final boolean attachToContext ( Context context ) { if ( context instanceof InternalEventContext ) { InternalEventContext iec = ( InternalEventContext ) context ; iec . attachEventCartridge ( this ) ; return true ; } else { return false ; } } } 	1	['7', '1', '0', '16', '12', '0', '11', '6', '7', '0.5', '140', '1', '3', '0', '0.326530612', '0', '0', '18.57142857', '5', '2.4286', '2']
package org . apache . velocity . exception ; public class MethodInvocationException extends VelocityException { private String methodName = "" ; private String referenceName = "" ; private Throwable wrapped = null ; public MethodInvocationException ( String message , Throwable e , String methodName ) { super ( message ) ; this . wrapped = e ; this . methodName = methodName ; } public String getMethodName ( ) { return methodName ; } public Throwable getWrappedThrowable ( ) { return wrapped ; } public void setReferenceName ( String ref ) { referenceName = ref ; } public String getReferenceName ( ) { return referenceName ; } } 	1	['5', '4', '0', '44', '6', '0', '43', '1', '5', '0.666666667', '40', '1', '0', '0.764705882', '0.533333333', '0', '0', '6.4', '1', '0.8', '2']
package org . apache . velocity . util . introspection ; import java . util . Map ; import java . util . List ; import java . util . Hashtable ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; public class ClassMap { private static final class CacheMiss { } private static final CacheMiss CACHE_MISS = new CacheMiss ( ) ; private static final Object OBJECT = new Object ( ) ; private Class clazz ; private Map methodCache = new Hashtable ( ) ; private MethodMap methodMap = new MethodMap ( ) ; public ClassMap ( Class clazz ) { this . clazz = clazz ; populateMethodCache ( ) ; } private ClassMap ( ) { } Class getCachedClass ( ) { return clazz ; } public Method findMethod ( String name , Object [ ] params ) throws MethodMap . AmbiguousException { String methodKey = makeMethodKey ( name , params ) ; Object cacheEntry = methodCache . get ( methodKey ) ; if ( cacheEntry == CACHE_MISS ) { return null ; } if ( cacheEntry == null ) { try { cacheEntry = methodMap . find ( name , params ) ; } catch ( MethodMap . AmbiguousException ae ) { methodCache . put ( methodKey , CACHE_MISS ) ; throw ae ; } if ( cacheEntry == null ) { methodCache . put ( methodKey , CACHE_MISS ) ; } else { methodCache . put ( methodKey , cacheEntry ) ; } } return ( Method ) cacheEntry ; } private void populateMethodCache ( ) { StringBuffer methodKey ; Method [ ] methods = getAccessibleMethods ( clazz ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; Method publicMethod = getPublicMethod ( method ) ; if ( publicMethod != null ) { methodMap . add ( publicMethod ) ; methodCache . put ( makeMethodKey ( publicMethod ) , publicMethod ) ; } } } private String makeMethodKey ( Method method ) { Class [ ] parameterTypes = method . getParameterTypes ( ) ; StringBuffer methodKey = new StringBuffer ( method . getName ( ) ) ; for ( int j = 0 ; j < parameterTypes . length ; j ++ ) { if ( parameterTypes [ j ] . isPrimitive ( ) ) { if ( parameterTypes [ j ] . equals ( Boolean . TYPE ) ) methodKey . append ( "java.lang.Boolean" ) ; else if ( parameterTypes [ j ] . equals ( Byte . TYPE ) ) methodKey . append ( "java.lang.Byte" ) ; else if ( parameterTypes [ j ] . equals ( Character . TYPE ) ) methodKey . append ( "java.lang.Character" ) ; else if ( parameterTypes [ j ] . equals ( Double . TYPE ) ) methodKey . append ( "java.lang.Double" ) ; else if ( parameterTypes [ j ] . equals ( Float . TYPE ) ) methodKey . append ( "java.lang.Float" ) ; else if ( parameterTypes [ j ] . equals ( Integer . TYPE ) ) methodKey . append ( "java.lang.Integer" ) ; else if ( parameterTypes [ j ] . equals ( Long . TYPE ) ) methodKey . append ( "java.lang.Long" ) ; else if ( parameterTypes [ j ] . equals ( Short . TYPE ) ) methodKey . append ( "java.lang.Short" ) ; } else { methodKey . append ( parameterTypes [ j ] . getName ( ) ) ; } } return methodKey . toString ( ) ; } private static String makeMethodKey ( String method , Object [ ] params ) { StringBuffer methodKey = new StringBuffer ( ) . append ( method ) ; for ( int j = 0 ; j < params . length ; j ++ ) { Object arg = params [ j ] ; if ( arg == null ) { arg = OBJECT ; } methodKey . append ( arg . getClass ( ) . getName ( ) ) ; } return methodKey . toString ( ) ; } private static Method [ ] getAccessibleMethods ( Class clazz ) { Method [ ] methods = clazz . getMethods ( ) ; if ( Modifier . isPublic ( clazz . getModifiers ( ) ) ) { return methods ; } MethodInfo [ ] methodInfos = new MethodInfo [ methods . length ] ; for ( int i = methods . length ; i -- > 0 ; ) { methodInfos [ i ] = new MethodInfo ( methods [ i ] ) ; } int upcastCount = getAccessibleMethods ( clazz , methodInfos , 0 ) ; if ( upcastCount < methods . length ) { methods = new Method [ upcastCount ] ; } int j = 0 ; for ( int i = 0 ; i < methodInfos . length ; ++ i ) { MethodInfo methodInfo = methodInfos [ i ] ; if ( methodInfo . upcast ) { methods [ j ++ ] = methodInfo . method ; } } return methods ; } private static int getAccessibleMethods ( Class clazz , MethodInfo [ ] methodInfos , int upcastCount ) { int l = methodInfos . length ; if ( Modifier . isPublic ( clazz . getModifiers ( ) ) ) { for ( int i = 0 ; i < l && upcastCount < l ; ++ i ) { try { MethodInfo methodInfo = methodInfos [ i ] ; if ( ! methodInfo . upcast ) { methodInfo . tryUpcasting ( clazz ) ; upcastCount ++ ; } } catch ( NoSuchMethodException e ) { } } if ( upcastCount == l ) { return upcastCount ; } } Class superclazz = clazz . getSuperclass ( ) ; if ( superclazz != null ) { upcastCount = getAccessibleMethods ( superclazz , methodInfos , upcastCount ) ; if ( upcastCount == l ) { return upcastCount ; } } Class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = interfaces . length ; i -- > 0 ; ) { upcastCount = getAccessibleMethods ( interfaces [ i ] , methodInfos , upcastCount ) ; if ( upcastCount == l ) { return upcastCount ; } } return upcastCount ; } public static Method getPublicMethod ( Method method ) { Class clazz = method . getDeclaringClass ( ) ; if ( ( clazz . getModifiers ( ) & Modifier . PUBLIC ) != 0 ) { return method ; } return getPublicMethod ( clazz , method . getName ( ) , method . getParameterTypes ( ) ) ; } private static Method getPublicMethod ( Class clazz , String name , Class [ ] paramTypes ) { if ( ( clazz . getModifiers ( ) & Modifier . PUBLIC ) != 0 ) { try { return clazz . getMethod ( name , paramTypes ) ; } catch ( NoSuchMethodException e ) { return null ; } } Class superclazz = clazz . getSuperclass ( ) ; if ( superclazz != null ) { Method superclazzMethod = getPublicMethod ( superclazz , name , paramTypes ) ; if ( superclazzMethod != null ) { return superclazzMethod ; } } Class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; ++ i ) { Method interfaceMethod = getPublicMethod ( interfaces [ i ] , name , paramTypes ) ; if ( interfaceMethod != null ) { return interfaceMethod ; } } return null ; } private static final class MethodInfo { Method method ; String name ; Class [ ] parameterTypes ; boolean upcast ; MethodInfo ( Method method ) { this . method = null ; name = method . getName ( ) ; parameterTypes = method . getParameterTypes ( ) ; upcast = false ; } void tryUpcasting ( Class clazz ) throws NoSuchMethodException { method = clazz . getMethod ( name , parameterTypes ) ; name = null ; parameterTypes = null ; upcast = true ; } } } 	1	['12', '1', '0', '6', '39', '46', '1', '5', '3', '0.8', '510', '1', '2', '0', '0.227272727', '0', '0', '41.08333333', '11', '3.5', '2']
package org . apache . velocity . util ; import java . io . File ; import java . io . FileReader ; import java . io . ByteArrayOutputStream ; import java . io . PrintWriter ; import java . net . MalformedURLException ; import java . util . ArrayList ; import java . util . Hashtable ; import java . util . List ; import java . util . StringTokenizer ; import java . util . Map ; public class StringUtils { private static final String EOL = System . getProperty ( "line.separator" ) ; private static final int EOL_LENGTH = EOL . length ( ) ; public String concat ( List list ) { StringBuffer sb = new StringBuffer ( ) ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { sb . append ( list . get ( i ) . toString ( ) ) ; } return sb . toString ( ) ; } static public String getPackageAsPath ( String pckge ) { return pckge . replace ( '.' , File . separator . charAt ( 0 ) ) + File . separator ; } static public String removeUnderScores ( String data ) { String temp = null ; StringBuffer out = new StringBuffer ( ) ; temp = data ; StringTokenizer st = new StringTokenizer ( temp , "_" ) ; while ( st . hasMoreTokens ( ) ) { String element = ( String ) st . nextElement ( ) ; out . append ( firstLetterCaps ( element ) ) ; } return out . toString ( ) ; } static public String removeAndHump ( String data ) { return removeAndHump ( data , "_" ) ; } static public String removeAndHump ( String data , String replaceThis ) { String temp = null ; StringBuffer out = new StringBuffer ( ) ; temp = data ; StringTokenizer st = new StringTokenizer ( temp , replaceThis ) ; while ( st . hasMoreTokens ( ) ) { String element = ( String ) st . nextElement ( ) ; out . append ( capitalizeFirstLetter ( element ) ) ; } return out . toString ( ) ; } static public String firstLetterCaps ( String data ) { String firstLetter = data . substring ( 0 , 1 ) . toUpperCase ( ) ; String restLetters = data . substring ( 1 ) . toLowerCase ( ) ; return firstLetter + restLetters ; } static public String capitalizeFirstLetter ( String data ) { String firstLetter = data . substring ( 0 , 1 ) . toUpperCase ( ) ; String restLetters = data . substring ( 1 ) ; return firstLetter + restLetters ; } public static String [ ] split ( String line , String delim ) { List list = new ArrayList ( ) ; StringTokenizer t = new StringTokenizer ( line , delim ) ; while ( t . hasMoreTokens ( ) ) { list . add ( t . nextToken ( ) ) ; } return ( String [ ] ) list . toArray ( new String [ list . size ( ) ] ) ; } public static String chop ( String s , int i ) { return chop ( s , i , EOL ) ; } public static String chop ( String s , int i , String eol ) { if ( i == 0 || s == null || eol == null ) { return s ; } int length = s . length ( ) ; if ( eol . length ( ) == 2 && s . endsWith ( eol ) ) { length -= 2 ; i -= 1 ; } if ( i > 0 ) { length -= i ; } if ( length < 0 ) { length = 0 ; } return s . substring ( 0 , length ) ; } public static StringBuffer stringSubstitution ( String argStr , Hashtable vars ) { return stringSubstitution ( argStr , ( Map ) vars ) ; } public static StringBuffer stringSubstitution ( String argStr , Map vars ) { StringBuffer argBuf = new StringBuffer ( ) ; for ( int cIdx = 0 ; cIdx < argStr . length ( ) ; ) { char ch = argStr . charAt ( cIdx ) ; switch ( ch ) { case '$' : StringBuffer nameBuf = new StringBuffer ( ) ; for ( ++ cIdx ; cIdx < argStr . length ( ) ; ++ cIdx ) { ch = argStr . charAt ( cIdx ) ; if ( ch == '_' || Character . isLetterOrDigit ( ch ) ) nameBuf . append ( ch ) ; else break ; } if ( nameBuf . length ( ) > 0 ) { String value = ( String ) vars . get ( nameBuf . toString ( ) ) ; if ( value != null ) { argBuf . append ( value ) ; } } break ; default : argBuf . append ( ch ) ; ++ cIdx ; break ; } } return argBuf ; } public static String fileContentsToString ( String file ) { String contents = "" ; File f = new File ( file ) ; if ( f . exists ( ) ) { try { FileReader fr = new FileReader ( f ) ; char [ ] template = new char [ ( int ) f . length ( ) ] ; fr . read ( template ) ; contents = new String ( template ) ; } catch ( Exception e ) { System . out . println ( e ) ; e . printStackTrace ( ) ; } } return contents ; } public static String collapseNewlines ( String argStr ) { char last = argStr . charAt ( 0 ) ; StringBuffer argBuf = new StringBuffer ( ) ; for ( int cIdx = 0 ; cIdx < argStr . length ( ) ; cIdx ++ ) { char ch = argStr . charAt ( cIdx ) ; if ( ch != '\n' || last != '\n' ) { argBuf . append ( ch ) ; last = ch ; } } return argBuf . toString ( ) ; } public static String collapseSpaces ( String argStr ) { char last = argStr . charAt ( 0 ) ; StringBuffer argBuf = new StringBuffer ( ) ; for ( int cIdx = 0 ; cIdx < argStr . length ( ) ; cIdx ++ ) { char ch = argStr . charAt ( cIdx ) ; if ( ch != ' ' || last != ' ' ) { argBuf . append ( ch ) ; last = ch ; } } return argBuf . toString ( ) ; } public static final String sub ( String line , String oldString , String newString ) { int i = 0 ; if ( ( i = line . indexOf ( oldString , i ) ) >= 0 ) { char [ ] line2 = line . toCharArray ( ) ; char [ ] newString2 = newString . toCharArray ( ) ; int oLength = oldString . length ( ) ; StringBuffer buf = new StringBuffer ( line2 . length ) ; buf . append ( line2 , 0 , i ) . append ( newString2 ) ; i += oLength ; int j = i ; while ( ( i = line . indexOf ( oldString , i ) ) > 0 ) { buf . append ( line2 , j , i - j ) . append ( newString2 ) ; i += oLength ; j = i ; } buf . append ( line2 , j , line2 . length - j ) ; return buf . toString ( ) ; } return line ; } public static final String stackTrace ( Throwable e ) { String foo = null ; try { ByteArrayOutputStream ostr = new ByteArrayOutputStream ( ) ; e . printStackTrace ( new PrintWriter ( ostr , true ) ) ; foo = ostr . toString ( ) ; } catch ( Exception f ) { } return foo ; } public static final String normalizePath ( String path ) { String normalized = path ; if ( normalized . indexOf ( '\\' ) >= 0 ) { normalized = normalized . replace ( '\\' , '/' ) ; } if ( ! normalized . startsWith ( "/" ) ) { normalized = "/" + normalized ; } while ( true ) { int index = normalized . indexOf ( "//" ) ; if ( index < 0 ) break ; normalized = normalized . substring ( 0 , index ) + normalized . substring ( index + 1 ) ; } while ( true ) { int index = normalized . indexOf ( "%20" ) ; if ( index < 0 ) break ; normalized = normalized . substring ( 0 , index ) + " " + normalized . substring ( index + 3 ) ; } while ( true ) { int index = normalized . indexOf ( "/./" ) ; if ( index < 0 ) break ; normalized = normalized . substring ( 0 , index ) + normalized . substring ( index + 2 ) ; } while ( true ) { int index = normalized . indexOf ( "/../" ) ; if ( index < 0 ) break ; if ( index == 0 ) return ( null ) ; int index2 = normalized . lastIndexOf ( '/' , index - 1 ) ; normalized = normalized . substring ( 0 , index2 ) + normalized . substring ( index + 3 ) ; } return ( normalized ) ; } public String select ( boolean state , String trueString , String falseString ) { if ( state ) { return trueString ; } else { return falseString ; } } public boolean allEmpty ( List list ) { int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( list . get ( i ) != null && list . get ( i ) . toString ( ) . length ( ) > 0 ) { return false ; } } return true ; } } 	1	['22', '1', '0', '13', '70', '229', '13', '0', '21', '0.976190476', '681', '1', '0', '0', '0.172619048', '0', '0', '29.86363636', '8', '2.6364', '1']
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . commons . collections . ExtendedProperties ; public class ClasspathResourceLoader extends ResourceLoader { public void init ( ExtendedProperties configuration ) { rsvc . info ( "ClasspathResourceLoader : initialization starting." ) ; rsvc . info ( "ClasspathResourceLoader : initialization complete." ) ; } public synchronized InputStream getResourceStream ( String name ) throws ResourceNotFoundException { InputStream result = null ; if ( name == null || name . length ( ) == 0 ) { throw new ResourceNotFoundException ( "No template name provided" ) ; } try { ClassLoader classLoader = this . getClass ( ) . getClassLoader ( ) ; result = classLoader . getResourceAsStream ( name ) ; } catch ( Exception fnfe ) { throw new ResourceNotFoundException ( fnfe . getMessage ( ) ) ; } return result ; } public boolean isSourceModified ( Resource resource ) { return false ; } public long getLastModified ( Resource resource ) { return 0 ; } } 	1	['5', '2', '0', '6', '13', '10', '0', '6', '5', '2', '51', '0', '0', '0.714285714', '0.45', '0', '0', '9.2', '1', '0.8', '1']
package org . apache . velocity . runtime ; public interface RuntimeConstants { public static final String RUNTIME_LOG = "runtime.log" ; public static final String RUNTIME_LOG_LOGSYSTEM = "runtime.log.logsystem" ; public static final String RUNTIME_LOG_LOGSYSTEM_CLASS = "runtime.log.logsystem.class" ; public static final String RUNTIME_LOG_ERROR_STACKTRACE = "runtime.log.error.stacktrace" ; public static final String RUNTIME_LOG_WARN_STACKTRACE = "runtime.log.warn.stacktrace" ; public static final String RUNTIME_LOG_INFO_STACKTRACE = "runtime.log.info.stacktrace" ; public static final String RUNTIME_LOG_REFERENCE_LOG_INVALID = "runtime.log.invalid.references" ; public final static String DEBUG_PREFIX = " [debug] " ; public final static String INFO_PREFIX = "  [info] " ; public final static String WARN_PREFIX = "  [warn] " ; public final static String ERROR_PREFIX = " [error] " ; public final static String UNKNOWN_PREFIX = " [unknown] " ; public final static String LOGSYSTEM_LOG4J_PATTERN = "runtime.log.logsystem.log4j.pattern" ; public final static String LOGSYSTEM_LOG4J_FILE_SIZE = "runtime.log.logsystem.log4j.file.size" ; public final static String LOGSYSTEM_LOG4J_FILE_BACKUPS = "runtime.log.logsystem.log4j.file.backups" ; public final static String LOGSYSTEM_LOG4J_SYSLOGD_HOST = "runtime.log.logsystem.log4j.syslogd.host" ; public final static String LOGSYSTEM_LOG4J_SYSLOGD_FACILITY = "runtime.log.logsystem.log4j.syslogd.facility" ; public final static String LOGSYSTEM_LOG4J_REMOTE_HOST = "runtime.log.logsystem.log4j.remote.host" ; public final static String LOGSYSTEM_LOG4J_REMOTE_PORT = "runtime.log.logsystem.log4j.remote.port" ; public final static String LOGSYSTEM_LOG4J_EMAIL_SERVER = "runtime.log.logsystem.log4j.email.server" ; public final static String LOGSYSTEM_LOG4J_EMAIL_FROM = "runtime.log.logsystem.log4j.email.from" ; public final static String LOGSYSTEM_LOG4J_EMAIL_TO = "runtime.log.logsystem.log4j.email.to" ; public final static String LOGSYSTEM_LOG4J_EMAIL_SUBJECT = "runtime.log.logsystem.log4j.email.subject" ; public final static String LOGSYSTEM_LOG4J_EMAIL_BUFFER_SIZE = "runtime.log.logsystem.log4j.email.buffer.size" ; public static final String COUNTER_NAME = "directive.foreach.counter.name" ; public static final String COUNTER_INITIAL_VALUE = "directive.foreach.counter.initial.value" ; public static String ERRORMSG_START = "directive.include.output.errormsg.start" ; public static String ERRORMSG_END = "directive.include.output.errormsg.end" ; public static String PARSE_DIRECTIVE_MAXDEPTH = "directive.parse.max.depth" ; public static String RESOURCE_MANAGER_CLASS = "resource.manager.class" ; public static String RESOURCE_MANAGER_CACHE_CLASS = "resource.manager.cache.class" ; public static final String RESOURCE_MANAGER_LOGWHENFOUND = "resource.manager.logwhenfound" ; public static final String RESOURCE_LOADER = "resource.loader" ; public static final String FILE_RESOURCE_LOADER_PATH = "file.resource.loader.path" ; public static final String FILE_RESOURCE_LOADER_CACHE = "file.resource.loader.cache" ; public static final String VM_LIBRARY = "velocimacro.library" ; public final static String VM_LIBRARY_AUTORELOAD = "velocimacro.library.autoreload" ; public static final String VM_PERM_ALLOW_INLINE = "velocimacro.permissions.allow.inline" ; public final static String VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL = "velocimacro.permissions.allow.inline.to.replace.global" ; public final static String VM_PERM_INLINE_LOCAL = "velocimacro.permissions.allow.inline.local.scope" ; public final static String VM_MESSAGES_ON = "velocimacro.messages.on" ; public final static String VM_CONTEXT_LOCALSCOPE = "velocimacro.context.localscope" ; public static String INTERPOLATE_STRINGLITERALS = "runtime.interpolate.string.literals" ; public static final String INPUT_ENCODING = "input.encoding" ; public static final String OUTPUT_ENCODING = "output.encoding" ; public static final String ENCODING_DEFAULT = "ISO-8859-1" ; final static String DEFAULT_RUNTIME_PROPERTIES = "org/apache/velocity/runtime/defaults/velocity.properties" ; final static String DEFAULT_RUNTIME_DIRECTIVES = "org/apache/velocity/runtime/defaults/directive.properties" ; final static int NUMBER_OF_PARSERS = 20 ; final static String PARSER_POOL_SIZE = "parser.pool.size" ; final static String UBERSPECT_CLASSNAME = "runtime.introspector.uberspect" ; } 	1	['0', '1', '0', '5', '0', '0', '5', '0', '0', '2', '51', '0', '0', '0', '0', '0', '0', '0', '0', '0', '3']
package org . apache . velocity . anakia ; public class Escape { public Escape ( ) { } public static final String getText ( String st ) { StringBuffer buff = new StringBuffer ( ) ; char [ ] block = st . toCharArray ( ) ; String stEntity = null ; int i , last ; for ( i = 0 , last = 0 ; i < block . length ; i ++ ) { switch ( block [ i ] ) { case '<' : stEntity = "&lt;" ; break ; case '>' : stEntity = "&gt;" ; break ; case '&' : stEntity = "&amp;" ; break ; case '"' : stEntity = "&quot;" ; break ; default : ; } if ( stEntity != null ) { buff . append ( block , last , i - last ) ; buff . append ( stEntity ) ; stEntity = null ; last = i + 1 ; } } if ( last < block . length ) { buff . append ( block , last , i - last ) ; } return buff . toString ( ) ; } } 	1	['2', '1', '0', '1', '8', '1', '1', '0', '2', '2', '75', '0', '0', '0', '0.5', '0', '0', '36.5', '9', '4.5', '1']
package org . apache . velocity . runtime ; import org . apache . velocity . Template ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . directive . VelocimacroProxy ; import java . util . Vector ; import java . util . Map ; import java . util . HashMap ; public class VelocimacroFactory { private RuntimeServices rsvc = null ; private VelocimacroManager vmManager = null ; private boolean replaceAllowed = false ; private boolean addNewAllowed = true ; private boolean templateLocal = false ; private boolean blather = false ; private boolean autoReloadLibrary = false ; private Vector macroLibVec = null ; private Map libModMap ; public VelocimacroFactory ( RuntimeServices rs ) { this . rsvc = rs ; libModMap = new HashMap ( ) ; vmManager = new VelocimacroManager ( rsvc ) ; } public void initVelocimacro ( ) { synchronized ( this ) { setReplacementPermission ( true ) ; setBlather ( true ) ; logVMMessageInfo ( "Velocimacro : initialization starting." ) ; vmManager . setNamespaceUsage ( false ) ; Object libfiles = rsvc . getProperty ( RuntimeConstants . VM_LIBRARY ) ; if ( libfiles != null ) { if ( libfiles instanceof Vector ) { macroLibVec = ( Vector ) libfiles ; } else if ( libfiles instanceof String ) { macroLibVec = new Vector ( ) ; macroLibVec . addElement ( libfiles ) ; } for ( int i = 0 ; i < macroLibVec . size ( ) ; i ++ ) { String lib = ( String ) macroLibVec . elementAt ( i ) ; if ( lib != null && ! lib . equals ( "" ) ) { vmManager . setRegisterFromLib ( true ) ; logVMMessageInfo ( "Velocimacro : adding VMs from " + "VM library template : " + lib ) ; try { Template template = rsvc . getTemplate ( lib ) ; Twonk twonk = new Twonk ( ) ; twonk . template = template ; twonk . modificationTime = template . getLastModified ( ) ; libModMap . put ( lib , twonk ) ; } catch ( Exception e ) { logVMMessageInfo ( "Velocimacro : error using  VM " + "library template " + lib + " : " + e ) ; } logVMMessageInfo ( "Velocimacro :  VM library template " + "macro registration complete." ) ; vmManager . setRegisterFromLib ( false ) ; } } } setAddMacroPermission ( true ) ; if ( ! rsvc . getBoolean ( RuntimeConstants . VM_PERM_ALLOW_INLINE , true ) ) { setAddMacroPermission ( false ) ; logVMMessageInfo ( "Velocimacro : allowInline = false : VMs can not " + "be defined inline in templates" ) ; } else { logVMMessageInfo ( "Velocimacro : allowInline = true : VMs can be " + "defined inline in templates" ) ; } setReplacementPermission ( false ) ; if ( rsvc . getBoolean ( RuntimeConstants . VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL , false ) ) { setReplacementPermission ( true ) ; logVMMessageInfo ( "Velocimacro : allowInlineToOverride = true : VMs " + "defined inline may replace previous VM definitions" ) ; } else { logVMMessageInfo ( "Velocimacro : allowInlineToOverride = false : VMs " + "defined inline may NOT replace previous VM definitions" ) ; } vmManager . setNamespaceUsage ( true ) ; setTemplateLocalInline ( rsvc . getBoolean ( RuntimeConstants . VM_PERM_INLINE_LOCAL , false ) ) ; if ( getTemplateLocalInline ( ) ) { logVMMessageInfo ( "Velocimacro : allowInlineLocal = true : VMs " + "defined inline will be local to their defining template only." ) ; } else { logVMMessageInfo ( "Velocimacro : allowInlineLocal = false : VMs " + "defined inline will be  global in scope if allowed." ) ; } vmManager . setTemplateLocalInlineVM ( getTemplateLocalInline ( ) ) ; setBlather ( rsvc . getBoolean ( RuntimeConstants . VM_MESSAGES_ON , true ) ) ; if ( getBlather ( ) ) { logVMMessageInfo ( "Velocimacro : messages on  : VM system " + "will output logging messages" ) ; } else { logVMMessageInfo ( "Velocimacro : messages off : VM system will be quiet" ) ; } setAutoload ( rsvc . getBoolean ( RuntimeConstants . VM_LIBRARY_AUTORELOAD , false ) ) ; if ( getAutoload ( ) ) { logVMMessageInfo ( "Velocimacro : autoload on  : VM system " + "will automatically reload global library macros" ) ; } else { logVMMessageInfo ( "Velocimacro : autoload off  : VM system " + "will not automatically reload global library macros" ) ; } rsvc . info ( "Velocimacro : initialization complete." ) ; } return ; } public boolean addVelocimacro ( String name , String macroBody , String argArray [ ] , String sourceTemplate ) { if ( name == null || macroBody == null || argArray == null || sourceTemplate == null ) { logVMMessageWarn ( "Velocimacro : VM addition rejected : " + "programmer error : arg null" ) ; return false ; } if ( ! canAddVelocimacro ( name , sourceTemplate ) ) { return false ; } synchronized ( this ) { vmManager . addVM ( name , macroBody , argArray , sourceTemplate ) ; } if ( blather ) { String s = "#" + argArray [ 0 ] ; s += "(" ; for ( int i = 1 ; i < argArray . length ; i ++ ) { s += " " ; s += argArray [ i ] ; } s += " ) : source = " ; s += sourceTemplate ; logVMMessageInfo ( "Velocimacro : added new VM : " + s ) ; } return true ; } private boolean canAddVelocimacro ( String name , String sourceTemplate ) { if ( getAutoload ( ) ) { for ( int i = 0 ; i < macroLibVec . size ( ) ; i ++ ) { String lib = ( String ) macroLibVec . elementAt ( i ) ; if ( lib . equals ( sourceTemplate ) ) { return true ; } } } if ( ! addNewAllowed ) { logVMMessageWarn ( "Velocimacro : VM addition rejected : " + name + " : inline VMs not allowed." ) ; return false ; } if ( ! templateLocal ) { if ( isVelocimacro ( name , sourceTemplate ) && ! replaceAllowed ) { logVMMessageWarn ( "Velocimacro : VM addition rejected : " + name + " : inline not allowed to replace existing VM" ) ; return false ; } } return true ; } private void logVMMessageInfo ( String s ) { if ( blather ) rsvc . info ( s ) ; } private void logVMMessageWarn ( String s ) { if ( blather ) rsvc . warn ( s ) ; } public boolean isVelocimacro ( String vm , String sourceTemplate ) { synchronized ( this ) { if ( vmManager . get ( vm , sourceTemplate ) != null ) return true ; } return false ; } public Directive getVelocimacro ( String vmName , String sourceTemplate ) { VelocimacroProxy vp = null ; synchronized ( this ) { vp = vmManager . get ( vmName , sourceTemplate ) ; if ( vp != null && getAutoload ( ) ) { String lib = vmManager . getLibraryName ( vmName , sourceTemplate ) ; if ( lib != null ) { try { Twonk tw = ( Twonk ) libModMap . get ( lib ) ; if ( tw != null ) { Template template = tw . template ; long tt = tw . modificationTime ; long ft = template . getResourceLoader ( ) . getLastModified ( template ) ; if ( ft > tt ) { logVMMessageInfo ( "Velocimacro : autoload reload for VMs from " + "VM library template : " + lib ) ; tw . modificationTime = ft ; template = rsvc . getTemplate ( lib ) ; tw . template = template ; tw . modificationTime = template . getLastModified ( ) ; } } } catch ( Exception e ) { logVMMessageInfo ( "Velocimacro : error using  VM " + "library template " + lib + " : " + e ) ; } vp = vmManager . get ( vmName , sourceTemplate ) ; } } } return vp ; } public boolean dumpVMNamespace ( String namespace ) { return vmManager . dumpNamespace ( namespace ) ; } private void setTemplateLocalInline ( boolean b ) { templateLocal = b ; } private boolean getTemplateLocalInline ( ) { return templateLocal ; } private boolean setAddMacroPermission ( boolean arg ) { boolean b = addNewAllowed ; addNewAllowed = arg ; return b ; } private boolean setReplacementPermission ( boolean arg ) { boolean b = replaceAllowed ; replaceAllowed = arg ; return b ; } private void setBlather ( boolean b ) { blather = b ; } private boolean getBlather ( ) { return blather ; } private void setAutoload ( boolean b ) { autoReloadLibrary = b ; } private boolean getAutoload ( ) { return autoReloadLibrary ; } private class Twonk { public Template template ; public long modificationTime ; } } 	1	['17', '1', '0', '11', '47', '42', '2', '10', '6', '0.701388889', '688', '1', '2', '0', '0.364705882', '0', '0', '38.94117647', '12', '2.7647', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTAddNode extends SimpleNode { public ASTAddNode ( int id ) { super ( id ) ; } public ASTAddNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of addition operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of addition operation is not a valid type. " + "Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } return new Integer ( ( ( Integer ) left ) . intValue ( ) + ( ( Integer ) right ) . intValue ( ) ) ; } } 	1	['4', '2', '0', '10', '20', '6', '4', '8', '4', '2', '131', '0', '0', '0.931034483', '0.416666667', '1', '1', '31.75', '1', '0.5', '1']
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import java . util . List ; import java . util . ArrayList ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . NodeUtils ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . RuntimeServices ; public class Macro extends Directive { private static boolean debugMode = false ; public String getName ( ) { return "macro" ; } public int getType ( ) { return BLOCK ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException { return true ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws Exception { super . init ( rs , context , node ) ; return ; } public static void processAndRegister ( RuntimeServices rs , Node node , String sourceTemplate ) throws IOException , ParseException { int numArgs = node . jjtGetNumChildren ( ) ; if ( numArgs < 2 ) { rs . error ( "#macro error : Velocimacro must have name as 1st " + "argument to #macro(). #args = " + numArgs ) ; throw new MacroParseException ( "First argument to #macro() must be " + " macro name." ) ; } int firstType = node . jjtGetChild ( 0 ) . getType ( ) ; if ( firstType != ParserTreeConstants . JJTWORD ) { Token t = node . jjtGetChild ( 0 ) . getFirstToken ( ) ; throw new MacroParseException ( "First argument to #macro() must be a" + " token without surrounding \' or \", which specifies" + " the macro name.  Currently it is a " + ParserTreeConstants . jjtNodeName [ firstType ] ) ; } String argArray [ ] = getArgArray ( node ) ; List macroArray = getASTAsStringArray ( node . jjtGetChild ( numArgs - 1 ) ) ; StringBuffer temp = new StringBuffer ( ) ; for ( int i = 0 ; i < macroArray . size ( ) ; i ++ ) { temp . append ( macroArray . get ( i ) ) ; } String macroBody = temp . toString ( ) ; boolean bRet = rs . addVelocimacro ( argArray [ 0 ] , macroBody , argArray , sourceTemplate ) ; return ; } private static String [ ] getArgArray ( Node node ) { int numArgs = node . jjtGetNumChildren ( ) ; numArgs -- ; String argArray [ ] = new String [ numArgs ] ; int i = 0 ; while ( i < numArgs ) { argArray [ i ] = node . jjtGetChild ( i ) . getFirstToken ( ) . image ; if ( i > 0 ) { if ( argArray [ i ] . startsWith ( "$" ) ) { argArray [ i ] = argArray [ i ] . substring ( 1 , argArray [ i ] . length ( ) ) ; } } i ++ ; } if ( debugMode ) { System . out . println ( "Macro.getArgArray() : #args = " + numArgs ) ; System . out . print ( argArray [ 0 ] + "(" ) ; for ( i = 1 ; i < numArgs ; i ++ ) { System . out . print ( " " + argArray [ i ] ) ; } System . out . println ( " )" ) ; } return argArray ; } private static List getASTAsStringArray ( Node rootNode ) { Token t = rootNode . getFirstToken ( ) ; Token tLast = rootNode . getLastToken ( ) ; ArrayList list = new ArrayList ( ) ; t = rootNode . getFirstToken ( ) ; while ( t != tLast ) { list . add ( NodeUtils . tokenLiteral ( t ) ) ; t = t . next ; } list . add ( NodeUtils . tokenLiteral ( t ) ) ; return list ; } } 	1	['9', '2', '0', '11', '34', '34', '1', '10', '6', '0.75', '239', '1', '0', '0.5', '0.333333333', '0', '0', '25.44444444', '6', '1.4444', '2']
package org . apache . velocity . runtime . log ; import java . io . File ; import org . apache . log . Priority ; import org . apache . log . Logger ; import org . apache . log . Hierarchy ; import org . apache . log . LogTarget ; import org . apache . log . output . io . FileTarget ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; public class AvalonLogSystem implements LogSystem { private Logger logger = null ; private RuntimeServices rsvc = null ; public AvalonLogSystem ( ) { } public void init ( RuntimeServices rs ) throws Exception { this . rsvc = rs ; String loggerName = ( String ) rsvc . getProperty ( "runtime.log.logsystem.avalon.logger" ) ; if ( loggerName != null ) { this . logger = Hierarchy . getDefaultHierarchy ( ) . getLoggerFor ( loggerName ) ; } else { String logfile = ( String ) rsvc . getProperty ( RuntimeConstants . RUNTIME_LOG ) ; try { init ( logfile ) ; logVelocityMessage ( 0 , "AvalonLogSystem initialized using logfile '" + logfile + "'" ) ; } catch ( Exception e ) { System . out . println ( "PANIC : Error configuring AvalonLogSystem : " + e ) ; System . err . println ( "PANIC : Error configuring AvalonLogSystem : " + e ) ; throw new Exception ( "Unable to configure AvalonLogSystem : " + e ) ; } } } public void init ( String logFile ) throws Exception { FileTarget target = new FileTarget ( new File ( logFile ) , false , new VelocityFormatter ( "%{time} %{message}\\n%{throwable}" ) ) ; logger = Hierarchy . getDefaultHierarchy ( ) . getLoggerFor ( rsvc . toString ( ) ) ; logger . setPriority ( Priority . DEBUG ) ; logger . setLogTargets ( new LogTarget [ ] { target } ) ; } public void logVelocityMessage ( int level , String message ) { switch ( level ) { case LogSystem . WARN_ID : logger . warn ( RuntimeConstants . WARN_PREFIX + message ) ; break ; case LogSystem . INFO_ID : logger . info ( RuntimeConstants . INFO_PREFIX + message ) ; break ; case LogSystem . DEBUG_ID : logger . debug ( RuntimeConstants . DEBUG_PREFIX + message ) ; break ; case LogSystem . ERROR_ID : logger . error ( RuntimeConstants . ERROR_PREFIX + message ) ; break ; default : logger . info ( message ) ; break ; } } } 	1	['4', '1', '0', '10', '24', '0', '1', '9', '4', '0.166666667', '178', '1', '1', '0', '0.5', '0', '0', '43', '2', '1', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTFalse extends SimpleNode { private static Boolean value = Boolean . FALSE ; public ASTFalse ( int id ) { super ( id ) ; } public ASTFalse ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) { return false ; } public Object value ( InternalContextAdapter context ) { return value ; } } 	1	['6', '2', '0', '6', '9', '13', '4', '4', '5', '0.8', '28', '1', '0', '0.9', '0.4', '0', '0', '3.5', '1', '0.5', '1']
package org . apache . velocity . runtime ; import java . io . InputStream ; import java . io . File ; import java . io . IOException ; import java . io . Reader ; import java . util . Map ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Enumeration ; import java . util . HashMap ; import org . apache . velocity . Template ; import org . apache . velocity . runtime . log . LogManager ; import org . apache . velocity . runtime . log . LogSystem ; import org . apache . velocity . runtime . log . PrimordialLogSystem ; import org . apache . velocity . runtime . log . NullLogSystem ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . VelocimacroFactory ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . runtime . resource . ResourceManager ; import org . apache . velocity . util . SimplePool ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . util . introspection . Uberspect ; import org . apache . velocity . util . introspection . UberspectLoggable ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . commons . collections . ExtendedProperties ; public class RuntimeInstance implements RuntimeConstants , RuntimeServices { private VelocimacroFactory vmFactory = null ; private LogSystem logSystem = new PrimordialLogSystem ( ) ; private SimplePool parserPool ; private boolean initialized ; private ExtendedProperties overridingProperties = null ; private Hashtable runtimeDirectives ; private ExtendedProperties configuration = new ExtendedProperties ( ) ; private ResourceManager resourceManager = null ; private Introspector introspector = null ; private Map applicationAttributes = null ; private Uberspect uberSpect ; public RuntimeInstance ( ) { vmFactory = new VelocimacroFactory ( this ) ; introspector = new Introspector ( this ) ; applicationAttributes = new HashMap ( ) ; } public synchronized void init ( ) throws Exception { if ( initialized == false ) { info ( "************************************************************** " ) ; info ( "Starting Jakarta Velocity v1.4" ) ; info ( "RuntimeInstance initializing." ) ; initializeProperties ( ) ; initializeLogger ( ) ; initializeResourceManager ( ) ; initializeDirectives ( ) ; initializeParserPool ( ) ; initializeIntrospection ( ) ; vmFactory . initVelocimacro ( ) ; info ( "Velocity successfully started." ) ; initialized = true ; } } private void initializeIntrospection ( ) throws Exception { String rm = getString ( RuntimeConstants . UBERSPECT_CLASSNAME ) ; if ( rm != null && rm . length ( ) > 0 ) { Object o = null ; try { o = Class . forName ( rm ) . newInstance ( ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for Uberspect (" + rm + ") does not exist (or is not accessible to the current classlaoder." ; error ( err ) ; throw new Exception ( err ) ; } if ( ! ( o instanceof Uberspect ) ) { String err = "The specified class for Uberspect (" + rm + ") does not implement org.apache.velocity.util.introspector.Uberspect." + " Velocity not initialized correctly." ; error ( err ) ; throw new Exception ( err ) ; } uberSpect = ( Uberspect ) o ; if ( uberSpect instanceof UberspectLoggable ) { ( ( UberspectLoggable ) uberSpect ) . setRuntimeLogger ( this ) ; } uberSpect . init ( ) ; } else { String err = "It appears that no class was specified as the" + " Uberspect.  Please ensure that all configuration" + " information is correct." ; error ( err ) ; throw new Exception ( err ) ; } } private void setDefaultProperties ( ) { try { InputStream inputStream = getClass ( ) . getResourceAsStream ( '/' + DEFAULT_RUNTIME_PROPERTIES ) ; configuration . load ( inputStream ) ; info ( "Default Properties File: " + new File ( DEFAULT_RUNTIME_PROPERTIES ) . getPath ( ) ) ; } catch ( IOException ioe ) { System . err . println ( "Cannot get Velocity Runtime default properties!" ) ; } } public void setProperty ( String key , Object value ) { if ( overridingProperties == null ) { overridingProperties = new ExtendedProperties ( ) ; } overridingProperties . setProperty ( key , value ) ; } public void setConfiguration ( ExtendedProperties configuration ) { if ( overridingProperties == null ) { overridingProperties = configuration ; } else { if ( overridingProperties != configuration ) { overridingProperties . combine ( configuration ) ; } } } public void addProperty ( String key , Object value ) { if ( overridingProperties == null ) { overridingProperties = new ExtendedProperties ( ) ; } overridingProperties . addProperty ( key , value ) ; } public void clearProperty ( String key ) { if ( overridingProperties != null ) { overridingProperties . clearProperty ( key ) ; } } public Object getProperty ( String key ) { return configuration . getProperty ( key ) ; } private void initializeProperties ( ) { if ( configuration . isInitialized ( ) == false ) { setDefaultProperties ( ) ; } if ( overridingProperties != null ) { configuration . combine ( overridingProperties ) ; } } public void init ( Properties p ) throws Exception { overridingProperties = ExtendedProperties . convertProperties ( p ) ; init ( ) ; } public void init ( String configurationFile ) throws Exception { overridingProperties = new ExtendedProperties ( configurationFile ) ; init ( ) ; } private void initializeResourceManager ( ) throws Exception { String rm = getString ( RuntimeConstants . RESOURCE_MANAGER_CLASS ) ; if ( rm != null && rm . length ( ) > 0 ) { Object o = null ; try { o = Class . forName ( rm ) . newInstance ( ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for Resourcemanager (" + rm + ") does not exist (or is not accessible to the current classlaoder." ; error ( err ) ; throw new Exception ( err ) ; } if ( ! ( o instanceof ResourceManager ) ) { String err = "The specified class for ResourceManager (" + rm + ") does not implement org.apache.runtime.resource.ResourceManager." + " Velocity not initialized correctly." ; error ( err ) ; throw new Exception ( err ) ; } resourceManager = ( ResourceManager ) o ; resourceManager . initialize ( this ) ; } else { String err = "It appears that no class was specified as the" + " ResourceManager.  Please ensure that all configuration" + " information is correct." ; error ( err ) ; throw new Exception ( err ) ; } } private void initializeLogger ( ) throws Exception { if ( logSystem instanceof PrimordialLogSystem ) { PrimordialLogSystem pls = ( PrimordialLogSystem ) logSystem ; logSystem = LogManager . createLogSystem ( this ) ; if ( logSystem == null ) { logSystem = new NullLogSystem ( ) ; } else { pls . dumpLogMessages ( logSystem ) ; } } } private void initializeDirectives ( ) throws Exception { runtimeDirectives = new Hashtable ( ) ; Properties directiveProperties = new Properties ( ) ; InputStream inputStream = getClass ( ) . getResourceAsStream ( '/' + DEFAULT_RUNTIME_DIRECTIVES ) ; if ( inputStream == null ) throw new Exception ( "Error loading directive.properties! " + "Something is very wrong if these properties " + "aren't being located. Either your Velocity " + "distribution is incomplete or your Velocity " + "jar file is corrupted!" ) ; directiveProperties . load ( inputStream ) ; Enumeration directiveClasses = directiveProperties . elements ( ) ; while ( directiveClasses . hasMoreElements ( ) ) { String directiveClass = ( String ) directiveClasses . nextElement ( ) ; loadDirective ( directiveClass , "System" ) ; } String [ ] userdirective = configuration . getStringArray ( "userdirective" ) ; for ( int i = 0 ; i < userdirective . length ; i ++ ) { loadDirective ( userdirective [ i ] , "User" ) ; } } private void loadDirective ( String directiveClass , String caption ) { try { Object o = Class . forName ( directiveClass ) . newInstance ( ) ; if ( o instanceof Directive ) { Directive directive = ( Directive ) o ; runtimeDirectives . put ( directive . getName ( ) , directive ) ; info ( "Loaded " + caption + " Directive: " + directiveClass ) ; } else { error ( caption + " Directive " + directiveClass + " is not org.apache.velocity.runtime.directive.Directive." + " Ignoring. " ) ; } } catch ( Exception e ) { error ( "Exception Loading " + caption + " Directive: " + directiveClass + " : " + e ) ; } } private void initializeParserPool ( ) { int numParsers = getInt ( PARSER_POOL_SIZE , NUMBER_OF_PARSERS ) ; parserPool = new SimplePool ( numParsers ) ; for ( int i = 0 ; i < numParsers ; i ++ ) { parserPool . put ( createNewParser ( ) ) ; } info ( "Created: " + numParsers + " parsers." ) ; } public Parser createNewParser ( ) { Parser parser = new Parser ( this ) ; parser . setDirectives ( runtimeDirectives ) ; return parser ; } public SimpleNode parse ( Reader reader , String templateName ) throws ParseException { return parse ( reader , templateName , true ) ; } public SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException { SimpleNode ast = null ; Parser parser = ( Parser ) parserPool . get ( ) ; boolean madeNew = false ; if ( parser == null ) { error ( "Runtime : ran out of parsers. Creating new.  " + " Please increment the parser.pool.size property." + " The current value is too small." ) ; parser = createNewParser ( ) ; if ( parser != null ) { madeNew = true ; } } if ( parser != null ) { try { if ( dumpNamespace ) { dumpVMNamespace ( templateName ) ; } ast = parser . parse ( reader , templateName ) ; } finally { if ( ! madeNew ) { parserPool . put ( parser ) ; } } } else { error ( "Runtime : ran out of parsers and unable to create more." ) ; } return ast ; } public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return getTemplate ( name , getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ) ; } public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ( Template ) resourceManager . getResource ( name , ResourceManager . RESOURCE_TEMPLATE , encoding ) ; } public ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return getContent ( name , getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ) ; } public ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ( ContentResource ) resourceManager . getResource ( name , ResourceManager . RESOURCE_CONTENT , encoding ) ; } public String getLoaderNameForResource ( String resourceName ) { return resourceManager . getLoaderNameForResource ( resourceName ) ; } private boolean showStackTrace ( ) { if ( configuration . isInitialized ( ) ) { return getBoolean ( RUNTIME_LOG_WARN_STACKTRACE , false ) ; } else { return false ; } } private void log ( int level , Object message ) { String out ; if ( showStackTrace ( ) && ( message instanceof Throwable || message instanceof Exception ) ) { out = StringUtils . stackTrace ( ( Throwable ) message ) ; } else { out = message . toString ( ) ; } logSystem . logVelocityMessage ( level , out ) ; } public void warn ( Object message ) { log ( LogSystem . WARN_ID , message ) ; } public void info ( Object message ) { log ( LogSystem . INFO_ID , message ) ; } public void error ( Object message ) { log ( LogSystem . ERROR_ID , message ) ; } public void debug ( Object message ) { log ( LogSystem . DEBUG_ID , message ) ; } public String getString ( String key , String defaultValue ) { return configuration . getString ( key , defaultValue ) ; } public Directive getVelocimacro ( String vmName , String templateName ) { return vmFactory . getVelocimacro ( vmName , templateName ) ; } public boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) { return vmFactory . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public boolean isVelocimacro ( String vmName , String templateName ) { return vmFactory . isVelocimacro ( vmName , templateName ) ; } public boolean dumpVMNamespace ( String namespace ) { return vmFactory . dumpVMNamespace ( namespace ) ; } public String getString ( String key ) { return configuration . getString ( key ) ; } public int getInt ( String key ) { return configuration . getInt ( key ) ; } public int getInt ( String key , int defaultValue ) { return configuration . getInt ( key , defaultValue ) ; } public boolean getBoolean ( String key , boolean def ) { return configuration . getBoolean ( key , def ) ; } public ExtendedProperties getConfiguration ( ) { return configuration ; } public Introspector getIntrospector ( ) { return introspector ; } public Object getApplicationAttribute ( Object key ) { return applicationAttributes . get ( key ) ; } public Object setApplicationAttribute ( Object key , Object o ) { return applicationAttributes . put ( key , o ) ; } public Uberspect getUberspect ( ) { return uberSpect ; } } 	1	['45', '1', '0', '27', '112', '730', '3', '24', '35', '0.83677686', '844', '1', '6', '0', '0.209876543', '0', '0', '17.51111111', '4', '1.2667', '3']
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . commons . collections . ExtendedProperties ; public class JarResourceLoader extends ResourceLoader { private Hashtable entryDirectory = new Hashtable ( 559 ) ; private Hashtable jarfiles = new Hashtable ( 89 ) ; public void init ( ExtendedProperties configuration ) { rsvc . info ( "JarResourceLoader : initialization starting." ) ; Vector paths = configuration . getVector ( "path" ) ; if ( paths == null || paths . size ( ) == 0 ) { paths = configuration . getVector ( "resource.path" ) ; if ( paths != null && paths . size ( ) > 0 ) { rsvc . warn ( "JarResourceLoader : you are using a deprecated configuration" + " property for the JarResourceLoader -> '<name>.resource.loader.resource.path'." + " Please change to the conventional '<name>.resource.loader.path'." ) ; } } rsvc . info ( "JarResourceLoader # of paths : " + paths . size ( ) ) ; for ( int i = 0 ; i < paths . size ( ) ; i ++ ) { loadJar ( ( String ) paths . get ( i ) ) ; } rsvc . info ( "JarResourceLoader : initialization complete." ) ; } private void loadJar ( String path ) { rsvc . info ( "JarResourceLoader : trying to load: " + path ) ; if ( path == null ) { rsvc . error ( "JarResourceLoader : can not load JAR - JAR path is null" ) ; } if ( ! path . startsWith ( "jar:" ) ) { rsvc . error ( "JarResourceLoader : JAR path must start with jar: -> " + "see java.net.JarURLConnection for information" ) ; } if ( ! path . endsWith ( "!/" ) ) { path += "!/" ; } closeJar ( path ) ; JarHolder temp = new JarHolder ( rsvc , path ) ; addEntries ( temp . getEntries ( ) ) ; jarfiles . put ( temp . getUrlPath ( ) , temp ) ; } private void closeJar ( String path ) { if ( jarfiles . containsKey ( path ) ) { JarHolder theJar = ( JarHolder ) jarfiles . get ( path ) ; theJar . close ( ) ; } } private synchronized void addEntries ( Hashtable entries ) { entryDirectory . putAll ( entries ) ; } public synchronized InputStream getResourceStream ( String source ) throws ResourceNotFoundException { InputStream results = null ; if ( source == null || source . length ( ) == 0 ) { throw new ResourceNotFoundException ( "Need to have a resource!" ) ; } String normalizedPath = StringUtils . normalizePath ( source ) ; if ( normalizedPath == null || normalizedPath . length ( ) == 0 ) { String msg = "JAR resource error : argument " + normalizedPath + " contains .. and may be trying to access " + "content outside of template root.  Rejected." ; rsvc . error ( "JarResourceLoader : " + msg ) ; throw new ResourceNotFoundException ( msg ) ; } if ( normalizedPath . startsWith ( "/" ) ) { normalizedPath = normalizedPath . substring ( 1 ) ; } if ( entryDirectory . containsKey ( normalizedPath ) ) { String jarurl = ( String ) entryDirectory . get ( normalizedPath ) ; if ( jarfiles . containsKey ( jarurl ) ) { JarHolder holder = ( JarHolder ) jarfiles . get ( jarurl ) ; results = holder . getResource ( normalizedPath ) ; return results ; } } throw new ResourceNotFoundException ( "JarResourceLoader Error: cannot find resource " + source ) ; } public boolean isSourceModified ( Resource resource ) { return true ; } public long getLastModified ( Resource resource ) { return 0 ; } } 	1	['8', '2', '0', '8', '35', '12', '0', '8', '5', '0.5', '262', '1', '0', '0.588235294', '0.375', '0', '0', '31.5', '6', '2', '1']
package org . apache . velocity . texen . util ; import java . io . File ; public class FileUtil { static public String mkdir ( String s ) { try { if ( ( new File ( s ) ) . mkdirs ( ) ) return "Created dir: " + s ; else return "Failed to create dir or dir already exists: " + s ; } catch ( Exception e ) { return e . toString ( ) ; } } public static File file ( String s ) { File f = new File ( s ) ; return f ; } public static File file ( String base , String s ) { File f = new File ( base , s ) ; return f ; } } 	1	['4', '1', '0', '0', '12', '6', '0', '0', '4', '2', '50', '0', '0', '0', '0.5', '0', '0', '11.5', '2', '1', '1']
package org . apache . velocity . context ; import java . util . HashMap ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . directive . VMProxyArg ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . app . event . EventCartridge ; public class VMContext implements InternalContextAdapter { HashMap vmproxyhash = new HashMap ( ) ; HashMap localcontext = new HashMap ( ) ; InternalContextAdapter innerContext = null ; InternalContextAdapter wrappedContext = null ; private boolean localcontextscope = false ; public VMContext ( InternalContextAdapter inner , RuntimeServices rsvc ) { localcontextscope = rsvc . getBoolean ( RuntimeConstants . VM_CONTEXT_LOCALSCOPE , false ) ; wrappedContext = inner ; innerContext = inner . getBaseContext ( ) ; } public Context getInternalUserContext ( ) { return innerContext . getInternalUserContext ( ) ; } public InternalContextAdapter getBaseContext ( ) { return innerContext . getBaseContext ( ) ; } public void addVMProxyArg ( VMProxyArg vmpa ) { String key = vmpa . getContextReference ( ) ; if ( vmpa . isConstant ( ) ) { localcontext . put ( key , vmpa . getObject ( wrappedContext ) ) ; } else { vmproxyhash . put ( key , vmpa ) ; } } public Object put ( String key , Object value ) { VMProxyArg vmpa = ( VMProxyArg ) vmproxyhash . get ( key ) ; if ( vmpa != null ) { return vmpa . setObject ( wrappedContext , value ) ; } else { if ( localcontextscope ) { return localcontext . put ( key , value ) ; } else { if ( localcontext . containsKey ( key ) ) { return localcontext . put ( key , value ) ; } else { return innerContext . put ( key , value ) ; } } } } public Object get ( String key ) { Object o = null ; VMProxyArg vmpa = ( VMProxyArg ) vmproxyhash . get ( key ) ; if ( vmpa != null ) { o = vmpa . getObject ( wrappedContext ) ; } else { if ( localcontextscope ) { o = localcontext . get ( key ) ; } else { o = localcontext . get ( key ) ; if ( o == null ) { o = innerContext . get ( key ) ; } } } return o ; } public boolean containsKey ( Object key ) { return false ; } public Object [ ] getKeys ( ) { return vmproxyhash . keySet ( ) . toArray ( ) ; } public Object remove ( Object key ) { return vmproxyhash . remove ( key ) ; } public void pushCurrentTemplateName ( String s ) { innerContext . pushCurrentTemplateName ( s ) ; } public void popCurrentTemplateName ( ) { innerContext . popCurrentTemplateName ( ) ; } public String getCurrentTemplateName ( ) { return innerContext . getCurrentTemplateName ( ) ; } public Object [ ] getTemplateNameStack ( ) { return innerContext . getTemplateNameStack ( ) ; } public IntrospectionCacheData icacheGet ( Object key ) { return innerContext . icacheGet ( key ) ; } public void icachePut ( Object key , IntrospectionCacheData o ) { innerContext . icachePut ( key , o ) ; } public EventCartridge attachEventCartridge ( EventCartridge ec ) { return innerContext . attachEventCartridge ( ec ) ; } public EventCartridge getEventCartridge ( ) { return innerContext . getEventCartridge ( ) ; } public void setCurrentResource ( Resource r ) { innerContext . setCurrentResource ( r ) ; } public Resource getCurrentResource ( ) { return innerContext . getCurrentResource ( ) ; } } 	1	['19', '1', '0', '11', '46', '0', '1', '10', '19', '0.7', '227', '0.2', '2', '0', '0.192982456', '0', '0', '10.68421053', '4', '1.3158', '3']
package org . apache . velocity . runtime . log ; import java . util . Enumeration ; import org . apache . log4j . Category ; import org . apache . log4j . RollingFileAppender ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . Priority ; import org . apache . log4j . Appender ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; public class SimpleLog4JLogSystem implements LogSystem { private RuntimeServices rsvc = null ; protected Category logger = null ; public SimpleLog4JLogSystem ( ) { } public void init ( RuntimeServices rs ) { rsvc = rs ; String categoryname = ( String ) rsvc . getProperty ( "runtime.log.logsystem.log4j.category" ) ; if ( categoryname != null ) { logger = Category . getInstance ( categoryname ) ; logVelocityMessage ( 0 , "SimpleLog4JLogSystem using category '" + categoryname + "'" ) ; return ; } String logfile = rsvc . getString ( RuntimeConstants . RUNTIME_LOG ) ; try { internalInit ( logfile ) ; logVelocityMessage ( 0 , "SimpleLog4JLogSystem initialized using logfile '" + logfile + "'" ) ; } catch ( Exception e ) { System . out . println ( "PANIC : error configuring SimpleLog4JLogSystem : " + e ) ; } } private void internalInit ( String logfile ) throws Exception { logger = Category . getInstance ( this . getClass ( ) . getName ( ) ) ; logger . setAdditivity ( false ) ; logger . setPriority ( Priority . DEBUG ) ; RollingFileAppender appender = new RollingFileAppender ( new PatternLayout ( "%d - %m%n" ) , logfile , true ) ; appender . setMaxBackupIndex ( 1 ) ; appender . setMaximumFileSize ( 100000 ) ; logger . addAppender ( appender ) ; } public void logVelocityMessage ( int level , String message ) { switch ( level ) { case LogSystem . WARN_ID : logger . warn ( message ) ; break ; case LogSystem . INFO_ID : logger . info ( message ) ; break ; case LogSystem . DEBUG_ID : logger . debug ( message ) ; break ; case LogSystem . ERROR_ID : logger . error ( message ) ; break ; default : logger . debug ( message ) ; break ; } } protected void finalize ( ) throws Throwable { shutdown ( ) ; } public void shutdown ( ) { Enumeration appenders = logger . getAllAppenders ( ) ; while ( appenders . hasMoreElements ( ) ) { Appender appender = ( Appender ) appenders . nextElement ( ) ; appender . close ( ) ; } } } 	1	['6', '1', '0', '8', '32', '0', '0', '8', '4', '0.4', '160', '1', '1', '0', '0.416666667', '0', '0', '25.33333333', '2', '1.3333', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . exception . ReferenceException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; public class SimpleNode implements Node { protected RuntimeServices rsvc = null ; protected Node parent ; protected Node [ ] children ; protected int id ; protected Parser parser ; protected int info ; public boolean state ; protected boolean invalid = false ; protected Token first , last ; public SimpleNode ( int i ) { id = i ; } public SimpleNode ( Parser p , int i ) { this ( i ) ; parser = p ; } public void jjtOpen ( ) { first = parser . getToken ( 1 ) ; } public void jjtClose ( ) { last = parser . getToken ( 0 ) ; } public void setFirstToken ( Token t ) { this . first = t ; } public Token getFirstToken ( ) { return first ; } public Token getLastToken ( ) { return last ; } public void jjtSetParent ( Node n ) { parent = n ; } public Node jjtGetParent ( ) { return parent ; } public void jjtAddChild ( Node n , int i ) { if ( children == null ) { children = new Node [ i + 1 ] ; } else if ( i >= children . length ) { Node c [ ] = new Node [ i + 1 ] ; System . arraycopy ( children , 0 , c , 0 , children . length ) ; children = c ; } children [ i ] = n ; } public Node jjtGetChild ( int i ) { return children [ i ] ; } public int jjtGetNumChildren ( ) { return ( children == null ) ? 0 : children . length ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object childrenAccept ( ParserVisitor visitor , Object data ) { if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { children [ i ] . jjtAccept ( visitor , data ) ; } } return data ; } public String toString ( String prefix ) { return prefix + toString ( ) ; } public void dump ( String prefix ) { System . out . println ( toString ( prefix ) ) ; if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { SimpleNode n = ( SimpleNode ) children [ i ] ; if ( n != null ) { n . dump ( prefix + " " ) ; } } } } public String literal ( ) { Token t = first ; StringBuffer sb = new StringBuffer ( t . image ) ; while ( t != last ) { t = t . next ; sb . append ( t . image ) ; } return sb . toString ( ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { rsvc = ( RuntimeServices ) data ; int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) { try { jjtGetChild ( i ) . init ( context , data ) ; } catch ( ReferenceException re ) { rsvc . error ( re ) ; } } return data ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { return false ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return null ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException { int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) jjtGetChild ( i ) . render ( context , writer ) ; return true ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { return null ; } public int getType ( ) { return id ; } public void setInfo ( int info ) { this . info = info ; } public int getInfo ( ) { return info ; } public void setInvalid ( ) { invalid = true ; } public boolean isInvalid ( ) { return invalid ; } public int getLine ( ) { return first . beginLine ; } public int getColumn ( ) { return first . beginColumn ; } } 	1	['29', '1', '40', '65', '43', '330', '57', '11', '29', '0.917857143', '318', '0.9', '6', '0', '0.179310345', '0', '0', '9.620689655', '4', '1.2414', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTLENode extends SimpleNode { public ASTLENode ( int id ) { super ( id ) ; } public ASTLENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '<=' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of '<=' operation is not a valid type. " + " It is a " + ( ! ( left instanceof Integer ) ? left . getClass ( ) : right . getClass ( ) ) + ". Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } return ( ( Integer ) left ) . intValue ( ) <= ( ( Integer ) right ) . intValue ( ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '10', '22', '10', '4', '8', '5', '2', '153', '0', '0', '0.9', '0.4', '1', '1', '29.6', '1', '0.6', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . * ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import org . apache . velocity . util . introspection . VelMethod ; import org . apache . velocity . util . introspection . Info ; import org . apache . velocity . exception . MethodInvocationException ; import java . lang . reflect . InvocationTargetException ; import org . apache . velocity . app . event . EventCartridge ; public class ASTMethod extends SimpleNode { private String methodName = "" ; private int paramCount = 0 ; public ASTMethod ( int id ) { super ( id ) ; } public ASTMethod ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { super . init ( context , data ) ; methodName = getFirstToken ( ) . image ; paramCount = jjtGetNumChildren ( ) - 1 ; return data ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { VelMethod method = null ; Object [ ] params = new Object [ paramCount ] ; try { IntrospectionCacheData icd = context . icacheGet ( this ) ; Class c = o . getClass ( ) ; if ( icd != null && icd . contextData == c ) { for ( int j = 0 ; j < paramCount ; j ++ ) params [ j ] = jjtGetChild ( j + 1 ) . value ( context ) ; method = ( VelMethod ) icd . thingy ; } else { for ( int j = 0 ; j < paramCount ; j ++ ) params [ j ] = jjtGetChild ( j + 1 ) . value ( context ) ; method = rsvc . getUberspect ( ) . getMethod ( o , methodName , params , new Info ( "" , 1 , 1 ) ) ; if ( method != null ) { icd = new IntrospectionCacheData ( ) ; icd . contextData = c ; icd . thingy = method ; context . icachePut ( this , icd ) ; } } if ( method == null ) return null ; } catch ( MethodInvocationException mie ) { throw mie ; } catch ( Exception e ) { rsvc . error ( "ASTMethod.execute() : exception from introspection : " + e ) ; return null ; } try { Object obj = method . invoke ( o , params ) ; if ( obj == null ) { if ( method . getReturnType ( ) == Void . TYPE ) return new String ( "" ) ; } return obj ; } catch ( InvocationTargetException ite ) { EventCartridge ec = context . getEventCartridge ( ) ; if ( ec != null && ite . getTargetException ( ) instanceof java . lang . Exception ) { try { return ec . methodException ( o . getClass ( ) , methodName , ( Exception ) ite . getTargetException ( ) ) ; } catch ( Exception e ) { throw new MethodInvocationException ( "Invocation of method '" + methodName + "' in  " + o . getClass ( ) + " threw exception " + e . getClass ( ) + " : " + e . getMessage ( ) , e , methodName ) ; } } else { throw new MethodInvocationException ( "Invocation of method '" + methodName + "' in  " + o . getClass ( ) + " threw exception " + ite . getTargetException ( ) . getClass ( ) + " : " + ite . getTargetException ( ) . getMessage ( ) , ite . getTargetException ( ) , methodName ) ; } } catch ( Exception e ) { rsvc . error ( "ASTMethod.execute() : exception invoking method '" + methodName + "' in " + o . getClass ( ) + " : " + e ) ; return null ; } } } 	1	['5', '2', '0', '17', '33', '0', '4', '15', '5', '0.25', '292', '1', '0', '0.9', '0.466666667', '1', '2', '57', '1', '0.6', '7']
package org . apache . velocity ; import java . util . HashMap ; import java . util . Map ; import org . apache . velocity . context . AbstractContext ; import org . apache . velocity . context . Context ; public class VelocityContext extends AbstractContext implements Cloneable { private Map context = null ; public VelocityContext ( ) { this ( null , null ) ; } public VelocityContext ( Map context ) { this ( context , null ) ; } public VelocityContext ( Context innerContext ) { this ( null , innerContext ) ; } public VelocityContext ( Map context , Context innerContext ) { super ( innerContext ) ; this . context = ( context == null ? new HashMap ( ) : context ) ; } public Object internalGet ( String key ) { return context . get ( key ) ; } public Object internalPut ( String key , Object value ) { return context . put ( key , value ) ; } public boolean internalContainsKey ( Object key ) { return context . containsKey ( key ) ; } public Object [ ] internalGetKeys ( ) { return context . keySet ( ) . toArray ( ) ; } public Object internalRemove ( Object key ) { return context . remove ( key ) ; } public Object clone ( ) { VelocityContext clone = null ; try { clone = ( VelocityContext ) super . clone ( ) ; clone . context = new HashMap ( context ) ; } catch ( CloneNotSupportedException ignored ) { } return clone ; } } 	1	['10', '3', '0', '22', '20', '3', '20', '2', '10', '0', '85', '1', '0', '0.777777778', '0.38', '1', '4', '7.4', '1', '0.6', '1']
package org . apache . velocity ; import java . io . InputStream ; import java . io . Writer ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . UnsupportedEncodingException ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . MethodInvocationException ; public class Template extends Resource { private boolean initialized = false ; private Exception errorCondition = null ; public Template ( ) { } public boolean process ( ) throws ResourceNotFoundException , ParseErrorException , Exception { data = null ; InputStream is = null ; errorCondition = null ; try { is = resourceLoader . getResourceStream ( name ) ; } catch ( ResourceNotFoundException rnfe ) { errorCondition = rnfe ; throw rnfe ; } if ( is != null ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; data = rsvc . parse ( br , name ) ; initDocument ( ) ; return true ; } catch ( UnsupportedEncodingException uce ) { String msg = "Template.process : Unsupported input encoding : " + encoding + " for template " + name ; errorCondition = new ParseErrorException ( msg ) ; throw errorCondition ; } catch ( ParseException pex ) { errorCondition = new ParseErrorException ( pex . getMessage ( ) ) ; throw errorCondition ; } catch ( Exception e ) { errorCondition = e ; throw e ; } finally { is . close ( ) ; } } else { errorCondition = new ResourceNotFoundException ( "Unknown resource error for resource " + name ) ; throw errorCondition ; } } public void initDocument ( ) throws Exception { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( new VelocityContext ( ) ) ; try { ica . pushCurrentTemplateName ( name ) ; ( ( SimpleNode ) data ) . init ( ica , rsvc ) ; } finally { ica . popCurrentTemplateName ( ) ; } } public void merge ( Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { if ( errorCondition != null ) { throw errorCondition ; } if ( data != null ) { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( context ) ; try { ica . pushCurrentTemplateName ( name ) ; ica . setCurrentResource ( this ) ; ( ( SimpleNode ) data ) . render ( ica , writer ) ; } finally { ica . popCurrentTemplateName ( ) ; ica . setCurrentResource ( null ) ; } } else { String msg = "Template.merge() failure. The document is null, " + "most likely due to parsing error." ; rsvc . error ( msg ) ; throw new Exception ( msg ) ; } } } 	1	['4', '2', '0', '33', '25', '0', '21', '13', '4', '0.666666667', '214', '1', '0', '0.842105263', '0.5', '1', '1', '52', '1', '0.75', '2']
package org . apache . velocity . exception ; public class ParseErrorException extends VelocityException { public ParseErrorException ( String exceptionMessage ) { super ( exceptionMessage ) ; } } 	1	['1', '4', '0', '26', '2', '0', '25', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '3']
package org . apache . velocity . runtime . resource . loader ; import java . io . File ; import java . io . InputStream ; import java . io . FileInputStream ; import java . io . BufferedInputStream ; import java . io . FileNotFoundException ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . commons . collections . ExtendedProperties ; public class FileResourceLoader extends ResourceLoader { private Vector paths = null ; private Hashtable templatePaths = new Hashtable ( ) ; public void init ( ExtendedProperties configuration ) { rsvc . info ( "FileResourceLoader : initialization starting." ) ; paths = configuration . getVector ( "path" ) ; int sz = paths . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { rsvc . info ( "FileResourceLoader : adding path '" + ( String ) paths . get ( i ) + "'" ) ; } rsvc . info ( "FileResourceLoader : initialization complete." ) ; } public synchronized InputStream getResourceStream ( String templateName ) throws ResourceNotFoundException { if ( templateName == null || templateName . length ( ) == 0 ) { throw new ResourceNotFoundException ( "Need to specify a file name or file path!" ) ; } String template = StringUtils . normalizePath ( templateName ) ; if ( template == null || template . length ( ) == 0 ) { String msg = "File resource error : argument " + template + " contains .. and may be trying to access " + "content outside of template root.  Rejected." ; rsvc . error ( "FileResourceLoader : " + msg ) ; throw new ResourceNotFoundException ( msg ) ; } if ( template . startsWith ( "/" ) ) { template = template . substring ( 1 ) ; } int size = paths . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { String path = ( String ) paths . get ( i ) ; InputStream inputStream = findTemplate ( path , template ) ; if ( inputStream != null ) { templatePaths . put ( templateName , path ) ; return inputStream ; } } String msg = "FileResourceLoader Error: cannot find resource " + template ; throw new ResourceNotFoundException ( msg ) ; } private InputStream findTemplate ( String path , String template ) { try { File file = new File ( path , template ) ; if ( file . canRead ( ) ) { return new BufferedInputStream ( new FileInputStream ( file . getAbsolutePath ( ) ) ) ; } else { return null ; } } catch ( FileNotFoundException fnfe ) { return null ; } } public boolean isSourceModified ( Resource resource ) { boolean modified = true ; String fileName = resource . getName ( ) ; String path = ( String ) templatePaths . get ( fileName ) ; File currentFile = null ; for ( int i = 0 ; currentFile == null && i < paths . size ( ) ; i ++ ) { String testPath = ( String ) paths . get ( i ) ; File testFile = new File ( testPath , fileName ) ; if ( testFile . canRead ( ) ) { currentFile = testFile ; } } File file = new File ( path , fileName ) ; if ( currentFile == null || ! file . exists ( ) ) { } else if ( currentFile . equals ( file ) && file . canRead ( ) ) { modified = ( file . lastModified ( ) != resource . getLastModified ( ) ) ; } return modified ; } public long getLastModified ( Resource resource ) { String path = ( String ) templatePaths . get ( resource . getName ( ) ) ; File file = new File ( path , resource . getName ( ) ) ; if ( file . canRead ( ) ) { return file . lastModified ( ) ; } else { return 0 ; } } } 	1	['6', '2', '0', '7', '33', '0', '0', '7', '5', '0.4', '279', '1', '0', '0.666666667', '0.458333333', '1', '1', '45.16666667', '9', '2.6667', '2']
package org . apache . velocity . runtime . resource ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeServices ; public interface ResourceCache { public void initialize ( RuntimeServices rs ) ; public Resource get ( Object resourceKey ) ; public Resource put ( Object resourceKey , Resource resource ) ; public Resource remove ( Object resourceKey ) ; public Iterator enumerateKeys ( ) ; } 	1	['5', '1', '0', '4', '5', '10', '2', '2', '5', '2', '5', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . parser . node ; import java . util . ArrayList ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTObjectArray extends SimpleNode { public ASTObjectArray ( int id ) { super ( id ) ; } public ASTObjectArray ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { int size = jjtGetNumChildren ( ) ; ArrayList objectArray = new ArrayList ( ) ; for ( int i = 0 ; i < size ; i ++ ) { objectArray . add ( jjtGetChild ( i ) . value ( context ) ) ; } return objectArray ; } } 	1	['4', '2', '0', '8', '12', '6', '4', '6', '4', '2', '42', '0', '0', '0.931034483', '0.416666667', '1', '1', '9.5', '1', '0.5', '1']
package org . apache . velocity . runtime . resource ; import java . io . StringWriter ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import org . apache . velocity . exception . ResourceNotFoundException ; public class ContentResource extends Resource { public ContentResource ( ) { } public boolean process ( ) throws ResourceNotFoundException { BufferedReader reader = null ; try { StringWriter sw = new StringWriter ( ) ; reader = new BufferedReader ( new InputStreamReader ( resourceLoader . getResourceStream ( name ) , encoding ) ) ; char buf [ ] = new char [ 1024 ] ; int len = 0 ; while ( ( len = reader . read ( buf , 0 , 1024 ) ) != - 1 ) sw . write ( buf , 0 , len ) ; setData ( sw . toString ( ) ) ; return true ; } catch ( ResourceNotFoundException e ) { throw e ; } catch ( Exception e ) { rsvc . error ( "Cannot process content resource : " + e . toString ( ) ) ; return false ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( Exception ignored ) { } } } } } 	1	['2', '2', '0', '10', '17', '1', '6', '5', '2', '2', '87', '0', '0', '0.941176471', '1', '1', '1', '42.5', '1', '0.5', '1']
package org . apache . velocity . servlet ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . io . OutputStreamWriter ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . UnsupportedEncodingException ; import java . util . Properties ; import javax . servlet . ServletConfig ; import javax . servlet . ServletContext ; import javax . servlet . ServletException ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . velocity . Template ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . io . VelocityWriter ; import org . apache . velocity . util . SimplePool ; import org . apache . velocity . context . Context ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . MethodInvocationException ; public abstract class VelocityServlet extends HttpServlet { public static final String REQUEST = "req" ; public static final String RESPONSE = "res" ; public static final String CONTENT_TYPE = "default.contentType" ; public static final String DEFAULT_CONTENT_TYPE = "text/html" ; public static final String DEFAULT_OUTPUT_ENCODING = "ISO-8859-1" ; private static String defaultContentType ; protected static final String INIT_PROPS_KEY = "org.apache.velocity.properties" ; private static final String OLD_INIT_PROPS_KEY = "properties" ; private static SimplePool writerPool = new SimplePool ( 40 ) ; public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; initVelocity ( config ) ; defaultContentType = RuntimeSingleton . getString ( CONTENT_TYPE , DEFAULT_CONTENT_TYPE ) ; } protected void initVelocity ( ServletConfig config ) throws ServletException { try { Properties props = loadConfiguration ( config ) ; Velocity . init ( props ) ; } catch ( Exception e ) { throw new ServletException ( "Error initializing Velocity: " + e , e ) ; } } protected Properties loadConfiguration ( ServletConfig config ) throws IOException , FileNotFoundException { String propsFile = config . getInitParameter ( INIT_PROPS_KEY ) ; if ( propsFile == null || propsFile . length ( ) == 0 ) { ServletContext sc = config . getServletContext ( ) ; propsFile = config . getInitParameter ( OLD_INIT_PROPS_KEY ) ; if ( propsFile == null || propsFile . length ( ) == 0 ) { propsFile = sc . getInitParameter ( INIT_PROPS_KEY ) ; if ( propsFile == null || propsFile . length ( ) == 0 ) { propsFile = sc . getInitParameter ( OLD_INIT_PROPS_KEY ) ; if ( propsFile != null && propsFile . length ( ) > 0 ) { sc . log ( "Use of the properties initialization " + "parameter '" + OLD_INIT_PROPS_KEY + "' has " + "been deprecated by '" + INIT_PROPS_KEY + '\'' ) ; } } } else { sc . log ( "Use of the properties initialization parameter '" + OLD_INIT_PROPS_KEY + "' has been deprecated by '" + INIT_PROPS_KEY + '\'' ) ; } } Properties p = new Properties ( ) ; if ( propsFile != null ) { String realPath = getServletContext ( ) . getRealPath ( propsFile ) ; if ( realPath != null ) { propsFile = realPath ; } p . load ( new FileInputStream ( propsFile ) ) ; } return p ; } public void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doRequest ( request , response ) ; } public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doRequest ( request , response ) ; } protected void doRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { Context context = null ; try { context = createContext ( request , response ) ; setContentType ( request , response ) ; Template template = handleRequest ( request , response , context ) ; if ( template == null ) { return ; } mergeTemplate ( template , context , response ) ; } catch ( Exception e ) { error ( request , response , e ) ; } finally { requestCleanup ( request , response , context ) ; } } protected void requestCleanup ( HttpServletRequest request , HttpServletResponse response , Context context ) { return ; } protected void mergeTemplate ( Template template , Context context , HttpServletResponse response ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , IOException , UnsupportedEncodingException , Exception { ServletOutputStream output = response . getOutputStream ( ) ; VelocityWriter vw = null ; String encoding = response . getCharacterEncoding ( ) ; try { vw = ( VelocityWriter ) writerPool . get ( ) ; if ( vw == null ) { vw = new VelocityWriter ( new OutputStreamWriter ( output , encoding ) , 4 * 1024 , true ) ; } else { vw . recycle ( new OutputStreamWriter ( output , encoding ) ) ; } template . merge ( context , vw ) ; } finally { try { if ( vw != null ) { vw . flush ( ) ; vw . recycle ( null ) ; writerPool . put ( vw ) ; } } catch ( Exception e ) { } } } protected void setContentType ( HttpServletRequest request , HttpServletResponse response ) { String contentType = defaultContentType ; int index = contentType . lastIndexOf ( ';' ) + 1 ; if ( index <= 0 || ( index < contentType . length ( ) && contentType . indexOf ( "charset" , index ) == - 1 ) ) { String encoding = chooseCharacterEncoding ( request ) ; if ( ! DEFAULT_OUTPUT_ENCODING . equalsIgnoreCase ( encoding ) ) { contentType += "; charset=" + encoding ; } } response . setContentType ( contentType ) ; } protected String chooseCharacterEncoding ( HttpServletRequest request ) { return RuntimeSingleton . getString ( RuntimeConstants . OUTPUT_ENCODING , DEFAULT_OUTPUT_ENCODING ) ; } protected Context createContext ( HttpServletRequest request , HttpServletResponse response ) { VelocityContext context = new VelocityContext ( ) ; context . put ( REQUEST , request ) ; context . put ( RESPONSE , response ) ; return context ; } public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name ) ; } public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name , encoding ) ; } protected Template handleRequest ( HttpServletRequest request , HttpServletResponse response , Context ctx ) throws Exception { Template t = handleRequest ( ctx ) ; if ( t == null ) { throw new Exception ( "handleRequest(Context) returned null - no template selected!" ) ; } return t ; } protected Template handleRequest ( Context ctx ) throws Exception { throw new Exception ( "You must override VelocityServlet.handleRequest( Context) " + " or VelocityServlet.handleRequest( HttpServletRequest, " + " HttpServletResponse, Context)" ) ; } protected void error ( HttpServletRequest request , HttpServletResponse response , Exception cause ) throws ServletException , IOException { StringBuffer html = new StringBuffer ( ) ; html . append ( "<html>" ) ; html . append ( "<title>Error</title>" ) ; html . append ( "<body bgcolor=\"#ffffff\">" ) ; html . append ( "<h2>VelocityServlet: Error processing the template</h2>" ) ; html . append ( "<pre>" ) ; String why = cause . getMessage ( ) ; if ( why != null && why . trim ( ) . length ( ) > 0 ) { html . append ( why ) ; html . append ( "<br>" ) ; } StringWriter sw = new StringWriter ( ) ; cause . printStackTrace ( new PrintWriter ( sw ) ) ; html . append ( sw . toString ( ) ) ; html . append ( "</pre>" ) ; html . append ( "</body>" ) ; html . append ( "</html>" ) ; response . getOutputStream ( ) . print ( html . toString ( ) ) ; } } 	1	['18', '3', '1', '13', '63', '149', '2', '11', '6', '1.019607843', '417', '0.444444444', '1', '0.6', '0.338235294', '1', '2', '21.66666667', '5', '1.1111', '1']
package org . apache . velocity . app . tools ; import java . util . * ; import java . text . * ; import java . lang . reflect . Array ; import org . apache . velocity . context . * ; public class VelocityFormatter { Context context = null ; NumberFormat nf = NumberFormat . getInstance ( ) ; public VelocityFormatter ( Context context ) { this . context = context ; } public String formatShortDate ( Date date ) { return DateFormat . getDateInstance ( DateFormat . SHORT ) . format ( date ) ; } public String formatLongDate ( Date date ) { return DateFormat . getDateInstance ( DateFormat . LONG ) . format ( date ) ; } public String formatShortDateTime ( Date date ) { return DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT ) . format ( date ) ; } public String formatLongDateTime ( Date date ) { return DateFormat . getDateTimeInstance ( DateFormat . LONG , DateFormat . LONG ) . format ( date ) ; } public String formatArray ( Object array ) { return formatArray ( array , ", " , " and " ) ; } public String formatArray ( Object array , String delim ) { return formatArray ( array , delim , delim ) ; } public String formatArray ( Object array , String delim , String finaldelim ) { StringBuffer sb = new StringBuffer ( ) ; int arrayLen = Array . getLength ( array ) ; for ( int i = 0 ; i < arrayLen ; i ++ ) { sb . append ( Array . get ( array , i ) . toString ( ) ) ; if ( i < arrayLen - 2 ) { sb . append ( delim ) ; } else if ( i < arrayLen - 1 ) { sb . append ( finaldelim ) ; } } return sb . toString ( ) ; } public String formatVector ( List list ) { return formatVector ( list , ", " , " and " ) ; } public String formatVector ( List list , String delim ) { return formatVector ( list , delim , delim ) ; } public String formatVector ( List list , String delim , String finaldelim ) { StringBuffer sb = new StringBuffer ( ) ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { sb . append ( list . get ( i ) ) ; if ( i < size - 2 ) { sb . append ( delim ) ; } else if ( i < size - 1 ) { sb . append ( finaldelim ) ; } } return sb . toString ( ) ; } public String limitLen ( int maxlen , String string ) { return limitLen ( maxlen , string , "..." ) ; } public String limitLen ( int maxlen , String string , String suffix ) { String ret = string ; if ( string . length ( ) > maxlen ) { ret = string . substring ( 0 , maxlen - suffix . length ( ) ) + suffix ; } return ret ; } public class VelocityAlternator { protected String [ ] alternates = null ; protected int current = 0 ; public VelocityAlternator ( String [ ] alternates ) { this . alternates = alternates ; } public String alternate ( ) { current ++ ; current %= alternates . length ; return "" ; } public String toString ( ) { return alternates [ current ] ; } } public class VelocityAutoAlternator extends VelocityAlternator { public VelocityAutoAlternator ( String [ ] alternates ) { super ( alternates ) ; } public final String toString ( ) { String s = alternates [ current ] ; alternate ( ) ; return s ; } } public String makeAlternator ( String name , String alt1 , String alt2 ) { String [ ] alternates = { alt1 , alt2 } ; context . put ( name , new VelocityAlternator ( alternates ) ) ; return "" ; } public String makeAlternator ( String name , String alt1 , String alt2 , String alt3 ) { String [ ] alternates = { alt1 , alt2 , alt3 } ; context . put ( name , new VelocityAlternator ( alternates ) ) ; return "" ; } public String makeAlternator ( String name , String alt1 , String alt2 , String alt3 , String alt4 ) { String [ ] alternates = { alt1 , alt2 , alt3 , alt4 } ; context . put ( name , new VelocityAlternator ( alternates ) ) ; return "" ; } public String makeAutoAlternator ( String name , String alt1 , String alt2 ) { String [ ] alternates = { alt1 , alt2 } ; context . put ( name , new VelocityAutoAlternator ( alternates ) ) ; return "" ; } public Object isNull ( Object o , Object dflt ) { if ( o == null ) { return dflt ; } else { return o ; } } } 	1	['18', '1', '0', '3', '37', '133', '2', '3', '18', '0.882352941', '302', '0', '1', '0', '0.333333333', '0', '0', '15.66666667', '4', '1.3889', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import java . io . StringWriter ; import java . io . BufferedReader ; import java . io . StringReader ; import org . apache . velocity . runtime . RuntimeConstants ; public class ASTStringLiteral extends SimpleNode { private boolean interpolate = true ; private SimpleNode nodeTree = null ; private String image = "" ; private String interpolateimage = "" ; public ASTStringLiteral ( int id ) { super ( id ) ; } public ASTStringLiteral ( Parser p , int id ) { super ( p , id ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { super . init ( context , data ) ; interpolate = rsvc . getBoolean ( RuntimeConstants . INTERPOLATE_STRINGLITERALS , true ) && getFirstToken ( ) . image . startsWith ( "\"" ) && ( ( getFirstToken ( ) . image . indexOf ( '$' ) != - 1 ) || ( getFirstToken ( ) . image . indexOf ( '#' ) != - 1 ) ) ; image = getFirstToken ( ) . image . substring ( 1 , getFirstToken ( ) . image . length ( ) - 1 ) ; interpolateimage = image + " " ; if ( interpolate ) { BufferedReader br = new BufferedReader ( new StringReader ( interpolateimage ) ) ; nodeTree = rsvc . parse ( br , ( context != null ) ? context . getCurrentTemplateName ( ) : "StringLiteral" , false ) ; nodeTree . init ( context , rsvc ) ; } return data ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) { if ( interpolate ) { try { StringWriter writer = new StringWriter ( ) ; nodeTree . render ( context , writer ) ; String ret = writer . toString ( ) ; return ret . substring ( 0 , ret . length ( ) - 1 ) ; } catch ( Exception e ) { rsvc . error ( "Error in interpolating string literal : " + e ) ; } } return image ; } } 	1	['5', '2', '0', '9', '27', '0', '4', '7', '5', '0.3125', '180', '1', '1', '0.9', '0.433333333', '1', '1', '34.2', '2', '0.8', '2']
package org . apache . velocity . util ; import java . util . Iterator ; import java . util . Enumeration ; public class EnumerationIterator implements Iterator { private Enumeration enum = null ; public EnumerationIterator ( Enumeration enum ) { this . enum = enum ; } public Object next ( ) { return enum . nextElement ( ) ; } public boolean hasNext ( ) { return enum . hasMoreElements ( ) ; } public void remove ( ) { } } 	1	['4', '1', '0', '1', '7', '0', '1', '0', '4', '0.333333333', '23', '1', '0', '0', '0.625', '0', '0', '4.5', '1', '0.75', '1']
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . commons . collections . ExtendedProperties ; public abstract class ResourceLoader { protected boolean isCachingOn = false ; protected long modificationCheckInterval = 2 ; protected String className = null ; protected RuntimeServices rsvc = null ; public void commonInit ( RuntimeServices rs , ExtendedProperties configuration ) { this . rsvc = rs ; isCachingOn = configuration . getBoolean ( "cache" , false ) ; modificationCheckInterval = configuration . getLong ( "modificationCheckInterval" , 0 ) ; className = configuration . getString ( "class" ) ; } public abstract void init ( ExtendedProperties configuration ) ; public abstract InputStream getResourceStream ( String source ) throws ResourceNotFoundException ; public abstract boolean isSourceModified ( Resource resource ) ; public abstract long getLastModified ( Resource resource ) ; public String getClassName ( ) { return className ; } public void setCachingOn ( boolean value ) { isCachingOn = value ; } public boolean isCachingOn ( ) { return isCachingOn ; } public void setModificationCheckInterval ( long modificationCheckInterval ) { this . modificationCheckInterval = modificationCheckInterval ; } public long getModificationCheckInterval ( ) { return modificationCheckInterval ; } } 	1	['11', '1', '3', '12', '15', '29', '9', '4', '11', '0.775', '68', '1', '1', '0', '0.246753247', '0', '0', '4.818181818', '1', '0.9091', '1']
package org . apache . velocity . texen . ant ; import java . util . StringTokenizer ; import java . util . Date ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Map ; import java . io . File ; import java . io . Writer ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . context . Context ; import org . apache . velocity . texen . Generator ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . commons . collections . ExtendedProperties ; public class TexenTask extends Task { private final static String ERR_MSG_FRAGMENT = ". For more information consult the velocity log, or invoke ant " + "with the -debug flag." ; protected String controlTemplate ; protected String templatePath ; protected String outputDirectory ; protected String outputFile ; protected String outputEncoding ; protected String inputEncoding ; protected ExtendedProperties contextProperties ; protected boolean useClasspath ; private String fileSeparator = System . getProperty ( "file.separator" ) ; public void setControlTemplate ( String controlTemplate ) { this . controlTemplate = controlTemplate ; } public String getControlTemplate ( ) { return controlTemplate ; } public void setTemplatePath ( String templatePath ) throws Exception { StringBuffer resolvedPath = new StringBuffer ( ) ; StringTokenizer st = new StringTokenizer ( templatePath , "," ) ; while ( st . hasMoreTokens ( ) ) { File fullPath = project . resolveFile ( st . nextToken ( ) ) ; resolvedPath . append ( fullPath . getCanonicalPath ( ) ) ; if ( st . hasMoreTokens ( ) ) { resolvedPath . append ( "," ) ; } } this . templatePath = resolvedPath . toString ( ) ; System . out . println ( templatePath ) ; } public String getTemplatePath ( ) { return templatePath ; } public void setOutputDirectory ( File outputDirectory ) { try { this . outputDirectory = outputDirectory . getCanonicalPath ( ) ; } catch ( java . io . IOException ioe ) { throw new BuildException ( ioe ) ; } } public String getOutputDirectory ( ) { return outputDirectory ; } public void setOutputFile ( String outputFile ) { this . outputFile = outputFile ; } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setInputEncoding ( String inputEncoding ) { this . inputEncoding = inputEncoding ; } public String getOutputFile ( ) { return outputFile ; } public void setContextProperties ( String file ) { String [ ] sources = StringUtils . split ( file , "," ) ; contextProperties = new ExtendedProperties ( ) ; for ( int i = 0 ; i < sources . length ; i ++ ) { ExtendedProperties source = new ExtendedProperties ( ) ; try { File fullPath = project . resolveFile ( sources [ i ] ) ; log ( "Using contextProperties file: " + fullPath ) ; source . load ( new FileInputStream ( fullPath ) ) ; } catch ( Exception e ) { ClassLoader classLoader = this . getClass ( ) . getClassLoader ( ) ; try { InputStream inputStream = classLoader . getResourceAsStream ( sources [ i ] ) ; if ( inputStream == null ) { throw new BuildException ( "Context properties file " + sources [ i ] + " could not be found in the file system or on the classpath!" ) ; } else { source . load ( inputStream ) ; } } catch ( IOException ioe ) { source = null ; } } Iterator j = source . getKeys ( ) ; while ( j . hasNext ( ) ) { String name = ( String ) j . next ( ) ; String value = source . getString ( name ) ; contextProperties . setProperty ( name , value ) ; } } } public ExtendedProperties getContextProperties ( ) { return contextProperties ; } public void setUseClasspath ( boolean useClasspath ) { this . useClasspath = useClasspath ; } public Context initControlContext ( ) throws Exception { return new VelocityContext ( ) ; } public void execute ( ) throws BuildException { if ( templatePath == null && useClasspath == false ) { throw new BuildException ( "The template path needs to be defined if you are not using " + "the classpath for locating templates!" ) ; } if ( controlTemplate == null ) { throw new BuildException ( "The control template needs to be defined!" ) ; } if ( outputDirectory == null ) { throw new BuildException ( "The output directory needs to be defined!" ) ; } if ( outputFile == null ) { throw new BuildException ( "The output file needs to be defined!" ) ; } VelocityEngine ve = new VelocityEngine ( ) ; try { if ( templatePath != null ) { log ( "Using templatePath: " + templatePath , project . MSG_VERBOSE ) ; ve . setProperty ( ve . FILE_RESOURCE_LOADER_PATH , templatePath ) ; } if ( useClasspath ) { log ( "Using classpath" ) ; ve . addProperty ( VelocityEngine . RESOURCE_LOADER , "classpath" ) ; ve . setProperty ( "classpath." + VelocityEngine . RESOURCE_LOADER + ".class" , "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader" ) ; ve . setProperty ( "classpath." + VelocityEngine . RESOURCE_LOADER + ".cache" , "false" ) ; ve . setProperty ( "classpath." + VelocityEngine . RESOURCE_LOADER + ".modificationCheckInterval" , "2" ) ; } ve . init ( ) ; Generator generator = Generator . getInstance ( ) ; generator . setVelocityEngine ( ve ) ; generator . setOutputPath ( outputDirectory ) ; generator . setInputEncoding ( inputEncoding ) ; generator . setOutputEncoding ( outputEncoding ) ; if ( templatePath != null ) { generator . setTemplatePath ( templatePath ) ; } File file = new File ( outputDirectory ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } String path = outputDirectory + File . separator + outputFile ; log ( "Generating to file " + path , project . MSG_INFO ) ; Writer writer = generator . getWriter ( path , outputEncoding ) ; Context c = initControlContext ( ) ; populateInitialContext ( c ) ; if ( contextProperties != null ) { Iterator i = contextProperties . getKeys ( ) ; while ( i . hasNext ( ) ) { String property = ( String ) i . next ( ) ; String value = contextProperties . getString ( property ) ; try { c . put ( property , new Integer ( value ) ) ; } catch ( NumberFormatException nfe ) { String booleanString = contextProperties . testBoolean ( value ) ; if ( booleanString != null ) { c . put ( property , new Boolean ( booleanString ) ) ; } else { if ( property . endsWith ( "file.contents" ) ) { value = StringUtils . fileContentsToString ( project . resolveFile ( value ) . getCanonicalPath ( ) ) ; property = property . substring ( 0 , property . indexOf ( "file.contents" ) - 1 ) ; } c . put ( property , value ) ; } } } } writer . write ( generator . parse ( controlTemplate , c ) ) ; writer . flush ( ) ; writer . close ( ) ; generator . shutdown ( ) ; cleanup ( ) ; } catch ( BuildException e ) { throw e ; } catch ( MethodInvocationException e ) { throw new BuildException ( "Exception thrown by '" + e . getReferenceName ( ) + "." + e . getMethodName ( ) + "'" + ERR_MSG_FRAGMENT , e . getWrappedThrowable ( ) ) ; } catch ( ParseErrorException e ) { throw new BuildException ( "Velocity syntax error" + ERR_MSG_FRAGMENT , e ) ; } catch ( ResourceNotFoundException e ) { throw new BuildException ( "Resource not found" + ERR_MSG_FRAGMENT , e ) ; } catch ( Exception e ) { throw new BuildException ( "Generation failed" + ERR_MSG_FRAGMENT , e ) ; } } protected void populateInitialContext ( Context context ) throws Exception { context . put ( "now" , new Date ( ) . toString ( ) ) ; } protected void cleanup ( ) throws Exception { } } 	1	['18', '3', '0', '13', '80', '117', '0', '13', '16', '0.929411765', '534', '1', '0', '0.685185185', '0.3', '1', '1', '28.11111111', '4', '1.1111', '1']
package org . apache . velocity . runtime . log ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . velocity . runtime . RuntimeServices ; public class PrimordialLogSystem implements LogSystem { private Vector pendingMessages = new Vector ( ) ; private RuntimeServices rsvc = null ; public PrimordialLogSystem ( ) { } public void init ( RuntimeServices rs ) throws Exception { rsvc = rs ; } public void logVelocityMessage ( int level , String message ) { synchronized ( this ) { Object [ ] data = new Object [ 2 ] ; data [ 0 ] = new Integer ( level ) ; data [ 1 ] = message ; pendingMessages . addElement ( data ) ; } } public void dumpLogMessages ( LogSystem newLogger ) { synchronized ( this ) { if ( ! pendingMessages . isEmpty ( ) ) { for ( Enumeration e = pendingMessages . elements ( ) ; e . hasMoreElements ( ) ; ) { Object [ ] data = ( Object [ ] ) e . nextElement ( ) ; newLogger . logVelocityMessage ( ( ( Integer ) data [ 0 ] ) . intValue ( ) , ( String ) data [ 1 ] ) ; } } } } } 	1	['4', '1', '0', '3', '14', '0', '1', '2', '4', '0.5', '92', '1', '1', '0', '0.4', '0', '0', '21.5', '3', '1.25', '1']
package org . apache . velocity . util . introspection ; import org . apache . velocity . runtime . RuntimeLogger ; public interface UberspectLoggable { public void setRuntimeLogger ( RuntimeLogger logger ) ; } 	1	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTGTNode extends SimpleNode { public ASTGTNode ( int id ) { super ( id ) ; } public ASTGTNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '>' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of '>' operation is not a valid type. " + " It is a " + ( ! ( left instanceof Integer ) ? left . getClass ( ) : right . getClass ( ) ) + ". Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } return ( ( Integer ) left ) . intValue ( ) > ( ( Integer ) right ) . intValue ( ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '10', '22', '10', '4', '8', '5', '2', '153', '0', '0', '0.9', '0.4', '1', '1', '29.6', '1', '0.6', '1']
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . util . introspection . Info ; public class Foreach extends Directive { public String getName ( ) { return "foreach" ; } public int getType ( ) { return BLOCK ; } private String counterName ; private int counterInitialValue ; private String elementKey ; protected Info uberInfo ; public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws Exception { super . init ( rs , context , node ) ; counterName = rsvc . getString ( RuntimeConstants . COUNTER_NAME ) ; counterInitialValue = rsvc . getInt ( RuntimeConstants . COUNTER_INITIAL_VALUE ) ; elementKey = node . jjtGetChild ( 0 ) . getFirstToken ( ) . image . substring ( 1 ) ; uberInfo = new Info ( context . getCurrentTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { Object listObject = node . jjtGetChild ( 2 ) . value ( context ) ; if ( listObject == null ) return false ; Iterator i = null ; try { i = rsvc . getUberspect ( ) . getIterator ( listObject , uberInfo ) ; } catch ( Exception ee ) { System . out . println ( ee ) ; } if ( i == null ) { return false ; } int counter = counterInitialValue ; Object o = context . get ( elementKey ) ; Object ctr = context . get ( counterName ) ; while ( i . hasNext ( ) ) { context . put ( counterName , new Integer ( counter ) ) ; context . put ( elementKey , i . next ( ) ) ; node . jjtGetChild ( 3 ) . render ( context , writer ) ; counter ++ ; } if ( ctr != null ) { context . put ( counterName , ctr ) ; } else { context . remove ( counterName ) ; } if ( o != null ) { context . put ( elementKey , o ) ; } else { context . remove ( elementKey ) ; } return true ; } } 	1	['5', '2', '0', '11', '27', '8', '0', '11', '5', '0.75', '154', '1', '1', '0.636363636', '0.44', '0', '0', '29', '1', '0.8', '4']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTNENode extends SimpleNode { public ASTNENode ( int id ) { super ( id ) ; } public ASTNENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '!=' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( left . getClass ( ) . equals ( right . getClass ( ) ) ) { return ! ( left . equals ( right ) ) ; } else { rsvc . error ( "Error in evaluation of != expression." + " Both arguments must be of the same Class." + " Currently left = " + left . getClass ( ) + ", right = " + right . getClass ( ) + ". " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "] (ASTEQNode)" ) ; return false ; } } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '10', '22', '10', '4', '8', '5', '2', '140', '0', '0', '0.9', '0.4', '2', '2', '27', '1', '0.6', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . app . event . EventCartridge ; public class ASTSetDirective extends SimpleNode { private String leftReference = "" ; private Node right ; private ASTReference left ; boolean blather = false ; public ASTSetDirective ( int id ) { super ( id ) ; } public ASTSetDirective ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { super . init ( context , data ) ; right = getRightHandSide ( ) ; left = getLeftHandSide ( ) ; blather = rsvc . getBoolean ( RuntimeConstants . RUNTIME_LOG_REFERENCE_LOG_INVALID , true ) ; leftReference = left . getFirstToken ( ) . image . substring ( 1 ) ; return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException { Object value = right . value ( context ) ; if ( value == null ) { if ( blather ) { EventCartridge ec = context . getEventCartridge ( ) ; boolean doit = true ; if ( ec != null ) { doit = ec . shouldLogOnNullSet ( left . literal ( ) , right . literal ( ) ) ; } if ( doit ) { rsvc . error ( "RHS of #set statement is null. Context will not be modified. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; } } return false ; } if ( left . jjtGetNumChildren ( ) == 0 ) { context . put ( leftReference , value ) ; } else { left . setValue ( context , value ) ; } return true ; } private ASTReference getLeftHandSide ( ) { return ( ASTReference ) jjtGetChild ( 0 ) ; } private Node getRightHandSide ( ) { return jjtGetChild ( 1 ) ; } } 	1	['7', '2', '0', '15', '31', '9', '4', '13', '5', '0.666666667', '149', '0.75', '2', '0.84375', '0.326530612', '1', '1', '19.71428571', '1', '0.7143', '3']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTAndNode extends SimpleNode { public ASTAndNode ( int id ) { super ( id ) ; } public ASTAndNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return new Boolean ( evaluate ( context ) ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Node left = jjtGetChild ( 0 ) ; Node right = jjtGetChild ( 1 ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side of '&&' operation is null." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( left . evaluate ( context ) ) { if ( right . evaluate ( context ) ) { return true ; } } return false ; } } 	1	['5', '2', '0', '10', '19', '10', '4', '8', '5', '2', '84', '0', '0', '0.9', '0.4', '1', '1', '15.8', '1', '0.6', '1']
package org . apache . velocity . runtime ; public interface RuntimeLogger { public void warn ( Object message ) ; public void info ( Object message ) ; public void error ( Object message ) ; public void debug ( Object message ) ; } 	1	['4', '1', '0', '46', '4', '6', '46', '0', '4', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import java . net . JarURLConnection ; import java . net . URL ; import java . util . Enumeration ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . Hashtable ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . exception . ResourceNotFoundException ; public class JarHolder { private String urlpath = null ; private JarFile theJar = null ; private JarURLConnection conn = null ; private RuntimeServices rsvc = null ; public JarHolder ( RuntimeServices rs , String urlpath ) { rsvc = rs ; this . urlpath = urlpath ; init ( ) ; rsvc . info ( "  JarHolder : initialized JAR: " + urlpath ) ; } public void init ( ) { try { rsvc . info ( "  JarHolder : attempting to connect to " + urlpath ) ; URL url = new URL ( urlpath ) ; conn = ( JarURLConnection ) url . openConnection ( ) ; conn . setAllowUserInteraction ( false ) ; conn . setDoInput ( true ) ; conn . setDoOutput ( false ) ; conn . connect ( ) ; theJar = conn . getJarFile ( ) ; } catch ( Exception e ) { rsvc . error ( "  JarHolder : error establishing connection to JAR " + e ) ; } } public void close ( ) { try { theJar . close ( ) ; } catch ( Exception e ) { rsvc . error ( "  JarHolder : error Closing JAR the file " + e ) ; } theJar = null ; conn = null ; rsvc . info ( "  JarHolder : JAR file closed" ) ; } public InputStream getResource ( String theentry ) throws ResourceNotFoundException { InputStream data = null ; try { JarEntry entry = theJar . getJarEntry ( theentry ) ; if ( entry != null ) { data = theJar . getInputStream ( entry ) ; } } catch ( Exception fnfe ) { rsvc . error ( "  JarHolder : getResource() error : exception : " + fnfe ) ; throw new ResourceNotFoundException ( fnfe . getMessage ( ) ) ; } return data ; } public Hashtable getEntries ( ) { Hashtable allEntries = new Hashtable ( 559 ) ; Enumeration all = theJar . entries ( ) ; while ( all . hasMoreElements ( ) ) { JarEntry je = ( JarEntry ) all . nextElement ( ) ; if ( ! je . isDirectory ( ) ) { allEntries . put ( je . getName ( ) , this . urlpath ) ; } } return allEntries ; } public String getUrlPath ( ) { return urlpath ; } } 	1	['6', '1', '0', '4', '32', '0', '1', '3', '6', '0.4', '195', '1', '1', '0', '0.5', '0', '0', '30.83333333', '3', '1.1667', '1']
package org . apache . velocity . runtime ; import java . util . Hashtable ; import java . io . StringReader ; import java . io . BufferedReader ; import org . apache . velocity . runtime . directive . VelocimacroProxy ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . context . InternalContextAdapter ; public class VelocimacroManager { private RuntimeServices rsvc = null ; private static String GLOBAL_NAMESPACE = "" ; private boolean registerFromLib = false ; private Hashtable namespaceHash = new Hashtable ( ) ; private Hashtable libraryMap = new Hashtable ( ) ; private boolean namespacesOn = true ; private boolean inlineLocalMode = false ; VelocimacroManager ( RuntimeServices rs ) { this . rsvc = rs ; addNamespace ( GLOBAL_NAMESPACE ) ; } public boolean addVM ( String vmName , String macroBody , String argArray [ ] , String namespace ) { MacroEntry me = new MacroEntry ( this , vmName , macroBody , argArray , namespace ) ; me . setFromLibrary ( registerFromLib ) ; boolean isLib = true ; if ( registerFromLib ) { libraryMap . put ( namespace , namespace ) ; } else { isLib = libraryMap . containsKey ( namespace ) ; } if ( ! isLib && usingNamespaces ( namespace ) ) { Hashtable local = getNamespace ( namespace , true ) ; local . put ( ( String ) vmName , me ) ; return true ; } else { MacroEntry exist = ( MacroEntry ) getNamespace ( GLOBAL_NAMESPACE ) . get ( vmName ) ; if ( exist != null ) { me . setFromLibrary ( exist . getFromLibrary ( ) ) ; } getNamespace ( GLOBAL_NAMESPACE ) . put ( vmName , me ) ; return true ; } } public VelocimacroProxy get ( String vmName , String namespace ) { if ( usingNamespaces ( namespace ) ) { Hashtable local = getNamespace ( namespace , false ) ; if ( local != null ) { MacroEntry me = ( MacroEntry ) local . get ( vmName ) ; if ( me != null ) { return me . createVelocimacro ( namespace ) ; } } } MacroEntry me = ( MacroEntry ) getNamespace ( GLOBAL_NAMESPACE ) . get ( vmName ) ; if ( me != null ) { return me . createVelocimacro ( namespace ) ; } return null ; } public boolean dumpNamespace ( String namespace ) { synchronized ( this ) { if ( usingNamespaces ( namespace ) ) { Hashtable h = ( Hashtable ) namespaceHash . remove ( namespace ) ; if ( h == null ) return false ; h . clear ( ) ; return true ; } return false ; } } public void setNamespaceUsage ( boolean b ) { namespacesOn = b ; } public void setRegisterFromLib ( boolean b ) { registerFromLib = b ; } public void setTemplateLocalInlineVM ( boolean b ) { inlineLocalMode = b ; } private Hashtable getNamespace ( String namespace ) { return getNamespace ( namespace , false ) ; } private Hashtable getNamespace ( String namespace , boolean addIfNew ) { Hashtable h = ( Hashtable ) namespaceHash . get ( namespace ) ; if ( h == null && addIfNew ) { h = addNamespace ( namespace ) ; } return h ; } private Hashtable addNamespace ( String namespace ) { Hashtable h = new Hashtable ( ) ; Object oh ; if ( ( oh = namespaceHash . put ( namespace , h ) ) != null ) { namespaceHash . put ( namespace , oh ) ; return null ; } return h ; } private boolean usingNamespaces ( String namespace ) { if ( ! namespacesOn ) { return false ; } if ( inlineLocalMode ) { return true ; } return false ; } public String getLibraryName ( String vmName , String namespace ) { if ( usingNamespaces ( namespace ) ) { Hashtable local = getNamespace ( namespace , false ) ; if ( local != null ) { MacroEntry me = ( MacroEntry ) local . get ( vmName ) ; if ( me != null ) { return null ; } } } MacroEntry me = ( MacroEntry ) getNamespace ( GLOBAL_NAMESPACE ) . get ( vmName ) ; if ( me != null ) { return me . getSourceTemplate ( ) ; } return null ; } protected class MacroEntry { String macroname ; String [ ] argarray ; String macrobody ; String sourcetemplate ; SimpleNode nodeTree = null ; VelocimacroManager manager = null ; boolean fromLibrary = false ; MacroEntry ( VelocimacroManager vmm , String vmName , String macroBody , String argArray [ ] , String sourceTemplate ) { this . macroname = vmName ; this . argarray = argArray ; this . macrobody = macroBody ; this . sourcetemplate = sourceTemplate ; this . manager = vmm ; } public void setFromLibrary ( boolean b ) { fromLibrary = b ; } public boolean getFromLibrary ( ) { return fromLibrary ; } public SimpleNode getNodeTree ( ) { return nodeTree ; } public String getSourceTemplate ( ) { return sourcetemplate ; } VelocimacroProxy createVelocimacro ( String namespace ) { VelocimacroProxy vp = new VelocimacroProxy ( ) ; vp . setName ( this . macroname ) ; vp . setArgArray ( this . argarray ) ; vp . setMacrobody ( this . macrobody ) ; vp . setNodeTree ( this . nodeTree ) ; vp . setNamespace ( namespace ) ; return vp ; } void setup ( InternalContextAdapter ica ) { if ( nodeTree == null ) parseTree ( ica ) ; } void parseTree ( InternalContextAdapter ica ) { try { BufferedReader br = new BufferedReader ( new StringReader ( macrobody ) ) ; nodeTree = rsvc . parse ( br , "VM:" + macroname , true ) ; nodeTree . init ( ica , null ) ; } catch ( Exception e ) { rsvc . error ( "VelocimacroManager.parseTree() : exception " + macroname + " : " + StringUtils . stackTrace ( e ) ) ; } } } } 	1	['14', '1', '0', '4', '26', '43', '2', '3', '7', '0.703296703', '309', '1', '1', '0', '0.346153846', '0', '0', '20.57142857', '5', '2.2143', '1']
package org . apache . velocity . util . introspection ; import java . util . Map ; import java . util . Set ; import java . util . HashMap ; import java . util . HashSet ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeLogger ; public class Introspector extends IntrospectorBase { public final static String CACHEDUMP_MSG = "Introspector : detected classloader change. Dumping cache." ; private RuntimeLogger rlog = null ; public Introspector ( RuntimeLogger logger ) { this . rlog = logger ; } public Method getMethod ( Class c , String name , Object [ ] params ) throws Exception { try { return super . getMethod ( c , name , params ) ; } catch ( MethodMap . AmbiguousException ae ) { String msg = "Introspection Error : Ambiguous method invocation " + name + "( " ; for ( int i = 0 ; i < params . length ; i ++ ) { if ( i > 0 ) msg = msg + ", " ; msg = msg + params [ i ] . getClass ( ) . getName ( ) ; } msg = msg + ") for class " + c ; rlog . error ( msg ) ; } return null ; } protected void clearCache ( ) { super . clearCache ( ) ; rlog . info ( CACHEDUMP_MSG ) ; } } 	1	['3', '2', '0', '13', '14', '0', '10', '3', '2', '0.75', '88', '0.5', '1', '0.6', '0.466666667', '1', '1', '27.66666667', '1', '0.6667', '1']
package org . apache . velocity . util ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . lang . reflect . Array ; public class ArrayIterator implements Iterator { private Object array ; private int pos ; private int size ; public ArrayIterator ( Object array ) { if ( ! array . getClass ( ) . isArray ( ) ) { throw new IllegalArgumentException ( "Programmer error : internal ArrayIterator invoked w/o array" ) ; } this . array = array ; pos = 0 ; size = Array . getLength ( this . array ) ; } public Object next ( ) { if ( pos < size ) return Array . get ( array , pos ++ ) ; throw new NoSuchElementException ( "No more elements: " + pos + " / " + size ) ; } public boolean hasNext ( ) { return ( pos < size ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } 	1	['4', '1', '0', '1', '16', '0', '1', '0', '4', '0.444444444', '77', '1', '0', '0', '0.625', '0', '0', '17.5', '2', '1.25', '1']
package org . apache . velocity . context ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import org . apache . velocity . runtime . resource . Resource ; interface InternalHousekeepingContext { void pushCurrentTemplateName ( String s ) ; void popCurrentTemplateName ( ) ; String getCurrentTemplateName ( ) ; Object [ ] getTemplateNameStack ( ) ; IntrospectionCacheData icacheGet ( Object key ) ; void icachePut ( Object key , IntrospectionCacheData o ) ; Resource getCurrentResource ( ) ; void setCurrentResource ( Resource r ) ; } 	1	['8', '1', '0', '6', '8', '28', '4', '2', '8', '2', '8', '0', '0', '0', '0.325', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . context ; public interface InternalContextAdapter extends InternalHousekeepingContext , Context , InternalWrapperContext , InternalEventContext { } 	1	['0', '1', '0', '58', '0', '0', '55', '4', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTSubtractNode extends SimpleNode { public ASTSubtractNode ( int id ) { super ( id ) ; } public ASTSubtractNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of subtraction operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of subtraction operation is not a valid type. " + "Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } return new Integer ( ( ( Integer ) left ) . intValue ( ) - ( ( Integer ) right ) . intValue ( ) ) ; } } 	1	['4', '2', '0', '10', '20', '6', '4', '8', '4', '2', '131', '0', '0', '0.931034483', '0.416666667', '1', '1', '31.75', '1', '0.5', '1']
package org . apache . velocity . runtime . resource ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; public interface ResourceManager { public static final int RESOURCE_TEMPLATE = 1 ; public static final int RESOURCE_CONTENT = 2 ; public void initialize ( RuntimeServices rs ) throws Exception ; public Resource getResource ( String resourceName , int resourceType , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception ; public String getLoaderNameForResource ( String resourceName ) ; } 	1	['3', '1', '0', '6', '3', '3', '2', '4', '3', '1.5', '5', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . context ; import java . util . HashMap ; import java . util . Stack ; import java . io . Serializable ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . runtime . resource . Resource ; class InternalContextBase implements InternalHousekeepingContext , InternalEventContext , Serializable { private HashMap introspectionCache = new HashMap ( 33 ) ; private Stack templateNameStack = new Stack ( ) ; private EventCartridge eventCartridge = null ; private Resource currentResource = null ; public void pushCurrentTemplateName ( String s ) { templateNameStack . push ( s ) ; return ; } public void popCurrentTemplateName ( ) { templateNameStack . pop ( ) ; return ; } public String getCurrentTemplateName ( ) { if ( templateNameStack . empty ( ) ) return "<undef>" ; else return ( String ) templateNameStack . peek ( ) ; } public Object [ ] getTemplateNameStack ( ) { return templateNameStack . toArray ( ) ; } public IntrospectionCacheData icacheGet ( Object key ) { return ( IntrospectionCacheData ) introspectionCache . get ( key ) ; } public void icachePut ( Object key , IntrospectionCacheData o ) { introspectionCache . put ( key , o ) ; } public void setCurrentResource ( Resource r ) { currentResource = r ; } public Resource getCurrentResource ( ) { return currentResource ; } public EventCartridge attachEventCartridge ( EventCartridge ec ) { EventCartridge temp = eventCartridge ; eventCartridge = ec ; return temp ; } public EventCartridge getEventCartridge ( ) { return eventCartridge ; } } 	1	['11', '1', '1', '7', '21', '17', '2', '5', '10', '0.75', '92', '1', '2', '0', '0.257575758', '0', '0', '7', '2', '1', '2']
package org . apache . velocity . runtime . visitor ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . node . * ; public abstract class BaseVisitor implements ParserVisitor { protected InternalContextAdapter context ; protected Writer writer ; public void setWriter ( Writer writer ) { this . writer = writer ; } public void setContext ( InternalContextAdapter context ) { this . context = context ; } public Object visit ( SimpleNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTprocess node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTExpression node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTAssignment node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTOrNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTAndNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTEQNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTNENode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTLTNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTGTNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTLENode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTGENode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTAddNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTSubtractNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTMulNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTDivNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTModNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTNotNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTNumberLiteral node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTStringLiteral node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIdentifier node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTMethod node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTReference node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTTrue node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTFalse node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTBlock node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTText node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIfStatement node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTElseStatement node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTElseIfStatement node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTComment node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTObjectArray node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTWord node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTSetDirective node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTDirective node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } } 	1	['38', '1', '2', '40', '40', '703', '3', '37', '38', '1', '296', '1', '1', '0', '0.074224022', '0', '0', '6.736842105', '1', '0.9737', '1']
package org . apache . velocity . runtime . directive ; import org . apache . velocity . runtime . parser . ParseException ; public class MacroParseException extends ParseException { public MacroParseException ( String msg ) { super ( msg ) ; } } 	1	['1', '4', '0', '3', '2', '0', '2', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . velocity . anakia ; import com . werken . xpath . XPath ; import java . util . Map ; import java . util . WeakHashMap ; class XPathCache { private static final Map XPATH_CACHE = new WeakHashMap ( ) ; private XPathCache ( ) { } static XPath getXPath ( String xpathString ) { XPath xpath = null ; synchronized ( XPATH_CACHE ) { xpath = ( XPath ) XPATH_CACHE . get ( xpathString ) ; if ( xpath == null ) { xpath = new XPath ( xpathString ) ; XPATH_CACHE . put ( xpathString , xpath ) ; } } return xpath ; } } 	1	['3', '1', '0', '4', '8', '1', '3', '1', '0', '0.5', '45', '1', '0', '0', '0.5', '0', '0', '13.66666667', '2', '0.6667', '1']
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . runtime . RuntimeLogger ; public class PropertyExecutor extends AbstractExecutor { protected Introspector introspector = null ; protected String methodUsed = null ; public PropertyExecutor ( RuntimeLogger r , Introspector ispctr , Class clazz , String property ) { rlog = r ; introspector = ispctr ; discover ( clazz , property ) ; } protected void discover ( Class clazz , String property ) { try { char c ; StringBuffer sb ; Object [ ] params = { } ; sb = new StringBuffer ( "get" ) ; sb . append ( property ) ; methodUsed = sb . toString ( ) ; method = introspector . getMethod ( clazz , methodUsed , params ) ; if ( method != null ) return ; sb = new StringBuffer ( "get" ) ; sb . append ( property ) ; c = sb . charAt ( 3 ) ; if ( Character . isLowerCase ( c ) ) { sb . setCharAt ( 3 , Character . toUpperCase ( c ) ) ; } else { sb . setCharAt ( 3 , Character . toLowerCase ( c ) ) ; } methodUsed = sb . toString ( ) ; method = introspector . getMethod ( clazz , methodUsed , params ) ; if ( method != null ) return ; } catch ( Exception e ) { rlog . error ( "PROGRAMMER ERROR : PropertyExector() : " + e ) ; } } public Object execute ( Object o ) throws IllegalAccessException , InvocationTargetException { if ( method == null ) return null ; return method . invoke ( o , null ) ; } } 	1	['3', '2', '1', '5', '17', '1', '2', '3', '2', '0.5', '122', '1', '1', '0.6', '0.555555556', '1', '2', '39', '3', '1.3333', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . runtime . RuntimeLogger ; public class BooleanPropertyExecutor extends PropertyExecutor { public BooleanPropertyExecutor ( RuntimeLogger rlog , Introspector is , Class clazz , String property ) { super ( rlog , is , clazz , property ) ; } protected void discover ( Class clazz , String property ) { try { char c ; StringBuffer sb ; Object [ ] params = { } ; sb = new StringBuffer ( "is" ) ; sb . append ( property ) ; c = sb . charAt ( 2 ) ; if ( Character . isLowerCase ( c ) ) { sb . setCharAt ( 2 , Character . toUpperCase ( c ) ) ; } methodUsed = sb . toString ( ) ; method = introspector . getMethod ( clazz , methodUsed , params ) ; if ( method != null ) { if ( method . getReturnType ( ) == Boolean . TYPE ) return ; method = null ; } } catch ( Exception e ) { rlog . error ( "PROGRAMMER ERROR : BooleanPropertyExector() : " + e ) ; } } } 	1	['2', '3', '0', '5', '15', '1', '1', '4', '1', '2', '72', '0', '0', '0.833333333', '0.8', '2', '5', '35', '3', '1.5', '1']
package org . apache . velocity . runtime . visitor ; import java . util . Map ; import org . apache . velocity . runtime . parser . node . ASTReference ; public class VMReferenceMungeVisitor extends BaseVisitor { private Map argmap = null ; public VMReferenceMungeVisitor ( Map map ) { argmap = map ; } public Object visit ( ASTReference node , Object data ) { String override = ( String ) argmap . get ( node . literal ( ) . substring ( 1 ) ) ; if ( override != null ) { node . setLiteral ( override ) ; } data = node . childrenAccept ( this , data ) ; return data ; } } 	1	['2', '2', '0', '5', '8', '0', '1', '4', '2', '0', '33', '1', '0', '0.973684211', '0.625', '0', '0', '15', '2', '1', '1']
package org . apache . velocity . exception ; public class ResourceNotFoundException extends VelocityException { public ResourceNotFoundException ( String exceptionMessage ) { super ( exceptionMessage ) ; } } 	1	['1', '4', '0', '31', '2', '0', '30', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '1']
package org . apache . velocity . context ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . runtime . resource . Resource ; public final class InternalContextAdapterImpl implements InternalContextAdapter { Context context = null ; InternalHousekeepingContext icb = null ; InternalEventContext iec = null ; public InternalContextAdapterImpl ( Context c ) { context = c ; if ( ! ( c instanceof InternalHousekeepingContext ) ) { icb = new InternalContextBase ( ) ; } else { icb = ( InternalHousekeepingContext ) context ; } if ( c instanceof InternalEventContext ) { iec = ( InternalEventContext ) context ; } } public void pushCurrentTemplateName ( String s ) { icb . pushCurrentTemplateName ( s ) ; } public void popCurrentTemplateName ( ) { icb . popCurrentTemplateName ( ) ; } public String getCurrentTemplateName ( ) { return icb . getCurrentTemplateName ( ) ; } public Object [ ] getTemplateNameStack ( ) { return icb . getTemplateNameStack ( ) ; } public IntrospectionCacheData icacheGet ( Object key ) { return icb . icacheGet ( key ) ; } public void icachePut ( Object key , IntrospectionCacheData o ) { icb . icachePut ( key , o ) ; } public void setCurrentResource ( Resource r ) { icb . setCurrentResource ( r ) ; } public Resource getCurrentResource ( ) { return icb . getCurrentResource ( ) ; } public Object put ( String key , Object value ) { return context . put ( key , value ) ; } public Object get ( String key ) { return context . get ( key ) ; } public boolean containsKey ( Object key ) { return context . containsKey ( key ) ; } public Object [ ] getKeys ( ) { return context . getKeys ( ) ; } public Object remove ( Object key ) { return context . remove ( key ) ; } public Context getInternalUserContext ( ) { return context ; } public InternalContextAdapter getBaseContext ( ) { return this ; } public EventCartridge attachEventCartridge ( EventCartridge ec ) { if ( iec != null ) { return iec . attachEventCartridge ( ec ) ; } return null ; } public EventCartridge getEventCartridge ( ) { if ( iec != null ) { return iec . getEventCartridge ( ) ; } return null ; } } 	1	['18', '1', '0', '12', '35', '33', '4', '8', '18', '0.68627451', '144', '0', '3', '0', '0.238095238', '0', '0', '6.833333333', '2', '1.0556', '2']
package org . apache . velocity . runtime . directive ; public interface DirectiveConstants { public static final int BLOCK = 1 ; public static final int LINE = 2 ; } 	1	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1']
package org . apache . velocity . runtime . directive ; import java . io . StringWriter ; import java . io . StringReader ; import java . io . BufferedReader ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . VelocityContext ; public class VMProxyArg { private int type = 0 ; private SimpleNode nodeTree = null ; private Object staticObject = null ; private InternalContextAdapter usercontext = null ; private int numTreeChildren = 0 ; private String contextReference = null ; private String callerReference = null ; private String singleLevelRef = null ; private boolean constant = false ; private final int GENERALSTATIC = - 1 ; private RuntimeServices rsvc = null ; public VMProxyArg ( RuntimeServices rs , String contextRef , String callerRef , int t ) { rsvc = rs ; contextReference = contextRef ; callerReference = callerRef ; type = t ; setup ( ) ; if ( nodeTree != null ) numTreeChildren = nodeTree . jjtGetNumChildren ( ) ; if ( type == ParserTreeConstants . JJTREFERENCE ) { if ( numTreeChildren == 0 ) { singleLevelRef = ( ( ASTReference ) nodeTree ) . getRootString ( ) ; } } } public boolean isConstant ( ) { return constant ; } public Object setObject ( InternalContextAdapter context , Object o ) { if ( type == ParserTreeConstants . JJTREFERENCE ) { if ( numTreeChildren > 0 ) { try { ( ( ASTReference ) nodeTree ) . setValue ( context , o ) ; } catch ( MethodInvocationException mie ) { rsvc . error ( "VMProxyArg.getObject() : method invocation error setting value : " + mie ) ; } } else { context . put ( singleLevelRef , o ) ; } } else { type = GENERALSTATIC ; staticObject = o ; rsvc . error ( "VMProxyArg.setObject() : Programmer error : I am a constant!  No setting! : " + contextReference + " / " + callerReference ) ; } return null ; } public Object getObject ( InternalContextAdapter context ) { try { Object retObject = null ; if ( type == ParserTreeConstants . JJTREFERENCE ) { if ( numTreeChildren == 0 ) { retObject = context . get ( singleLevelRef ) ; } else { retObject = nodeTree . execute ( null , context ) ; } } else if ( type == ParserTreeConstants . JJTOBJECTARRAY ) { retObject = nodeTree . value ( context ) ; } else if ( type == ParserTreeConstants . JJTINTEGERRANGE ) { retObject = nodeTree . value ( context ) ; } else if ( type == ParserTreeConstants . JJTTRUE ) { retObject = staticObject ; } else if ( type == ParserTreeConstants . JJTFALSE ) { retObject = staticObject ; } else if ( type == ParserTreeConstants . JJTSTRINGLITERAL ) { retObject = nodeTree . value ( context ) ; } else if ( type == ParserTreeConstants . JJTNUMBERLITERAL ) { retObject = staticObject ; } else if ( type == ParserTreeConstants . JJTTEXT ) { try { StringWriter writer = new StringWriter ( ) ; nodeTree . render ( context , writer ) ; retObject = writer ; } catch ( Exception e ) { rsvc . error ( "VMProxyArg.getObject() : error rendering reference : " + e ) ; } } else if ( type == GENERALSTATIC ) { retObject = staticObject ; } else { rsvc . error ( "Unsupported VM arg type : VM arg = " + callerReference + " type = " + type + "( VMProxyArg.getObject() )" ) ; } return retObject ; } catch ( MethodInvocationException mie ) { rsvc . error ( "VMProxyArg.getObject() : method invocation error getting value : " + mie ) ; return null ; } } private void setup ( ) { switch ( type ) { case ParserTreeConstants . JJTINTEGERRANGE : case ParserTreeConstants . JJTREFERENCE : case ParserTreeConstants . JJTOBJECTARRAY : case ParserTreeConstants . JJTSTRINGLITERAL : case ParserTreeConstants . JJTTEXT : { constant = false ; try { String buff = "#include(" + callerReference + " ) " ; BufferedReader br = new BufferedReader ( new StringReader ( buff ) ) ; nodeTree = rsvc . parse ( br , "VMProxyArg:" + callerReference , true ) ; nodeTree = ( SimpleNode ) nodeTree . jjtGetChild ( 0 ) . jjtGetChild ( 0 ) ; if ( nodeTree != null && nodeTree . getType ( ) != type ) { rsvc . error ( "VMProxyArg.setup() : programmer error : type doesn't match node type." ) ; } InternalContextAdapter ica = new InternalContextAdapterImpl ( new VelocityContext ( ) ) ; ica . pushCurrentTemplateName ( "VMProxyArg : " + ParserTreeConstants . jjtNodeName [ type ] ) ; nodeTree . init ( ica , rsvc ) ; } catch ( Exception e ) { rsvc . error ( "VMProxyArg.setup() : exception " + callerReference + " : " + StringUtils . stackTrace ( e ) ) ; } break ; } case ParserTreeConstants . JJTTRUE : { constant = true ; staticObject = new Boolean ( true ) ; break ; } case ParserTreeConstants . JJTFALSE : { constant = true ; staticObject = new Boolean ( false ) ; break ; } case ParserTreeConstants . JJTNUMBERLITERAL : { constant = true ; staticObject = new Integer ( callerReference ) ; break ; } case ParserTreeConstants . JJTWORD : { rsvc . error ( "Unsupported arg type : " + callerReference + "  You most likely intended to call a VM with a string literal, so enclose with ' or \" characters. (VMProxyArg.setup())" ) ; constant = true ; staticObject = new String ( callerReference ) ; break ; } default : { rsvc . error ( " VMProxyArg.setup() : unsupported type : " + callerReference ) ; } } } public VMProxyArg ( VMProxyArg model , InternalContextAdapter c ) { usercontext = c ; contextReference = model . getContextReference ( ) ; callerReference = model . getCallerReference ( ) ; nodeTree = model . getNodeTree ( ) ; staticObject = model . getStaticObject ( ) ; type = model . getType ( ) ; if ( nodeTree != null ) numTreeChildren = nodeTree . jjtGetNumChildren ( ) ; if ( type == ParserTreeConstants . JJTREFERENCE ) { if ( numTreeChildren == 0 ) { singleLevelRef = ( ( ASTReference ) nodeTree ) . getRootString ( ) ; } } } public String getCallerReference ( ) { return callerReference ; } public String getContextReference ( ) { return contextReference ; } public SimpleNode getNodeTree ( ) { return nodeTree ; } public Object getStaticObject ( ) { return staticObject ; } public int getType ( ) { return type ; } } 	1	['11', '1', '0', '14', '41', '0', '2', '12', '10', '0.654545455', '580', '1', '3', '0', '0.246753247', '0', '0', '50.72727273', '11', '2.1818', '2']
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . RuntimeLogger ; public abstract class AbstractExecutor { protected RuntimeLogger rlog = null ; protected Method method = null ; public abstract Object execute ( Object o ) throws IllegalAccessException , InvocationTargetException ; public boolean isAlive ( ) { return ( method != null ) ; } public Method getMethod ( ) { return method ; } } 	1	['4', '1', '2', '6', '5', '0', '5', '1', '4', '0.666666667', '25', '1', '1', '0', '0.625', '0', '0', '4.75', '2', '1', '1']
package org . apache . velocity . util . introspection ; public interface VelMethod { public Object invoke ( Object o , Object [ ] params ) throws Exception ; public boolean isCacheable ( ) ; public String getMethodName ( ) ; public Class getReturnType ( ) ; } 	1	['4', '1', '0', '5', '4', '6', '5', '0', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTParameters extends SimpleNode { public ASTParameters ( int id ) { super ( id ) ; } public ASTParameters ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	1	['3', '2', '0', '3', '6', '3', '0', '3', '3', '2', '17', '0', '0', '0.964285714', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '1']
package org . apache . velocity . app ; import java . io . Writer ; import java . util . Properties ; import java . io . InputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . InputStreamReader ; import java . io . UnsupportedEncodingException ; import org . apache . velocity . context . Context ; import org . apache . velocity . Template ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . configuration . Configuration ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . commons . collections . ExtendedProperties ; public class Velocity implements RuntimeConstants { public static void init ( ) throws Exception { RuntimeSingleton . init ( ) ; } public static void init ( String propsFilename ) throws Exception { RuntimeSingleton . init ( propsFilename ) ; } public static void init ( Properties p ) throws Exception { RuntimeSingleton . init ( p ) ; } public static void setProperty ( String key , Object value ) { RuntimeSingleton . setProperty ( key , value ) ; } public static void addProperty ( String key , Object value ) { RuntimeSingleton . addProperty ( key , value ) ; } public static void clearProperty ( String key ) { RuntimeSingleton . clearProperty ( key ) ; } public static void setConfiguration ( Configuration configuration ) { ExtendedProperties ep = configuration . getExtendedProperties ( ) ; RuntimeSingleton . setConfiguration ( ep ) ; } public static void setExtendedProperties ( ExtendedProperties configuration ) { RuntimeSingleton . setConfiguration ( configuration ) ; } public static Object getProperty ( String key ) { return RuntimeSingleton . getProperty ( key ) ; } public static boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { return evaluate ( context , out , logTag , new BufferedReader ( new StringReader ( instring ) ) ) ; } public static boolean evaluate ( Context context , Writer writer , String logTag , InputStream instream ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { BufferedReader br = null ; String encoding = null ; try { encoding = RuntimeSingleton . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ; br = new BufferedReader ( new InputStreamReader ( instream , encoding ) ) ; } catch ( UnsupportedEncodingException uce ) { String msg = "Unsupported input encoding : " + encoding + " for template " + logTag ; throw new ParseErrorException ( msg ) ; } return evaluate ( context , writer , logTag , br ) ; } public static boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { SimpleNode nodeTree = null ; try { nodeTree = RuntimeSingleton . parse ( reader , logTag ) ; } catch ( ParseException pex ) { throw new ParseErrorException ( pex . getMessage ( ) ) ; } if ( nodeTree != null ) { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( context ) ; ica . pushCurrentTemplateName ( logTag ) ; try { try { nodeTree . init ( ica , RuntimeSingleton . getRuntimeServices ( ) ) ; } catch ( Exception e ) { RuntimeSingleton . error ( "Velocity.evaluate() : init exception for tag = " + logTag + " : " + e ) ; } nodeTree . render ( ica , writer ) ; } finally { ica . popCurrentTemplateName ( ) ; } return true ; } return false ; } public static boolean invokeVelocimacro ( String vmName , String logTag , String params [ ] , Context context , Writer writer ) { if ( vmName == null || params == null || context == null || writer == null || logTag == null ) { RuntimeSingleton . error ( "Velocity.invokeVelocimacro() : invalid parameter" ) ; return false ; } if ( ! RuntimeSingleton . isVelocimacro ( vmName , logTag ) ) { RuntimeSingleton . error ( "Velocity.invokeVelocimacro() : VM '" + vmName + "' not registered." ) ; return false ; } StringBuffer construct = new StringBuffer ( "#" ) ; construct . append ( vmName ) ; construct . append ( "(" ) ; for ( int i = 0 ; i < params . length ; i ++ ) { construct . append ( " $" ) ; construct . append ( params [ i ] ) ; } construct . append ( " )" ) ; try { boolean retval = evaluate ( context , writer , logTag , construct . toString ( ) ) ; return retval ; } catch ( Exception e ) { RuntimeSingleton . error ( "Velocity.invokeVelocimacro() : error " + e ) ; } return false ; } public static boolean mergeTemplate ( String templateName , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { return mergeTemplate ( templateName , RuntimeSingleton . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) , context , writer ) ; } public static boolean mergeTemplate ( String templateName , String encoding , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { Template template = RuntimeSingleton . getTemplate ( templateName , encoding ) ; if ( template == null ) { RuntimeSingleton . error ( "Velocity.parseTemplate() failed loading template '" + templateName + "'" ) ; return false ; } else { template . merge ( context , writer ) ; return true ; } } public static Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name ) ; } public static Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name , encoding ) ; } public static boolean resourceExists ( String resourceName ) { return ( RuntimeSingleton . getLoaderNameForResource ( resourceName ) != null ) ; } public static void warn ( Object message ) { RuntimeSingleton . warn ( message ) ; } public static void info ( Object message ) { RuntimeSingleton . info ( message ) ; } public static void error ( Object message ) { RuntimeSingleton . error ( message ) ; } public static void debug ( Object message ) { RuntimeSingleton . debug ( message ) ; } public static void setApplicationAttribute ( Object key , Object value ) { RuntimeSingleton . getRuntimeInstance ( ) . setApplicationAttribute ( key , value ) ; } public static boolean templateExists ( String resourceName ) { return resourceExists ( resourceName ) ; } } 	1	['25', '1', '0', '29', '64', '300', '14', '15', '25', '2', '332', '0', '0', '0', '0.149090909', '0', '0', '12.28', '8', '1.28', '2']
package org . apache . velocity . convert ; import java . io . File ; import java . io . FileWriter ; import org . apache . oro . text . perl . Perl5Util ; import org . apache . velocity . util . StringUtils ; import org . apache . tools . ant . DirectoryScanner ; public class WebMacro { protected static final String VM_EXT = ".vm" ; protected static final String WM_EXT = ".wm" ; protected static String [ ] perLineREs = { "#if\\s*[(]\\s*(.*\\S)\\s*[)]\\s*(#begin|{)[ \\t]?" , "#if( $1 )" , "[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?(\\w)" , "$2#else#**#$4" , "[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?" , "$2#else" , "(#end|})(\\s*#else)\\s*(#begin|{)[ \\t]?" , "$1\n$2" , "#foreach\\s+(\\$\\w+)\\s+in\\s+(\\$[^\\s#]+)\\s*(#begin|{)[ \\t]?" , "#foreach( $1 in $2 )" , "#set\\s+(\\$[^\\s=]+)\\s*=\\s*([\\S \\t]+)" , "#set( $1 = $2 )" , "(##[# \\t\\w]*)\\)" , ")$1" , "#parse\\s+([^\\s#]+)[ \\t]?" , "#parse( $1 )" , "#include\\s+([^\\s#]+)[ \\t]?" , "#include( $1 )" , "\\$\\(([^\\)]+)\\)" , "${$1}" , "\\${([^}\\(]+)\\(([^}]+)}\\)" , "${$1($2)}" , "\\$_" , "$l_" , "\\${(_[^}]+)}" , "${l$1}" , "(#set\\s*\\([^;]+);(\\s*\\))" , "$1$2" , "(^|[^\\\\])\\$(\\w[^=\n;'\"]*);" , "$1${$2}" , "\\.wm" , ".vm" } ; public void convert ( String target ) { File file = new File ( target ) ; if ( ! file . exists ( ) ) { System . err . println ( "The specified template or directory does not exist" ) ; System . exit ( 1 ) ; } if ( file . isDirectory ( ) ) { String basedir = file . getAbsolutePath ( ) ; String newBasedir = basedir + VM_EXT ; DirectoryScanner ds = new DirectoryScanner ( ) ; ds . setBasedir ( basedir ) ; ds . addDefaultExcludes ( ) ; ds . scan ( ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { writeTemplate ( files [ i ] , basedir , newBasedir ) ; } } else { writeTemplate ( file . getAbsolutePath ( ) , "" , "" ) ; } } private boolean writeTemplate ( String file , String basedir , String newBasedir ) { if ( file . indexOf ( WM_EXT ) < 0 ) { return false ; } System . out . println ( "Converting " + file + "..." ) ; String template ; String templateDir ; String newTemplate ; File outputDirectory ; if ( basedir . length ( ) == 0 ) { template = file ; templateDir = "" ; newTemplate = convertName ( file ) ; } else { template = basedir + File . separator + file ; templateDir = newBasedir + extractPath ( file ) ; outputDirectory = new File ( templateDir ) ; if ( ! outputDirectory . exists ( ) ) { outputDirectory . mkdirs ( ) ; } newTemplate = newBasedir + File . separator + convertName ( file ) ; } String convertedTemplate = convertTemplate ( template ) ; try { FileWriter fw = new FileWriter ( newTemplate ) ; fw . write ( convertedTemplate ) ; fw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return true ; } private final String extractPath ( String file ) { int lastSepPos = file . lastIndexOf ( File . separator ) ; return ( lastSepPos == - 1 ? "" : File . separator + file . substring ( 0 , lastSepPos ) ) ; } private String convertName ( String name ) { if ( name . indexOf ( WM_EXT ) > 0 ) { return name . substring ( 0 , name . indexOf ( WM_EXT ) ) + VM_EXT ; } else { return name ; } } private static final void usage ( ) { System . err . println ( "Usage: convert-wm <template.wm | directory>" ) ; System . exit ( 1 ) ; } public String convertTemplate ( String template ) { String contents = StringUtils . fileContentsToString ( template ) ; if ( ! contents . endsWith ( "\n" ) ) { contents += "\n" ; } Perl5Util perl = new Perl5Util ( ) ; for ( int i = 0 ; i < perLineREs . length ; i += 2 ) { contents = perl . substitute ( makeSubstRE ( i ) , contents ) ; } if ( perl . match ( "m/javascript/i" , contents ) ) { contents = perl . substitute ( "s/\n}/\n#end/g" , contents ) ; } else { contents = perl . substitute ( "s/(\n\\s*)}/$1#end/g" , contents ) ; contents = perl . substitute ( "s/#end\\s*\n\\s*#else/#else/g" , contents ) ; } return contents ; } private final String makeSubstRE ( int i ) { return ( "s/" + perLineREs [ i ] + '/' + perLineREs [ i + 1 ] + "/g" ) ; } public static void main ( String [ ] args ) { if ( args . length > 0 ) { for ( int x = 0 ; x < args . length ; x ++ ) { WebMacro converter = new WebMacro ( ) ; converter . convert ( args [ x ] ) ; } } else { usage ( ) ; } } } 	1	['10', '1', '0', '3', '40', '39', '0', '3', '4', '0.962962963', '460', '1', '0', '0', '0.388888889', '0', '0', '44.7', '4', '2.1', '1']
package org . apache . velocity . context ; public interface InternalWrapperContext { public Context getInternalUserContext ( ) ; public InternalContextAdapter getBaseContext ( ) ; } 	1	['2', '1', '0', '3', '2', '1', '2', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTEscape extends SimpleNode { public String val ; private char [ ] ctext ; public ASTEscape ( int id ) { super ( id ) ; } public ASTEscape ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { ctext = val . toCharArray ( ) ; return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { writer . write ( ctext ) ; return true ; } } 	1	['5', '2', '0', '4', '10', '8', '1', '4', '5', '0.875', '34', '0.5', '0', '0.9', '0.4', '0', '0', '5.4', '1', '0.6', '2']
package org . apache . velocity . runtime . directive ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . resource . Resource ; public abstract class InputBase extends Directive { protected String getInputEncoding ( InternalContextAdapter context ) { Resource current = context . getCurrentResource ( ) ; if ( current != null ) { return current . getEncoding ( ) ; } else { return ( String ) rsvc . getProperty ( RuntimeConstants . INPUT_ENCODING ) ; } } } 	1	['2', '2', '2', '6', '6', '1', '2', '4', '1', '2', '19', '0', '0', '0.875', '0.75', '0', '0', '8.5', '2', '1', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTElseStatement extends SimpleNode { public ASTElseStatement ( int id ) { super ( id ) ; } public ASTElseStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) { return true ; } } 	1	['4', '2', '0', '6', '7', '6', '4', '4', '4', '2', '20', '0', '0', '0.931034483', '0.416666667', '0', '0', '4', '1', '0.5', '1']
package org . apache . velocity . runtime . log ; import java . util . Date ; import org . apache . log . format . PatternFormatter ; public class VelocityFormatter extends PatternFormatter { public VelocityFormatter ( String format ) { super ( format ) ; } protected String getTime ( final long time , final String format ) { return new Date ( ) . toString ( ) ; } } 	1	['2', '2', '0', '2', '5', '1', '1', '1', '1', '2', '11', '0', '0', '0.947368421', '0.833333333', '1', '2', '4.5', '1', '0.5', '1']
package org . apache . velocity . util . introspection ; public interface VelPropertySet { public Object invoke ( Object o , Object arg ) throws Exception ; public boolean isCacheable ( ) ; public String getMethodName ( ) ; } 	1	['3', '1', '0', '4', '3', '3', '4', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . anakia ; import java . io . IOException ; import java . io . StringWriter ; import org . jdom . Element ; import org . jdom . output . XMLOutputter ; public class OutputWrapper extends XMLOutputter { public OutputWrapper ( ) { } public String outputString ( Element element , boolean strip ) { StringWriter buff = new StringWriter ( ) ; String name = element . getName ( ) ; try { outputElementContent ( element , buff ) ; } catch ( IOException e ) { } return buff . toString ( ) ; } } 	1	['2', '2', '0', '3', '7', '1', '1', '2', '2', '2', '21', '0', '0', '0.987179487', '0.666666667', '1', '1', '9.5', '1', '0.5', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import org . apache . velocity . util . introspection . Info ; import org . apache . velocity . util . introspection . VelPropertyGet ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . app . event . EventCartridge ; import java . lang . reflect . InvocationTargetException ; public class ASTIdentifier extends SimpleNode { private String identifier = "" ; protected Info uberInfo ; public ASTIdentifier ( int id ) { super ( id ) ; } public ASTIdentifier ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { super . init ( context , data ) ; identifier = getFirstToken ( ) . image ; uberInfo = new Info ( context . getCurrentTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; return data ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { VelPropertyGet vg = null ; try { Class c = o . getClass ( ) ; IntrospectionCacheData icd = context . icacheGet ( this ) ; if ( icd != null && icd . contextData == c ) { vg = ( VelPropertyGet ) icd . thingy ; } else { vg = rsvc . getUberspect ( ) . getPropertyGet ( o , identifier , uberInfo ) ; if ( vg != null && vg . isCacheable ( ) ) { icd = new IntrospectionCacheData ( ) ; icd . contextData = c ; icd . thingy = vg ; context . icachePut ( this , icd ) ; } } } catch ( Exception e ) { rsvc . error ( "ASTIdentifier.execute() : identifier = " + identifier + " : " + e ) ; } if ( vg == null ) { return null ; } try { return vg . invoke ( o ) ; } catch ( InvocationTargetException ite ) { EventCartridge ec = context . getEventCartridge ( ) ; if ( ec != null && ite . getTargetException ( ) instanceof java . lang . Exception ) { try { return ec . methodException ( o . getClass ( ) , vg . getMethodName ( ) , ( Exception ) ite . getTargetException ( ) ) ; } catch ( Exception e ) { throw new MethodInvocationException ( "Invocation of method '" + vg . getMethodName ( ) + "'" + " in  " + o . getClass ( ) + " threw exception " + ite . getTargetException ( ) . getClass ( ) + " : " + ite . getTargetException ( ) . getMessage ( ) , ite . getTargetException ( ) , vg . getMethodName ( ) ) ; } } else { throw new MethodInvocationException ( "Invocation of method '" + vg . getMethodName ( ) + "'" + " in  " + o . getClass ( ) + " threw exception " + ite . getTargetException ( ) . getClass ( ) + " : " + ite . getTargetException ( ) . getMessage ( ) , ite . getTargetException ( ) , vg . getMethodName ( ) ) ; } } catch ( IllegalArgumentException iae ) { return null ; } catch ( Exception e ) { rsvc . error ( "ASTIdentifier() : exception invoking method " + "for identifier '" + identifier + "' in " + o . getClass ( ) + " : " + e ) ; } return null ; } } 	1	['5', '2', '0', '16', '33', '0', '4', '14', '5', '0.5', '245', '1', '1', '0.9', '0.466666667', '0', '0', '47.6', '1', '0.6', '3']
package org . apache . velocity . exception ; public class VelocityException extends Exception { public VelocityException ( String exceptionMessage ) { super ( exceptionMessage ) ; } } 	1	['1', '3', '3', '3', '2', '0', '3', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '2']
package org . apache . velocity . util . introspection ; import java . util . Iterator ; import java . util . List ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . Set ; import java . util . HashSet ; import java . util . Map ; import java . util . Hashtable ; import java . lang . reflect . Method ; public class MethodMap { private static final int MORE_SPECIFIC = 0 ; private static final int LESS_SPECIFIC = 1 ; private static final int INCOMPARABLE = 2 ; Map methodByNameMap = new Hashtable ( ) ; public void add ( Method method ) { String methodName = method . getName ( ) ; List l = get ( methodName ) ; if ( l == null ) { l = new ArrayList ( ) ; methodByNameMap . put ( methodName , l ) ; } l . add ( method ) ; return ; } public List get ( String key ) { return ( List ) methodByNameMap . get ( key ) ; } public Method find ( String methodName , Object [ ] args ) throws AmbiguousException { List methodList = get ( methodName ) ; if ( methodList == null ) { return null ; } int l = args . length ; Class [ ] classes = new Class [ l ] ; for ( int i = 0 ; i < l ; ++ i ) { Object arg = args [ i ] ; classes [ i ] = arg == null ? null : arg . getClass ( ) ; } return getMostSpecific ( methodList , classes ) ; } public static class AmbiguousException extends Exception { } private static Method getMostSpecific ( List methods , Class [ ] classes ) throws AmbiguousException { LinkedList applicables = getApplicables ( methods , classes ) ; if ( applicables . isEmpty ( ) ) { return null ; } if ( applicables . size ( ) == 1 ) { return ( Method ) applicables . getFirst ( ) ; } LinkedList maximals = new LinkedList ( ) ; for ( Iterator applicable = applicables . iterator ( ) ; applicable . hasNext ( ) ; ) { Method app = ( Method ) applicable . next ( ) ; Class [ ] appArgs = app . getParameterTypes ( ) ; boolean lessSpecific = false ; for ( Iterator maximal = maximals . iterator ( ) ; ! lessSpecific && maximal . hasNext ( ) ; ) { Method max = ( Method ) maximal . next ( ) ; switch ( moreSpecific ( appArgs , max . getParameterTypes ( ) ) ) { case MORE_SPECIFIC : { maximal . remove ( ) ; break ; } case LESS_SPECIFIC : { lessSpecific = true ; break ; } } } if ( ! lessSpecific ) { maximals . addLast ( app ) ; } } if ( maximals . size ( ) > 1 ) { throw new AmbiguousException ( ) ; } return ( Method ) maximals . getFirst ( ) ; } private static int moreSpecific ( Class [ ] c1 , Class [ ] c2 ) { boolean c1MoreSpecific = false ; boolean c2MoreSpecific = false ; for ( int i = 0 ; i < c1 . length ; ++ i ) { if ( c1 [ i ] != c2 [ i ] ) { c1MoreSpecific = c1MoreSpecific || isStrictMethodInvocationConvertible ( c2 [ i ] , c1 [ i ] ) ; c2MoreSpecific = c2MoreSpecific || isStrictMethodInvocationConvertible ( c1 [ i ] , c2 [ i ] ) ; } } if ( c1MoreSpecific ) { if ( c2MoreSpecific ) { return INCOMPARABLE ; } return MORE_SPECIFIC ; } if ( c2MoreSpecific ) { return LESS_SPECIFIC ; } return INCOMPARABLE ; } private static LinkedList getApplicables ( List methods , Class [ ] classes ) { LinkedList list = new LinkedList ( ) ; for ( Iterator imethod = methods . iterator ( ) ; imethod . hasNext ( ) ; ) { Method method = ( Method ) imethod . next ( ) ; if ( isApplicable ( method , classes ) ) { list . add ( method ) ; } } return list ; } private static boolean isApplicable ( Method method , Class [ ] classes ) { Class [ ] methodArgs = method . getParameterTypes ( ) ; if ( methodArgs . length != classes . length ) { return false ; } for ( int i = 0 ; i < classes . length ; ++ i ) { if ( ! isMethodInvocationConvertible ( methodArgs [ i ] , classes [ i ] ) ) { return false ; } } return true ; } private static boolean isMethodInvocationConvertible ( Class formal , Class actual ) { if ( actual == null && ! formal . isPrimitive ( ) ) { return true ; } if ( actual != null && formal . isAssignableFrom ( actual ) ) { return true ; } if ( formal . isPrimitive ( ) ) { if ( formal == Boolean . TYPE && actual == Boolean . class ) return true ; if ( formal == Character . TYPE && actual == Character . class ) return true ; if ( formal == Byte . TYPE && actual == Byte . class ) return true ; if ( formal == Short . TYPE && ( actual == Short . class || actual == Byte . class ) ) return true ; if ( formal == Integer . TYPE && ( actual == Integer . class || actual == Short . class || actual == Byte . class ) ) return true ; if ( formal == Long . TYPE && ( actual == Long . class || actual == Integer . class || actual == Short . class || actual == Byte . class ) ) return true ; if ( formal == Float . TYPE && ( actual == Float . class || actual == Long . class || actual == Integer . class || actual == Short . class || actual == Byte . class ) ) return true ; if ( formal == Double . TYPE && ( actual == Double . class || actual == Float . class || actual == Long . class || actual == Integer . class || actual == Short . class || actual == Byte . class ) ) return true ; } return false ; } private static boolean isStrictMethodInvocationConvertible ( Class formal , Class actual ) { if ( actual == null && ! formal . isPrimitive ( ) ) { return true ; } if ( formal . isAssignableFrom ( actual ) ) { return true ; } if ( formal . isPrimitive ( ) ) { if ( formal == Short . TYPE && ( actual == Byte . TYPE ) ) return true ; if ( formal == Integer . TYPE && ( actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; if ( formal == Long . TYPE && ( actual == Integer . TYPE || actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; if ( formal == Float . TYPE && ( actual == Long . TYPE || actual == Integer . TYPE || actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; if ( formal == Double . TYPE && ( actual == Float . TYPE || actual == Long . TYPE || actual == Integer . TYPE || actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; } return false ; } } 	1	['11', '1', '0', '2', '37', '49', '1', '1', '4', '0.933333333', '680', '0.25', '0', '0', '0.233766234', '0', '0', '59.72727273', '60', '9.8182', '2']
package org . apache . velocity . app ; import java . io . Writer ; import java . util . Properties ; import java . io . InputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . InputStreamReader ; import java . io . UnsupportedEncodingException ; import org . apache . velocity . context . Context ; import org . apache . velocity . Template ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . runtime . RuntimeInstance ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . configuration . Configuration ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . commons . collections . ExtendedProperties ; public class VelocityEngine implements RuntimeConstants { private RuntimeInstance ri = new RuntimeInstance ( ) ; public void init ( ) throws Exception { ri . init ( ) ; } public void init ( String propsFilename ) throws Exception { ri . init ( propsFilename ) ; } public void init ( Properties p ) throws Exception { ri . init ( p ) ; } public void setProperty ( String key , Object value ) { ri . setProperty ( key , value ) ; } public void addProperty ( String key , Object value ) { ri . addProperty ( key , value ) ; } public void clearProperty ( String key ) { ri . clearProperty ( key ) ; } public void setConfiguration ( Configuration configuration ) { ExtendedProperties ep = configuration . getExtendedProperties ( ) ; ri . setConfiguration ( ep ) ; } public void setExtendedProperties ( ExtendedProperties configuration ) { ri . setConfiguration ( configuration ) ; } public Object getProperty ( String key ) { return ri . getProperty ( key ) ; } public boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { return evaluate ( context , out , logTag , new BufferedReader ( new StringReader ( instring ) ) ) ; } public boolean evaluate ( Context context , Writer writer , String logTag , InputStream instream ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { BufferedReader br = null ; String encoding = null ; try { encoding = ri . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ; br = new BufferedReader ( new InputStreamReader ( instream , encoding ) ) ; } catch ( UnsupportedEncodingException uce ) { String msg = "Unsupported input encoding : " + encoding + " for template " + logTag ; throw new ParseErrorException ( msg ) ; } return evaluate ( context , writer , logTag , br ) ; } public boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { SimpleNode nodeTree = null ; try { nodeTree = ri . parse ( reader , logTag ) ; } catch ( ParseException pex ) { throw new ParseErrorException ( pex . getMessage ( ) ) ; } if ( nodeTree != null ) { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( context ) ; ica . pushCurrentTemplateName ( logTag ) ; try { try { nodeTree . init ( ica , ri ) ; } catch ( Exception e ) { ri . error ( "Velocity.evaluate() : init exception for tag = " + logTag + " : " + e ) ; } nodeTree . render ( ica , writer ) ; } finally { ica . popCurrentTemplateName ( ) ; } return true ; } return false ; } public boolean invokeVelocimacro ( String vmName , String logTag , String params [ ] , Context context , Writer writer ) throws Exception { if ( vmName == null || params == null || context == null || writer == null || logTag == null ) { ri . error ( "VelocityEngine.invokeVelocimacro() : invalid parameter" ) ; return false ; } if ( ! ri . isVelocimacro ( vmName , logTag ) ) { ri . error ( "VelocityEngine.invokeVelocimacro() : VM '" + vmName + "' not registered." ) ; return false ; } StringBuffer construct = new StringBuffer ( "#" ) ; construct . append ( vmName ) ; construct . append ( "(" ) ; for ( int i = 0 ; i < params . length ; i ++ ) { construct . append ( " $" ) ; construct . append ( params [ i ] ) ; } construct . append ( " )" ) ; try { boolean retval = evaluate ( context , writer , logTag , construct . toString ( ) ) ; return retval ; } catch ( Exception e ) { ri . error ( "VelocityEngine.invokeVelocimacro() : error " + e ) ; throw e ; } } public boolean mergeTemplate ( String templateName , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { return mergeTemplate ( templateName , ri . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) , context , writer ) ; } public boolean mergeTemplate ( String templateName , String encoding , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { Template template = ri . getTemplate ( templateName , encoding ) ; if ( template == null ) { ri . error ( "Velocity.parseTemplate() failed loading template '" + templateName + "'" ) ; return false ; } else { template . merge ( context , writer ) ; return true ; } } public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name ) ; } public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name , encoding ) ; } public boolean templateExists ( String templateName ) { return ( ri . getLoaderNameForResource ( templateName ) != null ) ; } public void warn ( Object message ) { ri . warn ( message ) ; } public void info ( Object message ) { ri . info ( message ) ; } public void error ( Object message ) { ri . error ( message ) ; } public void debug ( Object message ) { ri . debug ( message ) ; } public void setApplicationAttribute ( Object key , Object value ) { ri . setApplicationAttribute ( key , value ) ; } } 	1	['24', '1', '0', '19', '62', '0', '6', '13', '24', '0', '392', '1', '1', '0', '0.238636364', '0', '0', '15.29166667', '2', '1', '3']
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . StringReader ; import java . util . HashMap ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . context . VMContext ; import org . apache . velocity . runtime . visitor . VMReferenceMungeVisitor ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . exception . MethodInvocationException ; public class VelocimacroProxy extends Directive { private String macroName = "" ; private String macroBody = "" ; private String [ ] argArray = null ; private SimpleNode nodeTree = null ; private int numMacroArgs = 0 ; private String namespace = "" ; private boolean init = false ; private String [ ] callingArgs ; private int [ ] callingArgTypes ; private HashMap proxyArgHash = new HashMap ( ) ; public String getName ( ) { return macroName ; } public int getType ( ) { return LINE ; } public void setName ( String name ) { macroName = name ; } public void setArgArray ( String [ ] arr ) { argArray = arr ; numMacroArgs = argArray . length - 1 ; } public void setNodeTree ( SimpleNode tree ) { nodeTree = tree ; } public int getNumArgs ( ) { return numMacroArgs ; } public void setMacrobody ( String mb ) { macroBody = mb ; } public void setNamespace ( String ns ) { this . namespace = ns ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException { try { if ( nodeTree != null ) { if ( ! init ) { nodeTree . init ( context , rsvc ) ; init = true ; } VMContext vmc = new VMContext ( context , rsvc ) ; for ( int i = 1 ; i < argArray . length ; i ++ ) { VMProxyArg arg = ( VMProxyArg ) proxyArgHash . get ( argArray [ i ] ) ; vmc . addVMProxyArg ( arg ) ; } nodeTree . render ( vmc , writer ) ; } else { rsvc . error ( "VM error : " + macroName + ". Null AST" ) ; } } catch ( Exception e ) { if ( e instanceof MethodInvocationException ) { throw ( MethodInvocationException ) e ; } rsvc . error ( "VelocimacroProxy.render() : exception VM = #" + macroName + "() : " + StringUtils . stackTrace ( e ) ) ; } return true ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws Exception { super . init ( rs , context , node ) ; int i = node . jjtGetNumChildren ( ) ; if ( getNumArgs ( ) != i ) { rsvc . error ( "VM #" + macroName + ": error : too " + ( ( getNumArgs ( ) > i ) ? "few" : "many" ) + " arguments to macro. Wanted " + getNumArgs ( ) + " got " + i ) ; return ; } callingArgs = getArgArray ( node ) ; setupMacro ( callingArgs , callingArgTypes ) ; return ; } public boolean setupMacro ( String [ ] callArgs , int [ ] callArgTypes ) { setupProxyArgs ( callArgs , callArgTypes ) ; parseTree ( callArgs ) ; return true ; } private void parseTree ( String [ ] callArgs ) { try { BufferedReader br = new BufferedReader ( new StringReader ( macroBody ) ) ; nodeTree = rsvc . parse ( br , namespace , false ) ; HashMap hm = new HashMap ( ) ; for ( int i = 1 ; i < argArray . length ; i ++ ) { String arg = callArgs [ i - 1 ] ; if ( arg . charAt ( 0 ) == '$' ) { hm . put ( argArray [ i ] , arg ) ; } } VMReferenceMungeVisitor v = new VMReferenceMungeVisitor ( hm ) ; nodeTree . jjtAccept ( v , null ) ; } catch ( Exception e ) { rsvc . error ( "VelocimacroManager.parseTree() : exception " + macroName + " : " + StringUtils . stackTrace ( e ) ) ; } } private void setupProxyArgs ( String [ ] callArgs , int [ ] callArgTypes ) { for ( int i = 1 ; i < argArray . length ; i ++ ) { VMProxyArg arg = new VMProxyArg ( rsvc , argArray [ i ] , callArgs [ i - 1 ] , callArgTypes [ i - 1 ] ) ; proxyArgHash . put ( argArray [ i ] , arg ) ; } } private String [ ] getArgArray ( Node node ) { int numArgs = node . jjtGetNumChildren ( ) ; String args [ ] = new String [ numArgs ] ; callingArgTypes = new int [ numArgs ] ; int i = 0 ; Token t = null ; Token tLast = null ; while ( i < numArgs ) { args [ i ] = "" ; callingArgTypes [ i ] = node . jjtGetChild ( i ) . getType ( ) ; if ( false && node . jjtGetChild ( i ) . getType ( ) == ParserTreeConstants . JJTSTRINGLITERAL ) { args [ i ] += node . jjtGetChild ( i ) . getFirstToken ( ) . image . substring ( 1 , node . jjtGetChild ( i ) . getFirstToken ( ) . image . length ( ) - 1 ) ; } else { t = node . jjtGetChild ( i ) . getFirstToken ( ) ; tLast = node . jjtGetChild ( i ) . getLastToken ( ) ; while ( t != tLast ) { args [ i ] += t . image ; t = t . next ; } args [ i ] += t . image ; } i ++ ; } return args ; } } 	1	['15', '2', '0', '16', '42', '41', '3', '13', '12', '0.792857143', '445', '1', '1', '0.333333333', '0.237037037', '0', '0', '28', '3', '1.2667', '4']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTAssignment extends SimpleNode { public ASTAssignment ( int id ) { super ( id ) ; } public ASTAssignment ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	1	['3', '2', '0', '5', '6', '3', '4', '3', '3', '2', '17', '0', '0', '0.964285714', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '1']
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ResourceNotFoundException ; public class Include extends InputBase { private String outputMsgStart = "" ; private String outputMsgEnd = "" ; public String getName ( ) { return "include" ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws Exception { super . init ( rs , context , node ) ; outputMsgStart = rsvc . getString ( RuntimeConstants . ERRORMSG_START ) ; outputMsgStart = outputMsgStart + " " ; outputMsgEnd = rsvc . getString ( RuntimeConstants . ERRORMSG_END ) ; outputMsgEnd = " " + outputMsgEnd ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , ResourceNotFoundException { int argCount = node . jjtGetNumChildren ( ) ; for ( int i = 0 ; i < argCount ; i ++ ) { Node n = node . jjtGetChild ( i ) ; if ( n . getType ( ) == ParserTreeConstants . JJTSTRINGLITERAL || n . getType ( ) == ParserTreeConstants . JJTREFERENCE ) { if ( ! renderOutput ( n , context , writer ) ) outputErrorToStream ( writer , "error with arg " + i + " please see log." ) ; } else { rsvc . error ( "#include() error : invalid argument type : " + n . toString ( ) ) ; outputErrorToStream ( writer , "error with arg " + i + " please see log." ) ; } } return true ; } private boolean renderOutput ( Node node , InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException { String arg = "" ; if ( node == null ) { rsvc . error ( "#include() error :  null argument" ) ; return false ; } Object value = node . value ( context ) ; if ( value == null ) { rsvc . error ( "#include() error :  null argument" ) ; return false ; } arg = value . toString ( ) ; Resource resource = null ; try { resource = rsvc . getContent ( arg , getInputEncoding ( context ) ) ; } catch ( ResourceNotFoundException rnfe ) { rsvc . error ( "#include(): cannot find resource '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw rnfe ; } catch ( Exception e ) { rsvc . error ( "#include(): arg = '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ") : " + e ) ; } if ( resource == null ) return false ; writer . write ( ( String ) resource . getData ( ) ) ; return true ; } private void outputErrorToStream ( Writer writer , String msg ) throws IOException { if ( outputMsgStart != null && outputMsgEnd != null ) { writer . write ( outputMsgStart ) ; writer . write ( msg ) ; writer . write ( outputMsgEnd ) ; } return ; } } 	1	['7', '3', '0', '10', '28', '15', '0', '10', '5', '0.5', '258', '1', '0', '0.571428571', '0.428571429', '0', '0', '35.57142857', '1', '0.8571', '2']
package org . apache . velocity . app . event ; public interface NullSetEventHandler extends EventHandler { public boolean shouldLogOnNullSet ( String lhs , String rhs ) ; } 	1	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . runtime . resource ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . resource . loader . ResourceLoader ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; public abstract class Resource { protected RuntimeServices rsvc = null ; protected ResourceLoader resourceLoader ; protected static final long MILLIS_PER_SECOND = 1000 ; protected long modificationCheckInterval = 0 ; protected long lastModified = 0 ; protected long nextCheck = 0 ; protected String name ; protected String encoding = RuntimeConstants . ENCODING_DEFAULT ; protected Object data = null ; public Resource ( ) { } public void setRuntimeServices ( RuntimeServices rs ) { rsvc = rs ; } public abstract boolean process ( ) throws ResourceNotFoundException , ParseErrorException , Exception ; public boolean isSourceModified ( ) { return resourceLoader . isSourceModified ( this ) ; } public void setModificationCheckInterval ( long modificationCheckInterval ) { this . modificationCheckInterval = modificationCheckInterval ; } public boolean requiresChecking ( ) { if ( modificationCheckInterval <= 0 ) { return false ; } return ( System . currentTimeMillis ( ) >= nextCheck ) ; } public void touch ( ) { nextCheck = System . currentTimeMillis ( ) + ( MILLIS_PER_SECOND * modificationCheckInterval ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public long getLastModified ( ) { return lastModified ; } public void setLastModified ( long lastModified ) { this . lastModified = lastModified ; } public ResourceLoader getResourceLoader ( ) { return resourceLoader ; } public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } public void setData ( Object data ) { this . data = data ; } public Object getData ( ) { return data ; } } 	1	['17', '1', '2', '24', '20', '96', '21', '4', '17', '0.902777778', '120', '1', '2', '0', '0.235294118', '0', '0', '5.529411765', '3', '1.0588', '1']
package org . apache . velocity . anakia ; import org . jdom . Element ; import org . jdom . Namespace ; import org . jdom . output . XMLOutputter ; import java . util . List ; public class AnakiaElement extends Element { private static final XMLOutputter DEFAULT_OUTPUTTER = new XMLOutputter ( ) ; public AnakiaElement ( String name , Namespace namespace ) { super ( name , namespace ) ; } public AnakiaElement ( String name ) { super ( name ) ; } public AnakiaElement ( String name , String uri ) { super ( name , uri ) ; } public AnakiaElement ( String name , String prefix , String uri ) { super ( name , prefix , uri ) ; } public NodeList selectNodes ( String xpathExpression ) { return new NodeList ( XPathCache . getXPath ( xpathExpression ) . applyTo ( this ) , false ) ; } public String toString ( ) { return DEFAULT_OUTPUTTER . outputString ( this ) ; } public List getContent ( ) { return new NodeList ( super . getContent ( ) , false ) ; } public List getChildren ( ) { return new NodeList ( super . getChildren ( ) , false ) ; } public List getChildren ( String name ) { return new NodeList ( super . getChildren ( name ) ) ; } public List getChildren ( String name , Namespace ns ) { return new NodeList ( super . getChildren ( name , ns ) ) ; } public List getAttributes ( ) { return new NodeList ( super . getAttributes ( ) ) ; } } 	1	['12', '2', '0', '7', '27', '64', '1', '6', '11', '0.909090909', '86', '1', '0', '0.914634146', '0.606060606', '1', '1', '6.083333333', '1', '0.5833', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; public class ASTBlock extends SimpleNode { public ASTBlock ( int id ) { super ( id ) ; } public ASTBlock ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) jjtGetChild ( i ) . render ( context , writer ) ; return true ; } } 	1	['4', '2', '0', '10', '10', '6', '4', '8', '4', '2', '37', '0', '0', '0.931034483', '0.392857143', '1', '1', '8.25', '1', '0.5', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . * ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; public class ASTElseIfStatement extends SimpleNode { public ASTElseIfStatement ( int id ) { super ( id ) ; } public ASTElseIfStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { return jjtGetChild ( 0 ) . evaluate ( context ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { return jjtGetChild ( 1 ) . render ( context , writer ) ; } } 	1	['5', '2', '0', '10', '11', '10', '4', '8', '5', '2', '32', '0', '0', '0.9', '0.371428571', '1', '2', '5.4', '1', '0.6', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . Context ; import org . apache . velocity . runtime . parser . * ; public class NodeUtils { public static String specialText ( Token t ) { String specialText = "" ; if ( t . specialToken == null || t . specialToken . image . startsWith ( "##" ) ) return specialText ; Token tmp_t = t . specialToken ; while ( tmp_t . specialToken != null ) { tmp_t = tmp_t . specialToken ; } while ( tmp_t != null ) { String st = tmp_t . image ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { char c = st . charAt ( i ) ; if ( c == '#' || c == '$' ) { sb . append ( c ) ; } if ( c == '\\' ) { boolean ok = true ; boolean term = false ; int j = i ; for ( ok = true ; ok && j < st . length ( ) ; j ++ ) { char cc = st . charAt ( j ) ; if ( cc == '\\' ) { continue ; } else if ( cc == '$' ) { term = true ; ok = false ; } else { ok = false ; } } if ( term ) { String foo = st . substring ( i , j ) ; sb . append ( foo ) ; i = j ; } } } specialText += sb . toString ( ) ; tmp_t = tmp_t . next ; } return specialText ; } public static String tokenLiteral ( Token t ) { return specialText ( t ) + t . image ; } public static String interpolate ( String argStr , Context vars ) { StringBuffer argBuf = new StringBuffer ( ) ; for ( int cIdx = 0 ; cIdx < argStr . length ( ) ; ) { char ch = argStr . charAt ( cIdx ) ; switch ( ch ) { case '$' : StringBuffer nameBuf = new StringBuffer ( ) ; for ( ++ cIdx ; cIdx < argStr . length ( ) ; ++ cIdx ) { ch = argStr . charAt ( cIdx ) ; if ( ch == '_' || ch == '-' || Character . isLetterOrDigit ( ch ) ) nameBuf . append ( ch ) ; else if ( ch == '{' || ch == '}' ) continue ; else break ; } if ( nameBuf . length ( ) > 0 ) { Object value = vars . get ( nameBuf . toString ( ) ) ; if ( value == null ) argBuf . append ( "$" ) . append ( nameBuf . toString ( ) ) ; else argBuf . append ( value . toString ( ) ) ; } break ; default : argBuf . append ( ch ) ; ++ cIdx ; break ; } } return argBuf . toString ( ) ; } } 	1	['4', '1', '0', '4', '17', '6', '2', '2', '4', '2', '222', '0', '0', '0', '0.3125', '0', '0', '54.5', '14', '6.75', '1']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . Template ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; public class Parse extends InputBase { private boolean ready = false ; public String getName ( ) { return "parse" ; } public int getType ( ) { return LINE ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException { if ( node . jjtGetChild ( 0 ) == null ) { rsvc . error ( "#parse() error :  null argument" ) ; return false ; } Object value = node . jjtGetChild ( 0 ) . value ( context ) ; if ( value == null ) { rsvc . error ( "#parse() error :  null argument" ) ; return false ; } String arg = value . toString ( ) ; Object [ ] templateStack = context . getTemplateNameStack ( ) ; if ( templateStack . length >= rsvc . getInt ( RuntimeConstants . PARSE_DIRECTIVE_MAXDEPTH , 20 ) ) { StringBuffer path = new StringBuffer ( ) ; for ( int i = 0 ; i < templateStack . length ; ++ i ) { path . append ( " > " + templateStack [ i ] ) ; } rsvc . error ( "Max recursion depth reached (" + templateStack . length + ")" + " File stack:" + path ) ; return false ; } Template t = null ; try { t = rsvc . getTemplate ( arg , getInputEncoding ( context ) ) ; } catch ( ResourceNotFoundException rnfe ) { rsvc . error ( "#parse(): cannot find template '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw rnfe ; } catch ( ParseErrorException pee ) { rsvc . error ( "#parse(): syntax error in #parse()-ed template '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw pee ; } catch ( Exception e ) { rsvc . error ( "#parse() : arg = " + arg + ".  Exception : " + e ) ; return false ; } try { context . pushCurrentTemplateName ( arg ) ; ( ( SimpleNode ) t . getData ( ) ) . render ( context , writer ) ; } catch ( Exception e ) { if ( e instanceof MethodInvocationException ) { throw ( MethodInvocationException ) e ; } rsvc . error ( "Exception rendering #parse( " + arg + " )  : " + e ) ; return false ; } finally { context . popCurrentTemplateName ( ) ; } return true ; } } 	1	['4', '3', '0', '12', '25', '6', '0', '12', '4', '1', '238', '1', '0', '0.727272727', '0.4375', '1', '1', '58.25', '1', '0.75', '1']
package org . apache . velocity . runtime . log ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; public class LogManager { public static LogSystem createLogSystem ( RuntimeServices rsvc ) throws Exception { Object o = rsvc . getProperty ( RuntimeConstants . RUNTIME_LOG_LOGSYSTEM ) ; if ( o != null && o instanceof LogSystem ) { ( ( LogSystem ) o ) . init ( rsvc ) ; return ( LogSystem ) o ; } List classes = null ; Object obj = rsvc . getProperty ( RuntimeConstants . RUNTIME_LOG_LOGSYSTEM_CLASS ) ; if ( obj instanceof List ) { classes = ( List ) obj ; } else if ( obj instanceof String ) { classes = new ArrayList ( ) ; classes . add ( obj ) ; } for ( Iterator ii = classes . iterator ( ) ; ii . hasNext ( ) ; ) { String claz = ( String ) ii . next ( ) ; if ( claz != null && claz . length ( ) > 0 ) { rsvc . info ( "Trying to use logger class " + claz ) ; try { o = Class . forName ( claz ) . newInstance ( ) ; if ( o instanceof LogSystem ) { ( ( LogSystem ) o ) . init ( rsvc ) ; rsvc . info ( "Using logger class " + claz ) ; return ( LogSystem ) o ; } else { rsvc . error ( "The specifid logger class " + claz + " isn't a valid LogSystem" ) ; } } catch ( NoClassDefFoundError ncdfe ) { rsvc . debug ( "Couldn't find class " + claz + " or necessary supporting classes in " + "classpath. Exception : " + ncdfe ) ; } } } LogSystem als = null ; try { als = new AvalonLogSystem ( ) ; als . init ( rsvc ) ; } catch ( NoClassDefFoundError ncdfe ) { String errstr = "PANIC : Velocity cannot find any of the" + " specified or default logging systems in the classpath," + " or the classpath doesn't contain the necessary classes" + " to support them." + " Please consult the documentation regarding logging." + " Exception : " + ncdfe ; System . out . println ( errstr ) ; System . err . println ( errstr ) ; throw ncdfe ; } rsvc . info ( "Using AvalonLogSystem as logger of final resort." ) ; return als ; } } 	1	['2', '1', '0', '5', '22', '1', '1', '4', '2', '2', '158', '0', '0', '0', '0.5', '0', '0', '78', '1', '0.5', '1']
package org . apache . velocity . app ; import java . lang . Class ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . HashMap ; public class FieldMethodizer { private HashMap fieldHash = new HashMap ( ) ; private HashMap classHash = new HashMap ( ) ; public FieldMethodizer ( ) { } public FieldMethodizer ( String s ) { try { addObject ( s ) ; } catch ( Exception e ) { System . out . println ( e ) ; } } public FieldMethodizer ( Object o ) { try { addObject ( o ) ; } catch ( Exception e ) { System . out . println ( e ) ; } } public void addObject ( String s ) throws Exception { inspect ( Class . forName ( s ) ) ; } public void addObject ( Object o ) throws Exception { inspect ( o . getClass ( ) ) ; } public Object get ( String fieldName ) { try { Field f = ( Field ) fieldHash . get ( fieldName ) ; if ( f != null ) return f . get ( ( Class ) classHash . get ( fieldName ) ) ; } catch ( Exception e ) { } return null ; } private void inspect ( Class clas ) { Field [ ] fields = clas . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { int mod = fields [ i ] . getModifiers ( ) ; if ( Modifier . isStatic ( mod ) && Modifier . isPublic ( mod ) ) { fieldHash . put ( fields [ i ] . getName ( ) , fields [ i ] ) ; classHash . put ( fields [ i ] . getName ( ) , clas ) ; } } } } 	1	['7', '1', '0', '2', '20', '1', '2', '0', '6', '0', '137', '1', '0', '0', '0.464285714', '0', '0', '18.28571429', '4', '1', '1']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public interface LogSystem { public final static boolean DEBUG_ON = true ; public final static int DEBUG_ID = 0 ; public final static int INFO_ID = 1 ; public final static int WARN_ID = 2 ; public final static int ERROR_ID = 3 ; public void init ( RuntimeServices rs ) throws Exception ; public void logVelocityMessage ( int level , String message ) ; } 	1	['2', '1', '0', '11', '2', '1', '10', '1', '2', '2', '7', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTModNode extends SimpleNode { public ASTModNode ( int id ) { super ( id ) ; } public ASTModNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of modulus operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of modulus operation is not a valid type. " + "Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( ( ( Integer ) right ) . intValue ( ) == 0 ) { rsvc . error ( "Right side of modulus operation is zero. Must be non-zero. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } return new Integer ( ( ( Integer ) left ) . intValue ( ) % ( ( Integer ) right ) . intValue ( ) ) ; } } 	1	['4', '2', '0', '10', '20', '6', '4', '8', '4', '2', '161', '0', '0', '0.931034483', '0.416666667', '1', '1', '39.25', '1', '0.5', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTLTNode extends SimpleNode { public ASTLTNode ( int id ) { super ( id ) ; } public ASTLTNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '<' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of '<' operation is not a valid type. " + " It is a " + ( ! ( left instanceof Integer ) ? left . getClass ( ) : right . getClass ( ) ) + ". Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } return ( ( Integer ) left ) . intValue ( ) < ( ( Integer ) right ) . intValue ( ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '10', '22', '10', '4', '8', '5', '2', '153', '0', '0', '0.9', '0.4', '1', '1', '29.6', '1', '0.6', '1']
package org . apache . velocity . texen . util ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import java . util . Properties ; import java . util . StringTokenizer ; import org . apache . velocity . texen . Generator ; public class PropertiesUtil { public Properties load ( String propertiesFile ) { Properties properties = new Properties ( ) ; String templatePath = Generator . getInstance ( ) . getTemplatePath ( ) ; if ( templatePath != null ) { properties = loadFromTemplatePath ( propertiesFile ) ; } else { properties = loadFromClassPath ( propertiesFile ) ; } return properties ; } protected Properties loadFromTemplatePath ( String propertiesFile ) { Properties properties = new Properties ( ) ; String templatePath = Generator . getInstance ( ) . getTemplatePath ( ) ; StringTokenizer st = new StringTokenizer ( templatePath , "," ) ; while ( st . hasMoreTokens ( ) ) { String templateDir = st . nextToken ( ) ; try { String fullPath = propertiesFile ; if ( ! fullPath . startsWith ( templateDir ) ) { fullPath = templateDir + "/" + propertiesFile ; } properties . load ( new FileInputStream ( fullPath ) ) ; break ; } catch ( Exception e ) { } } return properties ; } protected Properties loadFromClassPath ( String propertiesFile ) { Properties properties = new Properties ( ) ; ClassLoader classLoader = this . getClass ( ) . getClassLoader ( ) ; try { if ( propertiesFile . startsWith ( "$generator" ) ) { propertiesFile = propertiesFile . substring ( "$generator.templatePath/" . length ( ) ) ; } InputStream inputStream = classLoader . getResourceAsStream ( propertiesFile ) ; properties . load ( inputStream ) ; } catch ( IOException ioe ) { } return properties ; } } 	1	['4', '1', '0', '1', '22', '6', '0', '1', '2', '2', '102', '0', '0', '0', '0.875', '0', '0', '24.5', '3', '1.75', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTEscapedDirective extends SimpleNode { public ASTEscapedDirective ( int id ) { super ( id ) ; } public ASTEscapedDirective ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { writer . write ( getFirstToken ( ) . image ) ; return true ; } } 	1	['4', '2', '0', '5', '9', '6', '1', '5', '4', '2', '25', '0', '0', '0.931034483', '0.392857143', '0', '0', '5.25', '1', '0.5', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTExpression extends SimpleNode { public ASTExpression ( int id ) { super ( id ) ; } public ASTExpression ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { return jjtGetChild ( 0 ) . evaluate ( context ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return jjtGetChild ( 0 ) . value ( context ) ; } } 	1	['5', '2', '0', '8', '11', '10', '4', '6', '5', '2', '31', '0', '0', '0.9', '0.4', '1', '2', '5.2', '1', '0.6', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTDivNode extends SimpleNode { public ASTDivNode ( int id ) { super ( id ) ; } public ASTDivNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of division operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of division operation is not a valid type. " + "Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( ( ( Integer ) right ) . intValue ( ) == 0 ) { rsvc . error ( "Right side of division operation is zero. Must be non-zero. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } return new Integer ( ( ( Integer ) left ) . intValue ( ) / ( ( Integer ) right ) . intValue ( ) ) ; } } 	1	['4', '2', '0', '10', '20', '6', '4', '8', '4', '2', '161', '0', '0', '0.931034483', '0.416666667', '1', '1', '39.25', '1', '0.5', '1']
package org . apache . velocity . context ; import org . apache . velocity . app . event . EventCartridge ; public interface InternalEventContext { public EventCartridge attachEventCartridge ( EventCartridge ec ) ; public EventCartridge getEventCartridge ( ) ; } 	1	['2', '1', '0', '10', '2', '1', '10', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . io ; import java . io . IOException ; import java . io . Writer ; public final class VelocityWriter extends Writer { public static final int NO_BUFFER = 0 ; public static final int DEFAULT_BUFFER = - 1 ; public static final int UNBOUNDED_BUFFER = - 2 ; protected int bufferSize ; protected boolean autoFlush ; private Writer writer ; private char cb [ ] ; private int nextChar ; private static int defaultCharBufferSize = 8 * 1024 ; private boolean flushed = false ; public VelocityWriter ( Writer writer ) { this ( writer , defaultCharBufferSize , true ) ; } private VelocityWriter ( int bufferSize , boolean autoFlush ) { this . bufferSize = bufferSize ; this . autoFlush = autoFlush ; } public int getBufferSize ( ) { return bufferSize ; } public boolean isAutoFlush ( ) { return autoFlush ; } public VelocityWriter ( Writer writer , int sz , boolean autoFlush ) { this ( sz , autoFlush ) ; if ( sz < 0 ) throw new IllegalArgumentException ( "Buffer size <= 0" ) ; this . writer = writer ; cb = sz == 0 ? null : new char [ sz ] ; nextChar = 0 ; } private final void init ( Writer writer , int sz , boolean autoFlush ) { this . writer = writer ; if ( sz > 0 && ( cb == null || sz > cb . length ) ) cb = new char [ sz ] ; nextChar = 0 ; this . autoFlush = autoFlush ; this . bufferSize = sz ; } private final void flushBuffer ( ) throws IOException { if ( bufferSize == 0 ) return ; flushed = true ; if ( nextChar == 0 ) return ; writer . write ( cb , 0 , nextChar ) ; nextChar = 0 ; } public final void clear ( ) { nextChar = 0 ; } private final void bufferOverflow ( ) throws IOException { throw new IOException ( "overflow" ) ; } public final void flush ( ) throws IOException { flushBuffer ( ) ; if ( writer != null ) { writer . flush ( ) ; } } public final void close ( ) throws IOException { if ( writer == null ) return ; flush ( ) ; } public final int getRemaining ( ) { return bufferSize - nextChar ; } public final void write ( int c ) throws IOException { if ( bufferSize == 0 ) { writer . write ( c ) ; } else { if ( nextChar >= bufferSize ) if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; cb [ nextChar ++ ] = ( char ) c ; } } private final int min ( int a , int b ) { return ( a < b ? a : b ) ; } public final void write ( char cbuf [ ] , int off , int len ) throws IOException { if ( bufferSize == 0 ) { writer . write ( cbuf , off , len ) ; return ; } if ( len == 0 ) { return ; } if ( len >= bufferSize ) { if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; writer . write ( cbuf , off , len ) ; return ; } int b = off , t = off + len ; while ( b < t ) { int d = min ( bufferSize - nextChar , t - b ) ; System . arraycopy ( cbuf , b , cb , nextChar , d ) ; b += d ; nextChar += d ; if ( nextChar >= bufferSize ) if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; } } public final void write ( char buf [ ] ) throws IOException { write ( buf , 0 , buf . length ) ; } public final void write ( String s , int off , int len ) throws IOException { if ( bufferSize == 0 ) { writer . write ( s , off , len ) ; return ; } int b = off , t = off + len ; while ( b < t ) { int d = min ( bufferSize - nextChar , t - b ) ; s . getChars ( b , b + d , cb , nextChar ) ; b += d ; nextChar += d ; if ( nextChar >= bufferSize ) if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; } } public final void write ( String s ) throws IOException { write ( s , 0 , s . length ( ) ) ; } public final void recycle ( Writer writer ) { this . writer = writer ; flushed = false ; clear ( ) ; } } 	1	['20', '2', '0', '1', '30', '52', '1', '0', '14', '0.673684211', '378', '0.7', '0', '0.448275862', '0.324561404', '1', '2', '17.4', '4', '1', '1']
package org . apache . velocity . runtime . resource . loader ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . StringUtils ; public class ResourceLoaderFactory { public static ResourceLoader getLoader ( RuntimeServices rs , String loaderClassName ) throws Exception { ResourceLoader loader = null ; try { loader = ( ( ResourceLoader ) Class . forName ( loaderClassName ) . newInstance ( ) ) ; rs . info ( "Resource Loader Instantiated: " + loader . getClass ( ) . getName ( ) ) ; return loader ; } catch ( Exception e ) { rs . error ( "Problem instantiating the template loader.\n" + "Look at your properties file and make sure the\n" + "name of the template loader is correct. Here is the\n" + "error: " + StringUtils . stackTrace ( e ) ) ; throw new Exception ( "Problem initializing template loader: " + loaderClassName + "\nError is: " + StringUtils . stackTrace ( e ) ) ; } } } 	1	['2', '1', '0', '5', '14', '1', '1', '4', '2', '2', '55', '0', '0', '0', '0.5', '0', '0', '26.5', '1', '0.5', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTprocess extends SimpleNode { public ASTprocess ( int id ) { super ( id ) ; } public ASTprocess ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	1	['3', '2', '0', '5', '6', '3', '4', '3', '3', '2', '17', '0', '0', '0.964285714', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '1']
package org . apache . velocity . app . event ; public interface ReferenceInsertionEventHandler extends EventHandler { public Object referenceInsert ( String reference , Object value ) ; } 	1	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . runtime . visitor ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . parser . node . * ; public class NodeViewMode extends BaseVisitor { private int indent = 0 ; private boolean showTokens = true ; private String indentString ( ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < indent ; ++ i ) { sb . append ( "  " ) ; } return sb . toString ( ) ; } private Object showNode ( Node node , Object data ) { String tokens = "" ; String special = "" ; Token t ; if ( showTokens ) { t = node . getFirstToken ( ) ; if ( t . specialToken != null && ! t . specialToken . image . startsWith ( "##" ) ) special = t . specialToken . image ; tokens = " -> " + special + t . image ; } System . out . println ( indentString ( ) + node + tokens ) ; ++ indent ; data = node . childrenAccept ( this , data ) ; -- indent ; return data ; } public Object visit ( SimpleNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTprocess node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTExpression node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTAssignment node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTOrNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTAndNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTEQNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTNENode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTLTNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTGTNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTLENode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTGENode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTAddNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTSubtractNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTMulNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTDivNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTModNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTNotNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTNumberLiteral node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTStringLiteral node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIdentifier node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTMethod node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTReference node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTTrue node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTFalse node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTBlock node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTText node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIfStatement node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTElseStatement node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTElseIfStatement node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTObjectArray node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTDirective node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTWord node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTSetDirective node , Object data ) { return showNode ( node , data ) ; } } 	1	['37', '2', '0', '39', '46', '660', '1', '38', '35', '0.013888889', '304', '1', '0', '0.506849315', '0.07815924', '0', '0', '7.162162162', '4', '1.0811', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTMulNode extends SimpleNode { public ASTMulNode ( int id ) { super ( id ) ; } public ASTMulNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of multiplication operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of multiplication operation is not a valid type. " + "Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } return new Integer ( ( ( Integer ) left ) . intValue ( ) * ( ( Integer ) right ) . intValue ( ) ) ; } } 	1	['4', '2', '0', '10', '20', '6', '4', '8', '4', '2', '131', '0', '0', '0.931034483', '0.416666667', '1', '1', '31.75', '1', '0.5', '1']
package org . apache . velocity . texen ; import java . io . File ; import java . io . InputStream ; import java . io . FileInputStream ; import java . io . BufferedInputStream ; import java . io . Writer ; import java . io . FileWriter ; import java . io . StringWriter ; import java . io . OutputStreamWriter ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import org . apache . velocity . Template ; import org . apache . velocity . context . Context ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . VelocityEngine ; public class Generator { public static final String OUTPUT_PATH = "output.path" ; public static final String TEMPLATE_PATH = "template.path" ; private static final String DEFAULT_TEXEN_PROPERTIES = "org/apache/velocity/texen/defaults/texen.properties" ; private Properties props = new Properties ( ) ; private Context controlContext ; private Hashtable writers = new Hashtable ( ) ; private static Generator instance = new Generator ( ) ; protected String outputEncoding ; protected String inputEncoding ; protected VelocityEngine ve ; private Generator ( ) { setDefaultProps ( ) ; } public static Generator getInstance ( ) { return instance ; } public void setVelocityEngine ( VelocityEngine ve ) { this . ve = ve ; } public Generator ( String propFile ) { try { BufferedInputStream bi = null ; try { bi = new BufferedInputStream ( new FileInputStream ( propFile ) ) ; props . load ( bi ) ; } finally { if ( bi != null ) { bi . close ( ) ; } } } catch ( Exception e ) { setDefaultProps ( ) ; } } public Generator ( Properties props ) { this . props = ( Properties ) props . clone ( ) ; } protected void setDefaultProps ( ) { ClassLoader classLoader = VelocityEngine . class . getClassLoader ( ) ; try { InputStream inputStream = null ; try { inputStream = classLoader . getResourceAsStream ( DEFAULT_TEXEN_PROPERTIES ) ; props . load ( inputStream ) ; } finally { if ( inputStream != null ) { inputStream . close ( ) ; } } } catch ( Exception ioe ) { System . err . println ( "Cannot get default properties!" ) ; } } public void setTemplatePath ( String templatePath ) { props . put ( TEMPLATE_PATH , templatePath ) ; } public String getTemplatePath ( ) { return props . getProperty ( TEMPLATE_PATH ) ; } public void setOutputPath ( String outputPath ) { props . put ( OUTPUT_PATH , outputPath ) ; } public String getOutputPath ( ) { return props . getProperty ( OUTPUT_PATH ) ; } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setInputEncoding ( String inputEncoding ) { this . inputEncoding = inputEncoding ; } public Writer getWriter ( String path , String encoding ) throws Exception { Writer writer ; if ( encoding == null || encoding . length ( ) == 0 || encoding . equals ( "8859-1" ) || encoding . equals ( "8859_1" ) ) { writer = new FileWriter ( path ) ; } else { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( path ) , encoding ) ) ; } return writer ; } public Template getTemplate ( String templateName , String encoding ) throws Exception { Template template ; if ( encoding == null || encoding . length ( ) == 0 || encoding . equals ( "8859-1" ) || encoding . equals ( "8859_1" ) ) { template = ve . getTemplate ( templateName ) ; } else { template = ve . getTemplate ( templateName , encoding ) ; } return template ; } public String parse ( String inputTemplate , String outputFile ) throws Exception { return parse ( inputTemplate , outputFile , null , null ) ; } public String parse ( String inputTemplate , String outputFile , String objectID , Object object ) throws Exception { return parse ( inputTemplate , null , outputFile , null , objectID , object ) ; } public String parse ( String inputTemplate , String intputEncoding , String outputFile , String outputEncoding , String objectID , Object object ) throws Exception { if ( objectID != null && object != null ) { controlContext . put ( objectID , object ) ; } Template template = getTemplate ( inputTemplate , inputEncoding != null ? inputEncoding : this . inputEncoding ) ; if ( outputFile == null || outputFile . equals ( "" ) ) { StringWriter sw = new StringWriter ( ) ; template . merge ( controlContext , sw ) ; return sw . toString ( ) ; } else { Writer writer = null ; if ( writers . get ( outputFile ) == null ) { writer = getWriter ( getOutputPath ( ) + File . separator + outputFile , outputEncoding != null ? outputEncoding : this . outputEncoding ) ; writers . put ( outputFile , writer ) ; } else { writer = ( Writer ) writers . get ( outputFile ) ; } VelocityContext vc = new VelocityContext ( controlContext ) ; template . merge ( vc , writer ) ; return "" ; } } public String parse ( String controlTemplate , Context controlContext ) throws Exception { this . controlContext = controlContext ; fillContextDefaults ( this . controlContext ) ; fillContextProperties ( this . controlContext ) ; Template template = getTemplate ( controlTemplate , inputEncoding ) ; StringWriter sw = new StringWriter ( ) ; template . merge ( controlContext , sw ) ; return sw . toString ( ) ; } protected Context getContext ( Hashtable objs ) { fillContextHash ( controlContext , objs ) ; return controlContext ; } protected void fillContextHash ( Context context , Hashtable objs ) { Enumeration enum = objs . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String key = enum . nextElement ( ) . toString ( ) ; context . put ( key , objs . get ( key ) ) ; } } protected void fillContextDefaults ( Context context ) { context . put ( "generator" , instance ) ; context . put ( "outputDirectory" , getOutputPath ( ) ) ; } protected void fillContextProperties ( Context context ) { Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String nm = ( String ) enum . nextElement ( ) ; if ( nm . startsWith ( "context.objects." ) ) { String contextObj = props . getProperty ( nm ) ; int colon = nm . lastIndexOf ( '.' ) ; String contextName = nm . substring ( colon + 1 ) ; try { Class cls = Class . forName ( contextObj ) ; Object o = cls . newInstance ( ) ; context . put ( contextName , o ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } public void shutdown ( ) { Iterator iterator = writers . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Writer writer = ( Writer ) iterator . next ( ) ; try { writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { } } writers . clear ( ) ; } } 	1	['25', '1', '0', '6', '76', '194', '2', '4', '17', '0.878787879', '508', '0.727272727', '3', '0', '0.261904762', '0', '0', '18.88', '5', '1.16', '1']
package org . apache . velocity . anakia ; import org . jdom . Element ; import org . jdom . Namespace ; import org . jdom . input . DefaultJDOMFactory ; public class AnakiaJDOMFactory extends DefaultJDOMFactory { public AnakiaJDOMFactory ( ) { } public Element element ( String name , Namespace namespace ) { return new AnakiaElement ( name , namespace ) ; } public Element element ( String name ) { return new AnakiaElement ( name ) ; } public Element element ( String name , String uri ) { return new AnakiaElement ( name , uri ) ; } public Element element ( String name , String prefix , String uri ) { return new AnakiaElement ( name , prefix , uri ) ; } } 	1	['5', '2', '0', '5', '10', '10', '1', '4', '5', '2', '32', '0', '0', '0.833333333', '0.666666667', '0', '0', '5.4', '1', '0.8', '1']
package org . apache . velocity . util ; public final class SimplePool { private Object pool [ ] ; private int max ; private int current = - 1 ; public SimplePool ( int max ) { this . max = max ; pool = new Object [ max ] ; } public void put ( Object o ) { int idx = - 1 ; synchronized ( this ) { if ( current < max - 1 ) { idx = ++ current ; } if ( idx >= 0 ) { pool [ idx ] = o ; } } } public Object get ( ) { int idx = - 1 ; synchronized ( this ) { if ( current >= 0 ) { idx = current ; current -- ; return pool [ idx ] ; } } return null ; } public int getMax ( ) { return max ; } } 	1	['4', '1', '0', '2', '5', '0', '2', '0', '4', '0.333333333', '97', '1', '0', '0', '0.5', '0', '0', '22.5', '3', '1.5', '1']
package org . apache . velocity . anakia ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import org . jdom . Element ; public class TreeWalker { public TreeWalker ( ) { } public NodeList allElements ( Element e ) { ArrayList theElements = new ArrayList ( ) ; treeWalk ( e , theElements ) ; return new NodeList ( theElements , false ) ; } private final void treeWalk ( Element e , Collection theElements ) { for ( Iterator i = e . getChildren ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Element child = ( Element ) i . next ( ) ; theElements . add ( child ) ; treeWalk ( child , theElements ) ; } } } 	1	['3', '1', '0', '3', '11', '3', '1', '2', '2', '2', '41', '0', '0', '0', '0.666666667', '0', '0', '12.66666667', '2', '1', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTWord extends SimpleNode { public ASTWord ( int id ) { super ( id ) ; } public ASTWord ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	1	['3', '2', '0', '5', '6', '3', '4', '3', '3', '2', '17', '0', '0', '0.964285714', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '1']
package org . apache . velocity . runtime . exception ; import org . apache . velocity . runtime . parser . node . Node ; public class ReferenceException extends Exception { public ReferenceException ( String exceptionMessage , Node node ) { super ( exceptionMessage + " [line " + node . getLine ( ) + ",column " + node . getColumn ( ) + "] : " + node . literal ( ) + " is not a valid reference." ) ; } } 	1	['1', '3', '0', '3', '9', '0', '2', '1', '1', '2', '27', '0', '0', '1', '1', '0', '0', '26', '0', '0', '2']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; public class ASTDirective extends SimpleNode { private Directive directive ; private String directiveName = "" ; private boolean isDirective ; public ASTDirective ( int id ) { super ( id ) ; } public ASTDirective ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { super . init ( context , data ) ; if ( parser . isDirective ( directiveName ) ) { isDirective = true ; directive = ( Directive ) parser . getDirective ( directiveName ) . getClass ( ) . newInstance ( ) ; directive . init ( rsvc , context , this ) ; directive . setLocation ( getLine ( ) , getColumn ( ) ) ; } else if ( rsvc . isVelocimacro ( directiveName , context . getCurrentTemplateName ( ) ) ) { isDirective = true ; directive = ( Directive ) rsvc . getVelocimacro ( directiveName , context . getCurrentTemplateName ( ) ) ; directive . init ( rsvc , context , this ) ; directive . setLocation ( getLine ( ) , getColumn ( ) ) ; } else { isDirective = false ; } return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { if ( isDirective ) { directive . render ( context , writer , this ) ; } else { writer . write ( "#" ) ; writer . write ( directiveName ) ; } return true ; } public void setDirectiveName ( String str ) { directiveName = str ; return ; } public String getDirectiveName ( ) { return directiveName ; } } 	1	['7', '2', '0', '12', '24', '0', '4', '10', '7', '0.611111111', '136', '1', '1', '0.84375', '0.303571429', '0', '0', '18', '1', '0.7143', '3']
package org . apache . velocity . context ; import java . io . Serializable ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextBase ; public abstract class AbstractContext extends InternalContextBase implements Context , Serializable { private Context innerContext = null ; public abstract Object internalGet ( String key ) ; public abstract Object internalPut ( String key , Object value ) ; public abstract boolean internalContainsKey ( Object key ) ; public abstract Object [ ] internalGetKeys ( ) ; public abstract Object internalRemove ( Object key ) ; public AbstractContext ( ) { } public AbstractContext ( Context inner ) { innerContext = inner ; if ( innerContext instanceof InternalEventContext ) { attachEventCartridge ( ( ( InternalEventContext ) innerContext ) . getEventCartridge ( ) ) ; } } public Object put ( String key , Object value ) { if ( key == null ) { return null ; } else if ( value == null ) { return null ; } return internalPut ( key , value ) ; } public Object get ( String key ) { if ( key == null ) { return null ; } Object o = internalGet ( key ) ; if ( o == null && innerContext != null ) { o = innerContext . get ( key ) ; } return o ; } public boolean containsKey ( Object key ) { if ( key == null ) { return false ; } return internalContainsKey ( key ) ; } public Object [ ] getKeys ( ) { return internalGetKeys ( ) ; } public Object remove ( Object key ) { if ( key == null ) { return null ; } return internalRemove ( key ) ; } public Context getChainedContext ( ) { return innerContext ; } } 	1	['13', '2', '1', '14', '17', '66', '10', '4', '13', '0.75', '95', '1', '1', '0.476190476', '0.461538462', '0', '0', '6.230769231', '4', '1.3846', '1']
package org . apache . velocity . anakia ; import java . io . Writer ; import java . io . IOException ; import java . io . StringWriter ; import java . util . * ; import org . jdom . * ; import org . jdom . output . * ; public class NodeList implements List , Cloneable { private static final AttributeXMLOutputter DEFAULT_OUTPUTTER = new AttributeXMLOutputter ( ) ; private List nodes ; public NodeList ( ) { nodes = new ArrayList ( ) ; } public NodeList ( Document document ) { this ( ( Object ) document ) ; } public NodeList ( Element element ) { this ( ( Object ) element ) ; } private NodeList ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( "Cannot construct NodeList with null." ) ; } nodes = new ArrayList ( 1 ) ; nodes . add ( object ) ; } public NodeList ( List nodes ) { this ( nodes , true ) ; } public NodeList ( List nodes , boolean copy ) { if ( nodes == null ) { throw new IllegalArgumentException ( "Cannot initialize NodeList with null list" ) ; } this . nodes = copy ? new ArrayList ( nodes ) : nodes ; } public List getList ( ) { return nodes ; } public String toString ( ) { if ( nodes . isEmpty ( ) ) { return "" ; } StringWriter sw = new StringWriter ( nodes . size ( ) * 128 ) ; try { for ( Iterator i = nodes . iterator ( ) ; i . hasNext ( ) ; ) { Object node = i . next ( ) ; if ( node instanceof Element ) { DEFAULT_OUTPUTTER . output ( ( Element ) node , sw ) ; } else if ( node instanceof Attribute ) { DEFAULT_OUTPUTTER . output ( ( Attribute ) node , sw ) ; } else if ( node instanceof Text ) { DEFAULT_OUTPUTTER . output ( ( Text ) node , sw ) ; } else if ( node instanceof Document ) { DEFAULT_OUTPUTTER . output ( ( Document ) node , sw ) ; } else if ( node instanceof ProcessingInstruction ) { DEFAULT_OUTPUTTER . output ( ( ProcessingInstruction ) node , sw ) ; } else if ( node instanceof Comment ) { DEFAULT_OUTPUTTER . output ( ( Comment ) node , sw ) ; } else if ( node instanceof CDATA ) { DEFAULT_OUTPUTTER . output ( ( CDATA ) node , sw ) ; } else if ( node instanceof DocType ) { DEFAULT_OUTPUTTER . output ( ( DocType ) node , sw ) ; } else if ( node instanceof EntityRef ) { DEFAULT_OUTPUTTER . output ( ( EntityRef ) node , sw ) ; } else { throw new IllegalArgumentException ( "Cannot process a " + ( node == null ? "null node" : "node of class " + node . getClass ( ) . getName ( ) ) ) ; } } } catch ( IOException e ) { throw new Error ( ) ; } return sw . toString ( ) ; } public Object clone ( ) throws CloneNotSupportedException { NodeList clonedList = ( NodeList ) super . clone ( ) ; clonedList . cloneNodes ( ) ; return clonedList ; } private void cloneNodes ( ) throws CloneNotSupportedException { Class listClass = nodes . getClass ( ) ; try { List clonedNodes = ( List ) listClass . newInstance ( ) ; clonedNodes . addAll ( nodes ) ; nodes = clonedNodes ; } catch ( IllegalAccessException e ) { throw new CloneNotSupportedException ( "Cannot clone NodeList since" + " there is no accessible no-arg constructor on class " + listClass . getName ( ) ) ; } catch ( InstantiationException e ) { throw new Error ( ) ; } } public int hashCode ( ) { return nodes . hashCode ( ) ; } public boolean equals ( Object o ) { return o instanceof NodeList ? ( ( NodeList ) o ) . nodes . equals ( nodes ) : false ; } public NodeList selectNodes ( String xpathString ) { return new NodeList ( XPathCache . getXPath ( xpathString ) . applyTo ( nodes ) , false ) ; } public boolean add ( Object o ) { return nodes . add ( o ) ; } public void add ( int index , Object o ) { nodes . add ( index , o ) ; } public boolean addAll ( Collection c ) { return nodes . addAll ( c ) ; } public boolean addAll ( int index , Collection c ) { return nodes . addAll ( index , c ) ; } public void clear ( ) { nodes . clear ( ) ; } public boolean contains ( Object o ) { return nodes . contains ( o ) ; } public boolean containsAll ( Collection c ) { return nodes . containsAll ( c ) ; } public Object get ( int index ) { return nodes . get ( index ) ; } public int indexOf ( Object o ) { return nodes . indexOf ( o ) ; } public boolean isEmpty ( ) { return nodes . isEmpty ( ) ; } public Iterator iterator ( ) { return nodes . iterator ( ) ; } public int lastIndexOf ( Object o ) { return nodes . lastIndexOf ( o ) ; } public ListIterator listIterator ( ) { return nodes . listIterator ( ) ; } public ListIterator listIterator ( int index ) { return nodes . listIterator ( index ) ; } public Object remove ( int index ) { return nodes . remove ( index ) ; } public boolean remove ( Object o ) { return nodes . remove ( o ) ; } public boolean removeAll ( Collection c ) { return nodes . removeAll ( c ) ; } public boolean retainAll ( Collection c ) { return nodes . retainAll ( c ) ; } public Object set ( int index , Object o ) { return nodes . set ( index , o ) ; } public int size ( ) { return nodes . size ( ) ; } public List subList ( int fromIndex , int toIndex ) { return new NodeList ( nodes . subList ( fromIndex , toIndex ) ) ; } public Object [ ] toArray ( ) { return nodes . toArray ( ) ; } public Object [ ] toArray ( Object [ ] a ) { return nodes . toArray ( a ) ; } private static final class AttributeXMLOutputter extends XMLOutputter { public void output ( Attribute attribute , Writer out ) throws IOException { out . write ( " " ) ; out . write ( attribute . getQualifiedName ( ) ) ; out . write ( "=" ) ; out . write ( "\"" ) ; out . write ( escapeAttributeEntities ( attribute . getValue ( ) ) ) ; out . write ( "\"" ) ; } } } 	1	['37', '1', '0', '17', '92', '0', '3', '14', '34', '0.5', '438', '1', '1', '0', '0.177777778', '1', '1', '10.78378378', '13', '1.1622', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTGENode extends SimpleNode { public ASTGENode ( int id ) { super ( id ) ; } public ASTGENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '>=' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of '>=' operation is not a valid type. " + " It is a " + ( ! ( left instanceof Integer ) ? left . getClass ( ) : right . getClass ( ) ) + ". Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } return ( ( Integer ) left ) . intValue ( ) >= ( ( Integer ) right ) . intValue ( ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '10', '22', '10', '4', '8', '5', '2', '153', '0', '0', '0.9', '0.4', '1', '1', '29.6', '1', '0.6', '1']
package org . apache . velocity . runtime ; import java . io . Reader ; import java . util . Properties ; import org . apache . velocity . Template ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . commons . collections . ExtendedProperties ; public class Runtime implements RuntimeConstants { public synchronized static void init ( ) throws Exception { RuntimeSingleton . init ( ) ; } public static void setProperty ( String key , Object value ) { RuntimeSingleton . setProperty ( key , value ) ; } public static void setConfiguration ( ExtendedProperties configuration ) { RuntimeSingleton . setConfiguration ( configuration ) ; } public static void addProperty ( String key , Object value ) { RuntimeSingleton . addProperty ( key , value ) ; } public static void clearProperty ( String key ) { RuntimeSingleton . clearProperty ( key ) ; } public static Object getProperty ( String key ) { return RuntimeSingleton . getProperty ( key ) ; } public static void init ( Properties p ) throws Exception { RuntimeSingleton . init ( p ) ; } public static void init ( String configurationFile ) throws Exception { RuntimeSingleton . init ( configurationFile ) ; } public static SimpleNode parse ( Reader reader , String templateName ) throws ParseException { return RuntimeSingleton . parse ( reader , templateName ) ; } public static SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException { return RuntimeSingleton . parse ( reader , templateName , dumpNamespace ) ; } public static Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name ) ; } public static Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name , encoding ) ; } public static ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getContent ( name ) ; } public static ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getContent ( name , encoding ) ; } public static String getLoaderNameForResource ( String resourceName ) { return RuntimeSingleton . getLoaderNameForResource ( resourceName ) ; } public static void warn ( Object message ) { RuntimeSingleton . warn ( message ) ; } public static void info ( Object message ) { RuntimeSingleton . info ( message ) ; } public static void error ( Object message ) { RuntimeSingleton . error ( message ) ; } public static void debug ( Object message ) { RuntimeSingleton . debug ( message ) ; } public static String getString ( String key , String defaultValue ) { return RuntimeSingleton . getString ( key , defaultValue ) ; } public static Directive getVelocimacro ( String vmName , String templateName ) { return RuntimeSingleton . getVelocimacro ( vmName , templateName ) ; } public static boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) { return RuntimeSingleton . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public static boolean isVelocimacro ( String vmName , String templateName ) { return RuntimeSingleton . isVelocimacro ( vmName , templateName ) ; } public static boolean dumpVMNamespace ( String namespace ) { return RuntimeSingleton . dumpVMNamespace ( namespace ) ; } public static String getString ( String key ) { return RuntimeSingleton . getString ( key ) ; } public static int getInt ( String key ) { return RuntimeSingleton . getInt ( key ) ; } public static int getInt ( String key , int defaultValue ) { return RuntimeSingleton . getInt ( key , defaultValue ) ; } public static boolean getBoolean ( String key , boolean def ) { return RuntimeSingleton . getBoolean ( key , def ) ; } public static ExtendedProperties getConfiguration ( ) { return RuntimeSingleton . getConfiguration ( ) ; } } 	1	['30', '1', '0', '10', '60', '435', '0', '10', '30', '2', '133', '0', '0', '0', '0.133333333', '0', '0', '3.433333333', '1', '0.9667', '1']
package org . apache . velocity . app . event ; public interface EventHandler { } 	1	['0', '1', '0', '6', '0', '0', '6', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1']
package org . apache . velocity . runtime . parser ; public final class VelocityCharStream implements CharStream { public static final boolean staticFlag = false ; int bufsize ; int available ; int tokenBegin ; public int bufpos = - 1 ; private int bufline [ ] ; private int bufcolumn [ ] ; private int column = 0 ; private int line = 1 ; private boolean prevCharIsCR = false ; private boolean prevCharIsLF = false ; private java . io . Reader inputStream ; private char [ ] buffer ; private int maxNextCharInd = 0 ; private int inBuf = 0 ; private final void ExpandBuff ( boolean wrapAround ) { char [ ] newbuffer = new char [ bufsize + 2048 ] ; int newbufline [ ] = new int [ bufsize + 2048 ] ; int newbufcolumn [ ] = new int [ bufsize + 2048 ] ; try { if ( wrapAround ) { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; System . arraycopy ( buffer , 0 , newbuffer , bufsize - tokenBegin , bufpos ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufline , 0 , newbufline , bufsize - tokenBegin , bufpos ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufcolumn , 0 , newbufcolumn , bufsize - tokenBegin , bufpos ) ; bufcolumn = newbufcolumn ; maxNextCharInd = ( bufpos += ( bufsize - tokenBegin ) ) ; } else { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; bufcolumn = newbufcolumn ; maxNextCharInd = ( bufpos -= tokenBegin ) ; } } catch ( Throwable t ) { throw new Error ( t . getMessage ( ) ) ; } bufsize += 2048 ; available = bufsize ; tokenBegin = 0 ; } private final void FillBuff ( ) throws java . io . IOException { if ( maxNextCharInd == available ) { if ( available == bufsize ) { if ( tokenBegin > 2048 ) { bufpos = maxNextCharInd = 0 ; available = tokenBegin ; } else if ( tokenBegin < 0 ) bufpos = maxNextCharInd = 0 ; else ExpandBuff ( false ) ; } else if ( available > tokenBegin ) available = bufsize ; else if ( ( tokenBegin - available ) < 2048 ) ExpandBuff ( true ) ; else available = tokenBegin ; } int i ; try { if ( ( i = inputStream . read ( buffer , maxNextCharInd , available - maxNextCharInd ) ) == - 1 ) { inputStream . close ( ) ; throw new java . io . IOException ( ) ; } else maxNextCharInd += i ; return ; } catch ( java . io . IOException e ) { -- bufpos ; backup ( 0 ) ; if ( tokenBegin == - 1 ) tokenBegin = bufpos ; throw e ; } } public final char BeginToken ( ) throws java . io . IOException { tokenBegin = - 1 ; char c = readChar ( ) ; tokenBegin = bufpos ; return c ; } private final void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c == '\n' ) { prevCharIsLF = true ; } else line += ( column = 1 ) ; } switch ( c ) { case '\r' : prevCharIsCR = true ; break ; case '\n' : prevCharIsLF = true ; break ; case '\t' : column -- ; column += ( 8 - ( column & 07 ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; } public final char readChar ( ) throws java . io . IOException { if ( inBuf > 0 ) { -- inBuf ; return buffer [ ( bufpos == bufsize - 1 ) ? ( bufpos = 0 ) : ++ bufpos ] ; } if ( ++ bufpos >= maxNextCharInd ) FillBuff ( ) ; char c = buffer [ bufpos ] ; UpdateLineColumn ( c ) ; return ( c ) ; } public final int getColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getLine ( ) { return bufline [ bufpos ] ; } public final int getEndColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getEndLine ( ) { return bufline [ bufpos ] ; } public final int getBeginColumn ( ) { return bufcolumn [ tokenBegin ] ; } public final int getBeginLine ( ) { return bufline [ tokenBegin ] ; } public final void backup ( int amount ) { inBuf += amount ; if ( ( bufpos -= amount ) < 0 ) bufpos += bufsize ; } public VelocityCharStream ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; } public VelocityCharStream ( java . io . Reader dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; if ( buffer == null || buffersize != buffer . length ) { available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; } prevCharIsLF = prevCharIsCR = false ; tokenBegin = inBuf = maxNextCharInd = 0 ; bufpos = - 1 ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public VelocityCharStream ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { this ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , 4096 ) ; } public VelocityCharStream ( java . io . InputStream dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { ReInit ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public final String GetImage ( ) { if ( bufpos >= tokenBegin ) return new String ( buffer , tokenBegin , bufpos - tokenBegin + 1 ) ; else return new String ( buffer , tokenBegin , bufsize - tokenBegin ) + new String ( buffer , 0 , bufpos + 1 ) ; } public final char [ ] GetSuffix ( int len ) { char [ ] ret = new char [ len ] ; if ( ( bufpos + 1 ) >= len ) System . arraycopy ( buffer , bufpos - len + 1 , ret , 0 , len ) ; else { System . arraycopy ( buffer , bufsize - ( len - bufpos - 1 ) , ret , 0 , len - bufpos - 1 ) ; System . arraycopy ( buffer , 0 , ret , len - bufpos - 1 , bufpos + 1 ) ; } return ret ; } public void Done ( ) { buffer = null ; bufline = null ; bufcolumn = null ; } public void adjustBeginLineColumn ( int newLine , int newCol ) { int start = tokenBegin ; int len ; if ( bufpos >= tokenBegin ) { len = bufpos - tokenBegin + inBuf + 1 ; } else { len = bufsize - tokenBegin + bufpos + 1 + inBuf ; } int i = 0 , j = 0 , k = 0 ; int nextColDiff = 0 , columnDiff = 0 ; while ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { bufline [ j ] = newLine ; nextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; bufcolumn [ j ] = newCol + columnDiff ; columnDiff = nextColDiff ; i ++ ; } if ( i < len ) { bufline [ j ] = newLine ++ ; bufcolumn [ j ] = newCol + columnDiff ; while ( i ++ < len ) { if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; else bufline [ j ] = newLine ; } } line = bufline [ j ] ; column = bufcolumn [ j ] ; } } 	1	['24', '1', '0', '2', '36', '0', '1', '1', '21', '0.504347826', '991', '0.666666667', '0', '0', '0.3125', '0', '0', '39.66666667', '7', '1.5', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTVariable extends SimpleNode { public ASTVariable ( int id ) { super ( id ) ; } public ASTVariable ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	1	['3', '2', '0', '3', '6', '3', '0', '3', '3', '2', '17', '0', '0', '0.964285714', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '1']
package org . apache . velocity . runtime . resource ; import java . util . Hashtable ; import java . util . Map ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeServices ; public class ResourceCacheImpl implements ResourceCache { protected Map cache = new Hashtable ( ) ; protected RuntimeServices rsvc = null ; public void initialize ( RuntimeServices rs ) { rsvc = rs ; rsvc . info ( "ResourceCache : initialized. (" + this . getClass ( ) + ")" ) ; } public Resource get ( Object key ) { return ( Resource ) cache . get ( key ) ; } public Resource put ( Object key , Resource value ) { return ( Resource ) cache . put ( key , value ) ; } public Resource remove ( Object key ) { return ( Resource ) cache . remove ( key ) ; } public Iterator enumerateKeys ( ) { return cache . keySet ( ) . iterator ( ) ; } } 	1	['6', '1', '0', '5', '19', '0', '1', '4', '6', '0.5', '61', '1', '1', '0', '0.458333333', '0', '0', '8.833333333', '1', '0.8333', '1']
package org . apache . velocity . runtime ; import java . io . Reader ; import java . util . Properties ; import org . apache . velocity . Template ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . util . introspection . Uberspect ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . commons . collections . ExtendedProperties ; public interface RuntimeServices extends RuntimeLogger { public void init ( ) throws Exception ; public void setProperty ( String key , Object value ) ; public void setConfiguration ( ExtendedProperties configuration ) ; public void addProperty ( String key , Object value ) ; public void clearProperty ( String key ) ; public Object getProperty ( String key ) ; public void init ( Properties p ) throws Exception ; public void init ( String configurationFile ) throws Exception ; public SimpleNode parse ( Reader reader , String templateName ) throws ParseException ; public SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException ; public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception ; public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception ; public ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception ; public ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception ; public String getLoaderNameForResource ( String resourceName ) ; public String getString ( String key , String defaultValue ) ; public Directive getVelocimacro ( String vmName , String templateName ) ; public boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) ; public boolean isVelocimacro ( String vmName , String templateName ) ; public boolean dumpVMNamespace ( String namespace ) ; public String getString ( String key ) ; public int getInt ( String key ) ; public int getInt ( String key , int defaultValue ) ; public boolean getBoolean ( String key , boolean def ) ; public ExtendedProperties getConfiguration ( ) ; public Object getApplicationAttribute ( Object key ) ; public Uberspect getUberspect ( ) ; public Introspector getIntrospector ( ) ; } 	1	['28', '1', '0', '67', '28', '378', '60', '11', '28', '2', '28', '0', '0', '0', '0.238095238', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; public abstract class Directive implements DirectiveConstants , Cloneable { private int line = 0 ; private int column = 0 ; protected RuntimeServices rsvc = null ; public abstract String getName ( ) ; public abstract int getType ( ) ; public void setLocation ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return column ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws Exception { rsvc = rs ; } public abstract boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException ; } 	1	['8', '1', '5', '20', '9', '16', '14', '7', '8', '0.761904762', '40', '1', '1', '0', '0.3125', '0', '0', '3.625', '1', '0.875', '2']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public class NullLogSystem implements LogSystem { public NullLogSystem ( ) { } public void init ( RuntimeServices rs ) throws Exception { } public void logVelocityMessage ( int level , String message ) { } } 	1	['3', '1', '0', '3', '4', '3', '1', '2', '3', '2', '8', '0', '0', '0', '0.5', '0', '0', '1.666666667', '1', '0.6667', '1']
package org . apache . velocity . runtime . directive ; import java . io . * ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . RuntimeServices ; public class Literal extends Directive { String literalText ; public String getName ( ) { return "literal" ; } public int getType ( ) { return BLOCK ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws Exception { super . init ( rs , context , node ) ; literalText = node . jjtGetChild ( 0 ) . literal ( ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException { writer . write ( literalText ) ; return true ; } } 	1	['5', '2', '0', '4', '10', '8', '0', '4', '5', '0.75', '31', '0', '0', '0.636363636', '0.44', '0', '0', '5', '1', '0.8', '2']
package org . apache . velocity . anakia ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . xml . sax . SAXParseException ; import org . jdom . Document ; import org . jdom . JDOMException ; import org . jdom . input . SAXBuilder ; import org . apache . velocity . Template ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . VelocityContext ; public class AnakiaTask extends MatchingTask { private SAXBuilder builder ; private File destDir = null ; private File baseDir = null ; private String style = null ; private File styleFile = null ; private long styleSheetLastModified = 0 ; private String projectAttribute = null ; private File projectFile = null ; private long projectFileLastModified = 0 ; private boolean lastModifiedCheck = true ; private String extension = ".html" ; private String templatePath = null ; private File velocityPropertiesFile = null ; private VelocityEngine ve = new VelocityEngine ( ) ; public AnakiaTask ( ) { builder = new SAXBuilder ( ) ; builder . setFactory ( new AnakiaJDOMFactory ( ) ) ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String extension ) { this . extension = extension ; } public void setStyle ( String style ) { this . style = style ; } public void setProjectFile ( String projectAttribute ) { this . projectAttribute = projectAttribute ; } public void setTemplatePath ( File templatePath ) { try { this . templatePath = templatePath . getCanonicalPath ( ) ; } catch ( java . io . IOException ioe ) { throw new BuildException ( ioe ) ; } } public void setVelocityPropertiesFile ( File velocityPropertiesFile ) { this . velocityPropertiesFile = velocityPropertiesFile ; } public void setLastModifiedCheck ( String lastmod ) { if ( lastmod . equalsIgnoreCase ( "false" ) || lastmod . equalsIgnoreCase ( "no" ) || lastmod . equalsIgnoreCase ( "off" ) ) { this . lastModifiedCheck = false ; } } public void execute ( ) throws BuildException { DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } if ( destDir == null ) { String msg = "destdir attribute must be set!" ; throw new BuildException ( msg ) ; } if ( style == null ) { throw new BuildException ( "style attribute must be set!" ) ; } if ( velocityPropertiesFile == null ) { velocityPropertiesFile = new File ( "velocity.properties" ) ; } if ( ! velocityPropertiesFile . exists ( ) && templatePath == null ) { throw new BuildException ( "No template path and could not " + "locate velocity.properties file: " + velocityPropertiesFile . getAbsolutePath ( ) ) ; } log ( "Transforming into: " + destDir . getAbsolutePath ( ) , Project . MSG_INFO ) ; if ( projectAttribute != null && projectAttribute . length ( ) > 0 ) { projectFile = new File ( baseDir , projectAttribute ) ; if ( projectFile . exists ( ) ) { projectFileLastModified = projectFile . lastModified ( ) ; } else { log ( "Project file is defined, but could not be located: " + projectFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; projectFile = null ; } } Document projectDocument = null ; try { if ( velocityPropertiesFile . exists ( ) ) { ve . init ( velocityPropertiesFile . getAbsolutePath ( ) ) ; } else if ( templatePath != null && templatePath . length ( ) > 0 ) { ve . setProperty ( RuntimeConstants . FILE_RESOURCE_LOADER_PATH , templatePath ) ; ve . init ( ) ; } styleSheetLastModified = ve . getTemplate ( style ) . getLastModified ( ) ; if ( projectFile != null ) { projectDocument = builder . build ( projectFile ) ; } } catch ( Exception e ) { log ( "Error: " + e . toString ( ) , Project . MSG_INFO ) ; throw new BuildException ( e ) ; } scanner = getDirectoryScanner ( baseDir ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , projectDocument ) ; } } private void process ( File baseDir , String xmlFile , File destDir , Document projectDocument ) throws BuildException { File outFile = null ; File inFile = null ; Writer writer = null ; try { inFile = new File ( baseDir , xmlFile ) ; outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + extension ) ; if ( lastModifiedCheck == false || ( inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) || projectFileLastModified > outFile . lastModified ( ) ) ) { ensureDirectoryFor ( outFile ) ; log ( "Input:  " + xmlFile , Project . MSG_INFO ) ; Document root = builder . build ( inFile ) ; VelocityContext context = new VelocityContext ( ) ; String encoding = ( String ) ve . getProperty ( RuntimeConstants . OUTPUT_ENCODING ) ; if ( encoding == null || encoding . length ( ) == 0 || encoding . equals ( "8859-1" ) || encoding . equals ( "8859_1" ) ) { encoding = "ISO-8859-1" ; } OutputWrapper ow = new OutputWrapper ( ) ; ow . setEncoding ( encoding ) ; context . put ( "root" , root . getRootElement ( ) ) ; context . put ( "xmlout" , ow ) ; context . put ( "relativePath" , getRelativePath ( xmlFile ) ) ; context . put ( "treeWalk" , new TreeWalker ( ) ) ; context . put ( "xpath" , new XPathTool ( ) ) ; context . put ( "escape" , new Escape ( ) ) ; context . put ( "date" , new java . util . Date ( ) ) ; if ( projectDocument != null ) { context . put ( "project" , projectDocument . getRootElement ( ) ) ; } writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( outFile ) , encoding ) ) ; Template template = ve . getTemplate ( style ) ; template . merge ( context , writer ) ; log ( "Output: " + outFile , Project . MSG_INFO ) ; } } catch ( JDOMException e ) { if ( outFile != null ) outFile . delete ( ) ; if ( e . getCause ( ) != null ) { Throwable rootCause = e . getCause ( ) ; if ( rootCause instanceof SAXParseException ) { System . out . println ( "" ) ; System . out . println ( "Error: " + rootCause . getMessage ( ) ) ; System . out . println ( "       Line: " + ( ( SAXParseException ) rootCause ) . getLineNumber ( ) + " Column: " + ( ( SAXParseException ) rootCause ) . getColumnNumber ( ) ) ; System . out . println ( "" ) ; } else { rootCause . printStackTrace ( ) ; } } else { e . printStackTrace ( ) ; } } catch ( Throwable e ) { if ( outFile != null ) { outFile . delete ( ) ; } e . printStackTrace ( ) ; } finally { if ( writer != null ) { try { writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { } } } } private String getRelativePath ( String file ) { if ( file == null || file . length ( ) == 0 ) return "" ; StringTokenizer st = new StringTokenizer ( file , "/\\" ) ; int slashCount = st . countTokens ( ) - 1 ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < slashCount ; i ++ ) { sb . append ( "../" ) ; } if ( sb . toString ( ) . length ( ) > 0 ) { return StringUtils . chop ( sb . toString ( ) , 1 ) ; } else { return "." ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = new File ( targetFile . getParent ( ) ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } } 	1	['13', '4', '0', '24', '76', '38', '0', '24', '10', '0.833333333', '683', '1', '1', '0.866666667', '0.5', '2', '2', '50.46153846', '5', '1.4615', '1']
package org . apache . velocity . anakia ; import java . util . List ; import org . jdom . Document ; import org . jdom . Element ; public class XPathTool { public XPathTool ( ) { } public NodeList applyTo ( String xpathSpec , Document doc ) { return new NodeList ( XPathCache . getXPath ( xpathSpec ) . applyTo ( doc ) , false ) ; } public NodeList applyTo ( String xpathSpec , Element elem ) { return new NodeList ( XPathCache . getXPath ( xpathSpec ) . applyTo ( elem ) , false ) ; } public NodeList applyTo ( String xpathSpec , List nodeSet ) { return new NodeList ( XPathCache . getXPath ( xpathSpec ) . applyTo ( nodeSet ) , false ) ; } } 	1	['4', '1', '0', '6', '10', '6', '1', '5', '4', '2', '34', '0', '0', '0', '0.5', '0', '0', '7.5', '1', '0.75', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; public class ASTText extends SimpleNode { private char [ ] ctext ; public ASTText ( int id ) { super ( id ) ; } public ASTText ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { Token t = getFirstToken ( ) ; String text = NodeUtils . tokenLiteral ( t ) ; ctext = text . toCharArray ( ) ; return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { writer . write ( ctext ) ; return true ; } } 	1	['5', '2', '0', '8', '12', '8', '4', '6', '5', '0.75', '38', '1', '0', '0.9', '0.4', '0', '0', '6.4', '1', '0.6', '2']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; public interface Node { public void jjtOpen ( ) ; public void jjtClose ( ) ; public void jjtSetParent ( Node n ) ; public Node jjtGetParent ( ) ; public void jjtAddChild ( Node n , int i ) ; public Node jjtGetChild ( int i ) ; public int jjtGetNumChildren ( ) ; public Object jjtAccept ( ParserVisitor visitor , Object data ) ; public Object childrenAccept ( ParserVisitor visitor , Object data ) ; public Token getFirstToken ( ) ; public Token getLastToken ( ) ; public int getType ( ) ; public Object init ( InternalContextAdapter context , Object data ) throws Exception ; public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException ; public Object value ( InternalContextAdapter context ) throws MethodInvocationException ; public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException ; public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException ; public void setInfo ( int info ) ; public int getInfo ( ) ; public String literal ( ) ; public void setInvalid ( ) ; public boolean isInvalid ( ) ; public int getLine ( ) ; public int getColumn ( ) ; } 	1	['24', '1', '0', '44', '24', '276', '38', '6', '24', '2', '24', '0', '0', '0', '0.244047619', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . util . introspection ; public class Info { private int line ; private int column ; private String templateName ; public Info ( String tn , int l , int c ) { templateName = tn ; line = l ; column = c ; } private Info ( ) { } public String getTemplateName ( ) { return templateName ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return column ; } } 	1	['5', '1', '0', '6', '6', '4', '6', '0', '4', '0.75', '32', '1', '0', '0', '0.466666667', '0', '0', '4.8', '1', '0.6', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . exception . ReferenceException ; import org . apache . velocity . runtime . parser . * ; import org . apache . velocity . util . introspection . VelPropertySet ; import org . apache . velocity . util . introspection . Info ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . app . event . EventCartridge ; public class ASTReference extends SimpleNode { private static final int NORMAL_REFERENCE = 1 ; private static final int FORMAL_REFERENCE = 2 ; private static final int QUIET_REFERENCE = 3 ; private static final int RUNT = 4 ; private int referenceType ; private String nullString ; private String rootString ; private boolean escaped = false ; private boolean computableReference = true ; private String escPrefix = "" ; private String morePrefix = "" ; private String identifier = "" ; private String literal = null ; private int numChildren = 0 ; protected Info uberInfo ; public ASTReference ( int id ) { super ( id ) ; } public ASTReference ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { super . init ( context , data ) ; rootString = getRoot ( ) ; numChildren = jjtGetNumChildren ( ) ; if ( numChildren > 0 ) { identifier = jjtGetChild ( numChildren - 1 ) . getFirstToken ( ) . image ; } uberInfo = new Info ( context . getCurrentTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; return data ; } public String getRootString ( ) { return rootString ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { if ( referenceType == RUNT ) return null ; Object result = getVariableValue ( context , rootString ) ; if ( result == null ) { return null ; } try { for ( int i = 0 ; i < numChildren ; i ++ ) { result = jjtGetChild ( i ) . execute ( result , context ) ; if ( result == null ) { return null ; } } return result ; } catch ( MethodInvocationException mie ) { rsvc . error ( "Method " + mie . getMethodName ( ) + " threw exception for reference $" + rootString + " in template " + context . getCurrentTemplateName ( ) + " at " + " [" + this . getLine ( ) + "," + this . getColumn ( ) + "]" ) ; mie . setReferenceName ( rootString ) ; throw mie ; } } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException { if ( referenceType == RUNT ) { writer . write ( rootString ) ; return true ; } Object value = execute ( null , context ) ; if ( escaped ) { if ( value == null ) { writer . write ( escPrefix ) ; writer . write ( "\\" ) ; writer . write ( nullString ) ; } else { writer . write ( escPrefix ) ; writer . write ( nullString ) ; } return true ; } EventCartridge ec = context . getEventCartridge ( ) ; if ( ec != null ) { value = ec . referenceInsert ( literal ( ) , value ) ; } if ( value == null ) { writer . write ( escPrefix ) ; writer . write ( escPrefix ) ; writer . write ( morePrefix ) ; writer . write ( nullString ) ; if ( referenceType != QUIET_REFERENCE && rsvc . getBoolean ( RuntimeConstants . RUNTIME_LOG_REFERENCE_LOG_INVALID , true ) ) { rsvc . warn ( new ReferenceException ( "reference : template = " + context . getCurrentTemplateName ( ) , this ) ) ; } return true ; } else { writer . write ( escPrefix ) ; writer . write ( morePrefix ) ; writer . write ( value . toString ( ) ) ; return true ; } } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object value = execute ( null , context ) ; if ( value == null ) { return false ; } else if ( value instanceof Boolean ) { if ( ( ( Boolean ) value ) . booleanValue ( ) ) return true ; else return false ; } else return true ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return ( computableReference ? execute ( null , context ) : null ) ; } public boolean setValue ( InternalContextAdapter context , Object value ) throws MethodInvocationException { if ( jjtGetNumChildren ( ) == 0 ) { context . put ( rootString , value ) ; return true ; } Object result = getVariableValue ( context , rootString ) ; if ( result == null ) { rsvc . error ( new ReferenceException ( "reference set : template = " + context . getCurrentTemplateName ( ) , this ) ) ; return false ; } for ( int i = 0 ; i < numChildren - 1 ; i ++ ) { result = jjtGetChild ( i ) . execute ( result , context ) ; if ( result == null ) { rsvc . error ( new ReferenceException ( "reference set : template = " + context . getCurrentTemplateName ( ) , this ) ) ; return false ; } } try { VelPropertySet vs = rsvc . getUberspect ( ) . getPropertySet ( result , identifier , value , uberInfo ) ; if ( vs == null ) return false ; vs . invoke ( result , value ) ; } catch ( InvocationTargetException ite ) { throw new MethodInvocationException ( "ASTReference : Invocation of method '" + identifier + "' in  " + result . getClass ( ) + " threw exception " + ite . getTargetException ( ) . getClass ( ) , ite . getTargetException ( ) , identifier ) ; } catch ( Exception e ) { rsvc . error ( "ASTReference setValue() : exception : " + e + " template = " + context . getCurrentTemplateName ( ) + " [" + this . getLine ( ) + "," + this . getColumn ( ) + "]" ) ; return false ; } return true ; } private String getRoot ( ) { Token t = getFirstToken ( ) ; int slashbang = t . image . indexOf ( "\\!" ) ; if ( slashbang != - 1 ) { int i = 0 ; int len = t . image . length ( ) ; i = t . image . indexOf ( '$' ) ; if ( i == - 1 ) { rsvc . error ( "ASTReference.getRoot() : internal error : " + "no $ found for slashbang." ) ; computableReference = false ; nullString = t . image ; return nullString ; } while ( i < len && t . image . charAt ( i ) != '\\' ) { i ++ ; } int start = i ; int count = 0 ; while ( i < len && t . image . charAt ( i ++ ) == '\\' ) { count ++ ; } nullString = t . image . substring ( 0 , start ) ; nullString += t . image . substring ( start , start + count - 1 ) ; nullString += t . image . substring ( start + count ) ; computableReference = false ; return nullString ; } escaped = false ; if ( t . image . startsWith ( "\\" ) ) { int i = 0 ; int len = t . image . length ( ) ; while ( i < len && t . image . charAt ( i ) == '\\' ) { i ++ ; } if ( ( i % 2 ) != 0 ) escaped = true ; if ( i > 0 ) escPrefix = t . image . substring ( 0 , i / 2 ) ; t . image = t . image . substring ( i ) ; } int loc1 = t . image . lastIndexOf ( '$' ) ; if ( loc1 > 0 ) { morePrefix = morePrefix + t . image . substring ( 0 , loc1 ) ; t . image = t . image . substring ( loc1 ) ; } nullString = literal ( ) ; if ( t . image . startsWith ( "$!" ) ) { referenceType = QUIET_REFERENCE ; if ( ! escaped ) nullString = "" ; if ( t . image . startsWith ( "$!{" ) ) { return t . next . image ; } else { return t . image . substring ( 2 ) ; } } else if ( t . image . equals ( "${" ) ) { referenceType = FORMAL_REFERENCE ; return t . next . image ; } else if ( t . image . startsWith ( "$" ) ) { referenceType = NORMAL_REFERENCE ; return t . image . substring ( 1 ) ; } else { referenceType = RUNT ; return t . image ; } } public Object getVariableValue ( Context context , String variable ) { return context . get ( variable ) ; } public void setLiteral ( String literal ) { if ( this . literal == null ) this . literal = literal ; } public String literal ( ) { if ( literal != null ) return literal ; return super . literal ( ) ; } } 	1	['14', '2', '0', '21', '61', '29', '7', '16', '13', '0.78974359', '782', '1', '1', '0.692307692', '0.253968254', '1', '2', '53.78571429', '18', '2.2143', '4']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . * ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTNotNode extends SimpleNode { public ASTNotNode ( int id ) { super ( id ) ; } public ASTNotNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { if ( jjtGetChild ( 0 ) . evaluate ( context ) ) return false ; else return true ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return ( jjtGetChild ( 0 ) . evaluate ( context ) ? Boolean . FALSE : Boolean . TRUE ) ; } } 	1	['5', '2', '0', '8', '10', '10', '4', '6', '5', '2', '39', '0', '0', '0.9', '0.4', '1', '2', '6.8', '1', '0.6', '1']
package org . apache . velocity . app . event ; public interface MethodExceptionEventHandler extends EventHandler { public Object methodException ( Class claz , String method , Exception e ) throws Exception ; } 	1	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . util . introspection . Introspector ; import java . lang . reflect . InvocationTargetException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . RuntimeLogger ; public class GetExecutor extends AbstractExecutor { private Object [ ] args = new Object [ 1 ] ; public GetExecutor ( RuntimeLogger r , Introspector ispect , Class c , String key ) throws Exception { rlog = r ; args [ 0 ] = key ; method = ispect . getMethod ( c , "get" , args ) ; } public Object execute ( Object o ) throws IllegalAccessException , InvocationTargetException { if ( method == null ) return null ; return method . invoke ( o , args ) ; } public Object OLDexecute ( Object o , InternalContextAdapter context ) throws IllegalAccessException , MethodInvocationException { if ( method == null ) return null ; try { return method . invoke ( o , args ) ; } catch ( InvocationTargetException ite ) { throw new MethodInvocationException ( "Invocation of method 'get(\"" + args [ 0 ] + "\")'" + " in  " + o . getClass ( ) + " threw exception " + ite . getTargetException ( ) . getClass ( ) , ite . getTargetException ( ) , "get" ) ; } catch ( IllegalArgumentException iae ) { return null ; } } } 	1	['3', '2', '0', '6', '13', '0', '1', '5', '3', '0', '86', '1', '0', '0.6', '0.476190476', '1', '2', '27.33333333', '1', '0.6667', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTOrNode extends SimpleNode { public ASTOrNode ( int id ) { super ( id ) ; } public ASTOrNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return new Boolean ( evaluate ( context ) ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Node left = jjtGetChild ( 0 ) ; Node right = jjtGetChild ( 1 ) ; if ( left != null && left . evaluate ( context ) ) return true ; if ( right != null && right . evaluate ( context ) ) return true ; return false ; } } 	1	['5', '2', '0', '8', '11', '10', '4', '6', '5', '2', '52', '0', '0', '0.9', '0.4', '1', '1', '9.4', '1', '0.6', '1']
package org . apache . velocity . runtime . log ; import java . util . Enumeration ; import org . apache . log4j . * ; import org . apache . log4j . net . * ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; public class Log4JLogSystem implements LogSystem { private RuntimeServices rsvc = null ; protected Category logger = null ; protected Layout layout = null ; private String logfile = "" ; public Log4JLogSystem ( ) { } public void init ( RuntimeServices rs ) { rsvc = rs ; logfile = rsvc . getString ( RuntimeConstants . RUNTIME_LOG ) ; try { internalInit ( ) ; logVelocityMessage ( 0 , "Log4JLogSystem initialized using logfile " + logfile ) ; } catch ( Exception e ) { System . out . println ( "PANIC : error configuring Log4JLogSystem : " + e ) ; } } private void internalInit ( ) throws Exception { logger = Category . getInstance ( "" ) ; logger . setAdditivity ( false ) ; logger . setPriority ( Priority . DEBUG ) ; String pattern = rsvc . getString ( RuntimeConstants . LOGSYSTEM_LOG4J_PATTERN ) ; if ( pattern == null || pattern . length ( ) == 0 ) { pattern = "%d - %m%n" ; } layout = new PatternLayout ( pattern ) ; configureFile ( ) ; configureRemote ( ) ; configureSyslog ( ) ; configureEmail ( ) ; } private void configureFile ( ) throws Exception { int backupFiles = rsvc . getInt ( RuntimeConstants . LOGSYSTEM_LOG4J_FILE_BACKUPS , 1 ) ; int fileSize = rsvc . getInt ( RuntimeConstants . LOGSYSTEM_LOG4J_FILE_SIZE , 100000 ) ; Appender appender = new RollingFileAppender ( layout , logfile , true ) ; ( ( RollingFileAppender ) appender ) . setMaxBackupIndex ( backupFiles ) ; if ( fileSize > - 1 ) { ( ( RollingFileAppender ) appender ) . setMaximumFileSize ( fileSize ) ; } logger . addAppender ( appender ) ; } private void configureRemote ( ) throws Exception { String remoteHost = rsvc . getString ( RuntimeConstants . LOGSYSTEM_LOG4J_REMOTE_HOST ) ; int remotePort = rsvc . getInt ( RuntimeConstants . LOGSYSTEM_LOG4J_REMOTE_PORT , 1099 ) ; if ( remoteHost == null || remoteHost . trim ( ) . equals ( "" ) || remotePort <= 0 ) { return ; } Appender appender = new SocketAppender ( remoteHost , remotePort ) ; logger . addAppender ( appender ) ; } private void configureSyslog ( ) throws Exception { String syslogHost = rsvc . getString ( RuntimeConstants . LOGSYSTEM_LOG4J_SYSLOGD_HOST ) ; String syslogFacility = rsvc . getString ( RuntimeConstants . LOGSYSTEM_LOG4J_SYSLOGD_FACILITY ) ; if ( syslogHost == null || syslogHost . trim ( ) . equals ( "" ) || syslogFacility == null ) { return ; } Appender appender = new SyslogAppender ( ) ; ( ( SyslogAppender ) appender ) . setLayout ( layout ) ; ( ( SyslogAppender ) appender ) . setSyslogHost ( syslogHost ) ; ( ( SyslogAppender ) appender ) . setFacility ( syslogFacility ) ; logger . addAppender ( appender ) ; } private void configureEmail ( ) throws Exception { String smtpHost = rsvc . getString ( RuntimeConstants . LOGSYSTEM_LOG4J_EMAIL_SERVER ) ; String emailFrom = rsvc . getString ( RuntimeConstants . LOGSYSTEM_LOG4J_EMAIL_FROM ) ; String emailTo = rsvc . getString ( RuntimeConstants . LOGSYSTEM_LOG4J_EMAIL_TO ) ; String emailSubject = rsvc . getString ( RuntimeConstants . LOGSYSTEM_LOG4J_EMAIL_SUBJECT ) ; String bufferSize = rsvc . getString ( RuntimeConstants . LOGSYSTEM_LOG4J_EMAIL_BUFFER_SIZE ) ; if ( smtpHost == null || smtpHost . trim ( ) . equals ( "" ) || emailFrom == null || smtpHost . trim ( ) . equals ( "" ) || emailTo == null || emailTo . trim ( ) . equals ( "" ) || emailSubject == null || emailSubject . trim ( ) . equals ( "" ) || bufferSize == null || bufferSize . trim ( ) . equals ( "" ) ) { return ; } SMTPAppender appender = new SMTPAppender ( ) ; appender . setSMTPHost ( smtpHost ) ; appender . setFrom ( emailFrom ) ; appender . setTo ( emailTo ) ; appender . setSubject ( emailSubject ) ; appender . setBufferSize ( Integer . parseInt ( bufferSize ) ) ; appender . setLayout ( layout ) ; appender . activateOptions ( ) ; logger . addAppender ( appender ) ; } public void logVelocityMessage ( int level , String message ) { switch ( level ) { case LogSystem . WARN_ID : logger . warn ( message ) ; break ; case LogSystem . INFO_ID : logger . info ( message ) ; break ; case LogSystem . DEBUG_ID : logger . debug ( message ) ; break ; case LogSystem . ERROR_ID : logger . error ( message ) ; break ; default : logger . debug ( message ) ; break ; } } protected void finalize ( ) throws Throwable { shutdown ( ) ; } public void shutdown ( ) { Enumeration appenders = logger . getAllAppenders ( ) ; while ( appenders . hasMoreElements ( ) ) { Appender appender = ( Appender ) appenders . nextElement ( ) ; appender . close ( ) ; } } } 	1	['10', '1', '0', '12', '50', '0', '0', '12', '4', '0.361111111', '353', '1', '1', '0', '0.325', '0', '0', '33.9', '2', '1.1', '1']
package org . apache . velocity . runtime . parser . node ; import java . util . ArrayList ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTIntegerRange extends SimpleNode { public ASTIntegerRange ( int id ) { super ( id ) ; } public ASTIntegerRange ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side of range operator [n..m] has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { rsvc . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of range operator is not a valid type. " + "Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } int l = ( ( Integer ) left ) . intValue ( ) ; int r = ( ( Integer ) right ) . intValue ( ) ; int num = Math . abs ( l - r ) ; num += 1 ; int delta = ( l >= r ) ? - 1 : 1 ; ArrayList foo = new ArrayList ( ) ; int val = l ; for ( int i = 0 ; i < num ; i ++ ) { foo . add ( new Integer ( val ) ) ; val += delta ; } return foo ; } } 	1	['4', '2', '0', '8', '22', '6', '1', '8', '4', '2', '156', '0', '0', '0.931034483', '0.416666667', '1', '1', '38', '1', '0.5', '1']
package org . apache . velocity . runtime . resource ; import java . util . ArrayList ; import java . util . Hashtable ; import java . util . Vector ; import java . io . InputStream ; import java . io . IOException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . resource . ResourceFactory ; import org . apache . velocity . runtime . resource . loader . ResourceLoader ; import org . apache . velocity . runtime . resource . loader . ResourceLoaderFactory ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . commons . collections . ExtendedProperties ; public class ResourceManagerImpl implements ResourceManager { public static final int RESOURCE_TEMPLATE = 1 ; public static final int RESOURCE_CONTENT = 2 ; private static final String RESOURCE_LOADER_IDENTIFIER = "_RESOURCE_LOADER_IDENTIFIER_" ; protected ResourceCache globalCache = null ; protected ArrayList resourceLoaders = new ArrayList ( ) ; private ArrayList sourceInitializerList = new ArrayList ( ) ; private Hashtable sourceInitializerMap = new Hashtable ( ) ; private boolean resourceLoaderInitializersActive = false ; private boolean logWhenFound = true ; protected RuntimeServices rsvc = null ; public void initialize ( RuntimeServices rs ) throws Exception { rsvc = rs ; rsvc . info ( "Default ResourceManager initializing. (" + this . getClass ( ) + ")" ) ; ResourceLoader resourceLoader ; assembleResourceLoaderInitializers ( ) ; for ( int i = 0 ; i < sourceInitializerList . size ( ) ; i ++ ) { ExtendedProperties configuration = ( ExtendedProperties ) sourceInitializerList . get ( i ) ; String loaderClass = configuration . getString ( "class" ) ; if ( loaderClass == null ) { rsvc . error ( "Unable to find '" + configuration . getString ( RESOURCE_LOADER_IDENTIFIER ) + ".resource.loader.class' specification in configuation." + " This is a critical value.  Please adjust configuration." ) ; continue ; } resourceLoader = ResourceLoaderFactory . getLoader ( rsvc , loaderClass ) ; resourceLoader . commonInit ( rsvc , configuration ) ; resourceLoader . init ( configuration ) ; resourceLoaders . add ( resourceLoader ) ; } logWhenFound = rsvc . getBoolean ( RuntimeConstants . RESOURCE_MANAGER_LOGWHENFOUND , true ) ; String claz = rsvc . getString ( RuntimeConstants . RESOURCE_MANAGER_CACHE_CLASS ) ; Object o = null ; if ( claz != null && claz . length ( ) > 0 ) { try { o = Class . forName ( claz ) . newInstance ( ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for ResourceCache (" + claz + ") does not exist (or is not accessible to the current classlaoder)." ; rsvc . error ( err ) ; o = null ; } if ( ! ( o instanceof ResourceCache ) ) { String err = "The specified class for ResourceCache (" + claz + ") does not implement org.apache.runtime.resource.ResourceCache." + " ResourceManager. Using default ResourceCache implementation." ; rsvc . error ( err ) ; o = null ; } } if ( o == null ) o = new ResourceCacheImpl ( ) ; globalCache = ( ResourceCache ) o ; globalCache . initialize ( rsvc ) ; rsvc . info ( "Default ResourceManager initialization complete." ) ; } private void assembleResourceLoaderInitializers ( ) { if ( resourceLoaderInitializersActive ) { return ; } Vector resourceLoaderNames = rsvc . getConfiguration ( ) . getVector ( RuntimeConstants . RESOURCE_LOADER ) ; for ( int i = 0 ; i < resourceLoaderNames . size ( ) ; i ++ ) { String loaderID = resourceLoaderNames . get ( i ) + "." + RuntimeConstants . RESOURCE_LOADER ; ExtendedProperties loaderConfiguration = rsvc . getConfiguration ( ) . subset ( loaderID ) ; if ( loaderConfiguration == null ) { rsvc . warn ( "ResourceManager : No configuration information for resource loader named '" + resourceLoaderNames . get ( i ) + "'. Skipping." ) ; continue ; } loaderConfiguration . setProperty ( RESOURCE_LOADER_IDENTIFIER , resourceLoaderNames . get ( i ) ) ; sourceInitializerList . add ( loaderConfiguration ) ; } resourceLoaderInitializersActive = true ; } public Resource getResource ( String resourceName , int resourceType , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { Resource resource = globalCache . get ( resourceName ) ; if ( resource != null ) { try { refreshResource ( resource , encoding ) ; } catch ( ResourceNotFoundException rnfe ) { globalCache . remove ( resourceName ) ; return getResource ( resourceName , resourceType , encoding ) ; } catch ( ParseErrorException pee ) { rsvc . error ( "ResourceManager.getResource() exception: " + pee ) ; throw pee ; } catch ( Exception eee ) { rsvc . error ( "ResourceManager.getResource() exception: " + eee ) ; throw eee ; } } else { try { resource = loadResource ( resourceName , resourceType , encoding ) ; if ( resource . getResourceLoader ( ) . isCachingOn ( ) ) { globalCache . put ( resourceName , resource ) ; } } catch ( ResourceNotFoundException rnfe2 ) { rsvc . error ( "ResourceManager : unable to find resource '" + resourceName + "' in any resource loader." ) ; throw rnfe2 ; } catch ( ParseErrorException pee ) { rsvc . error ( "ResourceManager.getResource() parse exception: " + pee ) ; throw pee ; } catch ( Exception ee ) { rsvc . error ( "ResourceManager.getResource() exception new: " + ee ) ; throw ee ; } } return resource ; } protected Resource loadResource ( String resourceName , int resourceType , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { Resource resource = ResourceFactory . getResource ( resourceName , resourceType ) ; resource . setRuntimeServices ( rsvc ) ; resource . setName ( resourceName ) ; resource . setEncoding ( encoding ) ; long howOldItWas = 0 ; ResourceLoader resourceLoader = null ; for ( int i = 0 ; i < resourceLoaders . size ( ) ; i ++ ) { resourceLoader = ( ResourceLoader ) resourceLoaders . get ( i ) ; resource . setResourceLoader ( resourceLoader ) ; try { if ( resource . process ( ) ) { if ( logWhenFound ) { rsvc . info ( "ResourceManager : found " + resourceName + " with loader " + resourceLoader . getClassName ( ) ) ; } howOldItWas = resourceLoader . getLastModified ( resource ) ; break ; } } catch ( ResourceNotFoundException rnfe ) { } } if ( resource . getData ( ) == null ) { throw new ResourceNotFoundException ( "Unable to find resource '" + resourceName + "'" ) ; } resource . setLastModified ( howOldItWas ) ; resource . setModificationCheckInterval ( resourceLoader . getModificationCheckInterval ( ) ) ; resource . touch ( ) ; return resource ; } protected void refreshResource ( Resource resource , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { if ( resource . requiresChecking ( ) ) { resource . touch ( ) ; if ( resource . isSourceModified ( ) ) { if ( ! resource . getEncoding ( ) . equals ( encoding ) ) { rsvc . error ( "Declared encoding for template '" + resource . getName ( ) + "' is different on reload.  Old = '" + resource . getEncoding ( ) + "'  New = '" + encoding ) ; resource . setEncoding ( encoding ) ; } long howOldItWas = resource . getResourceLoader ( ) . getLastModified ( resource ) ; resource . process ( ) ; resource . setLastModified ( howOldItWas ) ; } } } public Resource getResource ( String resourceName , int resourceType ) throws ResourceNotFoundException , ParseErrorException , Exception { return getResource ( resourceName , resourceType , RuntimeConstants . ENCODING_DEFAULT ) ; } public String getLoaderNameForResource ( String resourceName ) { ResourceLoader resourceLoader = null ; for ( int i = 0 ; i < resourceLoaders . size ( ) ; i ++ ) { resourceLoader = ( ResourceLoader ) resourceLoaders . get ( i ) ; InputStream is = null ; try { is = resourceLoader . getResourceStream ( resourceName ) ; if ( is != null ) { return resourceLoader . getClass ( ) . toString ( ) ; } } catch ( ResourceNotFoundException e ) { } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException ioe ) { } } } } return null ; } } 	1	['8', '1', '0', '12', '66', '0', '0', '12', '5', '0.728571429', '593', '0.8', '2', '0', '0.45', '0', '0', '71.875', '8', '2.125', '2']
package org . apache . velocity . runtime . resource ; import org . apache . velocity . Template ; public class ResourceFactory { public static Resource getResource ( String resourceName , int resourceType ) { Resource resource = null ; switch ( resourceType ) { case ResourceManager . RESOURCE_TEMPLATE : resource = new Template ( ) ; break ; case ResourceManager . RESOURCE_CONTENT : resource = new ContentResource ( ) ; break ; } return resource ; } } 	1	['2', '1', '0', '4', '5', '1', '1', '3', '2', '2', '20', '0', '0', '0', '0.5', '0', '0', '9', '4', '2', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTEQNode extends SimpleNode { public ASTEQNode ( int id ) { super ( id ) ; } public ASTEQNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { rsvc . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '==' operation " + "has null value. " + "If a reference, it may not be in the context." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( left . getClass ( ) . equals ( right . getClass ( ) ) ) { return left . equals ( right ) ; } else { rsvc . error ( "Error in evaluation of == expression." + " Both arguments must be of the same Class." + " Currently left = " + left . getClass ( ) + ", right = " + right . getClass ( ) + ". " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "] (ASTEQNode)" ) ; } return false ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '10', '22', '10', '4', '8', '5', '2', '140', '0', '0', '0.9', '0.4', '2', '2', '27', '1', '0.6', '1']
package org . apache . velocity . runtime ; import java . io . Reader ; import java . util . Properties ; import org . apache . velocity . Template ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . util . introspection . Uberspect ; public class RuntimeSingleton implements RuntimeConstants { private static RuntimeInstance ri = new RuntimeInstance ( ) ; public synchronized static void init ( ) throws Exception { ri . init ( ) ; } public static RuntimeServices getRuntimeServices ( ) { return ri ; } public static void setProperty ( String key , Object value ) { ri . setProperty ( key , value ) ; } public static void setConfiguration ( ExtendedProperties configuration ) { ri . setConfiguration ( configuration ) ; } public static void addProperty ( String key , Object value ) { ri . addProperty ( key , value ) ; } public static void clearProperty ( String key ) { ri . clearProperty ( key ) ; } public static Object getProperty ( String key ) { return ri . getProperty ( key ) ; } public static void init ( Properties p ) throws Exception { ri . init ( p ) ; } public static void init ( String configurationFile ) throws Exception { ri . init ( configurationFile ) ; } private static Parser createNewParser ( ) { return ri . createNewParser ( ) ; } public static SimpleNode parse ( Reader reader , String templateName ) throws ParseException { return ri . parse ( reader , templateName ) ; } public static SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException { return ri . parse ( reader , templateName , dumpNamespace ) ; } public static Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name ) ; } public static Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name , encoding ) ; } public static ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getContent ( name ) ; } public static ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getContent ( name , encoding ) ; } public static String getLoaderNameForResource ( String resourceName ) { return ri . getLoaderNameForResource ( resourceName ) ; } public static void warn ( Object message ) { ri . warn ( message ) ; } public static void info ( Object message ) { ri . info ( message ) ; } public static void error ( Object message ) { ri . error ( message ) ; } public static void debug ( Object message ) { ri . debug ( message ) ; } public static String getString ( String key , String defaultValue ) { return ri . getString ( key , defaultValue ) ; } public static Directive getVelocimacro ( String vmName , String templateName ) { return ri . getVelocimacro ( vmName , templateName ) ; } public static boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) { return ri . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public static boolean isVelocimacro ( String vmName , String templateName ) { return ri . isVelocimacro ( vmName , templateName ) ; } public static boolean dumpVMNamespace ( String namespace ) { return ri . dumpVMNamespace ( namespace ) ; } public static String getString ( String key ) { return ri . getString ( key ) ; } public static int getInt ( String key ) { return ri . getInt ( key ) ; } public static int getInt ( String key , int defaultValue ) { return ri . getInt ( key , defaultValue ) ; } public static boolean getBoolean ( String key , boolean def ) { return ri . getBoolean ( key , def ) ; } public static ExtendedProperties getConfiguration ( ) { return ri . getConfiguration ( ) ; } public static Introspector getIntrospector ( ) { return ri . getIntrospector ( ) ; } public static Object getApplicationAttribute ( Object key ) { return ri . getApplicationAttribute ( key ) ; } public static Uberspect getUberspect ( ) { return ri . getUberspect ( ) ; } public static RuntimeInstance getRuntimeInstance ( ) { return ri ; } } 	1	['37', '1', '0', '29', '72', '0', '15', '14', '35', '0.027777778', '192', '1', '1', '0', '0.114197531', '0', '0', '4.162162162', '1', '0.9459', '1']
package org . apache . velocity . util . introspection ; public class IntrospectionCacheData { public Object thingy ; public Class contextData ; } 	1	['1', '1', '0', '6', '2', '0', '6', '0', '1', '2', '6', '0', '0', '0', '1', '0', '0', '3', '0', '0', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . MethodInvocationException ; import java . io . IOException ; import java . io . Writer ; public class ASTComment extends SimpleNode { private static final char [ ] ZILCH = "" . toCharArray ( ) ; private char [ ] carr ; public ASTComment ( int id ) { super ( id ) ; } public ASTComment ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { Token t = getFirstToken ( ) ; int loc1 = t . image . indexOf ( "##" ) ; int loc2 = t . image . indexOf ( "#*" ) ; if ( loc1 == - 1 && loc2 == - 1 ) { carr = ZILCH ; } else { carr = t . image . substring ( 0 , ( loc1 == - 1 ) ? loc2 : loc1 ) . toCharArray ( ) ; } return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException { writer . write ( carr ) ; return true ; } } 	1	['6', '2', '0', '9', '14', '11', '3', '8', '5', '0.8', '70', '1', '0', '0.9', '0.4', '0', '0', '10.33333333', '1', '0.5', '2']
package org . apache . velocity . util . introspection ; public interface VelPropertyGet { public Object invoke ( Object o ) throws Exception ; public boolean isCacheable ( ) ; public String getMethodName ( ) ; } 	1	['3', '1', '0', '4', '3', '3', '4', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . util . introspection ; import org . apache . velocity . runtime . RuntimeLogger ; import java . util . Iterator ; import java . lang . reflect . Method ; public interface Uberspect { public void init ( ) throws Exception ; public Iterator getIterator ( Object obj , Info info ) throws Exception ; public VelMethod getMethod ( Object obj , String method , Object [ ] args , Info info ) throws Exception ; public VelPropertyGet getPropertyGet ( Object obj , String identifier , Info info ) throws Exception ; public VelPropertySet getPropertySet ( Object obj , String identifier , Object arg , Info info ) throws Exception ; } 	1	['5', '1', '0', '12', '5', '10', '8', '4', '5', '2', '5', '0', '0', '0', '0.68', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTTrue extends SimpleNode { private static Boolean value = Boolean . TRUE ; public ASTTrue ( int id ) { super ( id ) ; } public ASTTrue ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) { return true ; } public Object value ( InternalContextAdapter context ) { return value ; } } 	1	['6', '2', '0', '6', '9', '13', '4', '4', '5', '0.8', '28', '1', '0', '0.9', '0.4', '0', '0', '3.5', '1', '0.5', '1']
