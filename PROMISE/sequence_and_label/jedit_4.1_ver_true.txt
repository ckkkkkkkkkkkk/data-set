package org . gjt . sp . jedit . syntax ; import javax . swing . text . * ; import java . awt . font . * ; import java . util . List ; import org . gjt . sp . jedit . syntax . * ; public class SoftWrapTokenHandler extends DisplayTokenHandler { public void init ( Segment seg , SyntaxStyle [ ] styles , FontRenderContext fontRenderContext , TabExpander expander , List out , float wrapMargin ) { super . init ( seg , styles , fontRenderContext , expander ) ; this . wrapMargin = wrapMargin += 2.0f ; this . out = out ; initialSize = out . size ( ) ; seenNonWhitespace = addedNonWhitespace = false ; endX = endOfWhitespace = 0.0f ; end = null ; } public List getChunkList ( ) { return out ; } public void handleToken ( byte id , int offset , int length , TokenMarker . LineContext context ) { Token token = createToken ( id , offset , length , context ) ; if ( token != null ) { addToken ( token , context ) ; if ( id == Token . WHITESPACE || id == Token . TAB ) { if ( ! seenNonWhitespace ) { endOfWhitespace = x ; } } else seenNonWhitespace = true ; if ( out . size ( ) == initialSize ) out . add ( firstToken ) ; else if ( id == Token . WHITESPACE || id == Token . TAB ) { if ( out . size ( ) != initialSize ) { end = lastToken ; endX = x ; } } else if ( x > wrapMargin && end != null && addedNonWhitespace ) { Chunk blankSpace = new Chunk ( endOfWhitespace , end . offset + end . length , getParserRuleSet ( context ) ) ; blankSpace . next = end . next ; end . next = null ; x = x - endX + endOfWhitespace ; out . add ( blankSpace ) ; end = null ; endX = x ; } addedNonWhitespace = seenNonWhitespace ; } } private List out ; private float wrapMargin ; private float endX ; private Token end ; private boolean seenNonWhitespace ; private boolean addedNonWhitespace ; private float endOfWhitespace ; private int initialSize ; } 	0	['4', '3', '0', '8', '12', '0', '2', '6', '4', '0.625', '182', '1', '1', '0.833333333', '0.325', '1', '4', '42.5', '12', '3.5', '0']
package bsh ; class BSHBlock extends SimpleNode { BSHBlock ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { return eval ( callstack , interpreter , false ) ; } public Object eval ( CallStack callstack , Interpreter interpreter , boolean overrideNamespace ) throws EvalError { Object ret = Primitive . VOID ; int statements = jjtGetNumChildren ( ) ; NameSpace enclosingNameSpace = null ; if ( ! overrideNamespace ) { enclosingNameSpace = callstack . top ( ) ; BlockNameSpace bodyNameSpace = new BlockNameSpace ( enclosingNameSpace ) ; callstack . swap ( bodyNameSpace ) ; } try { for ( int i = 0 ; i < statements ; i ++ ) { SimpleNode node = ( ( SimpleNode ) jjtGetChild ( i ) ) ; ret = node . eval ( callstack , interpreter ) ; if ( ret instanceof ReturnControl ) break ; } } finally { if ( ! overrideNamespace ) callstack . swap ( enclosingNameSpace ) ; } return ret ; } } 	0	['3', '2', '0', '14', '10', '3', '5', '9', '2', '2', '71', '0', '0', '0.9', '0.6', '1', '1', '22.66666667', '1', '0.6667', '0']
package org . gjt . sp . jedit ; public interface EBComponent { void handleMessage ( EBMessage message ) ; } 	0	['1', '1', '0', '32', '1', '0', '32', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package bsh ; class BSHPrimaryExpression extends SimpleNode { BSHPrimaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object obj = jjtGetChild ( 0 ) ; int n = jjtGetNumChildren ( ) ; for ( int i = 1 ; i < n ; i ++ ) obj = ( ( BSHPrimarySuffix ) jjtGetChild ( i ) ) . doSuffix ( obj , callstack , interpreter ) ; if ( obj instanceof SimpleNode ) if ( obj instanceof BSHAmbiguousName ) obj = ( ( BSHAmbiguousName ) obj ) . toObject ( callstack , interpreter ) ; else obj = ( ( SimpleNode ) obj ) . eval ( callstack , interpreter ) ; return obj ; } } 	0	['2', '2', '0', '8', '8', '1', '1', '7', '1', '2', '50', '0', '0', '0.947368421', '0.625', '1', '1', '24', '1', '0.5', '0']
package org . gjt . sp . jedit . options ; import javax . swing . border . EmptyBorder ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . syntax . SyntaxStyle ; import org . gjt . sp . jedit . gui . ColorWellButton ; import org . gjt . sp . jedit . gui . EnhancedDialog ; import org . gjt . sp . jedit . * ; public class SyntaxHiliteOptionPane extends AbstractOptionPane { public static final EmptyBorder noFocusBorder = new EmptyBorder ( 1 , 1 , 1 , 1 ) ; public SyntaxHiliteOptionPane ( ) { super ( "syntax" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( 6 , 6 ) ) ; add ( BorderLayout . CENTER , createStyleTableScroller ( ) ) ; } protected void _save ( ) { styleModel . save ( ) ; } private StyleTableModel styleModel ; private JTable styleTable ; private JScrollPane createStyleTableScroller ( ) { styleModel = createStyleTableModel ( ) ; styleTable = new JTable ( styleModel ) ; styleTable . setRowSelectionAllowed ( false ) ; styleTable . setColumnSelectionAllowed ( false ) ; styleTable . setCellSelectionEnabled ( false ) ; styleTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; styleTable . addMouseListener ( new MouseHandler ( ) ) ; TableColumnModel tcm = styleTable . getColumnModel ( ) ; TableColumn styleColumn = tcm . getColumn ( 1 ) ; styleColumn . setCellRenderer ( new StyleTableModel . StyleRenderer ( ) ) ; Dimension d = styleTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 100 ) ; JScrollPane scroller = new JScrollPane ( styleTable ) ; scroller . setPreferredSize ( d ) ; return scroller ; } private StyleTableModel createStyleTableModel ( ) { return new StyleTableModel ( ) ; } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { int row = styleTable . rowAtPoint ( evt . getPoint ( ) ) ; if ( row == - 1 ) return ; SyntaxStyle style = new StyleEditor ( SyntaxHiliteOptionPane . this , ( SyntaxStyle ) styleModel . getValueAt ( row , 1 ) ) . getStyle ( ) ; if ( style != null ) styleModel . setValueAt ( style , row , 1 ) ; } } } class StyleTableModel extends AbstractTableModel { private Vector styleChoices ; StyleTableModel ( ) { styleChoices = new Vector ( 13 ) ; addStyleChoice ( "options.syntax.comment1Style" , "view.style.comment1" ) ; addStyleChoice ( "options.syntax.comment2Style" , "view.style.comment2" ) ; addStyleChoice ( "options.syntax.literal1Style" , "view.style.literal1" ) ; addStyleChoice ( "options.syntax.literal2Style" , "view.style.literal2" ) ; addStyleChoice ( "options.syntax.labelStyle" , "view.style.label" ) ; addStyleChoice ( "options.syntax.keyword1Style" , "view.style.keyword1" ) ; addStyleChoice ( "options.syntax.keyword2Style" , "view.style.keyword2" ) ; addStyleChoice ( "options.syntax.keyword3Style" , "view.style.keyword3" ) ; addStyleChoice ( "options.syntax.functionStyle" , "view.style.function" ) ; addStyleChoice ( "options.syntax.markupStyle" , "view.style.markup" ) ; addStyleChoice ( "options.syntax.operatorStyle" , "view.style.operator" ) ; addStyleChoice ( "options.syntax.digitStyle" , "view.style.digit" ) ; addStyleChoice ( "options.syntax.invalidStyle" , "view.style.invalid" ) ; addStyleChoice ( "options.syntax.foldLine" , "view.style.foldLine" ) ; MiscUtilities . quicksort ( styleChoices , new MiscUtilities . StringCompare ( ) ) ; } public int getColumnCount ( ) { return 2 ; } public int getRowCount ( ) { return styleChoices . size ( ) ; } public Object getValueAt ( int row , int col ) { StyleChoice ch = ( StyleChoice ) styleChoices . elementAt ( row ) ; switch ( col ) { case 0 : return ch . label ; case 1 : return ch . style ; default : return null ; } } public void setValueAt ( Object value , int row , int col ) { StyleChoice ch = ( StyleChoice ) styleChoices . elementAt ( row ) ; if ( col == 1 ) ch . style = ( SyntaxStyle ) value ; fireTableRowsUpdated ( row , row ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.syntax.object" ) ; case 1 : return jEdit . getProperty ( "options.syntax.style" ) ; default : return null ; } } public void save ( ) { for ( int i = 0 ; i < styleChoices . size ( ) ; i ++ ) { StyleChoice ch = ( StyleChoice ) styleChoices . elementAt ( i ) ; jEdit . setProperty ( ch . property , GUIUtilities . getStyleString ( ch . style ) ) ; } } private void addStyleChoice ( String label , String property ) { styleChoices . addElement ( new StyleChoice ( jEdit . getProperty ( label ) , property , GUIUtilities . parseStyle ( jEdit . getProperty ( property ) , "Dialog" , 12 ) ) ) ; } static class StyleChoice { String label ; String property ; SyntaxStyle style ; StyleChoice ( String label , String property , SyntaxStyle style ) { this . label = label ; this . property = property ; this . style = style ; } public String toString ( ) { return label ; } } static class StyleRenderer extends JLabel implements TableCellRenderer { public StyleRenderer ( ) { setOpaque ( true ) ; setBorder ( SyntaxHiliteOptionPane . noFocusBorder ) ; setText ( "Hello World" ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean cellHasFocus , int row , int col ) { if ( value != null ) { SyntaxStyle style = ( SyntaxStyle ) value ; setForeground ( style . getForegroundColor ( ) ) ; if ( style . getBackgroundColor ( ) != null ) setBackground ( style . getBackgroundColor ( ) ) ; else { setBackground ( jEdit . getColorProperty ( "view.bgColor" ) ) ; } setFont ( style . getFont ( ) ) ; } setBorder ( ( cellHasFocus ) ? UIManager . getBorder ( "Table.focusCellHighlightBorder" ) : SyntaxHiliteOptionPane . noFocusBorder ) ; return this ; } } } class StyleEditor extends EnhancedDialog implements ActionListener { StyleEditor ( Component comp , SyntaxStyle style ) { super ( GUIUtilities . getParentDialog ( comp ) , jEdit . getProperty ( "style-editor.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( 12 , 12 ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; GridBagLayout layout = new GridBagLayout ( ) ; JPanel panel = new JPanel ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridx = cons . gridy = 0 ; cons . gridwidth = 2 ; cons . gridheight = 1 ; cons . fill = GridBagConstraints . BOTH ; cons . weightx = 0.0f ; italics = new JCheckBox ( jEdit . getProperty ( "style-editor.italics" ) ) ; italics . setSelected ( style . getFont ( ) . isItalic ( ) ) ; layout . setConstraints ( italics , cons ) ; panel . add ( italics ) ; cons . gridy ++ ; bold = new JCheckBox ( jEdit . getProperty ( "style-editor.bold" ) ) ; bold . setSelected ( style . getFont ( ) . isBold ( ) ) ; layout . setConstraints ( bold , cons ) ; panel . add ( bold ) ; cons . gridy ++ ; cons . gridwidth = 1 ; Color fg = style . getForegroundColor ( ) ; fgColorCheckBox = new JCheckBox ( jEdit . getProperty ( "style-editor.fgColor" ) ) ; fgColorCheckBox . setSelected ( fg != null ) ; fgColorCheckBox . addActionListener ( this ) ; fgColorCheckBox . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; layout . setConstraints ( fgColorCheckBox , cons ) ; panel . add ( fgColorCheckBox ) ; cons . gridx ++ ; fgColor = new ColorWellButton ( fg ) ; fgColor . setEnabled ( fg != null ) ; layout . setConstraints ( fgColor , cons ) ; panel . add ( fgColor ) ; cons . gridx = 0 ; cons . gridy ++ ; Color bg = style . getBackgroundColor ( ) ; bgColorCheckBox = new JCheckBox ( jEdit . getProperty ( "style-editor.bgColor" ) ) ; bgColorCheckBox . setSelected ( bg != null ) ; bgColorCheckBox . addActionListener ( this ) ; bgColorCheckBox . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; layout . setConstraints ( bgColorCheckBox , cons ) ; panel . add ( bgColorCheckBox ) ; cons . gridx ++ ; bgColor = new ColorWellButton ( bg ) ; bgColor . setEnabled ( bg != null ) ; layout . setConstraints ( bgColor , cons ) ; panel . add ( bgColor ) ; content . add ( BorderLayout . CENTER , panel ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; box . add ( ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; ok . addActionListener ( this ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; box . add ( cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ) ; cancel . addActionListener ( this ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; pack ( ) ; setLocationRelativeTo ( GUIUtilities . getParentDialog ( comp ) ) ; setResizable ( false ) ; show ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; else if ( source == fgColorCheckBox ) fgColor . setEnabled ( fgColorCheckBox . isSelected ( ) ) ; else if ( source == bgColorCheckBox ) bgColor . setEnabled ( bgColorCheckBox . isSelected ( ) ) ; } public void ok ( ) { okClicked = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public SyntaxStyle getStyle ( ) { if ( ! okClicked ) return null ; Color foreground = ( fgColorCheckBox . isSelected ( ) ? fgColor . getSelectedColor ( ) : null ) ; Color background = ( bgColorCheckBox . isSelected ( ) ? bgColor . getSelectedColor ( ) : null ) ; return new SyntaxStyle ( foreground , background , new Font ( "Dialog" , ( italics . isSelected ( ) ? Font . ITALIC : 0 ) | ( bold . isSelected ( ) ? Font . BOLD : 0 ) , 12 ) ) ; } private JCheckBox italics ; private JCheckBox bold ; private JCheckBox fgColorCheckBox ; private ColorWellButton fgColor ; private JCheckBox bgColorCheckBox ; private ColorWellButton bgColor ; private JButton ok ; private JButton cancel ; private boolean okClicked ; } 	0	['8', '6', '0', '6', '31', '20', '4', '4', '1', '0.761904762', '121', '0.666666667', '1', '0.991111111', '0.5', '4', '12', '13.75', '1', '0.75', '0']
package org . gjt . sp . jedit ; public abstract class EBMessage { public EBMessage ( EBComponent source ) { this . source = source ; } public EBComponent getSource ( ) { return source ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + paramString ( ) + "]" ; } public String paramString ( ) { return "source=" + source ; } private EBComponent source ; public void veto ( ) { } public boolean isVetoed ( ) { return false ; } public static abstract class NonVetoable extends EBMessage { public NonVetoable ( EBComponent source ) { super ( source ) ; } public void veto ( ) { throw new InternalError ( "Can't veto this message" ) ; } } } 	0	['6', '1', '11', '31', '13', '9', '31', '1', '6', '0.4', '45', '1', '1', '0', '0.583333333', '0', '0', '6.333333333', '1', '0.8333', '0']
package org . gjt . sp . util ; import javax . swing . text . Segment ; public class SegmentBuffer extends Segment { public SegmentBuffer ( int capacity ) { ensureCapacity ( capacity ) ; } public void append ( char ch ) { ensureCapacity ( count + 1 ) ; array [ offset + count ] = ch ; count ++ ; } public void append ( char [ ] text , int off , int len ) { ensureCapacity ( count + len ) ; System . arraycopy ( text , off , array , count , len ) ; count += len ; } private void ensureCapacity ( int capacity ) { if ( array == null ) array = new char [ capacity ] ; else if ( capacity >= array . length ) { char [ ] arrayN = new char [ capacity * 2 ] ; System . arraycopy ( array , 0 , arrayN , 0 , count ) ; array = arrayN ; } } } 	0	['4', '2', '0', '2', '6', '0', '2', '0', '3', '2', '83', '0', '0', '0.842105263', '0.5625', '1', '11', '19.75', '3', '1.25', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . * ; public class EditPaneUpdate extends EBMessage { public static final Object CREATED = "CREATED" ; public static final Object DESTROYED = "DESTROYED" ; public static final Object BUFFER_CHANGED = "BUFFER_CHANGED" ; public EditPaneUpdate ( EditPane editPane , Object what ) { super ( editPane ) ; if ( what == null ) throw new NullPointerException ( "What must be non-null" ) ; this . what = what ; } public Object getWhat ( ) { return what ; } public EditPane getEditPane ( ) { return ( EditPane ) getSource ( ) ; } public String paramString ( ) { return "what=" + what + "," + super . paramString ( ) ; } private Object what ; } 	0	['5', '2', '0', '6', '13', '4', '4', '3', '4', '0.875', '52', '0.25', '0', '0.5', '0.5', '1', '1', '8.6', '1', '0.6', '0']
package org . gjt . sp . jedit . help ; import com . microstar . xml . * ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . tree . * ; import java . awt . * ; import java . awt . event . * ; import java . io . * ; import java . net . * ; import java . util . * ; import org . gjt . sp . jedit . browser . FileCellRenderer ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; class HelpTOCPanel extends JPanel { public HelpTOCPanel ( HelpViewer helpViewer ) { super ( new BorderLayout ( ) ) ; this . helpViewer = helpViewer ; nodes = new Hashtable ( ) ; createTOC ( ) ; toc = new TOCTree ( tocModel ) ; if ( ! OperatingSystem . isMacOSLF ( ) ) toc . putClientProperty ( "JTree.lineStyle" , "Angled" ) ; toc . setCellRenderer ( new TOCCellRenderer ( ) ) ; toc . setEditable ( false ) ; toc . setRootVisible ( false ) ; toc . setShowsRootHandles ( true ) ; for ( int i = 0 ; i < tocRoot . getChildCount ( ) ; i ++ ) { DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) tocRoot . getChildAt ( i ) ; toc . expandPath ( new TreePath ( node . getPath ( ) ) ) ; } add ( BorderLayout . CENTER , new JScrollPane ( toc ) ) ; } public void selectNode ( String shortURL ) { DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) nodes . get ( shortURL ) ; if ( node == null ) return ; TreePath path = new TreePath ( tocModel . getPathToRoot ( node ) ) ; toc . expandPath ( path ) ; toc . setSelectionPath ( path ) ; toc . scrollPathToVisible ( path ) ; } private HelpViewer helpViewer ; private DefaultTreeModel tocModel ; private DefaultMutableTreeNode tocRoot ; private JTree toc ; private Hashtable nodes ; private DefaultMutableTreeNode createNode ( String href , String title ) { DefaultMutableTreeNode node = new DefaultMutableTreeNode ( new HelpNode ( href , title ) , true ) ; nodes . put ( href , node ) ; return node ; } private void createTOC ( ) { tocRoot = new DefaultMutableTreeNode ( ) ; tocRoot . add ( createNode ( "welcome.html" , jEdit . getProperty ( "helpviewer.toc.welcome" ) ) ) ; tocRoot . add ( createNode ( "README.txt" , jEdit . getProperty ( "helpviewer.toc.readme" ) ) ) ; tocRoot . add ( createNode ( "NEWS.txt" , jEdit . getProperty ( "helpviewer.toc.news" ) ) ) ; tocRoot . add ( createNode ( "CHANGES.txt" , jEdit . getProperty ( "helpviewer.toc.changes" ) ) ) ; tocRoot . add ( createNode ( "TODO.txt" , jEdit . getProperty ( "helpviewer.toc.todo" ) ) ) ; tocRoot . add ( createNode ( "COPYING.txt" , jEdit . getProperty ( "helpviewer.toc.copying" ) ) ) ; tocRoot . add ( createNode ( "COPYING.DOC.txt" , jEdit . getProperty ( "helpviewer.toc.copying-doc" ) ) ) ; loadTOC ( tocRoot , "users-guide/toc.xml" ) ; loadTOC ( tocRoot , "FAQ/toc.xml" ) ; loadTOC ( tocRoot , "api/toc.xml" ) ; DefaultMutableTreeNode pluginTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "helpviewer.toc.plugins" ) , true ) ; EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin plugin = plugins [ i ] ; EditPlugin . JAR jar = plugin . getJAR ( ) ; if ( jar == null ) continue ; String name = plugin . getClassName ( ) ; String docs = jEdit . getProperty ( "plugin." + name + ".docs" ) ; String label = jEdit . getProperty ( "plugin." + name + ".name" ) ; if ( docs != null ) { if ( label != null && docs != null ) { URL url = jar . getClassLoader ( ) . getResource ( docs ) ; if ( url != null ) { pluginTree . add ( createNode ( url . toString ( ) , label ) ) ; } } } } if ( pluginTree . getChildCount ( ) != 0 ) tocRoot . add ( pluginTree ) ; else { pluginTree = null ; } tocModel = new DefaultTreeModel ( tocRoot ) ; } private void loadTOC ( DefaultMutableTreeNode root , String path ) { TOCHandler h = new TOCHandler ( root , MiscUtilities . getParentOfPath ( path ) ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( h ) ; try { parser . parse ( null , null , new InputStreamReader ( new URL ( helpViewer . getBaseURL ( ) + '/' + path ) . openStream ( ) ) ) ; } catch ( XmlException xe ) { int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , this , path + ':' + line + ": " + message ) ; } catch ( Exception e ) { Log . log ( Log . NOTICE , this , e ) ; } } static class HelpNode { String href , title ; HelpNode ( String href , String title ) { this . href = href ; this . title = title ; } public String toString ( ) { return title ; } } class TOCHandler extends HandlerBase { String dir ; TOCHandler ( DefaultMutableTreeNode root , String dir ) { nodes = new Stack ( ) ; node = root ; this . dir = dir ; } public void attribute ( String aname , String value , boolean isSpecified ) { if ( aname . equals ( "HREF" ) ) href = value ; } public void charData ( char [ ] c , int off , int len ) { if ( tag . equals ( "TITLE" ) ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char ch = c [ off + i ] ; if ( ch == ' ' || ! Character . isWhitespace ( ch ) ) buf . append ( ch ) ; } title = buf . toString ( ) ; } } public void startElement ( String name ) { tag = name ; } public void endElement ( String name ) { if ( name == null ) return ; if ( name . equals ( "TITLE" ) ) { DefaultMutableTreeNode newNode = createNode ( dir + href , title ) ; node . add ( newNode ) ; nodes . push ( node ) ; node = newNode ; } else if ( name . equals ( "ENTRY" ) ) node = ( DefaultMutableTreeNode ) nodes . pop ( ) ; } private String tag ; private String title ; private String href ; private DefaultMutableTreeNode node ; private Stack nodes ; } class TOCTree extends JTree { TOCTree ( TreeModel model ) { super ( model ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( this ) ; } public final String getToolTipText ( MouseEvent evt ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { Rectangle cellRect = getPathBounds ( path ) ; if ( cellRect != null && ! cellRectIsVisible ( cellRect ) ) return path . getLastPathComponent ( ) . toString ( ) ; } return null ; } protected void processMouseEvent ( MouseEvent evt ) { switch ( evt . getID ( ) ) { case MouseEvent . MOUSE_CLICKED : TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { if ( ! isPathSelected ( path ) ) setSelectionPath ( path ) ; Object obj = ( ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( ! ( obj instanceof HelpNode ) ) { this . expandPath ( path ) ; return ; } HelpNode node = ( HelpNode ) obj ; helpViewer . gotoURL ( node . href , true ) ; } super . processMouseEvent ( evt ) ; break ; default : super . processMouseEvent ( evt ) ; break ; } } private int toolTipInitialDelay = - 1 ; private int toolTipReshowDelay = - 1 ; private boolean cellRectIsVisible ( Rectangle cellRect ) { Rectangle vr = TOCTree . this . getVisibleRect ( ) ; return vr . contains ( cellRect . x , cellRect . y ) && vr . contains ( cellRect . x + cellRect . width , cellRect . y + cellRect . height ) ; } } class TOCCellRenderer extends DefaultTreeCellRenderer { EmptyBorder border = new EmptyBorder ( 1 , 0 , 1 , 1 ) ; public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean focus ) { super . getTreeCellRendererComponent ( tree , value , sel , expanded , leaf , row , focus ) ; setIcon ( leaf ? FileCellRenderer . fileIcon : ( expanded ? FileCellRenderer . openDirIcon : FileCellRenderer . dirIcon ) ) ; setBorder ( border ) ; return this ; } } } 	0	['7', '5', '0', '15', '59', '5', '4', '15', '2', '0.633333333', '389', '1', '1', '0.990895296', '0.371428571', '0', '0', '53.85714286', '8', '2', '0']
package org . gjt . sp . jedit . search ; import gnu . regexp . * ; import java . awt . Component ; import java . util . ArrayList ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class AllBufferSet extends BufferListSet { public AllBufferSet ( String glob ) { this . glob = glob ; } public String getFileFilter ( ) { return glob ; } public String getCode ( ) { return "new AllBufferSet(\"" + MiscUtilities . charsToEscapes ( glob ) + "\")" ; } private String glob ; protected String [ ] _getFiles ( Component comp ) { Buffer [ ] buffers = jEdit . getBuffers ( ) ; ArrayList returnValue = new ArrayList ( buffers . length ) ; RE filter ; try { filter = new RE ( MiscUtilities . globToRE ( glob ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; return null ; } for ( int i = 0 ; i < buffers . length ; i ++ ) { Buffer buffer = buffers [ i ] ; if ( filter . isMatch ( buffer . getName ( ) ) ) returnValue . add ( buffer . getPath ( ) ) ; } return ( String [ ] ) returnValue . toArray ( new String [ returnValue . size ( ) ] ) ; } } 	0	['4', '2', '0', '7', '20', '0', '1', '6', '3', '0', '79', '1', '0', '0.7', '0.5', '1', '1', '18.5', '3', '1.25', '0']
package bsh ; class ReturnControl implements ParserConstants { public int kind ; public Object value ; public ReturnControl ( int kind , Object value ) { this . kind = kind ; this . value = value ; } } 	0	['1', '1', '0', '10', '2', '0', '9', '1', '1', '2', '12', '0', '0', '0', '1', '0', '0', '9', '0', '0', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class BufferSwitcher extends JComboBox { public BufferSwitcher ( EditPane editPane ) { this . editPane = editPane ; setRenderer ( new BufferCellRenderer ( ) ) ; setMaximumRowCount ( jEdit . getIntegerProperty ( "bufferSwitcher.maxRowCount" , 10 ) ) ; addActionListener ( new ActionHandler ( ) ) ; } public void updateBufferList ( ) { if ( jEdit . getBufferCount ( ) == 0 ) return ; updating = true ; setMaximumRowCount ( jEdit . getIntegerProperty ( "bufferSwitcher.maxRowCount" , 10 ) ) ; setModel ( new DefaultComboBoxModel ( jEdit . getBuffers ( ) ) ) ; setSelectedItem ( editPane . getBuffer ( ) ) ; updating = false ; } private EditPane editPane ; private boolean updating ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( ! updating ) { Buffer buffer = ( Buffer ) getSelectedItem ( ) ; if ( buffer != null ) editPane . setBuffer ( buffer ) ; } } } class BufferCellRenderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; Buffer buffer = ( Buffer ) value ; if ( buffer == null ) setIcon ( null ) ; else setIcon ( buffer . getIcon ( ) ) ; return this ; } } } 	0	['4', '5', '0', '6', '17', '0', '4', '5', '2', '0.5', '61', '1', '1', '0.995856354', '0.416666667', '0', '0', '13.75', '2', '1', '0']
package org . gjt . sp . jedit . syntax ; public interface TokenHandler { public void handleToken ( byte id , int offset , int length , TokenMarker . LineContext context ) ; } 	0	['1', '1', '0', '8', '1', '0', '7', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class MacrosChanged extends EBMessage { public MacrosChanged ( EBComponent source ) { super ( source ) ; } } 	0	['1', '2', '0', '4', '2', '0', '2', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . gjt . sp . jedit . search ; import java . io . Serializable ; import javax . swing . text . Segment ; import gnu . regexp . * ; public class CharIndexedSegment implements CharIndexed , Serializable { public CharIndexedSegment ( Segment seg , int index ) { this . seg = seg ; m_index = index ; } public CharIndexedSegment ( Segment seg , boolean reverse ) { this . seg = seg ; m_index = ( reverse ? seg . count - 1 : 0 ) ; this . reverse = reverse ; } public char charAt ( int index ) { if ( reverse ) index = - index ; return ( ( m_index + index ) < seg . count && m_index + index >= 0 ) ? seg . array [ seg . offset + m_index + index ] : CharIndexed . OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( m_index >= 0 && m_index < seg . count ) ; } public void reset ( ) { m_index = ( reverse ? seg . count - 1 : 0 ) ; } public boolean move ( int index ) { if ( reverse ) index = - index ; return ( ( m_index += index ) < seg . count ) ; } private Segment seg ; private int m_index ; private boolean reverse ; } 	0	['6', '1', '0', '4', '7', '0', '3', '1', '6', '0.133333333', '118', '1', '0', '0', '0.5', '0', '0', '18.16666667', '4', '2', '0']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; class PluginManagerProgress extends JDialog { public PluginManagerProgress ( JDialog dialog , String type , Roster roster ) { super ( dialog , jEdit . getProperty ( "plugin-manager.progress." + type + "-task" ) , true ) ; this . dialog = dialog ; this . roster = roster ; this . type = type ; JPanel content = new JPanel ( new BorderLayout ( 12 , 12 ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; progress = new JProgressBar ( ) ; progress . setStringPainted ( true ) ; progress . setString ( jEdit . getProperty ( "plugin-manager.progress." + type + "-task" ) ) ; int maximum = 0 ; count = roster . getOperationCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { maximum += roster . getOperation ( i ) . getMaximum ( ) ; } progress . setMaximum ( maximum ) ; content . add ( BorderLayout . CENTER , progress ) ; stop = new JButton ( jEdit . getProperty ( "plugin-manager.progress.stop" ) ) ; stop . addActionListener ( new ActionHandler ( ) ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( stop ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , panel ) ; addWindowListener ( new WindowHandler ( ) ) ; pack ( ) ; Dimension size = getSize ( ) ; size . width = Math . max ( size . width , 500 ) ; setSize ( size ) ; setLocationRelativeTo ( dialog ) ; show ( ) ; } public void removing ( String plugin ) { String [ ] args = { plugin } ; showMessage ( jEdit . getProperty ( "plugin-manager.progress.removing" , args ) ) ; stop . setEnabled ( true ) ; } public void downloading ( String plugin ) { String [ ] args = { plugin } ; showMessage ( jEdit . getProperty ( "plugin-manager.progress.downloading" , args ) ) ; stop . setEnabled ( true ) ; } public void installing ( String plugin ) { String [ ] args = { plugin } ; showMessage ( jEdit . getProperty ( "plugin-manager.progress.installing" , args ) ) ; stop . setEnabled ( false ) ; } public void setValue ( final int value ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { progress . setValue ( valueSoFar + value ) ; } } ) ; } public void done ( final boolean ok ) { this . ok |= ok ; try { if ( ! ok || done == count ) { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { dispose ( ) ; if ( ok ) { GUIUtilities . message ( dialog , "plugin-manager." + type + "-done" , null ) ; } else { } } } ) ; } else { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { valueSoFar += roster . getOperation ( done - 1 ) . getMaximum ( ) ; progress . setValue ( valueSoFar ) ; done ++ ; } } ) ; } } catch ( Exception e ) { } } public boolean isOK ( ) { return ok ; } private JDialog dialog ; private Thread thread ; private String type ; private JProgressBar progress ; private JButton stop ; private int count ; private int done = 1 ; private int valueSoFar ; private boolean ok ; private Roster roster ; private void showMessage ( final String msg ) { } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == stop ) { thread . stop ( ) ; dispose ( ) ; } } } class WindowHandler extends WindowAdapter { boolean done ; public void windowOpened ( WindowEvent evt ) { if ( done ) return ; done = true ; thread = new RosterThread ( ) ; thread . start ( ) ; } public void windowClosing ( WindowEvent evt ) { thread . stop ( ) ; dispose ( ) ; } } class RosterThread extends Thread { RosterThread ( ) { super ( "Plugin manager thread" ) ; } public void run ( ) { roster . performOperations ( PluginManagerProgress . this ) ; } } } 	0	['19', '6', '0', '12', '60', '125', '11', '8', '7', '0.916666667', '336', '1', '1', '0.97309417', '0.197368421', '3', '6', '16.15789474', '3', '1.0526', '0']
package bsh ; import java . lang . reflect . Field ; import java . util . Hashtable ; class LHS implements ParserConstants , java . io . Serializable { NameSpace nameSpace ; static final int VARIABLE = 0 , FIELD = 1 , PROPERTY = 2 , INDEX = 3 ; int type ; String varName ; String propName ; Field field ; Object object ; int index ; LHS ( NameSpace nameSpace , String varName ) { type = VARIABLE ; this . varName = varName ; this . nameSpace = nameSpace ; } LHS ( Field field ) { type = FIELD ; this . object = null ; this . field = field ; } LHS ( Object object , Field field ) { if ( object == null ) throw new NullPointerException ( "constructed empty LHS" ) ; type = FIELD ; this . object = object ; this . field = field ; } LHS ( Object object , String propName ) { if ( object == null ) throw new NullPointerException ( "constructed empty LHS" ) ; type = PROPERTY ; this . object = object ; this . propName = propName ; } LHS ( Object array , int index ) { if ( array == null ) throw new NullPointerException ( "constructed empty LHS" ) ; type = INDEX ; this . object = array ; this . index = index ; } public Object getValue ( ) throws EvalError { if ( type == VARIABLE ) return nameSpace . getVariable ( varName ) ; else if ( type == FIELD ) try { return field . get ( object ) ; } catch ( IllegalAccessException e2 ) { throw new EvalError ( "Can't read field: " + field ) ; } else if ( type == PROPERTY ) try { return Reflect . getObjectProperty ( object , propName ) ; } catch ( ReflectError e ) { Interpreter . debug ( e . getMessage ( ) ) ; throw new EvalError ( "No such property: " + propName ) ; } else if ( type == INDEX ) try { return Reflect . getIndex ( object , index ) ; } catch ( Exception e ) { throw new EvalError ( "Array access: " + e ) ; } throw new InterpreterError ( "LHS type" ) ; } public Object assign ( Object val ) throws EvalError { if ( type == VARIABLE ) nameSpace . setVariable ( varName , val ) ; else if ( type == FIELD ) try { if ( val instanceof Primitive ) val = ( ( Primitive ) val ) . getValue ( ) ; field . set ( object , val ) ; return val ; } catch ( NullPointerException e ) { throw new EvalError ( "LHS (" + field . getName ( ) + ") not a static field." ) ; } catch ( IllegalAccessException e2 ) { throw new EvalError ( "LHS (" + field . getName ( ) + ") can't access field." ) ; } catch ( IllegalArgumentException e3 ) { throw new EvalError ( "Argument type mismatch. " + ( val == null ? "null" : val . getClass ( ) . getName ( ) ) + " not assignable to field " + field . getName ( ) ) ; } else if ( type == PROPERTY ) if ( object instanceof Hashtable ) ( ( Hashtable ) object ) . put ( propName , val ) ; else try { Reflect . setObjectProperty ( object , propName , val ) ; } catch ( ReflectError e ) { Interpreter . debug ( "Assignment: " + e . getMessage ( ) ) ; throw new EvalError ( "No such property: " + propName ) ; } else if ( type == INDEX ) try { Reflect . setIndex ( object , index , val ) ; } catch ( TargetError e1 ) { throw e1 ; } catch ( Exception e ) { throw new EvalError ( "Assignment: " + e . getMessage ( ) ) ; } return val ; } public String toString ( ) { return "LHS" ; } } 	0	['8', '1', '0', '15', '32', '0', '8', '9', '3', '0.766233766', '356', '0', '1', '0', '0.375', '0', '0', '42.125', '1', '0.375', '0']
package gnu . regexp ; final class RETokenWordBoundary extends REToken { private boolean negated ; private int where ; static final int BEGIN = 1 ; static final int END = 2 ; RETokenWordBoundary ( int subIndex , int where , boolean negated ) { super ( subIndex ) ; this . where = where ; this . negated = negated ; } boolean match ( CharIndexed input , REMatch mymatch ) { boolean after = false ; boolean before = false ; char ch ; if ( ( ( mymatch . eflags & RE . REG_ANCHORINDEX ) != RE . REG_ANCHORINDEX ) || ( mymatch . offset + mymatch . index > mymatch . anchor ) ) { if ( ( ch = input . charAt ( mymatch . index - 1 ) ) != CharIndexed . OUT_OF_BOUNDS ) { before = Character . isLetterOrDigit ( ch ) || ( ch == '_' ) ; } } if ( ( ch = input . charAt ( mymatch . index ) ) != CharIndexed . OUT_OF_BOUNDS ) { after = Character . isLetterOrDigit ( ch ) || ( ch == '_' ) ; } boolean doNext = false ; if ( ( where & BEGIN ) == BEGIN ) { doNext = after && ! before ; } if ( ( where & END ) == END ) { doNext ^= before && ! after ; } if ( negated ) doNext = ! doNext ; return ( doNext ? next ( input , mymatch ) : false ) ; } void dump ( StringBuffer os ) { if ( where == ( BEGIN | END ) ) { os . append ( negated ? "\\B" : "\\b" ) ; } else if ( where == BEGIN ) { os . append ( "\\<" ) ; } else { os . append ( "\\>" ) ; } } } 	0	['3', '2', '0', '4', '8', '0', '1', '3', '0', '0.75', '151', '0.5', '0', '0.777777778', '0.444444444', '1', '2', '48', '18', '7.3333', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class AddAbbrevDialog extends JDialog { public AddAbbrevDialog ( View view , String abbrev ) { super ( view , jEdit . getProperty ( "add-abbrev.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; editor = new AbbrevEditor ( ) ; editor . setAbbrev ( abbrev ) ; editor . setBorder ( new EmptyBorder ( 6 , 0 , 12 , 0 ) ) ; content . add ( BorderLayout . CENTER , editor ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; global = new JButton ( jEdit . getProperty ( "add-abbrev.global" ) ) ; global . addActionListener ( new ActionHandler ( ) ) ; box . add ( global ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; modeSpecific = new JButton ( jEdit . getProperty ( "add-abbrev.mode" ) ) ; modeSpecific . addActionListener ( new ActionHandler ( ) ) ; box . add ( modeSpecific ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; box . add ( cancel ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; KeyListener listener = new KeyHandler ( ) ; addKeyListener ( listener ) ; editor . getBeforeCaretTextArea ( ) . addKeyListener ( listener ) ; editor . getAfterCaretTextArea ( ) . addKeyListener ( listener ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; if ( abbrev == null ) GUIUtilities . requestFocus ( this , editor . getAbbrevField ( ) ) ; else GUIUtilities . requestFocus ( this , editor . getBeforeCaretTextArea ( ) ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } private View view ; private AbbrevEditor editor ; private JButton global ; private JButton modeSpecific ; private JButton cancel ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == global ) { String _abbrev = editor . getAbbrev ( ) ; if ( _abbrev == null || _abbrev . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } Abbrevs . addGlobalAbbrev ( _abbrev , editor . getExpansion ( ) ) ; Abbrevs . expandAbbrev ( view , false ) ; } else if ( source == modeSpecific ) { String _abbrev = editor . getAbbrev ( ) ; if ( _abbrev == null || _abbrev . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } Abbrevs . addModeAbbrev ( view . getBuffer ( ) . getMode ( ) . getName ( ) , _abbrev , editor . getExpansion ( ) ) ; Abbrevs . expandAbbrev ( view , false ) ; } dispose ( ) ; } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) dispose ( ) ; } } } 	0	['5', '6', '0', '7', '34', '2', '3', '6', '1', '0.8', '202', '1', '2', '0.99389313', '0.35', '0', '0', '38.4', '1', '0.8', '0']
package bsh ; class BSHFormalParameter extends SimpleNode { public static final Class UNTYPED = null ; public String name ; public Class type ; BSHFormalParameter ( int id ) { super ( id ) ; } public Object eval ( NameSpace namespace ) throws EvalError { if ( jjtGetNumChildren ( ) > 0 ) type = ( ( BSHType ) jjtGetChild ( 0 ) ) . getType ( namespace ) ; else type = UNTYPED ; return Primitive . VOID ; } } 	0	['3', '2', '0', '9', '7', '1', '3', '6', '1', '1', '30', '0', '0', '0.947368421', '0.666666667', '1', '2', '8', '1', '0.3333', '0']
package bsh ; class BSHWhileStatement extends SimpleNode implements ParserConstants { public boolean isDoStatement ; BSHWhileStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int numChild = jjtGetNumChildren ( ) ; SimpleNode condExp , body = null ; if ( isDoStatement ) { condExp = ( SimpleNode ) jjtGetChild ( 1 ) ; body = ( SimpleNode ) jjtGetChild ( 0 ) ; } else { condExp = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( numChild > 1 ) body = ( SimpleNode ) jjtGetChild ( 1 ) ; } boolean doOnceFlag = isDoStatement ; while ( doOnceFlag || BSHIfStatement . evaluateCondition ( condExp , callstack , interpreter ) ) { if ( body == null ) continue ; Object ret = body . eval ( callstack , interpreter ) ; boolean breakout = false ; if ( ret instanceof ReturnControl ) { switch ( ( ( ReturnControl ) ret ) . kind ) { case RETURN : return ret ; case CONTINUE : continue ; case BREAK : breakout = true ; break ; } } if ( breakout ) break ; doOnceFlag = false ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '10', '7', '1', '1', '9', '1', '1', '79', '0', '0', '0.947368421', '0.625', '1', '1', '38', '1', '0.5', '0']
package org . gjt . sp . jedit . proto . jeditresource ; import java . io . IOException ; import java . net . * ; public class Handler extends URLStreamHandler { public URLConnection openConnection ( URL url ) throws IOException { PluginResURLConnection c = new PluginResURLConnection ( url ) ; c . connect ( ) ; return c ; } } 	0	['2', '2', '0', '1', '5', '1', '0', '1', '2', '2', '14', '0', '0', '0.923076923', '0.75', '0', '0', '6', '1', '0.5', '0']
package gnu . regexp ; public interface CharIndexed { char OUT_OF_BOUNDS = 'ï¿¿' ; char charAt ( int index ) ; boolean move ( int index ) ; boolean isValid ( ) ; } 	0	['3', '1', '0', '29', '3', '3', '29', '0', '3', '1.5', '4', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '0']
package gnu . regexp ; import java . util . Vector ; final class RETokenRepeated extends REToken { private REToken token ; private int min , max ; private boolean stingy ; RETokenRepeated ( int subIndex , REToken token , int min , int max ) { super ( subIndex ) ; this . token = token ; this . min = min ; this . max = max ; } void makeStingy ( ) { stingy = true ; } boolean isStingy ( ) { return stingy ; } int getMinimumLength ( ) { return ( min * token . getMinimumLength ( ) ) ; } boolean match ( CharIndexed input , REMatch mymatch ) { int numRepeats = 0 ; REMatch newMatch = mymatch ; REMatch last = null ; REMatch current ; Vector positions = new Vector ( ) ; positions . addElement ( newMatch ) ; REMatch doables ; REMatch doablesLast ; REMatch recurrent ; do { if ( stingy && ( numRepeats >= min ) ) { REMatch result = matchRest ( input , newMatch ) ; if ( result != null ) { mymatch . assignFrom ( result ) ; return true ; } } doables = null ; doablesLast = null ; for ( current = newMatch ; current != null ; current = current . next ) { recurrent = ( REMatch ) current . clone ( ) ; if ( token . match ( input , recurrent ) ) { if ( doables == null ) { doables = recurrent ; doablesLast = recurrent ; } else { doablesLast . next = recurrent ; } while ( doablesLast . next != null ) { doablesLast = doablesLast . next ; } } } if ( doables == null ) break ; newMatch = doables ; ++ numRepeats ; positions . addElement ( newMatch ) ; } while ( numRepeats < max ) ; if ( numRepeats < min ) return false ; int posIndex = positions . size ( ) ; REMatch allResults = null ; REMatch allResultsLast = null ; REMatch results = null ; while ( -- posIndex >= min ) { newMatch = ( REMatch ) positions . elementAt ( posIndex ) ; results = matchRest ( input , newMatch ) ; if ( results != null ) { if ( allResults == null ) { allResults = results ; allResultsLast = results ; } else { allResultsLast . next = results ; } while ( allResultsLast . next != null ) { allResultsLast = allResultsLast . next ; } } } if ( allResults != null ) { mymatch . assignFrom ( allResults ) ; return true ; } return false ; } private REMatch matchRest ( CharIndexed input , final REMatch newMatch ) { REMatch current , single ; REMatch doneIndex = null ; REMatch doneIndexLast = null ; for ( current = newMatch ; current != null ; current = current . next ) { single = ( REMatch ) current . clone ( ) ; if ( next ( input , single ) ) { if ( doneIndex == null ) { doneIndex = single ; doneIndexLast = single ; } else { doneIndexLast . next = single ; } while ( doneIndexLast . next != null ) { doneIndexLast = doneIndexLast . next ; } } } return doneIndex ; } void dump ( StringBuffer os ) { os . append ( "(?:" ) ; token . dumpAll ( os ) ; os . append ( ')' ) ; if ( ( max == Integer . MAX_VALUE ) && ( min <= 1 ) ) os . append ( ( min == 0 ) ? '*' : '+' ) ; else if ( ( min == 0 ) && ( max == 1 ) ) os . append ( '?' ) ; else { os . append ( '{' ) . append ( min ) ; if ( max > min ) { os . append ( ',' ) ; if ( max != Integer . MAX_VALUE ) os . append ( max ) ; } os . append ( '}' ) ; } if ( stingy ) os . append ( '?' ) ; } } 	0	['7', '2', '0', '4', '21', '0', '1', '3', '0', '0.541666667', '300', '1', '1', '0.538461538', '0.333333333', '1', '3', '41.28571429', '16', '4.7143', '0']
package gnu . regexp ; import java . io . Serializable ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class REMatchEnumeration implements Enumeration , Serializable { private static final int YES = 1 ; private static final int MAYBE = 0 ; private static final int NO = - 1 ; private int more ; private REMatch match ; private RE expr ; private CharIndexed input ; private int eflags ; private int index ; REMatchEnumeration ( RE expr , CharIndexed input , int index , int eflags ) { more = MAYBE ; this . expr = expr ; this . input = input ; this . index = index ; this . eflags = eflags ; } public boolean hasMoreElements ( ) { return hasMoreMatches ( null ) ; } public boolean hasMoreMatches ( ) { return hasMoreMatches ( null ) ; } public boolean hasMoreMatches ( StringBuffer buffer ) { if ( more == MAYBE ) { match = expr . getMatchImpl ( input , index , eflags , buffer ) ; if ( match != null ) { input . move ( ( match . end [ 0 ] > 0 ) ? match . end [ 0 ] : 1 ) ; index = ( match . end [ 0 ] > 0 ) ? match . end [ 0 ] + match . offset : index + 1 ; more = YES ; } else more = NO ; } return ( more == YES ) ; } public Object nextElement ( ) throws NoSuchElementException { return nextMatch ( ) ; } public REMatch nextMatch ( ) throws NoSuchElementException { if ( hasMoreElements ( ) ) { more = ( input . isValid ( ) ) ? MAYBE : NO ; return match ; } throw new NoSuchElementException ( ) ; } } 	0	['6', '1', '0', '3', '11', '9', '1', '3', '5', '0.488888889', '135', '1', '3', '0', '0.333333333', '0', '0', '20', '6', '1.6667', '0']
package bsh ; import java . lang . reflect . Array ; class BSHType extends SimpleNode implements BshClassManager . Listener { private Class baseType ; private int arrayDims ; private Class type ; BSHType ( int id ) { super ( id ) ; BshClassManager . addCMListener ( this ) ; } public void addArrayDimension ( ) { arrayDims ++ ; } public Class getType ( NameSpace namespace ) throws EvalError { if ( type != null ) return type ; SimpleNode node = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( node instanceof BSHPrimitiveType ) baseType = ( ( BSHPrimitiveType ) node ) . getType ( ) ; else baseType = ( ( BSHAmbiguousName ) node ) . toClass ( namespace ) ; if ( arrayDims > 0 ) { try { int [ ] dims = new int [ arrayDims ] ; Object obj = Array . newInstance ( baseType , dims ) ; type = obj . getClass ( ) ; } catch ( Exception e ) { throw new EvalError ( "Couldn't construct array type" , this ) ; } } else type = baseType ; return type ; } public Class getBaseType ( ) { return baseType ; } public int getArrayDims ( ) { return arrayDims ; } public void classLoaderChanged ( ) { type = null ; baseType = null ; } } 	0	['6', '2', '0', '16', '14', '3', '8', '8', '5', '0.666666667', '92', '1', '0', '0.782608696', '0.444444444', '0', '0', '13.83333333', '1', '0.8333', '0']
package gnu . regexp ; import java . util . Vector ; final class RETokenOneOf extends REToken { private Vector options ; private boolean negative ; RETokenOneOf ( int subIndex , String optionsStr , boolean negative , boolean insens ) { super ( subIndex ) ; options = new Vector ( ) ; this . negative = negative ; for ( int i = 0 ; i < optionsStr . length ( ) ; i ++ ) options . addElement ( new RETokenChar ( subIndex , optionsStr . charAt ( i ) , insens ) ) ; } RETokenOneOf ( int subIndex , Vector options , boolean negative ) { super ( subIndex ) ; this . options = options ; this . negative = negative ; } int getMinimumLength ( ) { int min = Integer . MAX_VALUE ; int x ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { if ( ( x = ( ( REToken ) options . elementAt ( i ) ) . getMinimumLength ( ) ) < min ) min = x ; } return min ; } boolean match ( CharIndexed input , REMatch mymatch ) { if ( negative && ( input . charAt ( mymatch . index ) == CharIndexed . OUT_OF_BOUNDS ) ) return false ; REMatch newMatch = null ; REMatch last = null ; REToken tk ; boolean isMatch ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { tk = ( REToken ) options . elementAt ( i ) ; REMatch tryMatch = ( REMatch ) mymatch . clone ( ) ; if ( tk . match ( input , tryMatch ) ) { if ( negative ) return false ; if ( next ( input , tryMatch ) ) { if ( last == null ) { newMatch = tryMatch ; last = tryMatch ; } else { last . next = tryMatch ; last = tryMatch ; } } } } if ( newMatch != null ) { if ( negative ) { return false ; } else { mymatch . assignFrom ( newMatch ) ; return true ; } } else { if ( negative ) { ++ mymatch . index ; return next ( input , mymatch ) ; } else { return false ; } } } void dump ( StringBuffer os ) { os . append ( negative ? "[^" : "(?:" ) ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { if ( ! negative && ( i > 0 ) ) os . append ( '|' ) ; ( ( REToken ) options . elementAt ( i ) ) . dumpAll ( os ) ; } os . append ( negative ? ']' : ')' ) ; } } 	0	['5', '2', '0', '5', '22', '0', '1', '4', '0', '0.125', '206', '1', '0', '0.7', '0.35', '1', '3', '39.8', '11', '4', '0']
package bsh ; import java . lang . reflect . Array ; class BSHArrayDimensions extends SimpleNode { public Class baseType ; private int arrayDims ; public int [ ] dimensions ; BSHArrayDimensions ( int id ) { super ( id ) ; } public void addArrayDimension ( ) { arrayDims ++ ; } public Object eval ( Class type , CallStack callstack , Interpreter interpreter ) throws EvalError { if ( Interpreter . DEBUG ) Interpreter . debug ( "array base type = " + type ) ; baseType = type ; return eval ( callstack , interpreter ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode child = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( child instanceof BSHArrayInitializer ) { if ( baseType == null ) throw new EvalError ( "Internal Array Eval err:  unknown base type" , this ) ; Object initValue = ( ( BSHArrayInitializer ) child ) . eval ( baseType , arrayDims , callstack , interpreter ) ; Class arrayClass = initValue . getClass ( ) ; dimensions = new int [ Reflect . getArrayDimensions ( arrayClass ) ] ; if ( dimensions . length != arrayDims ) throw new EvalError ( "Incompatible initializer. Allocation calls for a " + arrayDims + " dimensional array, but initializer is a " + dimensions . length + " dimensional array" , this ) ; Object arraySlice = initValue ; for ( int i = 0 ; i < dimensions . length ; i ++ ) { dimensions [ i ] = Array . getLength ( arraySlice ) ; if ( dimensions [ i ] > 0 ) arraySlice = Array . get ( arraySlice , 0 ) ; } return initValue ; } else { dimensions = new int [ jjtGetNumChildren ( ) ] ; for ( int i = 0 ; i < dimensions . length ; i ++ ) { try { Object length = ( ( SimpleNode ) jjtGetChild ( i ) ) . eval ( callstack , interpreter ) ; dimensions [ i ] = ( ( Primitive ) length ) . intValue ( ) ; } catch ( Exception e ) { throw new EvalError ( "Array index: " + i + " does not evaluate to an integer" , this ) ; } } } return Primitive . VOID ; } } 	0	['4', '2', '0', '10', '21', '2', '2', '8', '3', '0.555555556', '176', '0.333333333', '0', '0.857142857', '0.5', '1', '1', '42.25', '1', '0.75', '0']
package gnu . regexp ; import java . io . Serializable ; class CharIndexedString implements CharIndexed , Serializable { private String s ; private int anchor ; private int len ; CharIndexedString ( String str , int index ) { s = str ; len = s . length ( ) ; anchor = index ; } public char charAt ( int index ) { int pos = anchor + index ; return ( ( pos < len ) && ( pos >= 0 ) ) ? s . charAt ( pos ) : OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( anchor < len ) ; } public boolean move ( int index ) { return ( ( anchor += index ) < len ) ; } } 	0	['4', '1', '0', '2', '7', '0', '1', '1', '3', '0.222222222', '62', '1', '0', '0', '0.666666667', '0', '0', '13.75', '3', '1.75', '0']
package org . gjt . sp . jedit ; import java . util . * ; import javax . swing . text . Segment ; import org . gjt . sp . jedit . syntax . * ; public class TextUtilities { public static Token getTokenAtOffset ( Token tokens , int offset ) { if ( offset == 0 && tokens . id == Token . END ) return tokens ; for ( ; ; ) { if ( tokens . id == Token . END ) throw new ArrayIndexOutOfBoundsException ( "offset > line length" ) ; if ( tokens . offset + tokens . length > offset ) return tokens ; else tokens = tokens . next ; } } public static int findMatchingBracket ( Buffer buffer , int line , int offset ) { if ( offset < 0 || offset >= buffer . getLineLength ( line ) ) { throw new ArrayIndexOutOfBoundsException ( offset + ":" + buffer . getLineLength ( line ) ) ; } Segment lineText = new Segment ( ) ; buffer . getLineText ( line , lineText ) ; char c = lineText . array [ lineText . offset + offset ] ; char cprime ; boolean direction ; switch ( c ) { case '(' : cprime = ')' ; direction = true ; break ; case ')' : cprime = '(' ; direction = false ; break ; case '[' : cprime = ']' ; direction = true ; break ; case ']' : cprime = '[' ; direction = false ; break ; case '{' : cprime = '}' ; direction = true ; break ; case '}' : cprime = '{' ; direction = false ; break ; default : return - 1 ; } int count = 1 ; DefaultTokenHandler tokenHandler = new DefaultTokenHandler ( ) ; buffer . markTokens ( line , tokenHandler ) ; byte idOfBracket = getTokenAtOffset ( tokenHandler . getTokens ( ) , offset ) . id ; boolean haveTokens = true ; if ( direction ) { offset ++ ; for ( ; ; ) { for ( int i = offset ; i < lineText . count ; i ++ ) { char ch = lineText . array [ lineText . offset + i ] ; if ( ch == c ) { if ( ! haveTokens ) { tokenHandler . init ( ) ; buffer . markTokens ( line , tokenHandler ) ; haveTokens = true ; } if ( getTokenAtOffset ( tokenHandler . getTokens ( ) , i ) . id == idOfBracket ) count ++ ; } else if ( ch == cprime ) { if ( ! haveTokens ) { tokenHandler . init ( ) ; buffer . markTokens ( line , tokenHandler ) ; haveTokens = true ; } if ( getTokenAtOffset ( tokenHandler . getTokens ( ) , i ) . id == idOfBracket ) { count -- ; if ( count == 0 ) return buffer . getLineStartOffset ( line ) + i ; } } } line ++ ; if ( line >= buffer . getLineCount ( ) ) break ; buffer . getLineText ( line , lineText ) ; offset = 0 ; haveTokens = false ; } } else { offset -- ; for ( ; ; ) { for ( int i = offset ; i >= 0 ; i -- ) { char ch = lineText . array [ lineText . offset + i ] ; if ( ch == c ) { if ( ! haveTokens ) { tokenHandler . init ( ) ; buffer . markTokens ( line , tokenHandler ) ; haveTokens = true ; } if ( getTokenAtOffset ( tokenHandler . getTokens ( ) , i ) . id == idOfBracket ) count ++ ; } else if ( ch == cprime ) { if ( ! haveTokens ) { tokenHandler . init ( ) ; buffer . markTokens ( line , tokenHandler ) ; haveTokens = true ; } if ( getTokenAtOffset ( tokenHandler . getTokens ( ) , i ) . id == idOfBracket ) { count -- ; if ( count == 0 ) return buffer . getLineStartOffset ( line ) + i ; } } } line -- ; if ( line < 0 ) break ; buffer . getLineText ( line , lineText ) ; offset = lineText . count - 1 ; haveTokens = false ; } } return - 1 ; } public static int findMatchingBracketFuzzy ( Buffer buffer , int line , int offset ) { int result = findMatchingBracket ( buffer , line , offset ) ; if ( ( result == - 1 ) && ( offset + 1 < buffer . getLineLength ( line ) ) ) { return findMatchingBracket ( buffer , line , offset + 1 ) ; } else { return result ; } } public static int findWordStart ( String line , int pos , String noWordSep ) { return findWordStart ( line , pos , noWordSep , true ) ; } public static int findWordStart ( String line , int pos , String noWordSep , boolean joinNonWordChars ) { char ch = line . charAt ( pos ) ; if ( noWordSep == null ) noWordSep = "" ; int type ; if ( Character . isWhitespace ( ch ) ) type = WHITESPACE ; else if ( Character . isLetterOrDigit ( ch ) || noWordSep . indexOf ( ch ) != - 1 ) type = WORD_CHAR ; else type = SYMBOL ; int whiteSpaceEnd = 0 ; loop : for ( int i = pos ; i >= 0 ; i -- ) { ch = line . charAt ( i ) ; switch ( type ) { case WHITESPACE : if ( Character . isWhitespace ( ch ) ) break ; else return i + 1 ; case WORD_CHAR : if ( Character . isLetterOrDigit ( ch ) || noWordSep . indexOf ( ch ) != - 1 ) { break ; } else return i + 1 ; case SYMBOL : if ( ! joinNonWordChars && pos != i ) return i + 1 ; if ( Character . isWhitespace ( ch ) ) { return i + 1 ; } else if ( Character . isLetterOrDigit ( ch ) || noWordSep . indexOf ( ch ) != - 1 ) { return i + 1 ; } else { break ; } } } return whiteSpaceEnd ; } public static int findWordEnd ( String line , int pos , String noWordSep ) { return findWordEnd ( line , pos , noWordSep , true ) ; } public static int findWordEnd ( String line , int pos , String noWordSep , boolean joinNonWordChars ) { if ( pos != 0 ) pos -- ; char ch = line . charAt ( pos ) ; if ( noWordSep == null ) noWordSep = "" ; int type ; if ( Character . isWhitespace ( ch ) ) type = WHITESPACE ; else if ( Character . isLetterOrDigit ( ch ) || noWordSep . indexOf ( ch ) != - 1 ) type = WORD_CHAR ; else type = SYMBOL ; loop : for ( int i = pos ; i < line . length ( ) ; i ++ ) { ch = line . charAt ( i ) ; switch ( type ) { case WHITESPACE : if ( Character . isWhitespace ( ch ) ) break ; else return i ; case WORD_CHAR : if ( Character . isLetterOrDigit ( ch ) || noWordSep . indexOf ( ch ) != - 1 ) { break ; } else return i ; case SYMBOL : if ( ! joinNonWordChars && i != pos ) return i ; if ( Character . isWhitespace ( ch ) ) { return i ; } else if ( Character . isLetterOrDigit ( ch ) || noWordSep . indexOf ( ch ) != - 1 ) return i ; else { break ; } } } return line . length ( ) ; } public static boolean regionMatches ( boolean ignoreCase , Segment text , int offset , char [ ] match ) { int length = offset + match . length ; if ( length > text . offset + text . count ) return false ; char [ ] textArray = text . array ; for ( int i = offset , j = 0 ; i < length ; i ++ , j ++ ) { char c1 = textArray [ i ] ; char c2 = match [ j ] ; if ( ignoreCase ) { c1 = Character . toUpperCase ( c1 ) ; c2 = Character . toUpperCase ( c2 ) ; } if ( c1 != c2 ) return false ; } return true ; } public static String spacesToTabs ( String in , int tabSize ) { StringBuffer buf = new StringBuffer ( ) ; int width = 0 ; int whitespace = 0 ; for ( int i = 0 ; i < in . length ( ) ; i ++ ) { switch ( in . charAt ( i ) ) { case ' ' : whitespace ++ ; width ++ ; break ; case '\t' : int tab = tabSize - ( width % tabSize ) ; width += tab ; whitespace += tab ; break ; case '\n' : if ( whitespace != 0 ) { buf . append ( MiscUtilities . createWhiteSpace ( whitespace , tabSize ) ) ; } whitespace = 0 ; width = 0 ; buf . append ( '\n' ) ; break ; default : if ( whitespace != 0 ) { buf . append ( MiscUtilities . createWhiteSpace ( whitespace , tabSize ) ) ; whitespace = 0 ; } buf . append ( in . charAt ( i ) ) ; width ++ ; break ; } } if ( whitespace != 0 ) { buf . append ( MiscUtilities . createWhiteSpace ( whitespace , tabSize ) ) ; } return buf . toString ( ) ; } public static String tabsToSpaces ( String in , int tabSize ) { StringBuffer buf = new StringBuffer ( ) ; int width = 0 ; for ( int i = 0 ; i < in . length ( ) ; i ++ ) { switch ( in . charAt ( i ) ) { case '\t' : int count = tabSize - ( width % tabSize ) ; width += count ; while ( -- count >= 0 ) buf . append ( ' ' ) ; break ; case '\n' : width = 0 ; buf . append ( in . charAt ( i ) ) ; break ; default : width ++ ; buf . append ( in . charAt ( i ) ) ; break ; } } return buf . toString ( ) ; } public static String format ( String text , int maxLineLength , int tabSize ) { StringBuffer buf = new StringBuffer ( ) ; int index = 0 ; for ( ; ; ) { int newIndex = text . indexOf ( "\n\n" , index ) ; if ( newIndex == - 1 ) break ; formatParagraph ( text . substring ( index , newIndex ) , maxLineLength , tabSize , buf ) ; buf . append ( "\n\n" ) ; index = newIndex + 2 ; } if ( index != text . length ( ) ) { formatParagraph ( text . substring ( index ) , maxLineLength , tabSize , buf ) ; } return buf . toString ( ) ; } public static final int MIXED = 0 ; public static final int LOWER_CASE = 1 ; public static final int UPPER_CASE = 2 ; public static final int TITLE_CASE = 3 ; public static int getStringCase ( String str ) { if ( str . length ( ) == 0 ) return MIXED ; int state = - 1 ; char ch = str . charAt ( 0 ) ; if ( Character . isLetter ( ch ) ) { if ( Character . isUpperCase ( ch ) ) state = UPPER_CASE ; else state = LOWER_CASE ; } for ( int i = 1 ; i < str . length ( ) ; i ++ ) { ch = str . charAt ( i ) ; if ( ! Character . isLetter ( ch ) ) continue ; switch ( state ) { case UPPER_CASE : if ( Character . isLowerCase ( ch ) ) { if ( i == 1 ) state = TITLE_CASE ; else return MIXED ; } break ; case LOWER_CASE : case TITLE_CASE : if ( Character . isUpperCase ( ch ) ) return MIXED ; break ; } } return state ; } public static String toTitleCase ( String str ) { if ( str . length ( ) == 0 ) return str ; else { return Character . toUpperCase ( str . charAt ( 0 ) ) + str . substring ( 1 ) . toLowerCase ( ) ; } } private static final int WHITESPACE = 0 ; private static final int WORD_CHAR = 1 ; private static final int SYMBOL = 2 ; private static void formatParagraph ( String text , int maxLineLength , int tabSize , StringBuffer buf ) { int leadingWhitespaceCount = MiscUtilities . getLeadingWhiteSpace ( text ) ; String leadingWhitespace = text . substring ( 0 , leadingWhitespaceCount ) ; int leadingWhitespaceWidth = MiscUtilities . getLeadingWhiteSpaceWidth ( text , tabSize ) ; buf . append ( leadingWhitespace ) ; int lineLength = leadingWhitespaceWidth ; StringTokenizer st = new StringTokenizer ( text ) ; while ( st . hasMoreTokens ( ) ) { String word = st . nextToken ( ) ; if ( lineLength == leadingWhitespaceWidth ) { } else if ( lineLength + word . length ( ) + 1 > maxLineLength ) { buf . append ( '\n' ) ; buf . append ( leadingWhitespace ) ; lineLength = leadingWhitespaceWidth ; } else { buf . append ( ' ' ) ; lineLength ++ ; } buf . append ( word ) ; lineLength += word . length ( ) ; } } } 	0	['15', '1', '0', '12', '50', '105', '8', '5', '14', '1.071428571', '913', '0.428571429', '0', '0', '0.237037037', '0', '0', '59.4', '29', '7.2667', '0']
package org . gjt . sp . jedit ; import java . util . Vector ; import java . util . zip . ZipFile ; import org . gjt . sp . jedit . gui . OptionsDialog ; import org . gjt . sp . util . Log ; public abstract class EditPlugin { public void start ( ) { } public void stop ( ) { } public void createMenuItems ( Vector menuItems ) { } public void createOptionPanes ( OptionsDialog optionsDialog ) { } public String getClassName ( ) { return getClass ( ) . getName ( ) ; } public EditPlugin . JAR getJAR ( ) { return jar ; } public static class Broken extends EditPlugin { public String getClassName ( ) { return clazz ; } Broken ( String clazz ) { this . clazz = clazz ; } private String clazz ; } public static class JAR { public String getPath ( ) { return path ; } public ZipFile getZipFile ( ) { return classLoader . getZipFile ( ) ; } public JARClassLoader getClassLoader ( ) { return classLoader ; } public ActionSet getActions ( ) { return actions ; } public void addPlugin ( EditPlugin plugin ) { plugin . jar = JAR . this ; long start = System . currentTimeMillis ( ) ; try { plugin . start ( ) ; } finally { Log . log ( Log . DEBUG , this , "-- startup took " + ( System . currentTimeMillis ( ) - start ) + " milliseconds" ) ; } if ( plugin instanceof EBPlugin ) EditBus . addToBus ( ( EBPlugin ) plugin ) ; plugins . addElement ( plugin ) ; } public EditPlugin [ ] getPlugins ( ) { EditPlugin [ ] array = new EditPlugin [ plugins . size ( ) ] ; plugins . copyInto ( array ) ; return array ; } public JAR ( String path , JARClassLoader classLoader ) { this . path = path ; this . classLoader = classLoader ; plugins = new Vector ( ) ; actions = new ActionSet ( ) ; } void getPlugins ( Vector vector ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { vector . addElement ( plugins . elementAt ( i ) ) ; } } private String path ; private JARClassLoader classLoader ; private Vector plugins ; private ActionSet actions ; } private EditPlugin . JAR jar ; } 	0	['8', '1', '2', '11', '11', '26', '10', '2', '7', '0.857142857', '28', '1', '1', '0', '0.275', '0', '0', '2.375', '1', '0.875', '0']
package bsh ; import java . util . Hashtable ; import java . lang . reflect . InvocationTargetException ; class BSHLHSPrimarySuffix extends SimpleNode { public static final int INDEX = 1 , NAME = 2 , PROPERTY = 3 ; public int operation ; Object index ; public String field ; public String method ; BSHLHSPrimarySuffix ( int id ) { super ( id ) ; } public LHS doLHSSuffix ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError { try { switch ( operation ) { case INDEX : return doIndex ( obj , callstack , interpreter ) ; case NAME : return doName ( obj , callstack , interpreter ) ; case PROPERTY : return doProperty ( obj , callstack , interpreter ) ; default : throw new InterpreterError ( "LHS suffix" ) ; } } catch ( ReflectError e ) { throw new EvalError ( "reflection error: " + e , this ) ; } catch ( InvocationTargetException e ) { throw new TargetError ( "target exception" , e . getTargetException ( ) , this , true ) ; } } private LHS doName ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError , InvocationTargetException { if ( jjtGetNumChildren ( ) == 0 ) return Reflect . getLHSObjectField ( obj , field ) ; else { Object [ ] oa = ( ( BSHArguments ) jjtGetChild ( 0 ) ) . getArguments ( callstack , interpreter ) ; try { obj = Reflect . invokeObjectMethod ( interpreter , obj , method , oa , this ) ; } catch ( EvalError ee ) { throw new EvalError ( ee . getMessage ( ) , this ) ; } return Reflect . getLHSObjectField ( obj , field ) ; } } private LHS doIndex ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError { int index = BSHPrimarySuffix . getIndexAux ( obj , callstack , interpreter , this ) ; return new LHS ( obj , index ) ; } private LHS doProperty ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError { if ( obj == Primitive . VOID ) throw new EvalError ( "Attempt to access property on a void type" , this ) ; else if ( obj instanceof Primitive ) throw new EvalError ( "Attempt to access property on a primitive" , this ) ; Object value = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( ! ( value instanceof String ) ) throw new EvalError ( "Property expression must be a String or identifier." , this ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( "LHS property access: " ) ; return new LHS ( obj , ( String ) value ) ; } } 	0	['5', '2', '0', '15', '25', '10', '2', '13', '1', '1.071428571', '162', '0', '0', '0.818181818', '0.72', '0', '0', '30', '1', '0.8', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; public abstract class EnhancedDialog extends JDialog { public EnhancedDialog ( Frame parent , String title , boolean modal ) { super ( parent , title , modal ) ; _init ( ) ; } public EnhancedDialog ( Dialog parent , String title , boolean modal ) { super ( parent , title , modal ) ; _init ( ) ; } public abstract void ok ( ) ; public abstract void cancel ( ) ; private void _init ( ) { ( ( Container ) getLayeredPane ( ) ) . addContainerListener ( new ContainerHandler ( ) ) ; getContentPane ( ) . addContainerListener ( new ContainerHandler ( ) ) ; keyHandler = new KeyHandler ( ) ; addKeyListener ( keyHandler ) ; addWindowListener ( new WindowHandler ( ) ) ; setDefaultCloseOperation ( DO_NOTHING_ON_CLOSE ) ; } protected KeyHandler keyHandler ; class ContainerHandler extends ContainerAdapter { public void componentAdded ( ContainerEvent evt ) { componentAdded ( evt . getChild ( ) ) ; } public void componentRemoved ( ContainerEvent evt ) { componentRemoved ( evt . getChild ( ) ) ; } private void componentAdded ( Component comp ) { comp . addKeyListener ( keyHandler ) ; if ( comp instanceof Container ) { Container cont = ( Container ) comp ; cont . addContainerListener ( this ) ; Component [ ] comps = cont . getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { componentAdded ( comps [ i ] ) ; } } } private void componentRemoved ( Component comp ) { comp . removeKeyListener ( keyHandler ) ; if ( comp instanceof Container ) { Container cont = ( Container ) comp ; cont . removeContainerListener ( this ) ; Component [ ] comps = cont . getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { componentRemoved ( comps [ i ] ) ; } } } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { if ( evt . isConsumed ( ) ) return ; if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { Component comp = getFocusOwner ( ) ; while ( comp != null ) { if ( comp instanceof JComboBox ) { JComboBox combo = ( JComboBox ) comp ; if ( combo . isEditable ( ) ) { Object selected = combo . getEditor ( ) . getItem ( ) ; if ( selected != null ) combo . setSelectedItem ( selected ) ; } break ; } comp = comp . getParent ( ) ; } ok ( ) ; evt . consume ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { cancel ( ) ; evt . consume ( ) ; } } } class WindowHandler extends WindowAdapter { public void windowClosing ( WindowEvent evt ) { cancel ( ) ; } } } 	0	['5', '6', '19', '22', '16', '10', '22', '3', '4', '0.5', '56', '1', '1', '0.995412844', '0.44', '0', '0', '10', '1', '0.6', '0']
package bsh ; class BSHSwitchLabel extends SimpleNode { boolean isDefault ; public BSHSwitchLabel ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { if ( isDefault ) return null ; SimpleNode label = ( ( SimpleNode ) jjtGetChild ( 0 ) ) ; return label . eval ( callstack , interpreter ) ; } } 	0	['2', '2', '0', '7', '5', '1', '2', '5', '2', '1', '22', '0', '0', '0.947368421', '0.625', '1', '1', '9.5', '1', '0.5', '0']
package com . microstar . xml ; public class XmlException extends Exception { private String message ; private String systemId ; private int line ; private int column ; public XmlException ( String message , String systemId , int line , int column ) { this . message = message ; this . systemId = systemId ; this . line = line ; this . column = column ; } public String getMessage ( ) { return message ; } public String getSystemId ( ) { return systemId ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return column ; } } 	0	['5', '3', '0', '6', '6', '2', '6', '0', '5', '0.75', '36', '1', '0', '0.80952381', '0.466666667', '1', '1', '5.4', '1', '0.8', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class PropertiesChanged extends EBMessage { public PropertiesChanged ( EBComponent source ) { super ( source ) ; } } 	0	['1', '2', '0', '8', '2', '0', '6', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . gjt . sp . jedit ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . * ; public class AbstractOptionPane extends JPanel implements OptionPane { public AbstractOptionPane ( String name ) { this . name = name ; setLayout ( gridBag = new GridBagLayout ( ) ) ; } public String getName ( ) { return name ; } public Component getComponent ( ) { return this ; } public void init ( ) { if ( ! initialized ) { initialized = true ; _init ( ) ; } } public void save ( ) { if ( initialized ) _save ( ) ; } public void addComponent ( String label , Component comp ) { JLabel l = new JLabel ( label ) ; l . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; addComponent ( l , comp , GridBagConstraints . BOTH ) ; } public void addComponent ( String label , Component comp , int fill ) { JLabel l = new JLabel ( label ) ; l . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; addComponent ( l , comp , fill ) ; } public void addComponent ( Component comp1 , Component comp2 ) { addComponent ( comp1 , comp2 , GridBagConstraints . BOTH ) ; } public void addComponent ( Component comp1 , Component comp2 , int fill ) { GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = 1 ; cons . weightx = 0.0f ; cons . insets = new Insets ( 1 , 0 , 1 , 0 ) ; cons . fill = GridBagConstraints . BOTH ; gridBag . setConstraints ( comp1 , cons ) ; add ( comp1 ) ; cons . fill = fill ; cons . gridx = 1 ; cons . weightx = 1.0f ; gridBag . setConstraints ( comp2 , cons ) ; add ( comp2 ) ; } public void addComponent ( Component comp ) { GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = cons . REMAINDER ; cons . fill = GridBagConstraints . NONE ; cons . anchor = GridBagConstraints . WEST ; cons . weightx = 1.0f ; cons . insets = new Insets ( 1 , 0 , 1 , 0 ) ; gridBag . setConstraints ( comp , cons ) ; add ( comp ) ; } public void addSeparator ( ) { if ( y != 0 ) addComponent ( Box . createVerticalStrut ( 6 ) ) ; JSeparator sep = new JSeparator ( JSeparator . HORIZONTAL ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = cons . REMAINDER ; cons . fill = GridBagConstraints . BOTH ; cons . anchor = GridBagConstraints . WEST ; cons . weightx = 1.0f ; cons . insets = new Insets ( 1 , 0 , 1 , 0 ) ; gridBag . setConstraints ( sep , cons ) ; add ( sep ) ; } public void addSeparator ( String label ) { if ( y != 0 ) addComponent ( Box . createVerticalStrut ( 6 ) ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; Box box2 = new Box ( BoxLayout . Y_AXIS ) ; box2 . add ( Box . createGlue ( ) ) ; box2 . add ( new JSeparator ( JSeparator . HORIZONTAL ) ) ; box2 . add ( Box . createGlue ( ) ) ; box . add ( box2 ) ; JLabel l = new JLabel ( jEdit . getProperty ( label ) ) ; l . setMaximumSize ( l . getPreferredSize ( ) ) ; box . add ( l ) ; Box box3 = new Box ( BoxLayout . Y_AXIS ) ; box3 . add ( Box . createGlue ( ) ) ; box3 . add ( new JSeparator ( JSeparator . HORIZONTAL ) ) ; box3 . add ( Box . createGlue ( ) ) ; box . add ( box3 ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = cons . REMAINDER ; cons . fill = GridBagConstraints . BOTH ; cons . anchor = GridBagConstraints . WEST ; cons . weightx = 1.0f ; cons . insets = new Insets ( 1 , 0 , 1 , 0 ) ; gridBag . setConstraints ( box , cons ) ; add ( box ) ; } protected boolean initialized ; protected GridBagLayout gridBag ; protected int y ; protected void _init ( ) { } protected void _save ( ) { } private String name ; } 	0	['14', '5', '17', '20', '32', '67', '18', '2', '12', '0.711538462', '395', '1', '0', '0.98048048', '0.446428571', '0', '0', '26.92857143', '2', '1.2143', '0']
package gnu . regexp ; import java . io . Serializable ; abstract class REToken implements Serializable { protected REToken next = null ; protected REToken uncle = null ; protected int subIndex ; protected REToken ( int subIndex ) { this . subIndex = subIndex ; } int getMinimumLength ( ) { return 0 ; } void setUncle ( REToken anUncle ) { uncle = anUncle ; } abstract boolean match ( CharIndexed input , REMatch mymatch ) ; protected boolean next ( CharIndexed input , REMatch mymatch ) { if ( next == null ) { if ( uncle == null ) { return true ; } else { return uncle . match ( input , mymatch ) ; } } else { return next . match ( input , mymatch ) ; } } boolean chain ( REToken token ) { next = token ; return true ; } abstract void dump ( StringBuffer os ) ; void dumpAll ( StringBuffer os ) { dump ( os ) ; if ( next != null ) next . dumpAll ( os ) ; } } 	0	['8', '1', '13', '15', '9', '12', '13', '2', '0', '0.761904762', '65', '1', '2', '0', '0.354166667', '0', '0', '6.75', '3', '1.25', '0']
package gnu . regexp ; public final class UncheckedRE extends RE { public UncheckedRE ( Object pattern ) { this ( pattern , 0 , RESyntax . RE_SYNTAX_PERL5 ) ; } public UncheckedRE ( Object pattern , int cflags ) { this ( pattern , cflags , RESyntax . RE_SYNTAX_PERL5 ) ; } public UncheckedRE ( Object pattern , int cflags , RESyntax syntax ) { try { initialize ( pattern , cflags , syntax , 0 , 0 ) ; } catch ( REException e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } } 	0	['3', '3', '0', '3', '7', '3', '0', '3', '3', '2', '33', '0', '0', '1', '0.75', '0', '0', '10', '0', '0', '0']
package org . gjt . sp . jedit . syntax ; public class DefaultTokenHandler implements TokenHandler { public void init ( ) { lastToken = firstToken = null ; } public Token getTokens ( ) { return firstToken ; } public void handleToken ( byte id , int offset , int length , TokenMarker . LineContext context ) { Token token = createToken ( id , offset , length , context ) ; if ( token != null ) addToken ( token , context ) ; } protected Token firstToken , lastToken ; protected ParserRuleSet getParserRuleSet ( TokenMarker . LineContext context ) { while ( context != null ) { if ( context . rules . getMode ( ) != null ) return context . rules ; context = context . parent ; } return null ; } protected Token createToken ( byte id , int offset , int length , TokenMarker . LineContext context ) { return new Token ( id , offset , length , getParserRuleSet ( context ) ) ; } protected void addToken ( Token token , TokenMarker . LineContext context ) { if ( firstToken == null ) { firstToken = lastToken = token ; } else { lastToken . next = token ; lastToken = lastToken . next ; } } } 	0	['7', '1', '2', '9', '10', '15', '4', '5', '4', '0.583333333', '81', '1', '2', '0', '0.457142857', '0', '0', '10.28571429', '3', '1.4286', '0']
package org . gjt . sp . jedit . textarea ; import java . awt . Graphics2D ; public abstract class TextAreaExtension { public void paintValidLine ( Graphics2D gfx , int screenLine , int physicalLine , int start , int end , int y ) { } public void paintInvalidLine ( Graphics2D gfx , int screenLine , int y ) { } public String getToolTipText ( int x , int y ) { return null ; } } 	0	['4', '1', '5', '9', '5', '6', '9', '0', '4', '2', '11', '0', '0', '0', '0.75', '0', '0', '1.75', '1', '0.75', '0']
package bsh ; public interface ParserTreeConstants { public int JJTVOID = 0 ; public int JJTMETHODDECLARATION = 1 ; public int JJTIMPORTDECLARATION = 2 ; public int JJTVARIABLEDECLARATOR = 3 ; public int JJTARRAYINITIALIZER = 4 ; public int JJTFORMALPARAMETERS = 5 ; public int JJTFORMALPARAMETER = 6 ; public int JJTTYPE = 7 ; public int JJTRETURNTYPE = 8 ; public int JJTPRIMITIVETYPE = 9 ; public int JJTAMBIGUOUSNAME = 10 ; public int JJTASSIGNMENT = 11 ; public int JJTTERNARYEXPRESSION = 12 ; public int JJTBINARYEXPRESSION = 13 ; public int JJTUNARYEXPRESSION = 14 ; public int JJTCASTEXPRESSION = 15 ; public int JJTPRIMARYEXPRESSION = 16 ; public int JJTMETHODINVOCATION = 17 ; public int JJTPRIMARYSUFFIX = 18 ; public int JJTLHSPRIMARYEXPRESSION = 19 ; public int JJTLHSPRIMARYSUFFIX = 20 ; public int JJTLITERAL = 21 ; public int JJTARGUMENTS = 22 ; public int JJTALLOCATIONEXPRESSION = 23 ; public int JJTARRAYDIMENSIONS = 24 ; public int JJTBLOCK = 25 ; public int JJTFORMALCOMMENT = 26 ; public int JJTSWITCHSTATEMENT = 27 ; public int JJTSWITCHLABEL = 28 ; public int JJTIFSTATEMENT = 29 ; public int JJTWHILESTATEMENT = 30 ; public int JJTFORSTATEMENT = 31 ; public int JJTTYPEDVARIABLEDECLARATION = 32 ; public int JJTSTATEMENTEXPRESSIONLIST = 33 ; public int JJTRETURNSTATEMENT = 34 ; public int JJTTHROWSTATEMENT = 35 ; public int JJTTRYSTATEMENT = 36 ; public String [ ] jjtNodeName = { "void" , "MethodDeclaration" , "ImportDeclaration" , "VariableDeclarator" , "ArrayInitializer" , "FormalParameters" , "FormalParameter" , "Type" , "ReturnType" , "PrimitiveType" , "AmbiguousName" , "Assignment" , "TernaryExpression" , "BinaryExpression" , "UnaryExpression" , "CastExpression" , "PrimaryExpression" , "MethodInvocation" , "PrimarySuffix" , "LHSPrimaryExpression" , "LHSPrimarySuffix" , "Literal" , "Arguments" , "AllocationExpression" , "ArrayDimensions" , "Block" , "FormalComment" , "SwitchStatement" , "SwitchLabel" , "IfStatement" , "WhileStatement" , "ForStatement" , "TypedVariableDeclaration" , "StatementExpressionList" , "ReturnStatement" , "ThrowStatement" , "TryStatement" , } ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '191', '0', '0', '0', '0', '0', '0', '152', '0', '0', '0']
package org . gjt . sp . jedit . help ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . text . html . * ; import java . awt . * ; import java . awt . event . * ; import java . beans . * ; import java . io . * ; import java . net . * ; import org . gjt . sp . jedit . gui . RolloverButton ; import org . gjt . sp . jedit . msg . PropertiesChanged ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class HelpViewer extends JFrame { public HelpViewer ( ) { this ( "welcome.html" ) ; } public HelpViewer ( URL url ) { this ( url . toString ( ) ) ; } public HelpViewer ( String url ) { super ( jEdit . getProperty ( "helpviewer.title" ) ) ; setIconImage ( GUIUtilities . getEditorIcon ( ) ) ; try { baseURL = new File ( MiscUtilities . constructPath ( jEdit . getJEditHome ( ) , "doc" ) ) . toURL ( ) . toString ( ) ; } catch ( MalformedURLException mu ) { Log . log ( Log . ERROR , this , mu ) ; } history = new String [ 25 ] ; ActionHandler actionListener = new ActionHandler ( ) ; JTabbedPane tabs = new JTabbedPane ( ) ; tabs . addTab ( jEdit . getProperty ( "helpviewer.toc.label" ) , toc = new HelpTOCPanel ( this ) ) ; tabs . addTab ( jEdit . getProperty ( "helpviewer.search.label" ) , new HelpSearchPanel ( this ) ) ; tabs . setMinimumSize ( new Dimension ( 0 , 0 ) ) ; JPanel rightPanel = new JPanel ( new BorderLayout ( ) ) ; JToolBar toolBar = new JToolBar ( ) ; toolBar . setFloatable ( false ) ; toolBar . add ( title = new JLabel ( ) ) ; toolBar . add ( Box . createGlue ( ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 0 , 12 , 0 , 0 ) ) ; back = new RolloverButton ( GUIUtilities . loadIcon ( jEdit . getProperty ( "helpviewer.back.icon" ) ) ) ; back . setToolTipText ( jEdit . getProperty ( "helpviewer.back.label" ) ) ; back . addActionListener ( actionListener ) ; toolBar . add ( back ) ; forward = new RolloverButton ( GUIUtilities . loadIcon ( jEdit . getProperty ( "helpviewer.forward.icon" ) ) ) ; forward . addActionListener ( actionListener ) ; forward . setToolTipText ( jEdit . getProperty ( "helpviewer.forward.label" ) ) ; toolBar . add ( forward ) ; back . setPreferredSize ( forward . getPreferredSize ( ) ) ; rightPanel . add ( BorderLayout . NORTH , toolBar ) ; viewer = new JEditorPane ( ) ; viewer . setEditable ( false ) ; viewer . addHyperlinkListener ( new LinkHandler ( ) ) ; viewer . setFont ( new Font ( "Monospaced" , Font . PLAIN , 12 ) ) ; viewer . addPropertyChangeListener ( new PropertyChangeHandler ( ) ) ; rightPanel . add ( BorderLayout . CENTER , new JScrollPane ( viewer ) ) ; splitter = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , tabs , rightPanel ) ; splitter . setBorder ( null ) ; getContentPane ( ) . add ( BorderLayout . CENTER , splitter ) ; gotoURL ( url , true ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; getRootPane ( ) . setPreferredSize ( new Dimension ( 800 , 400 ) ) ; pack ( ) ; GUIUtilities . loadGeometry ( this , "helpviewer" ) ; show ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { splitter . setDividerLocation ( jEdit . getIntegerProperty ( "helpviewer.splitter" , 250 ) ) ; viewer . requestFocus ( ) ; } } ) ; } public void gotoURL ( String url , boolean addToHistory ) { String shortURL ; if ( MiscUtilities . isURL ( url ) ) { if ( url . startsWith ( baseURL ) ) { shortURL = url . substring ( baseURL . length ( ) ) ; if ( shortURL . startsWith ( "/" ) ) shortURL = shortURL . substring ( 1 ) ; } else { shortURL = url ; } } else { shortURL = url ; if ( baseURL . endsWith ( "/" ) ) url = baseURL + url ; else url = baseURL + '/' + url ; } viewer . setCursor ( Cursor . getDefaultCursor ( ) ) ; URL _url = null ; try { _url = new URL ( url ) ; if ( ! _url . equals ( viewer . getPage ( ) ) ) title . setText ( jEdit . getProperty ( "helpviewer.loading" ) ) ; else { } viewer . setPage ( _url ) ; if ( addToHistory ) { history [ historyPos ] = url ; if ( historyPos + 1 == history . length ) { System . arraycopy ( history , 1 , history , 0 , history . length - 1 ) ; history [ historyPos ] = null ; } else historyPos ++ ; } } catch ( MalformedURLException mf ) { Log . log ( Log . ERROR , this , mf ) ; String [ ] args = { url , mf . getMessage ( ) } ; GUIUtilities . error ( this , "badurl" , args ) ; return ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] args = { url , io . toString ( ) } ; GUIUtilities . error ( this , "read-error" , args ) ; return ; } if ( shortURL != null ) toc . selectNode ( shortURL ) ; } public void dispose ( ) { jEdit . setIntegerProperty ( "helpviewer.splitter" , splitter . getDividerLocation ( ) ) ; GUIUtilities . saveGeometry ( this , "helpviewer" ) ; super . dispose ( ) ; } public String getBaseURL ( ) { return baseURL ; } private String baseURL ; private JButton back ; private JButton forward ; private JEditorPane viewer ; private JLabel title ; private JSplitPane splitter ; private String [ ] history ; private int historyPos ; private HelpTOCPanel toc ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == back ) { if ( historyPos <= 1 ) getToolkit ( ) . beep ( ) ; else { String url = history [ -- historyPos - 1 ] ; gotoURL ( url , false ) ; } } else if ( source == forward ) { if ( history . length - historyPos <= 1 ) getToolkit ( ) . beep ( ) ; else { String url = history [ historyPos ] ; if ( url == null ) getToolkit ( ) . beep ( ) ; else { historyPos ++ ; gotoURL ( url , false ) ; } } } } } class LinkHandler implements HyperlinkListener { public void hyperlinkUpdate ( HyperlinkEvent evt ) { if ( evt . getEventType ( ) == HyperlinkEvent . EventType . ACTIVATED ) { if ( evt instanceof HTMLFrameHyperlinkEvent ) { ( ( HTMLDocument ) viewer . getDocument ( ) ) . processHTMLFrameHyperlinkEvent ( ( HTMLFrameHyperlinkEvent ) evt ) ; } else { URL url = evt . getURL ( ) ; if ( url != null ) gotoURL ( url . toString ( ) , true ) ; } } else if ( evt . getEventType ( ) == HyperlinkEvent . EventType . ENTERED ) { viewer . setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND_CURSOR ) ) ; } else if ( evt . getEventType ( ) == HyperlinkEvent . EventType . EXITED ) { viewer . setCursor ( Cursor . getDefaultCursor ( ) ) ; } } } class PropertyChangeHandler implements PropertyChangeListener { public void propertyChange ( PropertyChangeEvent evt ) { if ( "page" . equals ( evt . getPropertyName ( ) ) ) { String titleStr = ( String ) viewer . getDocument ( ) . getProperty ( "title" ) ; if ( titleStr == null ) { titleStr = MiscUtilities . getFileName ( viewer . getPage ( ) . toString ( ) ) ; } title . setText ( titleStr ) ; } } } } 	0	['15', '6', '0', '13', '97', '65', '9', '11', '6', '0.738095238', '512', '1', '1', '0.98173516', '0.253333333', '1', '1', '32.53333333', '8', '1.2667', '0']
package bsh ; class BSHIfStatement extends SimpleNode { BSHIfStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object ret = null ; if ( evaluateCondition ( ( SimpleNode ) jjtGetChild ( 0 ) , callstack , interpreter ) ) ret = ( ( SimpleNode ) jjtGetChild ( 1 ) ) . eval ( callstack , interpreter ) ; else if ( jjtGetNumChildren ( ) > 2 ) ret = ( ( SimpleNode ) jjtGetChild ( 2 ) ) . eval ( callstack , interpreter ) ; if ( ret instanceof ReturnControl ) return ret ; else return Primitive . VOID ; } public static boolean evaluateCondition ( SimpleNode condExp , CallStack callstack , Interpreter interpreter ) throws EvalError { Object obj = condExp . eval ( callstack , interpreter ) ; if ( obj instanceof Primitive ) { if ( obj == Primitive . VOID ) throw new EvalError ( "Condition evaluates to void type" , condExp ) ; obj = ( ( Primitive ) obj ) . getValue ( ) ; } if ( obj instanceof Boolean ) return ( ( Boolean ) obj ) . booleanValue ( ) ; else throw new EvalError ( "Condition must evaluate to a Boolean or boolean." , condExp ) ; } } 	0	['3', '2', '0', '11', '10', '3', '4', '7', '2', '2', '79', '0', '0', '0.9', '0.533333333', '1', '1', '25.33333333', '1', '0.6667', '0']
package org . gjt . sp . jedit . options ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . gui . RolloverButton ; import org . gjt . sp . jedit . * ; public class BrowserColorsOptionPane extends AbstractOptionPane { public BrowserColorsOptionPane ( ) { super ( "browser.colors" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; colorsModel = new BrowserColorsModel ( ) ; colorsTable = new JTable ( colorsModel ) ; colorsTable . setAutoResizeMode ( JTable . AUTO_RESIZE_ALL_COLUMNS ) ; colorsTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; colorsTable . addMouseListener ( new MouseHandler ( ) ) ; colorsTable . getSelectionModel ( ) . addListSelectionListener ( new SelectionHandler ( ) ) ; TableColumnModel tcm = colorsTable . getColumnModel ( ) ; tcm . getColumn ( 1 ) . setCellRenderer ( new BrowserColorsModel . ColorRenderer ( ) ) ; Dimension d = colorsTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 200 ) ; JScrollPane scroller = new JScrollPane ( colorsTable ) ; scroller . setPreferredSize ( d ) ; add ( BorderLayout . CENTER , scroller ) ; JPanel buttons = new JPanel ( ) ; buttons . setBorder ( new EmptyBorder ( 3 , 0 , 0 , 0 ) ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; ActionHandler actionHandler = new ActionHandler ( ) ; add = new RolloverButton ( GUIUtilities . loadIcon ( "Plus.png" ) ) ; add . setToolTipText ( jEdit . getProperty ( "options.browser.colors.add" ) ) ; add . addActionListener ( actionHandler ) ; buttons . add ( add ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; remove = new RolloverButton ( GUIUtilities . loadIcon ( "Minus.png" ) ) ; remove . setToolTipText ( jEdit . getProperty ( "options.browser.colors.remove" ) ) ; remove . addActionListener ( actionHandler ) ; buttons . add ( remove ) ; buttons . add ( Box . createGlue ( ) ) ; add ( BorderLayout . SOUTH , buttons ) ; updateEnabled ( ) ; } protected void _save ( ) { colorsModel . save ( ) ; } private BrowserColorsModel colorsModel ; private JTable colorsTable ; private JButton add ; private JButton remove ; private void updateEnabled ( ) { int selectedRow = colorsTable . getSelectedRow ( ) ; remove . setEnabled ( selectedRow != - 1 ) ; } class SelectionHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { updateEnabled ( ) ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == add ) { colorsModel . add ( ) ; } else if ( source == remove ) { int selectedRow = colorsTable . getSelectedRow ( ) ; colorsModel . remove ( selectedRow ) ; updateEnabled ( ) ; } } } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { Point p = evt . getPoint ( ) ; int row = colorsTable . rowAtPoint ( p ) ; int column = colorsTable . columnAtPoint ( p ) ; if ( row == - 1 || column != 1 ) return ; Color color = JColorChooser . showDialog ( BrowserColorsOptionPane . this , jEdit . getProperty ( "colorChooser.title" ) , ( Color ) colorsModel . getValueAt ( row , 1 ) ) ; if ( color != null ) colorsModel . setValueAt ( color , row , 1 ) ; } } } class BrowserColorsModel extends AbstractTableModel { Vector entries ; BrowserColorsModel ( ) { entries = new Vector ( ) ; int i = 0 ; String glob ; while ( ( glob = jEdit . getProperty ( "vfs.browser.colors." + i + ".glob" ) ) != null ) { entries . addElement ( new Entry ( glob , jEdit . getColorProperty ( "vfs.browser.colors." + i + ".color" , Color . black ) ) ) ; i ++ ; } } void add ( ) { entries . addElement ( new Entry ( "" , UIManager . getColor ( "Tree.foreground" ) ) ) ; fireTableRowsInserted ( entries . size ( ) - 1 , entries . size ( ) - 1 ) ; } void remove ( int index ) { entries . removeElementAt ( index ) ; fireTableRowsDeleted ( entries . size ( ) , entries . size ( ) ) ; } void save ( ) { int i ; for ( i = 0 ; i < entries . size ( ) ; i ++ ) { Entry entry = ( Entry ) entries . elementAt ( i ) ; jEdit . setProperty ( "vfs.browser.colors." + i + ".glob" , entry . glob ) ; jEdit . setColorProperty ( "vfs.browser.colors." + i + ".color" , entry . color ) ; } jEdit . unsetProperty ( "vfs.browser.colors." + i + ".glob" ) ; jEdit . unsetProperty ( "vfs.browser.colors." + i + ".color" ) ; } public int getColumnCount ( ) { return 2 ; } public int getRowCount ( ) { return entries . size ( ) ; } public Object getValueAt ( int row , int col ) { Entry entry = ( Entry ) entries . elementAt ( row ) ; switch ( col ) { case 0 : return entry . glob ; case 1 : return entry . color ; default : return null ; } } public boolean isCellEditable ( int row , int col ) { return ( col == 0 ) ; } public void setValueAt ( Object value , int row , int col ) { Entry entry = ( Entry ) entries . elementAt ( row ) ; if ( col == 0 ) entry . glob = ( String ) value ; else entry . color = ( Color ) value ; fireTableRowsUpdated ( row , row ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.browser.colors.glob" ) ; case 1 : return jEdit . getProperty ( "options.browser.colors.color" ) ; default : return null ; } } public Class getColumnClass ( int col ) { switch ( col ) { case 0 : return String . class ; case 1 : return Color . class ; default : throw new InternalError ( ) ; } } static class Entry { String glob ; Color color ; Entry ( String glob , Color color ) { this . glob = glob ; this . color = color ; } } static class ColorRenderer extends JLabel implements TableCellRenderer { public ColorRenderer ( ) { setOpaque ( true ) ; setBorder ( SyntaxHiliteOptionPane . noFocusBorder ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean cellHasFocus , int row , int col ) { if ( isSelected ) { setBackground ( table . getSelectionBackground ( ) ) ; setForeground ( table . getSelectionForeground ( ) ) ; } else { setBackground ( table . getBackground ( ) ) ; setForeground ( table . getForeground ( ) ) ; } if ( value != null ) setBackground ( ( Color ) value ) ; setBorder ( ( cellHasFocus ) ? UIManager . getBorder ( "Table.focusCellHighlightBorder" ) : SyntaxHiliteOptionPane . noFocusBorder ) ; return this ; } } } 	0	['9', '6', '0', '10', '48', '18', '4', '9', '1', '0.71875', '210', '1', '1', '0.988183161', '0.5', '4', '12', '21.88888889', '2', '1', '0']
package org . gjt . sp . jedit ; import java . util . * ; import org . gjt . sp . util . Log ; public class EditBus { public static void addToBus ( EBComponent comp ) { synchronized ( components ) { components . add ( comp ) ; copyComponents = null ; } } public static void removeFromBus ( EBComponent comp ) { synchronized ( components ) { components . remove ( comp ) ; copyComponents = null ; } } public static EBComponent [ ] getComponents ( ) { synchronized ( components ) { if ( copyComponents == null ) { copyComponents = ( EBComponent [ ] ) components . toArray ( new EBComponent [ components . size ( ) ] ) ; } return copyComponents ; } } public static void send ( EBMessage message ) { Log . log ( Log . DEBUG , EditBus . class , message . toString ( ) ) ; EBComponent [ ] comps = getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { try { comps [ i ] . handleMessage ( message ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , EditBus . class , "Exception" + " while sending message on EditBus:" ) ; Log . log ( Log . ERROR , EditBus . class , t ) ; } } } private static ArrayList components = new ArrayList ( ) ; private static EBComponent [ ] copyComponents ; private EditBus ( ) { } } 	0	['7', '1', '0', '21', '19', '9', '18', '3', '4', '0.611111111', '141', '0.666666667', '1', '0', '0.208333333', '0', '0', '18.71428571', '5', '1.4286', '0']
package org . gjt . sp . jedit . gui ; import java . awt . * ; public class VariableGridLayout implements LayoutManager2 , java . io . Serializable { public static final int FIXED_NUM_ROWS = 1 ; public static final int FIXED_NUM_COLUMNS = 2 ; public VariableGridLayout ( int mode , int size , int hgap , int vgap ) { if ( mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS ) { throw new IllegalArgumentException ( "illegal mode; value is " + mode ) ; } if ( size <= 0 ) { throw new IllegalArgumentException ( "size cannot be zero or less; value is " + size ) ; } if ( hgap < 0 ) { throw new IllegalArgumentException ( "hgap cannot be negative; value is " + hgap ) ; } if ( vgap < 0 ) { throw new IllegalArgumentException ( "vgap cannot be negative; value is " + vgap ) ; } this . mode = mode ; this . size = size ; this . hgap = hgap ; this . vgap = vgap ; } public VariableGridLayout ( int mode , int size ) { this ( mode , size , 0 , 0 ) ; } public VariableGridLayout ( ) { this ( FIXED_NUM_ROWS , 1 , 0 , 0 ) ; } public void addLayoutComponent ( String name , Component component ) { } public void addLayoutComponent ( Component component , Object constraints ) { } public void removeLayoutComponent ( Component component ) { } public float getLayoutAlignmentX ( Container container ) { return 0.5f ; } public float getLayoutAlignmentY ( Container container ) { return 0.5f ; } public Dimension preferredLayoutSize ( Container parent ) { return getLayoutSize ( parent , 2 ) ; } public Dimension minimumLayoutSize ( Container parent ) { return getLayoutSize ( parent , 0 ) ; } public Dimension maximumLayoutSize ( Container parent ) { return getLayoutSize ( parent , 1 ) ; } public void layoutContainer ( Container parent ) { synchronized ( parent . getTreeLock ( ) ) { int ncomponents = parent . getComponentCount ( ) ; if ( ncomponents == 0 ) { return ; } int total_height = 0 ; for ( int r = 0 , i = 0 ; r < nrows ; r ++ ) { for ( int c = 0 ; c < ncols ; c ++ , i ++ ) { if ( i < ncomponents ) { Dimension d = parent . getComponent ( i ) . getPreferredSize ( ) ; row_heights [ r ] = Math . max ( row_heights [ r ] , d . height ) ; col_widths [ c ] = Math . max ( col_widths [ c ] , d . width ) ; } else { break ; } } total_height += row_heights [ r ] ; } int total_width = 0 ; for ( int c = 0 ; c < ncols ; c ++ ) { total_width += col_widths [ c ] ; } Dimension parent_size = parent . getSize ( ) ; Insets insets = parent . getInsets ( ) ; int free_height = parent_size . height - insets . top - insets . bottom - ( nrows - 1 ) * vgap ; int free_width = parent_size . width - insets . left - insets . right - ( ncols - 1 ) * hgap ; if ( total_height != free_height ) { double dy = ( double ) free_height / ( double ) total_height ; for ( int r = 0 ; r < nrows ; r ++ ) { row_heights [ r ] = ( int ) ( ( double ) row_heights [ r ] * dy ) ; } } if ( total_width != free_width ) { double dx = ( ( double ) free_width ) / ( ( double ) total_width ) ; for ( int c = 0 ; c < ncols ; c ++ ) { col_widths [ c ] = ( int ) ( ( double ) col_widths [ c ] * dx ) ; } } for ( int r = 0 , y = insets . top , i = 0 ; r < nrows ; y += row_heights [ r ] + vgap , r ++ ) { for ( int c = 0 , x = insets . left ; c < ncols ; x += col_widths [ c ] + hgap , c ++ , i ++ ) { if ( i < ncomponents ) { parent . getComponent ( i ) . setBounds ( x , y , col_widths [ c ] , row_heights [ r ] ) ; } } } } } public void invalidateLayout ( Container container ) { int ncomponents = container . getComponentCount ( ) ; int old_nrows = nrows ; int old_ncols = ncols ; if ( this . mode == FIXED_NUM_ROWS ) { nrows = this . size ; ncols = ( ncomponents + nrows - 1 ) / nrows ; } else { ncols = this . size ; nrows = ( ncomponents + ncols - 1 ) / ncols ; } if ( old_nrows != nrows ) { row_heights = new int [ nrows ] ; } if ( old_ncols != ncols ) { col_widths = new int [ ncols ] ; } } public int getRows ( ) { return nrows ; } public int getColumns ( ) { return ncols ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[mode=" + mode + ",size=" + size + ",hgap=" + hgap + ",vgap=" + vgap + "]" ; } private Dimension getLayoutSize ( Container parent , int which ) { synchronized ( parent . getTreeLock ( ) ) { int ncomponents = parent . getComponentCount ( ) ; int h = 0 ; int w = 0 ; for ( int r = 0 , i = 0 ; r < nrows ; r ++ ) { int row_height = 0 ; for ( int c = 0 ; c < ncols ; c ++ , i ++ ) { if ( i < ncomponents ) { switch ( which ) { case 0 : row_height = Math . max ( row_height , parent . getComponent ( i ) . getMinimumSize ( ) . height ) ; break ; case 1 : row_height = Math . max ( row_height , parent . getComponent ( i ) . getMaximumSize ( ) . height ) ; break ; default : row_height = Math . max ( row_height , parent . getComponent ( i ) . getPreferredSize ( ) . height ) ; break ; } } else { break ; } } h += row_height ; } for ( int c = 0 ; c < ncols ; c ++ ) { int col_width = 0 ; for ( int r = 0 ; r < nrows ; r ++ ) { int i = r * ncols + c ; if ( i < ncomponents ) { switch ( which ) { case 0 : col_width = Math . max ( col_width , parent . getComponent ( i ) . getMinimumSize ( ) . width ) ; break ; case 1 : col_width = Math . max ( col_width , parent . getComponent ( i ) . getMaximumSize ( ) . width ) ; break ; default : col_width = Math . max ( col_width , parent . getComponent ( i ) . getPreferredSize ( ) . width ) ; break ; } } else { break ; } } w += col_width ; } Insets insets = parent . getInsets ( ) ; return new Dimension ( w + insets . left + insets . right + ( ( ncols - 1 ) * hgap ) , h + insets . top + insets . bottom + ( ( nrows - 1 ) * vgap ) ) ; } } private int mode ; private int size ; private int hgap ; private int vgap ; private transient int nrows = - 1 ; private transient int ncols = - 1 ; private transient int [ ] row_heights = null ; private transient int [ ] col_widths = null ; } 	0	['17', '1', '0', '4', '36', '100', '4', '0', '16', '0.7', '679', '0.8', '0', '0', '0.323529412', '0', '0', '38.35294118', '13', '2.4118', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; public class GutterOptionPane extends AbstractOptionPane { public GutterOptionPane ( ) { super ( "gutter" ) ; } public void _init ( ) { lineNumbersEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.lineNumbers" ) ) ; lineNumbersEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.lineNumbers" ) ) ; addComponent ( lineNumbersEnabled ) ; gutterFont = new FontSelector ( jEdit . getFontProperty ( "view.gutter.font" , new Font ( "Monospaced" , Font . PLAIN , 10 ) ) ) ; addComponent ( jEdit . getProperty ( "options.gutter.font" ) , gutterFont ) ; addComponent ( jEdit . getProperty ( "options.gutter.foreground" ) , gutterForeground = new ColorWellButton ( jEdit . getColorProperty ( "view.gutter.fgColor" ) ) , GridBagConstraints . VERTICAL ) ; addComponent ( jEdit . getProperty ( "options.gutter.background" ) , gutterBackground = new ColorWellButton ( jEdit . getColorProperty ( "view.gutter.bgColor" ) ) , GridBagConstraints . VERTICAL ) ; gutterCurrentLineHighlightEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.currentLineHighlight" ) ) ; gutterCurrentLineHighlightEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.highlightCurrentLine" ) ) ; addComponent ( gutterCurrentLineHighlightEnabled , gutterCurrentLineHighlight = new ColorWellButton ( jEdit . getColorProperty ( "view.gutter.currentLineColor" ) ) , GridBagConstraints . VERTICAL ) ; gutterHighlightInterval = new JTextField ( jEdit . getProperty ( "view.gutter.highlightInterval" ) , 3 ) ; Box gutterHighlightBox = new Box ( BoxLayout . X_AXIS ) ; gutterHighlightBox . add ( new JLabel ( jEdit . getProperty ( "options.gutter.interval-1" ) ) ) ; gutterHighlightBox . add ( Box . createHorizontalStrut ( 3 ) ) ; gutterHighlightBox . add ( gutterHighlightInterval ) ; gutterHighlightBox . add ( Box . createHorizontalStrut ( 3 ) ) ; gutterHighlightBox . add ( new JLabel ( jEdit . getProperty ( "options.gutter.interval-2" ) ) ) ; gutterHighlightBox . add ( Box . createHorizontalStrut ( 12 ) ) ; addComponent ( gutterHighlightBox , gutterHighlightColor = new ColorWellButton ( jEdit . getColorProperty ( "view.gutter.bracketHighlightColor" ) ) , GridBagConstraints . VERTICAL ) ; gutterBracketHighlightEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.bracketHighlight" ) ) ; gutterBracketHighlightEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.bracketHighlight" ) ) ; addComponent ( gutterBracketHighlightEnabled , gutterBracketHighlight = new ColorWellButton ( jEdit . getColorProperty ( "view.gutter.bracketHighlightColor" ) ) , GridBagConstraints . VERTICAL ) ; gutterMarkerHighlightEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.markerHighlight" ) ) ; gutterMarkerHighlightEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.markerHighlight" ) ) ; addComponent ( gutterMarkerHighlightEnabled , gutterMarkerHighlight = new ColorWellButton ( jEdit . getColorProperty ( "view.gutter.markerColor" ) ) , GridBagConstraints . VERTICAL ) ; addComponent ( jEdit . getProperty ( "options.gutter.foldColor" ) , gutterFoldMarkers = new ColorWellButton ( jEdit . getColorProperty ( "view.gutter.foldColor" ) ) , GridBagConstraints . VERTICAL ) ; addComponent ( jEdit . getProperty ( "options.gutter.focusBorderColor" ) , gutterFocusBorder = new ColorWellButton ( jEdit . getColorProperty ( "view.gutter.focusBorderColor" ) ) , GridBagConstraints . VERTICAL ) ; addComponent ( jEdit . getProperty ( "options.gutter.noFocusBorderColor" ) , gutterNoFocusBorder = new ColorWellButton ( jEdit . getColorProperty ( "view.gutter.noFocusBorderColor" ) ) , GridBagConstraints . VERTICAL ) ; addSeparator ( "options.gutter.actions" ) ; int c = clickActionKeys . length ; String [ ] clickActionNames = new String [ c ] ; for ( int i = 0 ; i < c ; i ++ ) { clickActionNames [ i ] = jEdit . getProperty ( "options.gutter." + clickActionKeys [ i ] ) ; } c = clickModifierKeys . length ; String [ ] clickModifierNames = new String [ c ] ; for ( int i = 0 ; i < c ; i ++ ) { clickModifierNames [ i ] = jEdit . getProperty ( "options.gutter." + clickModifierKeys [ i ] ) ; } gutterClickActions = new JComboBox [ c ] ; for ( int i = 0 ; i < c ; i ++ ) { JComboBox cb = new JComboBox ( clickActionNames ) ; gutterClickActions [ i ] = cb ; String val = jEdit . getProperty ( "view.gutter." + clickModifierKeys [ i ] ) ; for ( int j = 0 ; j < clickActionKeys . length ; j ++ ) { if ( val . equals ( clickActionKeys [ j ] ) ) { cb . setSelectedIndex ( j ) ; } } addComponent ( clickModifierNames [ i ] , cb ) ; } } public void _save ( ) { jEdit . setBooleanProperty ( "view.gutter.lineNumbers" , lineNumbersEnabled . isSelected ( ) ) ; jEdit . setFontProperty ( "view.gutter.font" , gutterFont . getFont ( ) ) ; jEdit . setColorProperty ( "view.gutter.fgColor" , gutterForeground . getSelectedColor ( ) ) ; jEdit . setColorProperty ( "view.gutter.bgColor" , gutterBackground . getSelectedColor ( ) ) ; jEdit . setBooleanProperty ( "view.gutter.highlightCurrentLine" , gutterCurrentLineHighlightEnabled . isSelected ( ) ) ; jEdit . setColorProperty ( "view.gutter.currentLineColor" , gutterCurrentLineHighlight . getSelectedColor ( ) ) ; jEdit . setProperty ( "view.gutter.highlightInterval" , gutterHighlightInterval . getText ( ) ) ; jEdit . setColorProperty ( "view.gutter.highlightColor" , gutterHighlightColor . getSelectedColor ( ) ) ; jEdit . setBooleanProperty ( "view.gutter.bracketHighlight" , gutterBracketHighlightEnabled . isSelected ( ) ) ; jEdit . setColorProperty ( "view.gutter.bracketHighlightColor" , gutterBracketHighlight . getSelectedColor ( ) ) ; jEdit . setBooleanProperty ( "view.gutter.markerHighlight" , gutterMarkerHighlightEnabled . isSelected ( ) ) ; jEdit . setColorProperty ( "view.gutter.markerColor" , gutterMarkerHighlight . getSelectedColor ( ) ) ; jEdit . setColorProperty ( "view.gutter.foldColor" , gutterFoldMarkers . getSelectedColor ( ) ) ; jEdit . setColorProperty ( "view.gutter.focusBorderColor" , gutterFocusBorder . getSelectedColor ( ) ) ; jEdit . setColorProperty ( "view.gutter.noFocusBorderColor" , gutterNoFocusBorder . getSelectedColor ( ) ) ; int c = clickModifierKeys . length ; for ( int i = 0 ; i < c ; i ++ ) { int idx = gutterClickActions [ i ] . getSelectedIndex ( ) ; jEdit . setProperty ( "view.gutter." + clickModifierKeys [ i ] , clickActionKeys [ idx ] ) ; } } private FontSelector gutterFont ; private ColorWellButton gutterForeground ; private ColorWellButton gutterBackground ; private JTextField gutterBorderWidth ; private JTextField gutterHighlightInterval ; private ColorWellButton gutterHighlightColor ; private JComboBox gutterNumberAlignment ; private JCheckBox lineNumbersEnabled ; private JCheckBox gutterCurrentLineHighlightEnabled ; private ColorWellButton gutterCurrentLineHighlight ; private JCheckBox gutterBracketHighlightEnabled ; private ColorWellButton gutterBracketHighlight ; private JCheckBox gutterMarkerHighlightEnabled ; private ColorWellButton gutterMarkerHighlight ; private ColorWellButton gutterFoldMarkers ; private ColorWellButton gutterFocusBorder ; private ColorWellButton gutterNoFocusBorder ; private JComboBox [ ] gutterClickActions ; private static final String [ ] clickActionKeys = new String [ ] { "toggleFold" , "toggleFoldFully" } ; private static final String [ ] clickModifierKeys = new String [ ] { "gutterClick" , "gutterShiftClick" } ; } 	0	['4', '6', '0', '5', '39', '0', '1', '4', '3', '0.7', '507', '1', '10', '0.997019374', '1', '3', '5', '120.75', '6', '2', '0']
package gnu . regexp ; final class RETokenPOSIX extends REToken { int type ; boolean insens ; boolean negated ; static final int ALNUM = 0 ; static final int ALPHA = 1 ; static final int BLANK = 2 ; static final int CNTRL = 3 ; static final int DIGIT = 4 ; static final int GRAPH = 5 ; static final int LOWER = 6 ; static final int PRINT = 7 ; static final int PUNCT = 8 ; static final int SPACE = 9 ; static final int UPPER = 10 ; static final int XDIGIT = 11 ; static final String [ ] s_nameTable = { "alnum" , "alpha" , "blank" , "cntrl" , "digit" , "graph" , "lower" , "print" , "punct" , "space" , "upper" , "xdigit" } ; static int intValue ( String key ) { for ( int i = 0 ; i < s_nameTable . length ; i ++ ) { if ( s_nameTable [ i ] . equals ( key ) ) return i ; } return - 1 ; } RETokenPOSIX ( int subIndex , int type , boolean insens , boolean negated ) { super ( subIndex ) ; this . type = type ; this . insens = insens ; this . negated = negated ; } int getMinimumLength ( ) { return 1 ; } boolean match ( CharIndexed input , REMatch mymatch ) { char ch = input . charAt ( mymatch . index ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return false ; boolean retval = false ; switch ( type ) { case ALNUM : retval = Character . isLetterOrDigit ( ch ) || ( ch == '_' ) ; break ; case ALPHA : retval = Character . isLetter ( ch ) ; break ; case BLANK : retval = ( ( ch == ' ' ) || ( ch == '\t' ) ) ; break ; case CNTRL : retval = Character . isISOControl ( ch ) ; break ; case DIGIT : retval = Character . isDigit ( ch ) ; break ; case GRAPH : retval = ( ! ( Character . isWhitespace ( ch ) || Character . isISOControl ( ch ) ) ) ; break ; case LOWER : retval = ( ( insens && Character . isLetter ( ch ) ) || Character . isLowerCase ( ch ) ) ; break ; case PRINT : retval = ( ! ( Character . isWhitespace ( ch ) || Character . isISOControl ( ch ) ) ) || ( ch == ' ' ) ; break ; case PUNCT : retval = ( "`~!@#$%^&*()-_=+[]{}\\|;:'\"/?,.<>" . indexOf ( ch ) != - 1 ) ; break ; case SPACE : retval = Character . isWhitespace ( ch ) ; break ; case UPPER : retval = ( ( insens && Character . isLetter ( ch ) ) || Character . isUpperCase ( ch ) ) ; break ; case XDIGIT : retval = ( Character . isDigit ( ch ) || ( "abcdefABCDEF" . indexOf ( ch ) != - 1 ) ) ; break ; } if ( negated ) retval = ! retval ; if ( retval ) { ++ mymatch . index ; return next ( input , mymatch ) ; } else return false ; } void dump ( StringBuffer os ) { if ( negated ) os . append ( '^' ) ; os . append ( "[:" + s_nameTable [ type ] + ":]" ) ; } } 	0	['6', '2', '0', '4', '22', '3', '1', '3', '0', '1.0625', '283', '0', '0', '0.636363636', '0.285714286', '1', '2', '43.5', '24', '5', '0']
package gnu . regexp ; import java . io . FilterInputStream ; import java . io . InputStream ; public class REFilterInputStream extends FilterInputStream { private RE expr ; private String replace ; private String buffer ; private int bufpos ; private int offset ; private CharIndexedInputStream stream ; public REFilterInputStream ( InputStream stream , RE expr , String replace ) { super ( stream ) ; this . stream = new CharIndexedInputStream ( stream , 0 ) ; this . expr = expr ; this . replace = replace ; } public int read ( ) { if ( ( buffer != null ) && ( bufpos < buffer . length ( ) ) ) { return ( int ) buffer . charAt ( bufpos ++ ) ; } if ( ! stream . isValid ( ) ) return - 1 ; REMatch mymatch = new REMatch ( expr . getNumSubs ( ) , offset , 0 ) ; if ( expr . match ( stream , mymatch ) ) { mymatch . end [ 0 ] = mymatch . index ; mymatch . finish ( stream ) ; stream . move ( mymatch . toString ( ) . length ( ) ) ; offset += mymatch . toString ( ) . length ( ) ; buffer = mymatch . substituteInto ( replace ) ; bufpos = 1 ; if ( buffer . length ( ) > 0 ) { return buffer . charAt ( 0 ) ; } } char ch = stream . charAt ( 0 ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return - 1 ; stream . move ( 1 ) ; offset ++ ; return ch ; } public boolean markSupported ( ) { return false ; } public int read ( byte [ ] b , int off , int len ) { int i ; int ok = 0 ; while ( len -- > 0 ) { i = read ( ) ; if ( i == - 1 ) return ( ok == 0 ) ? - 1 : ok ; b [ off ++ ] = ( byte ) i ; ok ++ ; } return ok ; } public int read ( byte [ ] b ) { return read ( b , 0 , b . length ) ; } } 	0	['5', '3', '0', '4', '18', '8', '0', '4', '5', '0.375', '176', '1', '2', '0.818181818', '0.366666667', '2', '3', '33', '7', '2.6', '0']
package org . gjt . sp . jedit . buffer ; import javax . swing . text . Segment ; import org . gjt . sp . jedit . Buffer ; public class DummyFoldHandler extends FoldHandler { public DummyFoldHandler ( ) { super ( "none" ) ; } public int getFoldLevel ( Buffer buffer , int lineIndex , Segment seg ) { return 0 ; } } 	0	['2', '2', '0', '2', '3', '1', '2', '2', '2', '2', '8', '0', '0', '0.888888889', '0.625', '0', '0', '3', '1', '0.5', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . browser . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . io . VFS ; import org . gjt . sp . jedit . * ; public class RecentDirectoriesMenu extends EnhancedMenu { public RecentDirectoriesMenu ( ) { super ( "recent-directories" ) ; } public void menuSelected ( MenuEvent evt ) { super . menuSelected ( evt ) ; final View view = GUIUtilities . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) removeAll ( ) ; ActionListener actionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { VFSBrowser . browseDirectory ( view , evt . getActionCommand ( ) ) ; view . getStatus ( ) . setMessage ( null ) ; } } ; MouseListener mouseListener = new MouseAdapter ( ) { public void mouseEntered ( MouseEvent evt ) { view . getStatus ( ) . setMessage ( ( ( JMenuItem ) evt . getSource ( ) ) . getActionCommand ( ) ) ; } public void mouseExited ( MouseEvent evt ) { view . getStatus ( ) . setMessage ( null ) ; } } ; HistoryModel model = HistoryModel . getModel ( "vfs.browser.path" ) ; if ( model . getSize ( ) == 0 ) { add ( GUIUtilities . loadMenuItem ( "no-recent-dirs" ) ) ; return ; } boolean sort = jEdit . getBooleanProperty ( "sortRecent" ) ; Vector menuItems = new Vector ( ) ; for ( int i = 0 ; i < model . getSize ( ) ; i ++ ) { String path = model . getItem ( i ) ; VFS vfs = VFSManager . getVFSForPath ( path ) ; JMenuItem menuItem = new JMenuItem ( vfs . getFileName ( path ) ) ; menuItem . setActionCommand ( path ) ; menuItem . addActionListener ( actionListener ) ; menuItem . addMouseListener ( mouseListener ) ; menuItem . setIcon ( FileCellRenderer . dirIcon ) ; if ( sort ) menuItems . addElement ( menuItem ) ; else add ( menuItem ) ; } if ( sort ) { MiscUtilities . quicksort ( menuItems , new MiscUtilities . MenuItemCompare ( ) ) ; for ( int i = 0 ; i < menuItems . size ( ) ; i ++ ) { add ( ( JMenuItem ) menuItems . elementAt ( i ) ) ; } } } public void menuDeselected ( MenuEvent e ) { } public void menuCanceled ( MenuEvent e ) { } } 	0	['4', '8', '0', '13', '30', '6', '3', '13', '4', '2', '119', '0', '0', '0.996515679', '0.875', '0', '0', '28.75', '7', '2.25', '0']
package org . gjt . sp . jedit . buffer ; import javax . swing . text . * ; import org . gjt . sp . jedit . Buffer ; public class RootElement implements Element { public RootElement ( Buffer buffer ) { this . buffer = buffer ; } public Document getDocument ( ) { return null ; } public Element getParentElement ( ) { return null ; } public String getName ( ) { return null ; } public AttributeSet getAttributes ( ) { return null ; } public int getStartOffset ( ) { return 0 ; } public int getEndOffset ( ) { return buffer . getLength ( ) + 1 ; } public int getElementIndex ( int offset ) { return buffer . getLineOfOffset ( offset ) ; } public int getElementCount ( ) { return buffer . getLineCount ( ) ; } public Element getElement ( int line ) { return new LineElement ( buffer , line ) ; } public boolean isLeaf ( ) { return false ; } private Buffer buffer ; } 	0	['11', '1', '0', '2', '16', '35', '1', '2', '11', '0.6', '52', '1', '1', '0', '0.424242424', '0', '0', '3.636363636', '1', '0.9091', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . ColorWellButton ; import org . gjt . sp . jedit . * ; public class StatusBarOptionPane extends AbstractOptionPane { public StatusBarOptionPane ( ) { super ( "status" ) ; } protected void _init ( ) { statusVisible = new JCheckBox ( jEdit . getProperty ( "options.status.visible" ) ) ; statusVisible . setSelected ( jEdit . getBooleanProperty ( "view.status.visible" ) ) ; statusVisible . addActionListener ( new ActionHandler ( ) ) ; addComponent ( statusVisible ) ; showCaretStatus = new JCheckBox ( jEdit . getProperty ( "options.status.show-caret-status" ) ) ; showCaretStatus . setSelected ( jEdit . getBooleanProperty ( "view.status.show-caret-status" ) ) ; addComponent ( showCaretStatus ) ; showEditMode = new JCheckBox ( jEdit . getProperty ( "options.status.show-edit-mode" ) ) ; showEditMode . setSelected ( jEdit . getBooleanProperty ( "view.status.show-edit-mode" ) ) ; addComponent ( showEditMode ) ; showFoldMode = new JCheckBox ( jEdit . getProperty ( "options.status.show-fold-mode" ) ) ; showFoldMode . setSelected ( jEdit . getBooleanProperty ( "view.status.show-fold-mode" ) ) ; addComponent ( showFoldMode ) ; showEncoding = new JCheckBox ( jEdit . getProperty ( "options.status.show-encoding" ) ) ; showEncoding . setSelected ( jEdit . getBooleanProperty ( "view.status.show-encoding" ) ) ; addComponent ( showEncoding ) ; showWrap = new JCheckBox ( jEdit . getProperty ( "options.status.show-wrap" ) ) ; showWrap . setSelected ( jEdit . getBooleanProperty ( "view.status.show-wrap" ) ) ; addComponent ( showWrap ) ; showMultiSelect = new JCheckBox ( jEdit . getProperty ( "options.status.show-multi-select" ) ) ; showMultiSelect . setSelected ( jEdit . getBooleanProperty ( "view.status.show-multi-select" ) ) ; addComponent ( showMultiSelect ) ; showOverwrite = new JCheckBox ( jEdit . getProperty ( "options.status.show-overwrite" ) ) ; showOverwrite . setSelected ( jEdit . getBooleanProperty ( "view.status.show-overwrite" ) ) ; addComponent ( showOverwrite ) ; showLineSeperator = new JCheckBox ( jEdit . getProperty ( "options.status.show-line-seperator" ) ) ; showLineSeperator . setSelected ( jEdit . getBooleanProperty ( "view.status.show-line-seperator" ) ) ; addComponent ( showLineSeperator ) ; showMemory = new JCheckBox ( jEdit . getProperty ( "options.status.show-memory" ) ) ; showMemory . setSelected ( jEdit . getBooleanProperty ( "view.status.show-memory" ) ) ; showMemory . addActionListener ( new ActionHandler ( ) ) ; addComponent ( showMemory ) ; addComponent ( jEdit . getProperty ( "options.status.memory.foreground" ) , memForegroundColor = new ColorWellButton ( jEdit . getColorProperty ( "view.status.memory.foreground" ) ) , GridBagConstraints . VERTICAL ) ; addComponent ( jEdit . getProperty ( "options.status.memory.background" ) , memBackgroundColor = new ColorWellButton ( jEdit . getColorProperty ( "view.status.memory.background" ) ) , GridBagConstraints . VERTICAL ) ; updateEnabled ( ) ; } protected void _save ( ) { jEdit . setBooleanProperty ( "view.status.visible" , statusVisible . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.status.show-caret-status" , showCaretStatus . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.status.show-edit-mode" , showEditMode . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.status.show-fold-mode" , showFoldMode . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.status.show-encoding" , showEncoding . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.status.show-wrap" , showWrap . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.status.show-multi-select" , showMultiSelect . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.status.show-overwrite" , showOverwrite . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.status.show-line-seperator" , showLineSeperator . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.status.show-memory" , showMemory . isSelected ( ) ) ; jEdit . setColorProperty ( "view.status.memory.foreground" , memForegroundColor . getSelectedColor ( ) ) ; jEdit . setColorProperty ( "view.status.memory.background" , memBackgroundColor . getSelectedColor ( ) ) ; } private JCheckBox statusVisible ; private JCheckBox showCaretStatus ; private JCheckBox showEditMode ; private JCheckBox showFoldMode ; private JCheckBox showEncoding ; private JCheckBox showWrap ; private JCheckBox showMultiSelect ; private JCheckBox showOverwrite ; private JCheckBox showLineSeperator ; private JCheckBox showMemory ; private ColorWellButton memForegroundColor ; private ColorWellButton memBackgroundColor ; private void updateEnabled ( ) { boolean enabled = statusVisible . isSelected ( ) ; showCaretStatus . setEnabled ( enabled ) ; showEditMode . setEnabled ( enabled ) ; showFoldMode . setEnabled ( enabled ) ; showEncoding . setEnabled ( enabled ) ; showWrap . setEnabled ( enabled ) ; showMultiSelect . setEnabled ( enabled ) ; showOverwrite . setEnabled ( enabled ) ; showLineSeperator . setEnabled ( enabled ) ; showMemory . setEnabled ( enabled ) ; memForegroundColor . setEnabled ( enabled && showMemory . isSelected ( ) ) ; memBackgroundColor . setEnabled ( enabled && showMemory . isSelected ( ) ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { updateEnabled ( ) ; } } } 	0	['5', '6', '0', '5', '22', '4', '2', '4', '1', '0.25', '353', '1', '2', '0.994056464', '0.5', '1', '3', '67.2', '5', '1.6', '0']
package gnu . regexp ; final class RETokenAny extends REToken { private boolean newline ; private boolean matchNull ; RETokenAny ( int subIndex , boolean newline , boolean matchNull ) { super ( subIndex ) ; this . newline = newline ; this . matchNull = matchNull ; } int getMinimumLength ( ) { return 1 ; } boolean match ( CharIndexed input , REMatch mymatch ) { char ch = input . charAt ( mymatch . index ) ; if ( ( ch == CharIndexed . OUT_OF_BOUNDS ) || ( ! newline && ( ch == '\n' ) ) || ( matchNull && ( ch == 0 ) ) ) { return false ; } ++ mymatch . index ; return next ( input , mymatch ) ; } void dump ( StringBuffer os ) { os . append ( '.' ) ; } } 	0	['4', '2', '0', '4', '8', '4', '1', '3', '0', '0.666666667', '55', '1', '0', '0.7', '0.375', '1', '2', '12.25', '6', '2', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import org . gjt . sp . jedit . gui . FontSelector ; import org . gjt . sp . jedit . * ; public class AppearanceOptionPane extends AbstractOptionPane { public AppearanceOptionPane ( ) { super ( "appearance" ) ; } protected void _init ( ) { addComponent ( new JLabel ( jEdit . getProperty ( "options.appearance.lf.note" ) ) ) ; lfs = UIManager . getInstalledLookAndFeels ( ) ; String [ ] names = new String [ lfs . length ] ; String lf = UIManager . getLookAndFeel ( ) . getClass ( ) . getName ( ) ; int index = 0 ; for ( int i = 0 ; i < names . length ; i ++ ) { names [ i ] = lfs [ i ] . getName ( ) ; if ( lf . equals ( lfs [ i ] . getClassName ( ) ) ) index = i ; } lookAndFeel = new JComboBox ( names ) ; lookAndFeel . setSelectedIndex ( index ) ; lookAndFeel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { updateEnabled ( ) ; } } ) ; addComponent ( jEdit . getProperty ( "options.appearance.lf" ) , lookAndFeel ) ; primaryFont = new FontSelector ( jEdit . getFontProperty ( "metal.primary.font" ) ) ; addComponent ( jEdit . getProperty ( "options.appearance.primaryFont" ) , primaryFont ) ; secondaryFont = new FontSelector ( jEdit . getFontProperty ( "metal.secondary.font" ) ) ; addComponent ( jEdit . getProperty ( "options.appearance.secondaryFont" ) , secondaryFont ) ; updateEnabled ( ) ; addSeparator ( "options.appearance.experimental.label" ) ; addComponent ( GUIUtilities . createMultilineLabel ( jEdit . getProperty ( "options.appearance.experimental.caption" ) ) ) ; textColors = new JCheckBox ( jEdit . getProperty ( "options.appearance.textColors" ) ) ; textColors . setSelected ( jEdit . getBooleanProperty ( "textColors" ) ) ; addComponent ( textColors ) ; decorateFrames = new JCheckBox ( jEdit . getProperty ( "options.appearance.decorateFrames" ) ) ; decorateFrames . setSelected ( jEdit . getBooleanProperty ( "decorate.frames" ) ) ; decorateDialogs = new JCheckBox ( jEdit . getProperty ( "options.appearance.decorateDialogs" ) ) ; decorateDialogs . setSelected ( jEdit . getBooleanProperty ( "decorate.dialogs" ) ) ; if ( OperatingSystem . hasJava14 ( ) ) { addComponent ( decorateFrames ) ; addComponent ( decorateDialogs ) ; } } protected void _save ( ) { String lf = lfs [ lookAndFeel . getSelectedIndex ( ) ] . getClassName ( ) ; jEdit . setProperty ( "lookAndFeel" , lf ) ; jEdit . setFontProperty ( "metal.primary.font" , primaryFont . getFont ( ) ) ; jEdit . setFontProperty ( "metal.secondary.font" , secondaryFont . getFont ( ) ) ; jEdit . setBooleanProperty ( "textColors" , textColors . isSelected ( ) ) ; jEdit . setBooleanProperty ( "decorate.frames" , decorateFrames . isSelected ( ) ) ; jEdit . setBooleanProperty ( "decorate.dialogs" , decorateDialogs . isSelected ( ) ) ; } private UIManager . LookAndFeelInfo [ ] lfs ; private JComboBox lookAndFeel ; private FontSelector primaryFont ; private FontSelector secondaryFont ; private JCheckBox textColors ; private JCheckBox decorateFrames ; private JCheckBox decorateDialogs ; private void updateEnabled ( ) { String className = lfs [ lookAndFeel . getSelectedIndex ( ) ] . getClassName ( ) ; if ( className . equals ( "javax.swing.plaf.metal.MetalLookAndFeel" ) || className . equals ( "com.incors.plaf.kunststoff.KunststoffLookAndFeel" ) ) { primaryFont . setEnabled ( true ) ; secondaryFont . setEnabled ( true ) ; } else { primaryFont . setEnabled ( false ) ; secondaryFont . setEnabled ( false ) ; } } } 	0	['5', '6', '0', '7', '36', '4', '2', '6', '1', '0.464285714', '247', '1', '2', '0.994056464', '0.5', '2', '4', '47', '4', '1.8', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . browser . FileCellRenderer ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . io . VFS ; import org . gjt . sp . jedit . * ; public class RecentFilesMenu extends EnhancedMenu { public RecentFilesMenu ( ) { super ( "recent-files" ) ; } public void menuSelected ( MenuEvent evt ) { super . menuSelected ( evt ) ; final View view = GUIUtilities . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) removeAll ( ) ; ActionListener actionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { jEdit . openFile ( view , evt . getActionCommand ( ) ) ; view . getStatus ( ) . setMessage ( null ) ; } } ; MouseListener mouseListener = new MouseAdapter ( ) { public void mouseEntered ( MouseEvent evt ) { view . getStatus ( ) . setMessage ( ( ( JMenuItem ) evt . getSource ( ) ) . getActionCommand ( ) ) ; } public void mouseExited ( MouseEvent evt ) { view . getStatus ( ) . setMessage ( null ) ; } } ; Vector recentVector = BufferHistory . getBufferHistory ( ) ; if ( recentVector . size ( ) == 0 ) { add ( GUIUtilities . loadMenuItem ( "no-recent-files" ) ) ; return ; } Vector menuItems = new Vector ( ) ; boolean sort = jEdit . getBooleanProperty ( "sortRecent" ) ; int recentFileCount = Math . min ( recentVector . size ( ) , jEdit . getIntegerProperty ( "history" , 25 ) ) ; for ( int i = recentVector . size ( ) - 1 ; i >= recentVector . size ( ) - recentFileCount ; i -- ) { String path = ( ( BufferHistory . Entry ) recentVector . elementAt ( i ) ) . path ; VFS vfs = VFSManager . getVFSForPath ( path ) ; JMenuItem menuItem = new JMenuItem ( vfs . getFileName ( path ) ) ; menuItem . setActionCommand ( path ) ; menuItem . addActionListener ( actionListener ) ; menuItem . addMouseListener ( mouseListener ) ; menuItem . setIcon ( FileCellRenderer . fileIcon ) ; if ( sort ) menuItems . addElement ( menuItem ) ; else add ( menuItem ) ; } if ( sort ) { MiscUtilities . quicksort ( menuItems , new MiscUtilities . MenuItemCompare ( ) ) ; for ( int i = 0 ; i < menuItems . size ( ) ; i ++ ) { add ( ( JMenuItem ) menuItems . elementAt ( i ) ) ; } } } public void menuDeselected ( MenuEvent e ) { } public void menuCanceled ( MenuEvent e ) { } } 	0	['4', '8', '0', '14', '30', '6', '3', '14', '4', '2', '132', '0', '0', '0.996515679', '0.875', '0', '0', '32', '7', '2.25', '0']
package bsh . commands ; import java . io . * ; import bsh . * ; import java . util . Date ; import java . util . Vector ; import java . util . GregorianCalendar ; import java . util . Calendar ; public class dir { static final String [ ] months = { "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" , "Jul" , "Aug" , "Sep" , "Oct" , "Nov" , "Dec" } ; public static String usage ( ) { return "usage: dir( String dir )\n       dir()" ; } public static void invoke ( Interpreter env , NameSpace namespace ) { String dir = "." ; invoke ( env , namespace , dir ) ; } public static void invoke ( Interpreter env , NameSpace namespace , String dir ) { File file ; try { file = env . pathToFile ( dir ) ; } catch ( IOException e ) { env . println ( "error reading path: " + e ) ; return ; } if ( ! file . exists ( ) || ! file . canRead ( ) ) { env . println ( "Can't read " + file ) ; return ; } if ( ! file . isDirectory ( ) ) { env . println ( "'" + dir + "' is not a directory" ) ; } String [ ] files = file . list ( ) ; files = bubbleSort ( files ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( dir + File . separator + files [ i ] ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( f . canRead ( ) ? "r" : "-" ) ; sb . append ( f . canWrite ( ) ? "w" : "-" ) ; sb . append ( "_" ) ; sb . append ( " " ) ; Date d = new Date ( f . lastModified ( ) ) ; GregorianCalendar c = new GregorianCalendar ( ) ; c . setTime ( d ) ; int day = c . get ( Calendar . DAY_OF_MONTH ) ; sb . append ( months [ c . get ( Calendar . MONTH ) ] + " " + day ) ; if ( day < 10 ) sb . append ( " " ) ; sb . append ( " " ) ; int fieldlen = 8 ; StringBuffer len = new StringBuffer ( ) ; for ( int j = 0 ; j < fieldlen ; j ++ ) len . append ( " " ) ; len . insert ( 0 , f . length ( ) ) ; len . setLength ( fieldlen ) ; int si = len . toString ( ) . indexOf ( " " ) ; if ( si != - 1 ) { String pad = len . toString ( ) . substring ( si ) ; len . setLength ( si ) ; len . insert ( 0 , pad ) ; } sb . append ( len . toString ( ) ) ; sb . append ( " " + f . getName ( ) ) ; if ( f . isDirectory ( ) ) sb . append ( "/" ) ; env . println ( sb . toString ( ) ) ; } } public static String [ ] bubbleSort ( String [ ] in ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < in . length ; i ++ ) v . addElement ( in [ i ] ) ; int n = v . size ( ) ; boolean swap = true ; while ( swap ) { swap = false ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) if ( ( ( String ) v . elementAt ( i ) ) . compareTo ( ( ( String ) v . elementAt ( i + 1 ) ) ) > 0 ) { String tmp = ( String ) v . elementAt ( i + 1 ) ; v . removeElementAt ( i + 1 ) ; v . insertElementAt ( tmp , i ) ; swap = true ; } } String [ ] out = new String [ n ] ; v . copyInto ( out ) ; return out ; } } 	0	['6', '1', '0', '2', '40', '13', '0', '2', '5', '0.6', '375', '0', '0', '0', '0.28', '0', '0', '61.33333333', '11', '3', '0']
package gnu . regexp ; import java . text . MessageFormat ; public class REException extends Exception { private int type ; private int pos ; public static final int REG_BADRPT = 1 ; public static final int REG_BADBR = 2 ; public static final int REG_EBRACE = 3 ; public static final int REG_EBRACK = 4 ; public static final int REG_ERANGE = 5 ; public static final int REG_ECTYPE = 6 ; public static final int REG_EPAREN = 7 ; public static final int REG_ESUBREG = 8 ; public static final int REG_EEND = 9 ; public static final int REG_ESCAPE = 10 ; public static final int REG_BADPAT = 11 ; public static final int REG_ESIZE = 12 ; public static final int REG_ESPACE = 13 ; REException ( String msg , int type , int position ) { super ( msg ) ; this . type = type ; this . pos = position ; } public int getType ( ) { return type ; } public int getPosition ( ) { return pos ; } public String getMessage ( ) { Object [ ] args = { new Integer ( pos ) } ; StringBuffer sb = new StringBuffer ( ) ; String prefix = RE . getLocalizedMessage ( "error.prefix" ) ; sb . append ( MessageFormat . format ( prefix , args ) ) ; sb . append ( '\n' ) ; sb . append ( super . getMessage ( ) ) ; return sb . toString ( ) ; } } 	0	['4', '3', '0', '8', '13', '0', '8', '1', '3', '1.222222222', '71', '0.133333333', '0', '0.85', '0.5', '1', '1', '13', '1', '0.75', '0']
package bsh ; class BSHLHSPrimaryExpression extends SimpleNode { BSHLHSPrimaryExpression ( int id ) { super ( id ) ; } public LHS toLHS ( CallStack callstack , Interpreter interpreter ) throws EvalError { int childNum = 0 ; SimpleNode prefixNode = ( SimpleNode ) jjtGetChild ( childNum ++ ) ; Object prefixValue = null ; LHS lhs = null ; if ( prefixNode instanceof BSHAmbiguousName ) { lhs = ( ( BSHAmbiguousName ) prefixNode ) . toLHS ( callstack , interpreter ) ; } else prefixValue = ( ( SimpleNode ) prefixNode ) . eval ( callstack , interpreter ) ; if ( prefixValue != null ) lhs = ( ( BSHLHSPrimarySuffix ) jjtGetChild ( childNum ++ ) ) . doLHSSuffix ( prefixValue , callstack , interpreter ) ; int numChildren = jjtGetNumChildren ( ) ; while ( childNum < numChildren ) lhs = ( ( BSHLHSPrimarySuffix ) jjtGetChild ( childNum ++ ) ) . doLHSSuffix ( lhs . getValue ( ) , callstack , interpreter ) ; return lhs ; } } 	0	['2', '2', '0', '11', '9', '1', '3', '8', '1', '2', '65', '0', '0', '0.947368421', '0.625', '0', '0', '31.5', '1', '0.5', '0']
package bsh ; import java . util . * ; public class StringUtil { public static String [ ] split ( String s , String delim ) { Vector v = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( s , delim ) ; while ( st . hasMoreTokens ( ) ) v . addElement ( st . nextToken ( ) ) ; String [ ] sa = new String [ v . size ( ) ] ; v . copyInto ( sa ) ; return sa ; } public static String [ ] bubbleSort ( String [ ] in ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < in . length ; i ++ ) v . addElement ( in [ i ] ) ; int n = v . size ( ) ; boolean swap = true ; while ( swap ) { swap = false ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) if ( ( ( String ) v . elementAt ( i ) ) . compareTo ( ( ( String ) v . elementAt ( i + 1 ) ) ) > 0 ) { String tmp = ( String ) v . elementAt ( i + 1 ) ; v . removeElementAt ( i + 1 ) ; v . insertElementAt ( tmp , i ) ; swap = true ; } } String [ ] out = new String [ n ] ; v . copyInto ( out ) ; return out ; } public static String maxCommonPrefix ( String one , String two ) { int i = 0 ; while ( one . regionMatches ( 0 , two , 0 , i ) ) i ++ ; return one . substring ( 0 , i - 1 ) ; } public static String methodString ( String name , Class [ ] types ) { StringBuffer sb = new StringBuffer ( name + "(" ) ; if ( types . length > 0 ) sb . append ( " " ) ; for ( int i = 0 ; i < ( types . length - 1 ) ; i ++ ) { Class c = types [ i ] ; sb . append ( ( ( c == null ) ? "null" : c . getName ( ) ) + ", " ) ; } if ( types . length > 0 ) { Class c = types [ types . length - 1 ] ; sb . append ( ( ( c == null ) ? "null" : c . getName ( ) ) ) ; sb . append ( " " ) ; } sb . append ( ")" ) ; return sb . toString ( ) ; } } 	0	['5', '1', '0', '1', '24', '10', '1', '0', '5', '2', '206', '0', '0', '0', '0.3', '0', '0', '40.2', '6', '3', '0']
package bsh ; import java . lang . reflect . Array ; import java . util . Hashtable ; import java . io . * ; import java . lang . reflect . InvocationTargetException ; class Name implements java . io . Serializable { public NameSpace namespace ; String value = null ; private String evalName ; private Object evalBaseObject ; private int callstackDepth ; private boolean literalThisReference ; private boolean literalCallerReference ; private void reset ( ) { evalName = value ; evalBaseObject = null ; callstackDepth = 0 ; literalThisReference = false ; literalCallerReference = false ; } public Name ( NameSpace namespace , String s ) { this . namespace = namespace ; value = s ; } public Object toObject ( CallStack callstack , Interpreter interpreter ) throws EvalError { return toObject ( callstack , interpreter , false ) ; } synchronized public Object toObject ( CallStack callstack , Interpreter interpreter , boolean forceClass ) throws EvalError { reset ( ) ; Object obj = null ; while ( evalName != null ) obj = consumeNextObjectField ( callstack , interpreter , forceClass ) ; if ( obj == null ) throw new InterpreterError ( "null value in toObject()" ) ; return obj ; } private Object consumeNextObjectField ( CallStack callstack , Interpreter interpreter , boolean forceClass ) throws EvalError { if ( ( evalBaseObject == null && ! isCompound ( evalName ) ) && ! forceClass ) { Object obj = resolveThisFieldReference ( callstack , namespace , interpreter , evalName , false ) ; if ( obj != Primitive . VOID ) { evalName = null ; return evalBaseObject = obj ; } } if ( ( evalBaseObject == null || evalBaseObject instanceof This ) && ! forceClass ) { String varName = prefix ( evalName , 1 ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( "trying to resolve variable: " + varName ) ; Object obj ; if ( evalBaseObject == null ) { obj = resolveThisFieldReference ( callstack , namespace , interpreter , varName , false ) ; } else { obj = resolveThisFieldReference ( callstack , ( ( This ) evalBaseObject ) . namespace , interpreter , varName , true ) ; } if ( obj != Primitive . VOID ) { if ( Interpreter . DEBUG ) Interpreter . debug ( "resolved variable: " + varName + " in namespace: " + namespace ) ; evalName = suffix ( evalName ) ; return evalBaseObject = obj ; } } if ( evalBaseObject == null ) { if ( Interpreter . DEBUG ) Interpreter . debug ( "trying class: " + evalName ) ; Class clas = null ; int i = 1 ; for ( ; i <= countParts ( evalName ) ; i ++ ) if ( ( clas = namespace . getClass ( prefix ( evalName , i ) ) ) != null ) break ; if ( clas != null ) { evalName = suffix ( evalName , countParts ( evalName ) - i ) ; return ( evalBaseObject = new ClassIdentifier ( clas ) ) ; } if ( Interpreter . DEBUG ) Interpreter . debug ( "not a class, trying var prefix " + evalName ) ; } if ( evalBaseObject == null ) { if ( ! isCompound ( evalName ) ) { evalName = null ; return evalBaseObject = Primitive . VOID ; } else throw new EvalError ( "Class or variable not found:" + evalName ) ; } if ( evalBaseObject == Primitive . NULL ) throw new TargetError ( "Null Pointer while evaluating: " + value , new NullPointerException ( ) ) ; if ( evalBaseObject == Primitive . VOID ) throw new EvalError ( "Undefined variable or class name while evaluating: " + value ) ; if ( evalBaseObject instanceof Primitive ) throw new EvalError ( "Can't treat primitive like an object. " + "Error while evaluating: " + value ) ; if ( evalBaseObject instanceof ClassIdentifier ) { Class clas = ( ( ClassIdentifier ) evalBaseObject ) . getTargetClass ( ) ; String field = prefix ( evalName , 1 ) ; Object obj = null ; try { if ( Interpreter . DEBUG ) Interpreter . debug ( "Name call to getStaticField, class: " + clas + ", field:" + field ) ; obj = Reflect . getStaticField ( clas , field ) ; } catch ( ReflectError e ) { if ( Interpreter . DEBUG ) Interpreter . debug ( "field reflect error: " + e ) ; } if ( obj == null ) { String iclass = clas . getName ( ) + "$" + field ; Class c = namespace . getClass ( iclass ) ; if ( c != null ) obj = new ClassIdentifier ( c ) ; } if ( obj == null ) throw new EvalError ( "No static field or inner class: " + field + " of " + clas ) ; evalName = suffix ( evalName ) ; return ( evalBaseObject = obj ) ; } if ( forceClass ) throw new EvalError ( value + " does not resolve to a class name." ) ; String field = prefix ( evalName , 1 ) ; if ( field . equals ( "length" ) && evalBaseObject . getClass ( ) . isArray ( ) ) { Object obj = new Primitive ( Array . getLength ( evalBaseObject ) ) ; evalName = suffix ( evalName ) ; return ( evalBaseObject = obj ) ; } try { Object obj = Reflect . getObjectField ( evalBaseObject , field ) ; evalName = suffix ( evalName ) ; return ( evalBaseObject = obj ) ; } catch ( ReflectError e ) { } throw new EvalError ( "Cannot access field: " + field + ", on object: " + evalBaseObject ) ; } Object resolveThisFieldReference ( CallStack callstack , NameSpace thisNamespace , Interpreter interpreter , String varName , boolean specialFieldsVisible ) throws EvalError { Object obj = null ; boolean wasThis = false , wasCaller = false ; if ( varName . equals ( "this" ) ) { if ( specialFieldsVisible ) throw new EvalError ( "Redundant to call .this on This type" ) ; obj = thisNamespace . getThis ( interpreter ) ; wasThis = true ; } if ( obj == null ) { if ( varName . equals ( "super" ) ) obj = thisNamespace . getSuper ( ) . getThis ( interpreter ) ; else if ( varName . equals ( "global" ) ) obj = thisNamespace . getGlobal ( ) . getThis ( interpreter ) ; } if ( obj == null && specialFieldsVisible ) { if ( varName . equals ( "namespace" ) ) obj = thisNamespace ; else if ( varName . equals ( "variables" ) ) obj = thisNamespace . getVariableNames ( ) ; else if ( varName . equals ( "methods" ) ) obj = thisNamespace . getMethodNames ( ) ; else if ( varName . equals ( "interpreter" ) ) if ( literalThisReference ) obj = interpreter ; else throw new EvalError ( "Can only call .interpreter on literal 'this'" ) ; } if ( obj == null && specialFieldsVisible && varName . equals ( "caller" ) ) { if ( literalThisReference || literalCallerReference ) { if ( callstack == null ) throw new InterpreterError ( "no callstack" ) ; obj = callstack . get ( ++ callstackDepth ) . getThis ( interpreter ) ; } else throw new EvalError ( "Can only call .caller on literal 'this' or literal '.caller'" ) ; wasCaller = true ; } if ( obj == null && specialFieldsVisible && varName . equals ( "callstack" ) ) { if ( literalThisReference ) { if ( callstack == null ) throw new InterpreterError ( "no callstack" ) ; obj = callstack ; } else throw new EvalError ( "Can only call .callstack on literal 'this'" ) ; } if ( obj == null ) obj = thisNamespace . getVariable ( varName ) ; literalThisReference = wasThis ; literalCallerReference = wasCaller ; return obj ; } synchronized public Class toClass ( ) throws EvalError { reset ( ) ; Class clas = namespace . getClass ( evalName ) ; if ( clas == null ) { Object obj = null ; try { obj = toObject ( null , null , true ) ; } catch ( EvalError e ) { } ; if ( obj instanceof ClassIdentifier ) clas = ( ( ClassIdentifier ) obj ) . getTargetClass ( ) ; } if ( clas == null ) throw new EvalError ( "Class: " + value + " not found in namespace" ) ; return clas ; } synchronized public LHS toLHS ( CallStack callstack , Interpreter interpreter ) throws EvalError { reset ( ) ; if ( ! isCompound ( evalName ) ) { return new LHS ( namespace , evalName ) ; } Object obj = null ; try { while ( isCompound ( evalName ) ) obj = consumeNextObjectField ( callstack , interpreter , false ) ; } catch ( EvalError e ) { throw new EvalError ( "LHS evaluation: " + e ) ; } if ( obj == null ) throw new InterpreterError ( "internal error 2893749283" ) ; if ( obj instanceof This ) { Interpreter . debug ( "found This reference evaluating LHS" ) ; return new LHS ( ( ( This ) obj ) . namespace , evalName ) ; } if ( evalName != null ) { try { if ( obj instanceof ClassIdentifier ) { Class clas = ( ( ClassIdentifier ) obj ) . getTargetClass ( ) ; return Reflect . getLHSStaticField ( clas , evalName ) ; } else return Reflect . getLHSObjectField ( obj , evalName ) ; } catch ( ReflectError e ) { throw new EvalError ( "Field access: " + e ) ; } } throw new InterpreterError ( "Internal error in lhs..." ) ; } private BshMethod toLocalMethod ( Object [ ] args ) { Class [ ] sig = Reflect . getTypes ( args ) ; return namespace . getMethod ( value , sig ) ; } public Object invokeMethod ( Interpreter interpreter , Object [ ] args , CallStack callstack , SimpleNode callerInfo ) throws EvalError , ReflectError , InvocationTargetException { if ( ! Name . isCompound ( value ) ) return invokeLocalMethod ( interpreter , args , callstack , callerInfo ) ; Name targetName = namespace . getNameResolver ( Name . prefix ( value ) ) ; String methodName = Name . suffix ( value , 1 ) ; Object obj = targetName . toObject ( callstack , interpreter ) ; if ( obj == Primitive . VOID ) throw new EvalError ( "Attempt to invoke method: " + methodName + "() on undefined variable or class name: " + targetName ) ; if ( ! ( obj instanceof Name . ClassIdentifier ) ) { if ( obj instanceof Primitive ) { if ( obj == Primitive . NULL ) throw new TargetError ( "Null Pointer in Method Invocation" , new NullPointerException ( ) ) ; interpreter . error ( "Attempt to access method on primitive..." + " allowing bsh.Primitive to peek through for debugging" ) ; } return Reflect . invokeObjectMethod ( interpreter , obj , methodName , args , callerInfo ) ; } if ( Interpreter . DEBUG ) Interpreter . debug ( "invokeMethod: trying static - " + targetName ) ; Class clas = ( ( Name . ClassIdentifier ) obj ) . getTargetClass ( ) ; if ( clas != null ) return Reflect . invokeStaticMethod ( clas , methodName , args ) ; throw new EvalError ( "unknown target: " + targetName ) ; } public Object invokeLocalMethod ( Interpreter interpreter , Object [ ] args , CallStack callstack , SimpleNode callerInfo ) throws EvalError , ReflectError , InvocationTargetException { if ( Interpreter . DEBUG ) Interpreter . debug ( "invoke local method: " + value ) ; BshMethod meth = toLocalMethod ( args ) ; if ( meth != null ) return meth . invokeDeclaredMethod ( args , interpreter , callstack , callerInfo ) ; else if ( Interpreter . DEBUG ) Interpreter . debug ( "no locally declared method: " + value ) ; String commandName = "commands/" + value + ".bsh" ; InputStream in = Interpreter . class . getResourceAsStream ( commandName ) ; if ( in != null ) { if ( Interpreter . DEBUG ) Interpreter . debug ( "loading resource: " + commandName ) ; if ( interpreter == null ) throw new InterpreterError ( "2234432 interpreter = null" ) ; interpreter . eval ( new InputStreamReader ( in ) , namespace , commandName ) ; meth = toLocalMethod ( args ) ; if ( meth != null ) return meth . invokeDeclaredMethod ( args , interpreter , callstack , callerInfo ) ; else throw new EvalError ( "Loaded resource: " + commandName + "had an error or did not contain the correct method" ) ; } commandName = "bsh.commands." + value ; Class c = BshClassManager . classForName ( commandName ) ; if ( c == null ) throw new EvalError ( "Command not found: " + value ) ; Object [ ] invokeArgs = new Object [ args . length + 2 ] ; invokeArgs [ 0 ] = interpreter ; invokeArgs [ 1 ] = namespace ; System . arraycopy ( args , 0 , invokeArgs , 2 , args . length ) ; try { return Reflect . invokeStaticMethod ( c , "invoke" , invokeArgs ) ; } catch ( ReflectError e ) { if ( Interpreter . DEBUG ) Interpreter . debug ( "invoke command args error:" + e ) ; } try { String s = ( String ) Reflect . invokeStaticMethod ( c , "usage" , null ) ; interpreter . println ( s ) ; return Primitive . VOID ; } catch ( ReflectError e ) { if ( Interpreter . DEBUG ) Interpreter . debug ( "usage threw: " + e ) ; throw new EvalError ( "Wrong number or type of args for command" ) ; } } static boolean isCompound ( String value ) { return countParts ( value ) > 1 ; } static int countParts ( String value ) { if ( value == null ) return 0 ; int count = 0 ; int index = - 1 ; while ( ( index = value . indexOf ( '.' , index + 1 ) ) != - 1 ) count ++ ; return count + 1 ; } static String prefix ( String value ) { if ( ! isCompound ( value ) ) return null ; return prefix ( value , countParts ( value ) - 1 ) ; } static String prefix ( String value , int parts ) { if ( parts < 1 ) return null ; int count = 0 ; int index = - 1 ; while ( ( ( index = value . indexOf ( '.' , index + 1 ) ) != - 1 ) && ( ++ count < parts ) ) { ; } return ( index == - 1 ) ? value : value . substring ( 0 , index ) ; } static String suffix ( String name ) { if ( ! isCompound ( name ) ) return null ; return suffix ( name , countParts ( name ) - 1 ) ; } public static String suffix ( String value , int parts ) { if ( parts < 1 ) return null ; int count = 0 ; int index = value . length ( ) + 1 ; while ( ( ( index = value . lastIndexOf ( '.' , index - 1 ) ) != - 1 ) && ( ++ count < parts ) ) { ; } return ( index == - 1 ) ? value : value . substring ( index + 1 ) ; } public String toString ( ) { return value ; } static class ClassIdentifier { Class clas ; public ClassIdentifier ( Class clas ) { this . clas = clas ; } public Class getTargetClass ( ) { return clas ; } public String toString ( ) { return "Class Identifier: " + clas . getName ( ) ; } } } 	0	['19', '1', '0', '19', '71', '91', '6', '15', '9', '0.708333333', '1313', '0.625', '1', '0', '0.274853801', '0', '0', '67.68421053', '5', '1.6316', '0']
package gnu . regexp ; final class RETokenChar extends REToken { private char [ ] ch ; private boolean insens ; RETokenChar ( int subIndex , char c , boolean ins ) { super ( subIndex ) ; ch = new char [ 1 ] ; ch [ 0 ] = ( insens = ins ) ? Character . toLowerCase ( c ) : c ; } int getMinimumLength ( ) { return ch . length ; } boolean match ( CharIndexed input , REMatch mymatch ) { int z = ch . length ; char c ; for ( int i = 0 ; i < z ; i ++ ) { c = input . charAt ( mymatch . index + i ) ; if ( ( ( insens ) ? Character . toLowerCase ( c ) : c ) != ch [ i ] ) { return false ; } } mymatch . index += z ; return next ( input , mymatch ) ; } boolean chain ( REToken next ) { if ( next instanceof RETokenChar ) { RETokenChar cnext = ( RETokenChar ) next ; int newsize = ch . length + cnext . ch . length ; char [ ] chTemp = new char [ newsize ] ; System . arraycopy ( ch , 0 , chTemp , 0 , ch . length ) ; System . arraycopy ( cnext . ch , 0 , chTemp , ch . length , cnext . ch . length ) ; ch = chTemp ; return false ; } else return super . chain ( next ) ; } void dump ( StringBuffer os ) { os . append ( ch ) ; } } 	0	['5', '2', '0', '5', '12', '0', '2', '3', '0', '0.375', '127', '1', '0', '0.636363636', '0.3', '1', '2', '24', '4', '1.6', '0']
package org . gjt . sp . jedit . gui ; import java . awt . * ; import java . awt . event . * ; import java . util . Vector ; import javax . swing . * ; import javax . swing . border . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class ErrorListDialog extends EnhancedDialog { public static class ErrorEntry { String path ; String [ ] messages ; public ErrorEntry ( String path , String messageProp , Object [ ] args ) { this . path = path ; String message = jEdit . getProperty ( messageProp , args ) ; if ( message == null ) message = "Undefined property: " + messageProp ; Log . log ( Log . ERROR , this , path + ":" ) ; Log . log ( Log . ERROR , this , message ) ; Vector tokenizedMessage = new Vector ( ) ; int lastIndex = - 1 ; for ( int i = 0 ; i < message . length ( ) ; i ++ ) { if ( message . charAt ( i ) == '\n' ) { tokenizedMessage . addElement ( message . substring ( lastIndex + 1 , i ) ) ; lastIndex = i ; } } if ( lastIndex != message . length ( ) ) { tokenizedMessage . addElement ( message . substring ( lastIndex + 1 ) ) ; } messages = new String [ tokenizedMessage . size ( ) ] ; tokenizedMessage . copyInto ( messages ) ; } } public ErrorListDialog ( Frame frame , String title , String caption , Vector messages , boolean showPluginMgrButton ) { super ( frame , title , true ) ; JPanel content = new JPanel ( new BorderLayout ( 12 , 12 ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; Box iconBox = new Box ( BoxLayout . Y_AXIS ) ; iconBox . add ( new JLabel ( UIManager . getIcon ( "OptionPane.errorIcon" ) ) ) ; iconBox . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . WEST , iconBox ) ; JPanel centerPanel = new JPanel ( new BorderLayout ( ) ) ; JLabel label = new JLabel ( caption ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; centerPanel . add ( BorderLayout . NORTH , label ) ; JList errors = new JList ( messages ) ; errors . setCellRenderer ( new ErrorListCellRenderer ( ) ) ; errors . setVisibleRowCount ( Math . min ( messages . size ( ) , 4 ) ) ; JScrollPane scrollPane = new JScrollPane ( errors , JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_ALWAYS ) ; Dimension size = scrollPane . getPreferredSize ( ) ; size . width = Math . min ( size . width , 400 ) ; scrollPane . setPreferredSize ( size ) ; centerPanel . add ( BorderLayout . CENTER , scrollPane ) ; content . add ( BorderLayout . CENTER , centerPanel ) ; Box buttons = new Box ( BoxLayout . X_AXIS ) ; buttons . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; if ( showPluginMgrButton ) { pluginMgr = new JButton ( jEdit . getProperty ( "error-list.plugin-manager" ) ) ; pluginMgr . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( pluginMgr ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; } buttons . add ( ok ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , buttons ) ; getRootPane ( ) . setDefaultButton ( ok ) ; pack ( ) ; setLocationRelativeTo ( frame ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } private JButton ok , pluginMgr ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) dispose ( ) ; else if ( evt . getSource ( ) == pluginMgr ) { new org . gjt . sp . jedit . pluginmgr . PluginManager ( JOptionPane . getFrameForComponent ( ErrorListDialog . this ) ) ; } } } } 	0	['5', '7', '0', '6', '40', '6', '3', '4', '3', '0.75', '214', '1', '0', '0.993939394', '0.3', '2', '5', '41.4', '1', '0.8', '0']
package gnu . regexp ; import java . io . FilterReader ; import java . io . Reader ; public class REFilterReader extends FilterReader { private RE expr ; private String replace ; private String buffer ; private int bufpos ; private int offset ; private CharIndexedReader stream ; public REFilterReader ( Reader stream , RE expr , String replace ) { super ( stream ) ; this . stream = new CharIndexedReader ( stream , 0 ) ; this . expr = expr ; this . replace = replace ; } public int read ( ) { if ( ( buffer != null ) && ( bufpos < buffer . length ( ) ) ) { return ( int ) buffer . charAt ( bufpos ++ ) ; } if ( ! stream . isValid ( ) ) return - 1 ; REMatch mymatch = new REMatch ( expr . getNumSubs ( ) , offset , 0 ) ; if ( expr . match ( stream , mymatch ) ) { mymatch . end [ 0 ] = mymatch . index ; mymatch . finish ( stream ) ; stream . move ( mymatch . toString ( ) . length ( ) ) ; offset += mymatch . toString ( ) . length ( ) ; buffer = mymatch . substituteInto ( replace ) ; bufpos = 1 ; if ( buffer . length ( ) > 0 ) { return buffer . charAt ( 0 ) ; } } char ch = stream . charAt ( 0 ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return - 1 ; stream . move ( 1 ) ; offset ++ ; return ch ; } public boolean markSupported ( ) { return false ; } public int read ( char [ ] b , int off , int len ) { int i ; int ok = 0 ; while ( len -- > 0 ) { i = read ( ) ; if ( i == - 1 ) return ( ok == 0 ) ? - 1 : ok ; b [ off ++ ] = ( char ) i ; ok ++ ; } return ok ; } public int read ( char [ ] b ) { return read ( b , 0 , b . length ) ; } } 	0	['5', '3', '0', '4', '18', '8', '0', '4', '5', '0.375', '176', '1', '2', '0.818181818', '0.366666667', '2', '3', '33', '7', '2.6', '0']
package com . microstar . xml ; public interface XmlHandler { public void startDocument ( ) throws java . lang . Exception ; public void endDocument ( ) throws java . lang . Exception ; public Object resolveEntity ( String publicId , String systemId ) throws java . lang . Exception ; public void startExternalEntity ( String systemId ) throws java . lang . Exception ; public void endExternalEntity ( String systemId ) throws java . lang . Exception ; public void doctypeDecl ( String name , String publicId , String systemId ) throws java . lang . Exception ; public void attribute ( String aname , String value , boolean isSpecified ) throws java . lang . Exception ; public void startElement ( String elname ) throws java . lang . Exception ; public void endElement ( String elname ) throws java . lang . Exception ; public void charData ( char ch [ ] , int start , int length ) throws java . lang . Exception ; public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws java . lang . Exception ; public void processingInstruction ( String target , String data ) throws java . lang . Exception ; public void error ( String message , String systemId , int line , int column ) throws java . lang . Exception ; } 	0	['13', '1', '0', '7', '13', '78', '7', '0', '13', '2', '13', '0', '0', '0', '0.430769231', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class EnhancedMenuItem extends JMenuItem { public EnhancedMenuItem ( String label , EditAction action ) { super ( label ) ; this . action = action ; if ( action != null ) { setEnabled ( true ) ; addActionListener ( new EditAction . Wrapper ( action ) ) ; shortcutProp1 = action . getName ( ) + ".shortcut" ; shortcutProp2 = action . getName ( ) + ".shortcut2" ; addMouseListener ( new MouseHandler ( ) ) ; } else setEnabled ( false ) ; } public Dimension getPreferredSize ( ) { Dimension d = super . getPreferredSize ( ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { d . width += ( getFontMetrics ( acceleratorFont ) . stringWidth ( shortcut ) + 15 ) ; } return d ; } public void paint ( Graphics g ) { super . paint ( g ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { g . setFont ( acceleratorFont ) ; g . setColor ( getModel ( ) . isArmed ( ) ? acceleratorSelectionForeground : acceleratorForeground ) ; FontMetrics fm = g . getFontMetrics ( ) ; Insets insets = getInsets ( ) ; g . drawString ( shortcut , getWidth ( ) - ( fm . stringWidth ( shortcut ) + insets . right + insets . left + 5 ) , getFont ( ) . getSize ( ) + ( insets . top - ( OperatingSystem . isMacOSLF ( ) ? 0 : 1 ) ) ) ; } } private String shortcutProp1 ; private String shortcutProp2 ; private EditAction action ; private static Font acceleratorFont ; private static Color acceleratorForeground ; private static Color acceleratorSelectionForeground ; private String getShortcut ( ) { if ( action == null ) return null ; else { String shortcut1 = jEdit . getProperty ( shortcutProp1 ) ; String shortcut2 = jEdit . getProperty ( shortcutProp2 ) ; if ( shortcut1 == null || shortcut1 . length ( ) == 0 ) { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return null ; else return shortcut2 ; } else { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return shortcut1 ; else return shortcut1 + " or " + shortcut2 ; } } } static { String shortcutFont ; if ( OperatingSystem . isMacOSLF ( ) ) shortcutFont = "Lucida Grande" ; else shortcutFont = "Monospaced" ; acceleratorFont = UIManager . getFont ( "MenuItem.acceleratorFont" ) ; acceleratorFont = new Font ( shortcutFont , acceleratorFont . getStyle ( ) , acceleratorFont . getSize ( ) ) ; acceleratorForeground = UIManager . getColor ( "MenuItem.acceleratorForeground" ) ; acceleratorSelectionForeground = UIManager . getColor ( "MenuItem.acceleratorSelectionForeground" ) ; } class MouseHandler extends MouseAdapter { public void mouseReleased ( MouseEvent evt ) { GUIUtilities . getView ( ( Component ) evt . getSource ( ) ) . getStatus ( ) . setMessage ( null ) ; } public void mouseEntered ( MouseEvent evt ) { String msg = action . getMouseOverText ( ) ; if ( msg != null ) { GUIUtilities . getView ( ( Component ) evt . getSource ( ) ) . getStatus ( ) . setMessage ( msg ) ; } } public void mouseExited ( MouseEvent evt ) { GUIUtilities . getView ( ( Component ) evt . getSource ( ) ) . getStatus ( ) . setMessage ( null ) ; } } } 	0	['6', '6', '0', '7', '37', '3', '3', '5', '3', '0.533333333', '214', '1', '1', '0.994993742', '0.32', '2', '11', '33.66666667', '8', '2.5', '0']
package org . gjt . sp . jedit . syntax ; import gnu . regexp . * ; import org . gjt . sp . jedit . search . RESearchMatcher ; public class ParserRule { public static final int MAJOR_ACTIONS = 0x000000FF ; public static final int SEQ = 0 ; public static final int SPAN = 1 << 1 ; public static final int MARK_PREVIOUS = 1 << 2 ; public static final int MARK_FOLLOWING = 1 << 3 ; public static final int EOL_SPAN = 1 << 4 ; public static final int ACTION_HINTS = 0x0000FF00 ; public static final int EXCLUDE_MATCH = 1 << 8 ; public static final int AT_LINE_START = 1 << 9 ; public static final int AT_WHITESPACE_END = 1 << 10 ; public static final int AT_WORD_START = 1 << 11 ; public static final int NO_LINE_BREAK = 1 << 12 ; public static final int NO_WORD_BREAK = 1 << 13 ; public static final int IS_ESCAPE = 1 << 14 ; public static final int REGEXP = 1 << 15 ; public final char hashChar ; public final char [ ] start ; public final RE startRegexp ; public final char [ ] end ; public final int action ; public final byte token ; public ParserRule next ; public ParserRuleSet getDelegateRuleSet ( TokenMarker tokenMarker ) { if ( delegate == null ) { if ( ( action & MAJOR_ACTIONS ) == SEQ ) return null ; else return ParserRuleSet . getStandardRuleSet ( token ) ; } else { ParserRuleSet delegateSet = tokenMarker . getRuleSet ( delegate ) ; if ( delegateSet == null ) { return ParserRuleSet . getStandardRuleSet ( Token . NULL ) ; } else return delegateSet ; } } public static final ParserRule createSequenceRule ( String seq , String delegate , byte id , boolean atLineStart , boolean atWhitespaceEnd , boolean atWordStart ) { int ruleAction = SEQ | ( ( atLineStart ) ? AT_LINE_START : 0 ) | ( ( atWhitespaceEnd ) ? AT_WHITESPACE_END : 0 ) | ( ( atWordStart ) ? AT_WORD_START : 0 ) ; return new ParserRule ( ruleAction , seq . charAt ( 0 ) , seq . toCharArray ( ) , null , null , delegate , id ) ; } public static final ParserRule createRegexpSequenceRule ( char hashChar , String seq , String delegate , byte id , boolean atLineStart , boolean atWhitespaceEnd , boolean atWordStart , boolean ignoreCase ) throws REException { int ruleAction = SEQ | REGEXP | ( ( atLineStart ) ? AT_LINE_START : 0 ) | ( ( atWhitespaceEnd ) ? AT_WHITESPACE_END : 0 ) | ( ( atWordStart ) ? AT_WORD_START : 0 ) ; return new ParserRule ( ruleAction , hashChar , null , new RE ( "\\A" + seq , ( ignoreCase ? RE . REG_ICASE : 0 ) , RESearchMatcher . RE_SYNTAX_JEDIT ) , null , delegate , id ) ; } public static final ParserRule createSpanRule ( String begin , String end , String delegate , byte id , boolean noLineBreak , boolean atLineStart , boolean atWhitespaceEnd , boolean atWordStart , boolean excludeMatch , boolean noWordBreak ) { int ruleAction = SPAN | ( ( noLineBreak ) ? NO_LINE_BREAK : 0 ) | ( ( atLineStart ) ? AT_LINE_START : 0 ) | ( ( atWhitespaceEnd ) ? AT_WHITESPACE_END : 0 ) | ( ( atWordStart ) ? AT_WORD_START : 0 ) | ( ( excludeMatch ) ? EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? NO_WORD_BREAK : 0 ) ; return new ParserRule ( ruleAction , begin . charAt ( 0 ) , begin . toCharArray ( ) , null , end . toCharArray ( ) , delegate , id ) ; } public static final ParserRule createRegexpSpanRule ( char hashChar , String begin , String end , String delegate , byte id , boolean noLineBreak , boolean atLineStart , boolean atWhitespaceEnd , boolean atWordStart , boolean excludeMatch , boolean noWordBreak , boolean ignoreCase ) throws REException { int ruleAction = SPAN | REGEXP | ( ( noLineBreak ) ? NO_LINE_BREAK : 0 ) | ( ( atLineStart ) ? AT_LINE_START : 0 ) | ( ( atWhitespaceEnd ) ? AT_WHITESPACE_END : 0 ) | ( ( atWordStart ) ? AT_WORD_START : 0 ) | ( ( excludeMatch ) ? EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? NO_WORD_BREAK : 0 ) ; return new ParserRule ( ruleAction , hashChar , null , new RE ( "\\A" + begin , ( ignoreCase ? RE . REG_ICASE : 0 ) , RESearchMatcher . RE_SYNTAX_JEDIT ) , end . toCharArray ( ) , delegate , id ) ; } public static final ParserRule createEOLSpanRule ( String seq , String delegate , byte id , boolean atLineStart , boolean atWhitespaceEnd , boolean atWordStart , boolean excludeMatch ) { int ruleAction = EOL_SPAN | ( ( atLineStart ) ? AT_LINE_START : 0 ) | ( ( atWhitespaceEnd ) ? AT_WHITESPACE_END : 0 ) | ( ( atWordStart ) ? AT_WORD_START : 0 ) | ( ( excludeMatch ) ? EXCLUDE_MATCH : 0 ) | NO_LINE_BREAK ; return new ParserRule ( ruleAction , seq . charAt ( 0 ) , seq . toCharArray ( ) , null , null , delegate , id ) ; } public static final ParserRule createRegexpEOLSpanRule ( char hashChar , String seq , String delegate , byte id , boolean atLineStart , boolean atWhitespaceEnd , boolean atWordStart , boolean excludeMatch , boolean ignoreCase ) throws REException { int ruleAction = EOL_SPAN | REGEXP | ( ( atLineStart ) ? AT_LINE_START : 0 ) | ( ( atWhitespaceEnd ) ? AT_WHITESPACE_END : 0 ) | ( ( atWordStart ) ? AT_WORD_START : 0 ) | ( ( excludeMatch ) ? EXCLUDE_MATCH : 0 ) | NO_LINE_BREAK ; return new ParserRule ( ruleAction , hashChar , null , new RE ( "\\A" + seq , ( ignoreCase ? RE . REG_ICASE : 0 ) , RESearchMatcher . RE_SYNTAX_JEDIT ) , null , delegate , id ) ; } public static final ParserRule createMarkFollowingRule ( String seq , byte id , boolean atLineStart , boolean atWhitespaceEnd , boolean atWordStart , boolean excludeMatch ) { int ruleAction = MARK_FOLLOWING | ( ( atLineStart ) ? AT_LINE_START : 0 ) | ( ( atWhitespaceEnd ) ? AT_WHITESPACE_END : 0 ) | ( ( atWordStart ) ? AT_WORD_START : 0 ) | ( ( excludeMatch ) ? EXCLUDE_MATCH : 0 ) ; return new ParserRule ( ruleAction , seq . charAt ( 0 ) , seq . toCharArray ( ) , null , null , null , id ) ; } public static final ParserRule createMarkPreviousRule ( String seq , byte id , boolean atLineStart , boolean atWhitespaceEnd , boolean atWordStart , boolean excludeMatch ) { int ruleAction = MARK_PREVIOUS | ( ( atLineStart ) ? AT_LINE_START : 0 ) | ( ( atWhitespaceEnd ) ? AT_WHITESPACE_END : 0 ) | ( ( atWordStart ) ? AT_WORD_START : 0 ) | ( ( excludeMatch ) ? EXCLUDE_MATCH : 0 ) ; return new ParserRule ( ruleAction , seq . charAt ( 0 ) , seq . toCharArray ( ) , null , null , null , id ) ; } public static final ParserRule createEscapeRule ( String seq ) { int ruleAction = IS_ESCAPE ; return new ParserRule ( ruleAction , seq . charAt ( 0 ) , seq . toCharArray ( ) , null , null , null , Token . NULL ) ; } private String delegate ; private ParserRule ( int action , char hashChar , char [ ] start , RE startRegexp , char [ ] end , String delegate , byte token ) { this . hashChar = hashChar ; this . start = start ; this . startRegexp = startRegexp ; this . end = end ; this . delegate = delegate ; this . action = action ; this . token = token ; } } 	0	['11', '1', '0', '9', '20', '53', '5', '6', '10', '0.782608696', '477', '0.043478261', '2', '0', '0.373737374', '0', '0', '40.27272727', '7', '3.0909', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . * ; public class ViewRegisters extends EnhancedDialog { public ViewRegisters ( View view ) { super ( view , jEdit . getProperty ( "view-registers.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBorder ( new EmptyBorder ( 0 , 12 , 0 , 0 ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "view-registers.register" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 0 ) ) ; panel . add ( BorderLayout . NORTH , label ) ; DefaultListModel registerModel = new DefaultListModel ( ) ; registerList = new JList ( registerModel ) ; registerList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; registerList . setCellRenderer ( new Renderer ( ) ) ; Registers . Register [ ] registers = Registers . getRegisters ( ) ; int index = 0 ; for ( int i = 0 ; i < registers . length ; i ++ ) { Registers . Register reg = registers [ i ] ; if ( reg == null ) continue ; String value = reg . toString ( ) ; if ( value == null || value . length ( ) == 0 ) continue ; registerModel . addElement ( new Character ( ( char ) i ) ) ; } if ( registerModel . getSize ( ) == 0 ) registerModel . addElement ( jEdit . getProperty ( "view-registers.none" ) ) ; panel . add ( BorderLayout . CENTER , new JScrollPane ( registerList ) ) ; content . add ( BorderLayout . WEST , panel ) ; panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBorder ( new EmptyBorder ( 0 , 12 , 0 , 0 ) ) ; label = new JLabel ( jEdit . getProperty ( "view-registers.contents" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 0 ) ) ; panel . add ( BorderLayout . NORTH , label ) ; contentTextArea = new JTextArea ( 10 , 80 ) ; contentTextArea . setEditable ( false ) ; panel . add ( BorderLayout . CENTER , new JScrollPane ( contentTextArea ) ) ; content . add ( BorderLayout . CENTER , panel ) ; panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( new ActionHandler ( ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( close ) ; panel . add ( Box . createGlue ( ) ) ; getRootPane ( ) . setDefaultButton ( close ) ; content . add ( BorderLayout . SOUTH , panel ) ; registerList . addListSelectionListener ( new ListHandler ( ) ) ; registerList . setSelectedIndex ( index ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } private JList registerList ; private JTextArea contentTextArea ; private JButton close ; class Renderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; if ( value instanceof Character ) { char name = ( ( Character ) value ) . charValue ( ) ; String label ; if ( name == '\n' ) label = "\n" ; else if ( name == '\t' ) label = "\t" ; else if ( name == '$' ) label = jEdit . getProperty ( "view-registers.clipboard" ) ; else if ( name == '%' ) label = jEdit . getProperty ( "view-registers.selection" ) ; else label = String . valueOf ( ( char ) name ) ; setText ( label ) ; } return this ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == close ) cancel ( ) ; } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { Object value = registerList . getSelectedValue ( ) ; if ( ! ( value instanceof Character ) ) return ; char name = ( ( Character ) value ) . charValue ( ) ; Registers . Register reg = Registers . getRegister ( name ) ; if ( reg == null ) return ; contentTextArea . setText ( reg . toString ( ) ) ; contentTextArea . setCaretPosition ( 0 ) ; } } } 	0	['6', '7', '0', '8', '47', '9', '3', '8', '3', '0.8', '299', '1', '0', '0.992435703', '0.388888889', '0', '0', '48.33333333', '1', '0.8333', '0']
package org . gjt . sp . jedit . browser ; import java . awt . event . * ; import java . util . * ; import javax . swing . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . * ; public class BrowserCommandsMenu extends JPopupMenu { public BrowserCommandsMenu ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) { this . browser = browser ; if ( files != null ) { this . files = files ; VFS vfs = VFSManager . getVFSForPath ( files [ 0 ] . deletePath ) ; int type = files [ 0 ] . type ; boolean fileOpen = ( jEdit . getBuffer ( files [ 0 ] . path ) != null ) ; boolean delete = ! fileOpen && ( vfs . getCapabilities ( ) & VFS . DELETE_CAP ) != 0 ; boolean rename = ! fileOpen && ( vfs . getCapabilities ( ) & VFS . RENAME_CAP ) != 0 ; for ( int i = 1 ; i < files . length ; i ++ ) { VFS . DirectoryEntry file = files [ i ] ; VFS _vfs = VFSManager . getVFSForPath ( file . deletePath ) ; delete &= ( vfs == _vfs ) && ( _vfs . getCapabilities ( ) & VFS . DELETE_CAP ) != 0 ; if ( type == file . type ) ; else { type = - 1 ; } rename = false ; if ( jEdit . getBuffer ( file . path ) != null ) fileOpen = true ; } if ( type == VFS . DirectoryEntry . DIRECTORY || type == VFS . DirectoryEntry . FILESYSTEM ) { if ( files . length == 1 ) add ( createMenuItem ( "browse" ) ) ; if ( browser . getMode ( ) == VFSBrowser . BROWSER ) add ( createMenuItem ( "browse-window" ) ) ; } else if ( type == VFS . DirectoryEntry . FILE && ( browser . getMode ( ) == VFSBrowser . BROWSER || browser . getMode ( ) == VFSBrowser . BROWSER_DIALOG ) ) { add ( createMenuItem ( "open" ) ) ; JMenu openIn = new JMenu ( jEdit . getProperty ( "vfs.browser.commands.open-in.label" ) ) ; openIn . add ( createMenuItem ( "open-view" ) ) ; openIn . add ( createMenuItem ( "open-plain-view" ) ) ; openIn . add ( createMenuItem ( "open-split" ) ) ; add ( openIn ) ; add ( createMenuItem ( "insert" ) ) ; if ( fileOpen ) add ( createMenuItem ( "close" ) ) ; } else if ( type != - 1 ) add ( createMenuItem ( "choose" ) ) ; if ( rename ) add ( createMenuItem ( "rename" ) ) ; if ( delete ) add ( createMenuItem ( "delete" ) ) ; addSeparator ( ) ; } add ( createMenuItem ( "up" ) ) ; add ( createMenuItem ( "reload" ) ) ; add ( createMenuItem ( "roots" ) ) ; add ( createMenuItem ( "home" ) ) ; add ( createMenuItem ( "synchronize" ) ) ; addSeparator ( ) ; if ( browser . getMode ( ) == VFSBrowser . BROWSER ) add ( createMenuItem ( "new-file" ) ) ; add ( createMenuItem ( "new-directory" ) ) ; if ( browser . getMode ( ) == VFSBrowser . BROWSER ) { addSeparator ( ) ; add ( createMenuItem ( "search-in-directory" ) ) ; } addSeparator ( ) ; showHiddenFiles = new JCheckBoxMenuItem ( jEdit . getProperty ( "vfs.browser.commands.show-hidden-files.label" ) ) ; showHiddenFiles . setActionCommand ( "show-hidden-files" ) ; showHiddenFiles . addActionListener ( new ActionHandler ( ) ) ; add ( showHiddenFiles ) ; if ( browser . getMode ( ) == VFSBrowser . BROWSER || browser . getMode ( ) == VFSBrowser . BROWSER_DIALOG ) { addSeparator ( ) ; add ( createEncodingMenu ( ) ) ; } update ( ) ; } public void update ( ) { showHiddenFiles . setSelected ( browser . getShowHiddenFiles ( ) ) ; if ( encodingMenuItems != null ) { JRadioButtonMenuItem mi = ( JRadioButtonMenuItem ) encodingMenuItems . get ( browser . currentEncoding ) ; if ( mi != null ) { mi . setSelected ( true ) ; otherEncoding . setText ( jEdit . getProperty ( "vfs.browser.commands.other-encoding.label" ) ) ; } else { otherEncoding . setSelected ( true ) ; otherEncoding . setText ( jEdit . getProperty ( "vfs.browser.commands.other-encoding-2.label" , new String [ ] { browser . currentEncoding } ) ) ; } } } private VFSBrowser browser ; private VFS . DirectoryEntry [ ] files ; private VFS vfs ; private JCheckBoxMenuItem showHiddenFiles ; private HashMap encodingMenuItems ; private JRadioButtonMenuItem defaultEncoding ; private JRadioButtonMenuItem otherEncoding ; private JMenuItem createMenuItem ( String name ) { String label = jEdit . getProperty ( "vfs.browser.commands." + name + ".label" ) ; JMenuItem mi = new JMenuItem ( label ) ; mi . setActionCommand ( name ) ; mi . addActionListener ( new ActionHandler ( ) ) ; return mi ; } private JMenu createEncodingMenu ( ) { ActionHandler actionHandler = new ActionHandler ( ) ; encodingMenuItems = new HashMap ( ) ; JMenu encodingMenu = new JMenu ( jEdit . getProperty ( "vfs.browser.commands.encoding.label" ) ) ; ButtonGroup grp = new ButtonGroup ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { String encoding = st . nextToken ( ) ; JRadioButtonMenuItem mi = new JRadioButtonMenuItem ( encoding ) ; mi . setActionCommand ( "encoding@" + encoding ) ; mi . addActionListener ( actionHandler ) ; grp . add ( mi ) ; encodingMenuItems . put ( encoding , mi ) ; encodingMenu . add ( mi ) ; } String systemEncoding = System . getProperty ( "file.encoding" ) ; if ( encodingMenuItems . get ( systemEncoding ) == null ) { JRadioButtonMenuItem mi = new JRadioButtonMenuItem ( systemEncoding ) ; mi . setActionCommand ( "encoding@" + systemEncoding ) ; mi . addActionListener ( actionHandler ) ; grp . add ( mi ) ; encodingMenuItems . put ( systemEncoding , mi ) ; encodingMenu . add ( mi ) ; } encodingMenu . addSeparator ( ) ; otherEncoding = new JRadioButtonMenuItem ( ) ; otherEncoding . setActionCommand ( "other-encoding" ) ; otherEncoding . addActionListener ( actionHandler ) ; grp . add ( otherEncoding ) ; encodingMenu . add ( otherEncoding ) ; return encodingMenu ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { View view = browser . getView ( ) ; String actionCommand = evt . getActionCommand ( ) ; if ( actionCommand . equals ( "other-encoding" ) ) { String encoding = GUIUtilities . input ( browser , "encoding-prompt" , null , jEdit . getProperty ( "buffer.encoding" , System . getProperty ( "file.encoding" ) ) ) ; if ( encoding == null ) return ; browser . currentEncoding = encoding ; } else if ( actionCommand . startsWith ( "encoding@" ) ) { browser . currentEncoding = actionCommand . substring ( 9 ) ; } else if ( actionCommand . equals ( "open" ) ) browser . filesActivated ( VFSBrowser . M_OPEN , false ) ; else if ( actionCommand . equals ( "open-view" ) ) browser . filesActivated ( VFSBrowser . M_OPEN_NEW_VIEW , false ) ; else if ( actionCommand . equals ( "open-plain-view" ) ) browser . filesActivated ( VFSBrowser . M_OPEN_NEW_PLAIN_VIEW , false ) ; else if ( actionCommand . equals ( "open-split" ) ) browser . filesActivated ( VFSBrowser . M_OPEN_NEW_SPLIT , false ) ; else if ( actionCommand . equals ( "insert" ) ) { for ( int i = 0 ; i < files . length ; i ++ ) { view . getBuffer ( ) . insertFile ( view , files [ i ] . path ) ; } } else if ( actionCommand . equals ( "choose" ) ) browser . filesActivated ( VFSBrowser . M_OPEN , false ) ; else if ( actionCommand . equals ( "close" ) ) { for ( int i = 0 ; i < files . length ; i ++ ) { Buffer buffer = jEdit . getBuffer ( files [ i ] . path ) ; if ( buffer != null ) jEdit . closeBuffer ( view , buffer ) ; } } else if ( actionCommand . equals ( "browse" ) ) browser . setDirectory ( files [ 0 ] . path ) ; else if ( actionCommand . equals ( "browse-window" ) ) { for ( int i = 0 ; i < files . length ; i ++ ) { VFSBrowser . browseDirectoryInNewWindow ( view , files [ i ] . path ) ; } } else if ( actionCommand . equals ( "rename" ) ) browser . rename ( files [ 0 ] . path ) ; else if ( actionCommand . equals ( "delete" ) ) browser . delete ( files ) ; else if ( actionCommand . equals ( "up" ) ) { String path = browser . getDirectory ( ) ; VFS vfs = VFSManager . getVFSForPath ( path ) ; browser . setDirectory ( vfs . getParentOfPath ( path ) ) ; } else if ( actionCommand . equals ( "reload" ) ) browser . reloadDirectory ( ) ; else if ( actionCommand . equals ( "roots" ) ) browser . rootDirectory ( ) ; else if ( actionCommand . equals ( "home" ) ) browser . setDirectory ( System . getProperty ( "user.home" ) ) ; else if ( actionCommand . equals ( "synchronize" ) ) { Buffer buffer = browser . getView ( ) . getBuffer ( ) ; browser . setDirectory ( buffer . getDirectory ( ) ) ; } else if ( actionCommand . equals ( "new-file" ) ) browser . newFile ( ) ; else if ( actionCommand . equals ( "new-directory" ) ) browser . mkdir ( ) ; else if ( actionCommand . equals ( "search-in-directory" ) ) browser . searchInDirectory ( ) ; else if ( actionCommand . equals ( "show-hidden-files" ) ) { browser . setShowHiddenFiles ( ! browser . getShowHiddenFiles ( ) ) ; browser . reloadDirectory ( ) ; } } } } 	0	['6', '5', '0', '12', '45', '5', '6', '7', '2', '0.828571429', '536', '1', '3', '0.993055556', '0.3', '0', '0', '87.16666667', '3', '1.5', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . event . * ; import javax . swing . * ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . * ; public class EnhancedMenu extends JMenu implements MenuListener { public EnhancedMenu ( String name ) { this . _name = name ; String label = jEdit . getProperty ( name . concat ( ".label" ) ) ; if ( label == null ) label = name ; char mnemonic ; int index = label . indexOf ( '$' ) ; if ( index != - 1 && label . length ( ) - index > 1 ) { mnemonic = Character . toLowerCase ( label . charAt ( index + 1 ) ) ; label = label . substring ( 0 , index ) . concat ( label . substring ( ++ index ) ) ; } else mnemonic = '\0' ; setText ( label ) ; if ( ! OperatingSystem . isMacOS ( ) ) setMnemonic ( mnemonic ) ; addMenuListener ( this ) ; } public void menuSelected ( MenuEvent evt ) { init ( ) ; } public void menuDeselected ( MenuEvent e ) { } public void menuCanceled ( MenuEvent e ) { } public void init ( ) { if ( initialized ) return ; initialized = true ; String menuItems = jEdit . getProperty ( _name ) ; if ( menuItems != null ) { StringTokenizer st = new StringTokenizer ( menuItems ) ; while ( st . hasMoreTokens ( ) ) { String menuItemName = st . nextToken ( ) ; if ( menuItemName . equals ( "-" ) ) addSeparator ( ) ; else { if ( menuItemName . startsWith ( "%" ) ) add ( GUIUtilities . loadMenu ( menuItemName . substring ( 1 ) ) ) ; else add ( GUIUtilities . loadMenuItem ( menuItemName ) ) ; } } } } protected String _name ; protected boolean initialized ; } 	0	['5', '7', '5', '8', '27', '8', '6', '3', '5', '0.625', '121', '1', '0', '0.995359629', '0.6', '2', '2', '22.8', '6', '1.8', '0']
package bsh ; import java . util . Hashtable ; public class Capabilities { private static boolean accessibility = false ; public static boolean haveSwing ( ) { return classExists ( "javax.swing.JButton" ) ; } public static boolean canGenerateInterfaces ( ) { return classExists ( "java.lang.reflect.Proxy" ) ; } public static boolean haveAccessibility ( ) { return ( accessibility && classExists ( "java.lang.reflect.AccessibleObject" ) && classExists ( "bsh.reflect.ReflectManagerImpl" ) ) ; } public static void setAccessibility ( boolean b ) { accessibility = b ; } private static Hashtable classes = new Hashtable ( ) ; public static boolean classExists ( String name ) { Object c = classes . get ( name ) ; if ( c == null ) { try { c = Class . forName ( name ) ; } catch ( ClassNotFoundException e ) { } if ( c != null ) classes . put ( c , "unused" ) ; } return c != null ; } public static class Unavailable extends RuntimeException { public Unavailable ( String s ) { super ( s ) ; } } } 	0	['7', '1', '0', '5', '12', '13', '5', '0', '6', '0.5', '65', '1', '0', '0', '0.166666667', '0', '0', '8', '4', '1.5714', '0']
package bsh ; import java . util . Vector ; class BSHMethodDeclaration extends SimpleNode { String name ; BSHFormalParameters params ; BSHBlock block ; Object returnType ; BSHMethodDeclaration ( int id ) { super ( id ) ; } public Object eval ( NameSpace namespace ) throws EvalError { if ( block == null ) { if ( jjtGetNumChildren ( ) == 3 ) { returnType = ( ( BSHReturnType ) jjtGetChild ( 0 ) ) . getReturnType ( namespace ) ; params = ( BSHFormalParameters ) jjtGetChild ( 1 ) ; block = ( BSHBlock ) jjtGetChild ( 2 ) ; } else { params = ( BSHFormalParameters ) jjtGetChild ( 0 ) ; block = ( BSHBlock ) jjtGetChild ( 1 ) ; } params . eval ( namespace ) ; if ( Interpreter . strictJava ) { for ( int i = 0 ; i < params . argTypes . length ; i ++ ) if ( params . argTypes [ i ] == null ) throw new EvalError ( "(Strict Java Mode) Undeclared argument type, parameter: " + params . argNames [ i ] + " in method: " + name , this ) ; if ( returnType == null ) throw new EvalError ( "(Strict Java Mode) Undeclared return type for method: " + name , this ) ; } } namespace . setMethod ( name , new BshMethod ( this , namespace ) ) ; return Primitive . VOID ; } public String toString ( ) { return "MethodDeclaration: " + name ; } } 	0	['3', '2', '0', '11', '14', '1', '2', '10', '2', '0.875', '134', '0', '2', '0.9', '0.555555556', '1', '3', '42.33333333', '1', '0.6667', '0']
package org . gjt . sp . jedit . options ; import java . awt . Dialog ; import java . awt . Frame ; import org . gjt . sp . jedit . gui . OptionsDialog ; import org . gjt . sp . jedit . options . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class GlobalOptions extends OptionsDialog { public GlobalOptions ( Frame frame ) { super ( frame , "options" , jEdit . getProperty ( "options.last" ) ) ; } public GlobalOptions ( Frame frame , String pane ) { super ( frame , "options" , pane ) ; } public GlobalOptions ( Dialog dialog ) { super ( dialog , "options" , jEdit . getProperty ( "options.last" ) ) ; } public GlobalOptions ( Dialog dialog , String pane ) { super ( dialog , "options" , pane ) ; } protected OptionTreeModel createOptionTreeModel ( ) { OptionTreeModel paneTreeModel = new OptionTreeModel ( ) ; OptionGroup rootGroup = ( OptionGroup ) paneTreeModel . getRoot ( ) ; jEditGroup = new OptionGroup ( "jedit" ) ; addOptionPane ( new AbbrevsOptionPane ( ) , jEditGroup ) ; addOptionPane ( new AppearanceOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ContextOptionPane ( ) , jEditGroup ) ; addOptionPane ( new DockingOptionPane ( ) , jEditGroup ) ; addOptionPane ( new EditingOptionPane ( ) , jEditGroup ) ; addOptionPane ( new GeneralOptionPane ( ) , jEditGroup ) ; addOptionPane ( new GutterOptionPane ( ) , jEditGroup ) ; addOptionPane ( new LoadSaveOptionPane ( ) , jEditGroup ) ; addOptionPane ( new PrintOptionPane ( ) , jEditGroup ) ; addOptionPane ( new FirewallOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ShortcutsOptionPane ( ) , jEditGroup ) ; addOptionPane ( new StatusBarOptionPane ( ) , jEditGroup ) ; addOptionPane ( new SyntaxHiliteOptionPane ( ) , jEditGroup ) ; addOptionPane ( new TextAreaOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ToolBarOptionPane ( ) , jEditGroup ) ; addOptionGroup ( jEditGroup , rootGroup ) ; browserGroup = new OptionGroup ( "browser" ) ; addOptionPane ( new BrowserColorsOptionPane ( ) , browserGroup ) ; addOptionPane ( new BrowserOptionPane ( ) , browserGroup ) ; addOptionGroup ( browserGroup , rootGroup ) ; pluginsGroup = new OptionGroup ( "plugins" ) ; EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin ep = plugins [ i ] ; try { ep . createOptionPanes ( this ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , ep , "Error creating option pane" ) ; Log . log ( Log . ERROR , ep , t ) ; } } if ( pluginsGroup . getMemberCount ( ) > 0 ) { addOptionGroup ( pluginsGroup , rootGroup ) ; } return paneTreeModel ; } protected OptionGroup getDefaultGroup ( ) { return pluginsGroup ; } private OptionGroup jEditGroup ; private OptionGroup browserGroup ; private OptionGroup pluginsGroup ; } 	0	['6', '8', '0', '27', '35', '13', '3', '24', '4', '0.933333333', '233', '1', '3', '0.997028232', '0.5', '1', '1', '37.33333333', '3', '0.6667', '0']
package org . gjt . sp . jedit . search ; import gnu . regexp . CharIndexed ; public interface SearchMatcher { int [ ] nextMatch ( CharIndexed text , boolean start , boolean end , boolean firstTime , boolean reverse ) ; String substitute ( String text ) throws Exception ; } 	0	['2', '1', '0', '5', '2', '1', '4', '1', '2', '2', '2', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package bsh ; class ParseException extends EvalError { String sourceFile = "<unknown>" ; public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { this ( ) ; specialConstructor = true ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; } public ParseException ( ) { this ( "" ) ; specialConstructor = false ; } public ParseException ( String message ) { super ( message ) ; specialConstructor = false ; } protected boolean specialConstructor ; public Token currentToken ; public int [ ] [ ] expectedTokenSequences ; public String [ ] tokenImage ; public String getMessage ( ) { return getMessage ( false ) ; } public String getMessage ( boolean debug ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } String expected = "" ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected += tokenImage [ expectedTokenSequences [ i ] [ j ] ] + " " ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected += "..." ; } expected += eol + "    " ; } String retval = "In file: " + sourceFile + " Encountered \"" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += " " ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += "\" at line " + currentToken . next . beginLine + ", column " + currentToken . next . beginColumn + "." + eol ; if ( debug ) { if ( expectedTokenSequences . length == 1 ) { retval += "Was expecting:" + eol + "    " ; } else { retval += "Was expecting one of:" + eol + "    " ; } retval += expected ; } return retval ; } protected String eol = System . getProperty ( "line.separator" , "\n" ) ; protected String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } public String getErrorText ( ) { int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) maxSize = expectedTokenSequences [ i ] . length ; } String retval = "" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += " " ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } return retval ; } public int getErrorLineNumber ( ) { return currentToken . next . beginLine ; } public String getErrorSourceFile ( ) { return sourceFile ; } public void setErrorSourceFile ( String file ) { this . sourceFile = file ; } public String toString ( ) { return getMessage ( ) ; } } 	0	['11', '4', '0', '4', '23', '23', '2', '2', '10', '0.533333333', '492', '0.333333333', '1', '0.764705882', '0.272727273', '2', '4', '43.18181818', '14', '3.2727', '0']
package bsh ; class Token implements java . io . Serializable { public int kind ; public int beginLine , beginColumn , endLine , endColumn ; public String image ; public Token next ; public Token specialToken ; public final String toString ( ) { return image ; } public static final Token newToken ( int ofKind ) { switch ( ofKind ) { default : return new Token ( ) ; } } } 	0	['3', '1', '0', '5', '4', '3', '5', '0', '2', '1.4375', '23', '0', '2', '0', '0.5', '0', '0', '4', '2', '1', '0']
package bsh ; import java . awt . event . * ; import javax . swing . * ; import javax . swing . event . * ; import java . io . * ; import java . beans . * ; class JThis extends This implements ActionListener , AdjustmentListener , ComponentListener , ContainerListener , FocusListener , ItemListener , KeyListener , MouseListener , MouseMotionListener , TextListener , WindowListener , PropertyChangeListener , AncestorListener , CaretListener , CellEditorListener , ChangeListener , DocumentListener , HyperlinkListener , InternalFrameListener , ListDataListener , ListSelectionListener , MenuDragMouseListener , MenuKeyListener , MenuListener , MouseInputListener , PopupMenuListener , TableColumnModelListener , TableModelListener , TreeExpansionListener , TreeModelListener , TreeSelectionListener , TreeWillExpandListener , UndoableEditListener { JThis ( NameSpace namespace , Interpreter declaringInterp ) { super ( namespace , declaringInterp ) ; } public String toString ( ) { return "'this' reference (JThis) to Bsh object: " + namespace . name ; } void event ( String name , Object event ) { CallStack callstack = newCallStack ( ) ; BshMethod method ; method = namespace . getMethod ( "handleEvent" , new Class [ ] { null } ) ; if ( method != null ) try { method . invokeDeclaredMethod ( new Object [ ] { event } , declaringInterpreter , callstack , null ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "local event hander method invocation error:" + e ) ; } method = namespace . getMethod ( name , new Class [ ] { null } ) ; if ( method != null ) try { method . invokeDeclaredMethod ( new Object [ ] { event } , declaringInterpreter , callstack , null ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "local event hander method invocation error:" + e ) ; } } public void ancestorAdded ( AncestorEvent e ) { event ( "ancestorAdded" , e ) ; } public void ancestorRemoved ( AncestorEvent e ) { event ( "ancestorRemoved" , e ) ; } public void ancestorMoved ( AncestorEvent e ) { event ( "ancestorMoved" , e ) ; } public void caretUpdate ( CaretEvent e ) { event ( "caretUpdate" , e ) ; } public void editingStopped ( ChangeEvent e ) { event ( "editingStopped" , e ) ; } public void editingCanceled ( ChangeEvent e ) { event ( "editingCanceled" , e ) ; } public void stateChanged ( ChangeEvent e ) { event ( "stateChanged" , e ) ; } public void insertUpdate ( DocumentEvent e ) { event ( "insertUpdate" , e ) ; } public void removeUpdate ( DocumentEvent e ) { event ( "removeUpdate" , e ) ; } public void changedUpdate ( DocumentEvent e ) { event ( "changedUpdate" , e ) ; } public void hyperlinkUpdate ( HyperlinkEvent e ) { event ( "internalFrameOpened" , e ) ; } public void internalFrameOpened ( InternalFrameEvent e ) { event ( "internalFrameOpened" , e ) ; } public void internalFrameClosing ( InternalFrameEvent e ) { event ( "internalFrameClosing" , e ) ; } public void internalFrameClosed ( InternalFrameEvent e ) { event ( "internalFrameClosed" , e ) ; } public void internalFrameIconified ( InternalFrameEvent e ) { event ( "internalFrameIconified" , e ) ; } public void internalFrameDeiconified ( InternalFrameEvent e ) { event ( "internalFrameDeiconified" , e ) ; } public void internalFrameActivated ( InternalFrameEvent e ) { event ( "internalFrameActivated" , e ) ; } public void internalFrameDeactivated ( InternalFrameEvent e ) { event ( "internalFrameDeactivated" , e ) ; } public void intervalAdded ( ListDataEvent e ) { event ( "intervalAdded" , e ) ; } public void intervalRemoved ( ListDataEvent e ) { event ( "intervalRemoved" , e ) ; } public void contentsChanged ( ListDataEvent e ) { event ( "contentsChanged" , e ) ; } public void valueChanged ( ListSelectionEvent e ) { event ( "valueChanged" , e ) ; } public void menuDragMouseEntered ( MenuDragMouseEvent e ) { event ( "menuDragMouseEntered" , e ) ; } public void menuDragMouseExited ( MenuDragMouseEvent e ) { event ( "menuDragMouseExited" , e ) ; } public void menuDragMouseDragged ( MenuDragMouseEvent e ) { event ( "menuDragMouseDragged" , e ) ; } public void menuDragMouseReleased ( MenuDragMouseEvent e ) { event ( "menuDragMouseReleased" , e ) ; } public void menuKeyTyped ( MenuKeyEvent e ) { event ( "menuKeyTyped" , e ) ; } public void menuKeyPressed ( MenuKeyEvent e ) { event ( "menuKeyPressed" , e ) ; } public void menuKeyReleased ( MenuKeyEvent e ) { event ( "menuKeyReleased" , e ) ; } public void menuSelected ( MenuEvent e ) { event ( "menuSelected" , e ) ; } public void menuDeselected ( MenuEvent e ) { event ( "menuDeselected" , e ) ; } public void menuCanceled ( MenuEvent e ) { event ( "menuCanceled" , e ) ; } public void popupMenuWillBecomeVisible ( PopupMenuEvent e ) { event ( "popupMenuWillBecomeVisible" , e ) ; } public void popupMenuWillBecomeInvisible ( PopupMenuEvent e ) { event ( "popupMenuWillBecomeInvisible" , e ) ; } public void popupMenuCanceled ( PopupMenuEvent e ) { event ( "popupMenuCanceled" , e ) ; } public void columnAdded ( TableColumnModelEvent e ) { event ( "columnAdded" , e ) ; } public void columnRemoved ( TableColumnModelEvent e ) { event ( "columnRemoved" , e ) ; } public void columnMoved ( TableColumnModelEvent e ) { event ( "columnMoved" , e ) ; } public void columnMarginChanged ( ChangeEvent e ) { event ( "columnMarginChanged" , e ) ; } public void columnSelectionChanged ( ListSelectionEvent e ) { event ( "columnSelectionChanged" , e ) ; } public void tableChanged ( TableModelEvent e ) { event ( "tableChanged" , e ) ; } public void treeExpanded ( TreeExpansionEvent e ) { event ( "treeExpanded" , e ) ; } public void treeCollapsed ( TreeExpansionEvent e ) { event ( "treeCollapsed" , e ) ; } public void treeNodesChanged ( TreeModelEvent e ) { event ( "treeNodesChanged" , e ) ; } public void treeNodesInserted ( TreeModelEvent e ) { event ( "treeNodesInserted" , e ) ; } public void treeNodesRemoved ( TreeModelEvent e ) { event ( "treeNodesRemoved" , e ) ; } public void treeStructureChanged ( TreeModelEvent e ) { event ( "treeStructureChanged" , e ) ; } public void valueChanged ( TreeSelectionEvent e ) { event ( "valueChanged" , e ) ; } public void treeWillExpand ( TreeExpansionEvent e ) { event ( "treeWillExpand" , e ) ; } public void treeWillCollapse ( TreeExpansionEvent e ) { event ( "treeWillCollapse" , e ) ; } public void undoableEditHappened ( UndoableEditEvent e ) { event ( "undoableEditHappened" , e ) ; } public void actionPerformed ( ActionEvent e ) { event ( "actionPerformed" , e ) ; } public void adjustmentValueChanged ( AdjustmentEvent e ) { event ( "adjustmentValueChanged" , e ) ; } public void componentResized ( ComponentEvent e ) { event ( "componentResized" , e ) ; } public void componentMoved ( ComponentEvent e ) { event ( "componentMoved" , e ) ; } public void componentShown ( ComponentEvent e ) { event ( "componentShown" , e ) ; } public void componentHidden ( ComponentEvent e ) { event ( "componentHidden" , e ) ; } public void componentAdded ( ContainerEvent e ) { event ( "componentAdded" , e ) ; } public void componentRemoved ( ContainerEvent e ) { event ( "componentRemoved" , e ) ; } public void focusGained ( FocusEvent e ) { event ( "focusGained" , e ) ; } public void focusLost ( FocusEvent e ) { event ( "focusLost" , e ) ; } public void itemStateChanged ( ItemEvent e ) { event ( "itemStateChanged" , e ) ; } public void keyTyped ( KeyEvent e ) { event ( "keyTyped" , e ) ; } public void keyPressed ( KeyEvent e ) { event ( "keyPressed" , e ) ; } public void keyReleased ( KeyEvent e ) { event ( "keyReleased" , e ) ; } public void mouseClicked ( MouseEvent e ) { event ( "mouseClicked" , e ) ; } public void mousePressed ( MouseEvent e ) { event ( "mousePressed" , e ) ; } public void mouseReleased ( MouseEvent e ) { event ( "mouseReleased" , e ) ; } public void mouseEntered ( MouseEvent e ) { event ( "mouseEntered" , e ) ; } public void mouseExited ( MouseEvent e ) { event ( "mouseExited" , e ) ; } public void mouseDragged ( MouseEvent e ) { event ( "mouseDragged" , e ) ; } public void mouseMoved ( MouseEvent e ) { event ( "mouseMoved" , e ) ; } public void textValueChanged ( TextEvent e ) { event ( "textValueChanged" , e ) ; } public void windowOpened ( WindowEvent e ) { event ( "windowOpened" , e ) ; } public void windowClosing ( WindowEvent e ) { event ( "windowClosing" , e ) ; } public void windowClosed ( WindowEvent e ) { event ( "windowClosed" , e ) ; } public void windowIconified ( WindowEvent e ) { event ( "windowIconified" , e ) ; } public void windowDeiconified ( WindowEvent e ) { event ( "windowDeiconified" , e ) ; } public void windowActivated ( WindowEvent e ) { event ( "windowActivated" , e ) ; } public void windowDeactivated ( WindowEvent e ) { event ( "windowDeactivated" , e ) ; } public void propertyChange ( PropertyChangeEvent e ) { event ( "propertyChange" , e ) ; } public void vetoableChange ( PropertyChangeEvent e ) { event ( "vetoableChange" , e ) ; } public boolean imageUpdate ( java . awt . Image img , int infoflags , int x , int y , int width , int height ) { BshMethod method = namespace . getMethod ( "imageUpdate" , new Class [ ] { null , null , null , null , null , null } ) ; if ( method != null ) try { CallStack callstack = newCallStack ( ) ; method . invokeDeclaredMethod ( new Object [ ] { img , new Primitive ( infoflags ) , new Primitive ( x ) , new Primitive ( y ) , new Primitive ( width ) , new Primitive ( height ) } , declaringInterpreter , callstack , null ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "local event handler imageUpdate: method invocation error:" + e ) ; } return true ; } } 	0	['86', '2', '0', '8', '96', '3649', '0', '8', '84', '2', '696', '0', '0', '0.105263158', '0.05620155', '0', '0', '7.093023256', '3', '1.0233', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBMessage ; import org . gjt . sp . jedit . View ; public class EditorExitRequested extends EBMessage { public EditorExitRequested ( View view ) { super ( view ) ; } public View getView ( ) { return ( View ) getSource ( ) ; } } 	0	['2', '2', '0', '4', '4', '1', '1', '3', '2', '2', '10', '0', '0', '0.75', '0.75', '0', '0', '4', '1', '0.5', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . io . File ; import org . gjt . sp . jedit . browser . * ; import org . gjt . sp . jedit . io . FileVFS ; import org . gjt . sp . jedit . * ; public class DirectoryMenu extends EnhancedMenu { public DirectoryMenu ( String name , String dir ) { super ( name ) ; this . dir = dir ; } public void menuSelected ( MenuEvent evt ) { super . menuSelected ( evt ) ; final View view = GUIUtilities . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) removeAll ( ) ; final String path ; if ( dir == null ) { path = view . getBuffer ( ) . getDirectory ( ) ; } else path = dir ; JMenuItem mi = new JMenuItem ( path + ":" ) ; mi . setActionCommand ( path ) ; mi . setIcon ( FileCellRenderer . openDirIcon ) ; ActionListener fileListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { jEdit . openFile ( view , evt . getActionCommand ( ) ) ; } } ; ActionListener dirListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { VFSBrowser . browseDirectory ( view , evt . getActionCommand ( ) ) ; } } ; mi . addActionListener ( dirListener ) ; add ( mi ) ; addSeparator ( ) ; if ( dir == null && ! ( view . getBuffer ( ) . getVFS ( ) instanceof FileVFS ) ) { mi = new JMenuItem ( jEdit . getProperty ( "directory.not-local" ) ) ; mi . setEnabled ( false ) ; add ( mi ) ; return ; } File directory = new File ( path ) ; JMenu current = this ; String backupPrefix = jEdit . getProperty ( "backup.prefix" ) ; String backupSuffix = jEdit . getProperty ( "backup.suffix" ) ; File [ ] list = directory . listFiles ( ) ; if ( list == null || list . length == 0 ) { mi = new JMenuItem ( jEdit . getProperty ( "directory.no-files" ) ) ; mi . setEnabled ( false ) ; add ( mi ) ; } else { int maxItems = jEdit . getIntegerProperty ( "menu.spillover" , 20 ) ; MiscUtilities . quicksort ( list , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File file = list [ i ] ; String name = file . getName ( ) ; if ( name . endsWith ( ".marks" ) ) continue ; if ( name . startsWith ( "#" ) && name . endsWith ( "#" ) ) continue ; if ( ( backupPrefix . length ( ) != 0 && name . startsWith ( backupPrefix ) ) || ( backupSuffix . length ( ) != 0 && name . endsWith ( backupSuffix ) ) ) continue ; mi = new JMenuItem ( name ) ; mi . setActionCommand ( file . getPath ( ) ) ; mi . addActionListener ( file . isDirectory ( ) ? dirListener : fileListener ) ; mi . setIcon ( file . isDirectory ( ) ? FileCellRenderer . dirIcon : FileCellRenderer . fileIcon ) ; if ( current . getItemCount ( ) >= maxItems && i != list . length - 1 ) { JMenu newCurrent = new JMenu ( jEdit . getProperty ( "common.more" ) ) ; current . add ( newCurrent ) ; current = newCurrent ; } current . add ( mi ) ; } } } public void menuDeselected ( MenuEvent e ) { } public void menuCanceled ( MenuEvent e ) { } private String dir ; } 	0	['4', '8', '0', '13', '39', '4', '3', '13', '4', '0.666666667', '237', '1', '0', '0.996515679', '0.666666667', '0', '0', '58', '19', '5.25', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . GUIUtilities ; import org . gjt . sp . jedit . OperatingSystem ; public class ColorWellButton extends JButton { public ColorWellButton ( Color color ) { setIcon ( new ColorWell ( color ) ) ; setMargin ( new Insets ( 2 , 2 , 2 , 2 ) ) ; addActionListener ( new ActionHandler ( ) ) ; if ( OperatingSystem . isMacOSLF ( ) ) putClientProperty ( "JButton.buttonType" , "toolbar" ) ; } public Color getSelectedColor ( ) { return ( ( ColorWell ) getIcon ( ) ) . color ; } public void setSelectedColor ( Color color ) { ( ( ColorWell ) getIcon ( ) ) . color = color ; repaint ( ) ; } static class ColorWell implements Icon { Color color ; ColorWell ( Color color ) { this . color = color ; } public int getIconWidth ( ) { return 35 ; } public int getIconHeight ( ) { return 10 ; } public void paintIcon ( Component c , Graphics g , int x , int y ) { if ( color == null ) return ; g . setColor ( color ) ; g . fillRect ( x , y , getIconWidth ( ) , getIconHeight ( ) ) ; g . setColor ( color . darker ( ) ) ; g . drawRect ( x , y , getIconWidth ( ) - 1 , getIconHeight ( ) - 1 ) ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { JDialog parent = GUIUtilities . getParentDialog ( ColorWellButton . this ) ; JDialog dialog ; if ( parent != null ) { dialog = new ColorPickerDialog ( parent , jEdit . getProperty ( "colorChooser.title" ) , true ) ; } else { dialog = new ColorPickerDialog ( JOptionPane . getFrameForComponent ( ColorWellButton . this ) , jEdit . getProperty ( "colorChooser.title" ) , true ) ; } dialog . pack ( ) ; dialog . show ( ) ; } } private class ColorPickerDialog extends EnhancedDialog implements ActionListener { public ColorPickerDialog ( Frame parent , String title , boolean modal ) { super ( parent , title , modal ) ; init ( ) ; } public ColorPickerDialog ( Dialog parent , String title , boolean modal ) { super ( parent , title , modal ) ; getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; init ( ) ; } public void ok ( ) { Color c = chooser . getColor ( ) ; if ( c != null ) setSelectedColor ( c ) ; setVisible ( false ) ; } public void cancel ( ) { setVisible ( false ) ; } public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) ok ( ) ; else cancel ( ) ; } private JColorChooser chooser ; private JButton ok ; private JButton cancel ; private void init ( ) { Color c = getSelectedColor ( ) ; if ( c == null ) chooser = new JColorChooser ( ) ; else chooser = new JColorChooser ( c ) ; getContentPane ( ) . add ( BorderLayout . CENTER , chooser ) ; Box buttons = new Box ( BoxLayout . X_AXIS ) ; buttons . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( this ) ; buttons . add ( ok ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( this ) ; buttons . add ( cancel ) ; buttons . add ( Box . createGlue ( ) ) ; getContentPane ( ) . add ( BorderLayout . SOUTH , buttons ) ; pack ( ) ; setLocationRelativeTo ( getParent ( ) ) ; } } } 	0	['3', '6', '0', '8', '14', '3', '6', '3', '3', '2', '46', '0', '0', '0.997382199', '0.833333333', '0', '0', '14.33333333', '1', '0.6667', '0']
package bsh ; class BSHArguments extends SimpleNode { BSHArguments ( int id ) { super ( id ) ; } public Object [ ] getArguments ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object [ ] args = new Object [ jjtGetNumChildren ( ) ] ; for ( int i = 0 ; i < args . length ; i ++ ) args [ i ] = ( ( SimpleNode ) jjtGetChild ( i ) ) . eval ( callstack , interpreter ) ; return args ; } } 	0	['2', '2', '0', '10', '6', '1', '5', '5', '1', '2', '30', '0', '0', '0.947368421', '0.625', '0', '0', '14', '1', '0.5', '0']
package org . gjt . sp . jedit . pluginmgr ; import com . microstar . xml . * ; import java . io . * ; import java . net . URL ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . GZIPInputStream ; import org . gjt . sp . util . Log ; import org . gjt . sp . jedit . * ; class PluginList { Vector plugins ; Hashtable pluginHash ; Vector pluginSets ; PluginList ( ) throws Exception { plugins = new Vector ( ) ; pluginHash = new Hashtable ( ) ; pluginSets = new Vector ( ) ; String path = jEdit . getProperty ( "plugin-manager.url" ) ; PluginListHandler handler = new PluginListHandler ( this , path ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( handler ) ; parser . parse ( null , null , new BufferedReader ( new InputStreamReader ( new GZIPInputStream ( new URL ( path ) . openStream ( ) ) , "UTF8" ) ) ) ; } void addPlugin ( Plugin plugin ) { plugin . checkIfInstalled ( ) ; plugins . addElement ( plugin ) ; pluginHash . put ( plugin . name , plugin ) ; } void addPluginSet ( PluginSet set ) { pluginSets . addElement ( set ) ; } void finished ( ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { Plugin plugin = ( Plugin ) plugins . elementAt ( i ) ; for ( int j = 0 ; j < plugin . branches . size ( ) ; j ++ ) { Branch branch = ( Branch ) plugin . branches . elementAt ( j ) ; for ( int k = 0 ; k < branch . deps . size ( ) ; k ++ ) { Dependency dep = ( Dependency ) branch . deps . elementAt ( k ) ; if ( dep . what . equals ( "plugin" ) ) dep . plugin = ( Plugin ) pluginHash . get ( dep . pluginName ) ; } } } } void dump ( ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { System . err . println ( ( Plugin ) plugins . elementAt ( i ) ) ; System . err . println ( ) ; } } static class PluginSet { String name ; String description ; Vector plugins = new Vector ( ) ; public String toString ( ) { return plugins . toString ( ) ; } } static class Plugin { String jar ; String name ; String description ; String author ; Vector branches = new Vector ( ) ; String installed ; String installedVersion ; void checkIfInstalled ( ) { EditPlugin . JAR [ ] jars = jEdit . getPluginJARs ( ) ; for ( int i = 0 ; i < jars . length ; i ++ ) { String path = jars [ i ] . getPath ( ) ; if ( ! new File ( path ) . exists ( ) ) continue ; if ( MiscUtilities . getFileName ( path ) . equals ( jar ) ) { installed = path ; EditPlugin [ ] plugins = jars [ i ] . getPlugins ( ) ; if ( plugins . length >= 1 ) { installedVersion = jEdit . getProperty ( "plugin." + plugins [ 0 ] . getClassName ( ) + ".version" ) ; } break ; } } String [ ] notLoaded = jEdit . getNotLoadedPluginJARs ( ) ; for ( int i = 0 ; i < notLoaded . length ; i ++ ) { String path = notLoaded [ i ] ; if ( MiscUtilities . getFileName ( path ) . equals ( jar ) ) { installed = path ; break ; } } } Branch getCompatibleBranch ( ) { for ( int i = 0 ; i < branches . size ( ) ; i ++ ) { Branch branch = ( Branch ) branches . elementAt ( i ) ; if ( branch . canSatisfyDependencies ( ) ) return branch ; } return null ; } boolean canBeInstalled ( ) { Branch branch = getCompatibleBranch ( ) ; return branch != null && ! branch . obsolete && branch . canSatisfyDependencies ( ) ; } void install ( Roster roster , String installDirectory , boolean downloadSource ) { if ( installed != null ) roster . addOperation ( new Roster . Remove ( installed ) ) ; Branch branch = getCompatibleBranch ( ) ; if ( branch . obsolete ) return ; branch . satisfyDependencies ( roster , installDirectory , downloadSource ) ; if ( installed != null ) { installDirectory = MiscUtilities . getParentOfPath ( installed ) ; } roster . addOperation ( new Roster . Install ( ( downloadSource ? branch . downloadSource : branch . download ) , installDirectory , ( downloadSource ? branch . downloadSourceSize : branch . downloadSize ) ) ) ; } public String toString ( ) { return name ; } } static class Branch { String version ; String date ; int downloadSize ; String download ; int downloadSourceSize ; String downloadSource ; boolean obsolete ; Vector deps = new Vector ( ) ; boolean canSatisfyDependencies ( ) { for ( int i = 0 ; i < deps . size ( ) ; i ++ ) { Dependency dep = ( Dependency ) deps . elementAt ( i ) ; if ( ! dep . canSatisfy ( ) ) return false ; } return true ; } void satisfyDependencies ( Roster roster , String installDirectory , boolean downloadSource ) { for ( int i = 0 ; i < deps . size ( ) ; i ++ ) { Dependency dep = ( Dependency ) deps . elementAt ( i ) ; dep . satisfy ( roster , installDirectory , downloadSource ) ; } } public String toString ( ) { return "[version=" + version + ",download=" + download + ",obsolete=" + obsolete + ",deps=" + deps + "]" ; } } static class Dependency { String what ; String from ; String to ; String pluginName ; Plugin plugin ; Dependency ( String what , String from , String to , String pluginName ) { this . what = what ; this . from = from ; this . to = to ; this . pluginName = pluginName ; } boolean isSatisfied ( ) { if ( what . equals ( "plugin" ) ) { for ( int i = 0 ; i < plugin . branches . size ( ) ; i ++ ) { if ( plugin . installedVersion != null && ( from == null || MiscUtilities . compareStrings ( plugin . installedVersion , from , false ) >= 0 ) && ( to == null || MiscUtilities . compareStrings ( plugin . installedVersion , to , false ) <= 0 ) ) { return true ; } } return false ; } else if ( what . equals ( "jdk" ) ) { String javaVersion = System . getProperty ( "java.version" ) . substring ( 0 , 3 ) ; if ( ( from == null || MiscUtilities . compareStrings ( javaVersion , from , false ) >= 0 ) && ( to == null || MiscUtilities . compareStrings ( javaVersion , to , false ) <= 0 ) ) return true ; else return false ; } else if ( what . equals ( "jedit" ) ) { String build = jEdit . getBuild ( ) ; if ( ( from == null || MiscUtilities . compareStrings ( build , from , false ) >= 0 ) && ( to == null || MiscUtilities . compareStrings ( build , to , false ) <= 0 ) ) return true ; else return false ; } else { Log . log ( Log . ERROR , this , "Invalid dependency: " + what ) ; return false ; } } boolean canSatisfy ( ) { if ( isSatisfied ( ) ) return true ; else if ( what . equals ( "plugin" ) ) { return plugin . canBeInstalled ( ) ; } else return false ; } void satisfy ( Roster roster , String installDirectory , boolean downloadSource ) { if ( what . equals ( "plugin" ) ) { for ( int i = 0 ; i < plugin . branches . size ( ) ; i ++ ) { Branch branch = ( Branch ) plugin . branches . elementAt ( i ) ; if ( ( plugin . installedVersion == null || MiscUtilities . compareStrings ( plugin . installedVersion , branch . version , false ) < 0 ) && ( from == null || MiscUtilities . compareStrings ( branch . version , from , false ) >= 0 ) && ( to == null || MiscUtilities . compareStrings ( branch . version , to , false ) <= 0 ) ) { plugin . install ( roster , installDirectory , downloadSource ) ; return ; } } } } public String toString ( ) { return "[what=" + what + ",from=" + from + ",to=" + to + ",plugin=" + plugin + "]" ; } } } 	0	['5', '1', '0', '12', '27', '0', '5', '8', '0', '0.5', '158', '0', '0', '0', '0.466666667', '0', '0', '30', '5', '1.8', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class AbbrevEditor extends JPanel { public AbbrevEditor ( ) { GridBagLayout layout = new GridBagLayout ( ) ; setLayout ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . anchor = cons . WEST ; cons . fill = cons . BOTH ; cons . weightx = 0.0f ; cons . gridx = 1 ; cons . gridy = 1 ; JLabel label = new JLabel ( jEdit . getProperty ( "abbrev-editor.abbrev" ) , SwingConstants . RIGHT ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; layout . setConstraints ( label , cons ) ; add ( label ) ; cons . gridx ++ ; cons . weightx = 1.0f ; abbrev = new JTextField ( ) ; layout . setConstraints ( abbrev , cons ) ; add ( abbrev ) ; cons . gridx = 1 ; cons . weightx = 0.0f ; cons . gridwidth = 2 ; cons . gridy ++ ; label = new JLabel ( jEdit . getProperty ( "abbrev-editor.before" ) ) ; label . setBorder ( new EmptyBorder ( 6 , 0 , 3 , 0 ) ) ; layout . setConstraints ( label , cons ) ; add ( label ) ; cons . gridy ++ ; cons . weighty = 1.0f ; beforeCaret = new JTextArea ( 4 , 40 ) ; JScrollPane scroller = new JScrollPane ( beforeCaret ) ; layout . setConstraints ( scroller , cons ) ; add ( scroller ) ; cons . gridy ++ ; cons . weighty = 0.0f ; label = new JLabel ( jEdit . getProperty ( "abbrev-editor.after" ) ) ; label . setBorder ( new EmptyBorder ( 6 , 0 , 3 , 0 ) ) ; layout . setConstraints ( label , cons ) ; add ( label ) ; cons . gridy ++ ; cons . weighty = 1.0f ; afterCaret = new JTextArea ( 4 , 40 ) ; scroller = new JScrollPane ( afterCaret ) ; layout . setConstraints ( scroller , cons ) ; add ( scroller ) ; } public String getAbbrev ( ) { return abbrev . getText ( ) ; } public void setAbbrev ( String abbrev ) { this . abbrev . setText ( abbrev ) ; } public String getExpansion ( ) { StringBuffer buf = new StringBuffer ( ) ; String beforeCaretText = beforeCaret . getText ( ) ; String afterCaretText = afterCaret . getText ( ) ; for ( int i = 0 ; i < beforeCaretText . length ( ) ; i ++ ) { char ch = beforeCaretText . charAt ( i ) ; switch ( ch ) { case '\n' : buf . append ( "\\n" ) ; break ; case '\t' : buf . append ( "\\t" ) ; break ; case '\\' : buf . append ( "\\\\" ) ; break ; default : buf . append ( ch ) ; break ; } } if ( afterCaretText . length ( ) != 0 ) { buf . append ( "\\|" ) ; for ( int i = 0 ; i < afterCaretText . length ( ) ; i ++ ) { char ch = afterCaretText . charAt ( i ) ; switch ( ch ) { case '\n' : buf . append ( "\\n" ) ; break ; case '\t' : buf . append ( "\\t" ) ; break ; case '\\' : buf . append ( "\\\\" ) ; break ; default : buf . append ( ch ) ; break ; } } } return buf . toString ( ) ; } public void setExpansion ( String expansion ) { if ( expansion == null ) { beforeCaret . setText ( null ) ; afterCaret . setText ( null ) ; return ; } String beforeCaretText = null ; String afterCaretText = null ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < expansion . length ( ) ; i ++ ) { char ch = expansion . charAt ( i ) ; if ( ch == '\\' && i != expansion . length ( ) - 1 ) { ch = expansion . charAt ( ++ i ) ; switch ( ch ) { case 't' : buf . append ( '\t' ) ; break ; case 'n' : buf . append ( '\n' ) ; break ; case '|' : beforeCaretText = buf . toString ( ) ; buf . setLength ( 0 ) ; break ; default : buf . append ( ch ) ; break ; } } else buf . append ( ch ) ; } if ( beforeCaretText == null ) beforeCaretText = buf . toString ( ) ; else afterCaretText = buf . toString ( ) ; beforeCaret . setText ( beforeCaretText ) ; afterCaret . setText ( afterCaretText ) ; } public JTextField getAbbrevField ( ) { return abbrev ; } public JTextArea getBeforeCaretTextArea ( ) { return beforeCaret ; } public JTextArea getAfterCaretTextArea ( ) { return afterCaret ; } private JTextField abbrev ; private JTextArea beforeCaret , afterCaret ; } 	0	['8', '5', '0', '5', '33', '0', '4', '1', '8', '0.571428571', '419', '1', '0', '0.989393939', '0.625', '0', '0', '51', '12', '3.375', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . EditAction ; import org . gjt . sp . jedit . GUIUtilities ; public class EnhancedButton extends RolloverButton { public EnhancedButton ( Icon icon , String toolTip , EditAction action ) { super ( icon ) ; this . action = action ; if ( action != null ) { setEnabled ( true ) ; addActionListener ( new EditAction . Wrapper ( action ) ) ; addMouseListener ( new MouseHandler ( ) ) ; } else setEnabled ( false ) ; setToolTipText ( toolTip ) ; } public boolean isFocusTraversable ( ) { return false ; } private EditAction action ; class MouseHandler extends MouseAdapter { public void mouseEntered ( MouseEvent evt ) { String msg = action . getMouseOverText ( ) ; if ( msg != null ) { GUIUtilities . getView ( ( Component ) evt . getSource ( ) ) . getStatus ( ) . setMessage ( msg ) ; } } public void mouseExited ( MouseEvent evt ) { GUIUtilities . getView ( ( Component ) evt . getSource ( ) ) . getStatus ( ) . setMessage ( null ) ; } } } 	0	['3', '7', '0', '5', '10', '1', '2', '4', '2', '0.5', '40', '1', '1', '0.99739922', '0.4', '1', '1', '12', '1', '0.6667', '0']
package org . gjt . sp . jedit . print ; import javax . print . attribute . * ; import javax . print . attribute . standard . * ; import java . awt . print . * ; import java . awt . * ; import java . io . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; import org . gjt . sp . jedit . io . VFSManager ; public class BufferPrinter1_4 { private static PrinterJob getPrintJob ( String jobName ) { job = PrinterJob . getPrinterJob ( ) ; format = new HashPrintRequestAttributeSet ( ) ; String settings = jEdit . getSettingsDirectory ( ) ; if ( settings != null ) { String printSpecPath = MiscUtilities . constructPath ( settings , "printspec" ) ; File filePrintSpec = new File ( printSpecPath ) ; if ( filePrintSpec . exists ( ) ) { try { FileInputStream fileIn = new FileInputStream ( filePrintSpec ) ; ObjectInputStream obIn = new ObjectInputStream ( fileIn ) ; format = ( HashPrintRequestAttributeSet ) obIn . readObject ( ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , BufferPrinter1_4 . class , e ) ; } if ( jEdit . getBooleanProperty ( "print.color" ) ) format . add ( Chromaticity . COLOR ) ; else format . add ( Chromaticity . MONOCHROME ) ; format . add ( new JobName ( jobName , null ) ) ; } } return job ; } public static void pageSetup ( View view ) { PrinterJob prnJob = getPrintJob ( "PageSetupOnly" ) ; if ( prnJob . pageDialog ( format ) != null ) savePrintSpec ( ) ; } public static void print ( final View view , final Buffer buffer , boolean selection ) { job = getPrintJob ( buffer . getPath ( ) ) ; boolean header = jEdit . getBooleanProperty ( "print.header" ) ; boolean footer = jEdit . getBooleanProperty ( "print.footer" ) ; boolean lineNumbers = jEdit . getBooleanProperty ( "print.lineNumbers" ) ; boolean color = jEdit . getBooleanProperty ( "print.color" ) ; Font font = jEdit . getFontProperty ( "print.font" ) ; BufferPrintable printable = new BufferPrintable ( job , format , view , buffer , font , header , footer , lineNumbers , color ) ; job . setPrintable ( printable ) ; if ( ! job . printDialog ( format ) ) return ; savePrintSpec ( ) ; VFSManager . runInWorkThread ( printable ) ; } public static PageFormat getPageFormat ( ) { PrinterJob prnJob = getPrintJob ( " " ) ; PageFormat pf = prnJob . defaultPage ( ) ; Paper pap = pf . getPaper ( ) ; MediaSizeName media = ( MediaSizeName ) format . get ( Media . class ) ; MediaSize ms = MediaSize . getMediaSizeForName ( media ) ; MediaPrintableArea mediaarea = ( MediaPrintableArea ) format . get ( MediaPrintableArea . class ) ; if ( mediaarea != null ) pap . setImageableArea ( ( double ) ( mediaarea . getX ( MediaPrintableArea . INCH ) * 72 ) , ( double ) ( mediaarea . getY ( MediaPrintableArea . INCH ) * 72 ) , ( double ) ( mediaarea . getWidth ( MediaPrintableArea . INCH ) * 72 ) , ( double ) ( mediaarea . getHeight ( MediaPrintableArea . INCH ) * 72 ) ) ; if ( ms != null ) pap . setSize ( ( double ) ( ms . getX ( MediaSize . INCH ) * 72 ) , ( double ) ( ms . getY ( MediaSize . INCH ) * 72 ) ) ; pf . setPaper ( pap ) ; OrientationRequested orientation = ( OrientationRequested ) format . get ( OrientationRequested . class ) ; if ( orientation != null ) { if ( orientation . getValue ( ) == OrientationRequested . LANDSCAPE . getValue ( ) ) { pf . setOrientation ( PageFormat . LANDSCAPE ) ; } else if ( orientation . getValue ( ) == OrientationRequested . REVERSE_LANDSCAPE . getValue ( ) ) { pf . setOrientation ( PageFormat . REVERSE_LANDSCAPE ) ; } else if ( orientation . getValue ( ) == OrientationRequested . PORTRAIT . getValue ( ) ) { pf . setOrientation ( PageFormat . PORTRAIT ) ; } else if ( orientation . getValue ( ) == OrientationRequested . REVERSE_PORTRAIT . getValue ( ) ) { pf . setOrientation ( PageFormat . PORTRAIT ) ; } } return pf ; } private static void savePrintSpec ( ) { String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) return ; String printSpecPath = MiscUtilities . constructPath ( settings , "printspec" ) ; File filePrintSpec = new File ( printSpecPath ) ; try { FileOutputStream fileOut = new FileOutputStream ( filePrintSpec ) ; ObjectOutputStream obOut = new ObjectOutputStream ( fileOut ) ; obOut . writeObject ( format ) ; Chromaticity cc = ( Chromaticity ) format . get ( Chromaticity . class ) ; if ( cc != null ) jEdit . setBooleanProperty ( "print.color" , cc . getValue ( ) == Chromaticity . COLOR . getValue ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private static PrintRequestAttributeSet format ; private static PrinterJob job ; } 	0	['7', '1', '0', '7', '52', '1', '0', '7', '4', '0.714285714', '343', '0.285714286', '0', '0', '0.2', '0', '0', '47', '11', '3.5714', '0']
package bsh ; class ReflectError extends Exception { public ReflectError ( ) { super ( ) ; } public ReflectError ( String s ) { super ( s ) ; } } 	0	['2', '3', '0', '7', '4', '1', '7', '0', '2', '2', '9', '0', '0', '1', '0.75', '0', '0', '3.5', '0', '0', '0']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import java . io . * ; import java . util . Stack ; import org . gjt . sp . util . Log ; class ActionListHandler extends HandlerBase { ActionListHandler ( String path , ActionSet actionSet ) { this . path = path ; this . actionSet = actionSet ; stateStack = new Stack ( ) ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "actions.dtd" . equals ( systemId ) ) { return new StringReader ( "<!-- -->" ) ; } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { aname = ( aname == null ) ? null : aname . intern ( ) ; value = ( value == null ) ? null : value . intern ( ) ; if ( aname == "NAME" ) actionName = value ; else if ( aname == "NO_REPEAT" ) noRepeat = ( value == "TRUE" ) ; else if ( aname == "NO_RECORD" ) noRecord = ( value == "TRUE" ) ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "ACTIONS" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , path + ": DOCTYPE must be ACTIONS" ) ; } public void charData ( char [ ] c , int off , int len ) { String tag = peekElement ( ) ; String text = new String ( c , off , len ) ; if ( tag == "CODE" ) { code = text ; } else if ( tag == "IS_SELECTED" ) { isSelected = text ; } } public void startElement ( String tag ) { tag = pushElement ( tag ) ; if ( tag == "ACTION" ) { code = null ; isSelected = null ; } } public void endElement ( String name ) { if ( name == null ) return ; String tag = peekElement ( ) ; if ( name . equals ( tag ) ) { if ( tag == "ACTION" ) { actionSet . addAction ( new BeanShellAction ( actionName , code , isSelected , noRepeat , noRecord ) ) ; noRepeat = noRecord = false ; } popElement ( ) ; } else { throw new InternalError ( ) ; } } public void startDocument ( ) { try { pushElement ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private String path ; private ActionSet actionSet ; private String actionName ; private String code ; private String isSelected ; private boolean noRepeat ; private boolean noRecord ; private Stack stateStack ; private String pushElement ( String name ) { name = ( name == null ) ? null : name . intern ( ) ; stateStack . push ( name ) ; return name ; } private String peekElement ( ) { return ( String ) stateStack . peek ( ) ; } private String popElement ( ) { return ( String ) stateStack . pop ( ) ; } } 	0	['11', '2', '0', '6', '28', '31', '1', '5', '7', '0.8', '223', '1', '1', '0.565217391', '0.333333333', '1', '3', '18.54545455', '8', '2.2727', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . * ; public class MarkersMenu extends EnhancedMenu { public MarkersMenu ( ) { super ( "markers" ) ; } public void menuSelected ( MenuEvent evt ) { super . menuSelected ( evt ) ; final View view = GUIUtilities . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) { for ( int i = getMenuComponentCount ( ) - 1 ; i >= 0 ; i -- ) { Component comp = getMenuComponent ( i ) ; if ( comp instanceof JSeparator ) break ; else remove ( comp ) ; } } Buffer buffer = view . getBuffer ( ) ; Vector markers = buffer . getMarkers ( ) ; if ( markers . size ( ) == 0 ) { JMenuItem mi = new JMenuItem ( jEdit . getProperty ( "no-markers.label" ) ) ; mi . setEnabled ( false ) ; add ( mi ) ; return ; } int maxItems = jEdit . getIntegerProperty ( "menu.spillover" , 20 ) ; JMenu current = this ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { final Marker marker = ( Marker ) markers . elementAt ( i ) ; int lineNo = buffer . getLineOfOffset ( marker . getPosition ( ) ) ; if ( current . getItemCount ( ) >= maxItems && i != markers . size ( ) - 1 ) { JMenu newCurrent = new JMenu ( jEdit . getProperty ( "common.more" ) ) ; current . add ( newCurrent ) ; current = newCurrent ; } JMenuItem mi = new MarkersMenuItem ( buffer , lineNo , marker . getShortcut ( ) ) ; mi . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { view . getTextArea ( ) . setCaretPosition ( marker . getPosition ( ) ) ; } } ) ; current . add ( mi ) ; } } public void menuDeselected ( MenuEvent e ) { } public void menuCanceled ( MenuEvent e ) { } static class MarkersMenuItem extends JMenuItem { MarkersMenuItem ( Buffer buffer , int lineNo , char shortcut ) { String text = buffer . getLineText ( lineNo ) . trim ( ) ; if ( text . length ( ) == 0 ) text = jEdit . getProperty ( "markers.blank-line" ) ; setText ( ( lineNo + 1 ) + ": " + text ) ; shortcutProp = "goto-marker.shortcut" ; MarkersMenuItem . this . shortcut = shortcut ; } public Dimension getPreferredSize ( ) { Dimension d = super . getPreferredSize ( ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { d . width += ( getFontMetrics ( acceleratorFont ) . stringWidth ( shortcut ) + 15 ) ; } return d ; } public void paint ( Graphics g ) { super . paint ( g ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { g . setFont ( acceleratorFont ) ; g . setColor ( getModel ( ) . isArmed ( ) ? acceleratorSelectionForeground : acceleratorForeground ) ; FontMetrics fm = g . getFontMetrics ( ) ; Insets insets = getInsets ( ) ; g . drawString ( shortcut , getWidth ( ) - ( fm . stringWidth ( shortcut ) + insets . right + insets . left + 5 ) , getFont ( ) . getSize ( ) + ( insets . top - 1 ) ) ; } } private String shortcutProp ; private char shortcut ; private static Font acceleratorFont ; private static Color acceleratorForeground ; private static Color acceleratorSelectionForeground ; private String getShortcut ( ) { if ( shortcut == '\0' ) return null ; else { String shortcutPrefix = jEdit . getProperty ( shortcutProp ) ; if ( shortcutPrefix == null ) return null ; else { return shortcutPrefix + " " + shortcut ; } } } static { acceleratorFont = UIManager . getFont ( "MenuItem.acceleratorFont" ) ; acceleratorFont = new Font ( "Monospaced" , acceleratorFont . getStyle ( ) , acceleratorFont . getSize ( ) ) ; acceleratorForeground = UIManager . getColor ( "MenuItem.acceleratorForeground" ) ; acceleratorSelectionForeground = UIManager . getColor ( "MenuItem.acceleratorSelectionForeground" ) ; } } } 	0	['4', '8', '0', '8', '28', '6', '2', '8', '4', '2', '129', '0', '0', '0.996515679', '0.875', '0', '0', '31.25', '8', '2.5', '0']
package bsh ; class BSHStatementExpressionList extends SimpleNode { BSHStatementExpressionList ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int n = jjtGetNumChildren ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SimpleNode node = ( ( SimpleNode ) jjtGetChild ( i ) ) ; node . eval ( callstack , interpreter ) ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '7', '6', '1', '1', '6', '1', '2', '28', '0', '0', '0.947368421', '0.625', '1', '1', '13', '1', '0.5', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . Border ; import javax . swing . border . AbstractBorder ; import javax . swing . border . CompoundBorder ; import javax . swing . event . MouseInputAdapter ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . * ; public class HistoryTextField extends JTextField { public HistoryTextField ( ) { this ( null ) ; } public HistoryTextField ( String name ) { this ( name , false , true ) ; } public HistoryTextField ( String name , boolean instantPopups ) { this ( name , instantPopups , true ) ; } public HistoryTextField ( String name , boolean instantPopups , boolean enterAddsToHistory ) { setBorder ( new CompoundBorder ( getBorder ( ) , new HistoryBorder ( ) ) ) ; if ( name != null ) historyModel = HistoryModel . getModel ( name ) ; MouseHandler mouseHandler = new MouseHandler ( ) ; addMouseListener ( mouseHandler ) ; addMouseMotionListener ( mouseHandler ) ; this . instantPopups = instantPopups ; this . enterAddsToHistory = enterAddsToHistory ; index = - 1 ; } public void setInstantPopups ( boolean instantPopups ) { this . instantPopups = instantPopups ; } public boolean getInstantPopups ( ) { return instantPopups ; } public void setEnterAddsToHistory ( boolean enterAddsToHistory ) { this . enterAddsToHistory = enterAddsToHistory ; } public boolean setEnterAddsToHistory ( ) { return enterAddsToHistory ; } public void setSelectAllOnFocus ( boolean selectAllOnFocus ) { this . selectAllOnFocus = selectAllOnFocus ; } public boolean setSelectAllOnFocus ( ) { return selectAllOnFocus ; } public void setModel ( String name ) { if ( name == null ) historyModel = null ; else historyModel = HistoryModel . getModel ( name ) ; index = - 1 ; repaint ( ) ; } public void addCurrentToHistory ( ) { if ( historyModel != null ) historyModel . addItem ( getText ( ) ) ; index = 0 ; } public void setText ( String text ) { super . setText ( text ) ; index = - 1 ; } public HistoryModel getModel ( ) { return historyModel ; } public void fireActionPerformed ( ) { super . fireActionPerformed ( ) ; } protected void processKeyEvent ( KeyEvent evt ) { if ( ! isEnabled ( ) ) return ; if ( evt . getID ( ) == KeyEvent . KEY_PRESSED ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( enterAddsToHistory ) addCurrentToHistory ( ) ; if ( evt . getModifiers ( ) == 0 ) { fireActionPerformed ( ) ; evt . consume ( ) ; } } else if ( evt . getKeyCode ( ) == KeyEvent . VK_UP ) { if ( evt . isShiftDown ( ) ) doBackwardSearch ( ) ; else historyPrevious ( ) ; evt . consume ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_DOWN ) { if ( evt . isShiftDown ( ) ) doForwardSearch ( ) ; else historyNext ( ) ; evt . consume ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_TAB && evt . isControlDown ( ) ) { doBackwardSearch ( ) ; evt . consume ( ) ; } } if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } protected void processMouseEvent ( MouseEvent evt ) { if ( ! isEnabled ( ) ) return ; switch ( evt . getID ( ) ) { case MouseEvent . MOUSE_PRESSED : Border border = getBorder ( ) ; Insets insets = border . getBorderInsets ( HistoryTextField . this ) ; if ( evt . getX ( ) >= getWidth ( ) - insets . right || GUIUtilities . isPopupTrigger ( evt ) ) { if ( evt . isShiftDown ( ) ) showPopupMenu ( getText ( ) . substring ( 0 , getSelectionStart ( ) ) , 0 , getHeight ( ) ) ; else showPopupMenu ( "" , 0 , getHeight ( ) ) ; } else super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_EXITED : setCursor ( Cursor . getDefaultCursor ( ) ) ; super . processMouseEvent ( evt ) ; break ; default : super . processMouseEvent ( evt ) ; break ; } } private HistoryModel historyModel ; private JPopupMenu popup ; private boolean instantPopups ; private boolean enterAddsToHistory ; private boolean selectAllOnFocus ; private String current ; private int index ; private void doBackwardSearch ( ) { if ( historyModel == null ) return ; if ( getSelectionEnd ( ) != getDocument ( ) . getLength ( ) ) { setCaretPosition ( getDocument ( ) . getLength ( ) ) ; } String text = getText ( ) . substring ( 0 , getSelectionStart ( ) ) ; if ( text == null ) { historyPrevious ( ) ; return ; } for ( int i = index + 1 ; i < historyModel . getSize ( ) ; i ++ ) { String item = historyModel . getItem ( i ) ; if ( item . startsWith ( text ) ) { replaceSelection ( item . substring ( text . length ( ) ) ) ; select ( text . length ( ) , getDocument ( ) . getLength ( ) ) ; index = i ; return ; } } getToolkit ( ) . beep ( ) ; } private void doForwardSearch ( ) { if ( historyModel == null ) return ; if ( getSelectionEnd ( ) != getDocument ( ) . getLength ( ) ) { setCaretPosition ( getDocument ( ) . getLength ( ) ) ; } String text = getText ( ) . substring ( 0 , getSelectionStart ( ) ) ; if ( text == null ) { historyNext ( ) ; return ; } for ( int i = index - 1 ; i >= 0 ; i -- ) { String item = historyModel . getItem ( i ) ; if ( item . startsWith ( text ) ) { replaceSelection ( item . substring ( text . length ( ) ) ) ; select ( text . length ( ) , getDocument ( ) . getLength ( ) ) ; index = i ; return ; } } getToolkit ( ) . beep ( ) ; } private void historyPrevious ( ) { if ( historyModel == null ) return ; if ( index == historyModel . getSize ( ) - 1 ) getToolkit ( ) . beep ( ) ; else if ( index == - 1 ) { current = getText ( ) ; setText ( historyModel . getItem ( 0 ) ) ; index = 0 ; } else { int newIndex = index + 1 ; setText ( historyModel . getItem ( newIndex ) ) ; index = newIndex ; } } private void historyNext ( ) { if ( historyModel == null ) return ; if ( index == - 1 ) getToolkit ( ) . beep ( ) ; else if ( index == 0 ) setText ( current ) ; else { int newIndex = index - 1 ; setText ( historyModel . getItem ( newIndex ) ) ; index = newIndex ; } } private void showPopupMenu ( String text , int x , int y ) { if ( historyModel == null ) return ; requestFocus ( ) ; if ( popup != null && popup . isVisible ( ) ) { popup . setVisible ( false ) ; return ; } ActionHandler actionListener = new ActionHandler ( ) ; popup = new JPopupMenu ( ) ; JMenuItem caption = new JMenuItem ( jEdit . getProperty ( "history.caption" ) ) ; caption . getModel ( ) . setEnabled ( false ) ; popup . add ( caption ) ; popup . addSeparator ( ) ; for ( int i = 0 ; i < historyModel . getSize ( ) ; i ++ ) { String item = historyModel . getItem ( i ) ; if ( item . startsWith ( text ) ) { JMenuItem menuItem = new JMenuItem ( item ) ; menuItem . setActionCommand ( String . valueOf ( i ) ) ; menuItem . addActionListener ( actionListener ) ; popup . add ( menuItem ) ; } } GUIUtilities . showPopupMenu ( popup , this , x , y , false ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { int ind = Integer . parseInt ( evt . getActionCommand ( ) ) ; if ( ind == - 1 ) { if ( index != - 1 ) setText ( current ) ; } else { setText ( historyModel . getItem ( ind ) ) ; index = ind ; } if ( instantPopups ) { addCurrentToHistory ( ) ; fireActionPerformed ( ) ; } } } class MouseHandler extends MouseInputAdapter { boolean selectAll ; public void mousePressed ( MouseEvent evt ) { selectAll = ( ! hasFocus ( ) && selectAllOnFocus ) ; } public void mouseReleased ( MouseEvent evt ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( selectAll ) selectAll ( ) ; } } ) ; } public void mouseMoved ( MouseEvent evt ) { Border border = getBorder ( ) ; Insets insets = border . getBorderInsets ( HistoryTextField . this ) ; if ( evt . getX ( ) >= getWidth ( ) - insets . right ) setCursor ( Cursor . getDefaultCursor ( ) ) ; else setCursor ( Cursor . getPredefinedCursor ( Cursor . TEXT_CURSOR ) ) ; } public void mouseDragged ( MouseEvent evt ) { selectAll = false ; } } static class HistoryBorder extends AbstractBorder { static final int WIDTH = 16 ; public void paintBorder ( Component c , Graphics g , int x , int y , int w , int h ) { g . translate ( x + w - WIDTH , y - 1 ) ; int w2 = WIDTH / 2 ; int h2 = h / 2 ; g . setColor ( UIManager . getColor ( c . isEnabled ( ) && ( ( HistoryTextField ) c ) . getModel ( ) != null ? "TextField.foreground" : "TextField.disabledForeground" ) ) ; g . drawLine ( w2 - 5 , h2 - 2 , w2 + 4 , h2 - 2 ) ; g . drawLine ( w2 - 4 , h2 - 1 , w2 + 3 , h2 - 1 ) ; g . drawLine ( w2 - 3 , h2 , w2 + 2 , h2 ) ; g . drawLine ( w2 - 2 , h2 + 1 , w2 + 1 , h2 + 1 ) ; g . drawLine ( w2 - 1 , h2 + 2 , w2 , h2 + 2 ) ; g . translate ( - ( x + w - WIDTH ) , - ( y - 1 ) ) ; } public Insets getBorderInsets ( Component c ) { return new Insets ( 0 , 0 , 0 , WIDTH ) ; } } } 	0	['28', '6', '0', '21', '91', '206', '18', '6', '15', '0.772486772', '615', '1', '1', '0.970588235', '0.219387755', '3', '7', '20.71428571', '13', '2.3571', '0']
package org . gjt . sp . util ; public class IntegerArray { public IntegerArray ( ) { array = new int [ 1000 ] ; } public void add ( int num ) { if ( len >= array . length ) { int [ ] arrayN = new int [ len * 2 ] ; System . arraycopy ( array , 0 , arrayN , 0 , len ) ; array = arrayN ; } array [ len ++ ] = num ; } public final int get ( int index ) { return array [ index ] ; } public final int getSize ( ) { return len ; } public final void setSize ( int len ) { this . len = len ; } public final void clear ( ) { len = 0 ; } private int [ ] array ; private int len ; } 	0	['6', '1', '0', '4', '8', '0', '4', '0', '6', '0.5', '66', '1', '0', '0', '0.75', '0', '0', '9.666666667', '2', '1', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . * ; public class LoadSaveOptionPane extends AbstractOptionPane { public LoadSaveOptionPane ( ) { super ( "loadsave" ) ; } public void _init ( ) { autosave = new JTextField ( jEdit . getProperty ( "autosave" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.autosave" ) , autosave ) ; backups = new JTextField ( jEdit . getProperty ( "backups" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backups" ) , backups ) ; backupDirectory = new JTextField ( jEdit . getProperty ( "backup.directory" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backupDirectory" ) , backupDirectory ) ; backupPrefix = new JTextField ( jEdit . getProperty ( "backup.prefix" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backupPrefix" ) , backupPrefix ) ; backupSuffix = new JTextField ( jEdit . getProperty ( "backup.suffix" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backupSuffix" ) , backupSuffix ) ; String [ ] lineSeps = { jEdit . getProperty ( "lineSep.unix" ) , jEdit . getProperty ( "lineSep.windows" ) , jEdit . getProperty ( "lineSep.mac" ) } ; lineSeparator = new JComboBox ( lineSeps ) ; String lineSep = jEdit . getProperty ( "buffer.lineSeparator" , System . getProperty ( "line.separator" ) ) ; if ( "\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 0 ) ; else if ( "\r\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 1 ) ; else if ( "\r" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 2 ) ; addComponent ( jEdit . getProperty ( "options.loadsave.lineSeparator" ) , lineSeparator ) ; DefaultComboBoxModel encodings = new DefaultComboBoxModel ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { encodings . addElement ( st . nextToken ( ) ) ; } encoding = new JComboBox ( encodings ) ; encoding . setEditable ( true ) ; encoding . setSelectedItem ( jEdit . getProperty ( "buffer.encoding" , System . getProperty ( "file.encoding" ) ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.encoding" ) , encoding ) ; restore = new JCheckBox ( jEdit . getProperty ( "options.loadsave.restore" ) ) ; restore . setSelected ( jEdit . getBooleanProperty ( "restore" ) ) ; restore . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { restoreCLI . setEnabled ( restore . isSelected ( ) ) ; } } ) ; addComponent ( restore ) ; restoreCLI = new JCheckBox ( jEdit . getProperty ( "options.loadsave.restore.cli" ) ) ; restoreCLI . setSelected ( jEdit . getBooleanProperty ( "restore.cli" ) ) ; restoreCLI . setEnabled ( restore . isSelected ( ) ) ; addComponent ( restoreCLI ) ; newView = new JCheckBox ( jEdit . getProperty ( "options.loadsave.newView" ) ) ; newView . setSelected ( jEdit . getBooleanProperty ( "client.newView" ) ) ; addComponent ( newView ) ; persistentMarkers = new JCheckBox ( jEdit . getProperty ( "options.loadsave.persistentMarkers" ) ) ; persistentMarkers . setSelected ( jEdit . getBooleanProperty ( "persistentMarkers" ) ) ; addComponent ( persistentMarkers ) ; twoStageSave = new JCheckBox ( jEdit . getProperty ( "options.loadsave.twoStageSave" ) ) ; twoStageSave . setSelected ( jEdit . getBooleanProperty ( "twoStageSave" ) ) ; addComponent ( twoStageSave ) ; backupEverySave = new JCheckBox ( jEdit . getProperty ( "options.loadsave.backupEverySave" ) ) ; backupEverySave . setSelected ( jEdit . getBooleanProperty ( "backupEverySave" ) ) ; addComponent ( backupEverySave ) ; stripTrailingEOL = new JCheckBox ( jEdit . getProperty ( "options.loadsave.stripTrailingEOL" ) ) ; stripTrailingEOL . setSelected ( jEdit . getBooleanProperty ( "stripTrailingEOL" ) ) ; addComponent ( stripTrailingEOL ) ; } public void _save ( ) { jEdit . setProperty ( "autosave" , autosave . getText ( ) ) ; jEdit . setProperty ( "backups" , backups . getText ( ) ) ; jEdit . setProperty ( "backup.directory" , backupDirectory . getText ( ) ) ; jEdit . setProperty ( "backup.prefix" , backupPrefix . getText ( ) ) ; jEdit . setProperty ( "backup.suffix" , backupSuffix . getText ( ) ) ; String lineSep = null ; switch ( lineSeparator . getSelectedIndex ( ) ) { case 0 : lineSep = "\n" ; break ; case 1 : lineSep = "\r\n" ; break ; case 2 : lineSep = "\r" ; break ; } jEdit . setProperty ( "buffer.lineSeparator" , lineSep ) ; jEdit . setProperty ( "buffer.encoding" , ( String ) encoding . getSelectedItem ( ) ) ; jEdit . setBooleanProperty ( "restore" , restore . isSelected ( ) ) ; jEdit . setBooleanProperty ( "restore.cli" , restoreCLI . isSelected ( ) ) ; jEdit . setBooleanProperty ( "client.newView" , newView . isSelected ( ) ) ; jEdit . setBooleanProperty ( "persistentMarkers" , persistentMarkers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "twoStageSave" , twoStageSave . isSelected ( ) ) ; jEdit . setBooleanProperty ( "backupEverySave" , backupEverySave . isSelected ( ) ) ; jEdit . setBooleanProperty ( "stripTrailingEOL" , stripTrailingEOL . isSelected ( ) ) ; } private JTextField autosave ; private JTextField backups ; private JTextField backupDirectory ; private JTextField backupPrefix ; private JTextField backupSuffix ; private JComboBox lineSeparator ; private JComboBox encoding ; private JCheckBox restore ; private JCheckBox restoreCLI ; private JCheckBox newView ; private JCheckBox persistentMarkers ; private JCheckBox twoStageSave ; private JCheckBox backupEverySave ; private JCheckBox stripTrailingEOL ; } 	0	['5', '6', '0', '4', '35', '0', '2', '3', '3', '0.714285714', '406', '1', '0', '0.994056464', '0.5', '3', '5', '77.4', '5', '1.8', '0']
package bsh ; class SimpleNode implements Node { protected Node parent ; protected Node [ ] children ; protected int id ; Token firstToken , lastToken ; String sourceFile ; public SimpleNode ( int i ) { id = i ; } public void jjtOpen ( ) { } public void jjtClose ( ) { } public void jjtSetParent ( Node n ) { parent = n ; } public Node jjtGetParent ( ) { return parent ; } public void jjtAddChild ( Node n , int i ) { if ( children == null ) children = new Node [ i + 1 ] ; else if ( i >= children . length ) { Node c [ ] = new Node [ i + 1 ] ; System . arraycopy ( children , 0 , c , 0 , children . length ) ; children = c ; } children [ i ] = n ; } public Node jjtGetChild ( int i ) { return children [ i ] ; } public SimpleNode getChild ( int i ) { return ( SimpleNode ) jjtGetChild ( i ) ; } public int jjtGetNumChildren ( ) { return ( children == null ) ? 0 : children . length ; } public String toString ( ) { return ParserTreeConstants . jjtNodeName [ id ] ; } public String toString ( String prefix ) { return prefix + toString ( ) ; } public void dump ( String prefix ) { System . out . println ( toString ( prefix ) ) ; if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { SimpleNode n = ( SimpleNode ) children [ i ] ; if ( n != null ) { n . dump ( prefix + " " ) ; } } } } public void prune ( ) { jjtSetParent ( null ) ; } public Object eval ( NameSpace namespace ) throws EvalError { throw new EvalError ( "Unimplemented or inappropriate for " + getClass ( ) . getName ( ) ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { return eval ( callstack . top ( ) ) ; } public void setSourceFile ( String sourceFile ) { this . sourceFile = sourceFile ; } public String getSourceFile ( ) { if ( sourceFile == null ) if ( parent != null ) return ( ( SimpleNode ) parent ) . getSourceFile ( ) ; else return "<unknown file>" ; else return sourceFile ; } public int getLineNumber ( ) { return firstToken . beginLine ; } public String getText ( ) { StringBuffer text = new StringBuffer ( ) ; Token t = firstToken ; while ( t != null ) { text . append ( t . image ) ; if ( ! t . image . equals ( "." ) ) text . append ( " " ) ; if ( t == lastToken || t . image . equals ( "{" ) || t . image . equals ( ";" ) ) break ; t = t . next ; } return text . toString ( ) ; } } 	0	['19', '1', '36', '51', '30', '147', '47', '7', '19', '0.888888889', '240', '0.5', '4', '0', '0.233082707', '0', '0', '11.31578947', '6', '1.6316', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class EditorStarted extends EBMessage { public EditorStarted ( EBComponent source ) { super ( source ) ; } } 	0	['1', '2', '0', '3', '2', '0', '1', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package bsh ; class BSHVariableDeclarator extends SimpleNode { public String name ; BSHVariableDeclarator ( int id ) { super ( id ) ; } public Object eval ( BSHType typeNode , CallStack callstack , Interpreter interpreter ) throws EvalError { Object value = Primitive . VOID ; if ( jjtGetNumChildren ( ) > 0 ) { SimpleNode initializer = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( ( typeNode != null ) && initializer instanceof BSHArrayInitializer ) value = ( ( BSHArrayInitializer ) initializer ) . eval ( typeNode . getBaseType ( ) , typeNode . getArrayDims ( ) , callstack , interpreter ) ; else value = initializer . eval ( callstack , interpreter ) ; } return value ; } } 	0	['2', '2', '0', '10', '9', '1', '2', '8', '1', '2', '40', '0', '0', '0.947368421', '0.6', '1', '2', '18.5', '1', '0.5', '0']
package org . gjt . sp . util ; import java . util . EventListener ; public interface WorkThreadProgressListener extends EventListener { void statusUpdate ( WorkThreadPool threadPool , int threadIndex ) ; void progressUpdate ( WorkThreadPool threadPool , int threadIndex ) ; } 	0	['2', '1', '0', '6', '2', '1', '6', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . search ; import bsh . BshMethod ; import bsh . NameSpace ; import gnu . regexp . * ; import org . gjt . sp . jedit . BeanShell ; import org . gjt . sp . jedit . MiscUtilities ; public class RESearchMatcher implements SearchMatcher { public static final RESyntax RE_SYNTAX_JEDIT = new RESyntax ( RESyntax . RE_SYNTAX_PERL5 ) . set ( RESyntax . RE_CHAR_CLASSES ) . setLineSeparator ( "\n" ) ; public RESearchMatcher ( String search , String replace , boolean ignoreCase , boolean beanshell , BshMethod replaceMethod ) throws Exception { if ( beanshell && replaceMethod != null && replace . length ( ) != 0 ) { this . beanshell = true ; this . replaceMethod = replaceMethod ; replaceNS = new NameSpace ( BeanShell . getNameSpace ( ) , "search and replace" ) ; } else { this . replace = MiscUtilities . escapesToChars ( replace ) ; } re = new RE ( search , ( ignoreCase ? RE . REG_ICASE : 0 ) | RE . REG_MULTILINE , RE_SYNTAX_JEDIT ) ; returnValue = new int [ 2 ] ; } public int [ ] nextMatch ( CharIndexed text , boolean start , boolean end , boolean firstTime , boolean reverse ) { int flags = 0 ; if ( ! start ) flags |= RE . REG_NOTBOL ; if ( ! end ) flags |= RE . REG_NOTEOL ; REMatch match = re . getMatch ( text , 0 , flags ) ; if ( match == null ) return null ; int _start = match . getStartIndex ( ) ; int _end = match . getEndIndex ( ) ; if ( ! firstTime && _start == 0 && _end == 0 ) { text . move ( 1 ) ; if ( text . charAt ( 0 ) == CharIndexed . OUT_OF_BOUNDS ) { return null ; } match = re . getMatch ( text , 0 , flags | RE . REG_NOTBOL ) ; if ( match == null ) return null ; else { _start = match . getStartIndex ( ) + 1 ; _end = match . getEndIndex ( ) + 1 ; } } returnValue [ 0 ] = _start ; returnValue [ 1 ] = _end ; return returnValue ; } public String substitute ( String text ) throws Exception { REMatch match = re . getMatch ( text ) ; if ( match == null ) return null ; if ( beanshell ) { int count = re . getNumSubs ( ) ; for ( int i = 0 ; i <= count ; i ++ ) replaceNS . setVariable ( "_" + i , match . toString ( i ) ) ; Object obj = BeanShell . runCachedBlock ( replaceMethod , null , replaceNS ) ; if ( obj == null ) return "" ; else return obj . toString ( ) ; } else return match . substituteInto ( replace ) ; } private String replace ; private RE re ; private boolean beanshell ; private BshMethod replaceMethod ; private NameSpace replaceNS ; private int [ ] returnValue ; } 	0	['4', '1', '0', '14', '29', '0', '4', '10', '3', '0.619047619', '207', '0.857142857', '4', '0', '0.6', '0', '0', '49', '9', '2.5', '0']
package org . gjt . sp . jedit . search ; import javax . swing . text . Segment ; import javax . swing . tree . * ; import javax . swing . SwingUtilities ; import org . gjt . sp . jedit . textarea . Selection ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . Buffer ; import org . gjt . sp . jedit . GUIUtilities ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . View ; import org . gjt . sp . util . * ; class HyperSearchRequest extends WorkRequest { public HyperSearchRequest ( View view , SearchMatcher matcher , HyperSearchResults results , Selection [ ] selection ) { this . view = view ; this . matcher = matcher ; this . results = results ; this . searchString = SearchAndReplace . getSearchString ( ) ; this . rootSearchNode = new DefaultMutableTreeNode ( searchString ) ; this . selection = selection ; } public void run ( ) { setStatus ( jEdit . getProperty ( "hypersearch-status" ) ) ; SearchFileSet fileset = SearchAndReplace . getSearchFileSet ( ) ; String [ ] files = fileset . getFiles ( view ) ; if ( files == null || files . length == 0 ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { GUIUtilities . error ( view , "empty-fileset" , null ) ; } } ) ; return ; } setProgressMaximum ( fileset . getFileCount ( view ) ) ; long lastStatusTime = 0 ; try { if ( selection != null ) { Buffer buffer = view . getBuffer ( ) ; searchInSelection ( buffer ) ; } else { int current = 0 ; loop : for ( int i = 0 ; i < files . length ; i ++ ) { String file = files [ i ] ; current ++ ; long currentTime = System . currentTimeMillis ( ) ; if ( currentTime - lastStatusTime > 500 ) { setStatus ( jEdit . getProperty ( "hypersearch-status-file" , new String [ ] { file } ) ) ; setProgressValue ( current ) ; lastStatusTime = currentTime ; } Buffer buffer = jEdit . openTemporary ( null , null , file , false ) ; if ( buffer == null ) continue loop ; doHyperSearch ( buffer ) ; } ; } } catch ( final Exception e ) { Log . log ( Log . ERROR , this , e ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { GUIUtilities . error ( view , "searcherror" , new String [ ] { e . toString ( ) } ) ; } } ) ; } catch ( WorkThread . Abort a ) { } finally { VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { results . searchDone ( rootSearchNode ) ; } } ) ; } } private View view ; private SearchMatcher matcher ; private HyperSearchResults results ; private DefaultMutableTreeNode rootSearchNode ; private Selection [ ] selection ; private String searchString ; private int searchInSelection ( Buffer buffer ) throws Exception { setAbortable ( false ) ; int resultCount = 0 ; try { buffer . readLock ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; if ( s instanceof Selection . Rect ) { for ( int j = s . getStartLine ( ) ; j <= s . getEndLine ( ) ; j ++ ) { resultCount += doHyperSearch ( buffer , s . getStart ( buffer , j ) , s . getEnd ( buffer , j ) ) ; } } else { resultCount += doHyperSearch ( buffer , s . getStart ( ) , s . getEnd ( ) ) ; } } } finally { buffer . readUnlock ( ) ; } setAbortable ( true ) ; return resultCount ; } private int doHyperSearch ( Buffer buffer ) throws Exception { return doHyperSearch ( buffer , 0 , buffer . getLength ( ) ) ; } private int doHyperSearch ( Buffer buffer , int start , int end ) throws Exception { setAbortable ( false ) ; final DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode ( buffer . getPath ( ) ) ; int resultCount = doHyperSearch ( buffer , start , end , bufferNode ) ; if ( resultCount != 0 ) { rootSearchNode . insert ( bufferNode , rootSearchNode . getChildCount ( ) ) ; } setAbortable ( true ) ; return resultCount ; } private int doHyperSearch ( Buffer buffer , int start , int end , DefaultMutableTreeNode bufferNode ) { int resultCount = 0 ; try { buffer . readLock ( ) ; boolean endOfLine = ( buffer . getLineEndOffset ( buffer . getLineOfOffset ( end ) ) - 1 == end ) ; Segment text = new Segment ( ) ; int offset = start ; int line = - 1 ; loop : for ( int counter = 0 ; ; counter ++ ) { boolean startOfLine = ( buffer . getLineStartOffset ( buffer . getLineOfOffset ( offset ) ) == offset ) ; buffer . getText ( offset , end - offset , text ) ; int [ ] match = matcher . nextMatch ( new CharIndexedSegment ( text , false ) , startOfLine , endOfLine , counter == 0 , false ) ; if ( match == null ) break loop ; int matchStart = offset + match [ 0 ] ; int matchEnd = offset + match [ 1 ] ; offset += match [ 1 ] ; int newLine = buffer . getLineOfOffset ( offset ) ; if ( line == newLine ) { continue loop ; } line = newLine ; resultCount ++ ; bufferNode . add ( new DefaultMutableTreeNode ( new HyperSearchResult ( buffer , line , matchStart , matchEnd ) , false ) ) ; } } finally { buffer . readUnlock ( ) ; } return resultCount ; } } 	0	['9', '2', '0', '19', '52', '16', '4', '19', '2', '0.770833333', '404', '1', '4', '0.428571429', '0.24691358', '0', '0', '43.22222222', '11', '2.7778', '0']
package bsh ; class BlockNameSpace extends NameSpace { boolean initMode ; public BlockNameSpace ( NameSpace parent ) throws EvalError { super ( parent , parent . name + "/BlockNameSpace" ) ; } public void setVariable ( String name , Object o ) throws EvalError { if ( weHaveVar ( name ) || initMode ) super . setVariable ( name , o ) ; else getParent ( ) . setVariable ( name , o ) ; } public void setInitMode ( boolean b ) { initMode = b ; } boolean weHaveVar ( String name ) { return super . getVariableImpl ( name , false ) != null ; } public NameSpace getSuper ( ) { return getParent ( ) . getSuper ( ) ; } This getThis ( Interpreter declaringInterpreter ) { return getParent ( ) . getThis ( declaringInterpreter ) ; } public void importClass ( String name ) { getParent ( ) . importClass ( name ) ; } public void importPackage ( String name ) { getParent ( ) . importPackage ( name ) ; } } 	0	['8', '2', '0', '7', '19', '26', '3', '4', '6', '0.857142857', '72', '0', '0', '0.872727273', '0.333333333', '0', '0', '7.875', '2', '1', '0']
package bsh ; import java . util . * ; public interface NameSource { public String [ ] getAllNames ( ) ; public void addNameSourceListener ( NameSource . Listener listener ) ; public static interface Listener { public void nameSourceChanged ( NameSource src ) ; } } 	0	['2', '1', '0', '2', '2', '1', '2', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package bsh ; class TokenMgrError extends Error { static final int LEXICAL_ERROR = 0 ; static final int STATIC_LEXER_ERROR = 1 ; static final int INVALID_LEXICAL_STATE = 2 ; static final int LOOP_DETECTED = 3 ; int errorCode ; protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } private static final String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + ", column " + errorColumn + ".  Encountered: " + ( EOFSeen ? "<EOF> " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " (" + ( int ) curChar + "), " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; } public String getMessage ( ) { return super . getMessage ( ) ; } public TokenMgrError ( ) { } public TokenMgrError ( String message , int reason ) { super ( message ) ; errorCode = reason ; } public TokenMgrError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar , int reason ) { this ( LexicalError ( EOFSeen , lexState , errorLine , errorColumn , errorAfter , curChar ) , reason ) ; } } 	0	['6', '3', '0', '2', '19', '15', '2', '0', '4', '1.12', '184', '0', '0', '0.85', '0.5', '1', '1', '28.83333333', '14', '2.8333', '0']
package bsh ; import java . util . Vector ; public class CallStack { private Vector stack = new Vector ( 2 ) ; public void clear ( ) { stack . removeAllElements ( ) ; } public void push ( NameSpace ns ) { stack . insertElementAt ( ns , 0 ) ; } public NameSpace top ( ) { return get ( 0 ) ; } public NameSpace get ( int depth ) { if ( depth >= depth ( ) ) return NameSpace . JAVACODE ; else return ( NameSpace ) ( stack . elementAt ( depth ) ) ; } public void set ( int depth , NameSpace ns ) { stack . setElementAt ( ns , depth ) ; } public NameSpace pop ( ) { if ( depth ( ) < 1 ) throw new InterpreterError ( "pop on empty CallStack" ) ; NameSpace top = top ( ) ; stack . removeElementAt ( 0 ) ; return top ; } public NameSpace swap ( NameSpace newTop ) { NameSpace oldTop = ( NameSpace ) ( stack . elementAt ( 0 ) ) ; stack . setElementAt ( newTop , 0 ) ; return oldTop ; } public int depth ( ) { return stack . size ( ) ; } public NameSpace [ ] toArray ( ) { NameSpace [ ] nsa = new NameSpace [ depth ( ) ] ; stack . copyInto ( nsa ) ; return nsa ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "CallStack:\n" ) ; NameSpace [ ] nsa = toArray ( ) ; for ( int i = 0 ; i < nsa . length ; i ++ ) sb . append ( "\t" + nsa [ i ] + "\n" ) ; return sb . toString ( ) ; } } 	0	['11', '1', '0', '40', '25', '0', '39', '2', '11', '0', '135', '1', '0', '0', '0.484848485', '0', '0', '11.18181818', '2', '1.1818', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . util . Collections ; import java . util . Vector ; import org . gjt . sp . jedit . msg . MacrosChanged ; import org . gjt . sp . jedit . * ; public class MacrosMenu extends EnhancedMenu implements EBComponent { public MacrosMenu ( ) { super ( "macros" ) ; updateMacrosMenu ( ) ; } public void addNotify ( ) { super . addNotify ( ) ; EditBus . addToBus ( this ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; EditBus . removeFromBus ( this ) ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof MacrosChanged ) updateMacrosMenu ( ) ; } public void init ( ) { super . init ( ) ; updateMacrosMenu ( ) ; } private void updateMacrosMenu ( ) { if ( ! initialized ) return ; for ( int i = getMenuComponentCount ( ) - 1 ; i >= 0 ; i -- ) { if ( getMenuComponent ( i ) instanceof JSeparator ) break ; else remove ( i ) ; } int count = getMenuComponentCount ( ) ; Vector macroVector = Macros . getMacroHierarchy ( ) ; createMacrosMenu ( this , macroVector , 0 ) ; if ( count == getMenuComponentCount ( ) ) add ( GUIUtilities . loadMenuItem ( "no-macros" ) ) ; } private void createMacrosMenu ( JMenu menu , Vector vector , int start ) { Vector menuItems = new Vector ( ) ; for ( int i = start ; i < vector . size ( ) ; i ++ ) { Object obj = vector . elementAt ( i ) ; if ( obj instanceof Macros . Macro ) { Macros . Macro macro = ( Macros . Macro ) obj ; menuItems . add ( new EnhancedMenuItem ( macro . getLabel ( ) , macro ) ) ; } else if ( obj instanceof Vector ) { Vector subvector = ( Vector ) obj ; String name = ( String ) subvector . elementAt ( 0 ) ; JMenu submenu = new JMenu ( name ) ; createMacrosMenu ( submenu , subvector , 1 ) ; if ( submenu . getMenuComponentCount ( ) != 0 ) menuItems . add ( submenu ) ; } } Collections . sort ( menuItems , new MiscUtilities . MenuItemCompare ( ) ) ; for ( int i = 0 ; i < menuItems . size ( ) ; i ++ ) { menu . add ( ( JMenuItem ) menuItems . get ( i ) ) ; } } } 	0	['7', '8', '0', '11', '31', '21', '1', '11', '5', '2', '157', '0', '0', '0.993055556', '0.314285714', '1', '7', '21.42857143', '6', '2.2857', '0']
package bsh ; class BSHSwitchStatement extends SimpleNode implements ParserConstants { public BSHSwitchStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int numchild = jjtGetNumChildren ( ) ; int child = 0 ; SimpleNode switchExp = ( ( SimpleNode ) jjtGetChild ( child ++ ) ) ; Object switchVal = switchExp . eval ( callstack , interpreter ) ; BSHSwitchLabel label ; Object node ; ReturnControl returnControl = null ; if ( child >= numchild ) throw new EvalError ( "Empty switch statement..." ) ; label = ( ( BSHSwitchLabel ) jjtGetChild ( child ++ ) ) ; while ( child < numchild && returnControl == null ) { if ( label . isDefault || label . eval ( callstack , interpreter ) . equals ( switchVal ) ) { while ( child < numchild ) { node = jjtGetChild ( child ++ ) ; if ( node instanceof BSHSwitchLabel ) continue ; Object value = ( ( SimpleNode ) node ) . eval ( callstack , interpreter ) ; if ( value instanceof ReturnControl ) { returnControl = ( ReturnControl ) value ; break ; } } } else { while ( child < numchild ) { node = jjtGetChild ( child ++ ) ; if ( node instanceof BSHSwitchLabel ) { label = ( BSHSwitchLabel ) node ; break ; } } } } if ( returnControl != null && returnControl . kind == RETURN ) return returnControl ; else return Primitive . VOID ; } } 	0	['2', '2', '0', '10', '9', '1', '1', '9', '2', '2', '106', '0', '0', '0.947368421', '0.625', '2', '2', '52', '1', '0.5', '0']
package org . gjt . sp . jedit . io ; import java . awt . Component ; import java . util . ArrayList ; import org . gjt . sp . jedit . jEdit ; public class FavoritesVFS extends VFS { public static final String PROTOCOL = "favorites" ; public FavoritesVFS ( ) { super ( "favorites" , DELETE_CAP | LOW_LATENCY_CAP ) ; instance = this ; } public String getParentOfPath ( String path ) { return PROTOCOL + ":" ; } public VFS . DirectoryEntry [ ] _listDirectory ( Object session , String url , Component comp ) { synchronized ( lock ) { if ( favorites == null ) loadFavorites ( ) ; VFS . DirectoryEntry [ ] retVal = new VFS . DirectoryEntry [ favorites . size ( ) ] ; for ( int i = 0 ; i < retVal . length ; i ++ ) { String favorite = ( String ) favorites . get ( i ) ; retVal [ i ] = _getDirectoryEntry ( session , favorite , comp ) ; } return retVal ; } } public DirectoryEntry _getDirectoryEntry ( Object session , String path , Component comp ) { return new VFS . DirectoryEntry ( path , path , "favorites:" + path , VFS . DirectoryEntry . DIRECTORY , 0L , false ) ; } public boolean _delete ( Object session , String path , Component comp ) { synchronized ( lock ) { path = path . substring ( PROTOCOL . length ( ) + 1 ) ; favorites . remove ( path ) ; VFSManager . sendVFSUpdate ( this , PROTOCOL + ":" , false ) ; } return true ; } public static void loadFavorites ( ) { favorites = new ArrayList ( ) ; synchronized ( lock ) { String favorite ; int i = 0 ; while ( ( favorite = jEdit . getProperty ( "vfs.favorite." + i ) ) != null ) { favorites . add ( favorite ) ; i ++ ; } } } public static void addToFavorites ( String path ) { synchronized ( lock ) { if ( favorites == null ) loadFavorites ( ) ; if ( ! favorites . contains ( path ) ) favorites . add ( path ) ; VFSManager . sendVFSUpdate ( instance , PROTOCOL + ":" , false ) ; } } public static void saveFavorites ( ) { synchronized ( lock ) { if ( favorites == null ) return ; for ( int i = 0 ; i < favorites . size ( ) ; i ++ ) { jEdit . setProperty ( "vfs.favorite." + i , ( String ) favorites . get ( i ) ) ; } jEdit . unsetProperty ( "vfs.favorite." + favorites . size ( ) ) ; } } public static Object [ ] getFavorites ( ) { synchronized ( lock ) { if ( favorites == null ) loadFavorites ( ) ; return favorites . toArray ( ) ; } } private static FavoritesVFS instance ; private static Object lock = new Object ( ) ; private static ArrayList favorites ; } 	0	['10', '2', '0', '6', '30', '1', '4', '4', '9', '0.694444444', '246', '0.75', '1', '0.829787234', '0.444444444', '1', '1', '23.2', '3', '1.6', '0']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import java . io . * ; import org . gjt . sp . util . Log ; class ModeCatalogHandler extends HandlerBase { ModeCatalogHandler ( String directory , boolean resource ) { this . directory = directory ; this . resource = resource ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "catalog.dtd" . equals ( systemId ) ) { return new StringReader ( "<!-- -->" ) ; } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { aname = ( aname == null ) ? null : aname . intern ( ) ; if ( aname == "NAME" ) modeName = value ; else if ( aname == "FILE" ) { if ( value == null ) { Log . log ( Log . ERROR , this , directory + "catalog:" + " mode " + modeName + " doesn't have" + " a FILE attribute" ) ; } else file = value ; } else if ( aname == "FILE_NAME_GLOB" ) filenameGlob = value ; else if ( aname == "FIRST_LINE_GLOB" ) firstlineGlob = value ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "CATALOG" . equals ( name ) || "MODES" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , directory + "catalog: DOCTYPE must be CATALOG" ) ; } public void endElement ( String name ) { if ( name . equals ( "MODE" ) ) { Mode mode = jEdit . getMode ( modeName ) ; if ( mode == null ) { mode = new Mode ( modeName ) ; jEdit . addMode ( mode ) ; } Object path ; if ( resource ) path = jEdit . class . getResource ( directory + file ) ; else path = MiscUtilities . constructPath ( directory , file ) ; mode . setProperty ( "file" , path ) ; if ( filenameGlob != null ) mode . setProperty ( "filenameGlob" , filenameGlob ) ; else mode . unsetProperty ( "filenameGlob" ) ; if ( firstlineGlob != null ) mode . setProperty ( "firstlineGlob" , firstlineGlob ) ; else mode . unsetProperty ( "firstlineGlob" ) ; mode . init ( ) ; modeName = file = filenameGlob = firstlineGlob = null ; } } private String directory ; private boolean resource ; private String modeName ; private String file ; private String filenameGlob ; private String firstlineGlob ; } 	0	['6', '2', '0', '5', '25', '3', '1', '5', '4', '0.771428571', '215', '0.857142857', '0', '0.722222222', '0.722222222', '1', '3', '33.66666667', '7', '3', '0']
package bsh . reflect ; import bsh . ReflectManager ; import java . lang . reflect . AccessibleObject ; public class ReflectManagerImpl extends ReflectManager { public boolean setAccessible ( Object obj ) { if ( obj instanceof AccessibleObject ) { ( ( AccessibleObject ) obj ) . setAccessible ( true ) ; return true ; } else return false ; } } 	0	['2', '2', '0', '1', '4', '1', '0', '1', '2', '2', '16', '0', '0', '0.75', '0.75', '1', '1', '7', '2', '1', '0']
package org . gjt . sp . jedit ; import org . gjt . sp . util . Log ; public abstract class EBPlugin extends EditPlugin implements EBComponent { public void handleMessage ( EBMessage message ) { Log . log ( Log . WARNING , this , getClassName ( ) + " should extend" + " EditPlugin not EBPlugin since it has an empty" + " handleMessage()" ) ; EditBus . removeFromBus ( this ) ; } protected EBPlugin ( ) { } } 	0	['2', '2', '0', '6', '9', '1', '1', '5', '1', '2', '24', '0', '0', '0.954545455', '0.75', '0', '0', '11', '1', '0.5', '0']
package org . gjt . sp . jedit . gui ; import java . awt . Component ; import java . awt . Font ; import java . util . Vector ; import javax . swing . * ; import javax . swing . table . * ; public class JCheckBoxList extends JTable { public JCheckBoxList ( Object [ ] items ) { setModel ( items ) ; } public JCheckBoxList ( Vector items ) { setModel ( items ) ; } public void setModel ( Object [ ] items ) { setModel ( new CheckBoxListModel ( items ) ) ; init ( ) ; } public void setModel ( Vector items ) { setModel ( new CheckBoxListModel ( items ) ) ; init ( ) ; } public Object [ ] getCheckedValues ( ) { Vector values = new Vector ( ) ; CheckBoxListModel model = ( CheckBoxListModel ) getModel ( ) ; for ( int i = 0 ; i < model . items . size ( ) ; i ++ ) { Entry entry = ( Entry ) model . items . elementAt ( i ) ; if ( entry . checked && ! entry . caption ) values . addElement ( entry . value ) ; } Object [ ] retVal = new Object [ values . size ( ) ] ; values . copyInto ( retVal ) ; return retVal ; } public void selectAll ( ) { CheckBoxListModel model = ( CheckBoxListModel ) getModel ( ) ; for ( int i = 0 ; i < model . items . size ( ) ; i ++ ) { Entry entry = ( Entry ) model . items . elementAt ( i ) ; if ( ! entry . caption ) entry . checked = true ; } model . fireTableRowsUpdated ( 0 , model . getRowCount ( ) ) ; } public Entry [ ] getValues ( ) { CheckBoxListModel model = ( CheckBoxListModel ) getModel ( ) ; Entry [ ] retVal = new Entry [ model . items . size ( ) ] ; model . items . copyInto ( retVal ) ; return retVal ; } public Object getSelectedValue ( ) { int row = getSelectedRow ( ) ; if ( row == - 1 ) return null ; else return getModel ( ) . getValueAt ( row , 1 ) ; } public TableCellRenderer getCellRenderer ( int row , int column ) { if ( column == 0 ) { Entry entry = ( Entry ) ( ( CheckBoxListModel ) getModel ( ) ) . items . get ( row ) ; if ( entry . caption ) return dummy ; } return super . getCellRenderer ( row , column ) ; } private TableCellRenderer dummy ; private void init ( ) { dummy = new DummyRenderer ( ) ; getSelectionModel ( ) . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; setShowGrid ( false ) ; setAutoResizeMode ( JTable . AUTO_RESIZE_LAST_COLUMN ) ; TableColumn column = getColumnModel ( ) . getColumn ( 0 ) ; int checkBoxWidth = new JCheckBox ( ) . getPreferredSize ( ) . width ; column . setPreferredWidth ( checkBoxWidth ) ; column . setMinWidth ( checkBoxWidth ) ; column . setWidth ( checkBoxWidth ) ; column . setMaxWidth ( checkBoxWidth ) ; column . setResizable ( false ) ; column = getColumnModel ( ) . getColumn ( 1 ) ; column . setCellRenderer ( new LabelRenderer ( ) ) ; } public static class Entry { boolean checked ; boolean caption ; Object value ; public Entry ( Object value ) { this . caption = true ; this . value = value ; } public Entry ( boolean checked , Object value ) { this . checked = checked ; this . value = value ; } public boolean isChecked ( ) { return checked ; } public Object getValue ( ) { return value ; } } private class DummyRenderer extends DefaultTableCellRenderer { public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { return super . getTableCellRendererComponent ( table , null , isSelected , false , row , column ) ; } } private class LabelRenderer extends DefaultTableCellRenderer { Font plainFont , boldFont ; LabelRenderer ( ) { plainFont = UIManager . getFont ( "Tree.font" ) ; boldFont = plainFont . deriveFont ( Font . BOLD ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; Entry entry = ( Entry ) ( ( CheckBoxListModel ) getModel ( ) ) . items . get ( row ) ; if ( entry . caption ) setFont ( boldFont ) ; else setFont ( plainFont ) ; return this ; } } } class CheckBoxListModel extends AbstractTableModel { Vector items ; CheckBoxListModel ( Vector _items ) { items = new Vector ( _items . size ( ) ) ; for ( int i = 0 ; i < _items . size ( ) ; i ++ ) { items . addElement ( createEntry ( _items . elementAt ( i ) ) ) ; } } CheckBoxListModel ( Object [ ] _items ) { items = new Vector ( _items . length ) ; for ( int i = 0 ; i < _items . length ; i ++ ) { items . addElement ( createEntry ( _items [ i ] ) ) ; } } private JCheckBoxList . Entry createEntry ( Object obj ) { if ( obj instanceof JCheckBoxList . Entry ) return ( JCheckBoxList . Entry ) obj ; else return new JCheckBoxList . Entry ( false , obj ) ; } public int getRowCount ( ) { return items . size ( ) ; } public int getColumnCount ( ) { return 2 ; } public String getColumnName ( int col ) { return null ; } public Object getValueAt ( int row , int col ) { JCheckBoxList . Entry entry = ( JCheckBoxList . Entry ) items . elementAt ( row ) ; switch ( col ) { case 0 : return new Boolean ( entry . checked ) ; case 1 : return entry . value ; default : throw new InternalError ( ) ; } } public Class getColumnClass ( int col ) { switch ( col ) { case 0 : return Boolean . class ; case 1 : return String . class ; default : throw new InternalError ( ) ; } } public boolean isCellEditable ( int row , int col ) { JCheckBoxList . Entry entry = ( JCheckBoxList . Entry ) items . elementAt ( row ) ; return col == 0 && ! entry . caption ; } public void setValueAt ( Object value , int row , int col ) { if ( col == 0 ) { JCheckBoxList . Entry entry = ( JCheckBoxList . Entry ) items . elementAt ( row ) ; if ( ! entry . caption ) { entry . checked = ( value . equals ( Boolean . TRUE ) ) ; fireTableRowsUpdated ( row , row ) ; } } } } 	0	['10', '5', '0', '7', '42', '43', '4', '5', '9', '0.666666667', '219', '1', '0', '0.990654206', '0.375', '1', '1', '20.8', '4', '1.6', '0']
package gnu . regexp ; class RETokenStart extends REToken { private String newline ; RETokenStart ( int subIndex , String newline ) { super ( subIndex ) ; this . newline = newline ; } boolean match ( CharIndexed input , REMatch mymatch ) { if ( newline != null ) { int len = newline . length ( ) ; if ( mymatch . offset >= len ) { boolean found = true ; char z ; int i = 0 ; char ch = input . charAt ( mymatch . index - len ) ; do { z = newline . charAt ( i ) ; if ( ch != z ) { found = false ; break ; } ++ i ; ch = input . charAt ( mymatch . index - len + i ) ; } while ( i < len ) ; if ( found ) return next ( input , mymatch ) ; } } if ( ( mymatch . eflags & RE . REG_NOTBOL ) > 0 ) return false ; if ( ( mymatch . eflags & RE . REG_ANCHORINDEX ) > 0 ) return ( mymatch . anchor == mymatch . offset ) ? next ( input , mymatch ) : false ; else return ( ( mymatch . index == 0 ) && ( mymatch . offset == 0 ) ) ? next ( input , mymatch ) : false ; } void dump ( StringBuffer os ) { os . append ( '^' ) ; } } 	0	['3', '2', '0', '4', '9', '1', '1', '3', '0', '0.5', '106', '1', '0', '0.777777778', '0.444444444', '1', '2', '34', '11', '4', '0']
package org . gjt . sp . jedit . proto . jeditresource ; import java . io . * ; import java . net . * ; import org . gjt . sp . jedit . * ; public class PluginResURLConnection extends URLConnection { public PluginResURLConnection ( URL url ) throws IOException { super ( url ) ; String file = url . getFile ( ) ; int index = file . indexOf ( '!' , 0 ) ; if ( index == - 1 ) { plugin = null ; resource = file ; } else { int start ; if ( file . charAt ( 0 ) == '/' ) start = 1 ; else start = 0 ; plugin = file . substring ( start , index ) ; resource = file . substring ( index + 1 ) ; } if ( plugin != null && resource . startsWith ( "/" ) ) resource = resource . substring ( 1 ) ; } public void connect ( ) throws IOException { if ( ! connected ) { if ( plugin == null ) { in = jEdit . class . getResourceAsStream ( resource ) ; } else { EditPlugin . JAR [ ] plugins = jEdit . getPluginJARs ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin . JAR jar = plugins [ i ] ; if ( MiscUtilities . getFileName ( jar . getPath ( ) ) . equalsIgnoreCase ( plugin ) ) { in = jar . getClassLoader ( ) . getResourceAsStream ( resource ) ; break ; } } } if ( in == null ) { throw new IOException ( "Resource not found: " + resource ) ; } connected = true ; } } public InputStream getInputStream ( ) throws IOException { connect ( ) ; return in ; } public String getHeaderField ( String name ) { if ( name . equals ( "content-type" ) ) { String lcResource = resource . toLowerCase ( ) ; if ( lcResource . endsWith ( ".html" ) ) return "text/html" ; else if ( lcResource . endsWith ( ".txt" ) ) return "text/plain" ; else if ( lcResource . endsWith ( ".rtf" ) ) return "text/rtf" ; else if ( lcResource . endsWith ( ".gif" ) ) return "image/gif" ; else if ( lcResource . endsWith ( ".jpg" ) || lcResource . endsWith ( ".jpeg" ) ) return "image/jpeg" ; else return null ; } else return null ; } private InputStream in ; private String plugin ; private String resource ; } 	0	['5', '2', '0', '5', '29', '2', '1', '4', '4', '0.5625', '198', '0.75', '0', '0.935483871', '0.466666667', '1', '7', '37.8', '8', '2.2', '0']
package bsh ; import java . io . * ; public interface ConsoleInterface { public Reader getIn ( ) ; public PrintStream getOut ( ) ; public PrintStream getErr ( ) ; public void println ( String s ) ; public void print ( String s ) ; public void error ( String s ) ; } 	0	['6', '1', '0', '1', '6', '15', '1', '0', '6', '2', '6', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package bsh ; class BSHFormalParameters extends SimpleNode { int numArgs ; String [ ] argNames ; Class [ ] argTypes ; BSHFormalParameters ( int id ) { super ( id ) ; } public Object eval ( NameSpace namespace ) throws EvalError { numArgs = jjtGetNumChildren ( ) ; argNames = new String [ numArgs ] ; argTypes = new Class [ numArgs ] ; for ( int i = 0 ; i < numArgs ; i ++ ) { BSHFormalParameter param = ( BSHFormalParameter ) jjtGetChild ( i ) ; param . eval ( namespace ) ; argNames [ i ] = param . name ; argTypes [ i ] = param . type ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '9', '6', '1', '3', '6', '1', '1', '54', '0', '0', '0.947368421', '0.666666667', '1', '2', '24.5', '1', '0.5', '0']
package bsh ; import bsh . Capabilities . Unavailable ; public abstract class ReflectManager { private static ReflectManager rfm ; public static ReflectManager getReflectManager ( ) { if ( rfm == null ) { Class clas ; try { clas = BshClassManager . plainClassForName ( "bsh.reflect.ReflectManagerImpl" ) ; rfm = ( ReflectManager ) clas . newInstance ( ) ; } catch ( Exception e ) { throw new Unavailable ( "Reflect Manager unavailable: " + e ) ; } } return rfm ; } public static boolean RMSetAccessible ( Object obj ) throws Unavailable { return getReflectManager ( ) . setAccessible ( obj ) ; } public abstract boolean setAccessible ( Object o ) ; } 	0	['4', '1', '1', '4', '12', '6', '2', '2', '4', '0.666666667', '37', '1', '1', '0', '0.5', '0', '0', '8', '2', '1', '0']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . tree . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . File ; import java . util . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; public class PluginManager extends EnhancedDialog { public PluginManager ( Frame frame ) { super ( frame , jEdit . getProperty ( "plugin-manager.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel caption = new JLabel ( jEdit . getProperty ( "plugin-manager.caption" ) ) ; caption . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , caption ) ; tree = new JTree ( ) ; tree . setCellRenderer ( new Renderer ( ) ) ; tree . setRootVisible ( false ) ; tree . setVisibleRowCount ( 16 ) ; tree . addTreeSelectionListener ( new TreeHandler ( ) ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( BorderLayout . CENTER , new JScrollPane ( tree ) ) ; JPanel panel2 = new JPanel ( new BorderLayout ( ) ) ; panel2 . setBorder ( new EmptyBorder ( 6 , 0 , 0 , 0 ) ) ; JPanel labelBox = new JPanel ( new GridLayout ( 3 , 1 , 0 , 3 ) ) ; labelBox . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "plugin-manager" + ".info.name" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "plugin-manager" + ".info.author" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "plugin-manager" + ".info.version" ) , SwingConstants . RIGHT ) ) ; panel2 . add ( BorderLayout . WEST , labelBox ) ; JPanel valueBox = new JPanel ( new GridLayout ( 3 , 1 , 0 , 3 ) ) ; valueBox . add ( name = new JLabel ( ) ) ; valueBox . add ( author = new JLabel ( ) ) ; valueBox . add ( version = new JLabel ( ) ) ; panel2 . add ( BorderLayout . CENTER , valueBox ) ; panel . add ( BorderLayout . SOUTH , panel2 ) ; content . add ( BorderLayout . CENTER , panel ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; buttons . add ( Box . createGlue ( ) ) ; remove = new JButton ( jEdit . getProperty ( "plugin-manager" + ".remove" ) ) ; remove . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( remove ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; update = new JButton ( jEdit . getProperty ( "plugin-manager" + ".update" ) ) ; update . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( update ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; install = new JButton ( jEdit . getProperty ( "plugin-manager" + ".install" ) ) ; install . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( install ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( close ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , buttons ) ; updateTree ( ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( frame ) ; show ( ) ; } public void ok ( ) { } public void cancel ( ) { dispose ( ) ; } private JTree tree ; private JLabel name ; private JLabel author ; private JLabel version ; private JButton remove ; private JButton update ; private JButton install ; private JButton close ; private PluginList pluginList ; private PluginList getPluginList ( ) { if ( pluginList == null ) { pluginList = new PluginListDownloadProgress ( PluginManager . this ) . getPluginList ( ) ; } return pluginList ; } private void updateTree ( ) { DefaultMutableTreeNode treeRoot = new DefaultMutableTreeNode ( ) ; DefaultTreeModel treeModel = new DefaultTreeModel ( treeRoot ) ; DefaultMutableTreeNode loadedTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "plugin-manager.loaded" ) , true ) ; DefaultMutableTreeNode notLoadedTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "plugin-manager.not-loaded" ) , true ) ; DefaultMutableTreeNode newTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "plugin-manager.new" ) , true ) ; EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin plugin = plugins [ i ] ; String path = plugin . getJAR ( ) . getPath ( ) ; if ( ! new File ( path ) . exists ( ) ) { continue ; } if ( plugin instanceof EditPlugin . Broken ) { Entry entry = new Entry ( path , plugin . getClassName ( ) , true ) ; notLoadedTree . add ( new DefaultMutableTreeNode ( entry ) ) ; } else { Entry entry = new Entry ( path , plugin . getClassName ( ) , false ) ; loadedTree . add ( new DefaultMutableTreeNode ( entry ) ) ; } } if ( notLoadedTree . getChildCount ( ) != 0 ) treeRoot . add ( notLoadedTree ) ; if ( loadedTree . getChildCount ( ) != 0 ) treeRoot . add ( loadedTree ) ; String [ ] newPlugins = jEdit . getNotLoadedPluginJARs ( ) ; for ( int i = 0 ; i < newPlugins . length ; i ++ ) { Entry entry = new Entry ( newPlugins [ i ] , null , false ) ; newTree . add ( new DefaultMutableTreeNode ( entry ) ) ; } if ( newTree . getChildCount ( ) != 0 ) treeRoot . add ( newTree ) ; tree . setModel ( treeModel ) ; for ( int i = 0 ; i < tree . getRowCount ( ) ; i ++ ) tree . expandRow ( i ) ; remove . setEnabled ( false ) ; name . setText ( null ) ; author . setText ( null ) ; version . setText ( null ) ; } class Entry { String clazz ; String name , version , author ; Vector jars ; boolean broken ; Entry ( String path , String clazz , boolean broken ) { Entry . this . clazz = clazz ; Entry . this . broken = broken ; jars = new Vector ( ) ; jars . addElement ( path ) ; if ( clazz == null ) Entry . this . name = path ; else { Entry . this . name = jEdit . getProperty ( "plugin." + clazz + ".name" ) ; if ( name == null ) name = clazz ; Entry . this . version = jEdit . getProperty ( "plugin." + clazz + ".version" ) ; Entry . this . author = jEdit . getProperty ( "plugin." + clazz + ".author" ) ; String jarsProp = jEdit . getProperty ( "plugin." + clazz + ".jars" ) ; if ( jarsProp != null ) { String directory = MiscUtilities . getParentOfPath ( path ) ; StringTokenizer st = new StringTokenizer ( jarsProp ) ; while ( st . hasMoreElements ( ) ) { jars . addElement ( MiscUtilities . constructPath ( directory , st . nextToken ( ) ) ) ; } } } } public String toString ( ) { return Entry . this . name ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == close ) dispose ( ) ; else if ( source == remove ) { TreePath [ ] selected = tree . getSelectionModel ( ) . getSelectionPaths ( ) ; StringBuffer buf = new StringBuffer ( ) ; Roster roster = new Roster ( ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { Object last = ( ( DefaultMutableTreeNode ) selected [ i ] . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( last instanceof Entry ) { Entry entry = ( Entry ) last ; for ( int j = 0 ; j < entry . jars . size ( ) ; j ++ ) { String jar = ( String ) entry . jars . elementAt ( j ) ; if ( buf . length ( ) != 0 ) buf . append ( '\n' ) ; buf . append ( jar ) ; roster . addOperation ( new Roster . Remove ( jar ) ) ; } } } String [ ] args = { buf . toString ( ) } ; if ( GUIUtilities . confirm ( PluginManager . this , "plugin-manager.remove-confirm" , args , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . YES_OPTION ) { new PluginManagerProgress ( PluginManager . this , "remove" , roster ) ; updateTree ( ) ; } } else if ( source == update ) { if ( jEdit . getSettingsDirectory ( ) == null ) { GUIUtilities . error ( PluginManager . this , "no-settings" , null ) ; return ; } PluginList list = getPluginList ( ) ; if ( list == null ) return ; Vector plugins = new Vector ( ) ; for ( int i = 0 ; i < list . pluginSets . size ( ) ; i ++ ) { PluginList . PluginSet set = ( PluginList . PluginSet ) list . pluginSets . get ( i ) ; boolean addedSetLabel = false ; for ( int j = 0 ; j < set . plugins . size ( ) ; j ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) list . pluginHash . get ( set . plugins . get ( j ) ) ; PluginList . Branch branch = plugin . getCompatibleBranch ( ) ; if ( branch != null && branch . canSatisfyDependencies ( ) && plugin . installedVersion != null && MiscUtilities . compareStrings ( branch . version , plugin . installedVersion , false ) > 0 ) { if ( ! addedSetLabel ) { plugins . add ( new JCheckBoxList . Entry ( set . name + ":" ) ) ; addedSetLabel = true ; } plugins . addElement ( plugin ) ; } } } if ( plugins . size ( ) == 0 ) { GUIUtilities . message ( PluginManager . this , "plugin-manager.up-to-date" , null ) ; return ; } Roster roster = new Roster ( ) ; new InstallPluginsDialog ( PluginManager . this , plugins , InstallPluginsDialog . UPDATE ) . installPlugins ( roster ) ; if ( roster . isEmpty ( ) ) return ; new PluginManagerProgress ( PluginManager . this , "update" , roster ) ; updateTree ( ) ; } else if ( source == install ) { if ( jEdit . getSettingsDirectory ( ) == null && jEdit . getJEditHome ( ) == null ) { GUIUtilities . error ( PluginManager . this , "no-settings" , null ) ; return ; } PluginList list = getPluginList ( ) ; if ( list == null ) return ; Vector plugins = new Vector ( ) ; for ( int i = 0 ; i < list . pluginSets . size ( ) ; i ++ ) { PluginList . PluginSet set = ( PluginList . PluginSet ) list . pluginSets . get ( i ) ; boolean addedSetLabel = false ; for ( int j = 0 ; j < set . plugins . size ( ) ; j ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) list . pluginHash . get ( set . plugins . get ( j ) ) ; if ( plugin . installed == null && plugin . canBeInstalled ( ) ) { if ( ! addedSetLabel ) { plugins . add ( new JCheckBoxList . Entry ( set . name + ":" ) ) ; addedSetLabel = true ; } plugins . addElement ( plugin ) ; } } } Roster roster = new Roster ( ) ; new InstallPluginsDialog ( PluginManager . this , plugins , InstallPluginsDialog . INSTALL ) . installPlugins ( roster ) ; if ( roster . isEmpty ( ) ) return ; new PluginManagerProgress ( PluginManager . this , "install" , roster ) ; updateTree ( ) ; } } } class TreeHandler implements TreeSelectionListener { public void valueChanged ( TreeSelectionEvent evt ) { TreePath selection = evt . getPath ( ) ; DefaultMutableTreeNode node ; if ( selection == null ) { node = null ; } else { node = ( DefaultMutableTreeNode ) selection . getLastPathComponent ( ) ; } name . setText ( null ) ; author . setText ( null ) ; version . setText ( null ) ; if ( node != null && node . isLeaf ( ) && node . getUserObject ( ) instanceof Entry ) { remove . setEnabled ( true ) ; Entry entry = ( Entry ) node . getUserObject ( ) ; if ( entry . clazz != null ) { name . setText ( entry . name ) ; author . setText ( entry . author ) ; version . setText ( entry . version ) ; } } else remove . setEnabled ( false ) ; } } class Renderer extends DefaultTreeCellRenderer { public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean selected , boolean expanded , boolean leaf , int row , boolean hasFocus ) { super . getTreeCellRendererComponent ( tree , value , selected , expanded , leaf , row , hasFocus ) ; setIcon ( null ) ; return this ; } } } 	0	['15', '7', '0', '14', '71', '77', '8', '11', '3', '0.849206349', '584', '1', '1', '0.979104478', '0.355555556', '0', '0', '37.33333333', '9', '1.5333', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . * ; public class PastePrevious extends EnhancedDialog implements ActionListener , ListSelectionListener , MouseListener { public PastePrevious ( View view ) { super ( view , jEdit . getProperty ( "pasteprev.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; clipHistory = HistoryModel . getModel ( "clipboard" ) ; clips = new JList ( new AbstractListModel ( ) { public int getSize ( ) { return clipHistory . getSize ( ) ; } public Object getElementAt ( int index ) { StringBuffer buf = new StringBuffer ( ) ; String item = clipHistory . getItem ( index ) ; if ( item . toLowerCase ( ) . startsWith ( "<html>" ) ) buf . append ( ' ' ) ; boolean ws = true ; for ( int i = 0 ; i < item . length ( ) ; i ++ ) { char ch = item . charAt ( i ) ; if ( Character . isWhitespace ( ch ) ) { if ( ws ) ; else { buf . append ( ' ' ) ; ws = true ; } } else { ws = false ; buf . append ( ch ) ; } } return buf . toString ( ) ; } } ) ; clips . setVisibleRowCount ( 16 ) ; clips . addMouseListener ( this ) ; clips . addListSelectionListener ( this ) ; insert = new JButton ( jEdit . getProperty ( "pasteprev.insert" ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "pasteprev.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , label ) ; JScrollPane scroller = new JScrollPane ( clips ) ; Dimension dim = scroller . getPreferredSize ( ) ; scroller . setPreferredSize ( new Dimension ( 640 , dim . height ) ) ; content . add ( scroller , BorderLayout . CENTER ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( insert ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; panel . add ( cancel ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( panel , BorderLayout . SOUTH ) ; if ( clipHistory . getSize ( ) >= 1 ) clips . setSelectedIndex ( 0 ) ; updateButtons ( ) ; getRootPane ( ) . setDefaultButton ( insert ) ; insert . addActionListener ( this ) ; cancel . addActionListener ( this ) ; GUIUtilities . requestFocus ( this , clips ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { int selected = clips . getSelectedIndex ( ) ; if ( selected == - 1 ) { view . getToolkit ( ) . beep ( ) ; return ; } String clip = clipHistory . getItem ( selected ) ; view . getTextArea ( ) . setSelectedText ( clip ) ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == insert ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; } public void mouseClicked ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) ok ( ) ; } public void mouseEntered ( MouseEvent evt ) { } public void mouseExited ( MouseEvent evt ) { } public void mousePressed ( MouseEvent evt ) { } public void mouseReleased ( MouseEvent evt ) { } public void valueChanged ( ListSelectionEvent evt ) { updateButtons ( ) ; } private View view ; private JList clips ; private HistoryModel clipHistory ; private JButton insert ; private JButton cancel ; private void updateButtons ( ) { int selected = clips . getSelectedIndex ( ) ; insert . setEnabled ( selected != - 1 ) ; } } 	0	['12', '7', '0', '7', '59', '52', '1', '7', '10', '0.709090909', '284', '1', '2', '0.983508246', '0.277777778', '0', '0', '22.25', '3', '1.3333', '0']
package org . gjt . sp . jedit . search ; import org . gjt . sp . jedit . * ; public class CurrentBufferSet implements SearchFileSet { public String getFirstFile ( View view ) { return view . getBuffer ( ) . getPath ( ) ; } public String getNextFile ( View view , String file ) { if ( file == null ) return view . getBuffer ( ) . getPath ( ) ; else return null ; } public String [ ] getFiles ( View view ) { return new String [ ] { view . getBuffer ( ) . getPath ( ) } ; } public int getFileCount ( View view ) { return 1 ; } public String getCode ( ) { return "new CurrentBufferSet()" ; } } 	0	['6', '1', '0', '6', '9', '15', '4', '3', '6', '2', '34', '0', '0', '0', '0.611111111', '0', '0', '4.666666667', '2', '1', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . buffer . BufferIORequest ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . * ; public class CloseDialog extends EnhancedDialog { public CloseDialog ( View view ) { super ( view , jEdit . getProperty ( "close.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( 12 , 12 ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; Box iconBox = new Box ( BoxLayout . Y_AXIS ) ; iconBox . add ( new JLabel ( UIManager . getIcon ( "OptionPane.warningIcon" ) ) ) ; iconBox . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . WEST , iconBox ) ; JPanel centerPanel = new JPanel ( new BorderLayout ( ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "close.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; centerPanel . add ( BorderLayout . NORTH , label ) ; bufferList = new JList ( bufferModel = new DefaultListModel ( ) ) ; bufferList . setVisibleRowCount ( 10 ) ; bufferList . addListSelectionListener ( new ListHandler ( ) ) ; Buffer [ ] buffers = jEdit . getBuffers ( ) ; for ( int i = 0 ; i < buffers . length ; i ++ ) { Buffer buffer = buffers [ i ] ; if ( buffer . isDirty ( ) ) { bufferModel . addElement ( buffer . getPath ( ) ) ; } } centerPanel . add ( BorderLayout . CENTER , new JScrollPane ( bufferList ) ) ; content . add ( BorderLayout . CENTER , centerPanel ) ; ActionHandler actionListener = new ActionHandler ( ) ; Box buttons = new Box ( BoxLayout . X_AXIS ) ; buttons . add ( Box . createGlue ( ) ) ; buttons . add ( selectAll = new JButton ( jEdit . getProperty ( "close.selectAll" ) ) ) ; selectAll . setMnemonic ( jEdit . getProperty ( "close.selectAll.mnemonic" ) . charAt ( 0 ) ) ; selectAll . addActionListener ( actionListener ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( save = new JButton ( jEdit . getProperty ( "close.save" ) ) ) ; save . setMnemonic ( jEdit . getProperty ( "close.save.mnemonic" ) . charAt ( 0 ) ) ; save . addActionListener ( actionListener ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( discard = new JButton ( jEdit . getProperty ( "close.discard" ) ) ) ; discard . setMnemonic ( jEdit . getProperty ( "close.discard.mnemonic" ) . charAt ( 0 ) ) ; discard . addActionListener ( actionListener ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ) ; cancel . addActionListener ( actionListener ) ; buttons . add ( Box . createGlue ( ) ) ; bufferList . setSelectedIndex ( 0 ) ; content . add ( BorderLayout . SOUTH , buttons ) ; GUIUtilities . requestFocus ( this , bufferList ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public boolean isOK ( ) { return ok ; } public void ok ( ) { } public void cancel ( ) { dispose ( ) ; } private View view ; private JList bufferList ; private DefaultListModel bufferModel ; private JButton selectAll ; private JButton save ; private JButton discard ; private JButton cancel ; private boolean ok ; boolean selectAllFlag ; private void updateButtons ( ) { int index = bufferList . getSelectedIndex ( ) ; save . getModel ( ) . setEnabled ( index != - 1 ) ; discard . getModel ( ) . setEnabled ( index != - 1 ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == selectAll ) { try { selectAllFlag = true ; bufferList . setSelectionInterval ( 0 , bufferModel . getSize ( ) - 1 ) ; } finally { selectAllFlag = false ; } bufferList . requestFocus ( ) ; } else if ( source == save ) { Object [ ] paths = bufferList . getSelectedValues ( ) ; for ( int i = 0 ; i < paths . length ; i ++ ) { String path = ( String ) paths [ i ] ; Buffer buffer = jEdit . getBuffer ( path ) ; if ( ! buffer . save ( view , null , true ) ) return ; VFSManager . waitForRequests ( ) ; if ( buffer . getBooleanProperty ( BufferIORequest . ERROR_OCCURRED ) ) return ; jEdit . _closeBuffer ( view , buffer ) ; bufferModel . removeElement ( path ) ; } if ( bufferModel . getSize ( ) == 0 ) { ok = true ; dispose ( ) ; } else { bufferList . setSelectedIndex ( 0 ) ; bufferList . requestFocus ( ) ; } } else if ( source == discard ) { Object [ ] paths = bufferList . getSelectedValues ( ) ; for ( int i = 0 ; i < paths . length ; i ++ ) { String path = ( String ) paths [ i ] ; Buffer buffer = jEdit . getBuffer ( path ) ; jEdit . _closeBuffer ( view , buffer ) ; bufferModel . removeElement ( path ) ; } if ( bufferModel . getSize ( ) == 0 ) { ok = true ; dispose ( ) ; } else { bufferList . setSelectedIndex ( 0 ) ; bufferList . requestFocus ( ) ; } } else if ( source == cancel ) cancel ( ) ; } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { if ( selectAllFlag ) return ; int index = bufferList . getSelectedIndex ( ) ; if ( index != - 1 ) view . setBuffer ( jEdit . getBuffer ( ( String ) bufferModel . getElementAt ( index ) ) ) ; updateButtons ( ) ; } } } 	0	['14', '7', '0', '7', '55', '67', '3', '7', '4', '0.888888889', '356', '0.888888889', '1', '0.980568012', '0.285714286', '0', '0', '23.78571429', '3', '1.0714', '0']
package org . gjt . sp . jedit . gui ; import java . awt . * ; import java . awt . event . * ; import javax . swing . * ; public class AnimatedIcon extends ImageIcon { public AnimatedIcon ( Image icon , Image [ ] frames , int rate , Component host ) { super ( icon ) ; this . icon = icon ; this . frames = frames ; delay = 1000 / rate ; this . host = host ; } public Image [ ] getFrames ( ) { return frames ; } public Image getIcon ( ) { return icon ; } public int getRate ( ) { return 1000 / delay ; } public void setFrames ( Image [ ] frames ) { this . frames = frames ; } public void setIcon ( Image icon ) { this . icon = icon ; } public void setRate ( int rate ) { delay = 1000 / rate ; } public void start ( ) { if ( timer != null ) return ; timer = new Timer ( delay , new Animator ( ) ) ; timer . start ( ) ; } public void stop ( ) { current = 0 ; if ( timer != null ) { timer . stop ( ) ; timer = null ; } setImage ( icon ) ; host . repaint ( ) ; } private Image [ ] frames ; private int current ; private int delay ; private Timer timer ; private Component host ; private Image icon ; class Animator implements ActionListener { public void actionPerformed ( ActionEvent evt ) { current = ( current + 1 ) % frames . length ; setImage ( frames [ current ] ) ; host . repaint ( ) ; } } } 	0	['13', '2', '0', '1', '20', '30', '1', '1', '9', '0.805555556', '115', '1', '0', '0.571428571', '0.269230769', '0', '0', '7.384615385', '2', '1.0769', '0']
package gnu . regexp ; final class RETokenLookAhead extends REToken { REToken re ; boolean negative ; RETokenLookAhead ( REToken re , boolean negative ) throws REException { super ( 0 ) ; this . re = re ; this . negative = negative ; } boolean match ( CharIndexed input , REMatch mymatch ) { REMatch trymatch = ( REMatch ) mymatch . clone ( ) ; REMatch trymatch1 = ( REMatch ) mymatch . clone ( ) ; REMatch newMatch = null ; if ( re . match ( input , trymatch ) ) { if ( negative ) return false ; if ( next ( input , trymatch1 ) ) newMatch = trymatch1 ; } if ( newMatch != null ) { if ( negative ) return false ; mymatch . assignFrom ( newMatch ) ; return true ; } else { if ( negative ) return next ( input , mymatch ) ; return false ; } } void dump ( StringBuffer os ) { os . append ( "(?" ) ; os . append ( negative ? '!' : '=' ) ; re . dumpAll ( os ) ; os . append ( ')' ) ; } } 	0	['3', '2', '0', '5', '11', '0', '1', '4', '0', '0', '87', '0', '1', '0.777777778', '0.444444444', '1', '2', '27.33333333', '7', '3', '0']
package gnu . regexp ; import java . io . Serializable ; import java . util . BitSet ; public final class RESyntax implements Serializable { static final String DEFAULT_LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; private static final String SYNTAX_IS_FINAL = RE . getLocalizedMessage ( "syntax.final" ) ; private BitSet bits ; private boolean isFinal = false ; private String lineSeparator = DEFAULT_LINE_SEPARATOR ; public static final int RE_BACKSLASH_ESCAPE_IN_LISTS = 0 ; public static final int RE_BK_PLUS_QM = 1 ; public static final int RE_CHAR_CLASSES = 2 ; public static final int RE_CONTEXT_INDEP_ANCHORS = 3 ; public static final int RE_CONTEXT_INDEP_OPS = 4 ; public static final int RE_CONTEXT_INVALID_OPS = 5 ; public static final int RE_DOT_NEWLINE = 6 ; public static final int RE_DOT_NOT_NULL = 7 ; public static final int RE_INTERVALS = 8 ; public static final int RE_LIMITED_OPS = 9 ; public static final int RE_NEWLINE_ALT = 10 ; public static final int RE_NO_BK_BRACES = 11 ; public static final int RE_NO_BK_PARENS = 12 ; public static final int RE_NO_BK_REFS = 13 ; public static final int RE_NO_BK_VBAR = 14 ; public static final int RE_NO_EMPTY_RANGES = 15 ; public static final int RE_UNMATCHED_RIGHT_PAREN_ORD = 16 ; public static final int RE_HAT_LISTS_NOT_NEWLINE = 17 ; public static final int RE_STINGY_OPS = 18 ; public static final int RE_CHAR_CLASS_ESCAPES = 19 ; public static final int RE_PURE_GROUPING = 20 ; public static final int RE_LOOKAHEAD = 21 ; public static final int RE_STRING_ANCHORS = 22 ; public static final int RE_COMMENTS = 23 ; public static final int RE_CHAR_CLASS_ESC_IN_LISTS = 24 ; private static final int BIT_TOTAL = 25 ; public static final RESyntax RE_SYNTAX_AWK ; public static final RESyntax RE_SYNTAX_ED ; public static final RESyntax RE_SYNTAX_EGREP ; public static final RESyntax RE_SYNTAX_EMACS ; public static final RESyntax RE_SYNTAX_GREP ; public static final RESyntax RE_SYNTAX_POSIX_AWK ; public static final RESyntax RE_SYNTAX_POSIX_BASIC ; public static final RESyntax RE_SYNTAX_POSIX_EGREP ; public static final RESyntax RE_SYNTAX_POSIX_EXTENDED ; public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_BASIC ; public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_EXTENDED ; public static final RESyntax RE_SYNTAX_SED ; public static final RESyntax RE_SYNTAX_PERL4 ; public static final RESyntax RE_SYNTAX_PERL4_S ; public static final RESyntax RE_SYNTAX_PERL5 ; public static final RESyntax RE_SYNTAX_PERL5_S ; public static final RESyntax RE_SYNTAX_JAVA_1_4 ; static { RE_SYNTAX_EMACS = new RESyntax ( ) . makeFinal ( ) ; RESyntax RE_SYNTAX_POSIX_COMMON = new RESyntax ( ) . set ( RE_CHAR_CLASSES ) . set ( RE_DOT_NEWLINE ) . set ( RE_DOT_NOT_NULL ) . set ( RE_INTERVALS ) . set ( RE_NO_EMPTY_RANGES ) . makeFinal ( ) ; RE_SYNTAX_POSIX_BASIC = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_BK_PLUS_QM ) . makeFinal ( ) ; RE_SYNTAX_POSIX_EXTENDED = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INDEP_OPS ) . set ( RE_NO_BK_BRACES ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_VBAR ) . set ( RE_UNMATCHED_RIGHT_PAREN_ORD ) . makeFinal ( ) ; RE_SYNTAX_AWK = new RESyntax ( ) . set ( RE_BACKSLASH_ESCAPE_IN_LISTS ) . set ( RE_DOT_NOT_NULL ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_REFS ) . set ( RE_NO_BK_VBAR ) . set ( RE_NO_EMPTY_RANGES ) . set ( RE_UNMATCHED_RIGHT_PAREN_ORD ) . makeFinal ( ) ; RE_SYNTAX_POSIX_AWK = new RESyntax ( RE_SYNTAX_POSIX_EXTENDED ) . set ( RE_BACKSLASH_ESCAPE_IN_LISTS ) . makeFinal ( ) ; RE_SYNTAX_GREP = new RESyntax ( ) . set ( RE_BK_PLUS_QM ) . set ( RE_CHAR_CLASSES ) . set ( RE_HAT_LISTS_NOT_NEWLINE ) . set ( RE_INTERVALS ) . set ( RE_NEWLINE_ALT ) . makeFinal ( ) ; RE_SYNTAX_EGREP = new RESyntax ( ) . set ( RE_CHAR_CLASSES ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INDEP_OPS ) . set ( RE_HAT_LISTS_NOT_NEWLINE ) . set ( RE_NEWLINE_ALT ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_VBAR ) . makeFinal ( ) ; RE_SYNTAX_POSIX_EGREP = new RESyntax ( RE_SYNTAX_EGREP ) . set ( RE_INTERVALS ) . set ( RE_NO_BK_BRACES ) . makeFinal ( ) ; RE_SYNTAX_ED = new RESyntax ( RE_SYNTAX_POSIX_BASIC ) . makeFinal ( ) ; RE_SYNTAX_SED = new RESyntax ( RE_SYNTAX_POSIX_BASIC ) . makeFinal ( ) ; RE_SYNTAX_POSIX_MINIMAL_BASIC = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_LIMITED_OPS ) . makeFinal ( ) ; RE_SYNTAX_POSIX_MINIMAL_EXTENDED = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INVALID_OPS ) . set ( RE_NO_BK_BRACES ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_REFS ) . set ( RE_NO_BK_VBAR ) . set ( RE_UNMATCHED_RIGHT_PAREN_ORD ) . makeFinal ( ) ; RE_SYNTAX_PERL4 = new RESyntax ( ) . set ( RE_BACKSLASH_ESCAPE_IN_LISTS ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INDEP_OPS ) . set ( RE_INTERVALS ) . set ( RE_NO_BK_BRACES ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_VBAR ) . set ( RE_NO_EMPTY_RANGES ) . set ( RE_CHAR_CLASS_ESCAPES ) . makeFinal ( ) ; RE_SYNTAX_PERL4_S = new RESyntax ( RE_SYNTAX_PERL4 ) . set ( RE_DOT_NEWLINE ) . makeFinal ( ) ; RE_SYNTAX_PERL5 = new RESyntax ( RE_SYNTAX_PERL4 ) . set ( RE_PURE_GROUPING ) . set ( RE_STINGY_OPS ) . set ( RE_LOOKAHEAD ) . set ( RE_STRING_ANCHORS ) . set ( RE_CHAR_CLASS_ESC_IN_LISTS ) . set ( RE_COMMENTS ) . makeFinal ( ) ; RE_SYNTAX_PERL5_S = new RESyntax ( RE_SYNTAX_PERL5 ) . set ( RE_DOT_NEWLINE ) . makeFinal ( ) ; RE_SYNTAX_JAVA_1_4 = new RESyntax ( RE_SYNTAX_PERL5 ) . makeFinal ( ) ; } public RESyntax ( ) { bits = new BitSet ( BIT_TOTAL ) ; } public RESyntax makeFinal ( ) { isFinal = true ; return this ; } public RESyntax ( RESyntax other ) { bits = ( BitSet ) other . bits . clone ( ) ; } public boolean get ( int index ) { return bits . get ( index ) ; } public RESyntax set ( int index ) { if ( isFinal ) throw new IllegalAccessError ( SYNTAX_IS_FINAL ) ; bits . set ( index ) ; return this ; } public RESyntax clear ( int index ) { if ( isFinal ) throw new IllegalAccessError ( SYNTAX_IS_FINAL ) ; bits . clear ( index ) ; return this ; } public RESyntax setLineSeparator ( String aSeparator ) { if ( isFinal ) throw new IllegalAccessError ( SYNTAX_IS_FINAL ) ; lineSeparator = aSeparator ; return this ; } public String getLineSeparator ( ) { return lineSeparator ; } } 	0	['9', '1', '0', '6', '18', '0', '6', '1', '8', '1.015625', '368', '0.104166667', '17', '0', '0.40625', '0', '0', '34.55555556', '2', '1', '0']
package bsh ; class BSHTypedVariableDeclaration extends SimpleNode { public boolean isFinal ; BSHTypedVariableDeclaration ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { try { NameSpace namespace = callstack . top ( ) ; BSHType typeNode = ( ( BSHType ) jjtGetChild ( 0 ) ) ; Class type = typeNode . getType ( namespace ) ; int n = jjtGetNumChildren ( ) ; for ( int i = 1 ; i < n ; i ++ ) { BSHVariableDeclarator dec = ( BSHVariableDeclarator ) jjtGetChild ( i ) ; Object value = dec . eval ( typeNode , callstack , interpreter ) ; if ( value == Primitive . VOID ) value = null ; else if ( value == Primitive . NULL ) { } else if ( canCastToDeclaredType ( value , type ) ) value = BSHCastExpression . castObject ( value , type ) ; else { } namespace . setTypedVariable ( dec . name , type , value , isFinal ) ; } } catch ( EvalError e ) { e . reThrow ( "Typed variable declaration" , this ) ; } return Primitive . VOID ; } boolean canCastToDeclaredType ( Object value , Class toType ) { if ( ! ( value instanceof Primitive ) ) return false ; Class fromType = ( ( Primitive ) value ) . getType ( ) ; if ( ( toType == Byte . TYPE || toType == Short . TYPE || toType == Character . TYPE ) && fromType == Integer . TYPE ) return true ; else return false ; } } 	0	['3', '2', '0', '11', '13', '3', '1', '10', '1', '1', '102', '0', '0', '0.9', '0.444444444', '1', '1', '32.66666667', '6', '2.3333', '0']
package org . gjt . sp . jedit . textarea ; import java . awt . Toolkit ; import org . gjt . sp . jedit . buffer . OffsetManager ; import org . gjt . sp . jedit . * ; public class FoldVisibilityManager { public FoldVisibilityManager ( Buffer buffer , OffsetManager offsetMgr , JEditTextArea textArea ) { this . buffer = buffer ; this . offsetMgr = offsetMgr ; this . textArea = textArea ; } public boolean isNarrowed ( ) { return narrowed ; } public int getVirtualLineCount ( ) { return offsetMgr . getVirtualLineCount ( index ) ; } public final boolean isLineVisible ( int line ) { if ( line < 0 || line >= offsetMgr . getLineCount ( ) ) throw new ArrayIndexOutOfBoundsException ( line ) ; try { buffer . readLock ( ) ; return offsetMgr . isLineVisible ( line , index ) ; } finally { buffer . readUnlock ( ) ; } } public int getFirstVisibleLine ( ) { try { buffer . readLock ( ) ; for ( int i = 0 ; i < buffer . getLineCount ( ) ; i ++ ) { if ( offsetMgr . isLineVisible ( i , index ) ) return i ; } } finally { buffer . readUnlock ( ) ; } return - 1 ; } public int getLastVisibleLine ( ) { try { buffer . readLock ( ) ; for ( int i = buffer . getLineCount ( ) - 1 ; i >= 0 ; i -- ) { if ( offsetMgr . isLineVisible ( i , index ) ) return i ; } } finally { buffer . readUnlock ( ) ; } return - 1 ; } public int getNextVisibleLine ( int line ) { if ( line < 0 || line >= offsetMgr . getLineCount ( ) ) throw new ArrayIndexOutOfBoundsException ( line ) ; try { buffer . readLock ( ) ; if ( line == buffer . getLineCount ( ) - 1 ) return - 1 ; for ( int i = line + 1 ; i < buffer . getLineCount ( ) ; i ++ ) { if ( offsetMgr . isLineVisible ( i , index ) ) return i ; } return - 1 ; } finally { buffer . readUnlock ( ) ; } } public int getPrevVisibleLine ( int line ) { if ( line < 0 || line >= offsetMgr . getLineCount ( ) ) throw new ArrayIndexOutOfBoundsException ( line ) ; try { buffer . readLock ( ) ; if ( line == 0 ) return - 1 ; for ( int i = line - 1 ; i >= 0 ; i -- ) { if ( offsetMgr . isLineVisible ( i , index ) ) return i ; } return - 1 ; } finally { buffer . readUnlock ( ) ; } } public int physicalToVirtual ( int line ) { try { buffer . readLock ( ) ; if ( line < 0 ) throw new ArrayIndexOutOfBoundsException ( line + " < 0" ) ; else if ( line >= offsetMgr . getLineCount ( ) ) { throw new ArrayIndexOutOfBoundsException ( line + " > " + buffer . getLineCount ( ) ) ; } if ( getVirtualLineCount ( ) == buffer . getLineCount ( ) ) return line ; while ( ! offsetMgr . isLineVisible ( line , index ) && line > 0 ) line -- ; if ( line == 0 && ! offsetMgr . isLineVisible ( line , index ) ) { return 0 ; } if ( lastPhysical == line ) { if ( lastVirtual < 0 || lastVirtual >= offsetMgr . getVirtualLineCount ( index ) ) { throw new ArrayIndexOutOfBoundsException ( "cached: " + lastVirtual ) ; } } else if ( line > lastPhysical && lastPhysical != - 1 ) { for ( ; ; ) { if ( lastPhysical == line ) break ; if ( offsetMgr . isLineVisible ( lastPhysical , index ) ) lastVirtual ++ ; if ( lastPhysical == buffer . getLineCount ( ) - 1 ) break ; else lastPhysical ++ ; } if ( lastVirtual < 0 || lastVirtual >= offsetMgr . getVirtualLineCount ( index ) ) { throw new ArrayIndexOutOfBoundsException ( "fwd scan: " + lastVirtual ) ; } } else if ( line < lastPhysical && lastPhysical - line > line ) { for ( ; ; ) { if ( lastPhysical == line ) break ; if ( offsetMgr . isLineVisible ( lastPhysical , index ) ) lastVirtual -- ; if ( lastPhysical == 0 ) break ; else lastPhysical -- ; } if ( lastVirtual < 0 || lastVirtual >= offsetMgr . getVirtualLineCount ( index ) ) { throw new ArrayIndexOutOfBoundsException ( "back scan: " + lastVirtual ) ; } } else { lastPhysical = 0 ; while ( ! offsetMgr . isLineVisible ( lastPhysical , index ) ) lastPhysical ++ ; lastVirtual = 0 ; for ( ; ; ) { if ( lastPhysical == line ) break ; if ( offsetMgr . isLineVisible ( lastPhysical , index ) ) lastVirtual ++ ; if ( lastPhysical == buffer . getLineCount ( ) - 1 ) break ; else lastPhysical ++ ; } if ( lastVirtual < 0 || lastVirtual >= offsetMgr . getVirtualLineCount ( index ) ) { throw new ArrayIndexOutOfBoundsException ( "zero scan: " + lastVirtual ) ; } } return lastVirtual ; } finally { buffer . readUnlock ( ) ; } } public int virtualToPhysical ( int line ) { try { buffer . readLock ( ) ; if ( line < 0 ) throw new ArrayIndexOutOfBoundsException ( line + " < 0" ) ; else if ( line >= offsetMgr . getVirtualLineCount ( index ) ) { throw new ArrayIndexOutOfBoundsException ( line + " > " + offsetMgr . getVirtualLineCount ( index ) ) ; } if ( getVirtualLineCount ( ) == buffer . getLineCount ( ) ) return line ; if ( lastVirtual == line ) { if ( lastPhysical < 0 || lastPhysical >= buffer . getLineCount ( ) ) { throw new ArrayIndexOutOfBoundsException ( "cached: " + lastPhysical ) ; } } else if ( line > lastVirtual && lastVirtual != - 1 ) { for ( ; ; ) { if ( offsetMgr . isLineVisible ( lastPhysical , index ) ) { if ( lastVirtual == line ) break ; else lastVirtual ++ ; } if ( lastPhysical == buffer . getLineCount ( ) - 1 ) break ; else lastPhysical ++ ; } if ( lastPhysical < 0 || lastPhysical >= buffer . getLineCount ( ) ) { throw new ArrayIndexOutOfBoundsException ( "fwd scan: " + lastPhysical ) ; } } else if ( line < lastVirtual && lastVirtual - line > line ) { for ( ; ; ) { if ( offsetMgr . isLineVisible ( lastPhysical , index ) ) { if ( lastVirtual == line ) break ; else lastVirtual -- ; } if ( lastPhysical == 0 ) break ; else lastPhysical -- ; } if ( lastPhysical < 0 || lastPhysical >= buffer . getLineCount ( ) ) { throw new ArrayIndexOutOfBoundsException ( "back scan: " + lastPhysical ) ; } } else { lastPhysical = 0 ; while ( ! offsetMgr . isLineVisible ( lastPhysical , index ) ) lastPhysical ++ ; lastVirtual = 0 ; for ( ; ; ) { if ( offsetMgr . isLineVisible ( lastPhysical , index ) ) { if ( lastVirtual == line ) break ; else lastVirtual ++ ; } if ( lastPhysical == buffer . getLineCount ( ) - 1 ) break ; else lastPhysical ++ ; } if ( lastPhysical < 0 || lastPhysical >= buffer . getLineCount ( ) ) { throw new ArrayIndexOutOfBoundsException ( "zero scan: " + lastPhysical ) ; } } return lastPhysical ; } finally { buffer . readUnlock ( ) ; } } public void collapseFold ( int line ) { int lineCount = buffer . getLineCount ( ) ; int start = 0 ; int end = lineCount - 1 ; try { buffer . writeLock ( ) ; if ( line != 0 && line != buffer . getLineCount ( ) - 1 && buffer . isFoldStart ( line ) && ! offsetMgr . isLineVisible ( line + 1 , index ) ) { line -- ; } int initialFoldLevel = buffer . getFoldLevel ( line ) ; if ( line != lineCount - 1 && buffer . getFoldLevel ( line + 1 ) > initialFoldLevel ) { start = line + 1 ; for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( buffer . getFoldLevel ( i ) <= initialFoldLevel ) { end = i - 1 ; break ; } } } else { boolean ok = false ; for ( int i = line - 1 ; i >= 0 ; i -- ) { if ( buffer . getFoldLevel ( i ) < initialFoldLevel ) { start = i + 1 ; ok = true ; break ; } } if ( ! ok ) { return ; } for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( buffer . getFoldLevel ( i ) < initialFoldLevel ) { end = i - 1 ; break ; } } } int delta = ( end - start + 1 ) ; for ( int i = start ; i <= end ; i ++ ) { if ( offsetMgr . isLineVisible ( i , index ) ) offsetMgr . setLineVisible ( i , index , false ) ; else delta -- ; } if ( delta == 0 ) { return ; } offsetMgr . setVirtualLineCount ( index , offsetMgr . getVirtualLineCount ( index ) - delta ) ; } finally { buffer . writeUnlock ( ) ; } foldStructureChanged ( ) ; int virtualLine = physicalToVirtual ( start ) ; if ( textArea . getFirstLine ( ) > virtualLine ) textArea . setFirstLine ( virtualLine - textArea . getElectricScroll ( ) ) ; } public int expandFold ( int line , boolean fully ) { int returnValue = - 1 ; int lineCount = buffer . getLineCount ( ) ; int start = 0 ; int end = lineCount - 1 ; int delta = 0 ; try { buffer . writeLock ( ) ; int initialFoldLevel = buffer . getFoldLevel ( line ) ; if ( line != lineCount - 1 && offsetMgr . isLineVisible ( line , index ) && ! offsetMgr . isLineVisible ( line + 1 , index ) && buffer . getFoldLevel ( line + 1 ) > initialFoldLevel ) { start = line + 1 ; for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( buffer . getFoldLevel ( i ) <= initialFoldLevel ) { end = i - 1 ; break ; } } } else { boolean ok = false ; for ( int i = line - 1 ; i >= 0 ; i -- ) { if ( offsetMgr . isLineVisible ( i , index ) && buffer . getFoldLevel ( i ) < initialFoldLevel ) { start = i + 1 ; ok = true ; break ; } } if ( ! ok ) { return - 1 ; } for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( ( offsetMgr . isLineVisible ( i , index ) && buffer . getFoldLevel ( i ) < initialFoldLevel ) || i == getLastVisibleLine ( ) ) { end = i - 1 ; break ; } } } initialFoldLevel = buffer . getFoldLevel ( start ) ; for ( int i = start ; i <= end ; i ++ ) { buffer . getFoldLevel ( i ) ; } for ( int i = start ; i <= end ; i ++ ) { if ( buffer . getFoldLevel ( i ) > initialFoldLevel ) { if ( returnValue == - 1 && i != 0 && buffer . isFoldStart ( i - 1 ) ) { returnValue = i - 1 ; } if ( ! offsetMgr . isLineVisible ( i , index ) && fully ) { delta ++ ; offsetMgr . setLineVisible ( i , index , true ) ; } } else if ( ! offsetMgr . isLineVisible ( i , index ) ) { delta ++ ; offsetMgr . setLineVisible ( i , index , true ) ; } } offsetMgr . setVirtualLineCount ( index , offsetMgr . getVirtualLineCount ( index ) + delta ) ; if ( ! fully && ! offsetMgr . isLineVisible ( line , index ) ) { expandFold ( line , false ) ; return returnValue ; } } finally { buffer . writeUnlock ( ) ; } foldStructureChanged ( ) ; int virtualLine = physicalToVirtual ( start ) ; int firstLine = textArea . getFirstLine ( ) ; int visibleLines = textArea . getVisibleLines ( ) ; if ( virtualLine + delta >= firstLine + visibleLines && delta < visibleLines - 1 ) { textArea . setFirstLine ( virtualLine + delta - visibleLines + 1 ) ; } return returnValue ; } public void expandAllFolds ( ) { try { buffer . writeLock ( ) ; narrowed = false ; if ( offsetMgr . getVirtualLineCount ( index ) == buffer . getLineCount ( ) ) return ; offsetMgr . setVirtualLineCount ( index , buffer . getLineCount ( ) ) ; for ( int i = 0 ; i < buffer . getLineCount ( ) ; i ++ ) { offsetMgr . setLineVisible ( i , index , true ) ; } foldStructureChanged ( ) ; } finally { buffer . writeUnlock ( ) ; } } public void expandFolds ( char digit ) { if ( digit < '1' || digit > '9' ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } else expandFolds ( ( int ) ( digit - '1' ) + 1 ) ; } public void expandFolds ( int foldLevel ) { try { buffer . writeLock ( ) ; narrowed = false ; offsetMgr . setVirtualLineCount ( index , buffer . getLineCount ( ) ) ; int newVirtualLineCount = 0 ; foldLevel = ( foldLevel - 1 ) * buffer . getIndentSize ( ) + 1 ; boolean seenVisibleLine = false ; for ( int i = 0 ; i < buffer . getLineCount ( ) ; i ++ ) { if ( ! seenVisibleLine || buffer . getFoldLevel ( i ) < foldLevel ) { seenVisibleLine = true ; offsetMgr . setLineVisible ( i , index , true ) ; newVirtualLineCount ++ ; } else offsetMgr . setLineVisible ( i , index , false ) ; } offsetMgr . setVirtualLineCount ( index , newVirtualLineCount ) ; } finally { buffer . writeUnlock ( ) ; } foldStructureChanged ( ) ; } public void narrow ( int start , int end ) { if ( start > end || start < 0 || end >= offsetMgr . getLineCount ( ) ) throw new ArrayIndexOutOfBoundsException ( start + ", " + end ) ; if ( start < getFirstVisibleLine ( ) || end > getLastVisibleLine ( ) ) expandAllFolds ( ) ; else if ( start != offsetMgr . getLineCount ( ) - 1 && ! offsetMgr . isLineVisible ( start + 1 , index ) ) expandFold ( start , false ) ; int virtualLineCount = offsetMgr . getVirtualLineCount ( index ) ; for ( int i = 0 ; i < start ; i ++ ) { if ( offsetMgr . isLineVisible ( i , index ) ) { virtualLineCount -- ; offsetMgr . setLineVisible ( i , index , false ) ; } } for ( int i = end + 1 ; i < buffer . getLineCount ( ) ; i ++ ) { if ( offsetMgr . isLineVisible ( i , index ) ) { virtualLineCount -- ; offsetMgr . setLineVisible ( i , index , false ) ; } } offsetMgr . setVirtualLineCount ( index , virtualLineCount ) ; narrowed = true ; foldStructureChanged ( ) ; GUIUtilities . getView ( textArea ) . getStatus ( ) . setMessageAndClear ( jEdit . getProperty ( "view.status.narrow" ) ) ; } public final void _grab ( int index ) { this . index = index ; lastPhysical = lastVirtual = - 1 ; } public final void _release ( ) { index = - 1 ; } public final int _getIndex ( ) { return index ; } public void _invalidate ( int startLine ) { if ( lastPhysical >= startLine ) lastPhysical = lastVirtual = - 1 ; } public void foldStructureChanged ( ) { lastPhysical = lastVirtual = - 1 ; textArea . foldStructureChanged ( ) ; } private Buffer buffer ; private OffsetManager offsetMgr ; private JEditTextArea textArea ; private int index ; private int lastPhysical ; private int lastVirtual ; private boolean narrowed ; } 	0	['21', '1', '0', '14', '52', '0', '9', '7', '21', '0.492857143', '1738', '1', '3', '0', '0.25170068', '0', '0', '81.42857143', '35', '9.0952', '0']
package org . gjt . sp . jedit ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . Component ; public abstract class EditAction { public EditAction ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String getLabel ( ) { return jEdit . getProperty ( name + ".label" ) ; } public String getMouseOverText ( ) { return null ; } public abstract void invoke ( View view ) ; public static View getView ( Component comp ) { return GUIUtilities . getView ( comp ) ; } public boolean isToggle ( ) { return false ; } public boolean isSelected ( View view ) { return false ; } public boolean noRepeat ( ) { return false ; } public boolean noRecord ( ) { return false ; } public abstract String getCode ( ) ; public String toString ( ) { return name ; } private String name ; public static class Wrapper implements ActionListener { public Wrapper ( EditAction action ) { this . action = action ; } public void actionPerformed ( ActionEvent evt ) { jEdit . getActiveView ( ) . getInputHandler ( ) . invokeAction ( action ) ; } private EditAction action ; } } 	0	['12', '1', '5', '29', '18', '54', '28', '3', '12', '0.727272727', '49', '1', '0', '0', '0.3125', '0', '0', '3', '1', '0.9167', '0']
package org . gjt . sp . jedit ; import javax . swing . SwingUtilities ; import java . io . * ; import java . net . * ; import java . util . Random ; import org . gjt . sp . jedit . io . FileVFS ; import org . gjt . sp . util . Log ; public class EditServer extends Thread { EditServer ( String portFile ) { super ( "jEdit server daemon [" + portFile + "]" ) ; setDaemon ( true ) ; this . portFile = portFile ; try { if ( OperatingSystem . isUnix ( ) ) { new File ( portFile ) . createNewFile ( ) ; FileVFS . setPermissions ( portFile , 0600 ) ; } socket = new ServerSocket ( 0 , 2 , InetAddress . getByName ( "127.0.0.1" ) ) ; authKey = Math . abs ( new Random ( ) . nextInt ( ) ) ; int port = socket . getLocalPort ( ) ; FileWriter out = new FileWriter ( portFile ) ; out . write ( "b\n" ) ; out . write ( String . valueOf ( port ) ) ; out . write ( "\n" ) ; out . write ( String . valueOf ( authKey ) ) ; out . write ( "\n" ) ; out . close ( ) ; Log . log ( Log . DEBUG , this , "jEdit server started on port " + socket . getLocalPort ( ) ) ; Log . log ( Log . DEBUG , this , "Authorization key is " + authKey ) ; ok = true ; } catch ( IOException io ) { Log . log ( Log . NOTICE , this , io ) ; } } public void run ( ) { for ( ; ; ) { if ( abort ) return ; Socket client = null ; try { client = socket . accept ( ) ; client . setSoTimeout ( 1000 ) ; Log . log ( Log . MESSAGE , this , client + ": connected" ) ; DataInputStream in = new DataInputStream ( client . getInputStream ( ) ) ; if ( ! handleClient ( client , in ) ) abort = true ; } catch ( Exception e ) { if ( ! abort ) Log . log ( Log . ERROR , this , e ) ; abort = true ; } finally { if ( client != null ) { try { client . close ( ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } client = null ; } } } } public static void handleClient ( boolean restore , String parent , String [ ] args ) { String splitConfig = null ; boolean newView = jEdit . getBooleanProperty ( "client.newView" ) ; if ( jEdit . getFirstView ( ) == null || newView ) { Buffer buffer = jEdit . openFiles ( null , parent , args ) ; if ( restore ) { if ( jEdit . getFirstBuffer ( ) == null || ( jEdit . getFirstBuffer ( ) . isUntitled ( ) && jEdit . getBufferCount ( ) == 1 ) ) splitConfig = jEdit . restoreOpenFiles ( ) ; else if ( jEdit . getBooleanProperty ( "restore.cli" ) ) { jEdit . restoreOpenFiles ( ) ; } } if ( jEdit . getFirstBuffer ( ) == null || ( jEdit . getFirstBuffer ( ) . isUntitled ( ) && jEdit . getBufferCount ( ) == 1 ) ) buffer = jEdit . newFile ( null ) ; if ( splitConfig != null ) jEdit . newView ( null , splitConfig ) ; else jEdit . newView ( null , buffer ) ; } else { View view = jEdit . getFirstView ( ) ; jEdit . openFiles ( view , parent , args ) ; if ( OperatingSystem . isWindows ( ) ) view . setState ( java . awt . Frame . ICONIFIED ) ; view . setState ( java . awt . Frame . NORMAL ) ; view . requestFocus ( ) ; view . toFront ( ) ; return ; } } boolean isOK ( ) { return ok ; } void stopServer ( ) { abort = true ; try { socket . close ( ) ; } catch ( IOException io ) { } new File ( portFile ) . delete ( ) ; } private String portFile ; private ServerSocket socket ; private int authKey ; private boolean ok ; private boolean abort ; private boolean handleClient ( Socket client , DataInputStream in ) throws Exception { int key = in . readInt ( ) ; if ( key != authKey ) { Log . log ( Log . ERROR , this , client + ": wrong" + " authorization key (got " + key + ", expected " + authKey + ")" ) ; in . close ( ) ; client . close ( ) ; return false ; } else { client . setSoTimeout ( 0 ) ; Log . log ( Log . DEBUG , this , client + ": authenticated" + " successfully" ) ; final String script = in . readUTF ( ) ; Log . log ( Log . DEBUG , this , script ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { BeanShell . eval ( null , BeanShell . getNameSpace ( ) , script ) ; } } ) ; return true ; } } } 	0	['6', '2', '0', '8', '54', '5', '3', '7', '2', '0.72', '377', '1', '0', '0.924242424', '0.305555556', '0', '0', '61', '13', '3.8333', '0']
package bsh ; public interface ParserConstants { int EOF = 0 ; int NONPRINTABLE = 6 ; int SINGLE_LINE_COMMENT = 7 ; int HASH_BANG_COMMENT = 8 ; int MULTI_LINE_COMMENT = 9 ; int BOOLEAN = 10 ; int BREAK = 11 ; int CLASS = 12 ; int BYTE = 13 ; int CASE = 14 ; int CATCH = 15 ; int CHAR = 16 ; int CONST = 17 ; int CONTINUE = 18 ; int _DEFAULT = 19 ; int DO = 20 ; int DOUBLE = 21 ; int ELSE = 22 ; int FALSE = 23 ; int FINAL = 24 ; int FINALLY = 25 ; int FLOAT = 26 ; int FOR = 27 ; int GOTO = 28 ; int IF = 29 ; int IMPORT = 30 ; int INSTANCEOF = 31 ; int INT = 32 ; int INTERFACE = 33 ; int LONG = 34 ; int NEW = 35 ; int NULL = 36 ; int PRIVATE = 37 ; int PROTECTED = 38 ; int PUBLIC = 39 ; int RETURN = 40 ; int SHORT = 41 ; int STATIC = 42 ; int SWITCH = 43 ; int THROW = 44 ; int TRUE = 45 ; int TRY = 46 ; int VOID = 47 ; int WHILE = 48 ; int INTEGER_LITERAL = 49 ; int DECIMAL_LITERAL = 50 ; int HEX_LITERAL = 51 ; int OCTAL_LITERAL = 52 ; int FLOATING_POINT_LITERAL = 53 ; int EXPONENT = 54 ; int CHARACTER_LITERAL = 55 ; int STRING_LITERAL = 56 ; int FORMAL_COMMENT = 57 ; int IDENTIFIER = 58 ; int LETTER = 59 ; int DIGIT = 60 ; int LPAREN = 61 ; int RPAREN = 62 ; int LBRACE = 63 ; int RBRACE = 64 ; int LBRACKET = 65 ; int RBRACKET = 66 ; int SEMICOLON = 67 ; int COMMA = 68 ; int DOT = 69 ; int ASSIGN = 70 ; int GT = 71 ; int GTX = 72 ; int LT = 73 ; int LTX = 74 ; int BANG = 75 ; int TILDE = 76 ; int HOOK = 77 ; int COLON = 78 ; int EQ = 79 ; int LE = 80 ; int LEX = 81 ; int GE = 82 ; int GEX = 83 ; int NE = 84 ; int BOOL_OR = 85 ; int BOOL_ORX = 86 ; int BOOL_AND = 87 ; int BOOL_ANDX = 88 ; int INCR = 89 ; int DECR = 90 ; int PLUS = 91 ; int MINUS = 92 ; int STAR = 93 ; int SLASH = 94 ; int BIT_AND = 95 ; int BIT_ANDX = 96 ; int BIT_OR = 97 ; int BIT_ORX = 98 ; int XOR = 99 ; int MOD = 100 ; int LSHIFT = 101 ; int LSHIFTX = 102 ; int RSIGNEDSHIFT = 103 ; int RSIGNEDSHIFTX = 104 ; int RUNSIGNEDSHIFT = 105 ; int RUNSIGNEDSHIFTX = 106 ; int PLUSASSIGN = 107 ; int MINUSASSIGN = 108 ; int STARASSIGN = 109 ; int SLASHASSIGN = 110 ; int ANDASSIGN = 111 ; int ANDASSIGNX = 112 ; int ORASSIGN = 113 ; int ORASSIGNX = 114 ; int XORASSIGN = 115 ; int MODASSIGN = 116 ; int LSHIFTASSIGN = 117 ; int LSHIFTASSIGNX = 118 ; int RSIGNEDSHIFTASSIGN = 119 ; int RSIGNEDSHIFTASSIGNX = 120 ; int RUNSIGNEDSHIFTASSIGN = 121 ; int RUNSIGNEDSHIFTASSIGNX = 122 ; int DEFAULT = 0 ; String [ ] tokenImage = { "<EOF>" , "\" \"" , "\"\\t\"" , "\"\\r\"" , "\"\\f\"" , "\"\\n\"" , "<NONPRINTABLE>" , "<SINGLE_LINE_COMMENT>" , "<HASH_BANG_COMMENT>" , "<MULTI_LINE_COMMENT>" , "\"boolean\"" , "\"break\"" , "\"class\"" , "\"byte\"" , "\"case\"" , "\"catch\"" , "\"char\"" , "\"const\"" , "\"continue\"" , "\"default\"" , "\"do\"" , "\"double\"" , "\"else\"" , "\"false\"" , "\"final\"" , "\"finally\"" , "\"float\"" , "\"for\"" , "\"goto\"" , "\"if\"" , "\"import\"" , "\"instanceof\"" , "\"int\"" , "\"interface\"" , "\"long\"" , "\"new\"" , "\"null\"" , "\"private\"" , "\"protected\"" , "\"public\"" , "\"return\"" , "\"short\"" , "\"static\"" , "\"switch\"" , "\"throw\"" , "\"true\"" , "\"try\"" , "\"void\"" , "\"while\"" , "<INTEGER_LITERAL>" , "<DECIMAL_LITERAL>" , "<HEX_LITERAL>" , "<OCTAL_LITERAL>" , "<FLOATING_POINT_LITERAL>" , "<EXPONENT>" , "<CHARACTER_LITERAL>" , "<STRING_LITERAL>" , "<FORMAL_COMMENT>" , "<IDENTIFIER>" , "<LETTER>" , "<DIGIT>" , "\"(\"" , "\")\"" , "\"{\"" , "\"}\"" , "\"[\"" , "\"]\"" , "\";\"" , "\",\"" , "\".\"" , "\"=\"" , "\">\"" , "\"@gt\"" , "\"<\"" , "\"@lt\"" , "\"!\"" , "\"~\"" , "\"?\"" , "\":\"" , "\"==\"" , "\"<=\"" , "\"@lteq\"" , "\">=\"" , "\"@gteq\"" , "\"!=\"" , "\"||\"" , "\"@or\"" , "\"&&\"" , "\"@and\"" , "\"++\"" , "\"--\"" , "\"+\"" , "\"-\"" , "\"*\"" , "\"/\"" , "\"&\"" , "\"@bitwise_and\"" , "\"|\"" , "\"@bitwise_or\"" , "\"^\"" , "\"%\"" , "\"<<\"" , "\"@left_shift\"" , "\">>\"" , "\"@right_shift\"" , "\">>>\"" , "\"@right_unsigned_shift\"" , "\"+=\"" , "\"-=\"" , "\"*=\"" , "\"/=\"" , "\"&=\"" , "\"@and_assign\"" , "\"|=\"" , "\"@or_assign\"" , "\"^=\"" , "\"%=\"" , "\"<<=\"" , "\"@left_shift_assign\"" , "\">>=\"" , "\"@right_shift_assign\"" , "\">>>=\"" , "\"@right_unsigned_shift_assign\"" , } ; } 	0	['1', '1', '0', '12', '1', '0', '12', '0', '0', '2', '617', '0', '0', '0', '0', '0', '0', '496', '0', '0', '0']
package gnu . regexp ; final class RETokenEnd extends REToken { private String newline ; RETokenEnd ( int subIndex , String newline ) { super ( subIndex ) ; this . newline = newline ; } boolean match ( CharIndexed input , REMatch mymatch ) { char ch = input . charAt ( mymatch . index ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return ( ( mymatch . eflags & RE . REG_NOTEOL ) > 0 ) ? false : next ( input , mymatch ) ; if ( newline != null ) { char z ; int i = 0 ; do { z = newline . charAt ( i ) ; if ( ch != z ) return false ; ++ i ; ch = input . charAt ( mymatch . index + i ) ; } while ( i < newline . length ( ) ) ; return next ( input , mymatch ) ; } return false ; } void dump ( StringBuffer os ) { os . append ( '$' ) ; } } 	0	['3', '2', '0', '4', '9', '1', '1', '3', '0', '0.5', '71', '1', '0', '0.777777778', '0.444444444', '1', '2', '22.33333333', '6', '2.3333', '0']
package org . gjt . sp . jedit . options ; import java . awt . event . * ; import javax . swing . * ; import org . gjt . sp . jedit . * ; public class FirewallOptionPane extends AbstractOptionPane { public FirewallOptionPane ( ) { super ( "firewall" ) ; } public void _init ( ) { addComponent ( httpEnabled = new JCheckBox ( jEdit . getProperty ( "options.firewall.http.enabled" ) ) ) ; addComponent ( jEdit . getProperty ( "options.firewall.http.host" ) , httpHost = new JTextField ( jEdit . getProperty ( "firewall.host" ) , 15 ) ) ; addComponent ( jEdit . getProperty ( "options.firewall.http.port" ) , httpPort = new JTextField ( jEdit . getProperty ( "firewall.port" ) , 15 ) ) ; addComponent ( jEdit . getProperty ( "options.firewall.http.user" ) , httpUser = new JTextField ( jEdit . getProperty ( "firewall.user" ) , 15 ) ) ; addComponent ( jEdit . getProperty ( "options.firewall.http.password" ) , httpPass = new JPasswordField ( jEdit . getProperty ( "firewall.password" ) , 15 ) ) ; addComponent ( jEdit . getProperty ( "options.firewall.http.nonProxy" ) , httpNonProxy = new JTextField ( jEdit . getProperty ( "firewall.nonProxyHosts" ) , 15 ) ) ; boolean enabled = jEdit . getBooleanProperty ( "firewall.enabled" ) ; httpEnabled . setSelected ( enabled ) ; httpHost . setEnabled ( enabled ) ; httpPort . setEnabled ( enabled ) ; httpUser . setEnabled ( enabled ) ; httpPass . setEnabled ( enabled ) ; httpNonProxy . setEnabled ( enabled ) ; httpEnabled . addActionListener ( new ActionHandler ( ) ) ; addComponent ( socksEnabled = new JCheckBox ( jEdit . getProperty ( "options.firewall.socks.enabled" ) ) ) ; addComponent ( jEdit . getProperty ( "options.firewall.socks.host" ) , socksHost = new JTextField ( jEdit . getProperty ( "firewall.socks.host" ) , 15 ) ) ; addComponent ( jEdit . getProperty ( "options.firewall.socks.port" ) , socksPort = new JTextField ( jEdit . getProperty ( "firewall.socks.port" ) , 15 ) ) ; enabled = jEdit . getBooleanProperty ( "firewall.socks.enabled" ) ; socksEnabled . setSelected ( enabled ) ; socksHost . setEnabled ( enabled ) ; socksPort . setEnabled ( enabled ) ; socksEnabled . addActionListener ( new ActionHandler ( ) ) ; } public void _save ( ) { jEdit . setBooleanProperty ( "firewall.enabled" , httpEnabled . isSelected ( ) ) ; jEdit . setProperty ( "firewall.host" , httpHost . getText ( ) ) ; jEdit . setProperty ( "firewall.port" , httpPort . getText ( ) ) ; jEdit . setProperty ( "firewall.user" , httpUser . getText ( ) ) ; jEdit . setProperty ( "firewall.password" , new String ( httpPass . getPassword ( ) ) ) ; jEdit . setProperty ( "firewall.nonProxyHosts" , httpNonProxy . getText ( ) ) ; jEdit . setBooleanProperty ( "firewall.socks.enabled" , socksEnabled . isSelected ( ) ) ; jEdit . setProperty ( "firewall.socks.host" , socksHost . getText ( ) ) ; jEdit . setProperty ( "firewall.socks.port" , socksPort . getText ( ) ) ; } private JCheckBox httpEnabled ; private JTextField httpHost ; private JTextField httpPort ; private JTextField httpUser ; private JPasswordField httpPass ; private JTextField httpNonProxy ; private JCheckBox socksEnabled ; private JTextField socksHost ; private JTextField socksPort ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { httpHost . setEnabled ( httpEnabled . isSelected ( ) ) ; httpPort . setEnabled ( httpEnabled . isSelected ( ) ) ; httpUser . setEnabled ( httpEnabled . isSelected ( ) ) ; httpPass . setEnabled ( httpEnabled . isSelected ( ) ) ; httpNonProxy . setEnabled ( httpEnabled . isSelected ( ) ) ; socksHost . setEnabled ( socksEnabled . isSelected ( ) ) ; socksPort . setEnabled ( socksEnabled . isSelected ( ) ) ; } } } 	0	['12', '6', '0', '4', '31', '28', '2', '3', '3', '0.818181818', '269', '1', '0', '0.983823529', '0.5', '2', '4', '20.66666667', '1', '0.9167', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . plaf . metal . * ; import javax . swing . plaf . * ; import org . gjt . sp . jedit . jEdit ; public class JEditMetalTheme extends DefaultMetalTheme { public String getName ( ) { return "jEdit" ; } public ColorUIResource getSystemTextColor ( ) { return getBlack ( ) ; } public FontUIResource getControlTextFont ( ) { return primaryFont ; } public FontUIResource getSystemTextFont ( ) { return secondaryFont ; } public FontUIResource getUserTextFont ( ) { return secondaryFont ; } public FontUIResource getMenuTextFont ( ) { return primaryFont ; } public void propertiesChanged ( ) { primaryFont = new FontUIResource ( jEdit . getFontProperty ( "metal.primary.font" , super . getControlTextFont ( ) ) ) ; secondaryFont = new FontUIResource ( jEdit . getFontProperty ( "metal.secondary.font" , super . getSystemTextFont ( ) ) ) ; } private FontUIResource primaryFont ; private FontUIResource secondaryFont ; } 	0	['8', '3', '0', '1', '14', '16', '1', '1', '8', '0.714285714', '49', '1', '0', '0.911392405', '1', '0', '0', '4.875', '1', '0.875', '0']
package gnu . regexp ; final class RETokenEndSub extends REToken { RETokenEndSub ( int subIndex ) { super ( subIndex ) ; } boolean match ( CharIndexed input , REMatch mymatch ) { mymatch . end [ subIndex ] = mymatch . index ; return next ( input , mymatch ) ; } void dump ( StringBuffer os ) { } } 	0	['3', '2', '0', '4', '5', '3', '1', '3', '0', '2', '20', '0', '0', '0.777777778', '0.466666667', '1', '2', '5.666666667', '1', '0.6667', '0']
package gnu . regexp ; final class RETokenRange extends REToken { private char lo , hi ; private boolean insens ; RETokenRange ( int subIndex , char lo , char hi , boolean ins ) { super ( subIndex ) ; this . lo = ( insens = ins ) ? Character . toLowerCase ( lo ) : lo ; this . hi = ins ? Character . toLowerCase ( hi ) : hi ; } int getMinimumLength ( ) { return 1 ; } boolean match ( CharIndexed input , REMatch mymatch ) { char c = input . charAt ( mymatch . index ) ; if ( c == CharIndexed . OUT_OF_BOUNDS ) return false ; if ( insens ) c = Character . toLowerCase ( c ) ; if ( ( c >= lo ) && ( c <= hi ) ) { ++ mymatch . index ; return next ( input , mymatch ) ; } return false ; } void dump ( StringBuffer os ) { os . append ( lo ) . append ( '-' ) . append ( hi ) ; } } 	0	['4', '2', '0', '4', '9', '0', '1', '3', '0', '0.444444444', '80', '1', '0', '0.7', '0.357142857', '1', '2', '18.25', '5', '1.75', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import org . gjt . sp . jedit . * ; public class BrowserOptionPane extends AbstractOptionPane { public BrowserOptionPane ( ) { super ( "browser.general" ) ; } public void _init ( ) { String [ ] dirs = { jEdit . getProperty ( "options.browser.general.defaultPath.buffer" ) , jEdit . getProperty ( "options.browser.general.defaultPath.home" ) , jEdit . getProperty ( "options.browser.general.defaultPath.favorites" ) , jEdit . getProperty ( "options.browser.general.defaultPath.last" ) } ; defaultDirectory = new JComboBox ( dirs ) ; String defaultDir = jEdit . getProperty ( "vfs.browser.defaultPath" ) ; if ( "buffer" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 0 ) ; else if ( "home" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 1 ) ; else if ( "favorites" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 2 ) ; else if ( "last" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 3 ) ; addComponent ( jEdit . getProperty ( "options.browser.general.defaultPath" ) , defaultDirectory ) ; showToolbar = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".general.showToolbar" ) ) ; showToolbar . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".showToolbar" ) ) ; addComponent ( showToolbar ) ; showIcons = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".general.showIcons" ) ) ; showIcons . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".showIcons" ) ) ; addComponent ( showIcons ) ; showHiddenFiles = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".general.showHiddenFiles" ) ) ; showHiddenFiles . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".showHiddenFiles" ) ) ; addComponent ( showHiddenFiles ) ; sortIgnoreCase = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".general.sortIgnoreCase" ) ) ; sortIgnoreCase . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".sortIgnoreCase" ) ) ; addComponent ( sortIgnoreCase ) ; sortMixFilesAndDirs = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".general.sortMixFilesAndDirs" ) ) ; sortMixFilesAndDirs . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".sortMixFilesAndDirs" ) ) ; addComponent ( sortMixFilesAndDirs ) ; doubleClickClose = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".general.doubleClickClose" ) ) ; doubleClickClose . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".doubleClickClose" ) ) ; addComponent ( doubleClickClose ) ; splitHorizontally = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".general.splitHorizontally" ) ) ; splitHorizontally . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".splitHorizontally" ) ) ; addComponent ( splitHorizontally ) ; } public void _save ( ) { String [ ] dirs = { "buffer" , "home" , "favorites" , "last" } ; jEdit . setProperty ( "vfs.browser.defaultPath" , dirs [ defaultDirectory . getSelectedIndex ( ) ] ) ; jEdit . setBooleanProperty ( "vfs.browser.showToolbar" , showToolbar . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.showIcons" , showIcons . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.showHiddenFiles" , showHiddenFiles . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.sortIgnoreCase" , sortIgnoreCase . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.sortMixFilesAndDirs" , sortMixFilesAndDirs . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.doubleClickClose" , doubleClickClose . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.splitHorizontally" , splitHorizontally . isSelected ( ) ) ; } private JComboBox defaultDirectory ; private JCheckBox showToolbar ; private JCheckBox showIcons ; private JCheckBox showHiddenFiles ; private JCheckBox sortIgnoreCase ; private JCheckBox sortMixFilesAndDirs ; private JCheckBox doubleClickClose ; private JCheckBox splitHorizontally ; } 	0	['3', '6', '0', '3', '17', '1', '1', '2', '3', '0.5', '263', '1', '0', '0.997019374', '1', '2', '4', '84', '5', '2', '0']
package bsh ; public class InterpreterError extends RuntimeException { public InterpreterError ( String s ) { super ( s ) ; } } 	0	['1', '4', '0', '17', '2', '0', '17', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package bsh ; class BSHTernaryExpression extends SimpleNode { BSHTernaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode cond = ( SimpleNode ) jjtGetChild ( 0 ) , evalTrue = ( SimpleNode ) jjtGetChild ( 1 ) , evalFalse = ( SimpleNode ) jjtGetChild ( 2 ) ; if ( BSHIfStatement . evaluateCondition ( cond , callstack , interpreter ) ) return evalTrue . eval ( callstack , interpreter ) ; else return evalFalse . eval ( callstack , interpreter ) ; } } 	0	['2', '2', '0', '7', '6', '1', '1', '6', '1', '2', '36', '0', '0', '0.947368421', '0.625', '1', '1', '17', '1', '0.5', '0']
package org . gjt . sp . jedit . search ; import javax . swing . SwingUtilities ; import java . awt . Component ; import java . io . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class DirectoryListSet extends BufferListSet { public DirectoryListSet ( String directory , String glob , boolean recurse ) { this . directory = directory ; this . glob = glob ; this . recurse = recurse ; } public String getDirectory ( ) { return directory ; } public String getFileFilter ( ) { return glob ; } public boolean isRecursive ( ) { return recurse ; } public String getCode ( ) { return "new DirectoryListSet(\"" + MiscUtilities . charsToEscapes ( directory ) + "\",\"" + MiscUtilities . charsToEscapes ( glob ) + "\"," + recurse + ")" ; } protected String [ ] _getFiles ( final Component comp ) { final VFS vfs = VFSManager . getVFSForPath ( directory ) ; Object session ; if ( SwingUtilities . isEventDispatchThread ( ) ) { session = vfs . createVFSSession ( directory , comp ) ; } else { final Object [ ] returnValue = new Object [ 1 ] ; try { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { returnValue [ 0 ] = vfs . createVFSSession ( directory , comp ) ; } } ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } session = returnValue [ 0 ] ; } if ( session == null ) return null ; try { return vfs . _listDirectory ( session , directory , glob , recurse , comp ) ; } catch ( IOException io ) { VFSManager . error ( comp , directory , "ioerror" , new String [ ] { io . toString ( ) } ) ; return null ; } } private String directory ; private String glob ; private boolean recurse ; } 	0	['7', '2', '0', '9', '22', '0', '4', '6', '5', '0.444444444', '123', '1', '0', '0.538461538', '0.285714286', '1', '1', '16.14285714', '3', '1.1429', '0']
package bsh ; import java . lang . reflect . * ; import java . lang . reflect . InvocationHandler ; import java . io . * ; import java . util . Hashtable ; class XThis extends This { Hashtable interfaces ; InvocationHandler invocationHandler = new Handler ( ) ; XThis ( NameSpace namespace , Interpreter declaringInterp ) { super ( namespace , declaringInterp ) ; } public String toString ( ) { return "'this' reference (XThis) to Bsh object: " + namespace . name ; } String toStringShowInts ( Class [ ] ints ) { StringBuffer sb = new StringBuffer ( toString ( ) + "\nimplements:" ) ; for ( int i = 0 ; i < ints . length ; i ++ ) sb . append ( " " + ints [ i ] . getName ( ) + ( ( ints . length > 1 ) ? "," : "" ) ) ; return sb . toString ( ) ; } public Object getInterface ( Class clas ) { if ( interfaces == null ) interfaces = new Hashtable ( ) ; Object interf = interfaces . get ( clas ) ; if ( interf == null ) { interf = Proxy . newProxyInstance ( clas . getClassLoader ( ) , new Class [ ] { clas } , invocationHandler ) ; interfaces . put ( clas , interf ) ; } return interf ; } class Handler implements InvocationHandler , java . io . Serializable { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws EvalError { try { return invokeImpl ( proxy , method , args ) ; } catch ( EvalError ee ) { if ( Interpreter . DEBUG ) Interpreter . debug ( "EvalError in scripted interface: " + XThis . this . toString ( ) + ": " + ee ) ; throw ee ; } } public Object invokeImpl ( Object proxy , Method method , Object [ ] args ) throws EvalError { CallStack callstack = newCallStack ( ) ; Class [ ] sig = Reflect . getTypes ( args ) ; BshMethod bmethod = namespace . getMethod ( method . getName ( ) , sig ) ; if ( bmethod != null ) return Primitive . unwrap ( bmethod . invokeDeclaredMethod ( args , declaringInterpreter , callstack , null ) ) ; bmethod = namespace . getMethod ( "invoke" , new Class [ ] { null , null } ) ; if ( bmethod != null ) return Primitive . unwrap ( bmethod . invokeDeclaredMethod ( new Object [ ] { method . getName ( ) , args } , declaringInterpreter , callstack , null ) ) ; if ( method . getName ( ) . equals ( "toString" ) ) return toStringShowInts ( proxy . getClass ( ) . getInterfaces ( ) ) ; if ( method . getName ( ) . equals ( "hashCode" ) ) return new Integer ( this . hashCode ( ) ) ; if ( method . getName ( ) . equals ( "equals" ) ) { Object obj = args [ 0 ] ; return new Boolean ( proxy == obj ) ; } throw new EvalError ( "Bsh script method: " + method . getName ( ) + " not found in namespace: " + namespace . name ) ; } } ; } 	0	['4', '2', '0', '4', '16', '4', '1', '4', '2', '0.833333333', '109', '0', '0', '0.769230769', '0.4', '0', '0', '25.75', '3', '1.75', '0']
package org . gjt . sp . jedit ; import gnu . regexp . * ; import java . util . Hashtable ; import org . gjt . sp . jedit . syntax . TokenMarker ; import org . gjt . sp . util . Log ; public class Mode { public Mode ( String name ) { this . name = name ; props = new Hashtable ( ) ; } public void init ( ) { try { String filenameGlob = ( String ) getProperty ( "filenameGlob" ) ; if ( filenameGlob != null && filenameGlob . length ( ) != 0 ) { filenameRE = new RE ( MiscUtilities . globToRE ( filenameGlob ) , RE . REG_ICASE ) ; } String firstlineGlob = ( String ) getProperty ( "firstlineGlob" ) ; if ( firstlineGlob != null && firstlineGlob . length ( ) != 0 ) { firstlineRE = new RE ( MiscUtilities . globToRE ( firstlineGlob ) , RE . REG_ICASE ) ; } } catch ( REException re ) { Log . log ( Log . ERROR , this , "Invalid filename/firstline" + " globs in mode " + name ) ; Log . log ( Log . ERROR , this , re ) ; } marker = null ; } public TokenMarker getTokenMarker ( ) { loadIfNecessary ( ) ; return marker ; } public void setTokenMarker ( TokenMarker marker ) { this . marker = marker ; } public void loadIfNecessary ( ) { if ( marker == null ) jEdit . loadMode ( this ) ; } public Object getProperty ( String key ) { String prefix = "mode." + name + "." ; String property = jEdit . getProperty ( prefix + key ) ; if ( property != null ) { Object value ; try { value = new Integer ( property ) ; } catch ( NumberFormatException nf ) { value = property ; } return value ; } Object value = props . get ( key ) ; if ( value != null ) return value ; String global = jEdit . getProperty ( "buffer." + key ) ; if ( global != null ) { try { return new Integer ( global ) ; } catch ( NumberFormatException nf ) { return global ; } } else return null ; } public boolean getBooleanProperty ( String key ) { Object value = getProperty ( key ) ; if ( "true" . equals ( value ) || "on" . equals ( value ) || "yes" . equals ( value ) ) return true ; else return false ; } public void setProperty ( String key , Object value ) { props . put ( key , value ) ; } public void unsetProperty ( String key ) { props . remove ( key ) ; } public void setProperties ( Hashtable props ) { String filenameGlob = ( String ) this . props . get ( "filenameGlob" ) ; String firstlineGlob = ( String ) this . props . get ( "firstlineGlob" ) ; String filename = ( String ) this . props . get ( "file" ) ; this . props = props ; if ( filenameGlob != null ) props . put ( "filenameGlob" , filenameGlob ) ; if ( firstlineGlob != null ) props . put ( "firstlineGlob" , firstlineGlob ) ; if ( filename != null ) props . put ( "file" , filename ) ; } public boolean accept ( String fileName , String firstLine ) { if ( filenameRE != null && filenameRE . isMatch ( fileName ) ) return true ; if ( firstlineRE != null && firstlineRE . isMatch ( firstLine ) ) return true ; return false ; } public String getName ( ) { return name ; } public String toString ( ) { return name ; } private String name ; private Hashtable props ; private RE firstlineRE ; private RE filenameRE ; private TokenMarker marker ; } 	0	['13', '1', '0', '19', '30', '26', '15', '6', '13', '0.733333333', '274', '1', '3', '0', '0.338461538', '0', '0', '19.69230769', '5', '2.1538', '0']
package bsh ; class BSHLiteral extends SimpleNode { public Object value ; BSHLiteral ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { if ( value == null ) throw new InterpreterError ( "Null in bsh literal: " + value ) ; return value ; } private char getEscapeChar ( char ch ) { switch ( ch ) { case 'b' : ch = '\b' ; break ; case 't' : ch = '\t' ; break ; case 'n' : ch = '\n' ; break ; case 'f' : ch = '\f' ; break ; case 'r' : ch = '\r' ; break ; case '"' : case '\'' : case '\\' : break ; } return ch ; } public void charSetup ( String str ) { char ch = str . charAt ( 0 ) ; if ( ch == '\\' ) { ch = str . charAt ( 1 ) ; if ( Character . isDigit ( ch ) ) ch = ( char ) Integer . parseInt ( str . substring ( 1 ) , 8 ) ; else ch = getEscapeChar ( ch ) ; } value = new Primitive ( new Character ( ch ) ) ; } void stringSetup ( String str ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == '\\' ) { ch = str . charAt ( ++ i ) ; if ( Character . isDigit ( ch ) ) { int endPos = i ; while ( endPos < i + 2 ) { if ( Character . isDigit ( str . charAt ( endPos + 1 ) ) ) endPos ++ ; else break ; } ch = ( char ) Integer . parseInt ( str . substring ( i , endPos + 1 ) , 8 ) ; i = endPos ; } else ch = getEscapeChar ( ch ) ; } buffer . append ( ch ) ; } value = buffer . toString ( ) ; } } 	0	['5', '2', '0', '7', '20', '4', '1', '6', '2', '0.5', '153', '0', '0', '0.818181818', '0.366666667', '0', '0', '29.4', '10', '4', '0']
package org . gjt . sp . jedit . gui ; public interface DockableWindowContainer { void register ( DockableWindowManager . Entry entry ) ; void add ( DockableWindowManager . Entry entry ) ; void remove ( DockableWindowManager . Entry entry ) ; void save ( DockableWindowManager . Entry entry ) ; void show ( DockableWindowManager . Entry entry ) ; boolean isVisible ( DockableWindowManager . Entry entry ) ; } 	0	['6', '1', '0', '4', '6', '15', '4', '1', '6', '2', '6', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; public class TextAreaOptionPane extends AbstractOptionPane { public TextAreaOptionPane ( ) { super ( "textarea" ) ; } public void _init ( ) { font = new FontSelector ( jEdit . getFontProperty ( "view.font" ) ) ; addComponent ( jEdit . getProperty ( "options.textarea.font" ) , font ) ; addComponent ( jEdit . getProperty ( "options.textarea.foreground" ) , foregroundColor = new ColorWellButton ( jEdit . getColorProperty ( "view.fgColor" ) ) , GridBagConstraints . VERTICAL ) ; addComponent ( jEdit . getProperty ( "options.textarea.background" ) , backgroundColor = new ColorWellButton ( jEdit . getColorProperty ( "view.bgColor" ) ) , GridBagConstraints . VERTICAL ) ; blinkCaret = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".blinkCaret" ) ) ; blinkCaret . setSelected ( jEdit . getBooleanProperty ( "view.caretBlink" ) ) ; blockCaret = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".blockCaret" ) ) ; blockCaret . setSelected ( jEdit . getBooleanProperty ( "view.blockCaret" ) ) ; Box caretSettings = new Box ( BoxLayout . X_AXIS ) ; caretSettings . add ( new JLabel ( jEdit . getProperty ( "options.textarea.caret" ) ) ) ; caretSettings . add ( Box . createHorizontalStrut ( 6 ) ) ; caretSettings . add ( blinkCaret ) ; caretSettings . add ( blockCaret ) ; addComponent ( caretSettings , caretColor = new ColorWellButton ( jEdit . getColorProperty ( "view.caretColor" ) ) , GridBagConstraints . VERTICAL ) ; addComponent ( jEdit . getProperty ( "options.textarea.selection" ) , selectionColor = new ColorWellButton ( jEdit . getColorProperty ( "view.selectionColor" ) ) , GridBagConstraints . VERTICAL ) ; lineHighlight = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".lineHighlight" ) ) ; lineHighlight . setSelected ( jEdit . getBooleanProperty ( "view.lineHighlight" ) ) ; addComponent ( lineHighlight , lineHighlightColor = new ColorWellButton ( jEdit . getColorProperty ( "view.lineHighlightColor" ) ) , GridBagConstraints . VERTICAL ) ; bracketHighlight = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".bracketHighlight" ) ) ; bracketHighlight . setSelected ( jEdit . getBooleanProperty ( "view.bracketHighlight" ) ) ; addComponent ( bracketHighlight , bracketHighlightColor = new ColorWellButton ( jEdit . getColorProperty ( "view.bracketHighlightColor" ) ) , GridBagConstraints . VERTICAL ) ; eolMarkers = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".eolMarkers" ) ) ; eolMarkers . setSelected ( jEdit . getBooleanProperty ( "view.eolMarkers" ) ) ; addComponent ( eolMarkers , eolMarkerColor = new ColorWellButton ( jEdit . getColorProperty ( "view.eolMarkerColor" ) ) , GridBagConstraints . VERTICAL ) ; wrapGuide = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".wrapGuide" ) ) ; wrapGuide . setSelected ( jEdit . getBooleanProperty ( "view.wrapGuide" ) ) ; addComponent ( wrapGuide , wrapGuideColor = new ColorWellButton ( jEdit . getColorProperty ( "view.wrapGuideColor" ) ) , GridBagConstraints . VERTICAL ) ; electricBorders = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".electricBorders" ) ) ; electricBorders . setSelected ( ! "0" . equals ( jEdit . getProperty ( "view.electricBorders" ) ) ) ; addComponent ( electricBorders ) ; joinNonWordChars = new JCheckBox ( jEdit . getProperty ( "options.textarea.joinNonWordChars" ) ) ; joinNonWordChars . setSelected ( jEdit . getBooleanProperty ( "view.joinNonWordChars" ) ) ; addComponent ( joinNonWordChars ) ; middleMousePaste = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".middleMousePaste" ) ) ; middleMousePaste . setSelected ( jEdit . getBooleanProperty ( "view.middleMousePaste" ) ) ; addComponent ( middleMousePaste ) ; antiAlias = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".antiAlias" ) ) ; antiAlias . setSelected ( jEdit . getBooleanProperty ( "view.antiAlias" ) ) ; addComponent ( antiAlias ) ; fracFontMetrics = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".fracFontMetrics" ) ) ; fracFontMetrics . setSelected ( jEdit . getBooleanProperty ( "view.fracFontMetrics" ) ) ; addComponent ( fracFontMetrics ) ; } public void _save ( ) { jEdit . setFontProperty ( "view.font" , font . getFont ( ) ) ; jEdit . setColorProperty ( "view.fgColor" , foregroundColor . getSelectedColor ( ) ) ; jEdit . setColorProperty ( "view.bgColor" , backgroundColor . getSelectedColor ( ) ) ; jEdit . setBooleanProperty ( "view.caretBlink" , blinkCaret . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.blockCaret" , blockCaret . isSelected ( ) ) ; jEdit . setColorProperty ( "view.caretColor" , caretColor . getSelectedColor ( ) ) ; jEdit . setColorProperty ( "view.selectionColor" , selectionColor . getSelectedColor ( ) ) ; jEdit . setBooleanProperty ( "view.lineHighlight" , lineHighlight . isSelected ( ) ) ; jEdit . setColorProperty ( "view.lineHighlightColor" , lineHighlightColor . getSelectedColor ( ) ) ; jEdit . setBooleanProperty ( "view.bracketHighlight" , bracketHighlight . isSelected ( ) ) ; jEdit . setColorProperty ( "view.bracketHighlightColor" , bracketHighlightColor . getSelectedColor ( ) ) ; jEdit . setBooleanProperty ( "view.eolMarkers" , eolMarkers . isSelected ( ) ) ; jEdit . setColorProperty ( "view.eolMarkerColor" , eolMarkerColor . getSelectedColor ( ) ) ; jEdit . setBooleanProperty ( "view.wrapGuide" , wrapGuide . isSelected ( ) ) ; jEdit . setColorProperty ( "view.wrapGuideColor" , wrapGuideColor . getSelectedColor ( ) ) ; jEdit . setIntegerProperty ( "view.electricBorders" , electricBorders . isSelected ( ) ? 3 : 0 ) ; jEdit . setBooleanProperty ( "view.joinNonWordChars" , joinNonWordChars . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.middleMousePaste" , middleMousePaste . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.antiAlias" , antiAlias . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.fracFontMetrics" , fracFontMetrics . isSelected ( ) ) ; } private FontSelector font ; private ColorWellButton foregroundColor ; private ColorWellButton backgroundColor ; private JCheckBox blinkCaret ; private JCheckBox blockCaret ; private ColorWellButton caretColor ; private ColorWellButton selectionColor ; private JCheckBox lineHighlight ; private ColorWellButton lineHighlightColor ; private JCheckBox bracketHighlight ; private ColorWellButton bracketHighlightColor ; private JCheckBox eolMarkers ; private ColorWellButton eolMarkerColor ; private JCheckBox wrapGuide ; private ColorWellButton wrapGuideColor ; private JCheckBox electricBorders ; private JCheckBox middleMousePaste ; private JCheckBox antiAlias ; private JCheckBox fracFontMetrics ; private JCheckBox joinNonWordChars ; } 	0	['3', '6', '0', '5', '28', '1', '1', '4', '3', '0.5', '435', '1', '9', '0.997019374', '1', '3', '5', '137.3333333', '2', '1.3333', '0']
package gnu . regexp ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . IOException ; class CharIndexedReader implements CharIndexed { private static final int BUFFER_INCREMENT = 1024 ; private static final int UNKNOWN = Integer . MAX_VALUE ; private final BufferedReader br ; private int index = - 1 ; private int bufsize = BUFFER_INCREMENT ; private int end = UNKNOWN ; private char cached = OUT_OF_BOUNDS ; private char [ ] lookBehind = new char [ ] { OUT_OF_BOUNDS , OUT_OF_BOUNDS } ; CharIndexedReader ( Reader reader , int index ) { if ( reader instanceof BufferedReader ) { br = ( BufferedReader ) reader ; } else { br = new BufferedReader ( reader , BUFFER_INCREMENT ) ; } next ( ) ; if ( index > 0 ) move ( index ) ; } private boolean next ( ) { lookBehind [ 1 ] = lookBehind [ 0 ] ; lookBehind [ 0 ] = cached ; if ( end == 1 ) { cached = OUT_OF_BOUNDS ; return false ; } end -- ; try { if ( index != - 1 ) { br . reset ( ) ; } int i = br . read ( ) ; br . mark ( bufsize ) ; if ( i == - 1 ) { end = 1 ; cached = OUT_OF_BOUNDS ; return false ; } cached = ( char ) i ; index = 1 ; } catch ( IOException e ) { e . printStackTrace ( ) ; cached = OUT_OF_BOUNDS ; return false ; } return true ; } public char charAt ( int index ) { if ( index == 0 ) { return cached ; } else if ( index >= end ) { return OUT_OF_BOUNDS ; } else if ( index >= bufsize ) { try { while ( bufsize <= index ) bufsize += BUFFER_INCREMENT ; br . reset ( ) ; br . mark ( bufsize ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } else if ( this . index != index ) { try { br . reset ( ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } else if ( index == - 1 ) { return lookBehind [ 0 ] ; } else if ( index == - 2 ) { return lookBehind [ 1 ] ; } else if ( index < - 2 ) { return OUT_OF_BOUNDS ; } char ch = OUT_OF_BOUNDS ; try { int i = br . read ( ) ; this . index = index + 1 ; if ( i == - 1 ) { end = index ; return ch ; } ch = ( char ) i ; } catch ( IOException ie ) { } return ch ; } public boolean move ( int index ) { boolean retval = true ; while ( retval && ( index -- > 0 ) ) retval = next ( ) ; return retval ; } public boolean isValid ( ) { return ( cached != OUT_OF_BOUNDS ) ; } } 	0	['5', '1', '0', '3', '12', '0', '2', '1', '3', '0.46875', '273', '1', '0', '0', '0.6', '0', '0', '52', '10', '3.8', '0']
package org . gjt . sp . util ; import javax . swing . text . * ; import java . io . * ; import java . util . StringTokenizer ; public class Log { public static final int MAXLINES = 500 ; public static final int DEBUG = 1 ; public static final int MESSAGE = 3 ; public static final int NOTICE = 5 ; public static final int WARNING = 7 ; public static final int ERROR = 9 ; public static void init ( boolean stdio , int level ) { if ( stdio ) { if ( System . out == realOut && System . err == realErr ) { System . setOut ( createPrintStream ( NOTICE , null ) ) ; System . setErr ( createPrintStream ( ERROR , null ) ) ; } } Log . level = level ; log ( MESSAGE , Log . class , "When reporting bugs, please" + " include the following information:" ) ; String [ ] props = { "java.version" , "java.vm.version" , "java.runtime.version" , "java.vendor" , "java.compiler" , "os.name" , "os.version" , "os.arch" , "user.home" , "java.home" , "java.class.path" , } ; for ( int i = 0 ; i < props . length ; i ++ ) { log ( MESSAGE , Log . class , props [ i ] + "=" + System . getProperty ( props [ i ] ) ) ; } } public static void setLogWriter ( Writer stream ) { if ( Log . stream == null && stream != null ) { try { stream . write ( logDocument . getText ( 0 , logDocument . getLength ( ) ) ) ; stream . flush ( ) ; } catch ( Exception e ) { } } Log . stream = stream ; } public static Document getLogDocument ( ) { return logDocument ; } public static void flushStream ( ) { if ( stream != null ) { try { stream . flush ( ) ; } catch ( IOException io ) { io . printStackTrace ( realErr ) ; } } } public static void closeStream ( ) { if ( stream != null ) { try { stream . close ( ) ; stream = null ; } catch ( IOException io ) { io . printStackTrace ( realErr ) ; } } } public static void log ( int urgency , Object source , Object message ) { String _source ; if ( source == null ) { _source = Thread . currentThread ( ) . getName ( ) ; if ( _source == null ) { _source = Thread . currentThread ( ) . getClass ( ) . getName ( ) ; } } else if ( source instanceof Class ) _source = ( ( Class ) source ) . getName ( ) ; else _source = source . getClass ( ) . getName ( ) ; int index = _source . lastIndexOf ( '.' ) ; if ( index != - 1 ) _source = _source . substring ( index + 1 ) ; if ( message instanceof Throwable ) { _logException ( urgency , source , ( Throwable ) message ) ; } else { String _message = String . valueOf ( message ) ; synchronized ( LOCK ) { StringTokenizer st = new StringTokenizer ( _message , "\r\n" ) ; while ( st . hasMoreTokens ( ) ) { _log ( urgency , _source , st . nextToken ( ) ) ; } } } } private static Object LOCK = new Object ( ) ; private static Document logDocument ; private static int level = WARNING ; private static Writer stream ; private static String lineSep ; private static PrintStream realOut ; private static PrintStream realErr ; static { level = WARNING ; realOut = System . out ; realErr = System . err ; logDocument = new PlainDocument ( ) ; lineSep = System . getProperty ( "line.separator" ) ; } private static PrintStream createPrintStream ( final int urgency , final Object source ) { return new PrintStream ( new OutputStream ( ) { public void write ( int b ) { byte [ ] barray = { ( byte ) b } ; write ( barray , 0 , 1 ) ; } public void write ( byte [ ] b , int off , int len ) { String str = new String ( b , off , len ) ; log ( urgency , source , str ) ; } } ) ; } private static void _logException ( final int urgency , final Object source , final Throwable message ) { PrintStream out = createPrintStream ( urgency , source ) ; synchronized ( LOCK ) { message . printStackTrace ( out ) ; } } private static void _log ( int urgency , String source , String message ) { String urgencyString = "[" + urgencyToString ( urgency ) + "] " ; String fullMessage = urgencyString + source + ": " + message ; try { logDocument . insertString ( logDocument . getLength ( ) , fullMessage , null ) ; logDocument . insertString ( logDocument . getLength ( ) , "\n" , null ) ; Element map = logDocument . getDefaultRootElement ( ) ; int lines = map . getElementCount ( ) ; if ( lines > MAXLINES ) { Element first = map . getElement ( 0 ) ; Element last = map . getElement ( lines - MAXLINES ) ; logDocument . remove ( first . getStartOffset ( ) , last . getEndOffset ( ) ) ; } if ( stream != null ) { stream . write ( fullMessage ) ; stream . write ( lineSep ) ; } } catch ( Exception e ) { e . printStackTrace ( realErr ) ; } message = urgencyString + message + '\n' ; if ( urgency >= level ) { if ( urgency == ERROR ) realErr . print ( message ) ; else realOut . print ( message ) ; } } private static String urgencyToString ( int urgency ) { switch ( urgency ) { case DEBUG : return "debug" ; case MESSAGE : return "message" ; case NOTICE : return "notice" ; case WARNING : return "warning" ; case ERROR : return "error" ; } throw new IllegalArgumentException ( "Invalid urgency: " + urgency ) ; } } 	0	['13', '1', '0', '76', '55', '38', '76', '1', '7', '0.892857143', '446', '0.5', '0', '0', '0.178571429', '0', '0', '32.23076923', '7', '2.3846', '0']
package org . gjt . sp . jedit . syntax ; public class DummyTokenHandler implements TokenHandler { public static final DummyTokenHandler INSTANCE = new DummyTokenHandler ( ) ; public void handleToken ( byte id , int offset , int length , TokenMarker . LineContext context ) { } } 	0	['3', '1', '0', '3', '4', '3', '1', '2', '2', '1', '13', '0', '1', '0', '0.625', '0', '0', '3', '1', '0.3333', '0']
package bsh ; public class EvalError extends Exception { SimpleNode node ; String message ; public EvalError ( String s ) { setMessage ( s ) ; } public EvalError ( String s , SimpleNode node ) { this ( s ) ; this . node = node ; } public String toString ( ) { String trace ; if ( node != null ) trace = " : at Line: " + node . getLineNumber ( ) + " : in file: " + node . getSourceFile ( ) + " : " + node . getText ( ) ; else trace = ": <at unknown location>" ; return getMessage ( ) + trace ; } public void reThrow ( String msg ) throws EvalError { reThrow ( msg , null ) ; } public void reThrow ( SimpleNode node ) throws EvalError { reThrow ( null , node ) ; } public void reThrow ( String addMsg , SimpleNode addNode ) throws EvalError { prependMessage ( addMsg ) ; addNode ( addNode ) ; throw this ; } void setNode ( SimpleNode node ) { this . node = node ; } SimpleNode getNode ( ) { return node ; } public String getErrorText ( ) { if ( node != null ) return node . getText ( ) ; else return "<unknown error>" ; } public int getErrorLineNumber ( ) { if ( node != null ) return node . getLineNumber ( ) ; else return - 1 ; } public String getErrorSourceFile ( ) { if ( node != null ) return node . getSourceFile ( ) ; else return "<unknown file>" ; } public String getMessage ( ) { return message ; } public void setMessage ( String s ) { message = s ; } protected void prependMessage ( String s ) { if ( s != null ) message = s + " : " + message ; } protected void addNode ( SimpleNode addNode ) { SimpleNode node = this . node ; if ( node == null && addNode != null ) node = addNode ; } } 	0	['15', '3', '3', '53', '23', '43', '53', '1', '11', '0.5', '154', '0', '1', '0.566666667', '0.577777778', '1', '2', '9.133333333', '3', '1.3333', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import org . gjt . sp . jedit . gui . FontSelector ; import org . gjt . sp . jedit . * ; public class PrintOptionPane extends AbstractOptionPane { public PrintOptionPane ( ) { super ( "print" ) ; } protected void _init ( ) { font = new FontSelector ( jEdit . getFontProperty ( "print.font" ) ) ; addComponent ( jEdit . getProperty ( "options.print.font" ) , font ) ; printHeader = new JCheckBox ( jEdit . getProperty ( "options.print" + ".header" ) ) ; printHeader . setSelected ( jEdit . getBooleanProperty ( "print.header" ) ) ; addComponent ( printHeader ) ; printFooter = new JCheckBox ( jEdit . getProperty ( "options.print" + ".footer" ) ) ; printFooter . setSelected ( jEdit . getBooleanProperty ( "print.footer" ) ) ; addComponent ( printFooter ) ; printLineNumbers = new JCheckBox ( jEdit . getProperty ( "options.print" + ".lineNumbers" ) ) ; printLineNumbers . setSelected ( jEdit . getBooleanProperty ( "print.lineNumbers" ) ) ; addComponent ( printLineNumbers ) ; color = new JCheckBox ( jEdit . getProperty ( "options.print" + ".color" ) ) ; color . setSelected ( jEdit . getBooleanProperty ( "print.color" ) ) ; addComponent ( color ) ; String [ ] tabSizes = { "2" , "4" , "8" } ; tabSize = new JComboBox ( tabSizes ) ; tabSize . setEditable ( true ) ; tabSize . setSelectedItem ( jEdit . getProperty ( "print.tabSize" ) ) ; addComponent ( jEdit . getProperty ( "options.print.tabSize" ) , tabSize ) ; } protected void _save ( ) { jEdit . setFontProperty ( "print.font" , font . getFont ( ) ) ; jEdit . setBooleanProperty ( "print.header" , printHeader . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.footer" , printFooter . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.lineNumbers" , printLineNumbers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.color" , color . isSelected ( ) ) ; jEdit . setProperty ( "print.tabSize" , ( String ) tabSize . getSelectedItem ( ) ) ; } private FontSelector font ; private JCheckBox printHeader ; private JCheckBox printFooter ; private JCheckBox printLineNumbers ; private JCheckBox color ; private JComboBox tabSize ; } 	0	['3', '6', '0', '4', '21', '1', '1', '3', '1', '0.5', '159', '1', '1', '0.997019374', '1', '1', '3', '50', '1', '0.6667', '0']
package org . gjt . sp . jedit . io ; import java . awt . Component ; import java . io . * ; import java . net . * ; import org . gjt . sp . util . Log ; public class UrlVFS extends VFS { public UrlVFS ( ) { super ( "url" , READ_CAP | WRITE_CAP ) ; } public String constructPath ( String parent , String path ) { if ( parent . endsWith ( "/" ) ) return parent + path ; else return parent + '/' + path ; } public InputStream _createInputStream ( Object session , String path , boolean ignoreErrors , Component comp ) throws IOException { try { return new URL ( path ) . openStream ( ) ; } catch ( MalformedURLException mu ) { Log . log ( Log . ERROR , this , mu ) ; String [ ] args = { mu . getMessage ( ) } ; VFSManager . error ( comp , path , "ioerror.badurl" , args ) ; return null ; } } public OutputStream _createOutputStream ( Object session , String path , Component comp ) throws IOException { try { return new URL ( path ) . openConnection ( ) . getOutputStream ( ) ; } catch ( MalformedURLException mu ) { Log . log ( Log . ERROR , this , mu ) ; String [ ] args = { mu . getMessage ( ) } ; VFSManager . error ( comp , path , "ioerror.badurl" , args ) ; return null ; } } } 	0	['4', '2', '0', '3', '17', '6', '1', '3', '4', '2', '86', '0', '0', '0.928571429', '0.6', '1', '1', '20.5', '2', '1', '0']
package org . gjt . sp . util ; public class WorkThread extends Thread { public WorkThread ( WorkThreadPool pool , ThreadGroup group , String name ) { super ( group , name ) ; setPriority ( 4 ) ; this . pool = pool ; } public void setAbortable ( boolean abortable ) { synchronized ( abortLock ) { this . abortable = abortable ; if ( aborted ) stop ( new Abort ( ) ) ; } } public boolean isRequestRunning ( ) { return requestRunning ; } public String getStatus ( ) { return status ; } public void setStatus ( String status ) { this . status = status ; pool . fireProgressChanged ( this ) ; } public int getProgressValue ( ) { return progressValue ; } public void setProgressValue ( int progressValue ) { this . progressValue = progressValue ; pool . fireProgressChanged ( this ) ; } public int getProgressMaximum ( ) { return progressMaximum ; } public void setProgressMaximum ( int progressMaximum ) { this . progressMaximum = progressMaximum ; pool . fireProgressChanged ( this ) ; } public void abortCurrentRequest ( ) { synchronized ( abortLock ) { if ( abortable && ! aborted ) stop ( new Abort ( ) ) ; aborted = true ; } } public void run ( ) { Log . log ( Log . DEBUG , this , "Work request thread starting [" + getName ( ) + "]" ) ; for ( ; ; ) { doRequests ( ) ; } } private WorkThreadPool pool ; private Object abortLock = new Object ( ) ; private boolean requestRunning ; private boolean abortable ; private boolean aborted ; private String status ; private int progressValue ; private int progressMaximum ; private void doRequests ( ) { WorkThreadPool . Request request ; for ( ; ; ) { request = pool . getNextRequest ( ) ; if ( request == null ) break ; else { requestRunning = true ; pool . fireStatusChanged ( this ) ; doRequest ( request ) ; requestRunning = false ; } } pool . fireStatusChanged ( this ) ; synchronized ( pool . waitForAllLock ) { pool . waitForAllLock . notifyAll ( ) ; } synchronized ( pool . lock ) { try { pool . lock . wait ( ) ; } catch ( InterruptedException ie ) { Log . log ( Log . ERROR , this , ie ) ; } } } private void doRequest ( WorkThreadPool . Request request ) { Log . log ( Log . DEBUG , WorkThread . class , "Running in work thread: " + request ) ; try { request . run . run ( ) ; } catch ( Abort a ) { Log . log ( Log . ERROR , WorkThread . class , "Unhandled abort" ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , WorkThread . class , "Exception " + "in work thread:" ) ; Log . log ( Log . ERROR , WorkThread . class , t ) ; } finally { synchronized ( abortLock ) { aborted = abortable = false ; } status = null ; progressValue = progressMaximum = 0 ; pool . requestDone ( ) ; pool . fireStatusChanged ( this ) ; } } public static class Abort extends Error { public Abort ( ) { super ( "Work request aborted" ) ; } } } 	0	['14', '2', '0', '7', '35', '37', '4', '4', '11', '0.760683761', '429', '0.888888889', '1', '0.824324324', '0.224489796', '0', '0', '29', '5', '1.5', '0']
package bsh ; import java . util . Hashtable ; import java . lang . reflect . Array ; import java . lang . reflect . InvocationTargetException ; class BSHPrimarySuffix extends SimpleNode { public static final int CLASS = 0 , INDEX = 1 , NAME = 2 , PROPERTY = 3 ; public int operation ; Object index ; public String field ; BSHPrimarySuffix ( int id ) { super ( id ) ; } public Object doSuffix ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError { if ( operation == CLASS ) if ( obj instanceof BSHType ) { NameSpace namespace = callstack . top ( ) ; return ( ( BSHType ) obj ) . getType ( namespace ) ; } else throw new EvalError ( "Attemp to invoke .class on non class." , this ) ; if ( obj instanceof SimpleNode ) if ( obj instanceof BSHAmbiguousName ) obj = ( ( BSHAmbiguousName ) obj ) . toObject ( callstack , interpreter ) ; else obj = ( ( SimpleNode ) obj ) . eval ( callstack , interpreter ) ; try { switch ( operation ) { case INDEX : return doIndex ( obj , callstack , interpreter ) ; case NAME : return doName ( obj , callstack , interpreter ) ; case PROPERTY : return doProperty ( obj , callstack , interpreter ) ; default : throw new InterpreterError ( "LHS suffix" ) ; } } catch ( ReflectError e ) { throw new EvalError ( "reflection error: " + e , this ) ; } catch ( InvocationTargetException e ) { throw new TargetError ( "target exception" , e . getTargetException ( ) , this , true ) ; } } private Object doName ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError , InvocationTargetException { if ( field . equals ( "length" ) && obj . getClass ( ) . isArray ( ) ) return new Primitive ( Array . getLength ( obj ) ) ; if ( jjtGetNumChildren ( ) == 0 ) return Reflect . getObjectField ( obj , field ) ; else { Object [ ] oa = ( ( BSHArguments ) jjtGetChild ( 0 ) ) . getArguments ( callstack , interpreter ) ; try { return Reflect . invokeObjectMethod ( interpreter , obj , field , oa , this ) ; } catch ( EvalError ee ) { throw new EvalError ( ee . getMessage ( ) , this ) ; } } } static int getIndexAux ( Object obj , CallStack callstack , Interpreter interpreter , SimpleNode callerNode ) throws EvalError { if ( ! obj . getClass ( ) . isArray ( ) ) throw new EvalError ( "Not an array" , callerNode ) ; int index ; try { Object indexVal = ( ( SimpleNode ) callerNode . jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( ! ( indexVal instanceof Primitive ) ) indexVal = NameSpace . getAssignableForm ( indexVal , Integer . TYPE ) ; index = ( ( Primitive ) indexVal ) . intValue ( ) ; } catch ( EvalError e ) { Interpreter . debug ( "doIndex: " + e ) ; e . reThrow ( "You can only index arrays by integer types" , callerNode ) ; throw new Error ( "can't get here" ) ; } return index ; } private Object doIndex ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError { int index = getIndexAux ( obj , callstack , interpreter , this ) ; return Reflect . getIndex ( obj , index ) ; } private Object doProperty ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError { if ( obj == Primitive . VOID ) throw new EvalError ( "Attempt to access property on undefined variable or class name" , this ) ; if ( obj instanceof Primitive ) throw new EvalError ( "Attempt to access property on a primitive" , this ) ; Object value = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( ! ( value instanceof String ) ) throw new EvalError ( "Property expression must be a String or identifier." , this ) ; if ( obj instanceof Hashtable ) { Object val = ( ( Hashtable ) obj ) . get ( ( String ) value ) ; if ( val == null ) val = Primitive . NULL ; return val ; } try { return Reflect . getObjectProperty ( obj , ( String ) value ) ; } catch ( ReflectError e ) { Interpreter . debug ( e . toString ( ) ) ; throw new EvalError ( "No such property: " + value , this ) ; } } } 	0	['6', '2', '0', '17', '40', '15', '3', '14', '1', '1.114285714', '286', '0', '0', '0.782608696', '0.611111111', '0', '0', '45.5', '1', '0.8333', '0']
package org . gjt . sp . jedit ; import java . io . * ; import java . util . * ; import org . gjt . sp . jedit . gui . AddAbbrevDialog ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class Abbrevs { public static boolean getExpandOnInput ( ) { return expandOnInput ; } public static void setExpandOnInput ( boolean expandOnInput ) { Abbrevs . expandOnInput = expandOnInput ; } public static boolean expandAbbrev ( View view , boolean add ) { Buffer buffer = view . getBuffer ( ) ; JEditTextArea textArea = view . getTextArea ( ) ; if ( ! buffer . isEditable ( ) ) { view . getToolkit ( ) . beep ( ) ; return false ; } int line = textArea . getCaretLine ( ) ; int lineStart = buffer . getLineStartOffset ( line ) ; int caret = textArea . getCaretPosition ( ) ; String lineText = buffer . getLineText ( line ) ; if ( lineText . length ( ) == 0 ) { if ( add ) view . getToolkit ( ) . beep ( ) ; return false ; } int pos = caret - lineStart ; if ( pos == 0 ) { if ( add ) view . getToolkit ( ) . beep ( ) ; return false ; } pp . removeAllElements ( ) ; int wordStart ; String abbrev ; if ( lineText . charAt ( pos - 1 ) == '#' ) { wordStart = lineText . indexOf ( '#' ) ; wordStart = TextUtilities . findWordStart ( lineText , wordStart , buffer . getStringProperty ( "noWordSep" ) + '#' ) ; abbrev = lineText . substring ( wordStart , pos - 1 ) ; int lastIndex = 0 ; for ( int i = 0 ; i < abbrev . length ( ) ; i ++ ) { if ( abbrev . charAt ( i ) == '#' ) { pp . addElement ( abbrev . substring ( lastIndex , i ) ) ; lastIndex = i + 1 ; } } pp . addElement ( abbrev . substring ( lastIndex ) ) ; abbrev = ( String ) pp . elementAt ( 0 ) ; pp . removeElementAt ( 0 ) ; } else { wordStart = TextUtilities . findWordStart ( lineText , pos - 1 , buffer . getStringProperty ( "noWordSep" ) ) ; abbrev = lineText . substring ( wordStart , pos ) ; } Expansion expand = expandAbbrev ( buffer . getMode ( ) . getName ( ) , abbrev , ( buffer . getBooleanProperty ( "noTabs" ) ? buffer . getTabSize ( ) : 0 ) , pp ) ; if ( expand == null ) { if ( add ) new AddAbbrevDialog ( view , abbrev ) ; return false ; } else { buffer . beginCompoundEdit ( ) ; try { lineText = buffer . getText ( lineStart , wordStart ) ; int leadingIndent = MiscUtilities . getLeadingWhiteSpaceWidth ( lineText , buffer . getTabSize ( ) ) ; buffer . remove ( lineStart + wordStart , pos - wordStart ) ; buffer . insert ( lineStart + wordStart , expand . text ) ; if ( expand . caretPosition != - 1 ) { textArea . setCaretPosition ( lineStart + wordStart + expand . caretPosition ) ; } String whiteSpace = MiscUtilities . createWhiteSpace ( leadingIndent , buffer . getBooleanProperty ( "noTabs" ) ? 0 : buffer . getTabSize ( ) ) ; for ( int i = line + 1 ; i <= line + expand . lineCount ; i ++ ) { buffer . insert ( buffer . getLineStartOffset ( i ) , whiteSpace ) ; } } finally { buffer . endCompoundEdit ( ) ; } if ( expand . posParamCount != pp . size ( ) ) { view . getStatus ( ) . setMessageAndClear ( jEdit . getProperty ( "view.status.incomplete-abbrev" , new Integer [ ] { new Integer ( pp . size ( ) ) , new Integer ( expand . posParamCount ) } ) ) ; } return true ; } } public static Hashtable getGlobalAbbrevs ( ) { if ( ! loaded ) load ( ) ; return globalAbbrevs ; } public static void setGlobalAbbrevs ( Hashtable globalAbbrevs ) { abbrevsChanged = true ; Abbrevs . globalAbbrevs = globalAbbrevs ; } public static Hashtable getModeAbbrevs ( ) { if ( ! loaded ) load ( ) ; return modes ; } public static void setModeAbbrevs ( Hashtable modes ) { abbrevsChanged = true ; Abbrevs . modes = modes ; } public static void addGlobalAbbrev ( String abbrev , String expansion ) { if ( ! loaded ) load ( ) ; globalAbbrevs . put ( abbrev , expansion ) ; abbrevsChanged = true ; } public static void addModeAbbrev ( String mode , String abbrev , String expansion ) { if ( ! loaded ) load ( ) ; Hashtable modeAbbrevs = ( Hashtable ) modes . get ( mode ) ; if ( modeAbbrevs == null ) { modeAbbrevs = new Hashtable ( ) ; modes . put ( mode , modeAbbrevs ) ; } modeAbbrevs . put ( abbrev , expansion ) ; abbrevsChanged = true ; } static void save ( ) { jEdit . setBooleanProperty ( "view.expandOnInput" , expandOnInput ) ; String settings = jEdit . getSettingsDirectory ( ) ; if ( abbrevsChanged && settings != null ) { File file1 = new File ( MiscUtilities . constructPath ( settings , "#abbrevs#save#" ) ) ; File file2 = new File ( MiscUtilities . constructPath ( settings , "abbrevs" ) ) ; if ( file2 . exists ( ) && file2 . lastModified ( ) != abbrevsModTime ) { Log . log ( Log . WARNING , Abbrevs . class , file2 + " changed on disk;" + " will not save abbrevs" ) ; } else { jEdit . backupSettingsFile ( file2 ) ; try { saveAbbrevs ( new FileWriter ( file1 ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , Abbrevs . class , "Error while saving " + file1 ) ; Log . log ( Log . ERROR , Abbrevs . class , e ) ; } file2 . delete ( ) ; file1 . renameTo ( file2 ) ; abbrevsModTime = file2 . lastModified ( ) ; } } } private static boolean loaded ; private static boolean abbrevsChanged ; private static long abbrevsModTime ; private static boolean expandOnInput ; private static Hashtable globalAbbrevs ; private static Hashtable modes ; private static Vector pp = new Vector ( ) ; private Abbrevs ( ) { } static { expandOnInput = jEdit . getBooleanProperty ( "view.expandOnInput" ) ; } private static void load ( ) { globalAbbrevs = new Hashtable ( ) ; modes = new Hashtable ( ) ; String settings = jEdit . getSettingsDirectory ( ) ; if ( settings != null ) { File file = new File ( MiscUtilities . constructPath ( settings , "abbrevs" ) ) ; abbrevsModTime = file . lastModified ( ) ; try { loadAbbrevs ( new FileReader ( file ) ) ; loaded = true ; } catch ( FileNotFoundException fnf ) { } catch ( Exception e ) { Log . log ( Log . ERROR , Abbrevs . class , "Error while loading " + file ) ; Log . log ( Log . ERROR , Abbrevs . class , e ) ; } } if ( ! loaded ) { try { loadAbbrevs ( new InputStreamReader ( Abbrevs . class . getResourceAsStream ( "default.abbrevs" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , Abbrevs . class , "Error while loading default.abbrevs" ) ; Log . log ( Log . ERROR , Abbrevs . class , e ) ; } loaded = true ; } } private static Expansion expandAbbrev ( String mode , String abbrev , int softTabSize , Vector pp ) { if ( ! loaded ) load ( ) ; String expand = null ; Hashtable modeAbbrevs = ( Hashtable ) modes . get ( mode ) ; if ( modeAbbrevs != null ) expand = ( String ) modeAbbrevs . get ( abbrev ) ; if ( expand == null ) expand = ( String ) globalAbbrevs . get ( abbrev ) ; if ( expand == null ) return null ; else return new Expansion ( expand , softTabSize , pp ) ; } private static void loadAbbrevs ( Reader _in ) throws Exception { BufferedReader in = new BufferedReader ( _in ) ; Hashtable currentAbbrevs = null ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . length ( ) == 0 ) continue ; else if ( line . startsWith ( "[" ) && line . indexOf ( '|' ) == - 1 ) { if ( line . equals ( "[global]" ) ) currentAbbrevs = globalAbbrevs ; else { String mode = line . substring ( 1 , line . length ( ) - 1 ) ; currentAbbrevs = ( Hashtable ) modes . get ( mode ) ; if ( currentAbbrevs == null ) { currentAbbrevs = new Hashtable ( ) ; modes . put ( mode , currentAbbrevs ) ; } } } else { int index = line . indexOf ( '|' ) ; currentAbbrevs . put ( line . substring ( 0 , index ) , line . substring ( index + 1 ) ) ; } } in . close ( ) ; } private static void saveAbbrevs ( Writer _out ) throws Exception { BufferedWriter out = new BufferedWriter ( _out ) ; String lineSep = System . getProperty ( "line.separator" ) ; out . write ( "[global]" ) ; out . write ( lineSep ) ; saveAbbrevs ( out , globalAbbrevs ) ; Enumeration keys = modes . keys ( ) ; Enumeration values = modes . elements ( ) ; while ( keys . hasMoreElements ( ) ) { out . write ( '[' ) ; out . write ( ( String ) keys . nextElement ( ) ) ; out . write ( ']' ) ; out . write ( lineSep ) ; saveAbbrevs ( out , ( Hashtable ) values . nextElement ( ) ) ; } out . close ( ) ; } private static void saveAbbrevs ( Writer out , Hashtable abbrevs ) throws Exception { String lineSep = System . getProperty ( "line.separator" ) ; Enumeration keys = abbrevs . keys ( ) ; Enumeration values = abbrevs . elements ( ) ; while ( keys . hasMoreElements ( ) ) { String abbrev = ( String ) keys . nextElement ( ) ; out . write ( abbrev ) ; out . write ( '|' ) ; out . write ( values . nextElement ( ) . toString ( ) ) ; out . write ( lineSep ) ; } } static class Expansion { String text ; int caretPosition = - 1 ; int lineCount ; int posParamCount ; Expansion ( String text , int softTabSize , Vector pp ) { StringBuffer buf = new StringBuffer ( ) ; boolean backslash = false ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char ch = text . charAt ( i ) ; if ( backslash ) { backslash = false ; if ( ch == '|' ) caretPosition = buf . length ( ) ; else if ( ch == 'n' ) { buf . append ( '\n' ) ; lineCount ++ ; } else if ( ch == 't' ) { if ( softTabSize == 0 ) buf . append ( '\t' ) ; else { for ( int j = 0 ; j < softTabSize ; j ++ ) buf . append ( ' ' ) ; } } else buf . append ( ch ) ; } else if ( ch == '\\' ) backslash = true ; else if ( ch == '$' ) { if ( i != text . length ( ) - 1 ) { ch = text . charAt ( i + 1 ) ; if ( Character . isDigit ( ch ) && ch != '0' ) { i ++ ; int pos = ch - '0' ; posParamCount = Math . max ( pos , posParamCount ) ; if ( pos <= pp . size ( ) ) buf . append ( pp . elementAt ( pos - 1 ) ) ; } else { buf . append ( '$' ) ; } } else buf . append ( '$' ) ; } else buf . append ( ch ) ; } this . text = buf . toString ( ) ; } } } 	0	['18', '1', '0', '13', '102', '43', '4', '11', '9', '0.661764706', '785', '0.875', '0', '0', '0.104575163', '0', '0', '42.16666667', '18', '3.1111', '0']
package bsh ; class BSHPrimitiveType extends SimpleNode { public Class type ; BSHPrimitiveType ( int id ) { super ( id ) ; } public Class getType ( ) { return type ; } } 	0	['2', '2', '0', '4', '3', '1', '3', '1', '1', '1', '10', '0', '0', '0.947368421', '0.75', '0', '0', '3.5', '1', '0.5', '0']
package org . gjt . sp . jedit . gui ; import java . awt . event . * ; import java . awt . * ; import java . util . Vector ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import org . gjt . sp . jedit . * ; public class FontSelector extends JButton { public FontSelector ( Font font ) { setFont ( font ) ; updateText ( ) ; setRequestFocusEnabled ( false ) ; addActionListener ( new ActionHandler ( ) ) ; } private void updateText ( ) { Font font = getFont ( ) ; String styleString ; switch ( font . getStyle ( ) ) { case Font . PLAIN : styleString = jEdit . getProperty ( "font-selector.plain" ) ; break ; case Font . BOLD : styleString = jEdit . getProperty ( "font-selector.bold" ) ; break ; case Font . ITALIC : styleString = jEdit . getProperty ( "font-selector.italic" ) ; break ; case Font . BOLD | Font . ITALIC : styleString = jEdit . getProperty ( "font-selector.bolditalic" ) ; break ; default : styleString = "UNKNOWN!!!???" ; break ; } setText ( font . getName ( ) + " " + font . getSize ( ) + " " + styleString ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Font font ; JDialog dialog = GUIUtilities . getParentDialog ( FontSelector . this ) ; if ( dialog == null ) { font = new FontSelectorDialog ( JOptionPane . getFrameForComponent ( FontSelector . this ) , getFont ( ) ) . getSelectedFont ( ) ; } else { font = new FontSelectorDialog ( dialog , getFont ( ) ) . getSelectedFont ( ) ; } if ( font != null ) { setFont ( font ) ; updateText ( ) ; } } } } class FontSelectorDialog extends EnhancedDialog { public FontSelectorDialog ( Frame parent , Font font ) { super ( parent , jEdit . getProperty ( "font-selector.title" ) , true ) ; init ( font ) ; } public FontSelectorDialog ( Dialog parent , Font font ) { super ( parent , jEdit . getProperty ( "font-selector.title" ) , true ) ; init ( font ) ; } public void ok ( ) { isOK = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public Font getSelectedFont ( ) { if ( ! isOK ) return null ; int size ; try { size = Integer . parseInt ( sizeField . getText ( ) ) ; } catch ( Exception e ) { size = 12 ; } return new Font ( familyField . getText ( ) , styleList . getSelectedIndex ( ) , size ) ; } private boolean isOK ; private JTextField familyField ; private JList familyList ; private JTextField sizeField ; private JList sizeList ; private JTextField styleField ; private JList styleList ; private JLabel preview ; private JButton ok ; private JButton cancel ; private static final String [ ] HIDEFONTS = { ".bold" , ".italic" } ; private void init ( Font font ) { JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel listPanel = new JPanel ( new GridLayout ( 1 , 3 , 6 , 6 ) ) ; JPanel familyPanel = createTextFieldAndListPanel ( "font-selector.family" , familyField = new JTextField ( ) , familyList = new JList ( getFontList ( ) ) ) ; listPanel . add ( familyPanel ) ; String [ ] sizes = { "9" , "10" , "12" , "14" , "16" , "18" , "24" } ; JPanel sizePanel = createTextFieldAndListPanel ( "font-selector.size" , sizeField = new JTextField ( ) , sizeList = new JList ( sizes ) ) ; listPanel . add ( sizePanel ) ; String [ ] styles = { jEdit . getProperty ( "font-selector.plain" ) , jEdit . getProperty ( "font-selector.bold" ) , jEdit . getProperty ( "font-selector.italic" ) , jEdit . getProperty ( "font-selector.bolditalic" ) } ; JPanel stylePanel = createTextFieldAndListPanel ( "font-selector.style" , styleField = new JTextField ( ) , styleList = new JList ( styles ) ) ; styleField . setEditable ( false ) ; listPanel . add ( stylePanel ) ; familyList . setSelectedValue ( font . getFamily ( ) , true ) ; familyField . setText ( font . getFamily ( ) ) ; sizeList . setSelectedValue ( String . valueOf ( font . getSize ( ) ) , true ) ; sizeField . setText ( String . valueOf ( font . getSize ( ) ) ) ; styleList . setSelectedIndex ( font . getStyle ( ) ) ; styleField . setText ( ( String ) styleList . getSelectedValue ( ) ) ; ListHandler listHandler = new ListHandler ( ) ; familyList . addListSelectionListener ( listHandler ) ; sizeList . addListSelectionListener ( listHandler ) ; styleList . addListSelectionListener ( listHandler ) ; content . add ( BorderLayout . NORTH , listPanel ) ; preview = new JLabel ( jEdit . getProperty ( "font-selector.long-text" ) ) ; preview . setBorder ( new TitledBorder ( jEdit . getProperty ( "font-selector.preview" ) ) ) ; updatePreview ( ) ; Dimension prefSize = preview . getPreferredSize ( ) ; prefSize . height = 50 ; preview . setPreferredSize ( prefSize ) ; content . add ( BorderLayout . CENTER , preview ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; buttons . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; buttons . add ( ok ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( cancel ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , buttons ) ; pack ( ) ; setLocationRelativeTo ( getParent ( ) ) ; show ( ) ; } private String [ ] getFontList ( ) { String [ ] nameArray = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) . getAvailableFontFamilyNames ( ) ; Vector nameVector = new Vector ( nameArray . length ) ; for ( int i = 0 , j ; i < nameArray . length ; i ++ ) { for ( j = 0 ; j < HIDEFONTS . length ; j ++ ) { if ( nameArray [ i ] . indexOf ( HIDEFONTS [ j ] ) >= 0 ) break ; } if ( j == HIDEFONTS . length ) nameVector . addElement ( nameArray [ i ] ) ; } String [ ] _array = new String [ nameVector . size ( ) ] ; nameVector . copyInto ( _array ) ; return _array ; } private JPanel createTextFieldAndListPanel ( String label , JTextField textField , JList list ) { GridBagLayout layout = new GridBagLayout ( ) ; JPanel panel = new JPanel ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridx = cons . gridy = 0 ; cons . gridwidth = cons . gridheight = 1 ; cons . fill = GridBagConstraints . BOTH ; cons . weightx = 1.0f ; JLabel _label = new JLabel ( jEdit . getProperty ( label ) ) ; layout . setConstraints ( _label , cons ) ; panel . add ( _label ) ; cons . gridy = 1 ; Component vs = Box . createVerticalStrut ( 6 ) ; layout . setConstraints ( vs , cons ) ; panel . add ( vs ) ; cons . gridy = 2 ; layout . setConstraints ( textField , cons ) ; panel . add ( textField ) ; cons . gridy = 3 ; vs = Box . createVerticalStrut ( 6 ) ; layout . setConstraints ( vs , cons ) ; panel . add ( vs ) ; cons . gridy = 4 ; cons . gridheight = GridBagConstraints . REMAINDER ; cons . weighty = 1.0f ; JScrollPane scroller = new JScrollPane ( list ) ; layout . setConstraints ( scroller , cons ) ; panel . add ( scroller ) ; return panel ; } private void updatePreview ( ) { String family = familyField . getText ( ) ; int size ; try { size = Integer . parseInt ( sizeField . getText ( ) ) ; } catch ( Exception e ) { size = 12 ; } int style = styleList . getSelectedIndex ( ) ; preview . setFont ( new Font ( family , style , size ) ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) ok ( ) ; else if ( evt . getSource ( ) == cancel ) cancel ( ) ; } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == familyList ) { String family = ( String ) familyList . getSelectedValue ( ) ; if ( family != null ) familyField . setText ( family ) ; } else if ( source == sizeList ) { String size = ( String ) sizeList . getSelectedValue ( ) ; if ( size != null ) sizeField . setText ( size ) ; } else if ( source == styleList ) { String style = ( String ) styleList . getSelectedValue ( ) ; if ( style != null ) styleField . setText ( style ) ; } updatePreview ( ) ; } } } 	0	['3', '6', '0', '6', '18', '3', '5', '2', '1', '2', '66', '0', '0', '0.997382199', '0.444444444', '0', '0', '21', '2', '1', '0']
package org . gjt . sp . jedit . syntax ; public class Token { public static byte stringToToken ( String value ) { value = value . intern ( ) ; if ( value == "NULL" ) return Token . NULL ; else if ( value == "COMMENT1" ) return Token . COMMENT1 ; else if ( value == "COMMENT2" ) return Token . COMMENT2 ; else if ( value == "LITERAL1" ) return Token . LITERAL1 ; else if ( value == "LITERAL2" ) return Token . LITERAL2 ; else if ( value == "LABEL" ) return Token . LABEL ; else if ( value == "KEYWORD1" ) return Token . KEYWORD1 ; else if ( value == "KEYWORD2" ) return Token . KEYWORD2 ; else if ( value == "KEYWORD3" ) return Token . KEYWORD3 ; else if ( value == "FUNCTION" ) return Token . FUNCTION ; else if ( value == "MARKUP" ) return Token . MARKUP ; else if ( value == "OPERATOR" ) return Token . OPERATOR ; else if ( value == "DIGIT" ) return Token . DIGIT ; else if ( value == "INVALID" ) return Token . INVALID ; else return - 1 ; } public static final byte NULL = 0 ; public static final byte COMMENT1 = 1 ; public static final byte COMMENT2 = 2 ; public static final byte LITERAL1 = 3 ; public static final byte LITERAL2 = 4 ; public static final byte LABEL = 5 ; public static final byte KEYWORD1 = 6 ; public static final byte KEYWORD2 = 7 ; public static final byte KEYWORD3 = 8 ; public static final byte FUNCTION = 9 ; public static final byte MARKUP = 10 ; public static final byte OPERATOR = 11 ; public static final byte DIGIT = 12 ; public static final byte INVALID = 13 ; public static final byte ID_COUNT = 14 ; public static final byte WHITESPACE = 125 ; public static final byte TAB = 126 ; public static final byte END = 127 ; public byte id ; public int offset ; public int length ; public ParserRuleSet rules ; public Token next ; public Token ( byte id , int offset , int length , ParserRuleSet rules ) { this . id = id ; this . offset = offset ; this . length = length ; this . rules = rules ; } public String toString ( ) { return "[id=" + id + ",offset=" + offset + ",length=" + length + "]" ; } } 	0	['3', '1', '1', '10', '9', '1', '9', '1', '3', '1.347826087', '138', '0', '2', '0', '0.4', '0', '0', '37.33333333', '15', '5.3333', '0']
package bsh ; import java . io . * ; public class ParserTokenManager implements ParserConstants { private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active1 & 0x400040000000L ) != 0L ) return 56 ; if ( ( active0 & 0x3eL ) != 0L ) return 0 ; if ( ( active1 & 0x20L ) != 0L ) return 11 ; if ( ( active0 & 0x1fffffffffc00L ) != 0L ) { jjmatchedKind = 58 ; return 35 ; } return - 1 ; case 1 : if ( ( active0 & 0x1ffffdfcffc00L ) != 0L ) { if ( jjmatchedPos != 1 ) { jjmatchedKind = 58 ; jjmatchedPos = 1 ; } return 35 ; } if ( ( active0 & 0x20300000L ) != 0L ) return 35 ; return - 1 ; case 2 : if ( ( active0 & 0x1bff4d7effc00L ) != 0L ) { if ( jjmatchedPos != 2 ) { jjmatchedKind = 58 ; jjmatchedPos = 2 ; } return 35 ; } if ( ( active0 & 0x400b08000000L ) != 0L ) return 35 ; return - 1 ; case 3 : if ( ( active0 & 0xa01410416000L ) != 0L ) return 35 ; if ( ( active0 & 0x11fe2c7ae9c00L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 58 ; jjmatchedPos = 3 ; } return 35 ; } return - 1 ; case 4 : if ( ( active0 & 0xde2c02c0400L ) != 0L ) { if ( jjmatchedPos != 4 ) { jjmatchedKind = 58 ; jjmatchedPos = 4 ; } return 35 ; } if ( ( active0 & 0x1120007829800L ) != 0L ) return 35 ; return - 1 ; case 5 : if ( ( active0 & 0x62820c0400L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 5 ; return 35 ; } if ( ( active0 & 0xd8040200000L ) != 0L ) return 35 ; return - 1 ; case 6 : if ( ( active0 & 0x2002080400L ) != 0L ) return 35 ; if ( ( active0 & 0x4280040000L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 6 ; return 35 ; } return - 1 ; case 7 : if ( ( active0 & 0x4280000000L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 7 ; return 35 ; } if ( ( active0 & 0x40000L ) != 0L ) return 35 ; return - 1 ; case 8 : if ( ( active0 & 0x80000000L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 8 ; return 35 ; } if ( ( active0 & 0x4200000000L ) != 0L ) return 35 ; return - 1 ; case 9 : if ( ( active0 & 0x80000000L ) != 0L ) return 35 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_0 ( int pos , long active0 , long active1 ) { return jjMoveNfa_0 ( jjStopStringLiteralDfa_0 ( pos , active0 , active1 ) , pos + 1 ) ; } private final int jjStopAtPos ( int pos , int kind ) { jjmatchedKind = kind ; jjmatchedPos = pos ; return pos + 1 ; } private final int jjStartNfaWithStates_0 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_0 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_0 ( ) { switch ( curChar ) { case 9 : return jjStartNfaWithStates_0 ( 0 , 2 , 0 ) ; case 10 : return jjStartNfaWithStates_0 ( 0 , 5 , 0 ) ; case 12 : return jjStartNfaWithStates_0 ( 0 , 4 , 0 ) ; case 13 : return jjStartNfaWithStates_0 ( 0 , 3 , 0 ) ; case 32 : return jjStartNfaWithStates_0 ( 0 , 1 , 0 ) ; case 33 : jjmatchedKind = 75 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x100000L ) ; case 37 : jjmatchedKind = 100 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x10000000000000L ) ; case 38 : jjmatchedKind = 95 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x800000800000L ) ; case 40 : return jjStopAtPos ( 0 , 61 ) ; case 41 : return jjStopAtPos ( 0 , 62 ) ; case 42 : jjmatchedKind = 93 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x200000000000L ) ; case 43 : jjmatchedKind = 91 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x80002000000L ) ; case 44 : return jjStopAtPos ( 0 , 68 ) ; case 45 : jjmatchedKind = 92 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x100004000000L ) ; case 46 : return jjStartNfaWithStates_0 ( 0 , 69 , 11 ) ; case 47 : jjmatchedKind = 94 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x400000000000L ) ; case 58 : return jjStopAtPos ( 0 , 78 ) ; case 59 : return jjStopAtPos ( 0 , 67 ) ; case 60 : jjmatchedKind = 73 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x20002000010000L ) ; case 61 : jjmatchedKind = 70 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x8000L ) ; case 62 : jjmatchedKind = 71 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x280028000040000L ) ; case 63 : return jjStopAtPos ( 0 , 77 ) ; case 64 : return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x5450545014a0500L ) ; case 91 : return jjStopAtPos ( 0 , 65 ) ; case 93 : return jjStopAtPos ( 0 , 66 ) ; case 94 : jjmatchedKind = 99 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x8000000000000L ) ; case 98 : return jjMoveStringLiteralDfa1_0 ( 0x2c00L , 0x0L ) ; case 99 : return jjMoveStringLiteralDfa1_0 ( 0x7d000L , 0x0L ) ; case 100 : return jjMoveStringLiteralDfa1_0 ( 0x380000L , 0x0L ) ; case 101 : return jjMoveStringLiteralDfa1_0 ( 0x400000L , 0x0L ) ; case 102 : return jjMoveStringLiteralDfa1_0 ( 0xf800000L , 0x0L ) ; case 103 : return jjMoveStringLiteralDfa1_0 ( 0x10000000L , 0x0L ) ; case 105 : return jjMoveStringLiteralDfa1_0 ( 0x3e0000000L , 0x0L ) ; case 108 : return jjMoveStringLiteralDfa1_0 ( 0x400000000L , 0x0L ) ; case 110 : return jjMoveStringLiteralDfa1_0 ( 0x1800000000L , 0x0L ) ; case 112 : return jjMoveStringLiteralDfa1_0 ( 0xe000000000L , 0x0L ) ; case 114 : return jjMoveStringLiteralDfa1_0 ( 0x10000000000L , 0x0L ) ; case 115 : return jjMoveStringLiteralDfa1_0 ( 0xe0000000000L , 0x0L ) ; case 116 : return jjMoveStringLiteralDfa1_0 ( 0x700000000000L , 0x0L ) ; case 118 : return jjMoveStringLiteralDfa1_0 ( 0x800000000000L , 0x0L ) ; case 119 : return jjMoveStringLiteralDfa1_0 ( 0x1000000000000L , 0x0L ) ; case 123 : return jjStopAtPos ( 0 , 63 ) ; case 124 : jjmatchedKind = 97 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x2000000200000L ) ; case 125 : return jjStopAtPos ( 0 , 64 ) ; case 126 : return jjStopAtPos ( 0 , 76 ) ; default : return jjMoveNfa_0 ( 6 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_0 ( long active0 , long active1 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 0 , active0 , active1 ) ; return 1 ; } switch ( curChar ) { case 38 : if ( ( active1 & 0x800000L ) != 0L ) return jjStopAtPos ( 1 , 87 ) ; break ; case 43 : if ( ( active1 & 0x2000000L ) != 0L ) return jjStopAtPos ( 1 , 89 ) ; break ; case 45 : if ( ( active1 & 0x4000000L ) != 0L ) return jjStopAtPos ( 1 , 90 ) ; break ; case 60 : if ( ( active1 & 0x2000000000L ) != 0L ) { jjmatchedKind = 101 ; jjmatchedPos = 1 ; } return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x20000000000000L ) ; case 61 : if ( ( active1 & 0x8000L ) != 0L ) return jjStopAtPos ( 1 , 79 ) ; else if ( ( active1 & 0x10000L ) != 0L ) return jjStopAtPos ( 1 , 80 ) ; else if ( ( active1 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 82 ) ; else if ( ( active1 & 0x100000L ) != 0L ) return jjStopAtPos ( 1 , 84 ) ; else if ( ( active1 & 0x80000000000L ) != 0L ) return jjStopAtPos ( 1 , 107 ) ; else if ( ( active1 & 0x100000000000L ) != 0L ) return jjStopAtPos ( 1 , 108 ) ; else if ( ( active1 & 0x200000000000L ) != 0L ) return jjStopAtPos ( 1 , 109 ) ; else if ( ( active1 & 0x400000000000L ) != 0L ) return jjStopAtPos ( 1 , 110 ) ; else if ( ( active1 & 0x800000000000L ) != 0L ) return jjStopAtPos ( 1 , 111 ) ; else if ( ( active1 & 0x2000000000000L ) != 0L ) return jjStopAtPos ( 1 , 113 ) ; else if ( ( active1 & 0x8000000000000L ) != 0L ) return jjStopAtPos ( 1 , 115 ) ; else if ( ( active1 & 0x10000000000000L ) != 0L ) return jjStopAtPos ( 1 , 116 ) ; break ; case 62 : if ( ( active1 & 0x8000000000L ) != 0L ) { jjmatchedKind = 103 ; jjmatchedPos = 1 ; } return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x280020000000000L ) ; case 97 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x80c000L , active1 , 0x1000001000000L ) ; case 98 : return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x500000000L ) ; case 101 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x10800080000L , active1 , 0L ) ; case 102 : if ( ( active0 & 0x20000000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 29 , 35 ) ; break ; case 103 : return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x80100L ) ; case 104 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x1120000010000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x3000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x4401000L , active1 , 0x40004000020400L ) ; case 109 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x40000000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x380000000L , active1 , 0L ) ; case 111 : if ( ( active0 & 0x100000L ) != 0L ) { jjmatchedKind = 20 ; jjmatchedPos = 1 ; } return jjMoveStringLiteralDfa2_0 ( active0 , 0x800418260400L , active1 , 0x4000000400000L ) ; case 114 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x606000000800L , active1 , 0x500050000000000L ) ; case 116 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x40000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x9000000000L , active1 , 0L ) ; case 119 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x80000000000L , active1 , 0L ) ; case 121 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x2000L , active1 , 0L ) ; case 124 : if ( ( active1 & 0x200000L ) != 0L ) return jjStopAtPos ( 1 , 85 ) ; break ; default : break ; } return jjStartNfa_0 ( 0 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa2_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 0 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 1 , active0 , active1 ) ; return 2 ; } switch ( curChar ) { case 61 : if ( ( active1 & 0x20000000000000L ) != 0L ) return jjStopAtPos ( 2 , 117 ) ; else if ( ( active1 & 0x80000000000000L ) != 0L ) return jjStopAtPos ( 2 , 119 ) ; break ; case 62 : if ( ( active1 & 0x20000000000L ) != 0L ) { jjmatchedKind = 105 ; jjmatchedPos = 2 ; } return jjMoveStringLiteralDfa3_0 ( active0 , 0L , active1 , 0x200000000000000L ) ; case 97 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x40000011000L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x8000000000L , active1 , 0L ) ; case 101 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x800L , active1 , 0x40004000000000L ) ; case 102 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x80000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x1882000000000L , active1 , 0x500050500000000L ) ; case 108 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x1000800000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x403060000L , active1 , 0x1000001000000L ) ; case 111 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x24004000400L , active1 , 0L ) ; case 112 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x40000000L , active1 , 0L ) ; case 114 : if ( ( active0 & 0x8000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 27 , 35 ) ; else if ( ( active1 & 0x400000L ) != 0L ) { jjmatchedKind = 86 ; jjmatchedPos = 2 ; } return jjMoveStringLiteralDfa3_0 ( active0 , 0x100000000000L , active1 , 0x4000000000000L ) ; case 115 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x80404000L , active1 , 0L ) ; case 116 : if ( ( active0 & 0x100000000L ) != 0L ) { jjmatchedKind = 32 ; jjmatchedPos = 2 ; } else if ( ( active1 & 0x100L ) != 0L ) { jjmatchedKind = 72 ; jjmatchedPos = 2 ; } else if ( ( active1 & 0x400L ) != 0L ) { jjmatchedKind = 74 ; jjmatchedPos = 2 ; } return jjMoveStringLiteralDfa3_0 ( active0 , 0x1021000a000L , active1 , 0xa0000L ) ; case 117 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x200000200000L , active1 , 0L ) ; case 119 : if ( ( active0 & 0x800000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 35 , 35 ) ; break ; case 121 : if ( ( active0 & 0x400000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 46 , 35 ) ; break ; default : break ; } return jjStartNfa_0 ( 1 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa3_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 1 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 2 , active0 , active1 ) ; return 3 ; } switch ( curChar ) { case 61 : if ( ( active1 & 0x200000000000000L ) != 0L ) return jjStopAtPos ( 3 , 121 ) ; break ; case 95 : return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 97 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x7080800L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x200000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x8000L , active1 , 0L ) ; case 100 : if ( ( active0 & 0x800000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 47 , 35 ) ; else if ( ( active1 & 0x1000000L ) != 0L ) { jjmatchedKind = 88 ; jjmatchedPos = 3 ; } return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x1000000000000L ) ; case 101 : if ( ( active0 & 0x2000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 13 , 35 ) ; else if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 14 , 35 ) ; else if ( ( active0 & 0x400000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 22 , 35 ) ; else if ( ( active0 & 0x200000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 45 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x200000000L , active1 , 0xa0000L ) ; case 102 : return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 103 : if ( ( active0 & 0x400000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 34 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x500050000000000L ) ; case 108 : if ( ( active0 & 0x1000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 36 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x1008000000400L , active1 , 0L ) ; case 111 : if ( ( active0 & 0x10000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 28 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x100040000000L , active1 , 0L ) ; case 114 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 16 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x20000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x821000L , active1 , 0L ) ; case 116 : return jjMoveStringLiteralDfa4_0 ( active0 , 0xc4080040000L , active1 , 0x500000000L ) ; case 117 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x10000000000L , active1 , 0L ) ; case 118 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x2000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 2 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa4_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 2 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 3 , active0 , active1 ) ; return 4 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x1000000000000L ) ; case 97 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x2080000000L , active1 , 0x4000000000000L ) ; case 99 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x80000000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x800000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 23 , 35 ) ; else if ( ( active0 & 0x1000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 48 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0x4000000400L , active1 , 0L ) ; case 104 : if ( ( active0 & 0x8000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 15 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x500050000000000L ) ; case 105 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x48000040000L , active1 , 0L ) ; case 107 : if ( ( active0 & 0x800L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 11 , 35 ) ; break ; case 108 : if ( ( active0 & 0x1000000L ) != 0L ) { jjmatchedKind = 24 ; jjmatchedPos = 4 ; } return jjMoveStringLiteralDfa5_0 ( active0 , 0x2200000L , active1 , 0L ) ; case 113 : if ( ( active1 & 0x20000L ) != 0L ) return jjStopAtPos ( 4 , 81 ) ; else if ( ( active1 & 0x80000L ) != 0L ) return jjStopAtPos ( 4 , 83 ) ; break ; case 114 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x10240000000L , active1 , 0L ) ; case 115 : if ( ( active0 & 0x1000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 12 , 35 ) ; break ; case 116 : if ( ( active0 & 0x20000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 17 , 35 ) ; else if ( ( active0 & 0x4000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 26 , 35 ) ; else if ( ( active0 & 0x20000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 41 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 117 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x80000L , active1 , 0L ) ; case 119 : if ( ( active0 & 0x100000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 44 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x500000000L ) ; default : break ; } return jjStartNfa_0 ( 3 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa5_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 3 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 4 , active0 , active1 ) ; return 5 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa6_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 97 : return jjMoveStringLiteralDfa6_0 ( active0 , 0x400L , active1 , 0x1000000000000L ) ; case 99 : if ( ( active0 & 0x8000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 39 , 35 ) ; else if ( ( active0 & 0x40000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 42 , 35 ) ; return jjMoveStringLiteralDfa6_0 ( active0 , 0x4000000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x200000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 21 , 35 ) ; break ; case 102 : return jjMoveStringLiteralDfa6_0 ( active0 , 0x200000000L , active1 , 0L ) ; case 104 : if ( ( active0 & 0x80000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 43 , 35 ) ; break ; case 105 : return jjMoveStringLiteralDfa6_0 ( active0 , 0L , active1 , 0x500000000L ) ; case 108 : return jjMoveStringLiteralDfa6_0 ( active0 , 0x2080000L , active1 , 0L ) ; case 110 : if ( ( active0 & 0x10000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 40 , 35 ) ; return jjMoveStringLiteralDfa6_0 ( active0 , 0x80040000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa6_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 116 : if ( ( active0 & 0x40000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 30 , 35 ) ; return jjMoveStringLiteralDfa6_0 ( active0 , 0x2000000000L , active1 , 0x500050000000000L ) ; default : break ; } return jjStartNfa_0 ( 4 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa6_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 4 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 5 , active0 , active1 ) ; return 6 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa7_0 ( active0 , 0L , active1 , 0x500050000000000L ) ; case 97 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x200000000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x80000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x2000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 37 , 35 ) ; break ; case 110 : if ( ( active0 & 0x400L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 10 , 35 ) ; break ; case 115 : return jjMoveStringLiteralDfa7_0 ( active0 , 0L , active1 , 0x45004500000000L ) ; case 116 : if ( ( active0 & 0x80000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 19 , 35 ) ; return jjMoveStringLiteralDfa7_0 ( active0 , 0x4000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x40000L , active1 , 0L ) ; case 121 : if ( ( active0 & 0x2000000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 25 , 35 ) ; break ; default : break ; } return jjStartNfa_0 ( 5 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa7_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 5 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 6 , active0 , active1 ) ; return 7 ; } switch ( curChar ) { case 99 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x200000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x40000L ) != 0L ) return jjStartNfaWithStates_0 ( 7 , 18 , 35 ) ; return jjMoveStringLiteralDfa8_0 ( active0 , 0x4080000000L , active1 , 0x500000000L ) ; case 104 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 105 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 115 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x101010000000000L ) ; case 117 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 6 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa8_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 6 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 7 , active0 , active1 ) ; return 8 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x500000000L ) ; case 100 : if ( ( active0 & 0x4000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 8 , 38 , 35 ) ; break ; case 101 : if ( ( active0 & 0x200000000L ) != 0L ) return jjStartNfaWithStates_0 ( 8 , 33 , 35 ) ; break ; case 103 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 104 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x100010000000000L ) ; case 105 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x41004000000000L ) ; case 110 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x400040000000000L ) ; case 111 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x80000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 7 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 7 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 8 , active0 , active1 ) ; return 9 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x100000000L ) ; case 102 : if ( ( active0 & 0x80000000L ) != 0L ) return jjStartNfaWithStates_0 ( 9 , 31 , 35 ) ; return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 103 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x1000000000000L ) ; case 105 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x100010000000000L ) ; case 110 : if ( ( active1 & 0x4000000000000L ) != 0L ) return jjStopAtPos ( 9 , 114 ) ; break ; case 111 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x400000000L ) ; case 115 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 8 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa10_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 8 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 9 , 0L , active1 ) ; return 10 ; } switch ( curChar ) { case 102 : return jjMoveStringLiteralDfa11_0 ( active1 , 0x100010000000000L ) ; case 105 : return jjMoveStringLiteralDfa11_0 ( active1 , 0x400040000000000L ) ; case 110 : if ( ( active1 & 0x1000000000000L ) != 0L ) return jjStopAtPos ( 10 , 112 ) ; return jjMoveStringLiteralDfa11_0 ( active1 , 0x100000000L ) ; case 114 : if ( ( active1 & 0x400000000L ) != 0L ) return jjStopAtPos ( 10 , 98 ) ; break ; case 116 : if ( ( active1 & 0x4000000000L ) != 0L ) { jjmatchedKind = 102 ; jjmatchedPos = 10 ; } return jjMoveStringLiteralDfa11_0 ( active1 , 0x40000000000000L ) ; default : break ; } return jjStartNfa_0 ( 9 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa11_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 9 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 10 , 0L , active1 ) ; return 11 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa12_0 ( active1 , 0x40000000000000L ) ; case 100 : if ( ( active1 & 0x100000000L ) != 0L ) return jjStopAtPos ( 11 , 96 ) ; break ; case 103 : return jjMoveStringLiteralDfa12_0 ( active1 , 0x400040000000000L ) ; case 116 : if ( ( active1 & 0x10000000000L ) != 0L ) { jjmatchedKind = 104 ; jjmatchedPos = 11 ; } return jjMoveStringLiteralDfa12_0 ( active1 , 0x100000000000000L ) ; default : break ; } return jjStartNfa_0 ( 10 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa12_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 10 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 11 , 0L , active1 ) ; return 12 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa13_0 ( active1 , 0x100000000000000L ) ; case 97 : return jjMoveStringLiteralDfa13_0 ( active1 , 0x40000000000000L ) ; case 110 : return jjMoveStringLiteralDfa13_0 ( active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 11 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa13_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 11 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 12 , 0L , active1 ) ; return 13 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa14_0 ( active1 , 0x100000000000000L ) ; case 101 : return jjMoveStringLiteralDfa14_0 ( active1 , 0x400040000000000L ) ; case 115 : return jjMoveStringLiteralDfa14_0 ( active1 , 0x40000000000000L ) ; default : break ; } return jjStartNfa_0 ( 12 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa14_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 12 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 13 , 0L , active1 ) ; return 14 ; } switch ( curChar ) { case 100 : return jjMoveStringLiteralDfa15_0 ( active1 , 0x400040000000000L ) ; case 115 : return jjMoveStringLiteralDfa15_0 ( active1 , 0x140000000000000L ) ; default : break ; } return jjStartNfa_0 ( 13 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa15_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 13 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 14 , 0L , active1 ) ; return 15 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa16_0 ( active1 , 0x400040000000000L ) ; case 105 : return jjMoveStringLiteralDfa16_0 ( active1 , 0x40000000000000L ) ; case 115 : return jjMoveStringLiteralDfa16_0 ( active1 , 0x100000000000000L ) ; default : break ; } return jjStartNfa_0 ( 14 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa16_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 14 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 15 , 0L , active1 ) ; return 16 ; } switch ( curChar ) { case 103 : return jjMoveStringLiteralDfa17_0 ( active1 , 0x40000000000000L ) ; case 105 : return jjMoveStringLiteralDfa17_0 ( active1 , 0x100000000000000L ) ; case 115 : return jjMoveStringLiteralDfa17_0 ( active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 15 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa17_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 15 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 16 , 0L , active1 ) ; return 17 ; } switch ( curChar ) { case 103 : return jjMoveStringLiteralDfa18_0 ( active1 , 0x100000000000000L ) ; case 104 : return jjMoveStringLiteralDfa18_0 ( active1 , 0x400040000000000L ) ; case 110 : if ( ( active1 & 0x40000000000000L ) != 0L ) return jjStopAtPos ( 17 , 118 ) ; break ; default : break ; } return jjStartNfa_0 ( 16 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa18_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 16 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 17 , 0L , active1 ) ; return 18 ; } switch ( curChar ) { case 105 : return jjMoveStringLiteralDfa19_0 ( active1 , 0x400040000000000L ) ; case 110 : if ( ( active1 & 0x100000000000000L ) != 0L ) return jjStopAtPos ( 18 , 120 ) ; break ; default : break ; } return jjStartNfa_0 ( 17 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa19_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 17 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 18 , 0L , active1 ) ; return 19 ; } switch ( curChar ) { case 102 : return jjMoveStringLiteralDfa20_0 ( active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 18 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa20_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 18 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 19 , 0L , active1 ) ; return 20 ; } switch ( curChar ) { case 116 : if ( ( active1 & 0x40000000000L ) != 0L ) { jjmatchedKind = 106 ; jjmatchedPos = 20 ; } return jjMoveStringLiteralDfa21_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 19 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa21_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 19 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 20 , 0L , active1 ) ; return 21 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa22_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 20 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa22_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 20 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 21 , 0L , active1 ) ; return 22 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa23_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 21 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa23_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 21 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 22 , 0L , active1 ) ; return 23 ; } switch ( curChar ) { case 115 : return jjMoveStringLiteralDfa24_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 22 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa24_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 22 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 23 , 0L , active1 ) ; return 24 ; } switch ( curChar ) { case 115 : return jjMoveStringLiteralDfa25_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 23 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa25_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 23 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 24 , 0L , active1 ) ; return 25 ; } switch ( curChar ) { case 105 : return jjMoveStringLiteralDfa26_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 24 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa26_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 24 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 25 , 0L , active1 ) ; return 26 ; } switch ( curChar ) { case 103 : return jjMoveStringLiteralDfa27_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 25 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa27_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 25 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 26 , 0L , active1 ) ; return 27 ; } switch ( curChar ) { case 110 : if ( ( active1 & 0x400000000000000L ) != 0L ) return jjStopAtPos ( 27 , 122 ) ; break ; default : break ; } return jjStartNfa_0 ( 26 , 0L , active1 ) ; } private final void jjCheckNAdd ( int state ) { if ( jjrounds [ state ] != jjround ) { jjstateSet [ jjnewStateCnt ++ ] = state ; jjrounds [ state ] = jjround ; } } private final void jjAddStates ( int start , int end ) { do { jjstateSet [ jjnewStateCnt ++ ] = jjnextStates [ start ] ; } while ( start ++ != end ) ; } private final void jjCheckNAddTwoStates ( int state1 , int state2 ) { jjCheckNAdd ( state1 ) ; jjCheckNAdd ( state2 ) ; } private final void jjCheckNAddStates ( int start , int end ) { do { jjCheckNAdd ( jjnextStates [ start ] ) ; } while ( start ++ != end ) ; } private final void jjCheckNAddStates ( int start ) { jjCheckNAdd ( jjnextStates [ start ] ) ; jjCheckNAdd ( jjnextStates [ start + 1 ] ) ; } static final long [ ] jjbitVec0 = { 0x0L , 0x0L , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec1 = { 0xfffffffffffffffeL , 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec3 = { 0x1ff00000fffffffeL , 0xffffffffffffc000L , 0xffffffffL , 0x600000000000000L } ; static final long [ ] jjbitVec4 = { 0x0L , 0x0L , 0x0L , 0xff7fffffff7fffffL } ; static final long [ ] jjbitVec5 = { 0x0L , 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec6 = { 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffL , 0x0L } ; static final long [ ] jjbitVec7 = { 0xffffffffffffffffL , 0xffffffffffffffffL , 0x0L , 0x0L } ; static final long [ ] jjbitVec8 = { 0x3fffffffffffL , 0x0L , 0x0L , 0x0L } ; private final int jjMoveNfa_0 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 74 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : if ( ( 0x1ffffffffL & l ) != 0L ) { if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; } else if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 0 , 6 ) ; else if ( curChar == 47 ) jjAddStates ( 7 , 9 ) ; else if ( curChar == 36 ) { if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; } else if ( curChar == 34 ) jjCheckNAddStates ( 10 , 12 ) ; else if ( curChar == 39 ) jjAddStates ( 13 , 14 ) ; else if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; if ( ( 0x3fe000000000000L & l ) != 0L ) { if ( kind > 49 ) kind = 49 ; jjCheckNAddTwoStates ( 8 , 9 ) ; } else if ( curChar == 48 ) { if ( kind > 49 ) kind = 49 ; jjCheckNAddStates ( 15 , 17 ) ; } break ; case 56 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 67 ; else if ( curChar == 47 ) { if ( kind > 7 ) kind = 7 ; jjCheckNAddStates ( 18 , 20 ) ; } if ( curChar == 42 ) jjCheckNAdd ( 62 ) ; break ; case 0 : if ( ( 0x1ffffffffL & l ) == 0L ) break ; if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; break ; case 1 : if ( curChar == 33 ) jjCheckNAddStates ( 21 , 23 ) ; break ; case 2 : if ( ( 0xffffffffffffdbffL & l ) != 0L ) jjCheckNAddStates ( 21 , 23 ) ; break ; case 3 : if ( ( 0x2400L & l ) != 0L && kind > 8 ) kind = 8 ; break ; case 4 : if ( curChar == 10 && kind > 8 ) kind = 8 ; break ; case 5 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 4 ; break ; case 7 : if ( ( 0x3fe000000000000L & l ) == 0L ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 8 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 10 : if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; break ; case 11 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddStates ( 24 , 26 ) ; break ; case 13 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 14 ) ; break ; case 14 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 14 , 15 ) ; break ; case 16 : if ( curChar == 39 ) jjAddStates ( 13 , 14 ) ; break ; case 17 : if ( ( 0xffffff7fffffdbffL & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 18 : if ( curChar == 39 && kind > 55 ) kind = 55 ; break ; case 20 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 21 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 22 , 18 ) ; break ; case 22 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 23 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 24 ; break ; case 24 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 22 ) ; break ; case 25 : if ( curChar == 34 ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 26 : if ( ( 0xfffffffbffffdbffL & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 28 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 29 : if ( curChar == 34 && kind > 56 ) kind = 56 ; break ; case 30 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 27 , 30 ) ; break ; case 31 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 32 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 33 ; break ; case 33 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 31 ) ; break ; case 34 : if ( curChar != 36 ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 35 : if ( ( 0x3ff001000000000L & l ) == 0L ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 36 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 0 , 6 ) ; break ; case 37 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 37 , 38 ) ; break ; case 38 : if ( curChar != 46 ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddStates ( 31 , 33 ) ; break ; case 39 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddStates ( 31 , 33 ) ; break ; case 41 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 42 ) ; break ; case 42 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 42 , 15 ) ; break ; case 43 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 43 , 44 ) ; break ; case 45 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 46 ) ; break ; case 46 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 46 , 15 ) ; break ; case 47 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 34 , 36 ) ; break ; case 49 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 50 ) ; break ; case 50 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 50 , 15 ) ; break ; case 51 : if ( curChar != 48 ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAddStates ( 15 , 17 ) ; break ; case 53 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAddTwoStates ( 53 , 9 ) ; break ; case 54 : if ( ( 0xff000000000000L & l ) == 0L ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAddTwoStates ( 54 , 9 ) ; break ; case 55 : if ( curChar == 47 ) jjAddStates ( 7 , 9 ) ; break ; case 57 : if ( ( 0xffffffffffffdbffL & l ) == 0L ) break ; if ( kind > 7 ) kind = 7 ; jjCheckNAddStates ( 18 , 20 ) ; break ; case 58 : if ( ( 0x2400L & l ) != 0L && kind > 7 ) kind = 7 ; break ; case 59 : if ( curChar == 10 && kind > 7 ) kind = 7 ; break ; case 60 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 59 ; break ; case 61 : if ( curChar == 42 ) jjCheckNAdd ( 62 ) ; break ; case 62 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 63 : if ( curChar == 42 ) jjCheckNAddStates ( 37 , 39 ) ; break ; case 64 : if ( ( 0xffff7bffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 65 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 66 : if ( curChar == 47 && kind > 9 ) kind = 9 ; break ; case 67 : if ( curChar == 42 ) jjCheckNAddTwoStates ( 68 , 69 ) ; break ; case 68 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 68 , 69 ) ; break ; case 69 : if ( curChar == 42 ) jjCheckNAddStates ( 40 , 42 ) ; break ; case 70 : if ( ( 0xffff7bffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 71 , 69 ) ; break ; case 71 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 71 , 69 ) ; break ; case 72 : if ( curChar == 47 && kind > 57 ) kind = 57 ; break ; case 73 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 67 ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : case 35 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 2 : jjAddStates ( 21 , 23 ) ; break ; case 9 : if ( ( 0x100000001000L & l ) != 0L && kind > 49 ) kind = 49 ; break ; case 12 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 43 , 44 ) ; break ; case 15 : if ( ( 0x5000000050L & l ) != 0L && kind > 53 ) kind = 53 ; break ; case 17 : if ( ( 0xffffffffefffffffL & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 19 : if ( curChar == 92 ) jjAddStates ( 45 , 47 ) ; break ; case 20 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 26 : if ( ( 0xffffffffefffffffL & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 27 : if ( curChar == 92 ) jjAddStates ( 48 , 50 ) ; break ; case 28 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 40 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 51 , 52 ) ; break ; case 44 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 53 , 54 ) ; break ; case 48 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 55 , 56 ) ; break ; case 52 : if ( ( 0x100000001000000L & l ) != 0L ) jjCheckNAdd ( 53 ) ; break ; case 53 : if ( ( 0x7e0000007eL & l ) == 0L ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAddTwoStates ( 53 , 9 ) ; break ; case 57 : if ( kind > 7 ) kind = 7 ; jjAddStates ( 18 , 20 ) ; break ; case 62 : jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 64 : case 65 : jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 68 : jjCheckNAddTwoStates ( 68 , 69 ) ; break ; case 70 : case 71 : jjCheckNAddTwoStates ( 71 , 69 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) { if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; } if ( jjCanMove_2 ( hiByte , i1 , i2 , l1 , l2 ) ) { if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; } break ; case 0 : if ( ! jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; break ; case 2 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 21 , 23 ) ; break ; case 17 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjstateSet [ jjnewStateCnt ++ ] = 18 ; break ; case 26 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 10 , 12 ) ; break ; case 34 : case 35 : if ( ! jjCanMove_2 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 57 : if ( ! jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 7 ) kind = 7 ; jjAddStates ( 18 , 20 ) ; break ; case 62 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 64 : case 65 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 68 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 68 , 69 ) ; break ; case 70 : case 71 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 71 , 69 ) ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 74 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } static final int [ ] jjnextStates = { 37 , 38 , 43 , 44 , 47 , 48 , 15 , 56 , 61 , 73 , 26 , 27 , 29 , 17 , 19 , 52 , 54 , 9 , 57 , 58 , 60 , 2 , 3 , 5 , 11 , 12 , 15 , 26 , 27 , 31 , 29 , 39 , 40 , 15 , 47 , 48 , 15 , 63 , 64 , 66 , 69 , 70 , 72 , 13 , 14 , 20 , 21 , 23 , 28 , 30 , 32 , 41 , 42 , 45 , 46 , 49 , 50 , } ; private static final boolean jjCanMove_0 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec0 [ i2 ] & l2 ) != 0L ) ; default : return false ; } } private static final boolean jjCanMove_1 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec0 [ i2 ] & l2 ) != 0L ) ; default : if ( ( jjbitVec1 [ i1 ] & l1 ) != 0L ) return true ; return false ; } } private static final boolean jjCanMove_2 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec4 [ i2 ] & l2 ) != 0L ) ; case 48 : return ( ( jjbitVec5 [ i2 ] & l2 ) != 0L ) ; case 49 : return ( ( jjbitVec6 [ i2 ] & l2 ) != 0L ) ; case 51 : return ( ( jjbitVec7 [ i2 ] & l2 ) != 0L ) ; case 61 : return ( ( jjbitVec8 [ i2 ] & l2 ) != 0L ) ; default : if ( ( jjbitVec3 [ i1 ] & l1 ) != 0L ) return true ; return false ; } } public static final String [ ] jjstrLiteralImages = { "" , null , null , null , null , null , null , null , null , null , "\142\157\157\154\145\141\156" , "\142\162\145\141\153" , "\143\154\141\163\163" , "\142\171\164\145" , "\143\141\163\145" , "\143\141\164\143\150" , "\143\150\141\162" , "\143\157\156\163\164" , "\143\157\156\164\151\156\165\145" , "\144\145\146\141\165\154\164" , "\144\157" , "\144\157\165\142\154\145" , "\145\154\163\145" , "\146\141\154\163\145" , "\146\151\156\141\154" , "\146\151\156\141\154\154\171" , "\146\154\157\141\164" , "\146\157\162" , "\147\157\164\157" , "\151\146" , "\151\155\160\157\162\164" , "\151\156\163\164\141\156\143\145\157\146" , "\151\156\164" , "\151\156\164\145\162\146\141\143\145" , "\154\157\156\147" , "\156\145\167" , "\156\165\154\154" , "\160\162\151\166\141\164\145" , "\160\162\157\164\145\143\164\145\144" , "\160\165\142\154\151\143" , "\162\145\164\165\162\156" , "\163\150\157\162\164" , "\163\164\141\164\151\143" , "\163\167\151\164\143\150" , "\164\150\162\157\167" , "\164\162\165\145" , "\164\162\171" , "\166\157\151\144" , "\167\150\151\154\145" , null , null , null , null , null , null , null , null , null , null , null , null , "\50" , "\51" , "\173" , "\175" , "\133" , "\135" , "\73" , "\54" , "\56" , "\75" , "\76" , "\100\147\164" , "\74" , "\100\154\164" , "\41" , "\176" , "\77" , "\72" , "\75\75" , "\74\75" , "\100\154\164\145\161" , "\76\75" , "\100\147\164\145\161" , "\41\75" , "\174\174" , "\100\157\162" , "\46\46" , "\100\141\156\144" , "\53\53" , "\55\55" , "\53" , "\55" , "\52" , "\57" , "\46" , "\100\142\151\164\167\151\163\145\137\141\156\144" , "\174" , "\100\142\151\164\167\151\163\145\137\157\162" , "\136" , "\45" , "\74\74" , "\100\154\145\146\164\137\163\150\151\146\164" , "\76\76" , "\100\162\151\147\150\164\137\163\150\151\146\164" , "\76\76\76" , "\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164" , "\53\75" , "\55\75" , "\52\75" , "\57\75" , "\46\75" , "\100\141\156\144\137\141\163\163\151\147\156" , "\174\75" , "\100\157\162\137\141\163\163\151\147\156" , "\136\75" , "\45\75" , "\74\74\75" , "\100\154\145\146\164\137\163\150\151\146\164\137\141\163\163\151\147\156" , "\76\76\75" , "\100\162\151\147\150\164\137\163\150\151\146\164\137\141\163\163\151\147\156" , "\76\76\76\75" , "\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164\137\141\163\163\151\147\156" , } ; public static final String [ ] lexStateNames = { "DEFAULT" , } ; static final long [ ] jjtoToken = { 0xe7a3fffffffffc01L , 0x7ffffffffffffffL , } ; static final long [ ] jjtoSkip = { 0x3feL , 0x0L , } ; static final long [ ] jjtoSpecial = { 0x380L , 0x0L , } ; private ASCII_UCodeESC_CharStream input_stream ; private final int [ ] jjrounds = new int [ 74 ] ; private final int [ ] jjstateSet = new int [ 148 ] ; protected char curChar ; public ParserTokenManager ( ASCII_UCodeESC_CharStream stream ) { if ( ASCII_UCodeESC_CharStream . staticFlag ) throw new Error ( "ERROR: Cannot use a static CharStream class with a non-static lexical analyzer." ) ; input_stream = stream ; } public ParserTokenManager ( ASCII_UCodeESC_CharStream stream , int lexState ) { this ( stream ) ; SwitchTo ( lexState ) ; } public void ReInit ( ASCII_UCodeESC_CharStream stream ) { jjmatchedPos = jjnewStateCnt = 0 ; curLexState = defaultLexState ; input_stream = stream ; ReInitRounds ( ) ; } private final void ReInitRounds ( ) { int i ; jjround = 0x80000001 ; for ( i = 74 ; i -- > 0 ; ) jjrounds [ i ] = 0x80000000 ; } public void ReInit ( ASCII_UCodeESC_CharStream stream , int lexState ) { ReInit ( stream ) ; SwitchTo ( lexState ) ; } public void SwitchTo ( int lexState ) { if ( lexState >= 1 || lexState < 0 ) throw new TokenMgrError ( "Error: Ignoring invalid lexical state : " + lexState + ". State unchanged." , TokenMgrError . INVALID_LEXICAL_STATE ) ; else curLexState = lexState ; } private final Token jjFillToken ( ) { Token t = Token . newToken ( jjmatchedKind ) ; t . kind = jjmatchedKind ; String im = jjstrLiteralImages [ jjmatchedKind ] ; t . image = ( im == null ) ? input_stream . GetImage ( ) : im ; t . beginLine = input_stream . getBeginLine ( ) ; t . beginColumn = input_stream . getBeginColumn ( ) ; t . endLine = input_stream . getEndLine ( ) ; t . endColumn = input_stream . getEndColumn ( ) ; return t ; } int curLexState = 0 ; int defaultLexState = 0 ; int jjnewStateCnt ; int jjround ; int jjmatchedPos ; int jjmatchedKind ; public final Token getNextToken ( ) { int kind ; Token specialToken = null ; Token matchedToken ; int curPos = 0 ; EOFLoop : for ( ; ; ) { try { curChar = input_stream . BeginToken ( ) ; } catch ( java . io . IOException e ) { jjmatchedKind = 0 ; matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_0 ( ) ; if ( jjmatchedKind != 0x7fffffff ) { if ( jjmatchedPos + 1 < curPos ) input_stream . backup ( curPos - jjmatchedPos - 1 ) ; if ( ( jjtoToken [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } else { if ( ( jjtoSpecial [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; if ( specialToken == null ) specialToken = matchedToken ; else { matchedToken . specialToken = specialToken ; specialToken = ( specialToken . next = matchedToken ) ; } } continue EOFLoop ; } } int error_line = input_stream . getEndLine ( ) ; int error_column = input_stream . getEndColumn ( ) ; String error_after = null ; boolean EOFSeen = false ; try { input_stream . readChar ( ) ; input_stream . backup ( 1 ) ; } catch ( java . io . IOException e1 ) { EOFSeen = true ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; if ( curChar == '\n' || curChar == '\r' ) { error_line ++ ; error_column = 0 ; } else error_column ++ ; } if ( ! EOFSeen ) { input_stream . backup ( 1 ) ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; } throw new TokenMgrError ( EOFSeen , curLexState , error_line , error_column , error_after , curChar , TokenMgrError . LEXICAL_ERROR ) ; } } } 	0	['50', '1', '0', '5', '66', '3', '1', '4', '6', '0.75170068', '6280', '0.166666667', '1', '0', '0.5', '0', '0', '124.12', '167', '8.76', '0']
package gnu . regexp ; import java . io . Serializable ; class CharIndexedStringBuffer implements CharIndexed , Serializable { private StringBuffer s ; private int anchor ; CharIndexedStringBuffer ( StringBuffer str , int index ) { s = str ; anchor = index ; } public char charAt ( int index ) { int pos = anchor + index ; return ( ( pos < s . length ( ) ) && ( pos >= 0 ) ) ? s . charAt ( pos ) : OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( anchor < s . length ( ) ) ; } public boolean move ( int index ) { return ( ( anchor += index ) < s . length ( ) ) ; } } 	0	['4', '1', '0', '2', '7', '0', '1', '1', '3', '0', '59', '1', '0', '0', '0.666666667', '0', '0', '13.25', '3', '1.75', '0']
package org . gjt . sp . jedit . syntax ; import java . awt . Font ; import java . awt . Color ; public class SyntaxStyle { public SyntaxStyle ( Color fgColor , Color bgColor , Font font ) { this . fgColor = fgColor ; this . bgColor = bgColor ; this . font = font ; } public Color getForegroundColor ( ) { return fgColor ; } public Color getBackgroundColor ( ) { return bgColor ; } public Font getFont ( ) { return font ; } private Color fgColor ; private Color bgColor ; private Font font ; } 	0	['4', '1', '0', '14', '5', '0', '14', '0', '4', '0.666666667', '28', '1', '0', '0', '0.5', '0', '0', '5.25', '1', '0.75', '0']
package org . gjt . sp . jedit ; import javax . swing . text . Position ; public class Marker { public char getShortcut ( ) { return shortcut ; } public int getPosition ( ) { return ( position == null ? pos : position . getOffset ( ) ) ; } Marker ( Buffer buffer , char shortcut , int position ) { this . buffer = buffer ; this . shortcut = shortcut ; this . pos = position ; } void setShortcut ( char shortcut ) { this . shortcut = shortcut ; } void createPosition ( ) { position = buffer . createPosition ( pos ) ; } void removePosition ( ) { if ( position != null ) { pos = position . getOffset ( ) ; position = null ; } } void setPosition ( int pos ) { this . pos = pos ; } private Buffer buffer ; private char shortcut ; private int pos ; private Position position ; } 	0	['7', '1', '0', '7', '10', '0', '7', '1', '2', '0.625', '64', '1', '1', '0', '0.428571429', '0', '0', '7.571428571', '2', '1.1429', '0']
package gnu . regexp ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . util . Locale ; import java . util . PropertyResourceBundle ; import java . util . ResourceBundle ; import java . util . Vector ; class IntPair implements Serializable { public int first , second ; } class CharUnit implements Serializable { public char ch ; public boolean bk ; } public class RE extends REToken { private static final String VERSION = "1.1.5-dev" ; private static ResourceBundle messages = PropertyResourceBundle . getBundle ( "gnu/regexp/MessagesBundle" , Locale . getDefault ( ) ) ; private REToken firstToken , lastToken ; private int numSubs ; private int minimumLength ; public static final int REG_ICASE = 2 ; public static final int REG_DOT_NEWLINE = 4 ; public static final int REG_MULTILINE = 8 ; public static final int REG_NOTBOL = 16 ; public static final int REG_NOTEOL = 32 ; public static final int REG_ANCHORINDEX = 64 ; public static final int REG_NO_INTERPOLATE = 128 ; public static final String version ( ) { return VERSION ; } static final String getLocalizedMessage ( String key ) { return messages . getString ( key ) ; } public RE ( Object pattern ) throws REException { this ( pattern , 0 , RESyntax . RE_SYNTAX_PERL5 , 0 , 0 ) ; } public RE ( Object pattern , int cflags ) throws REException { this ( pattern , cflags , RESyntax . RE_SYNTAX_PERL5 , 0 , 0 ) ; } public RE ( Object pattern , int cflags , RESyntax syntax ) throws REException { this ( pattern , cflags , syntax , 0 , 0 ) ; } private RE ( REToken first , REToken last , int subs , int subIndex , int minLength ) { super ( subIndex ) ; firstToken = first ; lastToken = last ; numSubs = subs ; minimumLength = minLength ; addToken ( new RETokenEndSub ( subIndex ) ) ; } private RE ( Object patternObj , int cflags , RESyntax syntax , int myIndex , int nextSub ) throws REException { super ( myIndex ) ; initialize ( patternObj , cflags , syntax , myIndex , nextSub ) ; } protected RE ( ) { super ( 0 ) ; } protected void initialize ( Object patternObj , int cflags , RESyntax syntax , int myIndex , int nextSub ) throws REException { char [ ] pattern ; if ( patternObj instanceof String ) { pattern = ( ( String ) patternObj ) . toCharArray ( ) ; } else if ( patternObj instanceof char [ ] ) { pattern = ( char [ ] ) patternObj ; } else if ( patternObj instanceof StringBuffer ) { pattern = new char [ ( ( StringBuffer ) patternObj ) . length ( ) ] ; ( ( StringBuffer ) patternObj ) . getChars ( 0 , pattern . length , pattern , 0 ) ; } else { pattern = patternObj . toString ( ) . toCharArray ( ) ; } int pLength = pattern . length ; numSubs = 0 ; Vector branches = null ; firstToken = lastToken = null ; boolean insens = ( ( cflags & REG_ICASE ) > 0 ) ; int index = 0 ; CharUnit unit = new CharUnit ( ) ; IntPair minMax = new IntPair ( ) ; REToken currentToken = null ; char ch ; while ( index < pLength ) { index = getCharUnit ( pattern , index , unit ) ; if ( ( ( unit . ch == '|' && ( syntax . get ( RESyntax . RE_NO_BK_VBAR ) ^ unit . bk ) ) || ( syntax . get ( RESyntax . RE_NEWLINE_ALT ) && ( unit . ch == '\n' ) && ! unit . bk ) ) && ! syntax . get ( RESyntax . RE_LIMITED_OPS ) ) { addToken ( currentToken ) ; RE theBranch = new RE ( firstToken , lastToken , numSubs , subIndex , minimumLength ) ; minimumLength = 0 ; if ( branches == null ) { branches = new Vector ( ) ; } branches . addElement ( theBranch ) ; firstToken = lastToken = currentToken = null ; } else if ( ( unit . ch == '{' ) && syntax . get ( RESyntax . RE_INTERVALS ) && ( syntax . get ( RESyntax . RE_NO_BK_BRACES ) ^ unit . bk ) ) { int newIndex = getMinMax ( pattern , index , minMax , syntax ) ; if ( newIndex > index ) { if ( minMax . first > minMax . second ) throw new REException ( getLocalizedMessage ( "interval.order" ) , REException . REG_BADRPT , newIndex ) ; if ( currentToken == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , newIndex ) ; if ( currentToken instanceof RETokenRepeated ) throw new REException ( getLocalizedMessage ( "repeat.chained" ) , REException . REG_BADRPT , newIndex ) ; if ( currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary ) throw new REException ( getLocalizedMessage ( "repeat.assertion" ) , REException . REG_BADRPT , newIndex ) ; if ( ( currentToken . getMinimumLength ( ) == 0 ) && ( minMax . second == Integer . MAX_VALUE ) ) throw new REException ( getLocalizedMessage ( "repeat.empty.token" ) , REException . REG_BADRPT , newIndex ) ; index = newIndex ; currentToken = setRepeated ( currentToken , minMax . first , minMax . second , index ) ; } else { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , unit . ch , insens ) ; } } else if ( ( unit . ch == '[' ) && ! unit . bk ) { Vector options = new Vector ( ) ; boolean negative = false ; char lastChar = 0 ; if ( index == pLength ) throw new REException ( getLocalizedMessage ( "unmatched.bracket" ) , REException . REG_EBRACK , index ) ; if ( ( ch = pattern [ index ] ) == '^' ) { negative = true ; if ( ++ index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; ch = pattern [ index ] ; } if ( ch == ']' ) { lastChar = ch ; if ( ++ index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; } while ( ( ch = pattern [ index ++ ] ) != ']' ) { if ( ( ch == '-' ) && ( lastChar != 0 ) ) { if ( index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; if ( ( ch = pattern [ index ] ) == ']' ) { options . addElement ( new RETokenChar ( subIndex , lastChar , insens ) ) ; lastChar = '-' ; } else { options . addElement ( new RETokenRange ( subIndex , lastChar , ch , insens ) ) ; lastChar = 0 ; index ++ ; } } else if ( ( ch == '\\' ) && syntax . get ( RESyntax . RE_BACKSLASH_ESCAPE_IN_LISTS ) ) { if ( index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; int posixID = - 1 ; boolean negate = false ; char asciiEsc = 0 ; if ( ( "dswDSW" . indexOf ( pattern [ index ] ) != - 1 ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESC_IN_LISTS ) ) { switch ( pattern [ index ] ) { case 'D' : negate = true ; case 'd' : posixID = RETokenPOSIX . DIGIT ; break ; case 'S' : negate = true ; case 's' : posixID = RETokenPOSIX . SPACE ; break ; case 'W' : negate = true ; case 'w' : posixID = RETokenPOSIX . ALNUM ; break ; } } else if ( "nrt" . indexOf ( pattern [ index ] ) != - 1 ) { switch ( pattern [ index ] ) { case 'n' : asciiEsc = '\n' ; break ; case 't' : asciiEsc = '\t' ; break ; case 'r' : asciiEsc = '\r' ; break ; } } if ( lastChar != 0 ) options . addElement ( new RETokenChar ( subIndex , lastChar , insens ) ) ; if ( posixID != - 1 ) { options . addElement ( new RETokenPOSIX ( subIndex , posixID , insens , negate ) ) ; } else if ( asciiEsc != 0 ) { lastChar = asciiEsc ; } else { lastChar = pattern [ index ] ; } ++ index ; } else if ( ( ch == '[' ) && ( syntax . get ( RESyntax . RE_CHAR_CLASSES ) ) && ( index < pLength ) && ( pattern [ index ] == ':' ) ) { StringBuffer posixSet = new StringBuffer ( ) ; index = getPosixSet ( pattern , index + 1 , posixSet ) ; int posixId = RETokenPOSIX . intValue ( posixSet . toString ( ) ) ; if ( posixId != - 1 ) options . addElement ( new RETokenPOSIX ( subIndex , posixId , insens , false ) ) ; } else { if ( lastChar != 0 ) options . addElement ( new RETokenChar ( subIndex , lastChar , insens ) ) ; lastChar = ch ; } if ( index == pLength ) throw new REException ( getLocalizedMessage ( "class.no.end" ) , REException . REG_EBRACK , index ) ; } if ( lastChar != 0 ) options . addElement ( new RETokenChar ( subIndex , lastChar , insens ) ) ; addToken ( currentToken ) ; options . trimToSize ( ) ; currentToken = new RETokenOneOf ( subIndex , options , negative ) ; } else if ( ( unit . ch == '(' ) && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) { boolean pure = false ; boolean comment = false ; boolean lookAhead = false ; boolean negativelh = false ; if ( ( index + 1 < pLength ) && ( pattern [ index ] == '?' ) ) { switch ( pattern [ index + 1 ] ) { case '!' : if ( syntax . get ( RESyntax . RE_LOOKAHEAD ) ) { pure = true ; negativelh = true ; lookAhead = true ; index += 2 ; } break ; case '=' : if ( syntax . get ( RESyntax . RE_LOOKAHEAD ) ) { pure = true ; lookAhead = true ; index += 2 ; } break ; case ':' : if ( syntax . get ( RESyntax . RE_PURE_GROUPING ) ) { pure = true ; index += 2 ; } break ; case '#' : if ( syntax . get ( RESyntax . RE_COMMENTS ) ) { comment = true ; } break ; default : throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; } } if ( index >= pLength ) { throw new REException ( getLocalizedMessage ( "unmatched.paren" ) , REException . REG_ESUBREG , index ) ; } int endIndex = index ; int nextIndex = index ; int nested = 0 ; while ( ( ( nextIndex = getCharUnit ( pattern , endIndex , unit ) ) > 0 ) && ! ( nested == 0 && ( unit . ch == ')' ) && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) ) if ( ( endIndex = nextIndex ) >= pLength ) throw new REException ( getLocalizedMessage ( "subexpr.no.end" ) , REException . REG_ESUBREG , nextIndex ) ; else if ( unit . ch == '(' && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) nested ++ ; else if ( unit . ch == ')' && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) nested -- ; if ( comment ) index = nextIndex ; else { addToken ( currentToken ) ; if ( ! pure ) { numSubs ++ ; } int useIndex = ( pure || lookAhead ) ? 0 : nextSub + numSubs ; currentToken = new RE ( String . valueOf ( pattern , index , endIndex - index ) . toCharArray ( ) , cflags , syntax , useIndex , nextSub + numSubs ) ; numSubs += ( ( RE ) currentToken ) . getNumSubs ( ) ; if ( lookAhead ) { currentToken = new RETokenLookAhead ( currentToken , negativelh ) ; } index = nextIndex ; } } else if ( ! syntax . get ( RESyntax . RE_UNMATCHED_RIGHT_PAREN_ORD ) && ( ( unit . ch == ')' ) && ( syntax . get ( RESyntax . RE_NO_BK_PARENS ) ^ unit . bk ) ) ) { throw new REException ( getLocalizedMessage ( "unmatched.paren" ) , REException . REG_EPAREN , index ) ; } else if ( ( unit . ch == '^' ) && ! unit . bk ) { addToken ( currentToken ) ; currentToken = null ; addToken ( new RETokenStart ( subIndex , ( ( cflags & REG_MULTILINE ) > 0 ) ? syntax . getLineSeparator ( ) : null ) ) ; } else if ( ( unit . ch == '$' ) && ! unit . bk ) { addToken ( currentToken ) ; currentToken = null ; addToken ( new RETokenEnd ( subIndex , ( ( cflags & REG_MULTILINE ) > 0 ) ? syntax . getLineSeparator ( ) : null ) ) ; } else if ( ( unit . ch == '.' ) && ! unit . bk ) { addToken ( currentToken ) ; currentToken = new RETokenAny ( subIndex , syntax . get ( RESyntax . RE_DOT_NEWLINE ) || ( ( cflags & REG_DOT_NEWLINE ) > 0 ) , syntax . get ( RESyntax . RE_DOT_NOT_NULL ) ) ; } else if ( ( unit . ch == '*' ) && ! unit . bk ) { if ( currentToken == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenRepeated ) throw new REException ( getLocalizedMessage ( "repeat.chained" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary ) throw new REException ( getLocalizedMessage ( "repeat.assertion" ) , REException . REG_BADRPT , index ) ; if ( currentToken . getMinimumLength ( ) == 0 ) throw new REException ( getLocalizedMessage ( "repeat.empty.token" ) , REException . REG_BADRPT , index ) ; currentToken = setRepeated ( currentToken , 0 , Integer . MAX_VALUE , index ) ; } else if ( ( unit . ch == '+' ) && ! syntax . get ( RESyntax . RE_LIMITED_OPS ) && ( ! syntax . get ( RESyntax . RE_BK_PLUS_QM ) ^ unit . bk ) ) { if ( currentToken == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenRepeated ) throw new REException ( getLocalizedMessage ( "repeat.chained" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary ) throw new REException ( getLocalizedMessage ( "repeat.assertion" ) , REException . REG_BADRPT , index ) ; if ( currentToken . getMinimumLength ( ) == 0 ) throw new REException ( getLocalizedMessage ( "repeat.empty.token" ) , REException . REG_BADRPT , index ) ; currentToken = setRepeated ( currentToken , 1 , Integer . MAX_VALUE , index ) ; } else if ( ( unit . ch == '?' ) && ! syntax . get ( RESyntax . RE_LIMITED_OPS ) && ( ! syntax . get ( RESyntax . RE_BK_PLUS_QM ) ^ unit . bk ) ) { if ( currentToken == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; if ( currentToken instanceof RETokenRepeated ) { if ( syntax . get ( RESyntax . RE_STINGY_OPS ) && ! ( ( RETokenRepeated ) currentToken ) . isStingy ( ) ) ( ( RETokenRepeated ) currentToken ) . makeStingy ( ) ; else throw new REException ( getLocalizedMessage ( "repeat.chained" ) , REException . REG_BADRPT , index ) ; } else if ( currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary ) throw new REException ( getLocalizedMessage ( "repeat.assertion" ) , REException . REG_BADRPT , index ) ; else currentToken = setRepeated ( currentToken , 0 , 1 , index ) ; } else if ( unit . bk && Character . isDigit ( unit . ch ) && ! syntax . get ( RESyntax . RE_NO_BK_REFS ) ) { addToken ( currentToken ) ; currentToken = new RETokenBackRef ( subIndex , Character . digit ( unit . ch , 10 ) , insens ) ; } else if ( unit . bk && ( unit . ch == 'A' ) && syntax . get ( RESyntax . RE_STRING_ANCHORS ) ) { addToken ( currentToken ) ; currentToken = new RETokenStart ( subIndex , null ) ; } else if ( unit . bk && ( unit . ch == 'b' ) && syntax . get ( RESyntax . RE_STRING_ANCHORS ) ) { addToken ( currentToken ) ; currentToken = new RETokenWordBoundary ( subIndex , RETokenWordBoundary . BEGIN | RETokenWordBoundary . END , false ) ; } else if ( unit . bk && ( unit . ch == '<' ) ) { addToken ( currentToken ) ; currentToken = new RETokenWordBoundary ( subIndex , RETokenWordBoundary . BEGIN , false ) ; } else if ( unit . bk && ( unit . ch == '>' ) ) { addToken ( currentToken ) ; currentToken = new RETokenWordBoundary ( subIndex , RETokenWordBoundary . END , false ) ; } else if ( unit . bk && ( unit . ch == 'B' ) && syntax . get ( RESyntax . RE_STRING_ANCHORS ) ) { addToken ( currentToken ) ; currentToken = new RETokenWordBoundary ( subIndex , RETokenWordBoundary . BEGIN | RETokenWordBoundary . END , true ) ; } else if ( unit . bk && ( unit . ch == 'd' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . DIGIT , insens , false ) ; } else if ( unit . bk && ( unit . ch == 'D' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . DIGIT , insens , true ) ; } else if ( unit . bk && ( unit . ch == 'n' ) ) { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , '\n' , false ) ; } else if ( unit . bk && ( unit . ch == 'r' ) ) { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , '\r' , false ) ; } else if ( unit . bk && ( unit . ch == 's' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . SPACE , insens , false ) ; } else if ( unit . bk && ( unit . ch == 'S' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . SPACE , insens , true ) ; } else if ( unit . bk && ( unit . ch == 't' ) ) { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , '\t' , false ) ; } else if ( unit . bk && ( unit . ch == 'w' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . ALNUM , insens , false ) ; } else if ( unit . bk && ( unit . ch == 'W' ) && syntax . get ( RESyntax . RE_CHAR_CLASS_ESCAPES ) ) { addToken ( currentToken ) ; currentToken = new RETokenPOSIX ( subIndex , RETokenPOSIX . ALNUM , insens , true ) ; } else if ( unit . bk && ( unit . ch == 'Z' ) && syntax . get ( RESyntax . RE_STRING_ANCHORS ) ) { addToken ( currentToken ) ; currentToken = new RETokenEnd ( subIndex , null ) ; } else { addToken ( currentToken ) ; currentToken = new RETokenChar ( subIndex , unit . ch , insens ) ; } } addToken ( currentToken ) ; if ( branches != null ) { branches . addElement ( new RE ( firstToken , lastToken , numSubs , subIndex , minimumLength ) ) ; branches . trimToSize ( ) ; minimumLength = 0 ; firstToken = lastToken = null ; addToken ( new RETokenOneOf ( subIndex , branches , false ) ) ; } else addToken ( new RETokenEndSub ( subIndex ) ) ; } private static int getCharUnit ( char [ ] input , int index , CharUnit unit ) throws REException { unit . ch = input [ index ++ ] ; if ( unit . bk = ( unit . ch == '\\' ) ) if ( index < input . length ) unit . ch = input [ index ++ ] ; else throw new REException ( getLocalizedMessage ( "ends.with.backslash" ) , REException . REG_ESCAPE , index ) ; return index ; } public boolean isMatch ( Object input ) { return isMatch ( input , 0 , 0 ) ; } public boolean isMatch ( Object input , int index ) { return isMatch ( input , index , 0 ) ; } public boolean isMatch ( Object input , int index , int eflags ) { return isMatchImpl ( makeCharIndexed ( input , index ) , index , eflags ) ; } private boolean isMatchImpl ( CharIndexed input , int index , int eflags ) { if ( firstToken == null ) return ( input . charAt ( 0 ) == CharIndexed . OUT_OF_BOUNDS ) ; REMatch m = new REMatch ( numSubs , index , eflags ) ; if ( firstToken . match ( input , m ) ) { while ( m != null ) { if ( input . charAt ( m . index ) == CharIndexed . OUT_OF_BOUNDS ) { return true ; } m = m . next ; } } return false ; } public int getNumSubs ( ) { return numSubs ; } void setUncle ( REToken uncle ) { if ( lastToken != null ) { lastToken . setUncle ( uncle ) ; } else super . setUncle ( uncle ) ; } boolean chain ( REToken next ) { super . chain ( next ) ; setUncle ( next ) ; return true ; } public int getMinimumLength ( ) { return minimumLength ; } public REMatch [ ] getAllMatches ( Object input ) { return getAllMatches ( input , 0 , 0 ) ; } public REMatch [ ] getAllMatches ( Object input , int index ) { return getAllMatches ( input , index , 0 ) ; } public REMatch [ ] getAllMatches ( Object input , int index , int eflags ) { return getAllMatchesImpl ( makeCharIndexed ( input , index ) , index , eflags ) ; } private REMatch [ ] getAllMatchesImpl ( CharIndexed input , int index , int eflags ) { Vector all = new Vector ( ) ; REMatch m = null ; while ( ( m = getMatchImpl ( input , index , eflags , null ) ) != null ) { all . addElement ( m ) ; index = m . getEndIndex ( ) ; if ( m . end [ 0 ] == 0 ) { index ++ ; input . move ( 1 ) ; } else { input . move ( m . end [ 0 ] ) ; } if ( ! input . isValid ( ) ) break ; } REMatch [ ] mset = new REMatch [ all . size ( ) ] ; all . copyInto ( mset ) ; return mset ; } boolean match ( CharIndexed input , REMatch mymatch ) { if ( firstToken == null ) return next ( input , mymatch ) ; mymatch . start [ subIndex ] = mymatch . index ; return firstToken . match ( input , mymatch ) ; } public REMatch getMatch ( Object input ) { return getMatch ( input , 0 , 0 ) ; } public REMatch getMatch ( Object input , int index ) { return getMatch ( input , index , 0 ) ; } public REMatch getMatch ( Object input , int index , int eflags ) { return getMatch ( input , index , eflags , null ) ; } public REMatch getMatch ( Object input , int index , int eflags , StringBuffer buffer ) { return getMatchImpl ( makeCharIndexed ( input , index ) , index , eflags , buffer ) ; } REMatch getMatchImpl ( CharIndexed input , int anchor , int eflags , StringBuffer buffer ) { REMatch mymatch = new REMatch ( numSubs , anchor , eflags ) ; do { if ( minimumLength == 0 || input . charAt ( minimumLength - 1 ) != CharIndexed . OUT_OF_BOUNDS ) { if ( match ( input , mymatch ) ) { REMatch longest = mymatch ; while ( ( mymatch = mymatch . next ) != null ) { if ( mymatch . index > longest . index ) { longest = mymatch ; } } longest . end [ 0 ] = longest . index ; longest . finish ( input ) ; return longest ; } } mymatch . clear ( ++ anchor ) ; if ( buffer != null && input . charAt ( 0 ) != CharIndexed . OUT_OF_BOUNDS ) { buffer . append ( input . charAt ( 0 ) ) ; } } while ( input . move ( 1 ) ) ; if ( minimumLength == 0 ) { if ( match ( input , mymatch ) ) { mymatch . finish ( input ) ; return mymatch ; } } return null ; } public REMatchEnumeration getMatchEnumeration ( Object input ) { return getMatchEnumeration ( input , 0 , 0 ) ; } public REMatchEnumeration getMatchEnumeration ( Object input , int index ) { return getMatchEnumeration ( input , index , 0 ) ; } public REMatchEnumeration getMatchEnumeration ( Object input , int index , int eflags ) { return new REMatchEnumeration ( this , makeCharIndexed ( input , index ) , index , eflags ) ; } public String substitute ( Object input , String replace ) { return substitute ( input , replace , 0 , 0 ) ; } public String substitute ( Object input , String replace , int index ) { return substitute ( input , replace , index , 0 ) ; } public String substitute ( Object input , String replace , int index , int eflags ) { return substituteImpl ( makeCharIndexed ( input , index ) , replace , index , eflags ) ; } private String substituteImpl ( CharIndexed input , String replace , int index , int eflags ) { StringBuffer buffer = new StringBuffer ( ) ; REMatch m = getMatchImpl ( input , index , eflags , buffer ) ; if ( m == null ) return buffer . toString ( ) ; buffer . append ( ( ( eflags & REG_NO_INTERPOLATE ) > 0 ) ? replace : m . substituteInto ( replace ) ) ; if ( input . move ( m . end [ 0 ] ) ) { do { buffer . append ( input . charAt ( 0 ) ) ; } while ( input . move ( 1 ) ) ; } return buffer . toString ( ) ; } public String substituteAll ( Object input , String replace ) { return substituteAll ( input , replace , 0 , 0 ) ; } public String substituteAll ( Object input , String replace , int index ) { return substituteAll ( input , replace , index , 0 ) ; } public String substituteAll ( Object input , String replace , int index , int eflags ) { return substituteAllImpl ( makeCharIndexed ( input , index ) , replace , index , eflags ) ; } private String substituteAllImpl ( CharIndexed input , String replace , int index , int eflags ) { StringBuffer buffer = new StringBuffer ( ) ; REMatch m ; while ( ( m = getMatchImpl ( input , index , eflags , buffer ) ) != null ) { buffer . append ( ( ( eflags & REG_NO_INTERPOLATE ) > 0 ) ? replace : m . substituteInto ( replace ) ) ; index = m . getEndIndex ( ) ; if ( m . end [ 0 ] == 0 ) { char ch = input . charAt ( 0 ) ; if ( ch != CharIndexed . OUT_OF_BOUNDS ) buffer . append ( ch ) ; input . move ( 1 ) ; } else { input . move ( m . end [ 0 ] ) ; } if ( ! input . isValid ( ) ) break ; } return buffer . toString ( ) ; } private void addToken ( REToken next ) { if ( next == null ) return ; minimumLength += next . getMinimumLength ( ) ; if ( firstToken == null ) { lastToken = firstToken = next ; } else { if ( lastToken . chain ( next ) ) { lastToken = next ; } } } private static REToken setRepeated ( REToken current , int min , int max , int index ) throws REException { if ( current == null ) throw new REException ( getLocalizedMessage ( "repeat.no.token" ) , REException . REG_BADRPT , index ) ; return new RETokenRepeated ( current . subIndex , current , min , max ) ; } private static int getPosixSet ( char [ ] pattern , int index , StringBuffer buf ) { int i ; for ( i = index ; i < ( pattern . length - 1 ) ; i ++ ) { if ( ( pattern [ i ] == ':' ) && ( pattern [ i + 1 ] == ']' ) ) return i + 2 ; buf . append ( pattern [ i ] ) ; } return index ; } private int getMinMax ( char [ ] input , int index , IntPair minMax , RESyntax syntax ) throws REException { boolean mustMatch = ! syntax . get ( RESyntax . RE_NO_BK_BRACES ) ; int startIndex = index ; if ( index == input . length ) { if ( mustMatch ) throw new REException ( getLocalizedMessage ( "unmatched.brace" ) , REException . REG_EBRACE , index ) ; else return startIndex ; } int min , max = 0 ; CharUnit unit = new CharUnit ( ) ; StringBuffer buf = new StringBuffer ( ) ; do { index = getCharUnit ( input , index , unit ) ; if ( Character . isDigit ( unit . ch ) ) buf . append ( unit . ch ) ; } while ( ( index != input . length ) && Character . isDigit ( unit . ch ) ) ; if ( buf . length ( ) == 0 ) { if ( mustMatch ) throw new REException ( getLocalizedMessage ( "interval.error" ) , REException . REG_EBRACE , index ) ; else return startIndex ; } min = Integer . parseInt ( buf . toString ( ) ) ; if ( ( unit . ch == '}' ) && ( syntax . get ( RESyntax . RE_NO_BK_BRACES ) ^ unit . bk ) ) max = min ; else if ( index == input . length ) if ( mustMatch ) throw new REException ( getLocalizedMessage ( "interval.no.end" ) , REException . REG_EBRACE , index ) ; else return startIndex ; else if ( ( unit . ch == ',' ) && ! unit . bk ) { buf = new StringBuffer ( ) ; while ( ( ( index = getCharUnit ( input , index , unit ) ) != input . length ) && Character . isDigit ( unit . ch ) ) buf . append ( unit . ch ) ; if ( ! ( ( unit . ch == '}' ) && ( syntax . get ( RESyntax . RE_NO_BK_BRACES ) ^ unit . bk ) ) ) if ( mustMatch ) throw new REException ( getLocalizedMessage ( "interval.error" ) , REException . REG_EBRACE , index ) ; else return startIndex ; if ( buf . length ( ) == 0 ) max = Integer . MAX_VALUE ; else max = Integer . parseInt ( buf . toString ( ) ) ; } else if ( mustMatch ) throw new REException ( getLocalizedMessage ( "interval.error" ) , REException . REG_EBRACE , index ) ; else return startIndex ; minMax . first = min ; minMax . second = max ; return index ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; dump ( sb ) ; return sb . toString ( ) ; } void dump ( StringBuffer os ) { os . append ( '(' ) ; if ( subIndex == 0 ) os . append ( "?:" ) ; if ( firstToken != null ) firstToken . dumpAll ( os ) ; os . append ( ')' ) ; } private static CharIndexed makeCharIndexed ( Object input , int index ) { if ( input instanceof String ) return new CharIndexedString ( ( String ) input , index ) ; else if ( input instanceof char [ ] ) return new CharIndexedCharArray ( ( char [ ] ) input , index ) ; else if ( input instanceof StringBuffer ) return new CharIndexedStringBuffer ( ( StringBuffer ) input , index ) ; else if ( input instanceof InputStream ) return new CharIndexedInputStream ( ( InputStream ) input , index ) ; else if ( input instanceof Reader ) return new CharIndexedReader ( ( Reader ) input , index ) ; else if ( input instanceof CharIndexed ) return ( CharIndexed ) input ; else return new CharIndexedString ( input . toString ( ) , index ) ; } } 	0	['47', '2', '1', '41', '109', '1019', '19', '25', '26', '0.946488294', '2549', '0.461538462', '2', '0.14893617', '0.230072464', '1', '2', '52.95744681', '11', '1.766', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class EditorExiting extends EBMessage { public EditorExiting ( EBComponent source ) { super ( source ) ; } } 	0	['1', '2', '0', '3', '2', '0', '1', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package bsh ; import java . lang . reflect . Array ; class BSHArrayInitializer extends SimpleNode { BSHArrayInitializer ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { throw new EvalError ( "Array initializer has no base type." ) ; } public Object eval ( Class baseType , int dimensions , CallStack callstack , Interpreter interpreter ) throws EvalError { int numInitializers = jjtGetNumChildren ( ) ; int [ ] dima = new int [ dimensions ] ; dima [ 0 ] = numInitializers ; Object initializers = Array . newInstance ( baseType , dima ) ; for ( int i = 0 ; i < numInitializers ; i ++ ) { SimpleNode node = ( SimpleNode ) jjtGetChild ( i ) ; Object currentInitializer ; if ( node instanceof BSHArrayInitializer ) { if ( dimensions < 2 ) throw new EvalError ( "Invalid Location for Intializer, position: " + i , this ) ; currentInitializer = ( ( BSHArrayInitializer ) node ) . eval ( baseType , dimensions - 1 , callstack , interpreter ) ; } else currentInitializer = node . eval ( callstack , interpreter ) ; if ( currentInitializer == Primitive . VOID ) throw new EvalError ( "Void in array initializer, position" + i , this ) ; Object value ; if ( currentInitializer instanceof Primitive ) value = ( ( Primitive ) currentInitializer ) . getValue ( ) ; else value = currentInitializer ; try { Array . set ( initializers , i , value ) ; } catch ( IllegalArgumentException e ) { Interpreter . debug ( "illegal arg" + e ) ; throwTypeError ( baseType , currentInitializer , i ) ; } catch ( ArrayStoreException e ) { Interpreter . debug ( "arraystore" + e ) ; throwTypeError ( baseType , currentInitializer , i ) ; } } return initializers ; } private void throwTypeError ( Class baseType , Object initializer , int argNum ) throws EvalError { String lhsType = Reflect . normalizeClassName ( baseType ) ; String rhsType ; if ( initializer instanceof Primitive ) rhsType = ( ( Primitive ) initializer ) . getType ( ) . getName ( ) ; else rhsType = Reflect . normalizeClassName ( initializer . getClass ( ) ) ; throw new EvalError ( "Incompatible type: " + rhsType + " in initializer of array type: " + baseType + " at position: " + argNum , this ) ; } } 	0	['4', '2', '0', '10', '23', '6', '3', '7', '2', '2', '176', '0', '0', '0.857142857', '0.583333333', '1', '1', '43', '1', '0.75', '0']
package org . gjt . sp . jedit . gui ; import java . awt . * ; import java . awt . event . * ; import javax . swing . * ; import javax . swing . border . * ; public class RolloverButton extends JButton { public RolloverButton ( ) { setBorder ( new EtchedBorder ( ) ) ; setBorderPainted ( false ) ; setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; setRequestFocusEnabled ( false ) ; addMouseListener ( new MouseOverHandler ( ) ) ; } public RolloverButton ( Icon icon ) { this ( ) ; setIcon ( icon ) ; } public boolean isOpaque ( ) { return false ; } public void setEnabled ( boolean b ) { super . setEnabled ( b ) ; setBorderPainted ( false ) ; repaint ( ) ; } public void paint ( Graphics g ) { if ( isEnabled ( ) ) super . paint ( g ) ; else { Graphics2D g2 = ( Graphics2D ) g ; g2 . setComposite ( c ) ; super . paint ( g2 ) ; } } private static AlphaComposite c = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 0.5f ) ; class MouseOverHandler extends MouseAdapter { public void mouseEntered ( MouseEvent e ) { if ( isEnabled ( ) ) setBorderPainted ( true ) ; } public void mouseExited ( MouseEvent e ) { setBorderPainted ( false ) ; } } } 	0	['6', '6', '1', '11', '22', '13', '11', '1', '5', '0.8', '75', '1', '0', '0.996078431', '0.4', '3', '12', '11.33333333', '2', '0.6667', '0']
package org . gjt . sp . jedit . pluginmgr ; import com . microstar . xml . * ; import java . io . * ; import java . util . Stack ; import org . gjt . sp . util . Log ; class PluginListHandler extends HandlerBase { PluginListHandler ( PluginList pluginList , String path ) { this . pluginList = pluginList ; this . path = path ; stateStack = new Stack ( ) ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "plugins.dtd" . equals ( systemId ) ) { return new StringReader ( "<!-- -->" ) ; } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { aname = ( aname == null ) ? null : aname . intern ( ) ; value = ( value == null ) ? null : value . intern ( ) ; if ( aname == "NAME" ) name = value ; else if ( aname == "JAR" ) jar = value ; else if ( aname == "VERSION" ) version = value ; else if ( aname == "DATE" ) date = value ; else if ( aname == "OBSOLETE" ) obsolete = ( "TRUE" . equals ( value ) ) ; else if ( aname == "WHAT" ) depWhat = value ; else if ( aname == "FROM" ) depFrom = value ; else if ( aname == "TO" ) depTo = value ; else if ( aname == "PLUGIN" ) depPlugin = value ; else if ( aname == "SIZE" ) { size = Integer . parseInt ( value ) ; if ( size == 0 ) Log . log ( Log . WARNING , this , "SIZE = 0" ) ; } } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "PLUGINS" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , path + ": DOCTYPE must be PLUGINS" ) ; } public void charData ( char [ ] c , int off , int len ) { String tag = peekElement ( ) ; String text = new String ( c , off , len ) ; if ( tag == "DESCRIPTION" ) { description = text ; } else if ( tag == "PLUGIN_SET_ENTRY" ) pluginSetEntry = text ; else if ( tag == "AUTHOR" ) { if ( author != null && author . length ( ) != 0 ) author = author + ", " + text ; else author = text ; } else if ( tag == "DOWNLOAD" ) download = text ; else if ( tag == "DOWNLOAD_SOURCE" ) downloadSource = text ; } public void startElement ( String tag ) { tag = pushElement ( tag ) ; if ( tag == "PLUGIN_SET" ) { description = null ; pluginSet = new PluginList . PluginSet ( ) ; pluginSet . name = name ; } else if ( tag == "PLUGIN" ) { description = null ; author = null ; branch = null ; plugin = new PluginList . Plugin ( ) ; } else if ( tag == "BRANCH" ) { download = null ; branch = new PluginList . Branch ( ) ; } else if ( tag == "DOWNLOAD" ) downloadSize = size ; else if ( tag == "DOWNLOAD_SOURCE" ) downloadSourceSize = size ; } public void endElement ( String tag ) { if ( tag == null ) return ; else tag = tag . intern ( ) ; popElement ( ) ; if ( tag == "PLUGIN_SET" ) { pluginList . addPluginSet ( pluginSet ) ; pluginSet = null ; pluginSetEntry = null ; } else if ( tag == "PLUGIN_SET_ENTRY" ) { pluginSet . plugins . addElement ( pluginSetEntry ) ; pluginSetEntry = null ; } else if ( tag == "PLUGIN" ) { plugin . jar = jar ; plugin . name = name ; plugin . author = author ; plugin . description = description ; pluginList . addPlugin ( plugin ) ; jar = null ; name = null ; author = null ; } else if ( tag == "BRANCH" ) { branch . version = version ; branch . date = date ; branch . download = download ; branch . downloadSize = downloadSize ; branch . downloadSource = downloadSource ; branch . downloadSourceSize = downloadSourceSize ; branch . obsolete = obsolete ; plugin . branches . addElement ( branch ) ; version = null ; download = null ; obsolete = false ; } else if ( tag == "DEPEND" ) { PluginList . Dependency dep = new PluginList . Dependency ( depWhat , depFrom , depTo , depPlugin ) ; branch . deps . addElement ( dep ) ; depWhat = null ; depFrom = null ; depTo = null ; depPlugin = null ; } } public void startDocument ( ) { try { pushElement ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void endDocument ( ) { pluginList . finished ( ) ; } private String path ; private PluginList pluginList ; private PluginList . PluginSet pluginSet ; private String pluginSetEntry ; private PluginList . Plugin plugin ; private String jar ; private String author ; private PluginList . Branch branch ; private boolean obsolete ; private String version ; private String date ; private String download ; private int downloadSize ; private String downloadSource ; private int downloadSourceSize ; private int size ; private String depWhat ; private String depFrom ; private String depTo ; private String depPlugin ; private String name ; private String description ; private Stack stateStack ; private String pushElement ( String name ) { name = ( name == null ) ? null : name . intern ( ) ; stateStack . push ( name ) ; return name ; } private String peekElement ( ) { return ( String ) stateStack . peek ( ) ; } private String popElement ( ) { return ( String ) stateStack . pop ( ) ; } } 	0	['12', '2', '0', '7', '36', '36', '1', '7', '8', '0.865612648', '505', '1', '4', '0.541666667', '0.319444444', '1', '3', '39.16666667', '14', '3.6667', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class SearchSettingsChanged extends EBMessage { public SearchSettingsChanged ( EBComponent source ) { super ( source ) ; } } 	0	['1', '2', '0', '5', '2', '0', '3', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package bsh ; final class ASCII_UCodeESC_CharStream { public static final boolean staticFlag = false ; static final int hexval ( char c ) throws java . io . IOException { switch ( c ) { case '0' : return 0 ; case '1' : return 1 ; case '2' : return 2 ; case '3' : return 3 ; case '4' : return 4 ; case '5' : return 5 ; case '6' : return 6 ; case '7' : return 7 ; case '8' : return 8 ; case '9' : return 9 ; case 'a' : case 'A' : return 10 ; case 'b' : case 'B' : return 11 ; case 'c' : case 'C' : return 12 ; case 'd' : case 'D' : return 13 ; case 'e' : case 'E' : return 14 ; case 'f' : case 'F' : return 15 ; } throw new java . io . IOException ( ) ; } public int bufpos = - 1 ; int bufsize ; int available ; int tokenBegin ; private int bufline [ ] ; private int bufcolumn [ ] ; private int column = 0 ; private int line = 1 ; private java . io . Reader inputStream ; private boolean prevCharIsCR = false ; private boolean prevCharIsLF = false ; private char [ ] nextCharBuf ; private char [ ] buffer ; private int maxNextCharInd = 0 ; private int nextCharInd = - 1 ; private int inBuf = 0 ; private final void ExpandBuff ( boolean wrapAround ) { char [ ] newbuffer = new char [ bufsize + 2048 ] ; int newbufline [ ] = new int [ bufsize + 2048 ] ; int newbufcolumn [ ] = new int [ bufsize + 2048 ] ; try { if ( wrapAround ) { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; System . arraycopy ( buffer , 0 , newbuffer , bufsize - tokenBegin , bufpos ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufline , 0 , newbufline , bufsize - tokenBegin , bufpos ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufcolumn , 0 , newbufcolumn , bufsize - tokenBegin , bufpos ) ; bufcolumn = newbufcolumn ; bufpos += ( bufsize - tokenBegin ) ; } else { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; bufcolumn = newbufcolumn ; bufpos -= tokenBegin ; } } catch ( Throwable t ) { throw new Error ( t . getMessage ( ) ) ; } available = ( bufsize += 2048 ) ; tokenBegin = 0 ; } private final void FillBuff ( ) throws java . io . IOException { int i ; if ( maxNextCharInd == 4096 ) maxNextCharInd = nextCharInd = 0 ; try { if ( ( i = inputStream . read ( nextCharBuf , maxNextCharInd , 4096 - maxNextCharInd ) ) == - 1 ) { inputStream . close ( ) ; throw new java . io . IOException ( ) ; } else maxNextCharInd += i ; return ; } catch ( java . io . IOException e ) { if ( bufpos != 0 ) { -- bufpos ; backup ( 0 ) ; } else { bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; } throw e ; } } private final char ReadByte ( ) throws java . io . IOException { if ( ++ nextCharInd >= maxNextCharInd ) FillBuff ( ) ; return nextCharBuf [ nextCharInd ] ; } public final char BeginToken ( ) throws java . io . IOException { if ( inBuf > 0 ) { -- inBuf ; return buffer [ tokenBegin = ( bufpos == bufsize - 1 ) ? ( bufpos = 0 ) : ++ bufpos ] ; } tokenBegin = 0 ; bufpos = - 1 ; return readChar ( ) ; } private final void AdjustBuffSize ( ) { if ( available == bufsize ) { if ( tokenBegin > 2048 ) { bufpos = 0 ; available = tokenBegin ; } else ExpandBuff ( false ) ; } else if ( available > tokenBegin ) available = bufsize ; else if ( ( tokenBegin - available ) < 2048 ) ExpandBuff ( true ) ; else available = tokenBegin ; } private final void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c == '\n' ) { prevCharIsLF = true ; } else line += ( column = 1 ) ; } switch ( c ) { case '\r' : prevCharIsCR = true ; break ; case '\n' : prevCharIsLF = true ; break ; case '\t' : column -- ; column += ( 8 - ( column & 07 ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; } public final char readChar ( ) throws java . io . IOException { if ( inBuf > 0 ) { -- inBuf ; return buffer [ ( bufpos == bufsize - 1 ) ? ( bufpos = 0 ) : ++ bufpos ] ; } char c ; if ( ++ bufpos == available ) AdjustBuffSize ( ) ; if ( ( ( buffer [ bufpos ] = c = ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) == '\\' ) ) { UpdateLineColumn ( c ) ; int backSlashCnt = 1 ; for ( ; ; ) { if ( ++ bufpos == available ) AdjustBuffSize ( ) ; try { if ( ( buffer [ bufpos ] = c = ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) != '\\' ) { UpdateLineColumn ( c ) ; if ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { if ( -- bufpos < 0 ) bufpos = bufsize - 1 ; break ; } backup ( backSlashCnt ) ; return '\\' ; } } catch ( java . io . IOException e ) { if ( backSlashCnt > 1 ) backup ( backSlashCnt ) ; return '\\' ; } UpdateLineColumn ( c ) ; backSlashCnt ++ ; } try { while ( ( c = ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) == 'u' ) ++ column ; buffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) << 8 | hexval ( ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) << 4 | hexval ( ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) ) ; column += 4 ; } catch ( java . io . IOException e ) { throw new Error ( "Invalid escape character at line " + line + " column " + column + "." ) ; } if ( backSlashCnt == 1 ) return c ; else { backup ( backSlashCnt - 1 ) ; return '\\' ; } } else { UpdateLineColumn ( c ) ; return ( c ) ; } } public final int getColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getLine ( ) { return bufline [ bufpos ] ; } public final int getEndColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getEndLine ( ) { return bufline [ bufpos ] ; } public final int getBeginColumn ( ) { return bufcolumn [ tokenBegin ] ; } public final int getBeginLine ( ) { return bufline [ tokenBegin ] ; } public final void backup ( int amount ) { inBuf += amount ; if ( ( bufpos -= amount ) < 0 ) bufpos += bufsize ; } public ASCII_UCodeESC_CharStream ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; nextCharBuf = new char [ 4096 ] ; } public ASCII_UCodeESC_CharStream ( java . io . Reader dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; if ( buffer == null || buffersize != buffer . length ) { available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; nextCharBuf = new char [ 4096 ] ; } prevCharIsLF = prevCharIsCR = false ; tokenBegin = inBuf = maxNextCharInd = 0 ; nextCharInd = bufpos = - 1 ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public ASCII_UCodeESC_CharStream ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { this ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , 4096 ) ; } public ASCII_UCodeESC_CharStream ( java . io . InputStream dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { ReInit ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public final String GetImage ( ) { if ( bufpos >= tokenBegin ) return new String ( buffer , tokenBegin , bufpos - tokenBegin + 1 ) ; else return new String ( buffer , tokenBegin , bufsize - tokenBegin ) + new String ( buffer , 0 , bufpos + 1 ) ; } public final char [ ] GetSuffix ( int len ) { char [ ] ret = new char [ len ] ; if ( ( bufpos + 1 ) >= len ) System . arraycopy ( buffer , bufpos - len + 1 , ret , 0 , len ) ; else { System . arraycopy ( buffer , bufsize - ( len - bufpos - 1 ) , ret , 0 , len - bufpos - 1 ) ; System . arraycopy ( buffer , 0 , ret , len - bufpos - 1 , bufpos + 1 ) ; } return ret ; } public void Done ( ) { nextCharBuf = null ; buffer = null ; bufline = null ; bufcolumn = null ; } public void adjustBeginLineColumn ( int newLine , int newCol ) { int start = tokenBegin ; int len ; if ( bufpos >= tokenBegin ) { len = bufpos - tokenBegin + inBuf + 1 ; } else { len = bufsize - tokenBegin + bufpos + 1 + inBuf ; } int i = 0 , j = 0 , k = 0 ; int nextColDiff = 0 , columnDiff = 0 ; while ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { bufline [ j ] = newLine ; nextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; bufcolumn [ j ] = newCol + columnDiff ; columnDiff = nextColDiff ; i ++ ; } if ( i < len ) { bufline [ j ] = newLine ++ ; bufcolumn [ j ] = newCol + columnDiff ; while ( i ++ < len ) { if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; else bufline [ j ] = newLine ; } } line = bufline [ j ] ; column = bufcolumn [ j ] ; } } 	0	['27', '1', '0', '3', '40', '25', '3', '0', '21', '0.529411765', '1277', '0.705882353', '0', '0', '0.296296296', '0', '0', '45.66666667', '7', '1.5926', '0']
package org . gjt . sp . jedit . buffer ; import javax . swing . text . Segment ; import org . gjt . sp . jedit . Buffer ; public class IndentFoldHandler extends FoldHandler { public IndentFoldHandler ( ) { super ( "indent" ) ; } public int getFoldLevel ( Buffer buffer , int lineIndex , Segment seg ) { int tabSize = buffer . getTabSize ( ) ; buffer . getLineText ( lineIndex , seg ) ; int offset = seg . offset ; int count = seg . count ; int whitespace = 0 ; boolean seenNonWhiteSpace = false ; loop : for ( int i = 0 ; i < count ; i ++ ) { switch ( seg . array [ offset + i ] ) { case ' ' : whitespace ++ ; break ; case '\t' : whitespace += ( tabSize - whitespace % tabSize ) ; break ; default : seenNonWhiteSpace = true ; break loop ; } } if ( ! seenNonWhiteSpace ) { if ( lineIndex != 0 ) return buffer . getFoldLevel ( lineIndex - 1 ) ; else return 0 ; } return whitespace ; } } 	0	['2', '2', '0', '2', '6', '1', '1', '2', '2', '2', '65', '0', '0', '0.888888889', '0.625', '0', '0', '31.5', '7', '3.5', '0']
package bsh ; public class BSHFormalComment extends SimpleNode { public String text ; public BSHFormalComment ( int id ) { super ( id ) ; } } 	0	['1', '2', '0', '2', '2', '0', '1', '1', '1', '2', '6', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . gjt . sp . util ; import java . util . Vector ; public class ReadWriteLock { public synchronized void readLock ( ) { if ( activeReaders != 0 || allowRead ( ) ) { ++ activeReaders ; return ; } ++ waitingReaders ; while ( ! allowRead ( ) ) { try { wait ( ) ; } catch ( InterruptedException e ) { -- waitingReaders ; Log . log ( Log . ERROR , this , e ) ; return ; } } -- waitingReaders ; ++ activeReaders ; readers . addElement ( Thread . currentThread ( ) ) ; } public synchronized void readUnlock ( ) { if ( activeReaders == 0 ) throw new InternalError ( "Unbalanced readLock()/readUnlock() calls" ) ; -- activeReaders ; notifyAll ( ) ; } public synchronized void writeLock ( ) { if ( writerThread != null ) { if ( Thread . currentThread ( ) == writerThread ) { ++ lockCount ; return ; } } if ( allowWrite ( ) ) { claimWriteLock ( ) ; return ; } ++ waitingWriters ; while ( ! allowWrite ( ) ) { try { wait ( ) ; } catch ( InterruptedException e ) { -- waitingWriters ; Log . log ( Log . ERROR , this , e ) ; return ; } } -- waitingWriters ; claimWriteLock ( ) ; } public synchronized void writeUnlock ( ) { if ( activeWriters != 1 || lockCount <= 0 ) throw new InternalError ( "Unbalanced writeLock()/writeUnlock() calls" ) ; if ( Thread . currentThread ( ) != writerThread ) throw new InternalError ( "writeUnlock() from wrong thread" ) ; if ( -- lockCount == 0 ) { -- activeWriters ; writerThread = null ; notifyAll ( ) ; } } public synchronized boolean isWriteLocked ( ) { return activeWriters == 1 ; } private int activeReaders ; private int activeWriters ; private int waitingReaders ; private int waitingWriters ; private Vector readers = new Vector ( ) ; private Thread writerThread ; private int lockCount ; private final boolean allowRead ( ) { return ( Thread . currentThread ( ) == writerThread ) || ( waitingWriters == 0 && activeWriters == 0 ) ; } private final boolean allowWrite ( ) { return activeReaders == 0 && activeWriters == 0 ; } private void claimWriteLock ( ) { ++ activeWriters ; writerThread = Thread . currentThread ( ) ; lockCount = 1 ; } } 	0	['9', '1', '0', '2', '17', '2', '1', '1', '6', '0.678571429', '236', '1', '0', '0', '1', '0', '0', '24.44444444', '5', '2.8889', '0']
package org . gjt . sp . jedit ; import java . util . Enumeration ; import java . util . Vector ; import org . gjt . sp . util . Log ; public class OptionGroup { public OptionGroup ( String name ) { this . name = name ; members = new Vector ( ) ; } public String getName ( ) { return name ; } public void addOptionGroup ( OptionGroup group ) { if ( members . indexOf ( group ) != - 1 ) return ; members . addElement ( group ) ; } public void addOptionPane ( OptionPane pane ) { if ( members . indexOf ( pane ) != - 1 ) return ; members . addElement ( pane ) ; } public Enumeration getMembers ( ) { return members . elements ( ) ; } public Object getMember ( int index ) { return ( index >= 0 && index < members . size ( ) ) ? members . elementAt ( index ) : null ; } public int getMemberIndex ( Object member ) { return members . indexOf ( member ) ; } public int getMemberCount ( ) { return members . size ( ) ; } public void save ( ) { Enumeration enum = members . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object elem = enum . nextElement ( ) ; try { if ( elem instanceof OptionPane ) { ( ( OptionPane ) elem ) . save ( ) ; } else if ( elem instanceof OptionGroup ) { ( ( OptionGroup ) elem ) . save ( ) ; } } catch ( Throwable t ) { Log . log ( Log . ERROR , elem , "Error saving option pane" ) ; Log . log ( Log . ERROR , elem , t ) ; } } } private String name ; private Vector members ; } 	0	['9', '1', '0', '6', '20', '0', '4', '2', '9', '0.5', '112', '1', '0', '0', '0.259259259', '0', '0', '11.22222222', '3', '1.5556', '0']
package bsh ; class JJTParserState { private java . util . Stack nodes ; private java . util . Stack marks ; private int sp ; private int mk ; private boolean node_created ; JJTParserState ( ) { nodes = new java . util . Stack ( ) ; marks = new java . util . Stack ( ) ; sp = 0 ; mk = 0 ; } boolean nodeCreated ( ) { return node_created ; } void reset ( ) { nodes . removeAllElements ( ) ; marks . removeAllElements ( ) ; sp = 0 ; mk = 0 ; } Node rootNode ( ) { return ( Node ) nodes . elementAt ( 0 ) ; } void pushNode ( Node n ) { nodes . push ( n ) ; ++ sp ; } Node popNode ( ) { if ( -- sp < mk ) { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; } return ( Node ) nodes . pop ( ) ; } Node peekNode ( ) { return ( Node ) nodes . peek ( ) ; } int nodeArity ( ) { return sp - mk ; } void clearNodeScope ( Node n ) { while ( sp > mk ) { popNode ( ) ; } mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; } void openNodeScope ( Node n ) { marks . push ( new Integer ( mk ) ) ; mk = sp ; n . jjtOpen ( ) ; } void closeNodeScope ( Node n , int num ) { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; while ( num -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , num ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } void closeNodeScope ( Node n , boolean condition ) { if ( condition ) { int a = nodeArity ( ) ; mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; while ( a -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , a ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } else { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; node_created = false ; } } } 	0	['12', '1', '0', '3', '25', '0', '2', '1', '0', '0.436363636', '218', '1', '0', '0', '0.395833333', '0', '0', '16.75', '3', '1.3333', '0']
package bsh ; import java . net . * ; import java . util . * ; import java . io . IOException ; import java . io . * ; public abstract class BshClassManager { private static BshClassManager manager ; private static boolean checkedForManager ; private static Object NOVALUE = new Object ( ) ; private static ClassLoader externalClassLoader ; protected transient static Hashtable absoluteClassCache = new Hashtable ( ) ; protected transient static Hashtable absoluteNonClasses = new Hashtable ( ) ; public static BshClassManager getClassManager ( ) { if ( ! checkedForManager && manager == null ) try { if ( plainClassForName ( "java.lang.ref.WeakReference" ) != null && plainClassForName ( "java.util.HashMap" ) != null ) { Class bcm = plainClassForName ( "bsh.classpath.ClassManagerImpl" ) ; manager = ( BshClassManager ) bcm . newInstance ( ) ; } } catch ( ClassNotFoundException e ) { } catch ( Exception e ) { System . err . println ( "Error loading classmanager: " + e ) ; } checkedForManager = true ; return manager ; } public static boolean classExists ( String name ) { return ( classForName ( name ) != null ) ; } public static Class classForName ( String name ) { BshClassManager manager = getClassManager ( ) ; if ( manager != null ) return manager . getClassForName ( name ) ; else try { return plainClassForName ( name ) ; } catch ( ClassNotFoundException e ) { return null ; } } public static Class plainClassForName ( String name ) throws ClassNotFoundException { try { Class c ; if ( externalClassLoader != null ) c = externalClassLoader . loadClass ( name ) ; else { BshClassManager bcm = manager ; if ( bcm != null ) c = bcm . getPlainClassForName ( name ) ; else c = Class . forName ( name ) ; } cacheClassInfo ( name , c ) ; return c ; } catch ( NoClassDefFoundError e ) { cacheClassInfo ( name , null ) ; throw new ClassNotFoundException ( e . toString ( ) ) ; } } public static void cacheClassInfo ( String name , Class value ) { if ( value != null ) absoluteClassCache . put ( name , value ) ; else absoluteNonClasses . put ( name , NOVALUE ) ; } protected void clearCaches ( ) { absoluteNonClasses = new Hashtable ( ) ; absoluteClassCache = new Hashtable ( ) ; } public static void addCMListener ( Listener l ) { getClassManager ( ) ; if ( manager != null ) manager . addListener ( l ) ; } public static void setClassLoader ( ClassLoader externalCL ) { externalClassLoader = externalCL ; BshClassManager bcm = getClassManager ( ) ; if ( bcm != null ) bcm . classLoaderChanged ( ) ; } public static interface Listener { public void classLoaderChanged ( ) ; } public abstract Class getClassForName ( String name ) ; public abstract Class getPlainClassForName ( String name ) throws ClassNotFoundException ; public abstract ClassLoader getBaseLoader ( ) ; public abstract ClassLoader getLoaderForClass ( String name ) ; public abstract void addClassPath ( URL path ) throws IOException ; public abstract void reset ( ) ; public abstract void setClassPath ( URL [ ] cp ) ; public abstract void reloadAllClasses ( ) throws ClassPathException ; public abstract void reloadClasses ( String [ ] classNames ) throws ClassPathException ; public abstract void reloadPackage ( String pack ) throws ClassPathException ; public abstract void doSuperImport ( ) throws EvalError ; public abstract String getClassNameByUnqName ( String name ) throws ClassPathException ; public abstract void addListener ( Listener l ) ; public abstract void removeListener ( Listener l ) ; public abstract void dump ( PrintWriter pw ) ; protected abstract void classLoaderChanged ( ) ; } 	0	['26', '1', '0', '10', '39', '311', '7', '3', '23', '0.873333333', '179', '1', '1', '0', '0.16', '0', '0', '5.653846154', '3', '1.1923', '0']
package org . gjt . sp . jedit ; import java . awt . Component ; public interface OptionPane { String getName ( ) ; Component getComponent ( ) ; void init ( ) ; void save ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '6', '0', '4', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package gnu . regexp ; import java . io . Serializable ; public final class REMatch implements Serializable , Cloneable { private String matchedText ; int eflags ; int offset ; int anchor ; int index ; int [ ] start ; int [ ] end ; REMatch next ; public Object clone ( ) { try { REMatch copy = ( REMatch ) super . clone ( ) ; copy . next = null ; copy . start = ( int [ ] ) start . clone ( ) ; copy . end = ( int [ ] ) end . clone ( ) ; return copy ; } catch ( CloneNotSupportedException e ) { throw new Error ( ) ; } } void assignFrom ( REMatch other ) { start = other . start ; end = other . end ; index = other . index ; next = other . next ; } REMatch ( int subs , int anchor , int eflags ) { start = new int [ subs + 1 ] ; end = new int [ subs + 1 ] ; this . anchor = anchor ; this . eflags = eflags ; clear ( anchor ) ; } void finish ( CharIndexed text ) { start [ 0 ] = 0 ; StringBuffer sb = new StringBuffer ( ) ; int i ; for ( i = 0 ; i < end [ 0 ] ; i ++ ) sb . append ( text . charAt ( i ) ) ; matchedText = sb . toString ( ) ; for ( i = 0 ; i < start . length ; i ++ ) { if ( ( start [ i ] == - 1 ) ^ ( end [ i ] == - 1 ) ) { start [ i ] = - 1 ; end [ i ] = - 1 ; } } next = null ; } void clear ( int index ) { offset = index ; this . index = 0 ; for ( int i = 0 ; i < start . length ; i ++ ) { start [ i ] = end [ i ] = - 1 ; } next = null ; } public String toString ( ) { return matchedText ; } public int getStartIndex ( ) { return offset + start [ 0 ] ; } public int getEndIndex ( ) { return offset + end [ 0 ] ; } public String toString ( int sub ) { if ( ( sub >= start . length ) || ( start [ sub ] == - 1 ) ) return "" ; return ( matchedText . substring ( start [ sub ] , end [ sub ] ) ) ; } public int getSubStartIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = start [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getStartIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = start [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getSubEndIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = end [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getEndIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = end [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public String substituteInto ( String input ) { StringBuffer output = new StringBuffer ( ) ; int pos ; for ( pos = 0 ; pos < input . length ( ) - 1 ; pos ++ ) { if ( ( input . charAt ( pos ) == '$' ) && ( Character . isDigit ( input . charAt ( pos + 1 ) ) ) ) { int val = Character . digit ( input . charAt ( ++ pos ) , 10 ) ; if ( val < start . length ) { output . append ( toString ( val ) ) ; } } else output . append ( input . charAt ( pos ) ) ; } if ( pos < input . length ( ) ) output . append ( input . charAt ( pos ) ) ; return output . toString ( ) ; } } 	0	['14', '1', '0', '20', '27', '0', '19', '1', '10', '0.653846154', '386', '0.125', '1', '0', '0.342857143', '0', '0', '26', '6', '2.4286', '0']
package org . gjt . sp . util ; public abstract class WorkRequest implements Runnable { public void setAbortable ( boolean abortable ) { Thread thread = Thread . currentThread ( ) ; if ( thread instanceof WorkThread ) ( ( WorkThread ) thread ) . setAbortable ( abortable ) ; } public void setStatus ( String status ) { Thread thread = Thread . currentThread ( ) ; if ( thread instanceof WorkThread ) ( ( WorkThread ) thread ) . setStatus ( status ) ; } public void setProgressValue ( int value ) { Thread thread = Thread . currentThread ( ) ; if ( thread instanceof WorkThread ) ( ( WorkThread ) thread ) . setProgressValue ( value ) ; } public void setProgressMaximum ( int value ) { Thread thread = Thread . currentThread ( ) ; if ( thread instanceof WorkThread ) ( ( WorkThread ) thread ) . setProgressMaximum ( value ) ; } } 	0	['5', '1', '4', '5', '11', '10', '4', '1', '5', '2', '48', '0', '0', '0', '0.45', '0', '0', '8.6', '2', '1.6', '0']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . ArrayList ; import java . util . Vector ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; class InstallPluginsDialog extends EnhancedDialog { static final int INSTALL = 0 ; static final int UPDATE = 1 ; InstallPluginsDialog ( JDialog dialog , Vector model , int mode ) { super ( dialog , ( mode == INSTALL ? jEdit . getProperty ( "install-plugins.title" ) : jEdit . getProperty ( "update-plugins.title" ) ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( 12 , 12 ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "install-plugins.caption" ) ) ; content . add ( BorderLayout . NORTH , label ) ; plugins = new JCheckBoxList ( model ) ; plugins . getSelectionModel ( ) . addListSelectionListener ( new ListHandler ( ) ) ; plugins . getModel ( ) . addTableModelListener ( new TableModelHandler ( ) ) ; JScrollPane scroller = new JScrollPane ( plugins ) ; scroller . setPreferredSize ( new Dimension ( 200 , 0 ) ) ; content . add ( BorderLayout . WEST , scroller ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBorder ( new TitledBorder ( jEdit . getProperty ( "install-plugins" + ".plugin-info" ) ) ) ; JPanel labelAndValueBox = new JPanel ( new BorderLayout ( ) ) ; JPanel labelBox = new JPanel ( new GridLayout ( ( mode == UPDATE ? 7 : 6 ) , 1 , 0 , 3 ) ) ; labelBox . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 12 ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.name" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.author" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.size" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.latest-version" ) , SwingConstants . RIGHT ) ) ; if ( mode == UPDATE ) { labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.installed-version" ) , SwingConstants . RIGHT ) ) ; } labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.updated" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.description" ) , SwingConstants . RIGHT ) ) ; labelAndValueBox . add ( BorderLayout . WEST , labelBox ) ; JPanel valueBox = new JPanel ( new GridLayout ( ( mode == UPDATE ? 7 : 6 ) , 1 , 0 , 3 ) ) ; valueBox . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 0 ) ) ; valueBox . add ( name = new JLabel ( ) ) ; valueBox . add ( author = new JLabel ( ) ) ; valueBox . add ( size = new JLabel ( ) ) ; valueBox . add ( latestVersion = new JLabel ( ) ) ; if ( mode == UPDATE ) valueBox . add ( installedVersion = new JLabel ( ) ) ; valueBox . add ( updated = new JLabel ( ) ) ; valueBox . add ( Box . createGlue ( ) ) ; labelAndValueBox . add ( BorderLayout . CENTER , valueBox ) ; panel . add ( BorderLayout . NORTH , labelAndValueBox ) ; description = new JTextArea ( 6 , 50 ) ; description . setEditable ( false ) ; description . setLineWrap ( true ) ; description . setWrapStyleWord ( true ) ; panel . add ( BorderLayout . CENTER , new JScrollPane ( description ) ) ; content . add ( BorderLayout . CENTER , panel ) ; panel = new JPanel ( new BorderLayout ( 12 , 0 ) ) ; JPanel panel2 = new JPanel ( new GridLayout ( ( mode == INSTALL ? 4 : 2 ) , 1 ) ) ; Box totalSizeBox = new Box ( BoxLayout . X_AXIS ) ; totalSizeBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins.totalSize" ) ) ) ; totalSizeBox . add ( Box . createHorizontalStrut ( 12 ) ) ; totalSizeBox . add ( totalSize = new JLabel ( ) ) ; panel2 . add ( totalSizeBox ) ; panel2 . add ( downloadSource = new JCheckBox ( jEdit . getProperty ( "install-plugins.downloadSource" ) ) ) ; downloadSource . setSelected ( jEdit . getBooleanProperty ( "install-plugins" + ".downloadSource.value" ) ) ; downloadSource . addActionListener ( new ActionHandler ( ) ) ; if ( mode == INSTALL ) { ButtonGroup grp = new ButtonGroup ( ) ; installUser = new JRadioButton ( ) ; String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) { settings = jEdit . getProperty ( "install-plugins.none" ) ; installUser . setEnabled ( false ) ; } else { settings = MiscUtilities . constructPath ( settings , "jars" ) ; installUser . setEnabled ( true ) ; } String [ ] args = { settings } ; installUser . setText ( jEdit . getProperty ( "install-plugins.user" , args ) ) ; grp . add ( installUser ) ; panel2 . add ( installUser ) ; installSystem = new JRadioButton ( ) ; String jEditHome = jEdit . getJEditHome ( ) ; if ( jEditHome == null ) { jEditHome = jEdit . getProperty ( "install-plugins.none" ) ; installSystem . setEnabled ( false ) ; } else { jEditHome = MiscUtilities . constructPath ( jEditHome , "jars" ) ; installSystem . setEnabled ( true ) ; } args [ 0 ] = jEditHome ; installSystem . setText ( jEdit . getProperty ( "install-plugins.system" , args ) ) ; grp . add ( installSystem ) ; panel2 . add ( installSystem ) ; if ( installUser . isEnabled ( ) ) installUser . setSelected ( true ) ; else installSystem . setSelected ( true ) ; } panel . add ( BorderLayout . NORTH , panel2 ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; selectAll = new JButton ( jEdit . getProperty ( "install-plugins.select-all" ) ) ; selectAll . addActionListener ( new ActionHandler ( ) ) ; box . add ( selectAll ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; install = new JButton ( jEdit . getProperty ( "install-plugins.install" ) ) ; install . setEnabled ( false ) ; getRootPane ( ) . setDefaultButton ( install ) ; install . addActionListener ( new ActionHandler ( ) ) ; box . add ( install ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; box . add ( cancel ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; box . add ( Box . createGlue ( ) ) ; panel . add ( BorderLayout . SOUTH , box ) ; content . add ( BorderLayout . SOUTH , panel ) ; updateTotalSize ( ) ; pack ( ) ; setLocationRelativeTo ( dialog ) ; show ( ) ; } public void ok ( ) { jEdit . setBooleanProperty ( "install-plugins.downloadSource.value" , downloadSource . isSelected ( ) ) ; dispose ( ) ; } public void cancel ( ) { cancelled = true ; dispose ( ) ; } void installPlugins ( Roster roster ) { if ( cancelled ) return ; String installDirectory ; if ( installUser == null || installUser . isSelected ( ) ) { installDirectory = MiscUtilities . constructPath ( jEdit . getSettingsDirectory ( ) , "jars" ) ; } else { installDirectory = MiscUtilities . constructPath ( jEdit . getJEditHome ( ) , "jars" ) ; } Object [ ] selected = plugins . getCheckedValues ( ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) selected [ i ] ; plugin . install ( roster , installDirectory , downloadSource . isSelected ( ) ) ; } } private JCheckBoxList plugins ; private JLabel name ; private JLabel author ; private JLabel size ; private JLabel latestVersion ; private JLabel installedVersion ; private JLabel updated ; private JTextArea description ; private JLabel totalSize ; private JCheckBox downloadSource ; private JRadioButton installUser ; private JRadioButton installSystem ; private JButton selectAll ; private JButton install ; private JButton cancel ; private boolean cancelled ; private Thread thread ; private void updateInfo ( ) { Object selected = plugins . getSelectedValue ( ) ; if ( selected instanceof PluginList . Plugin ) { PluginList . Plugin plugin = ( PluginList . Plugin ) selected ; PluginList . Branch branch = plugin . getCompatibleBranch ( ) ; name . setText ( plugin . name ) ; author . setText ( plugin . author ) ; size . setText ( String . valueOf ( ( downloadSource . isSelected ( ) ? branch . downloadSourceSize : branch . downloadSize ) / 1024 ) + " Kb" ) ; if ( branch . obsolete ) latestVersion . setText ( jEdit . getProperty ( "install-plugins.info.obsolete" ) ) ; else latestVersion . setText ( branch . version ) ; if ( installedVersion != null ) installedVersion . setText ( plugin . installedVersion ) ; updated . setText ( branch . date ) ; ArrayList deps = new ArrayList ( ) ; createDependencyList ( branch . deps , deps ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < deps . size ( ) ; i ++ ) { buf . append ( "\n- " ) ; buf . append ( deps . get ( i ) ) ; } description . setText ( plugin . description + ( buf . length ( ) == 0 ? "" : jEdit . getProperty ( "install-plugins.info" + ".also-install" ) + buf . toString ( ) + ( branch . obsolete ? jEdit . getProperty ( "install-plugins.info.obsolete-text" ) : "" ) ) ) ; description . setCaretPosition ( 0 ) ; } else { name . setText ( null ) ; author . setText ( null ) ; size . setText ( null ) ; latestVersion . setText ( null ) ; if ( installedVersion != null ) installedVersion . setText ( null ) ; updated . setText ( null ) ; description . setText ( null ) ; } } private void createDependencyList ( Vector deps , ArrayList append ) { for ( int i = 0 ; i < deps . size ( ) ; i ++ ) { PluginList . Dependency dep = ( PluginList . Dependency ) deps . elementAt ( i ) ; if ( dep . what . equals ( "plugin" ) && ! dep . isSatisfied ( ) ) { if ( ! append . contains ( dep . plugin ) ) { append . add ( dep . plugin ) ; PluginList . Branch branch = dep . plugin . getCompatibleBranch ( ) ; createDependencyList ( branch . deps , append ) ; } } } } private void updateTotalSize ( ) { ArrayList selectedPlugins = new ArrayList ( ) ; Object [ ] selected = plugins . getCheckedValues ( ) ; install . setEnabled ( selected . length != 0 ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) selected [ i ] ; if ( ! selectedPlugins . contains ( plugin ) ) selectedPlugins . add ( plugin ) ; createDependencyList ( plugin . getCompatibleBranch ( ) . deps , selectedPlugins ) ; } int _totalSize = 0 ; for ( int i = 0 ; i < selectedPlugins . size ( ) ; i ++ ) { PluginList . Branch branch = ( ( PluginList . Plugin ) selectedPlugins . get ( i ) ) . getCompatibleBranch ( ) ; _totalSize += ( downloadSource . isSelected ( ) ? branch . downloadSourceSize : branch . downloadSize ) ; } totalSize . setText ( String . valueOf ( _totalSize / 1024 ) + " Kb" ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == selectAll ) plugins . selectAll ( ) ; if ( source == install ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; else if ( source == downloadSource ) { updateInfo ( ) ; updateTotalSize ( ) ; } } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { updateInfo ( ) ; } } class TableModelHandler implements TableModelListener { public void tableChanged ( TableModelEvent e ) { updateTotalSize ( ) ; } } } 	0	['14', '7', '0', '12', '98', '43', '4', '11', '2', '0.866396761', '1049', '0.894736842', '1', '0.980568012', '0.204081633', '0', '0', '72.57142857', '9', '2.4286', '0']
package org . gjt . sp . jedit . syntax ; import javax . swing . text . * ; import java . awt . font . * ; import org . gjt . sp . jedit . syntax . * ; public class DisplayTokenHandler extends DefaultTokenHandler { public void init ( Segment seg , SyntaxStyle [ ] styles , FontRenderContext fontRenderContext , TabExpander expander ) { super . init ( ) ; x = 0.0f ; this . seg = seg ; this . styles = styles ; this . fontRenderContext = fontRenderContext ; this . expander = expander ; } public void setMonospacedCharWidth ( float charWidth ) { this . charWidth = charWidth ; } public Chunk getChunks ( ) { return ( Chunk ) firstToken ; } protected Segment seg ; protected SyntaxStyle [ ] styles ; protected FontRenderContext fontRenderContext ; protected TabExpander expander ; protected float x ; protected float charWidth ; protected Token createToken ( byte id , int offset , int length , TokenMarker . LineContext context ) { if ( id == Token . END ) return null ; Chunk chunk = new Chunk ( id , offset , length , getParserRuleSet ( context ) ) ; chunk . init ( seg , expander , x , styles , fontRenderContext , context . rules . getDefault ( ) , charWidth ) ; x += chunk . width ; return chunk ; } } 	0	['5', '2', '1', '8', '11', '6', '2', '6', '4', '0.75', '81', '1', '1', '0.666666667', '0.288888889', '1', '2', '14', '2', '1', '0']
package org . gjt . sp . jedit . browser ; import java . util . EventListener ; import org . gjt . sp . jedit . io . VFS ; public interface BrowserListener extends EventListener { void filesSelected ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) ; void filesActivated ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package bsh ; public class Primitive implements ParserConstants , java . io . Serializable { private Object value ; private static class Special implements java . io . Serializable { private Special ( ) { } public static final Special NULL_VALUE = new Special ( ) ; public static final Special VOID_TYPE = new Special ( ) ; } public static final Primitive NULL = new Primitive ( Special . NULL_VALUE ) ; public static final Primitive VOID = new Primitive ( Special . VOID_TYPE ) ; private Primitive ( Object value ) { if ( value == null ) throw new InterpreterError ( "Use Primitve.NULL instead of Primitive(null)" ) ; this . value = value ; } public Primitive ( Number number ) { this ( ( Object ) number ) ; } public Primitive ( Boolean value ) { this ( ( Object ) value ) ; } public Primitive ( Byte value ) { this ( ( Object ) value ) ; } public Primitive ( Short value ) { this ( ( Object ) value ) ; } public Primitive ( Character value ) { this ( ( Object ) value ) ; } public Primitive ( Integer value ) { this ( ( Object ) value ) ; } public Primitive ( Long value ) { this ( ( Object ) value ) ; } public Primitive ( Float value ) { this ( ( Object ) value ) ; } public Primitive ( Double value ) { this ( ( Object ) value ) ; } public Primitive ( boolean value ) { this ( new Boolean ( value ) ) ; } public Primitive ( byte value ) { this ( new Byte ( value ) ) ; } public Primitive ( short value ) { this ( new Short ( value ) ) ; } public Primitive ( char value ) { this ( new Character ( value ) ) ; } public Primitive ( int value ) { this ( new Integer ( value ) ) ; } public Primitive ( long value ) { this ( new Long ( value ) ) ; } public Primitive ( float value ) { this ( new Float ( value ) ) ; } public Primitive ( double value ) { this ( new Double ( value ) ) ; } public Object getValue ( ) { if ( value == Special . NULL_VALUE ) return null ; else if ( value == Special . VOID_TYPE ) throw new InterpreterError ( "attempt to unwrap void type" ) ; else return value ; } public String toString ( ) { if ( value == Special . NULL_VALUE ) return "null" ; else if ( value == Special . VOID_TYPE ) return "void" ; else return value . toString ( ) ; } public Class getType ( ) { return getType ( value ) ; } private Class getType ( Object o ) { if ( o instanceof Boolean ) return Boolean . TYPE ; else if ( o instanceof Byte ) return Byte . TYPE ; else if ( o instanceof Short ) return Short . TYPE ; else if ( o instanceof Character ) return Character . TYPE ; else if ( o instanceof Integer ) return Integer . TYPE ; else if ( o instanceof Long ) return Long . TYPE ; else if ( o instanceof Float ) return Float . TYPE ; else if ( o instanceof Double ) return Double . TYPE ; return null ; } public static Object binaryOperation ( Object obj1 , Object obj2 , int kind ) throws EvalError { if ( obj1 == NULL || obj2 == NULL ) throw new EvalError ( "Null value or 'null' literal in binary operation" ) ; if ( obj1 == VOID || obj2 == VOID ) throw new EvalError ( "Undefined variable, class, or 'void' literal in binary operation" ) ; Class lhsOrgType = obj1 . getClass ( ) ; Class rhsOrgType = obj2 . getClass ( ) ; if ( obj1 instanceof Primitive ) obj1 = ( ( Primitive ) obj1 ) . getValue ( ) ; if ( obj2 instanceof Primitive ) obj2 = ( ( Primitive ) obj2 ) . getValue ( ) ; Object [ ] operands = promotePrimitives ( obj1 , obj2 ) ; Object lhs = operands [ 0 ] ; Object rhs = operands [ 1 ] ; if ( lhs . getClass ( ) != rhs . getClass ( ) ) throw new EvalError ( "type mismatch in operator.  " + lhs . getClass ( ) + " cannot be used with " + rhs . getClass ( ) ) ; Object result ; try { result = binaryOperationImpl ( lhs , rhs , kind ) ; } catch ( ArithmeticException e ) { throw new TargetError ( "Arithemetic Exception in binary op" , e ) ; } if ( lhsOrgType == Primitive . class && rhsOrgType == Primitive . class ) return new Primitive ( result ) ; else return result ; } static Object binaryOperationImpl ( Object lhs , Object rhs , int kind ) throws EvalError { if ( lhs instanceof Boolean ) return booleanBinaryOperation ( ( Boolean ) lhs , ( Boolean ) rhs , kind ) ; else if ( lhs instanceof Integer ) return intBinaryOperation ( ( Integer ) lhs , ( Integer ) rhs , kind ) ; else if ( lhs instanceof Long ) return longBinaryOperation ( ( Long ) lhs , ( Long ) rhs , kind ) ; else if ( lhs instanceof Float ) return floatBinaryOperation ( ( Float ) lhs , ( Float ) rhs , kind ) ; else if ( lhs instanceof Double ) return doubleBinaryOperation ( ( Double ) lhs , ( Double ) rhs , kind ) ; else throw new EvalError ( "Invalid types in binary operator" ) ; } static Boolean booleanBinaryOperation ( Boolean B1 , Boolean B2 , int kind ) throws EvalError { boolean lhs = B1 . booleanValue ( ) ; boolean rhs = B2 . booleanValue ( ) ; switch ( kind ) { case EQ : return new Boolean ( lhs == rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case BOOL_OR : case BOOL_ORX : return new Boolean ( lhs || rhs ) ; case BOOL_AND : case BOOL_ANDX : return new Boolean ( lhs && rhs ) ; default : throw new InterpreterError ( "unimplemented binary operator" ) ; } } static Object longBinaryOperation ( Long L1 , Long L2 , int kind ) { long lhs = L1 . longValue ( ) ; long rhs = L2 . longValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Long ( lhs + rhs ) ; case MINUS : return new Long ( lhs - rhs ) ; case STAR : return new Long ( lhs * rhs ) ; case SLASH : return new Long ( lhs / rhs ) ; case MOD : return new Long ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : return new Long ( lhs << rhs ) ; case RSIGNEDSHIFT : case RSIGNEDSHIFTX : return new Long ( lhs > > rhs ) ; case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : return new Long ( lhs > > > rhs ) ; case BIT_AND : case BIT_ANDX : return new Long ( lhs & rhs ) ; case BIT_OR : case BIT_ORX : return new Long ( lhs | rhs ) ; case XOR : return new Long ( lhs ^ rhs ) ; default : throw new InterpreterError ( "Unimplemented binary long operator" ) ; } } static Object intBinaryOperation ( Integer I1 , Integer I2 , int kind ) { int lhs = I1 . intValue ( ) ; int rhs = I2 . intValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Integer ( lhs + rhs ) ; case MINUS : return new Integer ( lhs - rhs ) ; case STAR : return new Integer ( lhs * rhs ) ; case SLASH : return new Integer ( lhs / rhs ) ; case MOD : return new Integer ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : return new Integer ( lhs << rhs ) ; case RSIGNEDSHIFT : case RSIGNEDSHIFTX : return new Integer ( lhs > > rhs ) ; case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : return new Integer ( lhs > > > rhs ) ; case BIT_AND : case BIT_ANDX : return new Integer ( lhs & rhs ) ; case BIT_OR : case BIT_ORX : return new Integer ( lhs | rhs ) ; case XOR : return new Integer ( lhs ^ rhs ) ; default : throw new InterpreterError ( "Unimplemented binary integer operator" ) ; } } static Object doubleBinaryOperation ( Double D1 , Double D2 , int kind ) throws EvalError { double lhs = D1 . doubleValue ( ) ; double rhs = D2 . doubleValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Double ( lhs + rhs ) ; case MINUS : return new Double ( lhs - rhs ) ; case STAR : return new Double ( lhs * rhs ) ; case SLASH : return new Double ( lhs / rhs ) ; case MOD : return new Double ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : case RSIGNEDSHIFT : case RSIGNEDSHIFTX : case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : throw new EvalError ( "Can't shift doubles" ) ; default : throw new InterpreterError ( "Unimplemented binary double operator" ) ; } } static Object floatBinaryOperation ( Float F1 , Float F2 , int kind ) throws EvalError { float lhs = F1 . floatValue ( ) ; float rhs = F2 . floatValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Float ( lhs + rhs ) ; case MINUS : return new Float ( lhs - rhs ) ; case STAR : return new Float ( lhs * rhs ) ; case SLASH : return new Float ( lhs / rhs ) ; case MOD : return new Float ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : case RSIGNEDSHIFT : case RSIGNEDSHIFTX : case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : throw new EvalError ( "Can't shift floats " ) ; default : throw new InterpreterError ( "Unimplemented binary float operator" ) ; } } static Object promoteToInteger ( Object primitive ) { if ( primitive instanceof Character ) return new Integer ( ( ( Character ) primitive ) . charValue ( ) ) ; else if ( ( primitive instanceof Byte ) || ( primitive instanceof Short ) ) return new Integer ( ( ( Number ) primitive ) . intValue ( ) ) ; return primitive ; } static Object [ ] promotePrimitives ( Object lhs , Object rhs ) { lhs = promoteToInteger ( lhs ) ; rhs = promoteToInteger ( rhs ) ; if ( ( lhs instanceof Number ) && ( rhs instanceof Number ) ) { Number lnum = ( Number ) lhs ; Number rnum = ( Number ) rhs ; boolean b ; if ( ( b = ( lnum instanceof Double ) ) || ( rnum instanceof Double ) ) { if ( b ) rhs = new Double ( rnum . doubleValue ( ) ) ; else lhs = new Double ( lnum . doubleValue ( ) ) ; } else if ( ( b = ( lnum instanceof Float ) ) || ( rnum instanceof Float ) ) { if ( b ) rhs = new Float ( rnum . floatValue ( ) ) ; else lhs = new Float ( lnum . floatValue ( ) ) ; } else if ( ( b = ( lnum instanceof Long ) ) || ( rnum instanceof Long ) ) { if ( b ) rhs = new Long ( rnum . longValue ( ) ) ; else lhs = new Long ( lnum . longValue ( ) ) ; } } return new Object [ ] { lhs , rhs } ; } public static Primitive unaryOperation ( Primitive val , int kind ) throws EvalError { if ( val == NULL ) throw new EvalError ( "illegal use of null object or 'null' literal" ) ; if ( val == VOID ) throw new EvalError ( "illegal use of undefined object or 'void' literal" ) ; Class operandType = val . getType ( ) ; Object operand = promoteToInteger ( val . getValue ( ) ) ; if ( operand instanceof Boolean ) return new Primitive ( booleanUnaryOperation ( ( Boolean ) operand , kind ) ) ; else if ( operand instanceof Integer ) { int result = intUnaryOperation ( ( Integer ) operand , kind ) ; if ( kind == INCR || kind == DECR ) { if ( operandType == Byte . TYPE ) return new Primitive ( ( byte ) result ) ; if ( operandType == Short . TYPE ) return new Primitive ( ( short ) result ) ; if ( operandType == Character . TYPE ) return new Primitive ( ( char ) result ) ; } return new Primitive ( result ) ; } else if ( operand instanceof Long ) return new Primitive ( longUnaryOperation ( ( Long ) operand , kind ) ) ; else if ( operand instanceof Float ) return new Primitive ( floatUnaryOperation ( ( Float ) operand , kind ) ) ; else if ( operand instanceof Double ) return new Primitive ( doubleUnaryOperation ( ( Double ) operand , kind ) ) ; else throw new InterpreterError ( "An error occurred.  Please call technical support." ) ; } static boolean booleanUnaryOperation ( Boolean B , int kind ) throws EvalError { boolean operand = B . booleanValue ( ) ; switch ( kind ) { case BANG : return ! operand ; default : throw new EvalError ( "Operator inappropriate for boolean" ) ; } } static int intUnaryOperation ( Integer I , int kind ) { int operand = I . intValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; case TILDE : return ~ operand ; case INCR : return operand + 1 ; case DECR : return operand - 1 ; default : throw new InterpreterError ( "bad integer unaryOperation" ) ; } } static long longUnaryOperation ( Long L , int kind ) { long operand = L . longValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; case TILDE : return ~ operand ; case INCR : return operand + 1 ; case DECR : return operand - 1 ; default : throw new InterpreterError ( "bad long unaryOperation" ) ; } } static float floatUnaryOperation ( Float F , int kind ) { float operand = F . floatValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; default : throw new InterpreterError ( "bad float unaryOperation" ) ; } } static double doubleUnaryOperation ( Double D , int kind ) { double operand = D . doubleValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; default : throw new InterpreterError ( "bad double unaryOperation" ) ; } } public int intValue ( ) throws EvalError { if ( value instanceof Number ) return ( ( Number ) value ) . intValue ( ) ; else throw new EvalError ( "Primitive not a number" ) ; } public boolean booleanValue ( ) throws EvalError { if ( value instanceof Boolean ) return ( ( Boolean ) value ) . booleanValue ( ) ; else throw new EvalError ( "Primitive not a boolean" ) ; } public boolean isNumber ( ) { return ( ! ( value instanceof Boolean ) && ! ( this == NULL ) && ! ( this == VOID ) ) ; } public Number numberValue ( ) throws EvalError { Object value = this . value ; if ( value instanceof Character ) value = new Integer ( ( ( Character ) value ) . charValue ( ) ) ; if ( value instanceof Number ) return ( Number ) value ; else throw new EvalError ( "Primitive not a number" ) ; } public boolean equals ( Object obj ) { if ( obj instanceof Primitive ) return ( ( Primitive ) obj ) . value . equals ( this . value ) ; else return obj . equals ( this . value ) ; } public static Object unwrap ( Object obj ) { if ( obj == null ) return null ; if ( obj == Primitive . VOID ) return null ; if ( obj instanceof Primitive ) return ( ( Primitive ) obj ) . getValue ( ) ; else return obj ; } } 	0	['45', '1', '0', '41', '77', '898', '36', '5', '28', '0.795454545', '1472', '0.25', '2', '0', '0.083333333', '0', '0', '31.62222222', '12', '2.0222', '0']
package bsh ; import java . lang . reflect . * ; import java . io . * ; import java . util . Vector ; class Reflect { public static Object invokeObjectMethod ( Interpreter interpreter , Object object , String methodName , Object [ ] args , SimpleNode callerInfo ) throws ReflectError , InvocationTargetException , EvalError { if ( object instanceof This && ! showThisMethod ( methodName ) ) { return ( ( This ) object ) . invokeMethod ( methodName , args , interpreter , null , callerInfo ) ; } else return invokeMethod ( object . getClass ( ) , object , methodName , args , false ) ; } private static boolean showThisMethod ( String name ) { return ( name . equals ( "getClass" ) || name . equals ( "invokeMethod" ) ) ; } public static Object invokeStaticMethod ( Class clas , String methodName , Object [ ] args ) throws ReflectError , InvocationTargetException , EvalError { Interpreter . debug ( "invoke static Method" ) ; return invokeMethod ( clas , null , methodName , args , true ) ; } public static Object getIndex ( Object array , int index ) throws ReflectError , TargetError { if ( Interpreter . DEBUG ) Interpreter . debug ( "getIndex: " + array + ", index=" + index ) ; try { Object val = Array . get ( array , index ) ; return wrapPrimitive ( val , array . getClass ( ) . getComponentType ( ) ) ; } catch ( ArrayIndexOutOfBoundsException e1 ) { throw new TargetError ( "Array Index" , e1 ) ; } catch ( Exception e ) { throw new ReflectError ( "Array access:" + e ) ; } } public static void setIndex ( Object array , int index , Object val ) throws ReflectError , TargetError { try { val = unwrapPrimitive ( val ) ; Array . set ( array , index , val ) ; } catch ( ArrayStoreException e2 ) { throw new TargetError ( "Array store exception" , e2 ) ; } catch ( IllegalArgumentException e1 ) { throw new TargetError ( "Illegal Argument" , new ArrayStoreException ( e1 . toString ( ) ) ) ; } catch ( Exception e ) { throw new ReflectError ( "Array access:" + e ) ; } } public static Object getStaticField ( Class clas , String fieldName ) throws ReflectError { return getFieldValue ( clas , null , fieldName ) ; } public static Object getObjectField ( Object object , String fieldName ) throws ReflectError { if ( object instanceof This ) return ( ( This ) object ) . namespace . getVariable ( fieldName ) ; else { try { return getFieldValue ( object . getClass ( ) , object , fieldName ) ; } catch ( ReflectError e ) { if ( hasObjectPropertyGetter ( object . getClass ( ) , fieldName ) ) return getObjectProperty ( object , fieldName ) ; else throw e ; } } } static LHS getLHSStaticField ( Class clas , String fieldName ) throws ReflectError { Field f = getField ( clas , fieldName ) ; return new LHS ( f ) ; } static LHS getLHSObjectField ( Object object , String fieldName ) throws ReflectError { if ( object instanceof This ) return new LHS ( ( ( This ) object ) . namespace , fieldName ) ; try { Field f = getField ( object . getClass ( ) , fieldName ) ; return new LHS ( object , f ) ; } catch ( ReflectError e ) { if ( hasObjectPropertySetter ( object . getClass ( ) , fieldName ) ) return new LHS ( object , fieldName ) ; else throw e ; } } private static Object getFieldValue ( Class clas , Object object , String fieldName ) throws ReflectError { try { Field f = getField ( clas , fieldName ) ; if ( f == null ) throw new ReflectError ( "internal: field not found:" + fieldName ) ; Object value = f . get ( object ) ; Class returnType = f . getType ( ) ; return wrapPrimitive ( value , returnType ) ; } catch ( NullPointerException e ) { throw new ReflectError ( "???" + fieldName + " is not a static field." ) ; } catch ( IllegalAccessException e ) { throw new ReflectError ( "Can't access field: " + fieldName ) ; } } private static Field getField ( Class clas , String fieldName ) throws ReflectError { try { if ( Capabilities . haveAccessibility ( ) ) return findAccessibleField ( clas , fieldName ) ; else return clas . getField ( fieldName ) ; } catch ( NoSuchFieldException e ) { throw new ReflectError ( "No such field: " + fieldName ) ; } } private static Field findAccessibleField ( Class clas , String fieldName ) throws NoSuchFieldException { try { return clas . getField ( fieldName ) ; } catch ( NoSuchFieldException e ) { } while ( clas != null ) { try { Field field = clas . getDeclaredField ( fieldName ) ; if ( ReflectManager . RMSetAccessible ( field ) ) return field ; } catch ( NoSuchFieldException e ) { } clas = clas . getSuperclass ( ) ; } throw new NoSuchFieldException ( fieldName ) ; } private static Object invokeMethod ( Class clas , Object object , String name , Object [ ] args , boolean onlyStatic ) throws ReflectError , InvocationTargetException , EvalError { if ( object == Primitive . NULL ) throw new TargetError ( "Attempt to invoke method " + name + " on null value" , new NullPointerException ( ) ) ; if ( object == Primitive . VOID ) throw new EvalError ( "Attempt to invoke method " + name + " on undefined variable or class name" ) ; if ( args == null ) args = new Object [ ] { } ; for ( int i = 0 ; i < args . length ; i ++ ) if ( args [ i ] == Primitive . VOID ) throw new ReflectError ( "Attempt to pass void argument " + "(position " + i + ") to method: " + name ) ; Class returnType = null ; Object returnValue = null ; Class [ ] types = getTypes ( args ) ; unwrapPrimitives ( args ) ; try { Method m = null ; try { m = findAccessibleMethod ( clas , name , types , onlyStatic ) ; } catch ( SecurityException e ) { } if ( m == null ) if ( Interpreter . DEBUG ) Interpreter . debug ( "Exact method " + StringUtil . methodString ( name , types ) + " not found in '" + clas . getName ( ) + "'" ) ; if ( m == null ) { if ( types . length == 0 ) throw new ReflectError ( "No args " + ( onlyStatic ? "static " : "" ) + "method " + StringUtil . methodString ( name , types ) + " not found in class'" + clas . getName ( ) + "'" ) ; Method [ ] methods = clas . getMethods ( ) ; if ( onlyStatic ) methods = retainStaticMethods ( methods ) ; m = findMostSpecificMethod ( name , types , methods ) ; methods = clas . getMethods ( ) ; if ( m == null ) m = findExtendedMethod ( name , args , methods ) ; if ( m != null ) { try { m = findAccessibleMethod ( clas , m . getName ( ) , m . getParameterTypes ( ) , onlyStatic ) ; } catch ( SecurityException e ) { } } } if ( m == null ) throw new ReflectError ( ( onlyStatic ? "Static method " : "Method " ) + StringUtil . methodString ( name , types ) + " not found in class'" + clas . getName ( ) + "'" ) ; returnValue = m . invoke ( object , args ) ; if ( returnValue == null ) returnValue = Primitive . NULL ; returnType = m . getReturnType ( ) ; } catch ( IllegalAccessException e ) { throw new ReflectError ( "Cannot access method " + StringUtil . methodString ( name , types ) + " in '" + clas . getName ( ) + "' :" + e ) ; } return wrapPrimitive ( returnValue , returnType ) ; } private static Method [ ] retainStaticMethods ( Method [ ] methods ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) if ( Modifier . isStatic ( methods [ i ] . getModifiers ( ) ) ) v . addElement ( methods [ i ] ) ; Method [ ] ma = new Method [ v . size ( ) ] ; v . copyInto ( ma ) ; return ma ; } static Method findAccessibleMethod ( Class clas , String name , Class [ ] types , boolean onlyStatic ) { Method meth = null ; Vector classQ = new Vector ( ) ; classQ . addElement ( clas ) ; Method found = null ; while ( classQ . size ( ) > 0 ) { Class c = ( Class ) classQ . firstElement ( ) ; classQ . removeElementAt ( 0 ) ; if ( Modifier . isPublic ( c . getModifiers ( ) ) || ( Capabilities . haveAccessibility ( ) ) ) { try { meth = c . getDeclaredMethod ( name , types ) ; if ( ( Modifier . isPublic ( meth . getModifiers ( ) ) && Modifier . isPublic ( c . getModifiers ( ) ) ) || ( Capabilities . haveAccessibility ( ) && ReflectManager . RMSetAccessible ( meth ) ) ) { found = meth ; break ; } } catch ( NoSuchMethodException e ) { } } if ( ! c . isInterface ( ) ) { Class superclass = c . getSuperclass ( ) ; if ( superclass != null ) classQ . addElement ( ( Object ) superclass ) ; } Class [ ] intfs = c . getInterfaces ( ) ; for ( int i = 0 ; i < intfs . length ; i ++ ) classQ . addElement ( ( Object ) intfs [ i ] ) ; } if ( found != null && ( ! onlyStatic || Modifier . isStatic ( found . getModifiers ( ) ) ) ) return found ; return null ; } private static Object wrapPrimitive ( Object value , Class returnType ) throws ReflectError { if ( value == null ) return Primitive . NULL ; if ( returnType == Void . TYPE ) return Primitive . VOID ; else if ( returnType . isPrimitive ( ) ) { if ( value instanceof Number ) return new Primitive ( ( Number ) value ) ; if ( value instanceof Boolean ) return new Primitive ( ( Boolean ) value ) ; if ( value instanceof Character ) return new Primitive ( ( Character ) value ) ; throw new ReflectError ( "Something bad happened" ) ; } else return value ; } public static Class [ ] getTypes ( Object [ ] args ) { if ( args == null ) return new Class [ 0 ] ; Class [ ] types = new Class [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] == null ) throw new InterpreterError ( "Null arg in getTypes()" ) ; if ( args [ i ] instanceof Primitive ) types [ i ] = ( ( Primitive ) args [ i ] ) . getType ( ) ; else types [ i ] = args [ i ] . getClass ( ) ; } return types ; } private static void unwrapPrimitives ( Object [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) args [ i ] = unwrapPrimitive ( args [ i ] ) ; } private static Object unwrapPrimitive ( Object arg ) { if ( arg instanceof Primitive ) return ( ( Primitive ) arg ) . getValue ( ) ; else return arg ; } static Object constructObject ( String clas , Object [ ] args ) throws ReflectError , InvocationTargetException { Class c = BshClassManager . classForName ( clas ) ; if ( c == null ) throw new ReflectError ( "Class not found: " + clas ) ; return constructObject ( c , args ) ; } static Object constructObject ( Class clas , Object [ ] args ) throws ReflectError , InvocationTargetException { for ( int i = 0 ; i < args . length ; i ++ ) if ( args [ i ] == Primitive . VOID ) throw new ReflectError ( "Attempt to pass void argument " + "(position " + i + ") to constructor for: " + clas ) ; if ( clas . isInterface ( ) ) throw new ReflectError ( "Can't create instance of an interface: " + clas ) ; Object obj = null ; Class [ ] types = getTypes ( args ) ; unwrapPrimitives ( args ) ; Constructor con = null ; Constructor [ ] constructors = clas . getDeclaredConstructors ( ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( "Looking for most specific constructor: " + clas ) ; con = findMostSpecificConstructor ( types , constructors ) ; if ( con == null ) if ( types . length == 0 ) throw new ReflectError ( "Can't find default constructor for: " + clas ) ; else con = findExtendedConstructor ( args , constructors ) ; if ( con == null ) throw new ReflectError ( "Can't find constructor: " + clas ) ; try { obj = con . newInstance ( args ) ; } catch ( InstantiationException e ) { throw new ReflectError ( "the class is abstract " ) ; } catch ( IllegalAccessException e ) { throw new ReflectError ( "we don't have permission to create an instance" ) ; } catch ( IllegalArgumentException e ) { throw new ReflectError ( "the number of arguments was wrong" ) ; } if ( obj == null ) throw new ReflectError ( "couldn't construct the object" ) ; return obj ; } static Method findMostSpecificMethod ( String name , Class [ ] idealMatch , Method [ ] methods ) { Vector sigs = new Vector ( ) ; Vector meths = new Vector ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) if ( methods [ i ] . getName ( ) . equals ( name ) ) { meths . addElement ( methods [ i ] ) ; sigs . addElement ( methods [ i ] . getParameterTypes ( ) ) ; } Class [ ] [ ] candidates = new Class [ sigs . size ( ) ] [ ] ; sigs . copyInto ( candidates ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( "Looking for most specific method: " + name ) ; int match = findMostSpecificSignature ( idealMatch , candidates ) ; if ( match == - 1 ) return null ; else return ( Method ) meths . elementAt ( match ) ; } static Method findExtendedMethod ( String name , Object [ ] args , Method [ ] methods ) { Method bestMatch = null ; Object [ ] tempArgs = new Object [ args . length ] ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method currentMethod = methods [ i ] ; if ( name . equals ( currentMethod . getName ( ) ) ) { Class [ ] parameters = currentMethod . getParameterTypes ( ) ; if ( parameters . length != args . length ) continue ; try { for ( int j = 0 ; j < parameters . length ; j ++ ) tempArgs [ j ] = NameSpace . getAssignableForm ( args [ j ] , parameters [ j ] ) ; System . arraycopy ( tempArgs , 0 , args , 0 , args . length ) ; return currentMethod ; } catch ( EvalError e ) { } } } return null ; } static Constructor findMostSpecificConstructor ( Class [ ] idealMatch , Constructor [ ] constructors ) { Class [ ] [ ] candidates = new Class [ constructors . length ] [ ] ; for ( int i = 0 ; i < candidates . length ; i ++ ) candidates [ i ] = constructors [ i ] . getParameterTypes ( ) ; int match = findMostSpecificSignature ( idealMatch , candidates ) ; if ( match == - 1 ) return null ; else return constructors [ match ] ; } static Constructor findExtendedConstructor ( Object [ ] args , Constructor [ ] constructors ) { Constructor bestMatch = null ; Object [ ] tempArgs = new Object [ args . length ] ; for ( int i = 0 ; i < constructors . length ; i ++ ) { Constructor currentConstructor = constructors [ i ] ; Class [ ] parameters = currentConstructor . getParameterTypes ( ) ; if ( parameters . length != args . length ) continue ; try { for ( int j = 0 ; j < parameters . length ; j ++ ) tempArgs [ j ] = NameSpace . getAssignableForm ( args [ j ] , parameters [ j ] ) ; System . arraycopy ( tempArgs , 0 , args , 0 , args . length ) ; return currentConstructor ; } catch ( EvalError e ) { } } return null ; } static int findMostSpecificSignature ( Class [ ] idealMatch , Class [ ] [ ] candidates ) { Class [ ] bestMatch = null ; int bestMatchIndex = - 1 ; for ( int i = 0 ; i < candidates . length ; i ++ ) { Class [ ] targetMatch = candidates [ i ] ; if ( isAssignable ( idealMatch , targetMatch ) && ( ( bestMatch == null ) || isAssignable ( targetMatch , bestMatch ) ) ) { bestMatch = targetMatch ; bestMatchIndex = i ; } } if ( bestMatch != null ) { return bestMatchIndex ; } else { Interpreter . debug ( "no match found" ) ; return - 1 ; } } static boolean isAssignable ( Class [ ] from , Class [ ] to ) { if ( from == null ) from = new Class [ 0 ] ; if ( to == null ) to = new Class [ 0 ] ; if ( from . length != to . length ) return false ; for ( int i = 0 ; i < from . length ; i ++ ) { if ( to [ i ] == null ) continue ; if ( from [ i ] == null ) { if ( ! ( to [ i ] . isPrimitive ( ) ) ) continue ; else return false ; } if ( ! isAssignableFrom ( to [ i ] , from [ i ] ) ) return false ; } return true ; } static boolean isAssignableFrom ( Class lhs , Class rhs ) { if ( lhs . isPrimitive ( ) && rhs . isPrimitive ( ) ) { if ( lhs == rhs ) return true ; if ( ( rhs == Byte . TYPE ) && ( lhs == Short . TYPE || lhs == Integer . TYPE || lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Short . TYPE ) && ( lhs == Integer . TYPE || lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Character . TYPE ) && ( lhs == Integer . TYPE || lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Integer . TYPE ) && ( lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Long . TYPE ) && ( lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Float . TYPE ) && ( lhs == Double . TYPE ) ) return true ; } else if ( lhs . isAssignableFrom ( rhs ) ) return true ; return false ; } private static String accessorName ( String getorset , String propName ) { return getorset + String . valueOf ( Character . toUpperCase ( propName . charAt ( 0 ) ) ) + propName . substring ( 1 ) ; } public static boolean hasObjectPropertyGetter ( Class clas , String propName ) { String getterName = accessorName ( "get" , propName ) ; try { clas . getMethod ( getterName , new Class [ 0 ] ) ; return true ; } catch ( NoSuchMethodException e ) { return false ; } } public static boolean hasObjectPropertySetter ( Class clas , String propName ) { String setterName = accessorName ( "set" , propName ) ; Class [ ] sig = new Class [ ] { clas } ; Method [ ] methods = clas . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) if ( methods [ i ] . getName ( ) . equals ( setterName ) ) return true ; return false ; } public static Object getObjectProperty ( Object obj , String propName ) throws ReflectError { String accessorName = accessorName ( "get" , propName ) ; Object [ ] args = new Object [ ] { } ; Interpreter . debug ( "property access: " ) ; try { try { return invokeObjectMethod ( null , obj , accessorName , args , null ) ; } catch ( EvalError e ) { throw new ReflectError ( "getter: " + e ) ; } } catch ( InvocationTargetException e ) { throw new ReflectError ( "Property accessor threw exception:" + e ) ; } } public static void setObjectProperty ( Object obj , String propName , Object value ) throws ReflectError , EvalError { String accessorName = accessorName ( "set" , propName ) ; Object [ ] args = new Object [ ] { value } ; Interpreter . debug ( "property access: " ) ; try { invokeObjectMethod ( null , obj , accessorName , args , null ) ; } catch ( InvocationTargetException e ) { throw new EvalError ( "Property accessor threw exception!" ) ; } } public static String normalizeClassName ( Class type ) { if ( ! type . isArray ( ) ) return type . getName ( ) ; StringBuffer className = new StringBuffer ( ) ; try { className . append ( getArrayBaseType ( type ) . getName ( ) ) ; for ( int i = 0 ; i < getArrayDimensions ( type ) ; i ++ ) className . append ( "[]" ) ; } catch ( Exception e ) { } return className . toString ( ) ; } public static int getArrayDimensions ( Class arrayClass ) { if ( ! arrayClass . isArray ( ) ) return 0 ; return arrayClass . getName ( ) . lastIndexOf ( '[' ) + 1 ; } public static Class getArrayBaseType ( Class arrayClass ) throws ReflectError { if ( ! arrayClass . isArray ( ) ) throw new ReflectError ( "The class is not an array." ) ; return arrayClass . getComponentType ( ) ; } } 	0	['37', '1', '0', '24', '111', '666', '12', '15', '14', '2', '1616', '0', '0', '0', '0.153846154', '0', '0', '42.67567568', '30', '3.1622', '0']
package org . gjt . sp . jedit . buffer ; import javax . swing . text . Segment ; public class ContentManager { public ContentManager ( ) { text = new char [ 1024 ] ; } public final int getLength ( ) { return length ; } public String getText ( int start , int len ) { if ( start >= gapStart ) return new String ( text , start + gapEnd - gapStart , len ) ; else if ( start + len <= gapStart ) return new String ( text , start , len ) ; else { return new String ( text , start , gapStart - start ) . concat ( new String ( text , gapEnd , start + len - gapStart ) ) ; } } public void getText ( int start , int len , Segment seg ) { if ( start >= gapStart ) { seg . array = text ; seg . offset = start + gapEnd - gapStart ; seg . count = len ; } else if ( start + len <= gapStart ) { seg . array = text ; seg . offset = start ; seg . count = len ; } else { seg . array = new char [ len ] ; System . arraycopy ( text , start , seg . array , 0 , gapStart - start ) ; System . arraycopy ( text , gapEnd , seg . array , gapStart - start , len + start - gapStart ) ; seg . offset = 0 ; seg . count = len ; } } public void insert ( int start , String str ) { int len = str . length ( ) ; moveGapStart ( start ) ; if ( gapEnd - gapStart < len ) { ensureCapacity ( length + len + 1024 ) ; moveGapEnd ( start + len + 1024 ) ; } str . getChars ( 0 , len , text , start ) ; gapStart += len ; length += len ; } public void insert ( int start , Segment seg ) { moveGapStart ( start ) ; if ( gapEnd - gapStart < seg . count ) { ensureCapacity ( length + seg . count + 1024 ) ; moveGapEnd ( start + seg . count + 1024 ) ; } System . arraycopy ( seg . array , seg . offset , text , start , seg . count ) ; gapStart += seg . count ; length += seg . count ; } public void _setContent ( char [ ] text , int length ) { this . text = text ; this . gapStart = this . gapEnd = 0 ; this . length = length ; } public void remove ( int start , int len ) { moveGapStart ( start ) ; gapEnd += len ; length -= len ; } private char [ ] text ; private int gapStart ; private int gapEnd ; private int length ; private void moveGapStart ( int newStart ) { int newEnd = gapEnd + ( newStart - gapStart ) ; if ( newStart == gapStart ) { } else if ( newStart > gapStart ) { System . arraycopy ( text , gapEnd , text , gapStart , newStart - gapStart ) ; } else if ( newStart < gapStart ) { System . arraycopy ( text , newStart , text , newEnd , gapStart - newStart ) ; } gapStart = newStart ; gapEnd = newEnd ; } private void moveGapEnd ( int newEnd ) { System . arraycopy ( text , gapEnd , text , newEnd , length - gapStart ) ; gapEnd = newEnd ; } private void ensureCapacity ( int capacity ) { if ( capacity >= text . length ) { char [ ] textN = new char [ capacity * 2 ] ; System . arraycopy ( text , 0 , textN , 0 , length + ( gapEnd - gapStart ) ) ; text = textN ; } } } 	0	['11', '1', '0', '2', '17', '0', '2', '0', '8', '0.225', '387', '1', '0', '0', '0.436363636', '0', '0', '33.81818182', '4', '1.8182', '0']
package bsh ; public class ClassPathException extends EvalError { public ClassPathException ( String msg ) { super ( msg ) ; } } 	0	['1', '4', '0', '3', '2', '0', '2', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package bsh ; class BSHThrowStatement extends SimpleNode { BSHThrowStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object obj = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( ! ( obj instanceof Exception ) ) throw new EvalError ( "Expression in 'throw' must be Exception type" , this ) ; throw new TargetError ( ( Exception ) obj , this ) ; } } 	0	['2', '2', '0', '7', '7', '1', '1', '6', '1', '2', '30', '0', '0', '0.947368421', '0.625', '1', '1', '14', '1', '0.5', '0']
package bsh ; class BSHCastExpression extends SimpleNode { public BSHCastExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { NameSpace namespace = callstack . top ( ) ; Class toType = ( ( BSHType ) jjtGetChild ( 0 ) ) . getType ( namespace ) ; SimpleNode expression = ( SimpleNode ) jjtGetChild ( 1 ) ; Object fromValue = expression . eval ( callstack , interpreter ) ; Class fromType = fromValue . getClass ( ) ; try { return castObject ( fromValue , toType ) ; } catch ( EvalError e ) { e . reThrow ( this ) ; throw new InterpreterError ( "can't happen" ) ; } } public static Object castObject ( Object fromValue , Class toType ) throws EvalError { Class fromType = fromValue . getClass ( ) ; Object result = null ; if ( toType . isPrimitive ( ) ) if ( fromValue instanceof Primitive ) result = castPrimitive ( ( Primitive ) fromValue , toType ) ; else castError ( fromValue . getClass ( ) , toType ) ; else if ( fromValue instanceof Primitive ) result = castPrimitive ( ( Primitive ) fromValue , toType ) ; else if ( Capabilities . canGenerateInterfaces ( ) && ( fromValue instanceof bsh . This ) && toType . isInterface ( ) ) result = ( ( bsh . This ) fromValue ) . getInterface ( toType ) ; else if ( toType . isInstance ( fromValue ) ) result = fromValue ; else castError ( fromType , toType ) ; if ( result == null ) throw new InternalError ( "bad construct somewhere..." ) ; return result ; } public static void castError ( Class from , Class to ) throws EvalError { castError ( Reflect . normalizeClassName ( from ) , Reflect . normalizeClassName ( to ) ) ; } public static void castError ( String from , String to ) throws EvalError { Exception cce = new ClassCastException ( "Illegal cast. Cannot cast " + from + " to " + to ) ; throw new TargetError ( "Cast" , cce ) ; } public static Primitive castPrimitive ( Primitive primValue , Class toType ) throws EvalError { if ( primValue == Primitive . VOID ) castError ( "void value" , Reflect . normalizeClassName ( toType ) ) ; Object value = primValue . getValue ( ) ; Class fromType = primValue . getType ( ) ; if ( ! toType . isPrimitive ( ) ) if ( primValue != Primitive . NULL ) castError ( "primitive value" , "object type:" + toType ) ; else return primValue ; if ( fromType == Boolean . TYPE ) { if ( toType != Boolean . TYPE ) castError ( fromType , toType ) ; else return primValue ; } if ( value instanceof Character ) value = new Integer ( ( ( Character ) value ) . charValue ( ) ) ; if ( value instanceof Number ) { Number number = ( Number ) value ; if ( toType == Byte . TYPE ) value = new Primitive ( number . byteValue ( ) ) ; else if ( toType == Short . TYPE ) value = new Primitive ( number . shortValue ( ) ) ; else if ( toType == Character . TYPE ) value = new Primitive ( ( char ) number . intValue ( ) ) ; else if ( toType == Integer . TYPE ) value = new Primitive ( number . intValue ( ) ) ; else if ( toType == Long . TYPE ) value = new Primitive ( number . longValue ( ) ) ; else if ( toType == Float . TYPE ) value = new Primitive ( number . floatValue ( ) ) ; else if ( toType == Double . TYPE ) value = new Primitive ( number . doubleValue ( ) ) ; else castError ( fromType , toType ) ; return ( Primitive ) value ; } throw new EvalError ( "unknown type in cast" ) ; } } 	0	['6', '2', '0', '16', '45', '15', '3', '13', '6', '2', '280', '0', '0', '0.782608696', '0.229166667', '1', '1', '45.66666667', '1', '0.8333', '0']
package com . microstar . xml ; import com . microstar . xml . XmlHandler ; import com . microstar . xml . XmlException ; import java . io . Reader ; public class HandlerBase implements XmlHandler { public void startDocument ( ) throws java . lang . Exception { } public void endDocument ( ) throws java . lang . Exception { } public Object resolveEntity ( String publicId , String systemId ) throws java . lang . Exception { return null ; } public void startExternalEntity ( String systemId ) throws java . lang . Exception { } public void endExternalEntity ( String systemId ) throws java . lang . Exception { } public void doctypeDecl ( String name , String publicId , String systemId ) throws java . lang . Exception { } public void attribute ( String aname , String value , boolean isSpecified ) throws java . lang . Exception { } public void startElement ( String elname ) throws java . lang . Exception { } public void endElement ( String elname ) throws java . lang . Exception { } public void charData ( char ch [ ] , int start , int length ) throws java . lang . Exception { } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws java . lang . Exception { } public void processingInstruction ( String target , String data ) throws java . lang . Exception { } public void error ( String message , String systemId , int line , int column ) throws XmlException , java . lang . Exception { throw new XmlException ( message , systemId , line , column ) ; } } 	0	['14', '1', '7', '9', '16', '91', '7', '2', '14', '2', '38', '0', '0', '0', '0.414285714', '0', '0', '1.714285714', '1', '0.9286', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . * ; public class ViewUpdate extends EBMessage { public static final Object CREATED = "CREATED" ; public static final Object CLOSED = "CLOSED" ; public static final Object EDIT_PANE_CHANGED = "EDIT_PANE_CHANGED" ; public ViewUpdate ( View view , Object what ) { super ( view ) ; if ( what == null ) throw new NullPointerException ( "What must be non-null" ) ; this . what = what ; } public Object getWhat ( ) { return what ; } public View getView ( ) { return ( View ) getSource ( ) ; } public String paramString ( ) { return "what=" + what + "," + super . paramString ( ) ; } private Object what ; } 	0	['5', '2', '0', '6', '13', '4', '4', '3', '4', '0.875', '52', '0.25', '0', '0.5', '0.5', '1', '1', '8.6', '1', '0.6', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . * ; import java . util . Random ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class TipOfTheDay extends EnhancedDialog { public TipOfTheDay ( View view ) { super ( view , jEdit . getProperty ( "tip.title" ) , false ) ; JPanel content = new JPanel ( new BorderLayout ( 12 , 12 ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "tip.caption" ) ) ; label . setFont ( new Font ( "SansSerif" , Font . PLAIN , 24 ) ) ; label . setForeground ( UIManager . getColor ( "Button.foreground" ) ) ; content . add ( BorderLayout . NORTH , label ) ; tipText = new JEditorPane ( ) ; tipText . setEditable ( false ) ; tipText . setContentType ( "text/html" ) ; nextTip ( ) ; JScrollPane scroller = new JScrollPane ( tipText ) ; scroller . setPreferredSize ( new Dimension ( 150 , 150 ) ) ; content . add ( BorderLayout . CENTER , scroller ) ; ActionHandler actionHandler = new ActionHandler ( ) ; Box buttons = new Box ( BoxLayout . X_AXIS ) ; showNextTime = new JCheckBox ( jEdit . getProperty ( "tip.show-next-time" ) , jEdit . getBooleanProperty ( "tip.show" ) ) ; showNextTime . addActionListener ( actionHandler ) ; buttons . add ( showNextTime ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( Box . createGlue ( ) ) ; nextTip = new JButton ( jEdit . getProperty ( "tip.next-tip" ) ) ; nextTip . addActionListener ( actionHandler ) ; buttons . add ( nextTip ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( actionHandler ) ; buttons . add ( close ) ; content . getRootPane ( ) . setDefaultButton ( close ) ; Dimension dim = nextTip . getPreferredSize ( ) ; dim . width = Math . max ( dim . width , close . getPreferredSize ( ) . width ) ; nextTip . setPreferredSize ( dim ) ; close . setPreferredSize ( dim ) ; content . add ( BorderLayout . SOUTH , buttons ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } private JCheckBox showNextTime ; private JButton nextTip , close ; private JEditorPane tipText ; private int currentTip = - 1 ; private void nextTip ( ) { File [ ] tips = new File ( MiscUtilities . constructPath ( jEdit . getJEditHome ( ) , "doc" , "tips" ) ) . listFiles ( ) ; if ( tips == null || tips . length == 0 ) { tipText . setText ( jEdit . getProperty ( "tip.not-found" ) ) ; return ; } int count = tips . length ; int tipToShow = currentTip ; while ( tipToShow == currentTip || ! tips [ tipToShow ] . getName ( ) . endsWith ( ".html" ) ) tipToShow = Math . abs ( new Random ( ) . nextInt ( ) ) % count ; try { tipText . setPage ( tips [ tipToShow ] . toURL ( ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == showNextTime ) { jEdit . setBooleanProperty ( "tip.show" , showNextTime . isSelected ( ) ) ; } else if ( source == nextTip ) nextTip ( ) ; else if ( source == close ) dispose ( ) ; } } } 	0	['8', '7', '0', '6', '60', '20', '2', '6', '3', '0.8', '294', '1', '0', '0.989441931', '0.375', '2', '5', '35.125', '5', '1.375', '0']
package bsh ; class BSHUnaryExpression extends SimpleNode implements ParserConstants { public int kind ; public boolean postfix = false ; BSHUnaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode node = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( node instanceof BSHLHSPrimaryExpression ) return lhsUnaryOperation ( ( ( BSHLHSPrimaryExpression ) node ) . toLHS ( callstack , interpreter ) ) ; else return unaryOperation ( node . eval ( callstack , interpreter ) , kind ) ; } private Object lhsUnaryOperation ( LHS lhs ) throws EvalError { if ( Interpreter . DEBUG ) Interpreter . debug ( "lhsUnaryOperation" ) ; Object prevalue , postvalue ; prevalue = lhs . getValue ( ) ; postvalue = unaryOperation ( prevalue , kind ) ; Object retVal ; if ( postfix ) retVal = prevalue ; else retVal = postvalue ; lhs . assign ( postvalue ) ; return retVal ; } private Object unaryOperation ( Object op , int kind ) throws EvalError { if ( op instanceof Boolean || op instanceof Character || op instanceof Number ) return primitiveWrapperUnaryOperation ( op , kind ) ; if ( ! ( op instanceof Primitive ) ) throw new EvalError ( "Unary operation " + tokenImage [ kind ] + " inappropriate for object" , this ) ; return Primitive . unaryOperation ( ( Primitive ) op , kind ) ; } private Object primitiveWrapperUnaryOperation ( Object val , int kind ) throws EvalError { Class operandType = val . getClass ( ) ; Object operand = Primitive . promoteToInteger ( val ) ; if ( operand instanceof Boolean ) return new Boolean ( Primitive . booleanUnaryOperation ( ( Boolean ) operand , kind ) ) ; else if ( operand instanceof Integer ) { int result = Primitive . intUnaryOperation ( ( Integer ) operand , kind ) ; if ( kind == INCR || kind == DECR ) { if ( operandType == Byte . TYPE ) return new Byte ( ( byte ) result ) ; if ( operandType == Short . TYPE ) return new Short ( ( short ) result ) ; if ( operandType == Character . TYPE ) return new Character ( ( char ) result ) ; } return new Integer ( result ) ; } else if ( operand instanceof Long ) return new Long ( Primitive . longUnaryOperation ( ( Long ) operand , kind ) ) ; else if ( operand instanceof Float ) return new Float ( Primitive . floatUnaryOperation ( ( Float ) operand , kind ) ) ; else if ( operand instanceof Double ) return new Double ( Primitive . doubleUnaryOperation ( ( Double ) operand , kind ) ) ; else throw new InterpreterError ( "An error occurred.  Please call technical support." ) ; } } 	0	['5', '2', '0', '11', '33', '6', '1', '10', '1', '0.625', '206', '0', '0', '0.818181818', '0.433333333', '1', '1', '39.8', '1', '0.8', '0']
package bsh ; class BSHReturnStatement extends SimpleNode implements ParserConstants { public int kind ; BSHReturnStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object value ; if ( jjtGetNumChildren ( ) > 0 ) value = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; else value = Primitive . VOID ; return new ReturnControl ( kind , value ) ; } } 	0	['2', '2', '0', '9', '7', '1', '1', '8', '1', '1', '28', '0', '0', '0.947368421', '0.625', '1', '1', '12.5', '1', '0.5', '0']
package gnu . regexp ; final class RETokenBackRef extends REToken { private int num ; private boolean insens ; RETokenBackRef ( int subIndex , int num , boolean insens ) { super ( subIndex ) ; this . num = num ; this . insens = insens ; } boolean match ( CharIndexed input , REMatch mymatch ) { int b , e ; b = mymatch . start [ num ] ; e = mymatch . end [ num ] ; if ( ( b == - 1 ) || ( e == - 1 ) ) return false ; for ( int i = b ; i < e ; i ++ ) { if ( input . charAt ( mymatch . index + i - b ) != input . charAt ( i ) ) { return false ; } } mymatch . index += e - b ; return next ( input , mymatch ) ; } void dump ( StringBuffer os ) { os . append ( '\\' ) . append ( num ) ; } } 	0	['3', '2', '0', '4', '8', '0', '1', '3', '0', '0.5', '77', '1', '0', '0.777777778', '0.444444444', '1', '2', '24', '5', '2', '0']
package org . gjt . sp . jedit . textarea ; public interface ScrollListener extends java . util . EventListener { void scrolledVertically ( JEditTextArea textArea ) ; void scrolledHorizontally ( JEditTextArea textArea ) ; } 	0	['2', '1', '0', '3', '2', '1', '3', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package gnu . regexp ; import java . io . Serializable ; class CharIndexedCharArray implements CharIndexed , Serializable { private char [ ] s ; private int anchor ; CharIndexedCharArray ( char [ ] str , int index ) { s = str ; anchor = index ; } public char charAt ( int index ) { int pos = anchor + index ; return ( ( pos < s . length ) && ( pos >= 0 ) ) ? s [ pos ] : OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( anchor < s . length ) ; } public boolean move ( int index ) { return ( ( anchor += index ) < s . length ) ; } } 	0	['4', '1', '0', '2', '5', '0', '1', '1', '3', '0', '59', '1', '0', '0', '0.666666667', '0', '0', '13.25', '3', '1.75', '0']
package bsh ; import java . lang . reflect . InvocationTargetException ; import java . io . PrintStream ; public class TargetError extends EvalError { Throwable target ; boolean inNativeCode ; public TargetError ( String msg , Throwable t , SimpleNode node , boolean inNativeCode ) { super ( msg , node ) ; target = t ; this . inNativeCode = inNativeCode ; } public TargetError ( Throwable t , SimpleNode node ) { this ( "TargetError" , t , node , false ) ; } public TargetError ( String s , Throwable t ) { this ( s , t , null , false ) ; } public Throwable getTarget ( ) { if ( target instanceof InvocationTargetException ) return ( ( InvocationTargetException ) target ) . getTargetException ( ) ; else return target ; } public String toString ( ) { return super . toString ( ) + "\nTarget exception: " + printTargetError ( target ) ; } public void printStackTrace ( ) { printStackTrace ( false , System . err ) ; } public void printStackTrace ( PrintStream out ) { printStackTrace ( false , out ) ; } public void printStackTrace ( boolean debug , PrintStream out ) { if ( debug ) { super . printStackTrace ( out ) ; System . out . println ( "--- Target Stack Trace ---" ) ; } target . printStackTrace ( out ) ; } public String printTargetError ( Throwable t ) { String s = target . toString ( ) ; if ( Capabilities . canGenerateInterfaces ( ) ) s += "\n" + xPrintTargetError ( t ) ; return s ; } public String xPrintTargetError ( Throwable t ) { String getTarget = "import java.lang.reflect.UndeclaredThrowableException;" + "result=\"\";" + "while ( target instanceof UndeclaredThrowableException ) {" + "	target=target.getUndeclaredThrowable(); " + "	result+=\"Nested: \"+target.toString();" + "}" + "return result;" ; Interpreter i = new Interpreter ( ) ; try { i . set ( "target" , t ) ; return ( String ) i . eval ( getTarget ) ; } catch ( EvalError e ) { throw new InterpreterError ( "xprintarget: " + e . toString ( ) ) ; } } public boolean inNativeCode ( ) { return inNativeCode ; } } 	0	['11', '4', '0', '18', '26', '33', '14', '5', '11', '0.45', '141', '0', '0', '0.764705882', '0.363636364', '1', '2', '11.63636364', '2', '1', '0']
package org . gjt . sp . jedit . print ; import java . awt . print . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . jedit . io . VFSManager ; public class BufferPrinter1_3 { private static PrinterJob getPrintJob ( ) { job = PrinterJob . getPrinterJob ( ) ; int orientation = jEdit . getIntegerProperty ( "print.orientation" , PageFormat . PORTRAIT ) ; double width = jEdit . getDoubleProperty ( "print.width" , 0 ) ; double height = jEdit . getDoubleProperty ( "print.height" , 0 ) ; double x = jEdit . getDoubleProperty ( "print.x" , 0 ) ; double y = jEdit . getDoubleProperty ( "print.y" , 0 ) ; double pagewidth = jEdit . getDoubleProperty ( "print.pagewidth" , 0 ) ; double pageheight = jEdit . getDoubleProperty ( "print.pageheight" , 0 ) ; format = job . defaultPage ( ) ; if ( width != 0 && height != 0 ) { Paper pap = format . getPaper ( ) ; pap . setImageableArea ( x , y , width , height ) ; pap . setSize ( pagewidth , pageheight ) ; format . setPaper ( pap ) ; } format . setOrientation ( orientation ) ; return job ; } public static void pageSetup ( View view ) { job = getPrintJob ( ) ; PageFormat newFormat = job . pageDialog ( format ) ; if ( newFormat != null ) { format = newFormat ; jEdit . setIntegerProperty ( "print.orientation" , format . getOrientation ( ) ) ; Paper paper = format . getPaper ( ) ; jEdit . setDoubleProperty ( "print.width" , paper . getImageableWidth ( ) ) ; jEdit . setDoubleProperty ( "print.height" , paper . getImageableHeight ( ) ) ; jEdit . setDoubleProperty ( "print.x" , paper . getImageableX ( ) ) ; jEdit . setDoubleProperty ( "print.y" , paper . getImageableY ( ) ) ; jEdit . setDoubleProperty ( "print.pagewidth" , paper . getWidth ( ) ) ; jEdit . setDoubleProperty ( "print.pageheight" , paper . getHeight ( ) ) ; } } public static void print ( final View view , final Buffer buffer , boolean selection ) { job = getPrintJob ( ) ; job . setJobName ( buffer . getPath ( ) ) ; boolean header = jEdit . getBooleanProperty ( "print.header" ) ; boolean footer = jEdit . getBooleanProperty ( "print.footer" ) ; boolean lineNumbers = jEdit . getBooleanProperty ( "print.lineNumbers" ) ; boolean color = jEdit . getBooleanProperty ( "print.color" ) ; Font font = jEdit . getFontProperty ( "print.font" ) ; BufferPrintable printable = new BufferPrintable ( job , null , view , buffer , font , header , footer , lineNumbers , color ) ; job . setPrintable ( printable , format ) ; if ( ! job . printDialog ( ) ) return ; VFSManager . runInWorkThread ( printable ) ; } public static PageFormat getPageFormat ( ) { return format ; } private static PageFormat format ; private static PrinterJob job ; } 	0	['5', '1', '0', '5', '33', '0', '0', '5', '4', '0.375', '161', '1', '0', '0', '0.25', '0', '0', '30.8', '3', '1.6', '0']
package gnu . regexp ; import java . io . InputStream ; import java . io . BufferedInputStream ; import java . io . IOException ; class CharIndexedInputStream implements CharIndexed { private static final int BUFFER_INCREMENT = 1024 ; private static final int UNKNOWN = Integer . MAX_VALUE ; private BufferedInputStream br ; private int index = - 1 ; private int bufsize = BUFFER_INCREMENT ; private int end = UNKNOWN ; private char cached = OUT_OF_BOUNDS ; private char [ ] lookBehind = new char [ ] { OUT_OF_BOUNDS , OUT_OF_BOUNDS } ; CharIndexedInputStream ( InputStream str , int index ) { if ( str instanceof BufferedInputStream ) br = ( BufferedInputStream ) str ; else br = new BufferedInputStream ( str , BUFFER_INCREMENT ) ; next ( ) ; if ( index > 0 ) move ( index ) ; } private boolean next ( ) { if ( end == 1 ) return false ; end -- ; try { if ( index != - 1 ) { br . reset ( ) ; } int i = br . read ( ) ; br . mark ( bufsize ) ; if ( i == - 1 ) { end = 1 ; cached = OUT_OF_BOUNDS ; return false ; } cached = ( char ) i ; index = 1 ; } catch ( IOException e ) { e . printStackTrace ( ) ; cached = OUT_OF_BOUNDS ; return false ; } return true ; } public char charAt ( int index ) { if ( index == 0 ) { return cached ; } else if ( index >= end ) { return OUT_OF_BOUNDS ; } else if ( index == - 1 ) { return lookBehind [ 0 ] ; } else if ( index == - 2 ) { return lookBehind [ 1 ] ; } else if ( index < - 2 ) { return OUT_OF_BOUNDS ; } else if ( index >= bufsize ) { try { while ( bufsize <= index ) bufsize += BUFFER_INCREMENT ; br . reset ( ) ; br . mark ( bufsize ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } else if ( this . index != index ) { try { br . reset ( ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } char ch = OUT_OF_BOUNDS ; try { int i = br . read ( ) ; this . index = index + 1 ; if ( i == - 1 ) { end = index ; return ch ; } ch = ( char ) i ; } catch ( IOException ie ) { } return ch ; } public boolean move ( int index ) { boolean retval = true ; while ( retval && ( index -- > 0 ) ) retval = next ( ) ; return retval ; } public boolean isValid ( ) { return ( cached != OUT_OF_BOUNDS ) ; } } 	0	['5', '1', '0', '3', '12', '0', '2', '1', '3', '0.53125', '256', '1', '0', '0', '0.6', '0', '0', '48.6', '10', '3.8', '0']
package bsh ; import java . lang . reflect . Array ; import java . lang . reflect . InvocationTargetException ; class BSHAllocationExpression extends SimpleNode { BSHAllocationExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode type = ( SimpleNode ) jjtGetChild ( 0 ) ; SimpleNode args = ( SimpleNode ) jjtGetChild ( 1 ) ; if ( type instanceof BSHAmbiguousName ) { BSHAmbiguousName name = ( BSHAmbiguousName ) type ; if ( args instanceof BSHArguments ) return objectAllocation ( name , ( BSHArguments ) args , callstack , interpreter ) ; else return objectArrayAllocation ( name , ( BSHArrayDimensions ) args , callstack , interpreter ) ; } else return primitiveArrayAllocation ( ( BSHPrimitiveType ) type , ( BSHArrayDimensions ) args , callstack , interpreter ) ; } private Object objectAllocation ( BSHAmbiguousName nameNode , BSHArguments argumentsNode , CallStack callstack , Interpreter interpreter ) throws EvalError { NameSpace namespace = callstack . top ( ) ; Class type = nameNode . toClass ( namespace ) ; Object [ ] args = argumentsNode . getArguments ( callstack , interpreter ) ; if ( args == null ) throw new EvalError ( "Trying to new a class...?" , this ) ; boolean hasBody = jjtGetNumChildren ( ) > 2 ; if ( hasBody ) { BSHBlock body = ( BSHBlock ) jjtGetChild ( 2 ) ; return constructWithBody ( type , args , body , callstack , interpreter ) ; } else return constructObject ( type , args ) ; } private Object constructObject ( Class type , Object [ ] args ) throws EvalError { try { return Reflect . constructObject ( type , args ) ; } catch ( ReflectError e ) { throw new EvalError ( "Constructor error: " + e . getMessage ( ) , this ) ; } catch ( InvocationTargetException e ) { Interpreter . debug ( "The constructor threw an exception:\n\t" + e . getTargetException ( ) ) ; throw new TargetError ( "Object constructor" , e . getTargetException ( ) , this , true ) ; } } private Object constructWithBody ( Class type , Object [ ] args , BSHBlock body , CallStack callstack , Interpreter interpreter ) throws EvalError { if ( ! type . isInterface ( ) ) throw new EvalError ( "BeanShell cannot extend class types: " + type ) ; NameSpace namespace = callstack . top ( ) ; NameSpace local = new NameSpace ( namespace , "anonymous block object" ) ; callstack . push ( local ) ; body . eval ( callstack , interpreter , true ) ; callstack . pop ( ) ; return local . getThis ( interpreter ) . getInterface ( type ) ; } private Object objectArrayAllocation ( BSHAmbiguousName nameNode , BSHArrayDimensions dimensionsNode , CallStack callstack , Interpreter interpreter ) throws EvalError { NameSpace namespace = callstack . top ( ) ; Class type = nameNode . toClass ( namespace ) ; if ( type == null ) throw new EvalError ( "Class " + nameNode . getName ( namespace ) + " not found." , this ) ; Object result = dimensionsNode . eval ( type , callstack , interpreter ) ; if ( result != Primitive . VOID ) return result ; else return arrayNewInstance ( type , dimensionsNode ) ; } private Object primitiveArrayAllocation ( BSHPrimitiveType typeNode , BSHArrayDimensions dimensionsNode , CallStack callstack , Interpreter interpreter ) throws EvalError { Class type = typeNode . getType ( ) ; Object result = dimensionsNode . eval ( type , callstack , interpreter ) ; if ( result != Primitive . VOID ) return result ; return arrayNewInstance ( type , dimensionsNode ) ; } private Object arrayNewInstance ( Class type , BSHArrayDimensions dimensionsNode ) throws EvalError { try { return Array . newInstance ( type , dimensionsNode . dimensions ) ; } catch ( NegativeArraySizeException e1 ) { throw new TargetError ( "Negative Array Size" , e1 ) ; } catch ( Exception e ) { throw new EvalError ( "Can't construct primitive array: " + e . getMessage ( ) , this ) ; } } } 	0	['8', '2', '0', '18', '38', '28', '1', '17', '1', '2', '273', '0', '0', '0.72', '0.363636364', '1', '1', '33.125', '1', '0.875', '0']
package bsh ; class BSHMethodInvocation extends SimpleNode { BSHMethodInvocation ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { NameSpace namespace = callstack . top ( ) ; Name name = ( ( BSHAmbiguousName ) jjtGetChild ( 0 ) ) . getName ( namespace ) ; Object [ ] args = ( ( BSHArguments ) jjtGetChild ( 1 ) ) . getArguments ( callstack , interpreter ) ; try { return name . invokeMethod ( interpreter , args , callstack , this ) ; } catch ( ReflectError e ) { throw new EvalError ( "Error in method invocation: " + e . getMessage ( ) , this ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { String msg = "Method Invocation " + name ; Throwable te = e . getTargetException ( ) ; boolean isNative = true ; if ( te instanceof EvalError ) if ( te instanceof TargetError ) isNative = ( ( TargetError ) te ) . inNativeCode ( ) ; else isNative = false ; throw new TargetError ( msg , te , this , isNative ) ; } catch ( EvalError ee ) { ee . reThrow ( this ) ; throw new Error ( "should be unreachable..." ) ; } } } 	0	['2', '2', '0', '12', '19', '1', '1', '11', '1', '2', '91', '0', '0', '0.947368421', '0.625', '1', '1', '44.5', '1', '0.5', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . * ; public class VFSUpdate extends EBMessage { public VFSUpdate ( String path ) { super ( null ) ; if ( path == null ) throw new NullPointerException ( "Path must be non-null" ) ; this . path = path ; } public String getPath ( ) { return path ; } public String paramString ( ) { return "path=" + path + "," + super . paramString ( ) ; } private String path ; } 	0	['3', '2', '0', '6', '9', '0', '4', '2', '3', '0', '36', '1', '0', '0.6', '0.666666667', '1', '1', '10.66666667', '1', '0.6667', '0']
package bsh ; class BSHReturnType extends SimpleNode { public boolean isVoid ; BSHReturnType ( int id ) { super ( id ) ; } public Object getReturnType ( NameSpace namespace ) throws EvalError { if ( isVoid ) return Primitive . VOID ; else return ( ( BSHType ) jjtGetChild ( 0 ) ) . getType ( namespace ) ; } } 	0	['2', '2', '0', '8', '5', '1', '2', '6', '1', '1', '19', '0', '0', '0.947368421', '0.666666667', '0', '0', '8', '1', '0.5', '0']
package org . gjt . sp . jedit . search ; import javax . swing . text . * ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . Buffer ; public class HyperSearchResult { public String path ; public Buffer buffer ; public int line ; public int start ; public int end ; public Position startPos ; public Position endPos ; public String str ; public HyperSearchResult ( Buffer buffer , int line , int start , int end ) { path = buffer . getPath ( ) ; this . line = line ; this . start = start ; this . end = end ; if ( ! buffer . isTemporary ( ) ) bufferOpened ( buffer ) ; str = ( line + 1 ) + ": " + buffer . getLineText ( line ) . replace ( '\t' , ' ' ) . trim ( ) ; } public void bufferOpened ( Buffer buffer ) { this . buffer = buffer ; startPos = buffer . createPosition ( Math . min ( buffer . getLength ( ) , start ) ) ; endPos = buffer . createPosition ( Math . min ( buffer . getLength ( ) , end ) ) ; } public void bufferClosed ( ) { buffer = null ; start = startPos . getOffset ( ) ; end = endPos . getOffset ( ) ; startPos = endPos = null ; } public Buffer getBuffer ( ) { if ( buffer == null ) buffer = jEdit . openFile ( null , path ) ; return buffer ; } public String toString ( ) { return str ; } } 	0	['5', '1', '0', '9', '20', '0', '6', '3', '5', '0.59375', '112', '0', '1', '0', '0.533333333', '0', '0', '19.8', '2', '1', '0']
package org . gjt . sp . jedit ; import bsh . BshMethod ; import org . gjt . sp . jedit . gui . BeanShellErrorDialog ; import org . gjt . sp . util . Log ; public class BeanShellAction extends EditAction { public BeanShellAction ( String name , String code , String isSelected , boolean noRepeat , boolean noRecord ) { super ( name ) ; this . code = code ; this . isSelected = isSelected ; this . noRepeat = noRepeat ; this . noRecord = noRecord ; sanitizedName = name . replace ( '.' , '_' ) . replace ( '-' , '_' ) ; if ( isSelected != null ) { String cachedIsSelectedName = "selected_" + sanitizedName ; try { cachedIsSelected = BeanShell . cacheBlock ( cachedIsSelectedName , isSelected , false ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; new BeanShellErrorDialog ( null , e ) ; } } } public void invoke ( View view ) { try { if ( cachedCode == null ) { String cachedCodeName = "action_" + sanitizedName ; cachedCode = BeanShell . cacheBlock ( cachedCodeName , code , false ) ; } BeanShell . runCachedBlock ( cachedCode , view , null ) ; } catch ( Throwable e ) { Log . log ( Log . ERROR , this , e ) ; new BeanShellErrorDialog ( view , e ) ; } } public boolean isToggle ( ) { return isSelected != null ; } public boolean isSelected ( View view ) { if ( isSelected == null ) return false ; try { return Boolean . TRUE . equals ( BeanShell . runCachedBlock ( cachedIsSelected , view , null ) ) ; } catch ( Throwable e ) { Log . log ( Log . ERROR , this , e ) ; new BeanShellErrorDialog ( view , e ) ; return false ; } } public boolean noRepeat ( ) { return noRepeat ; } public boolean noRecord ( ) { return noRecord ; } public String getCode ( ) { return code . trim ( ) ; } private boolean noRepeat ; private boolean noRecord ; private String code ; private String isSelected ; private BshMethod cachedCode ; private BshMethod cachedIsSelected ; private String sanitizedName ; } 	0	['7', '3', '0', '8', '18', '5', '1', '7', '7', '0.80952381', '153', '1', '2', '0.727272727', '0.392857143', '2', '2', '19.85714286', '2', '1.2857', '0']
package bsh ; public class BshMethod implements java . io . Serializable { BSHMethodDeclaration method ; NameSpace declaringNameSpace ; private Class [ ] argTypes ; BshMethod ( BSHMethodDeclaration method , NameSpace declaringNameSpace ) { this . method = method ; this . declaringNameSpace = declaringNameSpace ; } public Class [ ] getArgTypes ( ) { if ( argTypes == null ) argTypes = method . params . argTypes ; return argTypes ; } public String getName ( ) { return method . name ; } public Object invoke ( Object [ ] argValues , Interpreter interpreter , CallStack callstack ) throws EvalError { return invokeDeclaredMethod ( argValues , interpreter , callstack , null ) ; } Object invokeDeclaredMethod ( Object [ ] argValues , Interpreter interpreter , CallStack callstack , SimpleNode callerInfo ) throws EvalError { if ( argValues == null ) argValues = new Object [ ] { } ; if ( argValues . length != method . params . numArgs ) { try { String help = ( String ) declaringNameSpace . get ( "bsh.help." + method . name , interpreter ) ; interpreter . println ( help ) ; return Primitive . VOID ; } catch ( Exception e ) { throw new EvalError ( "Wrong number of arguments for local method: " + method . name , callerInfo ) ; } } NameSpace localNameSpace = new NameSpace ( declaringNameSpace , method . name ) ; localNameSpace . setNode ( callerInfo ) ; for ( int i = 0 ; i < method . params . numArgs ; i ++ ) { if ( method . params . argTypes [ i ] != null ) { try { argValues [ i ] = NameSpace . getAssignableForm ( argValues [ i ] , method . params . argTypes [ i ] ) ; } catch ( EvalError e ) { throw new EvalError ( "Invalid argument: " + "`" + method . params . argNames [ i ] + "'" + " for method: " + method . name + " : " + e . getMessage ( ) , callerInfo ) ; } localNameSpace . setTypedVariable ( method . params . argNames [ i ] , method . params . argTypes [ i ] , argValues [ i ] , false ) ; } else { if ( argValues [ i ] == Primitive . VOID ) throw new EvalError ( "Undefined variable or class name, parameter: " + method . params . argNames [ i ] + " to method: " + method . name , callerInfo ) ; else localNameSpace . setVariable ( method . params . argNames [ i ] , argValues [ i ] ) ; } } callstack . push ( localNameSpace ) ; Object ret = method . block . eval ( callstack , interpreter , true ) ; callstack . pop ( ) ; if ( ret instanceof ReturnControl ) { ReturnControl rs = ( ReturnControl ) ret ; if ( rs . kind == rs . RETURN ) ret = ( ( ReturnControl ) ret ) . value ; else throw new EvalError ( "continue or break in method body" , method ) ; } if ( method . returnType != null ) { if ( method . returnType == Primitive . VOID ) return method . returnType ; try { ret = NameSpace . getAssignableForm ( ret , ( Class ) method . returnType ) ; } catch ( EvalError e ) { throw new EvalError ( "Incorrect type returned from method: " + method . name + e . getMessage ( ) , method ) ; } } return ret ; } public String toString ( ) { return "Bsh Method: " + method . name ; } } 	0	['6', '1', '0', '18', '22', '0', '10', '10', '4', '0.533333333', '316', '0.333333333', '2', '0', '0.357142857', '0', '0', '51.16666667', '2', '1', '0']
package bsh ; class BSHImportDeclaration extends SimpleNode { public boolean importPackage ; public boolean superImport ; BSHImportDeclaration ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { if ( superImport ) NameSpace . doSuperImport ( ) ; else { NameSpace namespace = callstack . top ( ) ; String name = ( ( BSHAmbiguousName ) jjtGetChild ( 0 ) ) . getName ( namespace ) . value ; if ( importPackage ) namespace . importPackage ( name ) ; else namespace . importClass ( name ) ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '10', '9', '1', '1', '9', '1', '1', '36', '0', '0', '0.947368421', '0.625', '1', '1', '16', '1', '0.5', '0']
package bsh ; class BSHAssignment extends SimpleNode implements ParserConstants { public int operator ; BSHAssignment ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { BSHLHSPrimaryExpression lhsNode = ( BSHLHSPrimaryExpression ) jjtGetChild ( 0 ) ; if ( lhsNode == null ) throw new InterpreterError ( "Error, null LHSnode" ) ; LHS lhs = lhsNode . toLHS ( callstack , interpreter ) ; if ( lhs == null ) throw new InterpreterError ( "Error, null LHS" ) ; Object rhs = ( ( SimpleNode ) jjtGetChild ( 1 ) ) . eval ( callstack , interpreter ) ; if ( rhs == Primitive . VOID ) throw new EvalError ( "Void assignment." , this ) ; switch ( operator ) { case ASSIGN : try { return lhs . assign ( rhs ) ; } catch ( EvalError e ) { e . reThrow ( this ) ; } case PLUSASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , PLUS ) ) ; case MINUSASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , MINUS ) ) ; case STARASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , STAR ) ) ; case SLASHASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , SLASH ) ) ; case ANDASSIGN : case ANDASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , BIT_AND ) ) ; case ORASSIGN : case ORASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , BIT_OR ) ) ; case XORASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , XOR ) ) ; case MODASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , MOD ) ) ; case LSHIFTASSIGN : case LSHIFTASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , LSHIFT ) ) ; case RSIGNEDSHIFTASSIGN : case RSIGNEDSHIFTASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , RSIGNEDSHIFT ) ) ; case RUNSIGNEDSHIFTASSIGN : case RUNSIGNEDSHIFTASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , RUNSIGNEDSHIFT ) ) ; default : throw new InterpreterError ( "unimplemented operator in assignment BSH" ) ; } } private Object operation ( Object lhs , Object rhs , int kind ) throws EvalError { if ( lhs instanceof String && rhs != Primitive . VOID ) { if ( kind != PLUS ) throw new EvalError ( "Use of non + operator with String LHS" , this ) ; return ( String ) lhs + rhs ; } if ( lhs instanceof Primitive || rhs instanceof Primitive ) if ( lhs == Primitive . VOID || rhs == Primitive . VOID ) throw new EvalError ( "Illegal use of undefined object or 'void' literal" , this ) ; else if ( lhs == Primitive . NULL || rhs == Primitive . NULL ) throw new EvalError ( "Illegal use of null object or 'null' literal" , this ) ; if ( ( lhs instanceof Boolean || lhs instanceof Character || lhs instanceof Number || lhs instanceof Primitive ) && ( rhs instanceof Boolean || rhs instanceof Character || rhs instanceof Number || rhs instanceof Primitive ) ) { return Primitive . binaryOperation ( lhs , rhs , kind ) ; } throw new EvalError ( "Non primitive value in operator: " + lhs . getClass ( ) + " " + tokenImage [ kind ] + " " + rhs . getClass ( ) , this ) ; } } 	0	['3', '2', '0', '11', '18', '3', '1', '10', '1', '1', '274', '0', '0', '0.9', '0.533333333', '1', '1', '90', '1', '0.6667', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class EnhancedCheckBoxMenuItem extends JCheckBoxMenuItem { public EnhancedCheckBoxMenuItem ( String label , EditAction action ) { super ( label ) ; this . action = action ; if ( action != null ) { setEnabled ( true ) ; addActionListener ( new EditAction . Wrapper ( action ) ) ; shortcutProp1 = action . getName ( ) + ".shortcut" ; shortcutProp2 = action . getName ( ) + ".shortcut2" ; addMouseListener ( new MouseHandler ( ) ) ; } else setEnabled ( false ) ; setModel ( new Model ( ) ) ; } public Dimension getPreferredSize ( ) { Dimension d = super . getPreferredSize ( ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { d . width += ( getFontMetrics ( acceleratorFont ) . stringWidth ( shortcut ) + 15 ) ; } return d ; } public void paint ( Graphics g ) { super . paint ( g ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { g . setFont ( acceleratorFont ) ; g . setColor ( getModel ( ) . isArmed ( ) ? acceleratorSelectionForeground : acceleratorForeground ) ; FontMetrics fm = g . getFontMetrics ( ) ; Insets insets = getInsets ( ) ; g . drawString ( shortcut , getWidth ( ) - ( fm . stringWidth ( shortcut ) + insets . right + insets . left + 5 ) , getFont ( ) . getSize ( ) + ( insets . top - 1 ) ) ; } } public String getActionCommand ( ) { return getModel ( ) . getActionCommand ( ) ; } private String shortcutProp1 ; private String shortcutProp2 ; private EditAction action ; private static Font acceleratorFont ; private static Color acceleratorForeground ; private static Color acceleratorSelectionForeground ; private String getShortcut ( ) { if ( action == null ) return null ; else { String shortcut1 = jEdit . getProperty ( shortcutProp1 ) ; String shortcut2 = jEdit . getProperty ( shortcutProp2 ) ; if ( shortcut1 == null || shortcut1 . length ( ) == 0 ) { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return null ; else return shortcut2 ; } else { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return shortcut1 ; else return shortcut1 + " or " + shortcut2 ; } } } static { acceleratorFont = UIManager . getFont ( "MenuItem.acceleratorFont" ) ; acceleratorFont = new Font ( "Monospaced" , acceleratorFont . getStyle ( ) , acceleratorFont . getSize ( ) ) ; acceleratorForeground = UIManager . getColor ( "MenuItem.acceleratorForeground" ) ; acceleratorSelectionForeground = UIManager . getColor ( "MenuItem.acceleratorSelectionForeground" ) ; } class Model extends DefaultButtonModel { public boolean isSelected ( ) { if ( ! isShowing ( ) ) return false ; try { return action . isSelected ( GUIUtilities . getView ( EnhancedCheckBoxMenuItem . this ) ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , this , t ) ; return false ; } } public void setSelected ( boolean b ) { } } class MouseHandler extends MouseAdapter { public void mouseReleased ( MouseEvent evt ) { GUIUtilities . getView ( ( Component ) evt . getSource ( ) ) . getStatus ( ) . setMessage ( null ) ; } public void mouseEntered ( MouseEvent evt ) { String msg = action . getMouseOverText ( ) ; if ( msg != null ) { GUIUtilities . getView ( ( Component ) evt . getSource ( ) ) . getStatus ( ) . setMessage ( msg ) ; } } public void mouseExited ( MouseEvent evt ) { GUIUtilities . getView ( ( Component ) evt . getSource ( ) ) . getStatus ( ) . setMessage ( null ) ; } } } 	0	['7', '7', '0', '6', '40', '9', '3', '5', '4', '0.611111111', '214', '1', '1', '0.993811881', '0.3', '3', '13', '28.71428571', '8', '2.1429', '0']
package bsh ; class BSHForStatement extends SimpleNode implements ParserConstants { public boolean hasForInit ; public boolean hasExpression ; public boolean hasForUpdate ; private SimpleNode forInit ; private SimpleNode expression ; private SimpleNode forUpdate ; private SimpleNode statement ; private boolean parsed ; BSHForStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int i = 0 ; if ( hasForInit ) forInit = ( ( SimpleNode ) jjtGetChild ( i ++ ) ) ; if ( hasExpression ) expression = ( ( SimpleNode ) jjtGetChild ( i ++ ) ) ; if ( hasForUpdate ) forUpdate = ( ( SimpleNode ) jjtGetChild ( i ++ ) ) ; if ( i < jjtGetNumChildren ( ) ) statement = ( ( SimpleNode ) jjtGetChild ( i ) ) ; NameSpace enclosingNameSpace = callstack . top ( ) ; BlockNameSpace forNameSpace = new BlockNameSpace ( enclosingNameSpace ) ; callstack . swap ( forNameSpace ) ; if ( hasForInit ) forInit . eval ( callstack , interpreter ) ; Object returnControl = Primitive . VOID ; while ( true ) { if ( hasExpression ) { boolean cond = BSHIfStatement . evaluateCondition ( expression , callstack , interpreter ) ; if ( ! cond ) break ; } boolean breakout = false ; if ( statement != null ) { Object ret = statement . eval ( callstack , interpreter ) ; if ( ret instanceof ReturnControl ) { switch ( ( ( ReturnControl ) ret ) . kind ) { case RETURN : returnControl = ret ; breakout = true ; break ; case CONTINUE : break ; case BREAK : breakout = true ; break ; } } } if ( breakout ) break ; if ( hasForUpdate ) forUpdate . eval ( callstack , interpreter ) ; } callstack . swap ( enclosingNameSpace ) ; return returnControl ; } } 	0	['2', '2', '0', '12', '10', '1', '1', '11', '1', '1.125', '137', '0.625', '4', '0.947368421', '0.625', '1', '1', '63.5', '1', '0.5', '0']
package bsh ; class BSHAmbiguousName extends SimpleNode { public String text ; BSHAmbiguousName ( int id ) { super ( id ) ; } public Name getName ( NameSpace namespace ) { return namespace . getNameResolver ( text ) ; } public Object toObject ( CallStack callstack , Interpreter interpreter ) throws EvalError { return getName ( callstack . top ( ) ) . toObject ( callstack , interpreter ) ; } public Class toClass ( NameSpace namespace ) throws EvalError { return getName ( namespace ) . toClass ( ) ; } public LHS toLHS ( CallStack callstack , Interpreter interpreter ) throws EvalError { return getName ( callstack . top ( ) ) . toLHS ( callstack , interpreter ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { throw new InterpreterError ( "Don't know how to eval an ambiguous name!" + "  Use toObject() if you want an object." ) ; } public String toString ( ) { return "AmbigousName: " + text ; } } 	0	['7', '2', '0', '16', '17', '19', '8', '8', '6', '0.333333333', '53', '0', '0', '0.75', '0.457142857', '1', '1', '6.428571429', '1', '0.8571', '0']
package org . gjt . sp . jedit . help ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; class HelpSearchPanel extends JPanel { public HelpSearchPanel ( HelpViewer helpViewer ) { super ( new BorderLayout ( 6 , 6 ) ) ; this . helpViewer = helpViewer ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( new JLabel ( jEdit . getProperty ( "helpviewer.search.caption" ) ) ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; box . add ( searchField = new HistoryTextField ( "helpviewer.search" ) ) ; searchField . addActionListener ( new ActionHandler ( ) ) ; add ( BorderLayout . NORTH , box ) ; results = new JList ( ) ; results . addMouseListener ( new MouseHandler ( ) ) ; results . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; results . setCellRenderer ( new ResultRenderer ( ) ) ; add ( BorderLayout . CENTER , new JScrollPane ( results ) ) ; } private HelpViewer helpViewer ; private HistoryTextField searchField ; private JList results ; private HelpIndex index ; private HelpIndex getHelpIndex ( ) { if ( index == null ) { index = new HelpIndex ( ) ; try { index . indexEditorHelp ( ) ; } catch ( Exception e ) { index = null ; Log . log ( Log . ERROR , this , e ) ; GUIUtilities . error ( helpViewer , "helpviewer.search.error" , new String [ ] { e . toString ( ) } ) ; } } return index ; } static class ResultIcon implements Icon { private static RenderingHints renderingHints ; static { HashMap hints = new HashMap ( ) ; hints . put ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; hints . put ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; renderingHints = new RenderingHints ( hints ) ; } private int rank ; ResultIcon ( int rank ) { this . rank = rank ; } public int getIconWidth ( ) { return 40 ; } public int getIconHeight ( ) { return 9 ; } public void paintIcon ( Component c , Graphics g , int x , int y ) { Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . setRenderingHints ( renderingHints ) ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( rank > i ) g2d . setColor ( UIManager . getColor ( "Label.foreground" ) ) ; else g2d . setColor ( UIManager . getColor ( "Label.disabledForeground" ) ) ; g2d . fillOval ( x + i * 10 , y , 9 , 9 ) ; } } } class ResultRenderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , null , index , isSelected , cellHasFocus ) ; if ( value instanceof String ) { setIcon ( null ) ; setText ( ( String ) value ) ; } else { Result result = ( Result ) value ; setIcon ( new ResultIcon ( result . rank ) ) ; setText ( result . title ) ; } return this ; } } static class Result { String file ; String title ; int rank ; Result ( HelpIndex . HelpFile file , int count ) { this . file = file . file ; this . title = file . title ; rank = count ; } } static class ResultCompare implements Comparator { public int compare ( Object o1 , Object o2 ) { Result r1 = ( Result ) o1 ; Result r2 = ( Result ) o2 ; if ( r1 . rank == r2 . rank ) return r1 . title . compareTo ( r2 . title ) ; else return r2 . rank - r1 . rank ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { final HelpIndex index = getHelpIndex ( ) ; if ( index == null ) return ; results . setListData ( new String [ ] { jEdit . getProperty ( "helpviewer.searching" ) } ) ; final String text = searchField . getText ( ) ; final Vector resultModel = new Vector ( ) ; VFSManager . runInWorkThread ( new Runnable ( ) { public void run ( ) { StringTokenizer st = new StringTokenizer ( text , ",.;:-? " ) ; int maxRank = 0 ; while ( st . hasMoreTokens ( ) ) { String word = st . nextToken ( ) . toLowerCase ( ) ; HelpIndex . Word lookup = index . lookupWord ( word ) ; if ( lookup == null ) continue ; for ( int i = 0 ; i < lookup . occurCount ; i ++ ) { HelpIndex . Word . Occurrence occur = lookup . occurrences [ i ] ; boolean ok = false ; HelpIndex . HelpFile file = index . getFile ( occur . file ) ; for ( int j = 0 ; j < resultModel . size ( ) ; j ++ ) { Result result = ( Result ) resultModel . elementAt ( j ) ; if ( result . file . equals ( file . file ) ) { result . rank += occur . count ; result . rank += 20 ; maxRank = Math . max ( result . rank , maxRank ) ; ok = true ; break ; } } if ( ! ok ) { maxRank = Math . max ( occur . count , maxRank ) ; resultModel . addElement ( new Result ( file , occur . count ) ) ; } } } if ( maxRank != 0 ) { for ( int i = 0 ; i < resultModel . size ( ) ; i ++ ) { Result result = ( Result ) resultModel . elementAt ( i ) ; result . rank = ( int ) Math . ceil ( ( double ) result . rank * 4 / maxRank ) ; } Collections . sort ( resultModel , new ResultCompare ( ) ) ; } } } ) ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { if ( resultModel . size ( ) == 0 ) { results . setListData ( new String [ ] { jEdit . getProperty ( "helpviewer.no-results" ) } ) ; getToolkit ( ) . beep ( ) ; } else results . setListData ( resultModel ) ; } } ) ; } } public class MouseHandler extends MouseAdapter { public void mouseReleased ( MouseEvent evt ) { int row = results . locationToIndex ( evt . getPoint ( ) ) ; if ( row != - 1 ) { Result result = ( Result ) results . getModel ( ) . getElementAt ( row ) ; helpViewer . gotoURL ( result . file , true ) ; } } } } 	0	['6', '5', '0', '10', '29', '5', '5', '9', '1', '0.7', '140', '1', '3', '0.992401216', '0.388888889', '0', '0', '21.66666667', '2', '1', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . * ; public class IOProgressMonitor extends JPanel { public IOProgressMonitor ( ) { super ( new BorderLayout ( ) ) ; caption = new JLabel ( ) ; updateCaption ( ) ; add ( BorderLayout . NORTH , caption ) ; threads = new ThreadProgress [ VFSManager . getIOThreadPool ( ) . getThreadCount ( ) ] ; Box box = new Box ( BoxLayout . Y_AXIS ) ; for ( int i = 0 ; i < threads . length ; i ++ ) { if ( i != 0 ) box . add ( Box . createVerticalStrut ( 6 ) ) ; threads [ i ] = new ThreadProgress ( i ) ; box . add ( threads [ i ] ) ; } JPanel threadPanel = new JPanel ( new BorderLayout ( ) ) ; threadPanel . setBorder ( new EmptyBorder ( 6 , 6 , 6 , 6 ) ) ; threadPanel . add ( BorderLayout . NORTH , box ) ; add ( BorderLayout . CENTER , new JScrollPane ( threadPanel ) ) ; workThreadHandler = new WorkThreadHandler ( ) ; } public void addNotify ( ) { VFSManager . getIOThreadPool ( ) . addProgressListener ( workThreadHandler ) ; super . addNotify ( ) ; } public void removeNotify ( ) { VFSManager . getIOThreadPool ( ) . removeProgressListener ( workThreadHandler ) ; super . removeNotify ( ) ; } private JLabel caption ; private ThreadProgress [ ] threads ; private WorkThreadHandler workThreadHandler ; private void updateCaption ( ) { String [ ] args = { String . valueOf ( VFSManager . getIOThreadPool ( ) . getRequestCount ( ) ) } ; caption . setText ( jEdit . getProperty ( "io-progress-monitor.caption" , args ) ) ; } class WorkThreadHandler implements WorkThreadProgressListener { public void statusUpdate ( final WorkThreadPool pool , final int index ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { updateCaption ( ) ; threads [ index ] . update ( ) ; } } ) ; } public void progressUpdate ( final WorkThreadPool pool , final int index ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { updateCaption ( ) ; threads [ index ] . update ( ) ; } } ) ; } } class ThreadProgress extends JPanel { public ThreadProgress ( int index ) { super ( new BorderLayout ( 12 , 12 ) ) ; this . index = index ; Box box = new Box ( BoxLayout . Y_AXIS ) ; box . add ( Box . createGlue ( ) ) ; box . add ( progress = new JProgressBar ( ) ) ; progress . setStringPainted ( true ) ; box . add ( Box . createGlue ( ) ) ; ThreadProgress . this . add ( BorderLayout . CENTER , box ) ; abort = new JButton ( jEdit . getProperty ( "io-progress-monitor.abort" ) ) ; abort . addActionListener ( new ActionHandler ( ) ) ; ThreadProgress . this . add ( BorderLayout . EAST , abort ) ; update ( ) ; } public void update ( ) { WorkThread thread = VFSManager . getIOThreadPool ( ) . getThread ( index ) ; if ( thread . isRequestRunning ( ) ) { abort . setEnabled ( true ) ; progress . setString ( thread . getStatus ( ) ) ; progress . setMaximum ( thread . getProgressMaximum ( ) ) ; progress . setValue ( thread . getProgressValue ( ) ) ; } else { abort . setEnabled ( false ) ; progress . setString ( jEdit . getProperty ( "io-progress-monitor" + ".idle" ) ) ; progress . setValue ( 0 ) ; } } private int index ; private JProgressBar progress ; private JButton abort ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == abort ) { int result = GUIUtilities . confirm ( IOProgressMonitor . this , "abort" , null , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { VFSManager . getIOThreadPool ( ) . getThread ( index ) . abortCurrentRequest ( ) ; } } } } } } 	0	['6', '5', '0', '9', '29', '5', '5', '6', '3', '0.666666667', '141', '1', '2', '0.992401216', '0.5', '1', '7', '22', '1', '0.8333', '0']
package org . gjt . sp . jedit . pluginmgr ; import com . microstar . xml . XmlException ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . options . GlobalOptions ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; class PluginListDownloadProgress extends JDialog { PluginListDownloadProgress ( PluginManager window ) { super ( window , jEdit . getProperty ( "plugin-list.progress.title" ) , true ) ; this . window = window ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel caption = new JLabel ( jEdit . getProperty ( "plugin-list.progress.caption" ) ) ; caption . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; content . add ( BorderLayout . NORTH , caption ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; JButton stop = new JButton ( jEdit . getProperty ( "plugin-list.progress.stop" ) ) ; stop . addActionListener ( new ActionHandler ( ) ) ; stop . setMaximumSize ( stop . getPreferredSize ( ) ) ; box . add ( stop ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . CENTER , box ) ; addWindowListener ( new WindowHandler ( ) ) ; setDefaultCloseOperation ( DO_NOTHING_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( window ) ; setResizable ( false ) ; show ( ) ; } PluginList getPluginList ( ) { return list ; } private PluginManager window ; private PluginList list ; private DownloadThread thread ; class DownloadThread extends Thread { public void run ( ) { try { list = new PluginList ( ) ; dispose ( ) ; } catch ( XmlException xe ) { dispose ( ) ; int line = xe . getLine ( ) ; String path = jEdit . getProperty ( "plugin-manager.url" ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , this , path + ":" + line + ": " + message ) ; String [ ] pp = { path , String . valueOf ( line ) , message } ; GUIUtilities . error ( window , "plugin-list.xmlerror" , pp ) ; } catch ( Exception e ) { dispose ( ) ; Log . log ( Log . ERROR , this , e ) ; String [ ] pp = { e . toString ( ) } ; String ok = jEdit . getProperty ( "common.ok" ) ; String proxyButton = jEdit . getProperty ( "plugin-list.ioerror.proxy-servers" ) ; int retVal = JOptionPane . showOptionDialog ( window , jEdit . getProperty ( "plugin-list.ioerror.message" , pp ) , jEdit . getProperty ( "plugin-list.ioerror.title" ) , JOptionPane . YES_NO_OPTION , JOptionPane . ERROR_MESSAGE , null , new Object [ ] { proxyButton , ok } , ok ) ; if ( retVal == 0 ) new GlobalOptions ( window , "firewall" ) ; } } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { thread . stop ( ) ; dispose ( ) ; } } class WindowHandler extends WindowAdapter { boolean done ; public void windowOpened ( WindowEvent evt ) { if ( done ) return ; done = true ; thread = new DownloadThread ( ) ; thread . start ( ) ; } public void windowClosing ( WindowEvent evt ) { thread . stop ( ) ; } } } 	0	['6', '6', '0', '6', '31', '9', '4', '6', '0', '0.8', '134', '1', '3', '0.992378049', '0.3', '0', '0', '20.83333333', '1', '0.8333', '0']
package org . gjt . sp . jedit . buffer ; import javax . swing . text . * ; import org . gjt . sp . jedit . Buffer ; public class LineElement implements Element { public LineElement ( Buffer buffer , int line ) { this . buffer = buffer ; this . line = line ; } public Document getDocument ( ) { return null ; } public Element getParentElement ( ) { return null ; } public String getName ( ) { return null ; } public AttributeSet getAttributes ( ) { return null ; } public int getStartOffset ( ) { return buffer . getLineStartOffset ( line ) ; } public int getEndOffset ( ) { return buffer . getLineEndOffset ( line ) ; } public int getElementIndex ( int offset ) { return 0 ; } public int getElementCount ( ) { return 0 ; } public Element getElement ( int line ) { return null ; } public boolean isLeaf ( ) { return true ; } private Buffer buffer ; private int line ; } 	0	['11', '1', '0', '2', '14', '49', '2', '1', '11', '0.8', '50', '1', '1', '0', '0.454545455', '0', '0', '3.363636364', '1', '0.9091', '0']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . * ; public class BufferUpdate extends EBMessage { public static final Object CREATED = "CREATED" ; public static final Object LOAD_STARTED = "LOAD_STARTED" ; public static final Object LOADED = "LOADED" ; public static final Object CLOSED = "CLOSED" ; public static final Object DIRTY_CHANGED = "DIRTY_CHANGED" ; public static final Object MARKERS_CHANGED = "MARKERS_CHANGED" ; public static final Object SAVING = "SAVING" ; public static final Object SAVED = "SAVED" ; public static final Object PROPERTIES_CHANGED = "PROPERTIES_CHANGED" ; public static final Object MODE_CHANGED = "MODE_CHANGED" ; public BufferUpdate ( Buffer buffer , View view , Object what ) { super ( buffer ) ; this . view = view ; if ( what == null ) throw new NullPointerException ( "What must be non-null" ) ; this . what = what ; } public Object getWhat ( ) { return what ; } public Buffer getBuffer ( ) { return ( Buffer ) getSource ( ) ; } public View getView ( ) { return view ; } public String paramString ( ) { return "what=" + what + ",view=" + view + "," + super . paramString ( ) ; } private Object what ; private View view ; } 	0	['6', '2', '0', '10', '14', '5', '8', '4', '5', '0.933333333', '86', '0.166666667', '1', '0.428571429', '0.4', '1', '1', '11.33333333', '1', '0.6667', '0']
package org . gjt . sp . jedit . search ; import org . gjt . sp . jedit . * ; public interface SearchFileSet { String getFirstFile ( View view ) ; String getNextFile ( View view , String path ) ; String [ ] getFiles ( View view ) ; int getFileCount ( View view ) ; String getCode ( ) ; } 	0	['5', '1', '0', '9', '5', '10', '9', '1', '5', '2', '5', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package bsh ; import java . io . * ; public class Parser implements ParserTreeConstants , ParserConstants { protected JJTParserState jjtree = new JJTParserState ( ) ; boolean retainComments = false ; public void setRetainComments ( boolean b ) { retainComments = b ; } void jjtreeOpenNodeScope ( Node n ) { ( ( SimpleNode ) n ) . firstToken = getToken ( 1 ) ; } void jjtreeCloseNodeScope ( Node n ) { ( ( SimpleNode ) n ) . lastToken = getToken ( 0 ) ; } void reInitInput ( Reader in ) { ReInit ( in ) ; } public SimpleNode popNode ( ) { if ( jjtree . nodeArity ( ) > 0 ) return ( SimpleNode ) jjtree . popNode ( ) ; else return null ; } void reInitTokenInput ( Reader in ) { jj_input_stream . ReInit ( in , jj_input_stream . getEndLine ( ) , jj_input_stream . getEndColumn ( ) ) ; } public static void main ( String [ ] args ) throws IOException , ParseException { boolean print = false ; int i = 0 ; if ( args [ 0 ] . equals ( "-p" ) ) { i ++ ; print = true ; } for ( ; i < args . length ; i ++ ) { Reader in = new FileReader ( args [ i ] ) ; Parser parser = new Parser ( in ) ; parser . setRetainComments ( true ) ; while ( ! parser . Line ( ) ) if ( print ) System . out . println ( parser . popNode ( ) ) ; } } final public boolean Line ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 0 : jj_consume_token ( 0 ) ; Interpreter . debug ( "End of File!" ) ; { if ( true ) return true ; } break ; case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case FORMAL_COMMENT : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : if ( jj_2_1 ( 2147483647 ) ) { Expression ( ) ; jj_consume_token ( SEMICOLON ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case FORMAL_COMMENT : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : BlockStatement ( ) ; break ; default : jj_la1 [ 0 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } { if ( true ) return false ; } break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } throw new Error ( "Missing return statement in function" ) ; } final public void MethodDeclaration ( ) throws ParseException { BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration ( JJTMETHODDECLARATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { if ( jj_2_2 ( 2147483647 ) ) { ReturnType ( ) ; t = jj_consume_token ( IDENTIFIER ) ; jjtn000 . name = t . image ; FormalParameters ( ) ; Block ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : t = jj_consume_token ( IDENTIFIER ) ; jjtn000 . name = t . image ; FormalParameters ( ) ; Block ( ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void MethodDeclarationLookahead ( ) throws ParseException { if ( jj_2_3 ( 2147483647 ) ) { ReturnType ( ) ; jj_consume_token ( IDENTIFIER ) ; FormalParameters ( ) ; jj_consume_token ( LBRACE ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; FormalParameters ( ) ; jj_consume_token ( LBRACE ) ; break ; default : jj_la1 [ 3 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void MethodDeclarationTypeLookahead ( ) throws ParseException { ReturnType ( ) ; jj_consume_token ( IDENTIFIER ) ; jj_consume_token ( LPAREN ) ; } final public void ImportDeclaration ( ) throws ParseException { BSHImportDeclaration jjtn000 = new BSHImportDeclaration ( JJTIMPORTDECLARATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { if ( jj_2_4 ( 2 ) ) { jj_consume_token ( IMPORT ) ; AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case DOT : t = jj_consume_token ( DOT ) ; jj_consume_token ( STAR ) ; break ; default : jj_la1 [ 4 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; if ( t != null ) jjtn000 . importPackage = true ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IMPORT : jj_consume_token ( IMPORT ) ; jj_consume_token ( STAR ) ; jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . superImport = true ; break ; default : jj_la1 [ 5 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void VariableDeclarator ( ) throws ParseException { BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator ( JJTVARIABLEDECLARATOR ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; try { t = jj_consume_token ( IDENTIFIER ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ASSIGN : jj_consume_token ( ASSIGN ) ; VariableInitializer ( ) ; break ; default : jj_la1 [ 6 ] = jj_gen ; ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . name = t . image ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void VariableInitializer ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : ArrayInitializer ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : Expression ( ) ; break ; default : jj_la1 [ 7 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } final public void ArrayInitializer ( ) throws ParseException { BSHArrayInitializer jjtn000 = new BSHArrayInitializer ( JJTARRAYINITIALIZER ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : VariableInitializer ( ) ; label_1 : while ( true ) { if ( jj_2_5 ( 2 ) ) { ; } else { break label_1 ; } jj_consume_token ( COMMA ) ; VariableInitializer ( ) ; } break ; default : jj_la1 [ 8 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : jj_consume_token ( COMMA ) ; break ; default : jj_la1 [ 9 ] = jj_gen ; ; } jj_consume_token ( RBRACE ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void FormalParameters ( ) throws ParseException { BSHFormalParameters jjtn000 = new BSHFormalParameters ( JJTFORMALPARAMETERS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : case IDENTIFIER : FormalParameter ( ) ; label_2 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 10 ] = jj_gen ; break label_2 ; } jj_consume_token ( COMMA ) ; FormalParameter ( ) ; } break ; default : jj_la1 [ 11 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void FormalParameter ( ) throws ParseException { BSHFormalParameter jjtn000 = new BSHFormalParameter ( JJTFORMALPARAMETER ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; try { if ( jj_2_6 ( 2 ) ) { Type ( ) ; t = jj_consume_token ( IDENTIFIER ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . name = t . image ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : t = jj_consume_token ( IDENTIFIER ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . name = t . image ; break ; default : jj_la1 [ 12 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Type ( ) throws ParseException { BSHType jjtn000 = new BSHType ( JJTTYPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : PrimitiveType ( ) ; break ; case IDENTIFIER : AmbiguousName ( ) ; break ; default : jj_la1 [ 13 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } label_3 : while ( true ) { if ( jj_2_7 ( 2 ) ) { ; } else { break label_3 ; } jj_consume_token ( LBRACKET ) ; jj_consume_token ( RBRACKET ) ; jjtn000 . addArrayDimension ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ReturnType ( ) throws ParseException { BSHReturnType jjtn000 = new BSHReturnType ( JJTRETURNTYPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case VOID : jj_consume_token ( VOID ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isVoid = true ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : case IDENTIFIER : Type ( ) ; break ; default : jj_la1 [ 14 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void PrimitiveType ( ) throws ParseException { BSHPrimitiveType jjtn000 = new BSHPrimitiveType ( JJTPRIMITIVETYPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : jj_consume_token ( BOOLEAN ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Boolean . TYPE ; break ; case CHAR : jj_consume_token ( CHAR ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Character . TYPE ; break ; case BYTE : jj_consume_token ( BYTE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Byte . TYPE ; break ; case SHORT : jj_consume_token ( SHORT ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Short . TYPE ; break ; case INT : jj_consume_token ( INT ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Integer . TYPE ; break ; case LONG : jj_consume_token ( LONG ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Long . TYPE ; break ; case FLOAT : jj_consume_token ( FLOAT ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Float . TYPE ; break ; case DOUBLE : jj_consume_token ( DOUBLE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Double . TYPE ; break ; default : jj_la1 [ 15 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void AmbiguousName ( ) throws ParseException { BSHAmbiguousName jjtn000 = new BSHAmbiguousName ( JJTAMBIGUOUSNAME ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; StringBuffer s ; try { t = jj_consume_token ( IDENTIFIER ) ; s = new StringBuffer ( t . image ) ; label_4 : while ( true ) { if ( jj_2_8 ( 2 ) ) { ; } else { break label_4 ; } jj_consume_token ( DOT ) ; t = jj_consume_token ( IDENTIFIER ) ; s . append ( "." + t . image ) ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . text = s . toString ( ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Expression ( ) throws ParseException { if ( jj_2_9 ( 2147483647 ) ) { Assignment ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : ConditionalExpression ( ) ; break ; default : jj_la1 [ 16 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void Assignment ( ) throws ParseException { BSHAssignment jjtn000 = new BSHAssignment ( JJTASSIGNMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; int op ; try { LHSPrimaryExpression ( ) ; op = AssignmentOperator ( ) ; jjtn000 . operator = op ; Expression ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public int AssignmentOperator ( ) throws ParseException { Token t ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ASSIGN : jj_consume_token ( ASSIGN ) ; break ; case STARASSIGN : jj_consume_token ( STARASSIGN ) ; break ; case SLASHASSIGN : jj_consume_token ( SLASHASSIGN ) ; break ; case MODASSIGN : jj_consume_token ( MODASSIGN ) ; break ; case PLUSASSIGN : jj_consume_token ( PLUSASSIGN ) ; break ; case MINUSASSIGN : jj_consume_token ( MINUSASSIGN ) ; break ; case ANDASSIGN : jj_consume_token ( ANDASSIGN ) ; break ; case XORASSIGN : jj_consume_token ( XORASSIGN ) ; break ; case ORASSIGN : jj_consume_token ( ORASSIGN ) ; break ; case LSHIFTASSIGN : jj_consume_token ( LSHIFTASSIGN ) ; break ; case LSHIFTASSIGNX : jj_consume_token ( LSHIFTASSIGNX ) ; break ; case RSIGNEDSHIFTASSIGN : jj_consume_token ( RSIGNEDSHIFTASSIGN ) ; break ; case RSIGNEDSHIFTASSIGNX : jj_consume_token ( RSIGNEDSHIFTASSIGNX ) ; break ; case RUNSIGNEDSHIFTASSIGN : jj_consume_token ( RUNSIGNEDSHIFTASSIGN ) ; break ; case RUNSIGNEDSHIFTASSIGNX : jj_consume_token ( RUNSIGNEDSHIFTASSIGNX ) ; break ; default : jj_la1 [ 17 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } t = getToken ( 0 ) ; { if ( true ) return t . kind ; } throw new Error ( "Missing return statement in function" ) ; } final public void ConditionalExpression ( ) throws ParseException { ConditionalOrExpression ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case HOOK : jj_consume_token ( HOOK ) ; Expression ( ) ; jj_consume_token ( COLON ) ; BSHTernaryExpression jjtn001 = new BSHTernaryExpression ( JJTTERNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { ConditionalExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 3 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 18 ] = jj_gen ; ; } } final public void ConditionalOrExpression ( ) throws ParseException { Token t = null ; ConditionalAndExpression ( ) ; label_5 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_OR : case BOOL_ORX : ; break ; default : jj_la1 [ 19 ] = jj_gen ; break label_5 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_OR : t = jj_consume_token ( BOOL_OR ) ; break ; case BOOL_ORX : t = jj_consume_token ( BOOL_ORX ) ; break ; default : jj_la1 [ 20 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } ConditionalAndExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void ConditionalAndExpression ( ) throws ParseException { Token t = null ; InclusiveOrExpression ( ) ; label_6 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_AND : case BOOL_ANDX : ; break ; default : jj_la1 [ 21 ] = jj_gen ; break label_6 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_AND : t = jj_consume_token ( BOOL_AND ) ; break ; case BOOL_ANDX : t = jj_consume_token ( BOOL_ANDX ) ; break ; default : jj_la1 [ 22 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } InclusiveOrExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void InclusiveOrExpression ( ) throws ParseException { Token t = null ; ExclusiveOrExpression ( ) ; label_7 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_OR : case BIT_ORX : ; break ; default : jj_la1 [ 23 ] = jj_gen ; break label_7 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_OR : t = jj_consume_token ( BIT_OR ) ; break ; case BIT_ORX : t = jj_consume_token ( BIT_ORX ) ; break ; default : jj_la1 [ 24 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } ExclusiveOrExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void ExclusiveOrExpression ( ) throws ParseException { Token t = null ; AndExpression ( ) ; label_8 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case XOR : ; break ; default : jj_la1 [ 25 ] = jj_gen ; break label_8 ; } t = jj_consume_token ( XOR ) ; AndExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void AndExpression ( ) throws ParseException { Token t = null ; EqualityExpression ( ) ; label_9 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_AND : case BIT_ANDX : ; break ; default : jj_la1 [ 26 ] = jj_gen ; break label_9 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_AND : t = jj_consume_token ( BIT_AND ) ; break ; case BIT_ANDX : t = jj_consume_token ( BIT_ANDX ) ; break ; default : jj_la1 [ 27 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } EqualityExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void EqualityExpression ( ) throws ParseException { Token t = null ; InstanceOfExpression ( ) ; label_10 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EQ : case NE : ; break ; default : jj_la1 [ 28 ] = jj_gen ; break label_10 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EQ : t = jj_consume_token ( EQ ) ; break ; case NE : t = jj_consume_token ( NE ) ; break ; default : jj_la1 [ 29 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } InstanceOfExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void InstanceOfExpression ( ) throws ParseException { Token t = null ; RelationalExpression ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INSTANCEOF : t = jj_consume_token ( INSTANCEOF ) ; Type ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 30 ] = jj_gen ; ; } } final public void RelationalExpression ( ) throws ParseException { Token t = null ; ShiftExpression ( ) ; label_11 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case GT : case GTX : case LT : case LTX : case LE : case LEX : case GE : case GEX : ; break ; default : jj_la1 [ 31 ] = jj_gen ; break label_11 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LT : t = jj_consume_token ( LT ) ; break ; case LTX : t = jj_consume_token ( LTX ) ; break ; case GT : t = jj_consume_token ( GT ) ; break ; case GTX : t = jj_consume_token ( GTX ) ; break ; case LE : t = jj_consume_token ( LE ) ; break ; case LEX : t = jj_consume_token ( LEX ) ; break ; case GE : t = jj_consume_token ( GE ) ; break ; case GEX : t = jj_consume_token ( GEX ) ; break ; default : jj_la1 [ 32 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } ShiftExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void ShiftExpression ( ) throws ParseException { Token t = null ; AdditiveExpression ( ) ; label_12 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LSHIFT : case LSHIFTX : case RSIGNEDSHIFT : case RSIGNEDSHIFTX : case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : ; break ; default : jj_la1 [ 33 ] = jj_gen ; break label_12 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LSHIFT : t = jj_consume_token ( LSHIFT ) ; break ; case LSHIFTX : t = jj_consume_token ( LSHIFTX ) ; break ; case RSIGNEDSHIFT : t = jj_consume_token ( RSIGNEDSHIFT ) ; break ; case RSIGNEDSHIFTX : t = jj_consume_token ( RSIGNEDSHIFTX ) ; break ; case RUNSIGNEDSHIFT : t = jj_consume_token ( RUNSIGNEDSHIFT ) ; break ; case RUNSIGNEDSHIFTX : t = jj_consume_token ( RUNSIGNEDSHIFTX ) ; break ; default : jj_la1 [ 34 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } AdditiveExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void AdditiveExpression ( ) throws ParseException { Token t = null ; MultiplicativeExpression ( ) ; label_13 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : case MINUS : ; break ; default : jj_la1 [ 35 ] = jj_gen ; break label_13 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : t = jj_consume_token ( PLUS ) ; break ; case MINUS : t = jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 36 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } MultiplicativeExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void MultiplicativeExpression ( ) throws ParseException { Token t = null ; UnaryExpression ( ) ; label_14 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STAR : case SLASH : case MOD : ; break ; default : jj_la1 [ 37 ] = jj_gen ; break label_14 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STAR : t = jj_consume_token ( STAR ) ; break ; case SLASH : t = jj_consume_token ( SLASH ) ; break ; case MOD : t = jj_consume_token ( MOD ) ; break ; default : jj_la1 [ 38 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } UnaryExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void UnaryExpression ( ) throws ParseException { Token t = null ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : case MINUS : switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : t = jj_consume_token ( PLUS ) ; break ; case MINUS : t = jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 39 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } UnaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; case INCR : PreIncrementExpression ( ) ; break ; case DECR : PreDecrementExpression ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : UnaryExpressionNotPlusMinus ( ) ; break ; default : jj_la1 [ 40 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } final public void PreIncrementExpression ( ) throws ParseException { Token t = null ; t = jj_consume_token ( INCR ) ; LHSPrimaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } final public void PreDecrementExpression ( ) throws ParseException { Token t = null ; t = jj_consume_token ( DECR ) ; LHSPrimaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } final public void UnaryExpressionNotPlusMinus ( ) throws ParseException { Token t = null ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BANG : case TILDE : switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TILDE : t = jj_consume_token ( TILDE ) ; break ; case BANG : t = jj_consume_token ( BANG ) ; break ; default : jj_la1 [ 41 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } UnaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 42 ] = jj_gen ; if ( jj_2_10 ( 2147483647 ) ) { CastExpression ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : PostfixExpression ( ) ; break ; default : jj_la1 [ 43 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void CastLookahead ( ) throws ParseException { if ( jj_2_11 ( 2 ) ) { jj_consume_token ( LPAREN ) ; PrimitiveType ( ) ; } else if ( jj_2_12 ( 2147483647 ) ) { jj_consume_token ( LPAREN ) ; AmbiguousName ( ) ; jj_consume_token ( LBRACKET ) ; jj_consume_token ( RBRACKET ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : jj_consume_token ( LPAREN ) ; AmbiguousName ( ) ; jj_consume_token ( RPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TILDE : jj_consume_token ( TILDE ) ; break ; case BANG : jj_consume_token ( BANG ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; break ; case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; break ; case NEW : jj_consume_token ( NEW ) ; break ; case FALSE : case NULL : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : Literal ( ) ; break ; default : jj_la1 [ 44 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } break ; default : jj_la1 [ 45 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void PostfixExpression ( ) throws ParseException { Token t = null ; if ( jj_2_13 ( 2147483647 ) ) { LHSPrimaryExpression ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INCR : t = jj_consume_token ( INCR ) ; break ; case DECR : t = jj_consume_token ( DECR ) ; break ; default : jj_la1 [ 46 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; jjtn001 . postfix = true ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : PrimaryExpression ( ) ; break ; default : jj_la1 [ 47 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void CastExpression ( ) throws ParseException { BSHCastExpression jjtn000 = new BSHCastExpression ( JJTCASTEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { if ( jj_2_14 ( 2147483647 ) ) { jj_consume_token ( LPAREN ) ; Type ( ) ; jj_consume_token ( RPAREN ) ; UnaryExpression ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : jj_consume_token ( LPAREN ) ; Type ( ) ; jj_consume_token ( RPAREN ) ; UnaryExpressionNotPlusMinus ( ) ; break ; default : jj_la1 [ 48 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void PrimaryExpression ( ) throws ParseException { BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression ( JJTPRIMARYEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { PrimaryPrefix ( ) ; label_15 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : case LBRACKET : case DOT : ; break ; default : jj_la1 [ 49 ] = jj_gen ; break label_15 ; } PrimarySuffix ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void MethodInvocation ( ) throws ParseException { BSHMethodInvocation jjtn000 = new BSHMethodInvocation ( JJTMETHODINVOCATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { AmbiguousName ( ) ; Arguments ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void PrimaryPrefix ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FALSE : case NULL : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : Literal ( ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; break ; case NEW : AllocationExpression ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : case IDENTIFIER : if ( jj_2_16 ( 2147483647 ) ) { MethodInvocation ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : case IDENTIFIER : if ( jj_2_15 ( 2147483647 ) ) { Type ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : AmbiguousName ( ) ; break ; default : jj_la1 [ 50 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } break ; default : jj_la1 [ 51 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } break ; default : jj_la1 [ 52 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } final public void PrimarySuffix ( ) throws ParseException { BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix ( JJTPRIMARYSUFFIX ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { if ( jj_2_17 ( 2 ) ) { jj_consume_token ( DOT ) ; jj_consume_token ( CLASS ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . CLASS ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : jj_consume_token ( LBRACKET ) ; Expression ( ) ; jj_consume_token ( RBRACKET ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . INDEX ; break ; case DOT : jj_consume_token ( DOT ) ; t = jj_consume_token ( IDENTIFIER ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; break ; default : jj_la1 [ 53 ] = jj_gen ; ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . NAME ; jjtn000 . field = t . image ; break ; case LBRACE : jj_consume_token ( LBRACE ) ; Expression ( ) ; jj_consume_token ( RBRACE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . PROPERTY ; break ; default : jj_la1 [ 54 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void LHSPrimaryPrefix ( ) throws ParseException { if ( jj_2_18 ( 2147483647 ) ) { MethodInvocation ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : AmbiguousName ( ) ; break ; default : jj_la1 [ 55 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void LHSPrimaryExpression ( ) throws ParseException { BSHLHSPrimaryExpression jjtn000 = new BSHLHSPrimaryExpression ( JJTLHSPRIMARYEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { LHSPrimaryPrefix ( ) ; label_16 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : case LBRACKET : case DOT : ; break ; default : jj_la1 [ 56 ] = jj_gen ; break label_16 ; } LHSPrimarySuffix ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void LHSPrimarySuffix ( ) throws ParseException { BSHLHSPrimarySuffix jjtn000 = new BSHLHSPrimarySuffix ( JJTLHSPRIMARYSUFFIX ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null , t1 , t2 = null ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : jj_consume_token ( LBRACKET ) ; Expression ( ) ; jj_consume_token ( RBRACKET ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHLHSPrimarySuffix . INDEX ; break ; case DOT : jj_consume_token ( DOT ) ; t1 = jj_consume_token ( IDENTIFIER ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; jj_consume_token ( DOT ) ; t2 = jj_consume_token ( IDENTIFIER ) ; break ; default : jj_la1 [ 57 ] = jj_gen ; ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHLHSPrimarySuffix . NAME ; if ( t2 == null ) jjtn000 . field = t1 . image ; else { jjtn000 . method = t1 . image ; jjtn000 . field = t2 . image ; } break ; case LBRACE : jj_consume_token ( LBRACE ) ; Expression ( ) ; jj_consume_token ( RBRACE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHLHSPrimarySuffix . PROPERTY ; break ; default : jj_la1 [ 58 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Literal ( ) throws ParseException { BSHLiteral jjtn000 = new BSHLiteral ( JJTLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token x ; boolean b ; String literal ; char ch ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INTEGER_LITERAL : x = jj_consume_token ( INTEGER_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; literal = x . image ; ch = literal . charAt ( literal . length ( ) - 1 ) ; if ( ch == 'l' || ch == 'L' ) { literal = literal . substring ( 0 , literal . length ( ) - 1 ) ; jjtn000 . value = new Primitive ( new Long ( literal ) ) ; } else jjtn000 . value = new Primitive ( Integer . decode ( literal ) ) ; break ; case FLOATING_POINT_LITERAL : x = jj_consume_token ( FLOATING_POINT_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; literal = x . image ; ch = literal . charAt ( literal . length ( ) - 1 ) ; if ( ch == 'f' || ch == 'F' ) { literal = literal . substring ( 0 , literal . length ( ) - 1 ) ; jjtn000 . value = new Primitive ( new Float ( literal ) ) ; } else { if ( ch == 'd' || ch == 'D' ) literal = literal . substring ( 0 , literal . length ( ) - 1 ) ; jjtn000 . value = new Primitive ( new Double ( literal ) ) ; } break ; case CHARACTER_LITERAL : x = jj_consume_token ( CHARACTER_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; try { jjtn000 . charSetup ( x . image . substring ( 1 , x . image . length ( ) - 1 ) ) ; } catch ( Exception e ) { { if ( true ) throw new ParseException ( "Error parsing character: " + x . image ) ; } } break ; case STRING_LITERAL : x = jj_consume_token ( STRING_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; try { jjtn000 . stringSetup ( x . image . substring ( 1 , x . image . length ( ) - 1 ) ) ; } catch ( Exception e ) { { if ( true ) throw new ParseException ( "Error parsing string: " + x . image ) ; } } break ; case FALSE : case TRUE : b = BooleanLiteral ( ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . value = new Primitive ( new Boolean ( b ) ) ; break ; case NULL : NullLiteral ( ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . value = Primitive . NULL ; break ; case VOID : VoidLiteral ( ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . value = Primitive . VOID ; break ; default : jj_la1 [ 59 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public boolean BooleanLiteral ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TRUE : jj_consume_token ( TRUE ) ; { if ( true ) return true ; } break ; case FALSE : jj_consume_token ( FALSE ) ; { if ( true ) return false ; } break ; default : jj_la1 [ 60 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } throw new Error ( "Missing return statement in function" ) ; } final public void NullLiteral ( ) throws ParseException { jj_consume_token ( NULL ) ; } final public void VoidLiteral ( ) throws ParseException { jj_consume_token ( VOID ) ; } final public void Arguments ( ) throws ParseException { BSHArguments jjtn000 = new BSHArguments ( JJTARGUMENTS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : ArgumentList ( ) ; break ; default : jj_la1 [ 61 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ArgumentList ( ) throws ParseException { Expression ( ) ; label_17 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 62 ] = jj_gen ; break label_17 ; } jj_consume_token ( COMMA ) ; Expression ( ) ; } } final public void AllocationExpression ( ) throws ParseException { BSHAllocationExpression jjtn000 = new BSHAllocationExpression ( JJTALLOCATIONEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { if ( jj_2_20 ( 2 ) ) { jj_consume_token ( NEW ) ; PrimitiveType ( ) ; ArrayDimensions ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case NEW : jj_consume_token ( NEW ) ; AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : ArrayDimensions ( ) ; break ; case LPAREN : Arguments ( ) ; if ( jj_2_19 ( 2 ) ) { Block ( ) ; } else { ; } break ; default : jj_la1 [ 63 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } break ; default : jj_la1 [ 64 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ArrayDimensions ( ) throws ParseException { BSHArrayDimensions jjtn000 = new BSHArrayDimensions ( JJTARRAYDIMENSIONS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { if ( jj_2_22 ( 2 ) ) { label_18 : while ( true ) { jj_consume_token ( LBRACKET ) ; Expression ( ) ; jj_consume_token ( RBRACKET ) ; jjtn000 . addArrayDimension ( ) ; if ( jj_2_21 ( 2 ) ) { ; } else { break label_18 ; } } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : label_19 : while ( true ) { jj_consume_token ( LBRACKET ) ; jj_consume_token ( RBRACKET ) ; jjtn000 . addArrayDimension ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : ; break ; default : jj_la1 [ 65 ] = jj_gen ; break label_19 ; } } ArrayInitializer ( ) ; break ; default : jj_la1 [ 66 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Statement ( ) throws ParseException { if ( jj_2_23 ( 2 ) ) { LabeledStatement ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : Block ( ) ; break ; case SEMICOLON : EmptyStatement ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : StatementExpression ( ) ; jj_consume_token ( SEMICOLON ) ; break ; case SWITCH : SwitchStatement ( ) ; break ; case IF : IfStatement ( ) ; break ; case WHILE : WhileStatement ( ) ; break ; case DO : DoStatement ( ) ; break ; case FOR : ForStatement ( ) ; break ; case BREAK : BreakStatement ( ) ; break ; case CONTINUE : ContinueStatement ( ) ; break ; case RETURN : ReturnStatement ( ) ; break ; case THROW : ThrowStatement ( ) ; break ; case TRY : TryStatement ( ) ; break ; default : jj_la1 [ 67 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void LabeledStatement ( ) throws ParseException { jj_consume_token ( IDENTIFIER ) ; jj_consume_token ( COLON ) ; Statement ( ) ; } final public void Block ( ) throws ParseException { BSHBlock jjtn000 = new BSHBlock ( JJTBLOCK ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACE ) ; label_20 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case FORMAL_COMMENT : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : ; break ; default : jj_la1 [ 68 ] = jj_gen ; break label_20 ; } BlockStatement ( ) ; } jj_consume_token ( RBRACE ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void BlockStatement ( ) throws ParseException { if ( jj_2_24 ( 2147483647 ) ) { MethodDeclaration ( ) ; } else if ( jj_2_25 ( 2147483647 ) ) { TypedVariableDeclaration ( ) ; jj_consume_token ( SEMICOLON ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FLOAT : case FOR : case IF : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : Statement ( ) ; break ; case IMPORT : ImportDeclaration ( ) ; break ; case FORMAL_COMMENT : FormalComment ( ) ; break ; default : jj_la1 [ 69 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void FormalComment ( ) throws ParseException { BSHFormalComment jjtn000 = new BSHFormalComment ( JJTFORMALCOMMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; try { t = jj_consume_token ( FORMAL_COMMENT ) ; jjtree . closeNodeScope ( jjtn000 , retainComments ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . text = t . image ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , retainComments ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void EmptyStatement ( ) throws ParseException { jj_consume_token ( SEMICOLON ) ; } final public void StatementExpression ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INCR : PreIncrementExpression ( ) ; break ; case DECR : PreDecrementExpression ( ) ; break ; default : jj_la1 [ 70 ] = jj_gen ; if ( jj_2_26 ( 2147483647 ) ) { Assignment ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : PostfixExpression ( ) ; break ; default : jj_la1 [ 71 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void SwitchStatement ( ) throws ParseException { BSHSwitchStatement jjtn000 = new BSHSwitchStatement ( JJTSWITCHSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( SWITCH ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; jj_consume_token ( LBRACE ) ; label_21 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case CASE : case _DEFAULT : ; break ; default : jj_la1 [ 72 ] = jj_gen ; break label_21 ; } SwitchLabel ( ) ; label_22 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case FORMAL_COMMENT : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : ; break ; default : jj_la1 [ 73 ] = jj_gen ; break label_22 ; } BlockStatement ( ) ; } } jj_consume_token ( RBRACE ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void SwitchLabel ( ) throws ParseException { BSHSwitchLabel jjtn000 = new BSHSwitchLabel ( JJTSWITCHLABEL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case CASE : jj_consume_token ( CASE ) ; Expression ( ) ; jj_consume_token ( COLON ) ; break ; case _DEFAULT : jj_consume_token ( _DEFAULT ) ; jj_consume_token ( COLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isDefault = true ; break ; default : jj_la1 [ 74 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void IfStatement ( ) throws ParseException { BSHIfStatement jjtn000 = new BSHIfStatement ( JJTIFSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( IF ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; Statement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSE : jj_consume_token ( ELSE ) ; Statement ( ) ; break ; default : jj_la1 [ 75 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void WhileStatement ( ) throws ParseException { BSHWhileStatement jjtn000 = new BSHWhileStatement ( JJTWHILESTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( WHILE ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; Statement ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void DoStatement ( ) throws ParseException { BSHWhileStatement jjtn000 = new BSHWhileStatement ( JJTWHILESTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( DO ) ; Statement ( ) ; jj_consume_token ( WHILE ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isDoStatement = true ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ForStatement ( ) throws ParseException { BSHForStatement jjtn000 = new BSHForStatement ( JJTFORSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( FOR ) ; jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FINAL : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : ForInit ( ) ; jjtn000 . hasForInit = true ; break ; default : jj_la1 [ 76 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : Expression ( ) ; jjtn000 . hasExpression = true ; break ; default : jj_la1 [ 77 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : ForUpdate ( ) ; jjtn000 . hasForUpdate = true ; break ; default : jj_la1 [ 78 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; Statement ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ForInit ( ) throws ParseException { Token t = null ; if ( jj_2_27 ( 2147483647 ) ) { TypedVariableDeclaration ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : StatementExpressionList ( ) ; break ; default : jj_la1 [ 79 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void TypedVariableDeclaration ( ) throws ParseException { BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration ( JJTTYPEDVARIABLEDECLARATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FINAL : t = jj_consume_token ( FINAL ) ; break ; default : jj_la1 [ 80 ] = jj_gen ; ; } Type ( ) ; VariableDeclarator ( ) ; label_23 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 81 ] = jj_gen ; break label_23 ; } jj_consume_token ( COMMA ) ; VariableDeclarator ( ) ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isFinal = ( t != null ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void StatementExpressionList ( ) throws ParseException { BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList ( JJTSTATEMENTEXPRESSIONLIST ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { StatementExpression ( ) ; label_24 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 82 ] = jj_gen ; break label_24 ; } jj_consume_token ( COMMA ) ; StatementExpression ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ForUpdate ( ) throws ParseException { StatementExpressionList ( ) ; } final public void BreakStatement ( ) throws ParseException { BSHReturnStatement jjtn000 = new BSHReturnStatement ( JJTRETURNSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( BREAK ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; break ; default : jj_la1 [ 83 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . kind = BREAK ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ContinueStatement ( ) throws ParseException { BSHReturnStatement jjtn000 = new BSHReturnStatement ( JJTRETURNSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( CONTINUE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; break ; default : jj_la1 [ 84 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . kind = CONTINUE ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ReturnStatement ( ) throws ParseException { BSHReturnStatement jjtn000 = new BSHReturnStatement ( JJTRETURNSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( RETURN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : Expression ( ) ; break ; default : jj_la1 [ 85 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . kind = RETURN ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ThrowStatement ( ) throws ParseException { BSHThrowStatement jjtn000 = new BSHThrowStatement ( JJTTHROWSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( THROW ) ; Expression ( ) ; jj_consume_token ( SEMICOLON ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void TryStatement ( ) throws ParseException { BSHTryStatement jjtn000 = new BSHTryStatement ( JJTTRYSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( TRY ) ; Block ( ) ; label_25 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case CATCH : ; break ; default : jj_la1 [ 86 ] = jj_gen ; break label_25 ; } jj_consume_token ( CATCH ) ; jj_consume_token ( LPAREN ) ; FormalParameter ( ) ; jj_consume_token ( RPAREN ) ; Block ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FINALLY : jj_consume_token ( FINALLY ) ; Block ( ) ; break ; default : jj_la1 [ 87 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final private boolean jj_2_1 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_1 ( ) ; jj_save ( 0 , xla ) ; return retval ; } final private boolean jj_2_2 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_2 ( ) ; jj_save ( 1 , xla ) ; return retval ; } final private boolean jj_2_3 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_3 ( ) ; jj_save ( 2 , xla ) ; return retval ; } final private boolean jj_2_4 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_4 ( ) ; jj_save ( 3 , xla ) ; return retval ; } final private boolean jj_2_5 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_5 ( ) ; jj_save ( 4 , xla ) ; return retval ; } final private boolean jj_2_6 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_6 ( ) ; jj_save ( 5 , xla ) ; return retval ; } final private boolean jj_2_7 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_7 ( ) ; jj_save ( 6 , xla ) ; return retval ; } final private boolean jj_2_8 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_8 ( ) ; jj_save ( 7 , xla ) ; return retval ; } final private boolean jj_2_9 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_9 ( ) ; jj_save ( 8 , xla ) ; return retval ; } final private boolean jj_2_10 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_10 ( ) ; jj_save ( 9 , xla ) ; return retval ; } final private boolean jj_2_11 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_11 ( ) ; jj_save ( 10 , xla ) ; return retval ; } final private boolean jj_2_12 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_12 ( ) ; jj_save ( 11 , xla ) ; return retval ; } final private boolean jj_2_13 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_13 ( ) ; jj_save ( 12 , xla ) ; return retval ; } final private boolean jj_2_14 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_14 ( ) ; jj_save ( 13 , xla ) ; return retval ; } final private boolean jj_2_15 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_15 ( ) ; jj_save ( 14 , xla ) ; return retval ; } final private boolean jj_2_16 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_16 ( ) ; jj_save ( 15 , xla ) ; return retval ; } final private boolean jj_2_17 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_17 ( ) ; jj_save ( 16 , xla ) ; return retval ; } final private boolean jj_2_18 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_18 ( ) ; jj_save ( 17 , xla ) ; return retval ; } final private boolean jj_2_19 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_19 ( ) ; jj_save ( 18 , xla ) ; return retval ; } final private boolean jj_2_20 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_20 ( ) ; jj_save ( 19 , xla ) ; return retval ; } final private boolean jj_2_21 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_21 ( ) ; jj_save ( 20 , xla ) ; return retval ; } final private boolean jj_2_22 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_22 ( ) ; jj_save ( 21 , xla ) ; return retval ; } final private boolean jj_2_23 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_23 ( ) ; jj_save ( 22 , xla ) ; return retval ; } final private boolean jj_2_24 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_24 ( ) ; jj_save ( 23 , xla ) ; return retval ; } final private boolean jj_2_25 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_25 ( ) ; jj_save ( 24 , xla ) ; return retval ; } final private boolean jj_2_26 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_26 ( ) ; jj_save ( 25 , xla ) ; return retval ; } final private boolean jj_2_27 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_27 ( ) ; jj_save ( 26 , xla ) ; return retval ; } final private boolean jj_3R_33 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_11 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_68 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_69 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_11 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_284 ( ) { if ( jj_scan_token ( BANG ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_264 ( ) { if ( jj_scan_token ( MOD ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_279 ( ) { if ( jj_3R_207 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_278 ( ) { if ( jj_3R_285 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_283 ( ) { if ( jj_scan_token ( TILDE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_271 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_277 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_278 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_279 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_277 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_283 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_284 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_244 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_263 ( ) { if ( jj_scan_token ( SLASH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_239 ( ) { if ( jj_scan_token ( RSIGNEDSHIFTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_206 ( ) { if ( jj_scan_token ( DECR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_262 ( ) { if ( jj_scan_token ( STAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_205 ( ) { if ( jj_scan_token ( INCR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_245 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_262 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_263 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_264 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_244 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_238 ( ) { if ( jj_scan_token ( RSIGNEDSHIFT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_270 ( ) { if ( jj_scan_token ( MINUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_231 ( ) { if ( jj_scan_token ( GEX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_261 ( ) { if ( jj_3R_271 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_260 ( ) { if ( jj_3R_206 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_259 ( ) { if ( jj_3R_205 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_227 ( ) { if ( jj_scan_token ( GTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_269 ( ) { if ( jj_scan_token ( PLUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_244 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_258 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_259 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_260 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_261 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_258 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_269 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_270 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_244 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_247 ( ) { if ( jj_scan_token ( MINUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_230 ( ) { if ( jj_scan_token ( GE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_234 ( ) { if ( jj_3R_244 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_245 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_241 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_226 ( ) { if ( jj_scan_token ( GT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_237 ( ) { if ( jj_scan_token ( LSHIFTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_246 ( ) { if ( jj_scan_token ( PLUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_235 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_246 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_247 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_234 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_219 ( ) { if ( jj_scan_token ( NE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_222 ( ) { if ( jj_3R_234 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_235 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_229 ( ) { if ( jj_scan_token ( LEX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_240 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_225 ( ) { if ( jj_scan_token ( LTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_236 ( ) { if ( jj_scan_token ( LSHIFT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_223 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_236 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_237 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_238 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_239 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_240 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_241 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_222 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_218 ( ) { if ( jj_scan_token ( EQ ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_211 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_218 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_219 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_210 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_220 ( ) { if ( jj_3R_222 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_223 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_228 ( ) { if ( jj_scan_token ( LE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_224 ( ) { if ( jj_scan_token ( LT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_221 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_224 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_225 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_226 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_227 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_228 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_229 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_230 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_231 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_220 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_216 ( ) { if ( jj_3R_220 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_221 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_217 ( ) { if ( jj_scan_token ( INSTANCEOF ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_210 ( ) { if ( jj_3R_216 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_217 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_213 ( ) { if ( jj_scan_token ( BIT_ANDX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_195 ( ) { if ( jj_scan_token ( XOR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_194 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_203 ( ) { if ( jj_3R_210 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_211 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_61 ( ) { if ( jj_scan_token ( ORASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_212 ( ) { if ( jj_scan_token ( BIT_AND ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_204 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_212 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_213 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_203 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_60 ( ) { if ( jj_scan_token ( XORASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_194 ( ) { if ( jj_3R_203 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_204 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_197 ( ) { if ( jj_scan_token ( BIT_ORX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_59 ( ) { if ( jj_scan_token ( ANDASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_175 ( ) { if ( jj_3R_194 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_195 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_65 ( ) { if ( jj_scan_token ( RSIGNEDSHIFTASSIGNX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_178 ( ) { if ( jj_scan_token ( BOOL_ANDX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_196 ( ) { if ( jj_scan_token ( BIT_OR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_107 ( ) { if ( jj_scan_token ( HOOK ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_85 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_176 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_196 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_197 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_175 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_58 ( ) { if ( jj_scan_token ( MINUSASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_64 ( ) { if ( jj_scan_token ( RSIGNEDSHIFTASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_147 ( ) { if ( jj_3R_175 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_176 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_150 ( ) { if ( jj_scan_token ( BOOL_ORX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_177 ( ) { if ( jj_scan_token ( BOOL_AND ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_57 ( ) { if ( jj_scan_token ( PLUSASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_148 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_177 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_178 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_147 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_125 ( ) { if ( jj_3R_147 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_148 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_56 ( ) { if ( jj_scan_token ( MODASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_149 ( ) { if ( jj_scan_token ( BOOL_OR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_126 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_149 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_150 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_125 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_106 ( ) { if ( jj_3R_125 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_126 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_55 ( ) { if ( jj_scan_token ( SLASHASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_67 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFTASSIGNX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_63 ( ) { if ( jj_scan_token ( LSHIFTASSIGNX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_85 ( ) { if ( jj_3R_106 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_107 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_54 ( ) { if ( jj_scan_token ( STARASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_66 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFTASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_62 ( ) { if ( jj_scan_token ( LSHIFTASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_53 ( ) { if ( jj_scan_token ( ASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_32 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_53 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_54 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_55 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_56 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_57 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_58 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_59 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_60 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_61 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_62 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_63 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_64 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_65 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_66 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_67 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_9 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_84 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_45 ( ) { if ( jj_3R_85 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_26 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_44 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_45 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_44 ( ) { if ( jj_3R_84 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_8 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_28 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_8 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_77 ( ) { if ( jj_scan_token ( DOUBLE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_209 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_76 ( ) { if ( jj_scan_token ( FLOAT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_75 ( ) { if ( jj_scan_token ( LONG ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_74 ( ) { if ( jj_scan_token ( INT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_73 ( ) { if ( jj_scan_token ( SHORT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_50 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_72 ( ) { if ( jj_scan_token ( BYTE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_71 ( ) { if ( jj_scan_token ( CHAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_70 ( ) { if ( jj_scan_token ( BOOLEAN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_34 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_70 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_71 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_72 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_73 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_74 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_75 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_76 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_77 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_87 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_86 ( ) { if ( jj_scan_token ( VOID ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_46 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_86 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_87 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_7 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_49 ( ) { if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_30 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_49 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_50 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_7 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_142 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_141 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_171 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_6 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_141 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_6 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_171 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_257 ( ) { if ( jj_scan_token ( FINALLY ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_38 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_256 ( ) { if ( jj_scan_token ( CATCH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_141 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_38 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_5 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_29 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_192 ( ) { if ( jj_scan_token ( TRY ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_38 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_256 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } xsp = jj_scanpos ; if ( jj_3R_257 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_118 ( ) { if ( jj_3R_141 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_142 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_255 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_100 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_118 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_208 ( ) { if ( jj_3R_29 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_5 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_254 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_191 ( ) { if ( jj_scan_token ( THROW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_233 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_232 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_88 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_208 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_209 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_190 ( ) { if ( jj_scan_token ( RETURN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_255 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_282 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_182 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_253 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_48 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_189 ( ) { if ( jj_scan_token ( CONTINUE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_254 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_29 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_47 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_48 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_47 ( ) { if ( jj_3R_88 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_242 ( ) { if ( jj_scan_token ( ASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_29 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_243 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( STAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_188 ( ) { if ( jj_scan_token ( BREAK ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_253 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_268 ( ) { if ( jj_3R_276 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_276 ( ) { if ( jj_3R_182 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_282 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_232 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_242 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_156 ( ) { if ( jj_scan_token ( FINAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_170 ( ) { if ( jj_scan_token ( IMPORT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( STAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_137 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_156 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_232 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_233 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_43 ( ) { if ( jj_scan_token ( FINAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_27 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_43 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_139 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_4 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_170 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_4 ( ) { if ( jj_scan_token ( IMPORT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_243 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_249 ( ) { if ( jj_scan_token ( ELSE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_138 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_3 ( ) { if ( jj_3R_27 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_27 ( ) { if ( jj_3R_46 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_275 ( ) { if ( jj_3R_276 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_250 ( ) { if ( jj_3R_267 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_252 ( ) { if ( jj_3R_268 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_267 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_274 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_275 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_274 ( ) { if ( jj_3R_137 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_251 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_81 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_100 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_80 ( ) { if ( jj_3R_46 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_100 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_40 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_80 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_81 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_2 ( ) { if ( jj_3R_27 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_187 ( ) { if ( jj_scan_token ( FOR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_250 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_251 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_252 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_138 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_155 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_100 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_38 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_154 ( ) { if ( jj_3R_46 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_100 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_38 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_186 ( ) { if ( jj_scan_token ( DO ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_138 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( WHILE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_136 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_154 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_155 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_1 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_185 ( ) { if ( jj_scan_token ( WHILE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_138 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_184 ( ) { if ( jj_scan_token ( IF ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_138 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_249 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_266 ( ) { if ( jj_3R_99 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_273 ( ) { if ( jj_scan_token ( _DEFAULT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_265 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_272 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_273 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_272 ( ) { if ( jj_scan_token ( CASE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_248 ( ) { if ( jj_3R_265 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_266 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3_26 ( ) { if ( jj_3R_42 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_183 ( ) { if ( jj_scan_token ( SWITCH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_248 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_201 ( ) { if ( jj_3R_207 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_200 ( ) { if ( jj_3R_84 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_199 ( ) { if ( jj_3R_206 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_182 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_198 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_199 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_200 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_201 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_198 ( ) { if ( jj_3R_205 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_181 ( ) { if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_140 ( ) { if ( jj_scan_token ( FORMAL_COMMENT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_41 ( ) { if ( jj_scan_token ( FINAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_117 ( ) { if ( jj_3R_140 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_25 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_41 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_116 ( ) { if ( jj_3R_139 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_24 ( ) { if ( jj_3R_40 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_115 ( ) { if ( jj_3R_138 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_114 ( ) { if ( jj_3R_137 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_113 ( ) { if ( jj_3R_136 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_99 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_113 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_114 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_115 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_116 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_117 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_79 ( ) { if ( jj_3R_99 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_38 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_79 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_39 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_138 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_169 ( ) { if ( jj_3R_192 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_168 ( ) { if ( jj_3R_191 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_167 ( ) { if ( jj_3R_190 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_166 ( ) { if ( jj_3R_189 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_165 ( ) { if ( jj_3R_188 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_164 ( ) { if ( jj_3R_187 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_163 ( ) { if ( jj_3R_186 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_162 ( ) { if ( jj_3R_185 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_161 ( ) { if ( jj_3R_184 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_160 ( ) { if ( jj_3R_183 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_19 ( ) { if ( jj_3R_38 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_159 ( ) { if ( jj_3R_182 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_158 ( ) { if ( jj_3R_181 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_157 ( ) { if ( jj_3R_38 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_138 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_23 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_157 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_158 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_159 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_160 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_161 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_162 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_163 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_164 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_165 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_166 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_167 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_168 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_169 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_23 ( ) { if ( jj_3R_39 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_174 ( ) { if ( jj_3R_78 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_19 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_202 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_173 ( ) { if ( jj_3R_172 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_193 ( ) { Token xsp ; if ( jj_3R_202 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_202 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_3R_88 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_21 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_22 ( ) { Token xsp ; if ( jj_3_21 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_21 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_172 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_22 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_193 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_143 ( ) { if ( jj_scan_token ( NEW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_173 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_174 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_119 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_20 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_143 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_20 ( ) { if ( jj_scan_token ( NEW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_172 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_135 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_112 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_135 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_98 ( ) { if ( jj_3R_112 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_78 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_98 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_153 ( ) { if ( jj_scan_token ( VOID ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_152 ( ) { if ( jj_scan_token ( NULL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_180 ( ) { if ( jj_scan_token ( FALSE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_151 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_179 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_180 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_179 ( ) { if ( jj_scan_token ( TRUE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_134 ( ) { if ( jj_3R_153 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_133 ( ) { if ( jj_3R_152 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_132 ( ) { if ( jj_3R_151 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_131 ( ) { if ( jj_scan_token ( STRING_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_130 ( ) { if ( jj_scan_token ( CHARACTER_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_129 ( ) { if ( jj_scan_token ( FLOATING_POINT_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_128 ( ) { if ( jj_scan_token ( INTEGER_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_111 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_128 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_129 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_130 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_131 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_132 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_133 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_134 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_127 ( ) { if ( jj_3R_78 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_110 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_52 ( ) { if ( jj_3R_91 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_109 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_127 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_108 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_91 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_108 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_109 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_110 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_18 ( ) { if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_31 ( ) { if ( jj_3R_51 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_52 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_90 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_89 ( ) { if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_51 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_89 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_90 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_146 ( ) { if ( jj_3R_78 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_97 ( ) { if ( jj_3R_111 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_124 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_96 ( ) { if ( jj_scan_token ( NEW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_123 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_146 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_122 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_105 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_17 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_122 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_123 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_124 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_17 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( CLASS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_15 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( CLASS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_145 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_16 ( ) { if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_144 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_121 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_144 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_145 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_120 ( ) { if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_36 ( ) { if ( jj_scan_token ( DECR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_95 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_83 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_104 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_120 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_121 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_35 ( ) { if ( jj_scan_token ( INCR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_103 ( ) { if ( jj_3R_119 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_102 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_94 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_101 ( ) { if ( jj_3R_111 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_82 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_101 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_102 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_103 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_104 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_93 ( ) { if ( jj_scan_token ( BANG ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_37 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_78 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_14 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_281 ( ) { if ( jj_scan_token ( DECR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_92 ( ) { if ( jj_scan_token ( TILDE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_42 ( ) { if ( jj_3R_82 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_83 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_287 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_271 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_286 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_244 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_280 ( ) { if ( jj_scan_token ( INCR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_13 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_35 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_36 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_285 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_286 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_287 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_215 ( ) { if ( jj_3R_42 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_12 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_207 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_214 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_215 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_214 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_280 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_281 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_69 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_92 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_93 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_94 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_95 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_96 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_97 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_10 ( ) { if ( jj_3R_33 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_68 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } public ParserTokenManager token_source ; ASCII_UCodeESC_CharStream jj_input_stream ; public Token token , jj_nt ; private int jj_ntk ; private Token jj_scanpos , jj_lastpos ; private int jj_la ; public boolean lookingAhead = false ; private boolean jj_semLA ; private int jj_gen ; final private int [ ] jj_la1 = new int [ 88 ] ; final private int [ ] jj_la1_0 = { 0x6db52c00 , 0x6db52c01 , 0x0 , 0x0 , 0x0 , 0x40000000 , 0x0 , 0x4a12400 , 0x4a12400 , 0x0 , 0x0 , 0x4212400 , 0x0 , 0x4212400 , 0x4212400 , 0x4212400 , 0x4a12400 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x80000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x4a12400 , 0x0 , 0x0 , 0x4a12400 , 0x800000 , 0x0 , 0x0 , 0x4a12400 , 0x0 , 0x0 , 0x0 , 0x4212400 , 0x4a12400 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x800000 , 0x800000 , 0x4a12400 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x2cb52c00 , 0x6db52c00 , 0x6cb52c00 , 0x0 , 0x4a12400 , 0x84000 , 0x6db52c00 , 0x84000 , 0x400000 , 0x5a12400 , 0x4a12400 , 0x4a12400 , 0x4a12400 , 0x1000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x4a12400 , 0x8000 , 0x2000000 , } ; final private int [ ] jj_la1_1 = { 0xa7a3fb1d , 0xa7a3fb1d , 0x4000000 , 0x4000000 , 0x0 , 0x0 , 0x0 , 0xa5a2a21d , 0xa5a2a21d , 0x0 , 0x0 , 0x4000205 , 0x4000000 , 0x4000205 , 0x4008205 , 0x205 , 0x25a2a21d , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x25a2a21d , 0x0 , 0x0 , 0x25a2a21d , 0x25a2a018 , 0x20000000 , 0x0 , 0x25a2a21d , 0x20000000 , 0x80000000 , 0x4000000 , 0x4000205 , 0x25a2a21d , 0x20000000 , 0x80000000 , 0x4000000 , 0x80000000 , 0x20000000 , 0x80000000 , 0x1a2a010 , 0x2000 , 0x25a2a21d , 0x0 , 0x20000000 , 0x8 , 0x0 , 0x0 , 0xa5a3fb1d , 0xa7a3fb1d , 0xa7a3fb1d , 0x0 , 0x25a2a21d , 0x0 , 0xa7a3fb1d , 0x0 , 0x0 , 0x25a2a21d , 0x25a2a21d , 0x25a2a21d , 0x25a2a21d , 0x0 , 0x0 , 0x0 , 0x4000000 , 0x4000000 , 0x25a2a21d , 0x0 , 0x0 , } ; final private int [ ] jj_la1_2 = { 0x6000008 , 0x1e001808 , 0x0 , 0x0 , 0x20 , 0x0 , 0x40 , 0x1e001800 , 0x1e001800 , 0x10 , 0x10 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x1e001800 , 0x40 , 0x2000 , 0x600000 , 0x600000 , 0x1800000 , 0x1800000 , 0x0 , 0x0 , 0x0 , 0x80000000 , 0x80000000 , 0x108000 , 0x108000 , 0x0 , 0xf0780 , 0xf0780 , 0x0 , 0x0 , 0x18000000 , 0x18000000 , 0x60000000 , 0x60000000 , 0x18000000 , 0x1e001800 , 0x1800 , 0x1800 , 0x0 , 0x1800 , 0x0 , 0x6000000 , 0x0 , 0x0 , 0x22 , 0x0 , 0x0 , 0x0 , 0x0 , 0x22 , 0x0 , 0x22 , 0x0 , 0x22 , 0x0 , 0x0 , 0x1e001800 , 0x10 , 0x2 , 0x0 , 0x2 , 0x2 , 0x6000008 , 0x6000008 , 0x6000008 , 0x6000000 , 0x0 , 0x0 , 0x6000008 , 0x0 , 0x0 , 0x6000000 , 0x1e001800 , 0x6000000 , 0x6000000 , 0x0 , 0x10 , 0x10 , 0x0 , 0x0 , 0x1e001800 , 0x0 , 0x0 , } ; final private int [ ] jj_la1_3 = { 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x7faf800 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x6 , 0x6 , 0x8 , 0x1 , 0x1 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x7e0 , 0x7e0 , 0x0 , 0x0 , 0x10 , 0x10 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , } ; final private JJCalls [ ] jj_2_rtns = new JJCalls [ 27 ] ; private boolean jj_rescan = false ; private int jj_gc = 0 ; public Parser ( java . io . InputStream stream ) { jj_input_stream = new ASCII_UCodeESC_CharStream ( stream , 1 , 1 ) ; token_source = new ParserTokenManager ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 88 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( java . io . InputStream stream ) { jj_input_stream . ReInit ( stream , 1 , 1 ) ; token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 88 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public Parser ( java . io . Reader stream ) { jj_input_stream = new ASCII_UCodeESC_CharStream ( stream , 1 , 1 ) ; token_source = new ParserTokenManager ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 88 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( java . io . Reader stream ) { jj_input_stream . ReInit ( stream , 1 , 1 ) ; token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 88 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public Parser ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 88 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 88 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } final private Token jj_consume_token ( int kind ) throws ParseException { Token oldToken ; if ( ( oldToken = token ) . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; if ( token . kind == kind ) { jj_gen ++ ; if ( ++ jj_gc > 100 ) { jj_gc = 0 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) { JJCalls c = jj_2_rtns [ i ] ; while ( c != null ) { if ( c . gen < jj_gen ) c . first = null ; c = c . next ; } } } return token ; } token = oldToken ; jj_kind = kind ; throw generateParseException ( ) ; } final private boolean jj_scan_token ( int kind ) { if ( jj_scanpos == jj_lastpos ) { jj_la -- ; if ( jj_scanpos . next == null ) { jj_lastpos = jj_scanpos = jj_scanpos . next = token_source . getNextToken ( ) ; } else { jj_lastpos = jj_scanpos = jj_scanpos . next ; } } else { jj_scanpos = jj_scanpos . next ; } if ( jj_rescan ) { int i = 0 ; Token tok = token ; while ( tok != null && tok != jj_scanpos ) { i ++ ; tok = tok . next ; } if ( tok != null ) jj_add_error_token ( kind , i ) ; } return ( jj_scanpos . kind != kind ) ; } final public Token getNextToken ( ) { if ( token . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen ++ ; return token ; } final public Token getToken ( int index ) { Token t = lookingAhead ? jj_scanpos : token ; for ( int i = 0 ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token_source . getNextToken ( ) ; } return t ; } final private int jj_ntk ( ) { if ( ( jj_nt = token . next ) == null ) return ( jj_ntk = ( token . next = token_source . getNextToken ( ) ) . kind ) ; else return ( jj_ntk = jj_nt . kind ) ; } private java . util . Vector jj_expentries = new java . util . Vector ( ) ; private int [ ] jj_expentry ; private int jj_kind = - 1 ; private int [ ] jj_lasttokens = new int [ 100 ] ; private int jj_endpos ; private void jj_add_error_token ( int kind , int pos ) { if ( pos >= 100 ) return ; if ( pos == jj_endpos + 1 ) { jj_lasttokens [ jj_endpos ++ ] = kind ; } else if ( jj_endpos != 0 ) { jj_expentry = new int [ jj_endpos ] ; for ( int i = 0 ; i < jj_endpos ; i ++ ) { jj_expentry [ i ] = jj_lasttokens [ i ] ; } boolean exists = false ; for ( java . util . Enumeration enum = jj_expentries . elements ( ) ; enum . hasMoreElements ( ) ; ) { int [ ] oldentry = ( int [ ] ) ( enum . nextElement ( ) ) ; if ( oldentry . length == jj_expentry . length ) { exists = true ; for ( int i = 0 ; i < jj_expentry . length ; i ++ ) { if ( oldentry [ i ] != jj_expentry [ i ] ) { exists = false ; break ; } } if ( exists ) break ; } } if ( ! exists ) jj_expentries . addElement ( jj_expentry ) ; if ( pos != 0 ) jj_lasttokens [ ( jj_endpos = pos ) - 1 ] = kind ; } } final public ParseException generateParseException ( ) { jj_expentries . removeAllElements ( ) ; boolean [ ] la1tokens = new boolean [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { la1tokens [ i ] = false ; } if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 88 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } if ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 64 + j ] = true ; } if ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 96 + j ] = true ; } } } } for ( int i = 0 ; i < 123 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . addElement ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = ( int [ ] ) jj_expentries . elementAt ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; } final public void enable_tracing ( ) { } final public void disable_tracing ( ) { } final private void jj_rescan_token ( ) { jj_rescan = true ; for ( int i = 0 ; i < 27 ; i ++ ) { JJCalls p = jj_2_rtns [ i ] ; do { if ( p . gen > jj_gen ) { jj_la = p . arg ; jj_lastpos = jj_scanpos = p . first ; switch ( i ) { case 0 : jj_3_1 ( ) ; break ; case 1 : jj_3_2 ( ) ; break ; case 2 : jj_3_3 ( ) ; break ; case 3 : jj_3_4 ( ) ; break ; case 4 : jj_3_5 ( ) ; break ; case 5 : jj_3_6 ( ) ; break ; case 6 : jj_3_7 ( ) ; break ; case 7 : jj_3_8 ( ) ; break ; case 8 : jj_3_9 ( ) ; break ; case 9 : jj_3_10 ( ) ; break ; case 10 : jj_3_11 ( ) ; break ; case 11 : jj_3_12 ( ) ; break ; case 12 : jj_3_13 ( ) ; break ; case 13 : jj_3_14 ( ) ; break ; case 14 : jj_3_15 ( ) ; break ; case 15 : jj_3_16 ( ) ; break ; case 16 : jj_3_17 ( ) ; break ; case 17 : jj_3_18 ( ) ; break ; case 18 : jj_3_19 ( ) ; break ; case 19 : jj_3_20 ( ) ; break ; case 20 : jj_3_21 ( ) ; break ; case 21 : jj_3_22 ( ) ; break ; case 22 : jj_3_23 ( ) ; break ; case 23 : jj_3_24 ( ) ; break ; case 24 : jj_3_25 ( ) ; break ; case 25 : jj_3_26 ( ) ; break ; case 26 : jj_3_27 ( ) ; break ; } } p = p . next ; } while ( p != null ) ; } jj_rescan = false ; } final private void jj_save ( int index , int xla ) { JJCalls p = jj_2_rtns [ index ] ; while ( p . gen > jj_gen ) { if ( p . next == null ) { p = p . next = new JJCalls ( ) ; break ; } p = p . next ; } p . gen = jj_gen + xla - jj_la ; p . first = token ; p . arg = xla ; } static final class JJCalls { int gen ; Token first ; int arg ; JJCalls next ; } } 	0	['413', '1', '0', '48', '505', '0', '1', '48', '87', '0.727688574', '23590', '0.769230769', '8', '0', '0.138014528', '0', '0', '56.05569007', '46', '5.4673', '0']
package bsh ; import java . io . * ; class CommandLineReader extends FilterReader { public CommandLineReader ( Reader in ) { super ( in ) ; } static final int normal = 0 , lastCharNL = 1 , sentSemi = 2 ; int state = lastCharNL ; public int read ( ) throws IOException { int b ; if ( state == sentSemi ) { state = lastCharNL ; return '\n' ; } while ( ( b = in . read ( ) ) == '\r' ) ; if ( b == '\n' ) if ( state == lastCharNL ) { b = ';' ; state = sentSemi ; } else state = lastCharNL ; else state = normal ; return b ; } public int read ( char buff [ ] , int off , int len ) throws IOException { int b = read ( ) ; if ( b == - 1 ) return - 1 ; else { buff [ off ] = ( char ) b ; return 1 ; } } public static void main ( String [ ] args ) throws Exception { Reader in = new CommandLineReader ( new InputStreamReader ( System . in ) ) ; while ( true ) System . out . println ( in . read ( ) ) ; } } 	0	['4', '3', '0', '1', '8', '4', '1', '0', '4', '1', '82', '0', '0', '0.857142857', '0.35', '2', '2', '18.5', '1', '0.75', '0']
package org . gjt . sp . jedit . syntax ; import javax . swing . text . * ; import java . awt . font . * ; import java . awt . geom . * ; import java . awt . * ; import org . gjt . sp . jedit . syntax . * ; public class Chunk extends Token { public static boolean DEBUG = false ; public static float paintChunkList ( Segment lineText , Chunk chunks , Graphics2D gfx , float x , float y , Color background , boolean glyphVector ) { FontMetrics forBackground = gfx . getFontMetrics ( ) ; float _x = 0.0f ; for ( ; ; ) { if ( chunks == null ) return _x ; Chunk start = chunks ; float width = 0.0f ; int length = 0 ; while ( chunks != null && start . style == chunks . style && ( start . visible == chunks . visible ) && ( start . accessable == chunks . accessable ) ) { length += chunks . length ; width += chunks . width ; chunks = ( Chunk ) chunks . next ; } if ( DEBUG ) { gfx . draw ( new Rectangle2D . Float ( x + _x , y - 10 , width , 10 ) ) ; } if ( start . accessable ) { Color bgColor = start . style . getBackgroundColor ( ) ; if ( bgColor != null ) { Graphics2D xorGfx = ( Graphics2D ) gfx . create ( ) ; xorGfx . setXORMode ( background ) ; xorGfx . setColor ( bgColor ) ; xorGfx . fill ( new Rectangle2D . Float ( x + _x , y - forBackground . getAscent ( ) , _x + width - _x , forBackground . getHeight ( ) ) ) ; xorGfx . dispose ( ) ; } if ( start . visible ) { gfx . setFont ( start . style . getFont ( ) ) ; gfx . setColor ( start . style . getForegroundColor ( ) ) ; if ( glyphVector && start . gv != null && start . next == chunks ) gfx . drawGlyphVector ( start . gv , x + _x , y ) ; else { gfx . drawChars ( lineText . array , lineText . offset + start . offset , length , ( int ) ( x + _x ) , ( int ) y ) ; } } } _x += width ; } } public static float offsetToX ( Chunk chunks , int offset ) { if ( chunks != null && offset < chunks . offset ) { throw new ArrayIndexOutOfBoundsException ( offset + " < " + chunks . offset ) ; } float x = 0.0f ; while ( chunks != null ) { if ( chunks . accessable && offset < chunks . offset + chunks . length ) return x + chunks . offsetToX ( offset - chunks . offset ) ; x += chunks . width ; chunks = ( Chunk ) chunks . next ; } return x ; } public static int xToOffset ( Chunk chunks , float x , boolean round ) { float _x = 0.0f ; while ( chunks != null ) { if ( chunks . accessable && x < _x + chunks . width ) return chunks . xToOffset ( x - _x , round ) ; _x += chunks . width ; chunks = ( Chunk ) chunks . next ; } return - 1 ; } public boolean accessable ; public boolean visible ; public boolean monospaced ; public float charWidth ; public SyntaxStyle style ; public float width ; public GlyphVector gv ; public Chunk ( float width , int offset , ParserRuleSet rules ) { super ( Token . NULL , offset , 0 , rules ) ; this . width = width ; } public Chunk ( byte id , int offset , int length , ParserRuleSet rules ) { super ( id , offset , length , rules ) ; accessable = true ; } public final float [ ] getPositions ( ) { if ( gv == null ) return null ; if ( positions == null ) positions = gv . getGlyphPositions ( 0 , length , null ) ; return positions ; } public final float offsetToX ( int offset ) { if ( ! visible ) return 0.0f ; else if ( monospaced ) return offset * charWidth ; else return getPositions ( ) [ offset * 2 ] ; } public final int xToOffset ( float x , boolean round ) { if ( ! visible ) { if ( round && width - x < x ) return offset + length ; else return offset ; } else if ( monospaced ) { x = Math . max ( 0 , x ) ; float remainder = x % charWidth ; int i = ( int ) ( x / charWidth ) ; if ( round && remainder > charWidth / 2 ) return offset + i + 1 ; else return offset + i ; } else { float [ ] pos = getPositions ( ) ; for ( int i = 0 ; i < length ; i ++ ) { float glyphX = pos [ i * 2 ] ; float nextX = ( i == length - 1 ? width : pos [ i * 2 + 2 ] ) ; if ( nextX > x ) { if ( ! round || nextX - x > x - glyphX ) return offset + i ; else return offset + i + 1 ; } } } return - 1 ; } public void init ( Segment seg , TabExpander expander , float x , SyntaxStyle [ ] styles , FontRenderContext fontRenderContext , byte defaultID , float charWidth ) { style = styles [ ( id == Token . WHITESPACE || id == Token . TAB ) ? defaultID : id ] ; if ( length == 1 && seg . array [ seg . offset + offset ] == '\t' ) { visible = false ; float newX = expander . nextTabStop ( x , offset + length ) ; width = newX - x ; } else if ( charWidth != 0.0f ) { visible = monospaced = true ; this . charWidth = charWidth ; width = charWidth * length ; } else { visible = true ; String str = new String ( seg . array , seg . offset + offset , length ) ; gv = style . getFont ( ) . createGlyphVector ( fontRenderContext , str ) ; width = ( float ) gv . getLogicalBounds ( ) . getWidth ( ) ; } } private float [ ] positions ; } 	0	['10', '2', '0', '10', '39', '0', '7', '3', '9', '0.641975309', '552', '0.111111111', '1', '0.3', '0.273504274', '0', '0', '53.3', '13', '4.7', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . jedit . * ; public class SelectLineRange extends EnhancedDialog implements ActionListener { public SelectLineRange ( View view ) { super ( view , jEdit . getProperty ( "selectlinerange.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 0 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "selectlinerange.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 12 ) ) ; content . add ( BorderLayout . NORTH , label ) ; JPanel panel = createFieldPanel ( ) ; content . add ( BorderLayout . CENTER , panel ) ; panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 6 , 0 , 0 , 12 ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( this ) ; getRootPane ( ) . setDefaultButton ( ok ) ; panel . add ( ok ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( this ) ; panel . add ( cancel ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( panel , BorderLayout . SOUTH ) ; GUIUtilities . requestFocus ( this , startField ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { int startLine ; int endLine ; try { startLine = Integer . parseInt ( startField . getText ( ) ) - 1 ; endLine = Integer . parseInt ( endField . getText ( ) ) - 1 ; } catch ( NumberFormatException nf ) { getToolkit ( ) . beep ( ) ; return ; } Buffer buffer = view . getBuffer ( ) ; if ( startLine < 0 || endLine >= buffer . getLineCount ( ) || startLine > endLine ) { getToolkit ( ) . beep ( ) ; return ; } JEditTextArea textArea = view . getTextArea ( ) ; textArea . setSelection ( new Selection . Range ( buffer . getLineStartOffset ( startLine ) , buffer . getLineEndOffset ( endLine ) - 1 ) ) ; textArea . moveCaretPosition ( buffer . getLineEndOffset ( endLine ) - 1 ) ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; } private View view ; private JTextField startField ; private JTextField endField ; private JButton ok ; private JButton cancel ; private JPanel createFieldPanel ( ) { GridBagLayout layout = new GridBagLayout ( ) ; JPanel panel = new JPanel ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . insets = new Insets ( 0 , 0 , 6 , 12 ) ; cons . gridwidth = cons . gridheight = 1 ; cons . gridx = cons . gridy = 0 ; cons . fill = GridBagConstraints . BOTH ; JLabel label = new JLabel ( jEdit . getProperty ( "selectlinerange.start" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; startField = new JTextField ( 10 ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( startField , cons ) ; panel . add ( startField ) ; label = new JLabel ( jEdit . getProperty ( "selectlinerange.end" ) , SwingConstants . RIGHT ) ; cons . gridx = 0 ; cons . weightx = 0.0f ; cons . gridy = 1 ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; endField = new JTextField ( 10 ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( endField , cons ) ; panel . add ( endField ) ; return panel ; } } 	0	['5', '7', '0', '8', '50', '2', '1', '8', '4', '0.5', '362', '1', '1', '0.993939394', '0.466666667', '0', '0', '70.4', '4', '1.8', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import java . io . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class GeneralOptionPane extends AbstractOptionPane { public GeneralOptionPane ( ) { super ( "general" ) ; } protected void _init ( ) { history = new JTextField ( jEdit . getProperty ( "history" ) ) ; addComponent ( jEdit . getProperty ( "options.general.history" ) , history ) ; saveCaret = new JCheckBox ( jEdit . getProperty ( "options.general.saveCaret" ) ) ; saveCaret . setSelected ( jEdit . getBooleanProperty ( "saveCaret" ) ) ; addComponent ( saveCaret ) ; sortBuffers = new JCheckBox ( jEdit . getProperty ( "options.general.sortBuffers" ) ) ; sortBuffers . setSelected ( jEdit . getBooleanProperty ( "sortBuffers" ) ) ; sortBuffers . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { sortByName . setEnabled ( sortBuffers . isSelected ( ) ) ; } } ) ; addComponent ( sortBuffers ) ; sortByName = new JCheckBox ( jEdit . getProperty ( "options.general.sortByName" ) ) ; sortByName . setSelected ( jEdit . getBooleanProperty ( "sortByName" ) ) ; sortByName . setEnabled ( sortBuffers . isSelected ( ) ) ; addComponent ( sortByName ) ; sortRecent = new JCheckBox ( jEdit . getProperty ( "options.general.sortRecent" ) ) ; sortRecent . setSelected ( jEdit . getBooleanProperty ( "sortRecent" ) ) ; addComponent ( sortRecent ) ; checkModStatus = new JCheckBox ( jEdit . getProperty ( "options.general.checkModStatus" ) ) ; checkModStatus . setSelected ( jEdit . getBooleanProperty ( "view.checkModStatus" ) ) ; addComponent ( checkModStatus ) ; showFullPath = new JCheckBox ( jEdit . getProperty ( "options.general.showFullPath" ) ) ; showFullPath . setSelected ( jEdit . getBooleanProperty ( "view.showFullPath" ) ) ; addComponent ( showFullPath ) ; showSearchbar = new JCheckBox ( jEdit . getProperty ( "options.general.showSearchbar" ) ) ; showSearchbar . setSelected ( jEdit . getBooleanProperty ( "view.showSearchbar" ) ) ; addComponent ( showSearchbar ) ; beepOnSearchAutoWrap = new JCheckBox ( jEdit . getProperty ( "options.general.beepOnSearchAutoWrap" ) ) ; beepOnSearchAutoWrap . setSelected ( jEdit . getBooleanProperty ( "search.beepOnSearchAutoWrap" ) ) ; addComponent ( beepOnSearchAutoWrap ) ; showBufferSwitcher = new JCheckBox ( jEdit . getProperty ( "options.general.showBufferSwitcher" ) ) ; showBufferSwitcher . setSelected ( jEdit . getBooleanProperty ( "view.showBufferSwitcher" ) ) ; addComponent ( showBufferSwitcher ) ; showTips = new JCheckBox ( jEdit . getProperty ( "options.general.showTips" ) ) ; showTips . setSelected ( jEdit . getBooleanProperty ( "tip.show" ) ) ; addComponent ( showTips ) ; showSplash = new JCheckBox ( jEdit . getProperty ( "options.general.showSplash" ) ) ; String settingsDirectory = jEdit . getSettingsDirectory ( ) ; if ( settingsDirectory == null ) showSplash . setSelected ( true ) ; else showSplash . setSelected ( ! new File ( settingsDirectory , "nosplash" ) . exists ( ) ) ; addComponent ( showSplash ) ; } protected void _save ( ) { jEdit . setProperty ( "history" , history . getText ( ) ) ; jEdit . setBooleanProperty ( "saveCaret" , saveCaret . isSelected ( ) ) ; jEdit . setBooleanProperty ( "sortBuffers" , sortBuffers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "sortByName" , sortByName . isSelected ( ) ) ; jEdit . setBooleanProperty ( "sortRecent" , sortRecent . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.checkModStatus" , checkModStatus . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.showFullPath" , showFullPath . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.showSearchbar" , showSearchbar . isSelected ( ) ) ; jEdit . setBooleanProperty ( "search.beepOnSearchAutoWrap" , beepOnSearchAutoWrap . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.showBufferSwitcher" , showBufferSwitcher . isSelected ( ) ) ; jEdit . setBooleanProperty ( "tip.show" , showTips . isSelected ( ) ) ; String settingsDirectory = jEdit . getSettingsDirectory ( ) ; if ( settingsDirectory != null ) { File file = new File ( settingsDirectory , "nosplash" ) ; if ( showSplash . isSelected ( ) ) file . delete ( ) ; else { try { FileOutputStream out = new FileOutputStream ( file ) ; out . write ( '\n' ) ; out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; } } } } private JTextField history ; private JCheckBox saveCaret ; private JCheckBox sortBuffers ; private JCheckBox sortByName ; private JCheckBox sortRecent ; private JCheckBox checkModStatus ; private JCheckBox showFullPath ; private JCheckBox showSearchbar ; private JCheckBox beepOnSearchAutoWrap ; private JCheckBox showBufferSwitcher ; private JCheckBox showTips ; private JCheckBox showSplash ; } 	0	['5', '6', '0', '5', '28', '0', '2', '4', '1', '0.708333333', '338', '1', '0', '0.994056464', '0.5', '2', '4', '64.2', '3', '1.6', '0']
package org . gjt . sp . jedit . gui ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . * ; public class ToolBarManager { public ToolBarManager ( Container top , Container bottom ) { this . top = top ; this . bottom = bottom ; } public void addToolBar ( int group , int layer , Component toolbar ) { Entry entry = new Entry ( layer , toolbar ) ; if ( group == View . TOP_GROUP ) addToolBar ( top , topToolBars , entry ) ; else if ( group == View . BOTTOM_GROUP ) addToolBar ( bottom , bottomToolBars , entry ) ; else throw new InternalError ( "Invalid tool bar group" ) ; } public void removeToolBar ( Component toolbar ) { removeToolBar ( top , topToolBars , toolbar ) ; removeToolBar ( bottom , bottomToolBars , toolbar ) ; } private Container top ; private Container bottom ; private ArrayList topToolBars = new ArrayList ( ) ; private ArrayList bottomToolBars = new ArrayList ( ) ; private void addToolBar ( Container group , ArrayList toolbars , Entry entry ) { for ( int i = 0 ; i < toolbars . size ( ) ; i ++ ) { if ( entry . layer > ( ( Entry ) toolbars . get ( i ) ) . layer ) { toolbars . add ( i , entry ) ; group . add ( entry . toolbar , i ) ; return ; } } toolbars . add ( entry ) ; group . add ( entry . toolbar ) ; } private void removeToolBar ( Container group , ArrayList toolbars , Component toolbar ) { for ( int i = 0 ; i < toolbars . size ( ) ; i ++ ) { if ( toolbar == ( ( Entry ) toolbars . get ( i ) ) . toolbar ) { group . remove ( toolbar ) ; toolbars . remove ( i ) ; return ; } } } static class Entry { int layer ; Component toolbar ; Entry ( int layer , Component toolbar ) { this . layer = layer ; this . toolbar = toolbar ; } } } 	0	['5', '1', '0', '2', '17', '4', '1', '1', '3', '0.5', '137', '1', '0', '0', '0.5', '0', '0', '25.6', '3', '2', '0']
package bsh ; interface Node extends java . io . Serializable { public void jjtOpen ( ) ; public void jjtClose ( ) ; public void jjtSetParent ( Node n ) ; public Node jjtGetParent ( ) ; public void jjtAddChild ( Node n , int i ) ; public Node jjtGetChild ( int i ) ; public int jjtGetNumChildren ( ) ; } 	0	['7', '1', '0', '36', '7', '21', '36', '0', '7', '2', '7', '0', '0', '0', '0.523809524', '0', '0', '0', '1', '1', '0']
package bsh ; class BSHBinaryExpression extends SimpleNode implements ParserConstants { public int kind ; BSHBinaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object lhs = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( kind == INSTANCEOF ) { if ( lhs == Primitive . NULL ) return new Primitive ( false ) ; if ( lhs instanceof Primitive ) return new Primitive ( false ) ; NameSpace namespace = callstack . top ( ) ; Class rhs = ( ( BSHType ) jjtGetChild ( 1 ) ) . getType ( namespace ) ; boolean ret = ( Reflect . isAssignableFrom ( rhs , lhs . getClass ( ) ) ) ; return new Primitive ( ret ) ; } if ( kind == BOOL_AND || kind == BOOL_ANDX ) { Object obj = lhs ; if ( isPrimitiveValue ( lhs ) ) obj = ( ( Primitive ) lhs ) . getValue ( ) ; if ( obj instanceof Boolean && ( ( ( Boolean ) obj ) . booleanValue ( ) == false ) ) return new Primitive ( false ) ; } if ( kind == BOOL_OR || kind == BOOL_ORX ) { Object obj = lhs ; if ( isPrimitiveValue ( lhs ) ) obj = ( ( Primitive ) lhs ) . getValue ( ) ; if ( obj instanceof Boolean && ( ( ( Boolean ) obj ) . booleanValue ( ) == true ) ) return new Primitive ( true ) ; } boolean isLhsWrapper = isWrapper ( lhs ) ; Object rhs = ( ( SimpleNode ) jjtGetChild ( 1 ) ) . eval ( callstack , interpreter ) ; boolean isRhsWrapper = isWrapper ( rhs ) ; if ( ( isLhsWrapper || isPrimitiveValue ( lhs ) ) && ( isRhsWrapper || isPrimitiveValue ( rhs ) ) ) { if ( ( isLhsWrapper && isRhsWrapper && kind == EQ ) ) { } else try { return Primitive . binaryOperation ( lhs , rhs , kind ) ; } catch ( TargetError e ) { e . reThrow ( this ) ; } } switch ( kind ) { case EQ : return new Primitive ( ( lhs == rhs ) ) ; case NE : return new Primitive ( ( lhs != rhs ) ) ; case PLUS : if ( lhs instanceof String || rhs instanceof String ) return lhs . toString ( ) + rhs . toString ( ) ; default : if ( lhs instanceof Primitive || rhs instanceof Primitive ) if ( lhs == Primitive . VOID || rhs == Primitive . VOID ) throw new EvalError ( "illegal use of undefined variable, class, or 'void' literal" , this ) ; else if ( lhs == Primitive . NULL || rhs == Primitive . NULL ) throw new EvalError ( "illegal use of null value or 'null' literal" , this ) ; throw new EvalError ( "Operator: '" + tokenImage [ kind ] + "' inappropriate for objects" , this ) ; } } private boolean isPrimitiveValue ( Object obj ) { return ( ( obj instanceof Primitive ) && ( obj != Primitive . VOID ) && ( obj != Primitive . NULL ) ) ; } private boolean isWrapper ( Object obj ) { return ( obj instanceof Boolean || obj instanceof Character || obj instanceof Number ) ; } } 	0	['4', '2', '0', '12', '21', '6', '1', '11', '1', '1', '280', '0', '0', '0.857142857', '0.45', '1', '1', '68.75', '4', '2.25', '0']
package bsh ; import java . io . IOException ; public class This implements java . io . Serializable , Runnable { NameSpace namespace ; transient Interpreter declaringInterpreter ; static This getThis ( NameSpace namespace , Interpreter declaringInterpreter ) { try { if ( Capabilities . canGenerateInterfaces ( ) ) return ( This ) Reflect . constructObject ( "bsh.XThis" , new Object [ ] { namespace , declaringInterpreter } ) ; else if ( Capabilities . haveSwing ( ) ) return ( This ) Reflect . constructObject ( "bsh.JThis" , new Object [ ] { namespace , declaringInterpreter } ) ; else return new This ( namespace , declaringInterpreter ) ; } catch ( Exception e ) { throw new InterpreterError ( "internal error 1 in This: " + e ) ; } } public Object getInterface ( Class clas ) throws EvalError { if ( clas . isInstance ( this ) ) return this ; else throw new EvalError ( "Dynamic proxy mechanism not available. " + "Cannot construct interface type: " + clas ) ; } protected This ( NameSpace namespace , Interpreter declaringInterpreter ) { this . namespace = namespace ; this . declaringInterpreter = declaringInterpreter ; } public NameSpace getNameSpace ( ) { return namespace ; } public String toString ( ) { return "'this' reference to Bsh object: " + namespace . name ; } public void run ( ) { try { invokeMethod ( "run" , new Object [ 0 ] ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "Exception in runnable:" + e ) ; } } public Object invokeMethod ( String name , Object [ ] args ) throws EvalError { return invokeMethod ( name , args , declaringInterpreter , null , null ) ; } public Object invokeMethod ( String name , Object [ ] args , Interpreter interpreter , CallStack callstack , SimpleNode callerInfo ) throws EvalError { return namespace . invokeMethod ( name , args , interpreter , callstack , callerInfo ) ; } public static void bind ( This ths , NameSpace namespace , Interpreter declaringInterpreter ) { ths . namespace . setParent ( namespace ) ; ths . declaringInterpreter = declaringInterpreter ; } CallStack newCallStack ( ) { CallStack callstack = new CallStack ( ) ; callstack . push ( namespace ) ; return callstack ; } } 	0	['10', '1', '2', '14', '26', '5', '9', '8', '7', '0.388888889', '161', '0', '2', '0', '0.255555556', '0', '0', '14.9', '3', '1.1', '0']
package bsh ; import java . util . Vector ; class BSHTryStatement extends SimpleNode { BSHTryStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { BSHBlock tryBlock = ( ( BSHBlock ) jjtGetChild ( 0 ) ) ; Vector catchParams = new Vector ( ) ; Vector catchBlocks = new Vector ( ) ; int nchild = jjtGetNumChildren ( ) ; Node node = null ; int i = 1 ; while ( ( i < nchild ) && ( ( node = jjtGetChild ( i ++ ) ) instanceof BSHFormalParameter ) ) { catchParams . addElement ( node ) ; catchBlocks . addElement ( jjtGetChild ( i ++ ) ) ; node = null ; } BSHBlock finallyBlock = null ; if ( node != null ) finallyBlock = ( BSHBlock ) node ; TargetError target = null ; Throwable thrown = null ; Object ret = null ; int callstackDepth = callstack . depth ( ) ; try { ret = tryBlock . eval ( callstack , interpreter ) ; } catch ( TargetError e ) { target = e ; String stackInfo = "Bsh Stack: " ; while ( callstack . depth ( ) > callstackDepth ) stackInfo += "\t" + callstack . pop ( ) + "\n" ; } if ( target != null ) thrown = target . getTarget ( ) ; if ( thrown != null ) { int n = catchParams . size ( ) ; for ( i = 0 ; i < n ; i ++ ) { BSHFormalParameter fp = ( BSHFormalParameter ) catchParams . elementAt ( i ) ; fp . eval ( callstack . top ( ) ) ; if ( fp . type != null ) try { thrown = ( Throwable ) NameSpace . getAssignableForm ( thrown , fp . type ) ; } catch ( EvalError e ) { continue ; } BSHBlock cb = ( BSHBlock ) ( catchBlocks . elementAt ( i ) ) ; NameSpace enclosingNameSpace = callstack . top ( ) ; BlockNameSpace cbNameSpace = new BlockNameSpace ( enclosingNameSpace ) ; cbNameSpace . setInitMode ( true ) ; if ( fp . type == BSHFormalParameter . UNTYPED ) cbNameSpace . setVariable ( fp . name , thrown ) ; else cbNameSpace . setTypedVariable ( fp . name , fp . type , thrown , false ) ; cbNameSpace . setInitMode ( false ) ; callstack . swap ( cbNameSpace ) ; try { ret = cb . eval ( callstack , interpreter ) ; } finally { callstack . swap ( enclosingNameSpace ) ; } target = null ; break ; } } if ( finallyBlock != null ) ret = finallyBlock . eval ( callstack , interpreter ) ; if ( target != null ) throw target ; if ( ret instanceof ReturnControl ) return ret ; else return Primitive . VOID ; } } 	0	['2', '2', '0', '13', '25', '1', '1', '12', '1', '2', '214', '0', '0', '0.947368421', '0.625', '1', '2', '106', '1', '0.5', '0']
